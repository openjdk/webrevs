{"files":[{"patch":"@@ -395,1 +395,1 @@\n-  int mt_index = cp->bsm_attribute_entry(bsms_attribute_index)->argument_index(arg_i);\n+  int mt_index = cp->bsm_attribute_entry(bsms_attribute_index)->argument(arg_i);\n@@ -411,1 +411,1 @@\n-  int mh_index = cp->bsm_attribute_entry(bsms_attribute_index)->argument_index(arg_i);\n+  int mh_index = cp->bsm_attribute_entry(bsms_attribute_index)->argument(arg_i);\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"oops\/bsmAttribute.inline.hpp\"\n@@ -3301,0 +3302,1 @@\n+  const int cp_size = cp->length();\n@@ -3302,1 +3304,1 @@\n-  const u1* const current_start = cfs->current();\n+  const u1* const current_before_parsing = cfs->current();\n@@ -3311,1 +3313,1 @@\n-  const int attribute_array_length = cfs->get_u2_fast();\n+  const int num_bootstrap_methods = cfs->get_u2_fast();\n@@ -3313,1 +3315,1 @@\n-  guarantee_property(_max_bootstrap_specifier_index < attribute_array_length,\n+  guarantee_property(_max_bootstrap_specifier_index < num_bootstrap_methods,\n@@ -3317,0 +3319,1 @@\n+  const u4 bootstrap_methods_u2_len = (attribute_byte_length - sizeof(u2)) \/ sizeof(u2);\n@@ -3318,14 +3321,1 @@\n-  \/\/ The attribute contains a counted array of counted tuples of shorts,\n-  \/\/ represending bootstrap specifiers:\n-  \/\/    length*{bootstrap_method_index, argument_count*{argument_index}}\n-  const unsigned int operand_count = (attribute_byte_length - (unsigned)sizeof(u2)) \/ (unsigned)sizeof(u2);\n-  \/\/ operand_count = number of shorts in attr, except for leading length\n-\n-  \/\/ The attribute is copied into a short[] array.\n-  \/\/ The array begins with a series of short[2] pairs, one for each tuple.\n-  const int index_size = (attribute_array_length * 2);\n-\n-  Array<u2>* const operands =\n-    MetadataFactory::new_array<u2>(_loader_data, index_size + operand_count, CHECK);\n-\n-  \/\/ Eagerly assign operands so they will be deallocated with the constant\n+  \/\/ Eagerly assign the arrays so that they will be deallocated with the constant\n@@ -3333,8 +3323,5 @@\n-  cp->set_operands(operands);\n-\n-  int operand_fill_index = index_size;\n-  const int cp_size = cp->length();\n-\n-  for (int n = 0; n < attribute_array_length; n++) {\n-    \/\/ Store a 32-bit offset into the header of the operand array.\n-    ConstantPool::operand_offset_at_put(operands, n, operand_fill_index);\n+  BSMAttributeEntries::InsertionIterator iter =\n+    cp->bsm_entries().start_extension(num_bootstrap_methods,\n+                                      bootstrap_methods_u2_len,\n+                                      _loader_data,\n+                                      CHECK);\n@@ -3342,1 +3329,1 @@\n-    \/\/ Read a bootstrap specifier.\n+  for (int i = 0; i < num_bootstrap_methods; i++) {\n@@ -3344,2 +3331,2 @@\n-    const u2 bootstrap_method_index = cfs->get_u2_fast();\n-    const u2 argument_count = cfs->get_u2_fast();\n+    u2 bootstrap_method_ref = cfs->get_u2_fast();\n+    u2 num_bootstrap_arguments = cfs->get_u2_fast();\n@@ -3347,15 +3334,13 @@\n-      valid_cp_range(bootstrap_method_index, cp_size) &&\n-      cp->tag_at(bootstrap_method_index).is_method_handle(),\n-      \"bootstrap_method_index %u has bad constant type in class file %s\",\n-      bootstrap_method_index,\n-      CHECK);\n-\n-    guarantee_property((operand_fill_index + 1 + argument_count) < operands->length(),\n-      \"Invalid BootstrapMethods num_bootstrap_methods or num_bootstrap_arguments value in class file %s\",\n-      CHECK);\n-\n-    operands->at_put(operand_fill_index++, bootstrap_method_index);\n-    operands->at_put(operand_fill_index++, argument_count);\n-\n-    cfs->guarantee_more(sizeof(u2) * argument_count, CHECK);  \/\/ argv[argc]\n-    for (int j = 0; j < argument_count; j++) {\n+       valid_cp_range(bootstrap_method_ref, cp_size) &&\n+       cp->tag_at(bootstrap_method_ref).is_method_handle(),\n+       \"bootstrap_method_index %u has bad constant type in class file %s\",\n+       bootstrap_method_ref,\n+       CHECK);\n+    cfs->guarantee_more(sizeof(u2) * num_bootstrap_arguments, CHECK); \/\/ argv[argc]\n+\n+    BSMAttributeEntry* entry = iter.reserve_new_entry(bootstrap_method_ref, num_bootstrap_arguments);\n+    guarantee_property(entry != nullptr,\n+                       \"Invalid BootstrapMethods num_bootstrap_methods.\"\n+                       \" The total amount of space reserved for the BootstrapMethod attribute was not sufficient\", CHECK);\n+\n+    for (int argi = 0; argi < num_bootstrap_arguments; argi++) {\n@@ -3369,1 +3354,1 @@\n-      operands->at_put(operand_fill_index++, argument_index);\n+      entry->set_argument(argi, argument_index);\n@@ -3372,1 +3357,2 @@\n-  guarantee_property(current_start + attribute_byte_length == cfs->current(),\n+  cp->bsm_entries().end_extension(iter, _loader_data, CHECK);\n+  guarantee_property(current_before_parsing + attribute_byte_length == cfs->current(),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":31,"deletions":45,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_BSMATTRIBUTE_HPP\n+#define SHARE_OOPS_BSMATTRIBUTE_HPP\n+\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"oops\/array.hpp\"\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class BSMAttributeEntry {\n+  friend class ConstantPool;\n+  friend class BSMAttributeEntries;\n+\n+  u2 _bootstrap_method_index;\n+  u2 _argument_count;\n+\n+  \/\/ The argument indexes are stored right after the object, in a contiguous array.\n+  \/\/ [ bsmi_0 argc_0 arg_00 arg_01 ... arg_0N bsmi_1 argc_1 arg_10 ... arg_1N ... ]\n+  \/\/ So in order to find the argument array, jump over ourselves.\n+  const u2* argument_indexes() const {\n+    return reinterpret_cast<const u2*>(this + 1);\n+  }\n+  u2* argument_indexes() {\n+    return reinterpret_cast<u2*>(this + 1);\n+  }\n+  \/\/ These are overlays on top of the BSMAttributeEntries data array, do not construct.\n+  BSMAttributeEntry() = delete;\n+  NONCOPYABLE(BSMAttributeEntry);\n+\n+  void copy_args_into(BSMAttributeEntry* entry) const;\n+\n+public:\n+  \/\/ Offsets for SA\n+  enum {\n+    _bsmi_offset = 0,\n+    _argc_offset = 1,\n+    _argv_offset = 2\n+  };\n+\n+  int bootstrap_method_index() const {\n+    return _bootstrap_method_index;\n+  }\n+  int argument_count() const {\n+    return _argument_count;\n+  }\n+  int argument(int n) const {\n+    assert(checked_cast<u2>(n) < _argument_count, \"oob\");\n+    return argument_indexes()[n];\n+  }\n+\n+  void set_argument(int index, u2 value) {\n+    assert(index >= 0 && index < argument_count(), \"invariant\");\n+    argument_indexes()[index] = value;\n+  }\n+\n+  \/\/ How many u2s are required to store a BSM entry with argc arguments?\n+  static int u2s_required (u2 argc) {\n+    return 1 \/* index *\/ + 1  \/* argc *\/ + argc \/* argv *\/;\n+  }\n+};\n+\n+\/\/ The BSMAttributeEntries stores the state of the BootstrapMethods attribute.\n+class BSMAttributeEntries {\n+  friend class VMStructs;\n+  friend class JVMCIVMStructs;\n+\n+public:\n+  class InsertionIterator {\n+    friend BSMAttributeEntries;\n+    BSMAttributeEntries* insert_into;\n+    \/\/ Current unused offset into BSMAEs offset array.\n+    int _cur_offset;\n+    \/\/ Current unused offset into BSMAEs bsm-data array.\n+    int _cur_array;\n+  public:\n+    InsertionIterator() : insert_into(nullptr), _cur_offset(-1), _cur_array(-1) {}\n+    InsertionIterator(BSMAttributeEntries* insert_into, int cur_offset, int cur_array)\n+    : insert_into(insert_into),\n+      _cur_offset(cur_offset),\n+      _cur_array(cur_array) {\n+      assert(insert_into->offsets() != nullptr, \"must\");\n+      assert(insert_into->bootstrap_methods() != nullptr, \"must\");\n+    }\n+    InsertionIterator(const InsertionIterator&) = default;\n+    InsertionIterator& operator=(const InsertionIterator&) = default;\n+\n+    int current_offset() const { return _cur_offset; }\n+    \/\/ Add a new BSMAE, reserving the necessary memory for filling the argument vector.\n+    \/\/ Returns null if there isn't enough space.\n+    inline BSMAttributeEntry* reserve_new_entry(u2 bsmi, u2 argc);\n+  };\n+\n+private:\n+  \/\/ Each bootstrap method has a variable-sized array associated with it.\n+  \/\/ We want constant-time lookup of the Nth BSM. Therefore, we use an offset table,\n+  \/\/ such that the Nth BSM is located at _bootstrap_methods[_offsets[N]].\n+  Array<u4>* _offsets;\n+  Array<u2>* _bootstrap_methods;\n+\n+  \/\/ Copy the first num_entries into iter.\n+  void copy_into(InsertionIterator& iter, int num_entries) const;\n+\n+public:\n+  BSMAttributeEntries() : _offsets(nullptr), _bootstrap_methods(nullptr) {}\n+  BSMAttributeEntries(Array<u4>* offsets, Array<u2>* bootstrap_methods)\n+    : _offsets(offsets),\n+      _bootstrap_methods(bootstrap_methods) {}\n+\n+  bool is_empty() const {\n+    return _offsets == nullptr && _bootstrap_methods == nullptr;\n+  }\n+\n+  Array<u4>*& offsets() { return _offsets; }\n+  const Array<u4>* const& offsets() const { return _offsets; }\n+  Array<u2>*& bootstrap_methods() { return _bootstrap_methods; }\n+  const Array<u2>* const& bootstrap_methods() const { return _bootstrap_methods; }\n+\n+  BSMAttributeEntry* entry(int bsms_attribute_index) {\n+    return reinterpret_cast<BSMAttributeEntry*>(_bootstrap_methods->adr_at(_offsets->at(bsms_attribute_index)));\n+  }\n+  const BSMAttributeEntry* entry(int bsms_attribute_index) const {\n+    return reinterpret_cast<BSMAttributeEntry*>(_bootstrap_methods->adr_at(_offsets->at(bsms_attribute_index)));\n+  }\n+\n+  int number_of_entries() const {\n+    return _offsets == nullptr ? 0 : _offsets->length();\n+  }\n+\n+  \/\/ The number of U2s the BSM data consists of.\n+  int array_length() const {\n+    return _bootstrap_methods == nullptr ? 0 :  _bootstrap_methods->length();\n+  }\n+\n+  void deallocate_contents(ClassLoaderData* loader_data);\n+\n+  \/\/ Extend to have the space for both this BSMAEntries and other's.\n+  \/\/ Does not copy in the other's BSMAEntrys, that must be done via the InsertionIterator.\n+  \/\/ This starts an insertion iterator. Any call to start_extension must have a matching end_extension call.\n+  InsertionIterator start_extension(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS);\n+  \/\/ Extend the BSMAEntries with an additional number_of_entries with a total data_size.\n+  InsertionIterator start_extension(int number_of_entries, int data_size, ClassLoaderData* loader_data, TRAPS);\n+  \/\/ Reallocates the underlying memory to fit the limits of the InsertionIterator precisely.\n+  \/\/ This ends an insertion iteration. The memory is truncated to fit exactly the data used.\n+  void end_extension(InsertionIterator& iter, ClassLoaderData* loader_data, TRAPS);\n+  \/\/ Append all of the BSMAEs in other into this.\n+  void append(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS);\n+};\n+\n+#endif \/\/ SHARE_OOPS_BSMATTRIBUTE_HPP\n","filename":"src\/hotspot\/share\/oops\/bsmAttribute.hpp","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_BSMATTRIBUTE_INLINE_HPP\n+#define SHARE_OOPS_BSMATTRIBUTE_INLINE_HPP\n+\n+#include \"oops\/bsmAttribute.hpp\"\n+\n+inline BSMAttributeEntry* BSMAttributeEntries::InsertionIterator::reserve_new_entry(u2 bsmi, u2 argc) {\n+  if (_cur_offset + 1 > insert_into->offsets()->length() ||\n+      _cur_array + BSMAttributeEntry::u2s_required(argc) > insert_into->bootstrap_methods()->length()) {\n+    return nullptr;\n+  }\n+  insert_into->offsets()->at_put(_cur_offset, _cur_array);\n+  BSMAttributeEntry* e = insert_into->entry(_cur_offset);\n+  e->_bootstrap_method_index = bsmi;\n+  e->_argument_count = argc;\n+\n+  _cur_array += 1 + 1 + argc;\n+  _cur_offset += 1;\n+  return e;\n+}\n+\n+inline void BSMAttributeEntry::copy_args_into(BSMAttributeEntry* entry) const {\n+  assert(entry->argument_count() == this->argument_count(), \"must be same\");\n+  for (int i = 0; i < argument_count(); i++) {\n+    entry->set_argument(i, this->argument(i));\n+  }\n+}\n+\n+#endif \/\/ SHARE_OOPS_BSMATTRIBUTE_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/bsmAttribute.inline.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -136,2 +136,1 @@\n-  MetadataFactory::free_array<jushort>(loader_data, operands());\n-  set_operands(nullptr);\n+  _bsmaentries.deallocate_contents(loader_data);\n@@ -157,1 +156,2 @@\n-  it->push(&_operands);\n+  it->push(&bsm_entries().offsets());\n+  it->push(&bsm_entries().bootstrap_methods());\n@@ -761,1 +761,1 @@\n-    log_debug(class, resolve)(\"bad operand %d in:\", which); cpool->print();\n+    log_debug(class, resolve)(\"bad BSM %d in:\", which); cpool->print();\n@@ -1562,2 +1562,2 @@\n-    bool match_operand = compare_operand_to(i1, cp2, i2);\n-    return (match_entry && match_operand);\n+    bool match_bsm = compare_bootstrap_entry_to(i1, cp2, i2);\n+    return (match_entry && match_bsm);\n@@ -1573,2 +1573,2 @@\n-    bool match_operand = compare_operand_to(i1, cp2, i2);\n-    return (match_entry && match_operand);\n+    bool match_bsm = compare_bootstrap_entry_to(i1, cp2, i2);\n+    return (match_entry && match_bsm);\n@@ -1608,34 +1608,1 @@\n-\n-\/\/ Resize the operands array with delta_len and delta_size.\n-\/\/ Used in RedefineClasses for CP merge.\n-void ConstantPool::resize_operands(int delta_len, int delta_size, TRAPS) {\n-  int old_len  = operand_array_length(operands());\n-  int new_len  = old_len + delta_len;\n-  int min_len  = (delta_len > 0) ? old_len : new_len;\n-\n-  int old_size = operands()->length();\n-  int new_size = old_size + delta_size;\n-  int min_size = (delta_size > 0) ? old_size : new_size;\n-\n-  ClassLoaderData* loader_data = pool_holder()->class_loader_data();\n-  Array<u2>* new_ops = MetadataFactory::new_array<u2>(loader_data, new_size, CHECK);\n-\n-  \/\/ Set index in the resized array for existing elements only\n-  for (int idx = 0; idx < min_len; idx++) {\n-    int offset = operand_offset_at(idx);                       \/\/ offset in original array\n-    operand_offset_at_put(new_ops, idx, offset + 2*delta_len); \/\/ offset in resized array\n-  }\n-  \/\/ Copy the bootstrap specifiers only\n-  Copy::conjoint_memory_atomic(operands()->adr_at(2*old_len),\n-                               new_ops->adr_at(2*new_len),\n-                               (min_size - 2*min_len) * sizeof(u2));\n-  \/\/ Explicitly deallocate old operands array.\n-  \/\/ Note, it is not needed for 7u backport.\n-  if ( operands() != nullptr) { \/\/ the safety check\n-    MetadataFactory::free_array<u2>(loader_data, operands());\n-  }\n-  set_operands(new_ops);\n-} \/\/ end resize_operands()\n-\n-\n-\/\/ Extend the operands array with the length and size of the ext_cp operands.\n+\/\/ Extend the BSMAttributeEntries with the length and size of the ext_cp BSMAttributeEntries.\n@@ -1643,18 +1610,7 @@\n-void ConstantPool::extend_operands(const constantPoolHandle& ext_cp, TRAPS) {\n-  int delta_len = operand_array_length(ext_cp->operands());\n-  if (delta_len == 0) {\n-    return; \/\/ nothing to do\n-  }\n-  int delta_size = ext_cp->operands()->length();\n-\n-  assert(delta_len  > 0 && delta_size > 0, \"extended operands array must be bigger\");\n-\n-  if (operand_array_length(operands()) == 0) {\n-    ClassLoaderData* loader_data = pool_holder()->class_loader_data();\n-    Array<u2>* new_ops = MetadataFactory::new_array<u2>(loader_data, delta_size, CHECK);\n-    \/\/ The first element index defines the offset of second part\n-    operand_offset_at_put(new_ops, 0, 2*delta_len); \/\/ offset in new array\n-    set_operands(new_ops);\n-  } else {\n-    resize_operands(delta_len, delta_size, CHECK);\n-  }\n+BSMAttributeEntries::InsertionIterator\n+ConstantPool::start_extension(const constantPoolHandle& ext_cp, TRAPS) {\n+  BSMAttributeEntries::InsertionIterator iter =\n+    bsm_entries().start_extension(ext_cp->bsm_entries(), pool_holder()->class_loader_data(),\n+                                  CHECK_(BSMAttributeEntries::InsertionIterator()));\n+  return iter;\n+}\n@@ -1662,1 +1618,0 @@\n-} \/\/ end extend_operands()\n@@ -1664,0 +1619,3 @@\n+void ConstantPool::end_extension(BSMAttributeEntries::InsertionIterator iter, TRAPS) {\n+  bsm_entries().end_extension(iter, pool_holder()->class_loader_data(), THREAD);\n+}\n@@ -1665,71 +1623,0 @@\n-\/\/ Shrink the operands array to a smaller array with new_len length.\n-\/\/ Used in RedefineClasses for CP merge.\n-void ConstantPool::shrink_operands(int new_len, TRAPS) {\n-  int old_len = operand_array_length(operands());\n-  if (new_len == old_len) {\n-    return; \/\/ nothing to do\n-  }\n-  assert(new_len < old_len, \"shrunken operands array must be smaller\");\n-\n-  int free_base  = operand_next_offset_at(new_len - 1);\n-  int delta_len  = new_len - old_len;\n-  int delta_size = 2*delta_len + free_base - operands()->length();\n-\n-  resize_operands(delta_len, delta_size, CHECK);\n-\n-} \/\/ end shrink_operands()\n-\n-\n-void ConstantPool::copy_operands(const constantPoolHandle& from_cp,\n-                                 const constantPoolHandle& to_cp,\n-                                 TRAPS) {\n-\n-  int from_oplen = operand_array_length(from_cp->operands());\n-  int old_oplen  = operand_array_length(to_cp->operands());\n-  if (from_oplen != 0) {\n-    ClassLoaderData* loader_data = to_cp->pool_holder()->class_loader_data();\n-    \/\/ append my operands to the target's operands array\n-    if (old_oplen == 0) {\n-      \/\/ Can't just reuse from_cp's operand list because of deallocation issues\n-      int len = from_cp->operands()->length();\n-      Array<u2>* new_ops = MetadataFactory::new_array<u2>(loader_data, len, CHECK);\n-      Copy::conjoint_memory_atomic(\n-          from_cp->operands()->adr_at(0), new_ops->adr_at(0), len * sizeof(u2));\n-      to_cp->set_operands(new_ops);\n-    } else {\n-      int old_len  = to_cp->operands()->length();\n-      int from_len = from_cp->operands()->length();\n-      int old_off  = old_oplen * sizeof(u2);\n-      int from_off = from_oplen * sizeof(u2);\n-      \/\/ Use the metaspace for the destination constant pool\n-      Array<u2>* new_operands = MetadataFactory::new_array<u2>(loader_data, old_len + from_len, CHECK);\n-      int fillp = 0, len = 0;\n-      \/\/ first part of dest\n-      Copy::conjoint_memory_atomic(to_cp->operands()->adr_at(0),\n-                                   new_operands->adr_at(fillp),\n-                                   (len = old_off) * sizeof(u2));\n-      fillp += len;\n-      \/\/ first part of src\n-      Copy::conjoint_memory_atomic(from_cp->operands()->adr_at(0),\n-                                   new_operands->adr_at(fillp),\n-                                   (len = from_off) * sizeof(u2));\n-      fillp += len;\n-      \/\/ second part of dest\n-      Copy::conjoint_memory_atomic(to_cp->operands()->adr_at(old_off),\n-                                   new_operands->adr_at(fillp),\n-                                   (len = old_len - old_off) * sizeof(u2));\n-      fillp += len;\n-      \/\/ second part of src\n-      Copy::conjoint_memory_atomic(from_cp->operands()->adr_at(from_off),\n-                                   new_operands->adr_at(fillp),\n-                                   (len = from_len - from_off) * sizeof(u2));\n-      fillp += len;\n-      assert(fillp == new_operands->length(), \"\");\n-\n-      \/\/ Adjust indexes in the first part of the copied operands array.\n-      for (int j = 0; j < from_oplen; j++) {\n-        int offset = operand_offset_at(new_operands, old_oplen + j);\n-        assert(offset == operand_offset_at(from_cp->operands(), j), \"correct copy\");\n-        offset += old_len;  \/\/ every new tuple is preceded by old_len extra u2's\n-        operand_offset_at_put(new_operands, old_oplen + j, offset);\n-      }\n@@ -1737,5 +1624,7 @@\n-      \/\/ replace target operands array with combined array\n-      to_cp->set_operands(new_operands);\n-    }\n-  }\n-} \/\/ end copy_operands()\n+void ConstantPool::copy_bsm_entries(const constantPoolHandle& from_cp,\n+                                    const constantPoolHandle& to_cp,\n+                                    TRAPS) {\n+  to_cp->bsm_entries().append(from_cp->bsm_entries(),\n+                              to_cp->pool_holder()->class_loader_data(),\n+                              THREAD);\n+}\n@@ -1771,1 +1660,1 @@\n-  copy_operands(from_cp, to_cp, CHECK);\n+  copy_bsm_entries(from_cp, to_cp, THREAD);\n@@ -1895,1 +1784,1 @@\n-    k1 += operand_array_length(to_cp->operands());  \/\/ to_cp might already have operands\n+    k1 += to_cp->bsm_entries().array_length();  \/\/ to_cp might already have a BSM attribute\n@@ -1903,1 +1792,1 @@\n-    k1 += operand_array_length(to_cp->operands());  \/\/ to_cp might already have operands\n+    k1 += to_cp->bsm_entries().array_length();  \/\/ to_cp might already have a BSM attribute\n@@ -1939,3 +1828,3 @@\n-bool ConstantPool::compare_operand_to(int idx1, const constantPoolHandle& cp2, int idx2) {\n-  BSMAttributeEntry* e1 = bsm_attribute_entry(idx1);\n-  BSMAttributeEntry* e2 = cp2->bsm_attribute_entry(idx2);\n+bool ConstantPool::compare_bootstrap_entry_to(int idx1, const constantPoolHandle& cp2, int idx2) {\n+  const BSMAttributeEntry* const e1 = bsm_attribute_entry(idx1);\n+  const BSMAttributeEntry* const e2 = cp2->bsm_attribute_entry(idx2);\n@@ -1949,9 +1838,12 @@\n-  int argc = e1->argument_count();\n-  if (argc == e2->argument_count()) {\n-    for (int j = 0; j < argc; j++) {\n-      k1 = e1->argument_index(j);\n-      k2 = e2->argument_index(j);\n-      match = compare_entry_to(k1, cp2, k2);\n-      if (!match) {\n-        return false;\n-      }\n+\n+  const int argc = e1->argument_count();\n+  if (argc != e2->argument_count()) {\n+    return false;\n+  }\n+\n+  for (int j = 0; j < argc; j++) {\n+    k1 = e1->argument(j);\n+    k2 = e2->argument(j);\n+    match = compare_entry_to(k1, cp2, k2);\n+    if (!match) {\n+      return false;\n@@ -1959,1 +1851,0 @@\n-    return true;           \/\/ got through loop; all elements equal\n@@ -1961,2 +1852,3 @@\n-  return false;\n-} \/\/ end compare_operand_to()\n+\n+  return true; \/\/ got through loop; all elements equal\n+} \/\/ end compare_bootstrap_entry_to()\n@@ -1967,4 +1859,4 @@\n-int ConstantPool::find_matching_operand(int pattern_i,\n-                    const constantPoolHandle& search_cp, int search_len) {\n-  for (int i = 0; i < search_len; i++) {\n-    bool found = compare_operand_to(pattern_i, search_cp, i);\n+int ConstantPool::find_matching_bsm_entry(int pattern_i,\n+                                          const constantPoolHandle& search_cp, int offset_limit) {\n+  for (int i = 0; i < offset_limit; i++) {\n+    bool found = compare_bootstrap_entry_to(pattern_i, search_cp, i);\n@@ -1976,1 +1868,1 @@\n-} \/\/ end find_matching_operand()\n+} \/\/ end find_matching_bsm_entry()\n@@ -2411,1 +2303,1 @@\n-  if (operands() != nullptr)  st->print(\"\/operands[%d]\", operands()->length());\n+  if (!bsm_entries().is_empty())  st->print(\"\/BSMs[%d]\", bsm_entries().bootstrap_methods()->length());\n@@ -2446,0 +2338,84 @@\n+\n+void BSMAttributeEntries::deallocate_contents(ClassLoaderData* loader_data) {\n+  MetadataFactory::free_array<u4>(loader_data, this->_offsets);\n+  MetadataFactory::free_array<u2>(loader_data, this->_bootstrap_methods);\n+  this->_offsets = nullptr;\n+  this->_bootstrap_methods = nullptr;\n+}\n+\n+void BSMAttributeEntries::copy_into(InsertionIterator& iter, int num_entries) const {\n+  assert(num_entries + iter._cur_offset <= iter.insert_into->_offsets->length(), \"must\");\n+  for (int i = 0; i < num_entries; i++) {\n+    const BSMAttributeEntry* e = entry(i);\n+    BSMAttributeEntry* e_new = iter.reserve_new_entry(e->bootstrap_method_index(), e->argument_count());\n+    assert(e_new != nullptr, \"must be\");\n+    e->copy_args_into(e_new);\n+  }\n+}\n+\n+BSMAttributeEntries::InsertionIterator\n+BSMAttributeEntries::start_extension(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS) {\n+  InsertionIterator iter = start_extension(other.number_of_entries(), other.array_length(),\n+                                           loader_data, CHECK_(BSMAttributeEntries::InsertionIterator()));\n+  return iter;\n+}\n+\n+BSMAttributeEntries::InsertionIterator\n+BSMAttributeEntries::start_extension(int number_of_entries, int array_length,\n+                                     ClassLoaderData* loader_data, TRAPS) {\n+  InsertionIterator extension_iterator(this, this->number_of_entries(), this->array_length());\n+  int new_number_of_entries = this->number_of_entries() + number_of_entries;\n+  int new_array_length = this->array_length() + array_length;\n+  int invalid_index = new_array_length;\n+\n+  Array<u4>* new_offsets =\n+    MetadataFactory::new_array<u4>(loader_data, new_number_of_entries, invalid_index, CHECK_(InsertionIterator()));\n+  Array<u2>* new_array = MetadataFactory::new_array<u2>(loader_data, new_array_length, CHECK_(InsertionIterator()));\n+  { \/\/ Copy over all the old BSMAEntry's and their respective offsets\n+    BSMAttributeEntries carrier(new_offsets, new_array);\n+    InsertionIterator copy_iter(&carrier, 0, 0);\n+    copy_into(copy_iter, this->number_of_entries());\n+  }\n+  \/\/ Replace content\n+  deallocate_contents(loader_data);\n+  _offsets = new_offsets;\n+  _bootstrap_methods = new_array;\n+  return extension_iterator;\n+}\n+\n+\n+void BSMAttributeEntries::append(const BSMAttributeEntries& other, ClassLoaderData* loader_data, TRAPS) {\n+  if (other.number_of_entries() == 0) {\n+    return; \/\/ Done!\n+  }\n+  InsertionIterator iter = start_extension(other, loader_data, CHECK);\n+  other.copy_into(iter, other.number_of_entries());\n+  end_extension(iter, loader_data, THREAD);\n+}\n+\n+void BSMAttributeEntries::end_extension(InsertionIterator& iter, ClassLoaderData* loader_data, TRAPS) {\n+  assert(iter.insert_into == this, \"must be\");\n+  assert(iter._cur_offset <= this->_offsets->length(), \"must be\");\n+  assert(iter._cur_array <= this->_bootstrap_methods->length(), \"must be\");\n+\n+  \/\/ Did we fill up all of the available space? If so, do nothing.\n+  if (iter._cur_offset == this->_offsets->length() &&\n+      iter._cur_array == this->_bootstrap_methods->length()) {\n+    return;\n+  }\n+\n+  \/\/ We used less, truncate by allocating new arrays\n+  Array<u4>* new_offsets =\n+      MetadataFactory::new_array<u4>(loader_data, iter._cur_offset, 0, CHECK);\n+  Array<u2>* new_array =\n+    MetadataFactory::new_array<u2>(loader_data, iter._cur_array, CHECK);\n+  { \/\/ Copy over the constructed BSMAEntry's\n+    BSMAttributeEntries carrier(new_offsets, new_array);\n+    InsertionIterator copy_iter(&carrier, 0, 0);\n+    copy_into(copy_iter, iter._cur_offset);\n+  }\n+\n+  deallocate_contents(loader_data);\n+  _offsets = new_offsets;\n+  _bootstrap_methods = new_array;\n+}\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":137,"deletions":161,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/bsmAttribute.inline.hpp\"\n@@ -80,37 +81,0 @@\n-class BSMAttributeEntry {\n-  friend class ConstantPool;\n-  u2 _bootstrap_method_index;\n-  u2 _argument_count;\n-\n-  \/\/ The argument indexes are stored right after the object, in a contiguous array.\n-  \/\/ [ bsmi_0 argc_0 arg_00 arg_01 ... arg_0N bsmi_1 argc_1 arg_10 ... arg_1N ... ]\n-  \/\/ So in order to find the argument array, jump over ourselves.\n-  const u2* argument_indexes() const {\n-    return reinterpret_cast<const u2*>(this + 1);\n-  }\n-  u2* argument_indexes() {\n-    return reinterpret_cast<u2*>(this + 1);\n-  }\n-  \/\/ These are overlays on top of the operands array. Do not construct.\n-  BSMAttributeEntry() = delete;\n-\n-public:\n-  \/\/ Offsets for SA\n-  enum {\n-    _bsmi_offset = 0,\n-    _argc_offset = 1,\n-    _argv_offset = 2\n-  };\n-\n-  int bootstrap_method_index() const {\n-    return _bootstrap_method_index;\n-  }\n-  int argument_count() const {\n-    return _argument_count;\n-  }\n-  int argument_index(int n) const {\n-    assert(checked_cast<u2>(n) < _argument_count, \"oob\");\n-    return argument_indexes()[n];\n-  }\n-};\n-\n@@ -129,1 +93,2 @@\n-  Array<u2>*           _operands;    \/\/ for variable-sized (InvokeDynamic) nodes, usually empty\n+\n+  BSMAttributeEntries _bsmaentries;\n@@ -170,2 +135,0 @@\n-  void set_operands(Array<u2>* operands)       { _operands = operands; }\n-\n@@ -211,1 +174,7 @@\n-  Array<u2>* operands() const               { return _operands; }\n+\n+  BSMAttributeEntries& bsm_entries() {\n+    return _bsmaentries;\n+  }\n+  const BSMAttributeEntries& bsm_entries() const {\n+    return _bsmaentries;\n+  }\n@@ -559,46 +528,0 @@\n-  \/\/ The first part of the operands array consists of an index into the second part.\n-  \/\/ Extract a 32-bit index value from the first part.\n-  static int operand_offset_at(Array<u2>* operands, int bsms_attribute_index) {\n-    int n = (bsms_attribute_index * 2);\n-    assert(n >= 0 && n+2 <= operands->length(), \"oob\");\n-    \/\/ The first 32-bit index points to the beginning of the second part\n-    \/\/ of the operands array.  Make sure this index is in the first part.\n-    DEBUG_ONLY(int second_part = build_int_from_shorts(operands->at(0),\n-                                                       operands->at(1)));\n-    assert(second_part == 0 || n+2 <= second_part, \"oob (2)\");\n-    int offset = build_int_from_shorts(operands->at(n+0),\n-                                       operands->at(n+1));\n-    \/\/ The offset itself must point into the second part of the array.\n-    assert(offset == 0 || (offset >= second_part && offset <= operands->length()), \"oob (3)\");\n-    return offset;\n-  }\n-  static void operand_offset_at_put(Array<u2>* operands, int bsms_attribute_index, int offset) {\n-    int n = bsms_attribute_index * 2;\n-    assert(n >= 0 && n+2 <= operands->length(), \"oob\");\n-    operands->at_put(n+0, extract_low_short_from_int(offset));\n-    operands->at_put(n+1, extract_high_short_from_int(offset));\n-  }\n-  static int operand_array_length(Array<u2>* operands) {\n-    if (operands == nullptr || operands->length() == 0)  return 0;\n-    int second_part = operand_offset_at(operands, 0);\n-    return (second_part \/ 2);\n-  }\n-\n-#ifdef ASSERT\n-  \/\/ operand tuples fit together exactly, end to end\n-  static int operand_limit_at(Array<u2>* operands, int bsms_attribute_index) {\n-    int nextidx = bsms_attribute_index + 1;\n-    if (nextidx == operand_array_length(operands))\n-      return operands->length();\n-    else\n-      return operand_offset_at(operands, nextidx);\n-  }\n-#endif \/\/ASSERT\n-\n-  \/\/ These functions are used in RedefineClasses for CP merge\n-  int operand_offset_at(int bsms_attribute_index) {\n-    assert(0 <= bsms_attribute_index &&\n-           bsms_attribute_index < operand_array_length(operands()),\n-           \"Corrupted CP operands\");\n-    return operand_offset_at(operands(), bsms_attribute_index);\n-  }\n@@ -607,22 +530,13 @@\n-    int offset = operand_offset_at(bsms_attribute_index);\n-    return reinterpret_cast<BSMAttributeEntry*>(operands()->adr_at(offset));\n-  }\n-\n-  int operand_next_offset_at(int bsms_attribute_index) {\n-    BSMAttributeEntry* bsme = bsm_attribute_entry(bsms_attribute_index);\n-    u2* argv_start = bsme->argument_indexes();\n-    int offset = argv_start - operands()->data();\n-    return offset + bsme->argument_count();\n-  }\n-  \/\/ Compare a bootstrap specifier data in the operands arrays\n-  bool compare_operand_to(int bsms_attribute_index1, const constantPoolHandle& cp2,\n-                          int bsms_attribute_index2);\n-  \/\/ Find a bootstrap specifier data in the operands array\n-  int find_matching_operand(int bsms_attribute_index, const constantPoolHandle& search_cp,\n-                            int operands_cur_len);\n-  \/\/ Resize the operands array with delta_len and delta_size\n-  void resize_operands(int delta_len, int delta_size, TRAPS);\n-  \/\/ Extend the operands array with the length and size of the ext_cp operands\n-  void extend_operands(const constantPoolHandle& ext_cp, TRAPS);\n-  \/\/ Shrink the operands array to a smaller array with new_len length\n-  void shrink_operands(int new_len, TRAPS);\n+    return _bsmaentries.entry(bsms_attribute_index);\n+  }\n+\n+  bool compare_bootstrap_entry_to(int bsms_attribute_index1, const constantPoolHandle& cp2,\n+                                  int bsms_attribute_index2);\n+  \/\/ Find a BSM entry in search_cp that matches the BSM at bsm_attribute_index.\n+  \/\/ Return -1 if not found.\n+  int find_matching_bsm_entry(int bsms_attribute_index, const constantPoolHandle& search_cp,\n+                              int offset_limit);\n+  \/\/ Extend the BSM attribute storage to fit both the current data and the BSM data in ext_cp.\n+  \/\/ Use the returned InsertionIterator to fill out the newly allocated space.\n+  BSMAttributeEntries::InsertionIterator start_extension(const constantPoolHandle& ext_cp, TRAPS);\n+  void end_extension(BSMAttributeEntries::InsertionIterator iter, TRAPS);\n@@ -644,1 +558,1 @@\n-    return bsm_attribute_entry(bsmai)->argument_index(j);\n+    return bsm_attribute_entry(bsmai)->argument(j);\n@@ -851,1 +765,1 @@\n-  static void copy_operands(const constantPoolHandle& from_cp, const constantPoolHandle& to_cp, TRAPS);\n+  static void copy_bsm_entries(const constantPoolHandle& from_cp, const constantPoolHandle& to_cp, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":25,"deletions":111,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"oops\/bsmAttribute.inline.hpp\"\n@@ -392,1 +393,0 @@\n-  Array<u2>* operands = cpool()->operands();\n@@ -394,10 +394,3 @@\n-  int num_bootstrap_methods = ConstantPool::operand_array_length(operands);\n-\n-  \/\/ calculate length of attribute\n-  u4 length = sizeof(u2); \/\/ num_bootstrap_methods\n-  for (int n = 0; n < num_bootstrap_methods; n++) {\n-    u2 num_bootstrap_arguments = cpool()->bsm_attribute_entry(n)->argument_count();\n-    length += sizeof(u2); \/\/ bootstrap_method_ref\n-    length += sizeof(u2); \/\/ num_bootstrap_arguments\n-    length += (u4)sizeof(u2) * num_bootstrap_arguments; \/\/ bootstrap_arguments[num_bootstrap_arguments]\n-  }\n+  u4 length = sizeof(u2) + \/\/ Size of num_bootstrap_methods\n+              \/\/ The rest of the data for the attribute is exactly the u2s in the data array.\n+              sizeof(u2) * cpool()->bsm_entries().array_length();\n@@ -406,0 +399,1 @@\n+  int num_bootstrap_methods = cpool()->bsm_entries().number_of_entries();\n@@ -414,1 +408,1 @@\n-      u2 bootstrap_argument = bsme->argument_index(arg);\n+      u2 bootstrap_argument = bsme->argument(arg);\n@@ -801,1 +795,1 @@\n-  if (cpool()->operands() != nullptr) {\n+  if (!cpool()->bsm_entries().is_empty()) {\n@@ -846,1 +840,1 @@\n-  if (cpool()->operands() != nullptr) {\n+  if (!cpool()->bsm_entries().is_empty()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -48,1 +48,2 @@\n-#include \"oops\/constantPool.hpp\"\n+#include \"oops\/bsmAttribute.inline.hpp\"\n+#include \"oops\/constantPool.inline.hpp\"\n@@ -576,1 +577,1 @@\n-      \/\/ Index of the bootstrap specifier in the operands array\n+      \/\/ Index of the bootstrap specifier in the BSM array\n@@ -578,1 +579,1 @@\n-      int new_bs_i = find_or_append_operand(scratch_cp, old_bs_i, merge_cp_p,\n+      int new_bs_i = find_or_append_bsm_entry(scratch_cp, old_bs_i, merge_cp_p,\n@@ -594,1 +595,1 @@\n-      if (scratch_cp->tag_at(scratch_i).is_dynamic_constant())\n+      if (scratch_cp->tag_at(scratch_i).is_dynamic_constant()) {\n@@ -596,1 +597,1 @@\n-      else\n+      } else {\n@@ -598,0 +599,1 @@\n+      }\n@@ -663,2 +665,2 @@\n-\/\/ Append a bootstrap specifier into the merge_cp operands that is semantically equal\n-\/\/ to the scratch_cp operands bootstrap specifier passed by the old_bs_i index.\n+\/\/ Append a bootstrap specifier into the merge_cp BSM entries that is semantically equal\n+\/\/ to the scratch_cp BSM entries' bootstrap specifier passed by the old_bs_i index.\n@@ -666,1 +668,1 @@\n-void VM_RedefineClasses::append_operand(const constantPoolHandle& scratch_cp, const int old_bs_i,\n+int VM_RedefineClasses::append_bsm_entry(const constantPoolHandle& scratch_cp, const int old_bs_i,\n@@ -675,1 +677,1 @@\n-      (\"operands entry@%d bootstrap method ref_index change: %d to %d\", _operands_cur_length, old_ref_i, new_ref_i);\n+      (\"BSM attribute entry@%d bootstrap method ref_index change: %d to %d\", _bsmae_iter.current_offset() - 1, old_ref_i, new_ref_i);\n@@ -678,14 +680,6 @@\n-  Array<u2>* merge_ops = (*merge_cp_p)->operands();\n-  int new_bs_i = _operands_cur_length;\n-  \/\/ We have _operands_cur_length == 0 when the merge_cp operands is empty yet.\n-  \/\/ However, the operand_offset_at(0) was set in the extend_operands() call.\n-  int new_base = (new_bs_i == 0) ? (*merge_cp_p)->operand_offset_at(0)\n-                                 : (*merge_cp_p)->operand_next_offset_at(new_bs_i - 1);\n-  u2 argc      = old_bsme->argument_count();\n-\n-  ConstantPool::operand_offset_at_put(merge_ops, _operands_cur_length, new_base);\n-  merge_ops->at_put(new_base++, new_ref_i);\n-  merge_ops->at_put(new_base++, argc);\n-\n-  for (int i = 0; i < argc; i++) {\n-    u2 old_arg_ref_i = old_bsme->argument_index(i);\n+  const int new_bs_i = _bsmae_iter.current_offset();\n+  BSMAttributeEntry* new_bsme =\n+    _bsmae_iter.reserve_new_entry(new_ref_i, old_bsme->argument_count());\n+  assert(new_bsme != nullptr, \"must be\");\n+  for (int i = 0; i < new_bsme->argument_count(); i++) {\n+    u2 old_arg_ref_i = old_bsme->argument(i);\n@@ -694,1 +688,2 @@\n-    merge_ops->at_put(new_base++, new_arg_ref_i);\n+    new_bsme->set_argument(i, new_arg_ref_i);\n+\n@@ -697,2 +692,2 @@\n-        (\"operands entry@%d bootstrap method argument ref_index change: %d to %d\",\n-         _operands_cur_length, old_arg_ref_i, new_arg_ref_i);\n+        (\"BSM attribute entry@%d bootstrap method argument ref_index change: %d to %d\",\n+         _bsmae_iter.current_offset() - 1, old_arg_ref_i, new_arg_ref_i);\n@@ -701,7 +696,4 @@\n-  if (old_bs_i != _operands_cur_length) {\n-    \/\/ The bootstrap specifier in *merge_cp_p is at a different index than\n-    \/\/ that in scratch_cp so we need to map the index values.\n-    map_operand_index(old_bs_i, new_bs_i);\n-  }\n-  _operands_cur_length++;\n-} \/\/ end append_operand()\n+  \/\/ This is only for the logging\n+  map_bsm_index(old_bs_i, new_bs_i);\n+  return new_bs_i;\n+} \/\/ end append_bsm_entry()\n@@ -710,1 +702,1 @@\n-int VM_RedefineClasses::find_or_append_operand(const constantPoolHandle& scratch_cp,\n+int VM_RedefineClasses::find_or_append_bsm_entry(const constantPoolHandle& scratch_cp,\n@@ -713,0 +705,1 @@\n+  const int max_offset_in_merge = _bsmae_iter.current_offset();\n@@ -714,2 +707,4 @@\n-  bool match = (old_bs_i < _operands_cur_length) &&\n-               scratch_cp->compare_operand_to(old_bs_i, *merge_cp_p, old_bs_i);\n+  \/\/ Has the old_bs_i index been used already? Check if it's the same so we know\n+  \/\/ whether or not a remapping is required.\n+  bool match = (old_bs_i < max_offset_in_merge) &&\n+               scratch_cp->compare_bootstrap_entry_to(old_bs_i, *merge_cp_p, old_bs_i);\n@@ -719,2 +714,2 @@\n-    int found_i = scratch_cp->find_matching_operand(old_bs_i, *merge_cp_p,\n-                                                    _operands_cur_length);\n+    int found_i = scratch_cp->find_matching_bsm_entry(old_bs_i, *merge_cp_p,\n+                                                      max_offset_in_merge);\n@@ -722,2 +717,2 @@\n-      guarantee(found_i != old_bs_i, \"compare_operand_to() and find_matching_operand() disagree\");\n-      \/\/ found a matching operand somewhere else in *merge_cp_p so just need a mapping\n+      guarantee(found_i != old_bs_i, \"compare_bootstrap_entry_to() and find_matching_bsm_entry() disagree\");\n+      \/\/ found a matching BSM entry somewhere else in *merge_cp_p so just need a mapping\n@@ -725,1 +720,1 @@\n-      map_operand_index(old_bs_i, found_i);\n+      map_bsm_index(old_bs_i, found_i);\n@@ -728,2 +723,1 @@\n-      append_operand(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p);\n-      new_bs_i = _operands_cur_length - 1;\n+      new_bs_i = append_bsm_entry(scratch_cp, old_bs_i, merge_cp_p, merge_cp_length_p);\n@@ -733,1 +727,1 @@\n-} \/\/ end find_or_append_operand()\n+} \/\/ end find_or_append_bsm_entry()\n@@ -736,2 +730,2 @@\n-void VM_RedefineClasses::finalize_operands_merge(const constantPoolHandle& merge_cp, TRAPS) {\n-  if (merge_cp->operands() == nullptr) {\n+void VM_RedefineClasses::finalize_bsm_entries_merge(const constantPoolHandle& merge_cp, TRAPS) {\n+  if (merge_cp->bsm_entries().number_of_entries() == 0) {\n@@ -740,2 +734,2 @@\n-  \/\/ Shrink the merge_cp operands\n-  merge_cp->shrink_operands(_operands_cur_length, CHECK);\n+  \/\/ Finished extending the BSMAEs\n+  merge_cp->end_extension(_bsmae_iter, CHECK);\n@@ -746,2 +740,2 @@\n-    for (int i = 1; i < _operands_index_map_p->length(); i++) {\n-      int value = _operands_index_map_p->at(i);\n+    for (int i = 1; i < _bsm_index_map_p->length(); i++) {\n+      int value = _bsm_index_map_p->at(i);\n@@ -749,1 +743,1 @@\n-        log_trace(redefine, class, constantpool)(\"operands_index_map[%d]: old=%d new=%d\", count, i, value);\n+        log_trace(redefine, class, constantpool)(\"bsm_index_map[%d]: old=%d new=%d\", count, i, value);\n@@ -755,4 +749,4 @@\n-  _operands_index_map_p = nullptr;\n-  _operands_cur_length = 0;\n-  _operands_index_map_count = 0;\n-} \/\/ end finalize_operands_merge()\n+  _bsm_index_map_p = nullptr;\n+  _bsm_index_map_count = 0;\n+  _bsmae_iter = BSMAttributeEntries::InsertionIterator();\n+} \/\/ end finalize_bsmentries_merge()\n@@ -1275,2 +1269,2 @@\n-int VM_RedefineClasses::find_new_operand_index(int old_index) {\n-  if (_operands_index_map_count == 0) {\n+int VM_RedefineClasses::find_new_bsm_index(int old_index) {\n+  if (_bsm_index_map_count == 0) {\n@@ -1281,1 +1275,1 @@\n-  if (old_index == -1 || old_index >= _operands_index_map_p->length()) {\n+  if (old_index == -1 || old_index >= _bsm_index_map_p->length()) {\n@@ -1287,1 +1281,1 @@\n-  int value = _operands_index_map_p->at(old_index);\n+  int value = _bsm_index_map_p->at(old_index);\n@@ -1294,1 +1288,1 @@\n-} \/\/ end find_new_operand_index()\n+} \/\/ end find_new_bsm_index()\n@@ -1563,6 +1557,1 @@\n-void VM_RedefineClasses::map_operand_index(int old_index, int new_index) {\n-  if (find_new_operand_index(old_index) != -1) {\n-    \/\/ old_index is already mapped\n-    return;\n-  }\n-\n+void VM_RedefineClasses::map_bsm_index(int old_index, int new_index) {\n@@ -1573,4 +1562,2 @@\n-\n-  _operands_index_map_p->at_put(old_index, new_index);\n-  _operands_index_map_count++;\n-\n+  _bsm_index_map_p->at_put(old_index, new_index);\n+  _bsm_index_map_count++;\n@@ -1578,1 +1565,1 @@\n-} \/\/ end map_index()\n+} \/\/ end map_bsm_index()\n@@ -1642,2 +1629,2 @@\n-    ConstantPool::copy_operands(old_cp, merge_cp_p, CHECK_false);\n-    merge_cp_p->extend_operands(scratch_cp, CHECK_false);\n+    ConstantPool::copy_bsm_entries(old_cp, merge_cp_p, CHECK_false);\n+    _bsmae_iter = merge_cp_p->start_extension(scratch_cp, CHECK_false);\n@@ -1740,1 +1727,1 @@\n-  finalize_operands_merge(merge_cp_p, CHECK_false);\n+  finalize_bsm_entries_merge(merge_cp_p, CHECK_false);\n@@ -1810,4 +1797,3 @@\n-  _operands_cur_length = ConstantPool::operand_array_length(old_cp->operands());\n-  _operands_index_map_count = 0;\n-  int operands_index_map_len = ConstantPool::operand_array_length(scratch_cp->operands());\n-  _operands_index_map_p = new intArray(operands_index_map_len, operands_index_map_len, -1);\n+  _bsm_index_map_count = 0;\n+  int bsm_data_len = scratch_cp->bsm_entries().array_length();\n+  _bsm_index_map_p = new intArray(bsm_data_len, bsm_data_len, -1);\n@@ -1815,1 +1801,1 @@\n-  \/\/ reference to the cp holder is needed for copy_operands()\n+  \/\/ reference to the cp holder is needed for reallocating the BSM attribute\n@@ -3503,1 +3489,1 @@\n-  \/\/ reference to the cp holder is needed for copy_operands()\n+  \/\/ reference to the cp holder is needed for reallocating the BSM attribute\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":66,"deletions":80,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -366,5 +366,10 @@\n-  \/\/ _operands_index_map_count is just an optimization for knowing if\n-  \/\/ _operands_index_map_p contains any entries.\n-  int                         _operands_cur_length;\n-  int                         _operands_index_map_count;\n-  intArray *                  _operands_index_map_p;\n+  \/\/ _bsm_index_map_count is just an optimization for knowing if\n+  \/\/ _bsm_index_map_p contains any entries.\n+  int                         _bsm_index_map_count;\n+  intArray *                  _bsm_index_map_p;\n+\n+  \/\/ After merge_constant_pools \"Pass 0\", the BSMAttribute entries of merge_cp_p will have been expanded to fit\n+  \/\/ scratch_cp's BSMAttribute entries as well.\n+  \/\/ However, the newly acquired space will not have been filled in yet.\n+  \/\/ To append to this new space, the iterator is used.\n+  BSMAttributeEntries::InsertionIterator _bsmae_iter;\n@@ -432,1 +437,2 @@\n-  void append_operand(const constantPoolHandle& scratch_cp, int scratch_bootstrap_spec_index,\n+  \/\/ Returns the index of the appended BSM\n+  int append_bsm_entry(const constantPoolHandle& scratch_cp, int scratch_bootstrap_spec_index,\n@@ -434,1 +440,1 @@\n-  void finalize_operands_merge(const constantPoolHandle& merge_cp, TRAPS);\n+  void finalize_bsm_entries_merge(const constantPoolHandle& merge_cp, TRAPS);\n@@ -437,1 +443,1 @@\n-  int find_or_append_operand(const constantPoolHandle& scratch_cp, int scratch_bootstrap_spec_index,\n+  int find_or_append_bsm_entry(const constantPoolHandle& scratch_cp, int scratch_bootstrap_spec_index,\n@@ -440,1 +446,1 @@\n-  int find_new_operand_index(int old_bootstrap_spec_index);\n+  int find_new_bsm_index(int old_bootstrap_spec_index);\n@@ -442,1 +448,1 @@\n-  void map_operand_index(int old_bootstrap_spec_index, int new_bootstrap_spec_index);\n+  void map_bsm_index(int old_bootstrap_spec_index, int new_bootstrap_spec_index);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"oops\/bsmAttribute.hpp\"\n@@ -174,0 +175,3 @@\n+  nonstatic_field(BSMAttributeEntries,         _offsets,                                      Array<u4>*)                            \\\n+  nonstatic_field(BSMAttributeEntries,         _bootstrap_methods,                            Array<u2>*)                            \\\n+  nonstatic_field(ConstantPool,                _bsmaentries,                                  BSMAttributeEntries)                   \\\n@@ -177,1 +181,0 @@\n-  nonstatic_field(ConstantPool,                _operands,                                     Array<u2>*)                            \\\n@@ -735,0 +738,1 @@\n+  unchecked_nonstatic_field(Array<u4>,                 _data,                                 sizeof(u4))                            \\\n@@ -965,0 +969,1 @@\n+  declare_toplevel_type(BSMAttributeEntries)                              \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-    operands    = type.getAddressField(\"_operands\");\n@@ -93,0 +92,4 @@\n+    bsm_entries = type.getField(\"_bsmaentries\").getOffset();\n+    Type bsmae_type = db.lookupType(\"BSMAttributeEntries\");\n+    bsm_entries_offsets = bsmae_type.getAddressField(\"_offsets\");\n+    bsm_entries_bootstrap_methods = bsmae_type.getAddressField(\"_bootstrap_methods\");\n@@ -115,1 +118,0 @@\n-  private static AddressField operands;\n@@ -118,0 +120,3 @@\n+  private static long bsm_entries; \/\/ Offset in the constantpool where the Bsm_Entries are found\n+  private static AddressField bsm_entries_offsets;\n+  private static AddressField bsm_entries_bootstrap_methods;\n@@ -133,4 +138,0 @@\n-  public U2Array           getOperands()   {\n-    Address addr = operands.getValue(getAddress());\n-    return VMObjectFactory.newObject(U2Array.class, addr);\n-  }\n@@ -438,0 +439,12 @@\n+  private U4Array getOffsets() {\n+     Address a =  getAddress().addOffsetTo(bsm_entries);\n+     if (a == null) return null;\n+     a = bsm_entries_offsets.getValue(a);\n+     return VMObjectFactory.newObject(U4Array.class, a);\n+  }\n+  private U2Array getBootstrapMethods() {\n+    Address a =  getAddress().addOffsetTo(bsm_entries);\n+    if (a == null) return null;\n+    return VMObjectFactory.newObject(U2Array.class, bsm_entries_bootstrap_methods.getValue(a));\n+  }\n+\n@@ -439,1 +452,1 @@\n-    U2Array operands = getOperands();\n+    U4Array offsets = getOffsets();\n@@ -441,17 +454,2 @@\n-    if (operands != null) {\n-      \/\/ Operands array consists of two parts. First part is an array of 32-bit values which denote\n-      \/\/ index of the bootstrap method data in the operands array. Note that elements of operands array are of type short.\n-      \/\/ So each element of first part occupies two slots in the array.\n-      \/\/ Second part is the bootstrap methods data.\n-      \/\/ This layout allows us to get BSM count by getting the index of first BSM and dividing it by 2.\n-      \/\/\n-      \/\/ The example below shows layout of operands array with 3 bootstrap methods.\n-      \/\/ First part has 3 32-bit values indicating the index of the respective bootstrap methods in\n-      \/\/ the operands array.\n-      \/\/ The first BSM is at index 6. So the count in this case is 6\/2=3.\n-      \/\/\n-      \/\/            <-----first part----><-------second part------->\n-      \/\/ index:     0     2      4      6        i2       i3\n-      \/\/ operands:  |  6  |  i2  |  i3  |  bsm1  |  bsm2  |  bsm3  |\n-      \/\/\n-      count = getOperandOffsetAt(operands, 0) \/ 2;\n+    if (offsets != null) {\n+      count = offsets.length();\n@@ -466,1 +464,2 @@\n-    U2Array operands = getOperands();\n+    U4Array offs = getOffsets();\n+    U2Array bsms = getBootstrapMethods();\n@@ -468,1 +467,1 @@\n-      Assert.that(operands != null, \"Operands is not present\");\n+      Assert.that(offs != null && bsms != null, \"BSM attribute is not present\");\n@@ -470,2 +469,1 @@\n-    int bsmOffset = getOperandOffsetAt(operands, bsmIndex);\n-    int argc = operands.at(bsmOffset + INDY_ARGC_OFFSET);\n+    int argc = bsms.at(offs.at(bsmIndex) + INDY_ARGC_OFFSET);\n@@ -479,3 +477,4 @@\n-    U2Array operands = getOperands();\n-    if (operands == null)  return null;  \/\/ safety first\n-    int basePos = getOperandOffsetAt(operands, bsmIndex);\n+    U4Array offs = getOffsets();\n+    U2Array bsms = getBootstrapMethods();\n+    if (offs == null || bsms == null) return null; \/\/ safety first\n+    int basePos = offs.at(bsmIndex);\n@@ -483,1 +482,1 @@\n-    int argc = operands.at(basePos + INDY_ARGC_OFFSET);\n+    int argc = getBootstrapMethodArgsCount(bsmIndex);\n@@ -487,1 +486,1 @@\n-        values[j] = operands.at(basePos+j);\n+      values[j] = bsms.at(basePos+j);\n@@ -776,2 +775,1 @@\n-    return VM.getVM().buildIntFromShorts(operands.at(bsmIndex * 2),\n-                                         operands.at(bsmIndex * 2 + 1));\n+      return 0;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstantPool.java","additions":33,"deletions":35,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.utilities;\n+\n+import sun.jvm.hotspot.debugger.Address;\n+import sun.jvm.hotspot.runtime.VM;\n+import sun.jvm.hotspot.types.Type;\n+import sun.jvm.hotspot.types.TypeDataBase;\n+import sun.jvm.hotspot.types.WrongTypeException;\n+import sun.jvm.hotspot.utilities.Observable;\n+import sun.jvm.hotspot.utilities.Observer;\n+\n+public class U4Array extends GenericArray {\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+      public void update(Observable o, Object data) {\n+        initialize(VM.getVM().getTypeDataBase());\n+      }\n+    });\n+  }\n+\n+  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n+    elemType = db.lookupType(\"u4\");\n+    Type type = db.lookupType(\"Array<u4>\");\n+    dataFieldOffset = type.getAddressField(\"_data\").getOffset();\n+  }\n+\n+  private static long dataFieldOffset;\n+  protected static Type elemType;\n+\n+  public U4Array(Address addr) {\n+    super(addr, dataFieldOffset);\n+  }\n+\n+  public int at(int i) {\n+    return (int)getIntegerAt(i);\n+  }\n+\n+  public Type getElemType() {\n+    return elemType;\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/U4Array.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}