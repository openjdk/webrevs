{"files":[{"patch":"@@ -30,3 +30,1 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n@@ -34,1 +32,0 @@\n-import java.util.function.Function;\n@@ -41,3 +38,0 @@\n-import java.util.ServiceLoader;\n-import java.util.ServiceLoader.Provider;\n-import java.util.stream.Collectors;\n@@ -111,1 +105,1 @@\n-     * Instance provider class of random number algorithm.\n+     * Class of random number algorithm.\n@@ -113,1 +107,1 @@\n-    private final Provider<? extends RandomGenerator> provider;\n+    private final Class<? extends RandomGenerator> rgClass;\n@@ -116,1 +110,1 @@\n-     * Provider RandomGeneratorProperties annotation.\n+     * RandomGeneratorProperties annotation.\n@@ -121,1 +115,1 @@\n-     * Default provider constructor.\n+     * Default random generator constructor.\n@@ -126,1 +120,1 @@\n-     * Provider constructor with long seed.\n+     * Random generator constructor with long seed.\n@@ -131,1 +125,1 @@\n-     * Provider constructor with byte[] seed.\n+     * Random generator constructor with byte[] seed.\n@@ -137,1 +131,1 @@\n-        static final Map<String, Provider<? extends RandomGenerator>> FACTORY_MAP = createFactoryMap();\n+        static final Map<String, Class<? extends RandomGenerator>> FACTORY_MAP = createFactoryMap();\n@@ -142,1 +136,1 @@\n-         * @return Map of RandomGeneratorFactory classes.\n+         * @return Map of RandomGenerator classes.\n@@ -144,7 +138,21 @@\n-        private static Map<String, Provider<? extends RandomGenerator>> createFactoryMap() {\n-            FactoryMapHolder.class.getModule().addUses(RandomGenerator.class);\n-            return ServiceLoader\n-                .load(RandomGenerator.class, ClassLoader.getPlatformClassLoader())\n-                .stream()\n-                .filter(p -> !p.type().isInterface())\n-                .collect(Collectors.toMap(p -> p.type().getSimpleName(), Function.identity()));\n+        private static Map<String, Class<? extends RandomGenerator>> createFactoryMap() {\n+            return Map.ofEntries(\n+                    entry(java.security.SecureRandom.class),\n+                    entry(java.util.Random.class),\n+                    entry(java.util.SplittableRandom.class),\n+                    entry(jdk.internal.random.L32X64MixRandom.class),\n+                    entry(jdk.internal.random.L64X128MixRandom.class),\n+                    entry(jdk.internal.random.L64X128StarStarRandom.class),\n+                    entry(jdk.internal.random.L64X256MixRandom.class),\n+                    entry(jdk.internal.random.L64X1024MixRandom.class),\n+                    entry(jdk.internal.random.L128X128MixRandom.class),\n+                    entry(jdk.internal.random.L128X256MixRandom.class),\n+                    entry(jdk.internal.random.L128X1024MixRandom.class),\n+                    entry(jdk.internal.random.Xoroshiro128PlusPlus.class),\n+                    entry(jdk.internal.random.Xoshiro256PlusPlus.class)\n+            );\n+        }\n+\n+        private static SimpleImmutableEntry<String, Class<? extends RandomGenerator>>\n+        entry(Class<? extends RandomGenerator> rgClass) {\n+            return new SimpleImmutableEntry<>(rgClass.getSimpleName(), rgClass);\n@@ -157,1 +165,1 @@\n-     * @param provider  Provider class to wrap.\n+     * @param rgClass  Random generator class.\n@@ -159,2 +167,2 @@\n-    private RandomGeneratorFactory(Provider<? extends RandomGenerator> provider) {\n-        this.provider = provider;\n+    private RandomGeneratorFactory(Class<? extends RandomGenerator> rgClass) {\n+        this.rgClass = rgClass;\n@@ -166,1 +174,1 @@\n-     * @return Map of RandomGeneratorFactory classes.\n+     * @return Map of random generator classes.\n@@ -168,1 +176,1 @@\n-    private static Map<String, Provider<? extends RandomGenerator>> getFactoryMap() {\n+    private static Map<String, Class<? extends RandomGenerator>> getFactoryMap() {\n@@ -173,1 +181,1 @@\n-     * Return the annotation for the specified provider.\n+     * Return the annotation for the specified random generator.\n@@ -175,1 +183,1 @@\n-     * @return RandomGeneratorProperties annotation for the specified provider.\n+     * @return RandomGeneratorProperties annotation for the specified random generator.\n@@ -178,5 +186,6 @@\n-        if (properties == null) {\n-            synchronized (provider) {\n-                if (properties == null) {\n-                    properties = provider.type().getDeclaredAnnotation(RandomGeneratorProperties.class);\n-                    Objects.requireNonNull(properties, provider.type() + \" missing annotation\");\n+        if (properties == null) {  \/\/ volatile load\n+            synchronized (rgClass) {\n+                if (properties == null) {  \/\/ double-checking idiom\n+                    RandomGeneratorProperties props = rgClass.getDeclaredAnnotation(RandomGeneratorProperties.class);\n+                    Objects.requireNonNull(props, rgClass + \" missing annotation\");\n+                    properties = props;  \/\/ volatile store\n@@ -191,1 +200,1 @@\n-     * Return true if the provider is a subclass of the category.\n+     * Return true if rgClass is a subclass of the category.\n@@ -195,1 +204,1 @@\n-     * @return true if the provider is a subclass of the category.\n+     * @return true if the random generator is a subclass of the category.\n@@ -198,1 +207,1 @@\n-        return isSubclass(category, provider);\n+        return isSubclass(category, rgClass);\n@@ -202,1 +211,1 @@\n-     * Return true if the provider is a subclass of the category.\n+     * Return true if rgClass is a subclass of the category.\n@@ -205,1 +214,1 @@\n-     * @param provider Provider that is being filtered.\n+     * @param rgClass Class that is being filtered.\n@@ -207,1 +216,1 @@\n-     * @return true if the provider is a subclass of the category.\n+     * @return true if rgClass is a subclass of the category.\n@@ -210,2 +219,2 @@\n-                                      Provider<? extends RandomGenerator> provider) {\n-        return provider != null && category.isAssignableFrom(provider.type());\n+            Class<? extends RandomGenerator> rgClass) {\n+        return rgClass != null && category.isAssignableFrom(rgClass);\n@@ -215,1 +224,1 @@\n-     * Returns the provider matching name and category.\n+     * Returns the random generator class matching name and category.\n@@ -220,1 +229,1 @@\n-     * @return A provider matching name and category.\n+     * @return A random generator class matching name and category.\n@@ -222,1 +231,1 @@\n-     * @throws IllegalArgumentException if provider is not a subclass of category.\n+     * @throws IllegalArgumentException if the resulting type is not a subclass of category.\n@@ -224,6 +233,5 @@\n-    private static Provider<? extends RandomGenerator> findProvider(String name,\n-                                                                    Class<? extends RandomGenerator> category)\n-            throws IllegalArgumentException {\n-        Map<String, Provider<? extends RandomGenerator>> fm = getFactoryMap();\n-        Provider<? extends RandomGenerator> provider = fm.get(name);\n-        if (provider == null) {\n+    private static Class<? extends RandomGenerator> findClass(String name,\n+            Class<? extends RandomGenerator> category) throws IllegalArgumentException {\n+        Map<String, Class<? extends RandomGenerator>> fm = getFactoryMap();\n+        Class<? extends RandomGenerator> rgClass = fm.get(name);\n+        if (rgClass == null) {\n@@ -231,3 +239,4 @@\n-                                                name +\n-                                                \"\\\" is available\");\n-        } else if (!isSubclass(category, provider)) {\n+                    name +\n+                    \"\\\" is available\");\n+        }\n+        if (!isSubclass(category, rgClass)) {\n@@ -235,4 +244,4 @@\n-                                                name +\n-                                                \"\\\" is not implemented with the interface \\\"\" +\n-                                                category.getSimpleName() +\n-                                                \"\\\"\");\n+                    name +\n+                    \"\\\" is not implemented with the interface \\\"\" +\n+                    category.getSimpleName() +\n+                    \"\\\"\");\n@@ -240,1 +249,1 @@\n-        return provider;\n+        return rgClass;\n@@ -257,3 +266,8 @@\n-        @SuppressWarnings(\"unchecked\")\n-        T uncheckedRandomGenerator = (T)findProvider(name, category).get();\n-        return uncheckedRandomGenerator;\n+        Class<? extends RandomGenerator> rgClass = findClass(name, category);\n+        try {\n+            @SuppressWarnings(\"unchecked\")\n+            T instance = (T) rgClass.getConstructor().newInstance();\n+            return instance;\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n@@ -276,2 +290,2 @@\n-        Provider<? extends RandomGenerator> uncheckedProvider = findProvider(name, category);\n-        return new RandomGeneratorFactory<>(uncheckedProvider);\n+        Class<? extends RandomGenerator> rgClass = findClass(name, category);\n+        return new RandomGeneratorFactory<>(rgClass);\n@@ -281,3 +295,1 @@\n-     * Fetch the required constructors for class of random number algorithm.\n-     *\n-     * @param randomGeneratorClass class of random number algorithm (provider)\n+     * Ensure all the required constructors are fetched.\n@@ -285,29 +297,24 @@\n-    private void getConstructors(Class<? extends RandomGenerator> randomGeneratorClass) {\n-        if (ctor == null) {\n-            synchronized (provider) {\n-                if (ctor == null) {\n-                    PrivilegedExceptionAction<Constructor<?>[]> ctorAction = randomGeneratorClass::getConstructors;\n-                    try {\n-                        @SuppressWarnings(\"removal\")\n-                        Constructor<?>[] ctors = AccessController.doPrivileged(ctorAction);\n-\n-                        Constructor<T> tmpCtor = null;\n-                        Constructor<T> tmpCtorLong = null;\n-                        Constructor<T> tmpCtorBytes = null;\n-\n-\n-                        for (Constructor<?> ctorGeneric : ctors) {\n-                            @SuppressWarnings(\"unchecked\")\n-                            Constructor<T> ctorSpecific = (Constructor<T>) ctorGeneric;\n-                            final Class<?>[] parameterTypes = ctorSpecific.getParameterTypes();\n-\n-                            if (parameterTypes.length == 0) {\n-                                tmpCtor = ctorSpecific;\n-                            } else if (parameterTypes.length == 1) {\n-                                Class<?> argType = parameterTypes[0];\n-\n-                                if (argType == long.class) {\n-                                    tmpCtorLong = ctorSpecific;\n-                                } else if (argType == byte[].class) {\n-                                    tmpCtorBytes = ctorSpecific;\n-                                }\n+    private void ensureConstructors() {\n+        if (ctor == null) {  \/\/ volatile load\n+            synchronized (rgClass) {\n+                if (ctor == null) {  \/\/ double-checking idiom\n+                    Constructor<?>[] ctors = rgClass.getConstructors();\n+\n+                    Constructor<T> tmpCtor = null;\n+                    Constructor<T> tmpCtorLong = null;\n+                    Constructor<T> tmpCtorBytes = null;\n+\n+                    for (Constructor<?> ctorGeneric : ctors) {\n+                        @SuppressWarnings(\"unchecked\")\n+                        Constructor<T> ctorSpecific = (Constructor<T>) ctorGeneric;\n+                        final Class<?>[] parameterTypes = ctorSpecific.getParameterTypes();\n+\n+                        if (parameterTypes.length == 0) {\n+                            tmpCtor = ctorSpecific;\n+                        } else if (parameterTypes.length == 1) {\n+                            Class<?> argType = parameterTypes[0];\n+\n+                            if (argType == long.class) {\n+                                tmpCtorLong = ctorSpecific;\n+                            } else if (argType == byte[].class) {\n+                                tmpCtorBytes = ctorSpecific;\n@@ -316,0 +323,1 @@\n+                    }\n@@ -317,10 +325,2 @@\n-                        if (tmpCtor == null) {\n-                            throw new IllegalStateException(\"Random algorithm \" + name() + \" is missing a default constructor\");\n-                        }\n-\n-                        \/\/ Store specialized constructors first, guarded by ctor\n-                        ctorBytes = tmpCtorBytes;\n-                        ctorLong = tmpCtorLong;\n-                        ctor = tmpCtor;\n-                    } catch (PrivilegedActionException ex) {\n-                        \/\/ Do nothing\n+                    if (tmpCtor == null) {\n+                        throw new IllegalStateException(\"Random algorithm \" + name() + \" is missing a default constructor\");\n@@ -328,0 +328,5 @@\n+\n+                    \/\/ Store specialized constructors first, guarded by ctor\n+                    ctorBytes = tmpCtorBytes;\n+                    ctorLong = tmpCtorLong;\n+                    ctor = tmpCtor;  \/\/ volatile store comes last\n@@ -333,7 +338,0 @@\n-    \/**\n-     * Ensure all the required constructors are fetched.\n-     *\/\n-    private void ensureConstructors() {\n-        getConstructors(provider.type());\n-    }\n-\n@@ -358,1 +356,1 @@\n-                (RandomGeneratorFactory<T>)factoryOf(name, RandomGenerator.class);\n+                (RandomGeneratorFactory<T>) factoryOf(name, RandomGenerator.class);\n@@ -383,1 +381,1 @@\n-        Map<String, Provider<? extends RandomGenerator>> fm = getFactoryMap();\n+        Map<String, Class<? extends RandomGenerator>> fm = getFactoryMap();\n@@ -386,2 +384,2 @@\n-                 .filter(p -> !p.type().isAnnotationPresent(Deprecated.class) &&\n-                              p.type().isAnnotationPresent(RandomGeneratorProperties.class))\n+                 .filter(c -> !c.isAnnotationPresent(Deprecated.class) &&\n+                              c.isAnnotationPresent(RandomGeneratorProperties.class))\n@@ -398,1 +396,1 @@\n-        return provider.type().getSimpleName();\n+        return rgClass.getSimpleName();\n@@ -550,1 +548,1 @@\n-        return provider.type().isAnnotationPresent(Deprecated.class);\n+        return rgClass.isAnnotationPresent(Deprecated.class);\n@@ -554,1 +552,1 @@\n-     * Create an instance of {@link RandomGenerator} based on\n+     * Create an instance of {@link RandomGenerator} based on the\n@@ -558,1 +556,0 @@\n-     *\n@@ -566,1 +563,2 @@\n-            throw new IllegalStateException(\"Random algorithm \" + name() + \" is missing a default constructor\", ex);\n+            throw new InternalError(\"Random algorithm \" + name()\n+                    + \" is missing a default constructor\", ex);\n@@ -571,4 +569,5 @@\n-     * Create an instance of {@link RandomGenerator} based on\n-     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> chosen\n-     * providing a starting long seed. If long seed is not supported by an\n-     * algorithm then the no argument form of create is used.\n+     * Create an instance of {@link RandomGenerator} based on the\n+     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> chosen,\n+     * and providing a starting long seed.\n+     * If a long seed is not supported by the algorithm,\n+     * an UnsupportedOperationException is thrown.\n@@ -579,0 +578,2 @@\n+     *\n+     * @throws UnsupportedOperationException if a long seed in not supported.\n@@ -585,1 +586,2 @@\n-            return create();\n+            throw new UnsupportedOperationException(\"Random algorithm \"\n+                    + name() + \" does not support a long seed\");\n@@ -590,5 +592,5 @@\n-     * Create an instance of {@link RandomGenerator} based on\n-     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> chosen\n-     * providing a starting byte[] seed. If byte[] seed is not supported by an\n-     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> then the no\n-     * argument form of create is used.\n+     * Create an instance of {@link RandomGenerator} based on the\n+     * <a href=\"package-summary.html#algorithms\">algorithm<\/a> chosen,\n+     * and providing a starting byte[] seed.\n+     * If a byte[] seed is not supported by the algorithm,\n+     * an UnsupportedOperationException is thrown.\n@@ -600,0 +602,1 @@\n+     * @throws UnsupportedOperationException if a byte[] seed in not supported.\n@@ -608,1 +611,2 @@\n-            return create();\n+            throw new UnsupportedOperationException(\"Random algorithm \"\n+                    + name() + \" does not support a byte[] seed\");\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGeneratorFactory.java","additions":137,"deletions":133,"binary":false,"changes":270,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n- * algorithm to the static method {@link RandomGenerator#of}, in which case the\n- * no-arguments constructor for that implementation is used:\n+ * algorithm to the static method {@link RandomGenerator#of}, in which case no\n+ * seed is specified by the caller:\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/package-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -422,15 +422,0 @@\n-    provides java.util.random.RandomGenerator with\n-        java.security.SecureRandom,\n-        java.util.Random,\n-        java.util.SplittableRandom,\n-        jdk.internal.random.L32X64MixRandom,\n-        jdk.internal.random.L64X128MixRandom,\n-        jdk.internal.random.L64X128StarStarRandom,\n-        jdk.internal.random.L64X256MixRandom,\n-        jdk.internal.random.L64X1024MixRandom,\n-        jdk.internal.random.L128X128MixRandom,\n-        jdk.internal.random.L128X256MixRandom,\n-        jdk.internal.random.L128X1024MixRandom,\n-        jdk.internal.random.Xoroshiro128PlusPlus,\n-        jdk.internal.random.Xoshiro256PlusPlus;\n-\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,2 +174,19 @@\n-        coverRandomGenerator(factory.create(12345L));\n-        coverRandomGenerator(factory.create(new byte[] {1, 2, 3, 4, 5, 6, 7, 8}));\n+        RandomGenerator rng;\n+\n+        rng = null;\n+        try {\n+            rng = factory.create(12345L);\n+        } catch (UnsupportedOperationException ignore) {\n+        }\n+        if (rng != null) {\n+            coverRandomGenerator(rng);\n+        }\n+\n+        rng = null;\n+        try {\n+            rng = factory.create(new byte[] {1, 2, 3, 4, 5, 6, 7, 8});\n+        } catch (UnsupportedOperationException ignore) {\n+        }\n+        if (rng != null) {\n+            coverRandomGenerator(rng);\n+        }\n","filename":"test\/jdk\/java\/util\/Random\/RandomTestCoverage.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"}]}