{"files":[{"patch":"@@ -1509,28 +1509,15 @@\n-          Node* ptr = out->in(MemNode::Address);\n-          if (ptr->is_AddP()) {\n-            Node* ptr_base = ptr->as_AddP()->base_node();\n-            if (!_phase->type(ptr_base)->isa_oopptr()) {\n-              \/\/ Maybe a store to raw memory\n-              res = ESCAPED;\n-              break;\n-            }\n-\n-            \/\/ If an object o is stored into a field of a holder h and h has not escaped, we can\n-            \/\/ say that o has not escaped, too\n-            LocalEA store_base_ea(_phase, ptr->as_AddP()->base_node());\n-            if (!store_base_ea.is_candidate()) {\n-              res = ESCAPED;\n-              break;\n-            }\n-\n-            \/\/ This is similar to store_base_ea.check_escape_status(ctl), the differences are that\n-            \/\/ it avoids the drawbacks of recursion and does not unnecessarily collect\n-            \/\/ _not_escaped_controls again\n-            for (uint i = 0; i < store_base_ea.aliases().size(); i++) {\n-              dependencies.push(store_base_ea.aliases().at(i));\n-            }\n-          } else {\n-            \/\/ Do not know into where n is stored, give up\n-            res = ESCAPED;\n-            break;\n-          }\n+          \/\/ You may wonder if we can reason about the escape status of the destination memory\n+          \/\/ here so that we can determine that an object has not escaped if the object into which\n+          \/\/ it is stored has not escaped. Unfortunately, this store breaks _aliases, because there\n+          \/\/ is now a memory that can alias the object we are analyzed, and a load from such memory\n+          \/\/ is not visited by this analysis. For example:\n+          \/\/   Object o = new Object;\n+          \/\/   Holder h = new Holder;\n+          \/\/   h.o = o;\n+          \/\/   do_something();\n+          \/\/   Object p = h.o;\n+          \/\/   escape(p);\n+          \/\/ Then, o escapes at escape(p), but we will not visit that. In order for this to work,\n+          \/\/ the constructor needs to be more conservative when it collects _aliases.\n+          res = ESCAPED;\n+          break;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":15,"deletions":28,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, failOn = IRNode.LOAD_I, counts = {IRNode.ALLOC, \"1\"})\n+    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, counts = {IRNode.ALLOC, \"1\"})\n@@ -257,1 +257,1 @@\n-    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, failOn = IRNode.LOAD_I, counts = {IRNode.ALLOC, \"2\"})\n+    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, counts = {IRNode.ALLOC, \"2\"})\n@@ -270,1 +270,1 @@\n-    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, failOn = IRNode.LOAD_I, counts = {IRNode.ALLOC, \"3\"})\n+    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, counts = {IRNode.ALLOC, \"3\"})\n@@ -284,1 +284,1 @@\n-    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, failOn = IRNode.LOAD_I, counts = {IRNode.ALLOC, \"3\"})\n+    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, counts = {IRNode.ALLOC, \"3\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestLoadFolding.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}