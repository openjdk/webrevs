{"files":[{"patch":"@@ -709,8 +709,2 @@\n-  int cnt = 50;             \/\/ Cycle limiter\n-  if (is_Load() && alloc != nullptr) {\n-    \/\/ Get agressive for loads from freshly allocated objects\n-    cnt = 1000;\n-  }\n-\n-  \/\/ If alloc != nullptr and the allocated object has not escaped the current compilation unit, we\n-  \/\/ can be more aggressive, walk past calls and memory barriers to find a corresponding store\n+  \/\/ If base has not escaped the current compilation unit, we can be more aggressive, walk past\n+  \/\/ calls and memory barriers to find a corresponding store\n@@ -723,0 +717,6 @@\n+  int cnt = 50; \/\/ Cycle limiter\n+  if (is_Load() && (has_not_escaped.is_default() || has_not_escaped)) {\n+    \/\/ Get agressive for loads from freshly allocated objects\n+    cnt = 1000;\n+  }\n+\n@@ -745,2 +745,2 @@\n-      \/\/ For raw accesses, 2 accesses are independent if they have the same base and the offset\n-      \/\/ says that they do not overlap.\n+      \/\/ For raw accesses, 2 accesses are independent if they have the same base and the offsets\n+      \/\/ say that they do not overlap.\n@@ -748,1 +748,1 @@\n-      \/\/ at runtime or the offset says that the accesses do not overlap.\n+      \/\/ at runtime or the offsets say that the accesses do not overlap.\n@@ -870,2 +870,3 @@\n-      \/\/ We are more aggressive with known instances, for the others, if this call may modify base,\n-      \/\/ check_not_escaped would return false\n+      \/\/ We are more aggressive with known instances. For example, if base is an argument of call\n+      \/\/ and call is an invocation of unsafe_arraycopy, the global escape analyzer can consider\n+      \/\/ base not to escape, while the local escape analyzer will be more conservative.\n@@ -897,2 +898,4 @@\n-      \/\/ We are more aggressive with known instances, for the others, if this call may modify base,\n-      \/\/ check_not_escaped would return false\n+      \/\/ We are more aggressive with known instances. For example, if base is an argument of call\n+      \/\/ and call is an ArrayCopyNode, the global escape analyzer can consider base not to escape,\n+      \/\/ while the local escape analyzer will be more conservative. This case is about the trailing\n+      \/\/ memory barrier of an ArrayCopyNode.\n@@ -1398,1 +1401,1 @@\n-      \/\/ and a load, we cannot perform escape analysis). This branch is pretty conservative.\n+      \/\/ and a load), we cannot perform escape analysis. This branch is conservative.\n@@ -1406,1 +1409,1 @@\n-  \/\/ them, they may alias base as well. Actually, there may be case that a may alias b and b may\n+  \/\/ them, they may alias base as well. Actually, there may be cases that a may alias b and b may\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"}]}