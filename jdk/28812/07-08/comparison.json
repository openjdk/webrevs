{"files":[{"patch":"@@ -89,2 +89,2 @@\n-\/\/ Check whether an allocation has escaped at a certain control node ctl, the allocation does not\n-\/\/ escape at ctl if there is no node that:\n+\/\/ Check whether an allocation has escaped at a certain control node ctl, the allocation has not\n+\/\/ escaped at ctl if there is no node that:\n@@ -94,1 +94,1 @@\n-\/\/   b. Has a control input that is a transitive control input of ctl.\n+\/\/   b. Has a control input that is ctl or a transitive control input of ctl.\n@@ -96,3 +96,3 @@\n-\/\/ In other word, alloc is determined not to escape at ctl if all nodes that make alloc escape have\n-\/\/ a control input that is not a transitive control input of ctl.\n-bool MemNode::check_not_escaped(PhaseValues* phase, Unique_Node_List& aliases, AllocateNode* alloc, Node* ctl) {\n+\/\/ In other word, alloc is determined that it has not escaped at ctl if all nodes that make alloc\n+\/\/ escape have a control input that is neither nullptr, ctl, nor a transitive control input of ctl.\n+bool MemNode::check_not_escaped(PhaseValues* phase, Unique_Node_List& aliases, Unique_Node_List& not_escaped_controls, AllocateNode* alloc, Node* ctl) {\n@@ -108,24 +108,3 @@\n-  Node* base = alloc->result_cast();\n-  assert(base != nullptr, \"must have a result cast\");\n-\n-  \/\/ Find all nodes that may alias base, if any of these nodes escapes, then we conservatively say\n-  \/\/ that base escapes\n-  assert(aliases.size() == 0, \"must not be computed yet\");\n-  aliases.push(base);\n-  for (uint wl_idx = 0; wl_idx < aliases.size(); wl_idx++) {\n-    Node* n = aliases.at(wl_idx);\n-    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-      Node* out = n->fast_out(i);\n-      if (out->is_ConstraintCast() || out->is_EncodeP() || out->is_DecodeN() ||\n-          out->is_Phi() || out->is_CMove()) {\n-        aliases.push(out);\n-      } else if (out->is_AddP()) {\n-        \/\/ Some runtime calls receive a derived pointer but not its base, so we consider these\n-        \/\/ derived pointers aliases, too\n-        aliases.push(out);\n-      }\n-    }\n-  }\n-\n-  \/\/ Find all transitive control inputs of ctl that are not dead\n-  ResourceMark rm;\n+  \/\/ Find all transitive control inputs of ctl that are not dead, if it is determined that alloc\n+  \/\/ has not escaped at ctl, then it must be the case that it has not escaped at all of these\n+  assert(not_escaped_controls.size() == 0, \"must not be computed yet\");\n@@ -133,4 +112,3 @@\n-  Unique_Node_List controls;\n-  controls.push(ctl);\n-  for (uint control_idx = 0; control_idx < controls.size(); control_idx++) {\n-    Node* n = controls.at(control_idx);\n+  not_escaped_controls.push(ctl);\n+  for (uint control_idx = 0; control_idx < not_escaped_controls.size(); control_idx++) {\n+    Node* n = not_escaped_controls.at(control_idx);\n@@ -146,1 +124,1 @@\n-          controls.push(in);\n+          not_escaped_controls.push(in);\n@@ -152,1 +130,1 @@\n-        controls.push(in);\n+        not_escaped_controls.push(in);\n@@ -157,1 +135,1 @@\n-  if (!controls.member(start)) {\n+  if (!not_escaped_controls.member(start)) {\n@@ -159,0 +137,1 @@\n+    not_escaped_controls.clear();\n@@ -162,0 +141,3 @@\n+  Node* base = alloc->result_cast();\n+  assert(base != nullptr, \"must have a result cast\");\n+\n@@ -164,0 +146,2 @@\n+  bool res = true;\n+  aliases.push(base);\n@@ -168,0 +152,13 @@\n+      if (out->is_ConstraintCast() || out->is_EncodeP() || out->is_DecodeN() ||\n+          out->is_Phi() || out->is_CMove()) {\n+        \/\/ A node that may alias base, if any of these nodes escapes, then we conservatively say\n+        \/\/ that base escapes\n+        aliases.push(out);\n+        continue;\n+      } else if (out->is_AddP()) {\n+        \/\/ Some runtime calls receive a derived pointer but not its base, so we consider these\n+        \/\/ derived pointers aliases, too\n+        aliases.push(out);\n+        continue;\n+      }\n+\n@@ -169,1 +166,1 @@\n-      if (c != nullptr && !controls.member(c)) {\n+      if (c != nullptr && !not_escaped_controls.member(c)) {\n@@ -175,3 +172,1 @@\n-      if (aliases.member(out)) {\n-        \/\/ Just a node that may alias n, such as Phi, CMove, CastPP\n-      } else if (out->is_Load()) {\n+      if (out->is_Load()) {\n@@ -183,1 +178,2 @@\n-          return false;\n+          res = false;\n+          break;\n@@ -189,1 +185,2 @@\n-          return false;\n+          res = false;\n+          break;\n@@ -194,1 +191,2 @@\n-          return false;\n+          res = false;\n+          break;\n@@ -203,1 +201,2 @@\n-        return false;\n+        res = false;\n+        break;\n@@ -206,0 +205,4 @@\n+\n+    if (!res) {\n+      break;\n+    }\n@@ -208,1 +211,4 @@\n-  return true;\n+  if (!res) {\n+    not_escaped_controls.clear();\n+  }\n+  return res;\n@@ -835,2 +841,1 @@\n-  \/\/ Can't use optimize_simple_memory_chain() since it needs PhaseGVN.\n-  bool is_known_instance = addr_t != nullptr && addr_t->is_known_instance_field();\n+  ResourceMark rm;\n@@ -839,0 +844,1 @@\n+  bool is_known_instance = addr_t != nullptr && addr_t->is_known_instance_field();\n@@ -841,1 +847,0 @@\n-  ResourceMark rm;\n@@ -843,0 +848,9 @@\n+  \/\/ If it is known that alloc has not escaped at a control node c1, then it must be the case that\n+  \/\/ alloc has not escaped at all of the transitive control inputs of the node. Otherwise, there\n+  \/\/ will be a control flow following the path from a transitive input c2 of c1 to c1 in which\n+  \/\/ alloc has escaped at c2 but has also not escaped at a later point c1, which is impossible.\n+  \/\/ As a result, when alloc is determined that it has not escaped at a control node, we record\n+  \/\/ that node as well as all of its transitive control inputs here.\n+  Unique_Node_List not_escaped_controls;\n+\n+  \/\/ Can't use optimize_simple_memory_chain() since it needs PhaseGVN.\n@@ -900,1 +914,0 @@\n-#ifdef ASSERT\n@@ -902,6 +915,6 @@\n-        ResourceMark rm;\n-        Unique_Node_List verify_aliases;\n-        \/\/ Since we are walking from a node to its input, if alloc is found not to escape at an\n-        \/\/ earlier iteration, it must also be found not to escape at the current iteration\n-        assert(check_not_escaped(phase, verify_aliases, alloc, mem->in(0)), \"inconsistent\");\n-#endif \/\/ ASSERT\n+\n+        \/\/ Since we are walking from a node to its input, if alloc is found that it has not escaped\n+        \/\/ at an earlier iteration, it must also be found that it has not escaped at the current\n+        \/\/ iteration\n+        assert(not_escaped_controls.member(mem->in(0)), \"inconsistent\");\n+\n@@ -915,1 +928,1 @@\n-        \/\/ detect_ptr_independence == true means that it can prove that base and st_base can not\n+        \/\/ detect_ptr_independence == true means that it can prove that base and st_base cannot\n@@ -918,7 +931,0 @@\n-      } else if (has_not_escaped.is_default()) {\n-        \/\/ Both of the previous approaches fail, try to compute the set of all nodes that can have\n-        \/\/ the same runtime value as base and whether st_base is one of them\n-        has_not_escaped = check_not_escaped(phase, aliases, alloc, mem->in(0));\n-        if (has_not_escaped) {\n-          known_independent = !aliases.member(st_base);\n-        }\n@@ -981,1 +987,0 @@\n-#ifdef ASSERT\n@@ -983,5 +988,4 @@\n-        ResourceMark rm;\n-        Unique_Node_List verify_aliases;\n-        \/\/ Since we are walking from a node to its input, if alloc is found not to escape at an\n-        \/\/ earlier iteration, it must also be found not to escape at the current iteration\n-        assert(check_not_escaped(phase, verify_aliases, alloc, call), \"inconsistent\");\n+        \/\/ Since we are walking from a node to its input, if alloc is found that it has not escaped\n+        \/\/ at an earlier iteration, it must also be found that it has not escaped at the current\n+        \/\/ iteration\n+        assert(not_escaped_controls.member(call), \"inconsistent\");\n@@ -989,1 +993,0 @@\n-#endif \/\/ ASSERT\n@@ -991,1 +994,1 @@\n-        has_not_escaped = check_not_escaped(phase, aliases, alloc, call);\n+        has_not_escaped = check_not_escaped(phase, aliases, not_escaped_controls, alloc, call);\n@@ -1006,1 +1009,0 @@\n-#ifdef ASSERT\n@@ -1008,5 +1010,4 @@\n-        ResourceMark rm;\n-        Unique_Node_List verify_aliases;\n-        \/\/ Since we are walking from a node to its input, if alloc is found not to escape at an\n-        \/\/ earlier iteration, it must also be found not to escape at the current iteration\n-        assert(check_not_escaped(phase, verify_aliases, alloc, mem->in(0)), \"inconsistent\");\n+        \/\/ Since we are walking from a node to its input, if alloc is found that it has not escaped\n+        \/\/ at an earlier iteration, it must also be found that it has not escaped at the current\n+        \/\/ iteration\n+        assert(not_escaped_controls.member(mem->in(0)), \"inconsistent\");\n@@ -1014,1 +1015,0 @@\n-#endif \/\/ ASSERT\n@@ -1016,1 +1016,1 @@\n-        has_not_escaped = check_not_escaped(phase, aliases, alloc, mem->in(0));\n+        has_not_escaped = check_not_escaped(phase, aliases, not_escaped_controls, alloc, mem->in(0));\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":80,"deletions":80,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  static bool check_not_escaped(PhaseValues* phase, Unique_Node_List& aliases, AllocateNode* alloc, Node* ctl);\n+  static bool check_not_escaped(PhaseValues* phase, Unique_Node_List& aliases, Unique_Node_List& not_escaped_controls, AllocateNode* alloc, Node* ctl);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.function.Supplier;\n@@ -53,27 +54,3 @@\n-        TestFramework.run();\n-    }\n-\n-    @Run(test = {\"test11\", \"test12\", \"test13\", \"test14\", \"test15\", \"test16\", \"test17\", \"test18\"})\n-    public void runPositiveTests() {\n-        test11();\n-        test12(false);\n-        test12(true);\n-        test13(false);\n-        test13(true);\n-        test14();\n-        test15(1, 16);\n-        test16(1, 16, false);\n-        test16(1, 16, true);\n-        test17(0);\n-        test18(0);\n-    }\n-\n-    @Run(test = {\"test01\", \"test02\", \"test03\", \"test04\", \"test05\"})\n-    public void runNegativeTests() {\n-        test01();\n-        test02(false);\n-        test02(true);\n-        test03(false);\n-        test03(true);\n-        test04(1, 16);\n-        test05(0);\n+        var framework = new TestFramework();\n+        framework.setDefaultWarmup(1);\n+        framework.start();\n@@ -198,0 +175,34 @@\n+    static class SupplierHolder {\n+        Supplier<String> f;\n+\n+        static final Supplier<String> DEFAULT_VALUE = () -> \"test\";\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.DYNAMIC_CALL_OF_METHOD, \"get\", IRNode.LOAD_OF_FIELD, \"f\", IRNode.CLASS_CHECK_TRAP}, counts = {IRNode.ALLOC, \"1\"})\n+    public String test19() {\n+        \/\/ Folding of the load o.f allows o.f.get to get devirtualized\n+        SupplierHolder o = new SupplierHolder();\n+        o.f = SupplierHolder.DEFAULT_VALUE;\n+        escape(null);\n+        String res = o.f.get();\n+        escape(o);\n+        return res;\n+    }\n+\n+    @Run(test = {\"test11\", \"test12\", \"test13\", \"test14\", \"test15\", \"test16\", \"test17\", \"test18\", \"test19\"})\n+    public void runPositiveTests() {\n+        test11();\n+        test12(false);\n+        test12(true);\n+        test13(false);\n+        test13(true);\n+        test14();\n+        test15(1, 16);\n+        test16(1, 16, false);\n+        test16(1, 16, true);\n+        test17(0);\n+        test18(0);\n+        test19();\n+    }\n+\n@@ -258,0 +269,11 @@\n+\n+    @Run(test = {\"test01\", \"test02\", \"test03\", \"test04\", \"test05\"})\n+    public void runNegativeTests() {\n+        test01();\n+        test02(false);\n+        test02(true);\n+        test03(false);\n+        test03(true);\n+        test04(1, 16);\n+        test05(0);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestLoadFolding.java","additions":49,"deletions":27,"binary":false,"changes":76,"status":"modified"}]}