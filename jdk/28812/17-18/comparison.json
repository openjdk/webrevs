{"files":[{"patch":"@@ -62,1 +62,0 @@\n-#include \"utilities\/tribool.hpp\"\n@@ -733,2 +732,1 @@\n-  TriBool has_not_escaped = is_known_instance ? TriBool(true)\n-                                              : (is_Load() && local_ea.is_candidate() ? TriBool() : TriBool(false));\n+  bool has_not_escaped = is_known_instance;\n@@ -737,1 +735,1 @@\n-  if (is_Load() && (has_not_escaped.is_default() || has_not_escaped)) {\n+  if (is_Load() && (local_ea.is_candidate() || is_known_instance)) {\n@@ -869,1 +867,12 @@\n-      if (has_not_escaped && !is_known_instance) {\n+      if (!has_not_escaped) {\n+        if (!is_Load()) {\n+          return nullptr;\n+        }\n+\n+        LocalEA::EscapeStatus status = local_ea.check_escape_status(call);\n+        switch (status) {\n+          case LocalEA::ESCAPED:     return nullptr;\n+          case LocalEA::NOT_ESCAPED: has_not_escaped = true; break;\n+          case LocalEA::DEAD_PATH:   return phase->C->top();\n+        }\n+      } else if (!is_known_instance) {\n@@ -875,11 +884,0 @@\n-      if (has_not_escaped.is_default()) {\n-        LocalEA::EscapeStatus status = local_ea.check_escape_status(call);\n-        if (status == LocalEA::DEAD_PATH) {\n-          return phase->C->top();\n-        }\n-\n-        has_not_escaped = (status == LocalEA::NOT_ESCAPED);\n-      }\n-      if (!has_not_escaped) {\n-        break;\n-      }\n@@ -897,1 +895,13 @@\n-      if (has_not_escaped && !is_known_instance) {\n+      MemBarNode* membar = mem->in(0)->as_MemBar();\n+      if (!has_not_escaped) {\n+        if (!is_Load()) {\n+          return nullptr;\n+        }\n+\n+        LocalEA::EscapeStatus status = local_ea.check_escape_status(membar);\n+        switch (status) {\n+          case LocalEA::ESCAPED:     return nullptr;\n+          case LocalEA::NOT_ESCAPED: has_not_escaped = true; break;\n+          case LocalEA::DEAD_PATH:   return phase->C->top();\n+        }\n+      } else if (!is_known_instance) {\n@@ -901,12 +911,1 @@\n-        assert(local_ea.not_escaped_controls().member(mem->in(0)), \"inconsistent\");\n-      }\n-      if (has_not_escaped.is_default()) {\n-        LocalEA::EscapeStatus status = local_ea.check_escape_status(mem->in(0));\n-        if (status == LocalEA::DEAD_PATH) {\n-          return phase->C->top();\n-        }\n-\n-        has_not_escaped = (status == LocalEA::NOT_ESCAPED);\n-      }\n-      if (!has_not_escaped) {\n-        break;\n+        assert(local_ea.not_escaped_controls().member(membar), \"inconsistent\");\n@@ -920,1 +919,1 @@\n-      if (is_known_instance && ArrayCopyNode::may_modify(addr_t, mem->in(0)->as_MemBar(), phase, ac)) {\n+      if (is_known_instance && ArrayCopyNode::may_modify(addr_t, membar, phase, ac)) {\n@@ -1450,1 +1449,3 @@\n-  assert(is_candidate(), \"must be a candidate for escape analysis\");\n+  if (!_is_candidate) {\n+    return ESCAPED;\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":32,"deletions":31,"binary":false,"changes":63,"status":"modified"}]}