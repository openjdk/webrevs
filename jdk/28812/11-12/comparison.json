{"files":[{"patch":"@@ -47,0 +47,1 @@\n+#include \"opto\/movenode.hpp\"\n@@ -718,2 +719,3 @@\n-  TriBool has_not_escaped = is_known_instance ? TriBool(true) : (is_Load() ? TriBool() : TriBool(false));\n-  LocalEA local_ea;\n+  LocalEA local_ea(phase->is_IterGVN(), base);\n+  TriBool has_not_escaped = is_known_instance ? TriBool(true)\n+                                              : (is_Load() && local_ea.is_candidate() ? TriBool() : TriBool(false));\n@@ -778,3 +780,1 @@\n-      if (has_not_escaped && local_ea.aliases.size() > 0) {\n-        assert(!is_known_instance, \"aliases are not computed for known instances\");\n-\n+      if (has_not_escaped && !is_known_instance) {\n@@ -784,1 +784,1 @@\n-        assert(local_ea.not_escaped_controls.member(mem->in(0)), \"inconsistent\");\n+        assert(local_ea.not_escaped_controls().member(mem->in(0)), \"inconsistent\");\n@@ -789,1 +789,1 @@\n-        known_independent = !local_ea.aliases.member(st_base);\n+        known_independent = !local_ea.aliases().member(st_base);\n@@ -856,1 +856,1 @@\n-        assert(local_ea.not_escaped_controls.member(call), \"inconsistent\");\n+        assert(local_ea.not_escaped_controls().member(call), \"inconsistent\");\n@@ -859,1 +859,1 @@\n-        LocalEA::EscapeStatus status = local_ea.check_escape_status(phase, alloc, call);\n+        LocalEA::EscapeStatus status = local_ea.check_escape_status(call);\n@@ -883,1 +883,1 @@\n-        assert(local_ea.not_escaped_controls.member(mem->in(0)), \"inconsistent\");\n+        assert(local_ea.not_escaped_controls().member(mem->in(0)), \"inconsistent\");\n@@ -886,1 +886,1 @@\n-        LocalEA::EscapeStatus status = local_ea.check_escape_status(phase, alloc, mem->in(0));\n+        LocalEA::EscapeStatus status = local_ea.check_escape_status(mem->in(0));\n@@ -1352,3 +1352,70 @@\n-\/\/ Check whether an allocation has escaped at a certain control node ctl, the allocation has not\n-\/\/ escaped at ctl if there is no node that:\n-\/\/ 1. Make the allocation escape.\n+\/\/ Construct a LocalEA object that inspects a node for escape analysis. This constructor will\n+\/\/ calculate _is_candidate and _aliases.\n+MemNode::LocalEA::LocalEA(PhaseIterGVN* phase, Node* base) : _phase(phase), _is_candidate(true), _aliases(), _not_escaped_controls() {\n+  if (!DoLocalEscapeAnalysis || phase == nullptr) {\n+    _is_candidate = false;\n+    return;\n+  }\n+\n+  ciEnv* env = _phase->C->env();\n+  if (env->should_retain_local_variables() || env->jvmti_can_walk_any_space()) {\n+    \/\/ JVMTI can modify local objects, so give up\n+    _is_candidate = false;\n+  }\n+\n+  \/\/ Collect all nodes in _aliases.\n+  \/\/ Firstly, we traverse the graph from use to def, this visits all the allocations that may alias\n+  \/\/ base. Other nodes are collected as well, they are not important in this step as they should be\n+  \/\/ collected during the second step anyway.\n+  _aliases.push(base);\n+  for (uint idx = 0; idx < _aliases.size(); idx++) {\n+    Node* n = _aliases.at(idx);\n+    if (AllocateNode::Ideal_allocation(n) != nullptr) {\n+      continue;\n+    }\n+\n+    if (n->is_ConstraintCast() || n->is_DecodeN() || n->is_EncodeP()) {\n+      _aliases.push(n->in(1));\n+    } else if (n->is_Phi()) {\n+      for (uint i = 1; i < n->req(); i++) {\n+        Node* in = n->in(i);\n+        if (in != nullptr && !phase->type(in)->empty()) {\n+          _aliases.push(in);\n+        }\n+      }\n+    } else if (n->is_CMove()) {\n+      Node* if_false = n->in(CMoveNode::IfFalse);\n+      if (if_false != nullptr && !phase->type(if_false)->empty()) {\n+        _aliases.push(if_false);\n+      }\n+      Node* if_true = n->in(CMoveNode::IfTrue);\n+      if (if_true != nullptr && !phase->type(if_true)->empty()) {\n+        _aliases.push(if_true);\n+      }\n+    } else {\n+      \/\/ If base is not an allocation or a Phi of allocations (e.g. it is a Phi of an allocation\n+      \/\/ and a load, we cannot perform escape analysis). This branch is pretty conservative.\n+      _is_candidate = false;\n+      _aliases.clear();\n+      return;\n+    }\n+  }\n+\n+  \/\/ Secondly, from the set of allocations that may alias base, collect all nodes that may alias\n+  \/\/ them, they may alias base as well. Actually, there may be case that a may alias b and b may\n+  \/\/ alias c but a may not alias c, but we are conservative here.\n+  for (uint idx = 0; idx < _aliases.size(); idx++) {\n+    Node* n = _aliases.at(idx);\n+    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+      Node* out = n->fast_out(i);\n+      if (out->is_ConstraintCast() || out->is_EncodeP() || out->is_DecodeN() ||\n+          out->is_Phi() || out->is_CMove()) {\n+        _aliases.push(out);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Check whether the inspected node p has escaped at a certain control node ctl, p has not escaped\n+\/\/ at ctl if there is no node that:\n+\/\/ 1. Make p escape.\n@@ -1359,4 +1426,5 @@\n-\/\/ In other word, alloc is determined that it has not escaped at ctl if all nodes that make alloc\n-\/\/ escape have a control input that is neither nullptr, ctl, nor a transitive control input of ctl.\n-MemNode::LocalEA::EscapeStatus MemNode::LocalEA::check_escape_status(PhaseValues* phase, AllocateNode* alloc, Node* ctl) {\n-  if (phase->type(ctl) == Type::TOP) {\n+\/\/ In other word, p is determined that it has not escaped at ctl if all nodes that make p escape\n+\/\/ have a control input that is neither nullptr, ctl, nor a transitive control input of ctl.\n+MemNode::LocalEA::EscapeStatus MemNode::LocalEA::check_escape_status(Node* ctl) {\n+  assert(is_candidate(), \"must be a candidate for escape analysis\");\n+  if (_phase->type(ctl) == Type::TOP) {\n@@ -1365,9 +1433,0 @@\n-  if (!DoLocalEscapeAnalysis || !phase->is_IterGVN() || alloc == nullptr) {\n-    return ESCAPED;\n-  }\n-\n-  ciEnv* env = phase->C->env();\n-  if (env->should_retain_local_variables() || env->jvmti_can_walk_any_space()) {\n-    \/\/ JVMTI can modify local objects, so give up\n-    return ESCAPED;\n-  }\n@@ -1377,6 +1436,6 @@\n-  assert(not_escaped_controls.size() == 0, \"must not be computed yet\");\n-  Node* start = phase->C->start();\n-  not_escaped_controls.push(ctl);\n-  for (uint control_idx = 0; control_idx < not_escaped_controls.size(); control_idx++) {\n-    Node* n = not_escaped_controls.at(control_idx);\n-    assert(phase->type(n) == Type::CONTROL || phase->type(n)->base() == Type::Tuple, \"must be a control node %s\", n->Name());\n+  assert(_not_escaped_controls.size() == 0, \"must not be computed yet\");\n+  Node* start = _phase->C->start();\n+  _not_escaped_controls.push(ctl);\n+  for (uint control_idx = 0; control_idx < _not_escaped_controls.size(); control_idx++) {\n+    Node* n = _not_escaped_controls.at(control_idx);\n+    assert(_phase->type(n) == Type::CONTROL || _phase->type(n)->base() == Type::Tuple, \"must be a control node %s\", n->Name());\n@@ -1390,2 +1449,2 @@\n-        if (in != nullptr && phase->type(in) != Type::TOP) {\n-          not_escaped_controls.push(in);\n+        if (in != nullptr && _phase->type(in) != Type::TOP) {\n+          _not_escaped_controls.push(in);\n@@ -1396,2 +1455,2 @@\n-      if (in != nullptr && phase->type(in) != Type::TOP) {\n-        not_escaped_controls.push(in);\n+      if (in != nullptr && _phase->type(in) != Type::TOP) {\n+        _not_escaped_controls.push(in);\n@@ -1402,1 +1461,1 @@\n-  if (!not_escaped_controls.member(start)) {\n+  if (!_not_escaped_controls.member(start)) {\n@@ -1404,1 +1463,1 @@\n-    not_escaped_controls.clear();\n+    _not_escaped_controls.clear();\n@@ -1408,3 +1467,0 @@\n-  Node* base = alloc->result_cast();\n-  assert(base != nullptr, \"must have a result cast\");\n-\n@@ -1413,0 +1469,7 @@\n+  ResourceMark rm;\n+  \/\/ If any of these nodes escapes, then we conservatively say that the inspected node p escapes\n+  Unique_Node_List dependencies;\n+  for (uint i = 0; i < _aliases.size(); i++) {\n+    \/\/ If any node that may alias p escapes, then p escapes\n+    dependencies.push(_aliases.at(i));\n+  }\n@@ -1414,3 +1477,2 @@\n-  aliases.push(base);\n-  for (uint idx = 0; idx < aliases.size(); idx++) {\n-    Node* n = aliases.at(idx);\n+  for (uint idx = 0; idx < dependencies.size(); idx++) {\n+    Node* n = dependencies.at(idx);\n@@ -1421,3 +1483,2 @@\n-        \/\/ A node that may alias base, if any of these nodes escapes, then we conservatively say\n-        \/\/ that base escapes\n-        aliases.push(out);\n+        \/\/ A node that may alias n, if it escapes, then n escapes, which leads to p escaping\n+        dependencies.push(out);\n@@ -1427,2 +1488,2 @@\n-        \/\/ derived pointers aliases, too\n-        aliases.push(out);\n+        \/\/ derived pointers dependency, too\n+        dependencies.push(out);\n@@ -1433,1 +1494,1 @@\n-      if (c != nullptr && !not_escaped_controls.member(c)) {\n+      if (c != nullptr && !_not_escaped_controls.member(c)) {\n@@ -1444,3 +1505,26 @@\n-          \/\/ If an object is stored to memory, then it escapes\n-          res = ESCAPED;\n-          break;\n+          Node* ptr = out->in(MemNode::Address);\n+          if (ptr->is_AddP()) {\n+            Node* ptr_base = ptr->as_AddP()->base_node();\n+            if (!_phase->type(ptr_base)->isa_oopptr()) {\n+              \/\/ Maybe a store to raw memory\n+              res = ESCAPED;\n+              break;\n+            }\n+\n+            \/\/ If an object o is stored into a field of a holder h and h has not escaped, we can\n+            \/\/ say that o has not escaped, too\n+            LocalEA store_base_ea(_phase, ptr->as_AddP()->base_node());\n+            if (!store_base_ea.is_candidate()) {\n+              res = ESCAPED;\n+              break;\n+            }\n+\n+            \/\/ Push all aliases of h into dependencies, if h escapes, we will find it then\n+            for (uint i = 0; i < store_base_ea.aliases().size(); i++) {\n+              dependencies.push(store_base_ea.aliases().at(i));\n+            }\n+          } else {\n+            \/\/ Do not know into where n is stored, give up\n+            res = ESCAPED;\n+            break;\n+          }\n@@ -1479,1 +1563,1 @@\n-    not_escaped_controls.clear();\n+    _not_escaped_controls.clear();\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":139,"deletions":55,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -125,0 +125,27 @@\n+  private:\n+    PhaseIterGVN* _phase;\n+\n+    \/\/ If the node being inspected p is eligible for escape analysis. For example, if p is the\n+    \/\/ result cast of an allocation, or if it is a Phi and its inputs are the result casts of some\n+    \/\/ allocations, then it is eligible for escape analysis. On the other hand, if p is a load from\n+    \/\/ memory, or the return value of a Java call, then we cannot do escape analysis on it.\n+    bool _is_candidate;\n+\n+    \/\/ If the node being inspected p has not escaped from the compilation unit, this is the set of\n+    \/\/ all nodes that can alias p (i.e. may have the same value as p at runtime). This is the set\n+    \/\/ of all allocations that may alias p (if p is the result cast of an allocation, then that is\n+    \/\/ the only allocation that may alias p, otherwise, if p is a Phi and its inputs are the result\n+    \/\/ casts of some allocations, then those inputs may alias p) and all nodes q such that, there\n+    \/\/ is an allocation alloc such that alloc may alias p and there is a path of def-use edges from\n+    \/\/ the result cast of alloc to q consisting of ConstraintCasts, EncodePs, DecodeNs, Phis, and\n+    \/\/ CMoves.\n+    Unique_Node_List _aliases;\n+\n+    \/\/ If it is known that the node being inspected p has not escaped at a control node c1, then it\n+    \/\/ must be the case that p has not escaped at all of the transitive control inputs of c1.\n+    \/\/ Otherwise, there will be a control flow following the path from a transitive input c2 of c1\n+    \/\/ to c1 in which p has escaped at c2 but has also not escaped at a later point c1, which is\n+    \/\/ impossible. As a result, when p is determined that it has not escaped at a control node, we\n+    \/\/ record that node as well as all of its transitive control inputs here.\n+    Unique_Node_List _not_escaped_controls;\n+\n@@ -126,13 +153,5 @@\n-    \/\/ If a node p has not escaped from the compilation unit, this is the set of all nodes that can\n-    \/\/ alias p (i.e. may have the same value as p at runtime). This is the set of all nodes such\n-    \/\/ that for each of them, there is a path of def-use edges from p to it consisting of\n-    \/\/ ConstraintCasts, EncodePs, DecodeNs, Phis, CMoves, and AddPs.\n-    Unique_Node_List aliases;\n-\n-    \/\/ If it is known that a node p has not escaped at a control node c1, then it must be the case\n-    \/\/ that p has not escaped at all of the transitive control inputs of c1. Otherwise, there will\n-    \/\/ be a control flow following the path from a transitive input c2 of c1 to c1 in which p has\n-    \/\/ escaped at c2 but has also not escaped at a later point c1, which is impossible. As a\n-    \/\/ result, when p is determined that it has not escaped at a control node, we record that node\n-    \/\/ as well as all of its transitive control inputs here.\n-    Unique_Node_List not_escaped_controls;\n+    LocalEA(PhaseIterGVN* phase, Node* base);\n+\n+    bool is_candidate() const { return _is_candidate; }\n+    const Unique_Node_List& aliases() const { return _aliases; }\n+    const Unique_Node_List& not_escaped_controls() const { return _not_escaped_controls; }\n@@ -147,5 +166,3 @@\n-    LocalEA() : aliases(), not_escaped_controls() {}\n-\n-    \/\/ Check the escape status of an allocation alloc at a control node ctl. As this is called\n-    \/\/ during igvn, be prepared for non-canonical graph (dead paths, etc).\n-    EscapeStatus check_escape_status(PhaseValues* phase, AllocateNode* alloc, Node* ctl);\n+    \/\/ Check the escape status of the node being inspected p at a control node ctl. As this is\n+    \/\/ called during igvn, be prepared for non-canonical graph (dead paths, etc).\n+    EscapeStatus check_escape_status(Node* ctl);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":35,"deletions":18,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-\n@@ -30,0 +29,1 @@\n+import jdk.test.lib.Asserts;\n@@ -44,2 +44,6 @@\n-            x = 1;\n-            y = 2;\n+            this(1, 2);\n+        }\n+\n+        Point(int x, int y) {\n+            this.x = x;\n+            this.y = y;\n@@ -48,1 +52,9 @@\n-        static final Point DEFAULT = new Point();\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof Point p && x == p.x && y == p.y;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Point[\" + x + \", \" + y + \"]\";\n+        }\n@@ -51,1 +63,3 @@\n-    static Point staticField;\n+    public static class PointHolder {\n+        Point p;\n+    }\n@@ -66,1 +80,1 @@\n-    public Point test11() {\n+    public Point test101() {\n@@ -76,1 +90,1 @@\n-    public Point test12(boolean b) {\n+    public Point test102(boolean b) {\n@@ -90,2 +104,2 @@\n-    public Point test13(boolean b) {\n-        \/\/ A Phi of p1 and Point.DEFAULT, but a store to Phi is after all the loads from p1\n+    public Point test103(Point p, boolean b) {\n+        \/\/ A Phi of p1 and p, but a store to Phi is after all the loads from p1\n@@ -93,1 +107,3 @@\n-        Point p = b ? p1 : Point.DEFAULT;\n+        if (b) {\n+            p = new Point();\n+        }\n@@ -101,1 +117,1 @@\n-    public int test14() {\n+    public int test104(PointHolder h) {\n@@ -106,1 +122,1 @@\n-        staticField = p;\n+        h.p = p;\n@@ -112,1 +128,1 @@\n-    public Point test15(int begin, int end) {\n+    public Point test105(int begin, int end) {\n@@ -125,1 +141,1 @@\n-    public Point test16(int begin, int end, boolean b) {\n+    public Point test106(Point p2, int begin, int end, boolean b) {\n@@ -129,1 +145,1 @@\n-        Point.DEFAULT.y = 3;\n+        p2.y = 2;\n@@ -131,1 +147,1 @@\n-        for (int i = begin; i < end; i += 2) {\n+        for (int i = begin; i < end; i *= 2) {\n@@ -135,1 +151,1 @@\n-                p = Point.DEFAULT;\n+                p = p2;\n@@ -148,1 +164,1 @@\n-    public int test17(int idx) {\n+    public int test107(int idx) {\n@@ -162,1 +178,1 @@\n-    public int test18(int idx) {\n+    public int test108(int idx) {\n@@ -187,1 +203,1 @@\n-    public String test19() {\n+    public String test109() {\n@@ -196,0 +212,70 @@\n+    \n+    @Test\n+    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, failOn = IRNode.LOAD_I, counts = {IRNode.ALLOC, \"2\"})\n+    public int test110(PointHolder h, boolean b) {\n+        \/\/ Inspect the escape status of a Phi\n+        Point p1 = new Point();\n+        Point p2 = new Point();\n+        Point p = b ? p1 : p2;\n+        p.x = 4;\n+        escape(null);\n+        h.p = p1;\n+        return p.x;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, failOn = IRNode.LOAD_I, counts = {IRNode.ALLOC, \"2\"})\n+    public int test111(int begin, int end, boolean b) {\n+        \/\/ Inspect the escape status of a loop Phi\n+        Point p = new Point();\n+        for (int i = begin; i < end; i *= 2) {\n+            if (b) {\n+                p = new Point();\n+            }\n+        }\n+        p.x = 4;\n+        escape(null);\n+        int res = p.x;\n+        escape(p);\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, failOn = IRNode.LOAD_I, counts = {IRNode.ALLOC, \"1\"})\n+    public int test112() {\n+        \/\/ The object has been stored into memory but the destination does not escape\n+        PointHolder h = new PointHolder();\n+        Point p = new Point();\n+        h.p = p;\n+        VarHandle.fullFence();\n+        int res = p.x;\n+        escape(p);\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, failOn = IRNode.LOAD_I, counts = {IRNode.ALLOC, \"2\"})\n+    public int test113() {\n+        \/\/ The object has been stored into memory but the destination has not escaped\n+        PointHolder h = new PointHolder();\n+        Point p = new Point();\n+        h.p = p;\n+        VarHandle.fullFence();\n+        int res = p.x;\n+        escape(h);\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, failOn = IRNode.LOAD_I, counts = {IRNode.ALLOC, \"3\"})\n+    public int test114(boolean b) {\n+        \/\/ A Phi has been stored into memory but the destination has not escaped\n+        PointHolder h = new PointHolder();\n+        Point p1 = new Point();\n+        Point p2 = new Point();\n+        h.p = b ? p1 : p2;\n+        VarHandle.fullFence();\n+        int res = p1.x;\n+        escape(h);\n+        return res;\n+    }\n@@ -197,1 +283,17 @@\n-    @Run(test = {\"test11\", \"test12\", \"test13\", \"test14\", \"test15\", \"test16\", \"test17\", \"test18\", \"test19\"})\n+    @Test\n+    @IR(applyIf = {\"DoLocalEscapeAnalysis\", \"true\"}, failOn = IRNode.LOAD_I, counts = {IRNode.ALLOC, \"3\"})\n+    public int test115(boolean b) {\n+        \/\/ The object has been stored into a Phi but the destination has not escaped\n+        PointHolder h1 = new PointHolder();\n+        PointHolder h2 = new PointHolder();\n+        Point p = new Point();\n+        PointHolder h = b ? h1 : h2;\n+        h.p = p;\n+        VarHandle.fullFence();\n+        int res = p.x;\n+        escape(h1);\n+        return res;\n+    }\n+\n+    @Run(test = {\"test101\", \"test102\", \"test103\", \"test104\", \"test105\", \"test106\", \"test107\", \"test108\", \"test109\",\n+                 \"test110\", \"test111\", \"test112\", \"test113\", \"test114\", \"test115\"})\n@@ -199,12 +301,22 @@\n-        test11();\n-        test12(false);\n-        test12(true);\n-        test13(false);\n-        test13(true);\n-        test14();\n-        test15(1, 16);\n-        test16(1, 16, false);\n-        test16(1, 16, true);\n-        test17(0);\n-        test18(0);\n-        test19();\n+        Asserts.assertEQ(new Point(3, 2), test101());\n+        Asserts.assertEQ(new Point(3, 2), test102(false));\n+        Asserts.assertEQ(new Point(1, 2), test102(true));\n+        Asserts.assertEQ(new Point(3, 2), test103(new Point(), false));\n+        Asserts.assertEQ(new Point(3, 2), test103(new Point(), true));\n+        Asserts.assertEQ(3, test104(new PointHolder()));\n+        Asserts.assertEQ(new Point(7, 2), test105(1, 16));\n+        Asserts.assertEQ(new Point(2, 2), test106(new Point(), 1, 16, false));\n+        Asserts.assertEQ(new Point(5, 2), test106(new Point(), 1, 16, true));\n+        Asserts.assertEQ(4, test107(0));\n+        Asserts.assertEQ(4, test108(0));\n+        Asserts.assertEQ(\"test\", test109());\n+        Asserts.assertEQ(4, test110(new PointHolder(), false));\n+        Asserts.assertEQ(4, test110(new PointHolder(), true));\n+        Asserts.assertEQ(4, test111(1, 16, false));\n+        Asserts.assertEQ(4, test111(1, 16, true));\n+        Asserts.assertEQ(1, test112());\n+        Asserts.assertEQ(1, test113());\n+        Asserts.assertEQ(1, test114(false));\n+        Asserts.assertEQ(1, test114(true));\n+        Asserts.assertEQ(1, test115(false));\n+        Asserts.assertEQ(1, test115(true));\n@@ -215,1 +327,1 @@\n-    public int test01() {\n+    public int test001(PointHolder h) {\n@@ -217,1 +329,1 @@\n-        staticField = p;\n+        h.p = p;\n@@ -226,1 +338,1 @@\n-    public int test02(boolean b) {\n+    public int test002(boolean b) {\n@@ -240,1 +352,1 @@\n-    public int test03(boolean b) {\n+    public int test003(boolean b) {\n@@ -251,1 +363,1 @@\n-    public Point test04(int begin, int end) {\n+    public Point test004(int begin, int end) {\n@@ -263,1 +375,1 @@\n-    public int test05(int idx) {\n+    public int test005(int idx) {\n@@ -274,1 +386,79 @@\n-    @Run(test = {\"test01\", \"test02\", \"test03\", \"test04\", \"test05\"})\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I, \"1\", IRNode.ALLOC, \"1\"})\n+    public int test006(Point p, boolean b) {\n+        \/\/ A Phi with an input ineligible for escape analysis\n+        if (b) {\n+            p = new Point();\n+        }\n+        escape(null);\n+        int res = p.x;\n+        escape(p);\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I, \"1\", IRNode.ALLOC, \"2\"})\n+    public int test007(boolean b) {\n+        \/\/ A Phi that escapes because an input escapes\n+        Point p1 = new Point();\n+        Point p2 = new Point();\n+        Point p = b ? p1 : p2;\n+        escape(p1);\n+        return p.x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I, \"1\", IRNode.ALLOC, \"2\"})\n+    public int test008() {\n+        \/\/ An object is stored into another object that escapes\n+        PointHolder h = new PointHolder();\n+        Point p = new Point();\n+        h.p = p;\n+        escape(h);\n+        return p.x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I, \"1\", IRNode.ALLOC, \"2\"})\n+    public int test009(PointHolder h, boolean b) {\n+        \/\/ An object is stored into a Phi that is ineligible for escape analysis\n+        if (b) {\n+            h = new PointHolder();\n+        }\n+        Point p = new Point();\n+        h.p = p;\n+        escape(null);\n+        return p.x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I, \"1\", IRNode.ALLOC, \"3\"})\n+    public int test010(boolean b) {\n+        \/\/ An object is stored into a Phi that escapes because one of its inputs escapes\n+        PointHolder h1 = new PointHolder();\n+        PointHolder h2 = new PointHolder();\n+        PointHolder h = b ? h1 : h2;\n+        Point p = new Point();\n+        h.p = p;\n+        escape(h1);\n+        return p.x;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I, \"1\", IRNode.ALLOC, \"4\"})\n+    public int test011(boolean b1, boolean b2) {\n+        \/\/ A Phi escapes because one of its inputs is stored into a Phi, that in turn escapes\n+        \/\/ because one of its inputs escapes\n+        PointHolder h1 = new PointHolder();\n+        PointHolder h2 = new PointHolder();\n+        PointHolder h = b1 ? h1 : h2;\n+        Point p1 = new Point();\n+        Point p2 = new Point();\n+        Point p = b2 ? p1 : p2;\n+        h.p = p1;\n+        escape(h2);\n+        return p.x;\n+    }\n+\n+    @Run(test = {\"test001\", \"test002\", \"test003\", \"test004\", \"test005\", \"test006\", \"test007\", \"test008\", \"test009\",\n+                 \"test010\", \"test011\"})\n@@ -276,7 +466,20 @@\n-        test01();\n-        test02(false);\n-        test02(true);\n-        test03(false);\n-        test03(true);\n-        test04(1, 16);\n-        test05(0);\n+        Asserts.assertEQ(3, test001(new PointHolder()));\n+        Asserts.assertEQ(0, test002(false));\n+        Asserts.assertEQ(1, test002(true));\n+        Asserts.assertEQ(1, test003(false));\n+        Asserts.assertEQ(1, test003(true));\n+        Asserts.assertEQ(new Point(5, 2), test004(1, 16));\n+        Asserts.assertEQ(5, test005(0));\n+        Asserts.assertEQ(1, test006(new Point(), false));\n+        Asserts.assertEQ(1, test006(new Point(), true));\n+        Asserts.assertEQ(1, test007(false));\n+        Asserts.assertEQ(1, test007(true));\n+        Asserts.assertEQ(1, test008());\n+        Asserts.assertEQ(1, test009(new PointHolder(), false));\n+        Asserts.assertEQ(1, test009(new PointHolder(), true));\n+        Asserts.assertEQ(1, test010(false));\n+        Asserts.assertEQ(1, test010(true));\n+        Asserts.assertEQ(1, test011(false, false));\n+        Asserts.assertEQ(1, test011(false, true));\n+        Asserts.assertEQ(1, test011(true, false));\n+        Asserts.assertEQ(1, test011(true, true));\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestLoadFolding.java","additions":250,"deletions":47,"binary":false,"changes":297,"status":"modified"}]}