{"files":[{"patch":"@@ -89,128 +89,0 @@\n-\/\/ Check whether an allocation has escaped at a certain control node ctl, the allocation has not\n-\/\/ escaped at ctl if there is no node that:\n-\/\/ 1. Make the allocation escape.\n-\/\/ 2. Either:\n-\/\/   a. Has no control input.\n-\/\/   b. Has a control input that is ctl or a transitive control input of ctl.\n-\/\/\n-\/\/ In other word, alloc is determined that it has not escaped at ctl if all nodes that make alloc\n-\/\/ escape have a control input that is neither nullptr, ctl, nor a transitive control input of ctl.\n-bool MemNode::check_not_escaped(PhaseValues* phase, Unique_Node_List& aliases, Unique_Node_List& not_escaped_controls, AllocateNode* alloc, Node* ctl) {\n-  if (!phase->is_IterGVN() || alloc == nullptr || phase->type(ctl) == Type::TOP) {\n-    return false;\n-  }\n-  ciEnv* env = phase->C->env();\n-  if (env->should_retain_local_variables() || env->jvmti_can_walk_any_space()) {\n-    \/\/ JVMTI can modify local objects, so give up\n-    return false;\n-  }\n-\n-  \/\/ Find all transitive control inputs of ctl that are not dead, if it is determined that alloc\n-  \/\/ has not escaped at ctl, then it must be the case that it has not escaped at all of these\n-  assert(not_escaped_controls.size() == 0, \"must not be computed yet\");\n-  Node* start = phase->C->start();\n-  not_escaped_controls.push(ctl);\n-  for (uint control_idx = 0; control_idx < not_escaped_controls.size(); control_idx++) {\n-    Node* n = not_escaped_controls.at(control_idx);\n-    assert(phase->type(n) == Type::CONTROL || phase->type(n)->base() == Type::Tuple, \"must be a control node %s\", n->Name());\n-    if (n == start) {\n-      continue;\n-    }\n-\n-    if (n->is_Region()) {\n-      for (uint i = 1; i < n->req(); i++) {\n-        Node* in = n->in(i);\n-        if (in != nullptr && phase->type(in) != Type::TOP) {\n-          not_escaped_controls.push(in);\n-        }\n-      }\n-    } else {\n-      Node* in = n->in(0);\n-      if (in != nullptr && phase->type(in) != Type::TOP) {\n-        not_escaped_controls.push(in);\n-      }\n-    }\n-  }\n-\n-  if (!not_escaped_controls.member(start)) {\n-    \/\/ If there is no control path from ctl to start, ctl is a dead path, give up\n-    not_escaped_controls.clear();\n-    return false;\n-  }\n-\n-  Node* base = alloc->result_cast();\n-  assert(base != nullptr, \"must have a result cast\");\n-\n-  \/\/ Find all nodes that may escape alloc, and decide that it is provable that they must be\n-  \/\/ executed after ctl\n-  bool res = true;\n-  aliases.push(base);\n-  for (uint idx = 0; idx < aliases.size(); idx++) {\n-    Node* n = aliases.at(idx);\n-    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n-      Node* out = n->fast_out(i);\n-      if (out->is_ConstraintCast() || out->is_EncodeP() || out->is_DecodeN() ||\n-          out->is_Phi() || out->is_CMove()) {\n-        \/\/ A node that may alias base, if any of these nodes escapes, then we conservatively say\n-        \/\/ that base escapes\n-        aliases.push(out);\n-        continue;\n-      } else if (out->is_AddP()) {\n-        \/\/ Some runtime calls receive a derived pointer but not its base, so we consider these\n-        \/\/ derived pointers aliases, too\n-        aliases.push(out);\n-        continue;\n-      }\n-\n-      Node* c = out->in(0);\n-      if (c != nullptr && !not_escaped_controls.member(c)) {\n-        \/\/ c is not a live transitive control input of ctl, so out is not executed before ctl,\n-        \/\/ which means it does not affect the escape status of alloc at ctl\n-        continue;\n-      }\n-\n-      if (out->is_Load()) {\n-        \/\/ A Load does not escape alloc\n-      } else if (out->is_Mem()) {\n-        \/\/ A Store or a LoadStore\n-        if (n == out->in(MemNode::ValueIn)) {\n-          \/\/ If an object is stored to memory, then it escapes\n-          res = false;\n-          break;\n-        } else if (n == out->in(MemNode::Address) && (!out->is_Store() || out->as_Store()->is_mismatched_access())) {\n-          \/\/ Mismatched accesses can lie in a different alias class and are protected by memory\n-          \/\/ barriers, so we cannot be aggressive and walk past memory barriers if there is a\n-          \/\/ mismatched store into it. LoadStoreNodes are also lumped here because there is no\n-          \/\/ LoadStoreNode::is_mismatched_access.\n-          res = false;\n-          break;\n-        }\n-      } else if (out->is_Call()) {\n-        if (!out->is_AbstractLock() && out->as_Call()->has_non_debug_use(n)) {\n-          \/\/ A call that receives an object as an argument makes that object escape\n-          res = false;\n-          break;\n-        }\n-      } else if (out->is_SafePoint()) {\n-        \/\/ Non-call safepoints are pure control nodes\n-      } else if (out->Opcode() == Op_Blackhole) {\n-        \/\/ Blackhole does not escape an object (in the sense that it does not make its field values\n-        \/\/ unpredictable)\n-      } else {\n-        \/\/ Conservatively consider all other nodes to make alloc escape\n-        res = false;\n-        break;\n-      }\n-    }\n-\n-    if (!res) {\n-      break;\n-    }\n-  }\n-\n-  if (!res) {\n-    not_escaped_controls.clear();\n-  }\n-  return res;\n-}\n-\n@@ -841,1 +713,0 @@\n-  ResourceMark rm;\n@@ -844,0 +715,1 @@\n+  ResourceMark rm;\n@@ -846,9 +718,1 @@\n-  \/\/ If has_not_escaped and it is not empty, this is the set of all nodes that can alias base\n-  Unique_Node_List aliases;\n-  \/\/ If it is known that alloc has not escaped at a control node c1, then it must be the case that\n-  \/\/ alloc has not escaped at all of the transitive control inputs of the node. Otherwise, there\n-  \/\/ will be a control flow following the path from a transitive input c2 of c1 to c1 in which\n-  \/\/ alloc has escaped at c2 but has also not escaped at a later point c1, which is impossible.\n-  \/\/ As a result, when alloc is determined that it has not escaped at a control node, we record\n-  \/\/ that node as well as all of its transitive control inputs here.\n-  Unique_Node_List not_escaped_controls;\n+  LocalEA local_ea;\n@@ -913,1 +777,1 @@\n-      if (has_not_escaped && aliases.size() > 0) {\n+      if (has_not_escaped && local_ea.aliases.size() > 0) {\n@@ -919,1 +783,1 @@\n-        assert(not_escaped_controls.member(mem->in(0)), \"inconsistent\");\n+        assert(local_ea.not_escaped_controls.member(mem->in(0)), \"inconsistent\");\n@@ -924,1 +788,1 @@\n-        known_independent = !aliases.member(st_base);\n+        known_independent = !local_ea.aliases.member(st_base);\n@@ -991,1 +855,1 @@\n-        assert(not_escaped_controls.member(call), \"inconsistent\");\n+        assert(local_ea.not_escaped_controls.member(call), \"inconsistent\");\n@@ -994,1 +858,6 @@\n-        has_not_escaped = check_not_escaped(phase, aliases, not_escaped_controls, alloc, call);\n+        LocalEA::EscapeStatus status = local_ea.check_escape_status(phase, alloc, call);\n+        if (status == LocalEA::DEAD_PATH) {\n+          return phase->C->top();\n+        }\n+\n+        has_not_escaped = (status == LocalEA::NOT_ESCAPED);\n@@ -1013,1 +882,1 @@\n-        assert(not_escaped_controls.member(mem->in(0)), \"inconsistent\");\n+        assert(local_ea.not_escaped_controls.member(mem->in(0)), \"inconsistent\");\n@@ -1016,1 +885,6 @@\n-        has_not_escaped = check_not_escaped(phase, aliases, not_escaped_controls, alloc, mem->in(0));\n+        LocalEA::EscapeStatus status = local_ea.check_escape_status(phase, alloc, mem->in(0));\n+        if (status == LocalEA::DEAD_PATH) {\n+          return phase->C->top();\n+        }\n+\n+        has_not_escaped = (status == LocalEA::NOT_ESCAPED);\n@@ -1477,0 +1351,132 @@\n+\/\/ Check whether an allocation has escaped at a certain control node ctl, the allocation has not\n+\/\/ escaped at ctl if there is no node that:\n+\/\/ 1. Make the allocation escape.\n+\/\/ 2. Either:\n+\/\/   a. Has no control input.\n+\/\/   b. Has a control input that is ctl or a transitive control input of ctl.\n+\/\/\n+\/\/ In other word, alloc is determined that it has not escaped at ctl if all nodes that make alloc\n+\/\/ escape have a control input that is neither nullptr, ctl, nor a transitive control input of ctl.\n+MemNode::LocalEA::EscapeStatus MemNode::LocalEA::check_escape_status(PhaseValues* phase, AllocateNode* alloc, Node* ctl) {\n+  if (phase->type(ctl) == Type::TOP) {\n+    return DEAD_PATH;\n+  }\n+  if (!phase->is_IterGVN() || alloc == nullptr) {\n+    return ESCAPED;\n+  }\n+\n+  ciEnv* env = phase->C->env();\n+  if (env->should_retain_local_variables() || env->jvmti_can_walk_any_space()) {\n+    \/\/ JVMTI can modify local objects, so give up\n+    return ESCAPED;\n+  }\n+\n+  \/\/ Find all transitive control inputs of ctl that are not dead, if it is determined that alloc\n+  \/\/ has not escaped at ctl, then it must be the case that it has not escaped at all of these\n+  assert(not_escaped_controls.size() == 0, \"must not be computed yet\");\n+  Node* start = phase->C->start();\n+  not_escaped_controls.push(ctl);\n+  for (uint control_idx = 0; control_idx < not_escaped_controls.size(); control_idx++) {\n+    Node* n = not_escaped_controls.at(control_idx);\n+    assert(phase->type(n) == Type::CONTROL || phase->type(n)->base() == Type::Tuple, \"must be a control node %s\", n->Name());\n+    if (n == start) {\n+      continue;\n+    }\n+\n+    if (n->is_Region()) {\n+      for (uint i = 1; i < n->req(); i++) {\n+        Node* in = n->in(i);\n+        if (in != nullptr && phase->type(in) != Type::TOP) {\n+          not_escaped_controls.push(in);\n+        }\n+      }\n+    } else {\n+      Node* in = n->in(0);\n+      if (in != nullptr && phase->type(in) != Type::TOP) {\n+        not_escaped_controls.push(in);\n+      }\n+    }\n+  }\n+\n+  if (!not_escaped_controls.member(start)) {\n+    \/\/ If there is no control path from ctl to start, ctl is a dead path, give up\n+    not_escaped_controls.clear();\n+    return DEAD_PATH;\n+  }\n+\n+  Node* base = alloc->result_cast();\n+  assert(base != nullptr, \"must have a result cast\");\n+\n+  \/\/ Find all nodes that may escape alloc, and decide that it is provable that they must be\n+  \/\/ executed after ctl\n+  EscapeStatus res = NOT_ESCAPED;\n+  aliases.push(base);\n+  for (uint idx = 0; idx < aliases.size(); idx++) {\n+    Node* n = aliases.at(idx);\n+    for (DUIterator_Fast imax, i = n->fast_outs(imax); i < imax; i++) {\n+      Node* out = n->fast_out(i);\n+      if (out->is_ConstraintCast() || out->is_EncodeP() || out->is_DecodeN() ||\n+          out->is_Phi() || out->is_CMove()) {\n+        \/\/ A node that may alias base, if any of these nodes escapes, then we conservatively say\n+        \/\/ that base escapes\n+        aliases.push(out);\n+        continue;\n+      } else if (out->is_AddP()) {\n+        \/\/ Some runtime calls receive a derived pointer but not its base, so we consider these\n+        \/\/ derived pointers aliases, too\n+        aliases.push(out);\n+        continue;\n+      }\n+\n+      Node* c = out->in(0);\n+      if (c != nullptr && !not_escaped_controls.member(c)) {\n+        \/\/ c is not a live transitive control input of ctl, so out is not executed before ctl,\n+        \/\/ which means it does not affect the escape status of alloc at ctl\n+        continue;\n+      }\n+\n+      if (out->is_Load()) {\n+        \/\/ A Load does not escape alloc\n+      } else if (out->is_Mem()) {\n+        \/\/ A Store or a LoadStore\n+        if (n == out->in(MemNode::ValueIn)) {\n+          \/\/ If an object is stored to memory, then it escapes\n+          res = ESCAPED;\n+          break;\n+        } else if (n == out->in(MemNode::Address) && (!out->is_Store() || out->as_Store()->is_mismatched_access())) {\n+          \/\/ Mismatched accesses can lie in a different alias class and are protected by memory\n+          \/\/ barriers, so we cannot be aggressive and walk past memory barriers if there is a\n+          \/\/ mismatched store into it. LoadStoreNodes are also lumped here because there is no\n+          \/\/ LoadStoreNode::is_mismatched_access.\n+          res = ESCAPED;\n+          break;\n+        }\n+      } else if (out->is_Call()) {\n+        if (!out->is_AbstractLock() && out->as_Call()->has_non_debug_use(n)) {\n+          \/\/ A call that receives an object as an argument makes that object escape\n+          res = ESCAPED;\n+          break;\n+        }\n+      } else if (out->is_SafePoint()) {\n+        \/\/ Non-call safepoints are pure control nodes\n+      } else if (out->Opcode() == Op_Blackhole) {\n+        \/\/ Blackhole does not escape an object (in the sense that it does not make its field values\n+        \/\/ unpredictable)\n+      } else {\n+        \/\/ Conservatively consider all other nodes to make alloc escape\n+        res = ESCAPED;\n+        break;\n+      }\n+    }\n+\n+    if (res == ESCAPED) {\n+      break;\n+    }\n+  }\n+\n+  if (res == ESCAPED) {\n+    not_escaped_controls.clear();\n+  }\n+  return res;\n+}\n+\n@@ -2173,0 +2179,3 @@\n+  if (prev_mem != nullptr && prev_mem->is_top()) {\n+    return prev_mem;\n+  }\n@@ -3772,0 +3781,3 @@\n+      if (prev_mem != nullptr && prev_mem->is_top()) {\n+        return prev_mem;\n+      }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":157,"deletions":145,"binary":false,"changes":302,"status":"modified"},{"patch":"@@ -95,0 +95,59 @@\n+  \/\/ During igvn, in order to reason about the state of the memory a MemNode accesses, we can\n+  \/\/ inspect the escape status of that memory. A memory location is said to escape the compilation\n+  \/\/ unit if it is made visible outside the compilation unit, which is equivalent to the object\n+  \/\/ containing that memory visible outside the compilation unit. An object is in the not-escaped\n+  \/\/ state when it is just allocated, and stay so until its reference or a derived pointer of its\n+  \/\/ is stored into the memory, passed into a method invocation, or used as an input to a node we\n+  \/\/ do not know.\n+  \/\/\n+  \/\/ If an object has not escaped, it cannot be modified during a method invocation, and the\n+  \/\/ reordering of memory accesses into it is invisible to other threads. As a result, to find the\n+  \/\/ value that is stored at one of its fields, we can aggressively walk the memory graph past\n+  \/\/ CallNodes and MemBarNodes, this gives a much better chance to fold a load or a store.\n+  \/\/\n+  \/\/ This analysis is local, which means it only inspects a small part of the graph to determine\n+  \/\/ the escape status of an object. It is context-aware, which means it does not just try to find\n+  \/\/ a global escape status of an object, but it also tries to determine which node must observe\n+  \/\/ that the object has escaped. If an access into an object does not observe that the object has\n+  \/\/ escaped, it can try folding aggressively even though the object may escape afterwards.\n+  \/\/\n+  \/\/ It can be proved that if a node must observe that an object has escaped, then there is a path\n+  \/\/ of use-def edges from that node to the node which makes the object escape. This approach,\n+  \/\/ however, requires a global analysis as we need to walk the whole graph. As a result, we go for\n+  \/\/ a more conservative approach which inspects only the control subgraph of the IR graph. See\n+  \/\/ check_escape_status below.\n+  \/\/\n+  \/\/ Perform this local analysis during igvn has the advantage that it allows the folding to happen\n+  \/\/ earlier, before incremental inlining. This means that devirtualized method invocations can get\n+  \/\/ inlined. On the other hand, if the folding happens during the escape analysis phase, inlining\n+  \/\/ is already over.\n+  class LocalEA {\n+  public:\n+    \/\/ If a node p has not escaped from the compilation unit, this is the set of all nodes that can\n+    \/\/ alias p (i.e. may have the same value as p at runtime). This is the set of all nodes such\n+    \/\/ that for each of them, there is a path of def-use edges from p to it consisting of\n+    \/\/ ConstraintCasts, EncodePs, DecodeNs, Phis, CMoves, and AddPs.\n+    Unique_Node_List aliases;\n+\n+    \/\/ If it is known that a node p has not escaped at a control node c1, then it must be the case\n+    \/\/ that p has not escaped at all of the transitive control inputs of c1. Otherwise, there will\n+    \/\/ be a control flow following the path from a transitive input c2 of c1 to c1 in which p has\n+    \/\/ escaped at c2 but has also not escaped at a later point c1, which is impossible. As a\n+    \/\/ result, when p is determined that it has not escaped at a control node, we record that node\n+    \/\/ as well as all of its transitive control inputs here.\n+    Unique_Node_List not_escaped_controls;\n+\n+    \/\/ The result of the analysis whether an object has escaped at a control node\n+    enum EscapeStatus {\n+      ESCAPED,\n+      NOT_ESCAPED,\n+      DEAD_PATH\n+    };\n+\n+    LocalEA() : aliases(), not_escaped_controls() {}\n+\n+    \/\/ Check the escape status of an allocation alloc at a control node ctl. As this is called\n+    \/\/ during igvn, be prepared for non-canonical graph (dead paths, etc).\n+    EscapeStatus check_escape_status(PhaseValues* phase, AllocateNode* alloc, Node* ctl);\n+  };\n+\n@@ -98,1 +157,0 @@\n-  static bool check_not_escaped(PhaseValues* phase, Unique_Node_List& aliases, Unique_Node_List& not_escaped_controls, AllocateNode* alloc, Node* ctl);\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"}]}