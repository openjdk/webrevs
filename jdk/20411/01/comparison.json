{"files":[{"patch":"@@ -60,0 +60,2 @@\n+bool Arena::use_pool = false;\n+\n@@ -103,0 +105,2 @@\n+    if (!Arena::use_pool)\n+      return nullptr;\n@@ -105,0 +109,1 @@\n+        Atomic::inc(&usage[i]);\n@@ -112,0 +117,7 @@\n+  static size_t usage[_num_pools];\n+  static void report_usage() {\n+    for (size_t i = 0; i < _num_pools; i++) {\n+      tty->print_cr(\"pool \" SIZE_FORMAT \", used count: \" SIZE_FORMAT, i, usage[i]);\n+      usage[i] = 0;\n+    }\n+  }\n@@ -184,0 +196,1 @@\n+size_t ChunkPool::usage[] = { 0, 0, 0, 0};\n@@ -225,6 +238,6 @@\n-Arena::Arena(MEMFLAGS flag, Tag tag, size_t init_size) :\n-  _flags(flag), _tag(tag),\n-  _size_in_bytes(0),\n-  _first(nullptr), _chunk(nullptr),\n-  _hwm(nullptr), _max(nullptr)\n-{\n+\n+void Arena::report_usage() {\n+  ChunkPool::report_usage();\n+}\n+\n+Arena::Arena(MEMFLAGS flag, Tag tag, size_t init_size) : _flags(flag), _tag(tag), _size_in_bytes(0)  {\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -139,0 +139,2 @@\n+  static bool use_pool;\n+  static void report_usage();\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"concurrentTestRunner.inline.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -30,0 +32,1 @@\n+#include \"utilities\/fastrand.hpp\"\n@@ -385,0 +388,95 @@\n+\n+struct X : public TestRunnable {\n+  static volatile unsigned result;\n+  static FastRandom frand;\n+  static size_t total_alloc_dur;\n+  static size_t total_free_dur;\n+\n+  const int N = 1000;\n+  const size_t K = 1024;\n+  size_t chunks[10] = {32 * K, 16 * K, 8 * K, 4 * K, 2 * K, 1 * K, 512, 256, 128, 64};\n+  typedef struct {\n+    char* ptr;\n+    size_t size;\n+  } MemEntry;\n+  void runUnitTest() const override {\n+    ResourceMark rm;\n+    double dur;\n+    GrowableArray<MemEntry> entries(N);\n+    for (int n = 0; n < N; n++) {\n+      entries.push(MemEntry { nullptr, 0 });\n+    }\n+    size_t alloc_dur = 0;\n+    size_t free_dur = 0;\n+    int free_count = 0;\n+    while (free_count < N) {\n+      int i = frand.next() % N;\n+      MemEntry& entry = entries.at(i);\n+      bool do_alloc = entry.size == 0;\n+      bool do_free = !do_alloc;\n+\n+      if (do_alloc) {\n+        size_t size = chunks[i % 10];\n+        dur = os::elapsedTime();\n+        entry.ptr = NEW_RESOURCE_ARRAY(char, size);\n+        entry.size = size;\n+        alloc_dur += (os::elapsedTime() - dur) * 1000000;\n+      }\n+      if (do_free) {\n+        if (entry.ptr != nullptr) {\n+          dur = os::elapsedTime();\n+          FREE_RESOURCE_ARRAY(char, entry.ptr, entry.size);\n+          free_dur += (os::elapsedTime() - dur) * 1000000;\n+          entry.ptr = nullptr;\n+          free_count++;\n+        }\n+      }\n+    }\n+    Atomic::add(&total_alloc_dur, alloc_dur);\n+    Atomic::add(&total_free_dur, free_dur);\n+\n+  }\n+  static void report(const char *s) {\n+    tty->print_cr(\"Total time, %s, alloc: \" SIZE_FORMAT \", free: \" SIZE_FORMAT, s,\n+                  total_alloc_dur \/ 1000000,\n+                  total_free_dur \/ 1000000);\n+    total_alloc_dur = 0;\n+    total_free_dur = 0;\n+    Arena::report_usage();\n+  }\n+};\n+\n+ volatile unsigned X::result = 0;\n+ FastRandom X::frand;\n+ size_t X::total_alloc_dur = 0;\n+ size_t X::total_free_dur = 0;\n+\n+\n+TEST_VM(Arena, speed_and_memory_compare) {\n+  X x;\n+  ConcurrentTestRunner runner(&x, 100, 5000);\n+  const int N = 5;\n+  ssize_t rss[2][N];\n+\n+  for (bool pool : { false, true }) {\n+    for (int i = 0; i < N; i++) {\n+      Arena::use_pool = pool;\n+\n+      os::Linux::meminfo_t minfo_before;\n+      os::Linux::query_process_memory_info(&minfo_before);\n+\n+      runner.run();\n+\n+      os::Linux::meminfo_t minfo_after;\n+      os::Linux::query_process_memory_info(&minfo_after);\n+\n+      rss[pool ? 1 : 0][i] = minfo_after.vmrss - minfo_before.vmrss;\n+\n+      const char* pool_text = pool ? \"with pool\" : \"  no pool\";\n+      X::report(pool_text);\n+    }\n+  }\n+  for (int i = 0; i < N; i++) {\n+    tty->print_cr(\"\\nRSS(KB): no-pool= \" SSIZE_FORMAT \", pool= \" SSIZE_FORMAT \", diff=\" SSIZE_FORMAT \"\\n\", rss[0][i], rss[1][i], rss[0][i] - rss[1][i]);\n+  }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/gtest\/memory\/test_arena.cpp","additions":98,"deletions":0,"binary":false,"changes":98,"status":"modified"}]}