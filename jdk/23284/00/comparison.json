{"files":[{"patch":"@@ -3775,0 +3775,12 @@\n+  \/\/ True branch, pin count over\/underflow.\n+  Node* pin_count_over_underflow = _gvn.transform(new IfTrueNode(iff_pin_count_over_underflow));\n+  {\n+    \/\/ Trap (but not deoptimize (Action_none)) and continue in the interpreter\n+    \/\/ which will throw IllegalStateException for pin count over\/underflow.\n+    PreserveJVMState pjvms(this);\n+    set_control(pin_count_over_underflow);\n+    uncommon_trap(Deoptimization::Reason_intrinsic,\n+                  Deoptimization::Action_none);\n+    assert(stopped(), \"invariant\");\n+  }\n+\n@@ -3786,14 +3798,1 @@\n-  Node* updated_pin_count_memory = store_to_memory(control(), pin_count_offset, next_pin_count, T_INT, MemNode::unordered);\n-\n-  \/\/ True branch, pin count over\/underflow.\n-  Node* pin_count_over_underflow = _gvn.transform(new IfTrueNode(iff_pin_count_over_underflow));\n-  {\n-    \/\/ Trap (but not deoptimize (Action_none)) and continue in the interpreter\n-    \/\/ which will throw IllegalStateException for pin count over\/underflow.\n-    PreserveJVMState pjvms(this);\n-    set_control(pin_count_over_underflow);\n-    set_all_memory(input_memory_state);\n-    uncommon_trap_exact(Deoptimization::Reason_intrinsic,\n-                        Deoptimization::Action_none);\n-    assert(stopped(), \"invariant\");\n-  }\n+  store_to_memory(control(), pin_count_offset, next_pin_count, T_INT, MemNode::unordered);\n@@ -3809,1 +3808,1 @@\n-  result_mem->init_req(_true_path, _gvn.transform(updated_pin_count_memory));\n+  result_mem->init_req(_true_path, _gvn.transform(reset_memory()));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8347997\n+ * @summary Test that Cintinuation.pin() and unpin() intrinsics work with EA.\n+ * @run main\/othervm --add-opens=java.base\/jdk.internal.vm=ALL-UNNAMED\n+ *      TestContinuationPinningAndEA\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+public class TestContinuationPinningAndEA {\n+  public static final MethodHandle pin;\n+  public static final MethodHandle unpin;\n+\n+  static {\n+    try {\n+      MethodHandles.Lookup lookup = MethodHandles.lookup();\n+      Class<?> Continuation = lookup.findClass(\"jdk.internal.vm.Continuation\");\n+      pin = lookup.findStatic(Continuation, \"pin\", MethodType.methodType(void.class));\n+      unpin = lookup.findStatic(Continuation, \"unpin\", MethodType.methodType(void.class));\n+    } catch (Throwable e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  static class FailsEA {\n+    final Object o;\n+\n+    public FailsEA() throws Throwable {\n+      o = new Object();\n+      pin.invokeExact();\n+      unpin.invokeExact();\n+    }\n+  }\n+\n+  static class Crashes {\n+    final Object o;\n+\n+    public Crashes() throws Throwable {\n+      pin.invokeExact();\n+      unpin.invokeExact();\n+      o = new Object();\n+    }\n+  }\n+\n+  static void test_FailsEA() throws Throwable {\n+    for (int i = 0; i < 10_000; ++i) {\n+      new FailsEA();\n+    }\n+  }\n+\n+  static void test_Crashes() throws Throwable {\n+    for (int i = 0; i < 10_000; ++i) {\n+      new Crashes();\n+    }\n+  }\n+\n+  public static void main(String[] args) throws Throwable {\n+    int iterations = 100;\n+    for (int i = 0; i < iterations; ++i) {\n+      test_FailsEA();\n+    }\n+    for (int i = 0; i < iterations; ++i) {\n+      test_Crashes();\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestContinuationPinningAndEA.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}