{"files":[{"patch":"@@ -1058,1 +1058,0 @@\n-    static final int INVALID_ID       = 0x4000;   \/\/ unused external queue id\n@@ -1196,1 +1195,1 @@\n-        int dropOnEmptyScan;       \/\/ nonzero if trimmable\n+        int trimStatus;            \/\/ <0: drop on empty scan; >0 dropped, else 0\n@@ -1303,1 +1302,1 @@\n-            --top;    \/\/ back out\n+            U.putIntOpaque(this, TOP, top - 1); \/\/ backout\n@@ -1787,1 +1786,1 @@\n-        if (w == null || w.source != DROPPED) {\n+        if (w == null || w.trimStatus <= 0) {\n@@ -1808,1 +1807,1 @@\n-            phase != 0 && w != null && w.source != DROPPED) {\n+            phase != 0 && w != null && w.trimStatus <= 0) {\n@@ -1825,2 +1824,2 @@\n-        int pc = parallelism, i, sp; \/\/ rely on caller sync for initial reads\n-        long c = U.getLong(this, CTL);\n+        int pc = parallelism, i, sp;\n+        long c = ctl;\n@@ -1851,1 +1850,1 @@\n-             if (src != null && src.base - base > 0)\n+            if (src != null && src.base - base > 0)\n@@ -1946,1 +1945,1 @@\n-                            int b, nb; long bp, np, ps; ForkJoinTask<?> t;\n+                            int b, nb; long bp, np; ForkJoinTask<?> t;\n@@ -1959,1 +1958,1 @@\n-                                if (taken == 0)\n+                                if (src < 0)\n@@ -1964,3 +1963,3 @@\n-                                    if (ran != 0)         \/\/ end run on this queue\n-                                        break scan;\n-                                    if (nt == null)       \/\/ probably empty\n+                                    if (nt == null) {     \/\/ probably empty\n+                                        if (ran != 0)     \/\/ end run on this queue\n+                                            break scan;\n@@ -1968,0 +1967,1 @@\n+                                    }\n@@ -1973,3 +1973,8 @@\n-                                nt = U.getReference(a, np);\n-                                U.getAndSetInt(q, WorkQueue.BASE, nb);\n-                                if (qid != (ps = src))\n+                                Object rnt = U.getReference(a, np); \/\/ reread\n+                                U.getAndSetInt(q, WorkQueue.BASE, pb = nb);\n+                                boolean propagate = rnt != null &&\n+                                    (qid != src ||\n+                                     ((qid & 1) == 0 && (fifo != 0 || taken == 0)));\n+                                ran = 1;\n+                                ++taken;\n+                                if (qid != src)\n@@ -1977,6 +1982,2 @@\n-                                if (nt != null &&\n-                                    (qid != ps ||\n-                                     ((qid & 1) == 0 && (fifo != 0 || taken == 0))) &&\n-                                    U.getReferenceAcquire(a, np) != null)\n-                                    signalWork(q, nb);    \/\/ propagate\n-                                ran = ++taken;\n+                                if (propagate && U.getReferenceAcquire(a, np) != null)\n+                                    signalWork(q, nb);\n@@ -1988,2 +1989,2 @@\n-                        if (idle == 0) {\n-                            idle = tryDeactivate(w, taken);\n+                        if (taken != 0) {\n+                            w.nsteals += taken;\n@@ -1992,1 +1993,3 @@\n-                        else if ((idle = awaitWork(w)) != 0)\n+                        else if (idle == 0)\n+                            idle = tryDeactivate(w);\n+                        else if ((idle = awaitWork(w, src)) != 0)\n@@ -2004,1 +2007,1 @@\n-     * Possibly deactivates or pauses worker\n+     * Possibly deactivates worker\n@@ -2007,1 +2010,0 @@\n-     * @param taken number of tasks taken since last activate\n@@ -2010,1 +2012,1 @@\n-    private int tryDeactivate(WorkQueue w, int taken) {\n+    private int tryDeactivate(WorkQueue w) {\n@@ -2012,26 +2014,16 @@\n-        if (w != null) {                           \/\/ always true; hoist checks\n-            if (taken != 0) {                      \/\/ rescan before deactivating\n-                w.nsteals += taken;\n-                if ((w.config & CLEAR_TLS) != 0 &&\n-                    (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n-                    f.resetThreadLocals();         \/\/ (instanceof check always true)\n-                if ((runState & (SHUTDOWN|STOP)) == 0L)\n-                    Thread.yield();                \/\/ pause before rescan\n-            }\n-            else {\n-                int phase = U.getInt(w, WorkQueue.PHASE);\n-                long sp = (phase + NEXTIDLE) & LMASK, pc = ctl;\n-                U.putInt(w, WorkQueue.PHASE, phase | IDLE);\n-                for (;;) {                         \/\/ enqueue\n-                    w.stackPred = (int)pc;\n-                    long c = (pc - RC_UNIT) & UMASK | sp, ac = c & RC_MASK;\n-                    if (pc == (pc = U.compareAndExchangeLong(this, CTL, pc, c))) {\n-                        if (ac == 0L && (runState & (SHUTDOWN|STOP)) == SHUTDOWN)\n-                            quiescent();           \/\/ check quiescent termination\n-                        idle = w.phase & IDLE;\n-                        break;\n-                    }\n-                    else if (ac < (pc & RC_MASK)) {\n-                        w.phase = phase;           \/\/ back out if lost to signal\n-                        break;\n-                    }\n+        if (w != null) {                       \/\/ always true; hoist checks\n+            int phase = U.getInt(w, WorkQueue.PHASE);\n+            long sp = (phase + NEXTIDLE) & LMASK, pc = ctl;\n+            U.putInt(w, WorkQueue.PHASE, phase | IDLE);\n+            for (;;) {                         \/\/ enqueue\n+                w.stackPred = (int)pc;\n+                long c = (pc - RC_UNIT) & UMASK | sp, ac = c & RC_MASK;\n+                if (pc == (pc = U.compareAndExchangeLong(this, CTL, pc, c))) {\n+                    if (ac == 0L && (runState & (SHUTDOWN|STOP)) == SHUTDOWN)\n+                        quiescent();           \/\/ check quiescent termination\n+                    idle = w.phase & IDLE;\n+                    break;\n+                }\n+                else if (ac < (pc & RC_MASK)) {\n+                    w.phase = phase;           \/\/ back out if lost to signal\n+                    break;\n@@ -2071,1 +2063,1 @@\n-    private int awaitWork(WorkQueue w) {\n+    private int awaitWork(WorkQueue w, int src) {\n@@ -2074,0 +2066,1 @@\n+            ForkJoinWorkerThread t;\n@@ -2075,2 +2068,4 @@\n-            if ((trim = w.dropOnEmptyScan) != 0)\n-                w.dropOnEmptyScan = 0;\n+            if ((trim = w.trimStatus) != 0)\n+                w.trimStatus = 0;\n+            if (src >= 0 && (w.config & CLEAR_TLS) != 0 && (t = w.owner) != null)\n+                t.resetThreadLocals();        \/\/ clear before reactivate\n@@ -2081,1 +2076,1 @@\n-                boolean trimmable = false;\n+                boolean trimmable = false;    \/\/ true if at head of ctl and quiescent\n@@ -2083,15 +2078,10 @@\n-                int ac = (short)((c = ctl) >>> RC_SHIFT);\n-                int spins = ((short)(c >>> TC_SHIFT) | 1) & SMASK; \/\/ >= # workers\n-                if ((int)c == activePhase) { \/\/ at head of ctl\n-                    spins += Math.max(spins << 1, SPIN_WAITS); \/\/ approx 1 scan cost\n-                    if (ac == 0) {           \/\/ quiescent\n-                        long now = System.currentTimeMillis();\n-                        if (deadline == 0L)\n-                            d = deadline = now + keepAlive;\n-                        else if ((d = deadline) - now <= TIMEOUT_SLOP)\n-                            trim = 1;\n-                        if (trim != 0 && tryTrim(w, c, activePhase))\n-                            break;\n-                        trim = 0;\n-                        trimmable = true;\n-                    }\n+                if (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase) {\n+                    long now = System.currentTimeMillis();\n+                    if (deadline == 0L)\n+                        d = deadline = now + keepAlive;\n+                    else if ((d = deadline) - now <= TIMEOUT_SLOP)\n+                        trim = 1;\n+                    if (trim != 0 && tryTrim(w, c, activePhase))\n+                        break;\n+                    trim = 0;\n+                    trimmable = true;\n@@ -2099,0 +2089,2 @@\n+                int tc = ((short)(c >>> TC_SHIFT) | 1) & SMASK; \/\/ >= # workers\n+                int spins = tc + Math.max(tc << 1, SPIN_WAITS);\n@@ -2100,1 +2092,1 @@\n-                    Thread.onSpinWait();\n+                    Thread.onSpinWait();      \/\/ spin for approx 1 scan cost\n@@ -2127,1 +2119,1 @@\n-                w.source = DROPPED;\n+                w.trimStatus = 1;\n@@ -2134,1 +2126,1 @@\n-                    v.dropOnEmptyScan = 1;\n+                    v.trimStatus = -1;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":68,"deletions":76,"binary":false,"changes":144,"status":"modified"}]}