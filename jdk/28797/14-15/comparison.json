{"files":[{"patch":"@@ -1196,1 +1196,1 @@\n-        \/\/ Support for atomic operations (also used by ForkJoinPool)\n+        \/\/ Support for atomic operations\n@@ -1198,4 +1198,14 @@\n-        static final long PHASE;\n-        static final long BASE;\n-        static final long TOP;\n-        static final long ARRAY;\n+        private static final long PHASE;\n+        private static final long BASE;\n+        private static final long TOP;\n+        private static final long ARRAY;\n+\n+        final void getAndSetBase(int v) {\n+            U.getAndSetInt(this, BASE, v);\n+        }\n+        final void setPhasePlain(int v) {\n+            U.putInt(this, PHASE, v);\n+        }\n+        final int getPhasePlain() {\n+            return U.getInt(this, PHASE);\n+        }\n@@ -1299,14 +1309,3 @@\n-         * Takes next task, if one exists, in lifo order.\n-         *\/\n-        private ForkJoinTask<?> localPop() {\n-            ForkJoinTask<?> t = null;\n-            int s = top - 1, cap; long k; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0 &&\n-                U.getReference(a, k = slotOffset((cap - 1) & s)) != null &&\n-                (t = (ForkJoinTask<?>)U.getAndSetReference(a, k, null)) != null)\n-                U.putIntOpaque(this, TOP, s);\n-            return t;\n-        }\n-\n-        \/**\n-         * Takes next task, if one exists, in fifo order.\n+         * Takes next task, if one exists, in order specified by mode,\n+         * so acts as either local-pop or local-poll. Called only by owner.\n+         * @param fifo nonzero if FIFO mode\n@@ -1314,1 +1313,1 @@\n-        private ForkJoinTask<?> localPoll() {\n+        private ForkJoinTask<?> nextLocalTask(int fifo) {\n@@ -1316,6 +1315,17 @@\n-            int p = top, cap; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0) {\n-                for (int b = base; p - b > 0; ) {\n-                    int nb = b + 1;\n-                    long k = slotOffset((cap - 1) & b);\n-                    if (U.getReference(a, k) == null) {\n+            ForkJoinTask<?>[] a = array;\n+            int b = base, p = top, cap;\n+            if (a != null && (cap = a.length) > 0) {\n+                if (fifo == 0) {\n+                    int s = p - 1; long k;\n+                    if (U.getReference(a, k = slotOffset((cap - 1) & s)) != null &&\n+                        (t = (ForkJoinTask<?>)U.getAndSetReference(\n+                            a, k, null)) != null)\n+                        top = s;\n+                } else {\n+                    while (p - b > 0) {\n+                        int nb = b + 1;\n+                        if ((t = (ForkJoinTask<?>)U.getAndSetReference(\n+                                 a, slotOffset((cap - 1) & b), null)) != null) {\n+                            base = nb;\n+                            break;\n+                        }\n@@ -1323,1 +1333,1 @@\n-                            break;          \/\/ else base is lagging\n+                            break;\n@@ -1325,6 +1335,1 @@\n-                            Thread.onSpinWait(); \/\/ spin to reduce memory traffic\n-                    }\n-                    else if ((t = (ForkJoinTask<?>)\n-                              U.getAndSetReference(a, k, null)) != null) {\n-                        U.putIntOpaque(this, BASE, nb);\n-                        break;\n+                            Thread.onSpinWait();\n@@ -1332,2 +1337,0 @@\n-                    else\n-                        b = base;\n@@ -1343,1 +1346,3 @@\n-            return (config & FIFO) == 0 ? localPop() : localPoll();\n+            ForkJoinTask<?> t= nextLocalTask(config & FIFO);\n+            U.storeStoreFence(); \/\/ ensure ordering for external callers\n+            return t;\n@@ -1424,25 +1429,1 @@\n-                task = null;\n-                int p = top, cap; ForkJoinTask<?>[] a;\n-                if ((a = array) == null || (cap = a.length) <= 0)\n-                    break;        \/\/ currently impossible\n-                if (fifo == 0) {  \/\/ specialized localPop\n-                    int s = p - 1; long k;\n-                    if (U.getReference(\n-                            a, k = slotOffset((cap - 1) & s)) != null &&\n-                        (task = (ForkJoinTask<?>)\n-                         U.getAndSetReference(a, k, null)) != null)\n-                        top = s;\n-                } else {          \/\/ specialized localPoll\n-                    for (int b = base; p - b > 0; ) {\n-                        int nb = b + 1;\n-                        if ((task = (ForkJoinTask<?>)U.getAndSetReference(\n-                                 a, slotOffset((cap - 1) & b), null)) != null) {\n-                            base = nb;\n-                            break;\n-                        }\n-                        if (nb == p)\n-                            break;\n-                        while (b == (b = U.getIntAcquire(this, BASE)))\n-                            Thread.onSpinWait();\n-                    }\n-                }\n+                task = nextLocalTask(fifo);\n@@ -1580,1 +1561,1 @@\n-            for (ForkJoinTask<?> t; (t = localPop()) != null; ) {\n+            for (ForkJoinTask<?> t; (t = nextLocalTask(0)) != null; ) {\n@@ -1993,1 +1974,1 @@\n-                                    U.getAndSetInt(q, WorkQueue.BASE, nb);\n+                                    q.getAndSetBase(nb);\n@@ -2008,6 +1989,4 @@\n-                else if (inactive == 0) {\n-                    if ((inactive = deactivate(w, taken)) != 0)\n-                        taken = 0;\n-                }\n-                else if (awaitWork(w) == 0) {\n-                    inactive = rescans = 0;\n+                else if (inactive == 0)\n+                    inactive = deactivate(w, taken);\n+                else if (awaitWork(w, taken) == 0) {\n+                    taken = inactive = rescans = 0;\n@@ -2026,1 +2005,1 @@\n-     * @param taken number of stolen tasks since last deactivation\n+     * @param taken number of stolen tasks since last reactivation\n@@ -2030,15 +2009,15 @@\n-        int inactive = 0, phase;\n-        if (w != null && (inactive =          \/\/ plain accesses until CAS\n-                          (phase = U.getInt(w, WorkQueue.PHASE)) & IDLE) == 0) {\n-            long sp = (phase + (IDLE << 1)) & LMASK, pc, c;\n-            U.putInt(w, WorkQueue.PHASE, phase | IDLE);\n-            w.stackPred = (int)(pc = ctl);    \/\/ try to enqueue\n-            if (!U.compareAndSetLong(this, CTL, pc,\n-                                     c = ((pc - RC_UNIT) & UMASK) | sp))\n-                w.phase = phase;              \/\/ back out on contention\n-            else {\n-                if (taken != 0) {\n-                    w.nsteals += taken;\n-                    if ((w.config & CLEAR_TLS) != 0 &&\n-                        (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n-                        f.resetThreadLocals(); \/\/ (instanceof check always true)\n+        int inactive = IDLE;\n+        if (w != null) {                         \/\/ always true; hoist checks\n+            long pc = ctl, c;\n+            int phase = w.getPhasePlain();\n+            long sp = (phase + NEXTIDLE) & LMASK;\n+            w.setPhasePlain(phase | IDLE);\n+            for (;;) {\n+                w.stackPred = (int)pc;\n+                c = ((pc - RC_UNIT) & UMASK) | sp;\n+                if (pc == (pc = U.compareAndExchangeLong(this, CTL, pc, c)))\n+                    break;\n+                if ((pc & RC_MASK) >= (c & RC_MASK)) {\n+                    w.phase = phase;       \/\/ back out if lost to signal\n+                    inactive = 0;\n+                    break;\n@@ -2046,0 +2025,2 @@\n+            }\n+            if (inactive != 0) {\n@@ -2048,1 +2029,1 @@\n-                else {                         \/\/ spin for approx 1 scan cost\n+                else {                     \/\/ spin for approx 1 scan cost\n@@ -2084,0 +2065,1 @@\n+     * @param taken number of stolen tasks since last reactivation\n@@ -2086,2 +2068,2 @@\n-    private int awaitWork(WorkQueue w) {\n-        int inactive = 0, phase;\n+    private int awaitWork(WorkQueue w, int taken) {\n+        int inactive = 0;\n@@ -2089,0 +2071,1 @@\n+            int phase;\n@@ -2090,0 +2073,6 @@\n+            if (taken != 0) {\n+                w.nsteals += taken;\n+                if ((w.config & CLEAR_TLS) != 0 &&\n+                    (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n+                    f.resetThreadLocals(); \/\/ (instanceof check always true)\n+            }\n@@ -2426,1 +2415,2 @@\n-                for (ForkJoinTask<?> u; (u = w.nextLocalTask()) != null;)\n+                int fifo = ((int)config) & FIFO;\n+                for (ForkJoinTask<?> u; (u = w.nextLocalTask(fifo)) != null;)\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":79,"deletions":89,"binary":false,"changes":168,"status":"modified"}]}