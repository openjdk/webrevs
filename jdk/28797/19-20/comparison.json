{"files":[{"patch":"@@ -1249,1 +1249,0 @@\n-         \n@@ -1255,1 +1254,1 @@\n-            if (a == null || ((cap = a.length) - (s + 1 - b)) <= 0 || cap <= 0)\n+            if (a == null || (cap = a.length) <= s + 1 - b || (m = cap - 1) < 0)\n@@ -1259,2 +1258,2 @@\n-                U.putReferenceVolatile(a, slotOffset((m = cap - 1) & s), task);\n-                if (U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null &&\n+                U.putReferenceVolatile(a, slotOffset(m & s), task);\n+                if (U.getReference(a, slotOffset(m & (s - 1))) == null &&\n@@ -1294,1 +1293,3 @@\n-                    if (pool != null)\n+                    ForkJoinWorkerThread o;\n+                    if (pool != null ||\n+                        ((o = owner) != null && (pool = o.pool) != null))\n@@ -1551,0 +1552,7 @@\n+        final int spinWaitPhase() {\n+            int spins = SPIN_WAITS, f;\n+            while (((f = phase) & IDLE) != 0 && --spins != 0)\n+                Thread.onSpinWait();\n+            return f;\n+        }\n+\n@@ -1822,1 +1830,2 @@\n-        int pc = parallelism;\n+        int pc = U.getIntAcquire(this, PARALLELISM);\n+        long c = U.getLong(this, CTL);\n@@ -1824,1 +1833,0 @@\n-            long c = ctl;\n@@ -1844,1 +1852,4 @@\n-            if (U.compareAndSetLong(this, CTL, c, nc)) {\n+            if (q != null && q.base - qbase > 0)\n+                break;\n+            if (c == (c = ctl) &&\n+                c == (c = U.compareAndExchangeLong(this, CTL, c, nc))) {\n@@ -1854,2 +1865,0 @@\n-            if (q != null && q.base - qbase > 0)\n-                break;\n@@ -1950,3 +1959,16 @@\n-                            if (t == null) {\n-                                if (q.base == b && q.array == a) {\n-                                    if (rescans > 0)      \/\/ ran or stalled\n+                            if (q.base == b) {            \/\/ else inconsistent\n+                                if (t == null) {\n+                                    if (q.array == a) {   \/\/ else resized\n+                                        if (rescans > 0)  \/\/ ran or stalled\n+                                            break scan;\n+                                        if (U.getReference(a, np) == null &&\n+                                            (rescans >= 0 ||\n+                                             (U.getReferenceAcquire(a, bp) == null &&\n+                                              q.top == q.base)))\n+                                            break;\n+                                        rescans = 1;      \/\/ may be stalled\n+                                    }\n+                                }\n+                                else if (idle != 0) {\n+                                    if ((idle = tryReactivate(w)) != 0) {\n+                                        rescans = 1;      \/\/ can't take yet\n@@ -1954,12 +1976,11 @@\n-                                    if (U.getReference(a, np) == null &&\n-                                        (rescans >= 0 ||\n-                                         (U.getReferenceAcquire(a, bp) == null &&\n-                                          q.top == q.base)))\n-                                        break;\n-                                    rescans = 1;          \/\/ may be stalled\n-                                }                         \/\/ else inconsistent\n-                            }\n-                            else if (idle != 0) {\n-                                if ((idle = tryReactivate(w)) != 0) {\n-                                    rescans = 1;          \/\/ can't take yet\n-                                    break scan;\n+                                    }\n+                                }\n+                                else if (U.compareAndSetReference(a, bp, t, null)) {\n+                                    Object nt = U.getReference(a, np);\n+                                    U.putIntVolatile(q, WorkQueue.BASE, nb);\n+                                    if (nt != null)       \/\/ propagate\n+                                        signalWork(q, nb);\n+                                    rescans = 1;\n+                                    if (taken++ == 0 || src != qid)\n+                                        w.source = src = qid;\n+                                    w.topLevelExec(t, fifo);\n@@ -1967,11 +1988,0 @@\n-                            }\n-                            else if (q.base == b &&\n-                                     U.compareAndSetReference(a, bp, t, null)) {\n-                                Object nt = U.getReference(a, np);\n-                                U.getAndSetInt(q, WorkQueue.BASE, nb);\n-                                if (nt != null)\n-                                    signalWork(q, nb);    \/\/ propagate\n-                                rescans = 1;\n-                                if (taken++ == 0 || src != qid)\n-                                    w.source = src = qid;\n-                                w.topLevelExec(t, fifo);\n@@ -1985,1 +1995,2 @@\n-                    idle = deactivate(w, taken);\n+                    deactivate(w, taken);\n+                    idle = IDLE;\n@@ -1999,1 +2010,1 @@\n-     * Deactivates and enqueues worker, backing out on signal\n+     * Deactivates and enqueues worker\n@@ -2003,1 +2014,0 @@\n-     * @return active status\n@@ -2005,2 +2015,1 @@\n-    private int deactivate(WorkQueue w, int taken) {\n-        int idle = IDLE;\n+    private void deactivate(WorkQueue w, int taken) {\n@@ -2009,1 +2018,1 @@\n-            long sp = (phase + NEXTIDLE) & LMASK, pc = ctl, c, e;\n+            long sp = (phase + NEXTIDLE) & LMASK, pc = ctl, c;\n@@ -2011,1 +2020,1 @@\n-            for (;;)       {                 \/\/ try to enqueue\n+            do {\n@@ -2013,9 +2022,2 @@\n-                if (pc == (pc = U.compareAndExchangeLong(\n-                               this, CTL, pc, c = ((pc - RC_UNIT) & UMASK) | sp)))\n-                    break;\n-                else if ((c & RC_MASK) < (pc & RC_MASK)) {\n-                    w.phase = phase;         \/\/ back out if lost to signal\n-                    idle = 0;\n-                    break;\n-                }\n-            }\n+            } while (pc != (pc = U.compareAndExchangeLong(\n+                                this, CTL, pc, c = ((pc - RC_UNIT) & UMASK) | sp)));\n@@ -2028,6 +2030,2 @@\n-            if (idle != 0 &&\n-                ((e = runState) & STOP) == 0L &&\n-                ((e & SHUTDOWN) == 0L || (c & RC_MASK) > 0L || quiescent() <= 0)) {\n-                for (int s = SPIN_WAITS; (idle = w.phase & IDLE) != 0 && --s != 0;)\n-                    Thread.onSpinWait();     \/\/ spin before rescan\n-            }\n+            if ((c & RC_MASK) == 0L && (runState & SHUTDOWN) != 0L)\n+                quiescent();                 \/\/ may trigger quiescent termination\n@@ -2035,1 +2033,0 @@\n-        return idle;\n@@ -2066,2 +2063,3 @@\n-        int idle = 0, phase;\n-        if (w != null && (idle = (phase = w.phase) & IDLE) != 0) {\n+        int idle = IDLE, phase;\n+        if ((runState & STOP) == 0L && w != null &&\n+             (idle = (phase = w.spinWaitPhase()) & IDLE) != 0) {\n@@ -2070,4 +2068,2 @@\n-            do {\n-                boolean trimmable = false;    \/\/ use timed wait if trimmable\n-                int spins = 0;\n-                long d = 0L, c;\n+            LockSupport.setCurrentBlocker(this);\n+            for (;;) {\n@@ -2077,13 +2073,10 @@\n-                if ((int)(c = ctl) == activePhase) {\n-                    spins = SPIN_WAITS;       \/\/ trim or spin at head\n-                    if ((c & RC_MASK) == 0L) {\n-                        long now = System.currentTimeMillis();\n-                        if (deadline == 0L)\n-                            deadline = waitTime + now;\n-                        if (deadline - now <= TIMEOUT_SLOP) {\n-                            if (tryTrim(w, c, activePhase))\n-                                break;\n-                            continue;         \/\/ lost race to trim\n-                        }\n-                        d = deadline;\n-                        trimmable = true;\n+                boolean trimmable = false;    \/\/ use timed wait if trimmable\n+                long d = 0L, c;\n+                if (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase) {\n+                    long now = System.currentTimeMillis();\n+                    if (deadline == 0L)\n+                        deadline = waitTime + now;\n+                    if (deadline - now <= TIMEOUT_SLOP) {\n+                        if (tryTrim(w, c, activePhase))\n+                            break;\n+                        continue;             \/\/ lost race to trim\n@@ -2091,0 +2084,2 @@\n+                    d = deadline;\n+                    trimmable = true;\n@@ -2092,3 +2087,1 @@\n-                while ((idle = w.phase & IDLE) != 0 && spins-- != 0)\n-                    Thread.onSpinWait();\n-                if (idle == 0)\n+                if ((idle = w.phase & IDLE) == 0)\n@@ -2096,1 +2089,0 @@\n-                LockSupport.setCurrentBlocker(this);\n@@ -2101,2 +2093,4 @@\n-                LockSupport.setCurrentBlocker(null);\n-            } while (idle != 0 && (idle = w.phase & IDLE) != 0);\n+                if (idle == 0 || (idle = w.phase & IDLE) == 0)\n+                    break;\n+            }\n+            LockSupport.setCurrentBlocker(null);\n@@ -2576,0 +2570,3 @@\n+                int s = q.top, b = q.base, cap = 0;\n+                ForkJoinTask<?>[] a = q.array;\n+                int m = (a == null || (cap = a.length) <= s + 1 - b) ? -1 : cap - 1;\n@@ -2578,1 +2575,1 @@\n-                    break; \/\/ check while q lock held\n+                    break;                    \/\/ check while q lock held\n@@ -2580,3 +2577,1 @@\n-                ForkJoinTask<?>[] a = q.array;\n-                int b = q.base, s = q.top, cap;\n-                if (a == null || ((cap = a.length) - (s + 1 - b)) <= 0 || cap <= 0)\n+                else if (m < 0)\n@@ -2586,2 +2581,1 @@\n-                    a[(cap - 1) & s] = task;\n-                    long pk = slotOffset((cap - 1) & (s - 1)); \/\/ predecessor index\n+                    a[m & s] = task;\n@@ -2589,1 +2583,1 @@\n-                    if (U.getReferenceAcquire(a, pk) == null && signalIfEmpty)\n+                    if (a[m & (s - 1)] == null && signalIfEmpty)\n@@ -2597,1 +2591,0 @@\n-\n@@ -2599,1 +2592,1 @@\n-        Thread t; ForkJoinWorkerThread wt;\n+        Thread t; ForkJoinWorkerThread wt; WorkQueue q;\n@@ -2601,2 +2594,3 @@\n-            (wt = (ForkJoinWorkerThread)t).pool == this)\n-            wt.workQueue.push(task, signalIfEmpty ? this : null);\n+            (q = (wt = (ForkJoinWorkerThread)t).workQueue) != null &&\n+            wt.pool == this)\n+            q.push(task, signalIfEmpty ? this : null);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":89,"deletions":95,"binary":false,"changes":184,"status":"modified"}]}