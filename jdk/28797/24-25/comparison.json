{"files":[{"patch":"@@ -1260,2 +1260,4 @@\n-                if (unlock != 1)              \/\/ release external lock\n-                    phase = unlock;\n+                if (unlock != 1) {            \/\/ release external lock\n+                    U.putInt(this, PHASE, unlock);\n+                    U.storeFence();\n+                }\n@@ -1942,1 +1944,0 @@\n-                int i = r, step = (r >>> 16) | 1;\n@@ -1944,0 +1945,1 @@\n+                int i = r, step = (r >>> 16) | 1;\n@@ -1986,13 +1988,1 @@\n-                int phase;\n-                if (rescans >= 0) {\n-                    --rescans;\n-                    if (idle != 0)\n-                        idle = w.phase & IDLE;\n-                }\n-                else if (idle == 0) {\n-                    if ((idle = deactivate(w, taken)) == 0)\n-                        rescans = 0;\n-                    taken = 0;\n-                }\n-                else if ((idle = (phase = w.phase) & IDLE) == 0 ||\n-                         (idle = awaitWork(w, phase)) == 0)\n+                if (rescans > 0)\n@@ -2000,2 +1990,16 @@\n-                else\n-                    break;\n+                else {\n+                    if (rescans == 0)\n+                        rescans = -1;\n+                    else if (idle == 0) {\n+                        if ((idle = deactivate(w)) == 0)\n+                            rescans = 0;\n+                    }\n+                    else if ((idle = rescans = awaitWork(w)) != 0)\n+                        break;\n+                    if (idle != 0) {\n+                        int ns = taken;\n+                        taken = 0;\n+                        if ((idle = onEmptyScan(w, ns)) == 0)\n+                            rescans = 0;\n+                    }\n+                }\n@@ -2012,1 +2016,0 @@\n-     * @param taken number of stolen tasks since last reactivation\n@@ -2015,3 +2018,3 @@\n-    private int deactivate(WorkQueue w, int taken) {\n-        int idle = IDLE;\n-        if (w != null) {                     \/\/ always true; hoist checks\n+    private int deactivate(WorkQueue w) {\n+        int idle = 0;\n+        if (w != null) {                       \/\/ always true; hoist checks\n@@ -2019,1 +2022,1 @@\n-            long sp = (phase + NEXTIDLE) & LMASK, pc = ctl, c;\n+            long sp = (phase + NEXTIDLE) & LMASK, pc = ctl;\n@@ -2021,1 +2024,1 @@\n-            for (;;) {                      \/\/ try to enqueue\n+            for (;;) {                         \/\/ try to enqueue\n@@ -2023,6 +2026,5 @@\n-                if (pc == (pc = U.compareAndExchangeLong(\n-                               this, CTL, pc, c = ((pc - RC_UNIT) & UMASK) | sp)))\n-                    break;\n-                if ((c & RC_MASK) < (pc & RC_MASK)) {\n-                    w.phase = phase;         \/\/ back out if lost to signal\n-                    idle = 0;\n+                long c = (pc - RC_UNIT) & UMASK | sp, ac = c & RC_MASK;\n+                if (pc == (pc = U.compareAndExchangeLong(this, CTL, pc, c))) {\n+                    if (ac == 0L)             \/\/ check quiescent termination\n+                        quiescent();\n+                    idle = w.phase & IDLE;\n@@ -2031,17 +2033,3 @@\n-            }\n-            if (taken != 0) {\n-                w.nsteals += taken;\n-                if ((w.config & CLEAR_TLS) != 0 &&\n-                    (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n-                    f.resetThreadLocals();   \/\/ (instanceof check always true)\n-                Thread.interrupted();        \/\/ clear status\n-            }\n-            if (idle != 0 && (runState & STOP) == 0L) {\n-                if ((c & RC_MASK) == 0L) {\n-                    if (quiescent() <= 0)    \/\/ check quiescent termination\n-                        idle = w.phase & IDLE;\n-                }\n-                else if ((idle = w.phase & IDLE) != 0) {\n-                    Thread.yield();          \/\/ reduce unproductive scanning\n-                    for (int s = SPIN_WAITS; (idle = w.phase & IDLE) != 0 && --s != 0;)\n-                        Thread.onSpinWait();\n+                else if (ac < (pc & RC_MASK)) {\n+                    w.phase = phase;           \/\/ back out if lost to signal\n+                    break;\n@@ -2075,0 +2063,27 @@\n+    \/**\n+     * Spins and\/or yields to reduce unproductive scanning\n+     *\n+     * @param w the work queue\n+     * @param taken number of stolen tasks since last empty scan\n+     * @return active status\n+     *\/\n+    private int onEmptyScan(WorkQueue w, int taken) {\n+        int idle = 0;\n+        if (w != null) {                       \/\/ always true; hoist checks\n+            if (taken != 0) {\n+                w.nsteals += taken;\n+                if ((w.config & CLEAR_TLS) != 0 &&\n+                    (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n+                    f.resetThreadLocals();     \/\/ (instanceof check always true)\n+                Thread.interrupted();          \/\/ clear status\n+            }\n+            if ((idle = w.phase & IDLE) != 0 && (runState & STOP) == 0) {\n+                if (taken == 0)\n+                    Thread.yield();\n+                for (int s = SPIN_WAITS; (idle = w.phase & IDLE) != 0 && --s != 0;)\n+                    Thread.onSpinWait();\n+            }\n+        }\n+        return idle;\n+    }\n+\n@@ -2079,1 +2094,0 @@\n-     * @param phase w's (inactive) phase\n@@ -2082,3 +2096,4 @@\n-    private int awaitWork(WorkQueue w, int phase) {\n-        int idle = IDLE;\n-        if (w != null) {                      \/\/ always true; hoist checks\n+    private int awaitWork(WorkQueue w) {\n+        int idle = 0, phase;\n+        if (w != null && (idle = (phase = w.phase) & IDLE) != 0) {\n+            LockSupport.setCurrentBlocker(this);\n@@ -2089,15 +2104,9 @@\n-                long d = 0L, c;               \/\/ trim or spin at head\n-                int spins = 1;\n-                if ((int)(c = ctl) == activePhase) {\n-                    spins = SPIN_WAITS;\n-                    if ((c & RC_MASK) == 0L) {\n-                        long now = System.currentTimeMillis();\n-                        if (deadline == 0L)\n-                            deadline = waitTime + now;\n-                        if (deadline - now <= TIMEOUT_SLOP) {\n-                            if (tryTrim(w, c, activePhase))\n-                                break;\n-                            continue;         \/\/ lost race to trim\n-                        }\n-                        d = deadline;\n-                        trimmable = true;\n+                long d = 0L, c;               \/\/ trim at head\n+                if ((int)(c = ctl) == activePhase && (c & RC_MASK) == 0L) {\n+                    long now = System.currentTimeMillis();\n+                    if (deadline == 0L)\n+                        deadline = waitTime + now;\n+                    if (deadline - now <= TIMEOUT_SLOP) {\n+                        if (tryTrim(w, c, activePhase))\n+                            break;\n+                        continue;             \/\/ lost race to trim\n@@ -2105,0 +2114,2 @@\n+                    d = deadline;\n+                    trimmable = true;\n@@ -2106,3 +2117,1 @@\n-                while ((idle = w.phase & IDLE) != 0 && --spins != 0)\n-                    Thread.onSpinWait();\n-                if (idle == 0)\n+                if ((idle = w.phase & IDLE) == 0)\n@@ -2110,1 +2119,0 @@\n-                LockSupport.setCurrentBlocker(this);\n@@ -2115,1 +2123,0 @@\n-                LockSupport.setCurrentBlocker(null);\n@@ -2120,0 +2127,1 @@\n+            LockSupport.setCurrentBlocker(null);\n@@ -2591,1 +2599,0 @@\n-                ForkJoinTask<?>[] a;\n@@ -2593,1 +2600,1 @@\n-                 int unlock = lock + NEXTIDLE;\n+                int unlock = lock + NEXTIDLE;\n@@ -2604,0 +2611,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":81,"deletions":73,"binary":false,"changes":154,"status":"modified"}]}