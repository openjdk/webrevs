{"files":[{"patch":"@@ -1068,1 +1068,1 @@\n-    static final int SPIN_WAITS       = 1 <<  8;   \/\/ max calls to onSpinWait\n+    static final int SPIN_WAITS       = 1 <<  7;   \/\/ max calls to onSpinWait\n@@ -1171,6 +1171,0 @@\n-    \/**\n-     * Exception thrown in tryTrim after idle timeout\n-     *\/\n-    @SuppressWarnings(\"serial\")\n-    static final class WorkerTrimmedException extends RuntimeException { }\n-\n@@ -1198,1 +1192,1 @@\n-        int source;                \/\/ source queue id (or DROPPED)\n+        volatile int source;       \/\/ source queue id (or DROPPED)\n@@ -1201,0 +1195,2 @@\n+        @jdk.internal.vm.annotation.Contended(\"w\")\n+        int dropOnEmptyScan;       \/\/ nonzero if trimmable\n@@ -1259,2 +1255,2 @@\n-            int b = base, s = top, cap, m; long pos;\n-            if (a == null || (cap = a.length) <= s + 1 - b || (m = cap - 1) < 0)\n+            int b = base, s = top, p = top = s + 1, cap, m;\n+            if (a == null || (cap = a.length) <= p - b || (m = cap - 1) < 0)\n@@ -1263,2 +1259,1 @@\n-                top = s + 1;\n-                U.getAndSetReference(a, pos = slotOffset(m & s), task);\n+                U.getAndSetReference(a, slotOffset(m & s), task);\n@@ -1271,1 +1266,1 @@\n-                    pool.signalWork(a, pos); \/\/ may have appeared empty\n+                    pool.signalWork(this, s); \/\/ may have appeared empty\n@@ -1291,1 +1286,1 @@\n-                    int s = top++, mask = cap - 1, newMask = newCap - 1;\n+                    int s = top - 1, mask = cap - 1, newMask = newCap - 1;\n@@ -1300,1 +1295,0 @@\n-                    long pos = slotOffset(s & newMask);\n@@ -1305,1 +1299,1 @@\n-                        pool.signalWork(newArray, pos);\n+                        pool.signalWork(this, s);\n@@ -1309,0 +1303,1 @@\n+            --top;    \/\/ back out\n@@ -1422,22 +1417,0 @@\n-        \/**\n-         * Tries once to poll for a task\n-         * @param pool if non-null, pool to propagate signals\n-         *\/\n-        private ForkJoinTask<?> tryPoll(ForkJoinPool pool) {\n-           ForkJoinTask<?>[] a; int cap, b, nb; long bp;\n-            if ((a = array) != null && (cap = a.length) > 0) {\n-                 ForkJoinTask<?> t = (ForkJoinTask<?>)U.getReferenceAcquire(\n-                    a, bp = slotOffset((cap - 1) & (b = base)));\n-                long np = slotOffset((cap - 1) & (nb = b + 1));\n-                if (t != null && base == b &&\n-                    U.compareAndSetReference(a, bp, t, null)) {\n-                    Object nt = U.getReference(a, np);\n-                    U.getAndSetInt(this, BASE, nb);\n-                    if (pool != null && nt != null)\n-                        pool.signalWork(a, np);\n-                    return t;\n-                }\n-            }\n-            return null;\n-        }\n-\n@@ -1449,4 +1422,1 @@\n-        final int topLevelExec(ForkJoinTask<?> task, WorkQueue q, ForkJoinPool pool,\n-                               int fifo) {\n-            ForkJoinPool p = (fifo == 0) ? null : pool;\n-            int taken = 1;\n+        final void topLevelExec(ForkJoinTask<?> task, int fifo) {\n@@ -1455,4 +1425,1 @@\n-                if ((task = nextLocalTask(fifo)) == null &&\n-                    (q == null || (task = q.tryPoll(p)) == null))\n-                    break;\n-                ++taken;\n+                task = nextLocalTask(fifo);\n@@ -1460,1 +1427,0 @@\n-            return taken;\n@@ -1580,1 +1546,1 @@\n-                    U.putIntVolatile(this, BASE, b + 1);\n+                    base = b + 1;\n@@ -1764,1 +1730,1 @@\n-        if (w != null) {\n+        if (w != null && (runState & STOP) == 0L) {\n@@ -1818,2 +1784,0 @@\n-        if (ex instanceof WorkerTrimmedException)\n-            ex = null;\n@@ -1846,1 +1810,1 @@\n-            signalWork(null, 0L);          \/\/ possibly replace\n+            signalWork(null, 0);           \/\/ possibly replace\n@@ -1854,1 +1818,2 @@\n-     * giving up on contention if source slot already taken.\n+     * giving up on contention if q is nonull and signalled slot\n+     * already taken.\n@@ -1856,2 +1821,2 @@\n-     * @param src, if nonnull, the array containing signalled task\n-     * @param offset slot offset for the task\n+     * @param src, if nonnull, the WorkQueue containing signalled task\n+     * @param base src's base index for the task\n@@ -1859,1 +1824,1 @@\n-    final void signalWork(ForkJoinTask<?>[] src, long offset) {\n+    final void signalWork(WorkQueue src, int base) {\n@@ -1866,1 +1831,1 @@\n-            if (i == 0 || w == null) {\n+            if (i == 0) {\n@@ -1871,0 +1836,2 @@\n+            else if ((v = w) == null)\n+                break;\n@@ -1884,1 +1851,1 @@\n-            if (src != null && U.getReference(src, offset) == null)\n+             if (src != null && src.base - base > 0)\n@@ -1964,4 +1931,3 @@\n-            for (int fifo = (int)config & FIFO, idle = 0, taken = 0;;) {\n-                WorkQueue[] qs;\n-                long e = runState;\n-                int n = ((qs = queues) == null) ? 0 : qs.length;\n+            int fifo = (int)config & FIFO;\n+            rescan: for (int idle = 0, taken = 0, src = -1;;) {\n+                WorkQueue[] qs; int n;\n@@ -1969,2 +1935,3 @@\n-                int i = r, step = (r >>> 16) | 1;\n-                if ((e & STOP) != 0L || n <= 0) {\n+                long e = runState;\n+                if ((qs = queues) == null || (n = qs.length) <= 0 ||\n+                    (e & STOP) != 0L) {\n@@ -1974,2 +1941,1 @@\n-                boolean rescan = false;\n-                scan: for (int j = n; j != 0; --j, i += step) {\n+                scan: for (int j = n, i = r, step = (r >>> 16) | 1; ; i += step) {\n@@ -1978,1 +1944,1 @@\n-                        ForkJoinTask<?>[] a; int pb = -1, cap; \/\/ poll queue\n+                        ForkJoinTask<?>[] a; int pb = -1, ran = 0, cap;\n@@ -1980,1 +1946,1 @@\n-                            int b, nb; long bp, np; ForkJoinTask<?> t;\n+                            int b, nb; long bp, np, ps; ForkJoinTask<?> t;\n@@ -1989,2 +1955,1 @@\n-                                if ((idle = tryReactivate(w)) != 0) {\n-                                    rescan = true;\n+                                if ((idle = tryReactivate(w)) != 0)\n@@ -1992,1 +1957,0 @@\n-                                }\n@@ -1994,2 +1958,4 @@\n-                            else if (qb != b)             \/\/ inconsistent\/busy\n-                                ;\n+                            else if (qb != b) {           \/\/ inconsistent\n+                                if (taken == 0)\n+                                    break scan;           \/\/ busy\n+                            }\n@@ -1997,5 +1963,2 @@\n-                                if (q.array == a && U.getReference(a, bp) == null) {\n-                                    if (nt == null)\n-                                        break;\n-                                    if (pb == (pb = b)) {\n-                                        rescan = true;    \/\/ stalled; reorder scan\n+                                if (U.getReference(a, bp) == null) {\n+                                    if (ran != 0)         \/\/ end run on this queue\n@@ -2003,1 +1966,4 @@\n-                                    }\n+                                    if (nt == null)       \/\/ probably empty\n+                                        break;\n+                                    if (pb == (pb = b))\n+                                        break scan;       \/\/ stalled; reorder scan\n@@ -2009,6 +1975,9 @@\n-                                if (nt != null)           \/\/ propagate\n-                                    signalWork(a, np);\n-                                w.source = qid;\n-                                taken += w.topLevelExec(t, q, this, fifo);\n-                                rescan = true;\n-                                break scan;\n+                                if (qid != (ps = src))\n+                                    U.putIntOpaque(w, WorkQueue.SOURCE, src = qid);\n+                                if (nt != null &&\n+                                    (qid != ps ||\n+                                     ((qid & 1) == 0 && (fifo != 0 || taken == 0))) &&\n+                                    U.getReferenceAcquire(a, np) != null)\n+                                    signalWork(q, nb);    \/\/ propagate\n+                                ran = ++taken;\n+                                w.topLevelExec(t, fifo);\n@@ -2018,4 +1987,11 @@\n-                }\n-                if (!rescan) {\n-                    idle = onEmptyScan(w, idle, taken);\n-                    taken = 0;\n+                    if (--j == 0) {                       \/\/ empty scan\n+                        if (idle == 0) {\n+                            idle = tryDeactivate(w, taken);\n+                            taken = 0;\n+                        }\n+                        else if ((idle = awaitWork(w)) != 0)\n+                            break rescan;                 \/\/ trimmed or terminated\n+                        else\n+                            src = -1;\n+                        break;\n+                    }\n@@ -2028,1 +2004,1 @@\n-     * Possibly deactivates, reactivates or pauses worker\n+     * Possibly deactivates or pauses worker\n@@ -2031,0 +2007,1 @@\n+     * @param taken number of tasks taken since last activate\n@@ -2033,1 +2010,2 @@\n-    private int onEmptyScan(WorkQueue w, int idle, int taken) {\n+    private int tryDeactivate(WorkQueue w, int taken) {\n+        int idle = 0;\n@@ -2035,2 +2013,1 @@\n-            int phase = w.phase;\n-            if (taken != 0) {\n+            if (taken != 0) {                      \/\/ rescan before deactivating\n@@ -2044,1 +2021,2 @@\n-            else if (idle == 0) {                  \/\/ deactivate\n+            else {\n+                int phase = U.getInt(w, WorkQueue.PHASE);\n@@ -2062,4 +2040,0 @@\n-            else if ((idle = phase & IDLE) != 0) {\n-                awaitWork(w, phase);\n-                idle = 0;\n-            }\n@@ -2095,1 +2069,1 @@\n-     * @throws WorkerTrimmedException on idle timeout\n+     * @return 0 if now active\n@@ -2097,6 +2071,7 @@\n-    private void awaitWork(WorkQueue w, int phase) {\n-        if (w != null) {\n-            int activePhase = phase + IDLE;\n-            long deadline = 0L, waitTime = (w.source == INVALID_ID) ? 0L : keepAlive;\n-            for (;;) {\n-                long d = 0L, c; int idle;\n+    private int awaitWork(WorkQueue w) {\n+        int idle = 0, phase;\n+        if (w != null && (idle = (phase = w.phase) & IDLE) != 0) {\n+            int activePhase = phase + IDLE, trim;\n+            if ((trim = w.dropOnEmptyScan) != 0)\n+                w.dropOnEmptyScan = 0;\n+            for (long deadline = 0L;;) {\n@@ -2106,4 +2081,7 @@\n-                boolean trimmable = false;    \/\/ use timed wait if trimmable\n-                int spins = ((short)((c = ctl) >>> TC_SHIFT) | 1) & SMASK;\n-                if ((int)c == activePhase) {  \/\/ at head\n-                    if ((c & RC_MASK) == 0L) {\n+                boolean trimmable = false;\n+                long d = 0L, c;\n+                int ac = (short)((c = ctl) >>> RC_SHIFT);\n+                int spins = ((short)(c >>> TC_SHIFT) | 1) & SMASK; \/\/ >= # workers\n+                if ((int)c == activePhase) { \/\/ at head of ctl\n+                    spins += Math.max(spins << 1, SPIN_WAITS); \/\/ approx 1 scan cost\n+                    if (ac == 0) {           \/\/ quiescent\n@@ -2112,3 +2090,6 @@\n-                            deadline = waitTime + now;\n-                        if ((d = deadline) - now <= TIMEOUT_SLOP)\n-                            tryTrim(w, c, activePhase); \/\/ throws if trimmed\n+                            d = deadline = now + keepAlive;\n+                        else if ((d = deadline) - now <= TIMEOUT_SLOP)\n+                            trim = 1;\n+                        if (trim != 0 && tryTrim(w, c, activePhase))\n+                            break;\n+                        trim = 0;\n@@ -2117,1 +2098,0 @@\n-                    spins += SPIN_WAITS;      \/\/ spin more\n@@ -2129,1 +2109,1 @@\n-                if (idle == 0 || (w.phase & IDLE) == 0)\n+                if (idle == 0 || (idle = w.phase & IDLE) == 0)\n@@ -2133,0 +2113,1 @@\n+        return idle;\n@@ -2138,1 +2119,1 @@\n-     * @throws WorkerTrimmedException on idle timeout\n+     * @return true if trimmed\n@@ -2140,1 +2121,1 @@\n-    private void tryTrim(WorkQueue w, long c, int activePhase) {\n+    private boolean tryTrim(WorkQueue w, long c, int activePhase) {\n@@ -2153,1 +2134,1 @@\n-                    v.source = INVALID_ID;      \/\/ enable cascaded timeouts\n+                    v.dropOnEmptyScan = 1;\n@@ -2157,1 +2138,1 @@\n-                throw new WorkerTrimmedException();\n+                return true;\n@@ -2160,0 +2141,1 @@\n+        return false;\n@@ -2317,1 +2299,1 @@\n-                                    U.putIntVolatile(w, WorkQueue.SOURCE, j);\n+                                    w.source = j;\n@@ -2472,1 +2454,1 @@\n-                                U.putIntVolatile(w, WorkQueue.SOURCE, j);\n+                                w.source = j;\n@@ -3310,1 +3292,1 @@\n-            signalWork(null, 0L); \/\/ trigger worker activation\n+            signalWork(null, 0); \/\/ trigger worker activation\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":103,"deletions":121,"binary":false,"changes":224,"status":"modified"}]}