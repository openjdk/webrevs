{"files":[{"patch":"@@ -1257,1 +1257,1 @@\n-            int s = top, b = base, m, cap, room; ForkJoinTask<?>[] a, na;\n+            int s = top, b = base, m, cap, room; ForkJoinTask<?>[] a;\n@@ -1259,2 +1259,1 @@\n-                int k = (m = cap - 1) & s;\n-                if ((room = m - (s - b)) >= 0) {\n+                if ((room = (m = cap - 1) - (s - b)) >= 0) {\n@@ -1262,1 +1261,1 @@\n-                    long pos = slotOffset(k);\n+                    long pos = slotOffset(m & s);\n@@ -1267,2 +1266,2 @@\n-                    if (room == 0 && (na = growArray(a, cap, s)) != null)\n-                        k = ((a = na).length - 1) & s;      \/\/ resize\n+                    if (room == 0)\n+                        growArray(a, cap, s);\n@@ -1277,1 +1276,1 @@\n-                    pool.signalWork(a, k);    \/\/ may have appeared empty\n+                    pool.signalWork(this, s);    \/\/ may have appeared empty\n@@ -1286,1 +1285,0 @@\n-         * @return new array, or null on failure\n@@ -1288,1 +1286,1 @@\n-        private ForkJoinTask<?>[] growArray(ForkJoinTask<?>[] a, int cap, int s) {\n+        private void growArray(ForkJoinTask<?>[] a, int cap, int s) {\n@@ -1308,1 +1306,0 @@\n-            return newArray;\n@@ -1432,1 +1429,9 @@\n-         * Runs the given task, as well as remaining local tasks\n+         * Runs the given task, as well as remaining local tasks, and\n+         * those from the given queue that can be polled without interference.\n+         *\n+         * @param task the top-level task\n+         * @param q the WorkQueue from which task was taken\n+         * @param fifo nonzero if fifo mode\n+         * @param qbase the next base index of q to take;\n+         *        returning if no such task or already taken\n+         * @return number of top-level tasks stolen from q\n@@ -1434,2 +1439,6 @@\n-        final void topLevelExec(ForkJoinTask<?> task, int fifo) {\n-            while (task != null) {\n+        final int topLevelExec(ForkJoinTask<?> task, WorkQueue q,\n+                                int fifo, int qbase) {\n+            if (task == null || q == null)\n+                return 0;        \/\/ currently impossible\n+            int stolen = 1;\n+            outer: for (;;) {\n@@ -1437,1 +1446,37 @@\n-                task = (fifo != 0) ? localPoll() : localPop();\n+                task = null;\n+                int p = top, cap; ForkJoinTask<?>[] a;\n+                if ((a = array) == null || (cap = a.length) <= 0)\n+                    break;        \/\/ currently impossible\n+                if (fifo == 0) {  \/\/ specialized localPop\n+                    int s = p - 1; long k;\n+                    if (U.getReference(\n+                            a, k = slotOffset((cap - 1) & s)) != null &&\n+                        (task = (ForkJoinTask<?>)\n+                         U.getAndSetReference(a, k, null)) != null) {\n+                        top = s;\n+                        continue;\n+                    }\n+                } else {         \/\/ specialized localPoll\n+                    for (int b = base; p - b > 0; ) {\n+                        int nb = b + 1;\n+                        if ((task = (ForkJoinTask<?>)U.getAndSetReference(\n+                                 a, slotOffset((cap - 1) & b), null)) != null) {\n+                            base = nb;\n+                            continue outer;\n+                        }\n+                        if (nb == p)\n+                            break;\n+                        while (b == (b = U.getIntAcquire(this, BASE)))\n+                            Thread.onSpinWait();\n+                    }\n+                }\n+                \/\/ try (once) to steal at q's next base index\n+                ForkJoinTask<?>[] qa = q.array; int qcap; long qk;\n+                if (q.base != qbase || qa == null || (qcap = qa.length) <= 0 ||\n+                    (task = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                        qa, qk = slotOffset((qcap - 1) & qbase))) == null ||\n+                    q.base != qbase || \/\/ ensure valid read\n+                    !U.compareAndSetReference(qa, qk, task, null))\n+                    break;\n+                q.base = ++qbase;\n+                ++stolen;\n@@ -1439,0 +1484,1 @@\n+            return stolen;\n@@ -1857,1 +1903,4 @@\n-     * giving up if array a is nonnull and task at a[k] already taken.\n+     * giving up q is nonull and signalled slot already taken.\n+     *\n+     * @param q, if nonnull, the WorkQueue containing signalled task\n+     * @param qbase q's base index for the task\n@@ -1859,1 +1908,1 @@\n-    final void signalWork(ForkJoinTask<?>[] a, int k) {\n+    final void signalWork(WorkQueue q, int qbase) {\n@@ -1881,1 +1930,1 @@\n-            if (a != null && k < a.length && k >= 0 && a[k] == null)\n+            if (q != null && q.base - qbase > 0)\n@@ -1979,1 +2028,1 @@\n-                            int b, nb, nk; long bp; ForkJoinTask<?> t;\n+                            int b, nb; long bp; ForkJoinTask<?> t;\n@@ -1982,1 +2031,1 @@\n-                            long np = slotOffset(nk = (nb = b + 1) & (cap - 1));\n+                            long np = slotOffset((nb = b + 1) & (cap - 1));\n@@ -2007,5 +2056,3 @@\n-                                    ++taken;\n-                                    if (nt != null &&     \/\/ confirm a[nk]\n-                                        U.getReferenceAcquire(a, np) == nt)\n-                                        signalWork(a, nk); \/\/ propagate\n-                                    w.topLevelExec(t, fifo);\n+                                    if (nt != null)\n+                                        signalWork(q, nb); \/\/ propagate\n+                                    taken += w.topLevelExec(t, q, fifo, nb);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":71,"deletions":24,"binary":false,"changes":95,"status":"modified"}]}