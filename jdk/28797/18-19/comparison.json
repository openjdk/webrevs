{"files":[{"patch":"@@ -1201,0 +1201,1 @@\n+        private static final long SOURCE;\n@@ -1243,1 +1244,2 @@\n-         * Pushes a task. Called only by owner or if already locked\n+         * Pushes a task on an internal queue. Called only by owner.\n+         * (Use pool.externalPush for external queues).\n@@ -1246,2 +1248,2 @@\n-         * @param pool the pool to signal if was previously empty, else null\n-         * @param unlock if not 1, phase unlock value\n+         * @param pool the pool to signal if was previously empty or resized\n+         \n@@ -1250,1 +1252,1 @@\n-        final void push(ForkJoinTask<?> task, ForkJoinPool pool, int unlock) {\n+        final void push(ForkJoinTask<?> task, ForkJoinPool pool) {\n@@ -1252,4 +1254,4 @@\n-            int b = base, s = top, room, m;\n-            if (a != null &&\n-                ((room = a.length - (s + 1 - b)) > 0 || (a = growArray()) != null) &&\n-                (m = a.length - 1) >= 0) {    \/\/ else rejected or disabled\n+            int b = base, s = top, cap, m;\n+            if (a == null || ((cap = a.length) - (s + 1 - b)) <= 0 || cap <= 0)\n+                growAndPush(task, pool, 1);\n+            else {\n@@ -1257,5 +1259,3 @@\n-                U.putReferenceVolatile(a, slotOffset(m & s), task);\n-                if (unlock != 1)              \/\/ release external lock\n-                    U.putInt(this, PHASE, unlock);\n-                if ((U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null ||\n-                     room <= 0) && pool != null)\n+                U.putReferenceVolatile(a, slotOffset((m = cap - 1) & s), task);\n+                if (U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null &&\n+                    pool != null)\n@@ -1267,2 +1267,4 @@\n-         * Resizes the queue array unless out of memory.\n-         * @return new array, or throw on OOME\n+         * Resizes the queue array and pushes unless out of memory.\n+         * @param task the task; caller must ensure nonnull\n+         * @param pool the pool to signal upon resize\n+         * @param unlock if not 1, phase unlock value\n@@ -1270,1 +1272,1 @@\n-        private ForkJoinTask<?>[] growArray() {\n+        final void growAndPush(ForkJoinTask<?> task, ForkJoinPool pool, int unlock) {\n@@ -1280,2 +1282,3 @@\n-                    int mask = cap - 1, newMask = newCap - 1;\n-                    for (int k = top - 1, j = cap; j > 0; --j, --k) {\n+                    int s = top++, mask = cap - 1, newMask = newCap - 1;\n+                    newArray[s & newMask] = task;\n+                    for (int k = s - 1, j = cap; j > 0; --j, --k) {\n@@ -1289,1 +1292,5 @@\n-                    return newArray;\n+                    if (unlock != 1)\n+                        phase = unlock;\n+                    if (pool != null)\n+                        pool.signalWork(this, s);\n+                    return;\n@@ -1292,3 +1299,2 @@\n-            int f = phase;                   \/\/ unlock if externally locked\n-            if ((f & (IDLE | 1)) == 0)\n-                phase = f + IDLE;\n+            if (unlock != 1)\n+                phase = unlock;\n@@ -1311,1 +1317,1 @@\n-                        top = s;\n+                        U.putIntOpaque(this, TOP, s);\n@@ -1316,1 +1322,1 @@\n-                            base = b + 1;\n+                            U.putIntVolatile(this, BASE, b + 1);\n@@ -1333,4 +1339,1 @@\n-            U.loadFence();  \/\/ ensure ordering for external callers\n-            ForkJoinTask<?> t = nextLocalTask(config & FIFO);\n-            U.storeFence();\n-            return t;\n+            return nextLocalTask(config & FIFO);\n@@ -1455,0 +1458,1 @@\n+                            U.storeFence();\n@@ -1502,1 +1506,1 @@\n-                        top = s;\n+                        U.putIntOpaque(this, TOP, s);\n@@ -1539,1 +1543,1 @@\n-                    base = b + 1;\n+                    U.putIntVolatile(this, BASE, b + 1);\n@@ -1576,0 +1580,1 @@\n+            SOURCE = U.objectFieldOffset(klass, \"source\");\n@@ -1910,1 +1915,2 @@\n-                         U.compareAndSetLong(this, RUNSTATE, e, e | STOP))\n+                         U.compareAndSetLong(this, RUNSTATE, e, e | STOP)) {\n+                    releaseWaiters();\n@@ -1912,0 +1918,1 @@\n+                }\n@@ -1929,1 +1936,1 @@\n-            int src = -1, idle = 0, rescans = 0, taken = 0;\n+            int src = 0, idle = 0, rescans = 0, taken = 0;\n@@ -1968,2 +1975,1 @@\n-                                ++taken;\n-                                if (src != qid)\n+                                if (taken++ == 0 || src != qid)\n@@ -1978,2 +1984,0 @@\n-                else if ((runState & STOP) != 0L)\n-                    break;\n@@ -1984,7 +1988,1 @@\n-                else {\n-                    int phase;\n-                    if ((idle = (phase = w.phase) & IDLE) != 0) {\n-                        if ((idle = awaitWork(w, phase)) != 0)\n-                            break;\n-                        src = -1;\n-                    }\n+                else if ((idle = awaitWork(w)) == 0)\n@@ -1992,1 +1990,2 @@\n-                }\n+                else\n+                    break;\n@@ -2000,1 +1999,1 @@\n-     * Deactivates and enqueues worker\n+     * Deactivates and enqueues worker, backing out on signal\n@@ -2012,1 +2011,1 @@\n-            do {                             \/\/  enqueue\n+            for (;;)       {                 \/\/ try to enqueue\n@@ -2014,2 +2013,9 @@\n-            } while (pc != (pc = U.compareAndExchangeLong(\n-                                this, CTL, pc, c = ((pc - RC_UNIT) & UMASK) | sp)));\n+                if (pc == (pc = U.compareAndExchangeLong(\n+                               this, CTL, pc, c = ((pc - RC_UNIT) & UMASK) | sp)))\n+                    break;\n+                else if ((c & RC_MASK) < (pc & RC_MASK)) {\n+                    w.phase = phase;         \/\/ back out if lost to signal\n+                    idle = 0;\n+                    break;\n+                }\n+            }\n@@ -2022,8 +2028,5 @@\n-            if (((e = runState) & STOP) != 0L ||\n-                ((e & SHUTDOWN) != 0L && (c & RC_MASK) == 0L && quiescent() > 0))\n-                releaseWaiters();\n-            else {                           \/\/ spin for approx 1 scan cost\n-                int tc = (short)(c >>> TC_SHIFT);\n-                int spins = Math.max((tc << 1) + tc, SPIN_WAITS);\n-                while ((idle = w.phase & IDLE) != 0 && --spins != 0)\n-                    Thread.onSpinWait();\n+            if (idle != 0 &&\n+                ((e = runState) & STOP) == 0L &&\n+                ((e & SHUTDOWN) == 0L || (c & RC_MASK) > 0L || quiescent() <= 0)) {\n+                for (int s = SPIN_WAITS; (idle = w.phase & IDLE) != 0 && --s != 0;)\n+                    Thread.onSpinWait();     \/\/ spin before rescan\n@@ -2060,1 +2063,0 @@\n-     * @param phase w's current phase (must be inactive)\n@@ -2063,3 +2065,3 @@\n-    private int awaitWork(WorkQueue w, int phase) {\n-        int idle = IDLE;\n-        if (w != null) {                      \/\/ always true; hoist checks\n+    private int awaitWork(WorkQueue w) {\n+        int idle = 0, phase;\n+        if (w != null && (idle = (phase = w.phase) & IDLE) != 0) {\n@@ -2068,2 +2070,4 @@\n-            LockSupport.setCurrentBlocker(this);\n-            for (;;) {\n+            do {\n+                boolean trimmable = false;    \/\/ use timed wait if trimmable\n+                int spins = 0;\n+                long d = 0L, c;\n@@ -2073,10 +2077,13 @@\n-                boolean trimmable = false;    \/\/ use timed wait if trimmable\n-                long d = 0L, c;\n-                if (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase) {\n-                    long now = System.currentTimeMillis();\n-                    if (deadline == 0L)\n-                        deadline = waitTime + now;\n-                    if (deadline - now <= TIMEOUT_SLOP) {\n-                        if (tryTrim(w, c, activePhase))\n-                            break;\n-                        continue;             \/\/ lost race to trim\n+                if ((int)(c = ctl) == activePhase) {\n+                    spins = SPIN_WAITS;       \/\/ trim or spin at head\n+                    if ((c & RC_MASK) == 0L) {\n+                        long now = System.currentTimeMillis();\n+                        if (deadline == 0L)\n+                            deadline = waitTime + now;\n+                        if (deadline - now <= TIMEOUT_SLOP) {\n+                            if (tryTrim(w, c, activePhase))\n+                                break;\n+                            continue;         \/\/ lost race to trim\n+                        }\n+                        d = deadline;\n+                        trimmable = true;\n@@ -2084,2 +2091,0 @@\n-                    d = deadline;\n-                    trimmable = true;\n@@ -2087,1 +2092,3 @@\n-                if ((idle = w.phase & IDLE) == 0)\n+                while ((idle = w.phase & IDLE) != 0 && spins-- != 0)\n+                    Thread.onSpinWait();\n+                if (idle == 0)\n@@ -2089,0 +2096,1 @@\n+                LockSupport.setCurrentBlocker(this);\n@@ -2093,4 +2101,2 @@\n-                if (idle == 0 || (idle = w.phase & IDLE) == 0)\n-                    break;\n-            }\n-            LockSupport.setCurrentBlocker(null);\n+                LockSupport.setCurrentBlocker(null);\n+            } while (idle != 0 && (idle = w.phase & IDLE) != 0);\n@@ -2283,1 +2289,1 @@\n-                                    w.source = j;\n+                                    U.putIntVolatile(w, WorkQueue.SOURCE, j);\n@@ -2355,0 +2361,1 @@\n+                                        U.storeFence();\n@@ -2438,1 +2445,1 @@\n-                                w.source = j;\n+                                U.putIntVolatile(w, WorkQueue.SOURCE, j);\n@@ -2556,1 +2563,1 @@\n-        for (;;) {\n+        for (;; r = ThreadLocalRandom.advanceProbe(r)) {\n@@ -2573,1 +2580,12 @@\n-                q.push(task, signalIfEmpty ? this : null, unlock);\n+                ForkJoinTask<?>[] a = q.array;\n+                int b = q.base, s = q.top, cap;\n+                if (a == null || ((cap = a.length) - (s + 1 - b)) <= 0 || cap <= 0)\n+                    q.growAndPush(task, this, unlock);\n+                else {\n+                    q.top = s + 1;\n+                    a[(cap - 1) & s] = task;\n+                    long pk = slotOffset((cap - 1) & (s - 1)); \/\/ predecessor index\n+                    q.phase = unlock;\n+                    if (U.getReferenceAcquire(a, pk) == null && signalIfEmpty)\n+                        signalWork(q, s);\n+                }\n@@ -2576,1 +2594,0 @@\n-            r = ThreadLocalRandom.advanceProbe(r); \/\/ move\n@@ -2585,1 +2602,1 @@\n-            wt.workQueue.push(task, signalIfEmpty ? this : null, 1);\n+            wt.workQueue.push(task, signalIfEmpty ? this : null);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":102,"deletions":85,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-            ((wt = (ForkJoinWorkerThread)t).workQueue).push(this, wt.pool, 1);\n+            ((wt = (ForkJoinWorkerThread)t).workQueue).push(this, wt.pool);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}