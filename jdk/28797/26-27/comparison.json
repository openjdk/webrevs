{"files":[{"patch":"@@ -1068,1 +1068,1 @@\n-    static final int SPIN_WAITS       = 1 <<  7;   \/\/ max calls to onSpinWait\n+    static final int SPIN_WAITS       = 1 <<  8;   \/\/ max calls to onSpinWait\n@@ -1259,1 +1259,1 @@\n-            int b = base, s = top, cap, m;\n+            int b = base, s = top, cap, m; long pos;\n@@ -1264,1 +1264,1 @@\n-                U.getAndSetReference(a, slotOffset(m & s), task);\n+                U.getAndSetReference(a, pos = slotOffset(m & s), task);\n@@ -1271,1 +1271,1 @@\n-                    pool.signalWork(this, s); \/\/ may have appeared empty\n+                    pool.signalWork(a, pos); \/\/ may have appeared empty\n@@ -1300,0 +1300,1 @@\n+                    long pos = slotOffset(s & newMask);\n@@ -1304,1 +1305,1 @@\n-                        pool.signalWork(this, s);\n+                        pool.signalWork(newArray, pos);\n@@ -1421,0 +1422,22 @@\n+        \/**\n+         * Tries once to poll for a task\n+         * @param pool if non-null, pool to propagate signals\n+         *\/\n+        private ForkJoinTask<?> tryPoll(ForkJoinPool pool) {\n+           ForkJoinTask<?>[] a; int cap, b, nb; long bp;\n+            if ((a = array) != null && (cap = a.length) > 0) {\n+                 ForkJoinTask<?> t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                    a, bp = slotOffset((cap - 1) & (b = base)));\n+                long np = slotOffset((cap - 1) & (nb = b + 1));\n+                if (t != null && base == b &&\n+                    U.compareAndSetReference(a, bp, t, null)) {\n+                    Object nt = U.getReference(a, np);\n+                    U.getAndSetInt(this, BASE, nb);\n+                    if (pool != null && nt != null)\n+                        pool.signalWork(a, np);\n+                    return t;\n+                }\n+            }\n+            return null;\n+        }\n+\n@@ -1423,0 +1446,17 @@\n+        \/**\n+         * Runs the given task, as well as remaining local tasks\n+         *\/\n+        final int topLevelExec(ForkJoinTask<?> task, WorkQueue q, ForkJoinPool pool,\n+                               int fifo) {\n+            ForkJoinPool p = (fifo == 0) ? null : pool;\n+            int taken = 1;\n+            while (task != null) {\n+                task.doExec();\n+                if ((task = nextLocalTask(fifo)) == null &&\n+                    (q == null || (task = q.tryPoll(p)) == null))\n+                    break;\n+                ++taken;\n+            }\n+            return taken;\n+        }\n+\n@@ -1806,1 +1846,1 @@\n-            signalWork(null, 0);           \/\/ possibly replace\n+            signalWork(null, 0L);          \/\/ possibly replace\n@@ -1814,2 +1854,1 @@\n-     * giving up on contention if q is nonull and signalled slot\n-     * already taken.\n+     * giving up on contention if source slot already taken.\n@@ -1817,2 +1856,2 @@\n-     * @param src, if nonnull, the WorkQueue containing signalled task\n-     * @param base src's base index for the task\n+     * @param src, if nonnull, the array containing signalled task\n+     * @param offset slot offset for the task\n@@ -1820,3 +1859,3 @@\n-    final void signalWork(WorkQueue src, int base) {\n-        int pc = parallelism, i, sp;\n-        long c = U.getLong(this, CTL); \/\/ rely on caller sync for initial reads\n+    final void signalWork(ForkJoinTask<?>[] src, long offset) {\n+        int pc = parallelism, i, sp; \/\/ rely on caller sync for initial reads\n+        long c = U.getLong(this, CTL);\n@@ -1826,2 +1865,2 @@\n-            WorkQueue v; long nc;\n-            if (i == 0) {\n+            WorkQueue w = qs[i], v = null; long nc;\n+            if (i == 0 || w == null) {\n@@ -1830,1 +1869,0 @@\n-                v = null;\n@@ -1833,2 +1871,0 @@\n-            else if ((v = qs[i]) == null)\n-                break;\n@@ -1836,1 +1872,1 @@\n-                nc = (v.stackPred & LMASK) | ((c + RC_UNIT) & UMASK);\n+                nc = ((v = w).stackPred & LMASK) | ((c + RC_UNIT) & UMASK);\n@@ -1848,1 +1884,1 @@\n-            if (src != null && src.base - base > 0)\n+            if (src != null && U.getReference(src, offset) == null)\n@@ -1928,2 +1964,1 @@\n-            int fifo = (int)config & FIFO, idle = 0;\n-            for (boolean scanned = false;;) {\n+            for (int fifo = (int)config & FIFO, idle = 0, taken = 0;;) {\n@@ -1935,2 +1970,2 @@\n-                boolean found = false;\n-                if ((e & STOP) != 0L || n <= 0)\n+                if ((e & STOP) != 0L || n <= 0) {\n+                    w.nsteals += taken;\n@@ -1938,0 +1973,2 @@\n+                }\n+                boolean rescan = false;\n@@ -1941,1 +1978,1 @@\n-                        ForkJoinTask<?>[] a; int cap;     \/\/ poll queue\n+                        ForkJoinTask<?>[] a; int pb = -1, cap; \/\/ poll queue\n@@ -1948,5 +1985,14 @@\n-                            if (q.array == a && q.base == b &&\n-                                U.getReference(a, bp) == t) {\n-                                if (t == null) {\n-                                    if (nt == null && (!scanned || q.top == b)) {\n-                                        found = false;\n+                            int qb = q.base;              \/\/ reread\n+                            if (idle != 0) {\n+                                if (t == null && nt == null && q.top - qb <= 0)\n+                                    break;\n+                                if ((idle = tryReactivate(w)) != 0) {\n+                                    rescan = true;\n+                                    break scan;           \/\/ can't take yet\n+                                }\n+                            }\n+                            else if (qb != b)             \/\/ inconsistent\/busy\n+                                ;\n+                            else if (t == null) {\n+                                if (q.array == a && U.getReference(a, bp) == null) {\n+                                    if (nt == null)\n@@ -1954,0 +2000,3 @@\n+                                    if (pb == (pb = b)) {\n+                                        rescan = true;    \/\/ stalled; reorder scan\n+                                        break scan;\n@@ -1955,17 +2004,0 @@\n-                                    if (found)\n-                                        break scan;       \/\/ stall check\n-                                    found = true;\n-                                }\n-                                else if (idle != 0) {\n-                                    found = true;\n-                                    if ((idle = tryReactivate(w)) != 0)\n-                                        break scan;       \/\/ can't take yet\n-                                }\n-                                else if (U.compareAndSetReference(a, bp, t, null)) {\n-                                    nt = U.getReference(a, np);\n-                                    U.getAndSetInt(q, WorkQueue.BASE, nb);\n-                                    if (nt != null)       \/\/ propagate\n-                                        signalWork(q, nb);\n-                                    topLevelExec(t, w, q, fifo, qid);\n-                                    found = true;\n-                                    break scan;\n@@ -1974,0 +2006,10 @@\n+                            else if (U.compareAndSetReference(a, bp, t, null)) {\n+                                nt = U.getReference(a, np);\n+                                U.getAndSetInt(q, WorkQueue.BASE, nb);\n+                                if (nt != null)           \/\/ propagate\n+                                    signalWork(a, np);\n+                                w.source = qid;\n+                                taken += w.topLevelExec(t, q, this, fifo);\n+                                rescan = true;\n+                                break scan;\n+                            }\n@@ -1977,41 +2019,3 @@\n-                if (found)\n-                    scanned = false;\n-                else if (!scanned && idle == 0)\n-                    scanned = true;\n-                else if (!scanned || idle == 0) {\n-                    if ((idle = deactivate(w, idle)) == 0)\n-                        scanned = false;\n-                }\n-                else {\n-                    awaitWork(w);\n-                    idle = 0;\n-                    scanned = false;\n-                }\n-            }\n-        }\n-    }\n-\n-    private void topLevelExec(ForkJoinTask<?> t, WorkQueue w, WorkQueue q,\n-                              int fifo, int qid) {\n-        if (t != null && q != null && w != null) { \/\/ always true; hoist checks\n-            w.source = qid;\n-            int taken = 1;\n-            for (;;) {\n-                t.doExec();\n-                if ((t = w.nextLocalTask(fifo)) == null) {\n-                    ForkJoinTask<?>[] a; int cap, b, nb; long bp, np;\n-                    if ((a = q.array) == null || (cap = a.length) <= 0)\n-                        break;                     \/\/ similar to runWorker scan\n-                    t = (ForkJoinTask<?>)U.getReferenceAcquire(\n-                        a, bp = slotOffset((cap - 1) & (b = q.base)));\n-                    Object nt = U.getReference(\n-                        a, np = slotOffset((cap - 1) & (nb = b + 1)));\n-                    if (t == null || q.base != b ||\n-                        !U.compareAndSetReference(a, bp, t, null))\n-                        break;\n-                    nt = U.getReference(a, np);\n-                    U.getAndSetInt(q, WorkQueue.BASE, nb);\n-                    ++taken;\n-                    if (nt != null &&              \/\/ prevent stalls\n-                        (fifo != 0 || (t instanceof ForkJoinTask.InterruptibleTask)))\n-                        signalWork(q, nb);\n+                if (!rescan) {\n+                    idle = onEmptyScan(w, idle, taken);\n+                    taken = 0;\n@@ -2020,4 +2024,0 @@\n-            w.nsteals += taken;\n-            if ((w.config & CLEAR_TLS) != 0 &&\n-                (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n-                f.resetThreadLocals();             \/\/ (instanceof check always true)\n@@ -2028,1 +2028,1 @@\n-     * Possibly deactivates and pauses worker\n+     * Possibly deactivates, reactivates or pauses worker\n@@ -2031,1 +2031,0 @@\n-     * @param idle active status\n@@ -2034,1 +2033,1 @@\n-    private int deactivate(WorkQueue w, int idle) {\n+    private int onEmptyScan(WorkQueue w, int idle, int taken) {\n@@ -2037,3 +2036,9 @@\n-            if (idle != 0)                         \/\/ already deactivated\n-                idle = phase & IDLE;\n-            else {                                 \/\/ try to deactivate\n+            if (taken != 0) {\n+                w.nsteals += taken;\n+                if ((w.config & CLEAR_TLS) != 0 &&\n+                    (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n+                    f.resetThreadLocals();         \/\/ (instanceof check always true)\n+                if ((runState & (SHUTDOWN|STOP)) == 0L)\n+                    Thread.yield();                \/\/ pause before rescan\n+            }\n+            else if (idle == 0) {                  \/\/ deactivate\n@@ -2046,2 +2051,2 @@\n-                        if (ac == 0L)             \/\/ check quiescent termination\n-                            quiescent();\n+                        if (ac == 0L && (runState & (SHUTDOWN|STOP)) == SHUTDOWN)\n+                            quiescent();           \/\/ check quiescent termination\n@@ -2057,6 +2062,3 @@\n-            if (idle != 0 && (runState & STOP) == 0L) {\n-                int noise = (phase ^ (phase >>> 16)) & (SPIN_WAITS - 1);\n-                int spins = (SPIN_WAITS << 1) | noise;\n-                Thread.yield();                   \/\/ helps when oversubscribed\n-                while ((idle = w.phase & IDLE) != 0 && --spins > 0)\n-                    Thread.onSpinWait();\n+            else if ((idle = phase & IDLE) != 0) {\n+                awaitWork(w, phase);\n+                idle = 0;\n@@ -2095,3 +2097,2 @@\n-    private void awaitWork(WorkQueue w) {\n-        int phase;\n-        if (w != null && ((phase = w.phase) & IDLE) != 0) {\n+    private void awaitWork(WorkQueue w, int phase) {\n+        if (w != null) {\n@@ -2100,1 +2101,0 @@\n-            LockSupport.setCurrentBlocker(this);\n@@ -2102,0 +2102,1 @@\n+                long d = 0L, c; int idle;\n@@ -2105,2 +2106,0 @@\n-                int idle;\n-                long d = 0L, c;               \/\/ trim at head\n@@ -2108,7 +2107,11 @@\n-                if ((int)(c = ctl) == activePhase && (c & RC_MASK) == 0L) {\n-                    trimmable = true;\n-                    long now = System.currentTimeMillis();\n-                    if (deadline == 0L)\n-                        deadline = waitTime + now;\n-                    if ((d = deadline) - now <= TIMEOUT_SLOP)\n-                        tryTrim(w, c, activePhase); \/\/ throws if trimmed\n+                int spins = ((short)((c = ctl) >>> TC_SHIFT) | 1) & SMASK;\n+                if ((int)c == activePhase) {  \/\/ at head\n+                    if ((c & RC_MASK) == 0L) {\n+                        long now = System.currentTimeMillis();\n+                        if (deadline == 0L)\n+                            deadline = waitTime + now;\n+                        if ((d = deadline) - now <= TIMEOUT_SLOP)\n+                            tryTrim(w, c, activePhase); \/\/ throws if trimmed\n+                        trimmable = true;\n+                    }\n+                    spins += SPIN_WAITS;      \/\/ spin more\n@@ -2116,1 +2119,3 @@\n-                if ((w.phase & IDLE) == 0)\n+                while ((idle = w.phase & IDLE) != 0 && --spins != 0)\n+                    Thread.onSpinWait();\n+                if (idle == 0)\n@@ -2118,0 +2123,1 @@\n+                LockSupport.setCurrentBlocker(this);\n@@ -2122,0 +2128,1 @@\n+                LockSupport.setCurrentBlocker(null);\n@@ -2125,1 +2132,0 @@\n-            LockSupport.setCurrentBlocker(null);\n@@ -2151,1 +2157,0 @@\n-                LockSupport.setCurrentBlocker(null);\n@@ -2808,2 +2813,1 @@\n-                        q.base = b + 1;\n-                        U.storeFence();\n+                        U.putIntVolatile(q, WorkQueue.BASE, b + 1);\n@@ -3306,1 +3310,1 @@\n-            signalWork(null, 0); \/\/ trigger worker activation\n+            signalWork(null, 0L); \/\/ trigger worker activation\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":129,"deletions":125,"binary":false,"changes":254,"status":"modified"}]}