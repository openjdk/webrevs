{"files":[{"patch":"@@ -1171,0 +1171,6 @@\n+    \/**\n+     * Exception thrown in tryTrim after idle timeout\n+     *\/\n+    @SuppressWarnings(\"serial\")\n+    static final class WorkerTrimmedException extends RuntimeException { }\n+\n@@ -1312,1 +1318,1 @@\n-        private ForkJoinTask<?> nextLocalTask(int fifo) {\n+        final ForkJoinTask<?> nextLocalTask(int fifo) {\n@@ -1319,4 +1325,2 @@\n-                             a, slotOffset((cap - 1) & s), null)) != null) {\n-                        top = s;\n-                        U.storeFence();\n-                    }\n+                             a, slotOffset((cap - 1) & s), null)) != null)\n+                        U.putIntOpaque(this, TOP, s);\n@@ -1327,2 +1331,1 @@\n-                            base = b + 1;\n-                            U.storeFence();\n+                            U.putIntVolatile(this, BASE, b + 1);\n@@ -1362,2 +1365,1 @@\n-                    top = s;\n-                    U.storeFence();\n+                    U.putIntOpaque(this, TOP, s);\n@@ -1412,2 +1414,1 @@\n-                    base = nb;\n-                    U.storeFence();\n+                    U.putIntVolatile(this, BASE, nb);\n@@ -1422,10 +1423,0 @@\n-        \/**\n-         * Runs the given task, as well as remaining local tasks\n-         *\/\n-        final void topLevelExec(ForkJoinTask<?> task, int fifo) {\n-            while (task != null) {\n-                task.doExec();\n-                task = nextLocalTask(fifo);\n-            }\n-        }\n-\n@@ -1511,4 +1502,2 @@\n-                         U.compareAndSetReference(a, k, t, null))) {\n-                        top = s;\n-                        U.storeFence();\n-                    }\n+                         U.compareAndSetReference(a, k, t, null)))\n+                        U.putIntOpaque(this, TOP, s);\n@@ -1551,2 +1540,1 @@\n-                    base = b + 1;\n-                    U.storeFence();\n+                    U.putIntVolatile(this, BASE, b + 1);\n@@ -1790,0 +1778,2 @@\n+        if (ex instanceof WorkerTrimmedException)\n+            ex = null;\n@@ -1831,2 +1821,2 @@\n-        int pc = parallelism, i, sp; \/\/ rely on caller sync for initial reads\n-        long c = U.getLong(this, CTL);\n+        int pc = parallelism, i, sp;\n+        long c = U.getLong(this, CTL); \/\/ rely on caller sync for initial reads\n@@ -1938,3 +1928,2 @@\n-            int fifo = (int)config & FIFO;\n-            int src = 0, idle = 0, rescans = 0, taken = 0;\n-            for (;;) {\n+            int fifo = (int)config & FIFO, idle = 0;\n+            for (boolean scanned = false;;) {\n@@ -1946,0 +1935,1 @@\n+                boolean found = false;\n@@ -1953,1 +1943,1 @@\n-                            int b, nb; long bp; ForkJoinTask<?> t;\n+                            int b, nb; long bp, np; ForkJoinTask<?> t;\n@@ -1956,1 +1946,2 @@\n-                            long np = slotOffset((nb = b + 1) & (cap - 1));\n+                            Object nt = U.getReference(\n+                                a, np = slotOffset((cap - 1) & (nb = b + 1)));\n@@ -1960,6 +1951,7 @@\n-                                    if (rescans > 0)      \/\/ ran or stalled\n-                                        break scan;\n-                                    if (U.getReference(a, np) == null &&\n-                                        (rescans == 0 || q.top == b))\n-                                        break;            \/\/ retry at most twice\n-                                    ++rescans;            \/\/ may be stalled\n+                                    if (nt == null && (!scanned || q.top == b)) {\n+                                        found = false;\n+                                        break;\n+                                    }\n+                                    if (found)\n+                                        break scan;       \/\/ stall check\n+                                    found = true;\n@@ -1968,2 +1960,2 @@\n-                                    if ((idle = tryReactivate(w)) != 0) {\n-                                        rescans = 1;\n+                                    found = true;\n+                                    if ((idle = tryReactivate(w)) != 0)\n@@ -1971,2 +1963,0 @@\n-                                    }\n-                                    rescans = 0;\n@@ -1975,1 +1965,1 @@\n-                                    Object nt = U.getReference(a, np);\n+                                    nt = U.getReference(a, np);\n@@ -1979,4 +1969,3 @@\n-                                    rescans = 1;\n-                                    if (taken++ == 0 || src != qid)\n-                                        w.source = src = qid;\n-                                    w.topLevelExec(t, fifo);\n+                                    topLevelExec(t, w, q, fifo, qid);\n+                                    found = true;\n+                                    break scan;\n@@ -1988,2 +1977,8 @@\n-                if (rescans > 0)\n-                    rescans = 0;\n+                if (found)\n+                    scanned = false;\n+                else if (!scanned && idle == 0)\n+                    scanned = true;\n+                else if (!scanned || idle == 0) {\n+                    if ((idle = deactivate(w, idle)) == 0)\n+                        scanned = false;\n+                }\n@@ -1991,7 +1986,25 @@\n-                    if (rescans == 0)\n-                        rescans = -1;\n-                    else if (idle == 0) {\n-                        if ((idle = deactivate(w)) == 0)\n-                            rescans = 0;\n-                    }\n-                    else if ((idle = rescans = awaitWork(w)) != 0)\n+                    awaitWork(w);\n+                    idle = 0;\n+                    scanned = false;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void topLevelExec(ForkJoinTask<?> t, WorkQueue w, WorkQueue q,\n+                              int fifo, int qid) {\n+        if (t != null && q != null && w != null) { \/\/ always true; hoist checks\n+            w.source = qid;\n+            int taken = 1;\n+            for (;;) {\n+                t.doExec();\n+                if ((t = w.nextLocalTask(fifo)) == null) {\n+                    ForkJoinTask<?>[] a; int cap, b, nb; long bp, np;\n+                    if ((a = q.array) == null || (cap = a.length) <= 0)\n+                        break;                     \/\/ similar to runWorker scan\n+                    t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                        a, bp = slotOffset((cap - 1) & (b = q.base)));\n+                    Object nt = U.getReference(\n+                        a, np = slotOffset((cap - 1) & (nb = b + 1)));\n+                    if (t == null || q.base != b ||\n+                        !U.compareAndSetReference(a, bp, t, null))\n@@ -1999,6 +2012,6 @@\n-                    if (idle != 0) {\n-                        int ns = taken;\n-                        taken = 0;\n-                        if ((idle = onEmptyScan(w, ns)) == 0)\n-                            rescans = 0;\n-                    }\n+                    nt = U.getReference(a, np);\n+                    U.getAndSetInt(q, WorkQueue.BASE, nb);\n+                    ++taken;\n+                    if (nt != null &&              \/\/ prevent stalls\n+                        (fifo != 0 || (t instanceof ForkJoinTask.InterruptibleTask)))\n+                        signalWork(q, nb);\n@@ -2008,0 +2021,3 @@\n+            if ((w.config & CLEAR_TLS) != 0 &&\n+                (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n+                f.resetThreadLocals();             \/\/ (instanceof check always true)\n@@ -2012,2 +2028,1 @@\n-     * Deactivates and enqueues worker, possibly backing out on signal\n-     * contention.\n+     * Possibly deactivates and pauses worker\n@@ -2016,1 +2031,2 @@\n-     * @return active status\n+     * @param idle active status\n+     * @return 0 if now active\n@@ -2018,18 +2034,21 @@\n-    private int deactivate(WorkQueue w) {\n-        int idle = 0;\n-        if (w != null) {                       \/\/ always true; hoist checks\n-            int phase = U.getInt(w,  WorkQueue.PHASE);\n-            long sp = (phase + NEXTIDLE) & LMASK, pc = ctl;\n-            U.putInt(w, WorkQueue.PHASE, phase | IDLE);\n-            for (;;) {                         \/\/ try to enqueue\n-                w.stackPred = (int)pc;\n-                long c = (pc - RC_UNIT) & UMASK | sp, ac = c & RC_MASK;\n-                if (pc == (pc = U.compareAndExchangeLong(this, CTL, pc, c))) {\n-                    if (ac == 0L)             \/\/ check quiescent termination\n-                        quiescent();\n-                    idle = w.phase & IDLE;\n-                    break;\n-                }\n-                else if (ac < (pc & RC_MASK)) {\n-                    w.phase = phase;           \/\/ back out if lost to signal\n-                    break;\n+    private int deactivate(WorkQueue w, int idle) {\n+        if (w != null) {                           \/\/ always true; hoist checks\n+            int phase = w.phase;\n+            if (idle != 0)                         \/\/ already deactivated\n+                idle = phase & IDLE;\n+            else {                                 \/\/ try to deactivate\n+                long sp = (phase + NEXTIDLE) & LMASK, pc = ctl;\n+                U.putInt(w, WorkQueue.PHASE, phase | IDLE);\n+                for (;;) {                         \/\/ enqueue\n+                    w.stackPred = (int)pc;\n+                    long c = (pc - RC_UNIT) & UMASK | sp, ac = c & RC_MASK;\n+                    if (pc == (pc = U.compareAndExchangeLong(this, CTL, pc, c))) {\n+                        if (ac == 0L)             \/\/ check quiescent termination\n+                            quiescent();\n+                        idle = w.phase & IDLE;\n+                        break;\n+                    }\n+                    else if (ac < (pc & RC_MASK)) {\n+                        w.phase = phase;           \/\/ back out if lost to signal\n+                        break;\n+                    }\n@@ -2038,0 +2057,7 @@\n+            if (idle != 0 && (runState & STOP) == 0L) {\n+                int noise = (phase ^ (phase >>> 16)) & (SPIN_WAITS - 1);\n+                int spins = (SPIN_WAITS << 1) | noise;\n+                Thread.yield();                   \/\/ helps when oversubscribed\n+                while ((idle = w.phase & IDLE) != 0 && --spins > 0)\n+                    Thread.onSpinWait();\n+            }\n@@ -2063,27 +2089,0 @@\n-    \/**\n-     * Spins and\/or yields to reduce unproductive scanning\n-     *\n-     * @param w the work queue\n-     * @param taken number of stolen tasks since last empty scan\n-     * @return active status\n-     *\/\n-    private int onEmptyScan(WorkQueue w, int taken) {\n-        int idle = 0;\n-        if (w != null) {                       \/\/ always true; hoist checks\n-            if (taken != 0) {\n-                w.nsteals += taken;\n-                if ((w.config & CLEAR_TLS) != 0 &&\n-                    (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n-                    f.resetThreadLocals();     \/\/ (instanceof check always true)\n-                Thread.interrupted();          \/\/ clear status\n-            }\n-            if ((idle = w.phase & IDLE) != 0 && (runState & STOP) == 0) {\n-                if (taken == 0)\n-                    Thread.yield();\n-                for (int s = SPIN_WAITS; (idle = w.phase & IDLE) != 0 && --s != 0;)\n-                    Thread.onSpinWait();\n-            }\n-        }\n-        return idle;\n-    }\n-\n@@ -2094,1 +2093,1 @@\n-     * @return 0 if now active\n+     * @throws WorkerTrimmedException on idle timeout\n@@ -2096,4 +2095,3 @@\n-    private int awaitWork(WorkQueue w) {\n-        int idle = 0, phase;\n-        if (w != null && (idle = (phase = w.phase) & IDLE) != 0) {\n-            LockSupport.setCurrentBlocker(this);\n+    private void awaitWork(WorkQueue w) {\n+        int phase;\n+        if (w != null && ((phase = w.phase) & IDLE) != 0) {\n@@ -2102,2 +2100,6 @@\n-            while ((runState & STOP) == 0L) {\n-                boolean trimmable = false;    \/\/ use timed wait if trimmable\n+            LockSupport.setCurrentBlocker(this);\n+            for (;;) {\n+                Thread.interrupted();         \/\/ clear status\n+                if ((runState & STOP) != 0L)\n+                    break;\n+                int idle;\n@@ -2105,0 +2107,1 @@\n+                boolean trimmable = false;    \/\/ use timed wait if trimmable\n@@ -2106,0 +2109,1 @@\n+                    trimmable = true;\n@@ -2109,7 +2113,2 @@\n-                    if (deadline - now <= TIMEOUT_SLOP) {\n-                        if (tryTrim(w, c, activePhase))\n-                            break;\n-                        continue;             \/\/ lost race to trim\n-                    }\n-                    d = deadline;\n-                    trimmable = true;\n+                    if ((d = deadline) - now <= TIMEOUT_SLOP)\n+                        tryTrim(w, c, activePhase); \/\/ throws if trimmed\n@@ -2117,1 +2116,1 @@\n-                if ((idle = w.phase & IDLE) == 0)\n+                if ((w.phase & IDLE) == 0)\n@@ -2123,1 +2122,1 @@\n-                if (idle == 0 || (idle = w.phase & IDLE) == 0)\n+                if (idle == 0 || (w.phase & IDLE) == 0)\n@@ -2125,1 +2124,0 @@\n-                Thread.interrupted();         \/\/ clear status for next park\n@@ -2129,1 +2127,0 @@\n-        return idle;\n@@ -2135,0 +2132,1 @@\n+     * @throws WorkerTrimmedException on idle timeout\n@@ -2136,1 +2134,1 @@\n-    private boolean tryTrim(WorkQueue w, long c, int activePhase) {\n+    private void tryTrim(WorkQueue w, long c, int activePhase) {\n@@ -2153,1 +2151,2 @@\n-                return true;\n+                LockSupport.setCurrentBlocker(null);\n+                throw new WorkerTrimmedException();\n@@ -2156,1 +2155,0 @@\n-        return false;\n@@ -2385,2 +2383,1 @@\n-                                        q.base = b + 1;\n-                                        U.storeFence();\n+                                        U.putIntVolatile(q, WorkQueue.BASE, b + 1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":132,"deletions":135,"binary":false,"changes":267,"status":"modified"}]}