{"files":[{"patch":"@@ -1257,13 +1257,6 @@\n-            int s = top, b = base, m, cap, room; ForkJoinTask<?>[] a, na;\n-            if ((a = array) != null && (cap = a.length) > 0) { \/\/ else disabled\n-                int k = (m = cap - 1) & s;\n-                if ((room = m - (s - b)) >= 0) {\n-                    top = s + 1;\n-                    long pos = slotOffset(k);\n-                    if (!internal)\n-                        U.putReference(a, pos, task);       \/\/ inside lock\n-                    else\n-                        U.getAndSetReference(a, pos, task); \/\/ fully fenced\n-                    if (room == 0 && (na = growArray(a, cap, s)) != null)\n-                        k = ((a = na).length - 1) & s;      \/\/ resize\n-                }\n+            int s = top++;                      \/\/ back out on failure\n+            ForkJoinTask<?>[] a = array;\n+            int size = s - base + 1, m;\n+            if (((a != null && a.length > size) || (a = growArray(a, s)) != null) &&\n+                (m = a.length - 1) >= 0) {\n+                a[m & s] = task;\n@@ -1272,6 +1265,3 @@\n-                if (room < 0)\n-                    throw new RejectedExecutionException(\"Queue capacity exceeded\");\n-                if (pool != null &&\n-                    (room == 0 ||\n-                     U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null))\n-                    pool.signalWork(a, k);    \/\/ may have appeared empty\n+                if (U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null &&\n+                    pool != null)\n+                    pool.signalWork(this, s);   \/\/ may have appeared empty\n@@ -1284,1 +1274,0 @@\n-         * @param cap old array capacity\n@@ -1286,1 +1275,1 @@\n-         * @return new array, or null on failure\n+         * @return new array (or throws on OOME)\n@@ -1288,4 +1277,5 @@\n-        private ForkJoinTask<?>[] growArray(ForkJoinTask<?>[] a, int cap, int s) {\n-            int newCap = (cap >= 1 << 16) ? cap << 1 : cap << 2;\n-            ForkJoinTask<?>[] newArray = null;\n-            if (a != null && a.length == cap && cap > 0 && newCap > 0) {\n+        private ForkJoinTask<?>[] growArray(ForkJoinTask<?>[] a, int s) {\n+            int cap, newCap;\n+            if (a != null && (cap = a.length) > 0 &&\n+                (newCap = (cap >= 1 << 16) ? cap << 1 : cap << 2) > 0) {\n+                ForkJoinTask<?>[] newArray = null;\n@@ -1296,1 +1286,1 @@\n-                if (newArray != null) {               \/\/ else throw on next push\n+                if (newArray != null) {\n@@ -1298,1 +1288,1 @@\n-                    for (int k = s, j = cap; j > 0; --j, --k) {\n+                    for (int k = s - 1, j = cap; j > 0; --j, --k) {\n@@ -1305,1 +1295,2 @@\n-                    updateArray(newArray);           \/\/ fully fenced\n+                    updateArray(newArray);            \/\/ fully fenced\n+                    return newArray;\n@@ -1308,1 +1299,4 @@\n-            return newArray;\n+            top = s;                                  \/\/ back out\n+            if ((phase & 1) == 0)                     \/\/ unlock if external\n+                unlockPhase();\n+            throw new RejectedExecutionException(\"Queue capacity exceeded\");\n@@ -1437,1 +1431,25 @@\n-                task = (fifo != 0) ? localPoll() : localPop();\n+                task = null;\n+                int p = top, cap; ForkJoinTask<?>[] a;\n+                if ((a = array) == null || (cap = a.length) <= 0)\n+                    break;        \/\/ currently impossible\n+                if (fifo == 0) {  \/\/ specialized localPop\n+                    int s = p - 1; long k;\n+                    if (U.getReference(\n+                            a, k = slotOffset((cap - 1) & s)) != null &&\n+                        (task = (ForkJoinTask<?>)\n+                         U.getAndSetReference(a, k, null)) != null)\n+                        top = s;\n+                } else {          \/\/ specialized localPoll\n+                    for (int b = base; p - b > 0; ) {\n+                        int nb = b + 1;\n+                        if ((task = (ForkJoinTask<?>)U.getAndSetReference(\n+                                 a, slotOffset((cap - 1) & b), null)) != null) {\n+                            base = nb;\n+                            break;\n+                        }\n+                        if (nb == p)\n+                            break;\n+                        while (b == (b = U.getIntAcquire(this, BASE)))\n+                            Thread.onSpinWait();\n+                    }\n+                }\n@@ -1654,0 +1672,3 @@\n+    private long getCtlAcquire() {\n+        return U.getLongAcquire(this, CTL);\n+    }\n@@ -1827,1 +1848,1 @@\n-            long c = ctl;                  \/\/ decrement counts\n+            long c = getCtlAcquire();      \/\/ decrement counts\n@@ -1857,1 +1878,4 @@\n-     * giving up if array a is nonnull and task at a[k] already taken.\n+     * giving up q is nonull and signalled slot already taken.\n+     *\n+     * @param q, if nonnull, the WorkQueue containing signalled task\n+     * @param qbase q's base index for the task\n@@ -1859,1 +1883,1 @@\n-    final void signalWork(ForkJoinTask<?>[] a, int k) {\n+    final void signalWork(WorkQueue q, int qbase) {\n@@ -1861,1 +1885,1 @@\n-        for (long c = ctl;;) {\n+        for (long c = getCtlAcquire();;) {\n@@ -1881,3 +1905,1 @@\n-            if (a != null && k < a.length && k >= 0 && a[k] == null)\n-                break;\n-            if (c == (c = ctl) && c == (c = compareAndExchangeCtl(c, nc))) {\n+            if (c == (c = compareAndExchangeCtl(c, nc))) {\n@@ -1893,0 +1915,2 @@\n+            if (q != null && q.base - qbase > 0)\n+                break;\n@@ -1900,1 +1924,1 @@\n-        for (long c = ctl;;) {\n+        for (long c = getCtlAcquire();;) {\n@@ -1927,1 +1951,1 @@\n-                long c = ctl;\n+                long c = getCtlAcquire();\n@@ -1970,0 +1994,1 @@\n+            int src = -1;                                 \/\/ last queue taken from\n@@ -1979,1 +2004,1 @@\n-                            int b, nb, nk; long bp; ForkJoinTask<?> t;\n+                            int b, nb; long bp; ForkJoinTask<?> t;\n@@ -1982,1 +2007,1 @@\n-                            long np = slotOffset(nk = (nb = b + 1) & (cap - 1));\n+                            long np = slotOffset((nb = b + 1) & (cap - 1));\n@@ -2005,1 +2030,0 @@\n-                                    w.source = qid;\n@@ -2007,4 +2031,4 @@\n-                                    ++taken;\n-                                    if (nt != null &&     \/\/ confirm a[nk]\n-                                        U.getReferenceAcquire(a, np) == nt)\n-                                        signalWork(a, nk); \/\/ propagate\n+                                    if (taken++ == 0 || qid != src)\n+                                        w.source = src = qid;\n+                                    if (nt != null && q.base == nb)\n+                                        signalWork(q, nb); \/\/ propagate\n@@ -2043,1 +2067,1 @@\n-            w.stackPred = (int)(pc = ctl);    \/\/ set ctl stack link\n+            w.stackPred = (int)(pc = getCtlAcquire());    \/\/ set ctl stack link\n@@ -2078,1 +2102,1 @@\n-                (int)(c = ctl) == (activePhase = phase + IDLE) &&\n+                (int)(c = getCtlAcquire()) == (activePhase = phase + IDLE) &&\n@@ -2106,1 +2130,1 @@\n-                    if (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase) {\n+                    if (((c = getCtlAcquire()) & RC_MASK) == 0L && (int)c == activePhase) {\n@@ -2267,1 +2291,1 @@\n-                    if (sctl == (sctl = ctl) && (s = tryCompensate(sctl)) >= 0)\n+                    if (sctl == (sctl = getCtlAcquire()) && (s = tryCompensate(sctl)) >= 0)\n@@ -2347,1 +2371,1 @@\n-                    if (sctl == (sctl = ctl) &&\n+                    if (sctl == (sctl = getCtlAcquire()) &&\n@@ -4007,1 +4031,1 @@\n-        long c = ctl;\n+        long c = getCtlAcquire();\n@@ -4301,1 +4325,1 @@\n-            long c = ctl;\n+            long c = getCtlAcquire();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":77,"deletions":53,"binary":false,"changes":130,"status":"modified"}]}