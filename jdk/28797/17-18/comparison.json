{"files":[{"patch":"@@ -1259,1 +1259,1 @@\n-                    phase = unlock;\n+                    U.putInt(this, PHASE, unlock);\n@@ -1310,1 +1310,1 @@\n-                             a, slotOffset((cap - 1) & s), null)) != null) {\n+                             a, slotOffset((cap - 1) & s), null)) != null)\n@@ -1312,2 +1312,0 @@\n-                        U.storeFence();\n-                    }\n@@ -1319,1 +1317,0 @@\n-                            U.storeFence();\n@@ -1336,1 +1333,4 @@\n-            return nextLocalTask(config & FIFO);\n+            U.loadFence();  \/\/ ensure ordering for external callers\n+            ForkJoinTask<?> t = nextLocalTask(config & FIFO);\n+            U.storeFence();\n+            return t;\n@@ -1353,2 +1353,1 @@\n-                    top = s;\n-                    U.storeFence();\n+                    U.putIntOpaque(this, TOP, s);\n@@ -1417,1 +1416,0 @@\n-        \/\/        @jdk.internal.vm.annotation.DontInline\n@@ -1457,1 +1455,0 @@\n-                            U.storeFence();\n@@ -1504,1 +1501,1 @@\n-                         U.compareAndSetReference(a, k, t, null))) {\n+                         U.compareAndSetReference(a, k, t, null)))\n@@ -1506,2 +1503,0 @@\n-                        U.storeFence();\n-                    }\n@@ -1545,1 +1540,0 @@\n-                    U.storeFence();\n@@ -1916,2 +1910,1 @@\n-                         U.compareAndSetLong(this, RUNSTATE, e, e | STOP)) {\n-                    releaseWaiters();\n+                         U.compareAndSetLong(this, RUNSTATE, e, e | STOP))\n@@ -1919,1 +1912,0 @@\n-                }\n@@ -1951,16 +1943,3 @@\n-                            if (q.base == b) {            \/\/ else inconsistent\n-                                if (t == null) {\n-                                    if (q.array == a) {   \/\/ else resized\n-                                        if (rescans > 0)  \/\/ ran or stalled\n-                                            break scan;\n-                                        if (U.getReference(a, np) == null &&\n-                                            (rescans >= 0 ||\n-                                             (U.getReferenceAcquire(a, bp) == null &&\n-                                              q.top == q.base)))\n-                                            break;\n-                                        rescans = 1;      \/\/ may be stalled\n-                                    }\n-                                }\n-                                else if (idle != 0) {\n-                                    if ((idle = tryReactivate(w)) != 0) {\n-                                        rescans = 1;      \/\/ can't take yet\n+                            if (t == null) {\n+                                if (q.base == b && q.array == a) {\n+                                    if (rescans > 0)      \/\/ ran or stalled\n@@ -1968,12 +1947,12 @@\n-                                    }\n-                                }\n-                                else if (U.compareAndSetReference(a, bp, t, null)) {\n-                                    Object nt = U.getReference(a, np);\n-                                    U.getAndSetInt(q, WorkQueue.BASE, nb);\n-                                    if (nt != null)\n-                                        signalWork(q, nb); \/\/ propagate\n-                                    rescans = 1;\n-                                    ++taken;\n-                                    if (src != qid)\n-                                        w.source = src = qid;\n-                                    w.topLevelExec(t, fifo);\n+                                    if (U.getReference(a, np) == null &&\n+                                        (rescans >= 0 ||\n+                                         (U.getReferenceAcquire(a, bp) == null &&\n+                                          q.top == q.base)))\n+                                        break;\n+                                    rescans = 1;          \/\/ may be stalled\n+                                }                         \/\/ else inconsistent\n+                            }\n+                            else if (idle != 0) {\n+                                if ((idle = tryReactivate(w)) != 0) {\n+                                    rescans = 1;          \/\/ can't take yet\n+                                    break scan;\n@@ -1982,0 +1961,12 @@\n+                            else if (q.base == b &&\n+                                     U.compareAndSetReference(a, bp, t, null)) {\n+                                Object nt = U.getReference(a, np);\n+                                U.getAndSetInt(q, WorkQueue.BASE, nb);\n+                                if (nt != null)\n+                                    signalWork(q, nb);    \/\/ propagate\n+                                rescans = 1;\n+                                ++taken;\n+                                if (src != qid)\n+                                    w.source = src = qid;\n+                                w.topLevelExec(t, fifo);\n+                            }\n@@ -1989,0 +1980,4 @@\n+                else if (idle == 0) {\n+                    idle = deactivate(w, taken);\n+                    taken = 0;\n+                }\n@@ -1990,5 +1985,4 @@\n-                    int ns = taken, phase;\n-                    rescans = taken = 0;\n-                    if ((idle = (phase = w.phase) & IDLE) == 0)\n-                        idle = deactivate(w, phase, ns);\n-                    else if ((idle = awaitWork(w, phase)) == 0)\n+                    int phase;\n+                    if ((idle = (phase = w.phase) & IDLE) != 0) {\n+                        if ((idle = awaitWork(w, phase)) != 0)\n+                            break;\n@@ -1996,2 +1990,2 @@\n-                    else\n-                        break;\n+                    }\n+                    rescans = 0;\n@@ -2006,1 +2000,1 @@\n-     * Tries to deactivate worker, keeping active on contention\n+     * Deactivates and enqueues worker\n@@ -2009,1 +2003,0 @@\n-     * @param phase w's current phase (must be active)\n@@ -2011,1 +2004,1 @@\n-     * @return nonzero if inactive\n+     * @return active status\n@@ -2013,2 +2006,2 @@\n-    private int deactivate(WorkQueue w, int phase, int taken) {\n-        int idle = 0;\n+    private int deactivate(WorkQueue w, int taken) {\n+        int idle = IDLE;\n@@ -2016,0 +2009,7 @@\n+            int phase = U.getInt(w,  WorkQueue.PHASE);\n+            long sp = (phase + NEXTIDLE) & LMASK, pc = ctl, c, e;\n+            U.putInt(w, WorkQueue.PHASE, phase | IDLE);\n+            do {                             \/\/  enqueue\n+                w.stackPred = (int)pc;\n+            } while (pc != (pc = U.compareAndExchangeLong(\n+                                this, CTL, pc, c = ((pc - RC_UNIT) & UMASK) | sp)));\n@@ -2022,22 +2022,8 @@\n-            long sp = (phase + NEXTIDLE) & LMASK, pc = ctl;\n-            U.putInt(w, WorkQueue.PHASE, phase | IDLE);\n-            for (;;)       {                 \/\/ try to enqueue\n-                long c, e;\n-                w.stackPred = (int)pc;\n-                if (pc == (pc = U.compareAndExchangeLong(\n-                               this, CTL, pc, c = ((pc - RC_UNIT) & UMASK) | sp))) {\n-                    idle = IDLE;\n-                    if (((e = runState) & STOP) == 0L &&\n-                        ((e & SHUTDOWN) == 0L || (c & RC_MASK) > 0L ||\n-                         quiescent() <= 0)) {  \/\/ spin for approx 1 scan cost\n-                        int tc = (short)(c >>> TC_SHIFT);\n-                        int spins = Math.max((tc << 1) + tc, SPIN_WAITS);\n-                        while ((idle = w.phase & IDLE) != 0 && --spins != 0)\n-                            Thread.onSpinWait();\n-                    }\n-                    break;\n-                }\n-                else if ((c & RC_MASK) < (pc & RC_MASK)) {\n-                    w.phase = phase;         \/\/ back out if lost to signal\n-                    break;\n-                }\n+            if (((e = runState) & STOP) != 0L ||\n+                ((e & SHUTDOWN) != 0L && (c & RC_MASK) == 0L && quiescent() > 0))\n+                releaseWaiters();\n+            else {                           \/\/ spin for approx 1 scan cost\n+                int tc = (short)(c >>> TC_SHIFT);\n+                int spins = Math.max((tc << 1) + tc, SPIN_WAITS);\n+                while ((idle = w.phase & IDLE) != 0 && --spins != 0)\n+                    Thread.onSpinWait();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":65,"deletions":79,"binary":false,"changes":144,"status":"modified"}]}