{"files":[{"patch":"@@ -1179,1 +1179,1 @@\n-        volatile int base;         \/\/ index of next slot for poll\n+        int base;                  \/\/ index of next slot for poll\n@@ -1244,2 +1244,1 @@\n-         * Pushes a task on an internal queue. Called only by owner.\n-         * (Use pool.externalPush for external queues).\n+         * Pushes a task. Called only by owner or if already locked\n@@ -1248,1 +1247,2 @@\n-         * @param pool the pool to signal if was previously empty or resized\n+         * @param pool the pool to signal if was previously empty, else null\n+         * @param unlock if not 1, phase unlock value\n@@ -1251,1 +1251,1 @@\n-        final void push(ForkJoinTask<?> task, ForkJoinPool pool) {\n+        final void push(ForkJoinTask<?> task, ForkJoinPool pool, int unlock) {\n@@ -1253,3 +1253,3 @@\n-            int s = top, m, cap = (a == null) ? 0 : a.length;\n-            if (cap <= s + 1 - base || (m = cap - 1) < 0)\n-                growAndPush(task, pool, 1);\n+            int b = base, s = top, cap, m;\n+            if (a == null || (cap = a.length) <= s + 1 - b || (m = cap - 1) < 0)\n+                growAndPush(task, pool, unlock);\n@@ -1259,0 +1259,2 @@\n+                if (unlock != 1)              \/\/ release external lock\n+                    U.putInt(this, PHASE, unlock);\n@@ -1313,2 +1315,2 @@\n-            int s = top - 1, b, cap = (a == null) ? 0 : a.length;\n-            if (s - (b = base) >= 0 && cap > 0) {\n+            int b = base, s = top - 1, cap;\n+            if (a != null && s - b >= 0 && (cap = a.length) > 0) {\n@@ -1318,1 +1320,1 @@\n-                        U.putIntOpaque(this, TOP, s);\n+                        top = s;\n@@ -1328,1 +1330,1 @@\n-                        while (b == (b = base))\n+                        while (b == (b = U.getIntAcquire(this, BASE)))\n@@ -1340,1 +1342,4 @@\n-            return nextLocalTask(config & FIFO);\n+            U.loadFence();  \/\/ ensure ordering for external callers\n+            ForkJoinTask<?> t = nextLocalTask(config & FIFO);\n+            U.storeFence();\n+            return t;\n@@ -1408,1 +1413,1 @@\n-                    base = nb;\n+                    U.putIntVolatile(this, BASE, nb);\n@@ -1433,2 +1438,2 @@\n-            int p = top, s = p - 1, cap = (a == null) ? 0 : a.length, d = p - base;\n-            if (cap > 0) {\n+            int b = base, p = top, s = p - 1, d = p - b, cap;\n+            if (a != null && (cap = a.length) > 0) {\n@@ -1552,7 +1557,0 @@\n-        final int spinWaitPhase() {\n-            int spins = SPIN_WAITS, f;\n-            while (((f = phase) & IDLE) != 0 && --spins != 0)\n-                Thread.onSpinWait();\n-            return f;\n-        }\n-\n@@ -1826,2 +1824,2 @@\n-     * @param q, if nonnull, the WorkQueue containing signalled task\n-     * @param qbase q's base index for the task\n+     * @param src, if nonnull, the WorkQueue containing signalled task\n+     * @param base src's base index for the task\n@@ -1829,14 +1827,8 @@\n-    final void signalWork(WorkQueue q, int qbase) {\n-        int pc = parallelism;\n-        for (long c = ctl;;) {\n-            WorkQueue[] qs = queues;\n-            long ac = (c + RC_UNIT) & RC_MASK, nc;\n-            int sp = (int)c, i = sp & SMASK;\n-            if ((short)(c >>> RC_SHIFT) >= pc)\n-                break;\n-            if (qs == null)\n-                break;\n-            if (qs.length <= i)\n-                break;\n-            WorkQueue w = qs[i], v = null;\n-            if (sp == 0) {\n+    final void signalWork(WorkQueue src, int base) {\n+        int pc = parallelism, i, sp; \/\/ rely on caller sync for initial reads\n+        long c = U.getLong(this, CTL);\n+        WorkQueue[] qs = queues;\n+        while ((short)(c >>> RC_SHIFT) < pc && qs != null &&\n+               qs.length > (i = (sp = (int)c) & SMASK)) {\n+            WorkQueue v; long nc;\n+            if (i == 0) {\n@@ -1845,1 +1837,2 @@\n-                nc = ((c + TC_UNIT) & TC_MASK) | ac;\n+                v = null;\n+                nc = ((c + TC_UNIT) & TC_MASK) | ((c + RC_UNIT) & RC_MASK);\n@@ -1847,1 +1840,1 @@\n-            else if ((v = w) == null)\n+            else if ((v = qs[i]) == null)\n@@ -1850,5 +1843,2 @@\n-                nc = (v.stackPred & LMASK) | (c & TC_MASK) | ac;\n-            if (q != null && q.base - qbase > 0)\n-                break;\n-            if (c == (c = ctl) &&\n-                c == (c = U.compareAndExchangeLong(this, CTL, c, nc))) {\n+                nc = (v.stackPred & LMASK) | ((c + RC_UNIT) & UMASK);\n+            if (c == (c = U.compareAndExchangeLong(this, CTL, c, nc))) {\n@@ -1864,0 +1854,3 @@\n+            qs = queues;\n+            if (src != null && src.base - base > 0)\n+                break;\n@@ -1941,1 +1934,0 @@\n-            WorkQueue[] qs; int n;\n@@ -1945,2 +1937,4 @@\n-            while ((runState & STOP) == 0L && (qs = queues) != null &&\n-                   (n = qs.length) > 0) {\n+            for (;;) {\n+                WorkQueue[] qs;\n+                long e = runState;\n+                int n = ((qs = queues) == null) ? 0 : qs.length;\n@@ -1949,0 +1943,2 @@\n+                if ((e & STOP) != 0L || n <= 0)\n+                    break;\n@@ -1958,1 +1954,2 @@\n-                            if (q.base == b) {            \/\/ else inconsistent\n+                            if (q.array == a && q.base == b &&\n+                                U.getReference(a, bp) == t) {\n@@ -1960,9 +1957,6 @@\n-                                    if (q.array == a) {   \/\/ else resized\n-                                        if (rescans > 0)  \/\/ ran or stalled\n-                                            break scan;\n-                                        if (U.getReference(a, np) == null &&\n-                                            U.getReference(a, bp) == null &&\n-                                            (rescans >= 0 || q.top == b))\n-                                            break;\n-                                        rescans = 1;      \/\/ may be stalled\n-                                    }\n+                                    if (rescans > 0)      \/\/ ran or stalled\n+                                        break scan;\n+                                    if (U.getReference(a, np) == null &&\n+                                        (rescans == 0 || q.top == b))\n+                                        break;            \/\/ retry at most twice\n+                                    ++rescans;            \/\/ may be stalled\n@@ -1972,2 +1966,2 @@\n-                                        rescans = 1;      \/\/ can't take yet\n-                                        break scan;\n+                                        rescans = 1;\n+                                        break scan;       \/\/ can't take yet\n@@ -1975,0 +1969,1 @@\n+                                    rescans = 0;\n@@ -1978,1 +1973,1 @@\n-                                    q.base = nb;\n+                                    U.getAndSetInt(q, WorkQueue.BASE, nb);\n@@ -1990,1 +1985,2 @@\n-                if (rescans >= 0)\n+                int phase;\n+                if (rescans >= 0) {\n@@ -1992,0 +1988,3 @@\n+                    if (idle != 0)\n+                        idle = w.phase & IDLE;\n+                }\n@@ -1993,2 +1992,2 @@\n-                    deactivate(w, taken);\n-                    idle = IDLE;\n+                    if ((idle = deactivate(w, taken)) == 0)\n+                        rescans = 0;\n@@ -1997,1 +1996,2 @@\n-                else if ((idle = awaitWork(w)) == 0)\n+                else if ((idle = (phase = w.phase) & IDLE) == 0 ||\n+                         (idle = awaitWork(w, phase)) == 0)\n@@ -2002,2 +2002,1 @@\n-            if (taken != 0)\n-                w.nsteals += taken;\n+            w.nsteals += taken;\n@@ -2008,1 +2007,2 @@\n-     * Deactivates and enqueues worker\n+     * Deactivates and enqueues worker, possibly backing out on signal\n+     * contention.\n@@ -2012,0 +2012,1 @@\n+     * @return active status\n@@ -2013,1 +2014,2 @@\n-    private void deactivate(WorkQueue w, int taken) {\n+    private int deactivate(WorkQueue w, int taken) {\n+        int idle = IDLE;\n@@ -2018,1 +2020,1 @@\n-            do {\n+            for (;;) {                      \/\/ try to enqueue\n@@ -2020,2 +2022,9 @@\n-            } while (pc != (pc = U.compareAndExchangeLong(\n-                                this, CTL, pc, c = ((pc - RC_UNIT) & UMASK) | sp)));\n+                if (pc == (pc = U.compareAndExchangeLong(\n+                               this, CTL, pc, c = ((pc - RC_UNIT) & UMASK) | sp)))\n+                    break;\n+                if ((c & RC_MASK) < (pc & RC_MASK)) {\n+                    w.phase = phase;         \/\/ back out if lost to signal\n+                    idle = 0;\n+                    break;\n+                }\n+            }\n@@ -2027,0 +2036,12 @@\n+                Thread.interrupted();        \/\/ clear status\n+            }\n+            if (idle != 0 && (runState & STOP) == 0L) {\n+                if ((c & RC_MASK) == 0L) {\n+                    if (quiescent() <= 0)    \/\/ check quiescent termination\n+                        idle = w.phase & IDLE;\n+                }\n+                else if ((idle = w.phase & IDLE) != 0) {\n+                    Thread.yield();          \/\/ reduce unproductive scanning\n+                    for (int s = SPIN_WAITS; (idle = w.phase & IDLE) != 0 && --s != 0;)\n+                        Thread.onSpinWait();\n+                }\n@@ -2028,2 +2049,0 @@\n-            if ((c & RC_MASK) == 0L && (runState & SHUTDOWN) != 0L)\n-                quiescent();                 \/\/ may trigger quiescent termination\n@@ -2031,0 +2050,1 @@\n+        return idle;\n@@ -2058,0 +2078,1 @@\n+     * @param phase w's (inactive) phase\n@@ -2060,4 +2081,3 @@\n-    private int awaitWork(WorkQueue w) {\n-        int idle = IDLE, phase;\n-        if ((runState & STOP) == 0L && w != null &&\n-             (idle = (phase = w.spinWaitPhase()) & IDLE) != 0) {\n+    private int awaitWork(WorkQueue w, int phase) {\n+        int idle = IDLE;\n+        if (w != null) {                      \/\/ always true; hoist checks\n@@ -2066,5 +2086,1 @@\n-            LockSupport.setCurrentBlocker(this);\n-            for (;;) {\n-                Thread.interrupted();         \/\/ clear status\n-                if ((runState & STOP) != 0L)\n-                    break;\n+            while ((runState & STOP) == 0L) {\n@@ -2072,9 +2088,15 @@\n-                long d = 0L, c;\n-                if (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase) {\n-                    long now = System.currentTimeMillis();\n-                    if (deadline == 0L)\n-                        deadline = waitTime + now;\n-                    if (deadline - now <= TIMEOUT_SLOP) {\n-                        if (tryTrim(w, c, activePhase))\n-                            break;\n-                        continue;             \/\/ lost race to trim\n+                long d = 0L, c;               \/\/ trim or spin at head\n+                int spins = 1;\n+                if ((int)(c = ctl) == activePhase) {\n+                    spins = SPIN_WAITS;\n+                    if ((c & RC_MASK) == 0L) {\n+                        long now = System.currentTimeMillis();\n+                        if (deadline == 0L)\n+                            deadline = waitTime + now;\n+                        if (deadline - now <= TIMEOUT_SLOP) {\n+                            if (tryTrim(w, c, activePhase))\n+                                break;\n+                            continue;         \/\/ lost race to trim\n+                        }\n+                        d = deadline;\n+                        trimmable = true;\n@@ -2082,2 +2104,0 @@\n-                    d = deadline;\n-                    trimmable = true;\n@@ -2085,1 +2105,3 @@\n-                if ((idle = w.phase & IDLE) == 0)\n+                while ((idle = w.phase & IDLE) != 0 && --spins != 0)\n+                    Thread.onSpinWait();\n+                if (idle == 0)\n@@ -2087,0 +2109,1 @@\n+                LockSupport.setCurrentBlocker(this);\n@@ -2091,0 +2114,1 @@\n+                LockSupport.setCurrentBlocker(null);\n@@ -2093,0 +2117,1 @@\n+                Thread.interrupted();         \/\/ clear status for next park\n@@ -2094,1 +2119,0 @@\n-            LockSupport.setCurrentBlocker(null);\n@@ -2329,1 +2353,1 @@\n-                            int b, cap, nb; long k;\n+                            int b, cap; long k;\n@@ -2567,3 +2591,1 @@\n-                int unlock = lock + NEXTIDLE;\n-                int s = q.top, cap = ((a = q.array) == null) ? 0 : a.length;\n-                int m = (cap <= s + 1 - q.base) ? -1 : cap - 1;\n+                 int unlock = lock + NEXTIDLE;\n@@ -2572,11 +2594,1 @@\n-                    break;                    \/\/ check while q lock held\n-                }\n-                else if (m < 0)\n-                    q.growAndPush(task, this, unlock);\n-                else {\n-                    q.top = s + 1;\n-                    a[m & s] = task;\n-                    q.phase = unlock;\n-                    if (U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null &&\n-                        signalIfEmpty)\n-                        signalWork(q, s);\n+                    break; \/\/ check while q lock held\n@@ -2584,0 +2596,1 @@\n+                q.push(task, signalIfEmpty ? this : null, unlock);\n@@ -2594,1 +2607,1 @@\n-            q.push(task, signalIfEmpty ? this : null);\n+            q.push(task, signalIfEmpty ? this : null, 1);\n@@ -3082,2 +3095,2 @@\n-        ForkJoinPool cp; int p;\n-        if ((p = (cp = common).parallelism) == 0)\n+        ForkJoinPool cp;\n+        if ((cp = common).parallelism == 0)\n@@ -3859,1 +3872,1 @@\n-     * separately by method {@link getDelayedTaskCount}.\n+     * separately by method {@link #getDelayedTaskCount}.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":129,"deletions":116,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -645,1 +645,1 @@\n-            ((wt = (ForkJoinWorkerThread)t).workQueue).push(this, wt.pool);\n+            ((wt = (ForkJoinWorkerThread)t).workQueue).push(this, wt.pool, 1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}