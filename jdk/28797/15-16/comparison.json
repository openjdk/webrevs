{"files":[{"patch":"@@ -1203,10 +1203,0 @@\n-        final void getAndSetBase(int v) {\n-            U.getAndSetInt(this, BASE, v);\n-        }\n-        final void setPhasePlain(int v) {\n-            U.putInt(this, PHASE, v);\n-        }\n-        final int getPhasePlain() {\n-            return U.getInt(this, PHASE);\n-        }\n-\n@@ -1316,2 +1306,2 @@\n-            int b = base, p = top, cap;\n-            if (a != null && (cap = a.length) > 0) {\n+            int b = base, s = top - 1, cap;\n+            if (a != null && s - b >= 0 && (cap = a.length) > 0) {\n@@ -1319,4 +1309,2 @@\n-                    int s = p - 1; long k;\n-                    if (U.getReference(a, k = slotOffset((cap - 1) & s)) != null &&\n-                        (t = (ForkJoinTask<?>)U.getAndSetReference(\n-                            a, k, null)) != null)\n+                    if ((t = (ForkJoinTask<?>)U.getAndSetReference(\n+                             a, slotOffset((cap - 1) & s), null)) != null)\n@@ -1325,2 +1313,1 @@\n-                    while (p - b > 0) {\n-                        int nb = b + 1;\n+                    do {\n@@ -1329,1 +1316,1 @@\n-                            base = nb;\n+                            base = b + 1;\n@@ -1332,1 +1319,1 @@\n-                        if (nb == p)\n+                        if (b == s)\n@@ -1336,1 +1323,1 @@\n-                    }\n+                    } while (s - b >= 0);\n@@ -1346,0 +1333,1 @@\n+            U.loadFence();  \/\/ ensure ordering for external callers\n@@ -1347,1 +1335,1 @@\n-            U.storeStoreFence(); \/\/ ensure ordering for external callers\n+            U.storeFence();\n@@ -1377,0 +1365,1 @@\n+            U.loadFence();  \/\/ ensure ordering for external callers\n@@ -1397,0 +1386,1 @@\n+            U.loadFence();  \/\/ ensure ordering for external callers\n@@ -1920,1 +1910,2 @@\n-                         U.compareAndSetLong(this, RUNSTATE, e, e | STOP))\n+                         U.compareAndSetLong(this, RUNSTATE, e, e | STOP)) {\n+                    releaseWaiters();\n@@ -1922,0 +1913,1 @@\n+                }\n@@ -1935,2 +1927,2 @@\n-        if (w != null && w.phase != 0) {                  \/\/ else unregistered\n-            WorkQueue[] qs;\n+        if (w != null) {\n+            WorkQueue[] qs; int n;\n@@ -1938,2 +1930,2 @@\n-            int fifo = (int)config & FIFO, rescans = 0, inactive = 0, taken = 0, n;\n-            int src = -1;                                 \/\/ last queue taken from\n+            int fifo = (int)config & FIFO;\n+            int src = -1, idle = 0, rescans = 0, taken = 0;\n@@ -1966,2 +1958,2 @@\n-                                else if (inactive != 0) {\n-                                    if ((inactive = tryReactivate(w)) != 0) {\n+                                else if (idle != 0) {\n+                                    if ((idle = tryReactivate(w)) != 0) {\n@@ -1974,1 +1966,1 @@\n-                                    q.getAndSetBase(nb);\n+                                    U.getAndSetInt(q, WorkQueue.BASE, nb);\n@@ -1977,1 +1969,0 @@\n-                                    ++taken;\n@@ -1979,0 +1970,1 @@\n+                                    ++taken;\n@@ -1989,7 +1981,1 @@\n-                else if (inactive == 0)\n-                    inactive = deactivate(w, taken);\n-                else if (awaitWork(w, taken) == 0) {\n-                    taken = inactive = rescans = 0;\n-                    src = -1;\n-                }\n-                else\n+                else if ((runState & STOP) != 0L)\n@@ -1997,0 +1983,10 @@\n+                else {\n+                    int ns = taken, phase;\n+                    rescans = taken = 0;\n+                    if ((idle = (phase = w.phase) & IDLE) == 0)\n+                        idle = deactivate(w, phase, ns);\n+                    else if ((idle = awaitWork(w, phase)) == 0)\n+                        src = -1;\n+                    else\n+                        break;\n+                }\n@@ -1998,0 +1994,2 @@\n+            if (taken != 0)\n+                w.nsteals += taken;\n@@ -2005,0 +2003,1 @@\n+     * @param phase w's current phase (must be active)\n@@ -2008,8 +2007,12 @@\n-    private int deactivate(WorkQueue w, int taken) {\n-        int inactive = IDLE;\n-        if (w != null) {                         \/\/ always true; hoist checks\n-            long pc = ctl, c;\n-            int phase = w.getPhasePlain();\n-            long sp = (phase + NEXTIDLE) & LMASK;\n-            w.setPhasePlain(phase | IDLE);\n-            for (;;) {\n+    private int deactivate(WorkQueue w, int phase, int taken) {\n+        int idle = 0;\n+        if (w != null) {                     \/\/ always true; hoist checks\n+            if (taken != 0) {\n+                w.nsteals += taken;\n+                if ((w.config & CLEAR_TLS) != 0 &&\n+                    (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n+                    f.resetThreadLocals();   \/\/ (instanceof check always true)\n+            }\n+            long sp = (phase + NEXTIDLE) & LMASK, pc = ctl;\n+            U.putInt(w, WorkQueue.PHASE, phase | IDLE);\n+            for (long c;;) {                 \/\/ try to enqueue\n@@ -2017,6 +2020,5 @@\n-                c = ((pc - RC_UNIT) & UMASK) | sp;\n-                if (pc == (pc = U.compareAndExchangeLong(this, CTL, pc, c)))\n-                    break;\n-                if ((pc & RC_MASK) >= (c & RC_MASK)) {\n-                    w.phase = phase;       \/\/ back out if lost to signal\n-                    inactive = 0;\n+                if (pc == (pc = U.compareAndExchangeLong(\n+                               this, CTL, pc, c = ((pc - RC_UNIT) & UMASK) | sp))) {\n+                    idle = IDLE;\n+                    if ((c & RC_MASK) == 0L)\n+                        quiescent();         \/\/ check quiescent termination\n@@ -2025,9 +2027,3 @@\n-            }\n-            if (inactive != 0) {\n-                if (((c & RC_MASK) == 0L && quiescent() > 0) || taken == 0)\n-                    inactive = w.phase & IDLE; \/\/ check quiescent termination\n-                else {                     \/\/ spin for approx 1 scan cost\n-                    int tc = (short)(c >>> TC_SHIFT);\n-                    int spins = Math.max((tc << 1) + tc, SPIN_WAITS);\n-                    while ((inactive = w.phase & IDLE) != 0 && --spins != 0)\n-                        Thread.onSpinWait();\n+                else if ((c & RC_MASK) <= (pc & RC_MASK)) {\n+                    w.phase = phase;         \/\/ back out if lost to signal\n+                    break;\n@@ -2037,1 +2033,1 @@\n-        return inactive;\n+        return idle;\n@@ -2047,1 +2043,1 @@\n-        int inactive = 0;\n+        int idle = 0;\n@@ -2050,2 +2046,2 @@\n-            if ((inactive = (phase = w.phase) & IDLE) != 0 &&\n-                (int)(c = ctl) == (activePhase = phase + IDLE) &&\n+            if ((idle = (phase = w.phase) & IDLE) != 0 &&\n+                (activePhase = phase + IDLE) == (int)(c = ctl) &&\n@@ -2055,1 +2051,1 @@\n-                inactive = 0;\n+                idle = 0;\n@@ -2058,1 +2054,1 @@\n-        return inactive;\n+        return idle;\n@@ -2065,1 +2061,1 @@\n-     * @param taken number of stolen tasks since last reactivation\n+     * @param phase w's current phase (must be inactive)\n@@ -2068,31 +2064,20 @@\n-    private int awaitWork(WorkQueue w, int taken) {\n-        int inactive = 0;\n-        if (w != null) {                          \/\/ always true; hoist checks\n-            int phase;\n-            long waitTime = (w.source == INVALID_ID) ? 0L : keepAlive;\n-            if (taken != 0) {\n-                w.nsteals += taken;\n-                if ((w.config & CLEAR_TLS) != 0 &&\n-                    (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n-                    f.resetThreadLocals(); \/\/ (instanceof check always true)\n-            }\n-            if ((inactive = (phase = w.phase) & IDLE) != 0) {\n-                LockSupport.setCurrentBlocker(this);\n-                int activePhase = phase + IDLE;\n-                for (long deadline = 0L;;) {\n-                    Thread.interrupted();         \/\/ clear status\n-                    if ((runState & STOP) != 0L)\n-                        break;\n-                    boolean trimmable = false;    \/\/ use timed wait if trimmable\n-                    long d = 0L, c;\n-                    if (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase) {\n-                        long now = System.currentTimeMillis();\n-                        if (deadline == 0L)\n-                            deadline = waitTime + now;\n-                        if (deadline - now <= TIMEOUT_SLOP) {\n-                            if (tryTrim(w, c, activePhase))\n-                                break;\n-                            continue;             \/\/ lost race to trim\n-                        }\n-                        d = deadline;\n-                        trimmable = true;\n+    private int awaitWork(WorkQueue w, int phase) {\n+        int idle = IDLE;\n+        if (w != null) {                      \/\/ always true; hoist checks\n+            int activePhase = phase + IDLE;\n+            long deadline = 0L, waitTime = (w.source == INVALID_ID) ? 0L : keepAlive;\n+            LockSupport.setCurrentBlocker(this);\n+            for (;;) {\n+                Thread.interrupted();         \/\/ clear status\n+                if ((runState & STOP) != 0L)\n+                    break;\n+                boolean trimmable = false;    \/\/ use timed wait if trimmable\n+                long d = 0L, c;\n+                if (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase) {\n+                    long now = System.currentTimeMillis();\n+                    if (deadline == 0L)\n+                        deadline = waitTime + now;\n+                    if (deadline - now <= TIMEOUT_SLOP) {\n+                        if (tryTrim(w, c, activePhase))\n+                            break;\n+                        continue;             \/\/ lost race to trim\n@@ -2100,6 +2085,2 @@\n-                    w.parking = 1;                \/\/ enable unpark and recheck\n-                    if ((inactive = w.phase & IDLE) != 0)\n-                        U.park(trimmable, d);\n-                    w.parking = 0;                \/\/ close unpark window\n-                    if (inactive == 0 || (inactive = w.phase & IDLE) == 0)\n-                        break;\n+                    d = deadline;\n+                    trimmable = true;\n@@ -2107,1 +2088,8 @@\n-                LockSupport.setCurrentBlocker(null);\n+                if ((idle = w.phase & IDLE) == 0)\n+                    break;\n+                w.parking = 1;                \/\/ enable unpark and recheck\n+                if ((idle = w.phase & IDLE) != 0)\n+                    U.park(trimmable, d);\n+                w.parking = 0;                \/\/ close unpark window\n+                if (idle == 0 || (idle = w.phase & IDLE) == 0)\n+                    break;\n@@ -2109,0 +2097,1 @@\n+            LockSupport.setCurrentBlocker(null);\n@@ -2110,1 +2099,1 @@\n-        return inactive;\n+        return idle;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":96,"deletions":107,"binary":false,"changes":203,"status":"modified"}]}