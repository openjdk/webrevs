{"files":[{"patch":"@@ -1068,1 +1068,1 @@\n-    static final int SPIN_WAITS       = 1 <<  7;   \/\/ max calls to onSpinWait\n+    static final int SPIN_WAITS       = 1 <<  8;   \/\/ max calls to onSpinWait\n@@ -1081,0 +1081,1 @@\n+    static final int NEXTIDLE         = IDLE << 1;  \/\/ next IDLE phase bit\n@@ -1170,0 +1171,6 @@\n+    \/**\n+     * Exception thrown in tryTrim after idle timeout\n+     *\/\n+    @SuppressWarnings(\"serial\")\n+    static final class WorkerTrimmedException extends RuntimeException { }\n+\n@@ -1191,1 +1198,1 @@\n-        volatile int source;       \/\/ source queue id (or DROPPED)\n+        int source;                \/\/ source queue id (or DROPPED)\n@@ -1200,0 +1207,1 @@\n+        private static final long SOURCE;\n@@ -1202,13 +1210,5 @@\n-        final void updateBase(int v) {\n-            U.putIntVolatile(this, BASE, v);\n-        }\n-        final void updateTop(int v) {\n-            U.putIntOpaque(this, TOP, v);\n-        }\n-        final void updateArray(ForkJoinTask<?>[] a) {\n-            U.getAndSetReference(this, ARRAY, a);\n-        }\n-        final void unlockPhase() {\n-            U.getAndAddInt(this, PHASE, IDLE);\n-        }\n-        final boolean tryLockPhase() {    \/\/ seqlock acquire\n+        \/**\n+         * SeqLock acquire for external queues.\n+         * @return 1 if cannot acquire lock, else current phase\n+         *\/\n+        final int tryLockPhase() {\n@@ -1217,1 +1217,2 @@\n-                    U.compareAndSetInt(this, PHASE, p, p + IDLE));\n+                    (p == U.compareAndExchangeInt(this, PHASE, p, p + IDLE))) ?\n+                p : 1;\n@@ -1251,1 +1252,1 @@\n-         * @param task the task; no-op if null\n+         * @param task the task; caller must ensure nonnull\n@@ -1253,1 +1254,1 @@\n-         * @param internal if caller owns this queue\n+         * @param unlock if not 1, phase unlock value\n@@ -1256,13 +1257,12 @@\n-        final void push(ForkJoinTask<?> task, ForkJoinPool pool, boolean internal) {\n-            int s = top, b = base, m, cap, room; ForkJoinTask<?>[] a, na;\n-            if ((a = array) != null && (cap = a.length) > 0) { \/\/ else disabled\n-                int k = (m = cap - 1) & s;\n-                if ((room = m - (s - b)) >= 0) {\n-                    top = s + 1;\n-                    long pos = slotOffset(k);\n-                    if (!internal)\n-                        U.putReference(a, pos, task);       \/\/ inside lock\n-                    else\n-                        U.getAndSetReference(a, pos, task); \/\/ fully fenced\n-                    if (room == 0 && (na = growArray(a, cap, s)) != null)\n-                        k = ((a = na).length - 1) & s;      \/\/ resize\n+        final void push(ForkJoinTask<?> task, ForkJoinPool pool, int unlock) {\n+            ForkJoinTask<?>[] a = array;\n+            int b = base, s = top, cap, m; long pos;\n+            if (a == null || (cap = a.length) <= s + 1 - b || (m = cap - 1) < 0)\n+                growAndPush(task, pool, unlock);\n+            else {\n+                top = s + 1;\n+                U.getAndSetReference(a, pos = slotOffset(m & s), task);\n+                Object pred = U.getReferenceAcquire(a, slotOffset(m & (s - 1)));\n+                if (unlock != 1) {            \/\/ release external lock\n+                    U.putInt(this, PHASE, unlock);\n+                    U.storeFence();\n@@ -1270,8 +1270,2 @@\n-                if (!internal)\n-                    unlockPhase();\n-                if (room < 0)\n-                    throw new RejectedExecutionException(\"Queue capacity exceeded\");\n-                if (pool != null &&\n-                    (room == 0 ||\n-                     U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null))\n-                    pool.signalWork(a, k);    \/\/ may have appeared empty\n+                if (pred == null && pool != null)\n+                    pool.signalWork(a, pos); \/\/ may have appeared empty\n@@ -1282,5 +1276,4 @@\n-         * Resizes the queue array unless out of memory.\n-         * @param a old array\n-         * @param cap old array capacity\n-         * @param s current top\n-         * @return new array, or null on failure\n+         * Resizes the queue array and pushes unless out of memory.\n+         * @param task the task; caller must ensure nonnull\n+         * @param pool the pool to signal upon resize\n+         * @param unlock if not 1, phase unlock value\n@@ -1288,4 +1281,5 @@\n-        private ForkJoinTask<?>[] growArray(ForkJoinTask<?>[] a, int cap, int s) {\n-            int newCap = (cap >= 1 << 16) ? cap << 1 : cap << 2;\n-            ForkJoinTask<?>[] newArray = null;\n-            if (a != null && a.length == cap && cap > 0 && newCap > 0) {\n+        final void growAndPush(ForkJoinTask<?> task, ForkJoinPool pool, int unlock) {\n+            ForkJoinTask<?>[] a; int cap, newCap;\n+            if ((a = array) != null && (cap = a.length) > 0 &&\n+                (newCap = (cap >= 1 << 16) ? cap << 1 : cap << 2) > 0) {\n+                ForkJoinTask<?>[] newArray = null;\n@@ -1296,3 +1290,4 @@\n-                if (newArray != null) {               \/\/ else throw on next push\n-                    int mask = cap - 1, newMask = newCap - 1;\n-                    for (int k = s, j = cap; j > 0; --j, --k) {\n+                if (newArray != null) {\n+                    int s = top++, mask = cap - 1, newMask = newCap - 1;\n+                    newArray[s & newMask] = task;\n+                    for (int k = s - 1, j = cap; j > 0; --j, --k) {\n@@ -1305,1 +1300,7 @@\n-                    updateArray(newArray);           \/\/ fully fenced\n+                    long pos = slotOffset(s & newMask);\n+                    U.putReferenceVolatile(this, ARRAY, newArray);\n+                    if (unlock != 1)\n+                        phase = unlock;\n+                    if (pool != null)\n+                        pool.signalWork(newArray, pos);\n+                    return;\n@@ -1308,14 +1309,3 @@\n-            return newArray;\n-        }\n-\n-        \/**\n-         * Takes next task, if one exists, in lifo order.\n-         *\/\n-        private ForkJoinTask<?> localPop() {\n-            ForkJoinTask<?> t = null;\n-            int s = top - 1, cap; long k; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0 &&\n-                U.getReference(a, k = slotOffset((cap - 1) & s)) != null &&\n-                (t = (ForkJoinTask<?>)U.getAndSetReference(a, k, null)) != null)\n-                updateTop(s);\n-            return t;\n+            if (unlock != 1)\n+                phase = unlock;\n+            throw new RejectedExecutionException(\"Queue capacity exceeded\");\n@@ -1325,1 +1315,3 @@\n-         * Takes next task, if one exists, in fifo order.\n+         * Takes next task, if one exists, in order specified by mode,\n+         * so acts as either local-pop or local-poll. Called only by owner.\n+         * @param fifo nonzero if FIFO mode\n@@ -1327,1 +1319,1 @@\n-        private ForkJoinTask<?> localPoll() {\n+        final ForkJoinTask<?> nextLocalTask(int fifo) {\n@@ -1329,8 +1321,16 @@\n-            int p = top, cap; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0) {\n-                for (int b = base; p - b > 0; ) {\n-                    int nb = b + 1;\n-                    long k = slotOffset((cap - 1) & b);\n-                    if (U.getReference(a, k) == null) {\n-                        if (nb == p)\n-                            break;          \/\/ else base is lagging\n+            ForkJoinTask<?>[] a = array;\n+            int b = base, s = top - 1, cap;\n+            if (a != null && s - b >= 0 && (cap = a.length) > 0) {\n+                if (fifo == 0) {\n+                    if ((t = (ForkJoinTask<?>)U.getAndSetReference(\n+                             a, slotOffset((cap - 1) & s), null)) != null)\n+                        U.putIntOpaque(this, TOP, s);\n+                } else {\n+                    do {\n+                        if ((t = (ForkJoinTask<?>)U.getAndSetReference(\n+                                 a, slotOffset((cap - 1) & b), null)) != null) {\n+                            U.putIntVolatile(this, BASE, b + 1);\n+                            break;\n+                        }\n+                        if (b == s)\n+                            break;\n@@ -1338,9 +1338,2 @@\n-                            Thread.onSpinWait(); \/\/ spin to reduce memory traffic\n-                    }\n-                    else if ((t = (ForkJoinTask<?>)\n-                              U.getAndSetReference(a, k, null)) != null) {\n-                        updateBase(nb);\n-                        break;\n-                    }\n-                    else\n-                        b = base;\n+                            Thread.onSpinWait();\n+                    } while (s - b >= 0);\n@@ -1356,1 +1349,1 @@\n-            return (config & FIFO) == 0 ? localPop() : localPoll();\n+            return nextLocalTask(config & FIFO);\n@@ -1367,1 +1360,1 @@\n-            int p = top, s = p - 1, cap; long k;\n+            int p = top, s = p - 1, lock = 0, cap; long k;\n@@ -1370,1 +1363,1 @@\n-                (internal || tryLockPhase())) {\n+                (internal || (lock = tryLockPhase()) != 1)) {\n@@ -1373,1 +1366,1 @@\n-                    updateTop(s);\n+                    U.putIntOpaque(this, TOP, s);\n@@ -1376,1 +1369,1 @@\n-                    unlockPhase();\n+                    phase = lock + NEXTIDLE;\n@@ -1422,1 +1415,23 @@\n-                    updateBase(nb);\n+                    U.putIntVolatile(this, BASE, nb);\n+                    return t;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        \/**\n+         * Tries once to poll for a task\n+         * @param pool if non-null, pool to propagate signals\n+         *\/\n+        private ForkJoinTask<?> tryPoll(ForkJoinPool pool) {\n+           ForkJoinTask<?>[] a; int cap, b, nb; long bp;\n+            if ((a = array) != null && (cap = a.length) > 0) {\n+                 ForkJoinTask<?> t = (ForkJoinTask<?>)U.getReferenceAcquire(\n+                    a, bp = slotOffset((cap - 1) & (b = base)));\n+                long np = slotOffset((cap - 1) & (nb = b + 1));\n+                if (t != null && base == b &&\n+                    U.compareAndSetReference(a, bp, t, null)) {\n+                    Object nt = U.getReference(a, np);\n+                    U.getAndSetInt(this, BASE, nb);\n+                    if (pool != null && nt != null)\n+                        pool.signalWork(a, np);\n@@ -1434,1 +1449,4 @@\n-        final void topLevelExec(ForkJoinTask<?> task, int fifo) {\n+        final int topLevelExec(ForkJoinTask<?> task, WorkQueue q, ForkJoinPool pool,\n+                               int fifo) {\n+            ForkJoinPool p = (fifo == 0) ? null : pool;\n+            int taken = 1;\n@@ -1437,1 +1455,4 @@\n-                task = (fifo != 0) ? localPoll() : localPop();\n+                if ((task = nextLocalTask(fifo)) == null &&\n+                    (q == null || (task = q.tryPoll(p)) == null))\n+                    break;\n+                ++taken;\n@@ -1439,0 +1460,1 @@\n+            return taken;\n@@ -1456,1 +1478,2 @@\n-                        if (!internal && !tryLockPhase())\n+                        int lock = 0;\n+                        if (!internal && (lock = tryLockPhase()) == 1)\n@@ -1462,1 +1485,1 @@\n-                                updateTop(s);\n+                                top = s;\n@@ -1464,1 +1487,1 @@\n-                                updateBase(i + 1);\n+                                base = i + 1;\n@@ -1470,1 +1493,1 @@\n-                                updateTop(s);\n+                                top = s;\n@@ -1472,0 +1495,1 @@\n+                            U.storeFence();\n@@ -1474,1 +1498,1 @@\n-                            unlockPhase();\n+                            phase = lock + NEXTIDLE;\n@@ -1513,1 +1537,2 @@\n-                    if (!internal && !tryLockPhase())\n+                    int lock = 0;\n+                    if (!internal && (lock = tryLockPhase()) == 1)\n@@ -1518,1 +1543,1 @@\n-                        updateTop(s);\n+                        U.putIntOpaque(this, TOP, s);\n@@ -1520,1 +1545,1 @@\n-                        unlockPhase();\n+                        phase = lock + NEXTIDLE;\n@@ -1555,1 +1580,1 @@\n-                    updateBase(b + 1);\n+                    U.putIntVolatile(this, BASE, b + 1);\n@@ -1567,1 +1592,1 @@\n-            for (ForkJoinTask<?> t; (t = localPop()) != null; ) {\n+            for (ForkJoinTask<?> t; (t = nextLocalTask(0)) != null; ) {\n@@ -1592,0 +1617,1 @@\n+            SOURCE = U.objectFieldOffset(klass, \"source\");\n@@ -1654,27 +1680,1 @@\n-    private boolean compareAndSetCtl(long c, long v) {\n-        return U.compareAndSetLong(this, CTL, c, v);\n-    }\n-    private long compareAndExchangeCtl(long c, long v) {\n-        return U.compareAndExchangeLong(this, CTL, c, v);\n-    }\n-    private long getAndAddCtl(long v) {\n-        return U.getAndAddLong(this, CTL, v);\n-    }\n-    private long incrementThreadIds() {\n-        return U.getAndAddLong(this, THREADIDS, 1L);\n-    }\n-    private static int getAndAddPoolIds(int x) {\n-        return U.getAndAddInt(POOLIDS_BASE, POOLIDS, x);\n-    }\n-    private int getAndSetParallelism(int v) {\n-        return U.getAndSetInt(this, PARALLELISM, v);\n-    }\n-    private int getParallelismOpaque() {\n-        return U.getIntOpaque(this, PARALLELISM);\n-    }\n-    private CountDownLatch cmpExTerminationSignal(CountDownLatch x) {\n-        return (CountDownLatch)\n-            U.compareAndExchangeReference(this, TERMINATION, null, x);\n-    }\n-\n-    \/\/ runState operations\n+    \/\/ runState locking operations\n@@ -1682,6 +1682,0 @@\n-    private long getAndBitwiseOrRunState(long v) { \/\/ for status bits\n-        return U.getAndBitwiseOrLong(this, RUNSTATE, v);\n-    }\n-    private boolean casRunState(long c, long v) {\n-        return U.compareAndSetLong(this, RUNSTATE, c, v);\n-    }\n@@ -1693,1 +1687,2 @@\n-        if (((s = runState) & RS_LOCK) == 0L && casRunState(s, u = s + RS_LOCK))\n+        if (((s = runState) & RS_LOCK) == 0L &&\n+            U.compareAndSetLong(this, RUNSTATE, s, u = s + RS_LOCK))\n@@ -1702,1 +1697,1 @@\n-                if (casRunState(s, u = s + RS_LOCK))\n+                if (U.compareAndSetLong(this, RUNSTATE, s, u = s + RS_LOCK))\n@@ -1757,1 +1752,1 @@\n-        long tid = incrementThreadIds() + 1L;\n+        long tid = U.getAndAddLong(this, THREADIDS, 1L) + 1L;\n@@ -1823,0 +1818,2 @@\n+        if (ex instanceof WorkerTrimmedException)\n+            ex = null;\n@@ -1828,1 +1825,1 @@\n-            do {} while (c != (c = compareAndExchangeCtl(\n+            do {} while (c != (c = U.compareAndExchangeLong(this, CTL,\n@@ -1849,1 +1846,1 @@\n-            signalWork(null, 0);           \/\/ possibly replace\n+            signalWork(null, 0L);          \/\/ possibly replace\n@@ -1857,1 +1854,4 @@\n-     * giving up if array a is nonnull and task at a[k] already taken.\n+     * giving up on contention if source slot already taken.\n+     *\n+     * @param src, if nonnull, the array containing signalled task\n+     * @param offset slot offset for the task\n@@ -1859,14 +1859,8 @@\n-    final void signalWork(ForkJoinTask<?>[] a, int k) {\n-        int pc = parallelism;\n-        for (long c = ctl;;) {\n-            WorkQueue[] qs = queues;\n-            long ac = (c + RC_UNIT) & RC_MASK, nc;\n-            int sp = (int)c, i = sp & SMASK;\n-            if ((short)(c >>> RC_SHIFT) >= pc)\n-                break;\n-            if (qs == null)\n-                break;\n-            if (qs.length <= i)\n-                break;\n-            WorkQueue w = qs[i], v = null;\n-            if (sp == 0) {\n+    final void signalWork(ForkJoinTask<?>[] src, long offset) {\n+        int pc = parallelism, i, sp; \/\/ rely on caller sync for initial reads\n+        long c = U.getLong(this, CTL);\n+        WorkQueue[] qs = queues;\n+        while ((short)(c >>> RC_SHIFT) < pc && qs != null &&\n+               qs.length > (i = (sp = (int)c) & SMASK)) {\n+            WorkQueue w = qs[i], v = null; long nc;\n+            if (i == 0 || w == null) {\n@@ -1875,1 +1869,1 @@\n-                nc = ((c + TC_UNIT) & TC_MASK) | ac;\n+                nc = ((c + TC_UNIT) & TC_MASK) | ((c + RC_UNIT) & RC_MASK);\n@@ -1877,2 +1871,0 @@\n-            else if ((v = w) == null)\n-                break;\n@@ -1880,4 +1872,2 @@\n-                nc = (v.stackPred & LMASK) | (c & TC_MASK) | ac;\n-            if (a != null && k < a.length && k >= 0 && a[k] == null)\n-                break;\n-            if (c == (c = ctl) && c == (c = compareAndExchangeCtl(c, nc))) {\n+                nc = ((v = w).stackPred & LMASK) | ((c + RC_UNIT) & UMASK);\n+            if (c == (c = U.compareAndExchangeLong(this, CTL, c, nc))) {\n@@ -1893,0 +1883,3 @@\n+            qs = queues;\n+            if (src != null && U.getReference(src, offset) == null)\n+                break;\n@@ -1905,1 +1898,1 @@\n-            if (c == (c = compareAndExchangeCtl(\n+            if (c == (c = U.compareAndExchangeLong(this, CTL,\n@@ -1951,1 +1944,3 @@\n-                else if (compareAndSetCtl(c, c) && casRunState(e, e | STOP))\n+                else if (U.compareAndSetLong(this, CTL, c, c) &&\n+                         U.compareAndSetLong(this, RUNSTATE, e, e | STOP)) {\n+                    releaseWaiters();\n@@ -1953,0 +1948,1 @@\n+                }\n@@ -1966,2 +1962,1 @@\n-        if (w != null && w.phase != 0) {                  \/\/ else unregistered\n-            WorkQueue[] qs;\n+        if (w != null) {\n@@ -1969,4 +1964,4 @@\n-            int fifo = (int)config & FIFO, rescans = 0, inactive = 0, taken = 0, n;\n-            while ((runState & STOP) == 0L && (qs = queues) != null &&\n-                   (n = qs.length) > 0) {\n-                int i = r, step = (r >>> 16) | 1;\n+            for (int fifo = (int)config & FIFO, idle = 0, taken = 0;;) {\n+                WorkQueue[] qs;\n+                long e = runState;\n+                int n = ((qs = queues) == null) ? 0 : qs.length;\n@@ -1974,0 +1969,6 @@\n+                int i = r, step = (r >>> 16) | 1;\n+                if ((e & STOP) != 0L || n <= 0) {\n+                    w.nsteals += taken;\n+                    break;\n+                }\n+                boolean rescan = false;\n@@ -1977,1 +1978,1 @@\n-                        ForkJoinTask<?>[] a; int cap;     \/\/ poll queue\n+                        ForkJoinTask<?>[] a; int pb = -1, cap; \/\/ poll queue\n@@ -1979,1 +1980,1 @@\n-                            int b, nb, nk; long bp; ForkJoinTask<?> t;\n+                            int b, nb; long bp, np; ForkJoinTask<?> t;\n@@ -1982,13 +1983,9 @@\n-                            long np = slotOffset(nk = (nb = b + 1) & (cap - 1));\n-                            if (q.base == b) {            \/\/ else inconsistent\n-                                if (t == null) {\n-                                    if (q.array == a) {   \/\/ else resized\n-                                        if (rescans > 0)  \/\/ ran or stalled\n-                                            break scan;\n-                                        if (U.getReference(a, np) == null &&\n-                                            (rescans >= 0 ||\n-                                             (U.getReferenceAcquire(a, bp) == null &&\n-                                              q.top == q.base)))\n-                                            break;\n-                                        rescans = 1;      \/\/ may be stalled\n-                                    }\n+                            Object nt = U.getReference(\n+                                a, np = slotOffset((cap - 1) & (nb = b + 1)));\n+                            int qb = q.base;              \/\/ reread\n+                            if (idle != 0) {\n+                                if (t == null && nt == null && q.top - qb <= 0)\n+                                    break;\n+                                if ((idle = tryReactivate(w)) != 0) {\n+                                    rescan = true;\n+                                    break scan;           \/\/ can't take yet\n@@ -1996,3 +1993,9 @@\n-                                else if (inactive != 0) {\n-                                    if ((inactive = tryReactivate(w)) != 0) {\n-                                        rescans = 1;      \/\/ can't take yet\n+                            }\n+                            else if (qb != b)             \/\/ inconsistent\/busy\n+                                ;\n+                            else if (t == null) {\n+                                if (q.array == a && U.getReference(a, bp) == null) {\n+                                    if (nt == null)\n+                                        break;\n+                                    if (pb == (pb = b)) {\n+                                        rescan = true;    \/\/ stalled; reorder scan\n@@ -2002,11 +2005,10 @@\n-                                else if (U.compareAndSetReference(a, bp, t, null)) {\n-                                    q.base = nb;\n-                                    Object nt = U.getReferenceAcquire(a, np);\n-                                    w.source = qid;\n-                                    rescans = 1;\n-                                    ++taken;\n-                                    if (nt != null &&     \/\/ confirm a[nk]\n-                                        U.getReferenceAcquire(a, np) == nt)\n-                                        signalWork(a, nk); \/\/ propagate\n-                                    w.topLevelExec(t, fifo);\n-                                }\n+                            }\n+                            else if (U.compareAndSetReference(a, bp, t, null)) {\n+                                nt = U.getReference(a, np);\n+                                U.getAndSetInt(q, WorkQueue.BASE, nb);\n+                                if (nt != null)           \/\/ propagate\n+                                    signalWork(a, np);\n+                                w.source = qid;\n+                                taken += w.topLevelExec(t, q, this, fifo);\n+                                rescan = true;\n+                                break scan;\n@@ -2017,5 +2019,3 @@\n-                if (rescans >= 0)\n-                    --rescans;\n-                else if (inactive == 0) {\n-                    if ((inactive = deactivate(w, taken)) != 0)\n-                        taken = 0;\n+                if (!rescan) {\n+                    idle = onEmptyScan(w, idle, taken);\n+                    taken = 0;\n@@ -2023,4 +2023,0 @@\n-                else if (awaitWork(w) == 0)\n-                    inactive = rescans = 0;\n-                else\n-                    break;\n@@ -2032,1 +2028,1 @@\n-     * Tries to deactivate worker, keeping active on contention\n+     * Possibly deactivates, reactivates or pauses worker\n@@ -2035,2 +2031,1 @@\n-     * @param taken number of stolen tasks since last deactivation\n-     * @return nonzero if inactive\n+     * @return 0 if now active\n@@ -2038,23 +2033,27 @@\n-    private int deactivate(WorkQueue w, int taken) {\n-        int inactive = 0, phase;\n-        if (w != null && (inactive = (phase = w.phase) & IDLE) == 0) {\n-            long sp = (phase + (IDLE << 1)) & LMASK, pc, c;\n-            w.phase = phase | IDLE;\n-            w.stackPred = (int)(pc = ctl);    \/\/ set ctl stack link\n-            if (!compareAndSetCtl(            \/\/ try to enqueue\n-                    pc, c = ((pc - RC_UNIT) & UMASK) | sp))\n-                w.phase = phase;              \/\/ back out on contention\n-            else {\n-                if (taken != 0) {\n-                    w.nsteals += taken;\n-                    if ((w.config & CLEAR_TLS) != 0 &&\n-                        (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n-                        f.resetThreadLocals(); \/\/ (instanceof check always true)\n-                }\n-                if (((c & RC_MASK) == 0L && quiescent() > 0) || taken == 0)\n-                    inactive = w.phase & IDLE; \/\/ check quiescent termination\n-                else {                         \/\/ spin for approx 1 scan cost\n-                    int tc = (short)(c >>> TC_SHIFT);\n-                    int spins = Math.max((tc << 1) + tc, SPIN_WAITS);\n-                    while ((inactive = w.phase & IDLE) != 0 && --spins != 0)\n-                        Thread.onSpinWait();\n+    private int onEmptyScan(WorkQueue w, int idle, int taken) {\n+        if (w != null) {                           \/\/ always true; hoist checks\n+            int phase = w.phase;\n+            if (taken != 0) {\n+                w.nsteals += taken;\n+                if ((w.config & CLEAR_TLS) != 0 &&\n+                    (Thread.currentThread() instanceof ForkJoinWorkerThread f))\n+                    f.resetThreadLocals();         \/\/ (instanceof check always true)\n+                if ((runState & (SHUTDOWN|STOP)) == 0L)\n+                    Thread.yield();                \/\/ pause before rescan\n+            }\n+            else if (idle == 0) {                  \/\/ deactivate\n+                long sp = (phase + NEXTIDLE) & LMASK, pc = ctl;\n+                U.putInt(w, WorkQueue.PHASE, phase | IDLE);\n+                for (;;) {                         \/\/ enqueue\n+                    w.stackPred = (int)pc;\n+                    long c = (pc - RC_UNIT) & UMASK | sp, ac = c & RC_MASK;\n+                    if (pc == (pc = U.compareAndExchangeLong(this, CTL, pc, c))) {\n+                        if (ac == 0L && (runState & (SHUTDOWN|STOP)) == SHUTDOWN)\n+                            quiescent();           \/\/ check quiescent termination\n+                        idle = w.phase & IDLE;\n+                        break;\n+                    }\n+                    else if (ac < (pc & RC_MASK)) {\n+                        w.phase = phase;           \/\/ back out if lost to signal\n+                        break;\n+                    }\n@@ -2063,0 +2062,4 @@\n+            else if ((idle = phase & IDLE) != 0) {\n+                awaitWork(w, phase);\n+                idle = 0;\n+            }\n@@ -2064,1 +2067,1 @@\n-        return inactive;\n+        return idle;\n@@ -2074,1 +2077,1 @@\n-        int inactive = 0;\n+        int idle = 0;\n@@ -2077,3 +2080,4 @@\n-            if ((inactive = (phase = w.phase) & IDLE) != 0 &&\n-                (int)(c = ctl) == (activePhase = phase + IDLE) &&\n-                compareAndSetCtl(c, (sp & LMASK) | ((c + RC_UNIT) & UMASK))) {\n+            if ((idle = (phase = w.phase) & IDLE) != 0 &&\n+                (activePhase = phase + IDLE) == (int)(c = ctl) &&\n+                U.compareAndSetLong(this, CTL, c,\n+                                    (sp & LMASK) | ((c + RC_UNIT) & UMASK))) {\n@@ -2081,1 +2085,1 @@\n-                inactive = 0;\n+                idle = 0;\n@@ -2084,1 +2088,1 @@\n-        return inactive;\n+        return idle;\n@@ -2091,1 +2095,1 @@\n-     * @return 0 if now active\n+     * @throws WorkerTrimmedException on idle timeout\n@@ -2093,14 +2097,13 @@\n-    private int awaitWork(WorkQueue w) {\n-        int inactive = 0, phase;\n-        if (w != null) {                          \/\/ always true; hoist checks\n-            long waitTime = (w.source == INVALID_ID) ? 0L : keepAlive;\n-            if ((inactive = (phase = w.phase) & IDLE) != 0) {\n-                LockSupport.setCurrentBlocker(this);\n-                int activePhase = phase + IDLE;\n-                for (long deadline = 0L;;) {\n-                    Thread.interrupted();         \/\/ clear status\n-                    if ((runState & STOP) != 0L)\n-                        break;\n-                    boolean trimmable = false;    \/\/ use timed wait if trimmable\n-                    long d = 0L, c;\n-                    if (((c = ctl) & RC_MASK) == 0L && (int)c == activePhase) {\n+    private void awaitWork(WorkQueue w, int phase) {\n+        if (w != null) {\n+            int activePhase = phase + IDLE;\n+            long deadline = 0L, waitTime = (w.source == INVALID_ID) ? 0L : keepAlive;\n+            for (;;) {\n+                long d = 0L, c; int idle;\n+                Thread.interrupted();         \/\/ clear status\n+                if ((runState & STOP) != 0L)\n+                    break;\n+                boolean trimmable = false;    \/\/ use timed wait if trimmable\n+                int spins = ((short)((c = ctl) >>> TC_SHIFT) | 1) & SMASK;\n+                if ((int)c == activePhase) {  \/\/ at head\n+                    if ((c & RC_MASK) == 0L) {\n@@ -2110,6 +2113,2 @@\n-                        if (deadline - now <= TIMEOUT_SLOP) {\n-                            if (tryTrim(w, c, activePhase))\n-                                break;\n-                            continue;             \/\/ lost race to trim\n-                        }\n-                        d = deadline;\n+                        if ((d = deadline) - now <= TIMEOUT_SLOP)\n+                            tryTrim(w, c, activePhase); \/\/ throws if trimmed\n@@ -2118,6 +2117,1 @@\n-                    w.parking = 1;                \/\/ enable unpark and recheck\n-                    if ((inactive = w.phase & IDLE) != 0)\n-                        U.park(trimmable, d);\n-                    w.parking = 0;                \/\/ close unpark window\n-                    if (inactive == 0 || (inactive = w.phase & IDLE) == 0)\n-                        break;\n+                    spins += SPIN_WAITS;      \/\/ spin more\n@@ -2125,0 +2119,9 @@\n+                while ((idle = w.phase & IDLE) != 0 && --spins != 0)\n+                    Thread.onSpinWait();\n+                if (idle == 0)\n+                    break;\n+                LockSupport.setCurrentBlocker(this);\n+                w.parking = 1;                \/\/ enable unpark and recheck\n+                if ((idle = w.phase & IDLE) != 0)\n+                    U.park(trimmable, d);\n+                w.parking = 0;                \/\/ close unpark window\n@@ -2126,0 +2129,2 @@\n+                if (idle == 0 || (w.phase & IDLE) == 0)\n+                    break;\n@@ -2128,1 +2133,0 @@\n-        return inactive;\n@@ -2134,0 +2138,1 @@\n+     * @throws WorkerTrimmedException on idle timeout\n@@ -2135,1 +2140,1 @@\n-    private boolean tryTrim(WorkQueue w, long c, int activePhase) {\n+    private void tryTrim(WorkQueue w, long c, int activePhase) {\n@@ -2140,1 +2145,1 @@\n-            if (compareAndSetCtl(c, nc)) {\n+            if (U.compareAndSetLong(this, CTL, c, nc)) {\n@@ -2145,1 +2150,1 @@\n-                    compareAndSetCtl(           \/\/ try to wake up next waiter\n+                    U.compareAndSetLong(this, CTL, \/\/ try to wake up next waiter\n@@ -2152,1 +2157,1 @@\n-                return true;\n+                throw new WorkerTrimmedException();\n@@ -2155,1 +2160,0 @@\n-        return false;\n@@ -2208,1 +2212,2 @@\n-                compareAndSetCtl(c, (c & UMASK) | (v.stackPred & LMASK))) {\n+                U.compareAndSetLong(this, CTL, c,\n+                                    (c & UMASK) | (v.stackPred & LMASK))) {\n@@ -2216,1 +2221,2 @@\n-            if (compareAndSetCtl(c, ((c - RC_UNIT) & RC_MASK) | (c & ~RC_MASK)))\n+            if (U.compareAndSetLong(this, CTL, c,\n+                                    ((c - RC_UNIT) & RC_MASK) | (c & ~RC_MASK)))\n@@ -2223,1 +2229,1 @@\n-            else if (compareAndSetCtl(c, nc))\n+            else if (U.compareAndSetLong(this, CTL, c, nc))\n@@ -2226,1 +2232,1 @@\n-        else if (!compareAndSetCtl(c, c))               \/\/ validate\n+        else if (!U.compareAndSetLong(this, CTL, c, c))    \/\/ validate\n@@ -2240,1 +2246,1 @@\n-        getAndAddCtl(RC_UNIT);\n+        U.getAndAddLong(this, CTL, RC_UNIT);\n@@ -2311,1 +2317,1 @@\n-                                    w.source = j;    \/\/ volatile write\n+                                    U.putIntVolatile(w, WorkQueue.SOURCE, j);\n@@ -2359,1 +2365,1 @@\n-                            int b, cap, nb; long k;\n+                            int b, cap; long k;\n@@ -2382,1 +2388,1 @@\n-                                        q.updateBase(b + 1);\n+                                        U.putIntVolatile(q, WorkQueue.BASE, b + 1);\n@@ -2431,1 +2437,2 @@\n-                for (ForkJoinTask<?> u; (u = w.nextLocalTask()) != null;)\n+                int fifo = ((int)config) & FIFO;\n+                for (ForkJoinTask<?> u; (u = w.nextLocalTask(fifo)) != null;)\n@@ -2465,1 +2472,1 @@\n-                                w.source = j; \/\/ volatile write\n+                                U.putIntVolatile(w, WorkQueue.SOURCE, j);\n@@ -2576,1 +2583,2 @@\n-    final WorkQueue externalSubmissionQueue(boolean rejectOnShutdown) {\n+    final void externalPush(ForkJoinTask<?> task, boolean signalIfEmpty,\n+                            boolean rejectOnShutdown) {\n@@ -2582,2 +2590,2 @@\n-        for (;;) {\n-            WorkQueue q; WorkQueue[] qs; int n, id, i;\n+        for (;; r = ThreadLocalRandom.advanceProbe(r)) {\n+            WorkQueue q; WorkQueue[] qs; int n, id, i, lock;\n@@ -2593,1 +2601,2 @@\n-            if (q != null && q.tryLockPhase()) {\n+            if (q != null && (lock = q.tryLockPhase()) != 1) {\n+                int unlock = lock + NEXTIDLE;\n@@ -2595,2 +2604,2 @@\n-                    q.unlockPhase();          \/\/ check while q lock held\n-                    break;\n+                    q.phase = unlock;\n+                    break; \/\/ check while q lock held\n@@ -2598,1 +2607,2 @@\n-                return q;\n+                q.push(task, signalIfEmpty ? this : null, unlock);\n+                return;\n@@ -2600,1 +2610,0 @@\n-            r = ThreadLocalRandom.advanceProbe(r); \/\/ move\n@@ -2605,2 +2614,2 @@\n-    private <T> ForkJoinTask<T> poolSubmit(boolean signalIfEmpty, ForkJoinTask<T> task) {\n-        Thread t; ForkJoinWorkerThread wt; WorkQueue q; boolean internal;\n+    private void poolSubmit(ForkJoinTask<?> task, boolean signalIfEmpty) {\n+        Thread t; ForkJoinWorkerThread wt; WorkQueue q;\n@@ -2608,10 +2617,5 @@\n-            (wt = (ForkJoinWorkerThread)t).pool == this) {\n-            internal = true;\n-            q = wt.workQueue;\n-        }\n-        else {                     \/\/ find and lock queue\n-            internal = false;\n-            q = externalSubmissionQueue(true);\n-        }\n-        q.push(task, signalIfEmpty ? this : null, internal);\n-        return task;\n+            (q = (wt = (ForkJoinWorkerThread)t).workQueue) != null &&\n+            wt.pool == this)\n+            q.push(task, signalIfEmpty ? this : null, 1);\n+        else\n+            externalPush(task, signalIfEmpty, true);\n@@ -2732,1 +2736,2 @@\n-            if (((ps = getAndBitwiseOrRunState(SHUTDOWN|STOP) & STOP)) == 0L) {\n+            if (((ps = U.getAndBitwiseOrLong(this, RUNSTATE, SHUTDOWN | STOP)) &\n+                 STOP) == 0L) {\n@@ -2743,1 +2748,1 @@\n-                getAndBitwiseOrRunState(SHUTDOWN);\n+                U.getAndBitwiseOrLong(this, RUNSTATE, SHUTDOWN);\n@@ -2759,1 +2764,1 @@\n-                        e = getAndBitwiseOrRunState(CLEANED) | CLEANED;\n+                        e = U.getAndBitwiseOrLong(this, RUNSTATE, CLEANED) | CLEANED;\n@@ -2769,1 +2774,2 @@\n-                    if ((getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0L) {\n+                    if ((U.getAndBitwiseOrLong(this, RUNSTATE, TERMINATED) &\n+                         TERMINATED) == 0L) {\n@@ -2807,1 +2813,1 @@\n-                        q.updateBase(b + 1);\n+                        U.putIntVolatile(q, WorkQueue.BASE, b + 1);\n@@ -2848,1 +2854,2 @@\n-            signal = ((u = cmpExTerminationSignal(\n+            signal = ((u = (CountDownLatch)U.compareAndExchangeReference(\n+                           this, TERMINATION, null,\n@@ -3016,1 +3023,1 @@\n-        String pid = Integer.toString(getAndAddPoolIds(1) + 1);\n+        String pid = Integer.toString(U.getAndAddInt(POOLIDS_BASE, POOLIDS, 1) + 1);\n@@ -3100,2 +3107,2 @@\n-        ForkJoinPool cp; int p;\n-        if ((p = (cp = common).parallelism) == 0)\n+        ForkJoinPool cp;\n+        if ((cp = common).parallelism == 0)\n@@ -3126,1 +3133,1 @@\n-        poolSubmit(true, Objects.requireNonNull(task));\n+        poolSubmit(Objects.requireNonNull(task), true);\n@@ -3145,1 +3152,1 @@\n-        poolSubmit(true,  Objects.requireNonNull(task));\n+        poolSubmit(Objects.requireNonNull(task), true);\n@@ -3158,1 +3165,1 @@\n-        poolSubmit(true, (Objects.requireNonNull(task) instanceof ForkJoinTask<?>)\n+        poolSubmit((Objects.requireNonNull(task) instanceof ForkJoinTask<?>)\n@@ -3160,1 +3167,1 @@\n-                   : new ForkJoinTask.RunnableExecuteAction(task));\n+                   : new ForkJoinTask.RunnableExecuteAction(task), true);\n@@ -3178,1 +3185,2 @@\n-        return poolSubmit(true,  Objects.requireNonNull(task));\n+        poolSubmit(Objects.requireNonNull(task), true);\n+        return task;\n@@ -3189,2 +3197,1 @@\n-        return poolSubmit(\n-            true,\n+        ForkJoinTask<T> t =\n@@ -3193,1 +3200,3 @@\n-            new ForkJoinTask.AdaptedInterruptibleCallable<T>(task));\n+            new ForkJoinTask.AdaptedInterruptibleCallable<T>(task);\n+        poolSubmit(t, true);\n+        return t;\n@@ -3204,2 +3213,1 @@\n-        return poolSubmit(\n-            true,\n+        ForkJoinTask<T> t =\n@@ -3208,1 +3216,3 @@\n-            new ForkJoinTask.AdaptedInterruptibleRunnable<T>(task, result));\n+            new ForkJoinTask.AdaptedInterruptibleRunnable<T>(task, result);\n+        poolSubmit(t, true);\n+        return t;\n@@ -3220,2 +3230,1 @@\n-        return poolSubmit(\n-            true,\n+        ForkJoinTask<?> t =\n@@ -3226,1 +3235,3 @@\n-             new ForkJoinTask.AdaptedInterruptibleRunnable<Void>(task, null)));\n+             new ForkJoinTask.AdaptedInterruptibleRunnable<Void>(task, null));\n+        poolSubmit(t, true);\n+        return t;\n@@ -3248,1 +3259,1 @@\n-        externalSubmissionQueue(true).push(task, this, false);\n+        externalPush(task, true, true);\n@@ -3269,1 +3280,2 @@\n-        return poolSubmit(false,  Objects.requireNonNull(task));\n+        poolSubmit(Objects.requireNonNull(task), false);\n+        return task;\n@@ -3297,2 +3309,2 @@\n-        if ((prevSize = getAndSetParallelism(size)) < size)\n-            signalWork(null, 0); \/\/ trigger worker activation\n+        if ((prevSize = U.getAndSetInt(this, PARALLELISM, size)) < size)\n+            signalWork(null, 0L); \/\/ trigger worker activation\n@@ -3332,1 +3344,1 @@\n-                poolSubmit(true, f);\n+                poolSubmit(f, true);\n@@ -3355,1 +3367,1 @@\n-                poolSubmit(true, f);\n+                poolSubmit(f, true);\n@@ -3471,1 +3483,1 @@\n-        externalSubmissionQueue(false).push(task, this, false);\n+        externalPush(task, true, false);\n@@ -3712,1 +3724,2 @@\n-        return poolSubmit(true, task);\n+        poolSubmit(task, true);\n+        return task;\n@@ -3759,1 +3772,1 @@\n-        return Math.max(getParallelismOpaque(), 1);\n+        return Math.max(U.getIntOpaque(this, PARALLELISM), 1);\n@@ -3871,1 +3884,1 @@\n-     * separately by method {@link getDelayedTaskCount}.\n+     * separately by method {@link #getDelayedTaskCount}.\n@@ -4311,1 +4324,1 @@\n-                        getAndAddCtl(RC_UNIT);\n+                        U.getAndAddLong(this, CTL, RC_UNIT);\n@@ -4338,1 +4351,1 @@\n-            getAndAddCtl(post);\n+            U.getAndAddLong(this, CTL, post);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":353,"deletions":340,"binary":false,"changes":693,"status":"modified"},{"patch":"@@ -644,6 +644,2 @@\n-        ForkJoinPool p; ForkJoinPool.WorkQueue q; boolean internal;\n-        if (internal =\n-            (t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {\n-            q = (wt = (ForkJoinWorkerThread)t).workQueue;\n-            p = wt.pool;\n-        }\n+        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n+            ((wt = (ForkJoinWorkerThread)t).workQueue).push(this, wt.pool, 1);\n@@ -651,2 +647,1 @@\n-            q = (p = ForkJoinPool.common).externalSubmissionQueue(false);\n-        q.push(this, p, internal);\n+            ForkJoinPool.common.externalPush(this, true, false);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"}]}