{"files":[{"patch":"@@ -1081,0 +1081,1 @@\n+    static final int NEXTIDLE         = IDLE << 1;  \/\/ next IDLE phase bit\n@@ -1191,1 +1192,1 @@\n-        volatile int source;       \/\/ source queue id (or DROPPED)\n+        int source;                \/\/ source queue id (or DROPPED)\n@@ -1195,1 +1196,1 @@\n-        \/\/ Support for atomic operations\n+        \/\/ Support for atomic operations (also used by ForkJoinPool)\n@@ -1197,4 +1198,4 @@\n-        private static final long PHASE;\n-        private static final long BASE;\n-        private static final long TOP;\n-        private static final long ARRAY;\n+        static final long PHASE;\n+        static final long BASE;\n+        static final long TOP;\n+        static final long ARRAY;\n@@ -1202,13 +1203,5 @@\n-        final void updateBase(int v) {\n-            U.putIntVolatile(this, BASE, v);\n-        }\n-        final void updateTop(int v) {\n-            U.putIntOpaque(this, TOP, v);\n-        }\n-        final void updateArray(ForkJoinTask<?>[] a) {\n-            U.getAndSetReference(this, ARRAY, a);\n-        }\n-        final void unlockPhase() {\n-            U.getAndAddInt(this, PHASE, IDLE);\n-        }\n-        final boolean tryLockPhase() {    \/\/ seqlock acquire\n+        \/**\n+         * SeqLock acquire for external queues.\n+         * @return 1 if cannot acquire lock, else current phase\n+         *\/\n+        final int tryLockPhase() {\n@@ -1217,1 +1210,2 @@\n-                    U.compareAndSetInt(this, PHASE, p, p + IDLE));\n+                    (p == U.compareAndExchangeInt(this, PHASE, p, p + IDLE))) ?\n+                p : 1;\n@@ -1251,1 +1245,1 @@\n-         * @param task the task; no-op if null\n+         * @param task the task; caller must ensure nonnull\n@@ -1253,1 +1247,1 @@\n-         * @param internal if caller owns this queue\n+         * @param unlock if not 1, phase unlock value\n@@ -1256,21 +1250,13 @@\n-        final void push(ForkJoinTask<?> task, ForkJoinPool pool, boolean internal) {\n-            int s = top, b = base, m, cap, room; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0) { \/\/ else disabled\n-                if ((room = (m = cap - 1) - (s - b)) >= 0) {\n-                    top = s + 1;\n-                    long pos = slotOffset(m & s);\n-                    if (!internal)\n-                        U.putReference(a, pos, task);       \/\/ inside lock\n-                    else\n-                        U.getAndSetReference(a, pos, task); \/\/ fully fenced\n-                    if (room == 0)\n-                        growArray(a, cap, s);\n-                }\n-                if (!internal)\n-                    unlockPhase();\n-                if (room < 0)\n-                    throw new RejectedExecutionException(\"Queue capacity exceeded\");\n-                if (pool != null &&\n-                    (room == 0 ||\n-                     U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null))\n-                    pool.signalWork(this, s);    \/\/ may have appeared empty\n+        final void push(ForkJoinTask<?> task, ForkJoinPool pool, int unlock) {\n+            ForkJoinTask<?>[] a = array;\n+            int b = base, s = top, m;\n+            if (a != null &&\n+                (a.length > s + 1 - b || (a = growArray()) != null) &&\n+                (m = a.length - 1) >= 0) {    \/\/ else rejected or disabled\n+                top = s + 1;\n+                U.putReferenceVolatile(a, slotOffset(m & s), task);\n+                if (unlock != 1)              \/\/ release external lock\n+                    U.putInt(this, PHASE, unlock);\n+                if (U.getReferenceAcquire(a, slotOffset(m & (s - 1))) == null &&\n+                    pool != null)\n+                    pool.signalWork(this, s); \/\/ may have appeared empty\n@@ -1282,3 +1268,1 @@\n-         * @param a old array\n-         * @param cap old array capacity\n-         * @param s current top\n+         * @return new array, or throw on OOME\n@@ -1286,4 +1270,5 @@\n-        private void growArray(ForkJoinTask<?>[] a, int cap, int s) {\n-            int newCap = (cap >= 1 << 16) ? cap << 1 : cap << 2;\n-            ForkJoinTask<?>[] newArray = null;\n-            if (a != null && a.length == cap && cap > 0 && newCap > 0) {\n+        private ForkJoinTask<?>[] growArray() {\n+            ForkJoinTask<?>[] a; int cap, newCap;\n+            if ((a = array) != null && (cap = a.length) > 0 &&\n+                (newCap = (cap >= 1 << 16) ? cap << 1 : cap << 2) > 0) {\n+                ForkJoinTask<?>[] newArray = null;\n@@ -1294,1 +1279,1 @@\n-                if (newArray != null) {               \/\/ else throw on next push\n+                if (newArray != null) {\n@@ -1296,1 +1281,1 @@\n-                    for (int k = s, j = cap; j > 0; --j, --k) {\n+                    for (int k = top - 1, j = cap; j > 0; --j, --k) {\n@@ -1303,1 +1288,2 @@\n-                    updateArray(newArray);           \/\/ fully fenced\n+                    U.putReferenceVolatile(this, ARRAY, newArray);\n+                    return newArray;\n@@ -1306,0 +1292,4 @@\n+            int f = phase;                   \/\/ unlock if externally locked\n+            if ((f & (IDLE | 1)) == 0)\n+                phase = f + IDLE;\n+            throw new RejectedExecutionException(\"Queue capacity exceeded\");\n@@ -1317,1 +1307,1 @@\n-                updateTop(s);\n+                U.putIntOpaque(this, TOP, s);\n@@ -1339,1 +1329,1 @@\n-                        updateBase(nb);\n+                        U.putIntOpaque(this, BASE, nb);\n@@ -1364,1 +1354,1 @@\n-            int p = top, s = p - 1, cap; long k;\n+            int p = top, s = p - 1, lock = 0, cap; long k;\n@@ -1367,1 +1357,1 @@\n-                (internal || tryLockPhase())) {\n+                (internal || (lock = tryLockPhase()) != 1)) {\n@@ -1370,1 +1360,1 @@\n-                    updateTop(s);\n+                    U.putIntOpaque(this, TOP, s);\n@@ -1373,1 +1363,1 @@\n-                    unlockPhase();\n+                    U.putIntRelease(this, PHASE, lock + NEXTIDLE);\n@@ -1419,1 +1409,1 @@\n-                    updateBase(nb);\n+                    U.putIntVolatile(this, BASE, nb);\n@@ -1477,1 +1467,2 @@\n-                        if (!internal && !tryLockPhase())\n+                        int lock = 0;\n+                        if (!internal && (lock = tryLockPhase()) == 1)\n@@ -1483,1 +1474,1 @@\n-                                updateTop(s);\n+                                top = s;\n@@ -1485,1 +1476,1 @@\n-                                updateBase(i + 1);\n+                                base = i + 1;\n@@ -1491,1 +1482,1 @@\n-                                updateTop(s);\n+                                top = s;\n@@ -1495,1 +1486,1 @@\n-                            unlockPhase();\n+                            U.putIntRelease(this, PHASE, lock + NEXTIDLE);\n@@ -1534,1 +1525,2 @@\n-                    if (!internal && !tryLockPhase())\n+                    int lock = 0;\n+                    if (!internal && (lock = tryLockPhase()) == 1)\n@@ -1539,1 +1531,1 @@\n-                        updateTop(s);\n+                        top = s;\n@@ -1541,1 +1533,1 @@\n-                        unlockPhase();\n+                        U.putIntRelease(this, PHASE, lock + NEXTIDLE);\n@@ -1576,1 +1568,1 @@\n-                    updateBase(b + 1);\n+                    base = b + 1;\n@@ -1675,27 +1667,1 @@\n-    private boolean compareAndSetCtl(long c, long v) {\n-        return U.compareAndSetLong(this, CTL, c, v);\n-    }\n-    private long compareAndExchangeCtl(long c, long v) {\n-        return U.compareAndExchangeLong(this, CTL, c, v);\n-    }\n-    private long getAndAddCtl(long v) {\n-        return U.getAndAddLong(this, CTL, v);\n-    }\n-    private long incrementThreadIds() {\n-        return U.getAndAddLong(this, THREADIDS, 1L);\n-    }\n-    private static int getAndAddPoolIds(int x) {\n-        return U.getAndAddInt(POOLIDS_BASE, POOLIDS, x);\n-    }\n-    private int getAndSetParallelism(int v) {\n-        return U.getAndSetInt(this, PARALLELISM, v);\n-    }\n-    private int getParallelismOpaque() {\n-        return U.getIntOpaque(this, PARALLELISM);\n-    }\n-    private CountDownLatch cmpExTerminationSignal(CountDownLatch x) {\n-        return (CountDownLatch)\n-            U.compareAndExchangeReference(this, TERMINATION, null, x);\n-    }\n-\n-    \/\/ runState operations\n+    \/\/ runState locking operations\n@@ -1703,6 +1669,0 @@\n-    private long getAndBitwiseOrRunState(long v) { \/\/ for status bits\n-        return U.getAndBitwiseOrLong(this, RUNSTATE, v);\n-    }\n-    private boolean casRunState(long c, long v) {\n-        return U.compareAndSetLong(this, RUNSTATE, c, v);\n-    }\n@@ -1714,1 +1674,2 @@\n-        if (((s = runState) & RS_LOCK) == 0L && casRunState(s, u = s + RS_LOCK))\n+        if (((s = runState) & RS_LOCK) == 0L &&\n+            U.compareAndSetLong(this, RUNSTATE, s, u = s + RS_LOCK))\n@@ -1723,1 +1684,1 @@\n-                if (casRunState(s, u = s + RS_LOCK))\n+                if (U.compareAndSetLong(this, RUNSTATE, s, u = s + RS_LOCK))\n@@ -1778,1 +1739,1 @@\n-        long tid = incrementThreadIds() + 1L;\n+        long tid = U.getAndAddLong(this, THREADIDS, 1L) + 1L;\n@@ -1849,1 +1810,1 @@\n-            do {} while (c != (c = compareAndExchangeCtl(\n+            do {} while (c != (c = U.compareAndExchangeLong(this, CTL,\n@@ -1878,1 +1839,2 @@\n-     * giving up q is nonull and signalled slot already taken.\n+     * giving up on contention if q is nonull and signalled slot\n+     * already taken.\n@@ -1885,1 +1847,2 @@\n-        for (long c = ctl;;) {\n+        for (;;) {\n+            long c = ctl;\n@@ -1905,1 +1868,1 @@\n-            if (c == (c = compareAndExchangeCtl(c, nc))) {\n+            if (U.compareAndSetLong(this, CTL, c, nc)) {\n@@ -1929,1 +1892,1 @@\n-            if (c == (c = compareAndExchangeCtl(\n+            if (c == (c = U.compareAndExchangeLong(this, CTL,\n@@ -1975,1 +1938,2 @@\n-                else if (compareAndSetCtl(c, c) && casRunState(e, e | STOP))\n+                else if (U.compareAndSetLong(this, CTL, c, c) &&\n+                         U.compareAndSetLong(this, RUNSTATE, e, e | STOP))\n@@ -1994,0 +1958,1 @@\n+            int src = -1;                                 \/\/ last queue taken from\n@@ -2027,5 +1992,3 @@\n-                                    q.base = nb;\n-                                    w.source = qid;\n-                                    rescans = 1;\n-                                    ++taken;\n-                                    if (U.getReferenceAcquire(a, np) != null)\n+                                    Object nt = U.getReference(a, np);\n+                                    U.getAndSetInt(q, WorkQueue.BASE, nb);\n+                                    if (nt != null)\n@@ -2033,0 +1996,4 @@\n+                                    ++taken;\n+                                    rescans = 1;\n+                                    if (src != qid)\n+                                        w.source = src = qid;\n@@ -2045,1 +2012,1 @@\n-                else if (awaitWork(w) == 0)\n+                else if (awaitWork(w) == 0) {\n@@ -2047,0 +2014,2 @@\n+                    src = -1;\n+                }\n@@ -2062,1 +2031,2 @@\n-        if (w != null && (inactive = (phase = w.phase) & IDLE) == 0) {\n+        if (w != null && (inactive =          \/\/ plain accesses until CAS\n+                          (phase = U.getInt(w, WorkQueue.PHASE)) & IDLE) == 0) {\n@@ -2064,4 +2034,4 @@\n-            w.phase = phase | IDLE;\n-            w.stackPred = (int)(pc = ctl);    \/\/ set ctl stack link\n-            if (!compareAndSetCtl(            \/\/ try to enqueue\n-                    pc, c = ((pc - RC_UNIT) & UMASK) | sp))\n+            U.putInt(w, WorkQueue.PHASE, phase | IDLE);\n+            w.stackPred = (int)(pc = ctl);    \/\/ try to enqueue\n+            if (!U.compareAndSetLong(this, CTL, pc,\n+                                     c = ((pc - RC_UNIT) & UMASK) | sp))\n@@ -2101,1 +2071,2 @@\n-                compareAndSetCtl(c, (sp & LMASK) | ((c + RC_UNIT) & UMASK))) {\n+                U.compareAndSetLong(this, CTL, c,\n+                                    (sp & LMASK) | ((c + RC_UNIT) & UMASK))) {\n@@ -2162,1 +2133,1 @@\n-            if (compareAndSetCtl(c, nc)) {\n+            if (U.compareAndSetLong(this, CTL, c, nc)) {\n@@ -2167,1 +2138,1 @@\n-                    compareAndSetCtl(           \/\/ try to wake up next waiter\n+                    U.compareAndSetLong(this, CTL, \/\/ try to wake up next waiter\n@@ -2230,1 +2201,2 @@\n-                compareAndSetCtl(c, (c & UMASK) | (v.stackPred & LMASK))) {\n+                U.compareAndSetLong(this, CTL, c,\n+                                    (c & UMASK) | (v.stackPred & LMASK))) {\n@@ -2238,1 +2210,2 @@\n-            if (compareAndSetCtl(c, ((c - RC_UNIT) & RC_MASK) | (c & ~RC_MASK)))\n+            if (U.compareAndSetLong(this, CTL, c,\n+                                    ((c - RC_UNIT) & RC_MASK) | (c & ~RC_MASK)))\n@@ -2245,1 +2218,1 @@\n-            else if (compareAndSetCtl(c, nc))\n+            else if (U.compareAndSetLong(this, CTL, c, nc))\n@@ -2248,1 +2221,1 @@\n-        else if (!compareAndSetCtl(c, c))               \/\/ validate\n+        else if (!U.compareAndSetLong(this, CTL, c, c))    \/\/ validate\n@@ -2262,1 +2235,1 @@\n-        getAndAddCtl(RC_UNIT);\n+        U.getAndAddLong(this, CTL, RC_UNIT);\n@@ -2333,1 +2306,1 @@\n-                                    w.source = j;    \/\/ volatile write\n+                                    w.source = j;\n@@ -2404,1 +2377,1 @@\n-                                        q.updateBase(b + 1);\n+                                        q.base = b + 1;\n@@ -2487,1 +2460,1 @@\n-                                w.source = j; \/\/ volatile write\n+                                w.source = j;\n@@ -2598,1 +2571,2 @@\n-    final WorkQueue externalSubmissionQueue(boolean rejectOnShutdown) {\n+    final void externalPush(ForkJoinTask<?> task, boolean signalIfEmpty,\n+                            boolean rejectOnShutdown) {\n@@ -2605,1 +2579,1 @@\n-            WorkQueue q; WorkQueue[] qs; int n, id, i;\n+            WorkQueue q; WorkQueue[] qs; int n, id, i, lock;\n@@ -2615,1 +2589,2 @@\n-            if (q != null && q.tryLockPhase()) {\n+            if (q != null && (lock = q.tryLockPhase()) != 1) {\n+                int unlock = lock + NEXTIDLE;\n@@ -2617,2 +2592,2 @@\n-                    q.unlockPhase();          \/\/ check while q lock held\n-                    break;\n+                    q.phase = unlock;\n+                    break; \/\/ check while q lock held\n@@ -2620,1 +2595,2 @@\n-                return q;\n+                q.push(task, signalIfEmpty ? this : null, unlock);\n+                return;\n@@ -2627,2 +2603,2 @@\n-    private <T> ForkJoinTask<T> poolSubmit(boolean signalIfEmpty, ForkJoinTask<T> task) {\n-        Thread t; ForkJoinWorkerThread wt; WorkQueue q; boolean internal;\n+    private void poolSubmit(ForkJoinTask<?> task, boolean signalIfEmpty) {\n+        Thread t; ForkJoinWorkerThread wt;\n@@ -2630,10 +2606,4 @@\n-            (wt = (ForkJoinWorkerThread)t).pool == this) {\n-            internal = true;\n-            q = wt.workQueue;\n-        }\n-        else {                     \/\/ find and lock queue\n-            internal = false;\n-            q = externalSubmissionQueue(true);\n-        }\n-        q.push(task, signalIfEmpty ? this : null, internal);\n-        return task;\n+            (wt = (ForkJoinWorkerThread)t).pool == this)\n+            wt.workQueue.push(task, signalIfEmpty ? this : null, 1);\n+        else\n+            externalPush(task, signalIfEmpty, true);\n@@ -2754,1 +2724,2 @@\n-            if (((ps = getAndBitwiseOrRunState(SHUTDOWN|STOP) & STOP)) == 0L) {\n+            if (((ps = U.getAndBitwiseOrLong(this, RUNSTATE, SHUTDOWN | STOP)) &\n+                 STOP) == 0L) {\n@@ -2765,1 +2736,1 @@\n-                getAndBitwiseOrRunState(SHUTDOWN);\n+                U.getAndBitwiseOrLong(this, RUNSTATE, SHUTDOWN);\n@@ -2781,1 +2752,1 @@\n-                        e = getAndBitwiseOrRunState(CLEANED) | CLEANED;\n+                        e = U.getAndBitwiseOrLong(this, RUNSTATE, CLEANED) | CLEANED;\n@@ -2791,1 +2762,2 @@\n-                    if ((getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0L) {\n+                    if ((U.getAndBitwiseOrLong(this, RUNSTATE, TERMINATED) &\n+                         TERMINATED) == 0L) {\n@@ -2829,1 +2801,1 @@\n-                        q.updateBase(b + 1);\n+                        q.base = b + 1;\n@@ -2870,1 +2842,2 @@\n-            signal = ((u = cmpExTerminationSignal(\n+            signal = ((u = (CountDownLatch)U.compareAndExchangeReference(\n+                           this, TERMINATION, null,\n@@ -3038,1 +3011,1 @@\n-        String pid = Integer.toString(getAndAddPoolIds(1) + 1);\n+        String pid = Integer.toString(U.getAndAddInt(POOLIDS_BASE, POOLIDS, 1) + 1);\n@@ -3148,1 +3121,1 @@\n-        poolSubmit(true, Objects.requireNonNull(task));\n+        poolSubmit(Objects.requireNonNull(task), true);\n@@ -3167,1 +3140,1 @@\n-        poolSubmit(true,  Objects.requireNonNull(task));\n+        poolSubmit(Objects.requireNonNull(task), true);\n@@ -3180,1 +3153,1 @@\n-        poolSubmit(true, (Objects.requireNonNull(task) instanceof ForkJoinTask<?>)\n+        poolSubmit((Objects.requireNonNull(task) instanceof ForkJoinTask<?>)\n@@ -3182,1 +3155,1 @@\n-                   : new ForkJoinTask.RunnableExecuteAction(task));\n+                   : new ForkJoinTask.RunnableExecuteAction(task), true);\n@@ -3200,1 +3173,2 @@\n-        return poolSubmit(true,  Objects.requireNonNull(task));\n+        poolSubmit(Objects.requireNonNull(task), true);\n+        return task;\n@@ -3211,2 +3185,1 @@\n-        return poolSubmit(\n-            true,\n+        ForkJoinTask<T> t =\n@@ -3215,1 +3188,3 @@\n-            new ForkJoinTask.AdaptedInterruptibleCallable<T>(task));\n+            new ForkJoinTask.AdaptedInterruptibleCallable<T>(task);\n+        poolSubmit(t, true);\n+        return t;\n@@ -3226,2 +3201,1 @@\n-        return poolSubmit(\n-            true,\n+        ForkJoinTask<T> t =\n@@ -3230,1 +3204,3 @@\n-            new ForkJoinTask.AdaptedInterruptibleRunnable<T>(task, result));\n+            new ForkJoinTask.AdaptedInterruptibleRunnable<T>(task, result);\n+        poolSubmit(t, true);\n+        return t;\n@@ -3242,2 +3218,1 @@\n-        return poolSubmit(\n-            true,\n+        ForkJoinTask<?> t =\n@@ -3248,1 +3223,3 @@\n-             new ForkJoinTask.AdaptedInterruptibleRunnable<Void>(task, null)));\n+             new ForkJoinTask.AdaptedInterruptibleRunnable<Void>(task, null));\n+        poolSubmit(t, true);\n+        return t;\n@@ -3270,1 +3247,1 @@\n-        externalSubmissionQueue(true).push(task, this, false);\n+        externalPush(task, true, true);\n@@ -3291,1 +3268,2 @@\n-        return poolSubmit(false,  Objects.requireNonNull(task));\n+        poolSubmit(Objects.requireNonNull(task), false);\n+        return task;\n@@ -3319,1 +3297,1 @@\n-        if ((prevSize = getAndSetParallelism(size)) < size)\n+        if ((prevSize = U.getAndSetInt(this, PARALLELISM, size)) < size)\n@@ -3354,1 +3332,1 @@\n-                poolSubmit(true, f);\n+                poolSubmit(f, true);\n@@ -3377,1 +3355,1 @@\n-                poolSubmit(true, f);\n+                poolSubmit(f, true);\n@@ -3493,1 +3471,1 @@\n-        externalSubmissionQueue(false).push(task, this, false);\n+        externalPush(task, true, false);\n@@ -3734,1 +3712,2 @@\n-        return poolSubmit(true, task);\n+        poolSubmit(task, true);\n+        return task;\n@@ -3781,1 +3760,1 @@\n-        return Math.max(getParallelismOpaque(), 1);\n+        return Math.max(U.getIntOpaque(this, PARALLELISM), 1);\n@@ -4333,1 +4312,1 @@\n-                        getAndAddCtl(RC_UNIT);\n+                        U.getAndAddLong(this, CTL, RC_UNIT);\n@@ -4360,1 +4339,1 @@\n-            getAndAddCtl(post);\n+            U.getAndAddLong(this, CTL, post);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":161,"deletions":182,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -644,6 +644,2 @@\n-        ForkJoinPool p; ForkJoinPool.WorkQueue q; boolean internal;\n-        if (internal =\n-            (t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {\n-            q = (wt = (ForkJoinWorkerThread)t).workQueue;\n-            p = wt.pool;\n-        }\n+        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n+            ((wt = (ForkJoinWorkerThread)t).workQueue).push(this, wt.pool, 1);\n@@ -651,2 +647,1 @@\n-            q = (p = ForkJoinPool.common).externalSubmissionQueue(false);\n-        q.push(this, p, internal);\n+            ForkJoinPool.common.externalPush(this, true, false);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"}]}