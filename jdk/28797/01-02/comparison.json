{"files":[{"patch":"@@ -1429,9 +1429,1 @@\n-         * Runs the given task, as well as remaining local tasks, and\n-         * those from the given queue that can be polled without interference.\n-         *\n-         * @param task the top-level task\n-         * @param q the WorkQueue from which task was taken\n-         * @param fifo nonzero if fifo mode\n-         * @param qbase the next base index of q to take;\n-         *        returning if no such task or already taken\n-         * @return number of top-level tasks stolen from q\n+         * Runs the given task, as well as remaining local tasks\n@@ -1439,6 +1431,2 @@\n-        final int topLevelExec(ForkJoinTask<?> task, WorkQueue q,\n-                                int fifo, int qbase) {\n-            if (task == null || q == null)\n-                return 0;        \/\/ currently impossible\n-            int stolen = 1;\n-            outer: for (;;) {\n+        final void topLevelExec(ForkJoinTask<?> task, int fifo) {\n+            while (task != null) {\n@@ -1446,37 +1434,1 @@\n-                task = null;\n-                int p = top, cap; ForkJoinTask<?>[] a;\n-                if ((a = array) == null || (cap = a.length) <= 0)\n-                    break;        \/\/ currently impossible\n-                if (fifo == 0) {  \/\/ specialized localPop\n-                    int s = p - 1; long k;\n-                    if (U.getReference(\n-                            a, k = slotOffset((cap - 1) & s)) != null &&\n-                        (task = (ForkJoinTask<?>)\n-                         U.getAndSetReference(a, k, null)) != null) {\n-                        top = s;\n-                        continue;\n-                    }\n-                } else {         \/\/ specialized localPoll\n-                    for (int b = base; p - b > 0; ) {\n-                        int nb = b + 1;\n-                        if ((task = (ForkJoinTask<?>)U.getAndSetReference(\n-                                 a, slotOffset((cap - 1) & b), null)) != null) {\n-                            base = nb;\n-                            continue outer;\n-                        }\n-                        if (nb == p)\n-                            break;\n-                        while (b == (b = U.getIntAcquire(this, BASE)))\n-                            Thread.onSpinWait();\n-                    }\n-                }\n-                \/\/ try (once) to steal at q's next base index\n-                ForkJoinTask<?>[] qa = q.array; int qcap; long qk;\n-                if (q.base != qbase || qa == null || (qcap = qa.length) <= 0 ||\n-                    (task = (ForkJoinTask<?>)U.getReferenceAcquire(\n-                        qa, qk = slotOffset((qcap - 1) & qbase))) == null ||\n-                    q.base != qbase || \/\/ ensure valid read\n-                    !U.compareAndSetReference(qa, qk, task, null))\n-                    break;\n-                q.base = ++qbase;\n-                ++stolen;\n+                task = (fifo != 0) ? localPoll() : localPop();\n@@ -1484,1 +1436,0 @@\n-            return stolen;\n@@ -2056,0 +2007,1 @@\n+                                    ++taken;\n@@ -2058,1 +2010,1 @@\n-                                    taken += w.topLevelExec(t, q, fifo, nb);\n+                                    w.topLevelExec(t, fifo);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":6,"deletions":54,"binary":false,"changes":60,"status":"modified"}]}