{"files":[{"patch":"@@ -180,3 +180,1 @@\n-         if (b1 == b2) {\n-             return true;\n-         }\n+         assert b1 != b2; \/\/ Checked by callers\n@@ -193,0 +191,51 @@\n+    \/**\n+     * Unicode has a few non-latin1 code points which case fold into\n+     * latin1 range. If the given code point folds to latin1, this method\n+     * returns the corresponding latin1 lowercase code point.\n+     * Otherwise, -1 is returned.\n+     *\n+     * This method is equivalent to the following code:\n+     *\n+     * {@snippet :\n+     *   int fold = Character.toLowerCase(Character.toUpperCase(c));\n+     *   return folded <= 0XFF ? fold : -1;\n+     * }\n+     *\n+     * For performance reasons, the implementation compares to a set of known\n+     * code points instead. These code points were found using an exhaustive\n+     * search over all non-latin1 code points:\n+     *\n+     * {@snippet :\n+     *   for (int c = 256; c <= 0x3FFFF; c++) {\n+     *       int folded = Character.toLowerCase(Character.toUpperCase(c));\n+     *       if (folded <= 0XFF) {\n+     *           System.out.printf(\"0x%x folds to 0x%x%n\", c, folded);\n+     *       }\n+     *   }\n+     * }\n+     *\n+     * To catch regressions caused by future changes in Unicode, an exhaustive\n+     * test verifies that the constants in this method is always\n+     * up to date. (See EqualsIgnoreCase.guardUnicodeFoldingToLatin1)\n+     *\/\n+    static int latin1CaseFold(int c) {\n+        return switch (c) {\n+            \/\/ Capital I with dot above: Small i\n+            case 0x130  -> 'i';\n+            \/\/ Small dotless i: Small i\n+            case 0x131  -> 'i';\n+            \/\/ Capital Y with diaeresis: Small y with Diaeresis\n+            case 0x178  -> 0xFF;\n+            \/\/ Small long s: Small s\n+            case 0x17f  -> 's';\n+            \/\/ Capital sharp S: Small sharp s\n+            case 0x1e9e -> 0xDF;\n+            \/\/ Kelvin sign: Small k\n+            case 0x212a -> 'k';\n+            \/\/ Angstrom sign: Small a with overring\n+            case 0x212b -> 0xE5;\n+            \/\/ c does not fold into latin1\n+            default     -> -1;\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/CharacterDataLatin1.java.template","additions":52,"deletions":3,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-            if (CharacterDataLatin1.equalsIgnoreCase(b1, b2)) {\n+            if (b1 == b2 || CharacterDataLatin1.equalsIgnoreCase(b1, b2)) {\n@@ -401,3 +401,3 @@\n-            char c1 = (char)(value[toffset++] & 0xff);\n-            char c2 = StringUTF16.getChar(other, ooffset++);\n-            if (c1 == c2) {\n+            int lat = value[toffset++] & 0XFF;\n+            int utf = StringUTF16.getChar(other, ooffset++);\n+            if (lat == utf) {\n@@ -406,4 +406,7 @@\n-            char u1 = (char) CharacterDataLatin1.instance.toUpperCase(c1);\n-            char u2 = Character.toUpperCase(c2);\n-            if (u1 == u2) {\n-                continue;\n+            \/\/ Fast path if both code points are latin1\n+            if (utf <= 0xFF) {\n+                if (CharacterDataLatin1.equalsIgnoreCase((byte) lat, (byte) utf)) {\n+                    continue; \/\/ Equals ignoring case\n+                } else {\n+                    return false;\n+                }\n@@ -411,2 +414,8 @@\n-            if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) {\n-                continue;\n+            \/\/ If utf folds into latin1, compare lowercases\n+            int lat1CaseFold = CharacterDataLatin1.latin1CaseFold(utf);\n+            if (lat1CaseFold != -1) {\n+                if (lat1CaseFold == CharacterDataLatin1.instance.toLowerCase(lat)) {\n+                    continue; \/\/ Equals ignoring case\n+                } else {\n+                    return false;\n+                }\n@@ -414,0 +423,1 @@\n+            \/\/ Does not fold into latin1\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":20,"deletions":10,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -107,0 +107,15 @@\n+\n+    \/**\n+     * This guards that CharacterDataLatin1.latin1CaseFold is in sync with\n+     * Character.toUpperCase and Character.toLowerCase\n+     *\/\n+    @Test\n+    public void guardUnicodeFoldingToLatin1() {\n+        for (int c = 256; c <= 0x3FFFF; c++) {\n+            int lc = Character.toLowerCase(Character.toUpperCase(c));\n+            if (lc <= 0XFF) {\n+                assertTrue(Character.toString(lc).equalsIgnoreCase(Character.toString(c)),\n+                        \"%s and its lowercase %s should equalsIgnoreCase\".formatted(c, lc));\n+            }\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/EqualsIgnoreCase.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,0 +99,1 @@\n+                new Object[] { \"\\u0130\", true,  0, \"I\", 0, 1, true },\n@@ -102,0 +103,1 @@\n+                new Object[] { \"\\u0131\", true,  0, \"I\", 0, 1, true },\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/RegionMatches.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,0 +96,77 @@\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @State(Scope.Benchmark)\n+    @Warmup(iterations = 5, time = 1)\n+    @Measurement(iterations = 5, time = 1)\n+    @Fork(value = 3)\n+    public static class Mixed {\n+\n+        @Param({\"1024\"})\n+        public int size;\n+\n+        @Param({\"ascii-match\",\n+                \"ascii-mismatch\",\n+                \"number-match\",\n+                \"number-mismatch\",\n+                \"lat1-match\",\n+                \"lat1-mismatch\",\n+                \"utf16-match\",\n+                \"utf16-mismatch\"\n+        })\n+        String codePoints;\n+        private String leftString;\n+        private String rightString;\n+\n+\n+        @Setup\n+        public void setup() {\n+\n+            switch (codePoints) {\n+                case \"ascii-match\" -> {\n+                    leftString  = \"a\".repeat(size);\n+                    rightString = \"A\".repeat(size);\n+                }\n+                case \"ascii-mismatch\" -> {\n+                    leftString  = \"a\".repeat(size);\n+                    rightString = \"b\".repeat(size);\n+                }\n+                case \"number-match\" -> {\n+                    leftString  = \"7\".repeat(size);\n+                    rightString = \"7\".repeat(size);\n+                }\n+                case \"number-mismatch\" -> {\n+                    leftString  = \"7\".repeat(size);\n+                    rightString = \"9\".repeat(size);\n+                }\n+                case \"lat1-match\" -> {\n+                    leftString  = \"\\u00e5\".repeat(size);\n+                    rightString = \"\\u00c5\".repeat(size);\n+                }\n+                case \"lat1-mismatch\" -> {\n+                    leftString  = \"\\u00e5\".repeat(size);\n+                    rightString = \"\\u00c6\".repeat(size);\n+                }\n+                case \"utf16-match\" -> {\n+                    leftString  = \"i\".repeat(size);\n+                    rightString = \"\\u0130\".repeat(size);\n+                }\n+                case \"utf16-mismatch\" -> {\n+                    leftString  =  \"a\".repeat(size);\n+                    rightString = \"\\u0130\".repeat(size);\n+                }\n+                default -> throw new IllegalArgumentException(\"Unsupported coding: \" + codePoints);\n+            }\n+            \/\/ Make sure strings do not String.equals by adding a prefix.\n+            \/\/ Prefix the right String with a UTF16 code point to force mixed coders.\n+            leftString = \"l\" + leftString;\n+            rightString = \"\\u025b\" + rightString;\n+        }\n+\n+        @Benchmark\n+        public boolean regionMatchesIC() {\n+            return leftString.regionMatches(true, 1, rightString, 1, size);\n+        }\n+\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/RegionMatchesIC.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"}]}