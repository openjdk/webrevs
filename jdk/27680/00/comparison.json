{"files":[{"patch":"@@ -6284,0 +6284,103 @@\n+\n+\/*\n+ * Windows\/x64 does not use stack frames the way expected by Java:\n+ * [1] in most cases, there is no frame pointer. All locals are addressed via RSP\n+ * [2] in rare cases, when alloca() is used, a frame pointer is used, but this may\n+ *     not be RBP.\n+ * See http:\/\/msdn.microsoft.com\/en-us\/library\/ew5tede7.aspx\n+ *\n+ * So it's not possible to print the native stack using the\n+ *     while (...) {...  fr = os::get_sender_for_C_frame(&fr); }\n+ * loop in vmError.cpp. We need to roll our own loop.\n+ * This approach works for Windows AArch64 as well.\n+ *\/\n+bool os::win32::platform_print_native_stack(outputStream* st, const void* context,\n+                                            char *buf, int buf_size, address& lastpc)\n+{\n+  CONTEXT ctx;\n+  if (context != nullptr) {\n+    memcpy(&ctx, context, sizeof(ctx));\n+  } else {\n+    RtlCaptureContext(&ctx);\n+  }\n+\n+  st->print_cr(\"Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)\");\n+\n+  DWORD machine_type;\n+  STACKFRAME stk;\n+  memset(&stk, 0, sizeof(stk));\n+  stk.AddrStack.Mode      = AddrModeFlat;\n+  stk.AddrFrame.Mode      = AddrModeFlat;\n+  stk.AddrPC.Mode         = AddrModeFlat;\n+\n+#if defined(_M_AMD64)\n+  stk.AddrStack.Offset    = ctx.Rsp;\n+  stk.AddrFrame.Offset    = ctx.Rbp;\n+  stk.AddrPC.Offset       = ctx.Rip;\n+  machine_type            = IMAGE_FILE_MACHINE_AMD64;\n+#elif defined(_M_ARM64)\n+  stk.AddrStack.Offset    = ctx.Sp;\n+  stk.AddrFrame.Offset    = ctx.Fp;\n+  stk.AddrPC.Offset       = ctx.Pc;\n+  machine_type            = IMAGE_FILE_MACHINE_ARM64;\n+#else\n+  #error unknown architecture\n+#endif\n+\n+  \/\/ Ensure we consider dynamically loaded DLLs\n+  SymbolEngine::refreshModuleList();\n+\n+  int count = 0;\n+  address lastpc_internal = 0;\n+  while (count++ < StackPrintLimit) {\n+    intptr_t* sp = (intptr_t*)stk.AddrStack.Offset;\n+    intptr_t* fp = (intptr_t*)stk.AddrFrame.Offset; \/\/ NOT necessarily the same as ctx.Rbp!\n+    address pc = (address)stk.AddrPC.Offset;\n+\n+    if (pc != nullptr) {\n+      if (count == 2 && lastpc_internal == pc) {\n+        \/\/ Skip it -- StackWalk64() may return the same PC\n+        \/\/ (but different SP) on the first try.\n+      } else {\n+        \/\/ Don't try to create a frame(sp, fp, pc) -- on WinX64, stk.AddrFrame\n+        \/\/ may not contain what Java expects, and may cause the frame() constructor\n+        \/\/ to crash. Let's just print out the symbolic address.\n+        frame::print_C_frame(st, buf, buf_size, pc);\n+        \/\/ print source file and line, if available\n+        char buf[128];\n+        int line_no;\n+        if (SymbolEngine::get_source_info(pc, buf, sizeof(buf), &line_no)) {\n+          st->print(\"  (%s:%d)\", buf, line_no);\n+        } else {\n+          st->print(\"  (no source info available)\");\n+        }\n+        st->cr();\n+      }\n+      lastpc_internal = pc;\n+    }\n+\n+    PVOID p = WindowsDbgHelp::symFunctionTableAccess64(GetCurrentProcess(), stk.AddrPC.Offset);\n+    if (!p) {\n+      \/\/ StackWalk64() can't handle this PC. Calling StackWalk64 again may cause crash.\n+      lastpc = lastpc_internal;\n+      break;\n+    }\n+\n+    BOOL result = WindowsDbgHelp::stackWalk64(\n+        machine_type,              \/\/ __in      DWORD MachineType,\n+        GetCurrentProcess(),       \/\/ __in      HANDLE hProcess,\n+        GetCurrentThread(),        \/\/ __in      HANDLE hThread,\n+        &stk,                      \/\/ __inout   LP STACKFRAME64 StackFrame,\n+        &ctx);                     \/\/ __inout   PVOID ContextRecord,\n+\n+    if (!result) {\n+      break;\n+    }\n+  }\n+  if (count > StackPrintLimit) {\n+    st->print_cr(\"...<more frames>...\");\n+  }\n+  st->cr();\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"os_windows.hpp\"\n@@ -35,0 +36,6 @@\n+#define HAVE_PLATFORM_PRINT_NATIVE_STACK 1\n+inline bool os::platform_print_native_stack(outputStream* st, const void* context,\n+                                            char *buf, int buf_size, address& lastpc) {\n+  return os::win32::platform_print_native_stack(st, context, buf, buf_size, lastpc);\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -200,92 +200,0 @@\n-#ifdef HAVE_PLATFORM_PRINT_NATIVE_STACK\n-\/*\n- * Windows\/x64 does not use stack frames the way expected by Java:\n- * [1] in most cases, there is no frame pointer. All locals are addressed via RSP\n- * [2] in rare cases, when alloca() is used, a frame pointer is used, but this may\n- *     not be RBP.\n- * See http:\/\/msdn.microsoft.com\/en-us\/library\/ew5tede7.aspx\n- *\n- * So it's not possible to print the native stack using the\n- *     while (...) {...  fr = os::get_sender_for_C_frame(&fr); }\n- * loop in vmError.cpp. We need to roll our own loop.\n- *\/\n-bool os::win32::platform_print_native_stack(outputStream* st, const void* context,\n-                                            char *buf, int buf_size, address& lastpc)\n-{\n-  CONTEXT ctx;\n-  if (context != nullptr) {\n-    memcpy(&ctx, context, sizeof(ctx));\n-  } else {\n-    RtlCaptureContext(&ctx);\n-  }\n-\n-  st->print_cr(\"Native frames: (J=compiled Java code, j=interpreted, Vv=VM code, C=native code)\");\n-\n-  STACKFRAME stk;\n-  memset(&stk, 0, sizeof(stk));\n-  stk.AddrStack.Offset    = ctx.Rsp;\n-  stk.AddrStack.Mode      = AddrModeFlat;\n-  stk.AddrFrame.Offset    = ctx.Rbp;\n-  stk.AddrFrame.Mode      = AddrModeFlat;\n-  stk.AddrPC.Offset       = ctx.Rip;\n-  stk.AddrPC.Mode         = AddrModeFlat;\n-\n-  \/\/ Ensure we consider dynamically loaded dll's\n-  SymbolEngine::refreshModuleList();\n-\n-  int count = 0;\n-  address lastpc_internal = 0;\n-  while (count++ < StackPrintLimit) {\n-    intptr_t* sp = (intptr_t*)stk.AddrStack.Offset;\n-    intptr_t* fp = (intptr_t*)stk.AddrFrame.Offset; \/\/ NOT necessarily the same as ctx.Rbp!\n-    address pc = (address)stk.AddrPC.Offset;\n-\n-    if (pc != nullptr) {\n-      if (count == 2 && lastpc_internal == pc) {\n-        \/\/ Skip it -- StackWalk64() may return the same PC\n-        \/\/ (but different SP) on the first try.\n-      } else {\n-        \/\/ Don't try to create a frame(sp, fp, pc) -- on WinX64, stk.AddrFrame\n-        \/\/ may not contain what Java expects, and may cause the frame() constructor\n-        \/\/ to crash. Let's just print out the symbolic address.\n-        frame::print_C_frame(st, buf, buf_size, pc);\n-        \/\/ print source file and line, if available\n-        char buf[128];\n-        int line_no;\n-        if (SymbolEngine::get_source_info(pc, buf, sizeof(buf), &line_no)) {\n-          st->print(\"  (%s:%d)\", buf, line_no);\n-        } else {\n-          st->print(\"  (no source info available)\");\n-        }\n-        st->cr();\n-      }\n-      lastpc_internal = pc;\n-    }\n-\n-    PVOID p = WindowsDbgHelp::symFunctionTableAccess64(GetCurrentProcess(), stk.AddrPC.Offset);\n-    if (!p) {\n-      \/\/ StackWalk64() can't handle this PC. Calling StackWalk64 again may cause crash.\n-      lastpc = lastpc_internal;\n-      break;\n-    }\n-\n-    BOOL result = WindowsDbgHelp::stackWalk64(\n-        IMAGE_FILE_MACHINE_AMD64,  \/\/ __in      DWORD MachineType,\n-        GetCurrentProcess(),       \/\/ __in      HANDLE hProcess,\n-        GetCurrentThread(),        \/\/ __in      HANDLE hThread,\n-        &stk,                      \/\/ __inout   LP STACKFRAME64 StackFrame,\n-        &ctx);                     \/\/ __inout   PVOID ContextRecord,\n-\n-    if (!result) {\n-      break;\n-    }\n-  }\n-  if (count > StackPrintLimit) {\n-    st->print_cr(\"...<more frames>...\");\n-  }\n-  st->cr();\n-\n-  return true;\n-}\n-#endif \/\/ HAVE_PLATFORM_PRINT_NATIVE_STACK\n-\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":0,"deletions":92,"binary":false,"changes":92,"status":"modified"}]}