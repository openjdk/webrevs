{"files":[{"patch":"@@ -47,3 +47,4 @@\n-  NonNMethod          = 2,    \/\/ Non-nmethods like Buffers, Adapters and Runtime Stubs\n-  All                 = 3,    \/\/ All types (No code cache segmentation)\n-  NumTypes            = 4     \/\/ Number of CodeBlobTypes\n+  MethodHot           = 2,    \/\/ Nmethods predicted to be always hot\n+  NonNMethod          = 3,    \/\/ Non-nmethods like Buffers, Adapters and Runtime Stubs\n+  All                 = 4,    \/\/ All types (No code cache segmentation)\n+  NumTypes            = 5     \/\/ Number of CodeBlobTypes\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -194,0 +194,21 @@\n+\/\/ Returns the name of the VM option to set the size of the corresponding CodeHeap\n+static const char* get_code_heap_flag_name(CodeBlobType code_blob_type) {\n+  switch(code_blob_type) {\n+  case CodeBlobType::NonNMethod:\n+    return \"NonNMethodCodeHeapSize\";\n+    break;\n+  case CodeBlobType::MethodNonProfiled:\n+    return \"NonProfiledCodeHeapSize\";\n+    break;\n+  case CodeBlobType::MethodProfiled:\n+    return \"ProfiledCodeHeapSize\";\n+    break;\n+  case CodeBlobType::MethodHot:\n+    return \"HotCodeHeapSize\";\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+    return nullptr;\n+  }\n+}\n+\n@@ -199,1 +220,10 @@\n-void CodeCache::initialize_heaps() {\n+static void check_space_available_for_heap(CodeBlobType code_blob_type,\n+                                           size_t heap_size,\n+                                           size_t available_space) {\n+  if (heap_size > available_space) {\n+    err_msg msg(\"%s (%zuK) exceeds the available space (%zuK).\",\n+                get_code_heap_flag_name(code_blob_type), heap_size \/ K,\n+                available_space \/ K);\n+    vm_exit_during_initialization(\"Invalid code heap sizes\", msg);\n+  }\n+}\n@@ -201,0 +231,1 @@\n+void CodeCache::initialize_heaps() {\n@@ -204,0 +235,1 @@\n+  CodeHeapInfo hot = {HotCodeHeapSize, FLAG_IS_CMDLINE(HotCodeHeapSize), true};\n@@ -222,0 +254,6 @@\n+  if (!heap_available(CodeBlobType::MethodHot)) {\n+    hot.size = 0;\n+    hot.set = true;\n+    hot.enabled = false;\n+  }\n+\n@@ -241,2 +279,15 @@\n-  if (!profiled.set && non_profiled.set) {\n-    set_size_of_unset_code_heap(&profiled, cache_size, non_nmethod.size + non_profiled.size, min_size);\n+  if (!profiled.set && non_profiled.set && hot.set) {\n+    set_size_of_unset_code_heap(&profiled, cache_size, non_nmethod.size + non_profiled.size + hot.size, min_size);\n+  }\n+\n+  if (hot.enabled) {\n+    if (!hot.set) {\n+      assert(hot.size == 0, \"must be calculated during heaps initialization\");\n+      \/\/ An application usually has ~20% hot code which is mostly non-profiled code.\n+      \/\/ We set the hot code heap size to 20% of the non-profiled code heap.\n+      hot.size = MAX2((2 * non_profiled.size) \/ 10, min_size);\n+    }\n+    if (!(non_profiled.set && hot.set)) {\n+      check_space_available_for_heap(CodeBlobType::MethodHot, hot.size, non_profiled.size);\n+      non_profiled.size -= hot.size;\n+    }\n@@ -247,2 +298,2 @@\n-  if (!non_nmethod.set && profiled.set && non_profiled.set) {\n-    set_size_of_unset_code_heap(&non_nmethod, cache_size, profiled.size + non_profiled.size, non_nmethod_min_size);\n+  if (!non_nmethod.set && profiled.set && non_profiled.set && hot.set) {\n+    set_size_of_unset_code_heap(&non_nmethod, cache_size, profiled.size + non_profiled.size + hot.size, non_nmethod_min_size);\n@@ -251,1 +302,1 @@\n-  size_t total = non_nmethod.size + profiled.size + non_profiled.size;\n+  size_t total = non_nmethod.size + profiled.size + non_profiled.size + hot.size;\n@@ -254,2 +305,2 @@\n-                        \"%zuK NonProfiled %zuK Profiled %zuK = %zuK\",\n-                        cache_size\/K, non_nmethod.size\/K, non_profiled.size\/K, profiled.size\/K, total\/K);\n+                        \"%zuK NonProfiled %zuK Profiled %zuK Hot %zuK = %zuK\",\n+                        cache_size\/K, non_nmethod.size\/K, non_profiled.size\/K, profiled.size\/K, hot.size\/K, total\/K);\n@@ -261,2 +312,2 @@\n-                       \" NonProfiled %zuK Profiled %zuK\",\n-                       cache_size\/K, non_nmethod.size\/K, non_profiled.size\/K, profiled.size\/K);\n+                       \" NonProfiled %zuK Profiled %zuK Hot %zuK\",\n+                       cache_size\/K, non_nmethod.size\/K, non_profiled.size\/K, profiled.size\/K, hot.size\/K);\n@@ -273,0 +324,3 @@\n+  if (hot.enabled) {\n+    check_min_size(\"hot code heap\", hot.size, min_size);\n+  }\n@@ -286,0 +340,3 @@\n+    if (hot.enabled) {\n+      message.append(\" + HotCodeHeapSize (%zuK)\", hot.size\/K);\n+    }\n@@ -308,1 +365,7 @@\n-  cache_size = non_nmethod.size + profiled.size + non_profiled.size;\n+\n+  if (hot.enabled) {\n+    hot.size = align_up(hot.size, min_size);\n+    FLAG_SET_ERGO(HotCodeHeapSize, hot.size);\n+  }\n+\n+  cache_size = non_nmethod.size + profiled.size + non_profiled.size + hot.size;\n@@ -333,0 +396,7 @@\n+  if (hot.enabled) {\n+    ReservedSpace hot_space = rs.partition(offset, hot.size);\n+    offset += hot.size;\n+    \/\/ Nmethods known to be always hot.\n+    add_heap(hot_space, \"CodeHeap 'hot nmethods'\", CodeBlobType::MethodHot);\n+  }\n+\n@@ -372,0 +442,6 @@\n+    \/\/ except the hot code heap unless it is requested.\n+\n+    if (COMPILER2_PRESENT(!HotCodeHeap &&) (code_blob_type == CodeBlobType::MethodHot)) {\n+      return false;\n+    }\n+\n@@ -375,0 +451,1 @@\n+    \/\/ and the hot code heap if it is requested.\n@@ -376,18 +453,2 @@\n-           (code_blob_type == CodeBlobType::MethodNonProfiled);\n-  }\n-}\n-\n-const char* CodeCache::get_code_heap_flag_name(CodeBlobType code_blob_type) {\n-  switch(code_blob_type) {\n-  case CodeBlobType::NonNMethod:\n-    return \"NonNMethodCodeHeapSize\";\n-    break;\n-  case CodeBlobType::MethodNonProfiled:\n-    return \"NonProfiledCodeHeapSize\";\n-    break;\n-  case CodeBlobType::MethodProfiled:\n-    return \"ProfiledCodeHeapSize\";\n-    break;\n-  default:\n-    ShouldNotReachHere();\n-    return nullptr;\n+           (code_blob_type == CodeBlobType::MethodNonProfiled)\n+           COMPILER2_PRESENT(|| ((code_blob_type == CodeBlobType::MethodHot) && HotCodeHeap));\n@@ -507,1 +568,1 @@\n-  assert(heap != nullptr, \"heap is null\");\n+  assert(heap != nullptr, \"No heap for given code_blob_type (%d), heap is null\", (int)code_blob_type);\n@@ -535,0 +596,3 @@\n+        case CodeBlobType::MethodHot:\n+          type = CodeBlobType::MethodNonProfiled;\n+          break;\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":94,"deletions":30,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -123,2 +123,0 @@\n-  \/\/ Returns the name of the VM option to set the size of the corresponding CodeHeap\n-  static const char* get_code_heap_flag_name(CodeBlobType code_blob_type);\n@@ -267,1 +265,1 @@\n-    return type == CodeBlobType::All || type <= CodeBlobType::MethodProfiled;\n+    return type == CodeBlobType::All || type <= CodeBlobType::MethodHot;\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+#ifdef COMPILER2\n+#include \"runtime\/hotCodeGrouper.hpp\"\n+#endif \/\/ COMPILER2\n@@ -1256,0 +1259,5 @@\n+\n+#ifdef COMPILER2\n+  HotCodeGrouper::register_nmethod(this);\n+#endif \/\/ COMPILER2\n+\n@@ -2457,0 +2465,5 @@\n+\n+#ifdef COMPILER2\n+  HotCodeGrouper::unregister_nmethod(this);\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -331,0 +331,29 @@\n+#ifdef COMPILER2\n+  else if (HotCodeHeap && FLAG_IS_DEFAULT(SegmentedCodeCache)) {\n+    FLAG_SET_ERGO(SegmentedCodeCache, true);\n+  }\n+\n+  if (HotCodeHeap) {\n+    if (FLAG_IS_DEFAULT(NMethodRelocation)) {\n+      FLAG_SET_ERGO(NMethodRelocation, true);\n+    }\n+\n+    if (!NMethodRelocation) {\n+      vm_exit_during_initialization(\"HotCodeHeap requires NMethodRelocation enabled\");\n+    }\n+\n+    if (!SegmentedCodeCache) {\n+      vm_exit_during_initialization(\"HotCodeHeap requires SegmentedCodeCache enabled\");\n+    }\n+\n+    if (!is_c2_enabled()) {\n+      vm_exit_during_initialization(\"HotCodeHeap requires C2 enabled\");\n+    }\n+  } else if (HotCodeHeapSize > 0) {\n+    vm_exit_during_initialization(\"HotCodeHeapSize requires HotCodeHeap enabled\");\n+  }\n+#else\n+  if (HotCodeHeapSize > 0) {\n+    vm_exit_during_initialization(\"HotCodeHeapSize requires C2 present\");\n+  }\n+#endif \/\/ COMPILER2\n@@ -333,1 +362,1 @@\n-    vm_exit_during_initialization(\"Negative value specified for CompileThresholdScaling\", nullptr);\n+    vm_exit_during_initialization(\"Negative value specified for CompileThresholdScaling\");\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+  COMPILER2_PRESENT(LOG_TAG(hotcodegrouper)) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -896,0 +896,19 @@\n+                                                                            \\\n+  product(bool, HotCodeHeap, false, EXPERIMENTAL,                           \\\n+          \"Enable the code heap for hot C2 nmethods\")                       \\\n+                                                                            \\\n+  product(double, HotCodeSampleRatio, 0.8, DIAGNOSTIC,                      \\\n+          \"Ratio of samples from hot nmethods to consider grouping done\")   \\\n+          range(0.0, 1.0)                                                   \\\n+                                                                            \\\n+  product(double, HotCodeSteadyThreshold, 0.05, DIAGNOSTIC,                 \\\n+          \"Ratio of new to total C2 nmethods to be considered steady\")      \\\n+          range(0.0, 1.0)                                                   \\\n+                                                                            \\\n+  product(uintx, HotCodeIntervalSeconds, 300,                               \\\n+          \"Time between hot code grouping runs\")                            \\\n+          range(0, max_juint)                                               \\\n+                                                                            \\\n+  product(uintx, HotCodeSampleSeconds, 120,                                 \\\n+          \"Amount of time to sample application\")                           \\\n+          range(0, max_juint)                                               \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1547,0 +1547,4 @@\n+  product(size_t, HotCodeHeapSize, 0,                                       \\\n+          \"Size of code heap with predicted hot methods (in bytes)\")        \\\n+          constraint(VMPageSizeConstraintFunc, AtParse)                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifdef COMPILER2\n+\n+#include \"code\/codeCache.hpp\"\n+#include \"code\/compiledIC.hpp\"\n+#include \"compiler\/compilerDefinitions.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/hotCodeGrouper.hpp\"\n+#include \"runtime\/hotCodeSampler.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+\n+\/\/ Initalize static variables\n+bool      HotCodeGrouper::_is_initialized = false;\n+int       HotCodeGrouper::_new_c2_nmethods_count = 0;\n+int       HotCodeGrouper::_total_c2_nmethods_count = 0;\n+CodeHeap* HotCodeGrouper::hot_code_heap = nullptr;\n+\n+void HotCodeGrouper::initialize() {\n+  if (!HotCodeHeap) {\n+    return; \/\/ No hot code heap, no need for nmethod grouping\n+  }\n+\n+  assert(CompilerConfig::is_c2_enabled(), \"HotCodeGrouper requires C2 enabled\");\n+  assert(NMethodRelocation, \"HotCodeGrouper requires NMethodRelocation enabled\");\n+  assert(HotCodeHeapSize > 0, \"HotCodeHeapSize must be non-zero to use HotCodeGrouper\");\n+\n+  \/\/ Find HotCodeHeap\n+  const GrowableArray<CodeHeap*>* heaps = CodeCache::nmethod_heaps();\n+  for (GrowableArrayIterator<CodeHeap*> heap = heaps->begin(); heap != heaps->end(); ++heap) {\n+    if ((*heap)->accepts(CodeBlobType::MethodHot)) {\n+      hot_code_heap = *heap;\n+      break;\n+    }\n+  }\n+\n+  \/\/ If the hot code heap is not found return and remain uninitialized\n+  if (hot_code_heap == nullptr) {\n+    return;\n+  }\n+\n+  NonJavaThread* nmethod_grouper_thread = new HotCodeGrouper();\n+  if (os::create_thread(nmethod_grouper_thread, os::os_thread)) {\n+    os::start_thread(nmethod_grouper_thread);\n+  } else {\n+    vm_exit_during_initialization(\"Failed to create C2 nmethod grouper thread\");\n+  }\n+  _is_initialized = true;\n+}\n+\n+static inline bool steady_nmethod_count(int new_nmethods_count, int total_nmethods_count) {\n+  if (total_nmethods_count <= 0) {\n+    log_trace(hotcodegrouper)(\"C2 nmethod count not steady. Total C2 nmethods %d <= 0\", total_nmethods_count);\n+    return false;\n+  }\n+\n+  const double ratio_new = (double)new_nmethods_count \/ total_nmethods_count;\n+  bool is_steady_nmethod_count = ratio_new < HotCodeSteadyThreshold;\n+\n+  log_info(hotcodegrouper)(\"C2 nmethod count %s\", is_steady_nmethod_count ? \"steady\" : \"not steady\");\n+  log_trace(hotcodegrouper)(\"\\t- New: %d. Total: %d. Ratio: %f. Threshold: %f\", new_nmethods_count, total_nmethods_count, ratio_new, HotCodeSteadyThreshold);\n+\n+  return is_steady_nmethod_count;\n+}\n+\n+bool HotCodeGrouper::hot_heap_has_space(size_t size) {\n+  assert(hot_code_heap != nullptr, \"must initialize HotCodeGrouper\");\n+  return hot_code_heap->unallocated_capacity() > size;\n+}\n+\n+void HotCodeGrouper::run() {\n+  while (true) {\n+    os::naked_sleep(HotCodeIntervalSeconds * 1000);\n+\n+    ResourceMark rm;\n+\n+    { \/\/ Acquire CodeCache_lock and check if c2 nmethod count is steady\n+      MutexLocker ml_CodeCache_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+      bool is_steady_nmethod_count = steady_nmethod_count(_new_c2_nmethods_count, _total_c2_nmethods_count);\n+      _new_c2_nmethods_count = 0;\n+\n+      if (!is_steady_nmethod_count) {\n+        continue;\n+      }\n+    }\n+\n+    \/\/ Sample application and group hot nmethods\n+    ThreadSampler sampler;\n+    sampler.do_sampling();\n+    do_grouping(sampler);\n+  }\n+}\n+\n+void HotCodeGrouper::do_grouping(ThreadSampler& sampler) {\n+  while (sampler.has_candidates()) {\n+\n+    double ratio_from_hot = sampler.get_hot_sample_ratio();\n+    log_trace(hotcodegrouper)(\"Ratio of samples from hot code heap: %f\", ratio_from_hot);\n+    if (ratio_from_hot > HotCodeSampleRatio) {\n+      log_info(hotcodegrouper)(\"Ratio of samples from hot nmethods (%f) over threshold (%f). Done grouping\", ratio_from_hot, HotCodeSampleRatio);\n+      break;\n+    }\n+\n+    nmethod* candidate = sampler.get_candidate();\n+\n+    MutexLocker ml_Compile_lock(Compile_lock);\n+    MutexLocker ml_CompiledIC_lock(CompiledIC_lock, Mutex::_no_safepoint_check_flag);\n+    MutexLocker ml_CodeCache_lock(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+\n+    \/\/ Verify that address still points to CodeBlob\n+    CodeBlob* blob = CodeCache::find_blob(candidate);\n+    if (blob == nullptr) {\n+      continue;\n+    }\n+\n+    \/\/ Verify that nmethod address is still valid and not in hot code heap\n+    nmethod* nm = blob->as_nmethod_or_null();\n+    if (nm != candidate || !nm->is_in_use() || !nm->is_compiled_by_c2() || CodeCache::get_code_blob_type(nm) == CodeBlobType::MethodHot) {\n+      continue;\n+    }\n+\n+    if (!hot_heap_has_space(nm->size())) {\n+      log_info(hotcodegrouper)(\"Not enough space in HotCodeHeap (%zd bytes) to relocate nm (%d bytes). Bailing out\",\n+        hot_code_heap->unallocated_capacity(), nm->size());\n+      return;\n+    }\n+\n+    { \/\/ Relocate caller\n+      CompiledICLocker ic_locker(nm);\n+      if (nm->relocate(CodeBlobType::MethodHot) != nullptr) {\n+        sampler.update_sample_count(nm);\n+      }\n+    }\n+\n+    \/\/ Loop over relocations to relocate callees\n+    RelocIterator relocIter(nm);\n+    while (relocIter.next()) {\n+\n+      \/\/ Check is a call\n+      Relocation* reloc = relocIter.reloc();\n+      if(!reloc->is_call()) {\n+        continue;\n+      }\n+\n+      \/\/ Find the call destination address\n+      address dest = ((CallRelocation*) reloc)->destination();\n+\n+      \/\/ Check if the destination is to something in the code cache\n+      if (!CodeCache::contains(dest)) {\n+        continue;\n+      }\n+\n+      \/\/ Check if destination is a CodeBlob\n+      CodeBlob* dest_blob = CodeCache::find_blob(dest);\n+      if (dest_blob == nullptr) {\n+        continue;\n+      }\n+\n+      \/\/ Check if the destination is an nmethod\n+      nmethod* dest_nm = dest_blob->as_nmethod_or_null();\n+      if (dest_nm == nullptr || dest_nm->method() == nullptr) {\n+        continue;\n+      }\n+\n+      \/\/ Retrieve the latest nmethod for the destination's Method.\n+      \/\/ Due to relocation or recompilation, the destination may not yet reference\n+      \/\/ the Methodâ€™s most up to date nmethod.\n+      nmethod* actual_dest_nm = dest_nm->method()->code();\n+\n+      \/\/ Check is valid\n+      if (actual_dest_nm == nullptr || !actual_dest_nm->is_in_use() || !actual_dest_nm->is_compiled_by_c2() || CodeCache::get_code_blob_type(actual_dest_nm) == CodeBlobType::MethodHot) {\n+        continue;\n+      }\n+\n+      if (!hot_heap_has_space(actual_dest_nm->size())) {\n+        log_info(hotcodegrouper)(\"Not enough space in HotCodeHeap (%zd bytes) to relocate nm (%d bytes). Bailing out\",\n+          hot_code_heap->unallocated_capacity(), actual_dest_nm->size());\n+        return;\n+      }\n+\n+      { \/\/ Relocate callee\n+        CompiledICLocker ic_locker(actual_dest_nm);\n+        if (actual_dest_nm->relocate(CodeBlobType::MethodHot) != nullptr) {\n+          sampler.update_sample_count(actual_dest_nm);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void HotCodeGrouper::unregister_nmethod(nmethod* nm) {\n+  assert_lock_strong(CodeCache_lock);\n+  if (!_is_initialized) {\n+    return;\n+  }\n+\n+  if (!nm->is_compiled_by_c2()) {\n+    return;\n+  }\n+\n+  if (CodeCache::get_code_blob_type(nm) == CodeBlobType::MethodHot) {\n+    \/\/ Nmethods in the hot code heap do not count towards total C2 nmethods.\n+    return;\n+  }\n+\n+  \/\/ CodeCache_lock is held, so we can safely decrement the count.\n+  _total_c2_nmethods_count--;\n+}\n+\n+void HotCodeGrouper::register_nmethod(nmethod* nm) {\n+  assert_lock_strong(CodeCache_lock);\n+  if (!_is_initialized) {\n+    return;\n+  }\n+\n+  if (!nm->is_compiled_by_c2()) {\n+    return; \/\/ Only C2 nmethods are relocated to HotCodeHeap.\n+  }\n+\n+  if (CodeCache::get_code_blob_type(nm) == CodeBlobType::MethodHot) {\n+    \/\/ Nmethods in the hot code heap do not count towards total C2 nmethods.\n+    return;\n+  }\n+\n+  \/\/ CodeCache_lock is held, so we can safely increment the count.\n+  _new_c2_nmethods_count++;\n+  _total_c2_nmethods_count++;\n+}\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/share\/runtime\/hotCodeGrouper.cpp","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifdef COMPILER2\n+#ifndef SHARE_RUNTIME_HOTCODEGROUPER_HPP\n+#define SHARE_RUNTIME_HOTCODEGROUPER_HPP\n+\n+#include \"code\/codeCache.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+\n+class ThreadSampler;\n+\n+class HotCodeGrouper : public NonJavaThread {\n+ private:\n+  static bool _is_initialized;\n+\n+  static int _new_c2_nmethods_count;\n+  static int _total_c2_nmethods_count;\n+\n+  static CodeHeap* hot_code_heap;\n+\n+  void do_grouping(ThreadSampler& sampler);\n+\n+ public:\n+\n+  void run() override;\n+\n+  virtual const char* name()      const override { return \"Hot Code Grouper Thread\"; }\n+  virtual const char* type_name() const override { return \"HotCodeGrouper\"; }\n+\n+  static void initialize();\n+  static void unregister_nmethod(nmethod* nm);\n+  static void register_nmethod(nmethod* nm);\n+\n+  bool hot_heap_has_space(size_t size);\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_HOTCODEGROUPER_HPP\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/share\/runtime\/hotCodeGrouper.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifdef COMPILER2\n+\n+#include \"code\/codeCache.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/hotCodeSampler.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+\n+ThreadSampler* ThreadSampler::_current_sampler = nullptr;\n+\n+void ThreadSampler::do_sampling() {\n+  log_info(hotcodegrouper)(\"Sampling...\");\n+\n+  int total_samples = 0;\n+\n+  uint64_t start_time = os::javaTimeMillis();\n+\n+  while (true) {\n+    { \/\/ Collect sample for each JavaThread\n+      MutexLocker ml(Threads_lock);\n+\n+      for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n+        if (jt->is_hidden_from_external_view() ||\n+            jt->in_deopt_handler() ||\n+            (jt->thread_state() != _thread_in_native && jt->thread_state() != _thread_in_Java)) {\n+          continue;\n+        }\n+\n+        GetPCTask task(jt);\n+        task.run();\n+        address pc = task.pc();\n+        if (pc == nullptr) {\n+          continue;\n+        }\n+\n+        total_samples++;\n+\n+        if (CodeCache::contains(pc)) {\n+          nmethod* nm = CodeCache::find_blob(pc)->as_nmethod_or_null();\n+          if (nm != nullptr) {\n+            bool created = false;\n+            int *count = _samples.put_if_absent(nm, 0, &created);\n+            (*count)++;\n+            if (created) {\n+              _samples.maybe_grow();\n+            }\n+            nm->mark_as_maybe_on_stack();\n+          }\n+        }\n+      }\n+    }\n+\n+    \/\/ Check if we have sampled long enough\n+    if (os::javaTimeMillis() - start_time > HotCodeSampleSeconds * 1000) {\n+      log_info(hotcodegrouper)(\"Profiling complete: collected %d samples corresponding to %d nmethods\", total_samples, _samples.number_of_entries());\n+      generate_sorted_candidate_list();\n+      return;\n+    }\n+\n+    os::naked_sleep(rand_sampling_period_ms());\n+  }\n+}\n+\n+void ThreadSampler::generate_sorted_candidate_list() {\n+  assert(_sorted_candidate_list.is_empty(), \"should only generate once\");\n+\n+  \/\/ Add every C2 nmethod not in hot code heap to array\n+  auto func = [&](nmethod* nm, uint64_t count) {\n+    if (CodeCache::get_code_blob_type(nm) == CodeBlobType::MethodNonProfiled) {\n+      _non_profiled_sample_count += count;\n+      _sorted_candidate_list.append(nm);\n+    } else if (CodeCache::get_code_blob_type(nm) == CodeBlobType::MethodHot) {\n+      _hot_sample_count += count;\n+    }\n+  };\n+  _samples.iterate_all(func);\n+\n+  \/\/ Sort nmethods by increasing sample count\n+  assert(_current_sampler == nullptr, \"not thread safe\");\n+  _current_sampler = this;\n+  _sorted_candidate_list.sort(\n+    [](nmethod** a, nmethod** b) {\n+      ThreadSampler* self = get_current_sampler();\n+      if (*(self->_samples.get(*a)) > *(self->_samples.get(*b))) return 1;\n+      if (*(self->_samples.get(*a)) < *(self->_samples.get(*b))) return -1;\n+      return 0;\n+    }\n+  );\n+  _current_sampler = nullptr;\n+}\n+\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/share\/runtime\/hotCodeSampler.cpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifdef COMPILER2\n+#ifndef SHARE_RUNTIME_HOTCODESAMPLER_HPP\n+#define SHARE_RUNTIME_HOTCODESAMPLER_HPP\n+\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/suspendedThreadTask.hpp\"\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"utilities\/resizableHashTable.hpp\"\n+\n+\/\/ Minumum amount of time between samples\n+static inline int64_t min_sampling_period_ms() {\n+  return 5;\n+}\n+\n+\/\/ Maximum amount of time between samples\n+static inline int64_t max_sampling_period_ms() {\n+  return 15;\n+}\n+\n+\/\/ Generate a random sampling period between min and max\n+static inline int64_t rand_sampling_period_ms() {\n+  return os::random() % (max_sampling_period_ms() - min_sampling_period_ms() + 1) + min_sampling_period_ms();\n+}\n+\n+class GetPCTask : public SuspendedThreadTask {\n+ private:\n+  address _pc;\n+\n+  void do_task(const SuspendedThreadTaskContext& context) override{\n+    JavaThread* jt = JavaThread::cast(context.thread());\n+    if (jt->thread_state() != _thread_in_native && jt->thread_state() != _thread_in_Java) {\n+      return;\n+    }\n+    _pc = os::fetch_frame_from_context(context.ucontext(), nullptr, nullptr);\n+  }\n+\n+ public:\n+  GetPCTask(JavaThread* thread) : SuspendedThreadTask(thread), _pc(nullptr) {}\n+\n+  address pc() const {\n+    return _pc;\n+  }\n+};\n+\n+class ThreadSampler : public StackObj {\n+ public:\n+  static const int INITIAL_TABLE_SIZE = 109;\n+\n+  static ThreadSampler* _current_sampler;\n+\n+  \/\/ Table of nmethods found during profiling with sample count\n+  ResizeableHashTable<nmethod*, int, AnyObj::C_HEAP, mtCompiler> _samples;\n+\n+  int _hot_sample_count;\n+  int _non_profiled_sample_count;\n+\n+  \/\/ List of nmethods from profiling that are candidates for grouping\n+  GrowableArray<nmethod*> _sorted_candidate_list;\n+\n+  \/\/ Find candidate nmethods for grouping\n+  void generate_sorted_candidate_list();\n+\n+  static ThreadSampler* get_current_sampler() {\n+    return _current_sampler;\n+  }\n+\n+ public:\n+  ThreadSampler() : _samples(INITIAL_TABLE_SIZE, HotCodeSampleSeconds * 1000 \/ max_sampling_period_ms()), _hot_sample_count(0), _non_profiled_sample_count(0) {}\n+\n+  \/\/ Sample and generate the candidate nmethods for grouping\n+  void do_sampling();\n+\n+  \/\/ Get number of samples for nmethod. Returns zero if not found\n+  int get_sample_count(nmethod* nm) {\n+    int* num = _samples.get(nm);\n+    return num == nullptr ? 0 : *num;\n+  }\n+\n+  \/\/ Get ratio of C2 samples from hot code heap\n+  double get_hot_sample_ratio() {\n+    return (double) _hot_sample_count \/ (_hot_sample_count + _non_profiled_sample_count);\n+  }\n+\n+  \/\/ Update the number of samples from hot code heap after relocating nmethod\n+  void update_sample_count(nmethod* nm) {\n+    int samples = get_sample_count(nm);\n+    _hot_sample_count += samples;\n+    _non_profiled_sample_count -= samples;\n+  }\n+\n+  \/\/ Returns true if we still have candidates for grouping\n+  bool has_candidates() {\n+    return !_sorted_candidate_list.is_empty();\n+  }\n+\n+  \/\/ Get next candidate nmethod for grouping\n+  nmethod* get_candidate() {\n+    assert(has_candidates(), \"must not be empty\");\n+    return _sorted_candidate_list.pop();\n+  }\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_HOTCODESAMPLER_HPP\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/share\/runtime\/hotCodeSampler.hpp","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -44,0 +44,3 @@\n+#ifdef COMPILER2\n+#include \"runtime\/hotCodeGrouper.hpp\"\n+#endif \/\/ COMPILER2\n@@ -207,0 +210,6 @@\n+#ifdef COMPILER2\n+  if (HotCodeHeap) {\n+    HotCodeGrouper::initialize();\n+  }\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -161,0 +161,4 @@\n+#ifdef COMPILER2\n+Monitor* HotCodeGrouper_lock          = nullptr;\n+#endif \/\/ COMPILER2\n+\n@@ -367,0 +371,4 @@\n+#ifdef COMPILER2\n+  MUTEX_DEFL(HotCodeGrouper_lock            , PaddedMonitor, CodeCache_lock);\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -159,0 +159,4 @@\n+#ifdef COMPILER2\n+extern Monitor* HotCodeGrouper_lock;             \/\/ used to awake the hot code grouper if reprofiling is needed\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2022 SAP SE. All rights reserved.ights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025 SAP SE. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @requires vm.compiler2.enabled\n@@ -42,0 +43,5 @@\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:CompileCommand=compileonly,null::*\n+ *                   -XX:ReservedCodeCacheSize=20m -XX:+SegmentedCodeCache\n+ *                   -XX:+TieredCompilation -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=4M\n+ *                   compiler.codecache.MHIntrinsicAllocFailureTest\n@@ -76,1 +82,1 @@\n-        \/\/ Generate and use a MH itrinsic. Should not trigger one of the following:\n+        \/\/ Generate and use a MH intrinsic. Should not trigger one of the following:\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/MHIntrinsicAllocFailureTest.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,21 @@\n+\/*\n+ * @test OverflowCodeCacheTest\n+ * @bug 8059550 8279356 8326205\n+ * @requires vm.compiler2.enabled\n+ * @summary testing of code cache segments overflow\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:+TieredCompilation -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M\n+ *                   -Xmixed -XX:TieredStopAtLevel=4\n+ *                   compiler.codecache.OverflowCodeCacheTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI -XX:-TieredCompilation -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M\n+ *                   -Xmixed -XX:TieredStopAtLevel=4\n+ *                   compiler.codecache.OverflowCodeCacheTest\n+ *\/\n+\n@@ -88,0 +109,1 @@\n+        CodeCacheConstraints constraints = getCodeCacheConstraints(type);\n@@ -118,0 +140,1 @@\n+            constraints.check();\n@@ -146,0 +169,27 @@\n+    class CodeCacheConstraints {\n+        void check() {}\n+    }\n+\n+    CodeCacheConstraints getCodeCacheConstraints(final BlobType type) {\n+        if (Long.valueOf(0).equals(WHITE_BOX.getVMFlag(\"HotCodeHeapSize\"))) {\n+            return new CodeCacheConstraints();\n+        } else if (BlobType.MethodHot == type) {\n+            \/\/ NonProfiledHeap is used when HotCodeHeap runs out of space.\n+            return new CodeCacheConstraints() {\n+                final int nonProfiledCount = WHITE_BOX.getCodeHeapEntries(BlobType.MethodNonProfiled.id).length;\n+                @Override\n+                void check() {\n+                    Asserts.assertLT(nonProfiledCount, WHITE_BOX.getCodeHeapEntries(BlobType.MethodNonProfiled.id).length);\n+                }\n+            };\n+        } else {\n+            \/\/ HotCodeHeap should not be used when other heap runs out of space.\n+            return new CodeCacheConstraints() {\n+                final int hotCount = WHITE_BOX.getCodeHeapEntries(BlobType.MethodHot.id).length;\n+                @Override\n+                void check() {\n+                    Asserts.assertEQ(hotCount, WHITE_BOX.getCodeHeapEntries(BlobType.MethodHot.id).length);\n+                }\n+            };\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/OverflowCodeCacheTest.java","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,4 @@\n+    private static final String UNLOCK_EXPERIMENTAL_VM_OPTIONS\n+            = CommandLineOptionTest.prepareBooleanFlag(\"UnlockExperimentalVMOptions\", true);\n+    private static final String HOT_CODE_HEAP\n+            = CommandLineOptionTest.prepareBooleanFlag(\"HotCodeHeap\", true);\n@@ -57,0 +61,2 @@\n+    private static final long HOT_CODE_HEAP_SIZE\n+            = CodeCacheOptions.mB(8);\n@@ -107,1 +113,1 @@\n-                        + \" should be disabled by default  when tiered \"\n+                        + \" should be disabled by default when tiered \"\n@@ -165,0 +171,46 @@\n+        },\n+        OPTION_VALUES_HOT {\n+            @Override\n+            public boolean isApplicable() {\n+                return Platform.isServer() && !Platform.isEmulatedClient();\n+            }\n+\n+            @Override\n+            public void run() throws Throwable {\n+                \/\/ SCC is enabled w hot code heap w\/o TieredCompilation\n+                String errorMessage = SEGMENTED_CODE_CACHE\n+                        + \" should be enabled when the hot code heap \"\n+                        + \"is enabled\";\n+\n+                CommandLineOptionTest.verifyOptionValueForSameVM(\n+                        SEGMENTED_CODE_CACHE, \"true\", errorMessage,\n+                        UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n+                        HOT_CODE_HEAP,\n+                        CommandLineOptionTest.prepareNumericFlag(\n+                                BlobType.MethodHot.sizeOptionName,\n+                                HOT_CODE_HEAP_SIZE),\n+                        CommandLineOptionTest.prepareBooleanFlag(\n+                                TIERED_COMPILATION, false));\n+\n+                \/\/ Hot code heap could be explicitly enabled w\/ SegmentedCodeCache\n+                \/\/ and w\/ ReservedCodeCacheSize value below the threshold\n+                errorMessage = String.format(\"It should be possible to explicitly \"\n+                                + \"enable %s and %s with %s below threshold %d.\",\n+                        BlobType.MethodHot.sizeOptionName,\n+                        SEGMENTED_CODE_CACHE,\n+                        BlobType.All.sizeOptionName,\n+                        THRESHOLD_CC_SIZE_VALUE);\n+\n+                CommandLineOptionTest.verifyOptionValueForSameVM(\n+                        BlobType.MethodHot.sizeOptionName, String.valueOf(HOT_CODE_HEAP_SIZE),\n+                        errorMessage,\n+                        UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n+                        HOT_CODE_HEAP,\n+                        CommandLineOptionTest.prepareNumericFlag(\n+                                BlobType.All.sizeOptionName,\n+                                BELOW_THRESHOLD_CC_SIZE),\n+                        CommandLineOptionTest.prepareNumericFlag(\n+                                BlobType.MethodHot.sizeOptionName,\n+                                HOT_CODE_HEAP_SIZE),\n+                        USE_SEGMENTED_CODE_CACHE);\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/TestSegmentedCodeCacheOption.java","additions":54,"deletions":2,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,8 @@\n+\n+        CommandLineOptionTest.verifyOptionValueForSameVM(\n+                BlobType.MethodHot.sizeOptionName,\n+                Long.toString(expectedValues.hot),\n+                String.format(\"%s should have value %d.\",\n+                        BlobType.MethodHot.sizeOptionName,\n+                        expectedValues.hot),\n+                testCaseDescription.getTestOptions(options));\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/codeheapsize\/GenericCodeHeapSizeRunner.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,2 @@\n-                            options -> options.segmented,\n+                            options -> options.segmented\n+                                    && options.hot == 0,\n@@ -58,0 +59,1 @@\n+                                    && options.hot == 0\n@@ -68,1 +70,1 @@\n-                        .CommonDescriptions.NON_TIERED.description,\n+                        .CommonDescriptions.NON_TIERED_WO_HOT.description,\n@@ -74,1 +76,7 @@\n-                        .CommonDescriptions.TIERED_LEVEL_4.description,\n+                        .CommonDescriptions.TIERED_LEVEL_4_WO_HOT.description,\n+                        GENERIC_RUNNER),\n+                new CodeCacheCLITestCase(CodeCacheCLITestCase\n+                        .CommonDescriptions.NON_TIERED_W_HOT.description,\n+                        GENERIC_RUNNER),\n+                new CodeCacheCLITestCase(CodeCacheCLITestCase\n+                        .CommonDescriptions.TIERED_LEVEL_4_W_HOT.description,\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/codeheapsize\/TestCodeHeapSizeOptions.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,7 @@\n-            new CodeCacheOptions(CodeCacheOptions.mB(300))\n+            new CodeCacheOptions(CodeCacheOptions.mB(300)),\n+            new CodeCacheOptions(CodeCacheOptions.mB(250),\n+                    CodeCacheOptions.mB(50), CodeCacheOptions.mB(75),\n+                    CodeCacheOptions.mB(75), CodeCacheOptions.mB(50)),\n+            new CodeCacheOptions(CodeCacheOptions.mB(200),\n+                    CodeCacheOptions.mB(50), CodeCacheOptions.mB(100),\n+                    CodeCacheOptions.mB(0),  CodeCacheOptions.mB(50))\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/common\/CodeCacheCLITestBase.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,4 +42,4 @@\n-    private static final Function<CodeCacheOptions, Boolean> ONLY_SEGMENTED\n-            = options -> options.segmented;\n-    private static final Function<CodeCacheOptions, Boolean> SEGMENTED_SERVER\n-            = ONLY_SEGMENTED.andThen(isSegmented -> isSegmented\n+    private static final Function<CodeCacheOptions, Boolean> SEGMENTED_WO_HOT\n+            = options -> options.segmented && options.hot == 0;\n+    private static final Function<CodeCacheOptions, Boolean> SEGMENTED_SERVER_WO_HOT\n+            = SEGMENTED_WO_HOT.andThen(isSegmented -> isSegmented\n@@ -47,0 +47,7 @@\n+    private static final Function<CodeCacheOptions, Boolean> SEGMENTED_W_HOT\n+            = options -> options.segmented && options.hot > 0\n+                    && options.profiled > 0 && Platform.isTieredSupported();\n+    private static final Function<CodeCacheOptions, Boolean> SEGMENTED_W_HOT_WO_PROFILED\n+            = options -> options.segmented && options.hot > 0\n+                    && options.profiled == 0 && Platform.isTieredSupported();\n+\n@@ -51,0 +58,2 @@\n+    private static final String UNLOCK_EXPERIMENTAL_VM_OPTIONS = \"UnlockExperimentalVMOptions\";\n+    private static final String HOT_CODE_HEAP = \"HotCodeHeap\";\n@@ -71,1 +80,1 @@\n-        INT_MODE(ONLY_SEGMENTED, EnumSet.of(BlobType.All), USE_INT_MODE),\n+        INT_MODE(options -> options.hot == 0, EnumSet.of(BlobType.All), USE_INT_MODE),\n@@ -84,1 +93,1 @@\n-        NON_TIERED(ONLY_SEGMENTED,\n+        NON_TIERED_WO_HOT(SEGMENTED_WO_HOT,\n@@ -93,1 +102,1 @@\n-        TIERED_LEVEL_0(SEGMENTED_SERVER,\n+        TIERED_LEVEL_0(SEGMENTED_SERVER_WO_HOT,\n@@ -103,1 +112,1 @@\n-        TIERED_LEVEL_1(SEGMENTED_SERVER,\n+        TIERED_LEVEL_1(SEGMENTED_SERVER_WO_HOT,\n@@ -110,1 +119,2 @@\n-         * contain information about all three code heaps.\n+         * contain information about non-nmethods, non-profiled nmethods\n+         * and profiled nmethods heaps only.\n@@ -112,2 +122,2 @@\n-        TIERED_LEVEL_4(SEGMENTED_SERVER,\n-                EnumSet.complementOf(EnumSet.of(BlobType.All)),\n+        TIERED_LEVEL_4_WO_HOT(SEGMENTED_SERVER_WO_HOT,\n+                EnumSet.complementOf(EnumSet.of(BlobType.MethodHot, BlobType.All)),\n@@ -116,0 +126,24 @@\n+                CommandLineOptionTest.prepareNumericFlag(TIERED_STOP_AT, 4)),\n+\n+        \/**\n+         * Verifies that with disabled tiered compilation and enabled hot code\n+         * cache PrintCodeCache output does not contain information about\n+         * profiled-nmethods heap and non-segmented CodeCache.\n+         *\/\n+        NON_TIERED_W_HOT(SEGMENTED_W_HOT_WO_PROFILED,\n+                EnumSet.of(BlobType.NonNMethod, BlobType.MethodNonProfiled, BlobType.MethodHot),\n+                CommandLineOptionTest.prepareBooleanFlag(UNLOCK_EXPERIMENTAL_VM_OPTIONS, true),\n+                CommandLineOptionTest.prepareBooleanFlag(HOT_CODE_HEAP, true),\n+                CommandLineOptionTest.prepareBooleanFlag(TIERED_COMPILATION,\n+                        false)),\n+\n+        \/**\n+         * Verifies that with TieredStopAtLevel=4 and hot code heap\n+         * PrintCodeCache output will contain information about non-nmethods,\n+         * non-profiled nmethods, profiled nmethods, and hot code heaps only.\n+         *\/\n+        TIERED_LEVEL_4_W_HOT(SEGMENTED_W_HOT,\n+                EnumSet.complementOf(EnumSet.of(BlobType.All)),\n+                CommandLineOptionTest.prepareBooleanFlag(UNLOCK_EXPERIMENTAL_VM_OPTIONS, true),\n+                CommandLineOptionTest.prepareBooleanFlag(HOT_CODE_HEAP, true),\n+                CommandLineOptionTest.prepareBooleanFlag(TIERED_COMPILATION, true),\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/common\/CodeCacheCLITestCase.java","additions":46,"deletions":12,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-    private static final EnumSet<BlobType> SEGMENTED_HEAPS_WO_PROFILED\n+    private static final EnumSet<BlobType> NON_NMETHOD_AND_NON_PROFILED_HEAPS\n@@ -42,0 +42,2 @@\n+    private static final EnumSet<BlobType> SEGMENTED_HEAPS_WO_HOT\n+            = EnumSet.of(BlobType.NonNMethod, BlobType.MethodProfiled, BlobType.MethodNonProfiled);\n@@ -44,0 +46,2 @@\n+    private static final EnumSet<BlobType> NON_NMETHOD_AND_NON_PROFILED_AND_HOT_HEAPS\n+            = EnumSet.of(BlobType.NonNMethod, BlobType.MethodNonProfiled, BlobType.MethodHot);\n@@ -49,0 +53,1 @@\n+    public final long hot;\n@@ -64,0 +69,1 @@\n+        this.hot = 0;\n@@ -73,0 +79,11 @@\n+        this.hot = 0;\n+        this.segmented = true;\n+    }\n+\n+    public CodeCacheOptions(long reserved, long nonNmethods, long nonProfiled,\n+            long profiled, long hot) {\n+        this.reserved = reserved;\n+        this.nonNmethods = nonNmethods;\n+        this.nonProfiled = nonProfiled;\n+        this.profiled = profiled;\n+        this.hot = hot;\n@@ -86,0 +103,2 @@\n+            case MethodHot:\n+                return this.hot;\n@@ -109,0 +128,5 @@\n+            if (hot > 0) {\n+                Collections.addAll(options,\n+                        CommandLineOptionTest.prepareNumericFlag(\n+                                BlobType.MethodHot.sizeOptionName, hot));\n+            }\n@@ -116,1 +140,3 @@\n-                || involvedCodeHeaps.equals(ALL_SEGMENTED_HEAPS)) {\n+                || involvedCodeHeaps.equals(SEGMENTED_HEAPS_WO_HOT)\n+                || involvedCodeHeaps.equals(ALL_SEGMENTED_HEAPS)\n+                || involvedCodeHeaps.equals(NON_NMETHOD_AND_NON_PROFILED_AND_HOT_HEAPS)) {\n@@ -118,1 +144,1 @@\n-        } else if (involvedCodeHeaps.equals(SEGMENTED_HEAPS_WO_PROFILED)) {\n+        } else if (involvedCodeHeaps.equals(NON_NMETHOD_AND_NON_PROFILED_HEAPS)) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/common\/CodeCacheOptions.java","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-                            options -> true, EnumSet.noneOf(BlobType.class)),\n+                            options -> options.hot == 0, EnumSet.noneOf(BlobType.class)),\n@@ -64,1 +64,1 @@\n-                        .CommonDescriptions.NON_TIERED.description,\n+                        .CommonDescriptions.NON_TIERED_WO_HOT.description,\n@@ -73,1 +73,7 @@\n-                        .CommonDescriptions.TIERED_LEVEL_4.description,\n+                        .CommonDescriptions.TIERED_LEVEL_4_WO_HOT.description,\n+                        DEFAULT_RUNNER),\n+                new CodeCacheCLITestCase(CodeCacheCLITestCase\n+                        .CommonDescriptions.NON_TIERED_W_HOT.description,\n+                        DEFAULT_RUNNER),\n+                new CodeCacheCLITestCase(CodeCacheCLITestCase\n+                        .CommonDescriptions.TIERED_LEVEL_4_W_HOT.description,\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/cli\/printcodecache\/TestPrintCodeCacheOption.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,20 @@\n+\/**\n+ * @test BeanTypeTest\n+ * @requires vm.compiler2.enabled\n+ * @summary verify types of code cache memory pool bean\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @library \/test\/lib\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.BeanTypeTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.BeanTypeTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/BeanTypeTest.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,20 @@\n+\/**\n+ * @test CodeHeapBeanPresenceTest\n+ * @requires vm.compiler2.enabled\n+ * @summary verify CodeHeap bean presence\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @library \/test\/lib\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.CodeHeapBeanPresenceTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.CodeHeapBeanPresenceTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/CodeHeapBeanPresenceTest.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,22 @@\n+\/*\n+ * @test GetUsageTest\n+ * @requires vm.compiler2.enabled\n+ * @summary testing of getUsage() for segmented code cache\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @library \/test\/lib \/\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI -XX:CompileCommand=compileonly,null::*\n+ *     -XX:-UseCodeCacheFlushing -XX:-MethodFlushing\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.GetUsageTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI -XX:CompileCommand=compileonly,null::*\n+ *     -XX:-UseCodeCacheFlushing -XX:-MethodFlushing\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.GetUsageTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/GetUsageTest.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,22 @@\n+\/*\n+ * @test InitialAndMaxUsageTest\n+ * @requires vm.compiler2.enabled\n+ * @summary testing of initial and max usage\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @library \/test\/lib \/\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:-UseCodeCacheFlushing\n+ *     -XX:-MethodFlushing -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:CompileCommand=compileonly,null::* -XX:-UseLargePages\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.InitialAndMaxUsageTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:-UseCodeCacheFlushing\n+ *     -XX:-MethodFlushing -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:CompileCommand=compileonly,null::* -XX:-UseLargePages\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.InitialAndMaxUsageTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/InitialAndMaxUsageTest.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,20 @@\n+\/**\n+ * @test ManagerNamesTest\n+ * @requires vm.compiler2.enabled\n+ * @summary verify getMemoryManageNames calls in case of segmented code cache\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @library \/test\/lib\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.ManagerNamesTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.ManagerNamesTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/ManagerNamesTest.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,20 @@\n+\/**\n+ * @test MemoryPoolsPresenceTest\n+ * @requires vm.compiler2.enabled\n+ * @summary verify that MemoryManagerMXBean exists for every code cache segment\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @library \/test\/lib\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.MemoryPoolsPresenceTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.MemoryPoolsPresenceTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/MemoryPoolsPresenceTest.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+ * @summary testing of getPeakUsage() and resetPeakUsage for\n+ *     segmented code cache\n@@ -40,0 +42,5 @@\n+ *\/\n+\n+\/*\n+ * @test PeakUsageTest\n+ * @requires vm.compiler2.enabled\n@@ -42,0 +49,14 @@\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI -XX:CompileCommand=compileonly,null::*\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.PeakUsageTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI -XX:CompileCommand=compileonly,null::*\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.PeakUsageTest\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/PeakUsageTest.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,20 @@\n+\/*\n+ * @test PoolsIndependenceTest\n+ * @requires vm.compiler2.enabled\n+ * @summary testing of getUsageThreshold()\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @library \/test\/lib \/\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing -XX:-MethodFlushing\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.PoolsIndependenceTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing -XX:-MethodFlushing\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.PoolsIndependenceTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/PoolsIndependenceTest.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,20 @@\n+\/*\n+ * @test ThresholdNotificationsTest\n+ * @requires vm.compiler2.enabled\n+ * @summary testing of getUsageThreshold()\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:-UseCodeCacheFlushing\n+ *     -XX:+WhiteBoxAPI -XX:-MethodFlushing -XX:CompileCommand=compileonly,null::*\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.ThresholdNotificationsTest\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -Xbootclasspath\/a:. -XX:-UseCodeCacheFlushing\n+ *     -XX:+WhiteBoxAPI -XX:-MethodFlushing -XX:CompileCommand=compileonly,null::*\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.ThresholdNotificationsTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/ThresholdNotificationsTest.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,23 @@\n+\n+\/*\n+ * @test UsageThresholdExceededSeveralTimesTest\n+ * @requires vm.compiler2.enabled\n+ * @summary verifying that getUsageThresholdCount() returns correct value\n+ *     after threshold has been hit several times\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing -XX:-MethodFlushing\n+ *      -XX:CompileCommand=compileonly,null::* -Djdk.test.lib.iterations=10\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *      compiler.codecache.jmx.UsageThresholdExceededTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *      -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing -XX:-MethodFlushing\n+ *      -XX:CompileCommand=compileonly,null::* -Djdk.test.lib.iterations=10\n+ *      -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *      compiler.codecache.jmx.UsageThresholdExceededTest\n+ *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/UsageThresholdExceededSeveralTimesTest.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- *     -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing  -XX:-MethodFlushing\n+ *     -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing -XX:-MethodFlushing\n@@ -40,1 +40,1 @@\n- *     -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing  -XX:-MethodFlushing\n+ *     -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing -XX:-MethodFlushing\n@@ -46,0 +46,23 @@\n+\/*\n+ * @test UsageThresholdExceededTest\n+ * @requires vm.compiler2.enabled\n+ * @summary verifying that getUsageThresholdCount() returns correct value\n+ *     after threshold has been hit\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing -XX:-MethodFlushing\n+ *     -XX:CompileCommand=compileonly,null::*\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.UsageThresholdExceededTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing -XX:-MethodFlushing\n+ *     -XX:CompileCommand=compileonly,null::*\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.UsageThresholdExceededTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/UsageThresholdExceededTest.java","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,22 @@\n+\/*\n+ * @test UsageThresholdIncreasedTest\n+ * @requires vm.compiler2.enabled\n+ * @summary verifying that threshold hasn't been hit after allocation smaller\n+ *     than threshold value and that threshold value can be changed\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing  -XX:-MethodFlushing\n+ *     -XX:CompileCommand=compileonly,null::*\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.UsageThresholdIncreasedTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing  -XX:-MethodFlushing\n+ *     -XX:CompileCommand=compileonly,null::*\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.UsageThresholdIncreasedTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/UsageThresholdIncreasedTest.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,23 @@\n+\/*\n+ * @test UsageThresholdNotExceededTest\n+ * @requires vm.compiler2.enabled\n+ * @summary verifying that usage threshold not exceeded while allocating less\n+ *     than usage threshold\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing -XX:-MethodFlushing\n+ *     -XX:CompileCommand=compileonly,null::*\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.UsageThresholdNotExceededTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *     -XX:+WhiteBoxAPI -XX:-UseCodeCacheFlushing -XX:-MethodFlushing\n+ *     -XX:CompileCommand=compileonly,null::*\n+ *     -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *     compiler.codecache.jmx.UsageThresholdNotExceededTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/jmx\/UsageThresholdNotExceededTest.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -46,0 +46,23 @@\n+\/*\n+ * @test RandomAllocationTest\n+ * @key stress randomness\n+ * @requires vm.compiler2.enabled\n+ * @summary stressing code cache by allocating randomly sized \"dummy\" code blobs\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @build jdk.test.whitebox.WhiteBox compiler.codecache.stress.Helper compiler.codecache.stress.TestCaseImpl\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   -XX:CompileCommand=dontinline,compiler.codecache.stress.Helper$TestCase::method\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:+TieredCompilation -XX:TieredStopAtLevel=4\n+ *                   compiler.codecache.stress.RandomAllocationTest\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   -XX:CompileCommand=dontinline,compiler.codecache.stress.Helper$TestCase::method\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M -XX:-TieredCompilation -XX:TieredStopAtLevel=4\n+ *                   compiler.codecache.stress.RandomAllocationTest\n+ *\/\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/stress\/RandomAllocationTest.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -Xbatch -XX:-TieredCompilation -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap\n+ *                   -XX:+NMethodRelocation -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:HotCodeIntervalSeconds=0\n+ *                   -XX:HotCodeSampleSeconds=5 -XX:HotCodeSteadyThreshold=1 -XX:HotCodeSampleRatio=1\n+ *                   compiler.hotcodegrouper.HotCodeGrouperMoveFunction\n+ *\/\n+\n+package compiler.hotcodegrouper;\n+\n+import java.lang.reflect.Method;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.BlobType;\n+import jdk.test.whitebox.code.NMethod;\n+\n+public class HotCodeGrouperMoveFunction {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private static final Method method;\n+    private static final int C2_LEVEL = 4;\n+\n+    static {\n+        try {\n+            method = HotCodeGrouperMoveFunction.class.getMethod(\"func\");\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        WHITE_BOX.testSetDontInlineMethod(method, true);\n+\n+        compileFunc();\n+\n+        \/\/ Function should be in the NonProfiled code heap right after compilation\n+        NMethod orig_nm = NMethod.get(method, false);\n+        Asserts.assertNotEquals(orig_nm, null);\n+        Asserts.assertEQ(orig_nm.code_blob_type, BlobType.MethodNonProfiled);\n+\n+        \/\/ Call function so grouper samples and relocates\n+        func();\n+\n+        \/\/ Function should now be in the Hot code heap after grouper has had time to relocate\n+        NMethod reloc_nm = NMethod.get(method, false);\n+        Asserts.assertNotEquals(reloc_nm, null);\n+        Asserts.assertEQ(reloc_nm.code_blob_type, BlobType.MethodHot);\n+    }\n+\n+    public static void compileFunc() {\n+        WHITE_BOX.enqueueMethodForCompilation(method, C2_LEVEL);\n+\n+        if (WHITE_BOX.getMethodCompilationLevel(method) != C2_LEVEL) {\n+            throw new IllegalStateException(\"Method \" + method + \" is not compiled by C2.\");\n+        }\n+    }\n+\n+    public static void func() {\n+        long start = System.currentTimeMillis();\n+        while (System.currentTimeMillis() - start < 10_000) {}\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/hotcodegrouper\/HotCodeGrouperMoveFunction.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -Xcomp -XX:-TieredCompilation -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap\n+ *                   -XX:+NMethodRelocation -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:HotCodeIntervalSeconds=0\n+ *                   -XX:HotCodeSampleSeconds=10 -XX:HotCodeSteadyThreshold=1 -XX:HotCodeSampleRatio=1\n+ *                   compiler.hotcodegrouper.StressHotCodeGrouper\n+ *\/\n+\n+package compiler.hotcodegrouper;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Random;\n+\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class StressHotCodeGrouper {\n+\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    private static TestMethod[] methods = new TestMethod[100];\n+\n+    private static byte[] num1;\n+    private static byte[] num2;\n+\n+    private static byte[] genNum(Random random, int digitCount) {\n+        byte[] num = new byte[digitCount];\n+        int d;\n+        do {\n+            d = random.nextInt(10);\n+        } while (d == 0);\n+\n+        num[0] = (byte)d;\n+        for (int i = 1; i < digitCount; ++i) {\n+            num[i] = (byte)random.nextInt(10);\n+        }\n+        return num;\n+    }\n+\n+    private static void initNums() {\n+        final long seed = 8374592837465123L;\n+        Random random = new Random(seed);\n+\n+        final int digitCount = 40;\n+        num1 = genNum(random, digitCount);\n+        num2 = genNum(random, digitCount);\n+    }\n+\n+    private static void generateCode() throws Exception {\n+        byte[] result = new byte[num1.length + 1];\n+\n+        for (int i = 0; i < methods.length; i++) {\n+            methods[i] = new TestMethod();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        initNums();\n+        generateCode();\n+\n+        long start = System.currentTimeMillis();\n+        Random random = new Random();\n+\n+        while (System.currentTimeMillis() - start < 60_000) {\n+            for (TestMethod m : methods) {\n+                if (random.nextInt(100) < 10) {\n+                    m.deoptimize();\n+                }\n+\n+                byte[] result = new byte[num1.length + 1];\n+                m.invoke(num1, num2, result);\n+            }\n+        }\n+    }\n+\n+    private static final class TestMethod {\n+        private static final String CLASS_NAME = \"A\";\n+        private static final String METHOD_TO_COMPILE = \"sum\";\n+        private static final String JAVA_CODE = \"\"\"\n+        public class A {\n+\n+            public static void sum(byte[] n1, byte[] n2, byte[] out) {\n+                long start = System.currentTimeMillis();\n+                while (System.currentTimeMillis() - start < 100) {}\n+\n+                final int digitCount = n1.length;\n+                int carry = 0;\n+                for (int i = digitCount - 1; i >= 0; --i) {\n+                    int sum = n1[i] + n2[i] + carry;\n+                    out[i] = (byte)(sum % 10);\n+                    carry = sum \/ 10;\n+                }\n+                if (carry != 0) {\n+                    for (int i = digitCount; i > 0; --i) {\n+                        out[i] = out[i - 1];\n+                    }\n+                    out[0] = (byte)carry;\n+                }\n+            }\n+        }\"\"\";\n+\n+        private static final byte[] BYTE_CODE;\n+\n+        static {\n+            BYTE_CODE = InMemoryJavaCompiler.compile(CLASS_NAME, JAVA_CODE);\n+        }\n+\n+        private final Method method;\n+\n+        private static ClassLoader createClassLoaderFor() {\n+            return new ClassLoader() {\n+                @Override\n+                public Class<?> loadClass(String name) throws ClassNotFoundException {\n+                    if (!name.equals(CLASS_NAME)) {\n+                        return super.loadClass(name);\n+                    }\n+\n+                    return defineClass(name, BYTE_CODE, 0, BYTE_CODE.length);\n+                }\n+            };\n+        }\n+\n+        public TestMethod() throws Exception {\n+            var cl = createClassLoaderFor().loadClass(CLASS_NAME);\n+            method = cl.getMethod(METHOD_TO_COMPILE, byte[].class, byte[].class, byte[].class);\n+            WHITE_BOX.testSetDontInlineMethod(method, true);\n+        }\n+\n+        public void invoke(byte[] num1, byte[] num2, byte[] result) throws Exception {\n+            method.invoke(null, num1, num2, result);\n+        }\n+\n+        public void deoptimize() {\n+            WHITE_BOX.deoptimizeMethod(method);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/hotcodegrouper\/StressHotCodeGrouper.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -53,0 +53,6 @@\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:+TieredCompilation -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M jdk.jfr.event.compiler.TestCodeCacheFull\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-TieredCompilation -XX:+UnlockExperimentalVMOptions -XX:+HotCodeHeap -XX:HotCodeHeapSize=8M jdk.jfr.event.compiler.TestCodeCacheFull\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCodeCacheFull.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,0 +49,8 @@\n+    MethodHot(2, \"CodeHeap 'hot nmethods'\", \"HotCodeHeapSize\") {\n+        @Override\n+        public boolean allowTypeWhenOverflow(BlobType type) {\n+            return super.allowTypeWhenOverflow(type)\n+                    || type == BlobType.MethodNonProfiled\n+                    || type == BlobType.MethodProfiled;\n+        }\n+    },\n@@ -50,1 +58,1 @@\n-    NonNMethod(2, \"CodeHeap 'non-nmethods'\", \"NonNMethodCodeHeapSize\") {\n+    NonNMethod(3, \"CodeHeap 'non-nmethods'\", \"NonNMethodCodeHeapSize\") {\n@@ -59,1 +67,1 @@\n-    All(3, \"CodeCache\", \"ReservedCodeCacheSize\");\n+    All(4, \"CodeCache\", \"ReservedCodeCacheSize\");\n@@ -102,0 +110,4 @@\n+\n+        if (Long.valueOf(0).equals(whiteBox.getVMFlag(\"HotCodeHeapSize\"))) {\n+            result.remove(MethodHot);\n+        }\n","filename":"test\/lib\/jdk\/test\/whitebox\/code\/BlobType.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"}]}