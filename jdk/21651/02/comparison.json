{"files":[{"patch":"@@ -3362,0 +3362,10 @@\n+        @Override\n+        public Type visitUndetVar(UndetVar t, Void unused) {\n+            for (List<Type> from = this.from, to = this.to; from.nonEmpty(); from = from.tail, to = to.tail) {\n+                if (t.equalsIgnoreMetadata(from.head)) {\n+                    return to.head;\n+                }\n+            }\n+            return t;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -804,2 +804,2 @@\n-        boolean isSubtype(Type s, Type t, Warner warn) {\n-            return doIncorporationOp(IncorporationBinaryOpKind.IS_SUBTYPE, s, t, warn);\n+        boolean isSubtype(Type s, Type t, Warner warn, InferenceContext ic) {\n+            return doIncorporationOp(IncorporationBinaryOpKind.IS_SUBTYPE, s, t, warn, ic);\n@@ -811,2 +811,2 @@\n-        boolean isSameType(Type s, Type t) {\n-            return doIncorporationOp(IncorporationBinaryOpKind.IS_SAME_TYPE, s, t, null);\n+        boolean isSameType(Type s, Type t, InferenceContext ic) {\n+            return doIncorporationOp(IncorporationBinaryOpKind.IS_SAME_TYPE, s, t, null, ic);\n@@ -856,1 +856,1 @@\n-                    boolean success = checkBound(t, b, from, to, warn);\n+                    boolean success = checkBound(t, b, from, to, warn, inferenceContext);\n@@ -876,1 +876,1 @@\n-        boolean checkBound(Type s, Type t, InferenceBound ib_s, InferenceBound ib_t, Warner warn) {\n+        boolean checkBound(Type s, Type t, InferenceBound ib_s, InferenceBound ib_t, Warner warn, InferenceContext ic) {\n@@ -878,1 +878,1 @@\n-                return isSubtype(s, t, warn);\n+                return isSubtype(s, t, warn, ic);\n@@ -880,1 +880,1 @@\n-                return isSubtype(t, s, warn);\n+                return isSubtype(t, s, warn, ic);\n@@ -882,1 +882,1 @@\n-                return isSameType(s, t);\n+                return isSameType(s, t, ic);\n@@ -1013,1 +1013,1 @@\n-                                        inferenceContext.asUndetVar(allParamsSuperBound2.head))) {\n+                                        inferenceContext.asUndetVar(allParamsSuperBound2.head), inferenceContext)) {\n@@ -1197,2 +1197,2 @@\n-    boolean doIncorporationOp(IncorporationBinaryOpKind opKind, Type op1, Type op2, Warner warn) {\n-            IncorporationBinaryOp newOp = new IncorporationBinaryOp(opKind, op1, op2);\n+    boolean doIncorporationOp(IncorporationBinaryOpKind opKind, Type op1, Type op2, Warner warn, InferenceContext ic) {\n+            IncorporationBinaryOp newOp = new IncorporationBinaryOp(opKind, op1, op2, ic);\n@@ -1240,0 +1240,1 @@\n+        InferenceContext ic;\n@@ -1241,1 +1242,1 @@\n-        IncorporationBinaryOp(IncorporationBinaryOpKind opKind, Type op1, Type op2) {\n+        IncorporationBinaryOp(IncorporationBinaryOpKind opKind, Type op1, Type op2, InferenceContext ic) {\n@@ -1245,0 +1246,1 @@\n+            this.ic = ic;\n@@ -1251,2 +1253,2 @@\n-                    && types.isSameType(op1, incorporationBinaryOp.op1)\n-                    && types.isSameType(op2, incorporationBinaryOp.op2);\n+                    && types.isSameType(undetVarToTVar(op1), undetVarToTVar(incorporationBinaryOp.op1))\n+                    && types.isSameType(undetVarToTVar(op2), undetVarToTVar(incorporationBinaryOp.op2));\n@@ -1259,1 +1261,1 @@\n-            result += types.hashCode(op1);\n+            result += types.hashCode(undetVarToTVar(op1));\n@@ -1261,1 +1263,1 @@\n-            result += types.hashCode(op2);\n+            result += types.hashCode(undetVarToTVar(op2));\n@@ -1265,0 +1267,12 @@\n+        \/**\n+         * This method will map all occurrences of undetermined variables in a given type to its corresponding inference\n+         * variable. This is done to avoid that while doing a \"is same type\" comparison with another type, an\n+         * undetermined variable can be modified, by adding a bound to it, making it different to what it was before\n+         * the comparison.\n+         * @param t type for which undetermined variables will be mapped to the corresponding inference variable\n+         * @return a type with no undetermined variables\n+         *\/\n+        Type undetVarToTVar(Type t) {\n+            return types.subst(t, ic.undetvars, ic.inferencevars);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":31,"deletions":17,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8342090 8288590\n+ * @summary Infer::IncorporationBinaryOp::equals can produce side-effects\n+ * @compile NonDeterminismTest.java\n+ * @compile -J-XX:+UnlockExperimentalVMOptions -J-XX:hashCode=2 NonDeterminismTest.java\n+ *\/\n+\n+import java.util.*;\n+import java.lang.foreign.*;\n+import static java.lang.foreign.ValueLayout.*;\n+\n+import static java.util.Arrays.asList;\n+\n+class NonDeterminismTest {\n+    void test1() {\n+        Map<String, MemoryLayout> CANONICAL_LAYOUTS = Map.ofEntries(\n+                \/\/ specified canonical layouts\n+                Map.entry(\"bool\", JAVA_BOOLEAN),\n+                Map.entry(\"char\", JAVA_BYTE),\n+                Map.entry(\"float\", JAVA_FLOAT),\n+                Map.entry(\"long long\", JAVA_LONG),\n+                Map.entry(\"double\", JAVA_DOUBLE),\n+                Map.entry(\"void*\", ADDRESS),\n+                \/\/ JNI types\n+                Map.entry(\"jboolean\", JAVA_BOOLEAN),\n+                Map.entry(\"jchar\", JAVA_CHAR),\n+                Map.entry(\"jbyte\", JAVA_BYTE),\n+                Map.entry(\"jshort\", JAVA_SHORT),\n+                Map.entry(\"jint\", JAVA_INT),\n+                Map.entry(\"jlong\", JAVA_LONG),\n+                Map.entry(\"jfloat\", JAVA_FLOAT),\n+                Map.entry(\"jdouble\", JAVA_DOUBLE)\n+        );\n+    }\n+\n+    class Test2 {\n+        interface I1<T1> {}\n+        interface I2<T1, T2> {}\n+\n+        record R1<T1>(List<T1> T1) implements I1<T1> {}\n+        record R2<T1, T2>(List<T1> T1, List<T2> T2) implements I2<T1, T2> {}\n+\n+        <T1> I1<T1> m1(T1 T1) {\n+            return new R1<>(asList(T1));\n+        }\n+        <T1, T2> I2<T1, T2> m2(T1 T1, T2 T2) {\n+            return new R2<>(asList(T1), asList(T2));\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/inference_non_determinism\/NonDeterminismTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}