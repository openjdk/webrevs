{"files":[{"patch":"@@ -3331,0 +3331,4 @@\n+    \/* this class won't substitute all types for example UndetVars are never substituted, this is\n+     * by design as UndetVars are used locally during inference and shouldn't escape from inference routines,\n+     * some specialized applications could need a tailored solution\n+     *\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -804,2 +804,2 @@\n-        boolean isSubtype(Type s, Type t, Warner warn) {\n-            return doIncorporationOp(IncorporationBinaryOpKind.IS_SUBTYPE, s, t, warn);\n+        boolean isSubtype(Type s, Type t, Warner warn, InferenceContext ic) {\n+            return doIncorporationOp(IncorporationBinaryOpKind.IS_SUBTYPE, s, t, warn, ic);\n@@ -811,2 +811,2 @@\n-        boolean isSameType(Type s, Type t) {\n-            return doIncorporationOp(IncorporationBinaryOpKind.IS_SAME_TYPE, s, t, null);\n+        boolean isSameType(Type s, Type t, InferenceContext ic) {\n+            return doIncorporationOp(IncorporationBinaryOpKind.IS_SAME_TYPE, s, t, null, ic);\n@@ -856,1 +856,1 @@\n-                    boolean success = checkBound(t, b, from, to, warn);\n+                    boolean success = checkBound(t, b, from, to, warn, inferenceContext);\n@@ -876,1 +876,1 @@\n-        boolean checkBound(Type s, Type t, InferenceBound ib_s, InferenceBound ib_t, Warner warn) {\n+        boolean checkBound(Type s, Type t, InferenceBound ib_s, InferenceBound ib_t, Warner warn, InferenceContext ic) {\n@@ -878,1 +878,1 @@\n-                return isSubtype(s, t, warn);\n+                return isSubtype(s, t, warn, ic);\n@@ -880,1 +880,1 @@\n-                return isSubtype(t, s, warn);\n+                return isSubtype(t, s, warn, ic);\n@@ -882,1 +882,1 @@\n-                return isSameType(s, t);\n+                return isSameType(s, t, ic);\n@@ -1013,1 +1013,1 @@\n-                                        inferenceContext.asUndetVar(allParamsSuperBound2.head))) {\n+                                        inferenceContext.asUndetVar(allParamsSuperBound2.head), inferenceContext)) {\n@@ -1197,2 +1197,2 @@\n-    boolean doIncorporationOp(IncorporationBinaryOpKind opKind, Type op1, Type op2, Warner warn) {\n-            IncorporationBinaryOp newOp = new IncorporationBinaryOp(opKind, op1, op2);\n+    boolean doIncorporationOp(IncorporationBinaryOpKind opKind, Type op1, Type op2, Warner warn, InferenceContext ic) {\n+            IncorporationBinaryOpKey newOp = new IncorporationBinaryOpKey(opKind, ic.asTypeVar(op1), ic.asTypeVar(op2), types);\n@@ -1201,1 +1201,1 @@\n-                incorporationCache.put(newOp, res = newOp.apply(warn));\n+                incorporationCache.put(newOp, res = opKind.apply(op1, op2, warn, types));\n@@ -1235,12 +1235,1 @@\n-    class IncorporationBinaryOp {\n-\n-        IncorporationBinaryOpKind opKind;\n-        Type op1;\n-        Type op2;\n-\n-        IncorporationBinaryOp(IncorporationBinaryOpKind opKind, Type op1, Type op2) {\n-            this.opKind = opKind;\n-            this.op1 = op1;\n-            this.op2 = op2;\n-        }\n-\n+    record IncorporationBinaryOpKey(IncorporationBinaryOpKind opKind, Type op1, Type op2, Types types) {\n@@ -1249,4 +1238,4 @@\n-            return (o instanceof IncorporationBinaryOp incorporationBinaryOp)\n-                    && opKind == incorporationBinaryOp.opKind\n-                    && types.isSameType(op1, incorporationBinaryOp.op1)\n-                    && types.isSameType(op2, incorporationBinaryOp.op2);\n+            return (o instanceof IncorporationBinaryOpKey anotherKey)\n+                    && opKind == anotherKey.opKind\n+                    && types.isSameType(op1, anotherKey.op1)\n+                    && types.isSameType(op2, anotherKey.op2);\n@@ -1254,1 +1243,0 @@\n-\n@@ -1264,4 +1252,0 @@\n-\n-        boolean apply(Warner warn) {\n-            return opKind.apply(op1, op2, warn, types);\n-        }\n@@ -1271,1 +1255,1 @@\n-    Map<IncorporationBinaryOp, Boolean> incorporationCache = new LinkedHashMap<>();\n+    Map<IncorporationBinaryOpKey, Boolean> incorporationCache = new LinkedHashMap<>();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":19,"deletions":35,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -217,0 +217,14 @@\n+    \/**\n+     * Replace all undet vars in a given type with corresponding free variables\n+     *\/\n+    public final Type asTypeVar(Type t) {\n+        return asTypeVarFun.apply(t);\n+    }\n+\n+    Types.TypeMapping<Void> asTypeVarFun = new Type.StructuralTypeMapping<>() {\n+        @Override\n+        public Type visitUndetVar(UndetVar uv, Void aVoid) {\n+            return uv.qtype;\n+        }\n+    };\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/InferenceContext.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8342090 8288590\n+ * @summary Infer::IncorporationBinaryOp::equals can produce side-effects\n+ * @compile NonDeterminismTest.java\n+ * @compile -J-XX:+UnlockExperimentalVMOptions -J-XX:hashCode=2 NonDeterminismTest.java\n+ *\/\n+\n+import java.util.*;\n+import java.lang.foreign.*;\n+import static java.lang.foreign.ValueLayout.*;\n+\n+import static java.util.Arrays.asList;\n+\n+class NonDeterminismTest {\n+    void test1() {\n+        Map<String, MemoryLayout> CANONICAL_LAYOUTS = Map.ofEntries(\n+                \/\/ specified canonical layouts\n+                Map.entry(\"bool\", JAVA_BOOLEAN),\n+                Map.entry(\"char\", JAVA_BYTE),\n+                Map.entry(\"float\", JAVA_FLOAT),\n+                Map.entry(\"long long\", JAVA_LONG),\n+                Map.entry(\"double\", JAVA_DOUBLE),\n+                Map.entry(\"void*\", ADDRESS),\n+                \/\/ JNI types\n+                Map.entry(\"jboolean\", JAVA_BOOLEAN),\n+                Map.entry(\"jchar\", JAVA_CHAR),\n+                Map.entry(\"jbyte\", JAVA_BYTE),\n+                Map.entry(\"jshort\", JAVA_SHORT),\n+                Map.entry(\"jint\", JAVA_INT),\n+                Map.entry(\"jlong\", JAVA_LONG),\n+                Map.entry(\"jfloat\", JAVA_FLOAT),\n+                Map.entry(\"jdouble\", JAVA_DOUBLE)\n+        );\n+    }\n+\n+    class Test2 {\n+        interface I1<T1> {}\n+        interface I2<T1, T2> {}\n+\n+        record R1<T1>(List<T1> T1) implements I1<T1> {}\n+        record R2<T1, T2>(List<T1> T1, List<T2> T2) implements I2<T1, T2> {}\n+\n+        <T1> I1<T1> m1(T1 T1) {\n+            return new R1<>(asList(T1));\n+        }\n+        <T1, T2> I2<T1, T2> m2(T1 T1, T2 T2) {\n+            return new R2<>(asList(T1), asList(T2));\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/inference_non_determinism\/NonDeterminismTest.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}