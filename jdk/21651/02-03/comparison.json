{"files":[{"patch":"@@ -1198,1 +1198,1 @@\n-            IncorporationBinaryOp newOp = new IncorporationBinaryOp(opKind, op1, op2, ic);\n+            IncorporationBinaryOpKey newOp = new IncorporationBinaryOpKey(opKind, new TypeOperands(ic.asTVar(op1), ic.asTVar(op2), types));\n@@ -1201,1 +1201,1 @@\n-                incorporationCache.put(newOp, res = newOp.apply(warn));\n+                incorporationCache.put(newOp, res = opKind.apply(op1, op2, warn, types));\n@@ -1235,13 +1235,1 @@\n-    class IncorporationBinaryOp {\n-\n-        IncorporationBinaryOpKind opKind;\n-        Type op1;\n-        Type op2;\n-        InferenceContext ic;\n-\n-        IncorporationBinaryOp(IncorporationBinaryOpKind opKind, Type op1, Type op2, InferenceContext ic) {\n-            this.opKind = opKind;\n-            this.op1 = op1;\n-            this.op2 = op2;\n-            this.ic = ic;\n-        }\n+    record IncorporationBinaryOpKey(IncorporationBinaryOpKind opKind, TypeOperands typeOperands) {}\n@@ -1249,0 +1237,1 @@\n+    record TypeOperands(Type op1, Type op2, Types types) {\n@@ -1251,30 +1240,3 @@\n-            return (o instanceof IncorporationBinaryOp incorporationBinaryOp)\n-                    && opKind == incorporationBinaryOp.opKind\n-                    && types.isSameType(undetVarToTVar(op1), undetVarToTVar(incorporationBinaryOp.op1))\n-                    && types.isSameType(undetVarToTVar(op2), undetVarToTVar(incorporationBinaryOp.op2));\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            int result = opKind.hashCode();\n-            result *= 127;\n-            result += types.hashCode(undetVarToTVar(op1));\n-            result *= 127;\n-            result += types.hashCode(undetVarToTVar(op2));\n-            return result;\n-        }\n-\n-        \/**\n-         * This method will map all occurrences of undetermined variables in a given type to its corresponding inference\n-         * variable. This is done to avoid that while doing a \"is same type\" comparison with another type, an\n-         * undetermined variable can be modified, by adding a bound to it, making it different to what it was before\n-         * the comparison.\n-         * @param t type for which undetermined variables will be mapped to the corresponding inference variable\n-         * @return a type with no undetermined variables\n-         *\/\n-        Type undetVarToTVar(Type t) {\n-            return types.subst(t, ic.undetvars, ic.inferencevars);\n-        }\n-\n-        boolean apply(Warner warn) {\n-            return opKind.apply(op1, op2, warn, types);\n+            return (o instanceof TypeOperands typeOperands)\n+                    && types.isSameType(op1, typeOperands.op1)\n+                    && types.isSameType(op2, typeOperands.op2);\n@@ -1285,1 +1247,1 @@\n-    Map<IncorporationBinaryOp, Boolean> incorporationCache = new LinkedHashMap<>();\n+    Map<IncorporationBinaryOpKey, Boolean> incorporationCache = new LinkedHashMap<>();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Infer.java","additions":8,"deletions":46,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -217,0 +217,7 @@\n+    \/**\n+     * Replace all undet vars in a given type with corresponding free variables\n+     *\/\n+    public final Type asTVar(Type t) {\n+        return types.subst(t, undetvars, inferencevars);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/InferenceContext.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-T7177306e.java:16:8: compiler.err.cant.apply.symbol: kindname.method, m, java.util.List<U>, java.util.List<java.util.List<?>>, kindname.class, T7177306e, (compiler.misc.inferred.do.not.conform.to.eq.bounds: java.lang.Object, compiler.misc.type.captureof: 1, ?)\n+T7177306e.java:16:8: compiler.err.cant.apply.symbol: kindname.method, m, java.util.List<U>, java.util.List<java.util.List<?>>, kindname.class, T7177306e, (compiler.misc.incompatible.eq.bounds: Z, compiler.misc.type.captureof: 1, ?,compiler.misc.type.captureof: 2, ?)\n","filename":"test\/langtools\/tools\/javac\/generics\/inference\/7177306\/T7177306e.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}