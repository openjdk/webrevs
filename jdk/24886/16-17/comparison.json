{"files":[{"patch":"@@ -459,1 +459,1 @@\n-  uint64_t uimm = (uint64_t)uabs((jlong)imm);\n+  uint64_t uimm = (uint64_t)g_uabs((jlong)imm);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -935,1 +935,1 @@\n-    return uabs(target - branch) < branch_range;\n+    return g_uabs(target - branch) < branch_range;\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3280,1 +3280,1 @@\n-    if (uabs(imm) < (1 << 24)) {\n+    if (g_uabs(imm) < (1 << 24)) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  do_arch_blob(final, 20000 ZGC_ONLY(+60000))                           \\\n+  do_arch_blob(final, 20000 ZGC_ONLY(+85000))                           \\\n","filename":"src\/hotspot\/cpu\/aarch64\/stubDeclarations_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1165,1 +1165,1 @@\n-    size_t granularity = uabs(step);\n+    size_t granularity = g_uabs(step);\n@@ -1224,1 +1224,1 @@\n-    unsigned int granularity = uabs(step);\n+    unsigned int granularity = g_uabs(step);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2519,1 +2519,1 @@\n-\/\/ 2. 'CompressibleRegion' and 'IncompressibleRegion' are introduced to mark assembler scopes\n+\/\/ 2. 'CompressibleScope' and 'IncompressibleScope' are introduced to mark assembler scopes\n@@ -2523,1 +2523,1 @@\n-\/\/      CompressibleRegion cr(_masm);\n+\/\/      CompressibleScope scope(_masm);\n@@ -2526,1 +2526,1 @@\n-\/\/         IncompressibleRegion ir(_masm);\n+\/\/         IncompressibleScope scope(_masm);\n@@ -2529,1 +2529,1 @@\n-\/\/            CompressibleRegion cr(_masm);\n+\/\/            CompressibleScope scope(_masm);\n@@ -2538,1 +2538,1 @@\n-  bool _in_compressible_region;\n+  bool _in_compressible_scope;\n@@ -2540,2 +2540,2 @@\n-  bool in_compressible_region() const { return _in_compressible_region; }\n-  void set_in_compressible_region(bool b) { _in_compressible_region = b; }\n+  bool in_compressible_scope() const { return _in_compressible_scope; }\n+  void set_in_compressible_scope(bool b) { _in_compressible_scope = b; }\n@@ -2544,2 +2544,2 @@\n-  \/\/ an abstract compressible region\n-  class AbstractCompressibleRegion : public StackObj {\n+  \/\/ An abstract compressible scope\n+  class AbstractCompressibleScope : public StackObj {\n@@ -2548,1 +2548,1 @@\n-    bool _saved_in_compressible_region;\n+    bool _saved_in_compressible_scope;\n@@ -2550,1 +2550,1 @@\n-    AbstractCompressibleRegion(Assembler *_masm)\n+    AbstractCompressibleScope(Assembler *_masm)\n@@ -2552,1 +2552,1 @@\n-    , _saved_in_compressible_region(_masm->in_compressible_region()) {}\n+    , _saved_in_compressible_scope(_masm->in_compressible_scope()) {}\n@@ -2554,2 +2554,2 @@\n-  \/\/ a compressible region\n-  class CompressibleRegion : public AbstractCompressibleRegion {\n+  \/\/ A compressible scope\n+  class CompressibleScope : public AbstractCompressibleScope {\n@@ -2557,2 +2557,2 @@\n-    CompressibleRegion(Assembler *_masm) : AbstractCompressibleRegion(_masm) {\n-      _masm->set_in_compressible_region(true);\n+    CompressibleScope(Assembler *_masm) : AbstractCompressibleScope(_masm) {\n+      _masm->set_in_compressible_scope(true);\n@@ -2560,2 +2560,2 @@\n-    ~CompressibleRegion() {\n-      _masm->set_in_compressible_region(_saved_in_compressible_region);\n+    ~CompressibleScope() {\n+      _masm->set_in_compressible_scope(_saved_in_compressible_scope);\n@@ -2564,2 +2564,2 @@\n-  \/\/ an incompressible region\n-  class IncompressibleRegion : public AbstractCompressibleRegion {\n+  \/\/ An incompressible scope\n+  class IncompressibleScope : public AbstractCompressibleScope {\n@@ -2567,2 +2567,2 @@\n-    IncompressibleRegion(Assembler *_masm) : AbstractCompressibleRegion(_masm) {\n-      _masm->set_in_compressible_region(false);\n+    IncompressibleScope(Assembler *_masm) : AbstractCompressibleScope(_masm) {\n+      _masm->set_in_compressible_scope(false);\n@@ -2570,2 +2570,2 @@\n-    ~IncompressibleRegion() {\n-      _masm->set_in_compressible_region(_saved_in_compressible_region);\n+    ~IncompressibleScope() {\n+      _masm->set_in_compressible_scope(_saved_in_compressible_scope);\n@@ -2586,1 +2586,1 @@\n-    IncompressibleRegion ir(this);  \/\/ relocations\n+    IncompressibleScope scope(this); \/\/ relocations\n@@ -2592,1 +2592,1 @@\n-    IncompressibleRegion ir(this);  \/\/ relocations\n+    IncompressibleScope scope(this); \/\/ relocations\n@@ -3173,1 +3173,1 @@\n-    return UseRVC && in_compressible_region();\n+    return UseRVC && in_compressible_scope();\n@@ -3827,1 +3827,1 @@\n-    return uabs(target - branch) < branch_range;\n+    return g_uabs(target - branch) < branch_range;\n@@ -3841,1 +3841,1 @@\n-  Assembler(CodeBuffer* code) : AbstractAssembler(code), _in_compressible_region(true) {}\n+  Assembler(CodeBuffer* code) : AbstractAssembler(code), _in_compressible_scope(true) {}\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -352,1 +352,1 @@\n-  IncompressibleRegion ir(this);  \/\/ keep the nop as 4 bytes for patching.\n+  IncompressibleScope scope(this); \/\/ keep the nop as 4 bytes for patching.\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-  Assembler::IncompressibleRegion ir(masm);  \/\/ Fixed length: see entry_barrier_offset()\n+  Assembler::IncompressibleScope scope(masm); \/\/ Fixed length: see entry_barrier_offset()\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -259,1 +259,1 @@\n-  CompressibleRegion cr(this);\n+  CompressibleScope scope(this);\n@@ -420,1 +420,1 @@\n-    IncompressibleRegion ir(this);  \/\/ the label address will be patched back.\n+    IncompressibleScope scope(this); \/\/ the label address will be patched back.\n@@ -567,1 +567,1 @@\n-    IncompressibleRegion ir(this);  \/\/ Fixed length\n+    IncompressibleScope scope(this); \/\/ Fixed length\n@@ -607,1 +607,1 @@\n-    IncompressibleRegion ir(this);  \/\/ Fixed length\n+    IncompressibleScope scope(this); \/\/ Fixed length\n@@ -778,1 +778,1 @@\n-  IncompressibleRegion ir(this);  \/\/ Fixed length: see CompiledDirectCall::to_interp_stub_size().\n+  IncompressibleScope scope(this); \/\/ Fixed length: see CompiledDirectCall::to_interp_stub_size().\n@@ -910,1 +910,1 @@\n-  IncompressibleRegion ir(this);   \/\/ the label address may be patched back.\n+  IncompressibleScope scope(this); \/\/ the label address may be patched back.\n@@ -974,1 +974,1 @@\n-  IncompressibleRegion ir(this);\n+  IncompressibleScope scope(this);\n@@ -4980,1 +4980,1 @@\n-  IncompressibleRegion ir(this);  \/\/ relocations\n+  IncompressibleScope scope(this); \/\/ relocations\n@@ -4993,1 +4993,1 @@\n-  IncompressibleRegion ir(this);\n+  IncompressibleScope scope(this);\n@@ -5906,1 +5906,0 @@\n-  \/\/ align 8, so first sd n % 8 = mod, next loop sd 8 * n.\n@@ -5909,1 +5908,1 @@\n-  slli(t0, t0, 2); \/\/ sd_inst_nums * 4; t0 is cnt % 8, so t1 = t1 - sd_inst_nums * 4, 4 is sizeof(inst)\n+  slli(t0, t0, 2);\n@@ -5915,2 +5914,5 @@\n-  for (int i = -unroll; i < 0; i++) {\n-    sd(value, Address(base, i * 8));\n+  {\n+    IncompressibleScope scope(this); \/\/ Fixed length\n+    for (int i = -unroll; i < 0; i++) {\n+      sd(value, Address(base, i * 8));\n+    }\n@@ -6123,0 +6125,1 @@\n+\n@@ -6125,2 +6128,5 @@\n-  for (int i = -unroll; i < 0; i++) {\n-    sd(zr, Address(tmp, i * wordSize));\n+  {\n+    IncompressibleScope scope(this); \/\/ Fixed length\n+    for (int i = -unroll; i < 0; i++) {\n+      sd(zr, Address(tmp, i * wordSize));\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -752,1 +752,1 @@\n-    IncompressibleRegion ir(this);  \/* relocations *\/\n+    IncompressibleScope scope(this);  \/* relocations *\/\n@@ -973,1 +973,1 @@\n-    IncompressibleRegion ir(this);  \/* relocations *\/\n+    IncompressibleScope scope(this);  \/* relocations *\/\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -482,1 +482,1 @@\n-  Assembler::IncompressibleRegion ir(&a);  \/\/ Fixed length: see NativeGeneralJump::get_instruction_size()\n+  Assembler::IncompressibleScope scope(&a); \/\/ Fixed length: see NativeGeneralJump::get_instruction_size()\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1298,1 +1298,1 @@\n-    Assembler::CompressibleRegion cr(masm); \/\/ nops shall be 2-byte under RVC for alignment purposes.\n+    Assembler::CompressibleScope scope(masm); \/\/ nops shall be 2-byte under RVC for alignment purposes.\n@@ -1374,1 +1374,1 @@\n-    Assembler::IncompressibleRegion ir(masm);  \/\/ keep the nop as 4 bytes for patching.\n+    Assembler::IncompressibleScope scope(masm); \/\/ keep the nop as 4 bytes for patching.\n@@ -1757,1 +1757,1 @@\n-  Assembler::IncompressibleRegion ir(masm);  \/\/ Fixed length: see BoxLockNode::size()\n+  Assembler::IncompressibleScope scope(masm); \/\/ Fixed length: see BoxLockNode::size()\n@@ -2407,1 +2407,1 @@\n-    Assembler::IncompressibleRegion ir(masm);  \/\/ Fixed length: see ret_addr_offset\n+    Assembler::IncompressibleScope scope(masm); \/\/ Fixed length: see ret_addr_offset\n@@ -2454,1 +2454,1 @@\n-    Assembler::IncompressibleRegion ir(masm);  \/\/ Fixed length: see ret_addr_offset\n+    Assembler::IncompressibleScope scope(masm); \/\/ Fixed length: see ret_addr_offset\n@@ -2473,1 +2473,1 @@\n-    Assembler::IncompressibleRegion ir(masm);  \/\/ Fixed length: see ret_addr_offset\n+    Assembler::IncompressibleScope scope(masm); \/\/ Fixed length: see ret_addr_offset\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1328,1 +1328,1 @@\n-      Assembler::IncompressibleRegion ir(masm);  \/\/ keep the nop as 4 bytes for patching.\n+      Assembler::IncompressibleScope scope(masm); \/\/ keep the nop as 4 bytes for patching.\n@@ -1471,1 +1471,1 @@\n-    Assembler::IncompressibleRegion ir(masm);  \/\/ keep the nop as 4 bytes for patching.\n+    Assembler::IncompressibleScope scope(masm); \/\/ keep the nop as 4 bytes for patching.\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -889,1 +889,1 @@\n-    int granularity = uabs(step);\n+    int granularity = g_uabs(step);\n@@ -951,1 +951,1 @@\n-    int granularity = uabs(step);\n+    int granularity = g_uabs(step);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1514,1 +1514,1 @@\n-    align(32);\n+    align(CodeEntryAlignment);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_sha.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1447,1 +1447,1 @@\n-  if (profiled_method != nullptr) {\n+  if (profiled_method != nullptr && TypeProfileCasts) {\n@@ -1457,1 +1457,1 @@\n-  if (profiled_method != nullptr) {\n+  if (profiled_method != nullptr && TypeProfileCasts) {\n@@ -1469,1 +1469,1 @@\n-  if (profiled_method != nullptr) {\n+  if (profiled_method != nullptr && TypeProfileCasts) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -235,0 +235,2 @@\n+  _type_profile_args_limit = TypeProfileArgsLimit;\n+  _type_profile_parms_limit = TypeProfileParmsLimit;\n@@ -238,0 +240,1 @@\n+  _type_profile_casts = TypeProfileCasts;\n@@ -1924,3 +1927,3 @@\n-      log_info(cds)(\"The %s's TypeProfileLevel setting (%d)\"\n-                    \" does not equal the current TypeProfileLevel setting (%d).\", file_type,\n-                    _type_profile_level, TypeProfileLevel);\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileLevel setting (%d)\"\n+                                            \" does not equal the current TypeProfileLevel setting (%d).\", file_type,\n+                                            _type_profile_level, TypeProfileLevel);\n@@ -1929,0 +1932,13 @@\n+    if (_type_profile_args_limit != TypeProfileArgsLimit) {\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileArgsLimit setting (%d)\"\n+                                            \" does not equal the current TypeProfileArgsLimit setting (%d).\", file_type,\n+                                            _type_profile_args_limit, TypeProfileArgsLimit);\n+      return false;\n+    }\n+    if (_type_profile_parms_limit != TypeProfileParmsLimit) {\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileParamsLimit setting (%d)\"\n+                                            \" does not equal the current TypeProfileParamsLimit setting (%d).\", file_type,\n+                                            _type_profile_args_limit, TypeProfileArgsLimit);\n+      return false;\n+\n+    }\n@@ -1930,3 +1946,3 @@\n-      log_info(cds)(\"The %s's TypeProfileWidth setting (%d)\"\n-                    \" does not equal the current TypeProfileWidth setting (%d).\", file_type,\n-                    (int)_type_profile_width, (int)TypeProfileWidth);\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileWidth setting (%d)\"\n+                                            \" does not equal the current TypeProfileWidth setting (%d).\", file_type,\n+                                            (int)_type_profile_width, (int)TypeProfileWidth);\n@@ -1937,3 +1953,3 @@\n-      log_info(cds)(\"The %s's BciProfileWidth setting (%d)\"\n-                    \" does not equal the current BciProfileWidth setting (%d).\", file_type,\n-                    (int)_bci_profile_width, (int)BciProfileWidth);\n+      MetaspaceShared::report_loading_error(\"The %s's BciProfileWidth setting (%d)\"\n+                                            \" does not equal the current BciProfileWidth setting (%d).\", file_type,\n+                                            (int)_bci_profile_width, (int)BciProfileWidth);\n@@ -1942,0 +1958,9 @@\n+    if (_type_profile_casts != TypeProfileCasts) {\n+      MetaspaceShared::report_loading_error(\"The %s's TypeProfileCasts setting (%s)\"\n+                                            \" does not equal the current TypeProfileCasts setting (%s).\", file_type,\n+                                            _type_profile_casts ? \"enabled\" : \"disabled\",\n+                                            TypeProfileCasts    ? \"enabled\" : \"disabled\");\n+\n+      return false;\n+\n+    }\n@@ -1943,4 +1968,4 @@\n-      log_info(cds)(\"The %s's ProfileTraps setting (%s)\"\n-                    \" does not equal the current ProfileTraps setting (%s).\", file_type,\n-                    _profile_traps ? \"enabled\" : \"disabled\",\n-                    ProfileTraps   ? \"enabled\" : \"disabled\");\n+      MetaspaceShared::report_loading_error(\"The %s's ProfileTraps setting (%s)\"\n+                                            \" does not equal the current ProfileTraps setting (%s).\", file_type,\n+                                            _profile_traps ? \"enabled\" : \"disabled\",\n+                                            ProfileTraps   ? \"enabled\" : \"disabled\");\n@@ -1951,3 +1976,3 @@\n-      log_info(cds)(\"The %s's SpecTrapLimitExtraEntries setting (%d)\"\n-                    \" does not equal the current SpecTrapLimitExtraEntries setting (%d).\", file_type,\n-                    _spec_trap_limit_extra_entries, SpecTrapLimitExtraEntries);\n+      MetaspaceShared::report_loading_error(\"The %s's SpecTrapLimitExtraEntries setting (%d)\"\n+                                            \" does not equal the current SpecTrapLimitExtraEntries setting (%d).\", file_type,\n+                                            _spec_trap_limit_extra_entries, SpecTrapLimitExtraEntries);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -151,0 +151,2 @@\n+  int     _type_profile_args_limit;\n+  int     _type_profile_parms_limit;\n@@ -154,0 +156,1 @@\n+  bool    _type_profile_casts;\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -809,1 +809,1 @@\n-                                  methodHandle(), 0, CompileTask::Reason_Replay, THREAD);\n+                                  0, CompileTask::Reason_Replay, THREAD);\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,0 +92,5 @@\n+#if defined(ZERO) || !(defined(AMD64) || defined(AARCH64))\n+  log_info(aot, codecache, init)(\"AOT Code Cache is not supported on this platform.\");\n+  AOTAdapterCaching = false;\n+  return;\n+#else\n@@ -94,0 +99,1 @@\n+    AOTAdapterCaching = false;\n@@ -136,0 +142,1 @@\n+#endif \/\/ defined(AMD64) || defined(AARCH64)\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-      CompileBroker::compile_method(m, InvocationEntryBci, next_level, methodHandle(), 0, CompileTask::Reason_MustBeCompiled, THREAD);\n+      CompileBroker::compile_method(m, InvocationEntryBci, next_level, 0, CompileTask::Reason_MustBeCompiled, THREAD);\n@@ -137,1 +137,1 @@\n-    CompileBroker::compile_method(m, InvocationEntryBci, level, methodHandle(), 0, CompileTask::Reason_MustBeCompiled, THREAD);\n+    CompileBroker::compile_method(m, InvocationEntryBci, level, 0, CompileTask::Reason_MustBeCompiled, THREAD);\n@@ -945,1 +945,1 @@\n-    CompileBroker::compile_method(mh, bci, level, mh, hot_count, CompileTask::Reason_Tiered, THREAD);\n+    CompileBroker::compile_method(mh, bci, level, hot_count, CompileTask::Reason_Tiered, THREAD);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -409,1 +409,0 @@\n-  methodHandle save_hot_method;\n@@ -464,1 +463,0 @@\n-    save_hot_method = methodHandle(thread, task->hot_method());\n@@ -1182,1 +1180,0 @@\n-                                        const methodHandle& hot_method,\n@@ -1201,7 +1198,2 @@\n-    if (!hot_method.is_null()) {\n-      tty->print(\" hot: \");\n-      if (hot_method() != method()) {\n-          hot_method->print_short_name(tty);\n-      } else {\n-        tty->print(\"yes\");\n-      }\n+    if (hot_count > 0) {\n+      tty->print(\" hot: yes\");\n@@ -1354,1 +1346,1 @@\n-                               hot_method, hot_count, compile_reason,\n+                               hot_count, compile_reason,\n@@ -1365,1 +1357,1 @@\n-                                       const methodHandle& hot_method, int hot_count,\n+                                       int hot_count,\n@@ -1385,1 +1377,1 @@\n-  nmethod* nm = CompileBroker::compile_method(method, osr_bci, comp_level, hot_method, hot_count, compile_reason, directive, THREAD);\n+  nmethod* nm = CompileBroker::compile_method(method, osr_bci, comp_level, hot_count, compile_reason, directive, THREAD);\n@@ -1392,1 +1384,1 @@\n-                                         const methodHandle& hot_method, int hot_count,\n+                                         int hot_count,\n@@ -1488,1 +1480,1 @@\n-    compile_method_base(method, osr_bci, comp_level, hot_method, hot_count, compile_reason, is_blocking, THREAD);\n+    compile_method_base(method, osr_bci, comp_level, hot_count, compile_reason, is_blocking, THREAD);\n@@ -1635,1 +1627,0 @@\n-                                                const methodHandle& hot_method,\n@@ -1641,1 +1632,1 @@\n-                       hot_method, hot_count, compile_reason,\n+                       hot_count, compile_reason,\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -272,1 +272,0 @@\n-                                          const methodHandle& hot_method,\n@@ -293,1 +292,0 @@\n-                                  const methodHandle& hot_method,\n@@ -327,1 +325,0 @@\n-                                 const methodHandle& hot_method,\n@@ -338,1 +335,0 @@\n-                                   const methodHandle& hot_method,\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,2 +69,1 @@\n-    if ((task->_method_holder != nullptr && JNIHandles::is_weak_global_handle(task->_method_holder)) ||\n-        (task->_hot_method_holder != nullptr && JNIHandles::is_weak_global_handle(task->_hot_method_holder))) {\n+    if ((task->_method_holder != nullptr && JNIHandles::is_weak_global_handle(task->_method_holder))) {\n@@ -72,1 +71,0 @@\n-      JNIHandles::destroy_weak_global(task->_hot_method_holder);\n@@ -75,1 +73,0 @@\n-      JNIHandles::destroy_global(task->_hot_method_holder);\n@@ -93,1 +90,0 @@\n-                             const methodHandle& hot_method,\n@@ -115,2 +111,0 @@\n-  _hot_method = nullptr;\n-  _hot_method_holder = nullptr;\n@@ -131,12 +125,0 @@\n-  if (LogCompilation) {\n-    if (hot_method.not_null()) {\n-      if (hot_method == method) {\n-        _hot_method = _method;\n-      } else {\n-        _hot_method = hot_method();\n-        \/\/ only add loader or mirror if different from _method_holder\n-        _hot_method_holder = JNIHandles::make_weak_global(Handle(thread, hot_method->method_holder()->klass_holder()));\n-      }\n-    }\n-  }\n-\n@@ -163,1 +145,0 @@\n-  JNIHandles::destroy_weak_global(_hot_method_holder);\n@@ -165,3 +146,0 @@\n-  if (_hot_method != nullptr) {\n-    _hot_method_holder = JNIHandles::make_global(Handle(thread, _hot_method->method_holder()->klass_holder()));\n-  }\n@@ -177,3 +155,0 @@\n-  if (_hot_method != nullptr) {\n-    _hot_method->set_on_stack(true);\n-  }\n@@ -192,3 +167,0 @@\n-  if (hot_method() != nullptr && hot_method() != method()) {\n-    f->do_metadata(hot_method());\n-  }\n@@ -333,3 +305,0 @@\n-  if (_hot_method != nullptr && _hot_method != _method) {\n-    xtty->method(_hot_method);\n-  }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":1,"deletions":32,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -110,2 +110,0 @@\n-  Method*              _hot_method;   \/\/ which method actually triggered this task\n-  jobject              _hot_method_holder;\n@@ -127,1 +125,1 @@\n-                  const methodHandle& hot_method, int hot_count,\n+                  int hot_count,\n@@ -135,1 +133,0 @@\n-  Method*      hot_method() const                { return _hot_method; }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -223,0 +223,1 @@\n+  shenandoah_assert_heaplocked();\n@@ -231,0 +232,1 @@\n+    _available[partition_id] = FreeSetUnderConstruction;\n@@ -238,0 +240,2 @@\n+  shenandoah_assert_heaplocked();\n+\n@@ -246,0 +250,2 @@\n+  _available[int(ShenandoahFreeSetPartitionId::Mutator)] =\n+    _capacity[int(ShenandoahFreeSetPartitionId::Mutator)] - _used[int(ShenandoahFreeSetPartitionId::Mutator)];\n@@ -255,0 +261,1 @@\n+  _available[int(ShenandoahFreeSetPartitionId::Collector)] = 0;\n@@ -261,0 +268,2 @@\n+  shenandoah_assert_heaplocked();\n+\n@@ -269,0 +278,2 @@\n+  _available[int(ShenandoahFreeSetPartitionId::OldCollector)] =\n+    _capacity[int(ShenandoahFreeSetPartitionId::OldCollector)] - _used[int(ShenandoahFreeSetPartitionId::OldCollector)];\n@@ -272,0 +283,1 @@\n+  shenandoah_assert_heaplocked();\n@@ -273,0 +285,1 @@\n+\n@@ -274,0 +287,1 @@\n+  _available[int(which_partition)] -= bytes;\n@@ -369,0 +383,1 @@\n+  shenandoah_assert_heaplocked();\n@@ -377,0 +392,1 @@\n+  _available[int(which_partition)] += available;\n@@ -401,0 +417,1 @@\n+  shenandoah_assert_heaplocked();\n@@ -439,0 +456,1 @@\n+  _available[int(orig_partition)] -= available;\n@@ -443,0 +461,1 @@\n+  _available[int(new_partition)] += available;\n@@ -1366,1 +1385,0 @@\n-  shenandoah_assert_heaplocked();\n@@ -1371,0 +1389,1 @@\n+  shenandoah_assert_heaplocked();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+  size_t _available[UIntNumPartitions];\n@@ -111,0 +112,2 @@\n+  static const size_t FreeSetUnderConstruction = SIZE_MAX;\n+\n@@ -223,1 +226,23 @@\n-    return _capacity[int(which_partition)] - _used[int(which_partition)];\n+    shenandoah_assert_heaplocked();\n+    assert(_available[int(which_partition)] == _capacity[int(which_partition)] - _used[int(which_partition)],\n+           \"Expect available (%zu) equals capacity (%zu) - used (%zu) for partition %s\",\n+           _available[int(which_partition)], _capacity[int(which_partition)], _used[int(which_partition)],\n+           partition_membership_name(ssize_t(which_partition)));\n+    return _available[int(which_partition)];\n+  }\n+\n+  \/\/ Return available_in assuming caller does not hold the heap lock.  In production builds, available is\n+  \/\/ returned without acquiring the lock.  In debug builds, the global heap lock is acquired in order to\n+  \/\/ enforce a consistency assert.\n+  inline size_t available_in_not_locked(ShenandoahFreeSetPartitionId which_partition) const {\n+    assert (which_partition < NumPartitions, \"selected free set must be valid\");\n+    shenandoah_assert_not_heaplocked();\n+#ifdef ASSERT\n+    ShenandoahHeapLocker locker(ShenandoahHeap::heap()->lock());\n+    assert((_available[int(which_partition)] == FreeSetUnderConstruction) ||\n+           (_available[int(which_partition)] == _capacity[int(which_partition)] - _used[int(which_partition)]),\n+           \"Expect available (%zu) equals capacity (%zu) - used (%zu) for partition %s\",\n+           _available[int(which_partition)], _capacity[int(which_partition)], _used[int(which_partition)],\n+           partition_membership_name(ssize_t(which_partition)));\n+#endif\n+    return _available[int(which_partition)];\n@@ -227,0 +252,1 @@\n+    shenandoah_assert_heaplocked();\n@@ -229,0 +255,1 @@\n+    _available[int(which_partition)] = value - _used[int(which_partition)];\n@@ -232,0 +259,1 @@\n+    shenandoah_assert_heaplocked();\n@@ -234,0 +262,1 @@\n+    _available[int(which_partition)] = _capacity[int(which_partition)] - value;\n@@ -385,0 +414,2 @@\n+  static const size_t FreeSetUnderConstruction = ShenandoahRegionPartitions::FreeSetUnderConstruction;\n+\n@@ -444,2 +475,0 @@\n-  inline size_t capacity()  const { return _partitions.capacity_of(ShenandoahFreeSetPartitionId::Mutator); }\n-  inline size_t used()      const { return _partitions.used_by(ShenandoahFreeSetPartitionId::Mutator);     }\n@@ -447,4 +476,8 @@\n-  inline size_t available() const {\n-    assert(used() <= capacity(), \"must use less than capacity\");\n-    return capacity() - used();\n-  }\n+  \/\/ All three of the following functions may produce stale data if called without owning the global heap lock.\n+  \/\/ Changes to the values of these variables are performed with a lock.  A change to capacity or used \"atomically\"\n+  \/\/ adjusts available with respect to lock holders.  However, sequential calls to these three functions may produce\n+  \/\/ inconsistent data: available may not equal capacity - used because the intermediate states of any \"atomic\"\n+  \/\/ locked action can be seen by these unlocked functions.\n+  inline size_t capacity()  const { return _partitions.capacity_of(ShenandoahFreeSetPartitionId::Mutator);             }\n+  inline size_t used()      const { return _partitions.used_by(ShenandoahFreeSetPartitionId::Mutator);                 }\n+  inline size_t available() const { return _partitions.available_in_not_locked(ShenandoahFreeSetPartitionId::Mutator); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":40,"deletions":7,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+  ShenandoahGenerationalHeap::TransferResult result;\n@@ -255,1 +256,8 @@\n-    phase5_epilog();\n+    result = phase5_epilog();\n+  }\n+  if (heap->mode()->is_generational()) {\n+    LogTarget(Info, gc, ergo) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      result.print_on(\"Full GC\", &ls);\n+    }\n@@ -1123,1 +1131,1 @@\n-void ShenandoahFullGC::phase5_epilog() {\n+ShenandoahGenerationalHeap::TransferResult ShenandoahFullGC::phase5_epilog() {\n@@ -1126,0 +1134,1 @@\n+  ShenandoahGenerationalHeap::TransferResult result;\n@@ -1171,1 +1180,1 @@\n-    ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set();\n+    result = ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set();\n@@ -1174,0 +1183,1 @@\n+  return result;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -84,1 +85,1 @@\n-  void phase5_epilog();\n+  ShenandoahGenerationalHeap::TransferResult phase5_epilog();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -131,7 +131,2 @@\n-void ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set() {\n-  auto result = ShenandoahGenerationalHeap::heap()->balance_generations();\n-  LogTarget(Info, gc, ergo) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    result.print_on(\"Full GC\", &ls);\n-  }\n+ShenandoahGenerationalHeap::TransferResult ShenandoahGenerationalFullGC::balance_generations_after_rebuilding_free_set() {\n+  return ShenandoahGenerationalHeap::heap()->balance_generations();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahGenerationalHeap.hpp\"\n@@ -64,1 +65,1 @@\n-  static void balance_generations_after_rebuilding_free_set();\n+  static ShenandoahGenerationalHeap::TransferResult balance_generations_after_rebuilding_free_set();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalFullGC.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,1 +58,4 @@\n-  return ShenandoahHeap::heap()->free_set()->available();\n+  \/\/ The collector reserve may eat into what the mutator is allowed to use. Make sure we are looking\n+  \/\/ at what is available to the mutator when reporting how much memory is available.\n+  size_t available = this->ShenandoahGeneration::available();\n+  return MIN2(available, ShenandoahHeap::heap()->free_set()->available());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -405,1 +405,0 @@\n-  _free_set = new ShenandoahFreeSet(this, _num_regions);\n@@ -409,1 +408,1 @@\n-\n+    _free_set = new ShenandoahFreeSet(this, _num_regions);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  assert(free_actual != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+  assert(free != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n@@ -89,0 +90,1 @@\n+  assert(free != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n@@ -114,0 +116,1 @@\n+  assert(free != ShenandoahFreeSet::FreeSetUnderConstruction, \"Avoid this race\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  log_info(gc, barrier)(\"Cleaned read_table from \" PTR_FORMAT \" to \" PTR_FORMAT, p2i(&(read_table)[0]), p2i(end_bp));\n+  log_develop_debug(gc, barrier)(\"Cleaned read_table from \" PTR_FORMAT \" to \" PTR_FORMAT, p2i(&(read_table[0])), p2i(end_bp));\n@@ -619,1 +619,1 @@\n-  log_info(gc, remset)(\"Finished merging write_table into read_table.\");\n+  log_develop_debug(gc, remset)(\"Finished merging write_table into read_table.\");\n@@ -646,1 +646,1 @@\n-  log_info(gc, barrier)(\"Current write_card_table: \" PTR_FORMAT, p2i(swap_it._new_ptr));\n+  log_develop_debug(gc, barrier)(\"Current write_card_table: \" PTR_FORMAT, p2i(swap_it._new_ptr));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahScanRemembered.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,4 +42,0 @@\n-size_t ZAllocatorEden::tlab_used() const {\n-  return _object_allocator.used();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zAllocator.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-  size_t tlab_used() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zAllocator.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -146,0 +146,5 @@\n+  \/\/ Set an initial TLAB size to avoid depending on the current capacity\n+  if (FLAG_IS_DEFAULT(TLABSize)) {\n+    FLAG_SET_DEFAULT(TLABSize, 256*K);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zArguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-  return _heap.max_tlab_size();\n+  return _heap.max_tlab_size() \/ HeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -840,0 +840,3 @@\n+  \/\/ Reset TLAB usage\n+  ZHeap::heap()->reset_tlab_used();\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    _tlab_usage(),\n@@ -134,1 +135,1 @@\n-  return capacity();\n+  return _tlab_usage.tlab_capacity();\n@@ -138,1 +139,1 @@\n-  return _allocator_eden.tlab_used();\n+  return _tlab_usage.tlab_used();\n@@ -159,0 +160,3 @@\n+void ZHeap::reset_tlab_used() {\n+  _tlab_usage.reset();\n+}\n@@ -222,0 +226,24 @@\n+static bool is_small_eden_page(ZPage* page) {\n+  return page->type() == ZPageType::small && page->age() == ZPageAge::eden;\n+}\n+\n+void ZHeap::account_alloc_page(ZPage* page) {\n+  \/\/ Do TLAB accounting for small eden pages\n+  if (is_small_eden_page(page)) {\n+    _tlab_usage.increase_used(page->size());\n+  }\n+}\n+\n+void ZHeap::account_undo_alloc_page(ZPage* page) {\n+  \/\/ Increase the undo counter\n+  ZStatInc(ZCounterUndoPageAllocation);\n+\n+  \/\/ Undo TLAB accounting for small eden pages\n+  if (is_small_eden_page(page)) {\n+    _tlab_usage.decrease_used(page->size());\n+  }\n+\n+  log_trace(gc)(\"Undo page allocation, thread: \" PTR_FORMAT \" (%s), page: \" PTR_FORMAT \", size: %zu\",\n+                p2i(Thread::current()), ZUtils::thread_name(), p2i(page), page->size());\n+}\n+\n@@ -227,0 +255,3 @@\n+\n+    \/\/ Do accounting for the allocated page\n+    account_alloc_page(page);\n@@ -235,3 +266,2 @@\n-  ZStatInc(ZCounterUndoPageAllocation);\n-  log_trace(gc)(\"Undo page allocation, thread: \" PTR_FORMAT \" (%s), page: \" PTR_FORMAT \", size: %zu\",\n-                p2i(Thread::current()), ZUtils::thread_name(), p2i(page), page->size());\n+  \/\/ Undo accounting for the page being freed\n+  account_undo_alloc_page(page);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":35,"deletions":5,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/z\/zTLABUsage.hpp\"\n@@ -58,0 +59,2 @@\n+  ZTLABUsage              _tlab_usage;\n+\n@@ -60,0 +63,4 @@\n+  \/\/ Page allocation accounting\n+  void account_alloc_page(ZPage* page);\n+  void account_undo_alloc_page(ZPage* page);\n+\n@@ -84,0 +91,1 @@\n+  void reset_tlab_used();\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-    _used(0),\n-    _undone(0),\n@@ -61,7 +59,1 @@\n-  ZPage* const page = ZHeap::heap()->alloc_page(type, size, flags, _age);\n-  if (page != nullptr) {\n-    \/\/ Increment used bytes\n-    Atomic::add(_used.addr(), size);\n-  }\n-\n-  return page;\n+  return ZHeap::heap()->alloc_page(type, size, flags, _age);\n@@ -75,3 +67,0 @@\n-  \/\/ Increment undone bytes\n-  Atomic::add(_undone.addr(), page->size());\n-\n@@ -232,17 +221,0 @@\n-size_t ZObjectAllocator::used() const {\n-  size_t total_used = 0;\n-  size_t total_undone = 0;\n-\n-  ZPerCPUConstIterator<size_t> iter_used(&_used);\n-  for (const size_t* cpu_used; iter_used.next(&cpu_used);) {\n-    total_used += *cpu_used;\n-  }\n-\n-  ZPerCPUConstIterator<size_t> iter_undone(&_undone);\n-  for (const size_t* cpu_undone; iter_undone.next(&cpu_undone);) {\n-    total_undone += *cpu_undone;\n-  }\n-\n-  return total_used - total_undone;\n-}\n-\n@@ -263,4 +235,0 @@\n-  \/\/ Reset used and undone bytes\n-  _used.set_all(0);\n-  _undone.set_all(0);\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":1,"deletions":33,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-  ZPerCPU<size_t>    _used;\n-  ZPerCPU<size_t>    _undone;\n@@ -83,1 +81,0 @@\n-  size_t used() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"gc\/z\/zTLABUsage.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+ZTLABUsage::ZTLABUsage()\n+  : _used(0),\n+    _used_history() {}\n+\n+void ZTLABUsage::increase_used(size_t size) {\n+  Atomic::add(&_used, size, memory_order_relaxed);\n+}\n+\n+void ZTLABUsage::decrease_used(size_t size) {\n+  precond(size <= _used);\n+\n+  Atomic::sub(&_used, size, memory_order_relaxed);\n+}\n+\n+void ZTLABUsage::reset() {\n+  const size_t used = Atomic::xchg(&_used, (size_t) 0);\n+\n+  \/\/ Avoid updates when nothing has been allocated since the last YC\n+  if (used == 0) {\n+    return;\n+  }\n+\n+  \/\/ Save the old values for logging\n+  const size_t old_tlab_used = tlab_used();\n+  const size_t old_tlab_capacity = tlab_capacity();\n+\n+  \/\/ Update the usage history with the current value\n+  _used_history.add(used);\n+\n+  log_debug(gc, tlab)(\"TLAB usage update: used %zuM -> %zuM, capacity: %zuM -> %zuM\",\n+                      old_tlab_used \/ M,\n+                      tlab_used() \/ M,\n+                      old_tlab_capacity \/ M,\n+                      tlab_capacity() \/ M);\n+  }\n+\n+size_t ZTLABUsage::tlab_used() const {\n+  return _used_history.last();\n+}\n+\n+size_t ZTLABUsage::tlab_capacity() const {\n+  return _used_history.davg();\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zTLABUsage.cpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_Z_ZTLABUSAGE_HPP\n+#define SHARE_GC_Z_ZTLABUSAGE_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/numberSeq.hpp\"\n+\n+\/\/ ZGC is retiring TLABs concurrently with the application running when\n+\/\/ processing the stack watermarks. For the common TLAB heuristic to work we\n+\/\/ need to return consistent TLAB usage information when a TLAB is retired.\n+\/\/ We snapshot the TLAB usage in the mark start pause for the young generation\n+\/\/ and use this information until the next garbage collection cycle.\n+\/\/\n+\/\/ ZGC does not have set generation sizes unlike most other GCs and because of\n+\/\/ this there is no fixed TLAB capacity. For the common TLAB sizing heuristic\n+\/\/ to work properly ZGC estimates the current capacity by using a weighted\n+\/\/ average of the last 10 used values. ZGC uses the last snapshotted value as\n+\/\/ the value returned as tlab_used().\n+\n+class ZTLABUsage {\n+private:\n+  \/\/ Accounting TLAB used until the next GC cycle\n+  volatile size_t _used;\n+  \/\/ Sequence of historic used values\n+  TruncatedSeq    _used_history;\n+\n+public:\n+  ZTLABUsage();\n+\n+  void increase_used(size_t size);\n+  void decrease_used(size_t size);\n+  void reset();\n+\n+  size_t tlab_used() const;\n+  size_t tlab_capacity() const;\n+};\n+\n+#endif \/\/ SHARE_GC_Z_ZTLABUSAGE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zTLABUsage.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -92,1 +92,1 @@\n-      CompileBroker::compile_method(mh, InvocationEntryBci, CompLevel_full_optimization, mh, hot_count, CompileTask::Reason_Bootstrap, CHECK);\n+      CompileBroker::compile_method(mh, InvocationEntryBci, CompLevel_full_optimization, hot_count, CompileTask::Reason_Bootstrap, CHECK);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3234,1 +3234,5 @@\n-}\n+C2V_END\n+\n+C2V_VMENTRY_0(jboolean, isCompilerThread, (JNIEnv* env, jobject))\n+  return thread->is_Compiler_thread();\n+C2V_END\n@@ -3399,0 +3403,1 @@\n+  {CC \"isCompilerThread\",                             CC \"()Z\",                                                                             FN_PTR(isCompilerThread)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+    FLAG_SET_ERGO_IF_DEFAULT(EagerJVMCI, true);\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,1 +91,2 @@\n-          \"Force eager JVMCI initialization\")                               \\\n+          \"Force eager JVMCI initialization. Defaults to true if \"          \\\n+          \"UseJVMCICompiler is true.\")                                      \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-  assert(!is_empty(), \"should not use replace\");\n+  assert(!is_empty(), \"Must not use replace on empty handle\");\n@@ -79,0 +79,1 @@\n+  assert(!is_empty(), \"Must not use xchg on empty handle\");\n@@ -86,0 +87,1 @@\n+  assert(!is_empty(), \"Must not use cmpxchg on empty handle\");\n","filename":"src\/hotspot\/share\/oops\/oopHandle.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  assert(!is_empty(), \"Must not use replace on empty handle\");\n","filename":"src\/hotspot\/share\/oops\/weakHandle.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-  unsigned int abs_con = uabs(con);\n+  unsigned int abs_con = g_uabs(con);\n@@ -496,1 +496,1 @@\n-  julong abs_con = uabs(con);\n+  julong abs_con = g_uabs(con);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1946,1 +1946,1 @@\n-      return TypeInt::make(uabs(ti->get_con()));\n+      return TypeInt::make(g_uabs(ti->get_con()));\n@@ -1953,1 +1953,1 @@\n-      return TypeLong::make(uabs(tl->get_con()));\n+      return TypeLong::make(g_uabs(tl->get_con()));\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1127,1 +1127,1 @@\n-  nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh->invocation_count(), CompileTask::Reason_Whitebox, CHECK_false);\n+  nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh->invocation_count(), CompileTask::Reason_Whitebox, CHECK_false);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1121,1 +1121,1 @@\n-static inline unsigned int uabs(unsigned int n) {\n+static inline unsigned int g_uabs(unsigned int n) {\n@@ -1130,1 +1130,1 @@\n-static inline julong uabs(julong n) {\n+static inline julong g_uabs(julong n) {\n@@ -1139,2 +1139,2 @@\n-static inline julong uabs(jlong n) { return uabs((julong)n); }\n-static inline unsigned int uabs(int n) { return uabs((unsigned int)n); }\n+static inline julong g_uabs(jlong n) { return g_uabs((julong)n); }\n+static inline unsigned int g_uabs(int n) { return g_uabs((unsigned int)n); }\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3422,0 +3422,225 @@\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code int}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned int\n+     * @since 25\n+     *\/\n+    public static int unsignedMultiplyExact(int x, int y) {\n+        long r = (x & 0xFFFF_FFFFL) * (y & 0xFFFF_FFFFL);\n+        if (r >>> 32 != 0) {\n+            throw new ArithmeticException(\"unsigned integer overflow\");\n+        }\n+        return (int)r;\n+    }\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned long\n+     * @since 25\n+     *\/\n+    public static long unsignedMultiplyExact(long x, int y) {\n+        return unsignedMultiplyExact(x, y & 0xFFFF_FFFFL);\n+    }\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned long\n+     * @since 25\n+     *\/\n+    public static long unsignedMultiplyExact(long x, long y) {\n+        long l = x * y;\n+        long h = unsignedMultiplyHigh(x, y);\n+        if (h == 0) {\n+            return l;\n+        }\n+        throw new ArithmeticException(\"unsigned long overflow\");\n+    }\n+\n+    \/**\n+     * Returns {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows an {@code int}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an int.\n+     * @since 25\n+     *\/\n+    public static int powExact(int x, int n) {\n+        \/* See the comment in unsignedPowExact(long,int) for the details. *\/\n+        if (n < 0) {\n+            throw new ArithmeticException(\"negative exponent\");\n+        }\n+        if (n == 0) {\n+            return 1;\n+        }\n+        if (x == 0 || x == 1) {\n+            return x;\n+        }\n+        if (x == -1) {\n+            return (n & 0b1) == 0 ? 1 : -1;\n+        }\n+\n+        int p = 1;\n+        while (n > 1) {\n+            if ((n & 0b1) != 0) {\n+                p *= x;\n+            }\n+            x = multiplyExact(x, x);\n+            n >>>= 1;\n+        }\n+        return multiplyExact(p, x);\n+    }\n+\n+    \/**\n+     * Returns unsigned {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows an unsigned {@code int}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the unsigned base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an unsigned int.\n+     * @since 25\n+     *\/\n+    public static int unsignedPowExact(int x, int n) {\n+        \/* See the comment in unsignedPowExact(long,int) for the details. *\/\n+        if (n < 0) {\n+            throw new ArithmeticException(\"negative exponent\");\n+        }\n+        if (n == 0) {\n+            return 1;\n+        }\n+        if (x == 0 || x == 1) {\n+            return x;\n+        }\n+\n+        int p = 1;\n+        while (n > 1) {\n+            if ((n & 0b1) != 0) {\n+                p *= x;\n+            }\n+            x = unsignedMultiplyExact(x, x);\n+            n >>>= 1;\n+        }\n+        return unsignedMultiplyExact(p, x);\n+    }\n+\n+    \/**\n+     * Returns {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows a {@code long}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows a long.\n+     * @since 25\n+     *\/\n+    public static long powExact(long x, int n) {\n+        \/* See the comment in unsignedPowExact(long,int) for the details. *\/\n+        if (n < 0) {\n+            throw new ArithmeticException(\"negative exponent\");\n+        }\n+        if (n == 0) {\n+            return 1;\n+        }\n+        if (x == 0 || x == 1) {\n+            return x;\n+        }\n+        if (x == -1) {\n+            return (n & 0b1) != 0 ? -1 : 1;\n+        }\n+\n+        long p = 1;\n+        while (n > 1) {\n+            if ((n & 0b1) != 0) {\n+                p *= x;\n+            }\n+            x = multiplyExact(x, x);\n+            n >>>= 1;\n+        }\n+        return multiplyExact(p, x);\n+    }\n+\n+    \/**\n+     * Returns unsigned {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the unsigned base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an unsigned long.\n+     * @since 25\n+     *\/\n+    public static long unsignedPowExact(long x, int n) {\n+        if (n < 0) {\n+            throw new ArithmeticException(\"negative exponent\");\n+        }\n+        if (n == 0) {\n+            return 1;\n+        }\n+        \/*\n+         * To keep the code as simple as possible, there are intentionally\n+         * no fast paths, except for |x| <= 1.\n+         * The reason is that the number of loop iterations below can be kept\n+         * very small when |x| > 1, but not necessarily when |x| <= 1.\n+         *\/\n+        if (x == 0 || x == 1) {\n+            return x;\n+        }\n+\n+        \/*\n+         * Let x0 and n0 > 0 be the entry values of x and n, resp.\n+         * The useful loop invariants are:\n+         *      p * x^n = x0^n0\n+         *      |p| < |x|\n+         *\n+         * Since |x0| >= 2 here, and since |x0|^(2^6) >= 2^Long.SIZE, the squaring\n+         * of x in the loop overflows at latest during the 6th iteration,\n+         * so by then the method throws.\n+         * Thus, the loop executes at most 5 successful iterations, and fails\n+         * not later than at the 6th.\n+         *\n+         * But n is right-shifted at each iteration.\n+         * If the method returns, there are thus floor(log2(n0)) iterations.\n+         *\/\n+        long p = 1;\n+        while (n > 1) {\n+            if ((n & 0b1) != 0) {\n+                \/*\n+                 * The invariant |p| < |x| holds, so we have |p*x| < |x*x|.\n+                 * That is, if p*x overflows, so does x*x below, which is\n+                 * always executed.\n+                 * In other words, a plain * can be used here, since we are\n+                 * piggybacking on the squaring of x to throw.\n+                 *\/\n+                p *= x;\n+            }\n+            x = unsignedMultiplyExact(x, x);\n+            n >>>= 1;\n+        }\n+        return unsignedMultiplyExact(p, x);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,2 @@\n- *         try (var scope = new StructuredTaskScope<String>()) {\n+ *         \/\/ @link substring=\"open\" target=\"StructuredTaskScope#open()\" :\n+ *         try (var scope = StructuredTaskScope.open()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedValue.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -387,2 +387,2 @@\n- * Invocations of {@link #setOrThrow(Object)} form a total order of zero or more\n- * exceptional invocations followed by zero (if the contents were already set) or one\n+ * Invocations of {@link #orElseSet(Supplier)} form a total order of zero or\n+ * more exceptional invocations followed by zero (if the contents were already set) or one\n@@ -447,2 +447,0 @@\n-    \/\/ Principal methods\n-\n@@ -512,2 +510,0 @@\n-    \/\/ Convenience methods\n-\n@@ -522,0 +518,3 @@\n+     * @throws IllegalStateException if a supplier invoked by {@link #orElseSet(Supplier)}\n+     *         recursively attempts to set this stable value by calling this method\n+     *         directly or indirectly.\n@@ -576,2 +575,2 @@\n-     * thrown by the computing thread. The computing threads will then observe the newly\n-     * computed value (if any) and will then never execute.\n+     * thrown by the computing thread. The competing threads will then observe the newly\n+     * computed value (if any) and will then never execute the {@code underlying} supplier.\n@@ -617,3 +616,3 @@\n-     * @param size       the size of the allowed inputs in the continuous\n-     *                   interval {@code [0, size)}\n-     * @param underlying IntFunction used to compute cached values\n+     * @param size       the upper bound of the range {@code [0, size)} indicating\n+     *                   the allowed inputs\n+     * @param underlying {@code IntFunction} used to compute cached values\n@@ -687,1 +686,1 @@\n-     * Any direct {@link List#subList(int, int) subList} or {@link List#reversed()} views\n+     * Any {@link List#subList(int, int) subList} or {@link List#reversed()} views\n@@ -730,2 +729,2 @@\n-     * Any direct {@link Map#values()} or {@link Map#entrySet()} views\n-     * of the returned map are also stable.\n+     * Any {@link Map#values()} or {@link Map#entrySet()} views of the returned map are\n+     * also stable.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StableValue.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2597,0 +2597,107 @@\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code int}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned int\n+     * @since 25\n+     *\/\n+    public static int unsignedMultiplyExact(int x, int y) {\n+        return Math.unsignedMultiplyExact(x, y);\n+    }\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned long\n+     * @since 25\n+     *\/\n+    public static long unsignedMultiplyExact(long x, int y) {\n+        return Math.unsignedMultiplyExact(x, y);\n+    }\n+\n+    \/**\n+     * Returns the product of the unsigned arguments,\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     *\n+     * @param x the first unsigned value\n+     * @param y the second unsigned value\n+     * @return the result\n+     * @throws ArithmeticException if the result overflows an unsigned long\n+     * @since 25\n+     *\/\n+    public static long unsignedMultiplyExact(long x, long y) {\n+        return Math.unsignedMultiplyExact(x, y);\n+    }\n+\n+    \/**\n+     * Returns {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows an {@code int}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an int.\n+     * @since 25\n+     *\/\n+    public static int powExact(int x, int n) {\n+        return Math.powExact(x, n);\n+    }\n+\n+    \/**\n+     * Returns unsigned {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows an unsigned {@code int}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the unsigned base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an unsigned int.\n+     * @since 25\n+     *\/\n+    public static int unsignedPowExact(int x, int n) {\n+        return Math.unsignedPowExact(x, n);\n+    }\n+\n+    \/**\n+     * Returns {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows a {@code long}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows a long.\n+     * @since 25\n+     *\/\n+    public static long powExact(long x, int n) {\n+        return Math.powExact(x, n);\n+    }\n+\n+    \/**\n+     * Returns unsigned {@code x} raised to the power of {@code n},\n+     * throwing an exception if the result overflows an unsigned {@code long}.\n+     * When {@code n} is 0, the returned value is 1.\n+     *\n+     * @param x the unsigned base.\n+     * @param n the exponent.\n+     * @return {@code x} raised to the power of {@code n}.\n+     * @throws ArithmeticException when {@code n} is negative,\n+     *      or when the result overflows an unsigned long.\n+     * @since 25\n+     *\/\n+    public static long unsignedPowExact(long x, int n) {\n+        return Math.unsignedPowExact(x, n);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1412,1 +1412,1 @@\n-            container.onStart(this);  \/\/ may throw\n+            container.add(this);  \/\/ may throw\n@@ -1421,1 +1421,1 @@\n-                    container.onExit(this);\n+                    container.remove(this);\n@@ -1490,1 +1490,1 @@\n-                container.onExit(this);\n+                container.remove(this);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -667,1 +667,1 @@\n-            threadContainer().onExit(this);\n+            threadContainer().remove(this);\n@@ -695,1 +695,1 @@\n-            container.onStart(this);  \/\/ may throw\n+            container.add(this);  \/\/ may throw\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.vm.Continuation;\n@@ -148,13 +147,0 @@\n-    private boolean tryDisablePreempt() {\n-        if (Thread.currentThread().isVirtual() && ContinuationSupport.isSupported()) {\n-            Continuation.pin();\n-            return true;\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    private void enablePreempt() {\n-        Continuation.unpin();\n-    }\n-\n@@ -176,1 +162,1 @@\n-        boolean disabled = tryDisablePreempt();\n+        ContinuationSupport.pinIfSupported();\n@@ -182,1 +168,1 @@\n-            if (disabled) enablePreempt();\n+            ContinuationSupport.unpinIfSupported();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -752,1 +752,3 @@\n-     * path.\n+     * path. Where this {@code Path} is associated with the default provider,\n+     * then the returned absolute path will have a non-{@code null}\n+     * {@linkplain #getRoot root component}.\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2172,8 +2172,4 @@\n-     * Sets the maximum number of digits allowed in the integer portion of a\n-     * number.\n-     * The maximum allowed integer range is 309, if the {@code newValue} &gt; 309,\n-     * then the maximum integer digits count is set to 309. Negative input\n-     * values are replaced with 0.\n-     *\n-     * @param newValue the maximum number of integer digits to be shown\n-     * @see #getMaximumIntegerDigits()\n+     * {@inheritDoc NumberFormat}\n+     * <p>The maximum allowed integer range is 309, if the {@code newValue} &gt;\n+     * 309, then the maximum integer digits count is set to 309.\n+     * @param newValue the maximum number of integer digits to be shown.\n@@ -2197,8 +2193,4 @@\n-     * Sets the minimum number of digits allowed in the integer portion of a\n-     * number.\n-     * The maximum allowed integer range is 309, if the {@code newValue} &gt; 309,\n-     * then the minimum integer digits count is set to 309. Negative input\n-     * values are replaced with 0.\n-     *\n-     * @param newValue the minimum number of integer digits to be shown\n-     * @see #getMinimumIntegerDigits()\n+     * {@inheritDoc NumberFormat}\n+     * <p>The maximum allowed integer range is 309, if the {@code newValue} &gt;\n+     * 309, then the minimum integer digits count is set to 309.\n+     * @param newValue the minimum number of integer digits to be shown.\n@@ -2222,8 +2214,4 @@\n-     * Sets the minimum number of digits allowed in the fraction portion of a\n-     * number.\n-     * The maximum allowed fraction range is 340, if the {@code newValue} &gt; 340,\n-     * then the minimum fraction digits count is set to 340. Negative input\n-     * values are replaced with 0.\n-     *\n-     * @param newValue the minimum number of fraction digits to be shown\n-     * @see #getMinimumFractionDigits()\n+     * {@inheritDoc NumberFormat}\n+     * <p>The maximum allowed fraction range is 340, if the {@code newValue} &gt;\n+     * 340, then the minimum fraction digits count is set to 340.\n+     * @param newValue the minimum number of fraction digits to be shown.\n@@ -2248,8 +2236,4 @@\n-     * Sets the maximum number of digits allowed in the fraction portion of a\n-     * number.\n-     * The maximum allowed fraction range is 340, if the {@code newValue} &gt; 340,\n-     * then the maximum fraction digits count is set to 340. Negative input\n-     * values are replaced with 0.\n-     *\n-     * @param newValue the maximum number of fraction digits to be shown\n-     * @see #getMaximumFractionDigits()\n+     * {@inheritDoc NumberFormat}\n+     * <p>The maximum allowed fraction range is 340, if the {@code newValue} &gt;\n+     * 340, then the maximum fraction digits count is set to 340.\n+     * @param newValue the maximum number of fraction digits to be shown.\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":17,"deletions":33,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -113,0 +113,4 @@\n+ * The integer and fraction digit limits are set by either applying a {@link ##patterns\n+ * pattern} or using one of the appropriate {@code DecimalFormat} setter methods,\n+ * for example, {@link #setMinimumFractionDigits(int)}. These limits have no impact\n+ * on parsing behavior.\n@@ -3975,3 +3979,3 @@\n-     * Sets the maximum number of digits allowed in the integer portion of a\n-     * number. Negative input values are replaced with 0.\n-     * @see NumberFormat#setMaximumIntegerDigits\n+     * {@inheritDoc NumberFormat}\n+     * @param newValue the maximum number of integer digits to be shown.\n+     * @see #getMaximumIntegerDigits()\n@@ -3992,3 +3996,3 @@\n-     * Sets the minimum number of digits allowed in the integer portion of a\n-     * number. Negative input values are replaced with 0.\n-     * @see NumberFormat#setMinimumIntegerDigits\n+     * {@inheritDoc NumberFormat}\n+     * @param newValue the minimum number of integer digits to be shown.\n+     * @see #getMinimumIntegerDigits()\n@@ -4009,3 +4013,3 @@\n-     * Sets the maximum number of digits allowed in the fraction portion of a\n-     * number. Negative input values are replaced with 0.\n-     * @see NumberFormat#setMaximumFractionDigits\n+     * {@inheritDoc NumberFormat}\n+     * @param newValue the maximum number of fraction digits to be shown.\n+     * @see #getMaximumFractionDigits()\n@@ -4026,3 +4030,3 @@\n-     * Sets the minimum number of digits allowed in the fraction portion of a\n-     * number. Negative input values are replaced with 0.\n-     * @see NumberFormat#setMinimumFractionDigits\n+     * {@inheritDoc NumberFormat}\n+     * @param newValue the minimum number of fraction digits to be shown.\n+     * @see #getMinimumFractionDigits()\n@@ -4043,4 +4047,3 @@\n-     * Gets the maximum number of digits allowed in the integer portion of a\n-     * number. The maximum number of integer digits can be set by either {@link #setMaximumIntegerDigits(int)}\n-     * or {@link #applyPattern(String)}. See the {@link ##patterns Pattern Section} for\n-     * comprehensive rules regarding maximum integer digits in patterns.\n+     * {@inheritDoc NumberFormat}\n+     * <p>Unlike the other digit limits, {@code maximumIntegerDigits} is not\n+     * updated by {@code DecimalFormats} created or updated with a string pattern.\n@@ -4048,0 +4051,1 @@\n+     * @see ##patterns Pattern Section\n@@ -4056,2 +4060,1 @@\n-     * Gets the minimum number of digits allowed in the integer portion of a\n-     * number.\n+     * {@inheritDoc NumberFormat}\n@@ -4067,2 +4070,1 @@\n-     * Gets the maximum number of digits allowed in the fraction portion of a\n-     * number.\n+     * {@inheritDoc NumberFormat}\n@@ -4078,2 +4080,1 @@\n-     * Gets the minimum number of digits allowed in the fraction portion of a\n-     * number.\n+     * {@inheritDoc NumberFormat}\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":23,"deletions":22,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -132,3 +132,3 @@\n- * <li> {@link #setMinimumFractionDigits(int)}; Use to adjust the expected digits when\n- * formatting. Use any of the other minimum\/maximum or fraction\/integer setter methods\n- * in the same manner.\n+ * <li> {@link #setMinimumFractionDigits(int)}; Use to adjust the expected digits\n+ * when formatting. Use any of the other minimum\/maximum or fraction\/integer\n+ * setter methods in the same manner. These methods have no impact on parsing behavior.\n@@ -921,1 +921,1 @@\n-     * number.\n+     * number during formatting.\n@@ -932,4 +932,5 @@\n-     * number. maximumIntegerDigits must be &ge; minimumIntegerDigits.  If the\n-     * new value for maximumIntegerDigits is less than the current value\n-     * of minimumIntegerDigits, then minimumIntegerDigits will also be set to\n-     * the new value.\n+     * number during formatting. {@code maximumIntegerDigits} must be &ge;\n+     * {@code minimumIntegerDigits}. If the new value for {@code\n+     * maximumIntegerDigits} is less than the current value of\n+     * {@code minimumIntegerDigits}, then {@code minimumIntegerDigits} will\n+     * also be set to the new value. Negative input values are replaced with 0.\n@@ -937,3 +938,3 @@\n-     * @param newValue the maximum number of integer digits to be shown; if\n-     * less than zero, then zero is used. The concrete subclass may enforce an\n-     * upper limit to this value appropriate to the numeric type being formatted.\n+     * @param newValue the maximum number of integer digits to be shown. The\n+     * concrete subclass may enforce an upper limit to this value appropriate to\n+     * the numeric type being formatted.\n@@ -951,1 +952,1 @@\n-     * number.\n+     * number during formatting.\n@@ -962,4 +963,5 @@\n-     * number. minimumIntegerDigits must be &le; maximumIntegerDigits.  If the\n-     * new value for minimumIntegerDigits exceeds the current value\n-     * of maximumIntegerDigits, then maximumIntegerDigits will also be set to\n-     * the new value\n+     * number during formatting. {@code minimumIntegerDigits} must be &le;\n+     * {@code maximumIntegerDigits}. If the new value for {@code minimumIntegerDigits}\n+     * exceeds the current value of {@code maximumIntegerDigits}, then {@code\n+     * maximumIntegerDigits} will also be set to the new value. Negative input\n+     * values are replaced with 0.\n@@ -967,3 +969,3 @@\n-     * @param newValue the minimum number of integer digits to be shown; if\n-     * less than zero, then zero is used. The concrete subclass may enforce an\n-     * upper limit to this value appropriate to the numeric type being formatted.\n+     * @param newValue the minimum number of integer digits to be shown. The\n+     * concrete subclass may enforce an upper limit to this value appropriate to\n+     * the numeric type being formatted.\n@@ -981,1 +983,1 @@\n-     * number.\n+     * number during formatting.\n@@ -992,4 +994,5 @@\n-     * number. maximumFractionDigits must be &ge; minimumFractionDigits.  If the\n-     * new value for maximumFractionDigits is less than the current value\n-     * of minimumFractionDigits, then minimumFractionDigits will also be set to\n-     * the new value.\n+     * number during formatting. {@code maximumFractionDigits} must be &ge;\n+     * {@code minimumFractionDigits}. If the new value for {@code maximumFractionDigits}\n+     * is less than the current value of {@code minimumFractionDigits}, then\n+     * {@code minimumFractionDigits} will also be set to the new value. Negative\n+     * input values are replaced with 0.\n@@ -997,3 +1000,3 @@\n-     * @param newValue the maximum number of fraction digits to be shown; if\n-     * less than zero, then zero is used. The concrete subclass may enforce an\n-     * upper limit to this value appropriate to the numeric type being formatted.\n+     * @param newValue the maximum number of fraction digits to be shown. The\n+     * concrete subclass may enforce an upper limit to this value appropriate to\n+     * the numeric type being formatted.\n@@ -1011,1 +1014,1 @@\n-     * number.\n+     * number during formatting.\n@@ -1022,4 +1025,5 @@\n-     * number. minimumFractionDigits must be &le; maximumFractionDigits.  If the\n-     * new value for minimumFractionDigits exceeds the current value\n-     * of maximumFractionDigits, then maximumFractionDigits will also be set to\n-     * the new value\n+     * number during formatting. {@code minimumFractionDigits} must be &le;\n+     * {@code maximumFractionDigits}. If the new value for {@code\n+     * minimumFractionDigits} exceeds the current value of {@code\n+     * maximumFractionDigits}, then {@code maximumFractionDigits} will also be\n+     * set to the new value. Negative input values are replaced with 0.\n@@ -1027,3 +1031,3 @@\n-     * @param newValue the minimum number of fraction digits to be shown; if\n-     * less than zero, then zero is used. The concrete subclass may enforce an\n-     * upper limit to this value appropriate to the numeric type being formatted.\n+     * @param newValue the minimum number of fraction digits to be shown. The\n+     * concrete subclass may enforce an upper limit to this value appropriate to\n+     * the numeric type being formatted.\n","filename":"src\/java.base\/share\/classes\/java\/text\/NumberFormat.java","additions":39,"deletions":35,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.function.Supplier;\n@@ -144,1 +145,2 @@\n-    private static HashSet<Currency> available;\n+    private static final Supplier<HashSet<Currency>> available =\n+            StableValue.supplier(Currency::computeAllCurrencies);\n@@ -450,1 +452,1 @@\n-        return new HashSet<>(getCurrencies());\n+        return new HashSet<>(available.get());\n@@ -465,1 +467,1 @@\n-        return getCurrencies().stream();\n+        return available.get().stream();\n@@ -468,36 +470,35 @@\n-    \/\/ Returns the set of available Currencies which are lazily initialized\n-    private static synchronized HashSet<Currency> getCurrencies() {\n-        if (available == null) {\n-            var sysTime = System.currentTimeMillis();\n-            available = HashSet.newHashSet(256);\n-\n-            \/\/ Add simple currencies first\n-            for (char c1 = 'A'; c1 <= 'Z'; c1 ++) {\n-                for (char c2 = 'A'; c2 <= 'Z'; c2 ++) {\n-                    int tableEntry = getMainTableEntry(c1, c2);\n-                    if ((tableEntry & COUNTRY_TYPE_MASK) == SIMPLE_CASE_COUNTRY_MASK\n-                            && tableEntry != INVALID_COUNTRY_ENTRY) {\n-                        char finalChar = (char) ((tableEntry & SIMPLE_CASE_COUNTRY_FINAL_CHAR_MASK) + 'A');\n-                        int defaultFractionDigits = (tableEntry & SIMPLE_CASE_COUNTRY_DEFAULT_DIGITS_MASK) >> SIMPLE_CASE_COUNTRY_DEFAULT_DIGITS_SHIFT;\n-                        int numericCode = (tableEntry & NUMERIC_CODE_MASK) >> NUMERIC_CODE_SHIFT;\n-                        StringBuilder sb = new StringBuilder();\n-                        sb.append(c1);\n-                        sb.append(c2);\n-                        sb.append(finalChar);\n-                        available.add(getInstance(sb.toString(), defaultFractionDigits, numericCode));\n-                    } else if ((tableEntry & COUNTRY_TYPE_MASK) == SPECIAL_CASE_COUNTRY_MASK\n-                            && tableEntry != INVALID_COUNTRY_ENTRY\n-                            && tableEntry != COUNTRY_WITHOUT_CURRENCY_ENTRY) {\n-                        int index = SpecialCaseEntry.toIndex(tableEntry);\n-                        SpecialCaseEntry scEntry = specialCasesList.get(index);\n-\n-                        if (scEntry.cutOverTime == Long.MAX_VALUE\n-                                || sysTime < scEntry.cutOverTime) {\n-                            available.add(getInstance(scEntry.oldCurrency,\n-                                    scEntry.oldCurrencyFraction,\n-                                    scEntry.oldCurrencyNumericCode));\n-                        } else {\n-                            available.add(getInstance(scEntry.newCurrency,\n-                                    scEntry.newCurrencyFraction,\n-                                    scEntry.newCurrencyNumericCode));\n-                        }\n+    \/\/ Builds and returns the set of available Currencies\n+    private static HashSet<Currency> computeAllCurrencies() {\n+        var sysTime = System.currentTimeMillis();\n+        HashSet<Currency> available = HashSet.newHashSet(256);\n+\n+        for (char c1 = 'A'; c1 <= 'Z'; c1 ++) {\n+            for (char c2 = 'A'; c2 <= 'Z'; c2 ++) {\n+                int tableEntry = getMainTableEntry(c1, c2);\n+                if ((tableEntry & COUNTRY_TYPE_MASK) == SIMPLE_CASE_COUNTRY_MASK\n+                        && tableEntry != INVALID_COUNTRY_ENTRY) {\n+                    \/\/ Simple Currencies\n+                    char finalChar = (char) ((tableEntry & SIMPLE_CASE_COUNTRY_FINAL_CHAR_MASK) + 'A');\n+                    int defaultFractionDigits = (tableEntry & SIMPLE_CASE_COUNTRY_DEFAULT_DIGITS_MASK) >> SIMPLE_CASE_COUNTRY_DEFAULT_DIGITS_SHIFT;\n+                    int numericCode = (tableEntry & NUMERIC_CODE_MASK) >> NUMERIC_CODE_SHIFT;\n+                    StringBuilder sb = new StringBuilder();\n+                    sb.append(c1);\n+                    sb.append(c2);\n+                    sb.append(finalChar);\n+                    available.add(getInstance(sb.toString(), defaultFractionDigits, numericCode));\n+                } else if ((tableEntry & COUNTRY_TYPE_MASK) == SPECIAL_CASE_COUNTRY_MASK\n+                        && tableEntry != INVALID_COUNTRY_ENTRY\n+                        && tableEntry != COUNTRY_WITHOUT_CURRENCY_ENTRY) {\n+                    \/\/ Special Currencies\n+                    int index = SpecialCaseEntry.toIndex(tableEntry);\n+                    SpecialCaseEntry scEntry = specialCasesList.get(index);\n+\n+                    if (scEntry.cutOverTime == Long.MAX_VALUE\n+                            || sysTime < scEntry.cutOverTime) {\n+                        available.add(getInstance(scEntry.oldCurrency,\n+                                scEntry.oldCurrencyFraction,\n+                                scEntry.oldCurrencyNumericCode));\n+                    } else {\n+                        available.add(getInstance(scEntry.newCurrency,\n+                                scEntry.newCurrencyFraction,\n+                                scEntry.newCurrencyNumericCode));\n@@ -507,0 +508,1 @@\n+        }\n@@ -508,4 +510,3 @@\n-            \/\/ Now add other currencies\n-            for (OtherCurrencyEntry entry : otherCurrenciesList) {\n-                available.add(getInstance(entry.currencyCode));\n-            }\n+        \/\/ Other Currencies\n+        for (OtherCurrencyEntry entry : otherCurrenciesList) {\n+            available.add(getInstance(entry.currencyCode));\n","filename":"src\/java.base\/share\/classes\/java\/util\/Currency.java","additions":44,"deletions":43,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import jdk.internal.util.NullableKeyValueHolder;\n@@ -140,1 +139,2 @@\n-                    return ImmutableCollections.stableList(size, mapper);\n+                    \/\/ A stable list is not Serializable, so we cannot return `List.of()` if `size == 0`\n+                    return new StableList<>(size, mapper);\n@@ -143,0 +143,1 @@\n+                    \/\/ A stable map is not Serializable, so we cannot return `Map.of()` if `keys.isEmpty()`\n@@ -267,5 +268,0 @@\n-    static <E> List<E> stableList(int size, IntFunction<? extends E> mapper) {\n-        \/\/ A lazy list is not Serializable so, we cannot return `List.of()` if size == 0\n-        return new StableList<>(size, mapper);\n-    }\n-\n@@ -457,1 +453,1 @@\n-    static final class SubList<E> extends AbstractImmutableList<E>\n+    static sealed class SubList<E> extends AbstractImmutableList<E>\n@@ -461,1 +457,1 @@\n-        private final AbstractImmutableList<E> root;\n+        final AbstractImmutableList<E> root;\n@@ -464,1 +460,1 @@\n-        private final int offset;\n+        final int offset;\n@@ -467,1 +463,1 @@\n-        private final int size;\n+        final int size;\n@@ -520,3 +516,2 @@\n-        private boolean allowNulls() {\n-            return root instanceof ListN<?> listN && listN.allowNulls\n-                    || root instanceof StableList<E>;\n+        boolean allowNulls() {\n+            return root instanceof ListN<?> listN && listN.allowNulls;\n@@ -575,8 +570,0 @@\n-        @Override\n-        public String toString() {\n-            if (root instanceof StableList<E> stableList) {\n-                return StableUtil.renderElements(root, \"StableList\", stableList.delegates, offset, size);\n-            } else {\n-                return super.toString();\n-            }\n-        }\n@@ -800,0 +787,5 @@\n+    @FunctionalInterface\n+    interface HasStableDelegates<E> {\n+        StableValueImpl<E>[] delegates();\n+    }\n+\n@@ -801,1 +793,3 @@\n-    static final class StableList<E> extends AbstractImmutableList<E> {\n+    static final class StableList<E>\n+            extends AbstractImmutableList<E>\n+            implements HasStableDelegates<E> {\n@@ -881,0 +875,6 @@\n+        @Override\n+        public List<E> subList(int fromIndex, int toIndex) {\n+            subListRangeCheck(fromIndex, toIndex, size());\n+            return StableSubList.fromStableList(this, fromIndex, toIndex);\n+        }\n+\n@@ -883,1 +883,1 @@\n-            return StableUtil.renderElements(this, \"StableList\", delegates);\n+            return StableUtil.renderElements(this, \"StableCollection\", delegates);\n@@ -886,1 +886,53 @@\n-        private static final class StableReverseOrderListView<E> extends ReverseOrderListView.Rand<E> {\n+        @Override\n+        public StableValueImpl<E>[] delegates() {\n+            return delegates;\n+        }\n+\n+        private static final class StableSubList<E> extends SubList<E>\n+                implements HasStableDelegates<E> {\n+\n+            private StableSubList(AbstractImmutableList<E> root, int offset, int size) {\n+                super(root, offset, size);\n+            }\n+\n+            @Override\n+            public List<E> reversed() {\n+                return new StableReverseOrderListView<>(this);\n+            }\n+\n+            @Override\n+            public List<E> subList(int fromIndex, int toIndex) {\n+                subListRangeCheck(fromIndex, toIndex, size());\n+                return StableSubList.fromStableSubList(this, fromIndex, toIndex);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return StableUtil.renderElements(this, \"StableCollection\", delegates());\n+            }\n+\n+            @Override\n+            boolean allowNulls() {\n+                return true;\n+            }\n+\n+            @Override\n+            public StableValueImpl<E>[] delegates() {\n+                @SuppressWarnings(\"unchecked\")\n+                final var rootDelegates = ((HasStableDelegates<E>) root).delegates();\n+                return Arrays.copyOfRange(rootDelegates, offset, offset + size);\n+            }\n+\n+            static <E> SubList<E> fromStableList(StableList<E> list, int fromIndex, int toIndex) {\n+                return new StableSubList<>(list, fromIndex, toIndex - fromIndex);\n+            }\n+\n+            static <E> SubList<E> fromStableSubList(StableSubList<E> parent, int fromIndex, int toIndex) {\n+                return new StableSubList<>(parent.root, parent.offset + fromIndex, toIndex - fromIndex);\n+            }\n+\n+        }\n+\n+        private static final class StableReverseOrderListView<E>\n+                extends ReverseOrderListView.Rand<E>\n+                implements HasStableDelegates<E> {\n@@ -895,4 +947,1 @@\n-                final StableValueImpl<E>[] delegates = ((StableList<E>)base).delegates;\n-                final StableValueImpl<E>[] reversed = ArraysSupport.reverse(\n-                        Arrays.copyOf(delegates, delegates.length));\n-                return StableUtil.renderElements(base, \"Collection\", reversed);\n+                return StableUtil.renderElements(this, \"StableCollection\", delegates());\n@@ -902,2 +951,4 @@\n-            public List<E> reversed() {\n-                return base;\n+            public List<E> subList(int fromIndex, int toIndex) {\n+                final int size = base.size();\n+                subListRangeCheck(fromIndex, toIndex, size);\n+                return new StableReverseOrderListView<>(base.subList(size - toIndex, size - fromIndex));\n@@ -906,0 +957,7 @@\n+            @Override\n+            public StableValueImpl<E>[] delegates() {\n+                @SuppressWarnings(\"unchecked\")\n+                final var baseDelegates = ((HasStableDelegates<E>) base).delegates();\n+                return ArraysSupport.reverse(\n+                        Arrays.copyOf(baseDelegates, baseDelegates.length));\n+            }\n@@ -1563,1 +1621,1 @@\n-        @Override public Set<Map.Entry<K, V>> entrySet() { return new StableMapEntrySet(); }\n+        @Override public Set<Map.Entry<K, V>> entrySet() { return StableMapEntrySet.of(this); }\n@@ -1585,1 +1643,6 @@\n-        final class StableMapEntrySet extends AbstractImmutableSet<Map.Entry<K, V>> {\n+        static final class StableMapEntrySet<K, V> extends AbstractImmutableSet<Map.Entry<K, V>> {\n+\n+            \/\/ Use a separate field for the outer class in order to facilitate\n+            \/\/ a @Stable annotation.\n+            @Stable\n+            private final StableMap<K, V> outer;\n@@ -1590,2 +1653,3 @@\n-            StableMapEntrySet() {\n-                this.delegateEntrySet = delegate.entrySet();\n+            private StableMapEntrySet(StableMap<K, V> outer) {\n+                this.outer = outer;\n+                this.delegateEntrySet = outer.delegate.entrySet();\n@@ -1594,1 +1658,1 @@\n-            @Override public Iterator<Map.Entry<K, V>> iterator() { return new LazyMapIterator(); }\n+            @Override public Iterator<Map.Entry<K, V>> iterator() { return LazyMapIterator.of(this); }\n@@ -1596,1 +1660,1 @@\n-            @Override public int                       hashCode() { return StableMap.this.hashCode(); }\n+            @Override public int                       hashCode() { return outer.hashCode(); }\n@@ -1600,1 +1664,6 @@\n-                return StableUtil.renderMappings(this, \"StableSet\", delegateEntrySet, false);\n+                return StableUtil.renderMappings(this, \"StableCollection\", delegateEntrySet, false);\n+            }\n+\n+            \/\/ For @ValueBased\n+            private static <K, V> StableMapEntrySet<K, V> of(StableMap<K, V> outer) {\n+                return new StableMapEntrySet<>(outer);\n@@ -1604,1 +1673,6 @@\n-            final class LazyMapIterator implements Iterator<Map.Entry<K, V>> {\n+            static final class LazyMapIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n+\n+                \/\/ Use a separate field for the outer class in order to facilitate\n+                \/\/ a @Stable annotation.\n+                @Stable\n+                private final StableMapEntrySet<K, V> outer;\n@@ -1609,2 +1683,3 @@\n-                LazyMapIterator() {\n-                    this.delegateIterator = delegateEntrySet.iterator();\n+                private LazyMapIterator(StableMapEntrySet<K, V> outer) {\n+                    this.outer = outer;\n+                    this.delegateIterator = outer.delegateEntrySet.iterator();\n@@ -1619,2 +1694,2 @@\n-                    return new NullableKeyValueHolder<>(k, inner.getValue().orElseSet(new Supplier<V>() {\n-                        @Override public V get() { return mapper.apply(k); }}));\n+                    return new StableEntry<>(k, inner.getValue(), new Supplier<V>() {\n+                        @Override public V get() { return outer.outer.mapper.apply(k); }});\n@@ -1630,2 +1705,2 @@\n-                                    action.accept(new NullableKeyValueHolder<>(k, inner.getValue().orElseSet(new Supplier<V>() {\n-                                        @Override public V get() { return mapper.apply(k); }})));\n+                                    action.accept(new StableEntry<>(k, inner.getValue(), new Supplier<V>() {\n+                                        @Override public V get() { return outer.outer.mapper.apply(k); }}));\n@@ -1636,0 +1711,6 @@\n+\n+                \/\/ For @ValueBased\n+                private static  <K, V> LazyMapIterator<K, V> of(StableMapEntrySet<K, V> outer) {\n+                    return new LazyMapIterator<>(outer);\n+                }\n+\n@@ -1639,0 +1720,18 @@\n+        private record StableEntry<K, V>(K getKey, \/\/ trick\n+                                         StableValueImpl<V> stableValue,\n+                                         Supplier<? extends V> supplier) implements Map.Entry<K, V> {\n+\n+            @Override public V setValue(V value) { throw uoe(); }\n+            @Override public V getValue() { return stableValue.orElseSet(supplier); }\n+            @Override public int hashCode() { return hash(getKey()) ^ hash(getValue()); }\n+            @Override public String toString() { return getKey() + \"=\" + stableValue.toString(); }\n+            @Override public boolean equals(Object o) {\n+                return o instanceof Map.Entry<?, ?> e\n+                        && Objects.equals(getKey(), e.getKey())\n+                        \/\/ Invoke `getValue()` as late as possible to avoid evaluation\n+                        && Objects.equals(getValue(), e.getValue());\n+            }\n+\n+            private int hash(Object obj) { return (obj == null) ? 0 : obj.hashCode(); }\n+        }\n+\n@@ -1641,1 +1740,1 @@\n-            return new StableMapValues();\n+            return StableMapValues.of(this);\n@@ -1644,5 +1743,16 @@\n-        final class StableMapValues extends AbstractImmutableCollection<V> {\n-            @Override public Iterator<V> iterator() { return new ValueIterator(); }\n-            @Override public int size() { return StableMap.this.size(); }\n-            @Override public boolean isEmpty() { return StableMap.this.isEmpty();}\n-            @Override public boolean contains(Object v) { return StableMap.this.containsValue(v); }\n+        @jdk.internal.ValueBased\n+        static final class StableMapValues<V> extends AbstractImmutableCollection<V> {\n+\n+            \/\/ Use a separate field for the outer class in order to facilitate\n+            \/\/ a @Stable annotation.\n+            @Stable\n+            private final StableMap<?, V> outer;\n+\n+            private StableMapValues(StableMap<?, V> outer) {\n+                this.outer = outer;\n+            }\n+\n+            @Override public Iterator<V> iterator() { return outer.new ValueIterator(); }\n+            @Override public int size() { return outer.size(); }\n+            @Override public boolean isEmpty() { return outer.isEmpty();}\n+            @Override public boolean contains(Object v) { return outer.containsValue(v); }\n@@ -1659,2 +1769,7 @@\n-                final StableValueImpl<?>[] values = delegate.values().toArray(GENERATOR);\n-                return StableUtil.renderElements(StableMap.this, \"StableMap\", values);\n+                final StableValueImpl<?>[] values = outer.delegate.values().toArray(GENERATOR);\n+                return StableUtil.renderElements(this, \"StableCollection\", values);\n+            }\n+\n+            \/\/ For @ValueBased\n+            private static <V> StableMapValues<V> of(StableMap<?, V> outer) {\n+                return new StableMapValues<>(outer);\n@@ -1662,0 +1777,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":169,"deletions":53,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -42,0 +43,1 @@\n+    @Stable\n@@ -43,1 +45,2 @@\n-    final boolean modifiable;\n+    @Stable\n+    final Boolean modifiable;\n","filename":"src\/java.base\/share\/classes\/java\/util\/ReverseOrderListView.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.concurrent.StructuredTaskScope.Joiner;\n+import java.util.concurrent.StructuredTaskScope.Subtask;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.internal.invoke.MhUtil;\n+\n+\/**\n+ * Built-in StructuredTaskScope.Joiner implementations.\n+ *\/\n+class Joiners {\n+    private Joiners() { }\n+\n+    \/**\n+     * Throws IllegalArgumentException if the subtask is not in the UNAVAILABLE state.\n+     *\/\n+    private static void ensureUnavailable(Subtask<?> subtask) {\n+        if (subtask.state() != Subtask.State.UNAVAILABLE) {\n+            throw new IllegalArgumentException(\"Subtask not in UNAVAILABLE state\");\n+        }\n+    }\n+\n+    \/**\n+     * Throws IllegalArgumentException if the subtask has not completed.\n+     *\/\n+    private static Subtask.State ensureCompleted(Subtask<?> subtask) {\n+        Subtask.State state = subtask.state();\n+        if (state == Subtask.State.UNAVAILABLE) {\n+            throw new IllegalArgumentException(\"Subtask has not completed\");\n+        }\n+        return state;\n+    }\n+\n+    \/**\n+     * A joiner that returns a stream of all subtasks when all subtasks complete\n+     * successfully. Cancels the scope if any subtask fails.\n+     *\/\n+    static final class AllSuccessful<T> implements Joiner<T, Stream<Subtask<T>>> {\n+        private static final VarHandle FIRST_EXCEPTION =\n+                MhUtil.findVarHandle(MethodHandles.lookup(), \"firstException\", Throwable.class);\n+\n+        \/\/ list of forked subtasks, only accessed by owner thread\n+        private final List<Subtask<T>> subtasks = new ArrayList<>();\n+\n+        private volatile Throwable firstException;\n+\n+        @Override\n+        public boolean onFork(Subtask<? extends T> subtask) {\n+            ensureUnavailable(subtask);\n+            @SuppressWarnings(\"unchecked\")\n+            var s = (Subtask<T>) subtask;\n+            subtasks.add(s);\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean onComplete(Subtask<? extends T> subtask) {\n+            Subtask.State state = ensureCompleted(subtask);\n+            return (state == Subtask.State.FAILED)\n+                    && (firstException == null)\n+                    && FIRST_EXCEPTION.compareAndSet(this, null, subtask.exception());\n+        }\n+\n+        @Override\n+        public Stream<Subtask<T>> result() throws Throwable {\n+            Throwable ex = firstException;\n+            if (ex != null) {\n+                throw ex;\n+            } else {\n+                return subtasks.stream();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A joiner that returns the result of the first subtask to complete successfully.\n+     * Cancels the scope if any subtasks succeeds.\n+     *\/\n+    static final class AnySuccessful<T> implements Joiner<T, T> {\n+        private static final VarHandle SUBTASK =\n+                MhUtil.findVarHandle(MethodHandles.lookup(), \"subtask\", Subtask.class);\n+\n+        \/\/ UNAVAILABLE < FAILED < SUCCESS\n+        private static final Comparator<Subtask.State> SUBTASK_STATE_COMPARATOR =\n+                Comparator.comparingInt(AnySuccessful::stateToInt);\n+\n+        private volatile Subtask<T> subtask;\n+\n+        \/**\n+         * Maps a Subtask.State to an int that can be compared.\n+         *\/\n+        private static int stateToInt(Subtask.State s) {\n+            return switch (s) {\n+                case UNAVAILABLE -> 0;\n+                case FAILED      -> 1;\n+                case SUCCESS     -> 2;\n+            };\n+        }\n+\n+        @Override\n+        public boolean onComplete(Subtask<? extends T> subtask) {\n+            Subtask.State state = ensureCompleted(subtask);\n+            Subtask<T> s;\n+            while (((s = this.subtask) == null)\n+                    || SUBTASK_STATE_COMPARATOR.compare(s.state(), state) < 0) {\n+                if (SUBTASK.compareAndSet(this, s, subtask)) {\n+                    return (state == Subtask.State.SUCCESS);\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public T result() throws Throwable {\n+            Subtask<T> subtask = this.subtask;\n+            if (subtask == null) {\n+                throw new NoSuchElementException(\"No subtasks completed\");\n+            }\n+            return switch (subtask.state()) {\n+                case SUCCESS -> subtask.get();\n+                case FAILED  -> throw subtask.exception();\n+                default      -> throw new InternalError();\n+            };\n+        }\n+    }\n+\n+    \/**\n+     * A joiner that that waits for all successful subtasks. Cancels the scope if any\n+     * subtask fails.\n+     *\/\n+    static final class AwaitSuccessful<T> implements Joiner<T, Void> {\n+        private static final VarHandle FIRST_EXCEPTION =\n+                MhUtil.findVarHandle(MethodHandles.lookup(), \"firstException\", Throwable.class);\n+        private volatile Throwable firstException;\n+\n+        @Override\n+        public boolean onComplete(Subtask<? extends T> subtask) {\n+            Subtask.State state = ensureCompleted(subtask);\n+            return (state == Subtask.State.FAILED)\n+                    && (firstException == null)\n+                    && FIRST_EXCEPTION.compareAndSet(this, null, subtask.exception());\n+        }\n+\n+        @Override\n+        public Void result() throws Throwable {\n+            Throwable ex = firstException;\n+            if (ex != null) {\n+                throw ex;\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A joiner that returns a stream of all subtasks.\n+     *\/\n+    static final class AllSubtasks<T> implements Joiner<T, Stream<Subtask<T>>> {\n+        private final Predicate<Subtask<? extends T>> isDone;\n+\n+        \/\/ list of forked subtasks, only accessed by owner thread\n+        private final List<Subtask<T>> subtasks = new ArrayList<>();\n+\n+        AllSubtasks(Predicate<Subtask<? extends T>> isDone) {\n+            this.isDone = Objects.requireNonNull(isDone);\n+        }\n+\n+        @Override\n+        public boolean onFork(Subtask<? extends T> subtask) {\n+            ensureUnavailable(subtask);\n+            @SuppressWarnings(\"unchecked\")\n+            var s = (Subtask<T>) subtask;\n+            subtasks.add(s);\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean onComplete(Subtask<? extends T> subtask) {\n+            ensureCompleted(subtask);\n+            return isDone.test(subtask);\n+        }\n+\n+        @Override\n+        public Stream<Subtask<T>> result() {\n+            return subtasks.stream();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Joiners.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -30,4 +28,0 @@\n-import java.time.Instant;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.concurrent.locks.ReentrantLock;\n@@ -35,0 +29,1 @@\n+import java.util.function.Predicate;\n@@ -36,0 +31,1 @@\n+import java.util.stream.Stream;\n@@ -37,2 +33,0 @@\n-import jdk.internal.misc.ThreadFlock;\n-import jdk.internal.invoke.MhUtil;\n@@ -41,21 +35,22 @@\n- * A basic API for <em>structured concurrency<\/em>. {@code StructuredTaskScope} supports\n- * cases where a task splits into several concurrent subtasks, and where the subtasks must\n- * complete before the main task continues. A {@code StructuredTaskScope} can be used to\n- * ensure that the lifetime of a concurrent operation is confined by a <em>syntax block<\/em>,\n- * just like that of a sequential operation in structured programming.\n- *\n- * <h2>Basic operation<\/h2>\n- *\n- * A {@code StructuredTaskScope} is created with one of its public constructors. It defines\n- * the {@link #fork(Callable) fork} method to start a thread to execute a subtask, the {@link\n- * #join() join} method to wait for all subtasks to finish, and the {@link #close() close}\n- * method to close the task scope. The API is intended to be used with the {@code\n- * try-with-resources} statement. The intention is that code in the try <em>block<\/em>\n- * uses the {@code fork} method to fork threads to execute the subtasks, wait for the\n- * subtasks to finish with the {@code join} method, and then <em>process the results<\/em>.\n- * A call to the {@code fork} method returns a {@link Subtask Subtask} to representing\n- * the <em>forked subtask<\/em>. Once {@code join} is called, the {@code Subtask} can be\n- * used to get the result completed successfully, or the exception if the subtask failed.\n- * {@snippet lang=java :\n- *     Callable<String> task1 = ...\n- *     Callable<Integer> task2 = ...\n+ * An API for <em>structured concurrency<\/em>. {@code StructuredTaskScope} supports cases\n+ * where execution of a <em>task<\/em> (a unit of work) splits into several concurrent\n+ * subtasks, and where the subtasks must complete before the task continues. A {@code\n+ * StructuredTaskScope} can be used to ensure that the lifetime of a concurrent operation\n+ * is confined by a <em>syntax block<\/em>, similar to that of a sequential operation in\n+ * structured programming.\n+ *\n+ * <p> {@code StructuredTaskScope} defines the static method {@link #open() open} to open\n+ * a new {@code StructuredTaskScope} and the {@link #close() close} method to close it.\n+ * The API is designed to be used with the {@code try}-with-resources statement where\n+ * the {@code StructuredTaskScope} is opened as a resource and then closed automatically.\n+ * The code inside the block uses the {@link #fork(Callable) fork} method to fork subtasks.\n+ * After forking, it uses the {@link #join() join} method to wait for all subtasks to\n+ * finish (or some other outcome) as a single operation. Forking a subtask starts a new\n+ * {@link Thread} to run the subtask. The thread executing the task does not continue\n+ * beyond the {@code close} method until all threads started to execute subtasks have finished.\n+ * To ensure correct usage, the {@code fork}, {@code join} and {@code close} methods may\n+ * only be invoked by the <em>owner thread<\/em> (the thread that opened the {@code\n+ * StructuredTaskScope}), the {@code fork} method may not be called after {@code join},\n+ * the {@code join} method may only be invoked once, and the {@code close} method throws\n+ * an exception after closing if the owner did not invoke the {@code join} method after\n+ * forking subtasks.\n@@ -63,1 +58,9 @@\n- *     try (var scope = new StructuredTaskScope<Object>()) {\n+ * <p> As a first example, consider a task that splits into two subtasks to concurrently\n+ * fetch resources from two URL locations \"left\" and \"right\". Both subtasks may complete\n+ * successfully, one subtask may succeed and the other may fail, or both subtasks may\n+ * fail. The task in this example is interested in the successful result from both\n+ * subtasks. It waits in the {@link #join() join} method for both subtasks to complete\n+ * successfully or for either subtask to fail.\n+ * {@snippet lang=java :\n+ *    \/\/ @link substring=\"open\" target=\"#open()\" :\n+ *    try (var scope = StructuredTaskScope.open()) {\n@@ -65,2 +68,3 @@\n- *         Subtask<String> subtask1 = scope.fork(task1);   \/\/ @highlight substring=\"fork\"\n- *         Subtask<Integer> subtask2 = scope.fork(task2);  \/\/ @highlight substring=\"fork\"\n+ *        \/\/ @link substring=\"fork\" target=\"#fork(Callable)\" :\n+ *        Subtask<String> subtask1 = scope.fork(() -> query(left));\n+ *        Subtask<Integer> subtask2 = scope.fork(() -> query(right));\n@@ -68,1 +72,2 @@\n- *         scope.join();                                   \/\/ @highlight substring=\"join\"\n+ *        \/\/ throws if either subtask fails\n+ *        scope.join();  \/\/ @link substring=\"join\" target=\"#join()\"\n@@ -70,1 +75,3 @@\n- *         ... process results\/exceptions ...\n+ *        \/\/ both subtasks completed successfully\n+ *        \/\/ @link substring=\"get\" target=\"Subtask#get()\" :\n+ *        return new MyResult(subtask1.get(), subtask2.get());\n@@ -72,1 +79,2 @@\n- *     } \/\/ close                                          \/\/ @highlight substring=\"close\"\n+ *    \/\/ @link substring=\"close\" target=\"#close()\" :\n+ *    } \/\/ close\n@@ -74,6 +82,0 @@\n- * <p> The following example forks a collection of homogeneous subtasks, waits for all of\n- * them to complete with the {@code join} method, and uses the {@link Subtask.State\n- * Subtask.State} to partition the subtasks into a set of the subtasks that completed\n- * successfully and another for the subtasks that failed.\n- * {@snippet lang=java :\n- *     List<Callable<String>> callables = ...\n@@ -81,1 +83,18 @@\n- *     try (var scope = new StructuredTaskScope<String>()) {\n+ * <p> If both subtasks complete successfully then the {@code join} method completes\n+ * normally and the task uses the {@link Subtask#get() Subtask.get()} method to get\n+ * the result of each subtask. If one of the subtasks fails then the other subtask is\n+ * cancelled (this will {@linkplain Thread#interrupt() interrupt} the thread executing the\n+ * other subtask) and the {@code join} method throws {@link FailedException} with the\n+ * exception from the failed subtask as the {@linkplain Throwable#getCause() cause}.\n+ *\n+ * <p> To allow for cancellation, subtasks must be coded so that they finish as soon as\n+ * possible when interrupted. Subtasks that do not respond to interrupt, e.g. block on\n+ * methods that are not interruptible, may delay the closing of a scope indefinitely. The\n+ * {@link #close() close} method always waits for threads executing subtasks to finish,\n+ * even if the scope is cancelled, so execution cannot continue beyond the {@code close}\n+ * method until the interrupted threads finish.\n+ *\n+ * <p> In the example, the subtasks produce results of different types ({@code String} and\n+ * {@code Integer}). In other cases the subtasks may all produce results of the same type.\n+ * If the example had used {@code StructuredTaskScope.<String>open()} then it could\n+ * only be used to fork subtasks that return a {@code String} result.\n@@ -83,1 +102,1 @@\n- *         List<Subtask<String>> subtasks = callables.stream().map(scope::fork).toList();\n+ * <h2>Joiners<\/h2>\n@@ -85,1 +104,8 @@\n- *         scope.join();\n+ * <p> In the example above, the task fails if any subtask fails. If all subtasks\n+ * succeed then the {@code join} method completes normally. Other policy and outcome is\n+ * supported by creating a {@code StructuredTaskScope} with a {@link Joiner} that\n+ * implements the desired policy. A {@code Joiner} handles subtask completion and produces\n+ * the outcome for the {@link #join() join} method. In the example above, {@code join}\n+ * returns {@code null}. Depending on the {@code Joiner}, {@code join} may return a\n+ * result, a stream of elements, or some other object. The {@code Joiner} interface defines\n+ * factory methods to create {@code Joiner}s for some common cases.\n@@ -87,3 +113,10 @@\n- *         Map<Boolean, Set<Subtask<String>>> map = subtasks.stream()\n- *                 .collect(Collectors.partitioningBy(h -> h.state() == Subtask.State.SUCCESS,\n- *                                                    Collectors.toSet()));\n+ * <p> A {@code Joiner} may <a id=\"Cancallation\">cancel<\/a> the scope (sometimes called\n+ * \"short-circuiting\") when some condition is reached that does not require the result of\n+ * subtasks that are still executing. Cancelling the scope prevents new threads from being\n+ * started to execute further subtasks, {@linkplain Thread#interrupt() interrupts} the\n+ * threads executing subtasks that have not completed, and causes the {@code join} method\n+ * to wakeup with the outcome (result or exception). In the above example, the outcome is\n+ * that {@code join} completes with a result of {@code null} when all subtasks succeed.\n+ * The scope is cancelled if any of the subtasks fail and {@code join} throws {@code\n+ * FailedException} with the exception from the failed subtask as the cause. Other {@code\n+ * Joiner} implementations may cancel the scope for other reasons.\n@@ -91,1 +124,18 @@\n- *     } \/\/ close\n+ * <p> Now consider another example that splits into two subtasks. In this example,\n+ * each subtask produces a {@code String} result and the task is only interested in\n+ * the result from the first subtask to complete successfully. The example uses {@link\n+ * Joiner#anySuccessfulResultOrThrow() Joiner.anySuccessfulResultOrThrow()} to\n+ * create a {@code Joiner} that makes available the result of the first subtask to\n+ * complete successfully. The type parameter in the example is \"{@code String}\" so that\n+ * only subtasks that return a {@code String} can be forked.\n+ * {@snippet lang=java :\n+ *    \/\/ @link substring=\"open\" target=\"#open(Joiner)\" :\n+ *    try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow())) {\n+ *\n+ *        scope.fork(callable1);\n+ *        scope.fork(callable2);\n+ *\n+ *        \/\/ throws if both subtasks fail\n+ *        String firstResult = scope.join();\n+ *\n+ *    }\n@@ -94,42 +144,32 @@\n- * <p> To ensure correct usage, the {@code join} and {@code close} methods may only be\n- * invoked by the <em>owner<\/em> (the thread that opened\/created the task scope), and the\n- * {@code close} method throws an exception after closing if the owner did not invoke the\n- * {@code join} method after forking.\n- *\n- * <p> {@code StructuredTaskScope} defines the {@link #shutdown() shutdown} method to shut\n- * down a task scope without closing it. The {@code shutdown()} method <em>cancels<\/em> all\n- * unfinished subtasks by {@linkplain Thread#interrupt() interrupting} the threads. It\n- * prevents new threads from starting in the task scope. If the owner is waiting in the\n- * {@code join} method then it will wakeup.\n- *\n- * <p> Shutdown is used for <em>short-circuiting<\/em> and allow subclasses to implement\n- * <em>policy<\/em> that does not require all subtasks to finish.\n- *\n- * <h2>Subclasses with policies for common cases<\/h2>\n- *\n- * Two subclasses of {@code StructuredTaskScope} are defined to implement policy for\n- * common cases:\n- * <ol>\n- *   <li> {@link ShutdownOnSuccess ShutdownOnSuccess} captures the result of the first\n- *   subtask to complete successfully. Once captured, it shuts down the task scope to\n- *   interrupt unfinished threads and wakeup the owner. This class is intended for cases\n- *   where the result of any subtask will do (\"invoke any\") and where there is no need to\n- *   wait for results of other unfinished subtasks. It defines methods to get the first\n- *   result or throw an exception if all subtasks fail.\n- *   <li> {@link ShutdownOnFailure ShutdownOnFailure} captures the exception of the first\n- *   subtask to fail. Once captured, it shuts down the task scope to interrupt unfinished\n- *   threads and wakeup the owner. This class is intended for cases where the results of all\n- *   subtasks are required (\"invoke all\"); if any subtask fails then the results of other\n- *   unfinished subtasks are no longer needed. If defines methods to throw an exception if\n- *   any of the subtasks fail.\n- * <\/ol>\n- *\n- * <p> The following are two examples that use the two classes. In both cases, a pair of\n- * subtasks are forked to fetch resources from two URL locations \"left\" and \"right\". The\n- * first example creates a ShutdownOnSuccess object to capture the result of the first\n- * subtask to complete successfully, cancelling the other by way of shutting down the task\n- * scope. The main task waits in {@code join} until either subtask completes with a result\n- * or both subtasks fail. It invokes {@link ShutdownOnSuccess#result(Function)\n- * result(Function)} method to get the captured result. If both subtasks fail then this\n- * method throws a {@code WebApplicationException} with the exception from one of the\n- * subtasks as the cause.\n+ * <p> In the example, the task forks the two subtasks, then waits in the {@code\n+ * join} method for either subtask to complete successfully or for both subtasks to fail.\n+ * If one of the subtasks completes successfully then the {@code Joiner} causes the other\n+ * subtask to be cancelled (this will interrupt the thread executing the subtask), and\n+ * the {@code join} method returns the result from the successful subtask. Cancelling the\n+ * other subtask avoids the task waiting for a result that it doesn't care about. If\n+ * both subtasks fail then the {@code join} method throws {@code FailedException} with the\n+ * exception from one of the subtasks as the {@linkplain Throwable#getCause() cause}.\n+ *\n+ * <p> Whether code uses the {@code Subtask} returned from {@code fork} will depend on\n+ * the {@code Joiner} and usage. Some {@code Joiner} implementations are suited to subtasks\n+ * that return results of the same type and where the {@code join} method returns a result\n+ * for the task to use. Code that forks subtasks that return results of different\n+ * types, and uses a {@code Joiner} such as {@code Joiner.awaitAllSuccessfulOrThrow()} that\n+ * does not return a result, will use {@link Subtask#get() Subtask.get()} after joining.\n+ *\n+ * <h2>Exception handling<\/h2>\n+ *\n+ * <p> A {@code StructuredTaskScope} is opened with a {@link Joiner Joiner} that\n+ * handles subtask completion and produces the outcome for the {@link #join() join} method.\n+ * In some cases, the outcome will be a result, in other cases it will be an exception.\n+ * If the outcome is an exception then the {@code join} method throws {@link\n+ * FailedException} with the exception as the {@linkplain Throwable#getCause()\n+ * cause}. For many {@code Joiner} implementations, the exception will be an exception\n+ * thrown by a subtask that failed. In the case of {@link Joiner#allSuccessfulOrThrow()\n+ * allSuccessfulOrThrow} and {@link Joiner#awaitAllSuccessfulOrThrow() awaitAllSuccessfulOrThrow}\n+ * for example, the exception is from the first subtask to fail.\n+ *\n+ * <p> Many of the details for how exceptions are handled will depend on usage. In some\n+ * cases it may be useful to add a {@code catch} block to the {@code try}-with-resources\n+ * statement to catch {@code FailedException}. The exception handling may use {@code\n+ * instanceof} with pattern matching to handle specific causes.\n@@ -137,1 +177,1 @@\n- *     try (var scope = new StructuredTaskScope.ShutdownOnSuccess<String>()) {\n+ *    try (var scope = StructuredTaskScope.open()) {\n@@ -139,2 +179,1 @@\n- *         scope.fork(() -> fetch(left));\n- *         scope.fork(() -> fetch(right));\n+ *        ..\n@@ -142,1 +181,1 @@\n- *         scope.join();\n+ *    } catch (StructuredTaskScope.FailedException e) {\n@@ -144,2 +183,5 @@\n- *         \/\/ @link regex=\"result(?=\\()\" target=\"ShutdownOnSuccess#result\" :\n- *         String result = scope.result(e -> new WebApplicationException(e));\n+ *        Throwable cause = e.getCause();\n+ *        switch (cause) {\n+ *            case IOException ioe -> ..\n+ *            default -> ..\n+ *        }\n@@ -147,2 +189,1 @@\n- *         ...\n- *     }\n+ *    }\n@@ -150,12 +191,9 @@\n- * The second example creates a ShutdownOnFailure object to capture the exception of the\n- * first subtask to fail, cancelling the other by way of shutting down the task scope. The\n- * main task waits in {@link #joinUntil(Instant)} until both subtasks complete with a\n- * result, either fails, or a deadline is reached. It invokes {@link\n- * ShutdownOnFailure#throwIfFailed(Function) throwIfFailed(Function)} to throw an exception\n- * if either subtask fails. This method is a no-op if both subtasks complete successfully.\n- * The example uses {@link Supplier#get()} to get the result of each subtask. Using\n- * {@code Supplier} instead of {@code Subtask} is preferred for common cases where the\n- * object returned by fork is only used to get the result of a subtask that completed\n- * successfully.\n- * {@snippet lang=java :\n- *    Instant deadline = ...\n+ * In other cases it may not be useful to catch {@code FailedException} but instead leave\n+ * it to propagate to the configured {@linkplain Thread.UncaughtExceptionHandler uncaught\n+ * exception handler} for logging purposes.\n+ *\n+ * <p> For cases where a specific exception triggers the use of a default result then it\n+ * may be more appropriate to handle this in the subtask itself rather than the subtask\n+ * failing and the scope owner handling the exception.\n+ *\n+ * <h2>Configuration<\/h2>\n@@ -163,1 +201,0 @@\n- *    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n@@ -165,2 +202,3 @@\n- *         Supplier<String> supplier1 = scope.fork(() -> query(left));\n- *         Supplier<String> supplier2 = scope.fork(() -> query(right));\n+ * A {@code StructuredTaskScope} is opened with {@linkplain Configuration configuration}\n+ * that consists of a {@link ThreadFactory} to create threads, an optional name for\n+ * monitoring and management purposes, and an optional timeout.\n@@ -168,1 +206,5 @@\n- *         scope.joinUntil(deadline);\n+ * <p> The {@link #open()} and {@link #open(Joiner)} methods create a {@code StructuredTaskScope}\n+ * with the <a id=\"DefaultConfiguration\"> <em>default configuration<\/em><\/a>. The default\n+ * configuration has a {@code ThreadFactory} that creates unnamed\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>,\n+ * is unnamed for monitoring and management purposes, and has no timeout.\n@@ -170,2 +212,7 @@\n- *         \/\/ @link substring=\"throwIfFailed\" target=\"ShutdownOnFailure#throwIfFailed\" :\n- *         scope.throwIfFailed(e -> new WebApplicationException(e));\n+ * <p> The 2-arg {@link #open(Joiner, Function) open} method can be used to create a\n+ * {@code StructuredTaskScope} that uses a different {@code ThreadFactory}, has a name for\n+ * the purposes of monitoring and management, or has a timeout that cancels the scope if\n+ * the timeout expires before or while waiting for subtasks to complete. The {@code open}\n+ * method is called with a {@linkplain Function function} that is applied to the default\n+ * configuration and returns a {@link Configuration Configuration} for the\n+ * {@code StructuredTaskScope} under construction.\n@@ -173,4 +220,14 @@\n- *         \/\/ both subtasks completed successfully\n- *         String result = Stream.of(supplier1, supplier2)\n- *                 .map(Supplier::get)\n- *                 .collect(Collectors.joining(\", \", \"{ \", \" }\"));\n+ * <p> The following example opens a new {@code StructuredTaskScope} with a {@code\n+ * ThreadFactory} that creates virtual threads {@linkplain Thread#setName(String) named}\n+ * \"duke-0\", \"duke-1\" ...\n+ * {@snippet lang = java:\n+ *    \/\/ @link substring=\"name\" target=\"Thread.Builder#name(String, long)\" :\n+ *    ThreadFactory factory = Thread.ofVirtual().name(\"duke-\", 0).factory();\n+ *\n+ *    \/\/ @link substring=\"withThreadFactory\" target=\"Configuration#withThreadFactory(ThreadFactory)\" :\n+ *    try (var scope = StructuredTaskScope.open(joiner, cf -> cf.withThreadFactory(factory))) {\n+ *\n+ *        scope.fork( .. );   \/\/ runs in a virtual thread with name \"duke-0\"\n+ *        scope.fork( .. );   \/\/ runs in a virtual thread with name \"duke-1\"\n+ *\n+ *        scope.join();\n@@ -178,1 +235,0 @@\n- *         ...\n@@ -180,1 +236,1 @@\n- * }\n+ *}\n@@ -182,19 +238,5 @@\n- * <h2>Extending StructuredTaskScope<\/h2>\n- *\n- * {@code StructuredTaskScope} can be extended, and the {@link #handleComplete(Subtask)\n- * handleComplete} method overridden, to implement policies other than those implemented\n- * by {@code ShutdownOnSuccess} and {@code ShutdownOnFailure}. A subclass may, for example,\n- * collect the results of subtasks that complete successfully and ignore subtasks that\n- * fail. It may collect exceptions when subtasks fail. It may invoke the {@link #shutdown()\n- * shutdown} method to shut down and cause {@link #join() join} to wakeup when some\n- * condition arises.\n- *\n- * <p> A subclass will typically define methods to make available results, state, or other\n- * outcome to code that executes after the {@code join} method. A subclass that collects\n- * results and ignores subtasks that fail may define a method that returns the results.\n- * A subclass that implements a policy to shut down when a subtask fails may define a\n- * method to get the exception of the first subtask to fail.\n- *\n- * <p> The following is an example of a simple {@code StructuredTaskScope} implementation\n- * that collects homogenous subtasks that complete successfully. It defines the method\n- * \"{@code completedSuccessfully()}\" that the main task can invoke after it joins.\n+ * <p> A second example sets a timeout, represented by a {@link Duration}. The timeout\n+ * starts when the new scope is opened. If the timeout expires before the {@code join}\n+ * method has completed then the scope is <a href=\"#Cancallation\">cancelled<\/a>. This\n+ * interrupts the threads executing the two subtasks and causes the {@link #join() join}\n+ * method to throw {@link TimeoutException}.\n@@ -202,9 +244,1 @@\n- *     class CollectingScope<T> extends StructuredTaskScope<T> {\n- *         private final Queue<Subtask<? extends T>> subtasks = new LinkedTransferQueue<>();\n- *\n- *         @Override\n- *         protected void handleComplete(Subtask<? extends T> subtask) {\n- *             if (subtask.state() == Subtask.State.SUCCESS) {\n- *                 subtasks.add(subtask);\n- *             }\n- *         }\n+ *    Duration timeout = Duration.ofSeconds(10);\n@@ -212,5 +246,4 @@\n- *         @Override\n- *         public CollectingScope<T> join() throws InterruptedException {\n- *             super.join();\n- *             return this;\n- *         }\n+ *    \/\/ @link substring=\"allSuccessfulOrThrow\" target=\"Joiner#allSuccessfulOrThrow()\" :\n+ *    try (var scope = StructuredTaskScope.open(Joiner.<String>allSuccessfulOrThrow(),\n+ *    \/\/ @link substring=\"withTimeout\" target=\"Configuration#withTimeout(Duration)\" :\n+ *                                              cf -> cf.withTimeout(timeout))) {\n@@ -218,6 +251,8 @@\n- *         public Stream<Subtask<? extends T>> completedSuccessfully() {\n- *             \/\/ @link substring=\"ensureOwnerAndJoined\" target=\"ensureOwnerAndJoined\" :\n- *             super.ensureOwnerAndJoined();\n- *             return subtasks.stream();\n- *         }\n- *     }\n+ *        scope.fork(callable1);\n+ *        scope.fork(callable2);\n+ *\n+ *        List<String> result = scope.join()\n+ *                                   .map(Subtask::get)\n+ *                                   .toList();\n+ *\n+ *   }\n@@ -225,34 +260,38 @@\n- * <p> The implementations of the {@code completedSuccessfully()} method in the example\n- * invokes {@link #ensureOwnerAndJoined()} to ensure that the method can only be invoked\n- * by the owner thread and only after it has joined.\n- *\n- * <h2><a id=\"TreeStructure\">Tree structure<\/a><\/h2>\n- *\n- * Task scopes form a tree where parent-child relations are established implicitly when\n- * opening a new task scope:\n- * <ul>\n- *   <li> A parent-child relation is established when a thread started in a task scope\n- *   opens its own task scope. A thread started in task scope \"A\" that opens task scope\n- *   \"B\" establishes a parent-child relation where task scope \"A\" is the parent of task\n- *   scope \"B\".\n- *   <li> A parent-child relation is established with nesting. If a thread opens task\n- *   scope \"B\", then opens task scope \"C\" (before it closes \"B\"), then the enclosing task\n- *   scope \"B\" is the parent of the nested task scope \"C\".\n- * <\/ul>\n- *\n- * The <i>descendants<\/i> of a task scope are the child task scopes that it is a parent\n- * of, plus the descendants of the child task scopes, recursively.\n- *\n- * <p> The tree structure supports:\n- * <ul>\n- *   <li> Inheritance of {@linkplain ScopedValue scoped values} across threads.\n- *   <li> Confinement checks. The phrase \"threads contained in the task scope\" in method\n- *   descriptions means threads started in the task scope or descendant scopes.\n- * <\/ul>\n- *\n- * <p> The following example demonstrates the inheritance of a scoped value. A scoped\n- * value {@code USERNAME} is bound to the value \"{@code duke}\". A {@code StructuredTaskScope}\n- * is created and its {@code fork} method invoked to start a thread to execute {@code\n- * childTask}. The thread inherits the scoped value <em>bindings<\/em> captured when\n- * creating the task scope. The code in {@code childTask} uses the value of the scoped\n- * value and so reads the value \"{@code duke}\".\n+ *\n+ * <h2>Inheritance of scoped value bindings<\/h2>\n+ *\n+ * {@link ScopedValue} supports the execution of a method with a {@code ScopedValue} bound\n+ * to a value for the bounded period of execution of the method by the <em>current thread<\/em>.\n+ * It allows a value to be safely and efficiently shared to methods without using method\n+ * parameters.\n+ *\n+ * <p> When used in conjunction with a {@code StructuredTaskScope}, a {@code ScopedValue}\n+ * can also safely and efficiently share a value to methods executed by subtasks forked\n+ * in the scope. When a {@code ScopedValue} object is bound to a value in the thread\n+ * executing the task then that binding is inherited by the threads created to\n+ * execute the subtasks. The thread executing the task does not continue beyond the\n+ * {@link #close() close} method until all threads executing the subtasks have finished.\n+ * This ensures that the {@code ScopedValue} is not reverted to being {@linkplain\n+ * ScopedValue#isBound() unbound} (or its previous value) while subtasks are executing.\n+ * In addition to providing a safe and efficient means to inherit a value into subtasks,\n+ * the inheritance allows sequential code using {@code ScopedValue} be refactored to use\n+ * structured concurrency.\n+ *\n+ * <p> To ensure correctness, opening a new {@code StructuredTaskScope} captures the\n+ * current thread's scoped value bindings. These are the scoped values bindings that are\n+ * inherited by the threads created to execute subtasks in the scope. Forking a\n+ * subtask checks that the bindings in effect at the time that the subtask is forked\n+ * match the bindings when the {@code StructuredTaskScope} was created. This check ensures\n+ * that a subtask does not inherit a binding that is reverted in the task before the\n+ * subtask has completed.\n+ *\n+ * <p> A {@code ScopedValue} that is shared across threads requires that the value be an\n+ * immutable object or for all access to the value to be appropriately synchronized.\n+ *\n+ * <p> The following example demonstrates the inheritance of scoped value bindings. The\n+ * scoped value USERNAME is bound to the value \"duke\" for the bounded period of a lambda\n+ * expression by the thread executing it. The code in the block opens a {@code\n+ * StructuredTaskScope} and forks two subtasks, it then waits in the {@code join} method\n+ * and aggregates the results from both subtasks. If code executed by the threads\n+ * running subtask1 and subtask2 uses {@link ScopedValue#get()}, to get the value of\n+ * USERNAME, then value \"duke\" will be returned.\n@@ -260,0 +299,1 @@\n+ *     \/\/ @link substring=\"newInstance\" target=\"ScopedValue#newInstance()\" :\n@@ -262,3 +302,2 @@\n- *     \/\/ @link substring=\"run\" target=\"ScopedValue.Carrier#run(Runnable)\" :\n- *     ScopedValue.where(USERNAME, \"duke\").run(() -> {\n- *         try (var scope = new StructuredTaskScope<String>()) {\n+ *     \/\/ @link substring=\"where\" target=\"ScopedValue#where(ScopedValue, Object)\" :\n+ *     MyResult result = ScopedValue.where(USERNAME, \"duke\").call(() -> {\n@@ -266,4 +305,1 @@\n- *             scope.fork(() -> childTask());           \/\/ @highlight substring=\"fork\"\n- *             ...\n- *          }\n- *     });\n+ *         try (var scope = StructuredTaskScope.open()) {\n@@ -271,1 +307,2 @@\n- *     ...\n+ *             Subtask<String> subtask1 = scope.fork( .. );    \/\/ inherits binding\n+ *             Subtask<Integer> subtask2 = scope.fork( .. );   \/\/ inherits binding\n@@ -273,5 +310,5 @@\n- *     String childTask() {\n- *         \/\/ @link substring=\"get\" target=\"ScopedValue#get()\" :\n- *         String name = USERNAME.get();   \/\/ \"duke\"\n- *         ...\n- *     }\n+ *             scope.join();\n+ *             return new MyResult(subtask1.get(), subtask2.get());\n+ *         }\n+ *\n+ *     });\n@@ -280,2 +317,5 @@\n- * <p> {@code StructuredTaskScope} does not define APIs that exposes the tree structure\n- * at this time.\n+ * <p> A scoped value inherited into a subtask may be\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/ScopedValue.html#rebind\">rebound<\/a> to a new\n+ * value in the subtask for the bounded execution of some method executed in the subtask.\n+ * When the method completes, the value of the {@code ScopedValue} reverts to its previous\n+ * value, the value inherited from the thread executing the task.\n@@ -283,2 +323,8 @@\n- * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n- * or method in this class will cause a {@link NullPointerException} to be thrown.\n+ * <p> A subtask may execute code that itself opens a new {@code StructuredTaskScope}.\n+ * A task executing in thread T1 opens a {@code StructuredTaskScope} and forks a\n+ * subtask that runs in thread T2. The scoped value bindings captured when T1 opens the\n+ * scope are inherited into T2. The subtask (in thread T2) executes code that opens a\n+ * new {@code StructuredTaskScope} and forks a subtask that runs in thread T3. The scoped\n+ * value bindings captured when T2 opens the scope are inherited into T3. These\n+ * include (or may be the same) as the bindings that were inherited from T1. In effect,\n+ * scoped values are inherited into a tree of subtasks, not just one level of subtask.\n@@ -288,1 +334,1 @@\n- * <p> Actions in the owner thread of, or a thread contained in, the task scope prior to\n+ * <p> Actions in the owner thread of a {@code StructuredTaskScope} prior to\n@@ -291,3 +337,2 @@\n- * <i>happen-before<\/i><\/a> any actions taken by that subtask, which in turn <i>happen-before<\/i>\n- * the subtask result is {@linkplain Subtask#get() retrieved} or <i>happen-before<\/i> any\n- * actions taken in a thread after {@linkplain #join() joining} of the task scope.\n+ * <i>happen-before<\/i><\/a> any actions taken by that subtask, which in turn\n+ * <i>happen-before<\/i> the subtask result is {@linkplain Subtask#get() retrieved}.\n@@ -295,1 +340,7 @@\n- * @jls 17.4.5 Happens-before Order\n+ * <h2>General exceptions<\/h2>\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a method in this\n+ * class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * @param <T> the result type of subtasks executed in the scope\n+ * @param <R> the result type of the scope\n@@ -297,1 +348,1 @@\n- * @param <T> the result type of tasks executed in the task scope\n+ * @jls 17.4.5 Happens-before Order\n@@ -301,19 +352,3 @@\n-public class StructuredTaskScope<T> implements AutoCloseable {\n-    private final ThreadFactory factory;\n-    private final ThreadFlock flock;\n-    private final ReentrantLock shutdownLock = new ReentrantLock();\n-\n-    \/\/ states: OPEN -> SHUTDOWN -> CLOSED\n-    private static final int OPEN     = 0;   \/\/ initial state\n-    private static final int SHUTDOWN = 1;\n-    private static final int CLOSED   = 2;\n-\n-    \/\/ state: set to SHUTDOWN by any thread, set to CLOSED by owner, read by any thread\n-    private volatile int state;\n-\n-    \/\/ Counters to support checking that the task scope owner joins before processing\n-    \/\/ results and attempts join before closing the task scope. These counters are\n-    \/\/ accessed only by the owner thread.\n-    private int forkRound;         \/\/ incremented when the first subtask is forked after join\n-    private int lastJoinAttempted; \/\/ set to the current fork round when join is attempted\n-    private int lastJoinCompleted; \/\/ set to the current fork round when join completes\n+public sealed interface StructuredTaskScope<T, R>\n+        extends AutoCloseable\n+        permits StructuredTaskScopeImpl {\n@@ -322,1 +357,7 @@\n-     * Represents a subtask forked with {@link #fork(Callable)}.\n+     * Represents a subtask forked with {@link #fork(Callable)} or {@link #fork(Runnable)}.\n+     *\n+     * <p> Code that forks subtasks can use the {@link #get() get()} method after {@linkplain\n+     * #join() joining} to obtain the result of a subtask that completed successfully. It\n+     * can use the {@link #exception()} method to obtain the exception thrown by a subtask\n+     * that failed.\n+     *\n@@ -327,9 +368,1 @@\n-    public sealed interface Subtask<T> extends Supplier<T> permits SubtaskImpl {\n-        \/**\n-         * {@return the value returning task provided to the {@code fork} method}\n-         *\n-         * @apiNote Task objects with unique identity may be used for correlation by\n-         * implementations of {@link #handleComplete(Subtask) handleComplete}.\n-         *\/\n-        Callable<? extends T> task();\n-\n+    sealed interface Subtask<T> extends Supplier<T> permits StructuredTaskScopeImpl.SubtaskImpl {\n@@ -345,3 +378,3 @@\n-             * the subtask was forked but has not completed, it completed after the task\n-             * scope was {@linkplain #shutdown() shut down}, or it was forked after the\n-             * task scope was shut down.\n+             * the subtask was forked but has not completed, it completed after the scope\n+             * was cancelled, or it was forked after the scoped was cancelled (in which\n+             * case a thread was not created to execute the subtask).\n@@ -351,3 +384,2 @@\n-             * The subtask completed successfully with a result. The {@link Subtask#get()\n-             * Subtask.get()} method can be used to obtain the result. This is a terminal\n-             * state.\n+             * The subtask completed successfully. The {@link Subtask#get() Subtask.get()}\n+             * method can be used to get the result. This is a terminal state.\n@@ -358,1 +390,1 @@\n-             * Subtask.exception()} method can be used to obtain the exception. This is a\n+             * Subtask.exception()} method can be used to get the exception. This is a\n@@ -365,1 +397,1 @@\n-         * {@return the state of the subtask}\n+         * {@return the subtask state}\n@@ -370,1 +402,7 @@\n-         * Returns the result of the subtask.\n+         * Returns the result of this subtask if it completed successfully. If the subtask\n+         * was forked with {@link #fork(Callable) fork(Callable)} then the result from the\n+         * {@link Callable#call() call} method is returned. If the subtask was forked with\n+         * {@link #fork(Runnable) fork(Runnable)} then {@code null} is returned.\n+         *\n+         * <p> Code executing in the scope owner thread can use this method to get the\n+         * result of a successful subtask only after it has {@linkplain #join() joined}.\n@@ -372,3 +410,3 @@\n-         * <p> To ensure correct usage, if the scope owner {@linkplain #fork(Callable) forks}\n-         * a subtask, then it must join (with {@link #join() join} or {@link #joinUntil(Instant)\n-         * joinUntil}) before it can obtain the result of the subtask.\n+         * <p> Code executing in the {@code Joiner} {@link Joiner#onComplete(Subtask)\n+         * onComplete} method should test that the {@linkplain #state() subtask state} is\n+         * {@link State#SUCCESS SUCCESS} before using this method to get the result.\n@@ -378,2 +416,2 @@\n-         * successfully, or the current thread is the task scope owner and did not join\n-         * after forking\n+         * successfully, or the current thread is the scope owner invoking this\n+         * method before {@linkplain #join() joining}\n@@ -385,1 +423,8 @@\n-         * {@return the exception thrown by the subtask}\n+         * {@return the exception or error thrown by this subtask if it failed}\n+         * If the subtask was forked with {@link #fork(Callable) fork(Callable)} then the\n+         * exception or error thrown by the {@link Callable#call() call} method is returned.\n+         * If the subtask was forked with {@link #fork(Runnable) fork(Runnable)} then the\n+         * exception or error thrown by the {@link Runnable#run() run} method is returned.\n+         *\n+         * <p> Code executing in the scope owner thread can use this method to get the\n+         * exception thrown by a failed subtask only after it has {@linkplain #join() joined}.\n@@ -387,3 +432,3 @@\n-         * <p> To ensure correct usage, if the scope owner {@linkplain #fork(Callable) forks}\n-         * a subtask, then it must join (with {@link #join() join} or {@link #joinUntil(Instant)\n-         * joinUntil}) before it can obtain the exception thrown by the subtask.\n+         * <p> Code executing in a {@code Joiner} {@link Joiner#onComplete(Subtask)\n+         * onComplete} method should test that the {@linkplain #state() subtask state} is\n+         * {@link State#FAILED FAILED} before using this method to get the exception.\n@@ -392,2 +437,2 @@\n-         * a result, or the current thread is the task scope owner and did not join after\n-         * forking\n+         * a result, or the current thread is the scope owner invoking this method\n+         * before {@linkplain #join() joining}\n@@ -400,113 +445,3 @@\n-     * Creates a structured task scope with the given name and thread factory. The task\n-     * scope is optionally named for the purposes of monitoring and management. The thread\n-     * factory is used to {@link ThreadFactory#newThread(Runnable) create} threads when\n-     * subtasks are {@linkplain #fork(Callable) forked}. The task scope is owned by the\n-     * current thread.\n-     *\n-     * <p> Construction captures the current thread's {@linkplain ScopedValue scoped value}\n-     * bindings for inheritance by threads started in the task scope. The\n-     * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description details\n-     * how parent-child relations are established implicitly for the purpose of inheritance\n-     * of scoped value bindings.\n-     *\n-     * @param name the name of the task scope, can be null\n-     * @param factory the thread factory\n-     *\/\n-    @SuppressWarnings(\"this-escape\")\n-    public StructuredTaskScope(String name, ThreadFactory factory) {\n-        this.factory = Objects.requireNonNull(factory, \"'factory' is null\");\n-        if (name == null)\n-            name = Objects.toIdentityString(this);\n-        this.flock = ThreadFlock.open(name);\n-    }\n-\n-    \/**\n-     * Creates an unnamed structured task scope that creates virtual threads. The task\n-     * scope is owned by the current thread.\n-     *\n-     * @implSpec This constructor is equivalent to invoking the 2-arg constructor with a\n-     * name of {@code null} and a thread factory that creates virtual threads.\n-     *\/\n-    public StructuredTaskScope() {\n-        this(null, Thread.ofVirtual().factory());\n-    }\n-\n-    private IllegalStateException newIllegalStateExceptionScopeClosed() {\n-        return new IllegalStateException(\"Task scope is closed\");\n-    }\n-\n-    private IllegalStateException newIllegalStateExceptionNoJoin() {\n-        return new IllegalStateException(\"Owner did not join after forking subtasks\");\n-    }\n-\n-    \/**\n-     * Throws IllegalStateException if the scope is closed, returning the state if not\n-     * closed.\n-     *\/\n-    private int ensureOpen() {\n-        int s = state;\n-        if (s == CLOSED)\n-            throw newIllegalStateExceptionScopeClosed();\n-        return s;\n-    }\n-\n-    \/**\n-     * Throws WrongThreadException if the current thread is not the owner.\n-     *\/\n-    private void ensureOwner() {\n-        if (Thread.currentThread() != flock.owner())\n-            throw new WrongThreadException(\"Current thread not owner\");\n-    }\n-\n-    \/**\n-     * Throws WrongThreadException if the current thread is not the owner\n-     * or a thread contained in the tree.\n-     *\/\n-    private void ensureOwnerOrContainsThread() {\n-        Thread currentThread = Thread.currentThread();\n-        if (currentThread != flock.owner() && !flock.containsThread(currentThread))\n-            throw new WrongThreadException(\"Current thread not owner or thread in the tree\");\n-    }\n-\n-    \/**\n-     * Throws IllegalStateException if the current thread is the owner, and the owner did\n-     * not join after forking a subtask in the given fork round.\n-     *\/\n-    private void ensureJoinedIfOwner(int round) {\n-        if (Thread.currentThread() == flock.owner() && (round > lastJoinCompleted)) {\n-            throw newIllegalStateExceptionNoJoin();\n-        }\n-    }\n-\n-    \/**\n-     * Ensures that the current thread is the owner of this task scope and that it joined\n-     * (with {@link #join()} or {@link #joinUntil(Instant)}) after {@linkplain #fork(Callable)\n-     * forking} subtasks.\n-     *\n-     * @apiNote This method can be used by subclasses that define methods to make available\n-     * results, state, or other outcome to code intended to execute after the join method.\n-     *\n-     * @throws WrongThreadException if the current thread is not the task scope owner\n-     * @throws IllegalStateException if the task scope is open and task scope owner did\n-     * not join after forking\n-     *\/\n-    protected final void ensureOwnerAndJoined() {\n-        ensureOwner();\n-        if (forkRound > lastJoinCompleted) {\n-            throw newIllegalStateExceptionNoJoin();\n-        }\n-    }\n-\n-    \/**\n-     * Invoked by a subtask when it completes successfully or fails in this task scope.\n-     * This method is not invoked if a subtask completes after the task scope is\n-     * {@linkplain #shutdown() shut down}.\n-     *\n-     * @implSpec The default implementation throws {@code NullPointerException} if the\n-     * subtask is {@code null}. It throws {@link IllegalArgumentException} if the subtask\n-     * has not completed.\n-     *\n-     * @apiNote The {@code handleComplete} method should be thread safe. It may be\n-     * invoked by several threads concurrently.\n-     *\n-     * @param subtask the subtask\n+     * An object used with a {@link StructuredTaskScope} to handle subtask completion and\n+     * produce the result for the scope owner waiting in the {@link #join() join} method\n+     * for subtasks to complete.\n@@ -514,221 +449,1 @@\n-     * @throws IllegalArgumentException if called with a subtask that has not completed\n-     *\/\n-    protected void handleComplete(Subtask<? extends T> subtask) {\n-        if (subtask.state() == Subtask.State.UNAVAILABLE)\n-            throw new IllegalArgumentException();\n-    }\n-\n-    \/**\n-     * Starts a new thread in this task scope to execute a value-returning task, thus\n-     * creating a <em>subtask<\/em> of this task scope.\n-     *\n-     * <p> The value-returning task is provided to this method as a {@link Callable}, the\n-     * thread executes the task's {@link Callable#call() call} method. The thread is\n-     * created with the task scope's {@link ThreadFactory}. It inherits the current thread's\n-     * {@linkplain ScopedValue scoped value} bindings. The bindings must match the bindings\n-     * captured when the task scope was created.\n-     *\n-     * <p> This method returns a {@link Subtask Subtask} to represent the <em>forked\n-     * subtask<\/em>. The {@code Subtask} object can be used to obtain the result when\n-     * the subtask completes successfully, or the exception when the subtask fails. To\n-     * ensure correct usage, the {@link Subtask#get() get()} and {@link Subtask#exception()\n-     * exception()} methods may only be called by the task scope owner after it has waited\n-     * for all threads to finish with the {@link #join() join} or {@link #joinUntil(Instant)}\n-     * methods. When the subtask completes, the thread invokes the {@link\n-     * #handleComplete(Subtask) handleComplete} method to consume the completed subtask.\n-     * If the task scope is {@linkplain #shutdown() shut down} before the subtask completes\n-     * then the {@code handleComplete} method will not be invoked.\n-     *\n-     * <p> If this task scope is {@linkplain #shutdown() shutdown} (or in the process of\n-     * shutting down) then the subtask will not run and the {@code handleComplete} method\n-     * will not be invoked.\n-     *\n-     * <p> This method may only be invoked by the task scope owner or threads contained\n-     * in the task scope.\n-     *\n-     * @implSpec This method may be overridden for customization purposes, wrapping tasks\n-     * for example. If overridden, the subclass must invoke {@code super.fork} to start a\n-     * new thread in this task scope.\n-     *\n-     * @param task the value-returning task for the thread to execute\n-     * @param <U> the result type\n-     * @return the subtask\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the task scope owner or a\n-     * thread contained in the task scope\n-     * @throws StructureViolationException if the current scoped value bindings are not\n-     * the same as when the task scope was created\n-     * @throws RejectedExecutionException if the thread factory rejected creating a\n-     * thread to run the subtask\n-     *\/\n-    public <U extends T> Subtask<U> fork(Callable<? extends U> task) {\n-        Objects.requireNonNull(task, \"'task' is null\");\n-        int s = ensureOpen();   \/\/ throws ISE if closed\n-\n-        \/\/ when forked by the owner, the subtask is forked in the current or next round\n-        int round = -1;\n-        if (Thread.currentThread() == flock.owner()) {\n-            round = forkRound;\n-            if (forkRound == lastJoinCompleted) {\n-                \/\/ new round if first fork after join\n-                round++;\n-            }\n-        }\n-\n-        SubtaskImpl<U> subtask = new SubtaskImpl<>(this, task, round);\n-        if (s < SHUTDOWN) {\n-            \/\/ create thread to run task\n-            Thread thread = factory.newThread(subtask);\n-            if (thread == null) {\n-                throw new RejectedExecutionException(\"Rejected by thread factory\");\n-            }\n-\n-            \/\/ attempt to start the thread\n-            try {\n-                flock.start(thread);\n-            } catch (IllegalStateException e) {\n-                \/\/ shutdown by another thread, or underlying flock is shutdown due\n-                \/\/ to unstructured use\n-            }\n-        }\n-\n-        \/\/ force owner to join if this is the first fork in the round\n-        if (Thread.currentThread() == flock.owner() && round > forkRound) {\n-            forkRound = round;\n-        }\n-\n-        \/\/ return forked subtask or a subtask that did not run\n-        return subtask;\n-    }\n-\n-    \/**\n-     * Wait for all threads to finish or the task scope to shut down.\n-     *\/\n-    private void implJoin(Duration timeout)\n-        throws InterruptedException, TimeoutException\n-    {\n-        ensureOwner();\n-        lastJoinAttempted = forkRound;\n-        int s = ensureOpen();  \/\/ throws ISE if closed\n-        if (s == OPEN) {\n-            \/\/ wait for all threads, wakeup, interrupt, or timeout\n-            if (timeout != null) {\n-                flock.awaitAll(timeout);\n-            } else {\n-                flock.awaitAll();\n-            }\n-        }\n-        lastJoinCompleted = forkRound;\n-    }\n-\n-    \/**\n-     * Wait for all subtasks started in this task scope to finish or the task scope to\n-     * shut down.\n-     *\n-     * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n-     * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n-     * when all threads finish, the task scope is {@linkplain #shutdown() shut down}, or\n-     * the current thread is {@linkplain Thread#interrupt() interrupted}.\n-     *\n-     * <p> This method may only be invoked by the task scope owner.\n-     *\n-     * @implSpec This method may be overridden for customization purposes or to return a\n-     * more specific return type. If overridden, the subclass must invoke {@code\n-     * super.join} to ensure that the method waits for threads in this task scope to\n-     * finish.\n-     *\n-     * @return this task scope\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the task scope owner\n-     * @throws InterruptedException if interrupted while waiting\n-     *\/\n-    public StructuredTaskScope<T> join() throws InterruptedException {\n-        try {\n-            implJoin(null);\n-        } catch (TimeoutException e) {\n-            throw new InternalError();\n-        }\n-        return this;\n-    }\n-\n-    \/**\n-     * Wait for all subtasks started in this task scope to finish or the task scope to\n-     * shut down, up to the given deadline.\n-     *\n-     * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n-     * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n-     * when all threads finish, the task scope is {@linkplain #shutdown() shut down}, the\n-     * deadline is reached, or the current thread is {@linkplain Thread#interrupt()\n-     * interrupted}.\n-     *\n-     * <p> This method may only be invoked by the task scope owner.\n-     *\n-     * @implSpec This method may be overridden for customization purposes or to return a\n-     * more specific return type. If overridden, the subclass must invoke {@code\n-     * super.joinUntil} to ensure that the method waits for threads in this task scope to\n-     * finish.\n-     *\n-     * @param deadline the deadline\n-     * @return this task scope\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the task scope owner\n-     * @throws InterruptedException if interrupted while waiting\n-     * @throws TimeoutException if the deadline is reached while waiting\n-     *\/\n-    public StructuredTaskScope<T> joinUntil(Instant deadline)\n-        throws InterruptedException, TimeoutException\n-    {\n-        Duration timeout = Duration.between(Instant.now(), deadline);\n-        implJoin(timeout);\n-        return this;\n-    }\n-\n-    \/**\n-     * Interrupt all unfinished threads.\n-     *\/\n-    private void interruptAll() {\n-        flock.threads()\n-            .filter(t -> t != Thread.currentThread())\n-            .forEach(t -> {\n-                try {\n-                    t.interrupt();\n-                } catch (Throwable ignore) { }\n-            });\n-    }\n-\n-    \/**\n-     * Shutdown the task scope if not already shutdown. Return true if this method\n-     * shutdowns the task scope, false if already shutdown.\n-     *\/\n-    private boolean implShutdown() {\n-        shutdownLock.lock();\n-        try {\n-            if (state < SHUTDOWN) {\n-                \/\/ prevent new threads from starting\n-                flock.shutdown();\n-\n-                \/\/ set status before interrupting tasks\n-                state = SHUTDOWN;\n-\n-                \/\/ interrupt all unfinished threads\n-                interruptAll();\n-\n-                return true;\n-            } else {\n-                \/\/ already shutdown\n-                return false;\n-            }\n-        } finally {\n-            shutdownLock.unlock();\n-        }\n-    }\n-\n-    \/**\n-     * Shut down this task scope without closing it. Shutting down a task scope prevents\n-     * new threads from starting, interrupts all unfinished threads, and causes the\n-     * {@link #join() join} method to wakeup. Shutdown is useful for cases where the\n-     * results of unfinished subtasks are no longer needed. It will typically be called\n-     * by the {@link #handleComplete(Subtask)} implementation of a subclass that\n-     * implements a policy to discard unfinished tasks once some outcome is reached.\n-     *\n-     * <p> More specifically, this method:\n+     * <p> Joiner defines static methods to create {@code Joiner} objects for common cases:\n@@ -736,5 +451,12 @@\n-     * <li> {@linkplain Thread#interrupt() Interrupts} all unfinished threads in the\n-     * task scope (except the current thread).\n-     * <li> Wakes up the task scope owner if it is waiting in {@link #join()} or {@link\n-     * #joinUntil(Instant)}. If the task scope owner is not waiting then its next call to\n-     * {@code join} or {@code joinUntil} will return immediately.\n+     *   <li> {@link #allSuccessfulOrThrow() allSuccessfulOrThrow()} creates a {@code Joiner}\n+     *   that yields a stream of the completed subtasks for {@code join} to return when\n+     *   all subtasks complete successfully. It cancels the scope and causes {@code join}\n+     *   to throw if any subtask fails.\n+     *   <li> {@link #anySuccessfulResultOrThrow() anySuccessfulResultOrThrow()} creates a\n+     *   {@code Joiner} that yields the result of the first subtask to succeed for {@code\n+     *   join} to return. It causes {@code join} to throw if all subtasks fail.\n+     *   <li> {@link #awaitAllSuccessfulOrThrow() awaitAllSuccessfulOrThrow()} creates a\n+     *   {@code Joiner} that waits for all successful subtasks. It cancels the scope and\n+     *   causes {@code join} to throw if any subtask fails.\n+     *   <li> {@link #awaitAll() awaitAll()} creates a {@code Joiner} that waits for all\n+     *   subtasks. It does not cancel the scope or cause {@code join} to throw.\n@@ -743,8 +465,6 @@\n-     * <p> The {@linkplain Subtask.State state} of unfinished subtasks that complete at\n-     * around the time that the task scope is shutdown is not defined. A subtask that\n-     * completes successfully with a result, or fails with an exception, at around\n-     * the time that the task scope is shutdown may or may not <i>transition<\/i> to a\n-     * terminal state.\n-     *\n-     * <p> This method may only be invoked by the task scope owner or threads contained\n-     * in the task scope.\n+     * <p> In addition to the methods to create {@code Joiner} objects for common cases,\n+     * the {@link #allUntil(Predicate) allUntil(Predicate)} method is defined to create a\n+     * {@code Joiner} that yields a stream of all subtasks. It is created with a {@link\n+     * Predicate Predicate} that determines if the scope should continue or be cancelled.\n+     * This {@code Joiner} can be built upon to create custom policies that cancel the\n+     * scope based on some condition.\n@@ -752,3 +472,8 @@\n-     * @implSpec This method may be overridden for customization purposes. If overridden,\n-     * the subclass must invoke {@code super.shutdown} to ensure that the method shuts\n-     * down the task scope.\n+     * <p> More advanced policies can be developed by implementing the {@code Joiner}\n+     * interface. The {@link #onFork(Subtask)} method is invoked when subtasks are forked.\n+     * The {@link #onComplete(Subtask)} method is invoked when subtasks complete with a\n+     * result or exception. These methods return a {@code boolean} to indicate if scope\n+     * should be cancelled. These methods can be used to collect subtasks, results, or\n+     * exceptions, and control when to cancel the scope. The {@link #result()} method\n+     * must be implemented to produce the result (or exception) for the {@code join}\n+     * method.\n@@ -756,5 +481,2 @@\n-     * @apiNote\n-     * There may be threads that have not finished because they are executing code that\n-     * did not respond (or respond promptly) to thread interrupt. This method does not wait\n-     * for these threads. When the owner invokes the {@link #close() close} method\n-     * to close the task scope then it will wait for the remaining threads to finish.\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n+     * in this class will cause a {@link NullPointerException} to be thrown.\n@@ -762,22 +484,3 @@\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the task scope owner or\n-     * a thread contained in the task scope\n-     * @see #isShutdown()\n-     *\/\n-    public void shutdown() {\n-        ensureOwnerOrContainsThread();\n-        int s = ensureOpen();  \/\/ throws ISE if closed\n-        if (s < SHUTDOWN && implShutdown())\n-            flock.wakeup();\n-    }\n-\n-    \/**\n-     * {@return true if this task scope is shutdown, otherwise false}\n-     * @see #shutdown()\n-     *\/\n-    public final boolean isShutdown() {\n-        return state >= SHUTDOWN;\n-    }\n-\n-    \/**\n-     * Closes this task scope.\n+     * @implSpec Implementations of this interface must be thread safe. The {@link\n+     * #onComplete(Subtask)} method defined by this interface may be invoked by several\n+     * threads concurrently.\n@@ -785,4 +488,3 @@\n-     * <p> This method first shuts down the task scope (as if by invoking the {@link\n-     * #shutdown() shutdown} method). It then waits for the threads executing any\n-     * unfinished tasks to finish. If interrupted, this method will continue to wait for\n-     * the threads to finish before completing with the interrupt status set.\n+     * @apiNote It is very important that a new {@code Joiner} object is created for each\n+     * {@code StructuredTaskScope}. {@code Joiner} objects should never be shared with\n+     * different scopes or re-used after a task is closed.\n@@ -790,2 +492,6 @@\n-     * <p> This method may only be invoked by the task scope owner. If the task scope\n-     * is already closed then the task scope owner invoking this method has no effect.\n+     * <p> Designing a {@code Joiner} should take into account the code at the use-site\n+     * where the results from the {@link StructuredTaskScope#join() join} method are\n+     * processed. It should be clear what the {@code Joiner} does vs. the application\n+     * code at the use-site. In general, the {@code Joiner} implementation is not the\n+     * place for \"business logic\". A {@code Joiner} should be designed to be as general\n+     * purpose as possible.\n@@ -793,58 +499,4 @@\n-     * <p> A {@code StructuredTaskScope} is intended to be used in a <em>structured\n-     * manner<\/em>. If this method is called to close a task scope before nested task\n-     * scopes are closed then it closes the underlying construct of each nested task scope\n-     * (in the reverse order that they were created in), closes this task scope, and then\n-     * throws {@link StructureViolationException}.\n-     * Similarly, if this method is called to close a task scope while executing with\n-     * {@linkplain ScopedValue scoped value} bindings, and the task scope was created\n-     * before the scoped values were bound, then {@code StructureViolationException} is\n-     * thrown after closing the task scope.\n-     * If a thread terminates without first closing task scopes that it owns then\n-     * termination will cause the underlying construct of each of its open tasks scopes to\n-     * be closed. Closing is performed in the reverse order that the task scopes were\n-     * created in. Thread termination may therefore be delayed when the task scope owner\n-     * has to wait for threads forked in these task scopes to finish.\n-     *\n-     * @implSpec This method may be overridden for customization purposes. If overridden,\n-     * the subclass must invoke {@code super.close} to close the task scope.\n-     *\n-     * @throws IllegalStateException thrown after closing the task scope if the task scope\n-     * owner did not attempt to join after forking\n-     * @throws WrongThreadException if the current thread is not the task scope owner\n-     * @throws StructureViolationException if a structure violation was detected\n-     *\/\n-    @Override\n-    public void close() {\n-        ensureOwner();\n-        int s = state;\n-        if (s == CLOSED)\n-            return;\n-\n-        try {\n-            if (s < SHUTDOWN)\n-                implShutdown();\n-            flock.close();\n-        } finally {\n-            state = CLOSED;\n-        }\n-\n-        \/\/ throw ISE if the owner didn't attempt to join after forking\n-        if (forkRound > lastJoinAttempted) {\n-            lastJoinCompleted = forkRound;\n-            throw newIllegalStateExceptionNoJoin();\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        String name = flock.name();\n-        return switch (state) {\n-            case OPEN     -> name;\n-            case SHUTDOWN -> name + \"\/shutdown\";\n-            case CLOSED   -> name + \"\/closed\";\n-            default -> throw new InternalError();\n-        };\n-    }\n-\n-    \/**\n-     * Subtask implementation, runs the task specified to the fork method.\n+     * @param <T> the result type of subtasks executed in the scope\n+     * @param <R> the result type of the scope\n+     * @since 25\n+     * @see #open(Joiner)\n@@ -852,73 +504,23 @@\n-    private static final class SubtaskImpl<T> implements Subtask<T>, Runnable {\n-        private static final AltResult RESULT_NULL = new AltResult(Subtask.State.SUCCESS);\n-\n-        private record AltResult(Subtask.State state, Throwable exception) {\n-            AltResult(Subtask.State state) {\n-                this(state, null);\n-            }\n-        }\n-\n-        private final StructuredTaskScope<? super T> scope;\n-        private final Callable<? extends T> task;\n-        private final int round;\n-        private volatile Object result;\n-\n-        SubtaskImpl(StructuredTaskScope<? super T> scope,\n-                    Callable<? extends T> task,\n-                    int round) {\n-            this.scope = scope;\n-            this.task = task;\n-            this.round = round;\n-        }\n-\n-        @Override\n-        public void run() {\n-            T result = null;\n-            Throwable ex = null;\n-            try {\n-                result = task.call();\n-            } catch (Throwable e) {\n-                ex = e;\n-            }\n-\n-            \/\/ nothing to do if task scope is shutdown\n-            if (scope.isShutdown())\n-                return;\n-\n-            \/\/ capture result or exception, invoke handleComplete\n-            if (ex == null) {\n-                this.result = (result != null) ? result : RESULT_NULL;\n-            } else {\n-                this.result = new AltResult(State.FAILED, ex);\n-            }\n-            scope.handleComplete(this);\n-        }\n-\n-        @Override\n-        public Callable<? extends T> task() {\n-            return task;\n-        }\n-\n-        @Override\n-        public Subtask.State state() {\n-            Object result = this.result;\n-            if (result == null) {\n-                return State.UNAVAILABLE;\n-            } else if (result instanceof AltResult alt) {\n-                \/\/ null or failed\n-                return alt.state();\n-            } else {\n-                return State.SUCCESS;\n-            }\n-        }\n-\n-        @Override\n-        public T get() {\n-            scope.ensureJoinedIfOwner(round);\n-            Object result = this.result;\n-            if (result instanceof AltResult) {\n-                if (result == RESULT_NULL) return null;\n-            } else if (result != null) {\n-                @SuppressWarnings(\"unchecked\")\n-                T r = (T) result;\n-                return r;\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    @FunctionalInterface\n+    interface Joiner<T, R> {\n+        \/**\n+         * Invoked by {@link #fork(Callable) fork(Callable)} and {@link #fork(Runnable)\n+         * fork(Runnable)} when forking a subtask. The method is invoked from the task\n+         * owner thread. The method is invoked before a thread is created to run the\n+         * subtask.\n+         *\n+         * @implSpec The default implementation throws {@code NullPointerException} if the\n+         * subtask is {@code null}. It throws {@code IllegalArgumentException} if the\n+         * subtask is not in the {@link Subtask.State#UNAVAILABLE UNAVAILABLE} state, it\n+         * otherwise returns {@code false}.\n+         *\n+         * @apiNote This method is invoked by the {@code fork} methods. It should not be\n+         * invoked directly.\n+         *\n+         * @param subtask the subtask\n+         * @return {@code true} to cancel the scope, otherwise {@code false}\n+         *\/\n+        default boolean onFork(Subtask<? extends T> subtask) {\n+            if (subtask.state() != Subtask.State.UNAVAILABLE) {\n+                throw new IllegalArgumentException(\"Subtask not in UNAVAILABLE state\");\n@@ -926,2 +528,1 @@\n-            throw new IllegalStateException(\n-                    \"Result is unavailable or subtask did not complete successfully\");\n+            return false;\n@@ -930,6 +531,19 @@\n-        @Override\n-        public Throwable exception() {\n-            scope.ensureJoinedIfOwner(round);\n-            Object result = this.result;\n-            if (result instanceof AltResult alt && alt.state() == State.FAILED) {\n-                return alt.exception();\n+        \/**\n+         * Invoked by the thread started to execute a subtask after the subtask completes\n+         * successfully or fails with an exception. This method is not invoked if a\n+         * subtask completes after the scope is cancelled.\n+         *\n+         * @implSpec The default implementation throws {@code NullPointerException} if the\n+         * subtask is {@code null}. It throws {@code IllegalArgumentException} if the\n+         * subtask is not in the {@link Subtask.State#SUCCESS SUCCESS} or {@link\n+         * Subtask.State#FAILED FAILED} state, it otherwise returns {@code false}.\n+         *\n+         * @apiNote This method is invoked by subtasks when they complete. It should not\n+         * be invoked directly.\n+         *\n+         * @param subtask the subtask\n+         * @return {@code true} to cancel the scope, otherwise {@code false}\n+         *\/\n+        default boolean onComplete(Subtask<? extends T> subtask) {\n+            if (subtask.state() == Subtask.State.UNAVAILABLE) {\n+                throw new IllegalArgumentException(\"Subtask has not completed\");\n@@ -937,45 +551,1 @@\n-            throw new IllegalStateException(\n-                    \"Exception is unavailable or subtask did not complete with exception\");\n-        }\n-\n-        @Override\n-        public String toString() {\n-            String stateAsString = switch (state()) {\n-                case UNAVAILABLE -> \"[Unavailable]\";\n-                case SUCCESS     -> \"[Completed successfully]\";\n-                case FAILED      -> {\n-                    Throwable ex = ((AltResult) result).exception();\n-                    yield \"[Failed: \" + ex + \"]\";\n-                }\n-            };\n-            return Objects.toIdentityString(this) + stateAsString;\n-        }\n-    }\n-\n-    \/**\n-     * A {@code StructuredTaskScope} that captures the result of the first subtask to\n-     * complete {@linkplain Subtask.State#SUCCESS successfully}. Once captured, it\n-     * {@linkplain #shutdown() shuts down} the task scope to interrupt unfinished threads\n-     * and wakeup the task scope owner. The policy implemented by this class is intended\n-     * for cases where the result of any subtask will do (\"invoke any\") and where the\n-     * results of other unfinished subtasks are no longer needed.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n-     * in this class will cause a {@link NullPointerException} to be thrown.\n-     *\n-     * @apiNote This class implements a policy to shut down the task scope when a subtask\n-     * completes successfully. There shouldn't be any need to directly shut down the task\n-     * scope with the {@link #shutdown() shutdown} method.\n-     *\n-     * @param <T> the result type\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n-    public static final class ShutdownOnSuccess<T> extends StructuredTaskScope<T> {\n-        private static final Object RESULT_NULL = new Object();\n-        private static final VarHandle FIRST_RESULT;\n-        private static final VarHandle FIRST_EXCEPTION;\n-        static {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            FIRST_RESULT = MhUtil.findVarHandle(l, \"firstResult\", Object.class);\n-            FIRST_EXCEPTION = MhUtil.findVarHandle(l, \"firstException\", Throwable.class);\n+            return false;\n@@ -983,2 +553,0 @@\n-        private volatile Object firstResult;\n-        private volatile Throwable firstException;\n@@ -987,5 +555,11 @@\n-         * Constructs a new {@code ShutdownOnSuccess} with the given name and thread factory.\n-         * The task scope is optionally named for the purposes of monitoring and management.\n-         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n-         * threads when subtasks are {@linkplain #fork(Callable) forked}. The task scope\n-         * is owned by the current thread.\n+         * Invoked by the {@link #join() join()} method to produce the result (or exception)\n+         * after waiting for all subtasks to complete or the scope cancelled. The result\n+         * from this method is returned by the {@code join} method. If this method throws,\n+         * then {@code join} throws {@link FailedException} with the exception thrown by\n+         * this method as the cause.\n+         *\n+         * <p> In normal usage, this method will be called at most once by the {@code join}\n+         * method to produce the result (or exception). The behavior of this method when\n+         * invoked directly, and invoked more than once, is undefined. Where possible, an\n+         * implementation should return an equal result (or throw the same exception) on\n+         * second or subsequent calls to produce the outcome.\n@@ -993,5 +567,2 @@\n-         * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n-         * value} bindings for inheritance by threads started in the task scope. The\n-         * {@linkplain StructuredTaskScope##TreeStructure Tree Structure} section\n-         * in the class description details how parent-child relations are established\n-         * implicitly for the purpose of inheritance of scoped value bindings.\n+         * @apiNote This method is invoked by the {@code join} method. It should not be\n+         * invoked directly.\n@@ -999,2 +570,2 @@\n-         * @param name the name of the task scope, can be null\n-         * @param factory the thread factory\n+         * @return the result\n+         * @throws Throwable the exception\n@@ -1002,3 +573,1 @@\n-        public ShutdownOnSuccess(String name, ThreadFactory factory) {\n-            super(name, factory);\n-        }\n+        R result() throws Throwable;\n@@ -1007,1 +576,14 @@\n-         * Constructs a new unnamed {@code ShutdownOnSuccess} that creates virtual threads.\n+         * {@return a new Joiner object that yields a stream of all subtasks when all\n+         * subtasks complete successfully}\n+         * The {@code Joiner} <a href=\"StructuredTaskScope.html#Cancallation\">cancels<\/a>\n+         * the scope and causes {@code join} to throw if any subtask fails.\n+         *\n+         * <p> If all subtasks complete successfully, the joiner's {@link Joiner#result()}\n+         * method returns a stream of all subtasks in the order that they were forked.\n+         * If any subtask failed then the {@code result} method throws the exception from\n+         * the first subtask to fail.\n+         *\n+         * @apiNote Joiners returned by this method are suited to cases where all subtasks\n+         * return a result of the same type. Joiners returned by {@link\n+         * #awaitAllSuccessfulOrThrow()} are suited to cases where the subtasks return\n+         * results of different types.\n@@ -1009,2 +591,1 @@\n-         * @implSpec This constructor is equivalent to invoking the 2-arg constructor with\n-         * a name of {@code null} and a thread factory that creates virtual threads.\n+         * @param <T> the result type of subtasks\n@@ -1012,22 +593,2 @@\n-        public ShutdownOnSuccess() {\n-            this(null, Thread.ofVirtual().factory());\n-        }\n-\n-        @Override\n-        protected void handleComplete(Subtask<? extends T> subtask) {\n-            if (firstResult != null) {\n-                \/\/ already captured a result\n-                return;\n-            }\n-\n-            if (subtask.state() == Subtask.State.SUCCESS) {\n-                \/\/ task succeeded\n-                T result = subtask.get();\n-                Object r = (result != null) ? result : RESULT_NULL;\n-                if (FIRST_RESULT.compareAndSet(this, null, r)) {\n-                    super.shutdown();\n-                }\n-            } else if (firstException == null) {\n-                \/\/ capture the exception thrown by the first subtask that failed\n-                FIRST_EXCEPTION.compareAndSet(this, null, subtask.exception());\n-            }\n+        static <T> Joiner<T, Stream<Subtask<T>>> allSuccessfulOrThrow() {\n+            return new Joiners.AllSuccessful<>();\n@@ -1037,2 +598,3 @@\n-         * Wait for a subtask started in this task scope to complete {@linkplain\n-         * Subtask.State#SUCCESS successfully} or all subtasks to complete.\n+         * {@return a new Joiner object that yields the result of any subtask that\n+         * completed successfully}\n+         * The {@code Joiner} causes {@code join} to throw if all subtasks fail.\n@@ -1040,6 +602,4 @@\n-         * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n-         * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n-         * when all threads finish, a subtask completes successfully, or the current\n-         * thread is {@linkplain Thread#interrupt() interrupted}. It also stops waiting\n-         * if the {@link #shutdown() shutdown} method is invoked directly to shut down\n-         * this task scope.\n+         * <p> The joiner's {@link Joiner#result()} method returns the result of a subtask\n+         * that completed successfully. If all subtasks fail then the {@code result} method\n+         * throws the exception from one of the failed subtasks. The {@code result} method\n+         * throws {@code NoSuchElementException} if no subtasks were forked.\n@@ -1047,4 +607,1 @@\n-         * <p> This method may only be invoked by the task scope owner.\n-         *\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n+         * @param <T> the result type of subtasks\n@@ -1052,4 +609,2 @@\n-        @Override\n-        public ShutdownOnSuccess<T> join() throws InterruptedException {\n-            super.join();\n-            return this;\n+        static <T> Joiner<T, T> anySuccessfulResultOrThrow() {\n+            return new Joiners.AnySuccessful<>();\n@@ -1059,3 +614,3 @@\n-         * Wait for a subtask started in this task scope to complete {@linkplain\n-         * Subtask.State#SUCCESS successfully} or all subtasks to complete, up to the\n-         * given deadline.\n+         * {@return a new Joiner object that waits for subtasks to complete successfully}\n+         * The {@code Joiner} <a href=\"StructuredTaskScope.html#Cancallation\">cancels<\/a>\n+         * the scope and causes {@code join} to throw if any subtask fails.\n@@ -1063,6 +618,3 @@\n-         * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n-         * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n-         * when all threads finish, a subtask completes successfully, the deadline is\n-         * reached, or the current thread is {@linkplain Thread#interrupt() interrupted}.\n-         * It also stops waiting if the {@link #shutdown() shutdown} method is invoked\n-         * directly to shut down this task scope.\n+         * <p> The joiner's {@link Joiner#result() result} method returns {@code null}\n+         * if all subtasks complete successfully, or throws the exception from the first\n+         * subtask to fail.\n@@ -1070,1 +622,3 @@\n-         * <p> This method may only be invoked by the task scope owner.\n+         * @apiNote Joiners returned by this method are suited to cases where subtasks\n+         * return results of different types. Joiners returned by {@link #allSuccessfulOrThrow()}\n+         * are suited to cases where the subtasks return a result of the same type.\n@@ -1072,2 +626,1 @@\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n+         * @param <T> the result type of subtasks\n@@ -1075,6 +628,2 @@\n-        @Override\n-        public ShutdownOnSuccess<T> joinUntil(Instant deadline)\n-            throws InterruptedException, TimeoutException\n-        {\n-            super.joinUntil(deadline);\n-            return this;\n+        static <T> Joiner<T, Void> awaitAllSuccessfulOrThrow() {\n+            return new Joiners.AwaitSuccessful<>();\n@@ -1084,2 +633,9 @@\n-         * {@return the result of the first subtask that completed {@linkplain\n-         * Subtask.State#SUCCESS successfully}}\n+         * {@return a new Joiner object that waits for all subtasks to complete}\n+         * The {@code Joiner} does not cancel the scope if a subtask fails.\n+         *\n+         * <p> The joiner's {@link Joiner#result() result} method returns {@code null}.\n+         *\n+         * @apiNote This Joiner is useful for cases where subtasks make use of\n+         * <em>side-effects<\/em> rather than return results or fail with exceptions.\n+         * The {@link #fork(Runnable) fork(Runnable)} method can be used to fork subtasks\n+         * that do not return a result.\n@@ -1087,3 +643,14 @@\n-         * <p> When no subtask completed successfully, but a subtask {@linkplain\n-         * Subtask.State#FAILED failed} then {@code ExecutionException} is thrown with\n-         * the subtask's exception as the {@linkplain Throwable#getCause() cause}.\n+         * <p> This Joiner can also be used for <em>fan-in<\/em> scenarios where subtasks\n+         * are forked to handle incoming connections and the number of subtasks is unbounded.\n+         * In this example, the thread executing the {@code acceptLoop} method will only\n+         * stop when interrupted or the listener socket is closed asynchronously.\n+         * {@snippet lang=java :\n+         *   void acceptLoop(ServerSocket listener) throws IOException, InterruptedException {\n+         *       try (var scope = StructuredTaskScope.open(Joiner.<Socket>awaitAll())) {\n+         *           while (true) {\n+         *               Socket socket = listener.accept();\n+         *               scope.fork(() -> handle(socket));\n+         *           }\n+         *       }\n+         *   }\n+         * }\n@@ -1091,5 +658,1 @@\n-         * @throws ExecutionException if no subtasks completed successfully but at least\n-         * one subtask failed\n-         * @throws IllegalStateException if no subtasks completed or the task scope owner\n-         * did not join after forking\n-         * @throws WrongThreadException if the current thread is not the task scope owner\n+         * @param <T> the result type of subtasks\n@@ -1097,2 +660,8 @@\n-        public T result() throws ExecutionException {\n-            return result(ExecutionException::new);\n+        static <T> Joiner<T, Void> awaitAll() {\n+            \/\/ ensure that new Joiner object is returned\n+            return new Joiner<T, Void>() {\n+                @Override\n+                public Void result() {\n+                    return null;\n+                }\n+            };\n@@ -1102,3 +671,12 @@\n-         * Returns the result of the first subtask that completed {@linkplain\n-         * Subtask.State#SUCCESS successfully}, otherwise throws an exception produced\n-         * by the given exception supplying function.\n+         * {@return a new Joiner object that yields a stream of all subtasks when all\n+         * subtasks complete or a predicate returns {@code true} to cancel the scope}\n+         *\n+         * <p> The joiner's {@link Joiner#onComplete(Subtask)} method invokes the\n+         * predicate's {@link Predicate#test(Object) test} method with the subtask that\n+         * completed successfully or failed with an exception. If the {@code test} method\n+         * returns {@code true} then <a href=\"StructuredTaskScope.html#Cancallation\">\n+         * the scope is cancelled<\/a>. The {@code test} method must be thread safe as it\n+         * may be invoked concurrently from several threads. If the {@code test} method\n+         * completes with an exception or error, then the thread that executed the subtask\n+         * invokes the {@linkplain Thread.UncaughtExceptionHandler uncaught exception handler}\n+         * with the exception or error before the thread terminates.\n@@ -1106,3 +684,5 @@\n-         * <p> When no subtask completed successfully, but a subtask {@linkplain\n-         * Subtask.State#FAILED failed}, then the exception supplying function is invoked\n-         * with subtask's exception.\n+         * <p> The joiner's {@link #result()} method returns the stream of all subtasks,\n+         * in fork order. The stream may contain subtasks that have completed\n+         * (in {@link Subtask.State#SUCCESS SUCCESS} or {@link Subtask.State#FAILED FAILED}\n+         * state) or subtasks in the {@link Subtask.State#UNAVAILABLE UNAVAILABLE} state\n+         * if the scope was cancelled before all subtasks were forked or completed.\n@@ -1110,3 +690,12 @@\n-         * @param esf the exception supplying function\n-         * @param <X> type of the exception to be thrown\n-         * @return the result of the first subtask that completed with a result\n+         * <p> The following example uses this method to create a {@code Joiner} that\n+         * <a href=\"StructuredTaskScope.html#Cancallation\">cancels<\/a> the scope when\n+         * two or more subtasks fail.\n+         * {@snippet lang=java :\n+         *    class CancelAfterTwoFailures<T> implements Predicate<Subtask<? extends T>> {\n+         *         private final AtomicInteger failedCount = new AtomicInteger();\n+         *         @Override\n+         *         public boolean test(Subtask<? extends T> subtask) {\n+         *             return subtask.state() == Subtask.State.FAILED\n+         *                     && failedCount.incrementAndGet() >= 2;\n+         *         }\n+         *     }\n@@ -1114,4 +703,17 @@\n-         * @throws X if no subtasks completed successfully but at least one subtask failed\n-         * @throws IllegalStateException if no subtasks completed or the task scope owner\n-         * did not join after forking\n-         * @throws WrongThreadException if the current thread is not the task scope owner\n+         *     var joiner = Joiner.all(new CancelAfterTwoFailures<String>());\n+         * }\n+         *\n+         * <p> The following example uses {@code allUntil} to wait for all subtasks to\n+         * complete without any cancellation. This is similar to {@link #awaitAll()}\n+         * except that it yields a stream of the completed subtasks.\n+         * {@snippet lang=java :\n+         *    <T> List<Subtask<T>> invokeAll(Collection<Callable<T>> tasks) throws InterruptedException {\n+         *        try (var scope = StructuredTaskScope.open(Joiner.<T>allUntil(_ -> false))) {\n+         *            tasks.forEach(scope::fork);\n+         *            return scope.join().toList();\n+         *        }\n+         *    }\n+         * }\n+         *\n+         * @param isDone the predicate to evaluate completed subtasks\n+         * @param <T> the result type of subtasks\n@@ -1119,21 +721,2 @@\n-        public <X extends Throwable> T result(Function<Throwable, ? extends X> esf) throws X {\n-            Objects.requireNonNull(esf);\n-            ensureOwnerAndJoined();\n-\n-            Object result = firstResult;\n-            if (result == RESULT_NULL) {\n-                return null;\n-            } else if (result != null) {\n-                @SuppressWarnings(\"unchecked\")\n-                T r = (T) result;\n-                return r;\n-            }\n-\n-            Throwable exception = firstException;\n-            if (exception != null) {\n-                X ex = esf.apply(exception);\n-                Objects.requireNonNull(ex, \"esf returned null\");\n-                throw ex;\n-            }\n-\n-            throw new IllegalStateException(\"No completed subtasks\");\n+        static <T> Joiner<T, Stream<Subtask<T>>> allUntil(Predicate<Subtask<? extends T>> isDone) {\n+            return new Joiners.AllSubtasks<>(isDone);\n@@ -1144,6 +727,18 @@\n-     * A {@code StructuredTaskScope} that captures the exception of the first subtask to\n-     * {@linkplain Subtask.State#FAILED fail}. Once captured, it {@linkplain #shutdown()\n-     * shuts down} the task scope to interrupt unfinished threads and wakeup the task\n-     * scope owner. The policy implemented by this class is intended for cases where the\n-     * results for all subtasks are required (\"invoke all\"); if any subtask fails then the\n-     * results of other unfinished subtasks are no longer needed.\n+     * Represents the configuration for a {@code StructuredTaskScope}.\n+     *\n+     * <p> The configuration for a {@code StructuredTaskScope} consists of a {@link\n+     * ThreadFactory} to create threads, an optional name for the purposes of monitoring\n+     * and management, and an optional timeout.\n+     *\n+     * <p> Creating a {@code StructuredTaskScope} with {@link #open()} or {@link #open(Joiner)}\n+     * uses the <a href=\"StructuredTaskScope.html#DefaultConfiguration\">default\n+     * configuration<\/a>. The default configuration consists of a thread factory that\n+     * creates unnamed <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">\n+     * virtual threads<\/a>, no name for monitoring and management purposes, and no timeout.\n+     *\n+     * <p> Creating a {@code StructuredTaskScope} with its 2-arg {@link #open(Joiner, Function)\n+     * open} method allows a different configuration to be used. The function specified\n+     * to the {@code open} method is applied to the default configuration and returns the\n+     * configuration for the {@code StructuredTaskScope} under construction. The function\n+     * can use the {@code with-} prefixed methods defined here to specify the components\n+     * of the configuration to use.\n@@ -1154,5 +749,1 @@\n-     * @apiNote This class implements a policy to shut down the task scope when a subtask\n-     * fails. There shouldn't be any need to directly shut down the task scope with the\n-     * {@link #shutdown() shutdown} method.\n-     *\n-     * @since 21\n+     * @since 25\n@@ -1161,5 +752,1 @@\n-    public static final class ShutdownOnFailure extends StructuredTaskScope<Object> {\n-        private static final VarHandle FIRST_EXCEPTION =\n-                MhUtil.findVarHandle(MethodHandles.lookup(), \"firstException\", Throwable.class);\n-        private volatile Throwable firstException;\n-\n+    sealed interface Configuration permits StructuredTaskScopeImpl.ConfigImpl {\n@@ -1167,5 +754,4 @@\n-         * Constructs a new {@code ShutdownOnFailure} with the given name and thread factory.\n-         * The task scope is optionally named for the purposes of monitoring and management.\n-         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n-         * threads when subtasks are {@linkplain #fork(Callable) forked}. The task scope\n-         * is owned by the current thread.\n+         * {@return a new {@code Configuration} object with the given thread factory}\n+         * The other components are the same as this object. The thread factory is used by\n+         * a scope to create threads when {@linkplain #fork(Callable) forking} subtasks.\n+         * @param threadFactory the thread factory\n@@ -1173,5 +759,4 @@\n-         * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n-         * value} bindings for inheritance by threads started in the task scope. The\n-         * {@linkplain StructuredTaskScope##TreeStructure Tree Structure} section in the class description\n-         * details how parent-child relations are established implicitly for the purpose\n-         * of inheritance of scoped value bindings.\n+         * @apiNote The thread factory will typically create\n+         * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>,\n+         * maybe with names for monitoring purposes, an {@linkplain Thread.UncaughtExceptionHandler\n+         * uncaught exception handler}, or other properties configured.\n@@ -1179,2 +764,1 @@\n-         * @param name the name of the task scope, can be null\n-         * @param factory the thread factory\n+         * @see #fork(Callable)\n@@ -1182,3 +766,1 @@\n-        public ShutdownOnFailure(String name, ThreadFactory factory) {\n-            super(name, factory);\n-        }\n+        Configuration withThreadFactory(ThreadFactory threadFactory);\n@@ -1187,4 +769,4 @@\n-         * Constructs a new unnamed {@code ShutdownOnFailure} that creates virtual threads.\n-         *\n-         * @implSpec This constructor is equivalent to invoking the 2-arg constructor with\n-         * a name of {@code null} and a thread factory that creates virtual threads.\n+         * {@return a new {@code Configuration} object with the given name}\n+         * The other components are the same as this object. A scope is optionally\n+         * named for the purposes of monitoring and management.\n+         * @param name the name\n@@ -1192,12 +774,1 @@\n-        public ShutdownOnFailure() {\n-            this(null, Thread.ofVirtual().factory());\n-        }\n-\n-        @Override\n-        protected void handleComplete(Subtask<?> subtask) {\n-            if (subtask.state() == Subtask.State.FAILED\n-                    && firstException == null\n-                    && FIRST_EXCEPTION.compareAndSet(this, null, subtask.exception())) {\n-                super.shutdown();\n-            }\n-        }\n+        Configuration withName(String name);\n@@ -1206,8 +777,3 @@\n-         * Wait for all subtasks started in this task scope to complete or for a subtask\n-         * to {@linkplain Subtask.State#FAILED fail}.\n-         *\n-         * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n-         * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n-         * when all threads finish, a subtask fails, or the current thread is {@linkplain\n-         * Thread#interrupt() interrupted}. It also stops waiting if the {@link #shutdown()\n-         * shutdown} method is invoked directly to shut down this task scope.\n+         * {@return a new {@code Configuration} object with the given timeout}\n+         * The other components are the same as this object.\n+         * @param timeout the timeout\n@@ -1215,1 +781,3 @@\n-         * <p> This method may only be invoked by the task scope owner.\n+         * @apiNote Applications using deadlines, expressed as an {@link java.time.Instant},\n+         * can use {@link Duration#between Duration.between(Instant.now(), deadline)} to\n+         * compute the timeout for this method.\n@@ -1217,2 +785,1 @@\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n+         * @see #join()\n@@ -1220,5 +787,2 @@\n-        @Override\n-        public ShutdownOnFailure join() throws InterruptedException {\n-            super.join();\n-            return this;\n-        }\n+        Configuration withTimeout(Duration timeout);\n+    }\n@@ -1226,23 +790,10 @@\n-        \/**\n-         * Wait for all subtasks started in this task scope to complete or for a subtask\n-         * to {@linkplain Subtask.State#FAILED fail}, up to the given deadline.\n-         *\n-         * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n-         * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n-         * when all threads finish, a subtask fails, the deadline is reached, or the current\n-         * thread is {@linkplain Thread#interrupt() interrupted}. It also stops waiting\n-         * if the {@link #shutdown() shutdown} method is invoked directly to shut down\n-         * this task scope.\n-         *\n-         * <p> This method may only be invoked by the task scope owner.\n-         *\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n-         *\/\n-        @Override\n-        public ShutdownOnFailure joinUntil(Instant deadline)\n-            throws InterruptedException, TimeoutException\n-        {\n-            super.joinUntil(deadline);\n-            return this;\n-        }\n+    \/**\n+     * Exception thrown by {@link #join()} when the outcome is an exception rather than a\n+     * result.\n+     *\n+     * @since 25\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    final class FailedException extends RuntimeException {\n+        @java.io.Serial\n+        static final long serialVersionUID = -1533055100078459923L;\n@@ -1251,5 +802,1 @@\n-         * Returns the exception of the first subtask that {@linkplain Subtask.State#FAILED\n-         * failed}. If no subtasks failed then an empty {@code Optional} is returned.\n-         *\n-         * @return the exception for the first subtask to fail or an empty optional if no\n-         * subtasks failed\n+         * Constructs a {@code FailedException} with the specified cause.\n@@ -1257,2 +804,1 @@\n-         * @throws WrongThreadException if the current thread is not the task scope owner\n-         * @throws IllegalStateException if the task scope owner did not join after forking\n+         * @param  cause the cause, can be {@code null}\n@@ -1260,3 +806,2 @@\n-        public Optional<Throwable> exception() {\n-            ensureOwnerAndJoined();\n-            return Optional.ofNullable(firstException);\n+        FailedException(Throwable cause) {\n+            super(cause);\n@@ -1264,0 +809,1 @@\n+    }\n@@ -1265,13 +811,11 @@\n-        \/**\n-         * Throws if a subtask {@linkplain Subtask.State#FAILED failed}.\n-         * If any subtask failed with an exception then {@code ExecutionException} is\n-         * thrown with the exception of the first subtask to fail as the {@linkplain\n-         * Throwable#getCause() cause}. This method does nothing if no subtasks failed.\n-         *\n-         * @throws ExecutionException if a subtask failed\n-         * @throws WrongThreadException if the current thread is not the task scope owner\n-         * @throws IllegalStateException if the task scope owner did not join after forking\n-         *\/\n-        public void throwIfFailed() throws ExecutionException {\n-            throwIfFailed(ExecutionException::new);\n-        }\n+    \/**\n+     * Exception thrown by {@link #join()} if the scope was created with a timeout and\n+     * the timeout expired before or while waiting in {@code join}.\n+     *\n+     * @since 25\n+     * @see Configuration#withTimeout(Duration)\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    final class TimeoutException extends RuntimeException {\n+        @java.io.Serial\n+        static final long serialVersionUID = 705788143955048766L;\n@@ -1280,12 +824,1 @@\n-         * Throws the exception produced by the given exception supplying function if a\n-         * subtask {@linkplain Subtask.State#FAILED failed}. If any subtask failed with\n-         * an exception then the function is invoked with the exception of the first\n-         * subtask to fail. The exception returned by the function is thrown. This method\n-         * does nothing if no subtasks failed.\n-         *\n-         * @param esf the exception supplying function\n-         * @param <X> type of the exception to be thrown\n-         *\n-         * @throws X produced by the exception supplying function\n-         * @throws WrongThreadException if the current thread is not the task scope owner\n-         * @throws IllegalStateException if the task scope owner did not join after forking\n+         * Constructs a {@code TimeoutException} with no detail message.\n@@ -1293,11 +826,90 @@\n-        public <X extends Throwable>\n-        void throwIfFailed(Function<Throwable, ? extends X> esf) throws X {\n-            ensureOwnerAndJoined();\n-            Objects.requireNonNull(esf);\n-            Throwable exception = firstException;\n-            if (exception != null) {\n-                X ex = esf.apply(exception);\n-                Objects.requireNonNull(ex, \"esf returned null\");\n-                throw ex;\n-            }\n-        }\n+        TimeoutException() { }\n+    }\n+\n+    \/**\n+     * Opens a new {@code StructuredTaskScope} to use the given {@code Joiner} object and\n+     * with configuration that is the result of applying the given function to the\n+     * <a href=\"#DefaultConfiguration\">default configuration<\/a>.\n+     *\n+     * <p> The {@code configFunction} is called with the default configuration and returns\n+     * the configuration for the new scope. The function may, for example, set the\n+     * {@linkplain Configuration#withThreadFactory(ThreadFactory) ThreadFactory} or set a\n+     * {@linkplain Configuration#withTimeout(Duration) timeout}. If the function completes\n+     * with an exception or error then it is propagated by this method. If the function\n+     * returns {@code null} then {@code NullPointerException} is thrown.\n+     *\n+     * <p> If a {@code ThreadFactory} is set then its {@link ThreadFactory#newThread(Runnable)\n+     * newThread} method will be called to create threads when {@linkplain #fork(Callable)\n+     * forking} subtasks in this scope. If a {@code ThreadFactory} is not set then\n+     * forking subtasks will create an unnamed virtual thread for each subtask.\n+     *\n+     * <p> If a {@linkplain Configuration#withTimeout(Duration) timeout} is set then it\n+     * starts when the scope is opened. If the timeout expires before the scope has\n+     * {@linkplain #join() joined} then the scope is <a href=\"#Cancallation\">cancelled<\/a>\n+     * and the {@code join} method throws {@link TimeoutException}.\n+     *\n+     * <p> The new scope is owned by the current thread. Only code executing in this\n+     * thread can {@linkplain #fork(Callable) fork}, {@linkplain #join() join}, or\n+     * {@linkplain #close close} the scope.\n+     *\n+     * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n+     * value} bindings for inheritance by threads started in the scope.\n+     *\n+     * @param joiner the joiner\n+     * @param configFunction a function to produce the configuration\n+     * @return a new scope\n+     * @param <T> the result type of subtasks executed in the scope\n+     * @param <R> the result type of the scope\n+     * @since 25\n+     *\/\n+    static <T, R> StructuredTaskScope<T, R> open(Joiner<? super T, ? extends R> joiner,\n+                                                 Function<Configuration, Configuration> configFunction) {\n+        return StructuredTaskScopeImpl.open(joiner, configFunction);\n+    }\n+\n+    \/**\n+     * Opens a new {@code StructuredTaskScope}to use the given {@code Joiner} object. The\n+     * scope is created with the <a href=\"#DefaultConfiguration\">default configuration<\/a>.\n+     * The default configuration has a {@code ThreadFactory} that creates unnamed\n+     * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>,\n+     * is unnamed for monitoring and management purposes, and has no timeout.\n+     *\n+     * @implSpec\n+     * This factory method is equivalent to invoking the 2-arg open method with the given\n+     * joiner and the {@linkplain Function#identity() identity function}.\n+     *\n+     * @param joiner the joiner\n+     * @return a new scope\n+     * @param <T> the result type of subtasks executed in the scope\n+     * @param <R> the result type of the scope\n+     * @since 25\n+     *\/\n+    static <T, R> StructuredTaskScope<T, R> open(Joiner<? super T, ? extends R> joiner) {\n+        return open(joiner, Function.identity());\n+    }\n+\n+    \/**\n+     * Opens a new {@code StructuredTaskScope} that can be used to fork subtasks that return\n+     * results of any type. The scope's {@link #join()} method waits for all subtasks to\n+     * succeed or any subtask to fail.\n+     *\n+     * <p> The {@code join} method returns {@code null} if all subtasks complete successfully.\n+     * It throws {@link FailedException} if any subtask fails, with the exception from\n+     * the first subtask to fail as the cause.\n+     *\n+     * <p> The scope is created with the <a href=\"#DefaultConfiguration\">default\n+     * configuration<\/a>. The default configuration has a {@code ThreadFactory} that creates\n+     * unnamed <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual\n+     * threads<\/a>, is unnamed for monitoring and management purposes, and has no timeout.\n+     *\n+     * @implSpec\n+     * This factory method is equivalent to invoking the 2-arg open method with a joiner\n+     * created with {@link Joiner#awaitAllSuccessfulOrThrow() awaitAllSuccessfulOrThrow()}\n+     * and the {@linkplain Function#identity() identity function}.\n+     *\n+     * @param <T> the result type of subtasks\n+     * @return a new scope\n+     * @since 25\n+     *\/\n+    static <T> StructuredTaskScope<T, Void> open() {\n+        return open(Joiner.awaitAllSuccessfulOrThrow(), Function.identity());\n@@ -1305,1 +917,156 @@\n-}\n+\n+    \/**\n+     * Fork a subtask by starting a new thread in this scope to execute a value-returning\n+     * method. The new thread executes the subtask concurrently with the current thread.\n+     * The parameter to this method is a {@link Callable}, the new thread executes its\n+     * {@link Callable#call() call()} method.\n+     *\n+     * <p> This method first creates a {@link Subtask Subtask} object to represent the\n+     * <em>forked subtask<\/em>. It invokes the joiner's {@link Joiner#onFork(Subtask) onFork}\n+     * method with the subtask in the {@link Subtask.State#UNAVAILABLE UNAVAILABLE} state.\n+     * If the {@code onFork} completes with an exception or error then it is propagated by\n+     * the {@code fork} method without creating a thread. If the scope is already\n+     * <a href=\"#Cancallation\">cancelled<\/a>, or {@code onFork} returns {@code true} to\n+     * cancel the scope, then this method returns the {@code Subtask}, in the\n+     * {@link Subtask.State#UNAVAILABLE UNAVAILABLE} state, without creating a thread to\n+     * execute the subtask.\n+     *\n+     * <p> If the scope is not cancelled, and the {@code onFork} method returns {@code false},\n+     * then a thread is created with the {@link ThreadFactory} configured when the scope\n+     * was opened, and the thread is started. Forking a subtask inherits the current thread's\n+     * {@linkplain ScopedValue scoped value} bindings. The bindings must match the bindings\n+     * captured when the scope was opened. If the subtask completes (successfully or with\n+     * an exception) before the scope is cancelled, then the thread invokes the joiner's\n+     * {@link Joiner#onComplete(Subtask) onComplete} method with the subtask in the\n+     * {@link Subtask.State#SUCCESS SUCCESS} or {@link Subtask.State#FAILED FAILED} state.\n+     * If the {@code onComplete} method completes with an exception or error, then the\n+     * {@linkplain Thread.UncaughtExceptionHandler uncaught exception handler} is invoked\n+     * with the exception or error before the thread terminates.\n+     *\n+     * <p> This method returns the {@link Subtask Subtask} object. In some usages, this\n+     * object may be used to get its result. In other cases it may be used for correlation\n+     * or be discarded. To ensure correct usage, the {@link Subtask#get() Subtask.get()}\n+     * method may only be called by the scope owner to get the result after it has\n+     * waited for subtasks to complete with the {@link #join() join} method and the subtask\n+     * completed successfully. Similarly, the {@link Subtask#exception() Subtask.exception()}\n+     * method may only be called by the scope owner after it has joined and the subtask\n+     * failed. If the scope was cancelled before the subtask was forked, or before it\n+     * completes, then neither method can be used to obtain the outcome.\n+     *\n+     * <p> This method may only be invoked by the scope owner.\n+     *\n+     * @param task the value-returning task for the thread to execute\n+     * @param <U> the result type\n+     * @return the subtask\n+     * @throws WrongThreadException if the current thread is not the scope owner\n+     * @throws IllegalStateException if the owner has already {@linkplain #join() joined}\n+     * or the scope is closed\n+     * @throws StructureViolationException if the current scoped value bindings are not\n+     * the same as when the scope was created\n+     * @throws RejectedExecutionException if the thread factory rejected creating a\n+     * thread to run the subtask\n+     *\/\n+    <U extends T> Subtask<U> fork(Callable<? extends U> task);\n+\n+    \/**\n+     * Fork a subtask by starting a new thread in this scope to execute a method that\n+     * does not return a result.\n+     *\n+     * <p> This method works exactly the same as {@link #fork(Callable)} except that the\n+     * parameter to this method is a {@link Runnable}, the new thread executes its\n+     * {@link Runnable#run() run} method, and {@link Subtask#get() Subtask.get()} returns\n+     * {@code null} if the subtask completes successfully.\n+     *\n+     * @param task the task for the thread to execute\n+     * @param <U> the result type\n+     * @return the subtask\n+     * @throws WrongThreadException if the current thread is not the scope owner\n+     * @throws IllegalStateException if the owner has already {@linkplain #join() joined}\n+     * or the scope is closed\n+     * @throws StructureViolationException if the current scoped value bindings are not\n+     * the same as when the scope was created\n+     * @throws RejectedExecutionException if the thread factory rejected creating a\n+     * thread to run the subtask\n+     * @since 25\n+     *\/\n+    <U extends T> Subtask<U> fork(Runnable task);\n+\n+    \/**\n+     * Returns the result, or throws, after waiting for all subtasks to complete or\n+     * the scope to be <a href=\"#Cancallation\">cancelled<\/a>.\n+     *\n+     * <p> This method waits for all subtasks started in this scope to complete or the\n+     * scope to be cancelled. If a {@linkplain Configuration#withTimeout(Duration) timeout}\n+     * is configured and the timeout expires before or while waiting, then the scope is\n+     * cancelled and {@link TimeoutException TimeoutException} is thrown. Once finished\n+     * waiting, the {@code Joiner}'s {@link Joiner#result() result()} method is invoked\n+     * to get the result or throw an exception. If the {@code result()} method throws\n+     * then this method throws {@code FailedException} with the exception as the cause.\n+     *\n+     * <p> This method may only be invoked by the scope owner, and only once.\n+     *\n+     * @return the result\n+     * @throws WrongThreadException if the current thread is not the scope owner\n+     * @throws IllegalStateException if already joined or this scope is closed\n+     * @throws FailedException if the <i>outcome<\/i> is an exception, thrown with the\n+     * exception from {@link Joiner#result() Joiner.result()} as the cause\n+     * @throws TimeoutException if a timeout is set and the timeout expires before or\n+     * while waiting\n+     * @throws InterruptedException if interrupted while waiting\n+     * @since 25\n+     *\/\n+    R join() throws InterruptedException;\n+\n+    \/**\n+     * {@return {@code true} if this scope is <a href=\"#Cancallation\">cancelled<\/a> or in\n+     * the process of being cancelled, otherwise {@code false}}\n+     *\n+     * <p> Cancelling the scope prevents new threads from starting in the scope and\n+     * {@linkplain Thread#interrupt() interrupts} threads executing unfinished subtasks.\n+     * It may take some time before the interrupted threads finish execution; this\n+     * method may return {@code true} before all threads have been interrupted or before\n+     * all threads have finished.\n+     *\n+     * @apiNote A task with a lengthy \"forking phase\" (the code that executes before\n+     * it invokes {@link #join() join}) may use this method to avoid doing work in cases\n+     * where scope is cancelled by the completion of a previously forked subtask or timeout.\n+     *\n+     * @since 25\n+     *\/\n+    boolean isCancelled();\n+\n+    \/**\n+     * Closes this scope.\n+     *\n+     * <p> This method first <a href=\"#Cancallation\">cancels<\/a> the scope, if not\n+     * already cancelled. This interrupts the threads executing unfinished subtasks. This\n+     * method then waits for all threads to finish. If interrupted while waiting then it\n+     * will continue to wait until the threads finish, before completing with the interrupt\n+     * status set.\n+     *\n+     * <p> This method may only be invoked by the scope owner. If the scope\n+     * is already closed then the scope owner invoking this method has no effect.\n+     *\n+     * <p> A {@code StructuredTaskScope} is intended to be used in a <em>structured\n+     * manner<\/em>. If this method is called to close a scope before nested task\n+     * scopes are closed then it closes the underlying construct of each nested scope\n+     * (in the reverse order that they were created in), closes this scope, and then\n+     * throws {@link StructureViolationException}.\n+     * Similarly, if this method is called to close a scope while executing with\n+     * {@linkplain ScopedValue scoped value} bindings, and the scope was created\n+     * before the scoped values were bound, then {@code StructureViolationException} is\n+     * thrown after closing the scope.\n+     * If a thread terminates without first closing scopes that it owns then\n+     * termination will cause the underlying construct of each of its open tasks scopes to\n+     * be closed. Closing is performed in the reverse order that the scopes were\n+     * created in. Thread termination may therefore be delayed when the scope owner\n+     * has to wait for threads forked in these scopes to finish.\n+     *\n+     * @throws IllegalStateException thrown after closing the scope if the scope\n+     * owner did not attempt to join after forking\n+     * @throws WrongThreadException if the current thread is not the scope owner\n+     * @throws StructureViolationException if a structure violation was detected\n+     *\/\n+    @Override\n+    void close();\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":857,"deletions":1090,"binary":false,"changes":1947,"status":"modified"},{"patch":"@@ -0,0 +1,417 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.time.Duration;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import jdk.internal.misc.ThreadFlock;\n+import jdk.internal.invoke.MhUtil;\n+\n+\/**\n+ * StructuredTaskScope implementation.\n+ *\/\n+final class StructuredTaskScopeImpl<T, R> implements StructuredTaskScope<T, R> {\n+    private static final VarHandle CANCELLED =\n+            MhUtil.findVarHandle(MethodHandles.lookup(), \"cancelled\", boolean.class);\n+\n+    private final Joiner<? super T, ? extends R> joiner;\n+    private final ThreadFactory threadFactory;\n+    private final ThreadFlock flock;\n+\n+    \/\/ state, only accessed by owner thread\n+    private static final int ST_NEW            = 0,\n+                             ST_FORKED         = 1,   \/\/ subtasks forked, need to join\n+                             ST_JOIN_STARTED   = 2,   \/\/ join started, can no longer fork\n+                             ST_JOIN_COMPLETED = 3,   \/\/ join completed\n+                             ST_CLOSED         = 4;   \/\/ closed\n+    private int state;\n+\n+    \/\/ timer task, only accessed by owner thread\n+    private Future<?> timerTask;\n+\n+    \/\/ set or read by any thread\n+    private volatile boolean cancelled;\n+\n+    \/\/ set by the timer thread, read by the owner thread\n+    private volatile boolean timeoutExpired;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    private StructuredTaskScopeImpl(Joiner<? super T, ? extends R> joiner,\n+                                    ThreadFactory threadFactory,\n+                                    String name) {\n+        this.joiner = joiner;\n+        this.threadFactory = threadFactory;\n+        this.flock = ThreadFlock.open((name != null) ? name : Objects.toIdentityString(this));\n+    }\n+\n+    \/**\n+     * Returns a new {@code StructuredTaskScope} to use the given {@code Joiner} object\n+     * and with configuration that is the result of applying the given function to the\n+     * default configuration.\n+     *\/\n+    static <T, R> StructuredTaskScope<T, R> open(Joiner<? super T, ? extends R> joiner,\n+                                                 Function<Configuration, Configuration> configFunction) {\n+        Objects.requireNonNull(joiner);\n+\n+        var config = (ConfigImpl) configFunction.apply(ConfigImpl.defaultConfig());\n+        var scope = new StructuredTaskScopeImpl<T, R>(joiner, config.threadFactory(), config.name());\n+\n+        \/\/ schedule timeout\n+        Duration timeout = config.timeout();\n+        if (timeout != null) {\n+            boolean scheduled = false;\n+            try {\n+                scope.scheduleTimeout(timeout);\n+                scheduled = true;\n+            } finally {\n+                if (!scheduled) {\n+                    scope.close();  \/\/ pop if scheduling timeout failed\n+                }\n+            }\n+        }\n+\n+        return scope;\n+    }\n+\n+    \/**\n+     * Throws WrongThreadException if the current thread is not the owner thread.\n+     *\/\n+    private void ensureOwner() {\n+        if (Thread.currentThread() != flock.owner()) {\n+            throw new WrongThreadException(\"Current thread not owner\");\n+        }\n+    }\n+\n+    \/**\n+     * Throws IllegalStateException if already joined or scope is closed.\n+     *\/\n+    private void ensureNotJoined() {\n+        assert Thread.currentThread() == flock.owner();\n+        if (state > ST_FORKED) {\n+            throw new IllegalStateException(\"Already joined or scope is closed\");\n+        }\n+    }\n+\n+    \/**\n+     * Throws IllegalStateException if invoked by the owner thread and the owner thread\n+     * has not joined.\n+     *\/\n+    private void ensureJoinedIfOwner() {\n+        if (Thread.currentThread() == flock.owner() && state <= ST_JOIN_STARTED) {\n+            throw new IllegalStateException(\"join not called\");\n+        }\n+    }\n+\n+    \/**\n+     * Interrupts all threads in this scope, except the current thread.\n+     *\/\n+    private void interruptAll() {\n+        flock.threads()\n+                .filter(t -> t != Thread.currentThread())\n+                .forEach(t -> {\n+                    try {\n+                        t.interrupt();\n+                    } catch (Throwable ignore) { }\n+                });\n+    }\n+\n+    \/**\n+     * Cancel the scope if not already cancelled.\n+     *\/\n+    private void cancel() {\n+        if (!cancelled && CANCELLED.compareAndSet(this, false, true)) {\n+            \/\/ prevent new threads from starting\n+            flock.shutdown();\n+\n+            \/\/ interrupt all unfinished threads\n+            interruptAll();\n+\n+            \/\/ wakeup join\n+            flock.wakeup();\n+        }\n+    }\n+\n+    \/**\n+     * Schedules a task to cancel the scope on timeout.\n+     *\/\n+    private void scheduleTimeout(Duration timeout) {\n+        assert Thread.currentThread() == flock.owner() && timerTask == null;\n+        long nanos = TimeUnit.NANOSECONDS.convert(timeout);\n+        timerTask = ForkJoinPool.commonPool().schedule(() -> {\n+            if (!cancelled) {\n+                timeoutExpired = true;\n+                cancel();\n+            }\n+        }, nanos, TimeUnit.NANOSECONDS);\n+    }\n+\n+    \/**\n+     * Cancels the timer task if set.\n+     *\/\n+    private void cancelTimeout() {\n+        assert Thread.currentThread() == flock.owner();\n+        if (timerTask != null) {\n+            timerTask.cancel(false);\n+        }\n+    }\n+\n+    \/**\n+     * Invoked by the thread for a subtask when the subtask completes before scope is cancelled.\n+     *\/\n+    private void onComplete(SubtaskImpl<? extends T> subtask) {\n+        assert subtask.state() != Subtask.State.UNAVAILABLE;\n+        if (joiner.onComplete(subtask)) {\n+            cancel();\n+        }\n+    }\n+\n+    @Override\n+    public <U extends T> Subtask<U> fork(Callable<? extends U> task) {\n+        Objects.requireNonNull(task);\n+        ensureOwner();\n+        ensureNotJoined();\n+\n+        var subtask = new SubtaskImpl<U>(this, task);\n+\n+        \/\/ notify joiner, even if cancelled\n+        if (joiner.onFork(subtask)) {\n+            cancel();\n+        }\n+\n+        if (!cancelled) {\n+            \/\/ create thread to run task\n+            Thread thread = threadFactory.newThread(subtask);\n+            if (thread == null) {\n+                throw new RejectedExecutionException(\"Rejected by thread factory\");\n+            }\n+\n+            \/\/ attempt to start the thread\n+            try {\n+                flock.start(thread);\n+            } catch (IllegalStateException e) {\n+                \/\/ shutdown by another thread, or underlying flock is shutdown due\n+                \/\/ to unstructured use\n+            }\n+        }\n+\n+        \/\/ force owner to join\n+        state = ST_FORKED;\n+        return subtask;\n+    }\n+\n+    @Override\n+    public <U extends T> Subtask<U> fork(Runnable task) {\n+        Objects.requireNonNull(task);\n+        return fork(() -> { task.run(); return null; });\n+    }\n+\n+    @Override\n+    public R join() throws InterruptedException {\n+        ensureOwner();\n+        ensureNotJoined();\n+\n+        \/\/ join started\n+        state = ST_JOIN_STARTED;\n+\n+        \/\/ wait for all subtasks, the scope to be cancelled, or interrupt\n+        flock.awaitAll();\n+\n+        \/\/ throw if timeout expired\n+        if (timeoutExpired) {\n+            throw new TimeoutException();\n+        }\n+        cancelTimeout();\n+\n+        \/\/ all subtasks completed or cancelled\n+        state = ST_JOIN_COMPLETED;\n+\n+        \/\/ invoke joiner to get result\n+        try {\n+            return joiner.result();\n+        } catch (Throwable e) {\n+            throw new FailedException(e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isCancelled() {\n+        return cancelled;\n+    }\n+\n+    @Override\n+    public void close() {\n+        ensureOwner();\n+        int s = state;\n+        if (s == ST_CLOSED) {\n+            return;\n+        }\n+\n+        \/\/ cancel the scope if join did not complete\n+        if (s < ST_JOIN_COMPLETED) {\n+            cancel();\n+            cancelTimeout();\n+        }\n+\n+        \/\/ wait for stragglers\n+        try {\n+            flock.close();\n+        } finally {\n+            state = ST_CLOSED;\n+        }\n+\n+        \/\/ throw ISE if the owner didn't join after forking\n+        if (s == ST_FORKED) {\n+            throw new IllegalStateException(\"Owner did not join after forking\");\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return flock.name();\n+    }\n+\n+    \/**\n+     * Subtask implementation, runs the task specified to the fork method.\n+     *\/\n+    static final class SubtaskImpl<T> implements Subtask<T>, Runnable {\n+        private static final AltResult RESULT_NULL = new AltResult(Subtask.State.SUCCESS);\n+\n+        private record AltResult(Subtask.State state, Throwable exception) {\n+            AltResult(Subtask.State state) {\n+                this(state, null);\n+            }\n+        }\n+\n+        private final StructuredTaskScopeImpl<? super T, ?> scope;\n+        private final Callable<? extends T> task;\n+        private volatile Object result;\n+\n+        SubtaskImpl(StructuredTaskScopeImpl<? super T, ?> scope, Callable<? extends T> task) {\n+            this.scope = scope;\n+            this.task = task;\n+        }\n+\n+        @Override\n+        public void run() {\n+            T result = null;\n+            Throwable ex = null;\n+            try {\n+                result = task.call();\n+            } catch (Throwable e) {\n+                ex = e;\n+            }\n+\n+            \/\/ nothing to do if scope is cancelled\n+            if (scope.isCancelled())\n+                return;\n+\n+            \/\/ set result\/exception and invoke onComplete\n+            if (ex == null) {\n+                this.result = (result != null) ? result : RESULT_NULL;\n+            } else {\n+                this.result = new AltResult(State.FAILED, ex);\n+            }\n+            scope.onComplete(this);\n+        }\n+\n+        @Override\n+        public Subtask.State state() {\n+            Object result = this.result;\n+            if (result == null) {\n+                return State.UNAVAILABLE;\n+            } else if (result instanceof AltResult alt) {\n+                \/\/ null or failed\n+                return alt.state();\n+            } else {\n+                return State.SUCCESS;\n+            }\n+        }\n+\n+        @Override\n+        public T get() {\n+            scope.ensureJoinedIfOwner();\n+            Object result = this.result;\n+            if (result instanceof AltResult) {\n+                if (result == RESULT_NULL) return null;\n+            } else if (result != null) {\n+                @SuppressWarnings(\"unchecked\")\n+                T r = (T) result;\n+                return r;\n+            }\n+            throw new IllegalStateException(\n+                    \"Result is unavailable or subtask did not complete successfully\");\n+        }\n+\n+        @Override\n+        public Throwable exception() {\n+            scope.ensureJoinedIfOwner();\n+            Object result = this.result;\n+            if (result instanceof AltResult alt && alt.state() == State.FAILED) {\n+                return alt.exception();\n+            }\n+            throw new IllegalStateException(\n+                    \"Exception is unavailable or subtask did not complete with exception\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String stateAsString = switch (state()) {\n+                case UNAVAILABLE -> \"[Unavailable]\";\n+                case SUCCESS     -> \"[Completed successfully]\";\n+                case FAILED      -> \"[Failed: \" + ((AltResult) result).exception() + \"]\";\n+            };\n+            return Objects.toIdentityString(this) + stateAsString;\n+        }\n+    }\n+\n+    \/**\n+     * Configuration implementation.\n+     *\/\n+    record ConfigImpl(ThreadFactory threadFactory,\n+                      String name,\n+                      Duration timeout) implements Configuration {\n+        static Configuration defaultConfig() {\n+            return new ConfigImpl(Thread.ofVirtual().factory(), null, null);\n+        }\n+\n+        @Override\n+        public Configuration withThreadFactory(ThreadFactory threadFactory) {\n+            return new ConfigImpl(Objects.requireNonNull(threadFactory), name, timeout);\n+        }\n+\n+        @Override\n+        public Configuration withName(String name) {\n+            return new ConfigImpl(threadFactory, Objects.requireNonNull(name), timeout);\n+        }\n+\n+        @Override\n+        public Configuration withTimeout(Duration timeout) {\n+            return new ConfigImpl(threadFactory, name, Objects.requireNonNull(timeout));\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScopeImpl.java","additions":417,"deletions":0,"binary":false,"changes":417,"status":"added"},{"patch":"@@ -74,1 +74,1 @@\n-        @JEP(number=499, title=\"Structured Concurrency\", status=\"Fourth Preview\")\n+        @JEP(number=505, title=\"Structured Concurrency\", status=\"Fifth Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+ * @param enumType     the class type of the Enum\n@@ -50,0 +51,2 @@\n+ * @param member       an int predicate that can be used to test if an enum is a member\n+ *                     of the valid inputs (as there might be \"holes\")\n@@ -67,1 +70,0 @@\n-        final StableValueImpl<R> delegate;\n@@ -69,2 +71,1 @@\n-        delegate = delegates[index];\n-        return delegate.orElseSet(new Supplier<R>() {\n+        return delegates[index].orElseSet(new Supplier<R>() {\n@@ -87,0 +88,1 @@\n+        final Collection<Map.Entry<E, StableValueImpl<R>>> entries = new ArrayList<>(delegates.length);\n@@ -88,1 +90,0 @@\n-        final Collection<Map.Entry<E, StableValueImpl<R>>> entries = new ArrayList<>(enumElements.length);\n@@ -102,1 +103,1 @@\n-        final Class<E> enumType = (Class<E>)inputs.iterator().next().getClass();\n+        final Class<E> enumType = ((E) inputs.iterator().next()).getDeclaringClass();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableEnumFunction.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-\/\/ Note: It would be possible to just use `LazyMap::get` with some additional logic\n+\/\/ Note: It would be possible to just use `StableMap::get` with some additional logic\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableFunction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-\/\/ Note: It would be possible to just use `LazyList::get` instead of this\n-\/\/ class but explicitly providing a class like this provides better\n-\/\/ debug capability, exception handling, and may provide better performance.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableIntFunction.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-        final Object t = delegate.wrappedContentAcquire();\n+        final Object t = delegate.wrappedContentsAcquire();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableSupplier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-            final Object value = delegates[i + offset].wrappedContentAcquire();\n+            final Object value = delegates[i + offset].wrappedContentsAcquire();\n@@ -66,1 +66,1 @@\n-            final Object value = e.getValue().wrappedContentAcquire();\n+            final Object value = e.getValue().wrappedContentsAcquire();\n@@ -69,1 +69,1 @@\n-                valueString = (\"(this \") + selfName + \")\";\n+                valueString = \"(this \" + selfName + \")\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableUtil.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    private static final long CONTENT_OFFSET =\n+    private static final long CONTENTS_OFFSET =\n@@ -56,2 +56,2 @@\n-    \/\/ Used to indicate a holder value is `null` (see field `value` below)\n-    \/\/ A wrapper method `nullSentinel()` is used for generic type conversion.\n+\n+    \/\/ Used to indicate a holder value is `null` (see field `contents` below)\n@@ -80,1 +80,1 @@\n-        if (wrappedContentAcquire() != null) {\n+        if (wrappedContentsAcquire() != null) {\n@@ -86,1 +86,1 @@\n-        \/\/ attempt to modify the `wrappedValue`\n+        \/\/ attempt to modify `this.contents`\n@@ -105,1 +105,1 @@\n-        final Object t = wrappedContentAcquire();\n+        final Object t = wrappedContentsAcquire();\n@@ -115,1 +115,1 @@\n-        final Object t = wrappedContentAcquire();\n+        final Object t = wrappedContentsAcquire();\n@@ -122,1 +122,1 @@\n-        return wrappedContentAcquire() != null;\n+        return wrappedContentsAcquire() != null;\n@@ -129,1 +129,1 @@\n-        final Object t = wrappedContentAcquire();\n+        final Object t = wrappedContentsAcquire();\n@@ -152,1 +152,1 @@\n-        final Object t = wrappedContentAcquire();\n+        final Object t = wrappedContentsAcquire();\n@@ -161,2 +161,2 @@\n-    public Object wrappedContentAcquire() {\n-        return UNSAFE.getReferenceAcquire(this, CONTENT_OFFSET);\n+    public Object wrappedContentsAcquire() {\n+        return UNSAFE.getReferenceAcquire(this, CONTENTS_OFFSET);\n@@ -188,1 +188,1 @@\n-    private boolean wrapAndSet(Object newValue) {\n+    private boolean wrapAndSet(T newValue) {\n@@ -192,1 +192,1 @@\n-            UNSAFE.putReferenceRelease(this, CONTENT_OFFSET, wrap(newValue));\n+            UNSAFE.putReferenceRelease(this, CONTENTS_OFFSET, wrap(newValue));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/lang\/stable\/StableValueImpl.java","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -275,6 +275,0 @@\n-     *\n-     * <p> This method may only be invoked by the flock owner or threads {@linkplain\n-     * #containsThread(Thread) contained} in the flock.\n-     *\n-     * @throws WrongThreadException if the current thread is not the owner or a thread\n-     * contained in the flock\n@@ -283,1 +277,0 @@\n-        ensureOwnerOrContainsThread();\n@@ -373,3 +366,0 @@\n-     *\n-     * @throws WrongThreadException if the current thread is not the owner or a thread\n-     * contained in the flock\n@@ -378,1 +368,0 @@\n-        ensureOwnerOrContainsThread();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadFlock.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,18 @@\n+    \/**\n+     * Pins the current continuation if the VM has continuations support.\n+     *\/\n+    public static void pinIfSupported() {\n+        if (isSupported()) {\n+            Continuation.pin();\n+        }\n+    }\n+\n+    \/**\n+     * Unpins the current continuation if the VM has continuations support.\n+     *\/\n+    public static void unpinIfSupported() {\n+        if (isSupported()) {\n+            Continuation.unpin();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ContinuationSupport.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-     * Invoked by Thread::start before the given Thread is started.\n+     * Invoked by {@code add} to add a thread to this container before it starts.\n@@ -81,2 +81,1 @@\n-    public void onStart(Thread thread) {\n-        \/\/ do nothing\n+    protected void onStart(Thread thread) {\n@@ -86,8 +85,2 @@\n-     * Invoked when a Thread terminates or starting it fails.\n-     *\n-     * For a platform thread, this method is invoked by the thread itself when it\n-     * terminates. For a virtual thread, this method is invoked on its carrier\n-     * after the virtual thread has terminated.\n-     *\n-     * If starting the Thread failed then this method is invoked on the thread\n-     * that invoked onStart.\n+     * Invoked by {@code remove} to remove a thread from this container when it\n+     * terminates (or failed to start).\n@@ -95,2 +88,34 @@\n-    public void onExit(Thread thread) {\n-        \/\/ do nothing\n+    protected void onExit(Thread thread) {\n+    }\n+\n+    \/**\n+     * Adds a thread to this container. This method should be invoked before the\n+     * thread executes.\n+     *\/\n+    public final void add(Thread thread) {\n+        \/\/ Prevent a virtual thread from being preempted as this could potentially\n+        \/\/ deadlock when scheduled to continue and all carriers are blocked adding\n+        \/\/ or removing virtual threads.\n+        ContinuationSupport.pinIfSupported();\n+        try {\n+            onStart(thread);\n+        } finally {\n+            ContinuationSupport.unpinIfSupported();\n+        }\n+    }\n+\n+    \/**\n+     * Remove a thread from this container. This method can be invoked by the thread\n+     * itself as it terminates, or it can be invoked by another thread after the given\n+     * thread has terminated (or failed to start).\n+     *\/\n+    public final void remove(Thread thread) {\n+        \/\/ Prevent a virtual thread from being preempted as this could potentially\n+        \/\/ deadlock when scheduled to continue and all carriers are blocked adding\n+        \/\/ or removing virtual threads.\n+        ContinuationSupport.pinIfSupported();\n+        try {\n+            onExit(thread);\n+        } finally {\n+            ContinuationSupport.unpinIfSupported();\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainer.java","additions":39,"deletions":14,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.vm.Continuation;\n@@ -109,3 +108,1 @@\n-        if (ContinuationSupport.isSupported())\n-            Continuation.pin();\n-\n+        ContinuationSupport.pinIfSupported();\n@@ -129,2 +126,1 @@\n-                if (ContinuationSupport.isSupported())\n-                    Continuation.unpin();\n+                ContinuationSupport.unpinIfSupported();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsSecurity.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        if (FontUtilities.isDefaultIgnorable(unicode)) {\n+        if (FontUtilities.isDefaultIgnorable(unicode) || isIgnorableWhitespace(unicode)) {\n@@ -133,0 +133,6 @@\n+    \/\/ Matches behavior in e.g. CMap.getControlCodeGlyph(int, boolean)\n+    \/\/ and RasterPrinterJob.removeControlChars(String)\n+    private static boolean isIgnorableWhitespace(int code) {\n+        return code == 0x0009 || code == 0x000a || code == 0x000d;\n+    }\n+\n@@ -256,1 +262,1 @@\n-                } else if (FontUtilities.isDefaultIgnorable(code)) {\n+                } else if (FontUtilities.isDefaultIgnorable(code) || isIgnorableWhitespace(code)) {\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CCharToGlyphMapper.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -1741,3 +1741,1 @@\n-        if (storedInsets.get(win.getClass()) == null) {\n-            storedInsets.put(win.getClass(), correctWM);\n-        }\n+        storedInsets.putIfAbsent(win.getClass(), correctWM);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWM.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4547,1 +4547,1 @@\n-                    return rs.resolveSelf(pos, env, site.tsym, name);\n+                    return rs.resolveSelf(pos, env, site.tsym, tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -3858,2 +3858,2 @@\n-     * @param c             The qualifier.\n-     * @param name          The identifier's name.\n+     * @param c             The type of the selected expression\n+     * @param tree          The expression\n@@ -3864,1 +3864,2 @@\n-                       Name name) {\n+                       JCFieldAccess tree) {\n+        Name name = tree.name;\n@@ -3875,1 +3876,3 @@\n-                    else if (env1.info.ctorPrologue && !isAllowedEarlyReference(pos, env1, (VarSymbol)sym))\n+                    else if (env1.info.ctorPrologue &&\n+                            !isReceiverParameter(env, tree) &&\n+                            !isAllowedEarlyReference(pos, env1, (VarSymbol)sym))\n@@ -3927,0 +3930,6 @@\n+    private boolean isReceiverParameter(Env<AttrContext> env, JCFieldAccess tree) {\n+        if (env.tree.getTag() != METHODDEF)\n+            return false;\n+        JCMethodDecl method = (JCMethodDecl)env.tree;\n+        return method.recvparam != null && tree == method.recvparam.nameexpr;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -392,0 +392,4 @@\n+            if (!isString && !Character.isBmpCodePoint(getCodepoint())) {\n+                lexError(pos, Errors.IllegalCharLiteralMultipleSurrogates);\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,3 +262,1 @@\n-                        TypeElement e2 = (TypeElement)\n-                            ((DeclaredType) supertype).asElement();\n-                        if (e2.getSuperclass().getKind() != TypeKind.NONE)\n+                        if (isImportantType(supertype))\n@@ -527,1 +525,1 @@\n-                             .map(tpe -> annotationsToString(tpe) + tpe.toString())\n+                             .map(tpe -> annotationsToString(tpe) + tpe.toString() + printTypeVariableBoundsIfNeeded(tpe))\n@@ -534,0 +532,16 @@\n+        private String printTypeVariableBoundsIfNeeded(TypeParameterElement tpe) {\n+            List<? extends TypeMirror> printableBounds =\n+                    tpe.getBounds()\n+                       .stream()\n+                       .filter(type -> isImportantType(type))\n+                       .toList();\n+\n+            if (printableBounds.isEmpty()) {\n+                return \"\";\n+            }\n+\n+            return \" extends \" + printableBounds.stream()\n+                                                .map(t -> t.toString())\n+                                                .collect(Collectors.joining(\" & \"));\n+        }\n+\n@@ -773,0 +787,17 @@\n+        \/**{@return true if this type is either not {@code java.lang.Object},\n+         * or is annotated, and hence needs to be included in the output,\n+         * even for cases where there's implicit {@code java.lang.Object} type.}\n+         *\n+         * @param type the type to check.\n+         *\/\n+        private boolean isImportantType(TypeMirror type) {\n+            if (!type.getAnnotationMirrors().isEmpty()) {\n+                return true;\n+            }\n+            TypeElement e2 = (TypeElement)\n+                ((DeclaredType) type).asElement();\n+            if (!e2.getKind().isClass()) {\n+                return true;\n+            }\n+            return e2.getSuperclass().getKind() != TypeKind.NONE;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -697,0 +697,3 @@\n+compiler.err.illegal.char.literal.multiple.surrogates=\\\n+    character literal contains more than one UTF-16 code unit\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -403,6 +403,0 @@\n-        KeyInfo ki = getKeyInfo(keyAlgo);\n-        if (ki == null) {\n-            throw new InvalidKeyException(\"Unknown algorithm \" + keyAlgo);\n-        }\n-\n-        KeyInfo si;\n@@ -411,6 +405,4 @@\n-            si = ki;\n-        } else {\n-            si = getKeyInfo(svcAlgo);\n-            if (si == null) {\n-                throw new InvalidKeyException(\"Unknown algorithm \" + svcAlgo);\n-            }\n+        }\n+        KeyInfo si = getKeyInfo(svcAlgo);\n+        if (si == null) {\n+            throw new InvalidKeyException(\"Unknown algorithm \" + svcAlgo);\n@@ -420,4 +412,5 @@\n-        \/\/ Any key can be used for a MAC service.\n-        if (svcAlgo != keyAlgo && !(si instanceof HMACKeyInfo) &&\n-                !KeyInfo.checkUse(ki, si)) {\n-            throw new InvalidKeyException(\"Cannot use a \" + keyAlgo +\n+        \/\/ Skip this check for Hmac as any key can be used for Mac.\n+        if (svcAlgo != keyAlgo && !(si instanceof HMACKeyInfo)) {\n+            KeyInfo ki = getKeyInfo(keyAlgo);\n+            if (ki == null || !KeyInfo.checkUse(ki, si)) {\n+                throw new InvalidKeyException(\"Cannot use a \" + keyAlgo +\n@@ -425,0 +418,1 @@\n+            }\n@@ -457,0 +451,2 @@\n+            \/\/ make sure key info matches key type\n+            KeyInfo ki = (keyAlgo == svcAlgo ? si : getKeyInfo(keyAlgo));\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.io.IOException;\n@@ -37,0 +38,1 @@\n+import java.nio.file.Files;\n@@ -142,0 +144,1 @@\n+            root = realPath(root);\n@@ -155,0 +158,19 @@\n+    private static Path realPath(Path root) {\n+\n+        \/\/ `toRealPath()` invocation below already checks if file exists, though\n+        \/\/ there is no way to figure out if it fails due to a non-existent file.\n+        \/\/ Hence, checking the existence here first to deliver the user a more\n+        \/\/ descriptive message.\n+        if (!Files.exists(root)) {\n+            throw new IllegalArgumentException(\"Path does not exist: \" + root);\n+        }\n+\n+        \/\/ Obtain the real path\n+        try {\n+            return root.toRealPath();\n+        } catch (IOException exception) {\n+            throw new IllegalArgumentException(\"Path is invalid: \" + root, exception);\n+        }\n+\n+    }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/simpleserver\/SimpleFileServerImpl.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1531,0 +1531,5 @@\n+\n+    \/**\n+     * Returns whether the current thread is a CompilerThread.\n+     *\/\n+    native boolean isCompilerThread();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,0 +54,16 @@\n+            if (runtime.getConfig().getFlag(\"EagerJVMCI\", Boolean.class)) {\n+                if (runtime.getCompilerToVM().isCompilerThread()) {\n+                    throw noCompilerError();\n+                } else {\n+                    \/\/ This path will be taken when initializing JVMCI on a non-JIT thread.\n+                    \/\/ Such a usage of JVMCI might never request a compilation so delay the\n+                    \/\/ noCompilerError until such a request is made.\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Exits the VM due to unavailability of a JVMCI compiler.\n+         *\/\n+        Error noCompilerError() {\n+            throw runtime.exitHotSpotWithMessage(1, \"Cannot use JVMCI compiler: %s%n\", reason);\n@@ -58,1 +74,1 @@\n-            throw runtime.exitHotSpotWithMessage(1, \"Cannot use JVMCI compiler: %s%n\", reason);\n+            throw noCompilerError();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotJVMCICompilerConfig.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -204,2 +204,1 @@\n-            PrettyWriter prettyWriter = new PrettyWriter(pw);\n-            prettyWriter.setShowIds(showIds);\n+            MetadataWriter metadataWriter = new MetadataWriter(pw, showIds);\n@@ -218,1 +217,1 @@\n-                            prettyWriter.printType(type);\n+                            metadataWriter.printType(type);\n@@ -222,1 +221,1 @@\n-                    prettyWriter.printType(type);\n+                    metadataWriter.printType(type);\n@@ -225,1 +224,1 @@\n-            prettyWriter.flush(true);\n+            metadataWriter.flush(true);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Metadata.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.tool;\n+\n+import java.io.PrintWriter;\n+import java.util.List;\n+import java.util.StringJoiner;\n+import jdk.jfr.AnnotationElement;\n+import jdk.jfr.Name;\n+import jdk.jfr.ValueDescriptor;\n+import jdk.jfr.internal.Type;\n+import jdk.jfr.internal.PrivateAccess;\n+\n+\/**\n+* Print event metadata in a human-readable format.\n+*\/\n+final class MetadataWriter extends StructuredWriter {\n+    private final boolean showIds;\n+\n+    public MetadataWriter(PrintWriter p, boolean showIds) {\n+        super(p);\n+        this.showIds = showIds;\n+    }\n+\n+    public void printType(Type t) {\n+        if (showIds) {\n+            print(\"\/\/ id: \");\n+            println(String.valueOf(t.getId()));\n+        }\n+        int commentIndex = t.getName().length() + 10;\n+        String typeName = t.getName();\n+        int index = typeName.lastIndexOf(\".\");\n+        if (index != -1) {\n+            println(\"@Name(\\\"\" + typeName + \"\\\")\");\n+        }\n+        printAnnotations(commentIndex, t.getAnnotationElements());\n+        print(\"class \" + typeName.substring(index + 1));\n+        String superType = t.getSuperType();\n+        if (superType != null) {\n+            print(\" extends \" + superType);\n+        }\n+        println(\" {\");\n+        indent();\n+        boolean first = true;\n+        for (ValueDescriptor v : t.getFields()) {\n+            printField(commentIndex, v, first);\n+            first = false;\n+        }\n+        retract();\n+        println(\"}\");\n+        println();\n+    }\n+\n+    private void printField(int commentIndex, ValueDescriptor v, boolean first) {\n+        if (!first) {\n+            println();\n+        }\n+        printAnnotations(commentIndex, v.getAnnotationElements());\n+        printIndent();\n+        Type vType = PrivateAccess.getInstance().getType(v);\n+        if (Type.SUPER_TYPE_SETTING.equals(vType.getSuperType())) {\n+            print(\"static \");\n+        }\n+        print(makeSimpleType(v.getTypeName()));\n+        if (v.isArray()) {\n+            print(\"[]\");\n+        }\n+        print(\" \");\n+        print(v.getName());\n+        print(\";\");\n+        printCommentRef(commentIndex, v.getTypeId());\n+    }\n+\n+    private void printCommentRef(int commentIndex, long typeId) {\n+        if (showIds) {\n+            int column = getColumn();\n+            if (column > commentIndex) {\n+                print(\"  \");\n+            } else {\n+                while (column < commentIndex) {\n+                    print(\" \");\n+                    column++;\n+                }\n+            }\n+            println(\" \/\/ id=\" + typeId);\n+        } else {\n+            println();\n+        }\n+    }\n+\n+    private void printAnnotations(int commentIndex, List<AnnotationElement> annotations) {\n+        for (AnnotationElement a : annotations) {\n+            if (!Name.class.getName().equals(a.getTypeName())) {\n+                printIndent();\n+                print(\"@\");\n+                print(makeSimpleType(a.getTypeName()));\n+                List<ValueDescriptor> vs = a.getValueDescriptors();\n+                if (!vs.isEmpty()) {\n+                    printAnnotation(a);\n+                    printCommentRef(commentIndex, a.getTypeId());\n+                } else {\n+                    println();\n+                }\n+            }\n+        }\n+    }\n+\n+    private void printAnnotation(AnnotationElement a) {\n+        StringJoiner sj = new StringJoiner(\", \", \"(\", \")\");\n+        List<ValueDescriptor> vs = a.getValueDescriptors();\n+        for (ValueDescriptor v : vs) {\n+            Object o = a.getValue(v.getName());\n+            if (vs.size() == 1 && v.getName().equals(\"value\")) {\n+                sj.add(textify(o));\n+            } else {\n+                sj.add(v.getName() + \"=\" + textify(o));\n+            }\n+        }\n+        print(sj.toString());\n+    }\n+\n+    private String textify(Object o) {\n+        if (o.getClass().isArray()) {\n+            Object[] array = (Object[]) o;\n+            if (array.length == 1) {\n+                return quoteIfNeeded(array[0]);\n+            }\n+            StringJoiner s = new StringJoiner(\", \", \"{\", \"}\");\n+            for (Object ob : array) {\n+                s.add(quoteIfNeeded(ob));\n+            }\n+            return s.toString();\n+        } else {\n+            return quoteIfNeeded(o);\n+        }\n+    }\n+\n+    private String quoteIfNeeded(Object o) {\n+        if (o instanceof String) {\n+            return \"\\\"\" + o + \"\\\"\";\n+        } else {\n+            return String.valueOf(o);\n+        }\n+    }\n+\n+    private String makeSimpleType(String typeName) {\n+        int index = typeName.lastIndexOf(\".\");\n+        return typeName.substring(index + 1);\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/MetadataWriter.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.jfr.AnnotationElement;\n@@ -40,1 +39,0 @@\n-import jdk.jfr.Name;\n@@ -51,1 +49,0 @@\n-import jdk.jfr.internal.PrivateAccess;\n@@ -66,1 +63,0 @@\n-    private boolean showIds;\n@@ -86,126 +82,0 @@\n-    public void printType(Type t) {\n-        if (showIds) {\n-            print(\"\/\/ id: \");\n-            println(String.valueOf(t.getId()));\n-        }\n-        int commentIndex = t.getName().length() + 10;\n-        String typeName = t.getName();\n-        int index = typeName.lastIndexOf(\".\");\n-        if (index != -1) {\n-            println(\"@Name(\\\"\" + typeName + \"\\\")\");\n-        }\n-        printAnnotations(commentIndex, t.getAnnotationElements());\n-        print(\"class \" + typeName.substring(index + 1));\n-        String superType = t.getSuperType();\n-        if (superType != null) {\n-            print(\" extends \" + superType);\n-        }\n-        println(\" {\");\n-        indent();\n-        boolean first = true;\n-        for (ValueDescriptor v : t.getFields()) {\n-            printField(commentIndex, v, first);\n-            first = false;\n-        }\n-        retract();\n-        println(\"}\");\n-        println();\n-    }\n-\n-    private void printField(int commentIndex, ValueDescriptor v, boolean first) {\n-        if (!first) {\n-            println();\n-        }\n-        printAnnotations(commentIndex, v.getAnnotationElements());\n-        printIndent();\n-        Type vType = PrivateAccess.getInstance().getType(v);\n-        if (Type.SUPER_TYPE_SETTING.equals(vType.getSuperType())) {\n-            print(\"static \");\n-        }\n-        print(makeSimpleType(v.getTypeName()));\n-        if (v.isArray()) {\n-            print(\"[]\");\n-        }\n-        print(\" \");\n-        print(v.getName());\n-        print(\";\");\n-        printCommentRef(commentIndex, v.getTypeId());\n-    }\n-\n-    private void printCommentRef(int commentIndex, long typeId) {\n-        if (showIds) {\n-            int column = getColumn();\n-            if (column > commentIndex) {\n-                print(\"  \");\n-            } else {\n-                while (column < commentIndex) {\n-                    print(\" \");\n-                    column++;\n-                }\n-            }\n-            println(\" \/\/ id=\" + typeId);\n-        } else {\n-            println();\n-        }\n-    }\n-\n-    private void printAnnotations(int commentIndex, List<AnnotationElement> annotations) {\n-        for (AnnotationElement a : annotations) {\n-            if (!Name.class.getName().equals(a.getTypeName())) {\n-                printIndent();\n-                print(\"@\");\n-                print(makeSimpleType(a.getTypeName()));\n-                List<ValueDescriptor> vs = a.getValueDescriptors();\n-                if (!vs.isEmpty()) {\n-                    printAnnotation(a);\n-                    printCommentRef(commentIndex, a.getTypeId());\n-                } else {\n-                    println();\n-                }\n-            }\n-        }\n-    }\n-\n-    private void printAnnotation(AnnotationElement a) {\n-        StringJoiner sj = new StringJoiner(\", \", \"(\", \")\");\n-        List<ValueDescriptor> vs = a.getValueDescriptors();\n-        for (ValueDescriptor v : vs) {\n-            Object o = a.getValue(v.getName());\n-            if (vs.size() == 1 && v.getName().equals(\"value\")) {\n-                sj.add(textify(o));\n-            } else {\n-                sj.add(v.getName() + \"=\" + textify(o));\n-            }\n-        }\n-        print(sj.toString());\n-    }\n-\n-    private String textify(Object o) {\n-        if (o.getClass().isArray()) {\n-            Object[] array = (Object[]) o;\n-            if (array.length == 1) {\n-                return quoteIfNeeded(array[0]);\n-            }\n-            StringJoiner s = new StringJoiner(\", \", \"{\", \"}\");\n-            for (Object ob : array) {\n-                s.add(quoteIfNeeded(ob));\n-            }\n-            return s.toString();\n-        } else {\n-            return quoteIfNeeded(o);\n-        }\n-    }\n-\n-    private String quoteIfNeeded(Object o) {\n-        if (o instanceof String) {\n-            return \"\\\"\" + o + \"\\\"\";\n-        } else {\n-            return String.valueOf(o);\n-        }\n-    }\n-\n-    private String makeSimpleType(String typeName) {\n-        int index = typeName.lastIndexOf(\".\");\n-        return typeName.substring(index + 1);\n-    }\n-\n@@ -607,4 +477,0 @@\n-\n-    public void setShowIds(boolean showIds) {\n-        this.showIds = showIds;\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/PrettyWriter.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -119,0 +119,3 @@\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorInterpreterObjectTest.java                8356372 generic-all\n+serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorStatObjectCorrectnessTest.java\t          8356372 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -81,3 +81,0 @@\n-compiler\/c2\/irTests\/TestFloat16ScalarOperations.java 8355708 linux-aarch64\n-compiler\/c2\/irTests\/MulHFNodeIdealizationTests.java 8355708 linux-aarch64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    @Warmup(value = 10000)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulHFNodeIdealizationTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -611,0 +611,1 @@\n+    @Warmup(value = 10000)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFloat16ScalarOperations.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+            \"-XX:-EagerJVMCI\",\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/TestJVMCIPrintProperties.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TypeProfileCasts\n+ * @summary Check that turning of TypeProfileCasts is tolerated\n+ * @requires vm.debug == true\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ *\n+ * @run main\/othervm -XX:+TieredCompilation -XX:-BackgroundCompilation -XX:-TypeProfileCasts\n+ *                   -XX:CompileCommand=compileonly,compiler.tiered.TypeProfileCasts::test_instanceof\n+ *                   compiler.tiered.TypeProfileCasts\n+ * @run main\/othervm -XX:+TieredCompilation -XX:-BackgroundCompilation -XX:+TypeProfileCasts\n+ *                   -XX:CompileCommand=compileonly,compiler.tiered.TypeProfileCasts::test_instanceof\n+ *                   compiler.tiered.TypeProfileCasts\n+ * @run main\/othervm -XX:+TieredCompilation -XX:-BackgroundCompilation -XX:-TypeProfileCasts\n+ *                   -XX:CompileCommand=compileonly,compiler.tiered.TypeProfileCasts::test_checkcast\n+ *                   compiler.tiered.TypeProfileCasts\n+ * @run main\/othervm -XX:+TieredCompilation -XX:-BackgroundCompilation -XX:+TypeProfileCasts\n+ *                   -XX:CompileCommand=compileonly,compiler.tiered.TypeProfileCasts::test_checkcast\n+ *                   compiler.tiered.TypeProfileCasts\n+ * @run main\/othervm -XX:+TieredCompilation -XX:-BackgroundCompilation -XX:-TypeProfileCasts\n+ *                   -XX:CompileCommand=compileonly,compiler.tiered.TypeProfileCasts::test_array_store\n+ *                   compiler.tiered.TypeProfileCasts\n+ * @run main\/othervm -XX:+TieredCompilation -XX:-BackgroundCompilation -XX:+TypeProfileCasts\n+ *                   -XX:CompileCommand=compileonly,compiler.tiered.TypeProfileCasts::test_array_store\n+ *                   compiler.tiered.TypeProfileCasts\n+ *\/\n+\n+package compiler.tiered;\n+\n+public class TypeProfileCasts {\n+    static class Foo { }\n+    public static int sideEffect = 0;\n+\n+    private static void test_instanceof(Object o) {\n+      \/\/ instanceof\n+      if (o instanceof Foo) {\n+        sideEffect++;\n+      }\n+    }\n+\n+    private static void test_checkcast(Object o) {\n+      \/\/ checkcast\n+      Foo f = (Foo) o;\n+\n+      sideEffect++;\n+    }\n+\n+    private static void test_array_store(Object o) {\n+      \/\/ array store type check\n+      Foo[] fs = new Foo[1];\n+      Object[] os = fs;\n+      os[0] = o;\n+\n+      sideEffect++;\n+    }\n+\n+    public static void main(String... args) {\n+      for (int i = 0; i < 100_000; i++) {\n+        test_instanceof(new Foo());\n+        test_checkcast(new Foo());\n+        test_array_store(new Foo());\n+      }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/tiered\/TypeProfileCasts.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -30,0 +30,2 @@\n+ * @requires vm.flavor != \"zero\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeFlags.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n- * @library \/test\/lib \/test\/setup_aot\n- * @build AOTProfileFlags JavacBenchApp\n+ * @library \/test\/lib \/test\/setup_aot \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build AOTProfileFlags JavacBenchApp Hello\n@@ -40,0 +40,1 @@\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar Hello\n@@ -43,0 +44,1 @@\n+import jdk.test.lib.cds.CDSTestUtils;\n@@ -44,0 +46,3 @@\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n@@ -46,1 +51,2 @@\n-    public static void main(String... args) throws Exception {\n+    public static void testDiagnosticFlags() throws Exception {\n+        printTestCase(\"Diagnostic Flags\");\n@@ -59,0 +65,75 @@\n+    static void trainAndRun(String testName, String trainingFlags, String productionFlags) throws Exception {\n+        printTestCase(\"Flags mismatch \" + testName);\n+\n+        String appJar = ClassFileInstaller.getJarPath(\"hello.jar\");\n+        String aotConfigFile = \"hello.aotconfig\";\n+        String aotCacheFile = \"hello.aot\";\n+        String helloClass = \"Hello\";\n+\n+        ProcessBuilder pb;\n+        OutputAnalyzer out;\n+\n+        \/\/ first make sure we have a valid aotConfigFile with default value of TypeProfileLevel\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=record\",\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            trainingFlags,\n+            \"-cp\", appJar, helloClass);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"train\");\n+        out.shouldHaveExitValue(0);\n+\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=create\",\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-XX:AOTCache=\" + aotCacheFile,\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            trainingFlags,\n+            \"-cp\", appJar);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"assemble\");\n+        out.shouldHaveExitValue(0);\n+\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTCache=\" + aotCacheFile,\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            trainingFlags,\n+            \"-cp\", appJar, helloClass);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"production_success\");\n+        out.shouldNotContain(\"does not equal\");\n+        out.shouldHaveExitValue(0);\n+\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTCache=\" + aotCacheFile,\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            productionFlags,\n+            \"-cp\", appJar, helloClass);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"production_failure\");\n+        out.shouldContain(\"does not equal\");\n+        out.shouldHaveExitValue(0);\n+    }\n+\n+    public static void testFlagsMismatch() throws Exception {\n+        trainAndRun(\"TypeProfileLevel\", \"-XX:TypeProfileLevel=222\", \"-XX:TypeProfileLevel=111\");\n+        trainAndRun(\"TypeProfileArgsLimit\", \"-XX:TypeProfileArgsLimit=2\", \"-XX:TypeProfileArgsLimit=3\");\n+        trainAndRun(\"TypeProfileParamsLimit\", \"-XX:TypeProfileParmsLimit=2\", \"-XX:TypeProfileParmsLimit=3\");\n+        trainAndRun(\"TypeProfileWidth\", \"-XX:TypeProfileWidth=2\", \"-XX:TypeProfileWidth=3\");\n+        trainAndRun(\"SpecTrapLimitExtraEntries\", \"-XX:SpecTrapLimitExtraEntries=2\", \"-XX:SpecTrapLimitExtraEntries=3\");\n+        if (System.getProperty(\"jdk.debug\") != null) {\n+          trainAndRun(\"ProfileTraps\", \"-XX:+ProfileTraps\", \"-XX:-ProfileTraps\");\n+          trainAndRun(\"TypeProfileCasts\", \"-XX:+TypeProfileCasts\", \"-XX:-TypeProfileCasts\");\n+        }\n+    }\n+\n+    static int testNum = 0;\n+    static void printTestCase(String s) {\n+        System.out.println(\"vvvvvvv TEST CASE \" + testNum + \": \" + s + \" starts here vvvvvvv\");\n+        testNum++;\n+    }\n+    public static void main(String... args) throws Exception {\n+        testDiagnosticFlags();\n+        testFlagsMismatch();\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotProfile\/AOTProfileFlags.java","additions":84,"deletions":3,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -171,10 +171,0 @@\n-    @Test(dataProvider = \"directoryOptions\")\n-    public void testRootNotAbsolute(String opt) throws Throwable {\n-        out.println(\"\\n--- testRootNotAbsolute, opt=\\\"%s\\\" \".formatted(opt));\n-        var root = Path.of(\".\");\n-        assertFalse(root.isAbsolute());\n-        simpleserver(JAVA, LOCALE_OPT, \"-m\", \"jdk.httpserver\", opt, root.toString())\n-                .shouldNotHaveExitValue(0)\n-                .shouldContain(\"Error: server config failed: \" + \"Path is not absolute:\");\n-    }\n-\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/CommandLineNegativeTest.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.io.UncheckedIOException;\n@@ -55,4 +56,29 @@\n-    static final Path CWD = Path.of(\".\").toAbsolutePath().normalize();\n-    static final Path TEST_DIR = CWD.resolve(\"CommandLinePositiveTest\");\n-    static final Path TEST_FILE = TEST_DIR.resolve(\"file.txt\");\n-    static final String TEST_DIR_STR = TEST_DIR.toString();\n+\n+    \/**\n+     * The <b>real path<\/b> to the current working directory where\n+     * <ol>\n+     * <li>the web server process will be started in,<\/li>\n+     * <li>and hence, unless given an explicit content root directory, the web\n+     * server will be serving from.<\/li>\n+     * <\/ol>\n+     *\/\n+    private static final Path CWD;\n+\n+    static {\n+        try {\n+            CWD = Path.of(\".\").toRealPath();\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+\n+    private static final String CWD_STR = CWD.toString();\n+\n+    \/**\n+     * The <b>real path<\/b> to the web server content root directory, if one\n+     * needs to be provided explicitly.\n+     *\/\n+    private static final Path ROOT_DIR = CWD.resolve(\"www\");\n+\n+    private static final String ROOT_DIR_STR = ROOT_DIR.toString();\n+\n@@ -63,2 +89,2 @@\n-        if (Files.exists(TEST_DIR)) {\n-            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        if (Files.exists(ROOT_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(ROOT_DIR);\n@@ -66,2 +92,2 @@\n-        Files.createDirectories(TEST_DIR);\n-        Files.createFile(TEST_FILE);\n+        Files.createDirectories(ROOT_DIR);\n+        Files.createFile(ROOT_DIR.resolve(\"file.txt\"));\n@@ -86,3 +112,14 @@\n-    public void testDirectory(String opt) throws Throwable {\n-        out.println(\"\\n--- testDirectory, opt=\\\"%s\\\" \".formatted(opt));\n-        simpleserver(JAVA, LOCALE_OPT, \"-m\", \"jdk.httpserver\", \"-p\", \"0\", opt, TEST_DIR_STR)\n+    public void testAbsDirectory(String opt) throws Throwable {\n+        out.printf(\"\\n--- testAbsDirectory, opt=\\\"%s\\\"%n\", opt);\n+        testDirectory(opt, ROOT_DIR_STR);\n+    }\n+\n+    @Test(dataProvider = \"directoryOptions\")\n+    public void testRelDirectory(String opt) throws Throwable {\n+        out.printf(\"\\n--- testRelDirectory, opt=\\\"%s\\\"%n\", opt);\n+        Path rootRelDir = CWD.relativize(ROOT_DIR);\n+        testDirectory(opt, rootRelDir.toString());\n+    }\n+\n+    private static void testDirectory(String opt, String rootDir) throws Throwable {\n+        simpleserver(JAVA, LOCALE_OPT, \"-m\", \"jdk.httpserver\", \"-p\", \"0\", opt, rootDir)\n@@ -91,1 +128,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n+                .shouldContain(\"Serving \" + ROOT_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n@@ -104,1 +141,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n+                .shouldContain(\"Serving \" + CWD_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n@@ -158,1 +195,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on 0.0.0.0 (all interfaces) port\")\n+                .shouldContain(\"Serving \" + CWD_STR + \" and subdirectories on 0.0.0.0 (all interfaces) port\")\n@@ -163,1 +200,1 @@\n-                    .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on 0.0.0.0 (all interfaces) port\")\n+                    .shouldContain(\"Serving \" + CWD_STR + \" and subdirectories on 0.0.0.0 (all interfaces) port\")\n@@ -173,1 +210,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n+                .shouldContain(\"Serving \" + CWD_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n@@ -181,1 +218,1 @@\n-        simpleserver(JAVA, LOCALE_OPT, \"-m\", \"jdk.httpserver\", \"-p\", \"0\", opt, TEST_DIR_STR, opt, TEST_DIR_STR)\n+        simpleserver(JAVA, LOCALE_OPT, \"-m\", \"jdk.httpserver\", \"-p\", \"0\", opt, ROOT_DIR_STR, opt, ROOT_DIR_STR)\n@@ -184,1 +221,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n+                .shouldContain(\"Serving \" + ROOT_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n@@ -197,1 +234,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n+                .shouldContain(\"Serving \" + CWD_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n@@ -207,1 +244,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n+                .shouldContain(\"Serving \" + CWD_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n@@ -213,2 +250,2 @@\n-        if (Files.exists(TEST_DIR)) {\n-            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        if (Files.exists(ROOT_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(ROOT_DIR);\n@@ -250,1 +287,1 @@\n-                new ProcessBuilder(args).directory(TEST_DIR.toFile()),\n+                new ProcessBuilder(args),\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/CommandLinePositiveTest.java","additions":60,"deletions":23,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -671,8 +671,0 @@\n-        {   \/\/ not absolute\n-            Path p = Path.of(\".\");\n-            assert Files.isDirectory(p);\n-            assert Files.exists(p);\n-            assert !p.isAbsolute();\n-            var iae = expectThrows(IAE, () -> SimpleFileServer.createFileServer(addr, p, OutputLevel.INFO));\n-            assertTrue(iae.getMessage().contains(\"is not absolute\"));\n-        }\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/SimpleFileServerTest.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -171,10 +171,0 @@\n-    @Test(dataProvider = \"directoryOptions\")\n-    public void testRootNotAbsolute(String opt) throws Throwable {\n-        out.println(\"\\n--- testRootNotAbsolute, opt=\\\"%s\\\" \".formatted(opt));\n-        var root = Path.of(\".\");\n-        assertFalse(root.isAbsolute());\n-        simpleserver(JWEBSERVER, LOCALE_OPT, opt, root.toString())\n-                .shouldNotHaveExitValue(0)\n-                .shouldContain(\"Error: server config failed: \" + \"Path is not absolute:\");\n-    }\n-\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/jwebserver\/CommandLineNegativeTest.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.io.UncheckedIOException;\n@@ -55,4 +56,29 @@\n-    static final Path CWD = Path.of(\".\").toAbsolutePath().normalize();\n-    static final Path TEST_DIR = CWD.resolve(\"CommandLinePositiveTest\");\n-    static final Path TEST_FILE = TEST_DIR.resolve(\"file.txt\");\n-    static final String TEST_DIR_STR = TEST_DIR.toString();\n+\n+    \/**\n+     * The <b>real path<\/b> to the current working directory where\n+     * <ol>\n+     * <li>the web server process will be started in,<\/li>\n+     * <li>and hence, unless given an explicit content root directory, the web\n+     * server will be serving from.<\/li>\n+     * <\/ol>\n+     *\/\n+    private static final Path CWD;\n+\n+    static {\n+        try {\n+            CWD = Path.of(\".\").toRealPath();\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+\n+    private static final String CWD_STR = CWD.toString();\n+\n+    \/**\n+     * The <b>real path<\/b> to the web server content root directory, if one\n+     * needs to be provided explicitly.\n+     *\/\n+    private static final Path ROOT_DIR = CWD.resolve(\"www\");\n+\n+    private static final String ROOT_DIR_STR = ROOT_DIR.toString();\n+\n@@ -63,2 +89,2 @@\n-        if (Files.exists(TEST_DIR)) {\n-            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        if (Files.exists(ROOT_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(ROOT_DIR);\n@@ -66,2 +92,2 @@\n-        Files.createDirectories(TEST_DIR);\n-        Files.createFile(TEST_FILE);\n+        Files.createDirectories(ROOT_DIR);\n+        Files.createFile(ROOT_DIR.resolve(\"file.txt\"));\n@@ -86,3 +112,14 @@\n-    public void testDirectory(String opt) throws Throwable {\n-        out.println(\"\\n--- testDirectory, opt=\\\"%s\\\" \".formatted(opt));\n-        simpleserver(JWEBSERVER, LOCALE_OPT, \"-p\", \"0\", opt, TEST_DIR_STR)\n+    public void testAbsDirectory(String opt) throws Throwable {\n+        out.printf(\"\\n--- testAbsDirectory, opt=\\\"%s\\\"%n\", opt);\n+        testDirectory(opt, ROOT_DIR_STR);\n+    }\n+\n+    @Test(dataProvider = \"directoryOptions\")\n+    public void testRelDirectory(String opt) throws Throwable {\n+        out.printf(\"\\n--- testRelDirectory, opt=\\\"%s\\\"%n\", opt);\n+        Path rootRelDir = CWD.relativize(ROOT_DIR);\n+        testDirectory(opt, rootRelDir.toString());\n+    }\n+\n+    private static void testDirectory(String opt, String rootDir) throws Throwable {\n+        simpleserver(JWEBSERVER, LOCALE_OPT, \"-p\", \"0\", opt, rootDir)\n@@ -91,1 +128,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n+                .shouldContain(\"Serving \" + ROOT_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n@@ -104,1 +141,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n+                .shouldContain(\"Serving \" + CWD_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n@@ -158,1 +195,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on 0.0.0.0 (all interfaces) port\")\n+                .shouldContain(\"Serving \" + CWD_STR + \" and subdirectories on 0.0.0.0 (all interfaces) port\")\n@@ -163,1 +200,1 @@\n-                    .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on 0.0.0.0 (all interfaces) port\")\n+                    .shouldContain(\"Serving \" + CWD_STR + \" and subdirectories on 0.0.0.0 (all interfaces) port\")\n@@ -173,1 +210,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n+                .shouldContain(\"Serving \" + CWD_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n@@ -181,1 +218,1 @@\n-        simpleserver(JWEBSERVER, LOCALE_OPT, \"-p\", \"0\", opt, TEST_DIR_STR, opt, TEST_DIR_STR)\n+        simpleserver(JWEBSERVER, LOCALE_OPT, \"-p\", \"0\", opt, CWD_STR, opt, CWD_STR)\n@@ -184,1 +221,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n+                .shouldContain(\"Serving \" + CWD_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n@@ -197,1 +234,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n+                .shouldContain(\"Serving \" + CWD_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n@@ -207,1 +244,1 @@\n-                .shouldContain(\"Serving \" + TEST_DIR_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n+                .shouldContain(\"Serving \" + CWD_STR + \" and subdirectories on \" + LOOPBACK_ADDR + \" port\")\n@@ -213,2 +250,2 @@\n-        if (Files.exists(TEST_DIR)) {\n-            FileUtils.deleteFileTreeWithRetry(TEST_DIR);\n+        if (Files.exists(ROOT_DIR)) {\n+            FileUtils.deleteFileTreeWithRetry(ROOT_DIR);\n@@ -250,1 +287,1 @@\n-                new ProcessBuilder(args).directory(TEST_DIR.toFile()),\n+                new ProcessBuilder(args),\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/simpleserver\/jwebserver\/CommandLinePositiveTest.java","additions":60,"deletions":23,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350203\n+ * @summary Confirm that a few special whitespace characters are ignored.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.TextAttribute;\n+import java.awt.image.BufferedImage;\n+import java.text.AttributedString;\n+import java.util.Map;\n+\n+public class IgnoredWhitespaceTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        BufferedImage image = new BufferedImage(600, 600, BufferedImage.TYPE_BYTE_BINARY);\n+        Graphics2D g2d = image.createGraphics();\n+\n+        Font font = new Font(Font.DIALOG, Font.PLAIN, 40);\n+        test(image, g2d, font);\n+\n+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+        test(image, g2d, font);\n+\n+        g2d.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);\n+        test(image, g2d, font);\n+\n+        Font kerningFont = font.deriveFont(Map.of(TextAttribute.KERNING, TextAttribute.KERNING_ON));\n+        test(image, g2d, kerningFont);\n+\n+        Font physicalFont = getPhysicalFont(40);\n+        if (physicalFont != null) {\n+            test(image, g2d, physicalFont);\n+        }\n+\n+        g2d.dispose();\n+    }\n+\n+    private static void test(BufferedImage image, Graphics2D g2d, Font font) {\n+        test(image, g2d, font, \"XXXXX\", \"\\t\\t\\t\\t\\tXXXXX\");\n+        test(image, g2d, font, \"XXXXX\", \"\\tX\\tX\\tX\\tX\\tX\\t\");\n+        test(image, g2d, font, \"XXXXX\", \"\\r\\r\\r\\r\\rXXXXX\");\n+        test(image, g2d, font, \"XXXXX\", \"\\rX\\rX\\rX\\rX\\rX\\r\");\n+        test(image, g2d, font, \"XXXXX\", \"\\n\\n\\n\\n\\nXXXXX\");\n+        test(image, g2d, font, \"XXXXX\", \"\\nX\\nX\\nX\\nX\\nX\\n\");\n+    }\n+\n+    private static void test(BufferedImage image, Graphics2D g2d, Font font, String reference, String text) {\n+        g2d.setFont(font);\n+        FontRenderContext frc = g2d.getFontRenderContext();\n+        int w = image.getWidth();\n+        int h = image.getHeight();\n+        int x = w \/ 2;\n+        int y = h \/ 2;\n+\n+        g2d.setColor(Color.WHITE);\n+        g2d.fillRect(0, 0, w, h);\n+        g2d.setColor(Color.BLACK);\n+        g2d.drawString(reference, x, y);\n+        Rectangle expected = findTextBoundingBox(image);\n+\n+        g2d.setColor(Color.WHITE);\n+        g2d.fillRect(0, 0, w, h);\n+        g2d.setColor(Color.BLACK);\n+        g2d.drawString(text, x, y);\n+        Rectangle actual = findTextBoundingBox(image);\n+        assertEqual(expected, actual, text);\n+\n+        g2d.setColor(Color.WHITE);\n+        g2d.fillRect(0, 0, w, h);\n+        g2d.setColor(Color.BLACK);\n+        g2d.drawString(new AttributedString(text, Map.of(TextAttribute.FONT, font)).getIterator(), x, y);\n+        actual = findTextBoundingBox(image);\n+        assertEqual(expected, actual, text);\n+\n+        g2d.setColor(Color.WHITE);\n+        g2d.fillRect(0, 0, w, h);\n+        g2d.setColor(Color.BLACK);\n+        g2d.drawChars(text.toCharArray(), 0, text.length(), x, y);\n+        actual = findTextBoundingBox(image);\n+        assertEqual(expected, actual, text);\n+\n+        g2d.setColor(Color.WHITE);\n+        g2d.fillRect(0, 0, w, h);\n+        g2d.setColor(Color.BLACK);\n+        g2d.drawGlyphVector(font.createGlyphVector(frc, text), x, y);\n+        actual = findTextBoundingBox(image);\n+        assertEqual(expected, actual, text);\n+    }\n+\n+    private static void assertEqual(Rectangle r1, Rectangle r2, String text) {\n+        if (!r1.equals(r2)) {\n+            String escaped = text.replace(\"\\r\", \"\\\\r\")\n+                                 .replace(\"\\n\", \"\\\\n\")\n+                                 .replace(\"\\t\", \"\\\\t\");\n+            String msg = String.format(\"for text '%s': %s != %s\", escaped, r1.toString(), r2.toString());\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+\n+    private static Font getPhysicalFont(int size) {\n+        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        String[] names = ge.getAvailableFontFamilyNames();\n+        for (String n : names) {\n+            switch (n) {\n+                case Font.DIALOG:\n+                case Font.DIALOG_INPUT:\n+                case Font.SERIF:\n+                case Font.SANS_SERIF:\n+                case Font.MONOSPACED:\n+                     continue;\n+                default:\n+                    Font f = new Font(n, Font.PLAIN, size);\n+                    if (f.canDisplayUpTo(\"AZaz09\") == -1) {\n+                        return f;\n+                    }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static Rectangle findTextBoundingBox(BufferedImage image) {\n+        int minX = Integer.MAX_VALUE;\n+        int minY = Integer.MAX_VALUE;\n+        int maxX = Integer.MIN_VALUE;\n+        int maxY = Integer.MIN_VALUE;\n+        int width = image.getWidth();\n+        int height = image.getHeight();\n+\n+        int[] rowPixels = new int[width];\n+        for (int y = 0; y < height; y++) {\n+            image.getRGB(0, y, width, 1, rowPixels, 0, width);\n+            for (int x = 0; x < width; x++) {\n+                boolean white = (rowPixels[x] == -1);\n+                if (!white) {\n+                    if (x < minX) {\n+                        minX = x;\n+                    }\n+                    if (y < minY) {\n+                        minY = y;\n+                    }\n+                    if (x > maxX) {\n+                        maxX = x;\n+                    }\n+                    if (y > maxY) {\n+                        maxY = y;\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (minX != Integer.MAX_VALUE) {\n+            return new Rectangle(minX, minY, maxX - minX, maxY - minY);\n+        } else {\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Graphics2D\/DrawString\/IgnoredWhitespaceTest.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -26,0 +26,5 @@\n+ *\n+ * @comment If the VM does not have continuations, then VTs will be scheduled on OS threads.\n+ * @requires vm.continuations\n+ *\n+ * @bug 8356114 8356658\n@@ -41,0 +46,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -81,1 +87,2 @@\n-        var quiescent = new Object();\n+        var quiescentLatch = new CountDownLatch(1);\n+\n@@ -96,6 +103,5 @@\n-                synchronized (quiescent) {\n-                    try {\n-                        quiescent.wait();\n-                    } catch (Throwable ex) {\n-                        throw new AssertionError(ex);\n-                    }\n+                \/\/ wait for ForkJoinPool to contract\n+                try {\n+                    quiescentLatch.await();\n+                } catch (Throwable ex) {\n+                    throw new AssertionError(ex);\n@@ -126,4 +132,1 @@\n-\n-        synchronized (quiescent) {\n-            quiescent.notify();\n-        }\n+        quiescentLatch.countDown(); \/\/ notify the thread that accesses the MemorySegment\n@@ -134,0 +137,1 @@\n+\n","filename":"test\/jdk\/java\/foreign\/TestBufferStackStress2.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,392 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8355992\n+ * @summary Tests for StrictMath.*PowExact and .*unsignedMultiplyExact\n+ * @run junit IntegralPowTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.math.BigInteger;\n+\n+import static java.lang.StrictMath.*;\n+import static java.math.BigInteger.ONE;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class IntegralPowTest {\n+\n+    private static final long MASK_32 = (1L << Integer.SIZE) - 1;  \/\/ 2^32 - 1\n+    private static final BigInteger MASK_64 = ONE.shiftLeft(Long.SIZE).subtract(ONE);  \/\/ 2^64 - 1\n+    private static final double INT_F = Integer.SIZE * Math.log(2);\n+    private static final double LONG_F = Long.SIZE * Math.log(2);\n+    private static final int INT_XMAX = 0x1_0000;\n+    private static final int LONG_XMAX = 0x10_0000;\n+\n+    private static BigInteger unsignedBigInteger(int x) {\n+        return BigInteger.valueOf(x & MASK_32);\n+    }\n+\n+    private static BigInteger unsignedBigInteger(long x) {\n+        return BigInteger.valueOf(x).and(MASK_64);\n+    }\n+\n+    private static int slowPowExact(int x, int n) {\n+        BigInteger pow = BigInteger.valueOf(x).pow(n);\n+        return pow.intValueExact();\n+    }\n+\n+    private static int slowUnsignedPowExact(int x, int n) {\n+        BigInteger pow = unsignedBigInteger(x).pow(n);\n+        if (pow.bitLength() > Integer.SIZE) {\n+            throw new ArithmeticException();\n+        }\n+        return pow.intValue();\n+    }\n+\n+    private static long slowPowExact(long x, int n) {\n+        BigInteger pow = BigInteger.valueOf(x).pow(n);\n+        return pow.longValueExact();\n+    }\n+\n+    private static long slowUnsignedPowExact(long x, int n) {\n+        BigInteger pow = unsignedBigInteger(x).pow(n);\n+        if (pow.bitLength() > Long.SIZE) {\n+            throw new ArithmeticException();\n+        }\n+        return pow.longValue();\n+    }\n+\n+    @Test\n+    void testIntUnsignedMultiplyExact() {\n+        assertEquals(0, unsignedMultiplyExact(0, 0));\n+        assertEquals(0, unsignedMultiplyExact(1, 0));\n+        assertEquals(0, unsignedMultiplyExact(-1, 0));\n+        assertEquals(1, unsignedMultiplyExact(1, 1));\n+        assertEquals(-1, unsignedMultiplyExact(1, -1));\n+        assertEquals(1 << 31, unsignedMultiplyExact(1 << 15, 1 << 16));\n+        assertEquals(1 << 31, unsignedMultiplyExact(1 << 10, 1 << 21));\n+        \/* 2^32 - 1 = (2^16 + 1) (2^16 - 1) *\/\n+        assertEquals(-1, unsignedMultiplyExact((1 << 16) + 1, (1 << 16) - 1));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedMultiplyExact(-1, -1));\n+    }\n+\n+    @Test\n+    void testLongIntUnsignedMultiplyExact() {\n+        assertEquals(0L, unsignedMultiplyExact(0L, 0));\n+        assertEquals(0L, unsignedMultiplyExact(1L, 0));\n+        assertEquals(0L, unsignedMultiplyExact(-1L, 0));\n+        assertEquals(1L, unsignedMultiplyExact(1L, 1));\n+        assertEquals(-3 & MASK_32, unsignedMultiplyExact(1L, -3));\n+        assertEquals(1L << 50, unsignedMultiplyExact(1L << 25, 1 << 25));\n+        \/* 2^64 - 1 = (2^32 + 1) (2^32 - 1) *\/\n+        assertEquals(-1L, unsignedMultiplyExact((1L << 32) + 1, -1));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedMultiplyExact(-1L, -1));\n+    }\n+\n+    @Test\n+    void testLongUnsignedMultiplyExact() {\n+        assertEquals(0L, unsignedMultiplyExact(0L, 0L));\n+        assertEquals(0L, unsignedMultiplyExact(1L, 0L));\n+        assertEquals(0L, unsignedMultiplyExact(-1L, 0L));\n+        assertEquals(1L, unsignedMultiplyExact(1L, 1L));\n+        assertEquals(-1L, unsignedMultiplyExact(1L, -1L));\n+        assertEquals(1L << 63, unsignedMultiplyExact(1L << 31, 1L << 32));\n+        assertEquals(1L << 63, unsignedMultiplyExact(1L << 25, 1L << 38));\n+        \/* 2^64 - 1 = (2^32 + 1) (2^32 - 1) *\/\n+        assertEquals(-1L, unsignedMultiplyExact((1L << 32) + 1, (1L << 32) - 1));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedMultiplyExact(-1L, -1L));\n+    }\n+\n+    @Test\n+    void testIntPowExact() {\n+        assertEquals(1, powExact(0, 0));\n+        assertEquals(0, powExact(0, 1_000_000));\n+        assertEquals(1, powExact(1, 0));\n+        assertEquals(1, powExact(1, 1_000_000));\n+        assertEquals(1, powExact(-1, 0));\n+        assertEquals(1, powExact(-1, 1_000_000));\n+        assertEquals(-1, powExact(-1, 1_000_001));\n+\n+        assertEquals(1 << -2, powExact(2, Integer.SIZE - 2));\n+        assertEquals(-1 << -1, powExact(-2, Integer.SIZE - 1));\n+        assertEquals(1_000_000_000, powExact(10, 9));\n+        assertEquals(-1_000_000_000, powExact(-10, 9));\n+\n+        assertThrows(ArithmeticException.class, () -> powExact(0, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> powExact(1, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> powExact(2, Integer.SIZE - 1));\n+        assertThrows(ArithmeticException.class, () -> powExact(10, 10));\n+        assertThrows(ArithmeticException.class, () -> powExact(-10, 10));\n+    }\n+\n+    @Test\n+    void testUnsignedIntPowExact() {\n+        assertEquals(1, unsignedPowExact(0, 0));\n+        assertEquals(0, unsignedPowExact(0, 1_000_000));\n+        assertEquals(1, unsignedPowExact(1, 0));\n+        assertEquals(1, unsignedPowExact(1, 1_000_000));\n+        assertEquals(1, unsignedPowExact(-1, 0));\n+        assertEquals(-1, unsignedPowExact(-1, 1));\n+\n+        assertEquals(1 << -1, unsignedPowExact(2, Integer.SIZE - 1));\n+        assertEquals(1_000_000_000, unsignedPowExact(10, 9));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(0, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(1, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(-1, 2));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(2, Integer.SIZE));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(10, 10));\n+    }\n+\n+    @Test\n+    void testLongPowExact() {\n+        assertEquals(1L, powExact(0L, 0));\n+        assertEquals(0L, powExact(0L, 1_000_000));\n+        assertEquals(1L, powExact(1L, 0));\n+        assertEquals(1L, powExact(1L, 1_000_000));\n+        assertEquals(1L, powExact(-1L, 0));\n+        assertEquals(1L, powExact(-1L, 1_000_000));\n+        assertEquals(-1L, powExact(-1L, 1_000_001));\n+\n+        assertEquals(1L << -2, powExact(2L, Long.SIZE - 2));\n+        assertEquals(-1L << -1, powExact(-2L, Long.SIZE - 1));\n+        assertEquals(1_000_000_000_000_000_000L, powExact(10L, 18));\n+        assertEquals(-100_000_000_000_000_000L, powExact(-10L, 17));\n+        assertEquals(1_000_000_000_000_000_000L, powExact(-10L, 18));\n+\n+        assertThrows(ArithmeticException.class, () -> powExact(0L, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> powExact(1L, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> powExact(2L, Long.SIZE - 1));\n+        assertThrows(ArithmeticException.class, () -> powExact(10L, 19));\n+        assertThrows(ArithmeticException.class, () -> powExact(-10L, 19));\n+    }\n+\n+    @Test\n+    void testUnsignedLongPowExact() {\n+        assertEquals(1L, unsignedPowExact(0L, 0));\n+        assertEquals(0L, unsignedPowExact(0L, 1_000_000));\n+        assertEquals(1L, unsignedPowExact(1L, 0));\n+        assertEquals(1L, unsignedPowExact(1L, 1_000_000));\n+        assertEquals(1L, unsignedPowExact(-1L, 0));\n+        assertEquals(-1L, unsignedPowExact(-1L, 1));\n+\n+        assertEquals(1L << -1, unsignedPowExact(2L, Long.SIZE - 1));\n+        assertEquals(10 * 1_000_000_000_000_000_000L, unsignedPowExact(10L, 19));\n+\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(0L, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(1L, -1_000_000));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(-1L, 2));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(2L, Long.SIZE));\n+        assertThrows(ArithmeticException.class, () -> unsignedPowExact(10L, 20));\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static int expected(int x, int n) {\n+        try {\n+            return powExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static int actual(int x, int n) {\n+        try {\n+            return slowPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static int expectedUnsigned(int x, int n) {\n+        try {\n+            return unsignedPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static int actualUnsigned(int x, int n) {\n+        try {\n+            return slowUnsignedPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static long expected(long x, int n) {\n+        try {\n+            return powExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static long actual(long x, int n) {\n+        try {\n+            return slowPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static long expectedUnsigned(long x, int n) {\n+        try {\n+            return unsignedPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/*\n+     * Assumes that x^n != 0\n+     * Returns x^n, or 0 on overflow\n+     *\/\n+    private static long actualUnsigned(long x, int n) {\n+        try {\n+            return slowUnsignedPowExact(x, n);\n+        } catch (ArithmeticException ignore) {\n+            return 0;\n+        }\n+    }\n+\n+    \/* signed int *\/\n+\n+    @Test\n+    void testPositiveIntPowExact() {\n+        for (int x = 2; x <= INT_XMAX; x += 1) {\n+            \/* An estimate for the max n such that x^n does not overflow. *\/\n+            int nmax = (int) ceil(INT_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actual(x, n), expected(x, n));\n+            }\n+            int x0 = x;\n+            assertThrows(ArithmeticException.class, () -> powExact(x0, nmax + 1));\n+        }\n+    }\n+\n+    @Test\n+    void testNegativeIntPowExact() {\n+        for (int x = 2; x <= INT_XMAX; x += 1) {\n+            \/* An estimate for the max n such that (-x)^n does not overflow. *\/\n+            int nmax = (int) ceil(INT_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actual(-x, n), expected(-x, n));\n+            }\n+            int x0 = x;\n+            assertThrows(ArithmeticException.class, () -> powExact(-x0, nmax + 1));\n+        }\n+    }\n+\n+    \/* unsigned int *\/\n+\n+    @Test\n+    void testSmallUnsignedIntPowExact() {\n+        for (int x = 2; x <= INT_XMAX; x += 1) {\n+            \/* An estimate for the max n such that x^n does not overflow. *\/\n+            int nmax = (int) ceil(INT_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actualUnsigned(x, n), expectedUnsigned(x, n));\n+            }\n+            int x0 = x;\n+            assertThrows(ArithmeticException.class, () -> unsignedPowExact(x0, nmax + 1));\n+        }\n+    }\n+\n+    \/* signed long *\/\n+\n+    @Test\n+    void testPositiveLongPowExact() {\n+        for (long x = 2; x <= LONG_XMAX; x += 5) {\n+            \/* An estimate for the max n such that x^n does not overflow. *\/\n+            int nmax = (int) ceil(LONG_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actual(x, n), expected(x, n));\n+            }\n+            long x0 = x;\n+            assertThrows(ArithmeticException.class, () -> powExact(x0, nmax + 1));\n+        }\n+    }\n+\n+    @Test\n+    void testNegativeLongPowExact() {\n+        for (long x = 2; x <= LONG_XMAX; x += 5) {\n+            \/* An estimate for the max n such that (-x)^n does not overflow. *\/\n+            int nmax = (int) ceil(LONG_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actual(-x, n), expected(-x, n));\n+            }\n+            long x0 = x;\n+            assertThrows(ArithmeticException.class, () -> powExact(-x0, nmax + 1));\n+        }\n+    }\n+\n+    \/* unsigned long *\/\n+\n+    @Test\n+    void testSmallUnsignedLongPowExact() {\n+        for (long x = 2; x <= LONG_XMAX; x += 5) {\n+            \/* An estimate for the max n such that x^n does not overflow. *\/\n+            int nmax = (int) ceil(LONG_F \/ log(x));\n+            for (int n = 0; n <= nmax; ++n) {\n+                assertEquals(actualUnsigned(x, n), expectedUnsigned(x, n));\n+            }\n+            long x0 = x;\n+            assertThrows(ArithmeticException.class, () -> unsignedPowExact(x0, nmax + 1));\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/Math\/IntegralPowTest.java","additions":392,"deletions":0,"binary":false,"changes":392,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @requires (os.family == \"windows\")\n@@ -61,4 +62,0 @@\n-        if (!System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n-            return;\n-        }\n-\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/SiblingIOEHandle.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+   @requires (os.family == \"windows\")\n@@ -32,2 +33,1 @@\n-        if (File.separatorChar == '\\\\') {\n-            try {\n+        try {\n@@ -41,2 +41,2 @@\n-            } catch (IOException e) {\n-            \/\/ not Win NT - cmd doesnt exist\n+        } catch (IOException e) {\n+            \/\/ not Win NT - cmd doesn't exist\n@@ -44,1 +44,0 @@\n-            }\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/Space.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @requires (os.family == \"linux\")\n@@ -38,4 +39,0 @@\n-        if (!System.getProperty(\"os.name\").equals(\"Linux\")) {\n-            System.out.println(\"Only for Linux\");\n-            return;\n-        }\n","filename":"test\/jdk\/java\/lang\/RuntimeTests\/exec\/Status.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import java.util.concurrent.StructuredTaskScope.Joiner;\n@@ -172,1 +173,1 @@\n-        try (var scope = new StructuredTaskScope<>(\"\", threadFactory)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withThreadFactory(threadFactory))) {\n@@ -189,1 +190,1 @@\n-                try (var scope = new StructuredTaskScope<>()) {\n+                try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n","filename":"test\/jdk\/java\/lang\/ScopedValue\/StressStackOverflow.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,1 +55,7 @@\n-        THIRTEEN(13),\n+        THIRTEEN(13) {\n+            @Override\n+            public String toString() {\n+                \/\/ getEnumConstants will be `null` for this enum as it is overridden\n+                return super.toString()+\" (Overridden)\";\n+            }\n+        },\n@@ -199,0 +205,7 @@\n+    @Test\n+    void overriddenEnum() {\n+        final var overridden = Value.THIRTEEN;\n+        Function<Value, Integer> enumFunction = StableValue.function(EnumSet.of(overridden), Value::asInt);\n+        assertEquals(MAPPER.apply(overridden), enumFunction.apply(overridden));\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableFunctionTest.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.Arrays;\n@@ -49,0 +48,1 @@\n+import java.util.function.Function;\n@@ -50,0 +50,1 @@\n+import java.util.function.UnaryOperator;\n@@ -245,8 +246,1 @@\n-    @Test\n-    void subListToString() {\n-        subListToString0(newList());\n-        subListToString0(newList().subList(1, SIZE));\n-        subListToString0(newList().subList(1, SIZE).subList(0, SIZE - 2));\n-    }\n-\n-    void subListToString0(List<Integer> subList) {\n+    void assertUnevaluated(List<Integer> subList) {\n@@ -254,3 +248,0 @@\n-\n-        var first = subList.getFirst();\n-        assertEquals(asString(first.toString(), subList), subList.toString());\n@@ -275,3 +266,15 @@\n-    void reversedToString() {\n-        var reversed = newList().reversed();\n-        subListToString0(reversed);\n+    void sublistReversedToString() {\n+        var actual = StableValue.list(4, IDENTITY);\n+        var expected = List.of(0, 1, 2, 3);\n+        for (UnaryOperation op : List.of(\n+                new UnaryOperation(\"subList\", l -> l.subList(1, 3)),\n+                new UnaryOperation(\"reversed\", List::reversed))) {\n+            actual = op.apply(actual);\n+            expected = op.apply(expected);\n+        }\n+        \/\/ Touch one of the elements\n+        actual.getLast();\n+\n+        var actualToString = actual.toString();\n+        var expectedToString = expected.toString().replace(\"2\", \".unset\");\n+        assertEquals(expectedToString, actualToString);\n@@ -280,0 +283,2 @@\n+    \/\/ This test makes sure successive view operations retains the property\n+    \/\/ of being a Stable view.\n@@ -281,5 +286,21 @@\n-    void subListReversedToString() {\n-        var list = newList().subList(1, SIZE - 1).reversed();\n-        \/\/ This combination is not lazy. There has to be a limit somewhere.\n-        var regularList = newRegularList().subList(1, SIZE - 1).reversed();\n-        assertEquals(regularList.toString(), list.toString());\n+    void viewsStable() {\n+        viewOperations().forEach(op0 -> {\n+            viewOperations().forEach( op1 -> {\n+                viewOperations().forEach(op2 -> {\n+                    var list = newList();\n+                    var view1 = op0.apply(list);\n+                    var view2 = op1.apply(view1);\n+                    var view3 = op2.apply(view2);\n+                    var className3 = className(view3);\n+                    var transitions = className(list) + \", \" +\n+                            op0 + \" -> \" + className(view1) + \", \" +\n+                            op1 + \" -> \" + className(view2) + \", \" +\n+                            op2 + \" -> \" + className3;\n+                    assertTrue(className3.contains(\"Stable\"), transitions);\n+                    assertUnevaluated(list);\n+                    assertUnevaluated(view1);\n+                    assertUnevaluated(view2);\n+                    assertUnevaluated(view3);\n+                });\n+            });\n+        });\n@@ -297,0 +318,17 @@\n+    @Test\n+    void indexOfNullInViews() {\n+        final int size = 5;\n+        final int middle = 2;\n+        viewOperations().forEach(op0 -> {\n+            viewOperations().forEach( op1 -> {\n+                viewOperations().forEach(op2 -> {\n+                    var list = StableValue.list(size, x -> x == middle ? null : x);;\n+                    var view1 = op0.apply(list);\n+                    var view2 = op1.apply(view1);\n+                    var view3 = op2.apply(view2);\n+                    assertEquals(middle, view3.indexOf(null));\n+                });\n+            });\n+        });\n+    }\n+\n@@ -365,0 +403,33 @@\n+    @Test\n+    void childObjectOpsLazy() {\n+        viewOperations().forEach(op0 -> {\n+            viewOperations().forEach(op1 -> {\n+                viewOperations().forEach(op2 -> {\n+                    childOperations().forEach(co -> {\n+                        var list = newList();\n+                        var view1 = op0.apply(list);\n+                        var view2 = op1.apply(view1);\n+                        var view3 = op2.apply(view2);\n+                        var child = co.apply(view3);\n+                        var childClassName = className(child);\n+                        var transitions = className(list) + \", \" +\n+                                op0 + \" -> \" + className(view1) + \", \" +\n+                                op1 + \" -> \" + className(view2) + \", \" +\n+                                op2 + \" -> \" + className(view3) + \", \" +\n+                                co + \" -> \" + childClassName;\n+\n+                        \/\/ None of these operations should trigger evaluation\n+                        var childToString = child.toString();\n+                        int childHashCode = child.hashCode();\n+                        boolean childEqualToNewObj = child.equals(new Object());\n+\n+                        assertUnevaluated(list);\n+                        assertUnevaluated(view1);\n+                        assertUnevaluated(view2);\n+                        assertUnevaluated(view3);\n+                    });\n+                });\n+            });\n+        });\n+    }\n+\n@@ -373,0 +444,30 @@\n+    record UnaryOperation(String name,\n+                     UnaryOperator<List<Integer>> operator) implements UnaryOperator<List<Integer>> {\n+        @Override public List<Integer> apply(List<Integer> list) { return operator.apply(list); }\n+        @Override public String toString() { return name; }\n+    }\n+\n+    record ListFunction(String name,\n+                        Function<List<Integer>, Object> function) implements Function<List<Integer>, Object> {\n+        @Override public Object apply(List<Integer> list) { return function.apply(list); }\n+        @Override public String toString() { return name; }\n+    }\n+\n+    static Stream<UnaryOperation> viewOperations() {\n+        return Stream.of(\n+                \/\/ We need identity to capture all combinations\n+                new UnaryOperation(\"identity\", l -> l),\n+                new UnaryOperation(\"reversed\", List::reversed),\n+                new UnaryOperation(\"subList\", l -> l.subList(0, l.size()))\n+        );\n+    }\n+\n+    static Stream<ListFunction> childOperations() {\n+        return Stream.of(\n+                \/\/ We need identity to capture all combinations\n+                new ListFunction(\"iterator\", List::iterator),\n+                new ListFunction(\"listIterator\", List::listIterator),\n+                new ListFunction(\"listIterator\", List::stream)\n+        );\n+    }\n+\n@@ -436,0 +537,3 @@\n+    static String className(Object o) {\n+        return o.getClass().getName();\n+    }\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableListTest.java","additions":124,"deletions":20,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -251,0 +251,31 @@\n+    @Test\n+    void stableEntry() {\n+        var map = newMap();\n+        var entry = map.entrySet().stream()\n+                .filter(e -> e.getKey().equals(KEY))\n+                .findAny()\n+                .orElseThrow();\n+\n+        assertEquals(KEY + \"=.unset\", entry.toString());\n+        var otherDifferent = Map.entry(-1, -1);\n+        assertNotEquals(entry, otherDifferent);\n+        assertEquals(KEY + \"=.unset\", entry.toString());\n+        var otherEqual = Map.entry(KEY, KEY);\n+        assertEquals(entry, otherEqual);\n+        assertEquals(KEY + \"=\" + KEY, entry.toString());\n+        assertEquals(entry.hashCode(), otherEqual.hashCode());\n+    }\n+\n+    @Test\n+    void stableForEachEntry() {\n+        var map = newMap();\n+        \/\/ Only touch the key.\n+        map.entrySet().iterator().forEachRemaining(Map.Entry::getKey);\n+        map.entrySet().iterator()\n+                .forEachRemaining(e -> assertTrue(e.toString().contains(\".unset\")));\n+        \/\/ Only touch the value.\n+        map.entrySet().iterator().forEachRemaining(Map.Entry::getValue);\n+        map.entrySet().iterator()\n+                .forEachRemaining(e -> assertFalse(e.toString().contains(\".unset\")));\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableMapTest.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.util.ArrayList;\n@@ -358,1 +359,1 @@\n-        CountDownLatch starter = new CountDownLatch(1);\n+        CountDownLatch starter = new CountDownLatch(noThreads);\n@@ -363,1 +364,3 @@\n-                        \/\/ Ready, set ...\n+                        \/\/ Ready ...\n+                        starter.countDown();\n+                        \/\/ ... set ...\n@@ -373,3 +376,0 @@\n-        LockSupport.parkNanos(TimeUnit.MILLISECONDS.toNanos(1));\n-        \/\/ Start the race\n-        starter.countDown();\n","filename":"test\/jdk\/java\/lang\/StableValue\/StableValueTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n- * @run main\/othervm -Xms6G -Xmx6G -XX:+CompactStrings HugeCapacity true\n- * @run main\/othervm -Xms6G -Xmx6G -XX:-CompactStrings HugeCapacity false\n+ * @run main\/othervm -Xms8G -Xmx8G -XX:-CompactStrings -Xlog:gc HugeCapacity false\n+ * @run main\/othervm -Xms8G -Xmx8G -XX:+CompactStrings -Xlog:gc HugeCapacity true\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/HugeCapacity.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4459099\n- * @key i18n\n- * @summary Tests non ANSI code page locales set default file encoding\n- * to \"utf-8\".  This test must be run on Windows 2K\/XP in one of Armenian,\n- * Georgian, Hindi, Punjabi, Gujarati, Tamil, Telugu, Kannada, Marathi,\n- * or Sanskrit languages.\n- *\/\n-\n-public class NonAnsiFileEncodingTest {\n-    public static void main(String[] s)  {\n-        String OS = System.getProperty(\"os.name\");\n-        String lang = System.getProperty(\"user.language\");\n-        String fileenc = System.getProperty(\"file.encoding\");\n-\n-        if (!(OS.equals(\"Windows 2000\") || OS.equals(\"Windows XP\"))) {\n-            System.out.println(\"This test is not meaningful on the platform \\\"\" + OS + \"\\\".\");\n-            return;\n-        }\n-\n-        if (!(lang.equals(\"hy\") ||      \/\/ Armenian\n-              lang.equals(\"ka\") ||      \/\/ Georgian\n-              lang.equals(\"hi\") ||      \/\/ Hindi\n-              lang.equals(\"pa\") ||      \/\/ Punjabi\n-              lang.equals(\"gu\") ||      \/\/ Gujarati\n-              lang.equals(\"ta\") ||      \/\/ Tamil\n-              lang.equals(\"te\") ||      \/\/ Telugu\n-              lang.equals(\"kn\") ||      \/\/ Kannada\n-              lang.equals(\"mr\") ||      \/\/ Marathi\n-              lang.equals(\"sa\"))) {     \/\/ Sanskrit\n-            System.out.println(\"Windows' locale settings for this test is incorrect.  Select one of \\\"Armenian\\\", \\\"Georgian\\\", \\\"Hindi\\\", \\\"Punjabi\\\", \\\"Gujarati\\\", \\\"Tamil\\\", \\\"Telugu\\\", \\\"Kannada\\\", \\\"Marathi\\\", or \\\"Sanskrit\\\" for the user locale, and \\\"English(United States)\\\" for the system default locale using the Control Panel.\");\n-            return;\n-        }\n-\n-        if (!fileenc.equals(\"utf-8\")) {\n-            throw new RuntimeException(\"file.encoding is incorrectly set to \\\"\" + fileenc + \"\\\".  Should be \\\"utf-8\\\".\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/System\/NonAnsiFileEncodingTest.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test of StructuredTaskScope cancellation with running and starting threads\n+ * @enablePreview\n+ * @run junit StressCancellation\n+ *\/\n+\n+import java.time.Duration;\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructuredTaskScope.Joiner;\n+import java.util.concurrent.StructuredTaskScope.Subtask;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class StressCancellation {\n+\n+    static Stream<Arguments> testCases() {\n+        Stream<ThreadFactory> factories = Stream.of(\n+                Thread.ofPlatform().factory(),\n+                Thread.ofVirtual().factory()\n+        );\n+        \/\/ 0..15 forks before shutdown, 0..15 forks after shutdown\n+        return factories.flatMap(f -> IntStream.range(0, 256)\n+                .mapToObj(x -> Arguments.of(f, x & 0x0F, (x & 0xF0) >> 4)));\n+    }\n+\n+    \/**\n+     * Test StructuredTaskScope cancellation with running threads and concurrently with\n+     * threads that are starting. The cancellation should interrupt all running threads,\n+     * join should wakeup, and close would complete quickly.\n+     *\n+     * @param factory the ThreadFactory to use\n+     * @param beforeCancel the number of subtasks to fork before cancel\n+     * @param afterCancel the number of subtasks to fork after cancel\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"testCases\")\n+    void test(ThreadFactory factory, int beforeCancel, int afterCancel) throws Exception {\n+        var joiner = new Joiner<Boolean, Void>() {\n+            @Override\n+            public boolean onComplete(Subtask<? extends Boolean> subtask) {\n+                boolean cancel = subtask.get();\n+                return cancel;\n+            }\n+            @Override\n+            public Void result() {\n+                return null;\n+            }\n+        };\n+\n+        try (var scope = StructuredTaskScope.open(joiner, cf -> cf.withThreadFactory(factory))) {\n+            \/\/ fork subtasks\n+            for (int i = 0; i < beforeCancel; i++) {\n+                scope.fork(() -> {\n+                    Thread.sleep(Duration.ofDays(1));\n+                    return false;\n+                });\n+            }\n+\n+            \/\/ fork subtask to cancel\n+            scope.fork(() -> true);\n+\n+            \/\/ fork after forking subtask to cancel\n+            for (int i = 0; i < afterCancel; i++) {\n+                scope.fork(() -> {\n+                    Thread.sleep(Duration.ofDays(1));\n+                    return false;\n+                });\n+            }\n+\n+            scope.join();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StressCancellation.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8311867\n- * @summary Stress test of StructuredTaskScope.shutdown with running and starting threads\n- * @enablePreview\n- * @run junit StressShutdown\n- *\/\n-\n-import java.time.Duration;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.StructuredTaskScope;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class StressShutdown {\n-\n-    static final Callable<Void> SLEEP_FOR_A_DAY = () -> {\n-        Thread.sleep(Duration.ofDays(1));\n-        return null;\n-    };\n-\n-    static Stream<Arguments> testCases() {\n-        Stream<ThreadFactory> factories = Stream.of(\n-                Thread.ofPlatform().factory(),\n-                Thread.ofVirtual().factory()\n-        );\n-        \/\/ 0..15 forks before shutdown, 0..15 forks after shutdown\n-        return factories.flatMap(f -> IntStream.range(0, 256)\n-                .mapToObj(x -> Arguments.of(f, x & 0x0F, (x & 0xF0) >> 4)));\n-    }\n-\n-    \/**\n-     * Test StructuredTaskScope.shutdown with running threads and concurrently with\n-     * threads that are starting. The shutdown should interrupt all threads so that\n-     * join wakes up.\n-     *\n-     * @param factory the ThreadFactory to use\n-     * @param beforeShutdown the number of subtasks to fork before shutdown\n-     * @param afterShutdown the number of subtasks to fork after shutdown\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"testCases\")\n-    void testShutdown(ThreadFactory factory, int beforeShutdown, int afterShutdown)\n-        throws InterruptedException\n-    {\n-        try (var scope = new StructuredTaskScope<>(null, factory)) {\n-            \/\/ fork subtasks\n-            for (int i = 0; i < beforeShutdown; i++) {\n-                scope.fork(SLEEP_FOR_A_DAY);\n-            }\n-\n-            \/\/ fork subtask to shutdown\n-            scope.fork(() -> {\n-                scope.shutdown();\n-                return null;\n-            });\n-\n-            \/\/ fork after forking subtask to shutdown\n-            for (int i = 0; i < afterShutdown; i++) {\n-                scope.fork(SLEEP_FOR_A_DAY);\n-            }\n-\n-            scope.join();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StressShutdown.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,0 @@\n-import java.io.IOException;\n-import java.time.Instant;\n@@ -45,0 +43,1 @@\n+import java.util.NoSuchElementException;\n@@ -49,1 +48,0 @@\n-import java.util.concurrent.ExecutionException;\n@@ -51,0 +49,1 @@\n+import java.util.concurrent.LinkedTransferQueue;\n@@ -52,1 +51,0 @@\n-import java.util.concurrent.TimeoutException;\n@@ -57,0 +55,4 @@\n+import java.util.concurrent.StructuredTaskScope.TimeoutException;\n+import java.util.concurrent.StructuredTaskScope.Configuration;\n+import java.util.concurrent.StructuredTaskScope.FailedException;\n+import java.util.concurrent.StructuredTaskScope.Joiner;\n@@ -58,2 +60,0 @@\n-import java.util.concurrent.StructuredTaskScope.ShutdownOnSuccess;\n-import java.util.concurrent.StructuredTaskScope.ShutdownOnFailure;\n@@ -64,1 +64,2 @@\n-import java.util.function.Supplier;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n@@ -104,1 +105,1 @@\n-     * Test that fork creates a new thread for each task.\n+     * Test that fork creates virtual threads when no ThreadFactory is configured.\n@@ -106,6 +107,6 @@\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkCreatesThread(ThreadFactory factory) throws Exception {\n-        Set<Long> tids = ConcurrentHashMap.newKeySet();\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            for (int i = 0; i < 100; i++) {\n+    @Test\n+    void testForkCreatesVirtualThread() throws Exception {\n+        Set<Thread> threads = ConcurrentHashMap.newKeySet();\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            for (int i = 0; i < 50; i++) {\n+                \/\/ runnable\n@@ -113,2 +114,1 @@\n-                    tids.add(Thread.currentThread().threadId());\n-                    return null;\n+                    threads.add(Thread.currentThread());\n@@ -116,5 +116,0 @@\n-            }\n-            scope.join();\n-        }\n-        assertEquals(100, tids.size());\n-    }\n@@ -122,8 +117,1 @@\n-    \/**\n-     * Test that fork creates a new virtual thread for each task.\n-     *\/\n-    @Test\n-    void testForkCreateVirtualThread() throws Exception {\n-        Set<Thread> threads = ConcurrentHashMap.newKeySet();\n-        try (var scope = new StructuredTaskScope<Object>()) {\n-            for (int i = 0; i < 100; i++) {\n+                \/\/ callable\n@@ -142,1 +130,1 @@\n-     * Test that fork creates a new thread with the given thread factory.\n+     * Test that fork create threads with the configured ThreadFactory.\n@@ -146,9 +134,34 @@\n-    void testForkUsesFactory(ThreadFactory factory) throws Exception {\n-        var count = new AtomicInteger();\n-        ThreadFactory countingFactory = task -> {\n-            count.incrementAndGet();\n-            return factory.newThread(task);\n-        };\n-        try (var scope = new StructuredTaskScope<Object>(null, countingFactory)) {\n-            for (int i = 0; i < 100; i++) {\n-                scope.fork(() -> null);\n+    void testForkUsesThreadFactory(ThreadFactory factory) throws Exception {\n+        \/\/ TheadFactory that keeps reference to all threads it creates\n+        class RecordingThreadFactory implements ThreadFactory {\n+            final ThreadFactory delegate;\n+            final Set<Thread> threads = ConcurrentHashMap.newKeySet();\n+            RecordingThreadFactory(ThreadFactory delegate) {\n+                this.delegate = delegate;\n+            }\n+            @Override\n+            public Thread newThread(Runnable task) {\n+                Thread thread = delegate.newThread(task);\n+                threads.add(thread);\n+                return thread;\n+            }\n+            Set<Thread> threads() {\n+                return threads;\n+            }\n+        }\n+        var recordingThreadFactory = new RecordingThreadFactory(factory);\n+        Set<Thread> threads = ConcurrentHashMap.newKeySet();\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(recordingThreadFactory))) {\n+\n+            for (int i = 0; i < 50; i++) {\n+                \/\/ runnable\n+                scope.fork(() -> {\n+                    threads.add(Thread.currentThread());\n+                });\n+\n+                \/\/ callable\n+                scope.fork(() -> {\n+                    threads.add(Thread.currentThread());\n+                    return null;\n+                });\n@@ -158,1 +171,2 @@\n-        assertEquals(100, count.get());\n+        assertEquals(100, threads.size());\n+        assertEquals(recordingThreadFactory.threads(), threads);\n@@ -162,1 +176,1 @@\n-     * Test fork is confined to threads in the scope \"tree\".\n+     * Test fork method is owner confined.\n@@ -167,22 +181,2 @@\n-        try (var scope1 = new StructuredTaskScope<Boolean>();\n-             var scope2 = new StructuredTaskScope<Boolean>()) {\n-\n-            \/\/ thread in scope1 cannot fork thread in scope2\n-            Subtask<Boolean> subtask1 = scope1.fork(() -> {\n-                assertThrows(WrongThreadException.class, () -> {\n-                    scope2.fork(() -> null);\n-                });\n-                return true;\n-            });\n-\n-            \/\/ thread in scope2 can fork thread in scope1\n-            Subtask<Boolean> subtask2 = scope2.fork(() -> {\n-                scope1.fork(() -> null);\n-                return true;\n-            });\n-\n-            scope2.join();\n-            scope1.join();\n-\n-            assertTrue(subtask1.get());\n-            assertTrue(subtask2.get());\n+        try (var scope = StructuredTaskScope.open(Joiner.<Boolean>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -194,4 +188,1 @@\n-                        scope1.fork(() -> null);\n-                    });\n-                    assertThrows(WrongThreadException.class, () -> {\n-                        scope2.fork(() -> null);\n+                        scope.fork(() -> null);\n@@ -203,0 +194,10 @@\n+\n+            \/\/ subtask cannot fork\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, () -> {\n+                    scope.fork(() -> null);\n+                });\n+                return true;\n+            });\n+            scope.join();\n+            assertTrue(subtask.get());\n@@ -207,1 +208,1 @@\n-     * Test fork after join completes.\n+     * Test fork after join, no subtasks forked before join.\n@@ -211,12 +212,3 @@\n-    void testForkAfterJoin(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-            \/\/ round 1\n-            var subtask1 = scope.fork(() -> \"foo\");\n-            assertThrows(IllegalStateException.class, subtask1::get);\n-            scope.join();\n-            assertEquals(\"foo\", subtask1.get());\n-\n-            \/\/ round 2\n-            var subtask2 = scope.fork(() -> \"bar\");\n-            assertEquals(\"foo\", subtask1.get());\n-            assertThrows(IllegalStateException.class, subtask2::get);\n+    void testForkAfterJoin1(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -224,2 +216,3 @@\n-            assertEquals(\"foo\", subtask1.get());\n-            assertEquals(\"bar\", subtask2.get());\n+            assertThrows(IllegalStateException.class, () -> scope.fork(() -> \"bar\"));\n+        }\n+    }\n@@ -227,5 +220,9 @@\n-            \/\/ round 3\n-            var subtask3 = scope.fork(() -> \"baz\");\n-            assertEquals(\"foo\", subtask1.get());\n-            assertEquals(\"bar\", subtask2.get());\n-            assertThrows(IllegalStateException.class, subtask3::get);\n+    \/**\n+     * Test fork after join, subtasks forked before join.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterJoin2(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            scope.fork(() -> \"foo\");\n@@ -233,3 +230,1 @@\n-            assertEquals(\"foo\", subtask1.get());\n-            assertEquals(\"bar\", subtask2.get());\n-            assertEquals(\"baz\", subtask3.get());\n+            assertThrows(IllegalStateException.class, () -> scope.fork(() -> \"bar\"));\n@@ -245,1 +240,2 @@\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -256,10 +252,2 @@\n-            \/\/ allow subtask1 to finish\n-            latch.countDown();\n-\n-            \/\/ continue to fork\n-            var subtask2 = scope.fork(() -> \"bar\");\n-            assertThrows(IllegalStateException.class, subtask1::get);\n-            assertThrows(IllegalStateException.class, subtask2::get);\n-            scope.join();\n-            assertEquals(\"foo\", subtask1.get());\n-            assertEquals(\"bar\", subtask2.get());\n+            \/\/ fork should throw\n+            assertThrows(IllegalStateException.class, () -> scope.fork(() -> \"bar\"));\n@@ -270,1 +258,2 @@\n-     * Test fork after scope is shutdown.\n+     * Test fork after task scope is cancelled. This test uses a custom Joiner to\n+     * cancel execution.\n@@ -274,8 +263,23 @@\n-    void testForkAfterShutdown(ThreadFactory factory) throws Exception {\n-        var executed = new AtomicBoolean();\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            scope.shutdown();\n-            Subtask<String> subtask = scope.fork(() -> {\n-                executed.set(true);\n-                return null;\n-            });\n+    void testForkAfterCancel2(ThreadFactory factory) throws Exception {\n+        var countingThreadFactory = new CountingThreadFactory(factory);\n+        var testJoiner = new CancelAfterOneJoiner<String>();\n+\n+        try (var scope = StructuredTaskScope.open(testJoiner,\n+                cf -> cf.withThreadFactory(countingThreadFactory))) {\n+\n+            \/\/ fork subtask, the scope should be cancelled when the subtask completes\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            awaitCancelled(scope);\n+\n+            assertEquals(1, countingThreadFactory.threadCount());\n+            assertEquals(1, testJoiner.onForkCount());\n+            assertEquals(1, testJoiner.onCompleteCount());\n+\n+            \/\/ fork second subtask, it should not run\n+            var subtask2 = scope.fork(() -> \"bar\");\n+\n+            \/\/ onFork should be invoked, newThread and onComplete should not be invoked\n+            assertEquals(1, countingThreadFactory.threadCount());\n+            assertEquals(2, testJoiner.onForkCount());\n+            assertEquals(1, testJoiner.onCompleteCount());\n+\n@@ -283,3 +287,6 @@\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n-            assertThrows(IllegalStateException.class, subtask::get);\n-            assertThrows(IllegalStateException.class, subtask::exception);\n+\n+            assertEquals(1, countingThreadFactory.threadCount());\n+            assertEquals(2, testJoiner.onForkCount());\n+            assertEquals(1, testJoiner.onCompleteCount());\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n@@ -287,1 +294,0 @@\n-        assertFalse(executed.get());\n@@ -291,1 +297,1 @@\n-     * Test fork after scope is closed.\n+     * Test fork after task scope is closed.\n@@ -293,4 +299,3 @@\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkAfterClose(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+    @Test\n+    void testForkAfterClose() {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n@@ -303,1 +308,1 @@\n-     * Test fork when the thread factory rejects creating a thread.\n+     * Test fork with a ThreadFactory that rejects creating a thread.\n@@ -306,1 +311,1 @@\n-    void testForkRejectedExecutionException() throws Exception {\n+    void testForkRejectedExecutionException() {\n@@ -308,1 +313,2 @@\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -310,1 +316,0 @@\n-            scope.join();\n@@ -319,1 +324,1 @@\n-        try (var scope = new StructuredTaskScope()) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n@@ -325,1 +330,1 @@\n-     * Test join with unfinished subtasks.\n+     * Test join with a remaining subtask.\n@@ -329,2 +334,3 @@\n-    void testJoinWithSubtasks(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n+    void testJoinWithRemainingSubtasks(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -332,1 +338,1 @@\n-                Thread.sleep(Duration.ofMillis(50));\n+                Thread.sleep(Duration.ofMillis(100));\n@@ -341,1 +347,1 @@\n-     * Test join is owner confined.\n+     * Test join after join completed with a result.\n@@ -343,4 +349,7 @@\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinConfined(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Boolean>()) {\n+    @Test\n+    void testJoinAfterJoin1() throws Exception {\n+        var results = new LinkedTransferQueue<>(List.of(\"foo\", \"bar\", \"baz\"));\n+        Joiner<Object, String> joiner = results::take;\n+        try (var scope = StructuredTaskScope.open(joiner)) {\n+            scope.fork(() -> \"foo\");\n+            assertEquals(\"foo\", scope.join());\n@@ -348,5 +357,6 @@\n-            \/\/ thread in scope cannot join\n-            Subtask<Boolean> subtask = scope.fork(() -> {\n-                assertThrows(WrongThreadException.class, () -> { scope.join(); });\n-                return true;\n-            });\n+            \/\/ join already called\n+            for (int i = 0 ; i < 3; i++) {\n+                assertThrows(IllegalStateException.class, scope::join);\n+            }\n+        }\n+    }\n@@ -354,1 +364,9 @@\n-            scope.join();\n+    \/**\n+     * Test join after join completed with an exception.\n+     *\/\n+    @Test\n+    void testJoinAfterJoin2() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow())) {\n+            scope.fork(() -> { throw new FooException(); });\n+            Throwable ex = assertThrows(FailedException.class, scope::join);\n+            assertTrue(ex.getCause() instanceof FooException);\n@@ -356,1 +374,33 @@\n-            assertTrue(subtask.get());\n+            \/\/ join already called\n+            for (int i = 0 ; i < 3; i++) {\n+                assertThrows(IllegalStateException.class, scope::join);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test join after join completed with a timeout.\n+     *\/\n+    @Test\n+    void testJoinAfterJoin3() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow(),\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            \/\/ wait for scope to be cancelled by timeout\n+            awaitCancelled(scope);\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            \/\/ join already called\n+            for (int i = 0 ; i < 3; i++) {\n+                assertThrows(IllegalStateException.class, scope::join);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test join method is owner confined.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinConfined(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<Boolean>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -366,0 +416,8 @@\n+\n+            \/\/ subtask cannot join\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, () -> { scope.join(); });\n+                return true;\n+            });\n+            scope.join();\n+            assertTrue(subtask.get());\n@@ -375,2 +433,2 @@\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -379,1 +437,1 @@\n-                latch.await();\n+                Thread.sleep(60_000);\n@@ -389,4 +447,1 @@\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be cleared\n@@ -394,4 +449,0 @@\n-\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", subtask.get());\n@@ -407,1 +458,3 @@\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n+\n@@ -410,1 +463,1 @@\n-                latch.await();\n+                Thread.sleep(60_000);\n@@ -414,2 +467,2 @@\n-            \/\/ join should throw\n-            scheduleInterruptAt(\"java.util.concurrent.StructuredTaskScope.join\");\n+            \/\/ interrupt main thread when it blocks in join\n+            scheduleInterruptAt(\"java.util.concurrent.StructuredTaskScopeImpl.join\");\n@@ -421,3 +474,0 @@\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n@@ -425,4 +475,0 @@\n-\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", subtask.get());\n@@ -433,1 +479,1 @@\n-     * Test join when scope is shutdown.\n+     * Test join when scope is cancelled.\n@@ -437,20 +483,3 @@\n-    void testJoinWithShutdown1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-            var interrupted = new CountDownLatch(1);\n-            var finish = new CountDownLatch(1);\n-\n-            Subtask<String> subtask = scope.fork(() -> {\n-                try {\n-                    Thread.sleep(Duration.ofDays(1));\n-                } catch (InterruptedException e) {\n-                    interrupted.countDown();\n-                }\n-                finish.await();\n-                return \"foo\";\n-            });\n-\n-            scope.shutdown();      \/\/ should interrupt task\n-\n-            interrupted.await();\n-\n-            scope.join();\n+    void testJoinWhenCancelled(ThreadFactory factory) throws Exception {\n+        var countingThreadFactory = new CountingThreadFactory(factory);\n+        var testJoiner = new CancelAfterOneJoiner<String>();\n@@ -458,4 +487,2 @@\n-            \/\/ signal task to finish\n-            finish.countDown();\n-        }\n-    }\n+        try (var scope = StructuredTaskScope.open(testJoiner,\n+                    cf -> cf.withThreadFactory(countingThreadFactory))) {\n@@ -463,15 +490,3 @@\n-    \/**\n-     * Test shutdown when owner is blocked in join.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinWithShutdown2(ThreadFactory factory) throws Exception {\n-        class MyScope<T> extends StructuredTaskScope<T> {\n-            MyScope(ThreadFactory factory) {\n-                super(null, factory);\n-            }\n-            @Override\n-            protected void handleComplete(Subtask<? extends T> subtask) {\n-                shutdown();\n-            }\n-        }\n+            \/\/ fork subtask, the scope should be cancelled when the subtask completes\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            awaitCancelled(scope);\n@@ -479,6 +494,2 @@\n-        try (var scope = new MyScope<String>(factory)) {\n-            Subtask<String> subtask1 = scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(50));\n-                return \"foo\";\n-            });\n-            Subtask<String> subtask2 = scope.fork(() -> {\n+            \/\/ fork second subtask, it should not run\n+            var subtask2 = scope.fork(() -> {\n@@ -489,1 +500,0 @@\n-            \/\/ join should wakeup when shutdown is called\n@@ -492,2 +502,0 @@\n-            \/\/ task1 should have completed successfully\n-            assertEquals(Subtask.State.SUCCESS, subtask1.state());\n@@ -495,3 +503,0 @@\n-            assertThrows(IllegalStateException.class, subtask1::exception);\n-\n-            \/\/ task2 result\/exception not available\n@@ -499,2 +504,0 @@\n-            assertThrows(IllegalStateException.class, subtask2::get);\n-            assertThrows(IllegalStateException.class, subtask2::exception);\n@@ -509,2 +512,1 @@\n-        try (var scope = new StructuredTaskScope()) {\n-            scope.join();\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n@@ -513,1 +515,0 @@\n-            assertThrows(IllegalStateException.class, () -> scope.joinUntil(Instant.now()));\n@@ -518,1 +519,1 @@\n-     * Test joinUntil, subtasks finish before deadline expires.\n+     * Test join with timeout, subtasks finish before timeout expires.\n@@ -522,2 +523,5 @@\n-    void testJoinUntil1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+    void testJoinWithTimeout1(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory)\n+                        .withTimeout(Duration.ofDays(1)))) {\n+\n@@ -525,3 +529,1 @@\n-                try {\n-                    Thread.sleep(Duration.ofSeconds(2));\n-                } catch (InterruptedException e) { }\n+                Thread.sleep(Duration.ofSeconds(1));\n@@ -531,3 +533,3 @@\n-            long startMillis = millisTime();\n-            scope.joinUntil(Instant.now().plusSeconds(30));\n-            expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n+            scope.join();\n+\n+            assertFalse(scope.isCancelled());\n@@ -539,1 +541,1 @@\n-     * Test joinUntil, deadline expires before subtasks finish.\n+     * Test join with timeout, timeout expires before subtasks finish.\n@@ -543,2 +545,6 @@\n-    void testJoinUntil2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+    void testJoinWithTimeout2(ThreadFactory factory) throws Exception {\n+        long startMillis = millisTime();\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory)\n+                        .withTimeout(Duration.ofSeconds(2)))) {\n+\n@@ -550,6 +556,4 @@\n-            long startMillis = millisTime();\n-            try {\n-                scope.joinUntil(Instant.now().plusSeconds(2));\n-            } catch (TimeoutException e) {\n-                expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n-            }\n+            assertThrows(TimeoutException.class, scope::join);\n+            expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n+\n+            assertTrue(scope.isCancelled());\n@@ -561,1 +565,1 @@\n-     * Test joinUntil many times.\n+     * Test join with timeout that has already expired.\n@@ -565,17 +569,4 @@\n-    void testJoinUntil3(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-            Subtask<String> subtask = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n-\n-            for (int i = 0; i < 3; i++) {\n-                try {\n-                    scope.joinUntil(Instant.now().plusMillis(50));\n-                    fail(\"joinUntil did not throw\");\n-                } catch (TimeoutException expected) {\n-                    assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n-                }\n-            }\n-        }\n-    }\n+    void testJoinWithTimeout3(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory)\n+                        .withTimeout(Duration.ofSeconds(-1)))) {\n@@ -583,7 +574,0 @@\n-    \/**\n-     * Test joinUntil with a deadline that has already expired.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinUntil4(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n@@ -595,7 +579,1 @@\n-            \/\/ now\n-            try {\n-                scope.joinUntil(Instant.now());\n-                fail(\"joinUntil did not throw\");\n-            } catch (TimeoutException expected) {\n-                assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n-            }\n+            assertThrows(TimeoutException.class, scope::join);\n@@ -603,7 +581,2 @@\n-            \/\/ in the past\n-            try {\n-                scope.joinUntil(Instant.now().minusSeconds(1));\n-                fail(\"joinUntil did not throw\");\n-            } catch (TimeoutException expected) {\n-                assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n-            }\n+            assertTrue(scope.isCancelled());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n@@ -614,1 +587,2 @@\n-     * Test joinUntil with interrupt status set.\n+     * Test that cancelling execution interrupts unfinished threads. This test uses\n+     * a custom Joiner to cancel execution.\n@@ -618,3 +592,2 @@\n-    void testInterruptJoinUntil1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-            var latch = new CountDownLatch(1);\n+    void testCancelInterruptsThreads2(ThreadFactory factory) throws Exception {\n+        var testJoiner = new CancelAfterOneJoiner<String>();\n@@ -622,3 +595,13 @@\n-            Subtask<String> subtask = scope.fork(() -> {\n-                latch.await();\n-                return \"foo\";\n+        try (var scope = StructuredTaskScope.open(testJoiner,\n+                cf -> cf.withThreadFactory(factory))) {\n+\n+            \/\/ fork subtask1 that runs for a long time\n+            var started = new CountDownLatch(1);\n+            var interrupted = new CountDownLatch(1);\n+            var subtask1 = scope.fork(() -> {\n+                started.countDown();\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n@@ -626,0 +609,1 @@\n+            started.await();\n@@ -627,11 +611,6 @@\n-            \/\/ joinUntil should throw\n-            Thread.currentThread().interrupt();\n-            try {\n-                scope.joinUntil(Instant.now().plusSeconds(30));\n-                fail(\"joinUntil did not throw\");\n-            } catch (InterruptedException expected) {\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n-            }\n+            \/\/ fork subtask2, the scope should be cancelled when the subtask completes\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            awaitCancelled(scope);\n+\n+            \/\/ subtask1 should be interrupted\n+            interrupted.await();\n@@ -639,1 +618,0 @@\n-            \/\/ join should complete\n@@ -641,1 +619,2 @@\n-            assertEquals(\"foo\", subtask.get());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask1.state());\n+            assertEquals(\"bar\", subtask2.get());\n@@ -646,1 +625,1 @@\n-     * Test interrupt of thread blocked in joinUntil.\n+     * Test that timeout interrupts unfinished threads.\n@@ -650,3 +629,4 @@\n-    void testInterruptJoinUntil2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n+    void testTimeoutInterruptsThreads(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory)\n+                        .withTimeout(Duration.ofSeconds(2)))) {\n@@ -654,3 +634,10 @@\n-            Subtask<String> subtask = scope.fork(() -> {\n-                latch.await();\n-                return \"foo\";\n+            var started = new AtomicBoolean();\n+            var interrupted = new CountDownLatch(1);\n+            Subtask<Void> subtask = scope.fork(() -> {\n+                started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+                return null;\n@@ -659,10 +646,6 @@\n-            \/\/ joinUntil should throw\n-            scheduleInterruptAt(\"java.util.concurrent.StructuredTaskScope.joinUntil\");\n-            try {\n-                scope.joinUntil(Instant.now().plusSeconds(30));\n-                fail(\"joinUntil did not throw\");\n-            } catch (InterruptedException expected) {\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n+            \/\/ wait for scope to be cancelled by timeout\n+            awaitCancelled(scope);\n+\n+            \/\/ if subtask started then it should be interrupted\n+            if (started.get()) {\n+                interrupted.await();\n@@ -671,33 +654,1 @@\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", subtask.get());\n-        }\n-    }\n-\n-    \/**\n-     * Test that shutdown interrupts unfinished subtasks.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testShutdownInterruptsThreads1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            var interrupted = new AtomicBoolean();\n-            var latch = new CountDownLatch(1);\n-            var subtask = scope.fork(() -> {\n-                try {\n-                    Thread.sleep(Duration.ofDays(1));\n-                } catch (InterruptedException e) {\n-                    interrupted.set(true);\n-                } finally {\n-                    latch.countDown();\n-                }\n-                return null;\n-            });\n-\n-            scope.shutdown();\n-\n-            \/\/ wait for task to complete\n-            latch.await();\n-            assertTrue(interrupted.get());\n-\n-            scope.join();\n+            assertThrows(TimeoutException.class, scope::join);\n@@ -705,1 +656,0 @@\n-            \/\/ subtask result\/exception not available\n@@ -707,121 +657,0 @@\n-            assertThrows(IllegalStateException.class, subtask::get);\n-            assertThrows(IllegalStateException.class, subtask::exception);\n-        }\n-    }\n-\n-    \/**\n-     * Test that shutdown does not interrupt current thread.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testShutdownInterruptsThreads2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            var interrupted = new AtomicBoolean();\n-            var latch = new CountDownLatch(1);\n-            var subtask = scope.fork(() -> {\n-                try {\n-                    scope.shutdown();\n-                    interrupted.set(Thread.currentThread().isInterrupted());\n-                } finally {\n-                    latch.countDown();\n-                }\n-                return null;\n-            });\n-\n-            \/\/ wait for task to complete\n-            latch.await();\n-            assertFalse(interrupted.get());\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test shutdown wakes join.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testShutdownWakesJoin(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-            scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(100));  \/\/ give time for join to block\n-                scope.shutdown();\n-                latch.await();\n-                return null;\n-            });\n-\n-            scope.join();\n-\n-            \/\/ join woke up, allow task to complete\n-            latch.countDown();\n-        }\n-    }\n-\n-    \/**\n-     * Test shutdown after scope is closed.\n-     *\/\n-    @Test\n-    void testShutdownAfterClose() throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>()) {\n-            scope.join();\n-            scope.close();\n-            assertThrows(IllegalStateException.class, scope::shutdown);\n-        }\n-    }\n-\n-    \/**\n-     * Test shutdown is confined to threads in the scope \"tree\".\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testShutdownConfined(ThreadFactory factory) throws Exception {\n-        try (var scope1 = new StructuredTaskScope<Boolean>();\n-             var scope2 = new StructuredTaskScope<Boolean>()) {\n-\n-            \/\/ thread in scope1 cannot shutdown scope2\n-            Subtask<Boolean> subtask1 = scope1.fork(() -> {\n-                assertThrows(WrongThreadException.class, scope2::shutdown);\n-                return true;\n-            });\n-\n-            \/\/ wait for task in scope1 to complete to avoid racing with task in scope2\n-            while (subtask1.state() == Subtask.State.UNAVAILABLE) {\n-                Thread.sleep(10);\n-            }\n-\n-            \/\/ thread in scope2 shutdown scope1\n-            Subtask<Boolean> subtask2 = scope2.fork(() -> {\n-                scope1.shutdown();\n-                return true;\n-            });\n-\n-            scope2.join();\n-            scope1.join();\n-\n-            assertTrue(subtask1.get());\n-            assertTrue(subtask1.get());\n-\n-            \/\/ random thread cannot shutdown\n-            try (var pool = Executors.newSingleThreadExecutor()) {\n-                Future<Void> future = pool.submit(() -> {\n-                    assertThrows(WrongThreadException.class, scope1::shutdown);\n-                    assertThrows(WrongThreadException.class, scope2::shutdown);\n-                    return null;\n-                });\n-                future.get();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test isShutdown.\n-     *\/\n-    @Test\n-    void testIsShutdown() {\n-        try (var scope = new StructuredTaskScope<Object>()) {\n-            assertFalse(scope.isShutdown());   \/\/ before shutdown\n-            scope.shutdown();\n-            assertTrue(scope.isShutdown());    \/\/ after shutdown\n-            scope.close();\n-            assertTrue(scope.isShutdown());    \/\/ after cose\n@@ -836,1 +665,1 @@\n-        try (var scope = new StructuredTaskScope<Object>()) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n@@ -842,1 +671,1 @@\n-     * Test close without join, unfinished subtasks.\n+     * Test close without join, subtasks forked.\n@@ -847,1 +676,2 @@\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -852,8 +682,0 @@\n-            assertThrows(IllegalStateException.class, scope::close);\n-\n-            \/\/ subtask result\/exception not available\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n-            assertThrows(IllegalStateException.class, subtask::get);\n-            assertThrows(IllegalStateException.class, subtask::exception);\n-        }\n-    }\n@@ -861,14 +683,1 @@\n-    \/**\n-     * Test close without join, unfinished subtasks forked after join.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCloseWithoutJoin3(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            scope.fork(() -> \"foo\");\n-            scope.join();\n-\n-            Subtask<String> subtask = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n+            \/\/ first call to close should throw\n@@ -877,0 +686,5 @@\n+            \/\/ subsequent calls to close should not throw\n+            for (int i = 0; i < 3; i++) {\n+                scope.close();\n+            }\n+\n@@ -890,1 +704,2 @@\n-        try (var scope = new StructuredTaskScope<Object>()) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -900,2 +715,0 @@\n-        }\n-    }\n@@ -903,16 +716,1 @@\n-    \/**\n-     * Test close after joinUntil throws. Close should not throw as join attempted.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCloseAfterJoinUntilThrows(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>()) {\n-            var subtask = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n-\n-            \/\/ joinUntil throws\n-            assertThrows(TimeoutException.class, () -> scope.joinUntil(Instant.now()));\n-            assertThrows(IllegalStateException.class, subtask::get);\n-        }\n+        }  \/\/ close should not throw\n@@ -922,1 +720,1 @@\n-     * Test close is owner confined.\n+     * Test close method is owner confined.\n@@ -927,10 +725,2 @@\n-        try (var scope = new StructuredTaskScope<Boolean>()) {\n-\n-            \/\/ attempt to close from thread in scope\n-            Subtask<Boolean> subtask = scope.fork(() -> {\n-                assertThrows(WrongThreadException.class, scope::close);\n-                return true;\n-            });\n-\n-            scope.join();\n-            assertTrue(subtask.get());\n+        try (var scope = StructuredTaskScope.open(Joiner.<Boolean>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -946,0 +736,8 @@\n+\n+            \/\/ subtask cannot close\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, scope::close);\n+                return true;\n+            });\n+            scope.join();\n+            assertTrue(subtask.get());\n@@ -955,1 +753,6 @@\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+        var testJoiner = new CancelAfterOneJoiner<String>();\n+        try (var scope = StructuredTaskScope.open(testJoiner,\n+                cf -> cf.withThreadFactory(factory))) {\n+\n+            \/\/ fork first subtask, a straggler as it continues after being interrupted\n+            var started = new CountDownLatch(1);\n@@ -958,0 +761,1 @@\n+                started.countDown();\n@@ -961,1 +765,1 @@\n-                    \/\/ interrupted by shutdown, expected\n+                    \/\/ interrupted by cancel, expected\n@@ -967,0 +771,5 @@\n+            started.await();\n+\n+            \/\/ fork second subtask, the scope should be cancelled when this subtask completes\n+            scope.fork(() -> \"bar\");\n+            awaitCancelled(scope);\n@@ -968,1 +777,0 @@\n-            scope.shutdown();\n@@ -988,2 +796,4 @@\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            var done = new AtomicBoolean();\n+        var testJoiner = new CancelAfterOneJoiner<String>();\n+        try (var scope = StructuredTaskScope.open(testJoiner,\n+                cf -> cf.withThreadFactory(factory))) {\n+\n@@ -991,0 +801,4 @@\n+\n+            \/\/ fork first subtask, a straggler as it continues after being interrupted\n+            var started = new CountDownLatch(1);\n+            var done = new AtomicBoolean();\n@@ -992,0 +806,1 @@\n+                started.countDown();\n@@ -995,1 +810,1 @@\n-                    \/\/ interrupted by shutdown, expected\n+                    \/\/ interrupted by cancel, expected\n@@ -999,1 +814,1 @@\n-                interruptThreadAt(mainThread, \"java.util.concurrent.StructuredTaskScope.close\");\n+                interruptThreadAt(mainThread, \"java.util.concurrent.StructuredTaskScopeImpl.close\");\n@@ -1005,0 +820,5 @@\n+            started.await();\n+\n+            \/\/ fork second subtask, the scope should be cancelled when this subtask completes\n+            scope.fork(() -> \"bar\");\n+            awaitCancelled(scope);\n@@ -1006,1 +826,0 @@\n-            scope.shutdown();   \/\/ interrupts task\n@@ -1008,0 +827,2 @@\n+\n+            \/\/ main thread will be interrupted while blocked in close\n@@ -1011,1 +832,1 @@\n-                assertTrue(Thread.interrupted()); \/\/ clear interrupt status\n+                assertTrue(Thread.interrupted());   \/\/ clear interrupt status\n@@ -1022,2 +843,2 @@\n-        try (var scope1 = new StructuredTaskScope<Object>()) {\n-            try (var scope2 = new StructuredTaskScope<Object>()) {\n+        try (var scope1 = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            try (var scope2 = StructuredTaskScope.open(Joiner.awaitAll())) {\n@@ -1025,2 +846,1 @@\n-                \/\/ join + close enclosing scope\n-                scope1.join();\n+                \/\/ close enclosing scope\n@@ -1032,1 +852,1 @@\n-                \/\/ underlying flock should be closed, fork should return a cancelled task\n+                \/\/ underlying flock should be closed\n@@ -1034,4 +854,1 @@\n-                Subtask<Void> subtask = scope2.fork(() -> {\n-                    executed.set(true);\n-                    return null;\n-                });\n+                Subtask<?> subtask = scope2.fork(() -> executed.set(true));\n@@ -1041,0 +858,1 @@\n+                assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n@@ -1046,28 +864,1 @@\n-     * A StructuredTaskScope that collects the subtasks notified to the handleComplete method.\n-     *\/\n-    private static class CollectAll<T> extends StructuredTaskScope<T> {\n-        private final Set<Subtask<? extends T>> subtasks = ConcurrentHashMap.newKeySet();\n-\n-        CollectAll(ThreadFactory factory) {\n-            super(null, factory);\n-        }\n-\n-        @Override\n-        protected void handleComplete(Subtask<? extends T> subtask) {\n-            subtasks.add(subtask);\n-        }\n-\n-        Set<Subtask<? extends T>> subtasks() {\n-            return subtasks;\n-        }\n-\n-        Subtask<? extends T> find(Callable<T> task) {\n-            return subtasks.stream()\n-                    .filter(h -> task.equals(h.task()))\n-                    .findAny()\n-                    .orElseThrow();\n-        }\n-    }\n-\n-    \/**\n-     * Test that handleComplete method is invoked for tasks that complete before shutdown.\n+     * Test that isCancelled returns true after close.\n@@ -1075,15 +866,6 @@\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testHandleCompleteBeforeShutdown(ThreadFactory factory) throws Exception {\n-        try (var scope = new CollectAll<String>(factory)) {\n-            Callable<String> task1 = () -> \"foo\";\n-            Callable<String> task2 = () -> { throw new FooException(); };\n-            scope.fork(task1);\n-            scope.fork(task2);\n-            scope.join();\n-\n-            var subtask1 = scope.find(task1);\n-            assertEquals(\"foo\", subtask1.get());\n-\n-            var subtask2 = scope.find(task2);\n-            assertTrue(subtask2.exception() instanceof FooException);\n+    @Test\n+    void testIsCancelledAfterClose() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            assertFalse(scope.isCancelled());\n+            scope.close();\n+            assertTrue(scope.isCancelled());\n@@ -1094,2 +876,1 @@\n-     * Test that handleComplete method is not invoked for tasks that finish after shutdown\n-     * or are forked after shutdown.\n+     * Test Joiner.onFork throwing exception.\n@@ -1097,31 +878,6 @@\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testHandleCompleteAfterShutdown(ThreadFactory factory) throws Exception {\n-        try (var scope = new CollectAll<String>(factory)) {\n-            Callable<String> task1 = () -> {\n-                try {\n-                    Thread.sleep(Duration.ofDays(1));\n-                } catch (InterruptedException ignore) { }\n-                return \"foo\";\n-            };\n-            Callable<String> task2 = () -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return \"bar\";\n-            };\n-            Callable<String> task3 = () -> \"baz\";\n-\n-            \/\/ forked before shutdown, will complete after shutdown\n-            var subtask1 = scope.fork(task1);\n-            var subtask2 = scope.fork(task2);\n-\n-            scope.shutdown();\n-\n-            \/\/ forked after shutdown\n-            var subtask3 = scope.fork(task3);\n-\n-            scope.join();\n-\n-            \/\/ handleComplete should not be called\n-            for (int i = 0; i < 3; i++) {\n-                assertEquals(0, scope.subtasks().size());\n-                Thread.sleep(20);\n+    @Test\n+    void testOnForkThrows() throws Exception {\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public boolean onFork(Subtask<? extends String> subtask) {\n+                throw new FooException();\n@@ -1129,4 +885,7 @@\n-\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask1.state());\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask3.state());\n+            @Override\n+            public Void result() {\n+                return null;\n+            }\n+        };\n+        try (var scope = StructuredTaskScope.open(joiner)) {\n+            assertThrows(FooException.class, () -> scope.fork(() -> \"foo\"));\n@@ -1137,2 +896,1 @@\n-     * Test that the default handleComplete throws IllegalArgumentException if called\n-     * with a running task.\n+     * Test Joiner.onFork returning true to cancel execution.\n@@ -1141,4 +899,5 @@\n-    void testHandleCompleteThrows() throws Exception {\n-        class TestScope<T> extends StructuredTaskScope<T> {\n-            protected void handleComplete(Subtask<? extends T> subtask) {\n-                super.handleComplete(subtask);\n+    void testOnForkCancelsExecution() throws Exception {\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public boolean onFork(Subtask<? extends String> subtask) {\n+                return true;\n@@ -1146,16 +905,9 @@\n-        }\n-\n-        try (var scope = new TestScope<String>()) {\n-            var subtask = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return \"foo\";\n-            });\n-\n-            \/\/ running task\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n-            assertThrows(IllegalArgumentException.class, () -> scope.handleComplete(subtask));\n-            scope.shutdown();\n-\n-            \/\/ null task\n-            assertThrows(NullPointerException.class, () -> scope.handleComplete(null));\n-\n+            @Override\n+            public Void result() {\n+                return null;\n+            }\n+        };\n+        try (var scope = StructuredTaskScope.open(joiner)) {\n+            assertFalse(scope.isCancelled());\n+            scope.fork(() -> \"foo\");\n+            assertTrue(scope.isCancelled());\n@@ -1167,1 +919,1 @@\n-     * Test ensureOwnerAndJoined.\n+     * Test Joiner.onComplete throwing exception causes UHE to be invoked.\n@@ -1169,6 +921,6 @@\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testEnsureOwnerAndJoined(ThreadFactory factory) throws Exception {\n-        class MyScope<T> extends StructuredTaskScope<T> {\n-            MyScope(ThreadFactory factory) {\n-                super(null, factory);\n+    @Test\n+    void testOnCompleteThrows() throws Exception {\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public boolean onComplete(Subtask<? extends String> subtask) {\n+                throw new FooException();\n@@ -1176,2 +928,3 @@\n-            void invokeEnsureOwnerAndJoined() {\n-                super.ensureOwnerAndJoined();\n+            @Override\n+            public Void result() {\n+                return null;\n@@ -1179,20 +932,8 @@\n-        }\n-\n-        try (var scope = new MyScope<Boolean>(factory)) {\n-            \/\/ owner thread, before join\n-            scope.fork(() -> true);\n-            assertThrows(IllegalStateException.class, () -> {\n-                scope.invokeEnsureOwnerAndJoined();\n-            });\n-\n-            \/\/ owner thread, after join\n-            scope.join();\n-            scope.invokeEnsureOwnerAndJoined();\n-\n-            \/\/ thread in scope cannot invoke ensureOwnerAndJoined\n-            Subtask<Boolean> subtask = scope.fork(() -> {\n-                assertThrows(WrongThreadException.class, () -> {\n-                    scope.invokeEnsureOwnerAndJoined();\n-                });\n-                return true;\n-            });\n+        };\n+        var excRef = new AtomicReference<Throwable>();\n+        Thread.UncaughtExceptionHandler uhe = (t, e) -> excRef.set(e);\n+        ThreadFactory factory = Thread.ofVirtual()\n+                .uncaughtExceptionHandler(uhe)\n+                .factory();\n+        try (var scope = StructuredTaskScope.open(joiner, cf -> cf.withThreadFactory(factory))) {\n+            scope.fork(() -> \"foo\");\n@@ -1200,12 +941,1 @@\n-            assertTrue(subtask.get());\n-\n-            \/\/ random thread cannot invoke ensureOwnerAndJoined\n-            try (var pool = Executors.newSingleThreadExecutor()) {\n-                Future<Void> future = pool.submit(() -> {\n-                    assertThrows(WrongThreadException.class, () -> {\n-                        scope.invokeEnsureOwnerAndJoined();\n-                    });\n-                    return null;\n-                });\n-                future.get();\n-            }\n+            assertInstanceOf(FooException.class, excRef.get());\n@@ -1216,1 +946,1 @@\n-     * Test ensureOwnerAndJoined after the task scope has been closed.\n+     * Test Joiner.onComplete returning true to cancel execution.\n@@ -1218,6 +948,6 @@\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testEnsureOwnerAndJoinedAfterClose(ThreadFactory factory) throws Exception {\n-        class MyScope<T> extends StructuredTaskScope<T> {\n-            MyScope(ThreadFactory factory) {\n-                super(null, factory);\n+    @Test\n+    void testOnCompleteCancelsExecution() throws Exception {\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public boolean onComplete(Subtask<? extends String> subtask) {\n+                return true;\n@@ -1225,2 +955,3 @@\n-            public void invokeEnsureOwnerAndJoined() {\n-                super.ensureOwnerAndJoined();\n+            @Override\n+            public Void result() {\n+                return null;\n@@ -1228,4 +959,3 @@\n-        }\n-\n-        \/\/ ensureOwnerAndJoined after close, join invoked\n-        try (var scope = new MyScope<String>(factory)) {\n+        };\n+        try (var scope = StructuredTaskScope.open(joiner)) {\n+            assertFalse(scope.isCancelled());\n@@ -1233,0 +963,1 @@\n+            awaitCancelled(scope);\n@@ -1234,9 +965,0 @@\n-            scope.close();\n-            scope.invokeEnsureOwnerAndJoined();  \/\/ should not throw\n-        }\n-\n-        \/\/ ensureOwnerAndJoined after close, join not invoked\n-        try (var scope = new MyScope<String>(factory)) {\n-            scope.fork(() -> \"foo\");\n-            assertThrows(IllegalStateException.class, scope::close);\n-            scope.invokeEnsureOwnerAndJoined();  \/\/ should not throw\n@@ -1246,1 +968,0 @@\n-\n@@ -1252,4 +973,2 @@\n-        ThreadFactory factory = Thread.ofVirtual().factory();\n-        try (var scope = new StructuredTaskScope<Object>(\"duke\", factory)) {\n-            \/\/ open\n-            assertTrue(scope.toString().contains(\"duke\"));\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withName(\"duke\"))) {\n@@ -1257,2 +976,1 @@\n-            \/\/ shutdown\n-            scope.shutdown();\n+            \/\/ open\n@@ -1262,1 +980,0 @@\n-            scope.join();\n@@ -1274,3 +991,2 @@\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-            Callable<String> task = () -> \"foo\";\n-            Subtask<String> subtask = scope.fork(task);\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -1278,2 +994,3 @@\n-            \/\/ before join, owner thread\n-            assertEquals(task, subtask.task());\n+            Subtask<String> subtask = scope.fork(() -> \"foo\");\n+\n+            \/\/ before join\n@@ -1286,1 +1003,0 @@\n-            assertEquals(task, subtask.task());\n@@ -1299,3 +1015,2 @@\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-            Callable<String> task = () -> { throw new FooException(); };\n-            Subtask<String> subtask = scope.fork(task);\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -1303,2 +1018,3 @@\n-            \/\/ before join, owner thread\n-            assertEquals(task, subtask.task());\n+            Subtask<String> subtask = scope.fork(() -> { throw new FooException(); });\n+\n+            \/\/ before join\n@@ -1311,1 +1027,0 @@\n-            assertEquals(task, subtask.task());\n@@ -1324,2 +1039,3 @@\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            Callable<Void> task = () -> {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            Subtask<Void> subtask = scope.fork(() -> {\n@@ -1328,2 +1044,1 @@\n-            };\n-            Subtask<Void> subtask = scope.fork(task);\n+            });\n@@ -1332,1 +1047,0 @@\n-            assertEquals(task, subtask.task());\n@@ -1342,1 +1056,0 @@\n-            assertEquals(task, subtask.task());\n@@ -1350,1 +1063,1 @@\n-     * Test Subtask when forked after shutdown.\n+     * Test Subtask forked after execution cancelled.\n@@ -1354,6 +1067,4 @@\n-    void testSubtaskWhenShutdown(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            Callable<Void> task = () -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            };\n+    void testSubtaskWhenCancelled(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(new CancelAfterOneJoiner<String>())) {\n+            scope.fork(() -> \"foo\");\n+            awaitCancelled(scope);\n@@ -1361,1 +1072,6 @@\n-            scope.shutdown();\n+            var subtask = scope.fork(() -> \"foo\");\n+\n+            \/\/ before join\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n@@ -1363,2 +1079,0 @@\n-            \/\/ fork after shutdown\n-            Subtask<Void> subtask = scope.fork(task);\n@@ -1366,1 +1080,2 @@\n-            assertEquals(task, subtask.task());\n+\n+            \/\/ after join\n@@ -1378,7 +1093,6 @@\n-        try (var scope = new StructuredTaskScope<Object>()) {\n-            \/\/ success\n-            var subtask1 = scope.fork(() -> \"foo\");\n-            scope.join();\n-            assertTrue(subtask1.toString().contains(\"Completed successfully\"));\n-\n-            \/\/ failed\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            var latch = new CountDownLatch(1);\n+            var subtask1 = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n@@ -1386,0 +1100,5 @@\n+\n+            \/\/ subtask1 result is unavailable\n+            assertTrue(subtask1.toString().contains(\"Unavailable\"));\n+            latch.countDown();\n+\n@@ -1387,1 +1106,0 @@\n-            assertTrue(subtask2.toString().contains(\"Failed\"));\n@@ -1389,7 +1107,4 @@\n-            \/\/ not completed\n-            Callable<Void> sleepForDay = () -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            };\n-            var subtask3 = scope.fork(sleepForDay);\n-            assertTrue(subtask3.toString().contains(\"Unavailable\"));\n+            assertTrue(subtask1.toString().contains(\"Completed successfully\"));\n+            assertTrue(subtask2.toString().contains(\"Failed\"));\n+        }\n+    }\n@@ -1397,1 +1112,10 @@\n-            scope.shutdown();\n+    \/**\n+     * Test Joiner.allSuccessfulOrThrow() with no subtasks.\n+     *\/\n+    @Test\n+    void testAllSuccessfulOrThrow1() throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.allSuccessfulOrThrow())) {\n+            var subtasks = scope.join().toList();\n+            assertTrue(subtasks.isEmpty());\n+        }\n+    }\n@@ -1399,3 +1123,16 @@\n-            \/\/ forked after shutdown\n-            var subtask4 = scope.fork(sleepForDay);\n-            assertTrue(subtask4.toString().contains(\"Unavailable\"));\n+    \/**\n+     * Test Joiner.allSuccessfulOrThrow() with subtasks that complete successfully.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAllSuccessfulOrThrow2(ThreadFactory factory) throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allSuccessfulOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            var subtasks = scope.join().toList();\n+            assertEquals(List.of(subtask1, subtask2), subtasks);\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n+        }\n+    }\n@@ -1403,1 +1140,16 @@\n-            scope.join();\n+    \/**\n+     * Test Joiner.allSuccessfulOrThrow() with a subtask that complete successfully and\n+     * a subtask that fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAllSuccessfulOrThrow3(ThreadFactory factory) throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allSuccessfulOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> { throw new FooException(); });\n+            try {\n+                scope.join();\n+            } catch (FailedException e) {\n+                assertTrue(e.getCause() instanceof FooException);\n+            }\n@@ -1408,1 +1160,1 @@\n-     * Test ShutdownOnSuccess with no completed tasks.\n+     * Test Joiner.anySuccessfulResultOrThrow() with no subtasks.\n@@ -1411,4 +1163,7 @@\n-    void testShutdownOnSuccess1() throws Exception {\n-        try (var scope = new ShutdownOnSuccess<Object>()) {\n-            assertThrows(IllegalStateException.class, () -> scope.result());\n-            assertThrows(IllegalStateException.class, () -> scope.result(e -> null));\n+    void testAnySuccessfulResultOrThrow1() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow())) {\n+            try {\n+                scope.join();\n+            } catch (FailedException e) {\n+                assertTrue(e.getCause() instanceof NoSuchElementException);\n+            }\n@@ -1419,1 +1174,1 @@\n-     * Test ShutdownOnSuccess with tasks that complete successfully.\n+     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that completes successfully.\n@@ -1423,2 +1178,3 @@\n-    void testShutdownOnSuccess2(ThreadFactory factory) throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>(null, factory)) {\n+    void testAnySuccessfulResultOrThrow2(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -1426,5 +1182,2 @@\n-            scope.join();  \/\/ ensures foo completes first\n-            scope.fork(() -> \"bar\");\n-            scope.join();\n-            assertEquals(\"foo\", scope.result());\n-            assertEquals(\"foo\", scope.result(e -> null));\n+            String result = scope.join();\n+            assertEquals(\"foo\", result);\n@@ -1435,1 +1188,2 @@\n-     * Test ShutdownOnSuccess with a task that completes successfully with a null result.\n+     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that completes successfully\n+     * with a null result.\n@@ -1439,2 +1193,3 @@\n-    void testShutdownOnSuccess3(ThreadFactory factory) throws Exception {\n-        try (var scope = new ShutdownOnSuccess<Object>(null, factory)) {\n+    void testAnySuccessfulResultOrThrow3(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -1442,3 +1197,2 @@\n-            scope.join();\n-            assertNull(scope.result());\n-            assertNull(scope.result(e -> null));\n+            String result = scope.join();\n+            assertNull(result);\n@@ -1449,1 +1203,2 @@\n-     * Test ShutdownOnSuccess with tasks that complete succcessfully and tasks that fail.\n+     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that complete succcessfully\n+     * and a subtask that fails.\n@@ -1453,2 +1208,3 @@\n-    void testShutdownOnSuccess4(ThreadFactory factory) throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>(null, factory)) {\n+    void testAnySuccessfulResultOrThrow4(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -1456,4 +1212,3 @@\n-            scope.fork(() -> { throw new ArithmeticException(); });\n-            scope.join();\n-            assertEquals(\"foo\", scope.result());\n-            assertEquals(\"foo\", scope.result(e -> null));\n+            scope.fork(() -> { throw new FooException(); });\n+            String first = scope.join();\n+            assertEquals(\"foo\", first);\n@@ -1464,1 +1219,1 @@\n-     * Test ShutdownOnSuccess with a task that fails.\n+     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that fails.\n@@ -1468,8 +1223,6 @@\n-    void testShutdownOnSuccess5(ThreadFactory factory) throws Exception {\n-        try (var scope = new ShutdownOnSuccess<Object>(null, factory)) {\n-            scope.fork(() -> { throw new ArithmeticException(); });\n-            scope.join();\n-            Throwable ex = assertThrows(ExecutionException.class, () -> scope.result());\n-            assertTrue(ex.getCause() instanceof ArithmeticException);\n-            ex = assertThrows(FooException.class, () -> scope.result(e -> new FooException(e)));\n-            assertTrue(ex.getCause() instanceof ArithmeticException);\n+    void testAnySuccessfulResultOrThrow5(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            scope.fork(() -> { throw new FooException(); });\n+            Throwable ex = assertThrows(FailedException.class, scope::join);\n+            assertTrue(ex.getCause() instanceof FooException);\n@@ -1480,1 +1233,12 @@\n-     * Test ShutdownOnSuccess methods are confined to the owner.\n+     * Test Joiner.awaitAllSuccessfulOrThrow() with no subtasks.\n+     *\/\n+    @Test\n+    void testAwaitSuccessfulOrThrow1() throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAllSuccessfulOrThrow())) {\n+            var result = scope.join();\n+            assertNull(result);\n+        }\n+    }\n+\n+    \/**\n+     * Test Joiner.awaitAllSuccessfulOrThrow() with subtasks that complete successfully.\n@@ -1484,9 +1248,9 @@\n-    void testShutdownOnSuccessConfined(ThreadFactory factory) throws Exception {\n-        \/\/ owner before join\n-        try (var scope = new ShutdownOnSuccess<Boolean>(null, factory)) {\n-            scope.fork(() -> { throw new FooException(); });\n-            assertThrows(IllegalStateException.class, scope::result);\n-            assertThrows(IllegalStateException.class, () -> {\n-                scope.result(e -> new RuntimeException(e));\n-            });\n-            scope.join();\n+    void testAwaitSuccessfulOrThrow2(ThreadFactory factory) throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAllSuccessfulOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            var result = scope.join();\n+            assertNull(result);\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n@@ -1494,0 +1258,1 @@\n+    }\n@@ -1495,11 +1260,16 @@\n-        \/\/ non-owner\n-        try (var scope = new ShutdownOnSuccess<Boolean>(null, factory)) {\n-            Subtask<Boolean> subtask = scope.fork(() -> {\n-                assertThrows(WrongThreadException.class, scope::result);\n-                assertThrows(WrongThreadException.class, () -> {\n-                    scope.result(e -> new RuntimeException(e));\n-                });\n-                return true;\n-            });\n-            scope.join();\n-            assertTrue(subtask.get());\n+    \/**\n+     * Test Joiner.awaitAllSuccessfulOrThrow() with a subtask that complete successfully and\n+     * a subtask that fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAwaitSuccessfulOrThrow3(ThreadFactory factory) throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAllSuccessfulOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> { throw new FooException(); });\n+            try {\n+                scope.join();\n+            } catch (FailedException e) {\n+                assertTrue(e.getCause() instanceof FooException);\n+            }\n@@ -1510,1 +1280,1 @@\n-     * Test ShutdownOnFailure with no completed tasks.\n+     * Test Joiner.awaitAll() with no subtasks.\n@@ -1513,5 +1283,4 @@\n-    void testShutdownOnFailure1() throws Throwable {\n-        try (var scope = new ShutdownOnFailure()) {\n-            assertTrue(scope.exception().isEmpty());\n-            scope.throwIfFailed();\n-            scope.throwIfFailed(e -> new FooException(e));\n+    void testAwaitAll1() throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            var result = scope.join();\n+            assertNull(result);\n@@ -1522,1 +1291,1 @@\n-     * Test ShutdownOnFailure with tasks that complete successfully.\n+     * Test Joiner.awaitAll() with subtasks that complete successfully.\n@@ -1526,5 +1295,29 @@\n-    void testShutdownOnFailure2(ThreadFactory factory) throws Throwable {\n-        try (var scope = new ShutdownOnFailure(null, factory)) {\n-            scope.fork(() -> \"foo\");\n-            scope.fork(() -> \"bar\");\n-            scope.join();\n+    void testAwaitAll2(ThreadFactory factory) throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            var result = scope.join();\n+            assertNull(result);\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test Joiner.awaitAll() with a subtask that complete successfully and a subtask\n+     * that fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAwaitAll3(ThreadFactory factory) throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> { throw new FooException(); });\n+            var result = scope.join();\n+            assertNull(result);\n+            assertEquals(\"foo\", subtask1.get());\n+            assertTrue(subtask2.exception() instanceof FooException);\n+        }\n+    }\n@@ -1532,4 +1325,8 @@\n-            \/\/ no exception\n-            assertTrue(scope.exception().isEmpty());\n-            scope.throwIfFailed();\n-            scope.throwIfFailed(e -> new FooException(e));\n+    \/**\n+     * Test Joiner.allUntil(Predicate) with no subtasks.\n+     *\/\n+    @Test\n+    void testAllUntil1() throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.allUntil(s -> false))) {\n+            var subtasks = scope.join();\n+            assertEquals(0, subtasks.count());\n@@ -1540,1 +1337,1 @@\n-     * Test ShutdownOnFailure with tasks that complete succcessfully and tasks that fail.\n+     * Test Joiner.allUntil(Predicate) with no cancellation.\n@@ -1544,2 +1341,3 @@\n-    void testShutdownOnFailure3(ThreadFactory factory) throws Throwable {\n-        try (var scope = new ShutdownOnFailure(null, factory)) {\n+    void testAllUntil2(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allUntil(s -> false),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -1547,4 +1345,5 @@\n-            \/\/ one task completes successfully, the other fails\n-            scope.fork(() -> \"foo\");\n-            scope.fork(() -> { throw new ArithmeticException(); });\n-            scope.join();\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> { throw new FooException(); });\n+\n+            var subtasks = scope.join().toList();\n+            assertEquals(2, subtasks.size());\n@@ -1552,2 +1351,6 @@\n-            Throwable ex = scope.exception().orElse(null);\n-            assertTrue(ex instanceof ArithmeticException);\n+            assertSame(subtask1, subtasks.get(0));\n+            assertSame(subtask2, subtasks.get(1));\n+            assertEquals(\"foo\", subtask1.get());\n+            assertTrue(subtask2.exception() instanceof FooException);\n+        }\n+    }\n@@ -1555,2 +1358,8 @@\n-            ex = assertThrows(ExecutionException.class, () -> scope.throwIfFailed());\n-            assertTrue(ex.getCause() instanceof ArithmeticException);\n+    \/**\n+     * Test Joiner.allUntil(Predicate) with cancellation after one subtask completes.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAllUntil3(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allUntil(s -> true),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -1558,3 +1367,13 @@\n-            ex = assertThrows(FooException.class,\n-                              () -> scope.throwIfFailed(e -> new FooException(e)));\n-            assertTrue(ex.getCause() instanceof ArithmeticException);\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n+\n+            var subtasks = scope.join().toList();\n+\n+            assertEquals(2, subtasks.size());\n+            assertSame(subtask1, subtasks.get(0));\n+            assertSame(subtask2, subtasks.get(1));\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n@@ -1565,1 +1384,1 @@\n-     * Test ShutdownOnFailure methods are confined to the owner.\n+     * Test Joiner.allUntil(Predicate) with cancellation after serveral subtasks complete.\n@@ -1569,3 +1388,46 @@\n-    void testShutdownOnFailureConfined(ThreadFactory factory) throws Exception {\n-        \/\/ owner before join\n-        try (var scope = new ShutdownOnFailure(null, factory)) {\n+    void testAllUntil4(ThreadFactory factory) throws Exception {\n+\n+        \/\/ cancel execution after two or more failures\n+        class CancelAfterTwoFailures<T> implements Predicate<Subtask<? extends T>> {\n+            final AtomicInteger failedCount = new AtomicInteger();\n+            @Override\n+            public boolean test(Subtask<? extends T> subtask) {\n+                return subtask.state() == Subtask.State.FAILED\n+                        && failedCount.incrementAndGet() >= 2;\n+            }\n+        }\n+        var joiner = Joiner.allUntil(new CancelAfterTwoFailures<String>());\n+\n+        try (var scope = StructuredTaskScope.open(joiner)) {\n+            int forkCount = 0;\n+\n+            \/\/ fork subtasks until execution cancelled\n+            while (!scope.isCancelled()) {\n+                scope.fork(() -> \"foo\");\n+                scope.fork(() -> { throw new FooException(); });\n+                forkCount += 2;\n+                Thread.sleep(Duration.ofMillis(20));\n+            }\n+\n+            var subtasks = scope.join().toList();\n+            assertEquals(forkCount, subtasks.size());\n+\n+            long failedCount = subtasks.stream()\n+                    .filter(s -> s.state() == Subtask.State.FAILED)\n+                    .count();\n+            assertTrue(failedCount >= 2);\n+        }\n+    }\n+\n+    \/**\n+     * Test Test Joiner.allUntil(Predicate) where the Predicate's test method throws.\n+     *\/\n+    @Test\n+    void testAllUntil5() throws Exception {\n+        var joiner = Joiner.allUntil(_ -> { throw new FooException(); });\n+        var excRef = new AtomicReference<Throwable>();\n+        Thread.UncaughtExceptionHandler uhe = (t, e) -> excRef.set(e);\n+        ThreadFactory factory = Thread.ofVirtual()\n+                .uncaughtExceptionHandler(uhe)\n+                .factory();\n+        try (var scope = StructuredTaskScope.open(joiner, cf -> cf.withThreadFactory(factory))) {\n@@ -1573,5 +1435,0 @@\n-            assertThrows(IllegalStateException.class, scope::exception);\n-            assertThrows(IllegalStateException.class, scope::throwIfFailed);\n-            assertThrows(IllegalStateException.class, () -> {\n-                scope.throwIfFailed(e -> new RuntimeException(e));\n-            });\n@@ -1579,0 +1436,1 @@\n+            assertInstanceOf(FooException.class, excRef.get());\n@@ -1580,0 +1438,1 @@\n+    }\n@@ -1581,9 +1440,37 @@\n-        \/\/ non-owner\n-        try (var scope = new ShutdownOnFailure(null, factory)) {\n-            Subtask<Boolean> subtask = scope.fork(() -> {\n-                assertThrows(WrongThreadException.class, scope::exception);\n-                assertThrows(WrongThreadException.class, scope::throwIfFailed);\n-                assertThrows(WrongThreadException.class, () -> {\n-                    scope.throwIfFailed(e -> new RuntimeException(e));\n-                });\n-                return true;\n+    \/**\n+     * Test Joiner default methods.\n+     *\/\n+    @Test\n+    void testJoinerDefaultMethods() throws Exception {\n+        try (var scope = StructuredTaskScope.open(new CancelAfterOneJoiner<String>())) {\n+\n+            \/\/ need subtasks to test default methods\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            awaitCancelled(scope);\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            scope.join();\n+\n+            assertEquals(Subtask.State.SUCCESS, subtask1.state());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n+\n+            \/\/ Joiner that does not override default methods\n+            Joiner<Object, Void> joiner = () -> null;\n+            assertThrows(NullPointerException.class, () -> joiner.onFork(null));\n+            assertThrows(NullPointerException.class, () -> joiner.onComplete(null));\n+            assertThrows(IllegalArgumentException.class, () -> joiner.onFork(subtask1));\n+            assertFalse(joiner.onFork(subtask2));\n+            assertFalse(joiner.onComplete(subtask1));\n+            assertThrows(IllegalArgumentException.class, () -> joiner.onComplete(subtask2));\n+        }\n+    }\n+\n+    \/**\n+     * Test Joiners onFork\/onComplete methods with a subtask in an unexpected state.\n+     *\/\n+    @Test\n+    void testJoinersWithUnavailableResult() throws Exception {\n+        try (var scope = StructuredTaskScope.open()) {\n+            var done = new CountDownLatch(1);\n+            var subtask = scope.fork(() -> {\n+                done.await();\n+                return null;\n@@ -1591,0 +1478,15 @@\n+\n+            \/\/ onComplete with uncompleted task should throw IAE\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.allSuccessfulOrThrow().onComplete(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.anySuccessfulResultOrThrow().onComplete(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.awaitAllSuccessfulOrThrow().onComplete(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.awaitAll().onComplete(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.allUntil(_ -> false).onComplete(subtask));\n+\n+            done.countDown();\n@@ -1592,1 +1494,59 @@\n-            assertTrue(subtask.get());\n+\n+            \/\/ onFork with completed task should throw IAE\n+            assertEquals(Subtask.State.SUCCESS, subtask.state());\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.allSuccessfulOrThrow().onFork(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.anySuccessfulResultOrThrow().onFork(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.awaitAllSuccessfulOrThrow().onFork(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.awaitAll().onFork(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.allUntil(_ -> false).onFork(subtask));\n+        }\n+\n+    }\n+\n+    \/**\n+     * Test the Configuration function apply method throwing an exception.\n+     *\/\n+    @Test\n+    void testConfigFunctionThrows() throws Exception {\n+        assertThrows(FooException.class,\n+                () -> StructuredTaskScope.open(Joiner.awaitAll(),\n+                                               cf -> { throw new FooException(); }));\n+    }\n+\n+    \/**\n+     * Test Configuration equals\/hashCode\/toString\n+     *\/\n+    @Test\n+    void testConfigMethods() throws Exception {\n+        Function<Configuration, Configuration> testConfig = cf -> {\n+            var name = \"duke\";\n+            var threadFactory = Thread.ofPlatform().factory();\n+            var timeout = Duration.ofSeconds(10);\n+\n+            assertEquals(cf, cf);\n+            assertEquals(cf.withName(name), cf.withName(name));\n+            assertEquals(cf.withThreadFactory(threadFactory), cf.withThreadFactory(threadFactory));\n+            assertEquals(cf.withTimeout(timeout), cf.withTimeout(timeout));\n+\n+            assertNotEquals(cf, cf.withName(name));\n+            assertNotEquals(cf, cf.withThreadFactory(threadFactory));\n+            assertNotEquals(cf, cf.withTimeout(timeout));\n+\n+            assertEquals(cf.withName(name).hashCode(), cf.withName(name).hashCode());\n+            assertEquals(cf.withThreadFactory(threadFactory).hashCode(),\n+                    cf.withThreadFactory(threadFactory).hashCode());\n+            assertEquals(cf.withTimeout(timeout).hashCode(), cf.withTimeout(timeout).hashCode());\n+\n+            assertTrue(cf.withName(name).toString().contains(name));\n+            assertTrue(cf.withThreadFactory(threadFactory).toString().contains(threadFactory.toString()));\n+            assertTrue(cf.withTimeout(timeout).toString().contains(timeout.toString()));\n+\n+            return cf;\n+        };\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(), testConfig)) {\n+            \/\/ do nothing\n@@ -1601,4 +1561,60 @@\n-        assertThrows(NullPointerException.class, () -> new StructuredTaskScope(\"\", null));\n-        try (var scope = new StructuredTaskScope<Object>()) {\n-            assertThrows(NullPointerException.class, () -> scope.fork(null));\n-            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(null));\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(null, cf -> cf));\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(Joiner.awaitAll(), null));\n+\n+        assertThrows(NullPointerException.class, () -> Joiner.allUntil(null));\n+\n+        \/\/ fork\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            assertThrows(NullPointerException.class, () -> scope.fork((Callable<Object>) null));\n+            assertThrows(NullPointerException.class, () -> scope.fork((Runnable) null));\n+        }\n+\n+        \/\/ Configuration and withXXX methods\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(Joiner.awaitAll(), cf -> null));\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withName(null)));\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withThreadFactory(null)));\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withTimeout(null)));\n+\n+        \/\/ Joiner.onFork\/onComplete\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.awaitAllSuccessfulOrThrow().onFork(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.awaitAllSuccessfulOrThrow().onComplete(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.awaitAll().onFork(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.awaitAll().onComplete(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.allSuccessfulOrThrow().onFork(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.allSuccessfulOrThrow().onComplete(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.anySuccessfulResultOrThrow().onFork(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.anySuccessfulResultOrThrow().onComplete(null));\n+    }\n+\n+    \/**\n+     * ThreadFactory that counts usage.\n+     *\/\n+    private static class CountingThreadFactory implements ThreadFactory {\n+        final ThreadFactory delegate;\n+        final AtomicInteger threadCount = new AtomicInteger();\n+        CountingThreadFactory(ThreadFactory delegate) {\n+            this.delegate = delegate;\n+        }\n+        @Override\n+        public Thread newThread(Runnable task) {\n+            threadCount.incrementAndGet();\n+            return delegate.newThread(task);\n+        }\n+        int threadCount() {\n+            return threadCount.get();\n@@ -1606,0 +1622,1 @@\n+    }\n@@ -1607,5 +1624,26 @@\n-        assertThrows(NullPointerException.class, () -> new ShutdownOnSuccess<Object>(\"\", null));\n-        try (var scope = new ShutdownOnSuccess<Object>()) {\n-            assertThrows(NullPointerException.class, () -> scope.fork(null));\n-            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n-            assertThrows(NullPointerException.class, () -> scope.result(null));\n+    \/**\n+     * A joiner that counts that counts the number of subtasks that are forked and the\n+     * number of subtasks that complete.\n+     *\/\n+    private static class CountingJoiner<T> implements Joiner<T, Void> {\n+        final AtomicInteger onForkCount = new AtomicInteger();\n+        final AtomicInteger onCompleteCount = new AtomicInteger();\n+        @Override\n+        public boolean onFork(Subtask<? extends T> subtask) {\n+            onForkCount.incrementAndGet();\n+            return false;\n+        }\n+        @Override\n+        public boolean onComplete(Subtask<? extends T> subtask) {\n+            onCompleteCount.incrementAndGet();\n+            return false;\n+        }\n+        @Override\n+        public Void result() {\n+            return null;\n+        }\n+        int onForkCount() {\n+            return onForkCount.get();\n+        }\n+        int onCompleteCount() {\n+            return onCompleteCount.get();\n@@ -1613,0 +1651,1 @@\n+    }\n@@ -1614,5 +1653,26 @@\n-        assertThrows(NullPointerException.class, () -> new ShutdownOnFailure(\"\", null));\n-        try (var scope = new ShutdownOnFailure()) {\n-            assertThrows(NullPointerException.class, () -> scope.fork(null));\n-            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n-            assertThrows(NullPointerException.class, () -> scope.throwIfFailed(null));\n+    \/**\n+     * A joiner that cancels execution when a subtask completes. It also keeps a count\n+     * of the number of subtasks that are forked and the number of subtasks that complete.\n+     *\/\n+    private static class CancelAfterOneJoiner<T> implements Joiner<T, Void> {\n+        final AtomicInteger onForkCount = new AtomicInteger();\n+        final AtomicInteger onCompleteCount = new AtomicInteger();\n+        @Override\n+        public boolean onFork(Subtask<? extends T> subtask) {\n+            onForkCount.incrementAndGet();\n+            return false;\n+        }\n+        @Override\n+        public boolean onComplete(Subtask<? extends T> subtask) {\n+            onCompleteCount.incrementAndGet();\n+            return true;\n+        }\n+        @Override\n+        public Void result() {\n+            return null;\n+        }\n+        int onForkCount() {\n+            return onForkCount.get();\n+        }\n+        int onCompleteCount() {\n+            return onCompleteCount.get();\n@@ -1654,0 +1714,9 @@\n+    \/**\n+     * Wait for the given scope to be cancelled.\n+     *\/\n+    private static void awaitCancelled(StructuredTaskScope<?, ?> scope) throws InterruptedException {\n+        while (!scope.isCancelled()) {\n+            Thread.sleep(Duration.ofMillis(20));\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":952,"deletions":883,"binary":false,"changes":1835,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.concurrent.StructuredTaskScope.Joiner;\n@@ -56,2 +57,1 @@\n-        ThreadFactory factory = Thread.ofVirtual().factory();\n-        try (var scope = new StructuredTaskScope<>(\"scope\", factory)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withName(\"scope\"))) {\n@@ -86,1 +86,2 @@\n-                scope.shutdown();\n+                LockSupport.unpark(thread1);\n+                LockSupport.unpark(thread2);\n@@ -98,2 +99,1 @@\n-        ThreadFactory factory = Thread.ofVirtual().factory();\n-        try (var scope1 = new StructuredTaskScope<>(\"scope-A\", factory)) {\n+        try (var scope1 = StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withName(\"scope-A\"))) {\n@@ -102,1 +102,1 @@\n-            try (var scope2 = new StructuredTaskScope<>(\"scope-B\", factory)) {\n+            try (var scope2 = StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withName(\"scope-B\"))) {\n@@ -130,1 +130,1 @@\n-                    scope2.shutdown();\n+                    LockSupport.unpark(thread2);\n@@ -134,1 +134,1 @@\n-                scope1.shutdown();\n+                LockSupport.unpark(thread1);\n@@ -163,1 +163,1 @@\n-    private static Thread fork(StructuredTaskScope<Object> scope) throws Exception {\n+    private static Thread fork(StructuredTaskScope<Object, Void> scope) throws Exception {\n@@ -181,1 +181,1 @@\n-    private static Thread fork(StructuredTaskScope<Object> scope,\n+    private static Thread fork(StructuredTaskScope<Object, Void> scope,\n@@ -185,2 +185,2 @@\n-            ThreadFactory factory = Thread.ofVirtual().factory();\n-            try (var childScope = new StructuredTaskScope<Object>(childScopeName, factory)) {\n+            try (var childScope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                    cf -> cf.withName(childScopeName))) {\n@@ -190,1 +190,0 @@\n-            return null;\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StructuredThreadDumpTest.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.concurrent.StructuredTaskScope.Joiner;\n@@ -58,1 +59,2 @@\n-            try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                                                      cf -> cf.withThreadFactory(factory))) {\n@@ -77,1 +79,2 @@\n-            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+            try (var scope1 = StructuredTaskScope.open(Joiner.awaitAll(),\n+                                                       cf -> cf.withThreadFactory(factory))) {\n@@ -79,1 +82,2 @@\n-                    try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                    try (var scope2 = StructuredTaskScope.open(Joiner.awaitAll(),\n+                                                               cf -> cf.withThreadFactory(factory))) {\n@@ -102,1 +106,2 @@\n-            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+            try (var scope1 = StructuredTaskScope.open(Joiner.awaitAll(),\n+                                                       cf -> cf.withThreadFactory(factory))) {\n@@ -108,1 +113,2 @@\n-                        try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                        try (var scope2 = StructuredTaskScope.open(Joiner.awaitAll(),\n+                                                                   cf -> cf.withThreadFactory(factory))) {\n@@ -134,1 +140,1 @@\n-            StructuredTaskScope<Object> scope;\n+            StructuredTaskScope<Object, Void> scope;\n@@ -140,1 +146,1 @@\n-                    box.scope = new StructuredTaskScope<Object>();\n+                    box.scope = StructuredTaskScope.open(Joiner.awaitAll());\n@@ -146,1 +152,1 @@\n-            StructuredTaskScope<Object> scope = box.scope;\n+            StructuredTaskScope<Object, Void> scope = box.scope;\n@@ -156,1 +162,1 @@\n-            StructuredTaskScope<Object> scope = box.scope;\n+            StructuredTaskScope<Object, Void> scope = box.scope;\n@@ -169,2 +175,2 @@\n-        try (var scope = new StructuredTaskScope<String>()) {\n-                ScopedValue.where(name, \"x\").run(() -> {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            ScopedValue.where(name, \"x\").run(() -> {\n@@ -182,2 +188,2 @@\n-        try (var scope = new StructuredTaskScope<String>()) {\n-                ScopedValue.where(name, \"x\").run(() -> {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            ScopedValue.where(name, \"x\").run(() -> {\n@@ -200,2 +206,2 @@\n-            try (var scope = new StructuredTaskScope<String>()) {\n-                    ScopedValue.where(name1, \"y\").run(() -> {\n+            try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+                ScopedValue.where(name1, \"y\").run(() -> {\n@@ -210,2 +216,2 @@\n-            try (var scope = new StructuredTaskScope<String>()) {\n-                    ScopedValue.where(name2, \"y\").run(() -> {\n+            try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+                ScopedValue.where(name2, \"y\").run(() -> {\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/WithScopedValue.java","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,2 @@\n-            try (var scope = new StructuredTaskScope<>()) {\n+            var joiner = StructuredTaskScope.Joiner.awaitAll();\n+            try (var scope = StructuredTaskScope.open(joiner)) {\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/CallAsWithScopedValue.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -753,45 +753,0 @@\n-    \/**\n-     * Test wakeup is flock confined.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testWakeupConfined(ThreadFactory factory) throws Exception {\n-        try (var flock = ThreadFlock.open(null)) {\n-            \/\/ thread in flock\n-            testWakeupConfined(flock, task -> {\n-                Thread thread = factory.newThread(task);\n-                return flock.start(thread);\n-            });\n-\n-            \/\/ thread not in flock\n-            testWakeupConfined(flock, task -> {\n-                Thread thread = factory.newThread(task);\n-                thread.start();\n-                return thread;\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test that a thread created with the given factory cannot wakeup the\n-     * given flock.\n-     *\/\n-    private void testWakeupConfined(ThreadFlock flock,\n-                                    Function<Runnable, Thread> factory) throws Exception {\n-        var exception = new AtomicReference<Exception>();\n-        Thread thread = factory.apply(() -> {\n-            try {\n-                flock.wakeup();\n-            } catch (Exception e) {\n-                exception.set(e);\n-            }\n-        });\n-        thread.join();\n-        Throwable cause = exception.get();\n-        if (flock.containsThread(thread)) {\n-            assertNull(cause);\n-        } else {\n-            assertTrue(cause instanceof WrongThreadException);\n-        }\n-    }\n-\n@@ -936,53 +891,0 @@\n-    \/**\n-     * Test shutdown is confined to threads in the flock.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testShutdownConfined(ThreadFactory factory) throws Exception {\n-        try (var flock = ThreadFlock.open(null)) {\n-            \/\/ thread in flock\n-            testShutdownConfined(flock, task -> {\n-                Thread thread = factory.newThread(task);\n-                return flock.start(thread);\n-            });\n-\n-            \/\/ thread in flock\n-            try (var flock2 = ThreadFlock.open(null)) {\n-                testShutdownConfined(flock, task -> {\n-                    Thread thread = factory.newThread(task);\n-                    return flock2.start(thread);\n-                });\n-            }\n-\n-            \/\/ thread not contained in flock\n-            testShutdownConfined(flock, task -> {\n-                Thread thread = factory.newThread(task);\n-                thread.start();\n-                return thread;\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test that a thread created with the given factory cannot shut down the\n-     * given flock.\n-     *\/\n-    private void testShutdownConfined(ThreadFlock flock,\n-                                      Function<Runnable, Thread> factory) throws Exception {\n-        var exception = new AtomicReference<Exception>();\n-        Thread thread = factory.apply(() -> {\n-            try {\n-                flock.shutdown();\n-            } catch (Exception e) {\n-                exception.set(e);\n-            }\n-        });\n-        thread.join();\n-        Throwable cause = exception.get();\n-        if (flock.containsThread(thread)) {\n-            assertNull(cause);\n-        } else {\n-            assertTrue(cause instanceof WrongThreadException);\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/ThreadFlockTest.java","additions":1,"deletions":99,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8356087\n+ * @summary Ensure P11Mac using SHA message digests can be initialized with\n+ *     secret keys with unrecognized algorithms\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm InitMacWithAnyKey\n+ *\/\n+\n+import java.security.Provider;\n+import java.util.List;\n+import javax.crypto.Mac;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class InitMacWithAnyKey extends PKCS11Test {\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new InitMacWithAnyKey(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        SecretKey skey = new SecretKeySpec(\"whatever\".getBytes(), \"Any\");\n+        \/\/ Test against Hmacs using SHA-1, SHA-2 message digests and skip\n+        \/\/ PBE-related Hmacs as they need PBEKey\n+        List<String> algorithms = getSupportedAlgorithms(\"Mac\", \"HmacSHA\", p);\n+        for (String algo : algorithms) {\n+            System.out.println(\"Testing \" + algo);\n+            Mac mac = Mac.getInstance(algo, p);\n+            try {\n+                mac.init(skey);\n+            } catch (Exception e) {\n+                throw new Exception(\"Unexpected exception\", e);\n+            }\n+        }\n+        System.out.println(\"Passed\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Mac\/InitMacWithAnyKey.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -1283,1 +1283,1 @@\n-    private static final Path OPENSSL = Path.of(Optional.ofNullable(TKit.getConfigProperty(\"openssl\")).orElse(\"openssl\"));\n+    private static final Path OPENSSL = Path.of(Optional.ofNullable(TKit.getConfigProperty(\"openssl\")).orElse(\"\/usr\/local\/bin\/openssl\"));\n@@ -1287,1 +1287,1 @@\n-    private static final Path FAKETIME = Path.of(Optional.ofNullable(TKit.getConfigProperty(\"faketime\")).orElse(\"faketime\"));\n+    private static final Path FAKETIME = Path.of(Optional.ofNullable(TKit.getConfigProperty(\"faketime\")).orElse(\"\/usr\/local\/bin\/faketime\"));\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSign.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8194743\n+ * @bug 8194743 8345438 8356551\n@@ -456,1 +456,1 @@\n-    \/\/ Lambdas within constructors\n+    \/\/ Lambdas within constructors (JDK-8345438)\n@@ -492,0 +492,12 @@\n+    \/\/ Receiver parameter syntax (JDK-8356551)\n+    public static class Test23 {\n+        public Test23() {\n+            class Local {\n+                Local(Test23 Test23.this) {\n+                }\n+            }\n+            super();\n+            new Local();\n+        }\n+    }\n+\n@@ -537,0 +549,1 @@\n+        new Test23();\n","filename":"test\/langtools\/tools\/javac\/SuperInit\/SuperInitGood.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.illegal.char.literal.multiple.surrogates\n+\n+class IllegalCharLiteralMultipleSurrogates {\n+    char c = '\\uD83D\\uDE0A';\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/IllegalCharLiteralMultipleSurrogates.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -35,0 +37,1 @@\n+import javax.tools.DiagnosticListener;\n@@ -104,0 +107,2 @@\n+            new TestTuple(ERROR,         \"'\\uD83D\\uDE0A'\",\n+                          List.of(\"compiler.err.illegal.char.literal.multiple.surrogates\")),\n@@ -110,0 +115,1 @@\n+        List<String> expectedErrors;\n@@ -111,1 +117,1 @@\n-        TestTuple(TokenKind kind, String input, String expected) {\n+        TestTuple(TokenKind kind, String input, String expected, List<String> expectedErrors) {\n@@ -115,0 +121,9 @@\n+            this.expectedErrors = expectedErrors;\n+        }\n+\n+        TestTuple(TokenKind kind, String input, List<String> expectedErrors) {\n+            this(kind, input, input, expectedErrors);\n+        }\n+\n+        TestTuple(TokenKind kind, String input, String expected) {\n+            this(kind, input, expected, null);\n@@ -124,0 +139,6 @@\n+        List<String> errors = new ArrayList();\n+\n+        if (test.expectedErrors != null) {\n+            ctx.put(DiagnosticListener.class, (DiagnosticListener) d -> errors.add(d.getCode()));\n+        }\n+\n@@ -152,0 +173,4 @@\n+\n+        if (test.expectedErrors != null && !test.expectedErrors.equals(errors)) {\n+            throw new AssertionError(\"Unexpected errors: \" + errors);\n+        }\n","filename":"test\/langtools\/tools\/javac\/lexer\/JavaLexerTest.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8356057\n+ * @summary Verify annotated supertypes and type variable bounds are printed properly\n+ * @compile\/ref=XprintTypeAnnotationsAndTypeVarBounds.out -Xprint  XprintTypeAnnotationsAndTypeVarBounds.java\n+ *\/\n+\n+import java.lang.annotation.*;\n+\n+class AnnotatedObjectSuperType extends @TA Object {\n+}\n+\n+class UnannotatedObjectSuperType extends Object {\n+}\n+\n+class TypeVariableWithAnnotation1<@TA T> {\n+}\n+\n+class TypeVariableWithAnnotation2<@TA T extends Object> {\n+}\n+\n+class TypeVariableWithBound1<T extends @TA Object> {\n+}\n+\n+class TypeVariableWithBound2<T extends @TA CharSequence> {\n+}\n+\n+class TypeVariableWithBound3<T extends @TA Object & CharSequence> {\n+}\n+\n+class TypeVariableWithBound4<T extends Object & @TA CharSequence> {\n+}\n+\n+class TypeVariableWithBound5<T extends CharSequence> {\n+}\n+\n+class TypeVariableWithBound6<T extends Object & CharSequence> {\n+}\n+\n+class TypeVariableWithBoundRecursive<T extends TypeVariableWithBoundRecursive<T>> {\n+}\n+\n+class TypeVariableBoundsOnMethods {\n+    public <@TA T> void test1() {}\n+    public <@TA T extends Object> void test2() {}\n+    public <T extends @TA Object> void test3() {}\n+    public <T extends @TA CharSequence> void test4() {}\n+    public <T extends @TA Object & CharSequence> void test5() {}\n+    public <T extends Object & @TA CharSequence> void test6() {}\n+    public <T extends CharSequence> void test7() {}\n+    public <T extends Object & CharSequence> void test8() {}\n+}\n+\n+class TypeVariableBoundsOnConstructors {\n+    public <@TA T> TypeVariableBoundsOnConstructors(boolean b) {}\n+    public <@TA T extends Object> TypeVariableBoundsOnConstructors(byte b) {}\n+    public <T extends @TA Object> TypeVariableBoundsOnConstructors(char c) {}\n+    public <T extends @TA CharSequence> TypeVariableBoundsOnConstructors(short s) {}\n+    public <T extends @TA Object & CharSequence> TypeVariableBoundsOnConstructors(int i) {}\n+    public <T extends Object & @TA CharSequence> TypeVariableBoundsOnConstructors(long l) {}\n+    public <T extends CharSequence> TypeVariableBoundsOnConstructors(float f) {}\n+    public <T extends Object & CharSequence> TypeVariableBoundsOnConstructors(double d) {}\n+}\n+\n+@Target(ElementType.TYPE_USE)\n+@interface TA {\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/options\/XprintTypeAnnotationsAndTypeVarBounds.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\n+class AnnotatedObjectSuperType extends java.lang.@TA Object {\n+\n+  AnnotatedObjectSuperType();\n+}\n+\n+class UnannotatedObjectSuperType {\n+\n+  UnannotatedObjectSuperType();\n+}\n+\n+class TypeVariableWithAnnotation1<@TA T> {\n+\n+  TypeVariableWithAnnotation1();\n+}\n+\n+class TypeVariableWithAnnotation2<@TA T> {\n+\n+  TypeVariableWithAnnotation2();\n+}\n+\n+class TypeVariableWithBound1<T extends java.lang.@TA Object> {\n+\n+  TypeVariableWithBound1();\n+}\n+\n+class TypeVariableWithBound2<T extends java.lang.@TA CharSequence> {\n+\n+  TypeVariableWithBound2();\n+}\n+\n+class TypeVariableWithBound3<T extends java.lang.@TA Object & java.lang.CharSequence> {\n+\n+  TypeVariableWithBound3();\n+}\n+\n+class TypeVariableWithBound4<T extends java.lang.@TA CharSequence> {\n+\n+  TypeVariableWithBound4();\n+}\n+\n+class TypeVariableWithBound5<T extends java.lang.CharSequence> {\n+\n+  TypeVariableWithBound5();\n+}\n+\n+class TypeVariableWithBound6<T extends java.lang.CharSequence> {\n+\n+  TypeVariableWithBound6();\n+}\n+\n+class TypeVariableWithBoundRecursive<T extends TypeVariableWithBoundRecursive<T>> {\n+\n+  TypeVariableWithBoundRecursive();\n+}\n+\n+class TypeVariableBoundsOnMethods {\n+\n+  TypeVariableBoundsOnMethods();\n+\n+  public <@TA T> void test1();\n+\n+  public <@TA T> void test2();\n+\n+  public <T extends java.lang.@TA Object> void test3();\n+\n+  public <T extends java.lang.@TA CharSequence> void test4();\n+\n+  public <T extends java.lang.@TA Object & java.lang.CharSequence> void test5();\n+\n+  public <T extends java.lang.@TA CharSequence> void test6();\n+\n+  public <T extends java.lang.CharSequence> void test7();\n+\n+  public <T extends java.lang.CharSequence> void test8();\n+}\n+\n+class TypeVariableBoundsOnConstructors {\n+\n+  public <@TA T> TypeVariableBoundsOnConstructors(boolean b);\n+\n+  public <@TA T> TypeVariableBoundsOnConstructors(byte b);\n+\n+  public <T extends java.lang.@TA Object> TypeVariableBoundsOnConstructors(char c);\n+\n+  public <T extends java.lang.@TA CharSequence> TypeVariableBoundsOnConstructors(short s);\n+\n+  public <T extends java.lang.@TA Object & java.lang.CharSequence> TypeVariableBoundsOnConstructors(int i);\n+\n+  public <T extends java.lang.@TA CharSequence> TypeVariableBoundsOnConstructors(long l);\n+\n+  public <T extends java.lang.CharSequence> TypeVariableBoundsOnConstructors(float f);\n+\n+  public <T extends java.lang.CharSequence> TypeVariableBoundsOnConstructors(double d);\n+}\n+\n+@java.lang.annotation.Target({TYPE_USE})\n+@interface TA {\n+}\n\\ No newline at end of file\n","filename":"test\/langtools\/tools\/javac\/processing\/options\/XprintTypeAnnotationsAndTypeVarBounds.out","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -5,1 +5,1 @@\n-public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n+public class GeneratedSource<T extends java.lang.CharSequence> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n@@ -15,1 +15,1 @@\n-public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n+public class GeneratedClass<T extends java.lang.CharSequence> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n@@ -26,1 +26,1 @@\n-public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n+public class GeneratedSource<T extends java.lang.CharSequence> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n@@ -36,1 +36,1 @@\n-public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n+public class GeneratedClass<T extends java.lang.CharSequence> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n","filename":"test\/langtools\/tools\/javac\/processing\/rounds\/OverwriteBetweenCompilations_1.out","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n+public class GeneratedSource<T extends java.lang.CharSequence> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n@@ -14,1 +14,1 @@\n-public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n+public class GeneratedClass<T extends java.lang.CharSequence> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n@@ -25,1 +25,1 @@\n-public abstract class GeneratedSource<E> extends java.util.LinkedList<java.lang.Number> implements java.lang.Runnable, java.lang.CharSequence {\n+public abstract class GeneratedSource<E extends java.lang.Number> extends java.util.LinkedList<java.lang.Number> implements java.lang.Runnable, java.lang.CharSequence {\n@@ -33,1 +33,1 @@\n-public abstract class GeneratedClass<E> extends java.util.LinkedList<java.lang.Number> implements java.lang.Runnable, java.lang.CharSequence {\n+public abstract class GeneratedClass<E extends java.lang.Number> extends java.util.LinkedList<java.lang.Number> implements java.lang.Runnable, java.lang.CharSequence {\n@@ -42,1 +42,1 @@\n-public abstract class GeneratedSource<E> extends java.util.LinkedList<java.lang.Number> implements java.lang.Runnable, java.lang.CharSequence {\n+public abstract class GeneratedSource<E extends java.lang.Number> extends java.util.LinkedList<java.lang.Number> implements java.lang.Runnable, java.lang.CharSequence {\n@@ -50,1 +50,1 @@\n-public abstract class GeneratedClass<E> extends java.util.LinkedList<java.lang.Number> implements java.lang.Runnable, java.lang.CharSequence {\n+public abstract class GeneratedClass<E extends java.lang.Number> extends java.util.LinkedList<java.lang.Number> implements java.lang.Runnable, java.lang.CharSequence {\n","filename":"test\/langtools\/tools\/javac\/processing\/rounds\/OverwriteBetweenCompilations_2.out","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-public abstract class GeneratedSource<E> extends java.util.LinkedList<java.lang.Number> implements java.lang.Runnable, java.lang.CharSequence {\n+public abstract class GeneratedSource<E extends java.lang.Number> extends java.util.LinkedList<java.lang.Number> implements java.lang.Runnable, java.lang.CharSequence {\n@@ -12,1 +12,1 @@\n-public abstract class GeneratedClass<E> extends java.util.LinkedList<java.lang.Number> implements java.lang.Runnable, java.lang.CharSequence {\n+public abstract class GeneratedClass<E extends java.lang.Number> extends java.util.LinkedList<java.lang.Number> implements java.lang.Runnable, java.lang.CharSequence {\n@@ -21,1 +21,1 @@\n-public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n+public class GeneratedSource<T extends java.lang.CharSequence> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n@@ -31,1 +31,1 @@\n-public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n+public class GeneratedClass<T extends java.lang.CharSequence> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n@@ -42,1 +42,1 @@\n-public class GeneratedSource<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n+public class GeneratedSource<T extends java.lang.CharSequence> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n@@ -52,1 +52,1 @@\n-public class GeneratedClass<T> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n+public class GeneratedClass<T extends java.lang.CharSequence> extends java.util.ArrayList<java.lang.String> implements java.lang.Runnable {\n","filename":"test\/langtools\/tools\/javac\/processing\/rounds\/OverwriteBetweenCompilations_3.out","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,1 +68,2 @@\n-    private static MethodHandle mh = identityHandle();\n+\n+    private static \/* intentionally not final *\/ MethodHandle mh = identityHandle();\n@@ -115,8 +116,0 @@\n-    Object cp() {\n-        CodeBuilder cob = null;\n-        ConstantPoolBuilder cp = ConstantPoolBuilder.of();\n-        cob.ldc(cp.constantDynamicEntry(cp.bsmEntry(cp.methodHandleEntry(BSM_CLASS_DATA), List.of()),\n-                cp.nameAndTypeEntry(DEFAULT_NAME, CD_MethodHandle)));\n-        return null;\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/stable\/StableMethodHandleBenchmark.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-import java.nio.file.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -32,1 +33,0 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n@@ -52,8 +52,0 @@\n-    private SocketChannel s1, s2;\n-\n-    private static volatile String tempDir;\n-    private static final AtomicInteger count = new AtomicInteger(0);\n-    private volatile Path socket;\n-\n-    @Param({\"inet\", \"unix\"})\n-    private volatile String family;\n@@ -61,8 +53,1 @@\n-    static {\n-        try {\n-            Path p = Files.createTempDirectory(\"readWriteTest\");\n-            tempDir = p.toString();\n-        } catch (IOException e) {\n-            tempDir = null;\n-        }\n-    }\n+    private Path sscFilePath;\n@@ -70,12 +55,1 @@\n-    private ServerSocketChannel getServerSocketChannel() throws IOException {\n-        if (family.equals(\"inet\"))\n-            return getInetServerSocketChannel();\n-        else if (family.equals(\"unix\"))\n-            return getUnixServerSocketChannel();\n-        throw new InternalError();\n-    }\n-\n-\n-    private ServerSocketChannel getInetServerSocketChannel() throws IOException {\n-        return ServerSocketChannel.open().bind(null);\n-    }\n+    private SocketChannel s1, s2;\n@@ -83,6 +57,2 @@\n-    private ServerSocketChannel getUnixServerSocketChannel() throws IOException {\n-        int next = count.incrementAndGet();\n-        socket = Paths.get(tempDir, Integer.toString(next));\n-        UnixDomainSocketAddress addr = UnixDomainSocketAddress.of(socket);\n-        return ServerSocketChannel.open(StandardProtocolFamily.UNIX).bind(addr);\n-    }\n+    @Param({\"INET\", \"UNIX\"})\n+    private String family;\n@@ -92,1 +62,8 @@\n-        ssc = getServerSocketChannel();\n+        StandardProtocolFamily typedFamily = StandardProtocolFamily.valueOf(family);\n+        ssc = ServerSocketChannel.open(typedFamily).bind(null);\n+        \/\/ Record the UDS file path right after binding, as the socket may be\n+        \/\/ closed later due to a failure, and subsequent calls to `getPath()`\n+        \/\/ will throw.\n+        sscFilePath = ssc.getLocalAddress() instanceof UnixDomainSocketAddress udsChannel\n+                ? udsChannel.getPath()\n+                : null;\n@@ -96,1 +73,1 @@\n-    public void afterRun() throws IOException {\n+    public void afterRun() throws Exception {\n@@ -98,3 +75,2 @@\n-        if (family.equals(\"unix\")) {\n-            Files.deleteIfExists(socket);\n-            Files.deleteIfExists(Path.of(tempDir));\n+        if (sscFilePath != null) {\n+            Files.delete(sscFilePath);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/SocketChannelConnectionSetup.java","additions":17,"deletions":41,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+    private Path sscFilePath;\n@@ -54,10 +55,0 @@\n-    private volatile Path socket;\n-\n-    private ServerSocketChannel getServerSocketChannel() throws IOException {\n-        socket = Files.createTempDirectory(UnixSocketChannelReadWrite.class.getSimpleName()).resolve(\"sock\");\n-        UnixDomainSocketAddress addr = UnixDomainSocketAddress.of(socket);\n-        ServerSocketChannel c = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n-        c.bind(addr);\n-        return c;\n-    }\n-\n@@ -66,1 +57,5 @@\n-        ssc = getServerSocketChannel();\n+        ssc = ServerSocketChannel.open(StandardProtocolFamily.UNIX).bind(null);\n+        \/\/ Record the UDS file path right after binding, as the socket may be\n+        \/\/ closed later due to a failure, and subsequent calls to `getPath()`\n+        \/\/ will throw.\n+        sscFilePath = ((UnixDomainSocketAddress) ssc.getLocalAddress()).getPath();\n@@ -82,2 +77,1 @@\n-        Files.delete(socket);\n-        Files.delete(socket.getParent());\n+        Files.delete(sscFilePath);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/UnixSocketChannelReadWrite.java","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"}]}