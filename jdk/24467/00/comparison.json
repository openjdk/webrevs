{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+import java.time.Duration;\n@@ -236,2 +237,2 @@\n-        long latest = System.currentTimeMillis() + delay * 1000;\n-        while (System.currentTimeMillis() < latest) {\n+        long latest = System.nanoTime() + Duration.ofSeconds(delay).toNanos();\n+        while (activeExchanges() > 0 && System.nanoTime() < latest) {\n@@ -239,3 +240,0 @@\n-            if (finished) {\n-                break;\n-            }\n@@ -259,0 +257,1 @@\n+                dispatcherThread.interrupt();\n@@ -937,0 +936,4 @@\n+    synchronized int activeExchanges () {\n+        return exchangeCount;\n+    }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/**\n+ * @test\n+ * @bug 8304065\n+ * @summary HttpServer.stop() should terminate immediately if no exchanges are in progress\n+ * @run junit ServerStopTermination\n+ *\/\n+\n+public class ServerStopTermination {\n+\n+    \/\/ The server instance used to test shutdown timing\n+    private HttpServer server;\n+    \/\/ Client for initiating exchanges\n+    private HttpClient client;\n+    \/\/ Allows test to await the start of the exchange\n+    private CountDownLatch start = new CountDownLatch(1);\n+    \/\/ Allows test to signal when exchange should complete\n+    private CountDownLatch complete = new CountDownLatch(1);\n+\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        \/\/ Create an HttpServer binding to the loopback address with an ephemeral port\n+        server = HttpServer.create();\n+        InetAddress loopbackAddress = InetAddress.getLoopbackAddress();\n+        server.bind(new InetSocketAddress(loopbackAddress, 0), 0);\n+\n+        \/\/ A handler with completion timing controlled by tests\n+        server.createContext(\"\/\", new HttpHandler() {\n+            @Override\n+            public void handle(HttpExchange exchange) throws IOException {\n+                \/\/ Let the test know the exchange is started\n+                start.countDown();\n+                try {\n+                    \/\/ Wait for test to signal that we can complete the exchange\n+                    complete.await();\n+                    exchange.sendResponseHeaders(200, 0);\n+                    exchange.close();\n+                } catch (InterruptedException e) {\n+                    throw new IOException(e);\n+                }\n+            }\n+        });\n+\n+        \/\/ Start server and client\n+        server.start();\n+        client = HttpClient.newHttpClient();\n+    }\n+\n+    \/**\n+     * Clean up resources used by this test\n+     *\/\n+    @AfterEach\n+    public void cleanup() {\n+        client.shutdown();\n+    }\n+\n+    \/**\n+     * Verify that a stop operation with a 1 second exchange and a 2 second delay\n+     * completes when the exchange completes.\n+     *\n+     * @throws InterruptedException if an unexpected interruption occurs\n+     *\/\n+    @Test\n+    public void shouldAwaitActiveExchange() throws InterruptedException {\n+        \/\/ Initiate an exchange\n+        startExchange();\n+        \/\/ Wait for the server to receive the exchange\n+        start.await();\n+\n+        \/\/ Complete the exchange one second into the future\n+        Duration exchangeDuration = Duration.ofSeconds(1);\n+        completeExchange(exchangeDuration);\n+\n+        \/\/ Time the shutdown sequence\n+        Duration delayDuration = Duration.ofSeconds(2);\n+        long elapsed = timeShutdown(delayDuration);\n+\n+        \/\/ The shutdown should take at least as long as the exchange duration\n+        if (elapsed < exchangeDuration.toNanos()) {\n+            fail(\"HttpServer.stop terminated before exchange completed\");\n+        }\n+\n+        \/\/ The delay should not have expired\n+        if (elapsed >= delayDuration.toNanos()) {\n+            fail(\"HttpServer.stop terminated after delay expired\");\n+        }\n+    }\n+\n+    \/**\n+     * Verify that a stop operation with a 1 second delay and a 2 second exchange\n+     * completes after the delay expires.\n+     *\n+     * @throws InterruptedException if an unexpected interruption occurs\n+     *\/\n+    @Test\n+    public void shouldCompeteAfterDelay() throws InterruptedException {\n+        \/\/ Initiate an exchange\n+        startExchange();\n+        \/\/ Wait for the server to receive the exchange\n+        start.await();\n+\n+        \/\/ Complete the exchange two second into the future\n+        Duration exchangeDuration = Duration.ofSeconds(10);\n+        completeExchange(exchangeDuration);\n+\n+        \/\/ Time the shutdown sequence\n+        Duration delayDuration = Duration.ofSeconds(1);\n+        long elapsed = timeShutdown(delayDuration);\n+\n+        \/\/ The shutdown should not await the exchange to complete\n+        if (elapsed >= exchangeDuration.toNanos()) {\n+            fail(\"HttpServer.stop terminated too late\");\n+        }\n+\n+        \/\/ The shutdown delay should have expired\n+        if (elapsed < delayDuration.toNanos()) {\n+            fail(\"HttpServer.stop terminated before delay\");\n+        }\n+    }\n+\n+    \/**\n+     * Verify that an HttpServer with no active exchanges terminates\n+     * before the delay timeout occurs.\n+     *\/\n+    @Test\n+    public void noActiveExchanges() {\n+        \/\/ With no active exchanges, shutdown should complete immediately\n+        Duration delayDuration = Duration.ofSeconds(2);\n+        long elapsed = timeShutdown(delayDuration);\n+        if (elapsed >= delayDuration.toNanos()) {\n+            fail(\"Expected HttpServer.stop to terminate immediately with no active exchanges\");\n+        }\n+    }\n+\n+    \/**\n+     * Verify that an already stopped HttpServer can be stopped\n+     *\/\n+    @Test\n+    public void shouldAllowRepeatedStop() {\n+        Duration delayDuration = Duration.ofSeconds(1);\n+        long elapsed = timeShutdown(delayDuration);\n+        long elapsed2 = timeShutdown(delayDuration);\n+    }\n+\n+    \/**\n+     * Run HttpServer::stop with the given delay, returning the\n+     * elapsed time in nanoseconds for the shutdown to complete\n+     *\/\n+    private long timeShutdown(Duration delayDuration) {\n+        long before = System.nanoTime();\n+        server.stop((int) delayDuration.toSeconds());\n+        long elapsed = System.nanoTime() - before;\n+        return elapsed;\n+    }\n+\n+    \/**\n+     * Initiate an exchange asynchronously\n+     *\/\n+    private void startExchange() {\n+        HttpRequest request = HttpRequest.newBuilder()\n+                .uri(URI.create(\"http:\/\/\" + server.getAddress().getAddress().getHostAddress() +\":\" + server.getAddress().getPort() + \"\/\"))\n+                .GET()\n+                .build();\n+        client.sendAsync(request, HttpResponse.BodyHandlers.ofString());\n+    }\n+\n+    \/**\n+     * At the specified time into the future, signal to the\n+     * handler that the exchange can complete.\n+     *\n+     * @param exchangeDuration the duration to wait before signaling completion\n+     *\/\n+    private void completeExchange(Duration exchangeDuration) {\n+        Thread.ofVirtual().start(() -> {\n+            try {\n+                Thread.sleep(exchangeDuration);\n+                complete.countDown();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/ServerStopTermination.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"}]}