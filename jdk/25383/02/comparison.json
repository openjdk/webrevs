{"files":[{"patch":"@@ -54,2 +54,1 @@\n-    \/\/ All the threshold values below MUST be a power of two and should preferably be\n-    \/\/ greater or equal to 2^3.\n+    \/\/ All the threshold values below MUST be a power of two and greater or equal to 2^3.\n@@ -60,0 +59,18 @@\n+    \/**\n+     * Fills the provided {@code dst} segment with the provided {@code value}.\n+     * <p>\n+     * This implementation relies on a scheme where operations with as large units of\n+     * memory as possible are used and where the cleanup of the remaining \"tail\" is\n+     * made by applying the same large operation but skewed so it will precisely fill the\n+     * remaining tail.\n+     * Said tail scheme is simpler and faster than trying to apply a combination of\n+     * operations with different units of memory to clean up the tail.\n+     * <p>\n+     * This method is using Java for segments that are smaller than the configurable\n+     * {@code NATIVE_THRESHOLD_FILL} meaning it does not have to pay the price for\n+     * transitioning to native code.\n+     *\n+     * @param dst   segment to fill\n+     * @param value to fill the segment with\n+     * @return the provided {@code dst} segment\n+     *\/\n@@ -63,5 +80,5 @@\n-        if (dst.length == 0) {\n-            \/\/ Implicit state check\n-            dst.sessionImpl().checkValidState();\n-        } else if (dst.length < NATIVE_THRESHOLD_FILL) {\n-            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+        final long len = dst.length;\n+        \/* The multiplication below is equivalent to:\n+             long u = Byte.toUnsignedLong(value);\n+             long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u; *\/\n+        final long longValue = 0x01010101_01010101L * Byte.toUnsignedLong(value);\n@@ -69,3 +86,11 @@\n-            \/\/ Handle smaller segments directly without transitioning to native code\n-            final long u = Byte.toUnsignedLong(value);\n-            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+        \/\/ Switch on log2(len) = 64 - Long.numberOfLeadingZeros(len)\n+        switch (64 - Long.numberOfLeadingZeros(len)) {\n+            case 0 -> dst.sessionImpl().checkValidState(); \/\/ Implicit state check\n+            case 1 -> SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), value);\n+            case 2 -> fill2(dst, len, (short) longValue);\n+            case 3 -> fill3(dst, len, (int) longValue);\n+            case 4 -> fill4(dst, len, longValue);\n+            default -> fill5AndUpwards(dst, len, longValue);\n+        }\n+        return dst;\n+    }\n@@ -73,22 +98,24 @@\n-            int offset = 0;\n-            \/\/ 0...0X...X000\n-            final int limit = (int) (dst.length & (NATIVE_THRESHOLD_FILL - 8));\n-            for (; offset < limit; offset += Long.BYTES) {\n-                SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, longValue, !Architecture.isLittleEndian());\n-            }\n-            int remaining = (int) dst.length - limit;\n-            \/\/ 0...0X00\n-            if (remaining >= Integer.BYTES) {\n-                SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (int) longValue, !Architecture.isLittleEndian());\n-                offset += Integer.BYTES;\n-                remaining -= Integer.BYTES;\n-            }\n-            \/\/ 0...00X0\n-            if (remaining >= Short.BYTES) {\n-                SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (short) longValue, !Architecture.isLittleEndian());\n-                offset += Short.BYTES;\n-                remaining -= Short.BYTES;\n-            }\n-            \/\/ 0...000X\n-            if (remaining == 1) {\n-                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, value);\n+    @ForceInline\n+    private static void fill2(AbstractMemorySegmentImpl dst, long len, short value) {\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), value, !Architecture.isLittleEndian());\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Short.BYTES, value, !Architecture.isLittleEndian());\n+    }\n+\n+    @ForceInline\n+    private static void fill3(AbstractMemorySegmentImpl dst, long len, int value) {\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), value, !Architecture.isLittleEndian());\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Integer.BYTES, value, !Architecture.isLittleEndian());\n+    }\n+\n+    @ForceInline\n+    private static void fill4(AbstractMemorySegmentImpl dst, long len, long value) {\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), value, !Architecture.isLittleEndian());\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Long.BYTES, value, !Architecture.isLittleEndian());\n+    }\n+\n+    @ForceInline\n+    private static void fill5AndUpwards(AbstractMemorySegmentImpl dst, long len, long value) {\n+        if (len < NATIVE_THRESHOLD_FILL) {\n+            final int limit = (int) (len & (NATIVE_THRESHOLD_FILL - 8));\n+            for (int offset = 0; offset < limit; offset += Long.BYTES) {\n+                SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, value, !Architecture.isLittleEndian());\n@@ -96,1 +123,1 @@\n-            \/\/ We have now fully handled 0...0X...XXXX\n+            SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Long.BYTES, value, !Architecture.isLittleEndian());\n@@ -99,1 +126,1 @@\n-            SCOPED_MEMORY_ACCESS.setMemory(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), dst.length, value);\n+            SCOPED_MEMORY_ACCESS.setMemory(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), len, (byte) value);\n@@ -101,1 +128,0 @@\n-        return dst;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":61,"deletions":35,"binary":false,"changes":96,"status":"modified"}]}