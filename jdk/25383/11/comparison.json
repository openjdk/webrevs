{"files":[{"patch":"@@ -209,1 +209,2 @@\n-        return SegmentBulkOperations.fill(this, value);\n+        SegmentBulkOperations.fill(this, value);\n+        return this;\n@@ -348,1 +349,1 @@\n-    public void checkReadOnly(boolean readOnly) {\n+    public final void checkReadOnly(boolean readOnly) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-    public void checkValidStateRaw() {\n+    public final void checkValidStateRaw() {\n@@ -213,1 +213,1 @@\n-    public void checkValidState() {\n+    public final void checkValidState() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,3 +54,2 @@\n-    \/\/ All the threshold values below MUST be a power of two and should preferably be\n-    \/\/ greater or equal to 2^3.\n-    private static final int NATIVE_THRESHOLD_FILL = powerOfPropertyOr(\"fill\", 5);\n+    \/\/ All the threshold values below MUST be a power of two and greater or equal to 2^3.\n+    private static final int NATIVE_THRESHOLD_FILL = powerOfPropertyOr(\"fill\", 6);\n@@ -60,0 +59,17 @@\n+    \/**\n+     * Fills the provided {@code dst} segment with the provided {@code value}.\n+     * <p>\n+     * This implementation relies on a scheme where operations with as large units of\n+     * memory as possible are used and where the cleanup of the remaining \"tail\" is\n+     * made by applying the same large operation but skewed so it will precisely fill the\n+     * remaining tail.\n+     * Said tail scheme is simpler and faster than trying to apply a combination of\n+     * operations with different units of memory to clean up the tail.\n+     * <p>\n+     * This method is using Java for segments that are smaller than the configurable\n+     * {@code NATIVE_THRESHOLD_FILL} meaning it does not have to pay the price for\n+     * transitioning to native code.\n+     *\n+     * @param dst   segment to fill\n+     * @param value to fill the segment with\n+     *\/\n@@ -61,7 +77,7 @@\n-    public static MemorySegment fill(AbstractMemorySegmentImpl dst, byte value) {\n-        dst.checkReadOnly(false);\n-        if (dst.length == 0) {\n-            \/\/ Implicit state check\n-            dst.sessionImpl().checkValidState();\n-        } else if (dst.length < NATIVE_THRESHOLD_FILL) {\n-            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+    public static void fill(AbstractMemorySegmentImpl dst, byte value) {\n+        dst.checkReadOnly(true);\n+        final long len = dst.length;\n+        \/* The multiplication below is equivalent to (but faster than):\n+             long u = Byte.toUnsignedLong(value);\n+             long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u; *\/\n+        final long longValue = 0x01010101_01010101L * Byte.toUnsignedLong(value);\n@@ -69,3 +85,10 @@\n-            \/\/ Handle smaller segments directly without transitioning to native code\n-            final long u = Byte.toUnsignedLong(value);\n-            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+        \/\/ Switch on log2(len) = 64 - Long.numberOfLeadingZeros(len)\n+        switch (64 - Long.numberOfLeadingZeros(len)) {\n+            case 0 -> dst.sessionImpl().checkValidState(); \/\/ Explicit state check\n+            case 1 -> SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), value);\n+            case 2 -> fill2(dst, len, (short) longValue);\n+            case 3 -> fill3(dst, len, (int) longValue);\n+            case 4 -> fill4(dst, len, longValue);\n+            default -> fill5AndUpwards(dst, len, longValue);\n+        }\n+    }\n@@ -73,22 +96,37 @@\n-            int offset = 0;\n-            \/\/ 0...0X...X000\n-            final int limit = (int) (dst.length & (NATIVE_THRESHOLD_FILL - 8));\n-            for (; offset < limit; offset += Long.BYTES) {\n-                SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, longValue, !Architecture.isLittleEndian());\n-            }\n-            int remaining = (int) dst.length - limit;\n-            \/\/ 0...0X00\n-            if (remaining >= Integer.BYTES) {\n-                SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (int) longValue, !Architecture.isLittleEndian());\n-                offset += Integer.BYTES;\n-                remaining -= Integer.BYTES;\n-            }\n-            \/\/ 0...00X0\n-            if (remaining >= Short.BYTES) {\n-                SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (short) longValue, !Architecture.isLittleEndian());\n-                offset += Short.BYTES;\n-                remaining -= Short.BYTES;\n-            }\n-            \/\/ 0...000X\n-            if (remaining == 1) {\n-                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, value);\n+    \/** This case covers [2, 3] bytes *\/\n+    @ForceInline\n+    private static void fill2(AbstractMemorySegmentImpl dst, long len, short value) {\n+        final MemorySessionImpl sessionImpl = dst.sessionImpl();\n+        final long offset = dst.unsafeGetOffset();\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(sessionImpl, dst.unsafeGetBase(), offset, value);\n+        \/\/ `putByte()` below is enough as 3 is the maximum number of bytes covered\n+        SCOPED_MEMORY_ACCESS.putByte(sessionImpl, dst.unsafeGetBase(), offset + len - Byte.BYTES, (byte) value);\n+    }\n+\n+    \/** This case covers [4, 7] bytes *\/\n+    @ForceInline\n+    private static void fill3(AbstractMemorySegmentImpl dst, long len, int value) {\n+        final MemorySessionImpl sessionImpl = dst.sessionImpl();\n+        final long offset = dst.unsafeGetOffset();\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(sessionImpl, dst.unsafeGetBase(), offset, value);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(sessionImpl, dst.unsafeGetBase(), offset + len - Integer.BYTES, value);\n+    }\n+\n+    \/** This case covers [8, 15] bytes *\/\n+    @ForceInline\n+    private static void fill4(AbstractMemorySegmentImpl dst, long len, long value) {\n+        final MemorySessionImpl sessionImpl = dst.sessionImpl();\n+        final long offset = dst.unsafeGetOffset();\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(sessionImpl, dst.unsafeGetBase(), offset, value);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(sessionImpl, dst.unsafeGetBase(), offset + len - Long.BYTES, value);\n+    }\n+\n+    \/** This case covers [16, 2^63) bytes *\/\n+    @ForceInline\n+    private static void fill5AndUpwards(AbstractMemorySegmentImpl dst, long len, long value) {\n+        final MemorySessionImpl sessionImpl = dst.sessionImpl();\n+        final long offset = dst.unsafeGetOffset();\n+        if (len < NATIVE_THRESHOLD_FILL) {\n+            final int limit = (int) (len & (NATIVE_THRESHOLD_FILL - Long.BYTES));\n+            for (int i = 0; i < limit; i += Long.BYTES) {\n+                SCOPED_MEMORY_ACCESS.putLongUnaligned(sessionImpl, dst.unsafeGetBase(), offset + i, value);\n@@ -96,1 +134,1 @@\n-            \/\/ We have now fully handled 0...0X...XXXX\n+            SCOPED_MEMORY_ACCESS.putLongUnaligned(sessionImpl, dst.unsafeGetBase(), offset + len - Long.BYTES, value);\n@@ -99,1 +137,1 @@\n-            SCOPED_MEMORY_ACCESS.setMemory(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), dst.length, value);\n+            SCOPED_MEMORY_ACCESS.setMemory(sessionImpl, dst.unsafeGetBase(), offset, len, (byte) value);\n@@ -101,1 +139,0 @@\n-        return dst;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":75,"deletions":38,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -85,0 +85,42 @@\n+\n+    @ForceInline\n+    public $type$ get$Type$Unaligned(MemorySessionImpl session, Object base, long offset) {\n+        try {\n+            return get$Type$UnalignedInternal(session, base, offset);\n+        } catch (ScopedAccessError ex) {\n+            throw ex.newRuntimeException();\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$UnalignedInternal(MemorySessionImpl session, Object base, long offset) {\n+        try {\n+            if (session != null) {\n+                session.checkValidStateRaw();\n+            }\n+            return UNSAFE.get$Type$Unaligned(base, offset);\n+        } finally {\n+            Reference.reachabilityFence(session);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void put$Type$Unaligned(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+        try {\n+            put$Type$UnalignedInternal(session, base, offset, value);\n+        } catch (ScopedAccessError ex) {\n+            throw ex.newRuntimeException();\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$UnalignedInternal(MemorySessionImpl session, Object base, long offset, $type$ value) {\n+        try {\n+            if (session != null) {\n+                session.checkValidStateRaw();\n+            }\n+            UNSAFE.put$Type$Unaligned(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(session);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.Unsafe;\n@@ -51,1 +53,1 @@\n-@Fork(value = 3)\n+@Fork(value = 3, jvmArgs = {\"--add-opens=java.base\/jdk.internal.misc=ALL-UNNAMED\", \"--add-opens=java.base\/jdk.internal.foreign=ALL-UNNAMED\"})\n@@ -54,1 +56,3 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"12\", \"24\", \"64\", \"512\",\n@@ -59,3 +63,3 @@\n-    MemorySegment heapSegment;\n-    MemorySegment nativeSegment;\n-    MemorySegment unalignedSegment;\n+    AbstractMemorySegmentImpl heapSegment;\n+    AbstractMemorySegmentImpl nativeSegment;\n+    AbstractMemorySegmentImpl unalignedSegment;\n@@ -67,3 +71,3 @@\n-        heapSegment = MemorySegment.ofArray(array);\n-        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE, 8);\n-        unalignedSegment = Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n+        heapSegment = (AbstractMemorySegmentImpl)MemorySegment.ofArray(array);\n+        nativeSegment = (AbstractMemorySegmentImpl)Arena.ofAuto().allocate(ELEM_SIZE, 8);\n+        unalignedSegment = (AbstractMemorySegmentImpl)Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n@@ -92,1 +96,1 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n@@ -98,1 +102,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n@@ -101,1 +104,1 @@\n-        heapSegment.fill((byte) 0);\n+        UNSAFE.setMemory(heapSegment.heapBase().orElseThrow(), 0L, heapSegment.byteSize(), (byte) 0);\n@@ -111,1 +114,1 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n@@ -117,1 +120,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n@@ -120,1 +122,1 @@\n-        nativeSegment.fill((byte) 0);\n+        UNSAFE.setMemory(nativeSegment.address(), heapSegment.byteSize(), (byte) 0);\n@@ -130,1 +132,1 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n@@ -136,1 +138,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n@@ -139,1 +140,1 @@\n-        unalignedSegment.fill((byte) 0);\n+        UNSAFE.setMemory(unalignedSegment.address(), heapSegment.byteSize(), (byte) 0);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkFill.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"}]}