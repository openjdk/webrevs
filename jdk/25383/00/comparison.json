{"files":[{"patch":"@@ -60,0 +60,18 @@\n+    \/**\n+     * Fills the provided {@code dst} segment with the provided {@code value}.\n+     * <p>\n+     * This implementation relies on a scheme where operations with as large units of\n+     * memory as possible are used and where the cleanup of the remaining \"tail\" is\n+     * made by applying the same large operation but skewed so it will precisely fill the\n+     * remaining tail.\n+     * Said tail scheme is simpler and faster than trying to apply a combination of\n+     * operations with different units of memory to clean up the tail.\n+     * <p>\n+     * This method is using Java for segments that are smaller than the configurable\n+     * {@code NATIVE_THRESHOLD_FILL} meaning it does not have to pay the price for\n+     * transitioning to native code.\n+     *\n+     * @param dst   segment to fill\n+     * @param value to fill the segment with\n+     * @return the provided {@code dst} segment\n+     *\/\n@@ -63,5 +81,5 @@\n-        if (dst.length == 0) {\n-            \/\/ Implicit state check\n-            dst.sessionImpl().checkValidState();\n-        } else if (dst.length < NATIVE_THRESHOLD_FILL) {\n-            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+        final long len = dst.length;\n+        \/* The multiplication below is equivalent to:\n+             long u = Byte.toUnsignedLong(value);\n+             long value = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u; *\/\n+        final long longValue = 0x01010101_01010101L * Byte.toUnsignedLong(value);\n@@ -69,16 +87,7 @@\n-            \/\/ Handle smaller segments directly without transitioning to native code\n-            final long u = Byte.toUnsignedLong(value);\n-            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n-\n-            int offset = 0;\n-            \/\/ 0...0X...X000\n-            final int limit = (int) (dst.length & (NATIVE_THRESHOLD_FILL - 8));\n-            for (; offset < limit; offset += Long.BYTES) {\n-                SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, longValue, !Architecture.isLittleEndian());\n-            }\n-            int remaining = (int) dst.length - limit;\n-            \/\/ 0...0X00\n-            if (remaining >= Integer.BYTES) {\n-                SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (int) longValue, !Architecture.isLittleEndian());\n-                offset += Integer.BYTES;\n-                remaining -= Integer.BYTES;\n+        \/\/ Switch on log2(len) = 64 - Long.numberOfLeadingZeros(len)\n+        switch (64 - Long.numberOfLeadingZeros(len)) {\n+            case 0 -> dst.sessionImpl().checkValidState(); \/\/ Implicit state check\n+            case 1 -> SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), value);\n+            case 2 -> {\n+                SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), (short) longValue, !Architecture.isLittleEndian());\n+                SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Short.BYTES, (short) longValue, !Architecture.isLittleEndian());\n@@ -86,5 +95,3 @@\n-            \/\/ 0...00X0\n-            if (remaining >= Short.BYTES) {\n-                SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (short) longValue, !Architecture.isLittleEndian());\n-                offset += Short.BYTES;\n-                remaining -= Short.BYTES;\n+            case 3 -> {\n+                SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), (int) longValue, !Architecture.isLittleEndian());\n+                SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Integer.BYTES, (int) longValue, !Architecture.isLittleEndian());\n@@ -92,3 +99,11 @@\n-            \/\/ 0...000X\n-            if (remaining == 1) {\n-                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, value);\n+            default -> {\n+                if (len < NATIVE_THRESHOLD_FILL) {\n+                    final int limit = (int) (len & (NATIVE_THRESHOLD_FILL - 8));\n+                    for (int offset = 0; offset < limit; offset += Long.BYTES) {\n+                        SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, longValue, !Architecture.isLittleEndian());\n+                    }\n+                    SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Long.BYTES, longValue, !Architecture.isLittleEndian());\n+                } else {\n+                    \/\/ Handle larger segments via native calls\n+                    SCOPED_MEMORY_ACCESS.setMemory(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), len, value);\n+                }\n@@ -96,4 +111,0 @@\n-            \/\/ We have now fully handled 0...0X...XXXX\n-        } else {\n-            \/\/ Handle larger segments via native calls\n-            SCOPED_MEMORY_ACCESS.setMemory(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), dst.length, value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":44,"deletions":33,"binary":false,"changes":77,"status":"modified"}]}