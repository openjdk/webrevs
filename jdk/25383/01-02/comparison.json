{"files":[{"patch":"@@ -54,2 +54,1 @@\n-    \/\/ All the threshold values below MUST be a power of two and should preferably be\n-    \/\/ greater or equal to 2^3.\n+    \/\/ All the threshold values below MUST be a power of two and greater or equal to 2^3.\n@@ -91,20 +90,4 @@\n-            case 2 -> {\n-                SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), (short) longValue, !Architecture.isLittleEndian());\n-                SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Short.BYTES, (short) longValue, !Architecture.isLittleEndian());\n-            }\n-            case 3 -> {\n-                SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), (int) longValue, !Architecture.isLittleEndian());\n-                SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Integer.BYTES, (int) longValue, !Architecture.isLittleEndian());\n-            }\n-            default -> {\n-                if (len < NATIVE_THRESHOLD_FILL) {\n-                    final int limit = (int) (len & (NATIVE_THRESHOLD_FILL - 8));\n-                    for (int offset = 0; offset < limit; offset += Long.BYTES) {\n-                        SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, longValue, !Architecture.isLittleEndian());\n-                    }\n-                    SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Long.BYTES, longValue, !Architecture.isLittleEndian());\n-                } else {\n-                    \/\/ Handle larger segments via native calls\n-                    SCOPED_MEMORY_ACCESS.setMemory(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), len, value);\n-                }\n-            }\n+            case 2 -> fill2(dst, len, (short) longValue);\n+            case 3 -> fill3(dst, len, (int) longValue);\n+            case 4 -> fill4(dst, len, longValue);\n+            default -> fill5AndUpwards(dst, len, longValue);\n@@ -115,0 +98,32 @@\n+    @ForceInline\n+    private static void fill2(AbstractMemorySegmentImpl dst, long len, short value) {\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), value, !Architecture.isLittleEndian());\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Short.BYTES, value, !Architecture.isLittleEndian());\n+    }\n+\n+    @ForceInline\n+    private static void fill3(AbstractMemorySegmentImpl dst, long len, int value) {\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), value, !Architecture.isLittleEndian());\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Integer.BYTES, value, !Architecture.isLittleEndian());\n+    }\n+\n+    @ForceInline\n+    private static void fill4(AbstractMemorySegmentImpl dst, long len, long value) {\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), value, !Architecture.isLittleEndian());\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Long.BYTES, value, !Architecture.isLittleEndian());\n+    }\n+\n+    @ForceInline\n+    private static void fill5AndUpwards(AbstractMemorySegmentImpl dst, long len, long value) {\n+        if (len < NATIVE_THRESHOLD_FILL) {\n+            final int limit = (int) (len & (NATIVE_THRESHOLD_FILL - 8));\n+            for (int offset = 0; offset < limit; offset += Long.BYTES) {\n+                SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, value, !Architecture.isLittleEndian());\n+            }\n+            SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Long.BYTES, value, !Architecture.isLittleEndian());\n+        } else {\n+            \/\/ Handle larger segments via native calls\n+            SCOPED_MEMORY_ACCESS.setMemory(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), len, (byte) value);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":37,"deletions":22,"binary":false,"changes":59,"status":"modified"}]}