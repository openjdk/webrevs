{"files":[{"patch":"@@ -209,1 +209,2 @@\n-        return SegmentBulkOperations.fill(this, value);\n+        SegmentBulkOperations.fill(this, value);\n+        return this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,3 +54,2 @@\n-    \/\/ All the threshold values below MUST be a power of two and should preferably be\n-    \/\/ greater or equal to 2^3.\n-    private static final int NATIVE_THRESHOLD_FILL = powerOfPropertyOr(\"fill\", 5);\n+    \/\/ All the threshold values below MUST be a power of two and greater or equal to 2^3.\n+    private static final int NATIVE_THRESHOLD_FILL = 32;\n@@ -60,0 +59,17 @@\n+    \/**\n+     * Fills the provided {@code dst} segment with the provided {@code value}.\n+     * <p>\n+     * This implementation relies on a scheme where operations with as large units of\n+     * memory as possible are used and where the cleanup of the remaining \"tail\" is\n+     * made by applying the same large operation but skewed so it will precisely fill the\n+     * remaining tail.\n+     * Said tail scheme is simpler and faster than trying to apply a combination of\n+     * operations with different units of memory to clean up the tail.\n+     * <p>\n+     * This method is using Java for segments that are smaller than the configurable\n+     * {@code NATIVE_THRESHOLD_FILL} meaning it does not have to pay the price for\n+     * transitioning to native code.\n+     *\n+     * @param dst   segment to fill\n+     * @param value to fill the segment with\n+     *\/\n@@ -61,1 +77,1 @@\n-    public static MemorySegment fill(AbstractMemorySegmentImpl dst, byte value) {\n+    public static void fill(AbstractMemorySegmentImpl dst, byte value) {\n@@ -63,5 +79,5 @@\n-        if (dst.length == 0) {\n-            \/\/ Implicit state check\n-            dst.sessionImpl().checkValidState();\n-        } else if (dst.length < NATIVE_THRESHOLD_FILL) {\n-            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+        final long len = dst.length;\n+        \/* The multiplication below is equivalent to (but faster than):\n+             long u = Byte.toUnsignedLong(value);\n+             long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u; *\/\n+        final long longValue = 0x01010101_01010101L * Byte.toUnsignedLong(value);\n@@ -69,3 +85,10 @@\n-            \/\/ Handle smaller segments directly without transitioning to native code\n-            final long u = Byte.toUnsignedLong(value);\n-            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+        \/\/ Switch on log2(len) = 64 - Long.numberOfLeadingZeros(len)\n+        switch (64 - Long.numberOfLeadingZeros(len)) {\n+            case 0 -> dst.sessionImpl().checkValidState(); \/\/ Explicit state check\n+            case 1 -> SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), value);\n+            case 2 -> fill2(dst, len, (short) longValue);\n+            case 3 -> fill3(dst, len, (int) longValue);\n+            case 4 -> fill4(dst, len, longValue);\n+            default -> fill5AndUpwards(dst, len, longValue);\n+        }\n+    }\n@@ -73,22 +96,29 @@\n-            int offset = 0;\n-            \/\/ 0...0X...X000\n-            final int limit = (int) (dst.length & (NATIVE_THRESHOLD_FILL - 8));\n-            for (; offset < limit; offset += Long.BYTES) {\n-                SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, longValue, !Architecture.isLittleEndian());\n-            }\n-            int remaining = (int) dst.length - limit;\n-            \/\/ 0...0X00\n-            if (remaining >= Integer.BYTES) {\n-                SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (int) longValue, !Architecture.isLittleEndian());\n-                offset += Integer.BYTES;\n-                remaining -= Integer.BYTES;\n-            }\n-            \/\/ 0...00X0\n-            if (remaining >= Short.BYTES) {\n-                SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, (short) longValue, !Architecture.isLittleEndian());\n-                offset += Short.BYTES;\n-                remaining -= Short.BYTES;\n-            }\n-            \/\/ 0...000X\n-            if (remaining == 1) {\n-                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, value);\n+    \/** This case covers [2, 3] bytes *\/\n+    @ForceInline\n+    private static void fill2(AbstractMemorySegmentImpl dst, long len, short value) {\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), value, !Architecture.isLittleEndian());\n+        \/\/ `putByte()` below is enough as 3 is the maximum number of bytes covered\n+        SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Byte.BYTES, (byte) value);\n+    }\n+\n+    \/** This case covers [4, 7] bytes *\/\n+    @ForceInline\n+    private static void fill3(AbstractMemorySegmentImpl dst, long len, int value) {\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), value, !Architecture.isLittleEndian());\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Integer.BYTES, value, !Architecture.isLittleEndian());\n+    }\n+\n+    \/** This case covers [8, 15] bytes *\/\n+    @ForceInline\n+    private static void fill4(AbstractMemorySegmentImpl dst, long len, long value) {\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), value, !Architecture.isLittleEndian());\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Long.BYTES, value, !Architecture.isLittleEndian());\n+    }\n+\n+    \/** This case covers [16, 2^63) bytes *\/\n+    @ForceInline\n+    private static void fill5AndUpwards(AbstractMemorySegmentImpl dst, long len, long value) {\n+        if (len < NATIVE_THRESHOLD_FILL) {\n+            final int limit = (int) (len & (NATIVE_THRESHOLD_FILL - Long.BYTES));\n+            for (int offset = 0; offset < limit; offset += Long.BYTES) {\n+                SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + offset, value, !Architecture.isLittleEndian());\n@@ -96,1 +126,1 @@\n-            \/\/ We have now fully handled 0...0X...XXXX\n+            SCOPED_MEMORY_ACCESS.putLongUnaligned(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + len - Long.BYTES, value, !Architecture.isLittleEndian());\n@@ -99,1 +129,1 @@\n-            SCOPED_MEMORY_ACCESS.setMemory(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), dst.length, value);\n+            SCOPED_MEMORY_ACCESS.setMemory(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset(), len, (byte) value);\n@@ -101,1 +131,0 @@\n-        return dst;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentBulkOperations.java","additions":66,"deletions":37,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.misc.Unsafe;\n@@ -51,1 +53,1 @@\n-@Fork(value = 3)\n+@Fork(value = 3, jvmArgs = {\"--add-opens=java.base\/jdk.internal.misc=ALL-UNNAMED\", \"--add-opens=java.base\/jdk.internal.foreign=ALL-UNNAMED\"})\n@@ -54,1 +56,3 @@\n-    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"64\", \"512\",\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    @Param({\"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"12\", \"24\", \"64\", \"512\",\n@@ -59,3 +63,3 @@\n-    MemorySegment heapSegment;\n-    MemorySegment nativeSegment;\n-    MemorySegment unalignedSegment;\n+    AbstractMemorySegmentImpl heapSegment;\n+    AbstractMemorySegmentImpl nativeSegment;\n+    AbstractMemorySegmentImpl unalignedSegment;\n@@ -67,3 +71,3 @@\n-        heapSegment = MemorySegment.ofArray(array);\n-        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE, 8);\n-        unalignedSegment = Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n+        heapSegment = (AbstractMemorySegmentImpl)MemorySegment.ofArray(array);\n+        nativeSegment = (AbstractMemorySegmentImpl)Arena.ofAuto().allocate(ELEM_SIZE, 8);\n+        unalignedSegment = (AbstractMemorySegmentImpl)Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n@@ -92,1 +96,1 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n@@ -98,1 +102,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n@@ -101,1 +104,1 @@\n-        heapSegment.fill((byte) 0);\n+        UNSAFE.setMemory(heapSegment.heapBase().orElseThrow(), 0L, heapSegment.byteSize(), (byte) 0);\n@@ -111,1 +114,1 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n@@ -117,1 +120,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n@@ -120,1 +122,1 @@\n-        nativeSegment.fill((byte) 0);\n+        UNSAFE.setMemory(nativeSegment.address(), heapSegment.byteSize(), (byte) 0);\n@@ -130,1 +132,1 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n+    @Fork(value = 3, jvmArgsAppend = {\"-Djava.lang.foreign.native.threshold.power.fill=31\"})\n@@ -136,1 +138,0 @@\n-    @Fork(value = 3, jvmArgs = {\"-Djava.lang.foreign.native.threshold.power.fill=0\"})\n@@ -139,1 +140,1 @@\n-        unalignedSegment.fill((byte) 0);\n+        UNSAFE.setMemory(unalignedSegment.address(), heapSegment.byteSize(), (byte) 0);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentBulkFill.java","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"}]}