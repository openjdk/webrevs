{"files":[{"patch":"@@ -48,1 +48,0 @@\n-  _align_to_ref(nullptr),                                   \/\/ memory reference to align vectors to\n@@ -54,0 +53,2 @@\n+  _mem_ref_for_main_loop_alignment(nullptr),\n+  _aw_for_main_loop_alignment(0),\n@@ -519,5 +520,0 @@\n-  \/\/ Take the first mem_ref as the reference to align to. The pre-loop trip count is\n-  \/\/ modified to align this reference to a vector-aligned address. If strict alignment\n-  \/\/ is required, we may change the reference later (see filter_packs_for_alignment()).\n-  MemNode* align_to_mem_ref = nullptr;\n-\n@@ -530,5 +526,0 @@\n-    if (align_to_mem_ref == nullptr) {\n-      align_to_mem_ref = mem_ref;\n-      set_align_to_ref(align_to_mem_ref);\n-    }\n-\n@@ -576,3 +567,0 @@\n-  assert(_pairset.is_empty() || align_to_mem_ref != nullptr,\n-         \"pairset empty or we find the alignment reference\");\n-\n@@ -1726,1 +1714,5 @@\n-    set_align_to_ref(current->as_constrained()->mem_ref());\n+    MemNode const* mem = current->as_constrained()->mem_ref();\n+    Node_List* pack = get_pack(mem);\n+    assert(pack != nullptr, \"memop of final solution must still be packed\");\n+    _mem_ref_for_main_loop_alignment = mem;\n+    _aw_for_main_loop_alignment = pack->size() * mem->memory_size();\n@@ -3400,0 +3392,26 @@\n+\/\/ Find the memop pack with the maximum vector width, unless they were already\n+\/\/ determined by SuperWord::filter_packs_for_alignment().\n+void SuperWord::determine_mem_ref_and_aw_for_main_loop_alignment() {\n+  if (_mem_ref_for_main_loop_alignment != nullptr) {\n+    assert(vectors_should_be_aligned(), \"mem_ref only set if filtered for alignment\");\n+    return;\n+  }\n+\n+  MemNode const* mem_ref = nullptr;\n+  int max_aw = 0;\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* pack = _packset.at(i);\n+    MemNode* first = pack->at(0)->isa_Mem();\n+    if (first == nullptr) { continue; }\n+\n+    int vw = first->memory_size() * pack->size();\n+    if (vw > max_aw) {\n+      max_aw = vw;\n+      mem_ref = first;\n+    }\n+  }\n+  assert(mem_ref != nullptr && max_aw > 0, \"found mem_ref and aw\");\n+  _mem_ref_for_main_loop_alignment = mem_ref;\n+  _aw_for_main_loop_alignment = max_aw;\n+}\n+\n@@ -3410,2 +3428,3 @@\n-\/\/ the address of \"align_to_ref\" to the maximal possible vector width. We adjust the pre-loop\n-\/\/ iteration count by adjusting the pre-loop limit.\n+\/\/ the address of \"_mem_ref_for_main_loop_alignment\" to \"_aw_for_main_loop_alignment\", which is a\n+\/\/ sufficiently large alignment width. We adjust the pre-loop iteration count by adjusting the\n+\/\/ pre-loop limit.\n@@ -3413,2 +3432,4 @@\n-  const MemNode* align_to_ref = _align_to_ref;\n-  assert(align_to_ref != nullptr, \"align_to_ref must be set\");\n+  determine_mem_ref_and_aw_for_main_loop_alignment();\n+  const MemNode* align_to_ref = _mem_ref_for_main_loop_alignment;\n+  const int aw                = _aw_for_main_loop_alignment;\n+  assert(align_to_ref != nullptr && aw > 0, \"must have alignment reference and aw\");\n@@ -3559,4 +3580,1 @@\n-\n-  \/\/ We chose an aw that is the maximal possible vector width for the type of\n-  \/\/ align_to_ref.\n-  const int aw       = vector_width_in_bytes(align_to_ref);\n+  \/\/\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":41,"deletions":23,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -414,1 +414,0 @@\n-  MemNode const* _align_to_ref;          \/\/ Memory reference that pre-loop will align to\n@@ -419,0 +418,5 @@\n+  \/\/ Memory reference, and the alignment width (aw) for which we align the main-loop,\n+  \/\/ by adjusting the pre-loop limit.\n+  MemNode const* _mem_ref_for_main_loop_alignment;\n+  int _aw_for_main_loop_alignment;\n+\n@@ -566,2 +570,0 @@\n-  const MemNode* align_to_ref() const { return _align_to_ref; }\n-  void set_align_to_ref(const MemNode* m) { _align_to_ref = m; }\n@@ -673,0 +675,1 @@\n+  void determine_mem_ref_and_aw_for_main_loop_alignment();\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"}]}