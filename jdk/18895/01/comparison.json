{"files":[{"patch":"@@ -617,1 +617,0 @@\n-        MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, t);) \/\/ can call PcDescCache::add_pc_desc\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-  uint pc_desc_resets;   \/\/ number of resets (= number of caches)\n+  uint pc_desc_init;     \/\/ number of initialization of cache (= number of caches)\n@@ -226,1 +226,1 @@\n-                  pc_desc_resets,\n+                  pc_desc_init,\n@@ -344,1 +344,1 @@\n-  if (!approximate)\n+  if (!approximate) {\n@@ -346,1 +346,1 @@\n-  else\n+  } else {\n@@ -348,0 +348,1 @@\n+  }\n@@ -350,9 +351,6 @@\n-void PcDescCache::reset_to(PcDesc* initial_pc_desc) {\n-  if (initial_pc_desc == nullptr) {\n-    _pc_descs[0] = nullptr; \/\/ native method; no PcDescs at all\n-    return;\n-  }\n-  NOT_PRODUCT(++pc_nmethod_stats.pc_desc_resets);\n-  \/\/ reset the cache by filling it with benign (non-null) values\n-  assert(initial_pc_desc->pc_offset() < 0, \"must be sentinel\");\n-  for (int i = 0; i < cache_size; i++)\n+void PcDescCache::init_to(PcDesc* initial_pc_desc) {\n+  NOT_PRODUCT(++pc_nmethod_stats.pc_desc_init);\n+  \/\/ initialize the cache by filling it with benign (non-null) values\n+  assert(initial_pc_desc != nullptr && initial_pc_desc->pc_offset() == PcDesc::lower_offset_limit,\n+         \"must start with a sentinel\");\n+  for (int i = 0; i < cache_size; i++) {\n@@ -360,0 +358,1 @@\n+  }\n@@ -363,3 +362,0 @@\n-  NOT_PRODUCT(++pc_nmethod_stats.pc_desc_queries);\n-  NOT_PRODUCT(if (approximate) ++pc_nmethod_stats.pc_desc_approx);\n-\n@@ -378,2 +374,4 @@\n-  if (res == nullptr) return nullptr;  \/\/ native method; no PcDescs at all\n-  if (match_desc(res, pc_offset, approximate)) {\n+  assert(res != nullptr, \"PcDesc cache should be initialized already\");\n+\n+  \/\/ Approximate only here since PcDescContainer::find_pc_desc() checked for exact case.\n+  if (approximate && match_desc(res, pc_offset, approximate)) {\n@@ -399,1 +397,0 @@\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current());)\n@@ -1248,0 +1245,1 @@\n+    _pc_desc_container       = nullptr;\n@@ -1282,2 +1280,0 @@\n-    _pc_desc_container.reset_to(nullptr);\n-\n@@ -1448,3 +1444,1 @@\n-    \/\/ after _scopes_pcs_offset is set\n-    _pc_desc_container.reset_to(scopes_pcs_begin());\n-\n+    \/\/ Copy code and relocation info\n@@ -1452,1 +1446,1 @@\n-    \/\/ Copy contents of ScopeDescRecorder to nmethod\n+    \/\/ Copy oops and metadata\n@@ -1454,1 +1448,0 @@\n-    debug_info->copy_to(this);\n@@ -1456,0 +1449,5 @@\n+    \/\/ Copy PcDesc and ScopeDesc data\n+    debug_info->copy_to(this);\n+\n+    \/\/ Create cache after PcDesc data is copied - it will be used to initialize cache\n+    _pc_desc_container = new PcDescContainer(scopes_pcs_begin());\n@@ -2047,1 +2045,3 @@\n-\n+  if (_pc_desc_container != nullptr) {\n+    delete _pc_desc_container;\n+  }\n@@ -2622,4 +2622,1 @@\n-static PcDesc* linear_search(const PcDescSearch& search, int pc_offset, bool approximate) {\n-  PcDesc* lower = search.scopes_pcs_begin();\n-  PcDesc* upper = search.scopes_pcs_end();\n-  lower += 1; \/\/ exclude initial sentinel\n+static PcDesc* linear_search(int pc_offset, bool approximate, PcDesc* lower, PcDesc* upper) {\n@@ -2627,1 +2624,4 @@\n-  for (PcDesc* p = lower; p < upper; p++) {\n+  assert(lower != nullptr && lower->pc_offset() == PcDesc::lower_offset_limit,\n+         \"must start with a sentinel\");\n+  \/\/ lower + 1 to exclude initial sentinel\n+  for (PcDesc* p = lower + 1; p < upper; p++) {\n@@ -2630,1 +2630,1 @@\n-      if (res == nullptr)\n+      if (res == nullptr) {\n@@ -2632,1 +2632,1 @@\n-      else\n+      } else {\n@@ -2634,0 +2634,1 @@\n+      }\n@@ -2641,0 +2642,19 @@\n+#ifndef PRODUCT\n+\/\/ Version of method to collect statistic\n+PcDesc* PcDescContainer::find_pc_desc(address pc, bool approximate, address code_begin,\n+                                      PcDesc* lower, PcDesc* upper) {\n+  ++pc_nmethod_stats.pc_desc_queries;\n+  if (approximate) ++pc_nmethod_stats.pc_desc_approx;\n+\n+  PcDesc* desc = _pc_desc_cache.last_pc_desc();\n+  assert(desc != nullptr, \"PcDesc cache should be initialized already\");\n+  if (desc->pc_offset() == (pc - code_begin)) {\n+    \/\/ Cached value matched\n+    ++pc_nmethod_stats.pc_desc_tests;\n+    ++pc_nmethod_stats.pc_desc_repeats;\n+    return desc;\n+  }\n+  return find_pc_desc_internal(pc, approximate, code_begin, lower, upper);\n+}\n+#endif\n+\n@@ -2642,4 +2662,4 @@\n-PcDesc* PcDescContainer::find_pc_desc_internal(address pc, bool approximate, const PcDescSearch& search) {\n-  address base_address = search.code_begin();\n-  if ((pc < base_address) ||\n-      (pc - base_address) >= (ptrdiff_t) PcDesc::upper_offset_limit) {\n+PcDesc* PcDescContainer::find_pc_desc_internal(address pc, bool approximate, address code_begin,\n+                                               PcDesc* lower_incl, PcDesc* upper_incl) {\n+  if ((pc < code_begin) ||\n+      (pc - code_begin) >= (ptrdiff_t) PcDesc::upper_offset_limit) {\n@@ -2648,1 +2668,1 @@\n-  int pc_offset = (int) (pc - base_address);\n+  int pc_offset = (int) (pc - code_begin);\n@@ -2654,1 +2674,1 @@\n-    assert(res == linear_search(search, pc_offset, approximate), \"cache ok\");\n+    assert(res == linear_search(pc_offset, approximate, lower_incl, upper_incl), \"cache ok\");\n@@ -2662,4 +2682,3 @@\n-  PcDesc* lower = search.scopes_pcs_begin();\n-  PcDesc* upper = search.scopes_pcs_end();\n-  upper -= 1; \/\/ exclude final sentinel\n-  if (lower >= upper)  return nullptr;  \/\/ native method; no PcDescs at all\n+  PcDesc* lower = lower_incl;     \/\/ this is initial sentiel\n+  PcDesc* upper = upper_incl - 1; \/\/ exclude final sentinel\n+  if (lower >= upper)  return nullptr;  \/\/ no PcDescs at all\n@@ -2714,1 +2733,1 @@\n-    assert(upper == linear_search(search, pc_offset, approximate), \"search ok\");\n+    assert(upper == linear_search(pc_offset, approximate, lower_incl, upper_incl), \"search mismatch\");\n@@ -2722,1 +2741,1 @@\n-    assert(nullptr == linear_search(search, pc_offset, approximate), \"search ok\");\n+    assert(nullptr == linear_search(pc_offset, approximate, lower_incl, upper_incl), \"search mismatch\");\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":65,"deletions":46,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  void    reset_to(PcDesc* initial_pc_desc);\n+  void    init_to(PcDesc* initial_pc_desc);\n@@ -110,17 +110,1 @@\n-class PcDescSearch {\n-private:\n-  address _code_begin;\n-  PcDesc* _lower;\n-  PcDesc* _upper;\n-public:\n-  PcDescSearch(address code, PcDesc* lower, PcDesc* upper) :\n-    _code_begin(code), _lower(lower), _upper(upper)\n-  {\n-  }\n-\n-  address code_begin() const { return _code_begin; }\n-  PcDesc* scopes_pcs_begin() const { return _lower; }\n-  PcDesc* scopes_pcs_end() const { return _upper; }\n-};\n-\n-class PcDescContainer {\n+class PcDescContainer : public CHeapObj<mtCode> {\n@@ -130,1 +114,1 @@\n-  PcDescContainer() {}\n+  PcDescContainer(PcDesc* initial_pc_desc) { _pc_desc_cache.init_to(initial_pc_desc); }\n@@ -132,2 +116,2 @@\n-  PcDesc* find_pc_desc_internal(address pc, bool approximate, const PcDescSearch& search);\n-  void    reset_to(PcDesc* initial_pc_desc) { _pc_desc_cache.reset_to(initial_pc_desc); }\n+  PcDesc* find_pc_desc_internal(address pc, bool approximate, address code_begin,\n+                                PcDesc* lower, PcDesc* upper);\n@@ -135,2 +119,3 @@\n-  PcDesc* find_pc_desc(address pc, bool approximate, const PcDescSearch& search) {\n-    address base_address = search.code_begin();\n+  PcDesc* find_pc_desc(address pc, bool approximate, address code_begin, PcDesc* lower, PcDesc* upper)\n+#ifdef PRODUCT\n+  {\n@@ -138,1 +123,3 @@\n-    if (desc != nullptr && desc->pc_offset() == pc - base_address) {\n+    assert(desc != nullptr, \"PcDesc cache should be initialized already\");\n+    if (desc->pc_offset() == (pc - code_begin)) {\n+      \/\/ Cached value matched\n@@ -141,1 +128,1 @@\n-    return find_pc_desc_internal(pc, approximate, search);\n+    return find_pc_desc_internal(pc, approximate, code_begin, lower, upper);\n@@ -143,0 +130,2 @@\n+#endif\n+  ;\n@@ -209,1 +198,1 @@\n-  PcDescContainer _pc_desc_container;\n+  PcDescContainer* _pc_desc_container;\n@@ -362,1 +351,2 @@\n-    return _pc_desc_container.find_pc_desc(pc, approximate, PcDescSearch(code_begin(), scopes_pcs_begin(), scopes_pcs_end()));\n+    if (_pc_desc_container == nullptr) return nullptr; \/\/ native method\n+    return _pc_desc_container->find_pc_desc(pc, approximate, code_begin(), scopes_pcs_begin(), scopes_pcs_end());\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":17,"deletions":27,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -484,3 +484,0 @@\n-  \/\/ write lock needed because we might update the pc desc cache via PcDescCache::add_pc_desc\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, current));\n-\n@@ -1755,1 +1752,2 @@\n-  \/\/ write lock needed because we might update the pc desc cache via PcDescCache::add_pc_desc\n+  \/\/ write lock needed because we might patch call site by set_to_clean()\n+  \/\/ and is_unloading() can modify nmethod's state\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}