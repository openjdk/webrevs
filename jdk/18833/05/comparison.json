{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+#include \"utilities\/utf8.hpp\"\n@@ -57,1 +58,5 @@\n-ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n+ClassListParser::ClassListParser(const char* file, ParseMode parse_mode) :\n+    _classlist_file(file),\n+    _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE),\n+    _file_input(file),\n+    _input_stream(&_file_input) {\n@@ -60,11 +65,1 @@\n-  _classlist_file = file;\n-  _file = nullptr;\n-  \/\/ Use os::open() because neither fopen() nor os::fopen()\n-  \/\/ can handle long path name on Windows.\n-  int fd = os::open(file, O_RDONLY, S_IREAD);\n-  if (fd != -1) {\n-    \/\/ Obtain a File* from the file descriptor so that fgets()\n-    \/\/ can be used in parse_one_line()\n-    _file = os::fdopen(fd, \"r\");\n-  }\n-  if (_file == nullptr) {\n+  if (!_file_input.is_open()) {\n@@ -75,2 +70,1 @@\n-  _line_no = 0;\n-  _token = _line;\n+  _token = _line = nullptr;\n@@ -92,3 +86,0 @@\n-  if (_file != nullptr) {\n-    fclose(_file);\n-  }\n@@ -104,1 +95,9 @@\n-  while (parse_one_line()) {\n+  for (; !_input_stream.done(); _input_stream.next()) {\n+    _line = _input_stream.current_line();\n+    if (*_line == '#') { \/\/ comment\n+      continue;\n+    }\n+    if (!parse_one_line()) {\n+      break;\n+    }\n+\n@@ -115,0 +114,1 @@\n+    check_class_name(_class_name);\n@@ -168,21 +168,7 @@\n-  for (;;) {\n-    if (fgets(_line, sizeof(_line), _file) == nullptr) {\n-      return false;\n-    }\n-    ++ _line_no;\n-    _line_len = (int)strlen(_line);\n-    if (_line_len > _max_allowed_line_len) {\n-      error(\"input line too long (must be no longer than %d chars)\", _max_allowed_line_len);\n-    }\n-    if (*_line == '#') { \/\/ comment\n-      continue;\n-    }\n-\n-    {\n-      int len = (int)strlen(_line);\n-      int i;\n-      \/\/ Replace \\t\\r\\n\\f with ' '\n-      for (i=0; i<len; i++) {\n-        if (_line[i] == '\\t' || _line[i] == '\\r' || _line[i] == '\\n' || _line[i] == '\\f') {\n-          _line[i] = ' ';\n-        }\n+  {\n+    int len = (int)strlen(_line);\n+    int i;\n+    \/\/ Replace \\t\\r\\n\\f with ' '\n+    for (i=0; i<len; i++) {\n+      if (_line[i] == '\\t' || _line[i] == '\\r' || _line[i] == '\\n' || _line[i] == '\\f') {\n+        _line[i] = ' ';\n@@ -190,0 +176,1 @@\n+    }\n@@ -191,8 +178,7 @@\n-      \/\/ Remove trailing newline\/space\n-      while (len > 0) {\n-        if (_line[len-1] == ' ') {\n-          _line[len-1] = '\\0';\n-          len --;\n-        } else {\n-          break;\n-        }\n+    \/\/ Remove trailing newline\/space\n+    while (len > 0) {\n+      if (_line[len-1] == ' ') {\n+        _line[len-1] = '\\0';\n+        len --;\n+      } else {\n+        break;\n@@ -200,1 +186,0 @@\n-      _line_len = len;\n@@ -202,3 +187,1 @@\n-\n-    \/\/ valid line\n-    break;\n+    _line_len = len;\n@@ -289,1 +272,1 @@\n-    error(\"Too few items following the @ tag \\\"%s\\\" line #%d\", _line, _line_no);\n+    error(\"Too few items following the @ tag \\\"%s\\\" line #%zu\", _line, lineno());\n@@ -307,1 +290,1 @@\n-      error(\"Line with @ tag has too few items \\\"%s\\\" line #%d\", _token, _line_no);\n+      error(\"Line with @ tag has too few items \\\"%s\\\" line #%zu\", _token, lineno());\n@@ -318,1 +301,1 @@\n-    error(\"Invalid @ tag at the beginning of line \\\"%s\\\" line #%d\", _token, _line_no);\n+    error(\"Invalid @ tag at the beginning of line \\\"%s\\\" line #%zu\", _token, lineno());\n@@ -426,2 +409,2 @@\n-              \"An error has occurred while processing class list file %s %d:%d.\\n\",\n-              _classlist_file, _line_no, (error_index + 1));\n+              \"An error has occurred while processing class list file %s %zu:%d.\\n\",\n+              _classlist_file, lineno(), (error_index + 1));\n@@ -453,0 +436,19 @@\n+void ClassListParser::check_class_name(const char* class_name) {\n+  const char* err = nullptr;\n+  size_t len = strlen(class_name);\n+  if (len > (size_t)Symbol::max_length()) {\n+    err = \"class name too long\";\n+  } else {\n+    assert(Symbol::max_length() < INT_MAX && len < INT_MAX, \"must be\");\n+    if (!UTF8::is_legal_utf8((const unsigned char*)class_name, (int)len, \/*version_leq_47*\/false)) {\n+      err = \"class name is not valid UTF8\";\n+    }\n+  }\n+  if (err != nullptr) {\n+    jio_fprintf(defaultStream::error_stream(),\n+              \"An error has occurred while processing class list file %s:%zu %s\\n\",\n+              _classlist_file, lineno(), err);\n+    vm_exit_during_initialization(\"class list format error.\", nullptr);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":59,"deletions":57,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"utilities\/istream.hpp\"\n@@ -83,8 +84,0 @@\n-\n-    \/\/ Max number of bytes allowed per line in the classlist.\n-    \/\/ Theoretically Java class names could be 65535 bytes in length. Also, an input line\n-    \/\/ could have a very long path name up to JVM_MAXPATHLEN bytes in length. In reality,\n-    \/\/ 4K bytes is more than enough.\n-    _max_allowed_line_len = 4096,\n-    _line_buf_extra       = 10, \/\/ for detecting input too long\n-    _line_buf_size        = _max_allowed_line_len + _line_buf_extra\n@@ -99,1 +92,0 @@\n-  FILE* _file;\n@@ -103,3 +95,3 @@\n-  \/\/ The following field contains information from the *current* line being\n-  \/\/ parsed.\n-  char                _line[_line_buf_size];  \/\/ The buffer that holds the current line. Some characters in\n+  FileInput           _file_input;\n+  inputStream         _input_stream;\n+  char*               _line;                  \/\/ The buffer that holds the current line. Some characters in\n@@ -108,1 +100,0 @@\n-  int                 _line_no;               \/\/ Line number for current line being parsed\n@@ -135,0 +126,2 @@\n+  size_t lineno() { return _input_stream.lineno(); }\n+\n@@ -186,0 +179,1 @@\n+  void check_class_name(const char* class_name);\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":8,"deletions":14,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"utilities\/istream.hpp\"\n@@ -1059,22 +1060,2 @@\n-  char token[1024];\n-  int  pos = 0;\n-  int  c = getc(stream);\n-  bool success = true;\n-  while(c != EOF && pos < (int)(sizeof(token)-1)) {\n-    if (c == '\\n') {\n-      token[pos++] = '\\0';\n-      if (!parse_from_line(token)) {\n-        success = false;\n-      }\n-      pos = 0;\n-    } else {\n-      token[pos++] = c;\n-    }\n-    c = getc(stream);\n-  }\n-  token[pos++] = '\\0';\n-  if (!parse_from_line(token)) {\n-    success = false;\n-  }\n-  fclose(stream);\n-  return success;\n+  FileInput input(stream, \/*need_close=*\/ true);\n+  return parse_from_input(&input, parse_from_line);\n@@ -1083,5 +1064,3 @@\n-bool CompilerOracle::parse_from_string(const char* str, bool (*parse_line)(char*)) {\n-  char token[1024];\n-  int  pos = 0;\n-  const char* sp = str;\n-  int  c = *sp++;\n+bool CompilerOracle::parse_from_input(inputStream::Input* input,\n+                                      CompilerOracle::\n+                                      parse_from_line_fn_t* parse_from_line) {\n@@ -1089,9 +1068,3 @@\n-  while (c != '\\0' && pos < (int)(sizeof(token)-1)) {\n-    if (c == '\\n') {\n-      token[pos++] = '\\0';\n-      if (!parse_line(token)) {\n-        success = false;\n-      }\n-      pos = 0;\n-    } else {\n-      token[pos++] = c;\n+  for (inputStream in(input); !in.done(); in.next()) {\n+    if (!parse_from_line(in.current_line())) {\n+      success = false;\n@@ -1099,5 +1072,0 @@\n-    c = *sp++;\n-  }\n-  token[pos++] = '\\0';\n-  if (!parse_line(token)) {\n-    success = false;\n@@ -1108,0 +1076,7 @@\n+bool CompilerOracle::parse_from_string(const char* str,\n+                                       CompilerOracle::\n+                                       parse_from_line_fn_t* parse_from_line) {\n+  MemoryInput input(str, strlen(str));\n+  return parse_from_input(&input, parse_from_line);\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":16,"deletions":41,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/istream.hpp\"\n@@ -123,0 +124,3 @@\n+ public:\n+  typedef bool parse_from_line_fn_t(char*);\n+\n@@ -128,0 +132,4 @@\n+  \/\/ The core parser.\n+  static bool parse_from_input(inputStream::Input* input,\n+                               parse_from_line_fn_t* parse_from_line);\n+\n@@ -180,1 +188,2 @@\n-  static bool parse_from_string(const char* option_string, bool (*parser)(char*));\n+  static bool parse_from_string(const char* option_string,\n+                                parse_from_line_fn_t* parser);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,371 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/orderAccess.hpp\"\n+#include \"utilities\/istream.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/xmlstream.hpp\"\n+\n+#ifndef ASSERT\n+#define COV(casen) {}\n+#else \/\/ASSERT\n+\/\/ Support for coverage testing.  Used by the gtest.\n+\/* $ sed < istream.cpp '\/^.* COV(\\([A-Z][^)]*\\)).*$\/!d;s\/\/COV_FN(\\1)\/' |\n+     tr '\\12' ' ' | fold -sw72 | sed 's| $||;s|.*|  & \\\\|'\n+  *\/\n+#define DO_COV_CASES(COV_FN) \\\n+  COV_FN(NXT_L) COV_FN(NXT_N) COV_FN(FIB_P) COV_FN(FIB_E) COV_FN(FIB_N) \\\n+  COV_FN(FIB_L) COV_FN(PFB_C) COV_FN(PFB_P) COV_FN(PFB_A) \\\n+  COV_FN(PFB_G) COV_FN(PFB_H) COV_FN(SBC_C) COV_FN(SBC_B) COV_FN(SBC_N) \\\n+  COV_FN(SBC_L) COV_FN(EXB_R) COV_FN(EXB_A)\n+  \/**\/\n+#define COV_COUNT(casename) coverage_case_##casename\n+#define DECLARE_COV_CASE(casename) static int COV_COUNT(casename);\n+DO_COV_CASES(DECLARE_COV_CASE)\n+#undef DECLARE_COV_CASE\n+\n+static int current_coverage_mode = 0;\n+#define COV(casename) {                                 \\\n+    if (current_coverage_mode != 0) {                   \\\n+      COV_COUNT(casename)++;                            \\\n+    }                                                  }\n+#endif \/\/ASSERT\n+\n+bool inputStream::next() {\n+  \/\/ We have to look at the current line first, just in case nobody\n+  \/\/ actually called current_line() or done().\n+  preload();\n+  if (definitely_done()) {\n+    return false;         \/\/ OK to call this->next() after done is true\n+  }\n+  \/\/ current line is at buffer[beg..end]; now skip past its '\\0'\n+  assert(have_current_line(), \"\");\n+\n+  set_buffer_content(_next, _content_end);\n+  if (!need_to_read()) {  \/\/ any next line was already in the buffer\n+    COV(NXT_L);\n+    assert(have_current_line(), \"\");\n+    return true;\n+  } else {                \/\/ go back to the source for more\n+    COV(NXT_N);\n+    return fill_buffer();\n+  }\n+}\n+\n+void inputStream::set_done() {\n+  size_t end = _beg = _end = _content_end;\n+  _next = end + NEXT_PHANTOM;\n+  _line_ending = 0;\n+  assert(definitely_done(), \"\");\n+}\n+\n+void inputStream::set_error(bool error_condition) {\n+  if (error_condition) {\n+    set_done();\n+    _input_state = IState::ERR_STATE;\n+    assert(error(), \"\");\n+  } else if (error()) {\n+    _input_state = definitely_done() ? IState::EOF_STATE : IState::NTR_STATE;\n+  }\n+}\n+\n+void inputStream::clear_buffer() {\n+  _content_end = _beg = _end = _next = 0;\n+  _line_ending = 0;\n+}\n+\n+const char* inputStream::next_content(size_t& next_content_length) const {\n+  assert(is_sane(), \"\");\n+  size_t len = buffered_content_length(false);\n+  next_content_length = len;\n+  return len == 0 ? \"\" : &_buffer[_next];\n+}\n+\n+void inputStream::set_input(inputStream::Input* input) {\n+  clear_buffer();\n+  _input = input;\n+  _input_state = IState::NTR_STATE;\n+}\n+\n+bool inputStream::fill_buffer() {\n+  size_t fill_offset, fill_length;\n+  assert(!definitely_done(), \"\");  \/\/ caller responsibility\n+  while (need_to_read()) {\n+    prepare_to_fill_buffer(fill_offset, fill_length);\n+    if (error())  return false;\n+    assert(fill_length > 0, \"\");\n+    assert(fill_offset < _buffer_size, \"\");\n+    assert(fill_offset + fill_length <= _buffer_size, \"\");\n+    size_t nr = 0;\n+    if (_input != nullptr && _input_state == IState::NTR_STATE) {\n+      nr = _input->read(&_buffer[fill_offset], fill_length);\n+      if (nr == 0)  _input_state = IState::EOF_STATE;  \/\/ do not get EOF twice\n+    }\n+    bool last_partial = false;\n+    if (nr > 0) {\n+      fill_offset += nr;\n+    } else if (_beg == _end) {  \/\/ no partial line, so end it now\n+      \/\/ we hit the end of the file (or there was never anything there)\n+      COV(FIB_P);\n+      assert(!definitely_done(), \"\");\n+      set_done();\n+      assert(definitely_done(), \"\");\n+      return false;\n+    } else {\n+      \/\/ pretend to read a newline, to complete the last partial line\n+      COV(FIB_E);\n+      _buffer[fill_offset++] = '\\n';  \/\/ insert phantom newline\n+      last_partial = true;\n+    }\n+    set_buffer_content(_beg, fill_offset);\n+    assert(!definitely_done(), \"\");\n+    if (need_to_read()) { COV(FIB_N); }\n+    else                { COV(FIB_L); }\n+    if (last_partial) {\n+      assert(have_current_line(), \"\");\n+      _line_ending = 0;\n+      _content_end -= 1;  \/\/ reverse insertion of phantom newline\n+      assert(_next == _content_end + NEXT_PHANTOM, \"\");\n+      assert(have_current_line(), \"\");\n+    }\n+  }\n+  return true;\n+}\n+\n+\/\/ Find some space in the buffer for reading.  If there is already a\n+\/\/ partial line in the buffer, new space must follow it immediately.\n+\/\/ The partial line is between _beg and _end, and no other parts of\n+\/\/ the buffer are in use.\n+void inputStream::prepare_to_fill_buffer(size_t& fill_offset,\n+                                         size_t& fill_length) {\n+  assert(need_to_read(), \"\");  \/\/ _next pointer out of the way\n+  size_t end = _content_end;\n+  if (_beg == end) { \/\/ if no partial line present...\n+    COV(PFB_C);\n+    clear_buffer();\n+    fill_offset = 0;\n+    fill_length = _buffer_size;\n+    return;   \/\/ use the whole buffer\n+  }\n+  \/\/ at this point we have a pending line that needs more input\n+  if (_beg > 0 && (_input != nullptr || end == _buffer_size)) {\n+    COV(PFB_P);\n+    \/\/ compact the buffer by overwriting characters from previous lines\n+    size_t shift_left = _beg;\n+    ::memmove(_buffer, _buffer + shift_left, _content_end - _beg);\n+    _beg -= shift_left;\n+    _end -= shift_left;\n+    _next -= shift_left;\n+    _content_end -= shift_left;\n+    end = _content_end;\n+  }\n+  if (end < _buffer_size) {\n+    COV(PFB_A);\n+    fill_offset = end;\n+    fill_length = _buffer_size - end;\n+    return;   \/\/ use the whole buffer except partial line at the beginning\n+  }\n+  \/\/ the whole buffer contains a partial line, which means we must expand\n+  COV(PFB_G);\n+  size_t new_size = (_buffer_size < BIG_SIZE ? BIG_SIZE\n+                     : _buffer_size + _buffer_size \/ 2);\n+  assert(new_size > _buffer_size, \"\");\n+  if (expand_buffer(new_size)) {\n+    COV(PFB_H);\n+    fill_offset = end;\n+    fill_length = _buffer_size - end;\n+    return;   \/\/ use the expanded buffer, except the partial line\n+  }\n+  \/\/ no recovery from failed allocation; just set the error state and bail\n+  set_error();\n+}\n+\n+\/\/ The only buffer content is between the given offsets.\n+\/\/ Set _beg, _end, _next, and _content_end appropriately.\n+void inputStream::set_buffer_content(size_t content_start,\n+                                     size_t content_end) {\n+  assert(content_end <= _buffer_size, \"\");\n+  assert(content_start <= content_end + NEXT_PHANTOM, \"\");\n+  if (content_start >= content_end) {   \/\/ empty content; clear buffer\n+    COV(SBC_C);\n+    clear_buffer();\n+    return;\n+  }\n+  COV(SBC_B);\n+  size_t content_len = content_end - content_start;\n+  _beg = content_start;\n+  _content_end = content_end;\n+\n+  \/\/ this is where we scan for newlines\n+  char* nl = (char*) memchr(&_buffer[content_start], '\\n', content_len);\n+  if (nl == nullptr) {\n+    COV(SBC_N);\n+    _next = _end = content_end;\n+    _line_ending = 0;\n+    assert(need_to_read(), \"\");\n+  } else {\n+    COV(SBC_L);\n+    *nl = '\\0';  \/\/ so that this->current_line() will work\n+    ++_line_count;\n+    size_t end = nl - &_buffer[0];\n+    _next = end + 1;\n+    assert(_next != _content_end + NEXT_PHANTOM, \"\");\n+    if (end > content_start && nl[-1] == '\\r') { \/\/ yuck\n+      \/\/ again, for this->current_line(), remove '\\r' before '\\n'\n+      nl[-1] = '\\0';\n+      --end;\n+      \/\/ Note: we could treat '\\r' alone as a line ending on some\n+      \/\/ platforms, but that is way too much work.  Newline '\\n' is\n+      \/\/ supported everywhere, and some tools insist on accompanying\n+      \/\/ it with return as well, so we remove that.  But return '\\r'\n+      \/\/ by itself is an obsolete format, and also inconsistent with\n+      \/\/ outputStream, which standarizes on '\\n' and never emits '\\r'.\n+      \/\/ Postel's law suggests that we write '\\n' only and grudgingly\n+      \/\/ accept '\\r' before '\\n'.\n+    }\n+    _end = end;  \/\/ now this->current_line() points to buf[beg..end]\n+    _line_ending = (int)(_next - end);\n+    assert(have_current_line(), \"\");\n+    assert(current_line() == &_buffer[_beg], \"\");\n+    assert(current_line_length() == _end - _beg, \"\");\n+  }\n+}\n+\n+\/\/ Return true iff we expanded the buffer to the given length.\n+bool inputStream::expand_buffer(size_t new_length) {\n+  assert(new_length > _buffer_size, \"\");\n+  char* new_buf = nullptr;\n+  assert(new_length > sizeof(_small_buffer), \"\");\n+  if (_buffer == &_small_buffer[0]) {\n+    \/\/ fresh alloc from c-heap\n+    COV(EXB_A);\n+    new_buf = NEW_C_HEAP_ARRAY(char, new_length, mtInternal);\n+    assert(new_buf != nullptr, \"would have exited VM if OOM\");\n+    if (_content_end > 0) {\n+      assert(_content_end <= _buffer_size, \"\");\n+      ::memcpy(new_buf, _buffer, _content_end);  \/\/ copy only the active content\n+    }\n+  } else {\n+    \/\/ realloc\n+    COV(EXB_R);\n+    new_buf = REALLOC_C_HEAP_ARRAY(char, _buffer, new_length, mtInternal);\n+    assert(new_buf != nullptr, \"would have exited VM if OOM\");\n+  }\n+\n+  if (new_buf == nullptr) {\n+    return false;   \/\/ do not further update _buffer etc.\n+  }\n+  _buffer = new_buf;\n+  _buffer_size = new_length;\n+  return true;\n+}\n+\n+inputStream::~inputStream() {\n+  if (has_c_heap_buffer()) {\n+    FreeHeap(_buffer);\n+    DEBUG_ONLY(_buffer = (char*)0xdeadbeef); \/\/ sanity\n+  }\n+  if (_input != nullptr)  {\n+    set_input(nullptr);\n+  }\n+}\n+\n+#ifdef ASSERT\n+void inputStream::dump(const char* what) {\n+  int diff = (int)(_end - _beg);\n+  if (!_buffer || _beg > _buffer_size || _end > _buffer_size)\n+    diff = 0;\n+\n+  bool ntr = (_next == _end),\n+       hcl = (_beg < _content_end && _end < _next),\n+       ddn = (_beg == _content_end && _next > _content_end);\n+  tty->print_cr(\"%s%sistream %s%s%s%s%s [%d<%.*s>%d\/%d..%d] LE=%d,\"\n+                \" B=%llx%s[%d], LN=%d, CH=%d\",\n+                what ? what : \"\", what ? \": \" : \"\",\n+                _buffer == nullptr ? \"U\" : \"\",\n+                ntr ? \"R\" : \"\",\n+                hcl ? \"L\" : \"\",\n+                ddn ? \"D\" : \"\",\n+                (_next < _content_end ? \"\" :\n+                 _next == _content_end ? \"N\" : \"P\"),\n+                (int)_beg,\n+                diff < 0 ? 0 : diff > 10 ? 10 : diff,\n+                _buffer ? &_buffer[_beg] : \"\",\n+                (int)_end, (int)_next, (int)_content_end,\n+                _line_ending,\n+                (unsigned long long)(intptr_t)_buffer,\n+                _buffer == _small_buffer ? \"(SB)\" : \"\",\n+                (int)_buffer_size,\n+                (int)_line_count,\n+                has_c_heap_buffer());\n+  assert(is_sane(), \"\");\n+}\n+#endif\n+\n+#ifdef ASSERT\n+\/\/ More support for coverage testing.\n+int inputStream::coverage_mode(int start,\n+                               int& cases, int& total, int& zeroes) {\n+  int old_mode = current_coverage_mode;\n+  current_coverage_mode = start;\n+  int num_cases = 0, zero_count = 0, case_count = 0;\n+#define COUNT_COV_CASE(casename) {              \\\n+    int tem = COV_COUNT(casename);              \\\n+    case_count += tem;                          \\\n+    if (tem == 0)  ++zero_count;                \\\n+    num_cases++;                                \\\n+  }\n+  DO_COV_CASES(COUNT_COV_CASE)\n+#undef COUNT_COV_CASE\n+  if (start < 0) {\n+    tty->print(\"istream coverage:\");\n+    #define PRINT_COV_CASE(casename) \\\n+      tty->print(\" %s:%d\", #casename, COV_COUNT(casename));\n+    DO_COV_CASES(PRINT_COV_CASE)\n+    tty->cr();\n+    #undef PRINT_COV_CASE\n+    if (zero_count != 0) {\n+      case_count = -case_count;\n+      #define ZERO_COV_CASE(casename)                  \\\n+        if (COV_COUNT(casename) == 0)                  \\\n+          tty->print_cr(\"%s: no coverage for %s\",      \\\n+                        __FILE__, #casename);          \\\n+      DO_COV_CASES(ZERO_COV_CASE)\n+      #undef ZERO_COV_CASE\n+    }\n+  }\n+  if (start >= 2 || start < 0) {\n+    #define CLEAR_COV_CASE(casename) \\\n+       COV_COUNT(casename) = 0;\n+    DO_COV_CASES(CLEAR_COV_CASE)\n+    #undef CLEAR_COV_CASE\n+  }\n+  cases  = num_cases;\n+  total  = case_count;\n+  zeroes = zero_count;\n+  return old_mode;\n+}\n+#endif \/\/ASSERT\n","filename":"src\/hotspot\/share\/utilities\/istream.cpp","additions":371,"deletions":0,"binary":false,"changes":371,"status":"added"},{"patch":"@@ -0,0 +1,386 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_ISTREAM_HPP\n+#define SHARE_UTILITIES_ISTREAM_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\/\/ Input streams for reading line-oriented textual data. These streams\n+\/\/ treat newline '\\n' very differently from all other bytes.  Carriage\n+\/\/ return '\\r' is just another bit of whitespace, although it is\n+\/\/ removed just before newline.\n+\/\/\n+\/\/ Null '\\0' is just a data byte, although it also terminates C\n+\/\/ strings; the `current_line` function adds a null after removing any\n+\/\/ line terminator but does not specially process any nulls embedded\n+\/\/ in the line.\n+\/\/\n+\/\/ There are sizing access functions which allow lines to contain\n+\/\/ null, but the simpler function assumes null termination, and thus\n+\/\/ lines containing null will \"look\" shorter when viewed as C strings.\n+\/\/ Use the sizing access functions if you care about this.\n+\/\/\n+\/\/ Formatting guidelines:\n+\/\/\n+\/\/ Configuration data should be line-oriented.  It should be readable\n+\/\/ by humans (though perhaps with difficulty).  It should be easily\n+\/\/ processed by text editors and by widely available text processing\n+\/\/ tools such as grep, sed, and awk.\n+\/\/\n+\/\/ Configuration data should not require \"compilers\" to generate, if\n+\/\/ possible.  It should be editable by hand, if possible.  In cases\n+\/\/ where binary data is strongly required, pick a binary format\n+\/\/ already native to Hotspot, such as classfile, jar, or jmod.\n+\/\/\n+\/\/ Each line should be separately parseable; the parsing can be ad\n+\/\/ hoc.  For constructs inherently larger than single lines (such as\n+\/\/ complex method configuration information), try to use a structuring\n+\/\/ principle that allows \"leaf\" data to be line-oriented, and delimits\n+\/\/ that data with markup lines of some sort.  Try to pick a\n+\/\/ line-friendly version of a standard format like XML or Markdown.\n+\/\/ JSON is somewhat problematic because there is no line-friendly leaf\n+\/\/ syntax: everything at the leaves must be a quoted string in JSON.\n+\/\/\n+\/\/ Use simple parsing via scanf-like formats for simple applications.\n+\/\/ But, keep in mind that these formats may lose data when applied to\n+\/\/ unusual strings, such as class names that contain spaces, or method\n+\/\/ names that contain punctuation.  For more robust transmission of\n+\/\/ potentially unusual names, consider wrapping them in XML-flavored\n+\/\/ lines like <tag attr='pay load'\/>.\n+\/\/\n+\/\/ Note: Input streams are never MT-safe.\n+\n+class inputStream : public CHeapObjBase {\n+ public:\n+  class Input;\n+\n+ private:\n+  NONCOPYABLE(inputStream);\n+\n+  static constexpr size_t SMALL_SIZE =  240 DEBUG_ONLY(*0 + 10);\n+  static constexpr size_t BIG_SIZE   = 2048 DEBUG_ONLY(*0 + 20);\n+\n+ protected:\n+  \/\/ Values for _input_state, to distinguish some phases of history:\n+  \/\/ Do we need to read more input (NTR)?  Did we see EOF already?\n+  \/\/ Was there an error getting input or allocating buffer space?\n+  enum class IState : int { NTR_STATE, EOF_STATE, ERR_STATE };\n+\n+  \/\/ Named offset for _next relative to _content_end, of phantom '\\n'.\n+  static const int NEXT_PHANTOM = 1;\n+\n+  Input* _input;   \/\/ where the input comes from or else nullptr\n+  IState _input_state;  \/\/ one of {NTR,EOF,ERR}_STATE\n+  char   _line_ending;  \/\/ one of {0,1,2} for \"\", \"\\n\", \"\\r\\n\"\n+  char*  _buffer;       \/\/ scratch buffer holding at least the current line\n+  size_t _buffer_size;  \/\/ allocated size of buffer\n+  size_t _content_end;  \/\/ offset to end of valid contents of buffer\n+  size_t _beg;          \/\/ offset in buffer to start of current line\n+  size_t _end;          \/\/ offset to end of known current line (else content_end)\n+  size_t _next;         \/\/ offset to known start of next line (else =end)\n+  size_t _line_count;   \/\/ increasing non-resettable count of lines read\n+  char   _small_buffer[SMALL_SIZE];  \/\/ stack-allocated buffer for holding lines;\n+                                     \/\/ will switch to C_HEAP allocation when necessary.\n+\n+  bool has_c_heap_buffer() {\n+    return _buffer != &_small_buffer[0];\n+  }\n+\n+  \/\/ Buffer states\n+  \/\/\n+  \/\/ The current line (less any line ending) is always [beg..end).\n+  \/\/ It is always the case that 0 <= beg <= end <= con_end <= buffer_size.\n+  \/\/ When there is a current line buffered, end < next <= 1+con_end.\n+  \/\/ In that case, the value of next is end + max(1, strlen(lend)),\n+  \/\/ where lend is \"\\n\", \"\\r\\n\", or (for a last partial line) \"\".\n+  \/\/ But if next == end, we need to read more input, or observe an EOF.\n+  \/\/\n+  \/\/   beg ==end ==next ==  con_end => nothing buffered, we need to read\n+  \/\/   beg <=end < next <=  con_end => have current line, with terminator\n+  \/\/   beg < end < next ==1+con_end => have partial current line (saw EOF)\n+  \/\/   beg < end ==next ==  con_end => partial line, we need to read\n+  \/\/   beg ==end < next ==1+con_end => definitely done; no more I\/O\n+  \/\/\n+  \/\/ These states are in three mutually exclusive groups:\n+  \/\/   need_to_read()      <= nothing or partial line in buffer\n+  \/\/   have_current_line() <= beg\/end point to valid line (partial only if EOF)\n+  \/\/   definitely_done()   <= consumed all lines && (hit EOF || hit error)\n+  \/\/ These states are internal; the user can only look at next\/done\/error.\n+  \/\/\n+  \/\/ Relative to these states, everything already read from the input\n+  \/\/ before the first byte of the current line is logically present\n+  \/\/ (but not accessible) before _beg, while everything not yet read\n+  \/\/ from the input is after _content_end.  The difference between\n+  \/\/ these two pointers is constant, except when characters change\n+  \/\/ from being in the current line to being (logically) before it,\n+  \/\/ when next is called.\n+\n+  bool is_sane() const {\n+    assert(_buffer != nullptr, \"\");\n+    assert(_content_end <= _buffer_size, \"\");\n+    assert(_beg <= _end && _end <= _content_end, \"\");\n+    assert(_end <= _next && _next <= _content_end + NEXT_PHANTOM, \"\");\n+    assert(_buffer_size == 0 || _next <= _buffer_size, \"\");\n+    return true;\n+  }\n+\n+  bool need_to_read() const {\n+    assert(is_sane(), \"\");\n+    return _next == _end;\n+  }\n+  bool have_current_line() const {\n+    assert(is_sane(), \"\");\n+    \/\/ _beg < _content_end because there is an \\0 (was \\n) at _end,\n+    \/\/ or else it is a non-empty partial line and the \\0 is at\n+    \/\/ _content_end.  In either case, if _end == _next we are\n+    \/\/ still searching for more input.\n+    return (_beg < _content_end && _end < _next);\n+  }\n+  bool definitely_done() const {\n+    assert(is_sane(), \"\");\n+    \/\/ If _beg < _content_end we still have a line of some sort.\n+    \/\/ Otherwise, if _next > _content_end, we have seen EOF or error.\n+    return (_beg == _content_end && _next > _content_end);\n+  }\n+\n+  \/\/ Reset indexes within the buffer to point to no content.\n+  void clear_buffer();\n+\n+  \/\/ Reset indexes within the buffer to point to the given content.\n+  \/\/ This is where we scan for newlines as well.\n+  void set_buffer_content(size_t content_start, size_t content_end);\n+\n+  \/\/ Try to make the buffer bigger.  This may be necessary in order to\n+  \/\/ buffer a very long line.  Returns false if there was an\n+  \/\/ allocation failure.\n+  \/\/\n+  \/\/ On allocation failure, just make do with whatever buffer there\n+  \/\/ was to start with; the caller must check for this condition and\n+  \/\/ avoid buffering more data in the non-expanded buffer.  However,\n+  \/\/ the buffer will always be non-null, so at least one line can be\n+  \/\/ buffered, if it is of normal size.\n+  bool expand_buffer(size_t new_length);\n+\n+  \/\/ Make sure there is at least one line in the buffer, and set\n+  \/\/ _beg\/_end to indicate where it is.  Any content before _beg can\n+  \/\/ be overwritten to make more room in the buffer.  If there is no\n+  \/\/ more input, set the state up to indicate we are done.\n+  bool fill_buffer();\n+\n+  \/\/ Find some room in the buffer so we can call read on it.\n+  \/\/ This might call expand_buffer but will try not to.\n+  \/\/ The assumption is that read already buffers slow I\/O calls.\n+  \/\/ The purpose for the small buffer managed here is to store whole lines,\n+  \/\/ and perhaps edit them in-place.\n+  void prepare_to_fill_buffer(size_t& fill_offset, size_t& fill_length);\n+\n+  \/\/ Quick check for an initially incomplete buffer...\n+  void preload() const {\n+    if (need_to_read()) {\n+      const_cast<inputStream*>(this)->fill_buffer();\n+    }\n+  }\n+\n+  \/\/ How much content is buffered (if any) after the current line?\n+  size_t buffered_content_length(bool include_current) const {\n+    return (include_current       ? _content_end - _beg :\n+            _content_end >= _next ? _content_end - _next : 0);\n+  }\n+\n+  \/\/ Returns a pointer and count to characters buffered after the\n+  \/\/ current line, but not yet read from my input source.  Only useful\n+  \/\/ if you are trying to stack input streams on top of each other\n+  \/\/ somehow.  You can also ask the input source if it thinks it has\n+  \/\/ more bytes.\n+  const char* next_content(size_t& next_content_length) const;\n+\n+ public:\n+  \/\/ Create an empty input stream.\n+  \/\/ Call push_back_input or set_input to configure.\n+  inputStream() :\n+    _input(nullptr),\n+    _input_state(IState::NTR_STATE),\n+    _line_ending(0),\n+    _buffer(&_small_buffer[0]),\n+    _buffer_size(sizeof(_small_buffer)),\n+    _content_end(0),\n+    _beg(0),\n+    _end(0),\n+    _next(0),\n+    _line_count(0) {}\n+\n+  \/\/ Take input from the given source.  Buffer only a modest amount.\n+  inputStream(Input* input)\n+    : inputStream()\n+  {\n+    set_input(input);\n+  }\n+\n+  virtual ~inputStream();\n+\n+  \/\/ Discards any previous input and sets the given input source.\n+  void set_input(Input* input);\n+\n+  \/\/ Returns a pointer to a null terminated mutable copy of the current line.\n+  \/\/ Note that embedded nulls may make the line appear shorter than it really is.\n+  \/\/ This may trigger input activity if there is not enough data buffered.\n+  \/\/ If there are no more lines, return an empty line, statically allocated.\n+  char* current_line() const {\n+    preload();\n+    if (definitely_done())\n+      return (char*)\"\";\n+    return &_buffer[_beg];\n+  }\n+\n+  \/\/ Return the size of the current line, exclusive of any line terminator.\n+  \/\/ If no lines have been read yet, or there are none remaining, return zero.\n+  size_t current_line_length() const {\n+    preload();\n+    return _end - _beg;\n+  }\n+\n+  \/\/ Reports my current input source, if any, else a null pointer.\n+  Input* input() const { return _input; }\n+\n+  \/\/ Discards the current line, gets ready to report the next line.\n+  \/\/ Returns true if there is one, which is always the opposite of done().\n+  \/\/ Fetches input if necessary.\n+  bool next();\n+\n+  \/\/ Reports if there are no more lines.  Fetches input if necessary.\n+  bool done() const  {\n+    preload();\n+    return definitely_done();\n+  }\n+\n+  \/\/ Discard pending input and do not read any more.\n+  \/\/ Takes no action if already done, whether in an error state or not.\n+  void set_done();\n+\n+  \/\/ Reports if this stream has had an error was reported on it.\n+  bool error() const {\n+    return _input_state == IState::ERR_STATE;\n+  }\n+\n+  \/\/ Set this stream done with an error, if the argument is true.\n+  \/\/ If it is false but there is an error condition, clear the error.\n+  \/\/ Otherwise do nothing.\n+  void set_error(bool error_condition = true);\n+\n+  \/\/ lineno is the 1-based ordinal of the current line; it starts at one\n+  size_t lineno() const         { preload(); return _line_count; }\n+\n+  \/\/ Copy the current line to the given output stream.\n+  void print_on(outputStream* out);\n+\n+  \/\/ Copy the current line to the given output stream, and also call cr().\n+  void print_cr_on(outputStream* out) {\n+    print_on(out); out->cr();\n+  }\n+\n+#ifdef ASSERT\n+  void dump(const char* what = nullptr);\n+  static int coverage_mode(int mode, int& cases, int& total, int& zeroes);\n+#else\n+  void dump(const char* what = nullptr) { }\n+#endif\n+\n+\n+  \/\/ Block-oriented input, which treats all bytes equally.\n+  class Input : public CHeapObjBase {\n+  public:\n+    \/\/ Read some characters from an external source into the line buffer.\n+    \/\/ If there are no more, return zero, otherwise return non-zero.\n+    \/\/ It must be OK to call read even after it returns zero.\n+    virtual size_t read(char* buf, size_t size) = 0;\n+    \/\/ Example: read(b,s) { return fread(b, 1, s, _my_fp); }\n+    \/\/ Example: read(b,s) { return 0; } \/\/ never more than the initial buffer\n+  };\n+};\n+\n+\/\/ for reading lines from files\n+class FileInput : public inputStream::Input {\n+  NONCOPYABLE(FileInput);\n+\n+ protected:\n+  fileStream& _fs;\n+  fileStream _private_fs;\n+\n+  \/\/ it does not seem likely there are such file streams around\n+  FileInput(fileStream& fs)\n+    : _fs(fs)\n+  { }\n+\n+ public:\n+  \/\/ just forward all the constructor arguments to the wrapped line-input class\n+  template<typename... Arg>\n+  FileInput(Arg... arg)\n+    : _fs(_private_fs), _private_fs(arg...)\n+  { }\n+\n+  FileInput(const char* file_name)\n+    : FileInput(file_name, \"rt\")\n+  { }\n+\n+  bool is_open() const { return _fs.is_open(); }\n+\n+ protected:\n+  virtual size_t read(char* buf, size_t size) {\n+    return _fs.read(buf, size);\n+  }\n+};\n+\n+class MemoryInput : public inputStream::Input {\n+  const void* _base;\n+  const size_t _limit;\n+  size_t      _offset;\n+\n+ public:\n+  MemoryInput(const void* base, size_t size,\n+              size_t offset = 0)\n+    : _base(base), _limit(size), _offset(offset) {}\n+\n+  MemoryInput(const char* start)\n+    : MemoryInput(start, 0, strlen(start))\n+  { }\n+\n+ protected:\n+  virtual size_t read(char* buf, size_t size) {\n+    size_t nr = size;\n+    if (nr > _limit - _offset) {\n+      nr = _limit - _offset;\n+    }\n+    if (nr > 0) {\n+      ::memcpy(buf, (char*)_base + _offset, nr);\n+      _offset += nr;\n+    }\n+    return nr;\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_ISTREAM_HPP\n","filename":"src\/hotspot\/share\/utilities\/istream.hpp","additions":386,"deletions":0,"binary":false,"changes":386,"status":"added"},{"patch":"@@ -400,1 +400,1 @@\n-  copy[_written] = 0;  \/\/ terminating null\n+  copy[_written] = '\\0';  \/\/ terminating null\n@@ -593,11 +593,51 @@\n-char* fileStream::readln(char *data, int count ) {\n-  char * ret = nullptr;\n-  if (_file != nullptr) {\n-    ret = ::fgets(data, count, _file);\n-    \/\/ Get rid of annoying \\n char only if it is present.\n-    size_t len = ::strlen(data);\n-    if (len > 0 && data[len - 1] == '\\n') {\n-      data[len - 1] = '\\0';\n-    }\n-  }\n-  return ret;\n+#ifdef _WINDOWS\n+#define ftello _ftelli64\n+#define fseeko _fseeki64\n+#define OFF_T  __int64\n+#endif\n+\n+#ifndef OFF_T\n+#define OFF_T off_t\n+#endif\n+\n+size_t fileStream::position() {\n+  if (_file == nullptr)  return NO_SIZE;\n+#if _LP64\n+  typedef OFF_T position_t;\n+  position_t p = ::ftello(_file);\n+#else\n+  typedef long position_t;\n+  position_t p = ::ftell(_file);\n+#endif\n+  if (p == (position_t) -1)  return NO_SIZE;\n+  size_t result = (size_t) p;\n+  if (p != (position_t) result)  return NO_SIZE;\n+  return (size_t) p;\n+}\n+\n+size_t fileStream::set_position(size_t position) {\n+  if (_file == nullptr)  return NO_SIZE;\n+  int res = -1;\n+#if _LP64\n+  res = ::fseeko(_file, (OFF_T) position, SEEK_SET);\n+#else\n+  res = ::fseek(_file, (long) position, SEEK_SET);\n+#endif\n+  if (res != 0)  return NO_SIZE;\n+  \/\/ re-read position; why not...\n+  return this->position();\n+}\n+\n+size_t fileStream::remaining() {\n+  if (_file == nullptr)  return -1;\n+  size_t p1 = position();\n+  if (p1 == NO_SIZE)  return p1;\n+  if (::fseek(_file, 0, SEEK_END) != 0) {\n+    return NO_SIZE;\n+  }\n+  size_t p2 = position();\n+  p1 = set_position(p1);\n+  if (p2 == NO_SIZE || p1 == NO_SIZE) {\n+    return NO_SIZE;\n+  }\n+  return (p2 < p1) ? 0 : p2 - p1;\n@@ -608,2 +648,2 @@\n-    if (_need_close) fclose(_file);\n-    _file      = nullptr;\n+    close();\n+    _file = nullptr;\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":54,"deletions":14,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,0 +238,1 @@\n+  static constexpr size_t NO_SIZE = (size_t) -1;  \/\/ sentinel for query gone wrong\n@@ -245,3 +246,13 @@\n-  size_t read(void *data, size_t size, size_t count) { return _file != nullptr ? ::fread(data, size, count, _file) : 0; }\n-  char* readln(char *data, int count);\n-  int eof() { return _file != nullptr ? feof(_file) : -1; }\n+  \/\/ unlike other classes in this file, fileStream can perform input as well as output\n+  size_t read(void* data, size_t size) {\n+    if (_file == nullptr)  return 0;\n+    return ::fread(data, 1, size, _file);\n+  }\n+  size_t read(void *data, size_t size, size_t count) {\n+    return read(data, size * count);\n+  }\n+  void close() {\n+    if (_file == nullptr || !_need_close)  return;\n+    fclose(_file);\n+    _need_close = false;\n+  }\n@@ -249,1 +260,0 @@\n-  void rewind() { if (_file != nullptr) ::rewind(_file); }\n@@ -251,0 +261,3 @@\n+  size_t position();  \/\/ return NO_SIZE on failure\n+  size_t set_position(size_t position);  \/\/ return new position or NO_SIZE on failure\n+  size_t remaining();  \/\/ return remaining file size or NO_SIZE on failure\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,322 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/istream.hpp\"\n+#include \"unittest.hpp\"\n+\n+template<typename BlockClass>\n+class BlockInputStream : public inputStream {\n+  BlockClass _input;\n+ public:\n+  template<typename... Arg>\n+  BlockInputStream(Arg... arg)\n+    : _input(arg...) {\n+    set_input(&_input);\n+  }\n+};\n+\n+#define EXPECT_MEMEQ(s1, s2, len) \\\n+  EXPECT_PRED_FORMAT3(CmpHelperMEMEQ, s1, s2, len)\n+\/\/ cf. ::testing::internal::CmpHelperSTREQ\n+\n+testing::AssertionResult CmpHelperMEMEQ(const char* s1_expression,\n+                                        const char* s2_expression,\n+                                        const char* len_expression,\n+                                        const char* s1, const char* s2,\n+                                        size_t len) {\n+  if (s1 == nullptr || s2 == nullptr) {\n+    return testing::internal::CmpHelperEQ(s1_expression, s2_expression,\n+                                          s1, s2);\n+  }\n+  int c = ::memcmp(s1, s2, len);\n+  if (c == 0) {\n+    return testing::AssertionSuccess();\n+  }\n+  ::std::string str1, str2;\n+  for (auto which = 0; which <= 1; which++) {\n+    auto  s   = which ? s1   : s2;\n+    auto &str = which ? str1 : str2;\n+    std::stringstream buf;\n+    buf << \"{\";\n+    for (size_t i = 0; i < len; i++) {\n+      char c = s[i];\n+      switch (c) {\n+      case '\\0':  buf << \"\\\\0\"; break;\n+      case '\\n':  buf << \"\\\\n\"; break;\n+      case '\\\\':  buf << \"\\\\\\\\\"; break;\n+      default:    buf << c; break;\n+      }\n+    }\n+    buf << \"}[\" << len_expression << \"=\" << len << \"]\";\n+    str = buf.str();\n+  }\n+  return testing::internal::CmpHelperSTREQ(s1_expression, s2_expression,\n+                                           str1.c_str(), str2.c_str());\n+}\n+\n+static int firstdiff(char* b1, char* b2, int blen) {\n+  for (int i = 0; i < blen; i++) {\n+    if (b1[i] != b2[i])  return i;\n+  }\n+  return -1;\n+}\n+\n+static char* get_temp_file(bool VERBOSE, const char* filename) {\n+  const char* tmp_dir = os::get_temp_directory();\n+  const char* file_sep = os::file_separator();\n+  size_t temp_file_len = strlen(tmp_dir) + strlen(file_sep) + strlen(filename) + 28;\n+  char* temp_file = NEW_C_HEAP_ARRAY(char, temp_file_len, mtInternal);\n+  int ret = jio_snprintf(temp_file, temp_file_len, \"%s%spid%d.%s\",\n+                         tmp_dir, file_sep,\n+                         os::current_process_id(), filename);\n+  if (VERBOSE)  tty->print_cr(\"temp_file = %s\", temp_file);\n+  return temp_file;\n+}\n+\n+static const char* get_temp_file(bool VERBOSE) {\n+  static const char* temp_file = get_temp_file(VERBOSE, \"test_istream\");\n+  return temp_file;\n+}\n+\n+#define EIGHTY 80\n+#define LC0(x)     ('\/' + (((unsigned)(x)+1) % EIGHTY))\n+#define LC(line,col)  LC0((col) * (line))\n+\n+#define COLS 30\n+\n+static int cases, total, zeroes;\n+#ifdef ASSERT\n+#define istream_coverage_mode(mode, a,b,c) \\\n+  inputStream::coverage_mode(mode, a,b,c)\n+#else\n+#define istream_coverage_mode(mode, a,b,c)\n+#endif\n+\n+\/\/ Fill in a test pattern of ascii characters.\n+\/\/ Each line is ncols long, plus a line termination of lelen (1 or 2).\n+\/\/ Each character is a fixed, static function of the line and column.\n+\/\/ This enables test logic to predict exactly what will be read in each line.\n+static void fill_pattern(bool VERBOSE,\n+                         char* pat, int patlen, int ncols, int lelen,\n+                         int& full_lines, int& partial_line,\n+                         const char* &line_end,\n+                         const char* &partial_line_end) {\n+  full_lines = partial_line = 0;\n+  for (int i = 0; i < patlen; i++) {\n+    int line = (i \/ (ncols+lelen)) + 1;  \/\/ 1-based line number\n+    int col  = (i % (ncols+lelen)) + 1;  \/\/ 1-based column number\n+    if (col <= ncols) {\n+      pat[i] = LC(line, col);\n+      partial_line = 1;\n+    } else if (col < ncols+lelen) {\n+      pat[i] = i == patlen - 1 ? '!' : '%';\n+      partial_line = 1;\n+    } else {\n+      assert(col == ncols+lelen, \"\");\n+      pat[i] = '!';\n+      full_lines++;\n+      partial_line = 0;\n+    }\n+  }\n+  pat[patlen] = '\\0';\n+  if (VERBOSE)  tty->print_cr(\"PATTERN=%d+%d[%s]\",\n+                              full_lines, partial_line, pat);\n+  for (int i = 0; i < patlen; i++) {\n+    assert(pat[i] != '%' || (i+1 < patlen && pat[i+1] == '!'), \"\");\n+    if (pat[i] == '!')  pat[i] = '\\n';\n+    if (pat[i] == '%')  pat[i] = '\\r';\n+  }\n+  assert(pat[patlen-1] != '\\r', \"\");\n+\n+  line_end = (lelen == 2 ? \"\\r\\n\" : \"\\n\");\n+  int partial_line_bytes = patlen - (full_lines * (ncols + lelen));\n+  assert(partial_line_bytes < ncols + lelen, \"\");\n+  partial_line_end = (partial_line_bytes == ncols + 1) ? \"\\n\" : \"\";\n+}\n+\n+static const int MAX_PATLEN = COLS * (COLS-1);\n+\n+static void istream_test_driver(const bool VERBOSE,\n+                                const int patlen,\n+                                const int ncols,\n+                                const int lelen,\n+                                const bool TEST_SET_POSITION,\n+                                const bool TEST_PUSH_BACK,\n+                                const bool TEST_EXPAND_REDUCE) {\n+  DEBUG_ONLY( istream_coverage_mode(VERBOSE ? 2 : 1, cases, total, zeroes) );\n+  const char* temp_file = get_temp_file(VERBOSE);\n+  unlink(temp_file);\n+  char pat[MAX_PATLEN+1];\n+  int full_lines = 0, partial_line = 0;\n+  const char* line_end = \"\\n\";\n+  const char* partial_line_end = \"\";\n+  fill_pattern(VERBOSE, pat, patlen, ncols, lelen,\n+               full_lines, partial_line,\n+               line_end, partial_line_end);\n+\n+  char pat2[sizeof(pat)];  \/\/ copy of pat to help detect scribbling\n+  memcpy(pat2, pat, sizeof(pat));\n+  \/\/ Make three kinds of stream and test them all.\n+  MemoryInput _min(pat2, patlen);\n+  inputStream sin(&_min);\n+  if (VERBOSE) {\n+    tty->print(\"at %llx \", (unsigned long long)(intptr_t)&sin);\n+    sin.dump(\"sin\");\n+  }\n+  {\n+    fileStream tfs(temp_file);\n+    guarantee(tfs.is_open(), \"cannot open temp file\");\n+    tfs.write(pat, patlen);\n+  }\n+  BlockInputStream<FileInput> fin(temp_file);\n+  if (VERBOSE) {\n+    tty->print(\"at %llx \", (unsigned long long)(intptr_t)&fin);\n+    fin.dump(\"fin\");\n+  }\n+  BlockInputStream<MemoryInput> min(&pat2[0], patlen);\n+  if (VERBOSE) {\n+    tty->print(\"at %llx \", (unsigned long long)(intptr_t)&min);\n+    sin.dump(\"min\");\n+  }\n+  inputStream* ins[] = { &sin, &fin, &min };\n+  const char* in_names[] = { \"sin\", \"fin\", \"min\" };\n+  const char* test_mode = (TEST_SET_POSITION\n+                           ? (!TEST_PUSH_BACK ? \"(seek)\" : \"(seek\/push)\")\n+                           : TEST_EXPAND_REDUCE\n+                           ? (!TEST_PUSH_BACK ? \"(exp\/red)\" : \"(exp\/red\/push)\")\n+                           : (!TEST_PUSH_BACK ? \"(plain)\" : \"(push)\"));\n+  for (int which = 0; which < 3; which++) {\n+    inputStream& in = *ins[which];\n+    const char* in_name = in_names[which];\n+    int lineno;\n+    char* lp = (char*)\"--\";\n+#define LPEQ                                                    \\\n+    in_name << test_mode                                        \\\n+            << \" ncols=\" << ncols << \" lelen=\" << lelen         \\\n+            << \" full=\" << full_lines << \" lineno=\" << lineno   \\\n+            << \" [\" << lp << \"]\" << (in.dump(\"expect\"), \"\")\n+    if (VERBOSE)\n+      tty->print_cr(\"testing %s%s patlen=%d ncols=%d full_lines=%d partial_line=%d\",\n+                    in_name, test_mode,\n+                    patlen, ncols, full_lines, partial_line);\n+    int pos_to_set = 0, line_to_set = 1;  \/\/ for TEST_SET_POSITION only\n+    for (int phase = 0; phase <= (TEST_SET_POSITION ? 1 : 0); phase++) {\n+      lineno = 1;\n+      for (; lineno <= full_lines + partial_line; lineno++) {\n+        EXPECT_EQ(-1, firstdiff(pat, pat2, patlen + 1));\n+        if (VERBOSE)  in.dump(\"!done?\");\n+        bool done = in.done();\n+        EXPECT_TRUE(!done)  <<LPEQ;\n+        if (done)  break;\n+        lp = in.current_line();\n+        const char* expect_endl =\n+          (lineno <= full_lines) ? line_end : partial_line_end;\n+\n+        bool verify_lp = true;\n+        if (verify_lp) {\n+          int actual_lineno = (int) in.lineno();\n+          if (VERBOSE)  in.dump(\"CL    \");\n+          EXPECT_EQ(actual_lineno, lineno)  <<LPEQ;\n+          int len = (int) in.current_line_length();\n+          EXPECT_EQ(len, (int) strlen(lp))  <<LPEQ;\n+          int expect_len = ncols;\n+          if (lineno > full_lines)\n+            expect_len = MIN2(ncols, patlen % (ncols+lelen));\n+          EXPECT_EQ(len, expect_len)  <<LPEQ;\n+          for (int j = 0; j < len; j++) {\n+            int lc = LC(lineno, j+1);   \/\/ 1-based column\n+            EXPECT_EQ(lc, lp[j])  <<LPEQ;\n+          }\n+          if (len != expect_len || len != (int)strlen(lp)) {\n+            return;  \/\/ no error cascades please\n+          }\n+        }\n+        if (VERBOSE)  in.dump(\"next  \");\n+        in.next();\n+      }\n+\n+      for (int done_test = 0; done_test <= 3; done_test++) {\n+        if (done_test == 2)  in.set_done();\n+        lp = in.current_line();  \/\/ should be empty line\n+        if (VERBOSE)  in.dump(\"done!!\");\n+        EXPECT_TRUE(lp != nullptr);\n+        EXPECT_TRUE(in.done())  <<LPEQ;\n+        if (!in.done())  break;\n+        EXPECT_EQ((int)in.current_line_length(), 0)   <<LPEQ;\n+        EXPECT_EQ(strlen(lp), in.current_line_length())  <<LPEQ;\n+        bool extra_next = in.next();\n+        EXPECT_TRUE(!extra_next)  <<LPEQ;\n+      }\n+\n+      \/\/ no memory side effects\n+      EXPECT_EQ(-1, firstdiff(pat, pat2, patlen + 1));\n+    }\n+  }\n+  unlink(temp_file);\n+}\n+\n+static void istream_test_driver(const bool VERBOSE,\n+                                const bool TEST_SET_POSITION,\n+                                const bool TEST_PUSH_BACK,\n+                                const bool TEST_EXPAND_REDUCE) {\n+  ResourceMark rm;\n+  int patlen = MAX_PATLEN;\n+  const bool SHORT_TEST = false;\n+  const int SHORT_NCOLS = 1, SHORT_PATLEN = 37;\n+  if (SHORT_TEST)  patlen = SHORT_PATLEN;\n+  for (int ncols = 0; ncols <= patlen; ncols++) {\n+    if (SHORT_TEST) {\n+      if (ncols < SHORT_NCOLS)  ncols = SHORT_NCOLS;\n+      if (ncols > SHORT_NCOLS)  break;\n+    } else if (ncols > COLS && ncols < patlen - COLS) {\n+      ncols += ncols \/ 7;\n+      if (ncols > patlen - COLS)  ncols = (patlen - COLS);\n+    }\n+    for (int lelen = 1; lelen <= 2; lelen++) {  \/\/ try both kinds of newline\n+      istream_test_driver(VERBOSE,\n+                          patlen, ncols, lelen,\n+                          TEST_SET_POSITION, TEST_PUSH_BACK, TEST_EXPAND_REDUCE);\n+    }\n+  }\n+}\n+\n+TEST_VM(istream, basic) {\n+  const bool VERBOSE = false;\n+  istream_test_driver(VERBOSE, false, false, false);\n+}\n+\n+TEST_VM(istream, coverage) {\n+  const bool VERBOSE = false;\n+#ifdef ASSERT\n+  istream_coverage_mode(0, cases, total, zeroes);\n+  if (cases == 0)  return;\n+  if (VERBOSE || zeroes != 0)\n+    istream_coverage_mode(-1, cases, total, zeroes);\n+  EXPECT_EQ(zeroes, 0) << \"zeroes: \" << zeroes << \"\/\" << cases;\n+#endif \/\/ASSERT\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_istream.cpp","additions":322,"deletions":0,"binary":false,"changes":322,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,6 @@\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+\n@@ -97,1 +103,1 @@\n-            \"TESTCASE A6: extraneous spaces, tab characters and trailing new line characters\",\n+            \"TESTCASE A6: extraneous spaces, tab characters, trailing new line characters, and trailing comment line\",\n@@ -104,1 +110,2 @@\n-                \"CustomLoadee2 id: 5 super: 1 interfaces: 3 4 source: \" + customJarPath      \/\/ preceding spaces\n+                \"CustomLoadee2 id: 5 super: 1 interfaces: 3 4 source: \" + customJarPath,      \/\/ preceding spaces\n+                \"#last line is a comment\"\n@@ -107,5 +114,6 @@\n-        int _max_allowed_line = 4096; \/\/ Must match ClassListParser::_max_allowed_line in C code.\n-        int _line_buf_extra = 10;     \/\/ Must match ClassListParser::_line_buf_extra in C code.\n-        StringBuffer sbuf = new StringBuffer();\n-        for (int i=0; i<_max_allowed_line+1; i++) {\n-          sbuf.append(\"x\");\n+        \/\/ Tests for corner cases in the C++ class LineReader, or invalid UTF8. These can't\n+        \/\/ be tested with dumpShouldPass\/dumpShouldFail as we need to prepare a special class\n+        \/\/ list file.\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < 6500; i++) {\n+            sb.append(\"X123456789\");\n@@ -114,6 +122,12 @@\n-        dumpShouldFail(\n-            \"TESTCASE A7: bad input - line too long\",\n-            appJar, classlist(\n-                sbuf.toString()\n-            ),\n-            \"input line too long (must be no longer than \" + _max_allowed_line + \" chars\");\n+        {\n+            System.out.println(\"TESTCASE A7.1: Long line (65000 chars)\");\n+            String longName = sb.toString(); \/\/ 65000 chars long\n+            String classList = \"LongLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(longName + \"\\n\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchiveAndCheck(opts)\n+                .shouldContain(\"Preload Warning: Cannot find \" + longName);\n+        }\n@@ -121,2 +135,13 @@\n-        for (int i=0; i<_line_buf_extra + 1000; i++) {\n-          sbuf.append(\"X\");\n+        {\n+            System.out.println(\"TESTCASE A7.2: Name Length > Symbol::max_length()\");\n+            String tooLongName = sb.toString() + sb.toString();\n+            String classList = \"TooLongLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(\"java\/lang\/Object\\n\");\n+                fw.write(tooLongName + \"\\n\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchive(opts)\n+                .shouldContain(classList + \":2 class name too long\") \/\/ test line number as well.\n+                .shouldHaveExitValue(1);\n@@ -125,6 +150,24 @@\n-        dumpShouldFail(\n-            \"TESTCASE A8: bad input - line too long: try to overflow C buffer\",\n-            appJar, classlist(\n-                sbuf.toString()\n-            ),\n-            \"input line too long (must be no longer than \" + _max_allowed_line + \" chars\");\n+        {\n+            System.out.println(\"TESTCASE A7.3: File doesn't end with newline\");\n+            String classList = \"NoTrailingNewLine.classlist\";\n+            try (FileWriter fw = new FileWriter(classList)) {\n+                fw.write(\"No\/Such\/ClassABCD\");\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchiveAndCheck(opts)\n+                .shouldContain(\"Preload Warning: Cannot find No\/Such\/ClassABCD\");\n+        }\n+        {\n+            System.out.println(\"TESTCASE A7.4: invalid UTF8 character\");\n+            String classList = \"BadUTF8.classlist\";\n+            try (FileOutputStream fos = new FileOutputStream(classList)) {\n+                byte chars[] = new byte[] { (byte)0xa0, (byte)0xa1, '\\n'};\n+                fos.write(chars);\n+            }\n+            CDSOptions opts = (new CDSOptions())\n+                .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList, \"-Xlog:cds\");\n+            CDSTestUtils.createArchive(opts)\n+                .shouldContain(classList + \":1 class name is not valid UTF8\") \/\/ test line number as well.\n+                .shouldHaveExitValue(1);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatA.java","additions":65,"deletions":22,"binary":false,"changes":87,"status":"modified"}]}