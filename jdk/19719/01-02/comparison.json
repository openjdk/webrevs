{"files":[{"patch":"@@ -28,0 +28,2 @@\n+#include \"opto\/vtransform.hpp\"\n+#include \"opto\/superwordVTransformBuilder.hpp\"\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,3 +24,2 @@\n-module net.foo {\n-    requires jdk.jfr;\n-}\n+#include \"opto\/superwordVTransformBuilder.hpp\"\n+\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"test\/jdk\/tools\/jlink\/plugins\/SystemModuleDescriptors\/src\/net.foo\/module-info.java","status":"copied"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"opto\/vtransform.hpp\"\n+\n+#ifndef SHARE_OPTO_SUPERWORD_VTRANSFORM_BUILDER_HPP\n+#define SHARE_OPTO_SUPERWORD_VTRANSFORM_BUILDER_HPP\n+\n+\n+#endif \/\/ SHARE_OPTO_SUPERWORD_VTRANSFORM_BUILDER_HPP\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -1789,413 +1789,0 @@\n-void VTransformGraph::add_vtnode(VTransformNode* vtnode) {\n-  assert(vtnode->_idx == _vtnodes.length(), \"position must match idx\");\n-  _vtnodes.push(vtnode);\n-}\n-\n-\/\/ Compute a linearization of the graph. We do this with a reverse-post-order of a DFS.\n-\/\/ This only works if the graph is a directed acyclic graph (DAG). The C2 graph, and\n-\/\/ the VLoopDependencyGraph are both DAGs, but after introduction of vectors\/packs, the\n-\/\/ graph has additional constraints which can introduce cycles. Example:\n-\/\/\n-\/\/                                                       +--------+\n-\/\/  A -> X                                               |        v\n-\/\/                     Pack [A,B] and [X,Y]             [A,B]    [X,Y]\n-\/\/  Y -> B                                                 ^        |\n-\/\/                                                         +--------+\n-\/\/\n-\/\/ We return \"true\" IFF we find no cycle, i.e. if the linearization succeeds.\n-bool VTransformGraph::schedule() {\n-  assert(_schedule.is_empty(), \"not yet scheduled\");\n-\n-#ifndef PRODUCT\n-  if (_is_trace_verbose) {\n-    print_vtnodes();\n-  }\n-#endif\n-\n-  ResourceMark rm;\n-  GrowableArray<VTransformNode*> stack;\n-  VectorSet pre_visited;\n-  VectorSet post_visited;\n-\n-  schedule_collect_nodes_without_req_or_dependency(stack);\n-\n-  \/\/ We create a reverse-post-visit order. This gives us a linearization, if there are\n-  \/\/ no cycles. Then, we simply reverse the order, and we have a schedule.\n-  int rpo_idx = _vtnodes.length() - 1;\n-  while (!stack.is_empty()) {\n-    VTransformNode* vtn = stack.top();\n-    if (!pre_visited.test_set(vtn->_idx)) {\n-      \/\/ Forward arc in graph (pre-visit).\n-    } else if (!post_visited.test(vtn->_idx)) {\n-      \/\/ Forward arc in graph. Check if all uses were already visited:\n-      \/\/   Yes -> post-visit.\n-      \/\/   No  -> we are mid-visit.\n-      bool all_uses_already_visited = true;\n-\n-      for (int i = 0; i < vtn->outs(); i++) {\n-        VTransformNode* use = vtn->out(i);\n-        if (post_visited.test(use->_idx)) { continue; }\n-        if (pre_visited.test(use->_idx)) {\n-          \/\/ Circle detected!\n-          \/\/ The nodes that are pre_visited but not yet post_visited form a path from\n-          \/\/ the \"root\" to the current vtn. Now, we are looking at an edge (vtn, use),\n-          \/\/ and discover that use is also pre_visited but not post_visited. Thus, use\n-          \/\/ lies on that path from \"root\" to vtn, and the edge (vtn, use) closes a\n-          \/\/ circle.\n-          NOT_PRODUCT(if (_is_trace_rejections) { trace_schedule_cycle(stack, pre_visited, post_visited); } )\n-          return false;\n-        }\n-        stack.push(use);\n-        all_uses_already_visited = false;\n-      }\n-\n-      if (all_uses_already_visited) {\n-        stack.pop();\n-        post_visited.set(vtn->_idx);           \/\/ post-visit\n-        _schedule.at_put_grow(rpo_idx--, vtn); \/\/ assign rpo_idx\n-      }\n-\n-    } else {\n-      stack.pop(); \/\/ Already post-visited. Ignore secondary edge.\n-    }\n-  }\n-\n-#ifndef PRODUCT\n-  if (_is_trace_verbose) {\n-    print_schedule();\n-  }\n-#endif\n-\n-  assert(rpo_idx == -1, \"used up all rpo_idx, rpo_idx=%d\", rpo_idx);\n-  return true;\n-}\n-\n-\/\/ Push all \"root\" nodes, i.e. those that have no inputs (req or dependency):\n-void VTransformGraph::schedule_collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const {\n-  for (int i = 0; i < _vtnodes.length(); i++) {\n-    VTransformNode* vtn = _vtnodes.at(i);\n-    if (!vtn->has_req_or_dependency()) {\n-      stack.push(vtn);\n-    }\n-  }\n-}\n-\n-#ifndef PRODUCT\n-void VTransformGraph::trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n-                                           const VectorSet& pre_visited,\n-                                           const VectorSet& post_visited) const {\n-  tty->print_cr(\"\\nVTransformGraph::schedule found a cycle on path (P), vectorization attempt fails.\");\n-  for (int j = 0; j < stack.length(); j++) {\n-    VTransformNode* n = stack.at(j);\n-    bool on_path = pre_visited.test(n->_idx) && !post_visited.test(n->_idx);\n-    tty->print(\"  %s \", on_path ? \"P\" : \"_\");\n-    n->print();\n-  }\n-}\n-\n-void VTransformApplyResult::trace(VTransformNode* vtn) const {\n-  tty->print(\"  apply: \");\n-  vtn->print();\n-  tty->print(\"    ->   \");\n-  if (_node == nullptr) {\n-    tty->print_cr(\"nullptr\");\n-  } else {\n-    _node->dump();\n-  }\n-}\n-#endif\n-\n-Node* VTransformNode::find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* n = vnode_idx_to_transformed_node.at(in(i)->_idx);\n-  assert(n != nullptr, \"must find input IR node\");\n-  return n;\n-}\n-\n-VTransformApplyResult VTransformScalarNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n-  return VTransformApplyResult::make_scalar(_node);\n-}\n-\n-VTransformApplyResult VTransformReplicateNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n-  VectorNode* vn = VectorNode::scalar2vector(val, _vlen, _element_type);\n-  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n-  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n-}\n-\n-VTransformApplyResult VTransformConvI2LNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n-  Node* n = new ConvI2LNode(val);\n-  register_new_node_from_vectorization(vloop_analyzer, n, val);\n-  return VTransformApplyResult::make_scalar(n);\n-}\n-\n-VTransformApplyResult VTransformShiftCountNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  Node* shift_count_in = find_transformed_input(1, vnode_idx_to_transformed_node);\n-  assert(shift_count_in->bottom_type()->isa_int(), \"int type only for shift count\");\n-  \/\/ The shift_count_in would be automatically truncated to the lowest _mask\n-  \/\/ bits in a scalar shift operation. But vector shift does not truncate, so\n-  \/\/ we must apply the mask now.\n-  Node* shift_count_masked = new AndINode(shift_count_in, phase->igvn().intcon(_mask));\n-  register_new_node_from_vectorization(vloop_analyzer, shift_count_masked, shift_count_in);\n-  \/\/ Now that masked value is \"boadcast\" (some platforms only set the lowest element).\n-  VectorNode* vn = VectorNode::shift_count(_shift_opcode, shift_count_masked, _vlen, _element_bt);\n-  register_new_node_from_vectorization(vloop_analyzer, vn, shift_count_in);\n-  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n-}\n-\n-\n-VTransformApplyResult VTransformPopulateIndexNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n-  assert(val->is_Phi(), \"expected to be iv\");\n-  assert(VectorNode::is_populate_index_supported(_element_bt), \"should support\");\n-  const TypeVect* vt = TypeVect::make(_element_bt, _vlen);\n-  VectorNode* vn = new PopulateIndexNode(val, phase->igvn().intcon(1), vt);\n-  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n-  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n-}\n-\n-VTransformApplyResult VTransformElementWiseVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* first = nodes().at(0);\n-  uint  vlen = nodes().length();\n-  int   opc  = first->Opcode();\n-  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n-\n-  if (first->is_Cmp()) {\n-    \/\/ Cmp + Bool -> VectorMaskCmp\n-    \/\/ Handled by Bool \/ VTransformBoolVectorNode, so we do not generate any nodes here.\n-    return VTransformApplyResult::make_empty();\n-  }\n-\n-  assert(2 <= req() && req() <= 4, \"Must have 1-3 inputs\");\n-  VectorNode* vn = nullptr;\n-  Node* in1 =                find_transformed_input(1, vnode_idx_to_transformed_node);\n-  Node* in2 = (req() >= 3) ? find_transformed_input(2, vnode_idx_to_transformed_node) : nullptr;\n-  Node* in3 = (req() >= 4) ? find_transformed_input(3, vnode_idx_to_transformed_node) : nullptr;\n-\n-  if (first->is_CMove()) {\n-    assert(req() == 4, \"three inputs expected: mask, blend1, blend2\");\n-    vn = new VectorBlendNode(\/* blend1 *\/ in2, \/* blend2 *\/ in3, \/* mask *\/ in1);\n-  } else if (VectorNode::is_convert_opcode(opc)) {\n-    assert(first->req() == 2 && req() == 2, \"only one input expected\");\n-    int vopc = VectorCastNode::opcode(opc, in1->bottom_type()->is_vect()->element_basic_type());\n-    vn = VectorCastNode::make(vopc, in1, bt, vlen);\n-  } else if (VectorNode::can_use_RShiftI_instead_of_URShiftI(first, bt)) {\n-    opc = Op_RShiftI;\n-    vn = VectorNode::make(opc, in1, in2, vlen, bt);\n-  } else if (VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc)) {\n-    \/\/ The scalar operation was a long -> int operation.\n-    \/\/ However, the vector operation is long -> long.\n-    VectorNode* long_vn = VectorNode::make(opc, in1, nullptr, vlen, T_LONG);\n-    register_new_node_from_vectorization(vloop_analyzer, long_vn, first);\n-    \/\/ Cast long -> int, to mimic the scalar long -> int operation.\n-    vn = VectorCastNode::make(Op_VectorCastL2X, long_vn, T_INT, vlen);\n-  } else if (req() == 3 ||\n-             VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc)) {\n-    assert(!VectorNode::is_roundopD(first) || in2->is_Con(), \"rounding mode must be constant\");\n-    vn = VectorNode::make(opc, in1, in2, vlen, bt); \/\/ unary and binary\n-  } else {\n-    assert(req() == 4, \"three inputs expected\");\n-    assert(opc == Op_FmaD ||\n-           opc == Op_FmaF ||\n-           opc == Op_SignumF ||\n-           opc == Op_SignumD,\n-           \"element wise operation must be from this list\");\n-    vn = VectorNode::make(opc, in1, in2, in3, vlen, bt); \/\/ ternary\n-  }\n-\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n-  return VTransformApplyResult::make_vector(vn, vlen, vn->length_in_bytes());\n-}\n-\n-VTransformApplyResult VTransformBoolVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  BoolNode* first = nodes().at(0)->as_Bool();\n-  uint  vlen = nodes().length();\n-  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n-\n-  \/\/ Cmp + Bool -> VectorMaskCmp\n-  VTransformElementWiseVectorNode* vtn_cmp = in(1)->isa_ElementWiseVector();\n-  assert(vtn_cmp != nullptr && vtn_cmp->nodes().at(0)->is_Cmp(),\n-         \"bool vtn expects cmp vtn as input\");\n-\n-  Node* cmp_in1 = vtn_cmp->find_transformed_input(1, vnode_idx_to_transformed_node);\n-  Node* cmp_in2 = vtn_cmp->find_transformed_input(2, vnode_idx_to_transformed_node);\n-  BoolTest::mask mask = test()._mask;\n-\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  ConINode* mask_node  = phase->igvn().intcon((int)mask);\n-  const TypeVect* vt = TypeVect::make(bt, vlen);\n-  VectorNode* vn = new VectorMaskCmpNode(mask, cmp_in1, cmp_in2, mask_node, vt);\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n-  return VTransformApplyResult::make_vector(vn, vlen, vn->vect_type()->length_in_bytes());\n-}\n-\n-VTransformApplyResult VTransformReductionVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  Node* first = nodes().at(0);\n-  uint  vlen = nodes().length();\n-  int   opc  = first->Opcode();\n-  BasicType bt = first->bottom_type()->basic_type();\n-\n-  Node* init = find_transformed_input(1, vnode_idx_to_transformed_node);\n-  Node* vec  = find_transformed_input(2, vnode_idx_to_transformed_node);\n-\n-  ReductionNode* vn = ReductionNode::make(opc, nullptr, init, vec, bt);\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n-  return VTransformApplyResult::make_vector(vn, vlen, vn->vect_type()->length_in_bytes());\n-}\n-\n-VTransformApplyResult VTransformLoadVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  LoadNode* first = nodes().at(0)->as_Load();\n-  uint  vlen = nodes().length();\n-  Node* ctrl = first->in(MemNode::Control);\n-  Node* mem  = first->in(MemNode::Memory);\n-  Node* adr  = first->in(MemNode::Address);\n-  int   opc  = first->Opcode();\n-  const TypePtr* adr_type = first->adr_type();\n-  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n-\n-  \/\/ Set the memory dependency of the LoadVector as early as possible.\n-  \/\/ Walk up the memory chain, and ignore any StoreVector that provably\n-  \/\/ does not have any memory dependency.\n-  while (mem->is_StoreVector()) {\n-    VPointer p_store(mem->as_Mem(), vloop_analyzer.vloop());\n-    if (p_store.overlap_possible_with_any_in(nodes())) {\n-      break;\n-    } else {\n-      mem = mem->in(MemNode::Memory);\n-    }\n-  }\n-\n-  LoadVectorNode* vn = LoadVectorNode::make(opc, ctrl, mem, adr, adr_type, vlen, bt,\n-                                            control_dependency());\n-  DEBUG_ONLY( if (VerifyAlignVector) { vn->set_must_verify_alignment(); } )\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n-  return VTransformApplyResult::make_vector(vn, vlen, vn->memory_size());\n-}\n-\n-VTransformApplyResult VTransformStoreVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n-  StoreNode* first = nodes().at(0)->as_Store();\n-  uint  vlen = nodes().length();\n-  Node* ctrl = first->in(MemNode::Control);\n-  Node* mem  = first->in(MemNode::Memory);\n-  Node* adr  = first->in(MemNode::Address);\n-  int   opc  = first->Opcode();\n-  const TypePtr* adr_type = first->adr_type();\n-\n-  Node* value = find_transformed_input(MemNode::ValueIn, vnode_idx_to_transformed_node);\n-  StoreVectorNode* vn = StoreVectorNode::make(opc, ctrl, mem, adr, adr_type, value, vlen);\n-  DEBUG_ONLY( if (VerifyAlignVector) { vn->set_must_verify_alignment(); } )\n-  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n-  return VTransformApplyResult::make_vector(vn, vlen, vn->memory_size());\n-}\n-\n-void VTransformVectorNode::register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  Node* first = nodes().at(0);\n-\n-  register_new_node_from_vectorization(vloop_analyzer, vn, first);\n-\n-  for (int i = 0; i < _nodes.length(); i++) {\n-    Node* n = _nodes.at(i);\n-    phase->igvn().replace_node(n, vn);\n-  }\n-}\n-\n-void VTransformNode::register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const {\n-  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n-  phase->register_new_node_with_ctrl_of(vn, old_node);\n-  phase->igvn()._worklist.push(vn);\n-  VectorNode::trace_new_vector(vn, \"AutoVectorization\");\n-}\n-\n-#ifndef PRODUCT\n-void VTransformGraph::print_vtnodes() const {\n-  tty->print_cr(\"\\nVTransformGraph::print_vtnodes:\");\n-  for (int i = 0; i < _vtnodes.length(); i++) {\n-    _vtnodes.at(i)->print();\n-  }\n-}\n-\n-void VTransformGraph::print_schedule() const {\n-  tty->print_cr(\"\\nVTransformGraph::print_schedule:\");\n-  for (int i = 0; i < _schedule.length(); i++) {\n-    tty->print(\" %3d: \", i);\n-    VTransformNode* vtn = _schedule.at(i);\n-    if (vtn == nullptr) {\n-      tty->print_cr(\"nullptr\");\n-    } else {\n-      vtn->print();\n-    }\n-  }\n-}\n-\n-void VTransformGraph::print_memops_schedule() const {\n-  tty->print_cr(\"\\nVTransformGraph::print_memops_schedule:\");\n-  int i = 0;\n-  for_each_memop_in_schedule([&] (MemNode* mem) {\n-    tty->print(\" %3d: \", i++);\n-    mem->dump();\n-  });\n-}\n-\n-void VTransformNode::print() const {\n-  tty->print(\"%3d %s (\", _idx, name());\n-  for (uint i = 0; i < _req; i++) {\n-    print_node_idx(_in.at(i));\n-  }\n-  if ((uint)_in.length() > _req) {\n-    tty->print(\" |\");\n-    for (int i = _req; i < _in.length(); i++) {\n-      print_node_idx(_in.at(i));\n-    }\n-  }\n-  tty->print(\") [\");\n-  for (int i = 0; i < _out.length(); i++) {\n-    print_node_idx(_out.at(i));\n-  }\n-  tty->print(\"] \");\n-  print_spec();\n-  tty->cr();\n-}\n-\n-void VTransformNode::print_node_idx(const VTransformNode* vtn) {\n-  if (vtn == nullptr) {\n-    tty->print(\" _\");\n-  } else {\n-    tty->print(\" %d\", vtn->_idx);\n-  }\n-}\n-\n-void VTransformScalarNode::print_spec() const {\n-  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n-}\n-\n-void VTransformReplicateNode::print_spec() const {\n-  tty->print(\"vlen=%d element_type=\", _vlen);\n-  _element_type->dump();\n-}\n-\n-void VTransformShiftCountNode::print_spec() const {\n-  tty->print(\"vlen=%d element_bt=%s mask=%d shift_opcode=%s\",\n-             _vlen, type2name(_element_bt), _mask,\n-             NodeClassNames[_shift_opcode]);\n-}\n-\n-void VTransformPopulateIndexNode::print_spec() const {\n-  tty->print(\"vlen=%d element_bt=%s\", _vlen, type2name(_element_bt));\n-}\n-\n-void VTransformVectorNode::print_spec() const {\n-  tty->print(\"%d-pack[\", _nodes.length());\n-  for (int i = 0; i < _nodes.length(); i++) {\n-    Node* n = _nodes.at(i);\n-    if (i > 0) {\n-      tty->print(\", \");\n-    }\n-    tty->print(\"%d %s\", n->_idx, n->Name());\n-  }\n-  tty->print(\"]\");\n-}\n-#endif\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":0,"deletions":413,"binary":false,"changes":413,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/matcher.hpp\"\n@@ -1326,445 +1327,0 @@\n-\/\/ VTransform\n-\/\/\n-\/\/ Maps the transformation from the scalar to the vectorized loop.\n-\/\/\n-\/\/ The graph (VTransformGraph) of vtnodes (VTransformNode) represents the output\n-\/\/ C2 graph after vectorization as closely as possible.\n-\/\/\n-\/\/ This allows us to schedule the graph, and check for possible cycles that\n-\/\/ vectorization might introduce.\n-\/\/\n-\/\/ Changes to the C2 IR are only made once the \"apply\" method is called, and\n-\/\/ each vtnode generates its corresponding scalar or vector C2 nodes.\n-\/\/\n-\/\/ Future Plans with VTransform:\n-\/\/ - Cost model: estimate if vectorization is profitable.\n-\/\/ - Optimizations: moving unordered reductions out of the loop, whih decreases cost.\n-\/\/ - Pack\/Unpack\/Shuffle: introduce additional nodes not present in the scalar loop.\n-\/\/                        This is difficult to do with the SuperWord packset approach.\n-\/\/ - If-conversion: convert predicated nodes into CFG.\n-\n-typedef int VTransformNodeIDX;\n-class VTransformNode;\n-class VTransformScalarNode;\n-class VTransformInputScalarNode;\n-class VTransformVectorNode;\n-class VTransformElementWiseVectorNode;\n-class VTransformBoolVectorNode;\n-class VTransformReductionVectorNode;\n-\n-\/\/ Result from a VTransformNode::apply\n-class VTransformApplyResult {\n-private:\n-  Node* const _node;\n-  const uint _vector_length; \/\/ number of elements\n-  const uint _vector_width;  \/\/ total width in bytes\n-\n-  VTransformApplyResult(Node* n, uint vector_length, uint vector_width) :\n-    _node(n),\n-    _vector_length(vector_length),\n-    _vector_width(vector_width) {}\n-\n-public:\n-  static VTransformApplyResult make_scalar(Node* n) {\n-    return VTransformApplyResult(n, 0, 0);\n-  }\n-\n-  static VTransformApplyResult make_vector(Node* n, uint vector_length, uint vector_width) {\n-    assert(vector_length > 0 && vector_width > 0, \"must have nonzero size\");\n-    return VTransformApplyResult(n, vector_length, vector_width);\n-  }\n-\n-  static VTransformApplyResult make_empty() {\n-    return VTransformApplyResult(nullptr, 0, 0);\n-  }\n-\n-  Node* node() const { return _node; }\n-  uint vector_length() const { return _vector_length; }\n-  uint vector_width() const { return _vector_width; }\n-  NOT_PRODUCT( void trace(VTransformNode* vtn) const; )\n-};\n-\n-\/\/ VTransformGraph is a graph of VTransformNode, which represent the VTransform. It\n-\/\/ is designed to resemble the C2 nodes after \"apply\" as closely as possible.\n-\/\/ Currently, there are these stages to the VTransform:\n-\/\/\n-\/\/  - Construction:\n-\/\/      external (e.g. with SuperWordVTransformBuilder)\n-\/\/\n-\/\/  - Schedule:\n-\/\/      compute linearization of graph, into a order that respects all edges in the\n-\/\/      graph (bailout if circle detected).\n-\/\/\n-\/\/  - Apply:\n-\/\/      Make all necessary changes to the C2 IR, each VTransformNode generates the\n-\/\/      corresponding scalar or vector C2 nodes.\n-\/\/\n-class VTransformGraph : public StackObj {\n-private:\n-  const VLoopAnalyzer& _vloop_analyzer;\n-  const VLoop& _vloop;\n-\n-  \/\/ Everything in the graph is allocated from this arena, including all vtnodes.\n-  Arena _arena;\n-\n-  VTransformNodeIDX _next_idx;\n-  GrowableArray<VTransformNode*> _vtnodes;\n-\n-  \/\/ Schedule (linearization) of the graph. We use this to reorder the memory graph\n-  \/\/ before inserting vector operations.\n-  GrowableArray<VTransformNode*> _schedule;\n-\n-  \/\/ Memory reference, and the alignment width (aw) for which we align the main-loop,\n-  \/\/ by adjusting the pre-loop limit.\n-  MemNode const* _mem_ref_for_main_loop_alignment;\n-  int _aw_for_main_loop_alignment;\n-\n-#ifndef PRODUCT\n-  bool _is_trace_rejections;\n-  bool _is_trace_align_vector;\n-  bool _is_trace_info;\n-  bool _is_trace_verbose;\n-#endif\n-\n-public:\n-  VTransformGraph(const VLoopAnalyzer& vloop_analyzer,\n-                  MemNode const* mem_ref_for_main_loop_alignment,\n-                  int aw_for_main_loop_alignment\n-                  NOT_PRODUCT( COMMA const bool is_trace_rejections)\n-                  NOT_PRODUCT( COMMA const bool is_trace_align_vector)\n-                  NOT_PRODUCT( COMMA const bool is_trace_info)\n-                  ) :\n-    _vloop_analyzer(vloop_analyzer),\n-    _vloop(vloop_analyzer.vloop()),\n-    _arena(mtCompiler),\n-    _next_idx(0),\n-    _vtnodes(&_arena, _vloop.estimated_body_length(), 0, nullptr),\n-    _schedule(&_arena, _vloop.estimated_body_length(), 0, nullptr),\n-    _mem_ref_for_main_loop_alignment(mem_ref_for_main_loop_alignment),\n-    _aw_for_main_loop_alignment(aw_for_main_loop_alignment)\n-    NOT_PRODUCT( COMMA _is_trace_rejections(is_trace_rejections) )\n-    NOT_PRODUCT( COMMA _is_trace_align_vector(is_trace_align_vector) )\n-    NOT_PRODUCT( COMMA _is_trace_info(is_trace_info) )\n-  {\n-#ifndef PRODUCT\n-    bool is_trace     = _vloop.vtrace().is_trace(TraceAutoVectorizationTag::VTRANSFORM);\n-    _is_trace_verbose = _vloop.vtrace().is_trace(TraceAutoVectorizationTag::ALL);\n-    _is_trace_rejections   |= is_trace || _is_trace_verbose;\n-    _is_trace_align_vector |= is_trace || _is_trace_verbose;\n-    _is_trace_info         |= is_trace || _is_trace_verbose;\n-#endif\n-  }\n-\n-  const VLoopAnalyzer& vloop_analyzer() const { return _vloop_analyzer; }\n-  Arena* arena() { return &_arena; }\n-  VTransformNodeIDX new_idx() { return _next_idx++; }\n-  void add_vtnode(VTransformNode* vtnode);\n-  bool is_empty() const { return _vtnodes.is_empty(); }\n-\n-  bool schedule();\n-  void apply();\n-\n-private:\n-  \/\/ VLoop accessors\n-  PhaseIdealLoop* phase()     const { return _vloop.phase(); }\n-  PhaseIterGVN& igvn()        const { return _vloop.phase()->igvn(); }\n-  IdealLoopTree* lpt()        const { return _vloop.lpt(); }\n-  CountedLoopNode* cl()       const { return _vloop.cl(); }\n-  int iv_stride()             const { return cl()->stride_con(); }\n-  bool in_bb(const Node* n)   const { return _vloop.in_bb(n); }\n-\n-  \/\/ VLoopVPointers accessors\n-  const VPointer& vpointer(const MemNode* mem) const {\n-    return _vloop_analyzer.vpointers().vpointer(mem);\n-  }\n-\n-  void schedule_collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const;\n-\n-  template<typename Callback>\n-  void for_each_memop_in_schedule(Callback callback) const;\n-\n-  void apply_memops_reordering_with_schedule() const;\n-\n-  \/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit.\n-  void determine_mem_ref_and_aw_for_main_loop_alignment();\n-  void adjust_pre_loop_limit_to_align_main_loop_vectors();\n-\n-  void apply_vectorization() const;\n-\n-#ifndef PRODUCT\n-  void print_vtnodes() const;\n-  void print_schedule() const;\n-  void print_memops_schedule() const;\n-  void trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n-                            const VectorSet& pre_visited,\n-                            const VectorSet& post_visited) const;\n-#endif\n-};\n-\n-\/\/ VTransformNodes resemble the C2 IR Nodes. They represent the resulting scalar and\n-\/\/ vector nodes as closely as possible.\n-class VTransformNode : public ArenaObj {\n-public:\n-  const VTransformNodeIDX _idx;\n-\n-private:\n-  \/\/ _in is split into required inputs (_req), and additional dependencies.\n-  const uint _req;\n-  GrowableArray<VTransformNode*> _in;\n-  GrowableArray<VTransformNode*> _out;\n-\n-public:\n-  VTransformNode(VTransformGraph& graph, const uint req) :\n-    _idx(graph.new_idx()),\n-    _req(req),\n-    _in(graph.arena(),  req, req, nullptr),\n-    _out(graph.arena(), 4, 0, nullptr)\n-  {\n-    graph.add_vtnode(this);\n-  }\n-\n-  void set_req(uint i, VTransformNode* n) {\n-    assert(i < _req, \"must be a req\");\n-    assert(_in.at(i) == nullptr && n != nullptr, \"only set once\");\n-    _in.at_put(i, n);\n-    n->add_out(this);\n-  }\n-\n-  void swap_req(uint i, uint j) {\n-    assert(i < _req, \"must be a req\");\n-    assert(j < _req, \"must be a req\");\n-    VTransformNode* tmp = _in.at(i);\n-    _in.at_put(i, _in.at(j));\n-    _in.at_put(j, tmp);\n-  }\n-\n-  void add_dependency(VTransformNode* n) {\n-    assert(n != nullptr, \"no need to add nullptr\");\n-    _in.push(n);\n-    n->add_out(this);\n-  }\n-\n-  void add_out(VTransformNode* n) {\n-    _out.push(n);\n-  }\n-\n-  uint req() const { return _req; }\n-  VTransformNode* in(int i) const { return _in.at(i); }\n-  int outs() const { return _out.length(); }\n-  VTransformNode* out(int i) const { return _out.at(i); }\n-\n-  bool has_req_or_dependency() const {\n-    for (int i = 0; i < _in.length(); i++) {\n-      if (_in.at(i) != nullptr) { return true; }\n-    }\n-    return false;\n-  }\n-\n-  virtual VTransformScalarNode* isa_Scalar() { return nullptr; }\n-  virtual VTransformInputScalarNode* isa_InputScalar() { return nullptr; }\n-  virtual VTransformVectorNode* isa_Vector() { return nullptr; }\n-  virtual VTransformElementWiseVectorNode* isa_ElementWiseVector() { return nullptr; }\n-  virtual VTransformBoolVectorNode* isa_BoolVector() { return nullptr; }\n-  virtual VTransformReductionVectorNode* isa_ReductionVector() { return nullptr; }\n-\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const = 0;\n-\n-  Node* find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const;\n-\n-  void register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const;\n-\n-  NOT_PRODUCT(virtual const char* name() const = 0;)\n-  NOT_PRODUCT(void print() const;)\n-  NOT_PRODUCT(virtual void print_spec() const {};)\n-  NOT_PRODUCT(static void print_node_idx(const VTransformNode* vtn);)\n-};\n-\n-\/\/ Identity transform for scalar nodes.\n-class VTransformScalarNode : public VTransformNode {\n-private:\n-  Node* _node;\n-public:\n-  VTransformScalarNode(VTransformGraph& graph, Node* n) :\n-    VTransformNode(graph, n->req()), _node(n) {}\n-  Node* node() const { return _node; }\n-  virtual VTransformScalarNode* isa_Scalar() override { return this; }\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n-  NOT_PRODUCT(virtual const char* name() const override { return \"Scalar\"; };)\n-  NOT_PRODUCT(virtual void print_spec() const override;)\n-};\n-\n-\/\/ Wrapper node for nodes outside the loop that are inputs to nodes in the loop.\n-\/\/ Since we want the loop-internal nodes to be able to reference all inputs as vtnodes,\n-\/\/ we must wrap the inputs that are outside the loop also into special vtnodes.\n-class VTransformInputScalarNode : public VTransformScalarNode {\n-public:\n-  VTransformInputScalarNode(VTransformGraph& graph, Node* n) :\n-    VTransformScalarNode(graph, n) {}\n-  virtual VTransformInputScalarNode* isa_InputScalar() override { return this; }\n-  NOT_PRODUCT(virtual const char* name() const override { return \"InputScalar\"; };)\n-};\n-\n-\/\/ Transform produces a ReplicateNode, replicating the input to all vector lanes.\n-class VTransformReplicateNode : public VTransformNode {\n-private:\n-  int _vlen;\n-  const Type* _element_type;\n-public:\n-  VTransformReplicateNode(VTransformGraph& graph, int vlen, const Type* element_type) :\n-    VTransformNode(graph, 2), _vlen(vlen), _element_type(element_type) {}\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n-  NOT_PRODUCT(virtual const char* name() const override { return \"Replicate\"; };)\n-  NOT_PRODUCT(virtual void print_spec() const override;)\n-};\n-\n-\/\/ Transform introduces a scalar ConvI2LNode that was not previously in the C2 graph.\n-class VTransformConvI2LNode : public VTransformNode {\n-public:\n-  VTransformConvI2LNode(VTransformGraph& graph) : VTransformNode(graph, 2) {}\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n-  NOT_PRODUCT(virtual const char* name() const override { return \"ConvI2L\"; };)\n-};\n-\n-\/\/ Transform introduces a shift-count node, that truncates the shift count for a vector shift.\n-class VTransformShiftCountNode : public VTransformNode {\n-private:\n-  int _vlen;\n-  const BasicType _element_bt;\n-  juint _mask;\n-  int _shift_opcode;\n-public:\n-  VTransformShiftCountNode(VTransformGraph& graph, int vlen, BasicType element_bt, juint mask, int shift_opcode) :\n-    VTransformNode(graph, 2), _vlen(vlen), _element_bt(element_bt), _mask(mask), _shift_opcode(shift_opcode) {}\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n-  NOT_PRODUCT(virtual const char* name() const override { return \"ShiftCount\"; };)\n-  NOT_PRODUCT(virtual void print_spec() const override;)\n-};\n-\n-\/\/ Transform introduces a PopulateIndex node: [phi, phi+1, phi+2, phi+3, ...].\n-class VTransformPopulateIndexNode : public VTransformNode {\n-private:\n-  int _vlen;\n-  const BasicType _element_bt;\n-public:\n-  VTransformPopulateIndexNode(VTransformGraph& graph, int vlen, const BasicType element_bt) :\n-    VTransformNode(graph, 2), _vlen(vlen), _element_bt(element_bt) {}\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n-  NOT_PRODUCT(virtual const char* name() const override { return \"PopulateIndex\"; };)\n-  NOT_PRODUCT(virtual void print_spec() const override;)\n-};\n-\n-\/\/ Base class for all vector vtnodes.\n-class VTransformVectorNode : public VTransformNode {\n-private:\n-  GrowableArray<Node*> _nodes;\n-public:\n-  VTransformVectorNode(VTransformGraph& graph, const uint req, const uint number_of_nodes) :\n-    VTransformNode(graph, req), _nodes(graph.arena(), number_of_nodes, number_of_nodes, nullptr) {}\n-\n-  void set_nodes(const Node_List* pack) {\n-    for (uint k = 0; k < pack->size(); k++) {\n-      _nodes.at_put(k, pack->at(k));\n-    }\n-  }\n-\n-  const GrowableArray<Node*> nodes() const { return _nodes; }\n-  virtual VTransformVectorNode* isa_Vector() override { return this; }\n-  void register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const;\n-  NOT_PRODUCT(virtual void print_spec() const override;)\n-};\n-\n-\/\/ Catch all for all element-wise vector operations.\n-class VTransformElementWiseVectorNode : public VTransformVectorNode {\n-public:\n-  VTransformElementWiseVectorNode(VTransformGraph& graph, uint req, uint number_of_nodes) :\n-    VTransformVectorNode(graph, req, number_of_nodes) {}\n-  virtual VTransformElementWiseVectorNode* isa_ElementWiseVector() override { return this; }\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n-  NOT_PRODUCT(virtual const char* name() const override { return \"ElementWiseVector\"; };)\n-};\n-\n-struct VTransformBoolTest {\n-  const BoolTest::mask _mask;\n-  const bool _is_negated;\n-\n-  VTransformBoolTest(const BoolTest::mask mask, bool is_negated) :\n-    _mask(mask), _is_negated(is_negated) {}\n-};\n-\n-class VTransformBoolVectorNode : public VTransformElementWiseVectorNode {\n-private:\n-  const VTransformBoolTest _test;\n-public:\n-  VTransformBoolVectorNode(VTransformGraph& graph, uint number_of_nodes, VTransformBoolTest test) :\n-    VTransformElementWiseVectorNode(graph, 2, number_of_nodes), _test(test) {}\n-  VTransformBoolTest test() const { return _test; }\n-  virtual VTransformBoolVectorNode* isa_BoolVector() override { return this; }\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n-  NOT_PRODUCT(virtual const char* name() const override { return \"BoolVector\"; };)\n-};\n-\n-class VTransformReductionVectorNode : public VTransformVectorNode {\n-public:\n-  \/\/ req = 3 -> [ctrl, scalar init, vector]\n-  VTransformReductionVectorNode(VTransformGraph& graph, uint number_of_nodes) :\n-    VTransformVectorNode(graph, 3, number_of_nodes) {}\n-  virtual VTransformReductionVectorNode* isa_ReductionVector() override { return this; }\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n-  NOT_PRODUCT(virtual const char* name() const override { return \"ReductionVector\"; };)\n-};\n-\n-class VTransformLoadVectorNode : public VTransformVectorNode {\n-public:\n-  \/\/ req = 3 -> [ctrl, mem, adr]\n-  VTransformLoadVectorNode(VTransformGraph& graph, uint number_of_nodes) :\n-    VTransformVectorNode(graph, 3, number_of_nodes) {}\n-  LoadNode::ControlDependency control_dependency() const;\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n-  NOT_PRODUCT(virtual const char* name() const override { return \"LoadVector\"; };)\n-};\n-\n-class VTransformStoreVectorNode : public VTransformVectorNode {\n-public:\n-  \/\/ req = 4 -> [ctrl, mem, adr, val]\n-  VTransformStoreVectorNode(VTransformGraph& graph, uint number_of_nodes) :\n-    VTransformVectorNode(graph, 4, number_of_nodes) {}\n-  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n-                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n-  NOT_PRODUCT(virtual const char* name() const override { return \"StoreVector\"; };)\n-};\n-\n-\/\/ Invoke callback on all memops, in the order of the schedule.\n-template<typename Callback>\n-void VTransformGraph::for_each_memop_in_schedule(Callback callback) const {\n-  assert(_schedule.length() == _vtnodes.length(), \"schedule was computed\");\n-\n-  for (int i = 0; i < _schedule.length(); i++) {\n-    VTransformNode* vtn = _schedule.at(i);\n-\n-    \/\/ We can ignore input nodes, they are outside the loop.\n-    if (vtn->isa_InputScalar() != nullptr) { continue; }\n-\n-    VTransformScalarNode* scalar = vtn->isa_Scalar();\n-    if (scalar != nullptr && scalar->node()->is_Mem()) {\n-      callback(scalar->node()->as_Mem());\n-    }\n-\n-    VTransformVectorNode* vector = vtn->isa_Vector();\n-    if (vector != nullptr && vector->nodes().at(0)->is_Mem()) {\n-      for (int j = 0; j < vector->nodes().length(); j++) {\n-        callback(vector->nodes().at(j)->as_Mem());\n-      }\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":1,"deletions":445,"binary":false,"changes":446,"status":"modified"},{"patch":"@@ -0,0 +1,441 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"opto\/vtransform.hpp\"\n+#include \"opto\/vectornode.hpp\"\n+#include \"opto\/convertnode.hpp\"\n+\n+\n+void VTransformGraph::add_vtnode(VTransformNode* vtnode) {\n+  assert(vtnode->_idx == _vtnodes.length(), \"position must match idx\");\n+  _vtnodes.push(vtnode);\n+}\n+\n+\/\/ Compute a linearization of the graph. We do this with a reverse-post-order of a DFS.\n+\/\/ This only works if the graph is a directed acyclic graph (DAG). The C2 graph, and\n+\/\/ the VLoopDependencyGraph are both DAGs, but after introduction of vectors\/packs, the\n+\/\/ graph has additional constraints which can introduce cycles. Example:\n+\/\/\n+\/\/                                                       +--------+\n+\/\/  A -> X                                               |        v\n+\/\/                     Pack [A,B] and [X,Y]             [A,B]    [X,Y]\n+\/\/  Y -> B                                                 ^        |\n+\/\/                                                         +--------+\n+\/\/\n+\/\/ We return \"true\" IFF we find no cycle, i.e. if the linearization succeeds.\n+bool VTransformGraph::schedule() {\n+  assert(_schedule.is_empty(), \"not yet scheduled\");\n+\n+#ifndef PRODUCT\n+  if (_is_trace_verbose) {\n+    print_vtnodes();\n+  }\n+#endif\n+\n+  ResourceMark rm;\n+  GrowableArray<VTransformNode*> stack;\n+  VectorSet pre_visited;\n+  VectorSet post_visited;\n+\n+  schedule_collect_nodes_without_req_or_dependency(stack);\n+\n+  \/\/ We create a reverse-post-visit order. This gives us a linearization, if there are\n+  \/\/ no cycles. Then, we simply reverse the order, and we have a schedule.\n+  int rpo_idx = _vtnodes.length() - 1;\n+  while (!stack.is_empty()) {\n+    VTransformNode* vtn = stack.top();\n+    if (!pre_visited.test_set(vtn->_idx)) {\n+      \/\/ Forward arc in graph (pre-visit).\n+    } else if (!post_visited.test(vtn->_idx)) {\n+      \/\/ Forward arc in graph. Check if all uses were already visited:\n+      \/\/   Yes -> post-visit.\n+      \/\/   No  -> we are mid-visit.\n+      bool all_uses_already_visited = true;\n+\n+      for (int i = 0; i < vtn->outs(); i++) {\n+        VTransformNode* use = vtn->out(i);\n+        if (post_visited.test(use->_idx)) { continue; }\n+        if (pre_visited.test(use->_idx)) {\n+          \/\/ Circle detected!\n+          \/\/ The nodes that are pre_visited but not yet post_visited form a path from\n+          \/\/ the \"root\" to the current vtn. Now, we are looking at an edge (vtn, use),\n+          \/\/ and discover that use is also pre_visited but not post_visited. Thus, use\n+          \/\/ lies on that path from \"root\" to vtn, and the edge (vtn, use) closes a\n+          \/\/ circle.\n+          NOT_PRODUCT(if (_is_trace_rejections) { trace_schedule_cycle(stack, pre_visited, post_visited); } )\n+          return false;\n+        }\n+        stack.push(use);\n+        all_uses_already_visited = false;\n+      }\n+\n+      if (all_uses_already_visited) {\n+        stack.pop();\n+        post_visited.set(vtn->_idx);           \/\/ post-visit\n+        _schedule.at_put_grow(rpo_idx--, vtn); \/\/ assign rpo_idx\n+      }\n+\n+    } else {\n+      stack.pop(); \/\/ Already post-visited. Ignore secondary edge.\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  if (_is_trace_verbose) {\n+    print_schedule();\n+  }\n+#endif\n+\n+  assert(rpo_idx == -1, \"used up all rpo_idx, rpo_idx=%d\", rpo_idx);\n+  return true;\n+}\n+\n+\/\/ Push all \"root\" nodes, i.e. those that have no inputs (req or dependency):\n+void VTransformGraph::schedule_collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const {\n+  for (int i = 0; i < _vtnodes.length(); i++) {\n+    VTransformNode* vtn = _vtnodes.at(i);\n+    if (!vtn->has_req_or_dependency()) {\n+      stack.push(vtn);\n+    }\n+  }\n+}\n+\n+#ifndef PRODUCT\n+void VTransformGraph::trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n+                                           const VectorSet& pre_visited,\n+                                           const VectorSet& post_visited) const {\n+  tty->print_cr(\"\\nVTransformGraph::schedule found a cycle on path (P), vectorization attempt fails.\");\n+  for (int j = 0; j < stack.length(); j++) {\n+    VTransformNode* n = stack.at(j);\n+    bool on_path = pre_visited.test(n->_idx) && !post_visited.test(n->_idx);\n+    tty->print(\"  %s \", on_path ? \"P\" : \"_\");\n+    n->print();\n+  }\n+}\n+\n+void VTransformApplyResult::trace(VTransformNode* vtn) const {\n+  tty->print(\"  apply: \");\n+  vtn->print();\n+  tty->print(\"    ->   \");\n+  if (_node == nullptr) {\n+    tty->print_cr(\"nullptr\");\n+  } else {\n+    _node->dump();\n+  }\n+}\n+#endif\n+\n+Node* VTransformNode::find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* n = vnode_idx_to_transformed_node.at(in(i)->_idx);\n+  assert(n != nullptr, \"must find input IR node\");\n+  return n;\n+}\n+\n+VTransformApplyResult VTransformScalarNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformReplicateNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  VectorNode* vn = VectorNode::scalar2vector(val, _vlen, _element_type);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformConvI2LNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* n = new ConvI2LNode(val);\n+  register_new_node_from_vectorization(vloop_analyzer, n, val);\n+  return VTransformApplyResult::make_scalar(n);\n+}\n+\n+VTransformApplyResult VTransformShiftCountNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  Node* shift_count_in = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  assert(shift_count_in->bottom_type()->isa_int(), \"int type only for shift count\");\n+  \/\/ The shift_count_in would be automatically truncated to the lowest _mask\n+  \/\/ bits in a scalar shift operation. But vector shift does not truncate, so\n+  \/\/ we must apply the mask now.\n+  Node* shift_count_masked = new AndINode(shift_count_in, phase->igvn().intcon(_mask));\n+  register_new_node_from_vectorization(vloop_analyzer, shift_count_masked, shift_count_in);\n+  \/\/ Now that masked value is \"boadcast\" (some platforms only set the lowest element).\n+  VectorNode* vn = VectorNode::shift_count(_shift_opcode, shift_count_masked, _vlen, _element_bt);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, shift_count_in);\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+}\n+\n+\n+VTransformApplyResult VTransformPopulateIndexNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  assert(val->is_Phi(), \"expected to be iv\");\n+  assert(VectorNode::is_populate_index_supported(_element_bt), \"should support\");\n+  const TypeVect* vt = TypeVect::make(_element_bt, _vlen);\n+  VectorNode* vn = new PopulateIndexNode(val, phase->igvn().intcon(1), vt);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformElementWiseVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* first = nodes().at(0);\n+  uint  vlen = nodes().length();\n+  int   opc  = first->Opcode();\n+  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+\n+  if (first->is_Cmp()) {\n+    \/\/ Cmp + Bool -> VectorMaskCmp\n+    \/\/ Handled by Bool \/ VTransformBoolVectorNode, so we do not generate any nodes here.\n+    return VTransformApplyResult::make_empty();\n+  }\n+\n+  assert(2 <= req() && req() <= 4, \"Must have 1-3 inputs\");\n+  VectorNode* vn = nullptr;\n+  Node* in1 =                find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* in2 = (req() >= 3) ? find_transformed_input(2, vnode_idx_to_transformed_node) : nullptr;\n+  Node* in3 = (req() >= 4) ? find_transformed_input(3, vnode_idx_to_transformed_node) : nullptr;\n+\n+  if (first->is_CMove()) {\n+    assert(req() == 4, \"three inputs expected: mask, blend1, blend2\");\n+    vn = new VectorBlendNode(\/* blend1 *\/ in2, \/* blend2 *\/ in3, \/* mask *\/ in1);\n+  } else if (VectorNode::is_convert_opcode(opc)) {\n+    assert(first->req() == 2 && req() == 2, \"only one input expected\");\n+    int vopc = VectorCastNode::opcode(opc, in1->bottom_type()->is_vect()->element_basic_type());\n+    vn = VectorCastNode::make(vopc, in1, bt, vlen);\n+  } else if (VectorNode::can_use_RShiftI_instead_of_URShiftI(first, bt)) {\n+    opc = Op_RShiftI;\n+    vn = VectorNode::make(opc, in1, in2, vlen, bt);\n+  } else if (VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc)) {\n+    \/\/ The scalar operation was a long -> int operation.\n+    \/\/ However, the vector operation is long -> long.\n+    VectorNode* long_vn = VectorNode::make(opc, in1, nullptr, vlen, T_LONG);\n+    register_new_node_from_vectorization(vloop_analyzer, long_vn, first);\n+    \/\/ Cast long -> int, to mimic the scalar long -> int operation.\n+    vn = VectorCastNode::make(Op_VectorCastL2X, long_vn, T_INT, vlen);\n+  } else if (req() == 3 ||\n+             VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc)) {\n+    assert(!VectorNode::is_roundopD(first) || in2->is_Con(), \"rounding mode must be constant\");\n+    vn = VectorNode::make(opc, in1, in2, vlen, bt); \/\/ unary and binary\n+  } else {\n+    assert(req() == 4, \"three inputs expected\");\n+    assert(opc == Op_FmaD ||\n+           opc == Op_FmaF ||\n+           opc == Op_SignumF ||\n+           opc == Op_SignumD,\n+           \"element wise operation must be from this list\");\n+    vn = VectorNode::make(opc, in1, in2, in3, vlen, bt); \/\/ ternary\n+  }\n+\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformBoolVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  BoolNode* first = nodes().at(0)->as_Bool();\n+  uint  vlen = nodes().length();\n+  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+\n+  \/\/ Cmp + Bool -> VectorMaskCmp\n+  VTransformElementWiseVectorNode* vtn_cmp = in(1)->isa_ElementWiseVector();\n+  assert(vtn_cmp != nullptr && vtn_cmp->nodes().at(0)->is_Cmp(),\n+         \"bool vtn expects cmp vtn as input\");\n+\n+  Node* cmp_in1 = vtn_cmp->find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* cmp_in2 = vtn_cmp->find_transformed_input(2, vnode_idx_to_transformed_node);\n+  BoolTest::mask mask = test()._mask;\n+\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  ConINode* mask_node  = phase->igvn().intcon((int)mask);\n+  const TypeVect* vt = TypeVect::make(bt, vlen);\n+  VectorNode* vn = new VectorMaskCmpNode(mask, cmp_in1, cmp_in2, mask_node, vt);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->vect_type()->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformReductionVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* first = nodes().at(0);\n+  uint  vlen = nodes().length();\n+  int   opc  = first->Opcode();\n+  BasicType bt = first->bottom_type()->basic_type();\n+\n+  Node* init = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* vec  = find_transformed_input(2, vnode_idx_to_transformed_node);\n+\n+  ReductionNode* vn = ReductionNode::make(opc, nullptr, init, vec, bt);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->vect_type()->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformLoadVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  LoadNode* first = nodes().at(0)->as_Load();\n+  uint  vlen = nodes().length();\n+  Node* ctrl = first->in(MemNode::Control);\n+  Node* mem  = first->in(MemNode::Memory);\n+  Node* adr  = first->in(MemNode::Address);\n+  int   opc  = first->Opcode();\n+  const TypePtr* adr_type = first->adr_type();\n+  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+\n+  \/\/ Set the memory dependency of the LoadVector as early as possible.\n+  \/\/ Walk up the memory chain, and ignore any StoreVector that provably\n+  \/\/ does not have any memory dependency.\n+  while (mem->is_StoreVector()) {\n+    VPointer p_store(mem->as_Mem(), vloop_analyzer.vloop());\n+    if (p_store.overlap_possible_with_any_in(nodes())) {\n+      break;\n+    } else {\n+      mem = mem->in(MemNode::Memory);\n+    }\n+  }\n+\n+  LoadVectorNode* vn = LoadVectorNode::make(opc, ctrl, mem, adr, adr_type, vlen, bt,\n+                                            control_dependency());\n+  DEBUG_ONLY( if (VerifyAlignVector) { vn->set_must_verify_alignment(); } )\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->memory_size());\n+}\n+\n+VTransformApplyResult VTransformStoreVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  StoreNode* first = nodes().at(0)->as_Store();\n+  uint  vlen = nodes().length();\n+  Node* ctrl = first->in(MemNode::Control);\n+  Node* mem  = first->in(MemNode::Memory);\n+  Node* adr  = first->in(MemNode::Address);\n+  int   opc  = first->Opcode();\n+  const TypePtr* adr_type = first->adr_type();\n+\n+  Node* value = find_transformed_input(MemNode::ValueIn, vnode_idx_to_transformed_node);\n+  StoreVectorNode* vn = StoreVectorNode::make(opc, ctrl, mem, adr, adr_type, value, vlen);\n+  DEBUG_ONLY( if (VerifyAlignVector) { vn->set_must_verify_alignment(); } )\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->memory_size());\n+}\n+\n+void VTransformVectorNode::register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  Node* first = nodes().at(0);\n+\n+  register_new_node_from_vectorization(vloop_analyzer, vn, first);\n+\n+  for (int i = 0; i < _nodes.length(); i++) {\n+    Node* n = _nodes.at(i);\n+    phase->igvn().replace_node(n, vn);\n+  }\n+}\n+\n+void VTransformNode::register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  phase->register_new_node_with_ctrl_of(vn, old_node);\n+  phase->igvn()._worklist.push(vn);\n+  VectorNode::trace_new_vector(vn, \"AutoVectorization\");\n+}\n+\n+#ifndef PRODUCT\n+void VTransformGraph::print_vtnodes() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_vtnodes:\");\n+  for (int i = 0; i < _vtnodes.length(); i++) {\n+    _vtnodes.at(i)->print();\n+  }\n+}\n+\n+void VTransformGraph::print_schedule() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_schedule:\");\n+  for (int i = 0; i < _schedule.length(); i++) {\n+    tty->print(\" %3d: \", i);\n+    VTransformNode* vtn = _schedule.at(i);\n+    if (vtn == nullptr) {\n+      tty->print_cr(\"nullptr\");\n+    } else {\n+      vtn->print();\n+    }\n+  }\n+}\n+\n+void VTransformGraph::print_memops_schedule() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_memops_schedule:\");\n+  int i = 0;\n+  for_each_memop_in_schedule([&] (MemNode* mem) {\n+    tty->print(\" %3d: \", i++);\n+    mem->dump();\n+  });\n+}\n+\n+void VTransformNode::print() const {\n+  tty->print(\"%3d %s (\", _idx, name());\n+  for (uint i = 0; i < _req; i++) {\n+    print_node_idx(_in.at(i));\n+  }\n+  if ((uint)_in.length() > _req) {\n+    tty->print(\" |\");\n+    for (int i = _req; i < _in.length(); i++) {\n+      print_node_idx(_in.at(i));\n+    }\n+  }\n+  tty->print(\") [\");\n+  for (int i = 0; i < _out.length(); i++) {\n+    print_node_idx(_out.at(i));\n+  }\n+  tty->print(\"] \");\n+  print_spec();\n+  tty->cr();\n+}\n+\n+void VTransformNode::print_node_idx(const VTransformNode* vtn) {\n+  if (vtn == nullptr) {\n+    tty->print(\" _\");\n+  } else {\n+    tty->print(\" %d\", vtn->_idx);\n+  }\n+}\n+\n+void VTransformScalarNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformReplicateNode::print_spec() const {\n+  tty->print(\"vlen=%d element_type=\", _vlen);\n+  _element_type->dump();\n+}\n+\n+void VTransformShiftCountNode::print_spec() const {\n+  tty->print(\"vlen=%d element_bt=%s mask=%d shift_opcode=%s\",\n+             _vlen, type2name(_element_bt), _mask,\n+             NodeClassNames[_shift_opcode]);\n+}\n+\n+void VTransformPopulateIndexNode::print_spec() const {\n+  tty->print(\"vlen=%d element_bt=%s\", _vlen, type2name(_element_bt));\n+}\n+\n+void VTransformVectorNode::print_spec() const {\n+  tty->print(\"%d-pack[\", _nodes.length());\n+  for (int i = 0; i < _nodes.length(); i++) {\n+    Node* n = _nodes.at(i);\n+    if (i > 0) {\n+      tty->print(\", \");\n+    }\n+    tty->print(\"%d %s\", n->_idx, n->Name());\n+  }\n+  tty->print(\"]\");\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":441,"deletions":0,"binary":false,"changes":441,"status":"added"},{"patch":"@@ -0,0 +1,475 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_OPTO_VTRANSFORM_HPP\n+#define SHARE_OPTO_VTRANSFORM_HPP\n+\n+#include \"opto\/node.hpp\"\n+#include \"opto\/vectorization.hpp\"\n+\n+\/\/ VTransform\n+\/\/\n+\/\/ Maps the transformation from the scalar to the vectorized loop.\n+\/\/\n+\/\/ The graph (VTransformGraph) of vtnodes (VTransformNode) represents the output\n+\/\/ C2 graph after vectorization as closely as possible.\n+\/\/\n+\/\/ This allows us to schedule the graph, and check for possible cycles that\n+\/\/ vectorization might introduce.\n+\/\/\n+\/\/ Changes to the C2 IR are only made once the \"apply\" method is called, and\n+\/\/ each vtnode generates its corresponding scalar or vector C2 nodes.\n+\/\/\n+\/\/ Future Plans with VTransform:\n+\/\/ - Cost model: estimate if vectorization is profitable.\n+\/\/ - Optimizations: moving unordered reductions out of the loop, whih decreases cost.\n+\/\/ - Pack\/Unpack\/Shuffle: introduce additional nodes not present in the scalar loop.\n+\/\/                        This is difficult to do with the SuperWord packset approach.\n+\/\/ - If-conversion: convert predicated nodes into CFG.\n+\n+typedef int VTransformNodeIDX;\n+class VTransformNode;\n+class VTransformScalarNode;\n+class VTransformInputScalarNode;\n+class VTransformVectorNode;\n+class VTransformElementWiseVectorNode;\n+class VTransformBoolVectorNode;\n+class VTransformReductionVectorNode;\n+\n+\/\/ Result from a VTransformNode::apply\n+class VTransformApplyResult {\n+private:\n+  Node* const _node;\n+  const uint _vector_length; \/\/ number of elements\n+  const uint _vector_width;  \/\/ total width in bytes\n+\n+  VTransformApplyResult(Node* n, uint vector_length, uint vector_width) :\n+    _node(n),\n+    _vector_length(vector_length),\n+    _vector_width(vector_width) {}\n+\n+public:\n+  static VTransformApplyResult make_scalar(Node* n) {\n+    return VTransformApplyResult(n, 0, 0);\n+  }\n+\n+  static VTransformApplyResult make_vector(Node* n, uint vector_length, uint vector_width) {\n+    assert(vector_length > 0 && vector_width > 0, \"must have nonzero size\");\n+    return VTransformApplyResult(n, vector_length, vector_width);\n+  }\n+\n+  static VTransformApplyResult make_empty() {\n+    return VTransformApplyResult(nullptr, 0, 0);\n+  }\n+\n+  Node* node() const { return _node; }\n+  uint vector_length() const { return _vector_length; }\n+  uint vector_width() const { return _vector_width; }\n+  NOT_PRODUCT( void trace(VTransformNode* vtn) const; )\n+};\n+\n+\/\/ VTransformGraph is a graph of VTransformNode, which represent the VTransform. It\n+\/\/ is designed to resemble the C2 nodes after \"apply\" as closely as possible.\n+\/\/ Currently, there are these stages to the VTransform:\n+\/\/\n+\/\/  - Construction:\n+\/\/      external (e.g. with SuperWordVTransformBuilder)\n+\/\/\n+\/\/  - Schedule:\n+\/\/      compute linearization of graph, into a order that respects all edges in the\n+\/\/      graph (bailout if circle detected).\n+\/\/\n+\/\/  - Apply:\n+\/\/      Make all necessary changes to the C2 IR, each VTransformNode generates the\n+\/\/      corresponding scalar or vector C2 nodes.\n+\/\/\n+class VTransformGraph : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+  const VLoop& _vloop;\n+\n+  \/\/ Everything in the graph is allocated from this arena, including all vtnodes.\n+  Arena _arena;\n+\n+  VTransformNodeIDX _next_idx;\n+  GrowableArray<VTransformNode*> _vtnodes;\n+\n+  \/\/ Schedule (linearization) of the graph. We use this to reorder the memory graph\n+  \/\/ before inserting vector operations.\n+  GrowableArray<VTransformNode*> _schedule;\n+\n+  \/\/ Memory reference, and the alignment width (aw) for which we align the main-loop,\n+  \/\/ by adjusting the pre-loop limit.\n+  MemNode const* _mem_ref_for_main_loop_alignment;\n+  int _aw_for_main_loop_alignment;\n+\n+#ifndef PRODUCT\n+  bool _is_trace_rejections;\n+  bool _is_trace_align_vector;\n+  bool _is_trace_info;\n+  bool _is_trace_verbose;\n+#endif\n+\n+public:\n+  VTransformGraph(const VLoopAnalyzer& vloop_analyzer,\n+                  MemNode const* mem_ref_for_main_loop_alignment,\n+                  int aw_for_main_loop_alignment\n+                  NOT_PRODUCT( COMMA const bool is_trace_rejections)\n+                  NOT_PRODUCT( COMMA const bool is_trace_align_vector)\n+                  NOT_PRODUCT( COMMA const bool is_trace_info)\n+                  ) :\n+    _vloop_analyzer(vloop_analyzer),\n+    _vloop(vloop_analyzer.vloop()),\n+    _arena(mtCompiler),\n+    _next_idx(0),\n+    _vtnodes(&_arena, _vloop.estimated_body_length(), 0, nullptr),\n+    _schedule(&_arena, _vloop.estimated_body_length(), 0, nullptr),\n+    _mem_ref_for_main_loop_alignment(mem_ref_for_main_loop_alignment),\n+    _aw_for_main_loop_alignment(aw_for_main_loop_alignment)\n+    NOT_PRODUCT( COMMA _is_trace_rejections(is_trace_rejections) )\n+    NOT_PRODUCT( COMMA _is_trace_align_vector(is_trace_align_vector) )\n+    NOT_PRODUCT( COMMA _is_trace_info(is_trace_info) )\n+  {\n+#ifndef PRODUCT\n+    bool is_trace     = _vloop.vtrace().is_trace(TraceAutoVectorizationTag::VTRANSFORM);\n+    _is_trace_verbose = _vloop.vtrace().is_trace(TraceAutoVectorizationTag::ALL);\n+    _is_trace_rejections   |= is_trace || _is_trace_verbose;\n+    _is_trace_align_vector |= is_trace || _is_trace_verbose;\n+    _is_trace_info         |= is_trace || _is_trace_verbose;\n+#endif\n+  }\n+\n+  const VLoopAnalyzer& vloop_analyzer() const { return _vloop_analyzer; }\n+  Arena* arena() { return &_arena; }\n+  VTransformNodeIDX new_idx() { return _next_idx++; }\n+  void add_vtnode(VTransformNode* vtnode);\n+  bool is_empty() const { return _vtnodes.is_empty(); }\n+\n+  bool schedule();\n+  void apply();\n+\n+private:\n+  \/\/ VLoop accessors\n+  PhaseIdealLoop* phase()     const { return _vloop.phase(); }\n+  PhaseIterGVN& igvn()        const { return _vloop.phase()->igvn(); }\n+  IdealLoopTree* lpt()        const { return _vloop.lpt(); }\n+  CountedLoopNode* cl()       const { return _vloop.cl(); }\n+  int iv_stride()             const { return cl()->stride_con(); }\n+  bool in_bb(const Node* n)   const { return _vloop.in_bb(n); }\n+\n+  \/\/ VLoopVPointers accessors\n+  const VPointer& vpointer(const MemNode* mem) const {\n+    return _vloop_analyzer.vpointers().vpointer(mem);\n+  }\n+\n+  void schedule_collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const;\n+\n+  template<typename Callback>\n+  void for_each_memop_in_schedule(Callback callback) const;\n+\n+  void apply_memops_reordering_with_schedule() const;\n+\n+  \/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit.\n+  void determine_mem_ref_and_aw_for_main_loop_alignment();\n+  void adjust_pre_loop_limit_to_align_main_loop_vectors();\n+\n+  void apply_vectorization() const;\n+\n+#ifndef PRODUCT\n+  void print_vtnodes() const;\n+  void print_schedule() const;\n+  void print_memops_schedule() const;\n+  void trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n+                            const VectorSet& pre_visited,\n+                            const VectorSet& post_visited) const;\n+#endif\n+};\n+\n+\/\/ VTransformNodes resemble the C2 IR Nodes. They represent the resulting scalar and\n+\/\/ vector nodes as closely as possible.\n+class VTransformNode : public ArenaObj {\n+public:\n+  const VTransformNodeIDX _idx;\n+\n+private:\n+  \/\/ _in is split into required inputs (_req), and additional dependencies.\n+  const uint _req;\n+  GrowableArray<VTransformNode*> _in;\n+  GrowableArray<VTransformNode*> _out;\n+\n+public:\n+  VTransformNode(VTransformGraph& graph, const uint req) :\n+    _idx(graph.new_idx()),\n+    _req(req),\n+    _in(graph.arena(),  req, req, nullptr),\n+    _out(graph.arena(), 4, 0, nullptr)\n+  {\n+    graph.add_vtnode(this);\n+  }\n+\n+  void set_req(uint i, VTransformNode* n) {\n+    assert(i < _req, \"must be a req\");\n+    assert(_in.at(i) == nullptr && n != nullptr, \"only set once\");\n+    _in.at_put(i, n);\n+    n->add_out(this);\n+  }\n+\n+  void swap_req(uint i, uint j) {\n+    assert(i < _req, \"must be a req\");\n+    assert(j < _req, \"must be a req\");\n+    VTransformNode* tmp = _in.at(i);\n+    _in.at_put(i, _in.at(j));\n+    _in.at_put(j, tmp);\n+  }\n+\n+  void add_dependency(VTransformNode* n) {\n+    assert(n != nullptr, \"no need to add nullptr\");\n+    _in.push(n);\n+    n->add_out(this);\n+  }\n+\n+  void add_out(VTransformNode* n) {\n+    _out.push(n);\n+  }\n+\n+  uint req() const { return _req; }\n+  VTransformNode* in(int i) const { return _in.at(i); }\n+  int outs() const { return _out.length(); }\n+  VTransformNode* out(int i) const { return _out.at(i); }\n+\n+  bool has_req_or_dependency() const {\n+    for (int i = 0; i < _in.length(); i++) {\n+      if (_in.at(i) != nullptr) { return true; }\n+    }\n+    return false;\n+  }\n+\n+  virtual VTransformScalarNode* isa_Scalar() { return nullptr; }\n+  virtual VTransformInputScalarNode* isa_InputScalar() { return nullptr; }\n+  virtual VTransformVectorNode* isa_Vector() { return nullptr; }\n+  virtual VTransformElementWiseVectorNode* isa_ElementWiseVector() { return nullptr; }\n+  virtual VTransformBoolVectorNode* isa_BoolVector() { return nullptr; }\n+  virtual VTransformReductionVectorNode* isa_ReductionVector() { return nullptr; }\n+\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const = 0;\n+\n+  Node* find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const;\n+\n+  void register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const;\n+\n+  NOT_PRODUCT(virtual const char* name() const = 0;)\n+  NOT_PRODUCT(void print() const;)\n+  NOT_PRODUCT(virtual void print_spec() const {};)\n+  NOT_PRODUCT(static void print_node_idx(const VTransformNode* vtn);)\n+};\n+\n+\/\/ Identity transform for scalar nodes.\n+class VTransformScalarNode : public VTransformNode {\n+private:\n+  Node* _node;\n+public:\n+  VTransformScalarNode(VTransformGraph& graph, Node* n) :\n+    VTransformNode(graph, n->req()), _node(n) {}\n+  Node* node() const { return _node; }\n+  virtual VTransformScalarNode* isa_Scalar() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"Scalar\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Wrapper node for nodes outside the loop that are inputs to nodes in the loop.\n+\/\/ Since we want the loop-internal nodes to be able to reference all inputs as vtnodes,\n+\/\/ we must wrap the inputs that are outside the loop also into special vtnodes.\n+class VTransformInputScalarNode : public VTransformScalarNode {\n+public:\n+  VTransformInputScalarNode(VTransformGraph& graph, Node* n) :\n+    VTransformScalarNode(graph, n) {}\n+  virtual VTransformInputScalarNode* isa_InputScalar() override { return this; }\n+  NOT_PRODUCT(virtual const char* name() const override { return \"InputScalar\"; };)\n+};\n+\n+\/\/ Transform produces a ReplicateNode, replicating the input to all vector lanes.\n+class VTransformReplicateNode : public VTransformNode {\n+private:\n+  int _vlen;\n+  const Type* _element_type;\n+public:\n+  VTransformReplicateNode(VTransformGraph& graph, int vlen, const Type* element_type) :\n+    VTransformNode(graph, 2), _vlen(vlen), _element_type(element_type) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"Replicate\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Transform introduces a scalar ConvI2LNode that was not previously in the C2 graph.\n+class VTransformConvI2LNode : public VTransformNode {\n+public:\n+  VTransformConvI2LNode(VTransformGraph& graph) : VTransformNode(graph, 2) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ConvI2L\"; };)\n+};\n+\n+\/\/ Transform introduces a shift-count node, that truncates the shift count for a vector shift.\n+class VTransformShiftCountNode : public VTransformNode {\n+private:\n+  int _vlen;\n+  const BasicType _element_bt;\n+  juint _mask;\n+  int _shift_opcode;\n+public:\n+  VTransformShiftCountNode(VTransformGraph& graph, int vlen, BasicType element_bt, juint mask, int shift_opcode) :\n+    VTransformNode(graph, 2), _vlen(vlen), _element_bt(element_bt), _mask(mask), _shift_opcode(shift_opcode) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ShiftCount\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Transform introduces a PopulateIndex node: [phi, phi+1, phi+2, phi+3, ...].\n+class VTransformPopulateIndexNode : public VTransformNode {\n+private:\n+  int _vlen;\n+  const BasicType _element_bt;\n+public:\n+  VTransformPopulateIndexNode(VTransformGraph& graph, int vlen, const BasicType element_bt) :\n+    VTransformNode(graph, 2), _vlen(vlen), _element_bt(element_bt) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"PopulateIndex\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Base class for all vector vtnodes.\n+class VTransformVectorNode : public VTransformNode {\n+private:\n+  GrowableArray<Node*> _nodes;\n+public:\n+  VTransformVectorNode(VTransformGraph& graph, const uint req, const uint number_of_nodes) :\n+    VTransformNode(graph, req), _nodes(graph.arena(), number_of_nodes, number_of_nodes, nullptr) {}\n+\n+  void set_nodes(const Node_List* pack) {\n+    for (uint k = 0; k < pack->size(); k++) {\n+      _nodes.at_put(k, pack->at(k));\n+    }\n+  }\n+\n+  const GrowableArray<Node*> nodes() const { return _nodes; }\n+  virtual VTransformVectorNode* isa_Vector() override { return this; }\n+  void register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const;\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Catch all for all element-wise vector operations.\n+class VTransformElementWiseVectorNode : public VTransformVectorNode {\n+public:\n+  VTransformElementWiseVectorNode(VTransformGraph& graph, uint req, uint number_of_nodes) :\n+    VTransformVectorNode(graph, req, number_of_nodes) {}\n+  virtual VTransformElementWiseVectorNode* isa_ElementWiseVector() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ElementWiseVector\"; };)\n+};\n+\n+struct VTransformBoolTest {\n+  const BoolTest::mask _mask;\n+  const bool _is_negated;\n+\n+  VTransformBoolTest(const BoolTest::mask mask, bool is_negated) :\n+    _mask(mask), _is_negated(is_negated) {}\n+};\n+\n+class VTransformBoolVectorNode : public VTransformElementWiseVectorNode {\n+private:\n+  const VTransformBoolTest _test;\n+public:\n+  VTransformBoolVectorNode(VTransformGraph& graph, uint number_of_nodes, VTransformBoolTest test) :\n+    VTransformElementWiseVectorNode(graph, 2, number_of_nodes), _test(test) {}\n+  VTransformBoolTest test() const { return _test; }\n+  virtual VTransformBoolVectorNode* isa_BoolVector() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"BoolVector\"; };)\n+};\n+\n+class VTransformReductionVectorNode : public VTransformVectorNode {\n+public:\n+  \/\/ req = 3 -> [ctrl, scalar init, vector]\n+  VTransformReductionVectorNode(VTransformGraph& graph, uint number_of_nodes) :\n+    VTransformVectorNode(graph, 3, number_of_nodes) {}\n+  virtual VTransformReductionVectorNode* isa_ReductionVector() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ReductionVector\"; };)\n+};\n+\n+class VTransformLoadVectorNode : public VTransformVectorNode {\n+public:\n+  \/\/ req = 3 -> [ctrl, mem, adr]\n+  VTransformLoadVectorNode(VTransformGraph& graph, uint number_of_nodes) :\n+    VTransformVectorNode(graph, 3, number_of_nodes) {}\n+  LoadNode::ControlDependency control_dependency() const;\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"LoadVector\"; };)\n+};\n+\n+class VTransformStoreVectorNode : public VTransformVectorNode {\n+public:\n+  \/\/ req = 4 -> [ctrl, mem, adr, val]\n+  VTransformStoreVectorNode(VTransformGraph& graph, uint number_of_nodes) :\n+    VTransformVectorNode(graph, 4, number_of_nodes) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"StoreVector\"; };)\n+};\n+\n+\/\/ Invoke callback on all memops, in the order of the schedule.\n+template<typename Callback>\n+void VTransformGraph::for_each_memop_in_schedule(Callback callback) const {\n+  assert(_schedule.length() == _vtnodes.length(), \"schedule was computed\");\n+\n+  for (int i = 0; i < _schedule.length(); i++) {\n+    VTransformNode* vtn = _schedule.at(i);\n+\n+    \/\/ We can ignore input nodes, they are outside the loop.\n+    if (vtn->isa_InputScalar() != nullptr) { continue; }\n+\n+    VTransformScalarNode* scalar = vtn->isa_Scalar();\n+    if (scalar != nullptr && scalar->node()->is_Mem()) {\n+      callback(scalar->node()->as_Mem());\n+    }\n+\n+    VTransformVectorNode* vector = vtn->isa_Vector();\n+    if (vector != nullptr && vector->nodes().at(0)->is_Mem()) {\n+      for (int j = 0; j < vector->nodes().length(); j++) {\n+        callback(vector->nodes().at(j)->as_Mem());\n+      }\n+    }\n+  }\n+}\n+\n+#endif \/\/ SHARE_OPTO_VTRANSFORM_HPP\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":475,"deletions":0,"binary":false,"changes":475,"status":"added"}]}