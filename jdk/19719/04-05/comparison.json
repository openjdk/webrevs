{"files":[{"patch":"@@ -1895,1 +1895,1 @@\n-  assert(_schedule.is_nonempty(), \"must already be scheduled\");\n+  assert(_graph.is_scheduled(), \"must already be scheduled\");\n@@ -1917,0 +1917,1 @@\n+  assert(_graph.is_scheduled(), \"must be already scheduled\");\n@@ -1918,1 +1919,1 @@\n-    print_memops_schedule();\n+    _graph.print_memops_schedule();\n@@ -1947,1 +1948,1 @@\n-  for_each_memop_in_schedule([&] (MemNode* n) {\n+  _graph.for_each_memop_in_schedule([&] (MemNode* n) {\n@@ -2002,9 +2003,1 @@\n-\/\/ We call \"apply\" on every VTransformNode, which replaces the packed scalar nodes with vector nodes.\n-void VTransform::apply_vectorization() const {\n-  Compile* C = phase()->C;\n-#ifndef PRODUCT\n-  if (_is_trace_verbose) {\n-    tty->print_cr(\"\\nVTransform::apply_vectorization:\");\n-  }\n-#endif\n-\n+void VTransformGraph::apply_vectorization_for_each_vtnode(uint& max_vector_length, uint& max_vector_width NOT_PRODUCT( COMMA const bool is_trace_verbose)) const {\n@@ -2018,3 +2011,0 @@\n-  uint max_vector_length = 0; \/\/ number of elements\n-  uint max_vector_width  = 0; \/\/ total width in bytes\n-\n@@ -2025,1 +2015,1 @@\n-    NOT_PRODUCT( if (_is_trace_verbose) { result.trace(vtn); } )\n+    NOT_PRODUCT( if (is_trace_verbose) { result.trace(vtn); } )\n@@ -2031,0 +2021,14 @@\n+}\n+\n+\/\/ We call \"apply\" on every VTransformNode, which replaces the packed scalar nodes with vector nodes.\n+void VTransform::apply_vectorization() const {\n+  Compile* C = phase()->C;\n+#ifndef PRODUCT\n+  if (_is_trace_verbose) {\n+    tty->print_cr(\"\\nVTransform::apply_vectorization:\");\n+  }\n+#endif\n+\n+  uint max_vector_length = 0; \/\/ number of elements\n+  uint max_vector_width  = 0; \/\/ total width in bytes\n+  _graph.apply_vectorization_for_each_vtnode(max_vector_length, max_vector_width NOT_PRODUCT( COMMA _is_trace_verbose));\n@@ -2632,2 +2636,3 @@\n-  for (int i = 0; i < _vtnodes.length(); i++) {\n-    VTransformVectorNode* vtn = _vtnodes.at(i)->isa_Vector();\n+  const GrowableArray<VTransformNode*>& vtnodes = _graph.vtnodes();\n+  for (int i = 0; i < vtnodes.length(); i++) {\n+    VTransformVectorNode* vtn = vtnodes.at(i)->isa_Vector();\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":23,"deletions":18,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-void VTransform::add_vtnode(VTransformNode* vtnode) {\n+void VTransformGraph::add_vtnode(VTransformNode* vtnode) {\n@@ -46,0 +46,1 @@\n+\/\/ TODO: maybe do this in graph, but then tracing is an issue...\n@@ -47,1 +48,1 @@\n-  assert(_schedule.is_empty(), \"not yet scheduled\");\n+  assert(!_graph.is_scheduled(), \"not yet scheduled\");\n@@ -51,1 +52,1 @@\n-    print_vtnodes();\n+    _graph.print_vtnodes();\n@@ -60,1 +61,1 @@\n-  schedule_collect_nodes_without_req_or_dependency(stack);\n+  _graph.collect_nodes_without_req_or_dependency(stack);\n@@ -64,1 +65,1 @@\n-  int rpo_idx = _vtnodes.length() - 1;\n+  int rpo_idx = _graph.vtnodes().length() - 1;\n@@ -85,1 +86,1 @@\n-          NOT_PRODUCT(if (_is_trace_rejections) { trace_schedule_cycle(stack, pre_visited, post_visited); } )\n+          NOT_PRODUCT(if (_is_trace_rejections) { _graph.trace_schedule_cycle(stack, pre_visited, post_visited); } )\n@@ -94,2 +95,2 @@\n-        post_visited.set(vtn->_idx);           \/\/ post-visit\n-        _schedule.at_put_grow(rpo_idx--, vtn); \/\/ assign rpo_idx\n+        post_visited.set(vtn->_idx);                   \/\/ post-visit\n+        _graph.add_vtnode_to_schedule(rpo_idx--, vtn); \/\/ assign rpo_idx\n@@ -105,1 +106,1 @@\n-    print_schedule();\n+    _graph.print_schedule();\n@@ -114,1 +115,1 @@\n-void VTransform::schedule_collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const {\n+void VTransformGraph::collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const {\n@@ -124,1 +125,1 @@\n-void VTransform::trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n+void VTransformGraph::trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n@@ -354,2 +355,2 @@\n-void VTransform::print_vtnodes() const {\n-  tty->print_cr(\"\\nVTransform::print_vtnodes:\");\n+void VTransformGraph::print_vtnodes() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_vtnodes:\");\n@@ -361,2 +362,2 @@\n-void VTransform::print_schedule() const {\n-  tty->print_cr(\"\\nVTransform::print_schedule:\");\n+void VTransformGraph::print_schedule() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_schedule:\");\n@@ -374,2 +375,2 @@\n-void VTransform::print_memops_schedule() const {\n-  tty->print_cr(\"\\nVTransform::print_memops_schedule:\");\n+void VTransformGraph::print_memops_schedule() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_memops_schedule:\");\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -92,0 +92,45 @@\n+\/\/ TODO desc\n+class VTransformGraph : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+  const VLoop& _vloop;\n+\n+  VTransformNodeIDX _next_idx;\n+  GrowableArray<VTransformNode*> _vtnodes;\n+\n+  \/\/ Schedule (linearization) of the graph. We use this to reorder the memory graph\n+  \/\/ before inserting vector operations.\n+  GrowableArray<VTransformNode*> _schedule;\n+\n+public:\n+  VTransformGraph(const VLoopAnalyzer& vloop_analyzer, Arena& arena) :\n+    _vloop_analyzer(vloop_analyzer),\n+    _vloop(vloop_analyzer.vloop()),\n+    _next_idx(0),\n+    _vtnodes(&arena, _vloop.estimated_body_length(), 0, nullptr),\n+    _schedule(&arena, _vloop.estimated_body_length(), 0, nullptr) {}\n+\n+  VTransformNodeIDX new_idx() { return _next_idx++; }\n+  void add_vtnode(VTransformNode* vtnode);\n+  bool is_empty() const { return _vtnodes.is_empty(); }\n+  bool is_scheduled() const { return _schedule.is_nonempty(); }\n+  const GrowableArray<VTransformNode*>& vtnodes() const { return _vtnodes; }\n+  void add_vtnode_to_schedule(int index, VTransformNode* vtn) { _schedule.at_put_grow(index, vtn); }\n+\n+  template<typename Callback>\n+  void for_each_memop_in_schedule(Callback callback) const;\n+\n+  void collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const;\n+\n+  void apply_vectorization_for_each_vtnode(uint& max_vector_length, uint& max_vector_width NOT_PRODUCT( COMMA const bool is_trace_verbose)) const;\n+\n+#ifndef PRODUCT\n+  void print_vtnodes() const;\n+  void print_schedule() const;\n+  void print_memops_schedule() const;\n+  void trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n+                            const VectorSet& pre_visited,\n+                            const VectorSet& post_visited) const;\n+#endif\n+};\n+\n@@ -116,6 +161,1 @@\n-  VTransformNodeIDX _next_idx;\n-  GrowableArray<VTransformNode*> _vtnodes;\n-\n-  \/\/ Schedule (linearization) of the graph. We use this to reorder the memory graph\n-  \/\/ before inserting vector operations.\n-  GrowableArray<VTransformNode*> _schedule;\n+  VTransformGraph _graph;\n@@ -146,3 +186,1 @@\n-    _next_idx(0),\n-    _vtnodes(&_arena, _vloop.estimated_body_length(), 0, nullptr),\n-    _schedule(&_arena, _vloop.estimated_body_length(), 0, nullptr),\n+    _graph(_vloop_analyzer, _arena),\n@@ -166,3 +204,2 @@\n-  VTransformNodeIDX new_idx() { return _next_idx++; }\n-  void add_vtnode(VTransformNode* vtnode);\n-  bool is_empty() const { return _vtnodes.is_empty(); }\n+  bool is_empty() const { return _graph.is_empty(); }\n+  VTransformGraph& graph() { return _graph; }\n@@ -187,5 +224,0 @@\n-  void schedule_collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const;\n-\n-  template<typename Callback>\n-  void for_each_memop_in_schedule(Callback callback) const;\n-\n@@ -199,9 +231,0 @@\n-\n-#ifndef PRODUCT\n-  void print_vtnodes() const;\n-  void print_schedule() const;\n-  void print_memops_schedule() const;\n-  void trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n-                            const VectorSet& pre_visited,\n-                            const VectorSet& post_visited) const;\n-#endif\n@@ -224,1 +247,1 @@\n-    _idx(vtransform.new_idx()),\n+    _idx(vtransform.graph().new_idx()),\n@@ -229,1 +252,1 @@\n-    vtransform.add_vtnode(this);\n+    vtransform.graph().add_vtnode(this);\n@@ -454,1 +477,1 @@\n-void VTransform::for_each_memop_in_schedule(Callback callback) const {\n+void VTransformGraph::for_each_memop_in_schedule(Callback callback) const {\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":52,"deletions":29,"binary":false,"changes":81,"status":"modified"}]}