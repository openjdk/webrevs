{"files":[{"patch":"@@ -25,3 +25,0 @@\n-#include \"libadt\/vectset.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n@@ -29,1 +26,0 @@\n-#include \"opto\/c2compiler.hpp\"\n@@ -32,5 +28,0 @@\n-#include \"opto\/matcher.hpp\"\n-#include \"opto\/memnode.hpp\"\n-#include \"opto\/opcodes.hpp\"\n-#include \"opto\/opaquenode.hpp\"\n-#include \"opto\/rootnode.hpp\"\n@@ -38,0 +29,1 @@\n+#include \"opto\/superwordVTransformBuilder.hpp\"\n@@ -40,1 +32,0 @@\n-#include \"utilities\/powerOfTwo.hpp\"\n@@ -710,1 +701,1 @@\n-  \/\/ and will still be vectorized by SuperWord::vector_opd.\n+  \/\/ and will still be vectorized by SuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index.\n@@ -772,2 +763,3 @@\n-\/\/ Look for pattern n1 = (iv + c) and n2 = (iv + c + 1), which may lead to PopulateIndex vector node.\n-\/\/ We skip the pack creation of these nodes. They will be vectorized by SuperWord::vector_opd.\n+\/\/ Look for pattern n1 = (iv + c) and n2 = (iv + c + 1), which may lead to\n+\/\/ PopulateIndex vector node. We skip the pack creation of these nodes. They\n+\/\/ will be vectorized by SuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index.\n@@ -1861,177 +1853,2 @@\n-\/\/ The PacksetGraph combines the dependency graph with the packset. In the PackSet\n-\/\/ graph, we have two kinds of nodes:\n-\/\/  (1) pack-node:   Represents all nodes of some pack p in a single node, which\n-\/\/                   shall later become a vector node.\n-\/\/  (2) scalar-node: Represents a node that is not in any pack.\n-\/\/ For any edge (n1, n2) in the dependency graph, we add an edge to the PacksetGraph for\n-\/\/ the PacksetGraph nodes corresponding to n1 and n2.\n-\/\/ We work from the dependency graph, because it gives us all the data-dependencies,\n-\/\/ as well as more refined memory-dependencies than the C2 graph. The dependency graph\n-\/\/ does not have cycles. But packing nodes can introduce cyclic dependencies. Example:\n-\/\/\n-\/\/                                                       +--------+\n-\/\/  A -> X                                               |        v\n-\/\/                     Pack [A,B] and [X,Y]             [A,B]    [X,Y]\n-\/\/  Y -> B                                                 ^        |\n-\/\/                                                         +--------+\n-\/\/\n-class PacksetGraph {\n-private:\n-  \/\/ pid: packset graph node id.\n-  GrowableArray<int> _pid;                 \/\/ bb_idx(n) -> pid\n-  GrowableArray<Node*> _pid_to_node;       \/\/ one node per pid, find rest via _packset.pack\n-  GrowableArray<GrowableArray<int>> _out;  \/\/ out-edges\n-  GrowableArray<int> _incnt;               \/\/ number of (implicit) in-edges\n-  int _max_pid = 0;\n-\n-  bool _schedule_success;\n-\n-  SuperWord* _slp;\n-public:\n-  PacksetGraph(SuperWord* slp)\n-  : _pid(8, 0, \/* default *\/ 0), _slp(slp) {\n-  }\n-  \/\/ Get pid, if there is a packset node that n belongs to. Else return 0.\n-  int get_pid_or_zero(const Node* n) const {\n-    if (!_slp->in_bb(n)) {\n-      return 0;\n-    }\n-    int idx = _slp->bb_idx(n);\n-    if (idx >= _pid.length()) {\n-      return 0;\n-    } else {\n-      return _pid.at(idx);\n-    }\n-  }\n-  int get_pid(const Node* n) {\n-    int poz = get_pid_or_zero(n);\n-    assert(poz != 0, \"pid should not be zero\");\n-    return poz;\n-  }\n-  void set_pid(Node* n, int pid) {\n-    assert(n != nullptr && pid > 0, \"sane inputs\");\n-    assert(_slp->in_bb(n), \"must be\");\n-    int idx = _slp->bb_idx(n);\n-    _pid.at_put_grow(idx, pid);\n-    _pid_to_node.at_put_grow(pid - 1, n, nullptr);\n-  }\n-  Node* get_node(int pid) {\n-    assert(pid > 0 && pid <= _pid_to_node.length(), \"pid must be mapped\");\n-    Node* n = _pid_to_node.at(pid - 1);\n-    assert(n != nullptr, \"sanity\");\n-    return n;\n-  }\n-  int new_pid() {\n-    _incnt.push(0);\n-    _out.push(GrowableArray<int>());\n-    return ++_max_pid;\n-  }\n-  int incnt(int pid) { return _incnt.at(pid - 1); }\n-  void incnt_set(int pid, int cnt) { return _incnt.at_put(pid - 1, cnt); }\n-  GrowableArray<int>& out(int pid) { return _out.at(pid - 1); }\n-  bool schedule_success() const { return _schedule_success; }\n-\n-  \/\/ Create nodes (from packs and scalar-nodes), and add edges, based on the dependency graph.\n-  void build() {\n-    const PackSet& packset = _slp->packset();\n-    const GrowableArray<Node*>& body = _slp->body();\n-    \/\/ Map nodes in packsets\n-    for (int i = 0; i < packset.length(); i++) {\n-      Node_List* p = packset.at(i);\n-      int pid = new_pid();\n-      for (uint k = 0; k < p->size(); k++) {\n-        Node* n = p->at(k);\n-        set_pid(n, pid);\n-        assert(packset.get_pack(n) == p, \"matching packset\");\n-      }\n-    }\n-\n-    int max_pid_packset = _max_pid;\n-\n-    \/\/ Map nodes not in packset\n-    for (int i = 0; i < body.length(); i++) {\n-      Node* n = body.at(i);\n-      if (n->is_Phi() || n->is_CFG()) {\n-        continue; \/\/ ignore control flow\n-      }\n-      int pid = get_pid_or_zero(n);\n-      if (pid == 0) {\n-        pid = new_pid();\n-        set_pid(n, pid);\n-        assert(packset.get_pack(n) == nullptr, \"no packset\");\n-      }\n-    }\n-\n-    \/\/ Map edges for packset nodes\n-    VectorSet set;\n-    for (int i = 0; i < packset.length(); i++) {\n-      Node_List* p = packset.at(i);\n-      set.clear();\n-      int pid = get_pid(p->at(0));\n-      for (uint k = 0; k < p->size(); k++) {\n-        Node* n = p->at(k);\n-        assert(pid == get_pid(n), \"all nodes in pack have same pid\");\n-        for (VLoopDependencyGraph::PredsIterator preds(_slp->dependency_graph(), n); !preds.done(); preds.next()) {\n-          Node* pred = preds.current();\n-          int pred_pid = get_pid_or_zero(pred);\n-          if (pred_pid == pid && _slp->is_marked_reduction(n)) {\n-            continue; \/\/ reduction -> self-cycle is not a cyclic dependency\n-          }\n-          \/\/ Only add edges once, and only for mapped nodes (in body)\n-          if (pred_pid > 0 && !set.test_set(pred_pid)) {\n-            incnt_set(pid, incnt(pid) + 1); \/\/ increment\n-            out(pred_pid).push(pid);\n-          }\n-        }\n-      }\n-    }\n-\n-    \/\/ Map edges for nodes not in packset\n-    for (int i = 0; i < body.length(); i++) {\n-      Node* n = body.at(i);\n-      int pid = get_pid_or_zero(n); \/\/ zero for Phi or CFG\n-      if (pid <= max_pid_packset) {\n-        continue; \/\/ Only scalar-nodes\n-      }\n-      for (VLoopDependencyGraph::PredsIterator preds(_slp->dependency_graph(), n); !preds.done(); preds.next()) {\n-        Node* pred = preds.current();\n-        int pred_pid = get_pid_or_zero(pred);\n-        \/\/ Only add edges for mapped nodes (in body)\n-        if (pred_pid > 0) {\n-          incnt_set(pid, incnt(pid) + 1); \/\/ increment\n-          out(pred_pid).push(pid);\n-        }\n-      }\n-    }\n-  }\n-\n-  \/\/ Schedule nodes of PacksetGraph to worklist, using topsort: schedule a node\n-  \/\/ that has zero incnt. If a PacksetGraph node corresponds to memops, then add\n-  \/\/ those to the memops_schedule. At the end, we return the memops_schedule, and\n-  \/\/ note if topsort was successful.\n-  Node_List schedule() {\n-    Node_List memops_schedule;\n-    GrowableArray<int> worklist;\n-    \/\/ Directly schedule all nodes without precedence\n-    for (int pid = 1; pid <= _max_pid; pid++) {\n-      if (incnt(pid) == 0) {\n-        worklist.push(pid);\n-      }\n-    }\n-    \/\/ Continue scheduling via topological sort\n-    for (int i = 0; i < worklist.length(); i++) {\n-      int pid = worklist.at(i);\n-\n-      \/\/ Add memops to memops_schedule\n-      Node* n = get_node(pid);\n-      Node_List* p = _slp->packset().get_pack(n);\n-      if (n->is_Mem()) {\n-        if (p == nullptr) {\n-          memops_schedule.push(n);\n-        } else {\n-          for (uint k = 0; k < p->size(); k++) {\n-            memops_schedule.push(p->at(k));\n-            assert(p->at(k)->is_Mem(), \"only schedule memops\");\n-          }\n-        }\n-      }\n+bool SuperWord::schedule_and_apply() const {\n+  if (_packset.is_empty()) { return false; }\n@@ -2039,32 +1856,1 @@\n-      \/\/ Decrement incnt for all successors\n-      for (int j = 0; j < out(pid).length(); j++){\n-        int pid_use = out(pid).at(j);\n-        int incnt_use = incnt(pid_use) - 1;\n-        incnt_set(pid_use, incnt_use);\n-        \/\/ Did use lose its last input?\n-        if (incnt_use == 0) {\n-          worklist.push(pid_use);\n-        }\n-      }\n-    }\n-\n-    \/\/ Was every pid scheduled? If not, we found some cycles in the PacksetGraph.\n-    _schedule_success = (worklist.length() == _max_pid);\n-    return memops_schedule;\n-  }\n-\n-  \/\/ Print the PacksetGraph.\n-  \/\/ print_nodes = true: print all C2 nodes beloning to PacksetGrahp node.\n-  \/\/ print_zero_incnt = false: do not print nodes that have no in-edges (any more).\n-  void print(bool print_nodes, bool print_zero_incnt) {\n-    const GrowableArray<Node*> &body = _slp->body();\n-    tty->print_cr(\"PacksetGraph\");\n-    for (int pid = 1; pid <= _max_pid; pid++) {\n-      if (incnt(pid) == 0 && !print_zero_incnt) {\n-        continue;\n-      }\n-      tty->print(\"Node %d. incnt %d [\", pid, incnt(pid));\n-      for (int j = 0; j < out(pid).length(); j++) {\n-        tty->print(\"%d \", out(pid).at(j));\n-      }\n-      tty->print_cr(\"]\");\n+  \/\/ Make an empty transform.\n@@ -2072,9 +1858,4 @@\n-      if (print_nodes) {\n-        for (int i = 0; i < body.length(); i++) {\n-          Node* n = body.at(i);\n-          if (get_pid_or_zero(n) == pid) {\n-            tty->print(\"    \");\n-            n->dump();\n-          }\n-        }\n-      }\n+  VTransformTrace trace(_vloop.vtrace(),\n+                        is_trace_superword_rejections(),\n+                        is_trace_align_vector(),\n+                        is_trace_superword_info());\n@@ -2082,21 +1863,5 @@\n-    }\n-  }\n-};\n-\n-\/\/ We want to replace the packed scalars from the PackSet and replace them\n-\/\/ with vector operations. This requires scheduling and re-ordering the memory\n-\/\/ graph. We take these steps:\n-\/\/ (1) Build the PacksetGraph. It combines the dependency graph with the\n-\/\/     packset. The PacksetGraph gives us the dependencies that must be\n-\/\/     respected after scheduling.\n-\/\/ (2) Schedule the PacksetGraph to the memops_schedule, which represents\n-\/\/     a linear order of all memops in the body. The order respects the\n-\/\/     dependencies of the PacksetGraph.\n-\/\/ (3) If the PacksetGraph has cycles, we cannot schedule. Abort.\n-\/\/ (4) Apply the vectorization, including re-ordering the memops and replacing\n-\/\/     packed scalars with vector operations.\n-bool SuperWord::schedule_and_apply() {\n-  if (_packset.is_empty()) {\n-    return false;\n-  }\n-  ResourceMark rm;\n+  VTransform vtransform(_vloop_analyzer,\n+                        _mem_ref_for_main_loop_alignment,\n+                        _aw_for_main_loop_alignment\n+                        NOT_PRODUCT(COMMA trace)\n+                        );\n@@ -2104,3 +1869,5 @@\n-  \/\/ (1) Build the PacksetGraph.\n-  PacksetGraph graph(this);\n-  graph.build();\n+  \/\/ Build the transform from the packset.\n+  {\n+    ResourceMark rm;\n+    SuperWordVTransformBuilder builder(_packset, vtransform);\n+  }\n@@ -2108,2 +1875,4 @@\n-  \/\/ (2) Schedule the PacksetGraph.\n-  Node_List memops_schedule = graph.schedule();\n+  if (!vtransform.schedule()) { return false; }\n+  vtransform.apply();\n+  return true;\n+}\n@@ -2111,7 +1880,3 @@\n-  \/\/ (3) Check if the PacksetGraph schedule succeeded (had no cycles).\n-  \/\/ We now know that we only have independent packs, see verify_packs.\n-  \/\/ This is a necessary but not a sufficient condition for an acyclic\n-  \/\/ graph (DAG) after scheduling. Thus, we must check if the packs have\n-  \/\/ introduced a cycle. The SuperWord paper mentions the need for this\n-  \/\/ in \"3.7 Scheduling\".\n-  if (!graph.schedule_success()) {\n+\/\/ Apply the vectorization, i.e. we irreversibly edit the C2 graph. At this point, all\n+\/\/ correctness and profitability checks have passed, and the graph was successfully scheduled.\n+void VTransform::apply() {\n@@ -2119,8 +1884,4 @@\n-    if (is_trace_superword_rejections()) {\n-      tty->print_cr(\"SuperWord::schedule found cycle in PacksetGraph:\");\n-      graph.print(true, false);\n-      tty->print_cr(\"removing all packs from packset.\");\n-    }\n-#endif\n-    _packset.clear();\n-    return false;\n+  if (_trace._info || TraceLoopOpts) {\n+    tty->print_cr(\"\\nVTransform::apply:\");\n+    lpt()->dump_head();\n+    lpt()->head()->dump();\n@@ -2128,0 +1889,3 @@\n+  assert(cl()->is_main_loop(), \"auto vectorization only for main loops\");\n+  assert(_graph.is_scheduled(), \"must already be scheduled\");\n+#endif\n@@ -2129,5 +1893,0 @@\n-  \/\/ (4) Apply the vectorization, including re-ordering the memops.\n-  return apply(memops_schedule);\n-}\n-\n-bool SuperWord::apply(Node_List& memops_schedule) {\n@@ -2135,2 +1894,1 @@\n-  CountedLoopNode* cl = lpt()->_head->as_CountedLoop();\n-  C->print_method(PHASE_AUTO_VECTORIZATION1_BEFORE_APPLY, 4, cl);\n+  C->print_method(PHASE_AUTO_VECTORIZATION1_BEFORE_APPLY, 4, cl());\n@@ -2138,2 +1896,2 @@\n-  apply_memops_reordering_with_schedule(memops_schedule);\n-  C->print_method(PHASE_AUTO_VECTORIZATION2_AFTER_REORDER, 4, cl);\n+  _graph.apply_memops_reordering_with_schedule();\n+  C->print_method(PHASE_AUTO_VECTORIZATION2_AFTER_REORDER, 4, cl());\n@@ -2142,4 +1900,1 @@\n-  C->print_method(PHASE_AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT, 4, cl);\n-\n-  bool is_success = apply_vectorization();\n-  C->print_method(PHASE_AUTO_VECTORIZATION4_AFTER_APPLY, 4, cl);\n+  C->print_method(PHASE_AUTO_VECTORIZATION3_AFTER_ADJUST_LIMIT, 4, cl());\n@@ -2147,1 +1902,2 @@\n-  return is_success;\n+  apply_vectorization();\n+  C->print_method(PHASE_AUTO_VECTORIZATION4_AFTER_APPLY, 4, cl());\n@@ -2150,3 +1906,5 @@\n-\/\/ Reorder the memory graph for all slices in parallel. We walk over the schedule once,\n-\/\/ and track the current memory state of each slice.\n-void SuperWord::apply_memops_reordering_with_schedule(Node_List& memops_schedule) {\n+\/\/ We prepare the memory graph for the replacement of scalar memops with vector memops.\n+\/\/ We reorder all slices in parallel, ensuring that the memops inside each slice are\n+\/\/ ordered according to the _schedule. This means that all packed memops are consecutive\n+\/\/ in the memory graph after the reordering.\n+void VTransformGraph::apply_memops_reordering_with_schedule() const {\n@@ -2154,3 +1912,3 @@\n-  if (is_trace_superword_info()) {\n-    tty->print_cr(\"\\nSuperWord::apply_memops_reordering_with_schedule:\");\n-    memops_schedule.dump();\n+  assert(is_scheduled(), \"must be already scheduled\");\n+  if (_trace._info) {\n+    print_memops_schedule();\n@@ -2160,0 +1918,1 @@\n+  ResourceMark rm;\n@@ -2161,1 +1920,1 @@\n-  \/\/ When iterating over the memops_schedule, we keep track of the current memory state,\n+  \/\/ When iterating over the schedule, we keep track of the current memory state,\n@@ -2182,1 +1941,1 @@\n-  \/\/ (2) Walk over memops_schedule, append memops to the current state\n+  \/\/ (2) Walk over schedule, append memops to the current state\n@@ -2184,2 +1943,1 @@\n-  for (uint i = 0; i < memops_schedule.size(); i++) {\n-    MemNode* n = memops_schedule.at(i)->as_Mem();\n+  for_each_memop_in_schedule([&] (MemNode* n) {\n@@ -2201,1 +1959,1 @@\n-  }\n+  });\n@@ -2206,1 +1964,1 @@\n-  Node_List uses_after_loop;\n+  GrowableArray<Node*> uses_after_loop;\n@@ -2228,1 +1986,1 @@\n-    for (uint k = 0; k < uses_after_loop.size(); k++) {\n+    for (int k = 0; k < uses_after_loop.length(); k++) {\n@@ -2240,60 +1998,7 @@\n-\/\/ Convert packs into vector node operations\n-\/\/ At this point, all correctness and profitability checks have passed.\n-\/\/ We start the irreversible process of editing the C2 graph. Should\n-\/\/ there be an unexpected situation (assert fails), then we can only\n-\/\/ bail out of the compilation, as the graph has already been partially\n-\/\/ modified. We bail out, and retry without SuperWord.\n-bool SuperWord::apply_vectorization() {\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  assert(cl->is_main_loop(), \"SLP should only work on main loops\");\n-  Compile* C = phase()->C;\n-  assert(!_packset.is_empty(), \"vectorization requires non-empty packset\");\n-\n-#ifndef PRODUCT\n-  if (TraceLoopOpts) {\n-    tty->print(\"SuperWord::apply_vectorization \");\n-    lpt()->dump_head();\n-  }\n-#endif\n-\n-  uint max_vlen_in_bytes = 0;\n-  uint max_vlen = 0;\n-\n-  for (int i = 0; i < body().length(); i++) {\n-    Node* n = body().at(i);\n-    Node_List* p = get_pack(n);\n-    if (p != nullptr && n == p->at(p->size()-1)) {\n-      \/\/ After apply_memops_reordering_with_schedule, we know that the memops have the same order in the pack\n-      \/\/ as in the memory slice. Hence, \"first\" is the first memop in the slice from the pack,\n-      \/\/ and \"n\" is the last node in the slice from the pack.\n-      Node* first = p->at(0);\n-      uint vlen = p->size();\n-      uint vlen_in_bytes = 0;\n-      Node* vn = nullptr;\n-      int   opc = n->Opcode();\n-      if (n->is_Load()) {\n-        Node* ctl = n->in(MemNode::Control);\n-        Node* mem = first->in(MemNode::Memory);\n-        \/\/ Set the memory dependency of the LoadVector as early as possible.\n-        \/\/ Walk up the memory chain, and ignore any StoreVector that provably\n-        \/\/ does not have any memory dependency.\n-        while (mem->is_StoreVector()) {\n-          VPointer p_store(mem->as_Mem(), _vloop);\n-          if (p_store.overlap_possible_with_any_in(p)) {\n-            break;\n-          } else {\n-            mem = mem->in(MemNode::Memory);\n-          }\n-        }\n-        Node* adr = first->in(MemNode::Address);\n-        const TypePtr* atyp = n->adr_type();\n-        vn = LoadVectorNode::make(opc, ctl, mem, adr, atyp, vlen, velt_basic_type(n), control_dependency(p));\n-        vlen_in_bytes = vn->as_LoadVector()->memory_size();\n-      } else if (n->is_Store()) {\n-        \/\/ Promote value to be stored to vector\n-        Node* val = vector_opd(p, MemNode::ValueIn);\n-        if (val == nullptr) {\n-          assert(false, \"input to vector store was not created\");\n-          C->record_failure(C2Compiler::retry_no_superword());\n-          return false; \/\/ bailout\n-        }\n+void VTransformGraph::apply_vectorization_for_each_vtnode(uint& max_vector_length, uint& max_vector_width) const {\n+  ResourceMark rm;\n+  \/\/ We keep track of the resulting Nodes from every \"VTransformNode::apply\" call.\n+  \/\/ Since \"apply\" is called on defs before uses, this allows us to find the\n+  \/\/ generated def (input) nodes when we are generating the use nodes in \"apply\".\n+  int length = _vtnodes.length();\n+  GrowableArray<Node*> vtnode_idx_to_transformed_node(length, length, nullptr);\n@@ -2301,65 +2006,5 @@\n-        Node* ctl = n->in(MemNode::Control);\n-        Node* mem = first->in(MemNode::Memory);\n-        Node* adr = first->in(MemNode::Address);\n-        const TypePtr* atyp = n->adr_type();\n-        vn = StoreVectorNode::make(opc, ctl, mem, adr, atyp, val, vlen);\n-        vlen_in_bytes = vn->as_StoreVector()->memory_size();\n-      } else if (VectorNode::is_scalar_rotate(n)) {\n-        Node* in1 = vector_opd(p, 1);\n-        Node* in2 = first->in(2);\n-        \/\/ If rotation count is non-constant or greater than 8bit value create a vector.\n-        if (!in2->is_Con() || !Matcher::supports_vector_constant_rotates(in2->get_int())) {\n-          in2 =  vector_opd(p, 2);\n-        }\n-        vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (VectorNode::is_roundopD(n)) {\n-        Node* in1 = vector_opd(p, 1);\n-        Node* in2 = first->in(2);\n-        assert(in2->is_Con(), \"Constant rounding mode expected.\");\n-        vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (VectorNode::is_muladds2i(n)) {\n-        assert(n->req() == 5u, \"MulAddS2I should have 4 operands.\");\n-        Node* in1 = vector_opd(p, 1);\n-        Node* in2 = vector_opd(p, 2);\n-        vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (opc == Op_SignumF || opc == Op_SignumD) {\n-        assert(n->req() == 4, \"four inputs expected\");\n-        Node* in = vector_opd(p, 1);\n-        Node* zero = vector_opd(p, 2);\n-        Node* one = vector_opd(p, 3);\n-        vn = VectorNode::make(opc, in, zero, one, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (n->is_Cmp()) {\n-        \/\/ Bool + Cmp + CMove -> VectorMaskCmp + VectorBlend\n-        continue;\n-      } else if (n->is_Bool()) {\n-        \/\/ Bool + Cmp + CMove -> VectorMaskCmp + VectorBlend\n-        continue;\n-      } else if (n->is_CMove()) {\n-        \/\/ Bool + Cmp + CMove -> VectorMaskCmp + VectorBlend\n-\n-        BoolNode* bol = n->in(1)->as_Bool();\n-        assert(bol != nullptr, \"must have Bool above CMove\");\n-        Node_List* bool_pack = get_pack(bol);\n-        assert(bool_pack != nullptr, \"CMove must have matching Bool pack\");\n-\n-        CmpNode* cmp = bol->in(1)->as_Cmp();\n-        assert(cmp != nullptr, \"must have cmp above CMove\");\n-        Node_List* cmp_pack = get_pack(cmp);\n-        assert(cmp_pack != nullptr, \"Bool must have matching Cmp pack\");\n-\n-        Node* cmp_in1 = vector_opd(cmp_pack, 1);\n-        Node* cmp_in2 = vector_opd(cmp_pack, 2);\n-\n-        Node* blend_in1 = vector_opd(p, 2);\n-        Node* blend_in2 = vector_opd(p, 3);\n-\n-        VTransformBoolTest bool_test = _packset.get_bool_test(bool_pack);\n-        BoolTest::mask test_mask = bool_test._mask;\n-        if (bool_test._is_negated) {\n-           \/\/ We can cancel out the negation by swapping the blend inputs.\n-           swap(blend_in1, blend_in2);\n-        }\n+  for (int i = 0; i < _schedule.length(); i++) {\n+    VTransformNode* vtn = _schedule.at(i);\n+    VTransformApplyResult result = vtn->apply(_vloop_analyzer,\n+                                              vtnode_idx_to_transformed_node);\n+    NOT_PRODUCT( if (_trace._verbose) { result.trace(vtn); } )\n@@ -2367,90 +2012,5 @@\n-        \/\/ VectorMaskCmp\n-        ConINode* test_mask_node  = igvn().intcon((int)test_mask);\n-        BasicType bt = velt_basic_type(cmp);\n-        const TypeVect* vt = TypeVect::make(bt, vlen);\n-        VectorNode* mask = new VectorMaskCmpNode(test_mask, cmp_in1, cmp_in2, test_mask_node, vt);\n-        phase()->register_new_node_with_ctrl_of(mask, p->at(0));\n-        igvn()._worklist.push(mask);\n-\n-        \/\/ VectorBlend\n-        vn = new VectorBlendNode(blend_in1, blend_in2, mask);\n-      } else if (n->req() == 3) {\n-        \/\/ Promote operands to vector\n-        Node* in1 = nullptr;\n-        bool node_isa_reduction = is_marked_reduction(n);\n-        if (node_isa_reduction) {\n-          \/\/ the input to the first reduction operation is retained\n-          in1 = first->in(1);\n-        } else {\n-          in1 = vector_opd(p, 1);\n-          if (in1 == nullptr) {\n-            assert(false, \"input in1 to vector operand was not created\");\n-            C->record_failure(C2Compiler::retry_no_superword());\n-            return false; \/\/ bailout\n-          }\n-        }\n-        Node* in2 = vector_opd(p, 2);\n-        if (in2 == nullptr) {\n-          assert(false, \"input in2 to vector operand was not created\");\n-          C->record_failure(C2Compiler::retry_no_superword());\n-          return false; \/\/ bailout\n-        }\n-        if (in1->Opcode() == Op_Replicate && (node_isa_reduction == false) && (n->is_Add() || n->is_Mul())) {\n-          \/\/ Move invariant vector input into second position to avoid register spilling.\n-          Node* tmp = in1;\n-          in1 = in2;\n-          in2 = tmp;\n-        }\n-        if (node_isa_reduction) {\n-          const Type *arith_type = n->bottom_type();\n-          vn = ReductionNode::make(opc, nullptr, in1, in2, arith_type->basic_type());\n-          if (in2->is_Load()) {\n-            vlen_in_bytes = in2->as_LoadVector()->memory_size();\n-          } else {\n-            vlen_in_bytes = in2->as_Vector()->length_in_bytes();\n-          }\n-        } else {\n-          if (VectorNode::can_use_RShiftI_instead_of_URShiftI(n, velt_basic_type(n))) {\n-            opc = Op_RShiftI;\n-          }\n-          vn = VectorNode::make(opc, in1, in2, vlen, velt_basic_type(n));\n-          vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-        }\n-      } else if (VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc)) {\n-        assert(n->req() == 2, \"only one input expected\");\n-        Node* in = vector_opd(p, 1);\n-        vn = VectorNode::make(opc, in, nullptr, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc)) {\n-        assert(n->req() == 2, \"only one input expected\");\n-        Node* in = vector_opd(p, 1);\n-        Node* longval = VectorNode::make(opc, in, nullptr, vlen, T_LONG);\n-        phase()->register_new_node_with_ctrl_of(longval, first);\n-        \/\/ Requires extra vector long -> int conversion.\n-        vn = VectorCastNode::make(Op_VectorCastL2X, longval, T_INT, vlen);\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (VectorNode::is_convert_opcode(opc)) {\n-        assert(n->req() == 2, \"only one input expected\");\n-        BasicType bt = velt_basic_type(n);\n-        Node* in = vector_opd(p, 1);\n-        int vopc = VectorCastNode::opcode(opc, in->bottom_type()->is_vect()->element_basic_type());\n-        vn = VectorCastNode::make(vopc, in, bt, vlen);\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else if (opc == Op_FmaD || opc == Op_FmaF) {\n-        \/\/ Promote operands to vector\n-        Node* in1 = vector_opd(p, 1);\n-        Node* in2 = vector_opd(p, 2);\n-        Node* in3 = vector_opd(p, 3);\n-        vn = VectorNode::make(opc, in1, in2, in3, vlen, velt_basic_type(n));\n-        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n-      } else {\n-        assert(false, \"Unhandled scalar opcode (%s)\", NodeClassNames[opc]);\n-        C->record_failure(C2Compiler::retry_no_superword());\n-        return false; \/\/ bailout\n-      }\n-\n-      if (vn == nullptr) {\n-        assert(false, \"got null node instead of vector node\");\n-        C->record_failure(C2Compiler::retry_no_superword());\n-        return false; \/\/ bailout\n-      }\n+    vtnode_idx_to_transformed_node.at_put(vtn->_idx, result.node());\n+    max_vector_length = MAX2(max_vector_length, result.vector_length());\n+    max_vector_width  = MAX2(max_vector_width,  result.vector_width());\n+  }\n+}\n@@ -2458,9 +2018,7 @@\n-#ifdef ASSERT\n-      \/\/ Mark Load\/Store Vector for alignment verification\n-      if (VerifyAlignVector) {\n-        if (vn->Opcode() == Op_LoadVector) {\n-          vn->as_LoadVector()->set_must_verify_alignment();\n-        } else if (vn->Opcode() == Op_StoreVector) {\n-          vn->as_StoreVector()->set_must_verify_alignment();\n-        }\n-      }\n+\/\/ We call \"apply\" on every VTransformNode, which replaces the packed scalar nodes with vector nodes.\n+void VTransform::apply_vectorization() const {\n+  Compile* C = phase()->C;\n+#ifndef PRODUCT\n+  if (_trace._verbose) {\n+    tty->print_cr(\"\\nVTransform::apply_vectorization:\");\n+  }\n@@ -2469,6 +2027,3 @@\n-      phase()->register_new_node_with_ctrl_of(vn, first);\n-      for (uint j = 0; j < p->size(); j++) {\n-        Node* pm = p->at(j);\n-        igvn().replace_node(pm, vn);\n-      }\n-      igvn()._worklist.push(vn);\n+  uint max_vector_length = 0; \/\/ number of elements\n+  uint max_vector_width  = 0; \/\/ total width in bytes\n+  _graph.apply_vectorization_for_each_vtnode(max_vector_length, max_vector_width);\n@@ -2476,9 +2031,2 @@\n-      if (vlen > max_vlen) {\n-        max_vlen = vlen;\n-      }\n-      if (vlen_in_bytes > max_vlen_in_bytes) {\n-        max_vlen_in_bytes = vlen_in_bytes;\n-      }\n-      VectorNode::trace_new_vector(vn, \"SuperWord\");\n-    }\n-  }\/\/for (int i = 0; i < body().length(); i++)\n+  assert(max_vector_length > 0 && max_vector_width > 0, \"must have vectorized\");\n+  cl()->mark_loop_vectorized();\n@@ -2486,5 +2034,2 @@\n-  if (max_vlen_in_bytes > C->max_vector_size()) {\n-    C->set_max_vector_size(max_vlen_in_bytes);\n-  }\n-  if (max_vlen_in_bytes > 0) {\n-    cl->mark_loop_vectorized();\n+  if (max_vector_width > C->max_vector_size()) {\n+    C->set_max_vector_size(max_vector_width);\n@@ -2494,3 +2039,3 @@\n-    if (cl->has_passed_slp()) {\n-      uint slp_max_unroll_factor = cl->slp_max_unroll();\n-      if (slp_max_unroll_factor == max_vlen) {\n+    if (cl()->has_passed_slp()) {\n+      uint slp_max_unroll_factor = cl()->slp_max_unroll();\n+      if (slp_max_unroll_factor == max_vector_length) {\n@@ -2499,1 +2044,1 @@\n-          tty->print_cr(\"vector loop(unroll=%d, len=%d)\\n\", max_vlen, max_vlen_in_bytes*BitsPerByte);\n+          tty->print_cr(\"vector loop(unroll=%d, len=%d)\\n\", max_vector_length, max_vector_width * BitsPerByte);\n@@ -2503,1 +2048,1 @@\n-        cl->set_notpassed_slp();\n+        cl()->set_notpassed_slp();\n@@ -2507,1 +2052,1 @@\n-          cl->mark_do_unroll_only();\n+          cl()->mark_do_unroll_only();\n@@ -2512,118 +2057,0 @@\n-\n-  return true;\n-}\n-\n-\/\/------------------------------vector_opd---------------------------\n-\/\/ Create a vector operand for the nodes in pack p for operand: in(opd_idx)\n-Node* SuperWord::vector_opd(Node_List* p, int opd_idx) {\n-  Node* p0 = p->at(0);\n-  uint vlen = p->size();\n-  Node* opd = p0->in(opd_idx);\n-  CountedLoopNode *cl = lpt()->_head->as_CountedLoop();\n-  Node* same_input = _packset.same_inputs_at_index_or_null(p, opd_idx);\n-\n-  \/\/ Insert index population operation to create a vector of increasing\n-  \/\/ indices starting from the iv value. In some special unrolled loops\n-  \/\/ (see JDK-8286125), we need scalar replications of the iv value if\n-  \/\/ all inputs are the same iv, so we do a same inputs check here.\n-  if (opd == iv() && same_input == nullptr) {\n-    BasicType p0_bt = velt_basic_type(p0);\n-    BasicType iv_bt = is_subword_type(p0_bt) ? p0_bt : T_INT;\n-    assert(VectorNode::is_populate_index_supported(iv_bt), \"Should support\");\n-    const TypeVect* vt = TypeVect::make(iv_bt, vlen);\n-    Node* vn = new PopulateIndexNode(iv(), igvn().intcon(1), vt);\n-    VectorNode::trace_new_vector(vn, \"SuperWord\");\n-    phase()->register_new_node_with_ctrl_of(vn, opd);\n-    return vn;\n-  }\n-\n-  if (same_input != nullptr) {\n-    if (opd->is_Vector() || opd->is_LoadVector()) {\n-      if (opd_idx == 2 && VectorNode::is_shift(p0)) {\n-        assert(false, \"shift's count can't be vector\");\n-        return nullptr;\n-      }\n-      return opd; \/\/ input is matching vector\n-    }\n-    if ((opd_idx == 2) && VectorNode::is_shift(p0)) {\n-      Node* cnt = opd;\n-      \/\/ Vector instructions do not mask shift count, do it here.\n-      juint mask = (p0->bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);\n-      const TypeInt* t = opd->find_int_type();\n-      if (t != nullptr && t->is_con()) {\n-        juint shift = t->get_con();\n-        if (shift > mask) { \/\/ Unsigned cmp\n-          cnt = igvn().intcon(shift & mask);\n-          phase()->set_ctrl(cnt, phase()->C->root());\n-        }\n-      } else {\n-        if (t == nullptr || t->_lo < 0 || t->_hi > (int)mask) {\n-          cnt = igvn().intcon(mask);\n-          cnt = new AndINode(opd, cnt);\n-          phase()->register_new_node_with_ctrl_of(cnt, opd);\n-        }\n-        if (!opd->bottom_type()->isa_int()) {\n-          assert(false, \"int type only\");\n-          return nullptr;\n-        }\n-      }\n-      \/\/ Move shift count into vector register.\n-      cnt = VectorNode::shift_count(p0->Opcode(), cnt, vlen, velt_basic_type(p0));\n-      phase()->register_new_node_with_ctrl_of(cnt, opd);\n-      return cnt;\n-    }\n-    if (opd->is_StoreVector()) {\n-      assert(false, \"StoreVector is not expected here\");\n-      return nullptr;\n-    }\n-    \/\/ Convert scalar input to vector with the same number of elements as\n-    \/\/ p0's vector. Use p0's type because size of operand's container in\n-    \/\/ vector should match p0's size regardless operand's size.\n-    const Type* p0_t = nullptr;\n-    VectorNode* vn = nullptr;\n-    if (opd_idx == 2 && VectorNode::is_scalar_rotate(p0)) {\n-       Node* conv = opd;\n-       p0_t =  TypeInt::INT;\n-       if (p0->bottom_type()->isa_long()) {\n-         p0_t = TypeLong::LONG;\n-         conv = new ConvI2LNode(opd);\n-         phase()->register_new_node_with_ctrl_of(conv, opd);\n-       }\n-       vn = VectorNode::scalar2vector(conv, vlen, p0_t);\n-    } else {\n-       p0_t =  velt_type(p0);\n-       vn = VectorNode::scalar2vector(opd, vlen, p0_t);\n-    }\n-\n-    phase()->register_new_node_with_ctrl_of(vn, opd);\n-    VectorNode::trace_new_vector(vn, \"SuperWord\");\n-    return vn;\n-  }\n-\n-  \/\/ Insert pack operation\n-  BasicType bt = velt_basic_type(p0);\n-  PackNode* pk = PackNode::make(opd, vlen, bt);\n-  DEBUG_ONLY( const BasicType opd_bt = opd->bottom_type()->basic_type(); )\n-\n-  for (uint i = 1; i < vlen; i++) {\n-    Node* pi = p->at(i);\n-    Node* in = pi->in(opd_idx);\n-    if (get_pack(in) != nullptr) {\n-      assert(false, \"Should already have been unpacked\");\n-      return nullptr;\n-    }\n-    assert(opd_bt == in->bottom_type()->basic_type(), \"all same type\");\n-    pk->add_opd(in);\n-    if (VectorNode::is_muladds2i(pi)) {\n-      Node* in2 = pi->in(opd_idx + 2);\n-      if (get_pack(in2) != nullptr) {\n-        assert(false, \"Should already have been unpacked\");\n-        return nullptr;\n-      }\n-      assert(opd_bt == in2->bottom_type()->basic_type(), \"all same type\");\n-      pk->add_opd(in2);\n-    }\n-  }\n-  phase()->register_new_node_with_ctrl_of(pk, opd);\n-  VectorNode::trace_new_vector(pk, \"SuperWord\");\n-  return pk;\n@@ -2800,12 +2227,1 @@\n-  if (u_pk->size() != d_pk->size()) {\n-    return false;\n-  }\n-\n-  for (uint i = 0; i < u_pk->size(); i++) {\n-    Node* ui = u_pk->at(i);\n-    Node* di = d_pk->at(i);\n-    if (ui->in(u_idx) != di) {\n-      return false;\n-    }\n-  }\n-  return true;\n+  return _packset.pack_input_at_index_or_null(u_pk, u_idx) != nullptr;\n@@ -3185,1 +2601,1 @@\n-LoadNode::ControlDependency SuperWord::control_dependency(Node_List* p) {\n+LoadNode::ControlDependency VTransformLoadVectorNode::control_dependency() const {\n@@ -3187,2 +2603,2 @@\n-  for (uint i = 0; i < p->size(); i++) {\n-    Node* n = p->at(i);\n+  for (int i = 0; i < nodes().length(); i++) {\n+    Node* n = nodes().at(i);\n@@ -3205,2 +2621,2 @@\n-\/\/ determined by SuperWord::filter_packs_for_alignment().\n-void SuperWord::determine_mem_ref_and_aw_for_main_loop_alignment() {\n+\/\/ determined (e.g. by SuperWord::filter_packs_for_alignment()).\n+void VTransform::determine_mem_ref_and_aw_for_main_loop_alignment() {\n@@ -3214,4 +2630,0 @@\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* pack = _packset.at(i);\n-    MemNode* first = pack->at(0)->isa_Mem();\n-    if (first == nullptr) { continue; }\n@@ -3219,1 +2631,8 @@\n-    int vw = first->memory_size() * pack->size();\n+  const GrowableArray<VTransformNode*>& vtnodes = _graph.vtnodes();\n+  for (int i = 0; i < vtnodes.length(); i++) {\n+    VTransformVectorNode* vtn = vtnodes.at(i)->isa_Vector();\n+    if (vtn == nullptr) { continue; }\n+    MemNode* p0 = vtn->nodes().at(0)->isa_Mem();\n+    if (p0 == nullptr) { continue; }\n+\n+    int vw = p0->memory_size() * vtn->nodes().length();\n@@ -3222,1 +2641,1 @@\n-      mem_ref = first;\n+      mem_ref = p0;\n@@ -3232,1 +2651,1 @@\n-    if (is_trace_align_vector()) {      \\\n+    if (_trace._align_vector) {         \\\n@@ -3243,1 +2662,1 @@\n-void SuperWord::adjust_pre_loop_limit_to_align_main_loop_vectors() {\n+void VTransform::adjust_pre_loop_limit_to_align_main_loop_vectors() {\n@@ -3400,2 +2819,2 @@\n-  if (is_trace_align_vector()) {\n-    tty->print_cr(\"\\nadjust_pre_loop_limit_to_align_main_loop_vectors:\");\n+  if (_trace._align_vector) {\n+    tty->print_cr(\"\\nVLoopTransform::adjust_pre_loop_limit_to_align_main_loop_vectors:\");\n@@ -3427,1 +2846,1 @@\n-    if (is_trace_align_vector()) {\n+    if (_trace._align_vector) {\n@@ -3443,1 +2862,1 @@\n-  if (is_trace_align_vector()) {\n+  if (_trace._align_vector) {\n@@ -3598,1 +3017,1 @@\n-  tty->print_cr(\"\\nBlock\");\n+  tty->print_cr(\"\\nVLoopBody::print\");\n@@ -3601,1 +3020,1 @@\n-    tty->print(\"%d \", i);\n+    tty->print(\"%4d \", i);\n@@ -3618,0 +3037,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":118,"deletions":698,"binary":false,"changes":816,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/vtransform.hpp\"\n@@ -370,0 +371,4 @@\n+  Node_List* pack_input_at_index_or_null(const Node_List* pack, const int index) const {\n+    return strided_pack_input_at_index_or_null(pack, index, 1, 0);\n+  }\n+\n@@ -602,7 +607,0 @@\n-  bool schedule_and_apply();\n-  bool apply(Node_List& memops_schedule);\n-  void apply_memops_reordering_with_schedule(Node_List& memops_schedule);\n-  bool apply_vectorization();\n-  \/\/ Create a vector operand for the nodes in pack p for operand: in(opd_idx)\n-  Node* vector_opd(Node_List* p, int opd_idx);\n-\n@@ -633,5 +631,1 @@\n-  static LoadNode::ControlDependency control_dependency(Node_List* p);\n-\n-  \/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit.\n-  void determine_mem_ref_and_aw_for_main_loop_alignment();\n-  void adjust_pre_loop_limit_to_align_main_loop_vectors();\n+  bool schedule_and_apply() const;\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/superwordVTransformBuilder.hpp\"\n+#include \"opto\/vectornode.hpp\"\n+\n+void SuperWordVTransformBuilder::build() {\n+  assert(!_packset.is_empty(), \"must have non-empty packset\");\n+  assert(_vtransform.is_empty(), \"start with empty vtransform\");\n+\n+  \/\/ Create vtnodes for all nodes in the loop.\n+  build_vector_vtnodes_for_packed_nodes();\n+  build_scalar_vtnodes_for_non_packed_nodes();\n+\n+  \/\/ Connect all vtnodes with their inputs. Possibly create vtnodes for input\n+  \/\/ nodes that are outside the loop.\n+  VectorSet vtn_dependencies; \/\/ Shared, but cleared for every vtnode.\n+  build_inputs_for_vector_vtnodes(vtn_dependencies);\n+  build_inputs_for_scalar_vtnodes(vtn_dependencies);\n+}\n+\n+void SuperWordVTransformBuilder::build_vector_vtnodes_for_packed_nodes() {\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* pack = _packset.at(i);\n+    VTransformVectorNode* vtn = make_vector_vtnode_for_pack(pack);\n+    for (uint k = 0; k < pack->size(); k++) {\n+      map_node_to_vtnode(pack->at(k), vtn);\n+    }\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::build_scalar_vtnodes_for_non_packed_nodes() {\n+  for (int i = 0; i < _vloop_analyzer.body().body().length(); i++) {\n+    Node* n = _vloop_analyzer.body().body().at(i);\n+    if (_packset.get_pack(n) != nullptr) { continue; }\n+    VTransformScalarNode* vtn = new (_vtransform.arena()) VTransformScalarNode(_vtransform, n);\n+    map_node_to_vtnode(n, vtn);\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::build_inputs_for_vector_vtnodes(VectorSet& vtn_dependencies) {\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* pack = _packset.at(i);\n+    Node* p0 = pack->at(0);\n+\n+    VTransformVectorNode* vtn = get_vtnode(p0)->isa_Vector();\n+    assert(vtn != nullptr, \"all packs must have vector vtnodes\");\n+    vtn_dependencies.clear(); \/\/ Add every dependency only once per vtn.\n+\n+    if (p0->is_Load()) {\n+      set_req_with_scalar(p0,   vtn, vtn_dependencies, MemNode::Address);\n+    } else if (p0->is_Store()) {\n+      set_req_with_scalar(p0,   vtn, vtn_dependencies, MemNode::Address);\n+      set_req_with_vector(pack, vtn, vtn_dependencies, MemNode::ValueIn);\n+    } else if (vtn->isa_ReductionVector() != nullptr) {\n+      set_req_with_scalar(p0,   vtn, vtn_dependencies, 1); \/\/ scalar init\n+      set_req_with_vector(pack, vtn, vtn_dependencies, 2); \/\/ vector\n+    } else {\n+      assert(vtn->isa_ElementWiseVector() != nullptr, \"all other vtnodes are handled above\");\n+      if (VectorNode::is_scalar_rotate(p0) &&\n+          p0->in(2)->is_Con() &&\n+          Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n+        set_req_with_vector(pack, vtn, vtn_dependencies, 1);\n+        set_req_with_scalar(p0,   vtn, vtn_dependencies, 2); \/\/ constant rotation\n+      } else if (VectorNode::is_roundopD(p0)) {\n+        set_req_with_vector(pack, vtn, vtn_dependencies, 1);\n+        set_req_with_scalar(p0,   vtn, vtn_dependencies, 2); \/\/ constant rounding mode\n+      } else if (p0->is_CMove()) {\n+        \/\/ Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n+        set_all_req_with_vectors(pack, vtn, vtn_dependencies);\n+        VTransformBoolVectorNode* vtn_mask_cmp = vtn->in(1)->isa_BoolVector();\n+        if (vtn_mask_cmp->test()._is_negated) {\n+          vtn->swap_req(2, 3); \/\/ swap if test was negated.\n+        }\n+      } else {\n+        set_all_req_with_vectors(pack, vtn, vtn_dependencies);\n+      }\n+    }\n+\n+    for (uint k = 0; k < pack->size(); k++) {\n+      add_dependencies_of_node_to_vtnode(pack->at(k), vtn, vtn_dependencies);\n+    }\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::build_inputs_for_scalar_vtnodes(VectorSet& vtn_dependencies) {\n+  for (int i = 0; i < _vloop_analyzer.body().body().length(); i++) {\n+    Node* n = _vloop_analyzer.body().body().at(i);\n+    VTransformScalarNode* vtn = get_vtnode(n)->isa_Scalar();\n+    if (vtn == nullptr) { continue; }\n+    vtn_dependencies.clear(); \/\/ Add every dependency only once per vtn.\n+\n+    if (n->is_Load()) {\n+      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::Address);\n+    } else if (n->is_Store()) {\n+      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::Address);\n+      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::ValueIn);\n+    } else if (n->is_CountedLoop()) {\n+      continue; \/\/ Is \"root\", has no dependency.\n+    } else if (n->is_Phi()) {\n+      \/\/ CountedLoop Phi's: ignore backedge (and entry value).\n+      assert(n->in(0) == _vloop.cl(), \"only Phi's from the CountedLoop allowed\");\n+      set_req_with_scalar(n, vtn, vtn_dependencies, 0);\n+      continue;\n+    } else {\n+      set_all_req_with_scalars(n, vtn, vtn_dependencies);\n+    }\n+\n+    add_dependencies_of_node_to_vtnode(n, vtn, vtn_dependencies);\n+  }\n+}\n+\n+\/\/ Create a vtnode for each pack. No in\/out edges set yet.\n+VTransformVectorNode* SuperWordVTransformBuilder::make_vector_vtnode_for_pack(const Node_List* pack) const {\n+  uint pack_size = pack->size();\n+  Node* p0 = pack->at(0);\n+  int opc = p0->Opcode();\n+  VTransformVectorNode* vtn = nullptr;\n+\n+  if (p0->is_Load()) {\n+    vtn = new (_vtransform.arena()) VTransformLoadVectorNode(_vtransform, pack_size);\n+  } else if (p0->is_Store()) {\n+    vtn = new (_vtransform.arena()) VTransformStoreVectorNode(_vtransform, pack_size);\n+  } else if (p0->is_Bool()) {\n+    VTransformBoolTest kind = _packset.get_bool_test(pack);\n+    vtn = new (_vtransform.arena()) VTransformBoolVectorNode(_vtransform, pack_size, kind);\n+  } else if (_vloop_analyzer.reductions().is_marked_reduction(p0)) {\n+    vtn = new (_vtransform.arena()) VTransformReductionVectorNode(_vtransform, pack_size);\n+  } else if (VectorNode::is_muladds2i(p0)) {\n+    \/\/ A special kind of binary element-wise vector op: the inputs are \"ints\" a and b,\n+    \/\/ but reinterpreted as two \"shorts\" [a0, a1] and [b0, b1]:\n+    \/\/   v = MulAddS2I(a, b) = a0 * b0 + a1 + b1\n+    assert(p0->req() == 5, \"MulAddS2I should have 4 operands\");\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, 3, pack_size);\n+  } else {\n+    assert(p0->req() == 3 ||\n+           p0->is_CMove() ||\n+           VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc) ||\n+           VectorNode::is_convert_opcode(opc) ||\n+           VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc) ||\n+           opc == Op_FmaD ||\n+           opc == Op_FmaF ||\n+           opc == Op_SignumF ||\n+           opc == Op_SignumD,\n+           \"pack type must be in this list\");\n+    vtn = new (_vtransform.arena()) VTransformElementWiseVectorNode(_vtransform, p0->req(), pack_size);\n+  }\n+  vtn->set_nodes(pack);\n+  return vtn;\n+}\n+\n+void SuperWordVTransformBuilder::set_req_with_scalar(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index) {\n+  VTransformNode* req = get_vtnode_or_wrap_as_input_scalar(n->in(index));\n+  vtn->set_req(index, req);\n+  vtn_dependencies.set(req->_idx);\n+}\n+\n+\/\/ Either get existing vtnode vector input (when input is a pack), or else make a\n+\/\/ new one vector vtnode for the input (e.g. for Replicate or PopulateIndex).\n+VTransformNode* SuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index(const Node_List* pack, const int index) {\n+  Node* p0 = pack->at(0);\n+\n+  Node_List* pack_in = _packset.pack_input_at_index_or_null(pack, index);\n+  if (pack_in != nullptr) {\n+    \/\/ Input is a matching pack -> vtnode already exists.\n+    assert(index != 2 || !VectorNode::is_shift(p0), \"shift's count cannot be vector\");\n+    return get_vtnode(pack_in->at(0));\n+  }\n+\n+  if (VectorNode::is_muladds2i(p0)) {\n+    assert(_packset.is_muladds2i_pack_with_pack_inputs(pack), \"inputs must all be packs\");\n+    \/\/ All inputs are strided (stride = 2), either with offset 0 or 1.\n+    Node_List* pack_in0 = _packset.strided_pack_input_at_index_or_null(pack, index, 2, 0);\n+    if (pack_in0 != nullptr) {\n+      return get_vtnode(pack_in0->at(0));\n+    }\n+    Node_List* pack_in1 = _packset.strided_pack_input_at_index_or_null(pack, index, 2, 1);\n+    if (pack_in1 != nullptr) {\n+      return get_vtnode(pack_in1->at(0));\n+    }\n+  }\n+\n+  Node* same_input = _packset.same_inputs_at_index_or_null(pack, index);\n+  if (same_input == nullptr && p0->in(index) == _vloop.iv()) {\n+    \/\/ PopulateIndex: [iv+0, iv+1, iv+2, ...]\n+    VTransformNode* iv_vtn = get_vtnode_or_wrap_as_input_scalar(_vloop.iv());\n+    BasicType p0_bt = _vloop_analyzer.types().velt_basic_type(p0);\n+    \/\/ If we have subword type, take that type directly. If p0 is some ConvI2L\/F\/D,\n+    \/\/ then the p0_bt can also be L\/F\/D but we need to produce ints for the input of\n+    \/\/ the ConvI2L\/F\/D.\n+    BasicType element_bt = is_subword_type(p0_bt) ? p0_bt : T_INT;\n+    VTransformNode* populate_index = new (_vtransform.arena()) VTransformPopulateIndexNode(_vtransform, pack->size(), element_bt);\n+    populate_index->set_req(1, iv_vtn);\n+    return populate_index;\n+  }\n+\n+  if (same_input != nullptr) {\n+    VTransformNode* same_input_vtn = get_vtnode_or_wrap_as_input_scalar(same_input);\n+    if (index == 2 && VectorNode::is_shift(p0)) {\n+      \/\/ Scalar shift count for vector shift operation: vec2 = shiftV(vec1, scalar_count)\n+      \/\/ Scalar shift operations masks the shift count, but the vector shift does not, so\n+      \/\/ create a special ShiftCount node.\n+      BasicType element_bt = _vloop_analyzer.types().velt_basic_type(p0);\n+      juint mask = (p0->bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);\n+      VTransformNode* shift_count = new (_vtransform.arena()) VTransformShiftCountNode(_vtransform, pack->size(), element_bt, mask, p0->Opcode());\n+      shift_count->set_req(1, same_input_vtn);\n+      return shift_count;\n+    } else {\n+      \/\/ Replicate the scalar same_input to every vector element.\n+      const Type* element_type = _vloop_analyzer.types().velt_type(p0);\n+      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type->isa_long()) {\n+        \/\/ Scalar rotate has int rotation value, but the scalar rotate expects longs.\n+        assert(same_input->bottom_type()->isa_int(), \"scalar rotate expects int rotation\");\n+        VTransformNode* conv = new (_vtransform.arena()) VTransformConvI2LNode(_vtransform);\n+        conv->set_req(1, same_input_vtn);\n+        same_input_vtn = conv;\n+      }\n+      VTransformNode* replicate = new (_vtransform.arena()) VTransformReplicateNode(_vtransform, pack->size(), element_type);\n+      replicate->set_req(1, same_input_vtn);\n+      return replicate;\n+    }\n+  }\n+\n+  \/\/ The input is neither a pack not a same_input node. SuperWord::profitable does not allow\n+  \/\/ any other case. In the future, we could insert a PackNode.\n+#ifdef ASSERT\n+  tty->print_cr(\"\\nSuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index: index=%d\", index);\n+  pack->dump();\n+  assert(false, \"Pack input was neither a pack nor a same_input node\");\n+#endif\n+  ShouldNotReachHere();\n+}\n+\n+VTransformNode* SuperWordVTransformBuilder::get_vtnode_or_wrap_as_input_scalar(Node* n) {\n+  VTransformNode* vtn = get_vtnode_or_null(n);\n+  if (vtn != nullptr) { return vtn; }\n+\n+  assert(!_vloop.in_bb(n), \"only nodes outside the loop can be input nodes to the loop\");\n+  vtn = new (_vtransform.arena()) VTransformInputScalarNode(_vtransform, n);\n+  map_node_to_vtnode(n, vtn);\n+  return vtn;\n+}\n+\n+void SuperWordVTransformBuilder::set_req_with_vector(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies, int j) {\n+  VTransformNode* req = get_or_make_vtnode_vector_input_at_index(pack, j);\n+  vtn->set_req(j, req);\n+  vtn_dependencies.set(req->_idx);\n+}\n+\n+void SuperWordVTransformBuilder::set_all_req_with_scalars(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n+  assert(vtn->req() == n->req(), \"scalars must have same number of reqs\");\n+  for (uint j = 0; j < n->req(); j++) {\n+    Node* def = n->in(j);\n+    if (def == nullptr) { continue; }\n+    set_req_with_scalar(n, vtn, vtn_dependencies, j);\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n+  Node* p0 = pack->at(0);\n+  assert(vtn->req() <= p0->req(), \"must have at at most as many reqs\");\n+  \/\/ Vectors have no ctrl, so ignore it.\n+  for (uint j = 1; j < vtn->req(); j++) {\n+    Node* def = p0->in(j);\n+    if (def == nullptr) { continue; }\n+    set_req_with_vector(pack, vtn, vtn_dependencies, j);\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::add_dependencies_of_node_to_vtnode(Node*n, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n+  for (VLoopDependencyGraph::PredsIterator preds(_vloop_analyzer.dependency_graph(), n); !preds.done(); preds.next()) {\n+    Node* pred = preds.current();\n+    if (!_vloop.in_bb(pred)) { continue; }\n+\n+    \/\/ Only add memory dependencies to memory nodes. All others are taken care of with the req.\n+    if (n->is_Mem() && !pred->is_Mem()) { continue; }\n+\n+    VTransformNode* dependency = get_vtnode(pred);\n+\n+    \/\/ Reduction self-cycle?\n+    if (vtn == dependency && _vloop_analyzer.reductions().is_marked_reduction(n)) { continue; }\n+\n+    if (vtn_dependencies.test_set(dependency->_idx)) { continue; }\n+    vtn->add_dependency(dependency); \/\/ Add every dependency only once per vtn.\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"opto\/vtransform.hpp\"\n+#include \"opto\/superword.hpp\"\n+\n+#ifndef SHARE_OPTO_SUPERWORD_VTRANSFORM_BUILDER_HPP\n+#define SHARE_OPTO_SUPERWORD_VTRANSFORM_BUILDER_HPP\n+\n+\/\/ Facility class that builds a VTransform from a SuperWord PackSet.\n+class SuperWordVTransformBuilder : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+  const VLoop& _vloop;\n+  const PackSet& _packset;\n+  VTransform& _vtransform;\n+\n+  ResourceHashtable<\/* Node::_idx*\/ int, VTransformNode* \/* or null*\/> _idx_to_vtnode;\n+\n+public:\n+  SuperWordVTransformBuilder(const PackSet& packset,\n+                             VTransform& vtransform) :\n+      _vloop_analyzer(vtransform.vloop_analyzer()),\n+      _vloop(_vloop_analyzer.vloop()),\n+      _packset(packset),\n+      _vtransform(vtransform)\n+  {\n+    assert(_vtransform.is_empty(), \"constructor is passed an empty vtransform\");\n+    build();\n+    assert(!_vtransform.is_empty(), \"vtransform must contain some vtnodes now\");\n+  }\n+\n+private:\n+  void build();\n+  void build_vector_vtnodes_for_packed_nodes();\n+  void build_scalar_vtnodes_for_non_packed_nodes();\n+  void build_inputs_for_vector_vtnodes(VectorSet& vtn_dependencies);\n+  void build_inputs_for_scalar_vtnodes(VectorSet& vtn_dependencies);\n+\n+  \/\/ Helper methods for building VTransform.\n+  VTransformNode* get_vtnode_or_null(Node* n) const {\n+    VTransformNode** ptr = _idx_to_vtnode.get(n->_idx);\n+    return (ptr == nullptr) ? nullptr : *ptr;\n+  }\n+\n+  VTransformNode* get_vtnode(Node* n) const {\n+    VTransformNode* vtn = get_vtnode_or_null(n);\n+    assert(vtn != nullptr, \"expect non-null vtnode\");\n+    return vtn;\n+  }\n+\n+  void map_node_to_vtnode(Node* n, VTransformNode* vtn) {\n+    assert(vtn != nullptr, \"only set non-null vtnodes\");\n+    _idx_to_vtnode.put_when_absent(n->_idx, vtn);\n+  }\n+\n+  VTransformVectorNode* make_vector_vtnode_for_pack(const Node_List* pack) const;\n+  VTransformNode* get_or_make_vtnode_vector_input_at_index(const Node_List* pack, const int index);\n+  VTransformNode* get_vtnode_or_wrap_as_input_scalar(Node* n);\n+  void set_req_with_scalar(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index);\n+  void set_req_with_vector(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index);\n+  void set_all_req_with_scalars(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies);\n+  void set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies);\n+  void add_dependencies_of_node_to_vtnode(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies);\n+};\n+\n+#endif \/\/ SHARE_OPTO_SUPERWORD_VTRANSFORM_BUILDER_HPP\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+  flags(VTRANSFORM,           \"Trace VTransform Graph\") \\\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"opto\/matcher.hpp\"\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"opto\/node.hpp\"\n+#include \"opto\/matcher.hpp\"\n@@ -766,3 +766,3 @@\n-  bool overlap_possible_with_any_in(const Node_List* p) const {\n-    for (uint k = 0; k < p->size(); k++) {\n-      MemNode* mem = p->at(k)->as_Mem();\n+  bool overlap_possible_with_any_in(const GrowableArray<Node*>& nodes) const {\n+    for (int i = 0; i < nodes.length(); i++) {\n+      MemNode* mem = nodes.at(i)->as_Mem();\n@@ -1326,8 +1326,0 @@\n-struct VTransformBoolTest {\n-  const BoolTest::mask _mask;\n-  const bool _is_negated;\n-\n-  VTransformBoolTest(const BoolTest::mask mask, bool is_negated) :\n-    _mask(mask), _is_negated(is_negated) {}\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,440 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/vtransform.hpp\"\n+#include \"opto\/vectornode.hpp\"\n+#include \"opto\/convertnode.hpp\"\n+\n+void VTransformGraph::add_vtnode(VTransformNode* vtnode) {\n+  assert(vtnode->_idx == _vtnodes.length(), \"position must match idx\");\n+  _vtnodes.push(vtnode);\n+}\n+\n+\/\/ Compute a linearization of the graph. We do this with a reverse-post-order of a DFS.\n+\/\/ This only works if the graph is a directed acyclic graph (DAG). The C2 graph, and\n+\/\/ the VLoopDependencyGraph are both DAGs, but after introduction of vectors\/packs, the\n+\/\/ graph has additional constraints which can introduce cycles. Example:\n+\/\/\n+\/\/                                                       +--------+\n+\/\/  A -> X                                               |        v\n+\/\/                     Pack [A,B] and [X,Y]             [A,B]    [X,Y]\n+\/\/  Y -> B                                                 ^        |\n+\/\/                                                         +--------+\n+\/\/\n+\/\/ We return \"true\" IFF we find no cycle, i.e. if the linearization succeeds.\n+bool VTransformGraph::schedule() {\n+  assert(!is_scheduled(), \"not yet scheduled\");\n+\n+#ifndef PRODUCT\n+  if (_trace._verbose) {\n+    print_vtnodes();\n+  }\n+#endif\n+\n+  ResourceMark rm;\n+  GrowableArray<VTransformNode*> stack;\n+  VectorSet pre_visited;\n+  VectorSet post_visited;\n+\n+  collect_nodes_without_req_or_dependency(stack);\n+\n+  \/\/ We create a reverse-post-visit order. This gives us a linearization, if there are\n+  \/\/ no cycles. Then, we simply reverse the order, and we have a schedule.\n+  int rpo_idx = _vtnodes.length() - 1;\n+  while (!stack.is_empty()) {\n+    VTransformNode* vtn = stack.top();\n+    if (!pre_visited.test_set(vtn->_idx)) {\n+      \/\/ Forward arc in graph (pre-visit).\n+    } else if (!post_visited.test(vtn->_idx)) {\n+      \/\/ Forward arc in graph. Check if all uses were already visited:\n+      \/\/   Yes -> post-visit.\n+      \/\/   No  -> we are mid-visit.\n+      bool all_uses_already_visited = true;\n+\n+      for (int i = 0; i < vtn->outs(); i++) {\n+        VTransformNode* use = vtn->out(i);\n+        if (post_visited.test(use->_idx)) { continue; }\n+        if (pre_visited.test(use->_idx)) {\n+          \/\/ Cycle detected!\n+          \/\/ The nodes that are pre_visited but not yet post_visited form a path from\n+          \/\/ the \"root\" to the current vtn. Now, we are looking at an edge (vtn, use),\n+          \/\/ and discover that use is also pre_visited but not post_visited. Thus, use\n+          \/\/ lies on that path from \"root\" to vtn, and the edge (vtn, use) closes a\n+          \/\/ cycle.\n+          NOT_PRODUCT(if (_trace._rejections) { trace_schedule_cycle(stack, pre_visited, post_visited); } )\n+          return false;\n+        }\n+        stack.push(use);\n+        all_uses_already_visited = false;\n+      }\n+\n+      if (all_uses_already_visited) {\n+        stack.pop();\n+        post_visited.set(vtn->_idx);           \/\/ post-visit\n+        _schedule.at_put_grow(rpo_idx--, vtn); \/\/ assign rpo_idx\n+      }\n+    } else {\n+      stack.pop(); \/\/ Already post-visited. Ignore secondary edge.\n+    }\n+  }\n+\n+#ifndef PRODUCT\n+  if (_trace._verbose) {\n+    print_schedule();\n+  }\n+#endif\n+\n+  assert(rpo_idx == -1, \"used up all rpo_idx, rpo_idx=%d\", rpo_idx);\n+  return true;\n+}\n+\n+\/\/ Push all \"root\" nodes, i.e. those that have no inputs (req or dependency):\n+void VTransformGraph::collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const {\n+  for (int i = 0; i < _vtnodes.length(); i++) {\n+    VTransformNode* vtn = _vtnodes.at(i);\n+    if (!vtn->has_req_or_dependency()) {\n+      stack.push(vtn);\n+    }\n+  }\n+}\n+\n+#ifndef PRODUCT\n+void VTransformGraph::trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n+                                           const VectorSet& pre_visited,\n+                                           const VectorSet& post_visited) const {\n+  tty->print_cr(\"\\nVTransform::schedule found a cycle on path (P), vectorization attempt fails.\");\n+  for (int j = 0; j < stack.length(); j++) {\n+    VTransformNode* n = stack.at(j);\n+    bool on_path = pre_visited.test(n->_idx) && !post_visited.test(n->_idx);\n+    tty->print(\"  %s \", on_path ? \"P\" : \"_\");\n+    n->print();\n+  }\n+}\n+\n+void VTransformApplyResult::trace(VTransformNode* vtn) const {\n+  tty->print(\"  apply: \");\n+  vtn->print();\n+  tty->print(\"    ->   \");\n+  if (_node == nullptr) {\n+    tty->print_cr(\"nullptr\");\n+  } else {\n+    _node->dump();\n+  }\n+}\n+#endif\n+\n+Node* VTransformNode::find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* n = vnode_idx_to_transformed_node.at(in(i)->_idx);\n+  assert(n != nullptr, \"must find input IR node\");\n+  return n;\n+}\n+\n+VTransformApplyResult VTransformScalarNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  \/\/ This was just wrapped. Now we simply unwap without touching the inputs.\n+  return VTransformApplyResult::make_scalar(_node);\n+}\n+\n+VTransformApplyResult VTransformReplicateNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  VectorNode* vn = VectorNode::scalar2vector(val, _vlen, _element_type);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformConvI2LNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* n = new ConvI2LNode(val);\n+  register_new_node_from_vectorization(vloop_analyzer, n, val);\n+  return VTransformApplyResult::make_scalar(n);\n+}\n+\n+VTransformApplyResult VTransformShiftCountNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  Node* shift_count_in = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  assert(shift_count_in->bottom_type()->isa_int(), \"int type only for shift count\");\n+  \/\/ The shift_count_in would be automatically truncated to the lowest _mask\n+  \/\/ bits in a scalar shift operation. But vector shift does not truncate, so\n+  \/\/ we must apply the mask now.\n+  Node* shift_count_masked = new AndINode(shift_count_in, phase->igvn().intcon(_mask));\n+  register_new_node_from_vectorization(vloop_analyzer, shift_count_masked, shift_count_in);\n+  \/\/ Now that masked value is \"boadcast\" (some platforms only set the lowest element).\n+  VectorNode* vn = VectorNode::shift_count(_shift_opcode, shift_count_masked, _vlen, _element_bt);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, shift_count_in);\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+}\n+\n+\n+VTransformApplyResult VTransformPopulateIndexNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  Node* val = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  assert(val->is_Phi(), \"expected to be iv\");\n+  assert(VectorNode::is_populate_index_supported(_element_bt), \"should support\");\n+  const TypeVect* vt = TypeVect::make(_element_bt, _vlen);\n+  VectorNode* vn = new PopulateIndexNode(val, phase->igvn().intcon(1), vt);\n+  register_new_node_from_vectorization(vloop_analyzer, vn, val);\n+  return VTransformApplyResult::make_vector(vn, _vlen, vn->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformElementWiseVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* first = nodes().at(0);\n+  uint  vlen = nodes().length();\n+  int   opc  = first->Opcode();\n+  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+\n+  if (first->is_Cmp()) {\n+    \/\/ Cmp + Bool -> VectorMaskCmp\n+    \/\/ Handled by Bool \/ VTransformBoolVectorNode, so we do not generate any nodes here.\n+    return VTransformApplyResult::make_empty();\n+  }\n+\n+  assert(2 <= req() && req() <= 4, \"Must have 1-3 inputs\");\n+  VectorNode* vn = nullptr;\n+  Node* in1 =                find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* in2 = (req() >= 3) ? find_transformed_input(2, vnode_idx_to_transformed_node) : nullptr;\n+  Node* in3 = (req() >= 4) ? find_transformed_input(3, vnode_idx_to_transformed_node) : nullptr;\n+\n+  if (first->is_CMove()) {\n+    assert(req() == 4, \"three inputs expected: mask, blend1, blend2\");\n+    vn = new VectorBlendNode(\/* blend1 *\/ in2, \/* blend2 *\/ in3, \/* mask *\/ in1);\n+  } else if (VectorNode::is_convert_opcode(opc)) {\n+    assert(first->req() == 2 && req() == 2, \"only one input expected\");\n+    int vopc = VectorCastNode::opcode(opc, in1->bottom_type()->is_vect()->element_basic_type());\n+    vn = VectorCastNode::make(vopc, in1, bt, vlen);\n+  } else if (VectorNode::can_use_RShiftI_instead_of_URShiftI(first, bt)) {\n+    opc = Op_RShiftI;\n+    vn = VectorNode::make(opc, in1, in2, vlen, bt);\n+  } else if (VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc)) {\n+    \/\/ The scalar operation was a long -> int operation.\n+    \/\/ However, the vector operation is long -> long.\n+    VectorNode* long_vn = VectorNode::make(opc, in1, nullptr, vlen, T_LONG);\n+    register_new_node_from_vectorization(vloop_analyzer, long_vn, first);\n+    \/\/ Cast long -> int, to mimic the scalar long -> int operation.\n+    vn = VectorCastNode::make(Op_VectorCastL2X, long_vn, T_INT, vlen);\n+  } else if (req() == 3 ||\n+             VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc)) {\n+    assert(!VectorNode::is_roundopD(first) || in2->is_Con(), \"rounding mode must be constant\");\n+    vn = VectorNode::make(opc, in1, in2, vlen, bt); \/\/ unary and binary\n+  } else {\n+    assert(req() == 4, \"three inputs expected\");\n+    assert(opc == Op_FmaD ||\n+           opc == Op_FmaF ||\n+           opc == Op_SignumF ||\n+           opc == Op_SignumD,\n+           \"element wise operation must be from this list\");\n+    vn = VectorNode::make(opc, in1, in2, in3, vlen, bt); \/\/ ternary\n+  }\n+\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformBoolVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  BoolNode* first = nodes().at(0)->as_Bool();\n+  uint  vlen = nodes().length();\n+  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+\n+  \/\/ Cmp + Bool -> VectorMaskCmp\n+  VTransformElementWiseVectorNode* vtn_cmp = in(1)->isa_ElementWiseVector();\n+  assert(vtn_cmp != nullptr && vtn_cmp->nodes().at(0)->is_Cmp(),\n+         \"bool vtn expects cmp vtn as input\");\n+\n+  Node* cmp_in1 = vtn_cmp->find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* cmp_in2 = vtn_cmp->find_transformed_input(2, vnode_idx_to_transformed_node);\n+  BoolTest::mask mask = test()._mask;\n+\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  ConINode* mask_node  = phase->igvn().intcon((int)mask);\n+  const TypeVect* vt = TypeVect::make(bt, vlen);\n+  VectorNode* vn = new VectorMaskCmpNode(mask, cmp_in1, cmp_in2, mask_node, vt);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->vect_type()->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformReductionVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  Node* first = nodes().at(0);\n+  uint  vlen = nodes().length();\n+  int   opc  = first->Opcode();\n+  BasicType bt = first->bottom_type()->basic_type();\n+\n+  Node* init = find_transformed_input(1, vnode_idx_to_transformed_node);\n+  Node* vec  = find_transformed_input(2, vnode_idx_to_transformed_node);\n+\n+  ReductionNode* vn = ReductionNode::make(opc, nullptr, init, vec, bt);\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->vect_type()->length_in_bytes());\n+}\n+\n+VTransformApplyResult VTransformLoadVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  LoadNode* first = nodes().at(0)->as_Load();\n+  uint  vlen = nodes().length();\n+  Node* ctrl = first->in(MemNode::Control);\n+  Node* mem  = first->in(MemNode::Memory);\n+  Node* adr  = first->in(MemNode::Address);\n+  int   opc  = first->Opcode();\n+  const TypePtr* adr_type = first->adr_type();\n+  BasicType bt = vloop_analyzer.types().velt_basic_type(first);\n+\n+  \/\/ Set the memory dependency of the LoadVector as early as possible.\n+  \/\/ Walk up the memory chain, and ignore any StoreVector that provably\n+  \/\/ does not have any memory dependency.\n+  while (mem->is_StoreVector()) {\n+    VPointer p_store(mem->as_Mem(), vloop_analyzer.vloop());\n+    if (p_store.overlap_possible_with_any_in(nodes())) {\n+      break;\n+    } else {\n+      mem = mem->in(MemNode::Memory);\n+    }\n+  }\n+\n+  LoadVectorNode* vn = LoadVectorNode::make(opc, ctrl, mem, adr, adr_type, vlen, bt,\n+                                            control_dependency());\n+  DEBUG_ONLY( if (VerifyAlignVector) { vn->set_must_verify_alignment(); } )\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->memory_size());\n+}\n+\n+VTransformApplyResult VTransformStoreVectorNode::apply(const VLoopAnalyzer& vloop_analyzer, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const {\n+  StoreNode* first = nodes().at(0)->as_Store();\n+  uint  vlen = nodes().length();\n+  Node* ctrl = first->in(MemNode::Control);\n+  Node* mem  = first->in(MemNode::Memory);\n+  Node* adr  = first->in(MemNode::Address);\n+  int   opc  = first->Opcode();\n+  const TypePtr* adr_type = first->adr_type();\n+\n+  Node* value = find_transformed_input(MemNode::ValueIn, vnode_idx_to_transformed_node);\n+  StoreVectorNode* vn = StoreVectorNode::make(opc, ctrl, mem, adr, adr_type, value, vlen);\n+  DEBUG_ONLY( if (VerifyAlignVector) { vn->set_must_verify_alignment(); } )\n+  register_new_node_from_vectorization_and_replace_scalar_nodes(vloop_analyzer, vn);\n+  return VTransformApplyResult::make_vector(vn, vlen, vn->memory_size());\n+}\n+\n+void VTransformVectorNode::register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  Node* first = nodes().at(0);\n+\n+  register_new_node_from_vectorization(vloop_analyzer, vn, first);\n+\n+  for (int i = 0; i < _nodes.length(); i++) {\n+    Node* n = _nodes.at(i);\n+    phase->igvn().replace_node(n, vn);\n+  }\n+}\n+\n+void VTransformNode::register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const {\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  phase->register_new_node_with_ctrl_of(vn, old_node);\n+  phase->igvn()._worklist.push(vn);\n+  VectorNode::trace_new_vector(vn, \"AutoVectorization\");\n+}\n+\n+#ifndef PRODUCT\n+void VTransformGraph::print_vtnodes() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_vtnodes:\");\n+  for (int i = 0; i < _vtnodes.length(); i++) {\n+    _vtnodes.at(i)->print();\n+  }\n+}\n+\n+void VTransformGraph::print_schedule() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_schedule:\");\n+  for (int i = 0; i < _schedule.length(); i++) {\n+    tty->print(\" %3d: \", i);\n+    VTransformNode* vtn = _schedule.at(i);\n+    if (vtn == nullptr) {\n+      tty->print_cr(\"nullptr\");\n+    } else {\n+      vtn->print();\n+    }\n+  }\n+}\n+\n+void VTransformGraph::print_memops_schedule() const {\n+  tty->print_cr(\"\\nVTransformGraph::print_memops_schedule:\");\n+  int i = 0;\n+  for_each_memop_in_schedule([&] (MemNode* mem) {\n+    tty->print(\" %3d: \", i++);\n+    mem->dump();\n+  });\n+}\n+\n+void VTransformNode::print() const {\n+  tty->print(\"%3d %s (\", _idx, name());\n+  for (uint i = 0; i < _req; i++) {\n+    print_node_idx(_in.at(i));\n+  }\n+  if ((uint)_in.length() > _req) {\n+    tty->print(\" |\");\n+    for (int i = _req; i < _in.length(); i++) {\n+      print_node_idx(_in.at(i));\n+    }\n+  }\n+  tty->print(\") [\");\n+  for (int i = 0; i < _out.length(); i++) {\n+    print_node_idx(_out.at(i));\n+  }\n+  tty->print(\"] \");\n+  print_spec();\n+  tty->cr();\n+}\n+\n+void VTransformNode::print_node_idx(const VTransformNode* vtn) {\n+  if (vtn == nullptr) {\n+    tty->print(\" _\");\n+  } else {\n+    tty->print(\" %d\", vtn->_idx);\n+  }\n+}\n+\n+void VTransformScalarNode::print_spec() const {\n+  tty->print(\"node[%d %s]\", _node->_idx, _node->Name());\n+}\n+\n+void VTransformReplicateNode::print_spec() const {\n+  tty->print(\"vlen=%d element_type=\", _vlen);\n+  _element_type->dump();\n+}\n+\n+void VTransformShiftCountNode::print_spec() const {\n+  tty->print(\"vlen=%d element_bt=%s mask=%d shift_opcode=%s\",\n+             _vlen, type2name(_element_bt), _mask,\n+             NodeClassNames[_shift_opcode]);\n+}\n+\n+void VTransformPopulateIndexNode::print_spec() const {\n+  tty->print(\"vlen=%d element_bt=%s\", _vlen, type2name(_element_bt));\n+}\n+\n+void VTransformVectorNode::print_spec() const {\n+  tty->print(\"%d-pack[\", _nodes.length());\n+  for (int i = 0; i < _nodes.length(); i++) {\n+    Node* n = _nodes.at(i);\n+    if (i > 0) {\n+      tty->print(\", \");\n+    }\n+    tty->print(\"%d %s\", n->_idx, n->Name());\n+  }\n+  tty->print(\"]\");\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":440,"deletions":0,"binary":false,"changes":440,"status":"added"},{"patch":"@@ -0,0 +1,515 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_OPTO_VTRANSFORM_HPP\n+#define SHARE_OPTO_VTRANSFORM_HPP\n+\n+#include \"opto\/node.hpp\"\n+#include \"opto\/vectorization.hpp\"\n+\n+\/\/ VTransform:\n+\/\/ - Models the transformation of the scalar loop to vectorized loop:\n+\/\/   It is a \"C2 subgraph\" -> \"C2 subgraph\" mapping.\n+\/\/ - The VTransform contains a graph (VTransformGraph), which consists of\n+\/\/   many vtnodes (VTransformNode).\n+\/\/ - Each vtnode models a part of the transformation, and is supposed\n+\/\/   to represent the output C2 nodes after the vectorization as closely\n+\/\/   as possible.\n+\/\/\n+\/\/ This is the life-cycle of a VTransform:\n+\/\/ - Construction:\n+\/\/   - From SuperWord, with the SuperWordVTransformBuilder.\n+\/\/\n+\/\/ - Future Plans: optimize, if-conversion, etc.\n+\/\/\n+\/\/ - Schedule:\n+\/\/   - Compute linearization of the VTransformGraph, into an order that respects\n+\/\/     all edges in the graph (bailout if cycle detected).\n+\/\/\n+\/\/ - Apply:\n+\/\/   - Changes to the C2 IR are only made once the \"apply\" method is called.\n+\/\/   - Each vtnode generates its corresponding scalar and vector C2 nodes,\n+\/\/     possibly replacing old scalar C2 nodes.\n+\/\/\n+\/\/ Future Plans with VTransform:\n+\/\/ - Cost model: estimate if vectorization is profitable.\n+\/\/ - Optimizations: moving unordered reductions out of the loop, whih decreases cost.\n+\/\/ - Pack\/Unpack\/Shuffle: introduce additional nodes not present in the scalar loop.\n+\/\/                        This is difficult to do with the SuperWord packset approach.\n+\/\/ - If-conversion: convert predicated nodes into CFG.\n+\n+typedef int VTransformNodeIDX;\n+class VTransformNode;\n+class VTransformScalarNode;\n+class VTransformInputScalarNode;\n+class VTransformVectorNode;\n+class VTransformElementWiseVectorNode;\n+class VTransformBoolVectorNode;\n+class VTransformReductionVectorNode;\n+\n+\/\/ Result from VTransformNode::apply\n+class VTransformApplyResult {\n+private:\n+  Node* const _node;\n+  const uint _vector_length; \/\/ number of elements\n+  const uint _vector_width;  \/\/ total width in bytes\n+\n+  VTransformApplyResult(Node* n, uint vector_length, uint vector_width) :\n+    _node(n),\n+    _vector_length(vector_length),\n+    _vector_width(vector_width) {}\n+\n+public:\n+  static VTransformApplyResult make_scalar(Node* n) {\n+    return VTransformApplyResult(n, 0, 0);\n+  }\n+\n+  static VTransformApplyResult make_vector(Node* n, uint vector_length, uint vector_width) {\n+    assert(vector_length > 0 && vector_width > 0, \"must have nonzero size\");\n+    return VTransformApplyResult(n, vector_length, vector_width);\n+  }\n+\n+  static VTransformApplyResult make_empty() {\n+    return VTransformApplyResult(nullptr, 0, 0);\n+  }\n+\n+  Node* node() const { return _node; }\n+  uint vector_length() const { return _vector_length; }\n+  uint vector_width() const { return _vector_width; }\n+  NOT_PRODUCT( void trace(VTransformNode* vtnode) const; )\n+};\n+\n+#ifndef PRODUCT\n+\/\/ Convenience class for tracing flags.\n+class VTransformTrace {\n+public:\n+  const bool _verbose;\n+  const bool _rejections;\n+  const bool _align_vector;\n+  const bool _info;\n+\n+  VTransformTrace(const VTrace& vtrace,\n+                  const bool is_trace_rejections,\n+                  const bool is_trace_align_vector,\n+                  const bool is_trace_info) :\n+    _verbose     (vtrace.is_trace(TraceAutoVectorizationTag::ALL)),\n+    _rejections  (_verbose | is_trace_vtransform(vtrace) | is_trace_rejections),\n+    _align_vector(_verbose | is_trace_vtransform(vtrace) | is_trace_align_vector),\n+    _info        (_verbose | is_trace_vtransform(vtrace) | is_trace_info) {}\n+\n+  static bool is_trace_vtransform(const VTrace& vtrace) {\n+    return vtrace.is_trace(TraceAutoVectorizationTag::VTRANSFORM);\n+  }\n+};\n+#endif\n+\n+\/\/ VTransformGraph: component of VTransform\n+\/\/ See description at top of this file.\n+class VTransformGraph : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+  const VLoop& _vloop;\n+\n+  NOT_PRODUCT(const VTransformTrace _trace;)\n+\n+  VTransformNodeIDX _next_idx;\n+  GrowableArray<VTransformNode*> _vtnodes;\n+\n+  \/\/ Schedule (linearization) of the graph. We use this to reorder the memory graph\n+  \/\/ before inserting vector operations.\n+  GrowableArray<VTransformNode*> _schedule;\n+\n+public:\n+  VTransformGraph(const VLoopAnalyzer& vloop_analyzer,\n+                  Arena& arena\n+                  NOT_PRODUCT( COMMA const VTransformTrace trace)) :\n+    _vloop_analyzer(vloop_analyzer),\n+    _vloop(vloop_analyzer.vloop()),\n+    NOT_PRODUCT(_trace(trace) COMMA)\n+    _next_idx(0),\n+    _vtnodes(&arena, _vloop.estimated_body_length(), 0, nullptr),\n+    _schedule(&arena, _vloop.estimated_body_length(), 0, nullptr) {}\n+\n+  VTransformNodeIDX new_idx() { return _next_idx++; }\n+  void add_vtnode(VTransformNode* vtnode);\n+  bool is_empty() const { return _vtnodes.is_empty(); }\n+  bool is_scheduled() const { return _schedule.is_nonempty(); }\n+  const GrowableArray<VTransformNode*>& vtnodes() const { return _vtnodes; }\n+\n+  bool schedule();\n+  void apply_memops_reordering_with_schedule() const;\n+  void apply_vectorization_for_each_vtnode(uint& max_vector_length, uint& max_vector_width) const;\n+\n+private:\n+  \/\/ VLoop accessors\n+  PhaseIdealLoop* phase()     const { return _vloop.phase(); }\n+  PhaseIterGVN& igvn()        const { return _vloop.phase()->igvn(); }\n+  bool in_bb(const Node* n)   const { return _vloop.in_bb(n); }\n+\n+  void collect_nodes_without_req_or_dependency(GrowableArray<VTransformNode*>& stack) const;\n+\n+  template<typename Callback>\n+  void for_each_memop_in_schedule(Callback callback) const;\n+\n+#ifndef PRODUCT\n+  void print_vtnodes() const;\n+  void print_schedule() const;\n+  void print_memops_schedule() const;\n+  void trace_schedule_cycle(const GrowableArray<VTransformNode*>& stack,\n+                            const VectorSet& pre_visited,\n+                            const VectorSet& post_visited) const;\n+#endif\n+};\n+\n+\/\/ VTransform: models the transformation of the scalar loop to vectorized loop.\n+\/\/ It is a \"C2 subgraph\" to \"C2 subgraph\" mapping.\n+\/\/ See description at top of this file.\n+class VTransform : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+  const VLoop& _vloop;\n+\n+  NOT_PRODUCT(const VTransformTrace _trace;)\n+\n+  \/\/ Everything in the vtransform is allocated from this arena, including all vtnodes.\n+  Arena _arena;\n+\n+  VTransformGraph _graph;\n+\n+  \/\/ Memory reference, and the alignment width (aw) for which we align the main-loop,\n+  \/\/ by adjusting the pre-loop limit.\n+  MemNode const* _mem_ref_for_main_loop_alignment;\n+  int _aw_for_main_loop_alignment;\n+\n+public:\n+  VTransform(const VLoopAnalyzer& vloop_analyzer,\n+             MemNode const* mem_ref_for_main_loop_alignment,\n+             int aw_for_main_loop_alignment\n+             NOT_PRODUCT( COMMA const VTransformTrace trace)\n+             ) :\n+    _vloop_analyzer(vloop_analyzer),\n+    _vloop(vloop_analyzer.vloop()),\n+    NOT_PRODUCT(_trace(trace) COMMA)\n+    _arena(mtCompiler),\n+    _graph(_vloop_analyzer, _arena NOT_PRODUCT(COMMA _trace)),\n+    _mem_ref_for_main_loop_alignment(mem_ref_for_main_loop_alignment),\n+    _aw_for_main_loop_alignment(aw_for_main_loop_alignment) {}\n+\n+  const VLoopAnalyzer& vloop_analyzer() const { return _vloop_analyzer; }\n+  Arena* arena() { return &_arena; }\n+  bool is_empty() const { return _graph.is_empty(); }\n+  VTransformGraph& graph() { return _graph; }\n+\n+  bool schedule() { return _graph.schedule(); }\n+  void apply();\n+\n+private:\n+  \/\/ VLoop accessors\n+  PhaseIdealLoop* phase()     const { return _vloop.phase(); }\n+  PhaseIterGVN& igvn()        const { return _vloop.phase()->igvn(); }\n+  IdealLoopTree* lpt()        const { return _vloop.lpt(); }\n+  CountedLoopNode* cl()       const { return _vloop.cl(); }\n+  int iv_stride()             const { return cl()->stride_con(); }\n+\n+  \/\/ VLoopVPointers accessors\n+  const VPointer& vpointer(const MemNode* mem) const {\n+    return _vloop_analyzer.vpointers().vpointer(mem);\n+  }\n+\n+  \/\/ Ensure that the main loop vectors are aligned by adjusting the pre loop limit.\n+  void determine_mem_ref_and_aw_for_main_loop_alignment();\n+  void adjust_pre_loop_limit_to_align_main_loop_vectors();\n+\n+  void apply_vectorization() const;\n+};\n+\n+\/\/ The vtnodes (VTransformNode) resemble the C2 IR Nodes, and model a part of the\n+\/\/ VTransform. Many such vtnodes make up the VTransformGraph. The vtnodes represent\n+\/\/ the resulting scalar and vector nodes as closely as possible.\n+\/\/ See description at top of this file.\n+class VTransformNode : public ArenaObj {\n+public:\n+  const VTransformNodeIDX _idx;\n+\n+private:\n+  \/\/ _in is split into required inputs (_req), and additional dependencies.\n+  const uint _req;\n+  GrowableArray<VTransformNode*> _in;\n+  GrowableArray<VTransformNode*> _out;\n+\n+public:\n+  VTransformNode(VTransform& vtransform, const uint req) :\n+    _idx(vtransform.graph().new_idx()),\n+    _req(req),\n+    _in(vtransform.arena(),  req, req, nullptr),\n+    _out(vtransform.arena(), 4, 0, nullptr)\n+  {\n+    vtransform.graph().add_vtnode(this);\n+  }\n+\n+  void set_req(uint i, VTransformNode* n) {\n+    assert(i < _req, \"must be a req\");\n+    assert(_in.at(i) == nullptr && n != nullptr, \"only set once\");\n+    _in.at_put(i, n);\n+    n->add_out(this);\n+  }\n+\n+  void swap_req(uint i, uint j) {\n+    assert(i < _req, \"must be a req\");\n+    assert(j < _req, \"must be a req\");\n+    VTransformNode* tmp = _in.at(i);\n+    _in.at_put(i, _in.at(j));\n+    _in.at_put(j, tmp);\n+  }\n+\n+  void add_dependency(VTransformNode* n) {\n+    assert(n != nullptr, \"no need to add nullptr\");\n+    _in.push(n);\n+    n->add_out(this);\n+  }\n+\n+  void add_out(VTransformNode* n) {\n+    _out.push(n);\n+  }\n+\n+  uint req() const { return _req; }\n+  VTransformNode* in(int i) const { return _in.at(i); }\n+  int outs() const { return _out.length(); }\n+  VTransformNode* out(int i) const { return _out.at(i); }\n+\n+  bool has_req_or_dependency() const {\n+    for (int i = 0; i < _in.length(); i++) {\n+      if (_in.at(i) != nullptr) { return true; }\n+    }\n+    return false;\n+  }\n+\n+  virtual VTransformScalarNode* isa_Scalar() { return nullptr; }\n+  virtual VTransformInputScalarNode* isa_InputScalar() { return nullptr; }\n+  virtual VTransformVectorNode* isa_Vector() { return nullptr; }\n+  virtual VTransformElementWiseVectorNode* isa_ElementWiseVector() { return nullptr; }\n+  virtual VTransformBoolVectorNode* isa_BoolVector() { return nullptr; }\n+  virtual VTransformReductionVectorNode* isa_ReductionVector() { return nullptr; }\n+\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const = 0;\n+\n+  Node* find_transformed_input(int i, const GrowableArray<Node*>& vnode_idx_to_transformed_node) const;\n+\n+  void register_new_node_from_vectorization(const VLoopAnalyzer& vloop_analyzer, Node* vn, Node* old_node) const;\n+\n+  NOT_PRODUCT(virtual const char* name() const = 0;)\n+  NOT_PRODUCT(void print() const;)\n+  NOT_PRODUCT(virtual void print_spec() const {};)\n+  NOT_PRODUCT(static void print_node_idx(const VTransformNode* vtn);)\n+};\n+\n+\/\/ Identity transform for scalar nodes.\n+class VTransformScalarNode : public VTransformNode {\n+private:\n+  Node* _node;\n+public:\n+  VTransformScalarNode(VTransform& vtransform, Node* n) :\n+    VTransformNode(vtransform, n->req()), _node(n) {}\n+  Node* node() const { return _node; }\n+  virtual VTransformScalarNode* isa_Scalar() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"Scalar\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Wrapper node for nodes outside the loop that are inputs to nodes in the loop.\n+\/\/ Since we want the loop-internal nodes to be able to reference all inputs as vtnodes,\n+\/\/ we must wrap the inputs that are outside the loop into special vtnodes, too.\n+class VTransformInputScalarNode : public VTransformScalarNode {\n+public:\n+  VTransformInputScalarNode(VTransform& vtransform, Node* n) :\n+    VTransformScalarNode(vtransform, n) {}\n+  virtual VTransformInputScalarNode* isa_InputScalar() override { return this; }\n+  NOT_PRODUCT(virtual const char* name() const override { return \"InputScalar\"; };)\n+};\n+\n+\/\/ Transform produces a ReplicateNode, replicating the input to all vector lanes.\n+class VTransformReplicateNode : public VTransformNode {\n+private:\n+  int _vlen;\n+  const Type* _element_type;\n+public:\n+  VTransformReplicateNode(VTransform& vtransform, int vlen, const Type* element_type) :\n+    VTransformNode(vtransform, 2), _vlen(vlen), _element_type(element_type) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"Replicate\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Transform introduces a scalar ConvI2LNode that was not previously in the C2 graph.\n+class VTransformConvI2LNode : public VTransformNode {\n+public:\n+  VTransformConvI2LNode(VTransform& vtransform) : VTransformNode(vtransform, 2) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ConvI2L\"; };)\n+};\n+\n+\/\/ Transform introduces a shift-count node that truncates the shift count for a vector shift.\n+class VTransformShiftCountNode : public VTransformNode {\n+private:\n+  int _vlen;\n+  const BasicType _element_bt;\n+  juint _mask;\n+  int _shift_opcode;\n+public:\n+  VTransformShiftCountNode(VTransform& vtransform, int vlen, BasicType element_bt, juint mask, int shift_opcode) :\n+    VTransformNode(vtransform, 2), _vlen(vlen), _element_bt(element_bt), _mask(mask), _shift_opcode(shift_opcode) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ShiftCount\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Transform introduces a PopulateIndex node: [phi, phi+1, phi+2, phi+3, ...].\n+class VTransformPopulateIndexNode : public VTransformNode {\n+private:\n+  int _vlen;\n+  const BasicType _element_bt;\n+public:\n+  VTransformPopulateIndexNode(VTransform& vtransform, int vlen, const BasicType element_bt) :\n+    VTransformNode(vtransform, 2), _vlen(vlen), _element_bt(element_bt) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"PopulateIndex\"; };)\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Base class for all vector vtnodes.\n+class VTransformVectorNode : public VTransformNode {\n+private:\n+  GrowableArray<Node*> _nodes;\n+public:\n+  VTransformVectorNode(VTransform& vtransform, const uint req, const uint number_of_nodes) :\n+    VTransformNode(vtransform, req), _nodes(vtransform.arena(), number_of_nodes, number_of_nodes, nullptr) {}\n+\n+  void set_nodes(const Node_List* pack) {\n+    for (uint k = 0; k < pack->size(); k++) {\n+      _nodes.at_put(k, pack->at(k));\n+    }\n+  }\n+\n+  const GrowableArray<Node*> nodes() const { return _nodes; }\n+  virtual VTransformVectorNode* isa_Vector() override { return this; }\n+  void register_new_node_from_vectorization_and_replace_scalar_nodes(const VLoopAnalyzer& vloop_analyzer, Node* vn) const;\n+  NOT_PRODUCT(virtual void print_spec() const override;)\n+};\n+\n+\/\/ Catch all for all element-wise vector operations.\n+class VTransformElementWiseVectorNode : public VTransformVectorNode {\n+public:\n+  VTransformElementWiseVectorNode(VTransform& vtransform, uint req, uint number_of_nodes) :\n+    VTransformVectorNode(vtransform, req, number_of_nodes) {}\n+  virtual VTransformElementWiseVectorNode* isa_ElementWiseVector() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ElementWiseVector\"; };)\n+};\n+\n+struct VTransformBoolTest {\n+  const BoolTest::mask _mask;\n+  const bool _is_negated;\n+\n+  VTransformBoolTest(const BoolTest::mask mask, bool is_negated) :\n+    _mask(mask), _is_negated(is_negated) {}\n+};\n+\n+class VTransformBoolVectorNode : public VTransformElementWiseVectorNode {\n+private:\n+  const VTransformBoolTest _test;\n+public:\n+  VTransformBoolVectorNode(VTransform& vtransform, uint number_of_nodes, VTransformBoolTest test) :\n+    VTransformElementWiseVectorNode(vtransform, 2, number_of_nodes), _test(test) {}\n+  VTransformBoolTest test() const { return _test; }\n+  virtual VTransformBoolVectorNode* isa_BoolVector() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"BoolVector\"; };)\n+};\n+\n+class VTransformReductionVectorNode : public VTransformVectorNode {\n+public:\n+  \/\/ req = 3 -> [ctrl, scalar init, vector]\n+  VTransformReductionVectorNode(VTransform& vtransform, uint number_of_nodes) :\n+    VTransformVectorNode(vtransform, 3, number_of_nodes) {}\n+  virtual VTransformReductionVectorNode* isa_ReductionVector() override { return this; }\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"ReductionVector\"; };)\n+};\n+\n+class VTransformLoadVectorNode : public VTransformVectorNode {\n+public:\n+  \/\/ req = 3 -> [ctrl, mem, adr]\n+  VTransformLoadVectorNode(VTransform& vtransform, uint number_of_nodes) :\n+    VTransformVectorNode(vtransform, 3, number_of_nodes) {}\n+  LoadNode::ControlDependency control_dependency() const;\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"LoadVector\"; };)\n+};\n+\n+class VTransformStoreVectorNode : public VTransformVectorNode {\n+public:\n+  \/\/ req = 4 -> [ctrl, mem, adr, val]\n+  VTransformStoreVectorNode(VTransform& vtransform, uint number_of_nodes) :\n+    VTransformVectorNode(vtransform, 4, number_of_nodes) {}\n+  virtual VTransformApplyResult apply(const VLoopAnalyzer& vloop_analyzer,\n+                                      const GrowableArray<Node*>& vnode_idx_to_transformed_node) const override;\n+  NOT_PRODUCT(virtual const char* name() const override { return \"StoreVector\"; };)\n+};\n+\n+\/\/ Invoke callback on all memops, in the order of the schedule.\n+template<typename Callback>\n+void VTransformGraph::for_each_memop_in_schedule(Callback callback) const {\n+  assert(_schedule.length() == _vtnodes.length(), \"schedule was computed\");\n+\n+  for (int i = 0; i < _schedule.length(); i++) {\n+    VTransformNode* vtn = _schedule.at(i);\n+\n+    \/\/ We can ignore input nodes, they are outside the loop.\n+    if (vtn->isa_InputScalar() != nullptr) { continue; }\n+\n+    VTransformScalarNode* scalar = vtn->isa_Scalar();\n+    if (scalar != nullptr && scalar->node()->is_Mem()) {\n+      callback(scalar->node()->as_Mem());\n+    }\n+\n+    VTransformVectorNode* vector = vtn->isa_Vector();\n+    if (vector != nullptr && vector->nodes().at(0)->is_Mem()) {\n+      for (int j = 0; j < vector->nodes().length(); j++) {\n+        callback(vector->nodes().at(j)->as_Mem());\n+      }\n+    }\n+  }\n+}\n+\n+#endif \/\/ SHARE_OPTO_VTRANSFORM_HPP\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":515,"deletions":0,"binary":false,"changes":515,"status":"added"}]}