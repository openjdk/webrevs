{"files":[{"patch":"@@ -1905,1 +1905,1 @@\n-  apply_memops_reordering_with_schedule();\n+  _graph.apply_memops_reordering_with_schedule();\n@@ -1919,1 +1919,1 @@\n-void VTransform::apply_memops_reordering_with_schedule() const {\n+void VTransformGraph::apply_memops_reordering_with_schedule() const {\n@@ -1921,1 +1921,1 @@\n-  assert(_graph.is_scheduled(), \"must be already scheduled\");\n+  assert(is_scheduled(), \"must be already scheduled\");\n@@ -1923,1 +1923,1 @@\n-    _graph.print_memops_schedule();\n+    print_memops_schedule();\n@@ -1952,1 +1952,1 @@\n-  _graph.for_each_memop_in_schedule([&] (MemNode* n) {\n+  for_each_memop_in_schedule([&] (MemNode* n) {\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,3 +46,2 @@\n-\/\/ TODO: maybe do this in graph, but then tracing is an issue...\n-bool VTransform::schedule() {\n-  assert(!_graph.is_scheduled(), \"not yet scheduled\");\n+bool VTransformGraph::schedule() {\n+  assert(!is_scheduled(), \"not yet scheduled\");\n@@ -52,1 +51,1 @@\n-    _graph.print_vtnodes();\n+    print_vtnodes();\n@@ -61,1 +60,1 @@\n-  _graph.collect_nodes_without_req_or_dependency(stack);\n+  collect_nodes_without_req_or_dependency(stack);\n@@ -65,1 +64,1 @@\n-  int rpo_idx = _graph.vtnodes().length() - 1;\n+  int rpo_idx = _vtnodes.length() - 1;\n@@ -86,1 +85,1 @@\n-          NOT_PRODUCT(if (_trace._rejections) { _graph.trace_schedule_cycle(stack, pre_visited, post_visited); } )\n+          NOT_PRODUCT(if (_trace._rejections) { trace_schedule_cycle(stack, pre_visited, post_visited); } )\n@@ -95,2 +94,2 @@\n-        post_visited.set(vtn->_idx);                   \/\/ post-visit\n-        _graph.add_vtnode_to_schedule(rpo_idx--, vtn); \/\/ assign rpo_idx\n+        post_visited.set(vtn->_idx);           \/\/ post-visit\n+        _schedule.at_put_grow(rpo_idx--, vtn); \/\/ assign rpo_idx\n@@ -106,1 +105,1 @@\n-    _graph.print_schedule();\n+    print_schedule();\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -147,1 +147,0 @@\n-  void add_vtnode_to_schedule(int index, VTransformNode* vtn) { _schedule.at_put_grow(index, vtn); }\n@@ -149,2 +148,9 @@\n-  template<typename Callback>\n-  void for_each_memop_in_schedule(Callback callback) const;\n+  bool schedule();\n+  void apply_memops_reordering_with_schedule() const;\n+  void apply_vectorization_for_each_vtnode(uint& max_vector_length, uint& max_vector_width) const;\n+\n+private:\n+  \/\/ VLoop accessors\n+  PhaseIdealLoop* phase()     const { return _vloop.phase(); }\n+  PhaseIterGVN& igvn()        const { return _vloop.phase()->igvn(); }\n+  bool in_bb(const Node* n)   const { return _vloop.in_bb(n); }\n@@ -154,1 +160,2 @@\n-  void apply_vectorization_for_each_vtnode(uint& max_vector_length, uint& max_vector_width) const;\n+  template<typename Callback>\n+  void for_each_memop_in_schedule(Callback callback) const;\n@@ -218,1 +225,1 @@\n-  bool schedule();\n+  bool schedule() { return _graph.schedule(); }\n@@ -235,2 +242,0 @@\n-  void apply_memops_reordering_with_schedule() const;\n-\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"}]}