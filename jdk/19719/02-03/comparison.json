{"files":[{"patch":"@@ -37,0 +37,1 @@\n+#include \"opto\/superwordVTransformBuilder.hpp\"\n@@ -3034,281 +3035,0 @@\n-void SuperWordVTransformBuilder::build() {\n-  assert(!_packset.is_empty(), \"must have non-empty packset\");\n-  assert(_graph.is_empty(), \"start with empty graph\");\n-\n-  \/\/ Create vtnodes for all nodes in the loop.\n-  build_vector_vtnodes_for_packed_nodes();\n-  build_scalar_vtnodes_for_non_packed_nodes();\n-\n-  \/\/ Connect all vtnodes with their inputs. Possibly create vtnodes for input\n-  \/\/ nodes that are outside the loop.\n-  VectorSet vtn_dependencies; \/\/ Shared, but cleared for every vtnode.\n-  build_inputs_for_vector_vtnodes(vtn_dependencies);\n-  build_inputs_for_scalar_vtnodes(vtn_dependencies);\n-}\n-\n-void SuperWordVTransformBuilder::build_vector_vtnodes_for_packed_nodes() {\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* pack = _packset.at(i);\n-    VTransformVectorNode* vtn = make_vector_vtnode_for_pack(pack);\n-    for (uint k = 0; k < pack->size(); k++) {\n-      map_node_to_vtnode(pack->at(k), vtn);\n-    }\n-  }\n-}\n-\n-void SuperWordVTransformBuilder::build_scalar_vtnodes_for_non_packed_nodes() {\n-  for (int i = 0; i < _vloop_analyzer.body().body().length(); i++) {\n-    Node* n = _vloop_analyzer.body().body().at(i);\n-    if (_packset.get_pack(n) != nullptr) { continue; }\n-    VTransformScalarNode* vtn = new (_graph.arena()) VTransformScalarNode(_graph, n);\n-    map_node_to_vtnode(n, vtn);\n-  }\n-}\n-\n-void SuperWordVTransformBuilder::build_inputs_for_vector_vtnodes(VectorSet& vtn_dependencies) {\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* pack = _packset.at(i);\n-    Node* p0 = pack->at(0);\n-\n-    VTransformVectorNode* vtn = get_vtnode(p0)->isa_Vector();\n-    assert(vtn != nullptr, \"all packs must have vector vtnodes\");\n-    vtn_dependencies.clear(); \/\/ Add every dependency only once per vtn.\n-\n-    if (p0->is_Load()) {\n-      set_req_with_scalar(p0,   vtn, vtn_dependencies, MemNode::Address);\n-    } else if (p0->is_Store()) {\n-      set_req_with_scalar(p0,   vtn, vtn_dependencies, MemNode::Address);\n-      set_req_with_vector(pack, vtn, vtn_dependencies, MemNode::ValueIn);\n-    } else if (vtn->isa_ReductionVector() != nullptr) {\n-      set_req_with_scalar(p0,   vtn, vtn_dependencies, 1); \/\/ scalar init\n-      set_req_with_vector(pack, vtn, vtn_dependencies, 2); \/\/ vector\n-    } else {\n-      assert(vtn->isa_ElementWiseVector() != nullptr, \"all other vtnodes are handled above\");\n-      if (VectorNode::is_scalar_rotate(p0) &&\n-          p0->in(2)->is_Con() &&\n-          Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n-        set_req_with_vector(pack, vtn, vtn_dependencies, 1);\n-        set_req_with_scalar(p0,   vtn, vtn_dependencies, 2); \/\/ constant rotation\n-      } else if (VectorNode::is_roundopD(p0)) {\n-        set_req_with_vector(pack, vtn, vtn_dependencies, 1);\n-        set_req_with_scalar(p0,   vtn, vtn_dependencies, 2); \/\/ constant rounding mode\n-      } else if (p0->is_CMove()) {\n-        \/\/ Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n-        set_all_req_with_vectors(pack, vtn, vtn_dependencies);\n-        VTransformBoolVectorNode* vtn_mask_cmp = vtn->in(1)->isa_BoolVector();\n-        if (vtn_mask_cmp->test()._is_negated) {\n-          vtn->swap_req(2, 3); \/\/ swap if test was negated.\n-        }\n-      } else {\n-        set_all_req_with_vectors(pack, vtn, vtn_dependencies);\n-      }\n-    }\n-\n-    for (uint k = 0; k < pack->size(); k++) {\n-      add_dependencies_of_node_to_vtnode(pack->at(k), vtn, vtn_dependencies);\n-    }\n-  }\n-}\n-\n-void SuperWordVTransformBuilder::build_inputs_for_scalar_vtnodes(VectorSet& vtn_dependencies) {\n-  for (int i = 0; i < _vloop_analyzer.body().body().length(); i++) {\n-    Node* n = _vloop_analyzer.body().body().at(i);\n-    VTransformScalarNode* vtn = get_vtnode(n)->isa_Scalar();\n-    if (vtn == nullptr) { continue; }\n-    vtn_dependencies.clear(); \/\/ Add every dependency only once per vtn.\n-\n-    if (n->is_Load()) {\n-      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::Address);\n-    } else if (n->is_Store()) {\n-      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::Address);\n-      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::ValueIn);\n-    } else if (n->is_CountedLoop()) {\n-      continue; \/\/ Is \"root\", has no dependency.\n-    } else if (n->is_Phi()) {\n-      \/\/ CountedLoop Phi's: ignore backedge (and entry value).\n-      assert(n->in(0) == _vloop.cl(), \"only Phi's from the CountedLoop allowed\");\n-      set_req_with_scalar(n, vtn, vtn_dependencies, 0);\n-      continue;\n-    } else {\n-      set_all_req_with_scalars(n, vtn, vtn_dependencies);\n-    }\n-\n-    add_dependencies_of_node_to_vtnode(n, vtn, vtn_dependencies);\n-  }\n-}\n-\n-\/\/ Create a vtnode for each pack. No in\/out edges set yet.\n-VTransformVectorNode* SuperWordVTransformBuilder::make_vector_vtnode_for_pack(const Node_List* pack) const {\n-  uint pack_size = pack->size();\n-  Node* p0 = pack->at(0);\n-  int opc = p0->Opcode();\n-  VTransformVectorNode* vtn = nullptr;\n-\n-  if (p0->is_Load()) {\n-    vtn = new (_graph.arena()) VTransformLoadVectorNode(_graph, pack_size);\n-  } else if (p0->is_Store()) {\n-    vtn = new (_graph.arena()) VTransformStoreVectorNode(_graph, pack_size);\n-  } else if (p0->is_Bool()) {\n-    VTransformBoolTest kind = _packset.get_bool_test(pack);\n-    vtn = new (_graph.arena()) VTransformBoolVectorNode(_graph, pack_size, kind);\n-  } else if (_vloop_analyzer.reductions().is_marked_reduction(p0)) {\n-    vtn = new (_graph.arena()) VTransformReductionVectorNode(_graph, pack_size);\n-  } else if (VectorNode::is_muladds2i(p0)) {\n-    \/\/ A special kind of binary element-wise vector op: the inputs are \"ints\" a and b,\n-    \/\/ but reinterpreted as two \"shorts\" [a0, a1] and [b0, b1]:\n-    \/\/   v = MulAddS2I(a, b) = a0 * b0 + a1 + b1\n-    assert(p0->req() == 5, \"MulAddS2I should have 4 operands\");\n-    vtn = new (_graph.arena()) VTransformElementWiseVectorNode(_graph, 3, pack_size);\n-  } else {\n-    assert(p0->req() == 3 ||\n-           p0->is_CMove() ||\n-           VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc) ||\n-           VectorNode::is_convert_opcode(opc) ||\n-           VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc) ||\n-           opc == Op_FmaD ||\n-           opc == Op_FmaF ||\n-           opc == Op_SignumF ||\n-           opc == Op_SignumD,\n-           \"pack type must be in this list\");\n-    vtn = new (_graph.arena()) VTransformElementWiseVectorNode(_graph, p0->req(), pack_size);\n-  }\n-  vtn->set_nodes(pack);\n-  return vtn;\n-}\n-\n-void SuperWordVTransformBuilder::set_req_with_scalar(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index) {\n-  VTransformNode* req = get_vtnode_or_wrap_as_input_scalar(n->in(index));\n-  vtn->set_req(index, req);\n-  vtn_dependencies.set(req->_idx);\n-}\n-\n-\/\/ Either get existing vtnode vector input (when input is a pack), or else make a\n-\/\/ new one vector vtnode for the input (e.g. for Replicate or PopulateIndex).\n-VTransformNode* SuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index(const Node_List* pack, const int index) {\n-  Node* p0 = pack->at(0);\n-\n-  Node_List* pack_in = _packset.pack_input_at_index_or_null(pack, index);\n-  if (pack_in != nullptr) {\n-    \/\/ Input is a matching pack -> vtnode already exists.\n-    assert(index != 2 || !VectorNode::is_shift(p0), \"shift's count cannot be vector\");\n-    return get_vtnode(pack_in->at(0));\n-  }\n-\n-  if (VectorNode::is_muladds2i(p0)) {\n-    assert(_packset.is_muladds2i_pack_with_pack_inputs(pack), \"inputs must all be packs\");\n-    \/\/ All inputs are strided (stride = 2), either with offset 0 or 1.\n-    Node_List* pack_in0 = _packset.strided_pack_input_at_index_or_null(pack, index, 2, 0);\n-    if (pack_in0 != nullptr) {\n-      return get_vtnode(pack_in0->at(0));\n-    }\n-    Node_List* pack_in1 = _packset.strided_pack_input_at_index_or_null(pack, index, 2, 1);\n-    if (pack_in1 != nullptr) {\n-      return get_vtnode(pack_in1->at(0));\n-    }\n-  }\n-\n-  Node* same_input = _packset.same_inputs_at_index_or_null(pack, index);\n-  if (same_input == nullptr && p0->in(index) == _vloop.iv()) {\n-    \/\/ PopulateIndex: [iv+0, iv+1, iv+2, ...]\n-    VTransformNode* iv_vtn = get_vtnode_or_wrap_as_input_scalar(_vloop.iv());\n-    BasicType p0_bt = _vloop_analyzer.types().velt_basic_type(p0);\n-    \/\/ If we have subword type, take that type directly. If p0 is some ConvI2L\/F\/D,\n-    \/\/ then the p0_bt can also be L\/F\/D but we need to produce ints for the input of\n-    \/\/ the ConvI2L\/F\/D.\n-    BasicType element_bt = is_subword_type(p0_bt) ? p0_bt : T_INT;\n-    VTransformNode* populate_index = new (_graph.arena()) VTransformPopulateIndexNode(_graph, pack->size(), element_bt);\n-    populate_index->set_req(1, iv_vtn);\n-    return populate_index;\n-  }\n-\n-  if (same_input != nullptr) {\n-    VTransformNode* same_input_vtn = get_vtnode_or_wrap_as_input_scalar(same_input);\n-    if (index == 2 && VectorNode::is_shift(p0)) {\n-      \/\/ Scalar shift count for vector shift operation: vec2 = shiftV(vec1, scalar_count)\n-      \/\/ Scalar shift operations masks the shift count, but the vector shift does not, so\n-      \/\/ create a special ShiftCount node.\n-      BasicType element_bt = _vloop_analyzer.types().velt_basic_type(p0);\n-      juint mask = (p0->bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);\n-      VTransformNode* shift_count = new (_graph.arena()) VTransformShiftCountNode(_graph, pack->size(), element_bt, mask, p0->Opcode());\n-      shift_count->set_req(1, same_input_vtn);\n-      return shift_count;\n-    } else {\n-      \/\/ Replicate the scalar same_input to every vector element.\n-      const Type* element_type = _vloop_analyzer.types().velt_type(p0);\n-      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type->isa_long()) {\n-        \/\/ Scalar rotate has int rotation value, but the scalar rotate expects longs.\n-        assert(same_input->bottom_type()->isa_int(), \"scalar rotate expects int rotation\");\n-        VTransformNode* conv = new (_graph.arena()) VTransformConvI2LNode(_graph);\n-        conv->set_req(1, same_input_vtn);\n-        same_input_vtn = conv;\n-      }\n-      VTransformNode* replicate = new (_graph.arena()) VTransformReplicateNode(_graph, pack->size(), element_type);\n-      replicate->set_req(1, same_input_vtn);\n-      return replicate;\n-    }\n-  }\n-\n-  \/\/ The input is neither a pack not a same_input node. SuperWord::profitable does not allow\n-  \/\/ any other case. In the future, we could insert a PackNode.\n-#ifdef ASSERT\n-  tty->print_cr(\"\\nSuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index: index=%d\", index);\n-  pack->dump();\n-  assert(false, \"Pack input was neither a pack nor a same_input node\");\n-#endif\n-  ShouldNotReachHere();\n-}\n-\n-VTransformNode* SuperWordVTransformBuilder::get_vtnode_or_wrap_as_input_scalar(Node* n) {\n-  VTransformNode* vtn = get_vtnode_or_null(n);\n-  if (vtn != nullptr) { return vtn; }\n-\n-  assert(!_vloop.in_bb(n), \"only nodes outside the loop can be input nodes to the loop\");\n-  vtn = new (_graph.arena()) VTransformInputScalarNode(_graph, n);\n-  map_node_to_vtnode(n, vtn);\n-  return vtn;\n-}\n-\n-void SuperWordVTransformBuilder::set_req_with_vector(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies, int j) {\n-  VTransformNode* req = get_or_make_vtnode_vector_input_at_index(pack, j);\n-  vtn->set_req(j, req);\n-  vtn_dependencies.set(req->_idx);\n-}\n-\n-void SuperWordVTransformBuilder::set_all_req_with_scalars(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n-  assert(vtn->req() == n->req(), \"scalars must have same number of reqs\");\n-  for (uint j = 0; j < n->req(); j++) {\n-    Node* def = n->in(j);\n-    if (def == nullptr) { continue; }\n-    set_req_with_scalar(n, vtn, vtn_dependencies, j);\n-  }\n-}\n-\n-void SuperWordVTransformBuilder::set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n-  Node* p0 = pack->at(0);\n-  assert(vtn->req() <= p0->req(), \"must have at at most as many reqs\");\n-  \/\/ Vectors have no ctrl, so ignore it.\n-  for (uint j = 1; j < vtn->req(); j++) {\n-    Node* def = p0->in(j);\n-    if (def == nullptr) { continue; }\n-    set_req_with_vector(pack, vtn, vtn_dependencies, j);\n-  }\n-}\n-\n-void SuperWordVTransformBuilder::add_dependencies_of_node_to_vtnode(Node*n, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n-  for (VLoopDependencyGraph::PredsIterator preds(_vloop_analyzer.dependency_graph(), n); !preds.done(); preds.next()) {\n-    Node* pred = preds.current();\n-    if (!_vloop.in_bb(pred)) { continue; }\n-\n-    \/\/ Only add memory dependencies to memory nodes. All others are taken care of with the req.\n-    if (n->is_Mem() && !pred->is_Mem()) { continue; }\n-\n-    VTransformNode* dependency = get_vtnode(pred);\n-\n-    \/\/ Reduction self-cycle?\n-    if (vtn == dependency && _vloop_analyzer.reductions().is_marked_reduction(n)) { continue; }\n-\n-    if (vtn_dependencies.test_set(dependency->_idx)) { continue; }\n-    vtn->add_dependency(dependency); \/\/ Add every dependency only once per vtn.\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":281,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"opto\/superwordVTransformBuilder.hpp\"\n@@ -635,57 +634,0 @@\n-\/\/ Facility class that builds a VTransformGraph from a SuperWord PackSet.\n-class SuperWordVTransformBuilder : public StackObj {\n-private:\n-  const VLoopAnalyzer& _vloop_analyzer;\n-  const VLoop& _vloop;\n-  const PackSet& _packset;\n-  VTransformGraph& _graph;\n-\n-  ResourceHashtable<\/* Node::_idx*\/ int, VTransformNode* \/* or null*\/> _idx_to_vtnode;\n-\n-public:\n-  SuperWordVTransformBuilder(const PackSet& packset,\n-                             VTransformGraph& graph) :\n-      _vloop_analyzer(graph.vloop_analyzer()),\n-      _vloop(_vloop_analyzer.vloop()),\n-      _packset(packset),\n-      _graph(graph)\n-  {\n-    assert(_graph.is_empty(), \"constructor is passed an empty graph\");\n-    build();\n-    assert(!_graph.is_empty(), \"graph must contain some vtnodes now\");\n-  }\n-\n-private:\n-  void build();\n-  void build_vector_vtnodes_for_packed_nodes();\n-  void build_scalar_vtnodes_for_non_packed_nodes();\n-  void build_inputs_for_vector_vtnodes(VectorSet& vtn_dependencies);\n-  void build_inputs_for_scalar_vtnodes(VectorSet& vtn_dependencies);\n-\n-  \/\/ Helper methods for building VTransformGraph.\n-  VTransformNode* get_vtnode_or_null(Node* n) const {\n-    VTransformNode** ptr = _idx_to_vtnode.get(n->_idx);\n-    return (ptr == nullptr) ? nullptr : *ptr;\n-  }\n-\n-  VTransformNode* get_vtnode(Node* n) const {\n-    VTransformNode* vtn = get_vtnode_or_null(n);\n-    assert(vtn != nullptr, \"expect non-null vtnode\");\n-    return vtn;\n-  }\n-\n-  void map_node_to_vtnode(Node* n, VTransformNode* vtn) {\n-    assert(vtn != nullptr, \"only set non-null vtnodes\");\n-    _idx_to_vtnode.put_when_absent(n->_idx, vtn);\n-  }\n-\n-  VTransformVectorNode* make_vector_vtnode_for_pack(const Node_List* pack) const;\n-  VTransformNode* get_or_make_vtnode_vector_input_at_index(const Node_List* pack, const int index);\n-  VTransformNode* get_vtnode_or_wrap_as_input_scalar(Node* n);\n-  void set_req_with_scalar(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index);\n-  void set_req_with_vector(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index);\n-  void set_all_req_with_scalars(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies);\n-  void set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies);\n-  void add_dependencies_of_node_to_vtnode(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies);\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":0,"deletions":58,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -25,0 +25,282 @@\n+#include \"opto\/vectornode.hpp\"\n+\n+void SuperWordVTransformBuilder::build() {\n+  assert(!_packset.is_empty(), \"must have non-empty packset\");\n+  assert(_graph.is_empty(), \"start with empty graph\");\n+\n+  \/\/ Create vtnodes for all nodes in the loop.\n+  build_vector_vtnodes_for_packed_nodes();\n+  build_scalar_vtnodes_for_non_packed_nodes();\n+\n+  \/\/ Connect all vtnodes with their inputs. Possibly create vtnodes for input\n+  \/\/ nodes that are outside the loop.\n+  VectorSet vtn_dependencies; \/\/ Shared, but cleared for every vtnode.\n+  build_inputs_for_vector_vtnodes(vtn_dependencies);\n+  build_inputs_for_scalar_vtnodes(vtn_dependencies);\n+}\n+\n+void SuperWordVTransformBuilder::build_vector_vtnodes_for_packed_nodes() {\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* pack = _packset.at(i);\n+    VTransformVectorNode* vtn = make_vector_vtnode_for_pack(pack);\n+    for (uint k = 0; k < pack->size(); k++) {\n+      map_node_to_vtnode(pack->at(k), vtn);\n+    }\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::build_scalar_vtnodes_for_non_packed_nodes() {\n+  for (int i = 0; i < _vloop_analyzer.body().body().length(); i++) {\n+    Node* n = _vloop_analyzer.body().body().at(i);\n+    if (_packset.get_pack(n) != nullptr) { continue; }\n+    VTransformScalarNode* vtn = new (_graph.arena()) VTransformScalarNode(_graph, n);\n+    map_node_to_vtnode(n, vtn);\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::build_inputs_for_vector_vtnodes(VectorSet& vtn_dependencies) {\n+  for (int i = 0; i < _packset.length(); i++) {\n+    Node_List* pack = _packset.at(i);\n+    Node* p0 = pack->at(0);\n+\n+    VTransformVectorNode* vtn = get_vtnode(p0)->isa_Vector();\n+    assert(vtn != nullptr, \"all packs must have vector vtnodes\");\n+    vtn_dependencies.clear(); \/\/ Add every dependency only once per vtn.\n+\n+    if (p0->is_Load()) {\n+      set_req_with_scalar(p0,   vtn, vtn_dependencies, MemNode::Address);\n+    } else if (p0->is_Store()) {\n+      set_req_with_scalar(p0,   vtn, vtn_dependencies, MemNode::Address);\n+      set_req_with_vector(pack, vtn, vtn_dependencies, MemNode::ValueIn);\n+    } else if (vtn->isa_ReductionVector() != nullptr) {\n+      set_req_with_scalar(p0,   vtn, vtn_dependencies, 1); \/\/ scalar init\n+      set_req_with_vector(pack, vtn, vtn_dependencies, 2); \/\/ vector\n+    } else {\n+      assert(vtn->isa_ElementWiseVector() != nullptr, \"all other vtnodes are handled above\");\n+      if (VectorNode::is_scalar_rotate(p0) &&\n+          p0->in(2)->is_Con() &&\n+          Matcher::supports_vector_constant_rotates(p0->in(2)->get_int())) {\n+        set_req_with_vector(pack, vtn, vtn_dependencies, 1);\n+        set_req_with_scalar(p0,   vtn, vtn_dependencies, 2); \/\/ constant rotation\n+      } else if (VectorNode::is_roundopD(p0)) {\n+        set_req_with_vector(pack, vtn, vtn_dependencies, 1);\n+        set_req_with_scalar(p0,   vtn, vtn_dependencies, 2); \/\/ constant rounding mode\n+      } else if (p0->is_CMove()) {\n+        \/\/ Cmp + Bool + CMove -> VectorMaskCmp + VectorBlend.\n+        set_all_req_with_vectors(pack, vtn, vtn_dependencies);\n+        VTransformBoolVectorNode* vtn_mask_cmp = vtn->in(1)->isa_BoolVector();\n+        if (vtn_mask_cmp->test()._is_negated) {\n+          vtn->swap_req(2, 3); \/\/ swap if test was negated.\n+        }\n+      } else {\n+        set_all_req_with_vectors(pack, vtn, vtn_dependencies);\n+      }\n+    }\n+\n+    for (uint k = 0; k < pack->size(); k++) {\n+      add_dependencies_of_node_to_vtnode(pack->at(k), vtn, vtn_dependencies);\n+    }\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::build_inputs_for_scalar_vtnodes(VectorSet& vtn_dependencies) {\n+  for (int i = 0; i < _vloop_analyzer.body().body().length(); i++) {\n+    Node* n = _vloop_analyzer.body().body().at(i);\n+    VTransformScalarNode* vtn = get_vtnode(n)->isa_Scalar();\n+    if (vtn == nullptr) { continue; }\n+    vtn_dependencies.clear(); \/\/ Add every dependency only once per vtn.\n+\n+    if (n->is_Load()) {\n+      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::Address);\n+    } else if (n->is_Store()) {\n+      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::Address);\n+      set_req_with_scalar(n, vtn, vtn_dependencies, MemNode::ValueIn);\n+    } else if (n->is_CountedLoop()) {\n+      continue; \/\/ Is \"root\", has no dependency.\n+    } else if (n->is_Phi()) {\n+      \/\/ CountedLoop Phi's: ignore backedge (and entry value).\n+      assert(n->in(0) == _vloop.cl(), \"only Phi's from the CountedLoop allowed\");\n+      set_req_with_scalar(n, vtn, vtn_dependencies, 0);\n+      continue;\n+    } else {\n+      set_all_req_with_scalars(n, vtn, vtn_dependencies);\n+    }\n+\n+    add_dependencies_of_node_to_vtnode(n, vtn, vtn_dependencies);\n+  }\n+}\n+\n+\/\/ Create a vtnode for each pack. No in\/out edges set yet.\n+VTransformVectorNode* SuperWordVTransformBuilder::make_vector_vtnode_for_pack(const Node_List* pack) const {\n+  uint pack_size = pack->size();\n+  Node* p0 = pack->at(0);\n+  int opc = p0->Opcode();\n+  VTransformVectorNode* vtn = nullptr;\n+\n+  if (p0->is_Load()) {\n+    vtn = new (_graph.arena()) VTransformLoadVectorNode(_graph, pack_size);\n+  } else if (p0->is_Store()) {\n+    vtn = new (_graph.arena()) VTransformStoreVectorNode(_graph, pack_size);\n+  } else if (p0->is_Bool()) {\n+    VTransformBoolTest kind = _packset.get_bool_test(pack);\n+    vtn = new (_graph.arena()) VTransformBoolVectorNode(_graph, pack_size, kind);\n+  } else if (_vloop_analyzer.reductions().is_marked_reduction(p0)) {\n+    vtn = new (_graph.arena()) VTransformReductionVectorNode(_graph, pack_size);\n+  } else if (VectorNode::is_muladds2i(p0)) {\n+    \/\/ A special kind of binary element-wise vector op: the inputs are \"ints\" a and b,\n+    \/\/ but reinterpreted as two \"shorts\" [a0, a1] and [b0, b1]:\n+    \/\/   v = MulAddS2I(a, b) = a0 * b0 + a1 + b1\n+    assert(p0->req() == 5, \"MulAddS2I should have 4 operands\");\n+    vtn = new (_graph.arena()) VTransformElementWiseVectorNode(_graph, 3, pack_size);\n+  } else {\n+    assert(p0->req() == 3 ||\n+           p0->is_CMove() ||\n+           VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(opc) ||\n+           VectorNode::is_convert_opcode(opc) ||\n+           VectorNode::is_scalar_unary_op_with_equal_input_and_output_types(opc) ||\n+           opc == Op_FmaD ||\n+           opc == Op_FmaF ||\n+           opc == Op_SignumF ||\n+           opc == Op_SignumD,\n+           \"pack type must be in this list\");\n+    vtn = new (_graph.arena()) VTransformElementWiseVectorNode(_graph, p0->req(), pack_size);\n+  }\n+  vtn->set_nodes(pack);\n+  return vtn;\n+}\n+\n+void SuperWordVTransformBuilder::set_req_with_scalar(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index) {\n+  VTransformNode* req = get_vtnode_or_wrap_as_input_scalar(n->in(index));\n+  vtn->set_req(index, req);\n+  vtn_dependencies.set(req->_idx);\n+}\n+\n+\/\/ Either get existing vtnode vector input (when input is a pack), or else make a\n+\/\/ new one vector vtnode for the input (e.g. for Replicate or PopulateIndex).\n+VTransformNode* SuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index(const Node_List* pack, const int index) {\n+  Node* p0 = pack->at(0);\n+\n+  Node_List* pack_in = _packset.pack_input_at_index_or_null(pack, index);\n+  if (pack_in != nullptr) {\n+    \/\/ Input is a matching pack -> vtnode already exists.\n+    assert(index != 2 || !VectorNode::is_shift(p0), \"shift's count cannot be vector\");\n+    return get_vtnode(pack_in->at(0));\n+  }\n+\n+  if (VectorNode::is_muladds2i(p0)) {\n+    assert(_packset.is_muladds2i_pack_with_pack_inputs(pack), \"inputs must all be packs\");\n+    \/\/ All inputs are strided (stride = 2), either with offset 0 or 1.\n+    Node_List* pack_in0 = _packset.strided_pack_input_at_index_or_null(pack, index, 2, 0);\n+    if (pack_in0 != nullptr) {\n+      return get_vtnode(pack_in0->at(0));\n+    }\n+    Node_List* pack_in1 = _packset.strided_pack_input_at_index_or_null(pack, index, 2, 1);\n+    if (pack_in1 != nullptr) {\n+      return get_vtnode(pack_in1->at(0));\n+    }\n+  }\n+\n+  Node* same_input = _packset.same_inputs_at_index_or_null(pack, index);\n+  if (same_input == nullptr && p0->in(index) == _vloop.iv()) {\n+    \/\/ PopulateIndex: [iv+0, iv+1, iv+2, ...]\n+    VTransformNode* iv_vtn = get_vtnode_or_wrap_as_input_scalar(_vloop.iv());\n+    BasicType p0_bt = _vloop_analyzer.types().velt_basic_type(p0);\n+    \/\/ If we have subword type, take that type directly. If p0 is some ConvI2L\/F\/D,\n+    \/\/ then the p0_bt can also be L\/F\/D but we need to produce ints for the input of\n+    \/\/ the ConvI2L\/F\/D.\n+    BasicType element_bt = is_subword_type(p0_bt) ? p0_bt : T_INT;\n+    VTransformNode* populate_index = new (_graph.arena()) VTransformPopulateIndexNode(_graph, pack->size(), element_bt);\n+    populate_index->set_req(1, iv_vtn);\n+    return populate_index;\n+  }\n+\n+  if (same_input != nullptr) {\n+    VTransformNode* same_input_vtn = get_vtnode_or_wrap_as_input_scalar(same_input);\n+    if (index == 2 && VectorNode::is_shift(p0)) {\n+      \/\/ Scalar shift count for vector shift operation: vec2 = shiftV(vec1, scalar_count)\n+      \/\/ Scalar shift operations masks the shift count, but the vector shift does not, so\n+      \/\/ create a special ShiftCount node.\n+      BasicType element_bt = _vloop_analyzer.types().velt_basic_type(p0);\n+      juint mask = (p0->bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);\n+      VTransformNode* shift_count = new (_graph.arena()) VTransformShiftCountNode(_graph, pack->size(), element_bt, mask, p0->Opcode());\n+      shift_count->set_req(1, same_input_vtn);\n+      return shift_count;\n+    } else {\n+      \/\/ Replicate the scalar same_input to every vector element.\n+      const Type* element_type = _vloop_analyzer.types().velt_type(p0);\n+      if (index == 2 && VectorNode::is_scalar_rotate(p0) && element_type->isa_long()) {\n+        \/\/ Scalar rotate has int rotation value, but the scalar rotate expects longs.\n+        assert(same_input->bottom_type()->isa_int(), \"scalar rotate expects int rotation\");\n+        VTransformNode* conv = new (_graph.arena()) VTransformConvI2LNode(_graph);\n+        conv->set_req(1, same_input_vtn);\n+        same_input_vtn = conv;\n+      }\n+      VTransformNode* replicate = new (_graph.arena()) VTransformReplicateNode(_graph, pack->size(), element_type);\n+      replicate->set_req(1, same_input_vtn);\n+      return replicate;\n+    }\n+  }\n+\n+  \/\/ The input is neither a pack not a same_input node. SuperWord::profitable does not allow\n+  \/\/ any other case. In the future, we could insert a PackNode.\n+#ifdef ASSERT\n+  tty->print_cr(\"\\nSuperWordVTransformBuilder::get_or_make_vtnode_vector_input_at_index: index=%d\", index);\n+  pack->dump();\n+  assert(false, \"Pack input was neither a pack nor a same_input node\");\n+#endif\n+  ShouldNotReachHere();\n+}\n+\n+VTransformNode* SuperWordVTransformBuilder::get_vtnode_or_wrap_as_input_scalar(Node* n) {\n+  VTransformNode* vtn = get_vtnode_or_null(n);\n+  if (vtn != nullptr) { return vtn; }\n+\n+  assert(!_vloop.in_bb(n), \"only nodes outside the loop can be input nodes to the loop\");\n+  vtn = new (_graph.arena()) VTransformInputScalarNode(_graph, n);\n+  map_node_to_vtnode(n, vtn);\n+  return vtn;\n+}\n+\n+void SuperWordVTransformBuilder::set_req_with_vector(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies, int j) {\n+  VTransformNode* req = get_or_make_vtnode_vector_input_at_index(pack, j);\n+  vtn->set_req(j, req);\n+  vtn_dependencies.set(req->_idx);\n+}\n+\n+void SuperWordVTransformBuilder::set_all_req_with_scalars(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n+  assert(vtn->req() == n->req(), \"scalars must have same number of reqs\");\n+  for (uint j = 0; j < n->req(); j++) {\n+    Node* def = n->in(j);\n+    if (def == nullptr) { continue; }\n+    set_req_with_scalar(n, vtn, vtn_dependencies, j);\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n+  Node* p0 = pack->at(0);\n+  assert(vtn->req() <= p0->req(), \"must have at at most as many reqs\");\n+  \/\/ Vectors have no ctrl, so ignore it.\n+  for (uint j = 1; j < vtn->req(); j++) {\n+    Node* def = p0->in(j);\n+    if (def == nullptr) { continue; }\n+    set_req_with_vector(pack, vtn, vtn_dependencies, j);\n+  }\n+}\n+\n+void SuperWordVTransformBuilder::add_dependencies_of_node_to_vtnode(Node*n, VTransformNode* vtn, VectorSet& vtn_dependencies) {\n+  for (VLoopDependencyGraph::PredsIterator preds(_vloop_analyzer.dependency_graph(), n); !preds.done(); preds.next()) {\n+    Node* pred = preds.current();\n+    if (!_vloop.in_bb(pred)) { continue; }\n+\n+    \/\/ Only add memory dependencies to memory nodes. All others are taken care of with the req.\n+    if (n->is_Mem() && !pred->is_Mem()) { continue; }\n+\n+    VTransformNode* dependency = get_vtnode(pred);\n+\n+    \/\/ Reduction self-cycle?\n+    if (vtn == dependency && _vloop_analyzer.reductions().is_marked_reduction(n)) { continue; }\n+\n+    if (vtn_dependencies.test_set(dependency->_idx)) { continue; }\n+    vtn->add_dependency(dependency); \/\/ Add every dependency only once per vtn.\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.cpp","additions":282,"deletions":0,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"opto\/superword.hpp\"\n@@ -29,0 +30,56 @@\n+\/\/ Facility class that builds a VTransformGraph from a SuperWord PackSet.\n+class SuperWordVTransformBuilder : public StackObj {\n+private:\n+  const VLoopAnalyzer& _vloop_analyzer;\n+  const VLoop& _vloop;\n+  const PackSet& _packset;\n+  VTransformGraph& _graph;\n+\n+  ResourceHashtable<\/* Node::_idx*\/ int, VTransformNode* \/* or null*\/> _idx_to_vtnode;\n+\n+public:\n+  SuperWordVTransformBuilder(const PackSet& packset,\n+                             VTransformGraph& graph) :\n+      _vloop_analyzer(graph.vloop_analyzer()),\n+      _vloop(_vloop_analyzer.vloop()),\n+      _packset(packset),\n+      _graph(graph)\n+  {\n+    assert(_graph.is_empty(), \"constructor is passed an empty graph\");\n+    build();\n+    assert(!_graph.is_empty(), \"graph must contain some vtnodes now\");\n+  }\n+\n+private:\n+  void build();\n+  void build_vector_vtnodes_for_packed_nodes();\n+  void build_scalar_vtnodes_for_non_packed_nodes();\n+  void build_inputs_for_vector_vtnodes(VectorSet& vtn_dependencies);\n+  void build_inputs_for_scalar_vtnodes(VectorSet& vtn_dependencies);\n+\n+  \/\/ Helper methods for building VTransformGraph.\n+  VTransformNode* get_vtnode_or_null(Node* n) const {\n+    VTransformNode** ptr = _idx_to_vtnode.get(n->_idx);\n+    return (ptr == nullptr) ? nullptr : *ptr;\n+  }\n+\n+  VTransformNode* get_vtnode(Node* n) const {\n+    VTransformNode* vtn = get_vtnode_or_null(n);\n+    assert(vtn != nullptr, \"expect non-null vtnode\");\n+    return vtn;\n+  }\n+\n+  void map_node_to_vtnode(Node* n, VTransformNode* vtn) {\n+    assert(vtn != nullptr, \"only set non-null vtnodes\");\n+    _idx_to_vtnode.put_when_absent(n->_idx, vtn);\n+  }\n+\n+  VTransformVectorNode* make_vector_vtnode_for_pack(const Node_List* pack) const;\n+  VTransformNode* get_or_make_vtnode_vector_input_at_index(const Node_List* pack, const int index);\n+  VTransformNode* get_vtnode_or_wrap_as_input_scalar(Node* n);\n+  void set_req_with_scalar(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index);\n+  void set_req_with_vector(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies, const int index);\n+  void set_all_req_with_scalars(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies);\n+  void set_all_req_with_vectors(const Node_List* pack, VTransformNode* vtn, VectorSet& vtn_dependencies);\n+  void add_dependencies_of_node_to_vtnode(Node* n, VTransformNode* vtn, VectorSet& vtn_dependencies);\n+};\n","filename":"src\/hotspot\/share\/opto\/superwordVTransformBuilder.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"}]}