{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.file.StandardCopyOption;\n@@ -151,1 +152,2 @@\n-        FileUtils.copyRecursive(srcDir, dstDir.toAbsolutePath(), excludes, LinkOption.NOFOLLOW_LINKS);\n+        FileUtils.copyRecursive(srcDir, dstDir.toAbsolutePath(), excludes,\n+                LinkOption.NOFOLLOW_LINKS, StandardCopyOption.REPLACE_EXISTING);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationImageUtils.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,348 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.jpackage.internal.util.function.ExceptionBox.rethrowUnchecked;\n+import static jdk.jpackage.internal.util.function.ThrowingBiFunction.toBiFunction;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.DigestInputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Collection;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.function.ThrowingBiFunction;\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.AppImageFile;\n+import jdk.jpackage.test.ApplicationLayout;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary test order in which jpackage fills app image\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror AppImageFillOrderTest.java\n+ * @run main\/othervm\/timeout=1440 -Xmx512m\n+ *  jdk.jpackage.test.Main\n+ *  --jpt-run=AppImageFillOrderTest\n+ *\/\n+\n+\/**\n+ * Test order in which overlapping items are added to the app image. jpackage\n+ * defaults should go first to let user-provided content override them.\n+ *\n+ * <p>\n+ * Custom content comes from:\n+ * <ul>\n+ * <li>input directory (--input)\n+ * <li>app content (--app-content)\n+ * <ul>\n+ *\/\n+public class AppImageFillOrderTest {\n+\n+    @Test\n+    @ParameterSupplier\n+    public void test(AppImageOverlay overlays[]) {\n+        test(createJPackage().setFakeRuntime(), overlays);\n+    }\n+\n+    \/**\n+     * Test they can override a file in the runtime.\n+     * @param jlink\n+     *\/\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testRuntime(boolean jlink) {\n+        var cmd = createJPackage();\n+        if (jlink) {\n+            cmd.ignoreDefaultRuntime(true);\n+        } else {\n+            \/\/ Configure fake runtime and create it.\n+            cmd.setFakeRuntime().executePrerequisiteActions();\n+\n+            var runtimeDir = Path.of(cmd.getArgumentValue(\"--runtime-image\"));\n+            if (!runtimeDir.toAbsolutePath().normalize().startsWith(TKit.workDir().toAbsolutePath().normalize())) {\n+                throw new IllegalStateException(String.format(\n+                        \"Fake runtime [%s] created outside of the test work directory [%s]\",\n+                        runtimeDir, TKit.workDir()));\n+            }\n+\n+            TKit.createTextFile(runtimeDir.resolve(RUNTIME_RELEASE_FILE), List.of(\"Foo release\"));\n+        }\n+\n+        test(cmd, AppImageAppContentOverlay.APP_CONTENT_RUNTIME_RELEASE_FILE);\n+    }\n+\n+    \/**\n+     * Test they can not override .jpackage.xml file.\n+     * @throws IOException\n+     *\/\n+    @Test\n+    public void testAppImageFile() throws IOException {\n+\n+        var appContentRoot = TKit.createTempDirectory(\"app-content\");\n+\n+        var file = AppImageFile.getPathInAppImage(appContentRoot);\n+\n+        Files.createDirectories(file.getParent());\n+        TKit.createTextFile(file, List.of(\"This is not a valid XML content\"));\n+\n+        var cmd = createJPackage().setFakeRuntime();\n+        addAppContentPath(cmd, appContentRoot, ApplicationLayout::appDirectory);\n+\n+        \/\/ Run jpackage and verify it created valid .jpackage.xml file ignoring the overlay.\n+        cmd.executeAndAssertImageCreated();\n+\n+        TKit.trace(String.format(\"Parse [%s] file...\", AppImageFile.getPathInAppImage(cmd.outputBundle())));\n+        AppImageFile.load(cmd.outputBundle());\n+    }\n+\n+    private static void test(JPackageCommand cmd, AppImageOverlay... overlays) {\n+        if (overlays.length == 0) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        final var outputDir = Path.of(cmd.getArgumentValue(\"--dest\"));\n+        final var noOverlaysOutputDir = Path.of(outputDir.toString() + \"-no-overlay\");\n+        cmd.setArgumentValue(\"--dest\", noOverlaysOutputDir);\n+\n+        \/\/ Run the command without overlays with redirected output directory.\n+        cmd.execute();\n+\n+        final Optional<Path> appContentRoot;\n+        if (Stream.of(overlays).anyMatch(AppImageAppContentOverlay.class::isInstance)) {\n+            appContentRoot = Optional.of(TKit.createTempDirectory(\"app-content\"));\n+        } else {\n+            appContentRoot = Optional.empty();\n+        }\n+\n+        \/\/ Apply overlays to the command.\n+        var fileCopies = Stream.of(overlays).map(overlay -> {\n+            switch (overlay) {\n+                case AppImageDefaultOverlay v -> {\n+                    return v.addOverlay(cmd);\n+                }\n+                case AppImageAppContentOverlay v -> {\n+                    return v.addOverlay(cmd, appContentRoot.orElseThrow());\n+                }\n+            }\n+        }).flatMap(Collection::stream).collect(toMap(FileCopy::out, x -> x, (a, b) -> {\n+            return b;\n+        }, TreeMap::new)).values().stream().toList();\n+\n+        \/\/ Collect paths in the app image that will be affected by overlays.\n+        var noOverlayOutputPaths = fileCopies.stream().map(FileCopy::out).toList();\n+\n+        fileCopies = fileCopies.stream().map(v -> {\n+            return new FileCopy(v.in(), outputDir.resolve(noOverlaysOutputDir.relativize(v.out())));\n+        }).toList();\n+\n+        \/\/ Restore the original output directory for the command and execute it.\n+        cmd.setArgumentValue(\"--dest\", outputDir).execute();\n+\n+        for (var i = 0; i != fileCopies.size(); i++) {\n+            var noOverlayPath = noOverlayOutputPaths.get(i);\n+            var fc = fileCopies.get(i);\n+\n+            var overlayDigest = digest(fc.out());\n+            var noOverlayDigest = digest(noOverlayPath);\n+            var inputDigest = digest(fc.in());\n+\n+            TKit.trace(String.format(\"Check [%s] file:\", fc.out()));\n+            TKit.assertEquals(inputDigest, overlayDigest, String.format(\"Check contents equals to [%s] file\", fc.in()));\n+            TKit.assertNotEquals(noOverlayDigest, overlayDigest, String.format(\"Check contents differ from [%s] file\", noOverlayPath));\n+        }\n+    }\n+\n+    public static Collection<Object[]> test() {\n+        return Stream.of(\n+\n+                \/\/ Overwrite main launcher .cfg file from the input dir.\n+                List.of(AppImageDefaultOverlay.INPUT_MAIN_LAUNCHER_CFG),\n+\n+                \/\/ Overwrite main launcher .cfg file from the app content dir.\n+                List.of(AppImageAppContentOverlay.APP_CONTENT_MAIN_LAUNCHER_CFG),\n+\n+                \/\/ Overwrite main launcher .cfg file from the input dir and from the app content dir.\n+                \/\/ The one from app content should win.\n+                List.<AppImageOverlay>of(\n+                        AppImageDefaultOverlay.INPUT_MAIN_LAUNCHER_CFG,\n+                        AppImageAppContentOverlay.APP_CONTENT_MAIN_LAUNCHER_CFG\n+                ),\n+\n+                \/\/ Overwrite main jar from the app content dir.\n+                List.of(AppImageAppContentOverlay.APP_CONTENT_MAIN_JAR)\n+        ).map(args -> {\n+            return args.toArray(AppImageOverlay[]::new);\n+        }).map(args -> {\n+            return new Object[] {args};\n+        }).toList();\n+    }\n+\n+\n+    public sealed interface AppImageOverlay {\n+    }\n+\n+\n+    private enum AppImageDefaultOverlay implements AppImageOverlay {\n+        INPUT_MAIN_LAUNCHER_CFG(AppImageFillOrderTest::replaceMainLauncherCfgFile),\n+        ;\n+\n+        AppImageDefaultOverlay(ThrowingFunction<JPackageCommand, Collection<FileCopy>> func) {\n+            this.func = toFunction(func);\n+        }\n+\n+        Collection<FileCopy> addOverlay(JPackageCommand cmd) {\n+            return func.apply(cmd);\n+        }\n+\n+        private final Function<JPackageCommand, Collection<FileCopy>> func;\n+    }\n+\n+\n+    private enum AppImageAppContentOverlay implements AppImageOverlay {\n+        APP_CONTENT_MAIN_LAUNCHER_CFG(AppImageFillOrderTest::replaceMainLauncherCfgFile),\n+        APP_CONTENT_MAIN_JAR(AppImageFillOrderTest::replaceMainJar),\n+        APP_CONTENT_RUNTIME_RELEASE_FILE((cmd, appContentRoot) -> {\n+            return addRuntimeFile(cmd, appContentRoot, RUNTIME_RELEASE_FILE);\n+        }),\n+        ;\n+\n+        AppImageAppContentOverlay(ThrowingBiFunction<JPackageCommand, Path, Collection<FileCopy>> func) {\n+            this.func = toBiFunction(func);\n+        }\n+\n+        Collection<FileCopy> addOverlay(JPackageCommand cmd, Path appContentRoot) {\n+            return func.apply(cmd, appContentRoot);\n+        }\n+\n+        private final BiFunction<JPackageCommand, Path, Collection<FileCopy>> func;\n+    }\n+\n+\n+    private record FileCopy(Path in, Path out) {\n+        FileCopy {\n+            Objects.requireNonNull(in);\n+            Objects.requireNonNull(out);\n+        }\n+    }\n+\n+\n+    private static Collection<FileCopy> replaceMainLauncherCfgFile(JPackageCommand cmd) {\n+        var inputDir = Path.of(cmd.getArgumentValue(\"--input\"));\n+\n+        \/\/ Replace the standard main launcher .cfg file with the custom one from the input dir.\n+        final var inputMainLauncherCfg = inputDir.resolve(cmd.appLauncherCfgPath(null).getFileName());\n+\n+        TKit.createTextFile(inputMainLauncherCfg, List.of(\"Hello!\"));\n+\n+        return List.of(new FileCopy(inputMainLauncherCfg, cmd.appLauncherCfgPath(null)));\n+    }\n+\n+    private static Collection<FileCopy> replaceMainLauncherCfgFile(JPackageCommand cmd, Path appContentRoot) throws IOException {\n+        var appDirOverlay = APP_IMAGE_LAYOUT.resolveAt(appContentRoot).appDirectory();\n+\n+        \/\/ Replace the standard main launcher .cfg file with the custom one from the app content.\n+        final var inputMainLauncherCfg = appDirOverlay.resolve(cmd.appLauncherCfgPath(null).getFileName());\n+\n+        Files.createDirectories(inputMainLauncherCfg.getParent());\n+        TKit.createTextFile(inputMainLauncherCfg, List.of(\"!Olleh\"));\n+\n+        addAppContentPath(cmd, appContentRoot, ApplicationLayout::appDirectory);\n+\n+        return List.of(new FileCopy(inputMainLauncherCfg, cmd.appLauncherCfgPath(null)));\n+    }\n+\n+    private static Collection<FileCopy> replaceMainJar(JPackageCommand cmd, Path appContentRoot) throws IOException {\n+        var appDirOverlay = APP_IMAGE_LAYOUT.resolveAt(appContentRoot).appDirectory();\n+\n+        \/\/ Replace the jar file that jpackage will pick up from the input directory with the custom one.\n+        var mainJar = appDirOverlay.resolve(cmd.getArgumentValue(\"--main-jar\"));\n+\n+        Files.createDirectories(mainJar.getParent());\n+        TKit.createTextFile(mainJar, List.of(\"Surprise!\"));\n+\n+        addAppContentPath(cmd, appContentRoot, ApplicationLayout::appDirectory);\n+\n+        return List.of(new FileCopy(mainJar, cmd.appLayout().appDirectory().resolve(mainJar.getFileName())));\n+    }\n+\n+    private static Collection<FileCopy> addRuntimeFile(JPackageCommand cmd, Path appContentRoot, Path pathInRuntime) throws IOException {\n+        var runtimeOverlay = APP_IMAGE_LAYOUT.resolveAt(appContentRoot).runtimeHomeDirectory();\n+\n+        \/\/ Add a file to the runtime.\n+        var file = runtimeOverlay.resolve(pathInRuntime);\n+\n+        Files.createDirectories(file.getParent());\n+        TKit.createTextFile(file, List.of(\"blob\"));\n+\n+        addAppContentPath(cmd, appContentRoot, ApplicationLayout::runtimeDirectory);\n+\n+        return List.of(new FileCopy(file, cmd.appLayout().runtimeHomeDirectory().resolve(file.getFileName())));\n+    }\n+\n+    private static void addAppContentPath(JPackageCommand cmd, Path appContentRoot, Function<ApplicationLayout, Path> appImageComponentGetter) {\n+        var pathInAppImage = appImageComponentGetter.apply(APP_IMAGE_LAYOUT);\n+        if (TKit.isOSX()) {\n+            pathInAppImage = ApplicationLayout.macAppImage().contentDirectory().relativize(pathInAppImage);\n+        }\n+\n+        cmd.addArguments(\"--app-content\", appContentRoot.resolve(pathInAppImage.getName(0)));\n+    }\n+\n+    private static String digest(Path file) {\n+        try {\n+            var md = MessageDigest.getInstance(\"md5\");\n+            try (var is = Files.newInputStream(file); var dis = new DigestInputStream(is, md)) {\n+                dis.readAllBytes();\n+            }\n+            return HexFormat.of().formatHex(md.digest());\n+        } catch (NoSuchAlgorithmException|IOException ex) {\n+            throw rethrowUnchecked(ex);\n+        }\n+    }\n+\n+    private static JPackageCommand createJPackage() {\n+        \/\/ With short name.\n+        return JPackageCommand.helloAppImage().setArgumentValue(\"--name\", \"Foo\");\n+    }\n+\n+    private static final ApplicationLayout APP_IMAGE_LAYOUT = ApplicationLayout.platformAppImage();\n+    private static final Path RUNTIME_RELEASE_FILE = Path.of(\"release\");\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImageFillOrderTest.java","additions":348,"deletions":0,"binary":false,"changes":348,"status":"added"}]}