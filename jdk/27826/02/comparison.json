{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.file.StandardCopyOption;\n@@ -151,1 +152,2 @@\n-        FileUtils.copyRecursive(srcDir, dstDir.toAbsolutePath(), excludes, LinkOption.NOFOLLOW_LINKS);\n+        FileUtils.copyRecursive(srcDir, dstDir.toAbsolutePath(), excludes,\n+                LinkOption.NOFOLLOW_LINKS, StandardCopyOption.REPLACE_EXISTING);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationImageUtils.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.nio.file.Files;\n@@ -80,1 +79,1 @@\n-                TKit.assertTrue(-1 == Files.mismatch(expectedIcon, iconPath),\n+                TKit.assertSameFileContent(expectedIcon, iconPath,\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherIconVerifier.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingBiFunction.toBiFunction;\n@@ -800,0 +801,29 @@\n+    public static void assertMismatchFileContent(Path a, Path b) {\n+        assertFilesMismatch(a, b, true, Optional.empty());\n+    }\n+\n+    public static void assertMismatchFileContent(Path a, Path b, String msg) {\n+        assertFilesMismatch(a, b, true, Optional.of(msg));\n+    }\n+\n+    public static void assertSameFileContent(Path a, Path b) {\n+        assertFilesMismatch(a, b, false, Optional.empty());\n+    }\n+\n+    public static void assertSameFileContent(Path a, Path b, String msg) {\n+        assertFilesMismatch(a, b, false, Optional.of(msg));\n+    }\n+\n+    public static void assertFilesMismatch(Path a, Path b, boolean expectMismatch, Optional<String> msg) {\n+        var mismatch = toBiFunction(Files::mismatch).apply(a, b) != -1;\n+        if (expectMismatch) {\n+            assertTrue(mismatch, msg.orElseGet(() -> {\n+                return String.format(\"Check the content of [%s] and [%s] files mismatch\", a, b);\n+            }));\n+        } else {\n+            assertTrue(!mismatch, msg.orElseGet(() -> {\n+                return String.format(\"Check the content of [%s] and [%s] files is the same\", a, b);\n+            }));\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,359 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Annotations.ParameterSupplier;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.AppImageFile;\n+import jdk.jpackage.test.ApplicationLayout;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.TKit;\n+\n+\/*\n+ * @test\n+ * @summary test order in which jpackage fills app image\n+ * @library \/test\/jdk\/tools\/jpackage\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @compile -Xlint:all -Werror AppImageFillOrderTest.java\n+ * @run main\/othervm\/timeout=1440 -Xmx512m\n+ *  jdk.jpackage.test.Main\n+ *  --jpt-run=AppImageFillOrderTest\n+ *\/\n+\n+\/**\n+ * Test order in which overlapping items are added to the app image. jpackage\n+ * defaults should go first to let user-provided content override them.\n+ *\n+ * <p>\n+ * Custom content comes from:\n+ * <ul>\n+ * <li>input directory (--input)\n+ * <li>app content (--app-content)\n+ * <ul>\n+ *\/\n+public class AppImageFillOrderTest {\n+\n+    @Test\n+    @ParameterSupplier\n+    public void test(AppImageOverlay overlays[]) {\n+        test(createJPackage().setFakeRuntime(), overlays);\n+    }\n+\n+    \/**\n+     * Test they can override a file in the runtime.\n+     * @param jlink\n+     *\/\n+    @Test\n+    @Parameter(\"true\")\n+    @Parameter(\"false\")\n+    public void testRuntime(boolean jlink) {\n+        var cmd = createJPackage();\n+        if (jlink) {\n+            cmd.ignoreDefaultRuntime(true);\n+        } else {\n+            \/\/ Configure fake runtime and create it.\n+            cmd.setFakeRuntime().executePrerequisiteActions();\n+\n+            var runtimeDir = Path.of(cmd.getArgumentValue(\"--runtime-image\"));\n+            if (!runtimeDir.toAbsolutePath().normalize().startsWith(TKit.workDir().toAbsolutePath().normalize())) {\n+                throw new IllegalStateException(String.format(\n+                        \"Fake runtime [%s] created outside of the test work directory [%s]\",\n+                        runtimeDir, TKit.workDir()));\n+            }\n+\n+            TKit.createTextFile(runtimeDir.resolve(RUNTIME_RELEASE_FILE), List.of(\"Foo release\"));\n+        }\n+\n+        test(cmd, AppImageAppContentOverlay.APP_CONTENT_RUNTIME_RELEASE_FILE);\n+    }\n+\n+    \/**\n+     * Test they can not override .jpackage.xml file.\n+     * @throws IOException\n+     *\/\n+    @Test\n+    public void testAppImageFile() throws IOException {\n+\n+        var cmd = createJPackage().setFakeRuntime();\n+\n+        var outputBundle = cmd.outputBundle();\n+\n+        buildOverlay(cmd, TKit.createTempDirectory(\"app-content\"), AppImageFile.getPathInAppImage(outputBundle))\n+                .textContent(\"This is not a valid XML content\")\n+                .configureCmdOptions().createOverlayFile();\n+\n+        \/\/ Run jpackage and verify it created valid .jpackage.xml file ignoring the overlay.\n+        cmd.executeAndAssertImageCreated();\n+\n+        TKit.trace(String.format(\"Parse [%s] file...\", AppImageFile.getPathInAppImage(outputBundle)));\n+        AppImageFile.load(outputBundle);\n+    }\n+\n+    private static void test(JPackageCommand cmd, AppImageOverlay... overlays) {\n+        if (overlays.length == 0) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        final var outputDir = Path.of(cmd.getArgumentValue(\"--dest\"));\n+        final var noOverlaysOutputDir = Path.of(outputDir.toString() + \"-no-overlay\");\n+        cmd.setArgumentValue(\"--dest\", noOverlaysOutputDir);\n+\n+        \/\/ Run the command without overlays with redirected output directory.\n+        cmd.execute();\n+\n+        final Optional<Path> appContentRoot;\n+        if (Stream.of(overlays).anyMatch(AppImageAppContentOverlay.class::isInstance)) {\n+            appContentRoot = Optional.of(TKit.createTempDirectory(\"app-content\"));\n+        } else {\n+            appContentRoot = Optional.empty();\n+        }\n+\n+        \/\/ Apply overlays to the command.\n+        var fileCopies = Stream.of(overlays).map(overlay -> {\n+            switch (overlay) {\n+                case AppImageDefaultOverlay v -> {\n+                    return v.addOverlay(cmd);\n+                }\n+                case AppImageAppContentOverlay v -> {\n+                    return v.addOverlay(cmd, appContentRoot.orElseThrow());\n+                }\n+            }\n+        }).flatMap(Collection::stream).collect(toMap(FileCopy::out, x -> x, (a, b) -> {\n+            return b;\n+        }, TreeMap::new)).values().stream().toList();\n+\n+        \/\/ Collect paths in the app image that will be affected by overlays.\n+        var noOverlayOutputPaths = fileCopies.stream().map(FileCopy::out).toList();\n+\n+        fileCopies = fileCopies.stream().map(v -> {\n+            return new FileCopy(v.in(), outputDir.resolve(noOverlaysOutputDir.relativize(v.out())));\n+        }).toList();\n+\n+        \/\/ Restore the original output directory for the command and execute it.\n+        cmd.setArgumentValue(\"--dest\", outputDir).execute();\n+\n+        for (var i = 0; i != fileCopies.size(); i++) {\n+            var noOverlayPath = noOverlayOutputPaths.get(i);\n+            var fc = fileCopies.get(i);\n+            TKit.assertSameFileContent(fc.in(), fc.out());\n+            TKit.assertMismatchFileContent(noOverlayPath, fc.out());\n+        }\n+    }\n+\n+    public static Collection<Object[]> test() {\n+        return Stream.of(\n+\n+                \/\/ Overwrite main launcher .cfg file from the input dir.\n+                List.of(AppImageDefaultOverlay.INPUT_MAIN_LAUNCHER_CFG),\n+\n+                \/\/ Overwrite main launcher .cfg file from the app content dir.\n+                List.of(AppImageAppContentOverlay.APP_CONTENT_MAIN_LAUNCHER_CFG),\n+\n+                \/\/ Overwrite main launcher .cfg file from the input dir and from the app content dir.\n+                \/\/ The one from app content should win.\n+                List.<AppImageOverlay>of(\n+                        AppImageDefaultOverlay.INPUT_MAIN_LAUNCHER_CFG,\n+                        AppImageAppContentOverlay.APP_CONTENT_MAIN_LAUNCHER_CFG\n+                ),\n+\n+                \/\/ Overwrite main jar from the app content dir.\n+                List.of(AppImageAppContentOverlay.APP_CONTENT_MAIN_JAR)\n+        ).map(args -> {\n+            return args.toArray(AppImageOverlay[]::new);\n+        }).map(args -> {\n+            return new Object[] {args};\n+        }).toList();\n+    }\n+\n+\n+    public sealed interface AppImageOverlay {\n+    }\n+\n+\n+    private enum AppImageDefaultOverlay implements AppImageOverlay {\n+        INPUT_MAIN_LAUNCHER_CFG(AppImageFillOrderTest::replaceMainLauncherCfgFile),\n+        ;\n+\n+        AppImageDefaultOverlay(Function<JPackageCommand, FileCopy> func) {\n+            Objects.requireNonNull(func);\n+            this.func = cmd -> {\n+                return List.of(func.apply(cmd));\n+            };\n+        }\n+\n+        Collection<FileCopy> addOverlay(JPackageCommand cmd) {\n+            return func.apply(cmd);\n+        }\n+\n+        private final Function<JPackageCommand, Collection<FileCopy>> func;\n+    }\n+\n+\n+    private enum AppImageAppContentOverlay implements AppImageOverlay {\n+        \/\/ Replace the standard main launcher .cfg file with the custom one from the app content.\n+        APP_CONTENT_MAIN_LAUNCHER_CFG((cmd, appContentRoot) -> {\n+            return buildOverlay(cmd, appContentRoot, cmd.appLauncherCfgPath(null))\n+                    .textContent(\"!Olleh\")\n+                    .configureCmdOptions().createOverlayFile();\n+        }),\n+\n+        \/\/ Replace the jar file that jpackage will pick up from the input directory with the custom one.\n+        APP_CONTENT_MAIN_JAR((cmd, appContentRoot) -> {\n+            return buildOverlay(cmd, appContentRoot, cmd.appLayout().appDirectory().resolve(cmd.getArgumentValue(\"--main-jar\")))\n+                    .textContent(\"Surprise!\")\n+                    .configureCmdOptions().createOverlayFile();\n+        }),\n+\n+        \/\/ Replace \"release\" file in the runtime directory.\n+        APP_CONTENT_RUNTIME_RELEASE_FILE((cmd, appContentRoot) -> {\n+            return buildOverlay(cmd, appContentRoot, cmd.appLayout().runtimeHomeDirectory().resolve(\"release\"))\n+                    .textContent(\"blob\")\n+                    .configureCmdOptions().createOverlayFile();\n+        }),\n+        ;\n+\n+        AppImageAppContentOverlay(BiFunction<JPackageCommand, Path, FileCopy> func) {\n+            Objects.requireNonNull(func);\n+            this.func = (cmd, appContentRoot) -> {\n+                return List.of(func.apply(cmd, appContentRoot));\n+            };\n+        }\n+\n+        Collection<FileCopy> addOverlay(JPackageCommand cmd, Path appContentRoot) {\n+            return func.apply(cmd, appContentRoot);\n+        }\n+\n+        private final BiFunction<JPackageCommand, Path, Collection<FileCopy>> func;\n+    }\n+\n+\n+    private record FileCopy(Path in, Path out) {\n+        FileCopy {\n+            Objects.requireNonNull(in);\n+            Objects.requireNonNull(out);\n+        }\n+    }\n+\n+\n+    private static FileCopy replaceMainLauncherCfgFile(JPackageCommand cmd) {\n+        \/\/ Replace the standard main launcher .cfg file with the custom one from the input dir.\n+        final var outputFile = cmd.appLauncherCfgPath(null);\n+\n+        final var inputDir = Path.of(cmd.getArgumentValue(\"--input\"));\n+\n+        final var file = inputDir.resolve(outputFile.getFileName());\n+\n+        TKit.createTextFile(file, List.of(\"Hello!\"));\n+\n+        return new FileCopy(file, outputFile);\n+    }\n+\n+    private static AppContentOverlayFileBuilder buildOverlay(JPackageCommand cmd, Path appContentRoot, Path outputFile) {\n+        return new AppContentOverlayFileBuilder(cmd, appContentRoot, outputFile);\n+    }\n+\n+\n+    private static final class AppContentOverlayFileBuilder {\n+\n+        AppContentOverlayFileBuilder(JPackageCommand cmd, Path appContentRoot, Path outputFile) {\n+            if (outputFile.isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (!outputFile.startsWith(cmd.outputBundle())) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            this.cmd = Objects.requireNonNull(cmd);\n+            this.outputFile = Objects.requireNonNull(outputFile);\n+            this.appContentRoot = Objects.requireNonNull(appContentRoot);\n+        }\n+\n+        FileCopy createOverlayFile() {\n+            final var file = appContentRoot.resolve(pathInAppContentDirectory());\n+\n+            try {\n+                Files.createDirectories(file.getParent());\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+            fileContentInitializer.accept(file);\n+\n+            return new FileCopy(file, outputFile);\n+        }\n+\n+        AppContentOverlayFileBuilder configureCmdOptions() {\n+            cmd.addArguments(\"--app-content\", appContentRoot.resolve(pathInAppContentDirectory().getName(0)));\n+            return this;\n+        }\n+\n+        AppContentOverlayFileBuilder content(Consumer<Path> v) {\n+            fileContentInitializer = v;\n+            return this;\n+        }\n+\n+        AppContentOverlayFileBuilder textContent(String... lines) {\n+            return content(path -> {\n+                TKit.createTextFile(path, List.of(lines));\n+            });\n+        }\n+\n+        private Path pathInAppContentDirectory() {\n+            return APP_IMAGE_LAYOUT.resolveAt(cmd.outputBundle()).contentDirectory().relativize(outputFile);\n+        }\n+\n+        private Consumer<Path> fileContentInitializer;\n+        private final JPackageCommand cmd;\n+        private final Path outputFile;\n+        private final Path appContentRoot;\n+    }\n+\n+\n+    private static JPackageCommand createJPackage() {\n+        \/\/ With short name.\n+        var cmd = JPackageCommand.helloAppImage().setArgumentValue(\"--name\", \"Foo\");\n+\n+        \/\/ Clean leftovers in the input dir from the previous test run if any.\n+        TKit.deleteDirectoryContentsRecursive(cmd.inputDir());\n+\n+        return cmd;\n+    }\n+\n+    private static final ApplicationLayout APP_IMAGE_LAYOUT = ApplicationLayout.platformAppImage();\n+    private static final Path RUNTIME_RELEASE_FILE = Path.of(\"release\");\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImageFillOrderTest.java","additions":359,"deletions":0,"binary":false,"changes":359,"status":"added"}]}