{"files":[{"patch":"@@ -42,0 +42,1 @@\n+  friend class VMStructs;\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -619,0 +619,1 @@\n+  nonstatic_field(JavaThread,                  _cont_entry,                                   ContinuationEntry*)                    \\\n@@ -799,1 +800,2 @@\n-  volatile_nonstatic_field(Mutex,              _owner,                                        Thread*)\n+  volatile_nonstatic_field(Mutex,              _owner,                                        Thread*)                               \\\n+  static_field(ContinuationEntry,              _return_pc,                                    address)\n@@ -1273,0 +1275,1 @@\n+  declare_toplevel_type(ContinuationEntry)                                \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -183,0 +183,2 @@\n+  public boolean isContinuationStub()   { return getName().equals(\"StubRoutines (continuation stubs)\"); }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/CodeBlob.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.runtime;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.types.*;\n+\n+\n+public class ContinuationEntry extends VMObject {\n+    private static long size;\n+    private static Address returnPC;\n+\n+    static {\n+        VM.registerVMInitializedObserver((o, d) -> initialize(VM.getVM().getTypeDataBase()));\n+    }\n+\n+    private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n+        Type type = db.lookupType(\"ContinuationEntry\");\n+        size = type.getSize();\n+        returnPC = type.getAddressField(\"_return_pc\").getValue();\n+    }\n+\n+    public ContinuationEntry(Address addr) {\n+        super(addr);\n+    }\n+\n+    public Address getEntryPC() {\n+        return returnPC;\n+    }\n+\n+    public Address getEntrySP(){\n+        return this.getAddress();\n+    }\n+\n+    public Address getEntryFP(){\n+        return this.getAddress().addOffsetTo(size);\n+    }\n+\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ContinuationEntry.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -50,0 +50,1 @@\n+  private static AddressField  contEntryField;\n@@ -98,0 +99,1 @@\n+    contEntryField    = type.getAddressField(\"_cont_entry\");\n@@ -343,0 +345,4 @@\n+  public ContinuationEntry getContEntry() {\n+      return VMObjectFactory.newObject(ContinuationEntry.class, contEntryField.getValue(addr));\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/JavaThread.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -273,1 +273,7 @@\n-      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n+      if (cb.isUpcallStub()) {\n+        return senderForUpcallStub(map, (UpcallStub)cb);\n+      } else if (cb.isContinuationStub()) {\n+        return senderForContinuationStub(map, cb);\n+      } else {\n+        return senderForCompiledFrame(map, cb);\n+      }\n@@ -359,0 +365,10 @@\n+  private Frame senderForContinuationStub(AARCH64RegisterMap map, CodeBlob cb) {\n+    var contEntry = map.getThread().getContEntry();\n+\n+    Address senderSP = contEntry.getEntrySP();\n+    Address senderPC = contEntry.getEntryPC();\n+    Address senderFP = contEntry.getEntryFP();\n+\n+    return new AARCH64Frame(senderSP, senderFP, senderPC);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/aarch64\/AARCH64Frame.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -265,1 +265,7 @@\n-      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n+      if (cb.isUpcallStub()) {\n+        return senderForUpcallStub(map, (UpcallStub)cb);\n+      } else if (cb.isContinuationStub()) {\n+        return senderForContinuationStub(map, cb);\n+      } else {\n+        return senderForCompiledFrame(map, cb);\n+      }\n@@ -351,0 +357,10 @@\n+  private Frame senderForContinuationStub(RISCV64RegisterMap map, CodeBlob cb) {\n+    var contEntry = map.getThread().getContEntry();\n+\n+    Address senderSP = contEntry.getEntrySP();\n+    Address senderPC = contEntry.getEntryPC();\n+    Address senderFP = contEntry.getEntryFP();\n+\n+    return new RISCV64Frame(senderSP, senderFP, senderPC);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/riscv64\/RISCV64Frame.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -273,1 +273,7 @@\n-      return cb.isUpcallStub() ? senderForUpcallStub(map, (UpcallStub)cb) : senderForCompiledFrame(map, cb);\n+      if (cb.isUpcallStub()) {\n+        return senderForUpcallStub(map, (UpcallStub)cb);\n+      } else if (cb.isContinuationStub()) {\n+        return senderForContinuationStub(map, cb);\n+      } else {\n+        return senderForCompiledFrame(map, cb);\n+      }\n@@ -359,0 +365,10 @@\n+  private Frame senderForContinuationStub(X86RegisterMap map, CodeBlob cb) {\n+    var contEntry = map.getThread().getContEntry();\n+\n+    Address senderSP = contEntry.getEntrySP();\n+    Address senderPC = contEntry.getEntryPC();\n+    Address senderFP = contEntry.getEntryFP();\n+\n+    return new X86Frame(senderSP, senderFP, senderPC);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/x86\/X86Frame.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, NTT DATA\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.lang.foreign.ValueLayout;\n+import java.util.concurrent.CountDownLatch;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+\n+public class LingeredAppWithVirtualThread extends LingeredApp implements Runnable {\n+\n+    private static final String THREAD_NAME = \"target thread\";\n+\n+    private static final MethodHandle hndSleep;\n+\n+    private static final int sleepArg;\n+\n+    private static final CountDownLatch signal = new CountDownLatch(1);\n+\n+    static {\n+        MemorySegment func;\n+        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n+            func = SymbolLookup.libraryLookup(\"Kernel32\", Arena.global())\n+                               .findOrThrow(\"Sleep\");\n+            sleepArg = 3600_000; \/\/ 1h in milliseconds\n+        } else {\n+            func = Linker.nativeLinker()\n+                         .defaultLookup()\n+                         .findOrThrow(\"sleep\");\n+            sleepArg = 3600; \/\/ 1h in seconds\n+        }\n+\n+        var desc = FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.JAVA_INT);\n+        hndSleep = Linker.nativeLinker().downcallHandle(func, desc);\n+    }\n+\n+    @Override\n+    public void run() {\n+        Thread.yield();\n+        signal.countDown();\n+        try {\n+            hndSleep.invoke(sleepArg);\n+        } catch(Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        try {\n+            Thread.ofVirtual()\n+                  .name(THREAD_NAME)\n+                  .start(new LingeredAppWithVirtualThread());\n+\n+            signal.await();\n+            LingeredApp.main(args);\n+        } catch(Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/LingeredAppWithVirtualThread.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, NTT DATA\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.SA.SATestUtils;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @bug 8369505\n+ * @requires vm.hasSA\n+ * @requires (os.arch == \"amd64\" | os.arch == \"x86_64\" | os.arch == \"aarch64\" | os.arch == \"riscv64\")\n+ * @library \/test\/lib\n+ * @run driver TestJhsdbJstackWithVirtualThread\n+ *\/\n+public class TestJhsdbJstackWithVirtualThread {\n+\n+    private static void runJstack(LingeredApp app) throws Exception {\n+        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"jhsdb\");\n+        launcher.addVMArgs(Utils.getTestJavaOpts());\n+        launcher.addToolArg(\"jstack\");\n+        launcher.addToolArg(\"--pid\");\n+        launcher.addToolArg(Long.toString(app.getPid()));\n+\n+        ProcessBuilder pb = SATestUtils.createProcessBuilder(launcher);\n+        Process jhsdb = pb.start();\n+        OutputAnalyzer out = new OutputAnalyzer(jhsdb);\n+\n+        jhsdb.waitFor();\n+\n+        System.out.println(out.getStdout());\n+        System.err.println(out.getStderr());\n+\n+        out.stderrShouldBeEmptyIgnoreDeprecatedWarnings();\n+        out.shouldNotContain(\"must have non-zero frame size\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        SATestUtils.skipIfCannotAttach(); \/\/ throws SkippedException if attach not expected to work.\n+        LingeredApp app = null;\n+\n+        try {\n+            app = new LingeredAppWithVirtualThread();\n+            LingeredApp.startApp(app);\n+            System.out.println(\"Started LingeredApp with pid \" + app.getPid());\n+            runJstack(app);\n+            System.out.println(\"Test Completed\");\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            throw e;\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackWithVirtualThread.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"}]}