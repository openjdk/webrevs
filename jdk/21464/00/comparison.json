{"files":[{"patch":"@@ -0,0 +1,426 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6616089\n+ * @summary Displays a dithered Canvas on all available GraphicsConfigurations\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MultiDitherTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Canvas;\n+import java.awt.Choice;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.FontMetrics;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Image;\n+import java.awt.Label;\n+import java.awt.LayoutManager;\n+import java.awt.Panel;\n+import java.awt.TextField;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.image.ColorModel;\n+import java.awt.image.MemoryImageSource;\n+import java.util.List;\n+\n+public class MultiDitherTest extends Panel implements Runnable {\n+    final static int NOOP = 0;\n+    final static int RED = 1;\n+    final static int GREEN = 2;\n+    final static int BLUE = 3;\n+    final static int ALPHA = 4;\n+    final static int SATURATION = 5;\n+    final static String calcString = \"Calculating...\";\n+    static LayoutManager dcLayout = new FlowLayout(FlowLayout.CENTER, 10, 5);\n+    Thread runner;\n+    DitherControls XControls;\n+    DitherControls YControls;\n+    DitherCanvas canvas;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                This test displays several dithered Canvases similar to the\n+                DitherTest demo applet, one for each available GraphicsConfiguration.\n+                Depending on the GraphicsConfiguration, the dithering may be in\n+                color or in grayscale and\/or display at a lower bitdepth.\n+                The number of GraphicsConfigurations will be printed in the\n+                TextArea below as the test is starting up..\n+                On Solaris, making some Windows active will cause some of the\n+                other Windows to display strangely. This is normal.\n+                Ensure that there are as many Frames created as there are\n+                available GraphicsConfigurations.\n+                Examine each Frame to ensure it displays the dither pattern.\n+                If all Canvases display correctly, the test PASSES.\n+                Otherwise, the test FAILS.\n+                The GC button runs the garbage collector.\n+                This button can be ignored for now.\n+\n+                           \"\"\";\n+        PassFailJFrame passFailJFrame = PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .build();\n+\n+        EventQueue.invokeAndWait(() -> {\n+            for (Frame frame : MultiDitherTest.initialize()) {\n+                PassFailJFrame.addTestWindow(frame);\n+                frame.setVisible(true);\n+            }\n+        });\n+        passFailJFrame.awaitAndCheck();\n+    }\n+\n+    public MultiDitherTest(GraphicsConfiguration gc) {\n+        String xSpec, ySpec;\n+        int[] xValues = new int[2];\n+        int[] yValues = new int[2];\n+\n+        xSpec = \"red\";\n+        ySpec = \"blue\";\n+        int xMethod = colorMethod(xSpec, xValues);\n+        int yMethod = colorMethod(ySpec, yValues);\n+\n+        setLayout(new BorderLayout());\n+        XControls = new DitherControls(this, xValues[0], xValues[1],\n+                xMethod, false);\n+        YControls = new DitherControls(this, yValues[0], yValues[1],\n+                yMethod, true);\n+        YControls.addRenderButton();\n+        YControls.addGCButton();\n+        add(\"North\", XControls);\n+        add(\"South\", YControls);\n+        add(\"Center\", canvas = new DitherCanvas(gc));\n+    }\n+\n+    private static List<Frame> initialize() {\n+        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        GraphicsDevice[] gds = ge.getScreenDevices();\n+        Frame[] frames = new Frame[0];\n+        System.out.println(gds.length + \" screens detected\");\n+\n+        for (int j = 0; j < gds.length; j++) {\n+\n+            GraphicsDevice gd = gds[j];\n+            GraphicsConfiguration[] gcs = gd.getConfigurations();\n+            frames = new Frame[gcs.length];\n+            System.out.println(gcs.length + \" GraphicsConfigurations available on screen \" + j);\n+            for (int i = 0; i < gcs.length; i++) {\n+                Frame f = new Frame(\"MultiDitherTest \" + (i + 1), gcs[i]);\n+                f.setLayout(new BorderLayout());\n+                f.setLocation(gcs[i].getBounds().x + 100 + (i * 10),\n+                        gcs[i].getBounds().y + 100 + (i * 10));\n+                MultiDitherTest ditherTest = new MultiDitherTest(gcs[i]);\n+                f.add(\"Center\", ditherTest);\n+                f.pack();\n+                f.addWindowListener(new WindowAdapter() {\n+                    public void windowClosing(WindowEvent ev) {\n+                        ev.getWindow().dispose();\n+                    }\n+                });\n+                f.setVisible(true);\n+                ditherTest.start();\n+                frames[i] = f;\n+            }\n+\n+        }\n+        return List.of(frames);\n+    }\n+\n+    int colorMethod(String s, int[] values) {\n+        int method = NOOP;\n+\n+        if (s == null) {\n+            s = \"\";\n+        }\n+\n+        String lower = s.toLowerCase();\n+        if (lower.startsWith(\"red\")) {\n+            method = RED;\n+            lower = lower.substring(3);\n+        } else if (lower.startsWith(\"green\")) {\n+            method = GREEN;\n+            lower = lower.substring(5);\n+        } else if (lower.startsWith(\"blue\")) {\n+            method = BLUE;\n+            lower = lower.substring(4);\n+        } else if (lower.startsWith(\"alpha\")) {\n+            method = ALPHA;\n+            lower = lower.substring(4);\n+        } else if (lower.startsWith(\"saturation\")) {\n+            method = SATURATION;\n+            lower = lower.substring(10);\n+        }\n+\n+        if (method == NOOP) {\n+            values[0] = 0;\n+            values[1] = 0;\n+            return method;\n+        }\n+\n+        int begval = 0;\n+        int endval = 255;\n+\n+        try {\n+            int dash = lower.indexOf('-');\n+            if (dash < 0) {\n+                begval = endval = Integer.parseInt(lower);\n+            } else {\n+                begval = Integer.parseInt(lower.substring(0, dash));\n+                endval = Integer.parseInt(lower.substring(dash + 1));\n+            }\n+        } catch (Exception e) {\n+        }\n+\n+        if (begval < 0) {\n+            begval = 0;\n+        }\n+        if (endval < 0) {\n+            endval = 0;\n+        }\n+        if (begval > 255) {\n+            begval = 255;\n+        }\n+        if (endval > 255) {\n+            endval = 255;\n+        }\n+\n+        values[0] = begval;\n+        values[1] = endval;\n+\n+        return method;\n+    }\n+\n+    public void start() {\n+        runner = new Thread(this);\n+        runner.start();\n+    }\n+\n+    public void stop() {\n+        runner = null;\n+    }\n+\n+    public void destroy() {\n+        remove(XControls);\n+        remove(YControls);\n+        remove(canvas);\n+    }\n+\n+    void applyMethod(int[] c, int method, int step, int total, int[] values) {\n+        if (method == NOOP) {\n+            return;\n+        }\n+        int val = ((total < 2)\n+                ? values[0]\n+                : values[0] + ((values[1] - values[0]) * step \/ (total - 1)));\n+        switch (method) {\n+            case RED:\n+                c[0] = val;\n+                break;\n+            case GREEN:\n+                c[1] = val;\n+                break;\n+            case BLUE:\n+                c[2] = val;\n+                break;\n+            case ALPHA:\n+                c[3] = val;\n+                break;\n+            case SATURATION:\n+                int max = Math.max(Math.max(c[0], c[1]), c[2]);\n+                int min = max * (255 - val) \/ 255;\n+                if (c[0] == 0) c[0] = min;\n+                if (c[1] == 0) c[1] = min;\n+                if (c[2] == 0) c[2] = min;\n+                break;\n+        }\n+    }\n+\n+    public void run() {\n+        canvas.setImage(null);\n+        Image img = calculateImage();\n+        synchronized (this) {\n+            if (img != null && runner == Thread.currentThread()) {\n+                canvas.setImage(img);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Calculates and returns the image.  Halts the calculation and returns\n+     * null if the Applet is stopped during the calculation.\n+     *\/\n+    Image calculateImage() {\n+        Thread me = Thread.currentThread();\n+\n+        int width = canvas.getSize().width;\n+        int height = canvas.getSize().height;\n+        int[] xValues = new int[2];\n+        int[] yValues = new int[2];\n+        int xMethod = XControls.getParams(xValues);\n+        int yMethod = YControls.getParams(yValues);\n+        int[] pixels = new int[width * height];\n+        int[] c = new int[4];\n+        int index = 0;\n+\n+        for (int j = 0; j < height; j++) {\n+            for (int i = 0; i < width; i++) {\n+                c[0] = c[1] = c[2] = 0;\n+                c[3] = 255;\n+                if (xMethod < yMethod) {\n+                    applyMethod(c, xMethod, i, width, xValues);\n+                    applyMethod(c, yMethod, j, height, yValues);\n+                } else {\n+                    applyMethod(c, yMethod, j, height, yValues);\n+                    applyMethod(c, xMethod, i, width, xValues);\n+                }\n+                pixels[index++] = ((c[3] << 24) |\n+                        (c[0] << 16) |\n+                        (c[1] << 8) |\n+                        (c[2] << 0));\n+            }\n+            \/\/ Poll once per row to see if we've been told to stop.\n+            if (runner != me) {\n+                return null;\n+            }\n+        }\n+\n+        return createImage(new MemoryImageSource(width, height,\n+                ColorModel.getRGBdefault(), pixels, 0, width));\n+    }\n+\n+    static class DitherCanvas extends Canvas {\n+        Image img;\n+        GraphicsConfiguration mGC;\n+\n+        public DitherCanvas(GraphicsConfiguration gc) {\n+            super(gc);\n+            mGC = gc;\n+        }\n+\n+        public GraphicsConfiguration getGraphicsConfig() {\n+            return mGC;\n+        }\n+\n+        public void paint(Graphics g) {\n+            int w = getSize().width;\n+            int h = getSize().height;\n+            if (img == null) {\n+                super.paint(g);\n+                g.setColor(Color.black);\n+                FontMetrics fm = g.getFontMetrics();\n+                int x = (w - fm.stringWidth(calcString)) \/ 2;\n+                int y = h \/ 2;\n+                g.drawString(calcString, x, y);\n+            } else {\n+                g.drawImage(img, 0, 0, w, h, this);\n+            }\n+        }\n+\n+        public void update(Graphics g) {\n+            paint(g);\n+        }\n+\n+        public Dimension getMinimumSize() {\n+            return new Dimension(20, 20);\n+        }\n+\n+        public Dimension getPreferredSize() {\n+            return new Dimension(200, 200);\n+        }\n+\n+        public Image getImage() {\n+            return img;\n+        }\n+\n+        public void setImage(Image img) {\n+            this.img = img;\n+            paint(getGraphics());\n+        }\n+    }\n+\n+    static class DitherControls extends Panel implements ActionListener {\n+        TextField start;\n+        TextField end;\n+        Button button;\n+        Choice choice;\n+        MultiDitherTest panel;\n+        Button gc;\n+\n+        public DitherControls(MultiDitherTest app, int s, int e, int type,\n+                              boolean vertical) {\n+            panel = app;\n+            setLayout(dcLayout);\n+            add(new Label(vertical ? \"Vertical\" : \"Horizontal\"));\n+            add(choice = new Choice());\n+            choice.addItem(\"Noop\");\n+            choice.addItem(\"Red\");\n+            choice.addItem(\"Green\");\n+            choice.addItem(\"Blue\");\n+            choice.addItem(\"Alpha\");\n+            choice.addItem(\"Saturation\");\n+            choice.select(type);\n+            add(start = new TextField(Integer.toString(s), 4));\n+            add(end = new TextField(Integer.toString(e), 4));\n+        }\n+\n+        public void addRenderButton() {\n+            add(button = new Button(\"New Image\"));\n+            button.addActionListener(this);\n+        }\n+\n+        public void addGCButton() {\n+            add(gc = new Button(\"GC\"));\n+            gc.addActionListener(this);\n+        }\n+\n+        public int getParams(int[] values) {\n+            values[0] = Integer.parseInt(start.getText());\n+            values[1] = Integer.parseInt(end.getText());\n+            return choice.getSelectedIndex();\n+        }\n+\n+        public void actionPerformed(ActionEvent e) {\n+            if (e.getSource() == button) {\n+                panel.start();\n+            } else if (e.getSource() == gc) {\n+                System.gc();\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/Canvas\/MultiDitherTest.java","additions":426,"deletions":0,"binary":false,"changes":426,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6616089\n+ * @summary Display an image in all available GraphicsConfigurations\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual MultiGraphicsTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Canvas;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Image;\n+import java.awt.MediaTracker;\n+import java.awt.Toolkit;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.net.URL;\n+import java.util.List;\n+\n+public class MultiGraphicsTest extends Canvas {\n+    final static String IMAGEFILE = \"duke_404.gif\";\n+    static Image jim;\n+    MediaTracker tracker;\n+    int w, h;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                This test displays several Windows containing an image,\n+                one Window for each available GraphicsConfiguration.\n+                Depending on the GraphicsConfiguration, images may be\n+                displayed in color or in grayscale and\/or displayed at a\n+                lower bitdepth.\n+                The number of GraphicsConfigurations will be printed below\n+                as the test is starting up.\n+                On Solaris, making some Windows active will cause some of\n+                the other Windows to display strangely. This is normal.\n+                Ensure that there are as many Windows created as there are\n+                available GraphicsConfigurations.\n+                Examine each Window to ensure it displays Jim.\n+                If all Canvases display correctly, the test PASSES.\n+                Otherwise, the test FAILS.\"\n+                \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public MultiGraphicsTest(GraphicsConfiguration gc) {\n+        super(gc);\n+        tracker = new MediaTracker(this);\n+        tracker.addImage(jim, 0);\n+        try {\n+            tracker.waitForAll();\n+        } catch (java.lang.InterruptedException e) {\n+            System.err.println(e);\n+        }\n+        w = jim.getWidth(this);\n+        h = jim.getHeight(this);\n+    }\n+\n+    private static List<Frame> initialize() {\n+        URL imgURL;\n+        imgURL = MultiGraphicsTest.class.getResource(IMAGEFILE);\n+        if (imgURL == null) {\n+            System.err.println(\"Unable to locate \" + IMAGEFILE);\n+            return null;\n+        }\n+        jim = Toolkit.getDefaultToolkit().getImage(imgURL);\n+\n+        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        GraphicsDevice gd = ge.getDefaultScreenDevice();\n+        GraphicsConfiguration[] gc = gd.getConfigurations();\n+        Frame[] frames = new Frame[gc.length];\n+        System.out.println(gc.length + \" available GraphicsConfigurations\");\n+        for (int i = 0; i < gc.length; i++) {\n+            Frame f = new Frame(\"GraphicsTest \" + (i + 1));\n+            f.setLayout(new BorderLayout());\n+            f.setLocation(100 + (i * 10), 100 + (i * 10));\n+            MultiGraphicsTest gcTest = new MultiGraphicsTest(gc[i]);\n+            f.add(\"Center\", gcTest);\n+            f.pack();\n+            f.addWindowListener(new WindowAdapter() {\n+                public void windowClosing(WindowEvent ev) {\n+                    ev.getWindow().setVisible(false);\n+                }\n+            });\n+            frames[i] = f;\n+        }\n+        return List.of(frames);\n+    }\n+\n+    public void paint(Graphics g) {\n+        g.drawImage(jim, 0, 0, w, h, this);\n+    }\n+\n+    public void update(Graphics g) {\n+        paint(g);\n+    }\n+\n+    public Dimension getMinimumSize() {\n+        return new Dimension(w, h);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(w, h);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Canvas\/MultiGraphicsTest.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4250354\n+ * @key headful\n+ * @summary tests that JNI global refs are cleaned up correctly\n+ * @run main\/timeout=600 NoEventsLeakTest\n+ *\/\n+\n+import java.awt.Canvas;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+\n+public class NoEventsLeakTest extends Frame {\n+    static final int nLoopCount = 1000;\n+\n+    private static void initialize() {\n+        NoEventsLeakTest app = new NoEventsLeakTest();\n+        boolean result = app.run();\n+        if (result) {\n+            throw new RuntimeException(\"Memory leak in Component\");\n+        }\n+        System.out.println(\"Test Passed\");\n+    }\n+\n+    public boolean run() {\n+        setSize(10, 10);\n+        addNotify();\n+        for (int i = 0; i < nLoopCount; i++) {\n+            Canvas panel = new TestCanvas();\n+            add(panel, 0);\n+            remove(0);\n+            panel = null;\n+            System.gc();\n+        }\n+        try {\n+            Thread.currentThread().sleep(1000);\n+        } catch (InterruptedException e) {\n+        }\n+        System.gc();\n+        System.out.println(\"Checking\");\n+        return ((TestCanvas.created - TestCanvas.finalized) > 800);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        EventQueue.invokeAndWait(NoEventsLeakTest::initialize);\n+    }\n+}\n+\n+class TestCanvas extends Canvas {\n+    static int finalized = 0;\n+    static int created = 0;\n+    static final int nLoopPrint = 100;\n+\n+    public TestCanvas() {\n+        if (created % nLoopPrint == 0) {\n+            System.out.println(\"Created \" + getClass() + \" \" + created);\n+        }\n+        created++;\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    protected void finalize() {\n+        try {\n+            super.finalize();\n+            if (finalized % nLoopPrint == 0) {\n+                System.out.println(\"Finalized \" + getClass() + \" \" + finalized);\n+            }\n+            finalized++;\n+        } catch (Throwable t) {\n+            System.out.println(\"Exception in \" + getClass() + \": \" + t);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Canvas\/NoEventsLeakTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/awt\/Canvas\/duke_404.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/awt\/Frame\/MegaIconTest\/duke_404.gif","status":"copied"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4147957\n+ * @key headful\n+ * @summary Test to verify setClip with invalid rect changes rect to valid\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main IntersectionTest\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Panel;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+\n+public class IntersectionTest {\n+    public static Frame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot robot = new Robot();\n+        try {\n+            robot.setAutoDelay(100);\n+            EventQueue.invokeAndWait(() -> {\n+                TestFrame panel = new TestFrame();\n+                frame = new Frame(\"Rectangle Intersection Test\");\n+                frame.add(panel);\n+\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+            robot.waitForIdle();\n+            robot.delay(200);\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n+\n+class TestFrame extends Panel {\n+    @Override\n+    public void paint(Graphics g) {\n+        Rectangle r1 = new Rectangle(0, 0, 100, 100);\n+        Rectangle r2 = new Rectangle(200, 200, 20, 20);\n+        Rectangle r3 = r1.intersection(r2);\n+        System.out.println(\"intersect:(\" + (int) r3.getX() + \",\" +\n+                (int) r3.getY() + \",\" + (int) r3.getWidth() + \",\" +\n+                (int) r3.getHeight() + \")\");\n+        g.setClip(r3);\n+        Rectangle r4 = g.getClipBounds();\n+        System.out.println(\"getClipBounds:(\" + (int) r4.getX() + \",\" +\n+                (int) r4.getY() + \",\" + (int) r4.getWidth() + \",\" +\n+                (int) r4.getHeight() + \")\");\n+\n+        if ((r4.getWidth() <= 0) || (r4.getHeight() <= 0)) {\n+            System.out.println(\"Test Passed\");\n+        } else {\n+            throw new RuntimeException(\"IntersectionTest failed. \" +\n+                    \"Non-empty clip bounds.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Rectangle\/IntersectionTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}