{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import java.lang.classfile.constantpool.Utf8Entry;\n@@ -49,2 +48,2 @@\n-                dcb.methodInfo.methodName(),\n-                dcb.methodInfo.methodType(),\n+                dcb.methodInfo.methodName().stringValue(),\n+                dcb.methodInfo.methodTypeSymbol(),\n@@ -60,2 +59,2 @@\n-    private final Utf8Entry methodName;\n-    private final Utf8Entry methodDesc;\n+    private final String methodName;\n+    private final MethodTypeDesc methodDesc;\n@@ -95,2 +94,2 @@\n-                     Utf8Entry methodName,\n-                     Utf8Entry methodDesc,\n+                     String methodName,\n+                     MethodTypeDesc methodDesc,\n@@ -108,1 +107,1 @@\n-        maxLocals += countMethodSlots(methodDesc, false);\n+        maxLocals += Util.parameterSlots(methodDesc);\n@@ -306,1 +305,2 @@\n-                        addStackSlot(-countMethodSlots(nameAndType.type(), true));\n+                        var mtd = Util.methodTypeSymbol(nameAndType);\n+                        addStackSlot(Util.slotSize(mtd.returnType()) - Util.parameterSlots(mtd));\n@@ -338,47 +338,0 @@\n-    private static int countMethodSlots(Utf8Entry descriptor, boolean asStackDelta) {\n-        int cur = 0, end = descriptor.length();\n-        if (cur >= end || descriptor.charAt(cur) != '(')\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ++cur;  \/\/ skip '('\n-        int count = 0;\n-        boolean inArray = false;\n-        while (cur < end) {\n-            switch (descriptor.charAt(cur++)) {\n-                case 'Z', 'B', 'C', 'S', 'I', 'F' -> {\n-                    count++;\n-                    inArray = false;\n-                }\n-                case 'J', 'D' -> {\n-                    count += inArray ? 1 : 2;\n-                    inArray = false;\n-                }\n-                case 'L' -> {\n-                    cur = descriptor.indexOf(';', cur) + 1;\n-                    if (cur == 0)\n-                        throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-                    count++;\n-                    inArray = false;\n-                }\n-                case '[' -> {\n-                    inArray = true;\n-                }\n-                case ')' -> {\n-                    if (cur < end) {\n-                        if (asStackDelta) {\n-                            return switch (descriptor.charAt(cur++)) {\n-                                case 'Z', 'B', 'C', 'S', 'I', 'F', '[', 'L' -> count - 1;\n-                                case 'J', 'D' -> count - 2;\n-                                case 'V' -> count;\n-                                default -> throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-                            };\n-                        } else {\n-                            return count;\n-                        }\n-                    }\n-                }\n-                default -> throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-            }\n-        }\n-        throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-    }\n-\n@@ -419,1 +372,1 @@\n-                MethodTypeDesc.ofDescriptor(methodDesc.stringValue()).displayDescriptor()));\n+                methodDesc.displayDescriptor()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":11,"deletions":58,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.classfile;\n+\n+import java.io.IOException;\n+import java.lang.constant.ClassDesc;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.util.Iterator;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassReader;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.constantpool.ConstantPool;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.constant.MethodTypeDesc;\n+import jdk.internal.classfile.impl.AbstractPseudoInstruction;\n+import jdk.internal.classfile.impl.CodeImpl;\n+import jdk.internal.classfile.impl.LabelContext;\n+import jdk.internal.classfile.impl.ClassFileImpl;\n+import jdk.internal.classfile.impl.SplitConstantPool;\n+import jdk.internal.classfile.impl.StackCounter;\n+import jdk.internal.classfile.impl.StackMapGenerator;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsAppend = {\n+        \"--enable-preview\",\n+        \"--add-exports\", \"java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\"})\n+@Warmup(iterations = 2)\n+@Measurement(iterations = 8)\n+public class CodeAttributeTools {\n+\n+    record GenData(LabelContext labelContext,\n+                    ClassDesc thisClass,\n+                    String methodName,\n+                    MethodTypeDesc methodDesc,\n+                    boolean isStatic,\n+                    ByteBuffer bytecode,\n+                    ConstantPoolBuilder constantPool,\n+                    List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers) {}\n+\n+    List<GenData> data;\n+\n+    @Setup(Level.Invocation)\n+    public void setup() throws IOException {\n+        data = new ArrayList<>();\n+        Files.walk(FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"modules\/java.base\/java\")).forEach(p ->  {\n+            if (Files.isRegularFile(p) && p.toString().endsWith(\".class\")) try {\n+                var clm = ClassFile.of().parse(p);\n+                var thisCls = clm.thisClass().asSymbol();\n+                var cp = new SplitConstantPool((ClassReader)clm.constantPool());\n+                for (var m : clm.methods()) {\n+                    m.code().ifPresent(com -> {\n+                        var bb = ByteBuffer.wrap(((CodeImpl)com).contents());\n+                        data.add(new GenData(\n+                                (LabelContext)com,\n+                                thisCls,\n+                                m.methodName().stringValue(),\n+                                m.methodTypeSymbol(),\n+                                (m.flags().flagsMask() & ClassFile.ACC_STATIC) != 0,\n+                                bb.slice(8, bb.getInt(4)),\n+                                cp,\n+                                com.exceptionHandlers().stream().map(eh -> (AbstractPseudoInstruction.ExceptionCatchImpl)eh).toList()));\n+                    });\n+                }\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    @Benchmark\n+    public void benchmarkStackMapsGenerator() {\n+        for (var d : data) new StackMapGenerator(\n+                d.labelContext(),\n+                d.thisClass(),\n+                d.methodName(),\n+                d.methodDesc(),\n+                d.isStatic(),\n+                d.bytecode().rewind(),\n+                (SplitConstantPool)d.constantPool(),\n+                (ClassFileImpl)ClassFile.of(),\n+                d.handlers());\n+    }\n+\n+    @Benchmark\n+    public void benchmarkStackCounter() {\n+        for (var d : data) new StackCounter(\n+                d.labelContext(),\n+                d.methodName(),\n+                d.methodDesc(),\n+                d.isStatic(),\n+                d.bytecode().rewind(),\n+                (SplitConstantPool)d.constantPool(),\n+                d.handlers());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/CodeAttributeTools.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.classfile;\n-\n-import java.io.IOException;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.net.URI;\n-import java.nio.ByteBuffer;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.util.Iterator;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.ClassReader;\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n-import jdk.internal.classfile.impl.AbstractPseudoInstruction;\n-import jdk.internal.classfile.impl.CodeImpl;\n-import jdk.internal.classfile.impl.LabelContext;\n-import jdk.internal.classfile.impl.ClassFileImpl;\n-import jdk.internal.classfile.impl.SplitConstantPool;\n-import jdk.internal.classfile.impl.StackMapGenerator;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Level;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-@BenchmarkMode(Mode.Throughput)\n-@State(Scope.Benchmark)\n-@Fork(value = 1, jvmArgsAppend = {\n-        \"--enable-preview\",\n-        \"--add-exports\", \"java.base\/jdk.internal.classfile.impl=ALL-UNNAMED\"})\n-@Warmup(iterations = 2)\n-@Measurement(iterations = 10)\n-public class GenerateStackMaps {\n-\n-    record GenData(LabelContext labelContext,\n-                    ClassDesc thisClass,\n-                    String methodName,\n-                    MethodTypeDesc methodDesc,\n-                    boolean isStatic,\n-                    ByteBuffer bytecode,\n-                    ConstantPoolBuilder constantPool,\n-                    List<AbstractPseudoInstruction.ExceptionCatchImpl> handlers) {}\n-\n-    List<GenData> data;\n-    Iterator<GenData> it;\n-    GenData d;\n-    ClassFile cc;\n-\n-    @Setup(Level.Trial)\n-    public void setup() throws IOException {\n-        cc = ClassFile.of();\n-        data = new ArrayList<>();\n-        Files.walk(FileSystems.getFileSystem(URI.create(\"jrt:\/\")).getPath(\"modules\/java.base\/java\")).forEach(p ->  {\n-            if (Files.isRegularFile(p) && p.toString().endsWith(\".class\")) try {\n-                var clm = cc.parse(p);\n-                var thisCls = clm.thisClass().asSymbol();\n-                var cp = new SplitConstantPool((ClassReader)clm.constantPool());\n-                for (var m : clm.methods()) {\n-                    m.code().ifPresent(com -> {\n-                        var bb = ByteBuffer.wrap(((CodeImpl)com).contents());\n-                        data.add(new GenData(\n-                                (LabelContext)com,\n-                                thisCls,\n-                                m.methodName().stringValue(),\n-                                m.methodTypeSymbol(),\n-                                (m.flags().flagsMask() & ClassFile.ACC_STATIC) != 0,\n-                                bb.slice(8, bb.getInt(4)),\n-                                cp,\n-                                com.exceptionHandlers().stream().map(eh -> (AbstractPseudoInstruction.ExceptionCatchImpl)eh).toList()));\n-                    });\n-                }\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        });\n-    }\n-\n-    @Benchmark\n-    public void benchmark() {\n-        if (it == null || !it.hasNext())\n-            it = data.iterator();\n-        var d = it.next();\n-        new StackMapGenerator(\n-                d.labelContext(),\n-                d.thisClass(),\n-                d.methodName(),\n-                d.methodDesc(),\n-                d.isStatic(),\n-                d.bytecode().rewind(),\n-                (SplitConstantPool)d.constantPool(),\n-                (ClassFileImpl)cc,\n-                d.handlers());\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/GenerateStackMaps.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"}]}