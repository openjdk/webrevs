{"files":[{"patch":"@@ -90,0 +90,1 @@\n+        this.doneFullScan = true;\n@@ -192,1 +193,1 @@\n-            for (int i=1; i<parentSize; i++) {\n+            for (int i=1; i<parentSize;) {\n@@ -194,1 +195,4 @@\n-                if (cpi != null)\n+                if (cpi == null) {\n+                    doneFullScan = false;\n+                    i++;\n+                } else {\n@@ -196,0 +200,2 @@\n+                    i += cpi.width();\n+                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n@@ -32,1 +30,0 @@\n-import java.util.LinkedHashMap;\n@@ -34,1 +31,0 @@\n-import java.util.stream.Collectors;\n@@ -40,0 +36,4 @@\n+import java.lang.classfile.constantpool.Utf8Entry;\n+import java.lang.constant.MethodTypeDesc;\n+import java.util.ArrayDeque;\n+import java.util.Queue;\n@@ -44,0 +44,2 @@\n+    private record Target(int bci, int stack) {}\n+\n@@ -47,3 +49,2 @@\n-                buf.thisClass().asSymbol(),\n-                dcb.methodInfo.methodName().stringValue(),\n-                dcb.methodInfo.methodTypeSymbol(),\n+                dcb.methodInfo.methodName(),\n+                dcb.methodInfo.methodType(),\n@@ -59,2 +60,2 @@\n-    private final String methodName;\n-    private final MethodTypeDesc methodDesc;\n+    private final Utf8Entry methodName;\n+    private final Utf8Entry methodDesc;\n@@ -62,1 +63,1 @@\n-    private final LinkedHashMap<Integer, Integer> map;\n+    private final Queue<Target> targets;\n@@ -67,1 +68,1 @@\n-            map.put(targetBci, stack);\n+            targets.add(new Target(targetBci, stack));\n@@ -81,7 +82,5 @@\n-        var it = map.entrySet().iterator();\n-        while (it.hasNext()) {\n-            var en = it.next();\n-            it.remove();\n-            if (!visited.get(en.getKey())) {\n-                bcs.nextBci = en.getKey();\n-                stack = en.getValue();\n+        Target en;\n+        while ((en = targets.poll()) != null) {\n+            if (!visited.get(en.bci)) {\n+                bcs.nextBci = en.bci;\n+                stack = en.stack;\n@@ -96,3 +95,2 @@\n-                     ClassDesc thisClass,\n-                     String methodName,\n-                     MethodTypeDesc methodDesc,\n+                     Utf8Entry methodName,\n+                     Utf8Entry methodDesc,\n@@ -106,1 +104,1 @@\n-        map = new LinkedHashMap<>();\n+        targets = new ArrayDeque<>();\n@@ -108,1 +106,1 @@\n-        for (var h : handlers) map.put(labelContext.labelToBci(h.handler), 1);\n+        for (var h : handlers) targets.add(new Target(labelContext.labelToBci(h.handler), 1));\n@@ -110,3 +108,1 @@\n-        for (var cd : methodDesc.parameterList()) {\n-            maxLocals += Util.slotSize(cd);\n-        }\n+        maxLocals += countMethodStack(methodDesc, false);\n@@ -115,1 +111,1 @@\n-        map.put(0, 0);\n+        targets.add(new Target(0, 0));\n@@ -310,4 +306,1 @@\n-                        var mDesc = MethodTypeDesc.ofDescriptor(nameAndType.type().stringValue());\n-                        for (var arg : mDesc.parameterList()) {\n-                            addStackSlot(-TypeKind.from(arg).slotSize());\n-                        }\n+                        addStackSlot(-countMethodStack(nameAndType.type(), true));\n@@ -317,1 +310,0 @@\n-                        addStackSlot(TypeKind.from(mDesc.returnType()).slotSize());\n@@ -346,0 +338,45 @@\n+    private static int countMethodStack(Utf8Entry descriptor, boolean subReturn) {\n+        int cur = 0, end = descriptor.length();\n+        if (cur >= end || descriptor.charAt(cur) != '(')\n+            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+        ++cur;  \/\/ skip '('\n+        int count = 0;\n+        boolean inArray = false;\n+        while (cur < end) {\n+            switch (descriptor.charAt(cur++)) {\n+                case 'Z', 'B', 'C', 'S', 'I', 'F' -> {\n+                    count++;\n+                    inArray = false;\n+                }\n+                case 'J', 'D' -> {\n+                    count += inArray ? 1 : 2;\n+                    inArray = false;\n+                }\n+                case 'L' -> {\n+                    while (cur < end && descriptor.charAt(cur++) != ';');\n+                    count++;\n+                    inArray = false;\n+                }\n+                case '[' -> {\n+                    inArray = true;\n+                }\n+                case ')' -> {\n+                    if (cur < end) {\n+                        if (subReturn) {\n+                            return switch (descriptor.charAt(cur++)) {\n+                                case 'Z', 'B', 'C', 'S', 'I', 'F', '[', 'L' -> count - 1;\n+                                case 'J', 'D' -> count - 2;\n+                                case 'V' -> count;\n+                                default -> throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+                            };\n+                        } else {\n+                            return count;\n+                        }\n+                    }\n+                }\n+                default -> throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+    }\n+\n@@ -380,1 +417,1 @@\n-                methodDesc.displayDescriptor()));\n+                MethodTypeDesc.ofDescriptor(methodDesc.stringValue()).displayDescriptor()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":70,"deletions":33,"binary":false,"changes":103,"status":"modified"}]}