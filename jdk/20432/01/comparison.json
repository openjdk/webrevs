{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.awt.image.BufferedImage;\n@@ -922,2 +923,14 @@\n-            Rectangle rect = new Rectangle(minX, row, width, 1);\n-            Raster ras = image.getData(rect);\n+            Raster ras;\n+            if (image instanceof BufferedImage bi) {\n+                \/\/ Use the raster directly (no copy).\n+                ras = bi.getRaster();\n+            } else if (image.getNumXTiles() == 1 && image.getNumYTiles() == 1 &&\n+                       image.getTileWidth() == width && image.getTileHeight() == height) {\n+                \/\/ Use the single tile directly (no copy).\n+                ras = image.getTile(image.getMinTileX(), image.getMinTileY());\n+            } else {\n+                \/\/ Make a copy of the raster data.\n+                Rectangle rect = new Rectangle(minX, row, width, 1);\n+                ras = image.getData(rect);\n+            }\n+\n@@ -925,2 +938,1 @@\n-                ras = ras.createChild(minX, row, width, 1, minX, row,\n-                                      sourceBands);\n+                ras = ras.createChild(minX, row, width, 1, minX, row, sourceBands);\n@@ -932,1 +944,1 @@\n-                WritableRaster wr = ras.createCompatibleWritableRaster();\n+                WritableRaster wr = ras.createCompatibleWritableRaster(minX, row, width, 1);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/png\/PNGImageWriter.java","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337681\n+ * @summary Test that raster use optimization does not cause any regressions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.RenderedImage;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import javax.imageio.IIOImage;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageReader;\n+import javax.imageio.ImageWriteParam;\n+import javax.imageio.ImageWriter;\n+import javax.imageio.stream.ImageInputStream;\n+import javax.imageio.stream.ImageOutputStream;\n+import javax.imageio.stream.MemoryCacheImageOutputStream;\n+\n+public class RasterReuseWriteTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        test(BufferedImage.TYPE_INT_RGB);\n+        test(BufferedImage.TYPE_INT_ARGB);\n+        test(BufferedImage.TYPE_INT_ARGB_PRE);\n+        test(BufferedImage.TYPE_4BYTE_ABGR);\n+        test(BufferedImage.TYPE_4BYTE_ABGR_PRE);\n+    }\n+\n+    private static void test(int type) throws Exception {\n+\n+        \/\/ swaps blue and red\n+        int bands = (type == BufferedImage.TYPE_INT_RGB ? 3 : 4);\n+        int[] sourceBands = bands == 3 ? new int[] { 2, 1, 0 } :\n+                                         new int[] { 2, 1, 0, 3 };\n+\n+        \/\/ test writing a BufferedImage without source bands\n+        BufferedImage img1 = createImage(256, 256, type);\n+        byte[] bytes1 = writePng(img1, null);\n+        BufferedImage img2 = ImageIO.read(new ByteArrayInputStream(bytes1));\n+        compare(img1, img2, false);\n+\n+        \/\/ test writing a BufferedImage with source bands\n+        BufferedImage img3 = createImage(256, 256, type);\n+        byte[] bytes3 = writePng(img3, sourceBands);\n+        BufferedImage img4 = ImageIO.read(new ByteArrayInputStream(bytes3));\n+        compare(img3, img4, true);\n+\n+        \/\/ test writing a non-BufferedImage with source bands and one tile\n+        RenderedImage img5 = toTiledImage(img1, 256);\n+        byte[] bytes5 = writePng(img5, sourceBands);\n+        BufferedImage img6 = ImageIO.read(new ByteArrayInputStream(bytes5));\n+        compare(img5, img6, true);\n+\n+        \/\/ test writing a non-BufferedImage with source bands and multiple tiles\n+        RenderedImage img7 = toTiledImage(img1, 128);\n+        byte[] bytes7 = writePng(img7, sourceBands);\n+        BufferedImage img8 = ImageIO.read(new ByteArrayInputStream(bytes7));\n+        compare(img7, img8, true);\n+    }\n+\n+    private static BufferedImage createImage(int w, int h, int type) throws Exception {\n+        BufferedImage img = new BufferedImage(w, h, type);\n+        Graphics2D g2d = img.createGraphics();\n+        g2d.setColor(Color.WHITE);\n+        g2d.fillRect(0, 0, w, h);\n+        g2d.setColor(Color.GREEN);\n+        g2d.drawRect(20, 20, 100, 50);\n+        g2d.setColor(Color.RED);\n+        g2d.drawRect(80, 10, 100, 40);\n+        g2d.setColor(Color.BLUE);\n+        g2d.fillRect(40, 60, 120, 30);\n+        g2d.dispose();\n+        return img;\n+    }\n+\n+    private static byte[] writePng(RenderedImage img, int[] sourceBands) throws Exception {\n+        ImageWriter writer = ImageIO.getImageWritersByFormatName(\"png\").next();\n+        ImageWriteParam param = writer.getDefaultWriteParam();\n+        param.setSourceBands(sourceBands);\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ImageOutputStream stream = new MemoryCacheImageOutputStream(baos);\n+        writer.setOutput(stream);\n+        writer.write(null, new IIOImage(img, null, null), param);\n+        writer.dispose();\n+        stream.flush();\n+        return baos.toByteArray();\n+    }\n+\n+    private static void compare(RenderedImage img1, RenderedImage img2, boolean blueAndRedSwapped) {\n+        int[] pixels1 = getRgbPixels(img1);\n+        int[] pixels2 = getRgbPixels(img2);\n+        for (int i = 0; i < pixels1.length; i++) {\n+            int expected;\n+            if (blueAndRedSwapped && pixels1[i] == 0xFFFF0000) {\n+                expected = 0xFF0000FF; \/\/ red -> blue\n+            } else if (blueAndRedSwapped && pixels1[i] == 0xFF0000FF) {\n+                expected = 0xFFFF0000; \/\/ blue -> red\n+            } else {\n+                expected = pixels1[i]; \/\/ no change\n+            }\n+            int actual = pixels2[i];\n+            if (actual != expected) {\n+                throw new RuntimeException(\"Pixel \" + i + \": expected \" +\n+                    Integer.toHexString(expected) + \", but got \" +\n+                    Integer.toHexString(actual));\n+            }\n+        }\n+    }\n+\n+    private static int[] getRgbPixels(RenderedImage img) {\n+        int w = img.getWidth();\n+        int h = img.getHeight();\n+        if (img instanceof BufferedImage bi) {\n+            return bi.getRGB(0, 0, w, h, null, 0, w);\n+        } else {\n+            BufferedImage bi = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n+            Graphics2D g2d = bi.createGraphics();\n+            g2d.drawRenderedImage(img, new AffineTransform());\n+            g2d.dispose();\n+            return bi.getRGB(0, 0, w, h, null, 0, w);\n+        }\n+    }\n+\n+    private static RenderedImage toTiledImage(BufferedImage img, int tileSize) throws Exception {\n+\n+        \/\/ write to TIFF\n+        ImageWriter writer = ImageIO.getImageWritersByFormatName(\"tiff\").next();\n+        ImageWriteParam param = writer.getDefaultWriteParam();\n+        param.setTilingMode(ImageWriteParam.MODE_EXPLICIT);\n+        param.setTiling(tileSize, tileSize, 0, 0);\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ImageOutputStream stream = new MemoryCacheImageOutputStream(baos);\n+        writer.setOutput(stream);\n+        writer.write(null, new IIOImage(img, null, null), param);\n+        writer.dispose();\n+        stream.flush();\n+        byte[] bytes = baos.toByteArray();\n+\n+        \/\/ read from TIFF\n+        ImageReader reader = ImageIO.getImageReadersByFormatName(\"tiff\").next();\n+        ImageInputStream input = ImageIO.createImageInputStream(new ByteArrayInputStream(bytes));\n+        reader.setInput(input);\n+        RenderedImage ri = reader.readAsRenderedImage(0, null);\n+        if (ri instanceof BufferedImage) {\n+            throw new RuntimeException(\"Unexpected BufferedImage\");\n+        }\n+        int tw = ri.getTileWidth();\n+        int th = ri.getTileHeight();\n+        if (tw != tileSize || th != tileSize) {\n+            throw new RuntimeException(\"Expected tile size \" + tileSize +\n+                \", but found \" + tw + \"x\" + th);\n+        }\n+        return ri;\n+    }\n+}\n","filename":"test\/jdk\/javax\/imageio\/plugins\/png\/RasterReuseWriteTest.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"}]}