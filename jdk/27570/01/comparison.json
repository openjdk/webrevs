{"files":[{"patch":"@@ -38,2 +38,0 @@\n-#define SUPPORT_MONITOR_COUNT\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/globalDefinitions_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5633,32 +5633,0 @@\n-void MacroAssembler::inc_held_monitor_count(Register tmp) {\n-  Address dst(rthread, JavaThread::held_monitor_count_offset());\n-#ifdef ASSERT\n-  ldr(tmp, dst);\n-  increment(tmp);\n-  str(tmp, dst);\n-  Label ok;\n-  tbz(tmp, 63, ok);\n-  STOP(\"assert(held monitor count underflow)\");\n-  should_not_reach_here();\n-  bind(ok);\n-#else\n-  increment(dst);\n-#endif\n-}\n-\n-void MacroAssembler::dec_held_monitor_count(Register tmp) {\n-  Address dst(rthread, JavaThread::held_monitor_count_offset());\n-#ifdef ASSERT\n-  ldr(tmp, dst);\n-  decrement(tmp);\n-  str(tmp, dst);\n-  Label ok;\n-  tbz(tmp, 63, ok);\n-  STOP(\"assert(held monitor count underflow)\");\n-  should_not_reach_here();\n-  bind(ok);\n-#else\n-  decrement(dst);\n-#endif\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -986,3 +986,0 @@\n-  void inc_held_monitor_count(Register tmp);\n-  void dec_held_monitor_count(Register tmp);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -988,2 +988,0 @@\n-  __ ldr(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n-  __ str(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n@@ -992,1 +990,0 @@\n-  __ str(zr, Address(rthread, JavaThread::held_monitor_count_offset()));\n@@ -1008,44 +1005,0 @@\n-\n-  if (CheckJNICalls) {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ ldrw(rscratch1, Address(sp, ContinuationEntry::flags_offset()));\n-    __ cbzw(rscratch1, L_skip_vthread_code);\n-\n-    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n-    \/\/ it failed to release a JNI monitor. So we issue the same log message\n-    \/\/ that JavaThread::exit does.\n-    __ ldr(rscratch1, Address(rthread, JavaThread::jni_monitor_count_offset()));\n-    __ cbz(rscratch1, L_skip_vthread_code);\n-\n-    \/\/ Save return value potentially containing the exception oop in callee-saved R19.\n-    __ mov(r19, r0);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n-    \/\/ Restore potential return value.\n-    __ mov(r0, r19);\n-\n-    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n-    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n-    \/\/ the parent held count (which has to be zero).\n-    __ str(zr, Address(rthread, JavaThread::jni_monitor_count_offset()));\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#ifdef ASSERT\n-  else {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ ldrw(rscratch1, Address(sp, ContinuationEntry::flags_offset()));\n-    __ cbzw(rscratch1, L_skip_vthread_code);\n-\n-    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n-    \/\/ needed for assertion checking.\n-    __ str(zr, Address(rthread, JavaThread::jni_monitor_count_offset()));\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#endif\n-\n-  __ ldr(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  __ str(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,0 @@\n-#define SUPPORT_MONITOR_COUNT\n-\n","filename":"src\/hotspot\/cpu\/ppc\/globalDefinitions_ppc.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1642,1 +1642,0 @@\n-  Register tmp3 = R10_ARG8;\n@@ -1658,1 +1657,0 @@\n-  __ ld(tmp3, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n@@ -1660,1 +1658,0 @@\n-  __ std(tmp3, in_bytes(ContinuationEntry::parent_held_monitor_count_offset()), R1_SP);\n@@ -1663,1 +1660,0 @@\n-  __ std(zero, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n@@ -1684,1 +1680,0 @@\n-  Register tmp3 = R10_ARG8;\n@@ -1695,51 +1690,2 @@\n-\n-  if (CheckJNICalls) {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ lwz(R0, in_bytes(ContinuationEntry::flags_offset()), R1_SP);\n-    __ cmpwi(CR0, R0, 0);\n-    __ beq(CR0, L_skip_vthread_code);\n-\n-    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n-    \/\/ it failed to release a JNI monitor. So we issue the same log message\n-    \/\/ that JavaThread::exit does.\n-    __ ld(R0, in_bytes(JavaThread::jni_monitor_count_offset()), R16_thread);\n-    __ cmpdi(CR0, R0, 0);\n-    __ beq(CR0, L_skip_vthread_code);\n-\n-    \/\/ Save return value potentially containing the exception oop\n-    Register ex_oop = R15_esp;   \/\/ nonvolatile register\n-    __ mr(ex_oop, R3_RET);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n-    \/\/ Restore potental return value\n-    __ mr(R3_RET, ex_oop);\n-\n-    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n-    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n-    \/\/ the parent held count (which has to be zero).\n-    __ li(tmp1, 0);\n-    __ std(tmp1, in_bytes(JavaThread::jni_monitor_count_offset()), R16_thread);\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#ifdef ASSERT\n-  else {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ lwz(R0, in_bytes(ContinuationEntry::flags_offset()), R1_SP);\n-    __ cmpwi(CR0, R0, 0);\n-    __ beq(CR0, L_skip_vthread_code);\n-\n-    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n-    \/\/ needed for assertion checking.\n-    __ li(tmp1, 0);\n-    __ std(tmp1, in_bytes(JavaThread::jni_monitor_count_offset()), R16_thread);\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#endif\n-\n-  __ ld(tmp2, in_bytes(ContinuationEntry::parent_held_monitor_count_offset()), R1_SP);\n-  __ ld_ptr(tmp3, ContinuationEntry::parent_offset(), R1_SP);\n-  __ std(tmp2, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n-  __ st_ptr(tmp3, JavaThread::cont_entry_offset(), R16_thread);\n+  __ ld_ptr(tmp2, ContinuationEntry::parent_offset(), R1_SP);\n+  __ st_ptr(tmp2, JavaThread::cont_entry_offset(), R16_thread);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":2,"deletions":56,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,0 @@\n-#define SUPPORT_MONITOR_COUNT\n-\n","filename":"src\/hotspot\/cpu\/riscv\/globalDefinitions_riscv.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -228,30 +228,0 @@\n-void MacroAssembler::inc_held_monitor_count(Register tmp) {\n-  Address dst(xthread, JavaThread::held_monitor_count_offset());\n-  ld(tmp, dst);\n-  addi(tmp, tmp, 1);\n-  sd(tmp, dst);\n-#ifdef ASSERT\n-  Label ok;\n-  test_bit(tmp, tmp, 63);\n-  beqz(tmp, ok);\n-  STOP(\"assert(held monitor count overflow)\");\n-  should_not_reach_here();\n-  bind(ok);\n-#endif\n-}\n-\n-void MacroAssembler::dec_held_monitor_count(Register tmp) {\n-  Address dst(xthread, JavaThread::held_monitor_count_offset());\n-  ld(tmp, dst);\n-  subi(tmp, tmp, 1);\n-  sd(tmp, dst);\n-#ifdef ASSERT\n-  Label ok;\n-  test_bit(tmp, tmp, 63);\n-  beqz(tmp, ok);\n-  STOP(\"assert(held monitor count underflow)\");\n-  should_not_reach_here();\n-  bind(ok);\n-#endif\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -852,3 +852,0 @@\n-  void inc_held_monitor_count(Register tmp);\n-  void dec_held_monitor_count(Register tmp);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -888,2 +888,0 @@\n-  __ ld(t0, Address(xthread, JavaThread::held_monitor_count_offset()));\n-  __ sd(t0, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n@@ -892,1 +890,0 @@\n-  __ sd(zr, Address(xthread, JavaThread::held_monitor_count_offset()));\n@@ -908,44 +905,0 @@\n-\n-  if (CheckJNICalls) {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ lwu(t0, Address(sp, ContinuationEntry::flags_offset()));\n-    __ beqz(t0, L_skip_vthread_code);\n-\n-    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n-    \/\/ it failed to release a JNI monitor. So we issue the same log message\n-    \/\/ that JavaThread::exit does.\n-    __ ld(t0, Address(xthread, JavaThread::jni_monitor_count_offset()));\n-    __ beqz(t0, L_skip_vthread_code);\n-\n-    \/\/ Save return value potentially containing the exception oop in callee-saved x9\n-    __ mv(x9, x10);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n-    \/\/ Restore potential return value\n-    __ mv(x10, x9);\n-\n-    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n-    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n-    \/\/ the parent held count (which has to be zero).\n-    __ sd(zr, Address(xthread, JavaThread::jni_monitor_count_offset()));\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#ifdef ASSERT\n-  else {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ lwu(t0, Address(sp, ContinuationEntry::flags_offset()));\n-    __ beqz(t0, L_skip_vthread_code);\n-\n-    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n-    \/\/ needed for assertion checking.\n-    __ sd(zr, Address(xthread, JavaThread::jni_monitor_count_offset()));\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#endif\n-\n-  __ ld(t0, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  __ sd(t0, Address(xthread, JavaThread::held_monitor_count_offset()));\n-\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-#define SUPPORT_MONITOR_COUNT\n-\n","filename":"src\/hotspot\/cpu\/x86\/globalDefinitions_x86.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2434,8 +2434,0 @@\n-void MacroAssembler::inc_held_monitor_count() {\n-  incrementq(Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-}\n-\n-void MacroAssembler::dec_held_monitor_count() {\n-  decrementq(Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -475,3 +475,0 @@\n-  void inc_held_monitor_count();\n-  void dec_held_monitor_count();\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1355,2 +1355,0 @@\n-  __ movq(rax, Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-  __ movq(Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()), rax);\n@@ -1359,1 +1357,0 @@\n-  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), 0);\n@@ -1383,43 +1380,0 @@\n-\n-  if (CheckJNICalls) {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ cmpl(Address(rsp, ContinuationEntry::flags_offset()), 0);\n-    __ jcc(Assembler::equal, L_skip_vthread_code);\n-\n-    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n-    \/\/ it failed to release a JNI monitor. So we issue the same log message\n-    \/\/ that JavaThread::exit does.\n-    __ cmpptr(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n-    __ jcc(Assembler::equal, L_skip_vthread_code);\n-\n-    \/\/ rax may hold an exception oop, save it before the call\n-    __ push(rax);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n-    __ pop(rax);\n-\n-    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n-    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n-    \/\/ the parent held count (which has to be zero).\n-    __ movq(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#ifdef ASSERT\n-  else {\n-    \/\/ Check if this is a virtual thread continuation\n-    Label L_skip_vthread_code;\n-    __ cmpl(Address(rsp, ContinuationEntry::flags_offset()), 0);\n-    __ jcc(Assembler::equal, L_skip_vthread_code);\n-\n-    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n-    \/\/ needed for assertion checking.\n-    __ movq(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n-\n-    __ bind(L_skip_vthread_code);\n-  }\n-#endif\n-\n-  __ movq(rbx, Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), rbx);\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -259,1 +259,0 @@\n-  nonstatic_field(JavaThread,                  _held_monitor_count,                           intx)                                  \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,4 +56,3 @@\n-  freeze_pinned_monitor = 4,\n-  freeze_exception = 5,\n-  freeze_not_mounted = 6,\n-  freeze_unsupported = 7\n+  freeze_exception = 4,\n+  freeze_not_mounted = 5,\n+  freeze_unsupported = 6\n","filename":"src\/hotspot\/share\/runtime\/continuation.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-  values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_held_monitor_count_offset())), \"parent held monitor count\");\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,5 +82,0 @@\n-#ifdef _LP64\n-  int64_t   _parent_held_monitor_count;\n-#else\n-  int32_t   _parent_held_monitor_count;\n-#endif\n@@ -97,1 +92,0 @@\n-  static ByteSize parent_held_monitor_count_offset() { return byte_offset_of(ContinuationEntry, _parent_held_monitor_count); }\n@@ -106,1 +100,0 @@\n-  int64_t parent_held_monitor_count() const { return (int64_t)_parent_held_monitor_count; }\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1739,5 +1739,2 @@\n-  assert((current->held_monitor_count() == 0 && current->jni_monitor_count() == 0),\n-         \"Held monitor count should not be used for lightweight locking: \" INT64_FORMAT \" JNI: \" INT64_FORMAT, (int64_t)current->held_monitor_count(), (int64_t)current->jni_monitor_count());\n-\n-  if (entry->is_pinned() || current->held_monitor_count() > 0) {\n-    log_develop_debug(continuations)(\"PINNED due to critical section\/hold monitor\");\n+  if (entry->is_pinned()) {\n+    log_develop_debug(continuations)(\"PINNED due to critical section\");\n@@ -1745,1 +1742,1 @@\n-    freeze_result res = entry->is_pinned() ? freeze_pinned_cs : freeze_pinned_monitor;\n+    const freeze_result res = freeze_pinned_cs;\n@@ -1802,2 +1799,0 @@\n-  } else if (thread->held_monitor_count() > 0) {\n-    return freeze_pinned_monitor;\n@@ -1839,1 +1834,0 @@\n-      intx monitor_count = entry->parent_held_monitor_count();\n@@ -1846,2 +1840,0 @@\n-      } else if (monitor_count > 0) {\n-        return freeze_pinned_monitor;\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -492,2 +492,0 @@\n-  _held_monitor_count(0),\n-  _jni_monitor_count(0),\n@@ -931,21 +929,0 @@\n-    \/\/ Check for monitor counts being out of sync.\n-    assert(held_monitor_count() == jni_monitor_count(),\n-           \"held monitor count should be equal to jni: %zd != %zd\",\n-           held_monitor_count(), jni_monitor_count());\n-    \/\/ All in-use monitors, including JNI-locked ones, should have been released above.\n-    assert(held_monitor_count() == 0, \"Failed to unlock %zd object monitors\",\n-           held_monitor_count());\n-  } else {\n-    \/\/ Check for monitor counts being out of sync.\n-    assert(held_monitor_count() == jni_monitor_count(),\n-           \"held monitor count should be equal to jni: %zd != %zd\",\n-           held_monitor_count(), jni_monitor_count());\n-    \/\/ It is possible that a terminating thread failed to unlock monitors it locked\n-    \/\/ via JNI so we don't assert the count is zero.\n-  }\n-\n-  if (CheckJNICalls && jni_monitor_count() > 0) {\n-    \/\/ We would like a fatal here, but due to we never checked this before there\n-    \/\/ is a lot of tests which breaks, even with an error log.\n-    log_debug(jni)(\"JavaThread %s (tid: %zu) with Objects still locked by JNI MonitorEnter.\",\n-                   exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\", os::current_thread_id());\n@@ -1992,20 +1969,0 @@\n-\/\/ Slow-path increment of the held monitor counts. JNI locking is always\n-\/\/ this slow-path.\n-void JavaThread::inc_held_monitor_count(intx i, bool jni) {\n-#ifdef SUPPORT_MONITOR_COUNT\n-  \/\/ Nothing to do. Just do some sanity check.\n-  assert(_held_monitor_count == 0, \"counter should not be used\");\n-  assert(_jni_monitor_count == 0, \"counter should not be used\");\n-#endif \/\/ SUPPORT_MONITOR_COUNT\n-}\n-\n-\/\/ Slow-path decrement of the held monitor counts. JNI unlocking is always\n-\/\/ this slow-path.\n-void JavaThread::dec_held_monitor_count(intx i, bool jni) {\n-#ifdef SUPPORT_MONITOR_COUNT\n-  \/\/ Nothing to do. Just do some sanity check.\n-  assert(_held_monitor_count == 0, \"counter should not be used\");\n-  assert(_jni_monitor_count == 0, \"counter should not be used\");\n-#endif \/\/ SUPPORT_MONITOR_COUNT\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -480,3 +480,0 @@\n-  \/\/ It's signed for error detection.\n-  intx _held_monitor_count;  \/\/ used by continuations for fast lock detection\n-  intx _jni_monitor_count;\n@@ -666,7 +663,0 @@\n-  void inc_held_monitor_count(intx i = 1, bool jni = false);\n-  void dec_held_monitor_count(intx i = 1, bool jni = false);\n-\n-  intx held_monitor_count() { return _held_monitor_count; }\n-  intx jni_monitor_count()  { return _jni_monitor_count;  }\n-  void clear_jni_monitor_count() { _jni_monitor_count = 0; }\n-\n@@ -903,2 +893,0 @@\n-  static ByteSize held_monitor_count_offset() { return byte_offset_of(JavaThread, _held_monitor_count); }\n-  static ByteSize jni_monitor_count_offset()  { return byte_offset_of(JavaThread, _jni_monitor_count); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1955,1 +1955,0 @@\n-  current->inc_held_monitor_count(relock_count); \/\/ Deopt never entered these counts.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1988,1 +1988,0 @@\n-      current->dec_held_monitor_count();\n@@ -2010,14 +2009,0 @@\n-\/\/ This is only called when CheckJNICalls is true, and only\n-\/\/ for virtual thread termination.\n-JRT_LEAF(void,  SharedRuntime::log_jni_monitor_still_held())\n-  assert(CheckJNICalls, \"Only call this when checking JNI usage\");\n-  if (log_is_enabled(Debug, jni)) {\n-    JavaThread* current = JavaThread::current();\n-    int64_t vthread_id = java_lang_Thread::thread_id(current->vthread());\n-    int64_t carrier_id = java_lang_Thread::thread_id(current->threadObj());\n-    log_debug(jni)(\"VirtualThread (tid: \" INT64_FORMAT \", carrier id: \" INT64_FORMAT\n-                   \") exiting with Objects still locked by JNI MonitorEnter.\",\n-                   vthread_id, carrier_id);\n-  }\n-JRT_END\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -407,3 +407,0 @@\n-  \/\/ Issue UL warning for unlocked JNI monitor on virtual thread termination\n-  static void log_jni_monitor_still_held();\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -455,1 +455,0 @@\n-      current->inc_held_monitor_count(1, true);\n@@ -473,1 +472,0 @@\n-    current->dec_held_monitor_count(1, true);\n@@ -1266,2 +1264,1 @@\n-    intx rec = mid->complete_exit(_thread);\n-    _thread->dec_held_monitor_count(rec + 1);\n+    mid->complete_exit(_thread);\n@@ -1293,3 +1290,0 @@\n-  assert(current->held_monitor_count() == 0, \"Should not be possible\");\n-  \/\/ All monitors (including entered via JNI) have been unlocked above, so we need to clear jni count.\n-  current->clear_jni_monitor_count();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,2 +64,0 @@\n-  current->dec_held_monitor_count();\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,0 @@\n-        \/** Monitor held *\/          MONITOR,\n@@ -72,2 +71,1 @@\n-        \/** Transient failure: continuation pinned due to native frame *\/   TRANSIENT_FAIL_PINNED_NATIVE(Pinned.NATIVE),\n-        \/** Transient failure: continuation pinned due to a held monitor *\/ TRANSIENT_FAIL_PINNED_MONITOR(Pinned.MONITOR);\n+        \/** Transient failure: continuation pinned due to native frame *\/   TRANSIENT_FAIL_PINNED_NATIVE(Pinned.NATIVE);\n@@ -88,2 +86,1 @@\n-            case 4 -> Pinned.MONITOR;\n-            case 5 -> Pinned.EXCEPTION;\n+            case 4 -> Pinned.EXCEPTION;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"}]}