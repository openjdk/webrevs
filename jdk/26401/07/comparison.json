{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,3 +76,6 @@\n-        \/\/ threads the process is allowed to create, so we hit that limit first.\n-\n-        final String ULIMIT_CMD = \"ulimit -u 4096\";\n+        \/\/ threads the process is allowed to create, so we hit that limit first. What we want is\n+        \/\/ for another \"limit\" processes to be available, but ulimit doesn't work that way and\n+        \/\/ if there are already many running processes we could fail to even start the JVM properly.\n+        \/\/ So we loop increasing the limit until we get a successful run. This is not foolproof.\n+        int pLimit = 4096;\n+        final String ULIMIT_CMD = \"ulimit -u \";\n@@ -81,3 +84,13 @@\n-        \/\/ Relaunch the test with args.length > 0, and the ulimit set\n-        ProcessTools.executeCommand(\"bash\", \"-c\", ULIMIT_CMD + \" && \" + javaCmd + \" dummy\")\n-                    .shouldHaveExitValue(0);\n+        for (int i = 1; i <= 10; i++) {\n+            \/\/ Relaunch the test with args.length > 0, and the ulimit set\n+            String cmd = ULIMIT_CMD + Integer.toString(pLimit * i) + \" && \" + javaCmd + \" dummy\";\n+            System.out.println(\"Trying: bash -c \" + cmd);\n+            OutputAnalyzer oa = ProcessTools.executeCommand(\"bash\", \"-c\", cmd);\n+            int exitValue = oa.getExitValue();\n+            switch (exitValue) {\n+              case 0: System.out.println(\"Success!\"); return;\n+              case 1: System.out.println(\"Retry ...\"); continue;\n+              default: oa.shouldHaveExitValue(0); \/\/ generate error report\n+            }\n+        }\n+        throw new Error(\"Failed to perform a successful run!\");\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/ThreadCountLimit.java","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"}]}