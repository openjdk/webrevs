{"files":[{"patch":"@@ -549,0 +549,14 @@\n+### libsleef\n+\n+libsleef, the [SIMD Library for Evaluating Elementary Functions](\n+https:\/\/sleef.org\/) is required when building libvmath.so on Linux+AArch64\n+platforms.\n+\n+  * To install on an apt-based Linux, try running `sudo apt-get install\n+    libsleef-dev`.\n+  * To install on an rpm-based Linux, try running `sudo yum install\n+    sleef-devel`.\n+\n+Use `--with-libsleef=<path>` if `configure` does not properly locate your libsleef\n+files.\n+\n","filename":"doc\/building.md","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+#\n+# Copyright (c) 2023, Arm Limited. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+###############################################################################\n+#\n+# Setup vmath framework and check its dependences\n+#\n+AC_DEFUN_ONCE([LIB_SETUP_VMATH],\n+[\n+  AC_ARG_WITH(libsleef, [AS_HELP_STRING([--with-libsleef],\n+      [specify prefix directory for the libsleef library\n+      (expecting the libraries under PATH\/lib and the headers under PATH\/include)])])\n+\n+  LIBSLEEF_FOUND=no\n+  LIBVMATH_CFLAGS=\n+  LIBVMATH_LIBS=\n+\n+  if test \"x${with_libsleef}\" = xno; then\n+    AC_MSG_NOTICE([libvmath will not be compiled, because its dependence libsleef is disabled in command line])\n+  else\n+    # Check the specified libsleef.so\n+    if test \"x${with_libsleef}\" != x; then\n+      AC_MSG_CHECKING([the specified LIBSLEEF])\n+      if test -e ${with_libsleef}\/lib\/libsleef.so &&\n+         test -e ${with_libsleef}\/include\/sleef.h; then\n+        LIBSLEEF_FOUND=yes\n+        LIBVMATH_LIBS=\"-L${with_libsleef}\/lib\"\n+        LIBVMATH_CFLAGS=\"-I${with_libsleef}\/include\"\n+      else\n+        AC_MSG_ERROR([Could not locate libsleef.so or sleef.h in ${with_libsleef}])\n+      fi\n+      AC_MSG_RESULT([${LIBSLEEF_FOUND}])\n+    fi\n+\n+    # Check the system locations if libsleef is not specified with option\n+    if test \"x$SYSROOT\" = x && test \"x${LIBSLEEF_FOUND}\" = \"xno\"; then\n+      PKG_CHECK_MODULES([LIBSLEEF], [sleef], [LIBSLEEF_FOUND=yes], [LIBSLEEF_FOUND=no])\n+    fi\n+    if test \"x$LIBSLEEF_FOUND\" = xno; then\n+      AC_CHECK_HEADERS([sleef.h],\n+          [LIBSLEEF_FOUND=yes],\n+          []\n+      )\n+    fi\n+\n+    if test \"x${LIBSLEEF_FOUND}\" = \"xyes\"; then\n+      LIBVMATH_LIBS=\"${LIBVMATH_LIBS} -lsleef\"\n+\n+      if test \"x${OPENJDK_TARGET_CPU}\" = \"xaarch64\"; then\n+        # Check the ARM SVE feature\n+        SVE_FEATURE_SUPPORT=no\n+        SVE_CFLAGS=\"-march=armv8-a+sve\"\n+\n+        AC_LANG_PUSH(C)\n+        OLD_CFLAGS=\"$CFLAGS\"\n+        CFLAGS=\"$CFLAGS $SVE_CFLAGS\"\n+\n+        AC_MSG_CHECKING([if ARM SVE feature is supported])\n+        AC_COMPILE_IFELSE([AC_LANG_PROGRAM([#include <arm_sve.h>],\n+            [\n+              svint32_t r = svdup_n_s32(1);\n+              return 0;\n+            ])],\n+            [\n+              SVE_FEATURE_SUPPORT=yes\n+              LIBVMATH_CFLAGS=\"${LIBVMATH_CFLAGS} ${SVE_CFLAGS}\"\n+            ],\n+            []\n+        )\n+        AC_MSG_RESULT([${SVE_FEATURE_SUPPORT}])\n+\n+        CFLAGS=\"$OLD_CFLAGS\"\n+        AC_LANG_POP(C)\n+      fi\n+\n+    fi\n+\n+  fi\n+\n+  AC_SUBST(LIBSLEEF_FOUND)\n+  AC_SUBST(LIBVMATH_CFLAGS)\n+  AC_SUBST(LIBVMATH_LIBS)\n+])\n","filename":"make\/autoconf\/lib-vmath.m4","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+m4_include([lib-vmath.m4])\n@@ -128,0 +129,1 @@\n+  LIB_SETUP_VMATH\n","filename":"make\/autoconf\/libraries.m4","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -892,0 +892,3 @@\n+LIBSLEEF_FOUND:=@LIBSLEEF_FOUND@\n+LIBVMATH_CFLAGS:=@LIBVMATH_CFLAGS@\n+LIBVMATH_LIBS:=@LIBVMATH_LIBS@\n","filename":"make\/autoconf\/spec.gmk.in","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,12 @@\n+ifeq ($(call isTargetOs, linux)+$(call isTargetCpu, aarch64)+$(INCLUDE_COMPILER2)+$(LIBSLEEF_FOUND), true+true+true+yes)\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBVMATH, \\\n+      NAME := vmath, \\\n+      CFLAGS := $(CFLAGS_JDKLIB) $(LIBVMATH_CFLAGS) -fvisibility=default, \\\n+      LDFLAGS := $(LDFLAGS_JDKLIB) \\\n+          $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+      LIBS := $(JDKLIB_LIBS) $(LIBVMATH_LIBS) \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBVMATH)\n+endif\n+\n","filename":"make\/modules\/jdk.incubator.vector\/Lib.gmk","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2329,1 +2329,0 @@\n-\/\/ Vector calling convention not yet implemented.\n@@ -2331,1 +2330,1 @@\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n@@ -2335,2 +2334,7 @@\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  int lo = V0_num;\n+  int hi = V0_H_num;\n+  if (ideal_reg == Op_VecX || ideal_reg == Op_VecA) {\n+    hi = V0_K_num;\n+  }\n+  return OptoRegPair(hi, lo);\n@@ -16551,0 +16555,16 @@\n+\/\/ Call Runtime Instruction without safepoint and with vector arguments\n+instruct CallLeafDirectVector(method meth)\n+%{\n+  match(CallLeafVector);\n+\n+  effect(USE meth);\n+\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"CALL, runtime leaf vector $meth\" %}\n+\n+  ins_encode(aarch64_enc_java_to_runtime(meth));\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -894,1 +894,14 @@\n-  Unimplemented();\n+  \/\/ More than 8 argument inputs are not supported now.\n+  assert(total_args_passed <= Argument::n_float_register_parameters_c, \"unsupported\");\n+  assert(num_bits >= 64 && num_bits <= 2048 && is_power_of_2(num_bits), \"unsupported\");\n+\n+  static const FloatRegister VEC_ArgReg[Argument::n_float_register_parameters_c] = {\n+    v0, v1, v2, v3, v4, v5, v6, v7\n+  };\n+\n+  \/\/ On SVE, we use the same vector registers with 128-bit vector registers on NEON.\n+  int next_reg_val = num_bits == 64 ? 1 : 3;\n+  for (uint i = 0; i < total_args_passed; i++) {\n+    VMReg vmreg = VEC_ArgReg[i]->as_VMReg();\n+    regs[i].set_pair(vmreg->next(next_reg_val), vmreg);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/arguments.hpp\"\n@@ -8509,0 +8510,66 @@\n+\n+#ifdef COMPILER2\n+    \/\/ Get native vector math stub routine addresses\n+    void* libvmath = nullptr;\n+    char ebuf[1024];\n+    char dll_name[JVM_MAXPATHLEN];\n+    if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"vmath\")) {\n+      libvmath = os::dll_load(dll_name, ebuf, sizeof ebuf);\n+    }\n+    if (libvmath != nullptr) {\n+      \/\/ Method naming convention\n+      \/\/   All the methods are named as <OP><T><N>_<U><suffix>\n+      \/\/   Where:\n+      \/\/     <OP>     is the operation name, e.g. sin\n+      \/\/     <T>      is optional to indicate float\/double\n+      \/\/              \"f\/d\" for vector float\/double operation\n+      \/\/     <N>      is the number of elements in the vector\n+      \/\/              \"2\/4\" for neon, and \"x\" for sve\n+      \/\/     <U>      is the precision level\n+      \/\/              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n+      \/\/               We use \"u10\" for all operations by default\n+      \/\/               But for those functions do not have u10 support, we use \"u05\" instead\n+      \/\/     <suffix> indicates neon\/sve\n+      \/\/              \"sve\/advsimd\" for sve\/neon implementations\n+      \/\/     e.g. sinfx_u10sve is the method for computing vector float sin using SVE instructions\n+      \/\/          cosd2_u10advsimd is the method for computing 2 elements vector double cos using NEON instructions\n+      \/\/\n+      log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"vmath\" JNI_LIB_SUFFIX, p2i(libvmath));\n+\n+      \/\/ Math vector stubs implemented with SVE for scalable vector size.\n+      if (UseSVE > 0) {\n+        for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+          int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n+\n+          \/\/ The native library does not support u10 level of \"hypot\".\n+          const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n+\n+          snprintf(ebuf, sizeof(ebuf), \"%sfx_%ssve\", VectorSupport::mathname[op], ulf);\n+          StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libvmath, ebuf);\n+\n+          snprintf(ebuf, sizeof(ebuf), \"%sdx_%ssve\", VectorSupport::mathname[op], ulf);\n+          StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libvmath, ebuf);\n+        }\n+      }\n+\n+      \/\/ Math vector stubs implemented with NEON for 64\/128 bits vector size.\n+      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n+\n+        \/\/ The native library does not support u10 level of \"hypot\".\n+        const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n+\n+        snprintf(ebuf, sizeof(ebuf), \"%sf4_%sadvsimd\", VectorSupport::mathname[op], ulf);\n+        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_64][op] = (address)os::dll_lookup(libvmath, ebuf);\n+\n+        snprintf(ebuf, sizeof(ebuf), \"%sf4_%sadvsimd\", VectorSupport::mathname[op], ulf);\n+        StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libvmath, ebuf);\n+\n+        snprintf(ebuf, sizeof(ebuf), \"%sd2_%sadvsimd\", VectorSupport::mathname[op], ulf);\n+        StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_128][op] = (address)os::dll_lookup(libvmath, ebuf);\n+      }\n+    } else {\n+      log_info(library)(\"Failed to load native vector math library!\");\n+    }\n+#endif \/\/ COMPILER2\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -4241,2 +4241,2 @@\n-      for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n-        int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n@@ -4247,1 +4247,1 @@\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::svmlname[op]);\n+        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::mathname[op]);\n@@ -4250,1 +4250,1 @@\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::svmlname[op]);\n+        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::mathname[op]);\n@@ -4255,2 +4255,2 @@\n-    for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n-      int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n@@ -4260,1 +4260,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4263,1 +4263,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4266,1 +4266,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4269,1 +4269,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4272,1 +4272,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4275,1 +4275,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-      if(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ) {\n+      if(ideal_reg >= Op_VecA && ideal_reg <= Op_VecZ) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -366,1 +366,1 @@\n-  Node* gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n+  Node* gen_call_to_vector_math(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -540,1 +540,1 @@\n-    operation = gen_call_to_svml(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n+    operation = gen_call_to_vector_math(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n@@ -543,3 +543,3 @@\n-        tty->print_cr(\"  ** svml call failed for %s_%s_%d\",\n-                         (elem_bt == T_FLOAT)?\"float\":\"double\",\n-                         VectorSupport::svmlname[opr->get_con() - VectorSupport::VECTOR_OP_SVML_START],\n+        tty->print_cr(\"  ** Vector math call failed for %s_%s_%d\",\n+                         (elem_bt == T_FLOAT) ? \"float\" : \"double\",\n+                         VectorSupport::mathname[opr->get_con() - VectorSupport::VECTOR_OP_MATH_START],\n@@ -2159,1 +2159,1 @@\n-static address get_svml_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {\n+static address get_vector_math_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {\n@@ -2163,2 +2163,2 @@\n-  assert((vop >= VectorSupport::VECTOR_OP_SVML_START) && (vop <= VectorSupport::VECTOR_OP_SVML_END), \"unexpected\");\n-  int op = vop - VectorSupport::VECTOR_OP_SVML_START;\n+  assert((vop >= VectorSupport::VECTOR_OP_MATH_START) && (vop <= VectorSupport::VECTOR_OP_MATH_END), \"unexpected\");\n+  int op = vop - VectorSupport::VECTOR_OP_MATH_START;\n@@ -2172,1 +2172,1 @@\n-        snprintf(name_ptr, name_len, \"vector_%s_float%d\", VectorSupport::svmlname[op], bits);\n+        snprintf(name_ptr, name_len, \"vector_%s_float_%dbits\", VectorSupport::mathname[op], bits);\n@@ -2176,1 +2176,1 @@\n-        snprintf(name_ptr, name_len, \"vector_%s_double%d\", VectorSupport::svmlname[op], bits);\n+        snprintf(name_ptr, name_len, \"vector_%s_double_%dbits\", VectorSupport::mathname[op], bits);\n@@ -2187,0 +2187,10 @@\n+  if (addr == nullptr && Matcher::supports_scalable_vector()) {\n+    if (bt == T_FLOAT) {\n+      snprintf(name_ptr, name_len, \"vector_%s_float_%dbits\", VectorSupport::mathname[op], bits);\n+      addr = StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n+    } else {\n+      assert(bt == T_DOUBLE, \"must be FP type only\");\n+      snprintf(name_ptr, name_len, \"vector_%s_double_%dbits\", VectorSupport::mathname[op], bits);\n+      addr = StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n+    }\n+  }\n@@ -2190,1 +2200,1 @@\n-Node* LibraryCallKit::gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n+Node* LibraryCallKit::gen_call_to_vector_math(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n@@ -2192,1 +2202,1 @@\n-  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_SVML_START && vector_api_op_id <= VectorSupport::VECTOR_OP_SVML_END, \"need valid op id\");\n+  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_MATH_START && vector_api_op_id <= VectorSupport::VECTOR_OP_MATH_END, \"need valid op id\");\n@@ -2198,2 +2208,2 @@\n-  \/\/ Get address for svml method.\n-  address addr = get_svml_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);\n+  \/\/ Get address for vector math method.\n+  address addr = get_vector_math_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-const char* VectorSupport::svmlname[VectorSupport::NUM_SVML_OP] = {\n+const char* VectorSupport::mathname[VectorSupport::NUM_VECTOR_OP_MATH] = {\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,3 +124,3 @@\n-    VECTOR_OP_SVML_START = VECTOR_OP_TAN,\n-    VECTOR_OP_SVML_END   = VECTOR_OP_HYPOT,\n-    NUM_SVML_OP = VECTOR_OP_SVML_END - VECTOR_OP_SVML_START + 1\n+    VECTOR_OP_MATH_START = VECTOR_OP_TAN,\n+    VECTOR_OP_MATH_END   = VECTOR_OP_HYPOT,\n+    NUM_VECTOR_OP_MATH   = VECTOR_OP_MATH_END - VECTOR_OP_MATH_START + 1\n@@ -134,1 +134,2 @@\n-    NUM_VEC_SIZES = 4\n+    VEC_SIZE_SCALABLE = 4,\n+    NUM_VEC_SIZES = 5\n@@ -142,1 +143,1 @@\n-  static const char* svmlname[VectorSupport::NUM_SVML_OP];\n+  static const char* mathname[VectorSupport::NUM_VECTOR_OP_MATH];\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -176,2 +176,2 @@\n-address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n-address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -269,2 +269,2 @@\n-  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n-  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n+  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n+  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <sleef.h>\n+\n+#define DEFINE_VECTOR_MATH_UNARY(op, type, cpu) \\\n+type op##cpu(type input) {                      \\\n+  return Sleef_##op##cpu(input);                \\\n+}\n+\n+DEFINE_VECTOR_MATH_UNARY(tanf4_u10,   float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(tanhf4_u10,  float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(sinf4_u10,   float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(sinhf4_u10,  float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(cosf4_u10,   float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(coshf4_u10,  float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(asinf4_u10,  float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(acosf4_u10,  float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(atanf4_u10,  float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(cbrtf4_u10,  float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(logf4_u10,   float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(log10f4_u10, float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(log1pf4_u10, float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(expf4_u10,   float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(expm1f4_u10, float32x4_t, advsimd)\n+\n+DEFINE_VECTOR_MATH_UNARY(tand2_u10,   float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(tanhd2_u10,  float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(sind2_u10,   float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(sinhd2_u10,  float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(cosd2_u10,   float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(coshd2_u10,  float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(asind2_u10,  float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(acosd2_u10,  float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(atand2_u10,  float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(cbrtd2_u10,  float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(logd2_u10,   float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(log10d2_u10, float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(log1pd2_u10, float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(expd2_u10,   float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_UNARY(expm1d2_u10, float64x2_t, advsimd)\n+\n+#ifdef __ARM_FEATURE_SVE\n+DEFINE_VECTOR_MATH_UNARY(tanfx_u10,   svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(sinfx_u10,   svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(sinhfx_u10,  svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(cosfx_u10,   svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(coshfx_u10,  svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(asinfx_u10,  svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(acosfx_u10,  svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(atanfx_u10,  svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(cbrtfx_u10,  svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(logfx_u10,   svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(log10fx_u10, svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(log1pfx_u10, svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(expfx_u10,   svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(expm1fx_u10, svfloat32_t, sve)\n+\n+DEFINE_VECTOR_MATH_UNARY(tandx_u10,   svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(sindx_u10,   svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(sinhdx_u10,  svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(cosdx_u10,   svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(coshdx_u10,  svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(asindx_u10,  svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(acosdx_u10,  svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(atandx_u10,  svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(cbrtdx_u10,  svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(logdx_u10,   svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(log10dx_u10, svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(log1pdx_u10, svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(expdx_u10,   svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_UNARY(expm1dx_u10, svfloat64_t, sve)\n+#endif \/* __ARM_FEATURE_SVE *\/\n+\n+#undef DEFINE_VECTOR_MATH_UNARY\n+\n+#define DEFINE_VECTOR_MATH_BINARY(op, type, cpu) \\\n+type op##cpu(type input1, type input2) {         \\\n+  return Sleef_##op##cpu(input1, input2);        \\\n+}\n+\n+DEFINE_VECTOR_MATH_BINARY(atan2f4_u10, float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_BINARY(powf4_u10,   float32x4_t, advsimd)\n+DEFINE_VECTOR_MATH_BINARY(hypotf4_u05, float32x4_t, advsimd)\n+\n+DEFINE_VECTOR_MATH_BINARY(atan2d2_u10, float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_BINARY(powd2_u10,   float64x2_t, advsimd)\n+DEFINE_VECTOR_MATH_BINARY(hypotd2_u05, float64x2_t, advsimd)\n+\n+#ifdef __ARM_FEATURE_SVE\n+DEFINE_VECTOR_MATH_BINARY(atan2fx_u10, svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_BINARY(powfx_u10,   svfloat32_t, sve)\n+DEFINE_VECTOR_MATH_BINARY(hypotfx_u05, svfloat32_t, sve)\n+\n+DEFINE_VECTOR_MATH_BINARY(atan2dx_u10, svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_BINARY(powdx_u10,   svfloat64_t, sve)\n+DEFINE_VECTOR_MATH_BINARY(hypotdx_u05, svfloat64_t, sve)\n+#endif \/* __ARM_FEATURE_SVE *\/\n+\n+#undef DEFINE_VECTOR_MATH_BINARY\n+\n","filename":"src\/jdk.incubator.vector\/linux\/native\/libvmath\/vect_math.c","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"}]}