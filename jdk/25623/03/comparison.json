{"files":[{"patch":"@@ -41,1 +41,1 @@\n-  static const uint strong_count = 4 JVMTI_ONLY(+ 1);\n+  static const uint strong_count = 4 JVMTI_ONLY(+ 1) CDS_ONLY(+ 1);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+  \/\/ This has to be done because OopStorageSet expects it.\n+  training_data_set()->initialize_oopstorage();\n@@ -435,19 +437,3 @@\n-  if (holder() == klass) {\n-    return;   \/\/ no change to make\n-  }\n-\n-  jobject hmj = _holder_mirror;\n-  if (hmj != nullptr) {   \/\/ clear out previous handle, if any\n-    _holder_mirror = nullptr;\n-    assert(JNIHandles::is_global_handle(hmj), \"\");\n-    JNIHandles::destroy_global(hmj);\n-  }\n-\n-  if (klass != nullptr) {\n-    Handle hm(JavaThread::current(), klass->java_mirror());\n-    hmj = JNIHandles::make_global(hm);\n-    Atomic::release_store(&_holder_mirror, hmj);\n-  }\n-\n-  Atomic::release_store(&_holder, const_cast<InstanceKlass*>(klass));\n-  assert(holder() == klass, \"\");\n+  assert(klass != nullptr, \"\");\n+  training_data_set()->keep_alive(klass);\n+  _holder = klass;\n@@ -775,1 +761,0 @@\n-  _holder_mirror = nullptr;\n","filename":"src\/hotspot\/share\/oops\/trainingData.cpp","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#include \"gc\/shared\/oopStorage.hpp\"\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n@@ -35,0 +37,1 @@\n+#include \"oops\/access.hpp\"\n@@ -39,0 +42,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -175,0 +179,1 @@\n+    friend KlassTrainingData;\n@@ -181,0 +186,9 @@\n+    OopStorage* _mirror_refs;\n+    void keep_alive(InstanceKlass* klass) {\n+      assert(_mirror_refs != nullptr, \"Did you forget to call initialize()?\");\n+      oop* handle = _mirror_refs->allocate();\n+      if (handle == nullptr) {\n+        vm_exit_out_of_memory(sizeof(oop), OOM_MALLOC_ERROR, \"Cannot allocate oop storage for mirror\");\n+      }\n+      NativeAccess<>::oop_store(handle, klass->java_mirror());\n+    }\n@@ -184,1 +198,5 @@\n-      : _table(arg...) {\n+      : _table(arg...), _mirror_refs(nullptr) {\n+    }\n+    void initialize_oopstorage() {\n+      assert(_mirror_refs == nullptr, \"Already initialized\");\n+      _mirror_refs = OopStorageSet::create_strong(\"Training OopStorage\", mtInternal);\n@@ -420,1 +438,0 @@\n-  jobject _holder_mirror;   \/\/ extra link to prevent unloading by GC\n","filename":"src\/hotspot\/share\/oops\/trainingData.hpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -192,4 +192,1 @@\n-  \/\/ Initialize TrainingData only we're recording\/replaying\n-  if (TrainingData::have_data() || TrainingData::need_data()) {\n-   TrainingData::initialize();\n-  }\n+  TrainingData::initialize();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+            \"Training OopStorage\",\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}