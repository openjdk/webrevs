{"files":[{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/ptrQueue.hpp\"\n+#include \"gc\/shared\/satbMarkQueue.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-  nonstatic_field(PtrQueue,            _buf,            void**)               \\\n-  nonstatic_field(PtrQueue,            _index,          size_t)\n+  nonstatic_field(SATBMarkQueue,       _buf,            void**)               \\\n+  nonstatic_field(SATBMarkQueue,       _index,          size_t)\n@@ -99,1 +99,0 @@\n-  declare_toplevel_type(PtrQueue)                                             \\\n","filename":"src\/hotspot\/share\/gc\/g1\/vmStructs_g1.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"gc\/shared\/bufferNode.hpp\"\n-#include \"gc\/shared\/ptrQueue.hpp\"\n-\n-PtrQueue::PtrQueue(PtrQueueSet* qset) :\n-  _index(0),\n-  _buf(nullptr)\n-{}\n-\n-PtrQueue::~PtrQueue() {\n-  assert(_buf == nullptr, \"queue must be flushed before delete\");\n-}\n-\n-size_t PtrQueue::current_capacity() const {\n-  if (_buf == nullptr) {\n-    return 0;\n-  } else {\n-    return BufferNode::make_node_from_buffer(_buf)->capacity();\n-  }\n-}\n-\n-PtrQueueSet::PtrQueueSet(BufferNode::Allocator* allocator) :\n-  _allocator(allocator)\n-{}\n-\n-PtrQueueSet::~PtrQueueSet() {}\n-\n-void PtrQueueSet::reset_queue(PtrQueue& queue) {\n-  queue.set_index(queue.current_capacity());\n-}\n-\n-void PtrQueueSet::flush_queue(PtrQueue& queue) {\n-  void** buffer = queue.buffer();\n-  if (buffer != nullptr) {\n-    size_t index = queue.index();\n-    queue.set_buffer(nullptr);\n-    queue.set_index(0);\n-    BufferNode* node = BufferNode::make_node_from_buffer(buffer, index);\n-    if (index == node->capacity()) {\n-      deallocate_buffer(node);\n-    } else {\n-      enqueue_completed_buffer(node);\n-    }\n-  }\n-}\n-\n-bool PtrQueueSet::try_enqueue(PtrQueue& queue, void* value) {\n-  size_t index = queue.index();\n-  if (index == 0) return false;\n-  void** buffer = queue.buffer();\n-  assert(buffer != nullptr, \"no buffer but non-zero index\");\n-  buffer[--index] = value;\n-  queue.set_index(index);\n-  return true;\n-}\n-\n-void PtrQueueSet::retry_enqueue(PtrQueue& queue, void* value) {\n-  assert(queue.index() != 0, \"precondition\");\n-  assert(queue.buffer() != nullptr, \"precondition\");\n-  size_t index = queue.index();\n-  queue.buffer()[--index] = value;\n-  queue.set_index(index);\n-}\n-\n-BufferNode* PtrQueueSet::exchange_buffer_with_new(PtrQueue& queue) {\n-  BufferNode* node = nullptr;\n-  void** buffer = queue.buffer();\n-  if (buffer != nullptr) {\n-    node = BufferNode::make_node_from_buffer(buffer, queue.index());\n-  }\n-  install_new_buffer(queue);\n-  return node;\n-}\n-\n-void PtrQueueSet::install_new_buffer(PtrQueue& queue) {\n-  BufferNode* node = _allocator->allocate();\n-  queue.set_buffer(BufferNode::make_buffer_from_node(node));\n-  queue.set_index(node->capacity());\n-}\n-\n-void** PtrQueueSet::allocate_buffer() {\n-  BufferNode* node = _allocator->allocate();\n-  return BufferNode::make_buffer_from_node(node);\n-}\n-\n-void PtrQueueSet::deallocate_buffer(BufferNode* node) {\n-  _allocator->release(node);\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.cpp","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -1,168 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_PTRQUEUE_HPP\n-#define SHARE_GC_SHARED_PTRQUEUE_HPP\n-\n-#include \"gc\/shared\/bufferNode.hpp\"\n-#include \"utilities\/align.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/sizes.hpp\"\n-\n-\/\/ There are various techniques that require threads to be able to log\n-\/\/ addresses.  For example, a generational write barrier might log\n-\/\/ the addresses of modified old-generation objects.  This type supports\n-\/\/ this operation.\n-\n-class PtrQueueSet;\n-class PtrQueue {\n-  friend class VMStructs;\n-\n-  NONCOPYABLE(PtrQueue);\n-\n-  \/\/ The (byte) index at which an object was last enqueued.  Starts at\n-  \/\/ capacity (in bytes) (indicating an empty buffer) and goes towards zero.\n-  \/\/ Value is always pointer-size aligned.\n-  size_t _index;\n-\n-  static const size_t _element_size = sizeof(void*);\n-\n-  static size_t byte_index_to_index(size_t ind) {\n-    assert(is_aligned(ind, _element_size), \"precondition\");\n-    return ind \/ _element_size;\n-  }\n-\n-  static size_t index_to_byte_index(size_t ind) {\n-    return ind * _element_size;\n-  }\n-\n-protected:\n-  \/\/ The buffer.\n-  void** _buf;\n-\n-  \/\/ Initialize this queue to contain a null buffer, and be part of the\n-  \/\/ given PtrQueueSet.\n-  PtrQueue(PtrQueueSet* qset);\n-\n-  \/\/ Requires queue flushed.\n-  ~PtrQueue();\n-\n-public:\n-\n-  void** buffer() const { return _buf; }\n-  void set_buffer(void** buffer) { _buf = buffer; }\n-\n-  size_t index() const {\n-    return byte_index_to_index(_index);\n-  }\n-\n-  void set_index(size_t new_index) {\n-    assert(new_index <= current_capacity(), \"precondition\");\n-    _index = index_to_byte_index(new_index);\n-  }\n-\n-  \/\/ Returns the capacity of the buffer, or 0 if the queue doesn't currently\n-  \/\/ have a buffer.\n-  size_t current_capacity() const;\n-\n-  bool is_empty() const { return index() == current_capacity(); }\n-  size_t size() const { return current_capacity() - index(); }\n-\n-protected:\n-  \/\/ To support compiler.\n-  template<typename Derived>\n-  static ByteSize byte_offset_of_index() {\n-    return byte_offset_of(Derived, _index);\n-  }\n-\n-  static constexpr ByteSize byte_width_of_index() { return in_ByteSize(sizeof(size_t)); }\n-\n-  template<typename Derived>\n-  static ByteSize byte_offset_of_buf() {\n-    return byte_offset_of(Derived, _buf);\n-  }\n-\n-  static ByteSize byte_width_of_buf() { return in_ByteSize(_element_size); }\n-};\n-\n-\/\/ A PtrQueueSet represents resources common to a set of pointer queues.\n-\/\/ In particular, the individual queues allocate buffers from this shared\n-\/\/ set, and return completed buffers to the set.\n-class PtrQueueSet {\n-  BufferNode::Allocator* _allocator;\n-\n-  NONCOPYABLE(PtrQueueSet);\n-\n-protected:\n-  \/\/ Create an empty ptr queue set.\n-  PtrQueueSet(BufferNode::Allocator* allocator);\n-  ~PtrQueueSet();\n-\n-  \/\/ Discard any buffered enqueued data.\n-  void reset_queue(PtrQueue& queue);\n-\n-  \/\/ If queue has any buffered enqueued data, transfer it to this qset.\n-  \/\/ Otherwise, deallocate queue's buffer.\n-  void flush_queue(PtrQueue& queue);\n-\n-  \/\/ Add value to queue's buffer, returning true.  If buffer is full\n-  \/\/ or if queue doesn't have a buffer, does nothing and returns false.\n-  bool try_enqueue(PtrQueue& queue, void* value);\n-\n-  \/\/ Add value to queue's buffer.  The queue must have a non-full buffer.\n-  \/\/ Used after an initial try_enqueue has failed and the situation resolved.\n-  void retry_enqueue(PtrQueue& queue, void* value);\n-\n-  \/\/ Installs a new buffer into queue.\n-  \/\/ Returns the old buffer, or null if queue didn't have a buffer.\n-  BufferNode* exchange_buffer_with_new(PtrQueue& queue);\n-\n-  \/\/ Installs a new buffer into queue.\n-  void install_new_buffer(PtrQueue& queue);\n-\n-public:\n-\n-  \/\/ Return the associated BufferNode allocator.\n-  BufferNode::Allocator* allocator() const { return _allocator; }\n-\n-  \/\/ Return the buffer for a BufferNode of size buffer_capacity().\n-  void** allocate_buffer();\n-\n-  \/\/ Return an empty buffer to the free list.  The node is required\n-  \/\/ to have been allocated with a size of buffer_capacity().\n-  void deallocate_buffer(BufferNode* node);\n-\n-  \/\/ A completed buffer is a buffer the mutator is finished with, and\n-  \/\/ is ready to be processed by the collector.  It need not be full.\n-\n-  \/\/ Adds node to the completed buffer list.\n-  virtual void enqueue_completed_buffer(BufferNode* node) = 0;\n-\n-  size_t buffer_capacity() const {\n-    return _allocator->buffer_capacity();\n-  }\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_PTRQUEUE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.hpp","additions":0,"deletions":168,"binary":false,"changes":168,"status":"deleted"},{"patch":"@@ -39,1 +39,2 @@\n-  PtrQueue(qset),\n+  _buf(nullptr),\n+  _index(0),\n@@ -46,1 +47,5 @@\n-{ }\n+{}\n+\n+SATBMarkQueue::~SATBMarkQueue() {\n+  assert(_buf == nullptr, \"queue must be flushed before delete\");\n+}\n@@ -67,1 +72,1 @@\n-  PtrQueueSet(allocator),\n+  _allocator(allocator),\n@@ -217,7 +222,0 @@\n-void SATBMarkQueueSet::flush_queue(SATBMarkQueue& queue) {\n-  \/\/ Filter now to possibly save work later.  If filtering empties the\n-  \/\/ buffer then flush_queue can deallocate the buffer.\n-  filter(queue);\n-  PtrQueueSet::flush_queue(queue);\n-}\n-\n@@ -358,0 +356,73 @@\n+\n+size_t SATBMarkQueue::current_capacity() const {\n+  if (_buf == nullptr) {\n+    return 0;\n+  } else {\n+    return BufferNode::make_node_from_buffer(_buf)->capacity();\n+  }\n+}\n+\n+void SATBMarkQueueSet::reset_queue(SATBMarkQueue& queue) {\n+  queue.set_index(queue.current_capacity());\n+}\n+\n+void SATBMarkQueueSet::flush_queue(SATBMarkQueue& queue) {\n+  \/\/ Filter now to possibly save work later.  If filtering empties the\n+  \/\/ buffer then flush_queue can deallocate the buffer.\n+  filter(queue);\n+  void** buffer = queue.buffer();\n+  if (buffer != nullptr) {\n+    size_t index = queue.index();\n+    queue.set_buffer(nullptr);\n+    queue.set_index(0);\n+    BufferNode* node = BufferNode::make_node_from_buffer(buffer, index);\n+    if (index == node->capacity()) {\n+      deallocate_buffer(node);\n+    } else {\n+      enqueue_completed_buffer(node);\n+    }\n+  }\n+}\n+\n+bool SATBMarkQueueSet::try_enqueue(SATBMarkQueue& queue, void* value) {\n+  size_t index = queue.index();\n+  if (index == 0) return false;\n+  void** buffer = queue.buffer();\n+  assert(buffer != nullptr, \"no buffer but non-zero index\");\n+  buffer[--index] = value;\n+  queue.set_index(index);\n+  return true;\n+}\n+\n+void SATBMarkQueueSet::retry_enqueue(SATBMarkQueue& queue, void* value) {\n+  assert(queue.index() != 0, \"precondition\");\n+  assert(queue.buffer() != nullptr, \"precondition\");\n+  size_t index = queue.index();\n+  queue.buffer()[--index] = value;\n+  queue.set_index(index);\n+}\n+\n+BufferNode* SATBMarkQueueSet::exchange_buffer_with_new(SATBMarkQueue& queue) {\n+  BufferNode* node = nullptr;\n+  void** buffer = queue.buffer();\n+  if (buffer != nullptr) {\n+    node = BufferNode::make_node_from_buffer(buffer, queue.index());\n+  }\n+  install_new_buffer(queue);\n+  return node;\n+}\n+\n+void SATBMarkQueueSet::install_new_buffer(SATBMarkQueue& queue) {\n+  BufferNode* node = _allocator->allocate();\n+  queue.set_buffer(BufferNode::make_buffer_from_node(node));\n+  queue.set_index(node->capacity());\n+}\n+\n+void** SATBMarkQueueSet::allocate_buffer() {\n+  BufferNode* node = _allocator->allocate();\n+  return BufferNode::make_buffer_from_node(node);\n+}\n+\n+void SATBMarkQueueSet::deallocate_buffer(BufferNode* node) {\n+  _allocator->release(node);\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.cpp","additions":81,"deletions":10,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"gc\/shared\/ptrQueue.hpp\"\n+#include \"gc\/shared\/bufferNode.hpp\"\n@@ -33,0 +33,4 @@\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/sizes.hpp\"\n@@ -48,2 +52,2 @@\n-\/\/ A PtrQueue whose elements are (possibly stale) pointers to object heads.\n-class SATBMarkQueue: public PtrQueue {\n+\/\/ A queue whose elements are (possibly stale) pointers to object heads.\n+class SATBMarkQueue {\n@@ -54,0 +58,21 @@\n+  NONCOPYABLE(SATBMarkQueue);\n+\n+  \/\/ The buffer.\n+  void** _buf;\n+\n+  \/\/ The (byte) index at which an object was last enqueued.  Starts at\n+  \/\/ capacity (in bytes) (indicating an empty buffer) and goes towards zero.\n+  \/\/ Value is always pointer-size aligned.\n+  size_t _index;\n+\n+  static const size_t _element_size = sizeof(void*);\n+\n+  static size_t byte_index_to_index(size_t ind) {\n+    assert(is_aligned(ind, _element_size), \"precondition\");\n+    return ind \/ _element_size;\n+  }\n+\n+  static size_t index_to_byte_index(size_t ind) {\n+    return ind * _element_size;\n+  }\n+\n@@ -61,0 +86,23 @@\n+  \/\/ Queue must be flushed\n+  ~SATBMarkQueue();\n+\n+  void** buffer() const { return _buf; }\n+\n+  void set_buffer(void** buffer) { _buf = buffer; }\n+\n+  size_t index() const {\n+    return byte_index_to_index(_index);\n+  }\n+\n+  void set_index(size_t new_index) {\n+    assert(new_index <= current_capacity(), \"precondition\");\n+    _index = index_to_byte_index(new_index);\n+  }\n+\n+  \/\/ Returns the capacity of the buffer, or 0 if the queue doesn't currently\n+  \/\/ have a buffer.\n+  size_t current_capacity() const;\n+\n+  bool is_empty() const { return index() == current_capacity(); }\n+  size_t size() const { return current_capacity() - index(); }\n+\n@@ -71,1 +119,1 @@\n-    return PtrQueue::byte_offset_of_index<SATBMarkQueue>();\n+    return byte_offset_of(SATBMarkQueue, _index);\n@@ -73,1 +121,2 @@\n-  using PtrQueue::byte_width_of_index;\n+\n+  static constexpr ByteSize byte_width_of_index() { return in_ByteSize(sizeof(size_t)); }\n@@ -76,1 +125,1 @@\n-    return PtrQueue::byte_offset_of_buf<SATBMarkQueue>();\n+    return byte_offset_of(SATBMarkQueue, _buf);\n@@ -78,1 +127,2 @@\n-  using PtrQueue::byte_width_of_buf;\n+\n+  static ByteSize byte_width_of_buf() { return in_ByteSize(_element_size); }\n@@ -87,1 +137,12 @@\n-class SATBMarkQueueSet: public PtrQueueSet {\n+\n+\/\/ A SATBMarkQueueSet represents resources common to a set of SATBMarkQueues.\n+\/\/ In particular, the individual queues allocate buffers from this shared\n+\/\/ set, and return completed buffers to the set.\n+\/\/ A completed buffer is a buffer the mutator is finished with, and\n+\/\/ is ready to be processed by the collector.  It need not be full.\n+\n+class SATBMarkQueueSet {\n+\n+  BufferNode::Allocator* _allocator;\n+\n+  NONCOPYABLE(SATBMarkQueueSet);\n@@ -102,0 +163,18 @@\n+  \/\/ Discard any buffered enqueued data.\n+  void reset_queue(SATBMarkQueue& queue);\n+\n+  \/\/ Add value to queue's buffer, returning true.  If buffer is full\n+  \/\/ or if queue doesn't have a buffer, does nothing and returns false.\n+  bool try_enqueue(SATBMarkQueue& queue, void* value);\n+\n+  \/\/ Add value to queue's buffer.  The queue must have a non-full buffer.\n+  \/\/ Used after an initial try_enqueue has failed and the situation resolved.\n+  void retry_enqueue(SATBMarkQueue& queue, void* value);\n+\n+  \/\/ Installs a new buffer into queue.\n+  \/\/ Returns the old buffer, or null if queue didn't have a buffer.\n+  BufferNode* exchange_buffer_with_new(SATBMarkQueue& queue);\n+\n+  \/\/ Installs a new buffer into queue.\n+  void install_new_buffer(SATBMarkQueue& queue);\n+\n@@ -109,0 +188,1 @@\n+\n@@ -134,0 +214,1 @@\n+\n@@ -160,0 +241,14 @@\n+  \/\/ Return the associated BufferNode allocator.\n+  BufferNode::Allocator* allocator() const { return _allocator; }\n+\n+  \/\/ Return the buffer for a BufferNode of size buffer_capacity().\n+  void** allocate_buffer();\n+\n+  \/\/ Return an empty buffer to the free list.  The node is required\n+  \/\/ to have been allocated with a size of buffer_capacity().\n+  void deallocate_buffer(BufferNode* node);\n+\n+  size_t buffer_capacity() const {\n+    return _allocator->buffer_capacity();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/satbMarkQueue.hpp","additions":103,"deletions":8,"binary":false,"changes":111,"status":"modified"}]}