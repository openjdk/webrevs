{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.util.stream.Stream;\n@@ -31,0 +30,1 @@\n+import jdk.internal.constant.ArrayClassDescImpl;\n@@ -33,1 +33,0 @@\n-import sun.invoke.util.Wrapper;\n@@ -35,10 +34,1 @@\n-import static java.util.stream.Collectors.joining;\n-import static jdk.internal.constant.ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS;\n-import static jdk.internal.constant.ConstantUtils.arrayDepth;\n-import static jdk.internal.constant.ConstantUtils.binaryToInternal;\n-import static jdk.internal.constant.ConstantUtils.concat;\n-import static jdk.internal.constant.ConstantUtils.forPrimitiveType;\n-import static jdk.internal.constant.ConstantUtils.internalToBinary;\n-import static jdk.internal.constant.ConstantUtils.validateBinaryClassName;\n-import static jdk.internal.constant.ConstantUtils.validateInternalClassName;\n-import static jdk.internal.constant.ConstantUtils.validateMemberName;\n+import static jdk.internal.constant.ConstantUtils.*;\n@@ -67,1 +57,2 @@\n-                ReferenceClassDescImpl {\n+                ReferenceClassDescImpl,\n+                ArrayClassDescImpl {\n@@ -183,14 +174,1 @@\n-    default ClassDesc arrayType() {\n-        String desc = descriptorString();\n-        int depth = arrayDepth(desc);\n-        if (depth >= MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-            throw new IllegalStateException(\n-                    \"Cannot create an array type descriptor with more than \" +\n-                    MAX_ARRAY_TYPE_DESC_DIMENSIONS + \" dimensions\");\n-        }\n-        String newDesc = \"[\".concat(desc);\n-        if (desc.length() == 1 && desc.charAt(0) == 'V') {\n-            throw new IllegalArgumentException(\"not a valid reference type descriptor: \" + newDesc);\n-        }\n-        return ReferenceClassDescImpl.ofValidated(newDesc);\n-    }\n+    ClassDesc arrayType();\n@@ -209,18 +187,1 @@\n-    default ClassDesc arrayType(int rank) {\n-        if (rank <= 0) {\n-            throw new IllegalArgumentException(\"rank \" + rank + \" is not a positive value\");\n-        }\n-        String desc = descriptorString();\n-        long currentDepth = arrayDepth(desc);\n-        long netRank = currentDepth + rank;\n-        if (netRank > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-            throw new IllegalArgumentException(\"rank: \" + netRank +\n-                    \" exceeds maximum supported dimension of \" +\n-                    MAX_ARRAY_TYPE_DESC_DIMENSIONS);\n-        }\n-        String newDesc = new StringBuilder(desc.length() + rank).repeat('[', rank).append(desc).toString();\n-        if (desc.length() == 1 && desc.charAt(0) == 'V') {\n-            throw new IllegalArgumentException(\"not a valid reference type descriptor: \" + newDesc);\n-        }\n-        return ReferenceClassDescImpl.ofValidated(newDesc);\n-    }\n+    ClassDesc arrayType(int rank);\n@@ -246,7 +207,1 @@\n-        validateMemberName(nestedName, false);\n-        if (!isClassOrInterface())\n-            throw new IllegalStateException(\"Outer class is not a class or interface type\");\n-        String desc = descriptorString();\n-        StringBuilder sb = new StringBuilder(desc.length() + nestedName.length() + 1);\n-        sb.append(desc, 0, desc.length() - 1).append('$').append(nestedName).append(';');\n-        return ReferenceClassDescImpl.ofValidated(sb.toString());\n+        throw new IllegalStateException(\"Outer class is not a class or interface type\");\n@@ -269,10 +224,1 @@\n-        if (!isClassOrInterface())\n-            throw new IllegalStateException(\"Outer class is not a class or interface type\");\n-        validateMemberName(firstNestedName, false);\n-        \/\/ implicit null-check\n-        for (String addNestedNames : moreNestedNames) {\n-            validateMemberName(addNestedNames, false);\n-        }\n-        return moreNestedNames.length == 0\n-               ? nested(firstNestedName)\n-               : nested(firstNestedName + Stream.of(moreNestedNames).collect(joining(\"$\", \"$\", \"\")));\n+        throw new IllegalStateException(\"Outer class is not a class or interface type\");\n@@ -287,1 +233,1 @@\n-        return descriptorString().charAt(0) == '[';\n+        return false;\n@@ -296,1 +242,1 @@\n-        return descriptorString().length() == 1;\n+        return false;\n@@ -305,1 +251,1 @@\n-        return descriptorString().charAt(0) == 'L';\n+        return false;\n@@ -316,8 +262,0 @@\n-        if (isArray()) {\n-            String desc = descriptorString();\n-            if (desc.length() == 2) {\n-                return Wrapper.forBasicType(desc.charAt(1)).basicClassDescriptor();\n-            } else {\n-                return ReferenceClassDescImpl.ofValidated(desc.substring(1));\n-            }\n-        }\n@@ -335,5 +273,1 @@\n-        if (!isClassOrInterface())\n-            return \"\";\n-        String desc = descriptorString();\n-        int index = desc.lastIndexOf('\/');\n-        return (index == -1) ? \"\" : internalToBinary(desc.substring(1, index));\n+        return \"\";\n@@ -346,1 +280,1 @@\n-     * <p>The default implementation returns the simple name\n+     * <p>The implementations return the simple name\n@@ -353,17 +287,1 @@\n-    default String displayName() {\n-        if (isPrimitive())\n-            return Wrapper.forBasicType(descriptorString().charAt(0)).primitiveSimpleName();\n-        else if (isClassOrInterface()) {\n-            String desc = descriptorString();\n-            return desc.substring(Math.max(1, desc.lastIndexOf('\/') + 1), desc.length() - 1);\n-        }\n-        else if (isArray()) {\n-            int depth = arrayDepth(descriptorString());\n-            ClassDesc c = this;\n-            for (int i=0; i<depth; i++)\n-                c = c.componentType();\n-            return c.displayName().concat(\"[]\".repeat(depth));\n-        }\n-        else\n-            throw new IllegalStateException(descriptorString());\n-    }\n+    String displayName();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":14,"deletions":96,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -423,1 +423,1 @@\n-                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"));\n+                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, CD_Object.arrayType());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,3 +79,3 @@\n-    private static final ClassDesc CD_Object_array  = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n-    private static final ClassDesc CD_MethodHandle_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/invoke\/MethodHandle;\");\n-    private static final ClassDesc CD_MethodHandle_array2 = ReferenceClassDescImpl.ofValidated(\"[[Ljava\/lang\/invoke\/MethodHandle;\");\n+    private static final ClassDesc CD_Object_array  = CD_Object.arrayType();\n+    private static final ClassDesc CD_MethodHandle_array = CD_MethodHandle.arrayType();\n+    private static final ClassDesc CD_MethodHandle_array2 = CD_MethodHandle_array.arrayType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1041,1 +1041,1 @@\n-        private static final ClassDesc CD_Object_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n+        private static final ClassDesc CD_Object_array = CD_Object.arrayType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-            CD_Class_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Class;\"),\n+            CD_Class_array = CD_Class.arrayType(),\n@@ -76,1 +76,1 @@\n-            CD_Object_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"),\n+            CD_Object_array = CD_Object.arrayType(),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1069,1 +1069,1 @@\n-                    if (desc instanceof ReferenceClassDescImpl) {\n+                    if (!desc.isPrimitive()) {\n@@ -1251,8 +1251,8 @@\n-            INT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[I\")),\n-            BOOLEAN_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[Z\")),\n-            BYTE_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[B\")),\n-            CHAR_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[C\")),\n-            SHORT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[S\")),\n-            LONG_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[J\")),\n-            DOUBLE_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[D\")),\n-            FLOAT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[F\")),\n+            INT_ARRAY_TYPE = referenceType(CD_int.arrayType()),\n+            BOOLEAN_ARRAY_TYPE = referenceType(CD_boolean.arrayType()),\n+            BYTE_ARRAY_TYPE = referenceType(CD_byte.arrayType()),\n+            CHAR_ARRAY_TYPE = referenceType(CD_char.arrayType()),\n+            SHORT_ARRAY_TYPE = referenceType(CD_short.arrayType()),\n+            LONG_ARRAY_TYPE = referenceType(CD_long.arrayType()),\n+            DOUBLE_ARRAY_TYPE = referenceType(CD_double.arrayType()),\n+            FLOAT_ARRAY_TYPE = referenceType(CD_float.arrayType()),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+\n+import jdk.internal.vm.annotation.Stable;\n+import sun.invoke.util.Wrapper;\n+\n+import static java.lang.constant.ConstantDescs.CD_void;\n+\n+import static jdk.internal.constant.ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS;\n+\n+public final class ArrayClassDescImpl implements ClassDesc {\n+    private final ClassDesc element;\n+    private final int rank;\n+    private @Stable String cachedDescriptorString;\n+\n+    public static ArrayClassDescImpl ofValidatedDescriptor(String desc) {\n+        var lastChar = desc.charAt(desc.length() - 1);\n+        if (lastChar != ';') {\n+            var ret = ofValidated(Wrapper.forBasicType(lastChar).basicClassDescriptor(), desc.length() - 1);\n+            ret.cachedDescriptorString = desc;\n+            return ret;\n+        }\n+        int level = ConstantUtils.arrayDepth(desc);\n+        var ret = ofValidated(ReferenceClassDescImpl.ofValidated(desc.substring(level)), level);\n+        ret.cachedDescriptorString = desc;\n+        return ret;\n+    }\n+\n+    public static ArrayClassDescImpl ofValidated(ClassDesc element, int rank) {\n+        assert !element.isArray() && element != CD_void;\n+        assert rank > 0 && rank <= MAX_ARRAY_TYPE_DESC_DIMENSIONS;\n+\n+        return new ArrayClassDescImpl(element, rank);\n+    }\n+\n+    private ArrayClassDescImpl(ClassDesc element, int rank) {\n+        this.element = element;\n+        this.rank = rank;\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType() {\n+        if (rank == MAX_ARRAY_TYPE_DESC_DIMENSIONS)\n+            throw new IllegalStateException(\n+                \"Cannot create an array type descriptor with more than \"\n+                        + MAX_ARRAY_TYPE_DESC_DIMENSIONS + \" dimensions\");\n+        return new ArrayClassDescImpl(element, rank + 1);\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType(int rank) {\n+        if (rank <= 0) {\n+            throw new IllegalArgumentException(\"rank \" + rank + \" is not a positive value\");\n+        }\n+        rank += this.rank;\n+        ConstantUtils.validateArrayDepth(rank);\n+        return new ArrayClassDescImpl(element, rank);\n+    }\n+\n+    @Override\n+    public boolean isArray() {\n+        return true;\n+    }\n+\n+    @Override\n+    public ClassDesc componentType() {\n+        return rank == 1 ? element : new ArrayClassDescImpl(element, rank - 1);\n+    }\n+\n+    @Override\n+    public String displayName() {\n+        return componentType().displayName() + \"[]\".repeat(rank);\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        var desc = cachedDescriptorString;\n+        if (desc != null)\n+            return desc;\n+\n+        return cachedDescriptorString = computeDescriptor();\n+    }\n+\n+    private String computeDescriptor() {\n+        var componentDesc = element.descriptorString();\n+        StringBuilder sb = new StringBuilder(rank + componentDesc.length());\n+        sb.repeat('[', rank);\n+        sb.append(componentDesc);\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup) throws ReflectiveOperationException {\n+        if (element.isPrimitive()) {\n+            return lookup.findClass(descriptorString());\n+        }\n+        \/\/ Class.forName is slow on class or interface arrays\n+        Class<?> clazz = element.resolveConstantDesc(lookup);\n+        for (int i = 0; i < rank; i++)\n+            clazz = clazz.arrayType();\n+        return clazz;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o instanceof ArrayClassDescImpl constant) {\n+            return element.equals(constant.element) && rank == constant.rank;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return descriptorString().hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ArrayClassDesc[%s, %d]\", element.displayName(), rank);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ArrayClassDescImpl.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -259,0 +259,11 @@\n+    public static void validateArrayDepth(int rank) {\n+        if (rank <= 0) {\n+            throw new IllegalArgumentException(\"rank \" + rank + \" is not a positive value\");\n+        }\n+        if (rank > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+            throw new IllegalArgumentException(\"rank: \" + rank +\n+                    \" exceeds maximum supported dimension of \" +\n+                    MAX_ARRAY_TYPE_DESC_DIMENSIONS);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import static java.lang.constant.ConstantDescs.CD_void;\n@@ -48,1 +49,0 @@\n-import static jdk.internal.constant.PrimitiveClassDescImpl.CD_void;\n@@ -89,1 +89,1 @@\n-        if (arg.descriptorString().charAt(0) == 'V') \/\/ implicit null check\n+        if (requireNonNull(arg) == CD_void)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,0 +96,25 @@\n+    @Override\n+    public boolean isPrimitive() {\n+        return true;\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType(int rank) {\n+        ConstantUtils.validateArrayDepth(rank);\n+        if (this == CD_void)\n+            throw new IllegalArgumentException(\"not a valid reference type descriptor: \" + \"[\".repeat(rank) + \"V\");\n+        return ArrayClassDescImpl.ofValidated(this, rank);\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType() {\n+        if (this == CD_void)\n+            throw new IllegalArgumentException(\"not a valid reference type descriptor: [V\");\n+        return ArrayClassDescImpl.ofValidated(this, 1);\n+    }\n+\n+    @Override\n+    public String displayName() {\n+        return wrapper().primitiveSimpleName();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PrimitiveClassDescImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -33,3 +33,1 @@\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a class,\n- * interface, or array type.  A {@linkplain ReferenceClassDescImpl} corresponds to a\n- * {@code Constant_Class_info} entry in the constant pool of a classfile.\n+ * A class or interface descriptor.\n@@ -53,1 +51,1 @@\n-    public static ReferenceClassDescImpl of(String descriptor) {\n+    public static ClassDesc of(String descriptor) {\n@@ -58,0 +56,3 @@\n+        if (descriptor.charAt(0) == '[') {\n+            return ArrayClassDescImpl.ofValidatedDescriptor(descriptor);\n+        }\n@@ -68,1 +69,1 @@\n-    public static ReferenceClassDescImpl ofValidated(String descriptor) {\n+    public static ClassDesc ofValidated(String descriptor) {\n@@ -71,0 +72,3 @@\n+        if (descriptor.charAt(0) == '[') {\n+            return ArrayClassDescImpl.ofValidatedDescriptor(descriptor);\n+        }\n@@ -74,0 +78,51 @@\n+    @Override\n+    public ClassDesc arrayType(int rank) {\n+        ConstantUtils.validateArrayDepth(rank);\n+        return ArrayClassDescImpl.ofValidated(this, rank);\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType() {\n+        return ArrayClassDescImpl.ofValidated(this, 1);\n+    }\n+\n+    @Override\n+    public ClassDesc nested(String nestedName) {\n+        validateMemberName(nestedName, false);\n+        String desc = descriptorString();\n+        StringBuilder sb = new StringBuilder(desc.length() + nestedName.length() + 1);\n+        sb.append(desc, 0, desc.length() - 1).append('$').append(nestedName).append(';');\n+        return ReferenceClassDescImpl.ofValidated(sb.toString());\n+    }\n+\n+    @Override\n+    public ClassDesc nested(String firstNestedName, String... moreNestedNames) {\n+        validateMemberName(firstNestedName, false);\n+        \/\/ implicit null-check\n+        for (String addNestedNames : moreNestedNames) {\n+            validateMemberName(addNestedNames, false);\n+        }\n+        return moreNestedNames.length == 0\n+                ? nested(firstNestedName)\n+                : nested(firstNestedName + \"$\" + String.join(\"$\", moreNestedNames));\n+\n+    }\n+\n+    @Override\n+    public boolean isClassOrInterface() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String packageName() {\n+        String desc = descriptorString();\n+        int index = desc.lastIndexOf('\/');\n+        return (index == -1) ? \"\" : internalToBinary(desc.substring(1, index));\n+    }\n+\n+    @Override\n+    public String displayName() {\n+        String desc = descriptorString();\n+        return desc.substring(Math.max(1, desc.lastIndexOf('\/') + 1), desc.length() - 1);\n+    }\n+\n@@ -82,11 +137,0 @@\n-        if (isArray()) {\n-            if (isPrimitiveArray()) {\n-                return lookup.findClass(descriptor);\n-            }\n-            \/\/ Class.forName is slow on class or interface arrays\n-            int depth = ConstantUtils.arrayDepth(descriptor);\n-            Class<?> clazz = lookup.findClass(internalToBinary(descriptor.substring(depth + 1, descriptor.length() - 1)));\n-            for (int i = 0; i < depth; i++)\n-                clazz = clazz.arrayType();\n-            return clazz;\n-        }\n@@ -96,10 +140,0 @@\n-    \/**\n-     * Whether the descriptor is one of a primitive array, given this is\n-     * already a valid reference type descriptor.\n-     *\/\n-    private boolean isPrimitiveArray() {\n-        \/\/ All L-type descriptors must end with a semicolon; same for reference\n-        \/\/ arrays, leaving primitive arrays the only ones without a final semicolon\n-        return descriptor.charAt(descriptor.length() - 1) != ';';\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":60,"deletions":26,"binary":false,"changes":86,"status":"modified"}]}