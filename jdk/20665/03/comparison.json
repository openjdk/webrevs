{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.util.stream.Stream;\n@@ -31,0 +30,2 @@\n+import jdk.internal.constant.ArrayClassDescImpl;\n+import jdk.internal.constant.ConstantUtils;\n@@ -32,2 +33,1 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n-import sun.invoke.util.Wrapper;\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -35,10 +35,1 @@\n-import static java.util.stream.Collectors.joining;\n-import static jdk.internal.constant.ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS;\n-import static jdk.internal.constant.ConstantUtils.arrayDepth;\n-import static jdk.internal.constant.ConstantUtils.binaryToInternal;\n-import static jdk.internal.constant.ConstantUtils.concat;\n-import static jdk.internal.constant.ConstantUtils.forPrimitiveType;\n-import static jdk.internal.constant.ConstantUtils.internalToBinary;\n-import static jdk.internal.constant.ConstantUtils.validateBinaryClassName;\n-import static jdk.internal.constant.ConstantUtils.validateInternalClassName;\n-import static jdk.internal.constant.ConstantUtils.validateMemberName;\n+import static jdk.internal.constant.ConstantUtils.*;\n@@ -67,1 +58,2 @@\n-                ReferenceClassDescImpl {\n+                ClassOrInterfaceDescImpl,\n+                ArrayClassDescImpl {\n@@ -87,1 +79,1 @@\n-        return ClassDesc.ofDescriptor(concat(\"L\", binaryToInternal(name), \";\"));\n+        return ConstantUtils.binaryNameToDesc(name);\n@@ -113,1 +105,1 @@\n-        return ClassDesc.ofDescriptor(concat(\"L\", name, \";\"));\n+        return ConstantUtils.internalNameToDesc(name);\n@@ -132,0 +124,1 @@\n+        validateMemberName(className, false);\n@@ -133,1 +126,1 @@\n-            return of(className);\n+            return internalNameToDesc(className);\n@@ -135,2 +128,1 @@\n-        validateMemberName(className, false);\n-        return ofDescriptor('L' + binaryToInternal(packageName) +\n+        return ClassOrInterfaceDescImpl.ofValidated('L' + binaryToInternal(packageName) +\n@@ -171,1 +163,1 @@\n-               : ReferenceClassDescImpl.of(descriptor);\n+               : parseReferenceTypeDesc(descriptor);\n@@ -183,14 +175,1 @@\n-    default ClassDesc arrayType() {\n-        String desc = descriptorString();\n-        int depth = arrayDepth(desc);\n-        if (depth >= MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-            throw new IllegalStateException(\n-                    \"Cannot create an array type descriptor with more than \" +\n-                    MAX_ARRAY_TYPE_DESC_DIMENSIONS + \" dimensions\");\n-        }\n-        String newDesc = \"[\".concat(desc);\n-        if (desc.length() == 1 && desc.charAt(0) == 'V') {\n-            throw new IllegalArgumentException(\"not a valid reference type descriptor: \" + newDesc);\n-        }\n-        return ReferenceClassDescImpl.ofValidated(newDesc);\n-    }\n+    ClassDesc arrayType();\n@@ -209,18 +188,1 @@\n-    default ClassDesc arrayType(int rank) {\n-        if (rank <= 0) {\n-            throw new IllegalArgumentException(\"rank \" + rank + \" is not a positive value\");\n-        }\n-        String desc = descriptorString();\n-        long currentDepth = arrayDepth(desc);\n-        long netRank = currentDepth + rank;\n-        if (netRank > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-            throw new IllegalArgumentException(\"rank: \" + netRank +\n-                    \" exceeds maximum supported dimension of \" +\n-                    MAX_ARRAY_TYPE_DESC_DIMENSIONS);\n-        }\n-        String newDesc = new StringBuilder(desc.length() + rank).repeat('[', rank).append(desc).toString();\n-        if (desc.length() == 1 && desc.charAt(0) == 'V') {\n-            throw new IllegalArgumentException(\"not a valid reference type descriptor: \" + newDesc);\n-        }\n-        return ReferenceClassDescImpl.ofValidated(newDesc);\n-    }\n+    ClassDesc arrayType(int rank);\n@@ -246,7 +208,1 @@\n-        validateMemberName(nestedName, false);\n-        if (!isClassOrInterface())\n-            throw new IllegalStateException(\"Outer class is not a class or interface type\");\n-        String desc = descriptorString();\n-        StringBuilder sb = new StringBuilder(desc.length() + nestedName.length() + 1);\n-        sb.append(desc, 0, desc.length() - 1).append('$').append(nestedName).append(';');\n-        return ReferenceClassDescImpl.ofValidated(sb.toString());\n+        throw new IllegalStateException(\"Outer class is not a class or interface type\");\n@@ -269,10 +225,1 @@\n-        if (!isClassOrInterface())\n-            throw new IllegalStateException(\"Outer class is not a class or interface type\");\n-        validateMemberName(firstNestedName, false);\n-        \/\/ implicit null-check\n-        for (String addNestedNames : moreNestedNames) {\n-            validateMemberName(addNestedNames, false);\n-        }\n-        return moreNestedNames.length == 0\n-               ? nested(firstNestedName)\n-               : nested(firstNestedName + Stream.of(moreNestedNames).collect(joining(\"$\", \"$\", \"\")));\n+        throw new IllegalStateException(\"Outer class is not a class or interface type\");\n@@ -287,1 +234,1 @@\n-        return descriptorString().charAt(0) == '[';\n+        return false;\n@@ -296,1 +243,1 @@\n-        return descriptorString().length() == 1;\n+        return false;\n@@ -305,1 +252,1 @@\n-        return descriptorString().charAt(0) == 'L';\n+        return false;\n@@ -316,8 +263,0 @@\n-        if (isArray()) {\n-            String desc = descriptorString();\n-            if (desc.length() == 2) {\n-                return Wrapper.forBasicType(desc.charAt(1)).basicClassDescriptor();\n-            } else {\n-                return ReferenceClassDescImpl.ofValidated(desc.substring(1));\n-            }\n-        }\n@@ -335,5 +274,1 @@\n-        if (!isClassOrInterface())\n-            return \"\";\n-        String desc = descriptorString();\n-        int index = desc.lastIndexOf('\/');\n-        return (index == -1) ? \"\" : internalToBinary(desc.substring(1, index));\n+        return \"\";\n@@ -353,17 +288,1 @@\n-    default String displayName() {\n-        if (isPrimitive())\n-            return Wrapper.forBasicType(descriptorString().charAt(0)).primitiveSimpleName();\n-        else if (isClassOrInterface()) {\n-            String desc = descriptorString();\n-            return desc.substring(Math.max(1, desc.lastIndexOf('\/') + 1), desc.length() - 1);\n-        }\n-        else if (isArray()) {\n-            int depth = arrayDepth(descriptorString());\n-            ClassDesc c = this;\n-            for (int i=0; i<depth; i++)\n-                c = c.componentType();\n-            return c.displayName().concat(\"[]\".repeat(depth));\n-        }\n-        else\n-            throw new IllegalStateException(descriptorString());\n-    }\n+    String displayName();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":21,"deletions":102,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -29,1 +30,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -71,1 +71,1 @@\n-    public static final ClassDesc CD_Object = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Object;\");\n+    public static final ClassDesc CD_Object = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Object;\");\n@@ -74,1 +74,1 @@\n-    public static final ClassDesc CD_String = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/String;\");\n+    public static final ClassDesc CD_String = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/String;\");\n@@ -77,1 +77,1 @@\n-    public static final ClassDesc CD_Class = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Class;\");\n+    public static final ClassDesc CD_Class = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Class;\");\n@@ -80,1 +80,1 @@\n-    public static final ClassDesc CD_Number = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Number;\");\n+    public static final ClassDesc CD_Number = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Number;\");\n@@ -83,1 +83,1 @@\n-    public static final ClassDesc CD_Integer = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Integer;\");\n+    public static final ClassDesc CD_Integer = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Integer;\");\n@@ -86,1 +86,1 @@\n-    public static final ClassDesc CD_Long = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Long;\");\n+    public static final ClassDesc CD_Long = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Long;\");\n@@ -89,1 +89,1 @@\n-    public static final ClassDesc CD_Float = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Float;\");\n+    public static final ClassDesc CD_Float = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Float;\");\n@@ -92,1 +92,1 @@\n-    public static final ClassDesc CD_Double = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Double;\");\n+    public static final ClassDesc CD_Double = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Double;\");\n@@ -95,1 +95,1 @@\n-    public static final ClassDesc CD_Short = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Short;\");\n+    public static final ClassDesc CD_Short = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Short;\");\n@@ -98,1 +98,1 @@\n-    public static final ClassDesc CD_Byte = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Byte;\");\n+    public static final ClassDesc CD_Byte = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Byte;\");\n@@ -101,1 +101,1 @@\n-    public static final ClassDesc CD_Character = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Character;\");\n+    public static final ClassDesc CD_Character = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Character;\");\n@@ -104,1 +104,1 @@\n-    public static final ClassDesc CD_Boolean = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Boolean;\");\n+    public static final ClassDesc CD_Boolean = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Boolean;\");\n@@ -107,1 +107,1 @@\n-    public static final ClassDesc CD_Void = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Void;\");\n+    public static final ClassDesc CD_Void = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Void;\");\n@@ -110,1 +110,1 @@\n-    public static final ClassDesc CD_Throwable = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Throwable;\");\n+    public static final ClassDesc CD_Throwable = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Throwable;\");\n@@ -113,1 +113,1 @@\n-    public static final ClassDesc CD_Exception = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Exception;\");\n+    public static final ClassDesc CD_Exception = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Exception;\");\n@@ -116,1 +116,1 @@\n-    public static final ClassDesc CD_Enum = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Enum;\");\n+    public static final ClassDesc CD_Enum = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Enum;\");\n@@ -119,1 +119,1 @@\n-    public static final ClassDesc CD_VarHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle;\");\n+    public static final ClassDesc CD_VarHandle = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle;\");\n@@ -122,1 +122,1 @@\n-    public static final ClassDesc CD_MethodHandles = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles;\");\n+    public static final ClassDesc CD_MethodHandles = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles;\");\n@@ -125,1 +125,1 @@\n-    public static final ClassDesc CD_MethodHandles_Lookup = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles$Lookup;\");\n+    public static final ClassDesc CD_MethodHandles_Lookup = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandles$Lookup;\");\n@@ -128,1 +128,1 @@\n-    public static final ClassDesc CD_MethodHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandle;\");\n+    public static final ClassDesc CD_MethodHandle = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandle;\");\n@@ -131,1 +131,1 @@\n-    public static final ClassDesc CD_MethodType = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodType;\");\n+    public static final ClassDesc CD_MethodType = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodType;\");\n@@ -134,1 +134,1 @@\n-    public static final ClassDesc CD_CallSite = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/CallSite;\");\n+    public static final ClassDesc CD_CallSite = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/CallSite;\");\n@@ -137,1 +137,1 @@\n-    public static final ClassDesc CD_Collection = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Collection;\");\n+    public static final ClassDesc CD_Collection = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/Collection;\");\n@@ -140,1 +140,1 @@\n-    public static final ClassDesc CD_List = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/List;\");\n+    public static final ClassDesc CD_List = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/List;\");\n@@ -143,1 +143,1 @@\n-    public static final ClassDesc CD_Set = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Set;\");\n+    public static final ClassDesc CD_Set = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/Set;\");\n@@ -146,1 +146,1 @@\n-    public static final ClassDesc CD_Map = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Map;\");\n+    public static final ClassDesc CD_Map = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/Map;\");\n@@ -149,1 +149,1 @@\n-    public static final ClassDesc CD_ConstantDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/ConstantDesc;\");\n+    public static final ClassDesc CD_ConstantDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/ConstantDesc;\");\n@@ -152,1 +152,1 @@\n-    public static final ClassDesc CD_ClassDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/ClassDesc;\");\n+    public static final ClassDesc CD_ClassDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/ClassDesc;\");\n@@ -155,1 +155,1 @@\n-    public static final ClassDesc CD_EnumDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Enum$EnumDesc;\");\n+    public static final ClassDesc CD_EnumDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Enum$EnumDesc;\");\n@@ -158,1 +158,1 @@\n-    public static final ClassDesc CD_MethodTypeDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodTypeDesc;\");\n+    public static final ClassDesc CD_MethodTypeDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodTypeDesc;\");\n@@ -161,1 +161,1 @@\n-    public static final ClassDesc CD_MethodHandleDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodHandleDesc;\");\n+    public static final ClassDesc CD_MethodHandleDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/MethodHandleDesc;\");\n@@ -164,1 +164,1 @@\n-    public static final ClassDesc CD_DirectMethodHandleDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc;\");\n+    public static final ClassDesc CD_DirectMethodHandleDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc;\");\n@@ -167,1 +167,1 @@\n-    public static final ClassDesc CD_VarHandleDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle$VarHandleDesc;\");\n+    public static final ClassDesc CD_VarHandleDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/VarHandle$VarHandleDesc;\");\n@@ -170,1 +170,1 @@\n-    public static final ClassDesc CD_MethodHandleDesc_Kind = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc$Kind;\");\n+    public static final ClassDesc CD_MethodHandleDesc_Kind = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/DirectMethodHandleDesc$Kind;\");\n@@ -173,1 +173,1 @@\n-    public static final ClassDesc CD_DynamicConstantDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicConstantDesc;\");\n+    public static final ClassDesc CD_DynamicConstantDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicConstantDesc;\");\n@@ -176,1 +176,1 @@\n-    public static final ClassDesc CD_DynamicCallSiteDesc = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicCallSiteDesc;\");\n+    public static final ClassDesc CD_DynamicCallSiteDesc = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/constant\/DynamicCallSiteDesc;\");\n@@ -179,1 +179,1 @@\n-    public static final ClassDesc CD_ConstantBootstraps = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/ConstantBootstraps;\");\n+    public static final ClassDesc CD_ConstantBootstraps = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/ConstantBootstraps;\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n+import jdk.internal.constant.ConstantUtils;\n@@ -46,1 +48,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -68,2 +69,2 @@\n-    private static final ClassDesc CD_LambdaForm = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n-    private static final ClassDesc CD_BoundMethodHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/BoundMethodHandle;\");\n+    private static final ClassDesc CD_LambdaForm = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n+    private static final ClassDesc CD_BoundMethodHandle = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/BoundMethodHandle;\");\n@@ -977,1 +978,1 @@\n-             : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+             : ConstantUtils.referenceClassDesc(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -56,1 +57,0 @@\n-import static java.lang.invoke.MethodType.methodType;\n@@ -59,1 +59,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -160,1 +159,1 @@\n-        lambdaClassEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(ConstantUtils.concat(\"L\", lambdaClassName, \";\")));\n+        lambdaClassEntry = pool.classEntry(ConstantUtils.internalNameToDesc(lambdaClassName));\n@@ -410,3 +409,3 @@\n-        private static final ClassDesc CD_SerializedLambda = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n-        private static final ClassDesc CD_ObjectOutputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n-        private static final ClassDesc CD_ObjectInputStream = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n+        private static final ClassDesc CD_SerializedLambda = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/SerializedLambda;\");\n+        private static final ClassDesc CD_ObjectOutputStream = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/ObjectOutputStream;\");\n+        private static final ClassDesc CD_ObjectInputStream = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/ObjectInputStream;\");\n@@ -421,1 +420,1 @@\n-        static final ClassDesc CD_NotSerializableException = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n+        static final ClassDesc CD_NotSerializableException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/NotSerializableException;\");\n@@ -424,1 +423,1 @@\n-                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"));\n+                CD_Class, CD_String, CD_String, CD_String, CD_int, CD_String, CD_String, CD_String, CD_String, CD_Object.arrayType());\n@@ -560,1 +559,1 @@\n-        return cls.isHidden() ? null : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+        return cls.isHidden() ? null : ConstantUtils.referenceClassDesc(cls.descriptorString());\n@@ -565,1 +564,1 @@\n-                                 : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+                                 : ConstantUtils.referenceClassDesc(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n+import jdk.internal.constant.ConstantUtils;\n@@ -53,1 +55,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -62,1 +63,0 @@\n-import static jdk.internal.constant.ConstantUtils.concat;\n@@ -72,10 +72,10 @@\n-    private static final ClassDesc CD_CasesHolder = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$CasesHolder;\");\n-    private static final ClassDesc CD_DirectMethodHandle = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/DirectMethodHandle;\");\n-    private static final ClassDesc CD_MemberName = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MemberName;\");\n-    private static final ClassDesc CD_MethodHandleImpl = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl;\");\n-    private static final ClassDesc CD_LambdaForm = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n-    private static final ClassDesc CD_LambdaForm_Name = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Name;\");\n-    private static final ClassDesc CD_LoopClauses = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$LoopClauses;\");\n-    private static final ClassDesc CD_Object_array  = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n-    private static final ClassDesc CD_MethodHandle_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/invoke\/MethodHandle;\");\n-    private static final ClassDesc CD_MethodHandle_array2 = ReferenceClassDescImpl.ofValidated(\"[[Ljava\/lang\/invoke\/MethodHandle;\");\n+    private static final ClassDesc CD_CasesHolder = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$CasesHolder;\");\n+    private static final ClassDesc CD_DirectMethodHandle = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/DirectMethodHandle;\");\n+    private static final ClassDesc CD_MemberName = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MemberName;\");\n+    private static final ClassDesc CD_MethodHandleImpl = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl;\");\n+    private static final ClassDesc CD_LambdaForm = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm;\");\n+    private static final ClassDesc CD_LambdaForm_Name = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Name;\");\n+    private static final ClassDesc CD_LoopClauses = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/MethodHandleImpl$LoopClauses;\");\n+    private static final ClassDesc CD_Object_array  = CD_Object.arrayType();\n+    private static final ClassDesc CD_MethodHandle_array = CD_MethodHandle.arrayType();\n+    private static final ClassDesc CD_MethodHandle_array2 = CD_MethodHandle_array.arrayType();\n@@ -136,1 +136,1 @@\n-        this.classEntry = pool.classEntry(ReferenceClassDescImpl.ofValidated(concat(\"L\", className, \";\")));\n+        this.classEntry = pool.classEntry(ConstantUtils.internalNameToDesc(className));\n@@ -520,5 +520,5 @@\n-    static final Annotation DONTINLINE      = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/DontInline;\"));\n-    static final Annotation FORCEINLINE     = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\"));\n-    static final Annotation HIDDEN          = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/Hidden;\"));\n-    static final Annotation INJECTEDPROFILE = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/InjectedProfile;\"));\n-    static final Annotation LF_COMPILED     = Annotation.of(ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Compiled;\"));\n+    static final Annotation DONTINLINE      = Annotation.of(ClassOrInterfaceDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/DontInline;\"));\n+    static final Annotation FORCEINLINE     = Annotation.of(ClassOrInterfaceDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\"));\n+    static final Annotation HIDDEN          = Annotation.of(ClassOrInterfaceDescImpl.ofValidated(\"Ljdk\/internal\/vm\/annotation\/Hidden;\"));\n+    static final Annotation INJECTEDPROFILE = Annotation.of(ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/InjectedProfile;\"));\n+    static final Annotation LF_COMPILED     = Annotation.of(ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/invoke\/LambdaForm$Compiled;\"));\n@@ -1652,1 +1652,1 @@\n-             : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+             : ConstantUtils.referenceClassDesc(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -31,1 +32,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -57,1 +57,0 @@\n-import java.util.Set;\n@@ -70,1 +69,0 @@\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n@@ -1041,1 +1039,1 @@\n-        private static final ClassDesc CD_Object_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\");\n+        private static final ClassDesc CD_Object_array = CD_Object.arrayType();\n@@ -1270,1 +1268,1 @@\n-            return ClassFile.of().build(ReferenceClassDescImpl.ofValidated(\"LInjectedInvoker;\"), clb -> clb\n+            return ClassFile.of().build(ClassOrInterfaceDescImpl.ofValidated(\"LInjectedInvoker;\"), clb -> clb\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -33,1 +34,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -1091,4 +1091,4 @@\n-        static final ClassDesc CD_StringConcatHelper = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper;\");\n-        static final ClassDesc CD_StringConcatBase   = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper$StringConcatBase;\");\n-        static final ClassDesc CD_Array_byte         = ReferenceClassDescImpl.ofValidated(\"[B\");\n-        static final ClassDesc CD_Array_String       = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/String;\");\n+        static final ClassDesc CD_StringConcatHelper = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper;\");\n+        static final ClassDesc CD_StringConcatBase   = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper$StringConcatBase;\");\n+        static final ClassDesc CD_Array_byte         = CD_byte.arrayType();\n+        static final ClassDesc CD_Array_String       = CD_String.arrayType();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+\n+import jdk.internal.constant.ConstantUtils;\n@@ -34,1 +36,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -205,1 +206,1 @@\n-             : ReferenceClassDescImpl.ofValidated(cls.descriptorString());\n+             : ConstantUtils.referenceClassDesc(cls.descriptorString());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/TypeConvertingMethodAdapter.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -44,1 +46,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -67,12 +68,12 @@\n-            CD_ClassLoader = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n-            CD_Class_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Class;\"),\n-            CD_ClassNotFoundException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/ClassNotFoundException;\"),\n-            CD_NoClassDefFoundError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoClassDefFoundError;\"),\n-            CD_IllegalAccessException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/IllegalAccessException;\"),\n-            CD_InvocationHandler = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/InvocationHandler;\"),\n-            CD_Method = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Method;\"),\n-            CD_NoSuchMethodError = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodError;\"),\n-            CD_NoSuchMethodException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodException;\"),\n-            CD_Object_array = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/Object;\"),\n-            CD_Proxy = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Proxy;\"),\n-            CD_UndeclaredThrowableException = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/reflect\/UndeclaredThrowableException;\");\n+            CD_ClassLoader = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/ClassLoader;\"),\n+            CD_Class_array = CD_Class.arrayType(),\n+            CD_ClassNotFoundException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/ClassNotFoundException;\"),\n+            CD_NoClassDefFoundError = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/NoClassDefFoundError;\"),\n+            CD_IllegalAccessException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/IllegalAccessException;\"),\n+            CD_InvocationHandler = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/reflect\/InvocationHandler;\"),\n+            CD_Method = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Method;\"),\n+            CD_NoSuchMethodError = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodError;\"),\n+            CD_NoSuchMethodException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/NoSuchMethodException;\"),\n+            CD_Object_array = CD_Object.arrayType(),\n+            CD_Proxy = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/reflect\/Proxy;\"),\n+            CD_UndeclaredThrowableException = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/reflect\/UndeclaredThrowableException;\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -53,1 +54,0 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -85,2 +85,2 @@\n-    private static final ClassDesc CD_BiPredicate = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/function\/BiPredicate;\");\n-    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n+    private static final ClassDesc CD_BiPredicate = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/function\/BiPredicate;\");\n+    private static final ClassDesc CD_Objects = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n@@ -587,1 +587,1 @@\n-                            cb.invokestatic(referenceClassDesc(ExactConversionsSupport.class),\n+                            cb.invokestatic(ConstantUtils.referenceClassDesc(ExactConversionsSupport.class),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-import jdk.internal.constant.ReferenceClassDescImpl;\n-import jdk.internal.constant.PrimitiveClassDescImpl;\n+\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n@@ -1062,1 +1062,1 @@\n-                    desc instanceof PrimitiveClassDescImpl\n+                    desc.isPrimitive()\n@@ -1072,1 +1072,1 @@\n-                    desc instanceof PrimitiveClassDescImpl\n+                    desc.isPrimitive()\n@@ -1277,1 +1277,1 @@\n-                    if (desc instanceof ReferenceClassDescImpl) {\n+                    if (!desc.isPrimitive()) {\n@@ -1462,8 +1462,8 @@\n-            INT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[I\")),\n-            BOOLEAN_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[Z\")),\n-            BYTE_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[B\")),\n-            CHAR_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[C\")),\n-            SHORT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[S\")),\n-            LONG_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[J\")),\n-            DOUBLE_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[D\")),\n-            FLOAT_ARRAY_TYPE = referenceType(ReferenceClassDescImpl.ofValidated(\"[F\")),\n+            INT_ARRAY_TYPE = referenceType(CD_int.arrayType()),\n+            BOOLEAN_ARRAY_TYPE = referenceType(CD_boolean.arrayType()),\n+            BYTE_ARRAY_TYPE = referenceType(CD_byte.arrayType()),\n+            CHAR_ARRAY_TYPE = referenceType(CD_char.arrayType()),\n+            SHORT_ARRAY_TYPE = referenceType(CD_short.arrayType()),\n+            LONG_ARRAY_TYPE = referenceType(CD_long.arrayType()),\n+            DOUBLE_ARRAY_TYPE = referenceType(CD_double.arrayType()),\n+            FLOAT_ARRAY_TYPE = referenceType(CD_float.arrayType()),\n@@ -1534,2 +1534,2 @@\n-        private static final ClassDesc CD_Cloneable = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/Cloneable;\");\n-        private static final ClassDesc CD_Serializable = ReferenceClassDescImpl.ofValidated(\"Ljava\/io\/Serializable;\");\n+        private static final ClassDesc CD_Cloneable = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/lang\/Cloneable;\");\n+        private static final ClassDesc CD_Serializable = ClassOrInterfaceDescImpl.ofValidated(\"Ljava\/io\/Serializable;\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapGenerator.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+\n+import jdk.internal.vm.annotation.Stable;\n+import sun.invoke.util.Wrapper;\n+\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static jdk.internal.constant.ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS;\n+\n+\/**\n+ * An array class descriptor.\n+ * Restrictions: <ul>\n+ * <li>{@code rank} must be in {@code [1, 255]}\n+ * <li>{@code element} must not be void or array\n+ * <\/ul>\n+ *\/\n+public final class ArrayClassDescImpl implements ClassDesc {\n+    private final ClassDesc elementType;\n+    private final int rank;\n+    private @Stable String cachedDescriptorString;\n+\n+    public static ArrayClassDescImpl ofValidatedDescriptor(String desc) {\n+        assert desc.charAt(0) == '[';\n+        var lastChar = desc.charAt(desc.length() - 1);\n+        ArrayClassDescImpl ret;\n+        if (lastChar != ';') {\n+            \/\/ Primitive element arrays\n+            ret = ofValidated(Wrapper.forBasicType(lastChar).basicClassDescriptor(), desc.length() - 1);\n+        } else {\n+            int level = ConstantUtils.arrayDepth(desc, 0);\n+            ret = ofValidated(ClassOrInterfaceDescImpl.ofValidated(desc.substring(level)), level);\n+        }\n+        ret.cachedDescriptorString = desc;\n+        return ret;\n+    }\n+\n+    public static ArrayClassDescImpl ofValidated(ClassDesc elementType, int rank) {\n+        assert !elementType.isArray() && elementType != CD_void;\n+        assert rank > 0 && rank <= MAX_ARRAY_TYPE_DESC_DIMENSIONS;\n+\n+        return new ArrayClassDescImpl(elementType, rank);\n+    }\n+\n+    private ArrayClassDescImpl(ClassDesc elementType, int rank) {\n+        this.elementType = elementType;\n+        this.rank = rank;\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType() {\n+        int rank = this.rank + 1;\n+        if (rank > MAX_ARRAY_TYPE_DESC_DIMENSIONS)\n+            throw new IllegalStateException(ConstantUtils.invalidArrayRankMessage(rank));\n+        return new ArrayClassDescImpl(elementType, rank);\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType(int rank) {\n+        if (rank <= 0) {\n+            throw new IllegalArgumentException(\"rank \" + rank + \" is not a positive value\");\n+        }\n+        rank += this.rank;\n+        ConstantUtils.validateArrayRank(rank);\n+        return new ArrayClassDescImpl(elementType, rank);\n+    }\n+\n+    @Override\n+    public boolean isArray() {\n+        return true;\n+    }\n+\n+    @Override\n+    public ClassDesc componentType() {\n+        return rank == 1 ? elementType : new ArrayClassDescImpl(elementType, rank - 1);\n+    }\n+\n+    @Override\n+    public String displayName() {\n+        return componentType().displayName() + \"[]\".repeat(rank);\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        var desc = cachedDescriptorString;\n+        if (desc != null)\n+            return desc;\n+\n+        return cachedDescriptorString = computeDescriptor();\n+    }\n+\n+    private String computeDescriptor() {\n+        var componentDesc = elementType.descriptorString();\n+        StringBuilder sb = new StringBuilder(rank + componentDesc.length());\n+        sb.repeat('[', rank);\n+        sb.append(componentDesc);\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup) throws ReflectiveOperationException {\n+        if (elementType.isPrimitive()) {\n+            return lookup.findClass(descriptorString());\n+        }\n+        \/\/ Class.forName is slow on class or interface arrays\n+        Class<?> clazz = elementType.resolveConstantDesc(lookup);\n+        for (int i = 0; i < rank; i++)\n+            clazz = clazz.arrayType();\n+        return clazz;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o instanceof ArrayClassDescImpl constant) {\n+            return elementType.equals(constant.elementType) && rank == constant.rank;\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return descriptorString().hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ArrayClassDesc[%s, %d]\", elementType.displayName(), rank);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ArrayClassDescImpl.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.constant;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodHandles;\n+\n+import static jdk.internal.constant.ConstantUtils.*;\n+\n+\/**\n+ * A class or interface descriptor.\n+ * Restrictions:\n+ * <ul>\n+ * <li>Starts with 'L'\n+ * <li>Ends with ';'\n+ * <li>No '.' or '[' or ';' in the middle\n+ * <li>No leading\/trailing\/consecutive '\/'\n+ * <\/ul>\n+ *\/\n+public final class ClassOrInterfaceDescImpl implements ClassDesc {\n+    private final String descriptor;\n+\n+    \/**\n+     * Creates a {@linkplain ClassOrInterfaceDescImpl} from a pre-validated descriptor string\n+     * for a class or interface.\n+     *\/\n+    public static ClassOrInterfaceDescImpl ofValidated(String descriptor) {\n+        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length())\n+                == descriptor.length() : descriptor;\n+        assert descriptor.charAt(0) == 'L';\n+        return new ClassOrInterfaceDescImpl(descriptor);\n+    }\n+\n+    ClassOrInterfaceDescImpl(String descriptor) {\n+        this.descriptor = descriptor;\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType(int rank) {\n+        ConstantUtils.validateArrayRank(rank);\n+        return ArrayClassDescImpl.ofValidated(this, rank);\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType() {\n+        return ArrayClassDescImpl.ofValidated(this, 1);\n+    }\n+\n+    @Override\n+    public ClassDesc nested(String nestedName) {\n+        validateMemberName(nestedName, false);\n+        String desc = descriptorString();\n+        StringBuilder sb = new StringBuilder(desc.length() + nestedName.length() + 1);\n+        sb.append(desc, 0, desc.length() - 1).append('$').append(nestedName).append(';');\n+        return ofValidated(sb.toString());\n+    }\n+\n+    @Override\n+    public ClassDesc nested(String firstNestedName, String... moreNestedNames) {\n+        validateMemberName(firstNestedName, false);\n+        \/\/ implicit null-check\n+        for (String addNestedNames : moreNestedNames) {\n+            validateMemberName(addNestedNames, false);\n+        }\n+        return moreNestedNames.length == 0\n+                ? nested(firstNestedName)\n+                : nested(firstNestedName + \"$\" + String.join(\"$\", moreNestedNames));\n+\n+    }\n+\n+    @Override\n+    public boolean isClassOrInterface() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String packageName() {\n+        String desc = descriptorString();\n+        int index = desc.lastIndexOf('\/');\n+        return (index == -1) ? \"\" : internalToBinary(desc.substring(1, index));\n+    }\n+\n+    @Override\n+    public String displayName() {\n+        String desc = descriptorString();\n+        return desc.substring(Math.max(1, desc.lastIndexOf('\/') + 1), desc.length() - 1);\n+    }\n+\n+    @Override\n+    public String descriptorString() {\n+        return descriptor;\n+    }\n+\n+    @Override\n+    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup)\n+            throws ReflectiveOperationException {\n+        return lookup.findClass(internalToBinary(dropFirstAndLastChar(descriptor)));\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this {@linkplain ClassOrInterfaceDescImpl} is\n+     * equal to another {@linkplain ClassOrInterfaceDescImpl}.  Equality is\n+     * determined by the two class descriptors having equal class descriptor\n+     * strings.\n+     *\n+     * @param o the {@code ClassDesc} to compare to this\n+     *       {@code ClassDesc}\n+     * @return {@code true} if the specified {@code ClassDesc}\n+     *      is equal to this {@code ClassDesc}.\n+     *\/\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o instanceof ClassOrInterfaceDescImpl constant) {\n+            return descriptor.equals(constant.descriptor);\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return descriptor.hashCode();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return String.format(\"ClassOrInterfaceDesc[%s]\", displayName());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ClassOrInterfaceDescImpl.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -34,2 +34,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -73,1 +71,12 @@\n-        return ReferenceClassDescImpl.ofValidated(concat(\"L\", binaryToInternal(binaryName), \";\"));\n+        return internalNameToDesc(binaryToInternal(binaryName));\n+    }\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a pre-validated internal name\n+     * for a class or interface type. Validated version of {@link\n+     * ClassDesc#ofInternalName(String)}.\n+     *\n+     * @param internalName a binary name\n+     *\/\n+    public static ClassDesc internalNameToDesc(String internalName) {\n+        return ClassOrInterfaceDescImpl.ofValidated(concat(\"L\", internalName, \";\"));\n@@ -94,1 +103,15 @@\n-        return ReferenceClassDescImpl.ofValidated(type.descriptorString());\n+        return referenceClassDesc(type.descriptorString());\n+    }\n+\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a pre-validated descriptor string\n+     * for a class or interface type or an array type.\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    public static ClassDesc referenceClassDesc(String descriptor) {\n+        if (descriptor.charAt(0) == '[') {\n+            return ArrayClassDescImpl.ofValidatedDescriptor(descriptor);\n+        }\n+        return ClassOrInterfaceDescImpl.ofValidated(descriptor);\n@@ -131,0 +154,20 @@\n+    \/**\n+     * Creates a {@linkplain ClassDesc} from a descriptor string for a class or\n+     * interface type or an array type.\n+     *\n+     * @param descriptor a field descriptor string for a class or interface type\n+     * @throws IllegalArgumentException if the descriptor string is not a valid\n+     * field descriptor string, or does not describe a class or interface type\n+     * @jvms 4.3.2 Field Descriptors\n+     *\/\n+    public static ClassDesc parseReferenceTypeDesc(String descriptor) {\n+        int dLen = descriptor.length();\n+        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen);\n+        if (len <= 1 || len != dLen)\n+            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %s\", descriptor));\n+        if (descriptor.charAt(0) == '[') {\n+            return ArrayClassDescImpl.ofValidatedDescriptor(descriptor);\n+        }\n+        return ClassOrInterfaceDescImpl.ofValidated(descriptor);\n+    }\n+\n@@ -143,2 +186,3 @@\n-            if (ch == ';' || ch == '[' || ch == '\/')\n-                throw new IllegalArgumentException(\"Invalid class name: \" + name);\n+            if (ch == ';' || ch == '[' || ch == '\/'\n+                    || ch == '.' && (i == 0 || i + 1 == name.length() || name.charAt(i - 1) == '.'))\n+                throw invalidClassName(name);\n@@ -161,2 +205,3 @@\n-            if (ch == ';' || ch == '[' || ch == '.')\n-                throw new IllegalArgumentException(\"Invalid class name: \" + name);\n+            if (ch == ';' || ch == '[' || ch == '.'\n+                    || ch == '\/' && (i == 0 || i + 1 == name.length() || name.charAt(i - 1) == '\/'))\n+                throw invalidClassName(name);\n@@ -259,1 +304,13 @@\n-    public static int arrayDepth(String descriptorString) {\n+    public static void validateArrayRank(int rank) {\n+        \/\/ array rank must be representable with u1 and nonzero\n+        if (rank == 0 || (rank & ~0xFF) != 0) {\n+            throw new IllegalArgumentException(invalidArrayRankMessage(rank));\n+        }\n+    }\n+\n+    \/**\n+     * Retrieves the array depth on a trusted descriptor.\n+     * Uses a simple loop with the assumption that most descriptors have\n+     * 0 or very low array depths.\n+     *\/\n+    public static int arrayDepth(String descriptorString, int off) {\n@@ -261,1 +318,1 @@\n-        while (descriptorString.charAt(depth) == '[')\n+        while (descriptorString.charAt(off) == '[') {\n@@ -263,0 +320,2 @@\n+            off++;\n+        }\n@@ -299,1 +358,16 @@\n-        return ReferenceClassDescImpl.ofValidated(descriptor.substring(start, start + len));\n+        int arrayDepth = arrayDepth(descriptor, start);\n+        if (arrayDepth == 0) {\n+            return ClassOrInterfaceDescImpl.ofValidated(descriptor.substring(start, start + len));\n+        } else if (arrayDepth + 1 == len) {\n+            return ArrayClassDescImpl.ofValidated(forPrimitiveType(descriptor, start + arrayDepth), arrayDepth);\n+        } else {\n+            return ArrayClassDescImpl.ofValidated(ClassOrInterfaceDescImpl.ofValidated(descriptor.substring(start + arrayDepth, start + len)), arrayDepth);\n+        }\n+    }\n+\n+    static String invalidArrayRankMessage(int rank) {\n+        return \"Array rank must be within [1, 255]: \" + rank;\n+    }\n+\n+    static IllegalArgumentException invalidClassName(String className) {\n+        return new IllegalArgumentException(\"Invalid class name: \".concat(className));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":85,"deletions":11,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import static java.lang.constant.ConstantDescs.CD_void;\n@@ -48,1 +49,0 @@\n-import static jdk.internal.constant.PrimitiveClassDescImpl.CD_void;\n@@ -89,1 +89,1 @@\n-        if (arg.descriptorString().charAt(0) == 'V') \/\/ implicit null check\n+        if (requireNonNull(arg) == CD_void)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,0 +96,25 @@\n+    @Override\n+    public boolean isPrimitive() {\n+        return true;\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType(int rank) {\n+        ConstantUtils.validateArrayRank(rank);\n+        if (this == CD_void)\n+            throw new IllegalArgumentException(\"not a valid reference type descriptor: \" + \"[\".repeat(rank) + \"V\");\n+        return ArrayClassDescImpl.ofValidated(this, rank);\n+    }\n+\n+    @Override\n+    public ClassDesc arrayType() {\n+        if (this == CD_void)\n+            throw new IllegalArgumentException(\"not a valid reference type descriptor: [V\");\n+        return ArrayClassDescImpl.ofValidated(this, 1);\n+    }\n+\n+    @Override\n+    public String displayName() {\n+        return wrapper().primitiveSimpleName();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PrimitiveClassDescImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,135 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.constant;\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.invoke.MethodHandles;\n-\n-import static jdk.internal.constant.ConstantUtils.*;\n-\n-\/**\n- * A <a href=\"package-summary.html#nominal\">nominal descriptor<\/a> for a class,\n- * interface, or array type.  A {@linkplain ReferenceClassDescImpl} corresponds to a\n- * {@code Constant_Class_info} entry in the constant pool of a classfile.\n- *\/\n-public final class ReferenceClassDescImpl implements ClassDesc {\n-    private final String descriptor;\n-\n-    private ReferenceClassDescImpl(String descriptor) {\n-        this.descriptor = descriptor;\n-    }\n-\n-    \/**\n-     * Creates a {@linkplain ClassDesc} from a descriptor string for a class or\n-     * interface type or an array type.\n-     *\n-     * @param descriptor a field descriptor string for a class or interface type\n-     * @throws IllegalArgumentException if the descriptor string is not a valid\n-     * field descriptor string, or does not describe a class or interface type\n-     * @jvms 4.3.2 Field Descriptors\n-     *\/\n-    public static ReferenceClassDescImpl of(String descriptor) {\n-        int dLen = descriptor.length();\n-        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen);\n-        if (len <= 1 || len != dLen)\n-            throw new IllegalArgumentException(String.format(\"not a valid reference type descriptor: %s\", descriptor));\n-        return new ReferenceClassDescImpl(descriptor);\n-    }\n-\n-    \/**\n-     * Creates a {@linkplain ClassDesc} from a pre-validated descriptor string\n-     * for a class or interface type or an array type.\n-     *\n-     * @param descriptor a field descriptor string for a class or interface type\n-     * @jvms 4.3.2 Field Descriptors\n-     *\/\n-    public static ReferenceClassDescImpl ofValidated(String descriptor) {\n-        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length())\n-                == descriptor.length() : descriptor;\n-        return new ReferenceClassDescImpl(descriptor);\n-    }\n-\n-    @Override\n-    public String descriptorString() {\n-        return descriptor;\n-    }\n-\n-    @Override\n-    public Class<?> resolveConstantDesc(MethodHandles.Lookup lookup)\n-            throws ReflectiveOperationException {\n-        if (isArray()) {\n-            if (isPrimitiveArray()) {\n-                return lookup.findClass(descriptor);\n-            }\n-            \/\/ Class.forName is slow on class or interface arrays\n-            int depth = ConstantUtils.arrayDepth(descriptor);\n-            Class<?> clazz = lookup.findClass(internalToBinary(descriptor.substring(depth + 1, descriptor.length() - 1)));\n-            for (int i = 0; i < depth; i++)\n-                clazz = clazz.arrayType();\n-            return clazz;\n-        }\n-        return lookup.findClass(internalToBinary(dropFirstAndLastChar(descriptor)));\n-    }\n-\n-    \/**\n-     * Whether the descriptor is one of a primitive array, given this is\n-     * already a valid reference type descriptor.\n-     *\/\n-    private boolean isPrimitiveArray() {\n-        \/\/ All L-type descriptors must end with a semicolon; same for reference\n-        \/\/ arrays, leaving primitive arrays the only ones without a final semicolon\n-        return descriptor.charAt(descriptor.length() - 1) != ';';\n-    }\n-\n-    \/**\n-     * Returns {@code true} if this {@linkplain ReferenceClassDescImpl} is\n-     * equal to another {@linkplain ReferenceClassDescImpl}.  Equality is\n-     * determined by the two class descriptors having equal class descriptor\n-     * strings.\n-     *\n-     * @param o the {@code ClassDesc} to compare to this\n-     *       {@code ClassDesc}\n-     * @return {@code true} if the specified {@code ClassDesc}\n-     *      is equal to this {@code ClassDesc}.\n-     *\/\n-    @Override\n-    public boolean equals(Object o) {\n-        if (this == o) return true;\n-        if (o instanceof ReferenceClassDescImpl constant) {\n-            return descriptor.equals(constant.descriptor);\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return descriptor.hashCode();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"ClassDesc[%s]\", displayName());\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":0,"deletions":135,"binary":false,"changes":135,"status":"deleted"}]}