{"files":[{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.io;\n-\n-import java.util.Map;\n-import java.util.LinkedHashMap;\n-import java.util.Set;\n-\n-final class ExpiringCache {\n-\n-    private static final int QUERY_OVERFLOW = 300;\n-    private static final int MAX_ENTRIES = 200;\n-    private final long millisUntilExpiration;\n-    private final Map<String,Entry> map;\n-\n-    \/\/ Clear out old entries every few queries\n-    private int queryCount;\n-\n-    static final class Entry {\n-        private long timestamp;\n-        private String val;\n-\n-        Entry(long timestamp, String val) {\n-            this.timestamp = timestamp;\n-            this.val = val;\n-        }\n-\n-        long   timestamp()                  { return timestamp;           }\n-        void   setTimestamp(long timestamp) { this.timestamp = timestamp; }\n-\n-        String val()                        { return val;                 }\n-        void   setVal(String val)           { this.val = val;             }\n-    }\n-\n-    ExpiringCache() {\n-        this(30000);\n-    }\n-\n-    @SuppressWarnings(\"serial\")\n-    ExpiringCache(long millisUntilExpiration) {\n-        this.millisUntilExpiration = millisUntilExpiration;\n-        map = new LinkedHashMap<>() {\n-            protected boolean removeEldestEntry(Map.Entry<String,Entry> eldest) {\n-              return size() > MAX_ENTRIES;\n-            }\n-          };\n-    }\n-\n-    synchronized String get(String key) {\n-        if (++queryCount >= QUERY_OVERFLOW) {\n-            cleanup();\n-        }\n-        Entry entry = entryFor(key);\n-        if (entry != null) {\n-            return entry.val();\n-        }\n-        return null;\n-    }\n-\n-    synchronized void put(String key, String val) {\n-        if (++queryCount >= QUERY_OVERFLOW) {\n-            cleanup();\n-        }\n-        Entry entry = entryFor(key);\n-        if (entry != null) {\n-            entry.setTimestamp(System.currentTimeMillis());\n-            entry.setVal(val);\n-        } else {\n-            map.put(key, new Entry(System.currentTimeMillis(), val));\n-        }\n-    }\n-\n-    synchronized void clear() {\n-        map.clear();\n-    }\n-\n-    private Entry entryFor(String key) {\n-        Entry entry = map.get(key);\n-        if (entry != null) {\n-            long delta = System.currentTimeMillis() - entry.timestamp();\n-            if (delta < 0 || delta >= millisUntilExpiration) {\n-                map.remove(key);\n-                entry = null;\n-            }\n-        }\n-        return entry;\n-    }\n-\n-    private void cleanup() {\n-        Set<String> keySet = map.keySet();\n-        \/\/ Avoid ConcurrentModificationExceptions\n-        String[] keys = new String[keySet.size()];\n-        int i = 0;\n-        for (String key: keySet) {\n-            keys[i++] = key;\n-        }\n-        for (int j = 0; j < keys.length; j++) {\n-            entryFor(keys[j]);\n-        }\n-        queryCount = 0;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/io\/ExpiringCache.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -246,14 +246,0 @@\n-    \/\/ Flags for enabling\/disabling performance optimizations for file\n-    \/\/ name canonicalization\n-    static final boolean useCanonCaches;\n-    static final boolean useCanonPrefixCache;\n-\n-    private static boolean getBooleanProperty(String prop, boolean defaultVal) {\n-        String value = System.getProperty(prop);\n-        return (value != null) ? Boolean.parseBoolean(value) : defaultVal;\n-    }\n-\n-    static {\n-        useCanonCaches      = getBooleanProperty(\"sun.io.useCanonCaches\", false);\n-        useCanonPrefixCache = useCanonCaches && getBooleanProperty(\"sun.io.useCanonPrefixCache\", false);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileSystem.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,3 @@\n-class DefaultFileSystem {\n+final class DefaultFileSystem {\n+\n+    private DefaultFileSystem() {}\n","filename":"src\/java.base\/unix\/classes\/java\/io\/DefaultFileSystem.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-class UnixFileSystem extends FileSystem {\n+final class UnixFileSystem extends FileSystem {\n@@ -37,1 +37,0 @@\n-    private final String javaHome;\n@@ -40,1 +39,1 @@\n-    public UnixFileSystem() {\n+    UnixFileSystem() {\n@@ -44,1 +43,0 @@\n-        javaHome = StaticProperty.javaHome();\n@@ -46,2 +44,0 @@\n-        cache = useCanonCaches ? new ExpiringCache() : null;\n-        javaHomePrefixCache = useCanonPrefixCache ? new ExpiringCache() : null;\n@@ -50,1 +46,0 @@\n-\n@@ -145,1 +140,1 @@\n-        return f.getPath().indexOf('\\u0000') < 0 ? false : true;\n+        return f.getPath().indexOf('\\u0000') >= 0;\n@@ -159,12 +154,0 @@\n-    \/\/ Caches for canonicalization results to improve startup performance.\n-    \/\/ The first cache handles repeated canonicalizations of the same path\n-    \/\/ name. The prefix cache handles repeated canonicalizations within the\n-    \/\/ same directory, and must not create results differing from the true\n-    \/\/ canonicalization algorithm in canonicalize_md.c. For this reason the\n-    \/\/ prefix cache is conservative and is not used for complex path names.\n-    private final ExpiringCache cache;\n-    \/\/ On Unix symlinks can jump anywhere in the file system, so we only\n-    \/\/ treat prefixes in java.home as trusted and cacheable in the\n-    \/\/ canonicalization algorithm\n-    private final ExpiringCache javaHomePrefixCache;\n-\n@@ -173,52 +156,5 @@\n-        if (!useCanonCaches) {\n-            long comp = Blocker.begin();\n-            try {\n-                return canonicalize0(path);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n-        } else {\n-            String res = cache.get(path);\n-            if (res == null) {\n-                String dir = null;\n-                String resDir;\n-                if (useCanonPrefixCache) {\n-                    \/\/ Note that this can cause symlinks that should\n-                    \/\/ be resolved to a destination directory to be\n-                    \/\/ resolved to the directory they're contained in\n-                    dir = parentOrNull(path);\n-                    if (dir != null) {\n-                        resDir = javaHomePrefixCache.get(dir);\n-                        if (resDir != null) {\n-                            \/\/ Hit only in prefix cache; full path is canonical\n-                            String filename = path.substring(1 + dir.length());\n-                            res = resDir + slash + filename;\n-                            cache.put(dir + slash + filename, res);\n-                        }\n-                    }\n-                }\n-                if (res == null) {\n-                    long comp = Blocker.begin();\n-                    try {\n-                        res = canonicalize0(path);\n-                    } finally {\n-                        Blocker.end(comp);\n-                    }\n-                    cache.put(path, res);\n-                    if (useCanonPrefixCache &&\n-                        dir != null && dir.startsWith(javaHome)) {\n-                        resDir = parentOrNull(res);\n-                        \/\/ Note that we don't allow a resolved symlink\n-                        \/\/ to elsewhere in java.home to pollute the\n-                        \/\/ prefix cache (java.home prefix cache could\n-                        \/\/ just as easily be a set at this point)\n-                        if (resDir != null && resDir.equals(dir)) {\n-                            File f = new File(res);\n-                            if (f.exists() && !f.isDirectory()) {\n-                                javaHomePrefixCache.put(dir, resDir);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            return res;\n+        long comp = Blocker.begin();\n+        try {\n+            return canonicalize0(path);\n+        } finally {\n+            Blocker.end(comp);\n@@ -228,42 +164,0 @@\n-    \/\/ Best-effort attempt to get parent of this path; used for\n-    \/\/ optimization of filename canonicalization. This must return null for\n-    \/\/ any cases where the code in canonicalize_md.c would throw an\n-    \/\/ exception or otherwise deal with non-simple pathnames like handling\n-    \/\/ of \".\" and \"..\". It may conservatively return null in other\n-    \/\/ situations as well. Returning null will cause the underlying\n-    \/\/ (expensive) canonicalization routine to be called.\n-    static String parentOrNull(String path) {\n-        if (path == null) return null;\n-        char sep = File.separatorChar;\n-        int last = path.length() - 1;\n-        int idx = last;\n-        int adjacentDots = 0;\n-        int nonDotCount = 0;\n-        while (idx > 0) {\n-            char c = path.charAt(idx);\n-            if (c == '.') {\n-                if (++adjacentDots >= 2) {\n-                    \/\/ Punt on pathnames containing . and ..\n-                    return null;\n-                }\n-            } else if (c == sep) {\n-                if (adjacentDots == 1 && nonDotCount == 0) {\n-                    \/\/ Punt on pathnames containing . and ..\n-                    return null;\n-                }\n-                if (idx == 0 ||\n-                    idx >= last - 1 ||\n-                    path.charAt(idx - 1) == sep) {\n-                    \/\/ Punt on pathnames containing adjacent slashes\n-                    \/\/ toward the end\n-                    return null;\n-                }\n-                return path.substring(0, idx);\n-            } else {\n-                ++nonDotCount;\n-                adjacentDots = 0;\n-            }\n-            --idx;\n-        }\n-        return null;\n-    }\n@@ -365,11 +259,0 @@\n-        \/\/ Keep canonicalization caches in sync after file deletion\n-        \/\/ and renaming operations. Could be more clever than this\n-        \/\/ (i.e., only remove\/update affected entries) but probably\n-        \/\/ not worth it since these entries expire after 30 seconds\n-        \/\/ anyway.\n-        if (useCanonCaches) {\n-            cache.clear();\n-        }\n-        if (useCanonPrefixCache) {\n-            javaHomePrefixCache.clear();\n-        }\n@@ -409,11 +292,0 @@\n-        \/\/ Keep canonicalization caches in sync after file deletion\n-        \/\/ and renaming operations. Could be more clever than this\n-        \/\/ (i.e., only remove\/update affected entries) but probably\n-        \/\/ not worth it since these entries expire after 30 seconds\n-        \/\/ anyway.\n-        if (useCanonCaches) {\n-            cache.clear();\n-        }\n-        if (useCanonPrefixCache) {\n-            javaHomePrefixCache.clear();\n-        }\n@@ -503,1 +375,0 @@\n-\n","filename":"src\/java.base\/unix\/classes\/java\/io\/UnixFileSystem.java","additions":9,"deletions":138,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,3 @@\n-class DefaultFileSystem {\n+final class DefaultFileSystem {\n+\n+    private DefaultFileSystem() {}\n","filename":"src\/java.base\/windows\/classes\/java\/io\/DefaultFileSystem.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.File;\n@@ -43,1 +42,1 @@\n-class WinNTFileSystem extends FileSystem {\n+final class WinNTFileSystem extends FileSystem {\n@@ -64,1 +63,1 @@\n-    public WinNTFileSystem() {\n+    WinNTFileSystem() {\n@@ -70,2 +69,0 @@\n-        cache = useCanonCaches ? new ExpiringCache() : null;\n-        prefixCache = useCanonPrefixCache ? new ExpiringCache() : null;\n@@ -413,1 +410,1 @@\n-    private static String[] driveDirCache = new String[26];\n+    private static final String[] DRIVE_DIR_CACHE = new String[26];\n@@ -426,1 +423,4 @@\n-        String s = driveDirCache[i];\n+        \/\/ Updates might not be visible to other threads so there\n+        \/\/ is no guarantee getDriveDirectory(i+1) is called just once\n+        \/\/ for any given value of i.\n+        String s = DRIVE_DIR_CACHE[i];\n@@ -429,1 +429,1 @@\n-        driveDirCache[i] = s;\n+        DRIVE_DIR_CACHE[i] = s;\n@@ -431,1 +431,0 @@\n-    }\n@@ -433,8 +432,1 @@\n-    \/\/ Caches for canonicalization results to improve startup performance.\n-    \/\/ The first cache handles repeated canonicalizations of the same path\n-    \/\/ name. The prefix cache handles repeated canonicalizations within the\n-    \/\/ same directory, and must not create results differing from the true\n-    \/\/ canonicalization algorithm in canonicalize_md.c. For this reason the\n-    \/\/ prefix cache is conservative and is not used for complex path names.\n-    private final ExpiringCache cache;\n-    private final ExpiringCache prefixCache;\n+    }\n@@ -462,44 +454,5 @@\n-        if (!useCanonCaches) {\n-            long comp = Blocker.begin();\n-            try {\n-                return canonicalize0(path);\n-            } finally {\n-                Blocker.end(comp);\n-            }\n-        } else {\n-            String res = cache.get(path);\n-            if (res == null) {\n-                String dir = null;\n-                String resDir = null;\n-                if (useCanonPrefixCache) {\n-                    dir = parentOrNull(path);\n-                    if (dir != null) {\n-                        resDir = prefixCache.get(dir);\n-                        if (resDir != null) {\n-                            \/*\n-                             * Hit only in prefix cache; full path is canonical,\n-                             * but we need to get the canonical name of the file\n-                             * in this directory to get the appropriate\n-                             * capitalization\n-                             *\/\n-                            String filename = path.substring(1 + dir.length());\n-                            res = canonicalizeWithPrefix(resDir, filename);\n-                            cache.put(dir + File.separatorChar + filename, res);\n-                        }\n-                    }\n-                }\n-                if (res == null) {\n-                    res = canonicalize0(path);\n-                    cache.put(path, res);\n-                    if (useCanonPrefixCache && dir != null) {\n-                        resDir = parentOrNull(res);\n-                        if (resDir != null) {\n-                            File f = new File(res);\n-                            if (f.exists() && !f.isDirectory()) {\n-                                prefixCache.put(dir, resDir);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-            return res;\n+        long comp = Blocker.begin();\n+        try {\n+            return canonicalize0(path);\n+        } finally {\n+            Blocker.end(comp);\n@@ -512,69 +465,0 @@\n-    private String canonicalizeWithPrefix(String canonicalPrefix,\n-            String filename) throws IOException\n-    {\n-        return canonicalizeWithPrefix0(canonicalPrefix,\n-                canonicalPrefix + File.separatorChar + filename);\n-    }\n-\n-    \/\/ Run the canonicalization operation assuming that the prefix\n-    \/\/ (everything up to the last filename) is canonical; just gets\n-    \/\/ the canonical name of the last element of the path\n-    private native String canonicalizeWithPrefix0(String canonicalPrefix,\n-            String pathWithCanonicalPrefix)\n-            throws IOException;\n-\n-    \/\/ Best-effort attempt to get parent of this path; used for\n-    \/\/ optimization of filename canonicalization. This must return null for\n-    \/\/ any cases where the code in canonicalize_md.c would throw an\n-    \/\/ exception or otherwise deal with non-simple pathnames like handling\n-    \/\/ of \".\" and \"..\". It may conservatively return null in other\n-    \/\/ situations as well. Returning null will cause the underlying\n-    \/\/ (expensive) canonicalization routine to be called.\n-    private static String parentOrNull(String path) {\n-        if (path == null) return null;\n-        char sep = File.separatorChar;\n-        char altSep = '\/';\n-        int last = path.length() - 1;\n-        int idx = last;\n-        int adjacentDots = 0;\n-        int nonDotCount = 0;\n-        while (idx > 0) {\n-            char c = path.charAt(idx);\n-            if (c == '.') {\n-                if (++adjacentDots >= 2) {\n-                    \/\/ Punt on pathnames containing . and ..\n-                    return null;\n-                }\n-                if (nonDotCount == 0) {\n-                    \/\/ Punt on pathnames ending in a .\n-                    return null;\n-                }\n-            } else if (c == sep) {\n-                if (adjacentDots == 1 && nonDotCount == 0) {\n-                    \/\/ Punt on pathnames containing . and ..\n-                    return null;\n-                }\n-                if (idx == 0 ||\n-                    idx >= last - 1 ||\n-                    path.charAt(idx - 1) == sep ||\n-                    path.charAt(idx - 1) == altSep) {\n-                    \/\/ Punt on pathnames containing adjacent slashes\n-                    \/\/ toward the end\n-                    return null;\n-                }\n-                return path.substring(0, idx);\n-            } else if (c == altSep) {\n-                \/\/ Punt on pathnames containing both backward and\n-                \/\/ forward slashes\n-                return null;\n-            } else if (c == '*' || c == '?') {\n-                \/\/ Punt on pathnames containing wildcards\n-                return null;\n-            } else {\n-                ++nonDotCount;\n-                adjacentDots = 0;\n-            }\n-            --idx;\n-        }\n-        return null;\n-    }\n@@ -698,11 +582,0 @@\n-        \/\/ Keep canonicalization caches in sync after file deletion\n-        \/\/ and renaming operations. Could be more clever than this\n-        \/\/ (i.e., only remove\/update affected entries) but probably\n-        \/\/ not worth it since these entries expire after 30 seconds\n-        \/\/ anyway.\n-        if (useCanonCaches) {\n-            cache.clear();\n-        }\n-        if (useCanonPrefixCache) {\n-            prefixCache.clear();\n-        }\n@@ -720,11 +593,0 @@\n-        \/\/ Keep canonicalization caches in sync after file deletion\n-        \/\/ and renaming operations. Could be more clever than this\n-        \/\/ (i.e., only remove\/update affected entries) but probably\n-        \/\/ not worth it since these entries expire after 30 seconds\n-        \/\/ anyway.\n-        if (useCanonCaches) {\n-            cache.clear();\n-        }\n-        if (useCanonPrefixCache) {\n-            prefixCache.clear();\n-        }\n","filename":"src\/java.base\/windows\/classes\/java\/io\/WinNTFileSystem.java","additions":14,"deletions":152,"binary":false,"changes":166,"status":"modified"}]}