{"files":[{"patch":"@@ -203,0 +203,1 @@\n+                new CK_ATTRIBUTE(CKA_VALUE_LEN, secretLen),\n@@ -216,15 +217,3 @@\n-            \/\/ Some vendors, e.g. NSS, trim off the leading 0x00 byte(s) from\n-            \/\/ the generated secret. Thus, we need to check the secret length\n-            \/\/ and trim\/pad it so the returned value has the same length as\n-            \/\/ the modulus size\n-            if (secret.length == secretLen) {\n-                return secret;\n-            } else {\n-                if (secret.length > secretLen) {\n-                    \/\/ Shouldn't happen; but check just in case\n-                    throw new ProviderException(\"generated secret is out-of-range\");\n-                }\n-                byte[] newSecret = new byte[secretLen];\n-                System.arraycopy(secret, 0, newSecret, secretLen - secret.length,\n-                    secret.length);\n-                return newSecret;\n+            if (secret.length != secretLen) {\n+                \/\/ Shouldn't happen; but check just in case\n+                throw new ProviderException(\"generated secret is out-of-range\");\n@@ -232,0 +221,1 @@\n+            return secret;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyAgreement.java","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"}]}