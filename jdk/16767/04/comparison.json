{"files":[{"patch":"@@ -167,1 +167,1 @@\n-  blob->purge();\n+  blob->purge(true \/* free_code_cache_data *\/, true \/* unregister_nmethod *\/);\n@@ -176,1 +176,1 @@\n-void CodeBlob::purge(bool free_code_cache_data) {\n+void CodeBlob::purge(bool free_code_cache_data, bool unregister_nmethod) {\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  virtual void purge(bool free_code_cache_data = true);\n+  virtual void purge(bool free_code_cache_data, bool unregister_nmethod);\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  virtual void purge(bool free_code_cache_data = true) = 0;\n+  virtual void purge(bool free_code_cache_data, bool unregister_nmethod) = 0;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1447,1 +1447,1 @@\n-void nmethod::purge(bool free_code_cache_data) {\n+void nmethod::purge(bool free_code_cache_data, bool unregister_nmethod) {\n@@ -1467,1 +1467,5 @@\n-  Universe::heap()->unregister_nmethod(this);\n+  if (unregister_nmethod) {\n+    assert(!free_code_cache_data, \"must not free when postponing unregistering\");\n+    Universe::heap()->unregister_nmethod(this);\n+  }\n+\n@@ -1470,1 +1474,1 @@\n-  CodeBlob::purge();\n+  CodeBlob::purge(free_code_cache_data, unregister_nmethod);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -525,1 +525,1 @@\n-  void purge(bool free_code_cache_data = true);\n+  void purge(bool free_code_cache_data, bool unregister_nmethod);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1791,1 +1791,1 @@\n-    blob->purge();\n+    blob->purge(true \/* free_code_cache_data *\/, true \/* unregister_nmethod *\/);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -190,0 +190,9 @@\n+  \/\/ Removes dead\/unlinked entries.\n+  void remove_unlinked_entries() {\n+    auto delete_check = [&] (nmethod** value) {\n+      return (*value)->is_unlinked();\n+    };\n+\n+    clean(delete_check);\n+  }\n+\n@@ -258,0 +267,5 @@\n+void G1CodeRootSet::remove_unlinked_entries() {\n+  assert(!_is_iterating, \"should not mutate while iterating the table\");\n+  _table->remove_unlinked_entries();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  void remove_unlinked_entries();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2492,0 +2492,1 @@\n+                            false \/* unregister_nmethods_during_purge *\/,\n@@ -2503,0 +2504,4 @@\n+  {\n+    GCTraceTime(Debug, gc, phases) ur(\"Unregister NMethods\", timer);\n+    G1CollectedHeap::heap()->remove_unlinked_nmethods_from_code_root_sets();\n+  }\n@@ -2514,0 +2519,27 @@\n+class G1RemoveUnlinkedFromCodeRootSetsTask : public WorkerTask {\n+  HeapRegionClaimer _hrclaimer;\n+\n+  class RemoveUnlinkedHeapRegionClosure : public HeapRegionClosure {\n+  public:\n+\n+    bool do_heap_region(HeapRegion* hr) {\n+      hr->rem_set()->remove_unlinked_nmethods();\n+      return false;\n+    }\n+  } _cl;\n+\n+public:\n+  G1RemoveUnlinkedFromCodeRootSetsTask(uint num_workers)\n+  : WorkerTask(\"G1 Remove Unlinked NMethods From Code Root Set Task\"),\n+    _hrclaimer(num_workers) { }\n+\n+  void work(uint worker_id) {\n+    G1CollectedHeap::heap()->heap_region_par_iterate_from_worker_offset(&_cl, &_hrclaimer, worker_id);\n+  }\n+};\n+\n+void G1CollectedHeap::remove_unlinked_nmethods_from_code_root_sets() {\n+  uint num_workers = workers()->active_workers();\n+  G1RemoveUnlinkedFromCodeRootSetsTask remove_unlinked_task(num_workers);\n+  workers()->run_task(&remove_unlinked_task);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1272,0 +1272,2 @@\n+  void remove_unlinked_nmethods_from_code_root_sets();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,0 +118,4 @@\n+void HeapRegionRemSet::remove_unlinked_nmethods() {\n+  _code_roots.remove_unlinked_entries();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,0 +153,1 @@\n+  void remove_unlinked_nmethods();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -530,0 +530,8 @@\n+void ParallelScavengeHeap::prune_scavengable_nmethods() {\n+  ScavengableNMethods::prune_nmethods_not_into_young();\n+}\n+\n+void ParallelScavengeHeap::prune_unlinked_nmethods() {\n+  ScavengableNMethods::prune_unlinked_nmethods();\n+}\n+\n@@ -861,4 +869,0 @@\n-void ParallelScavengeHeap::prune_scavengable_nmethods() {\n-  ScavengableNMethods::prune_nmethods();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  void prune_unlinked_nmethods();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1772,0 +1772,1 @@\n+                              false \/* unregister_nmethods_during_purge *\/,\n@@ -2081,0 +2082,4 @@\n+    {\n+      GCTraceTime(Debug, gc, phases) ur(\"Unregister NMethods\", &_gc_timer);\n+      ParallelScavengeHeap::heap()->prune_unlinked_nmethods();\n+    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -222,0 +222,4 @@\n+    {\n+      GCTraceTime(Debug, gc, phases) ur(\"Unregister NMethods\", gc_timer());\n+      gch->prune_unlinked_nmethods();\n+    }\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/scavengableNMethods.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,3 @@\n-ClassUnloadingContext::ClassUnloadingContext(uint num_workers, bool lock_codeblob_free_separately) :\n+ClassUnloadingContext::ClassUnloadingContext(uint num_workers,\n+                                             bool unregister_nmethods_during_purge,\n+                                             bool lock_codeblob_free_separately) :\n@@ -39,0 +41,1 @@\n+  _unregister_nmethods_during_purge(unregister_nmethods_during_purge),\n@@ -116,1 +119,1 @@\n-      nm->purge(false \/* free_code_cache_data *\/);\n+      nm->purge(false \/* free_code_cache_data *\/, _unregister_nmethods_during_purge);\n","filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  bool _unregister_nmethods_during_purge;\n@@ -52,0 +53,3 @@\n+  \/\/ unregister_nmethods_during_purge determines whether unloaded nmethods should\n+  \/\/     be unregistered from the garbage collector during purge. If not, ,the caller\n+  \/\/     is responsible to do that later.\n@@ -56,0 +60,1 @@\n+                        bool unregister_nmethods_during_purge,\n","filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -527,0 +527,1 @@\n+                              false \/* unregister_nmethods_during_purge *\/,\n@@ -585,1 +586,5 @@\n-  ScavengableNMethods::prune_nmethods();\n+  ScavengableNMethods::prune_nmethods_not_into_young();\n+}\n+\n+void GenCollectedHeap::prune_unlinked_nmethods() {\n+  ScavengableNMethods::prune_unlinked_nmethods();\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -185,0 +185,1 @@\n+  void prune_unlinked_nmethods();\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-void ScavengableNMethods::prune_nmethods() {\n+void ScavengableNMethods::prune_nmethods_not_into_young() {\n@@ -179,0 +179,27 @@\n+void ScavengableNMethods::prune_unlinked_nmethods() {\n+  assert_locked_or_safepoint(CodeCache_lock);\n+\n+  debug_only(mark_on_list_nmethods());\n+\n+  nmethod* prev = nullptr;\n+  nmethod* cur = _head;\n+  while (cur != nullptr) {\n+    ScavengableNMethodsData data = gc_data(cur);\n+    debug_only(data.clear_marked());\n+    assert(data.on_list(), \"else shouldn't be on this list\");\n+\n+    nmethod* const next = data.next();\n+\n+    if (cur->is_unlinked()) {\n+      unlist_nmethod(cur, prev);\n+    } else {\n+      prev = cur;\n+    }\n+\n+    cur = next;\n+  }\n+\n+  \/\/ Check for stray marks.\n+  debug_only(verify_unlisted_nmethods(nullptr));\n+}\n+\n@@ -221,1 +248,1 @@\n-    if (data.on_list())\n+    if (data.on_list()) {\n@@ -223,0 +250,1 @@\n+    }\n@@ -233,1 +261,4 @@\n-    verify_nmethod(nm);\n+    \/\/ Can not verify already unlinked nmethods as they are partially invalid already.\n+    if (!nm->is_unlinked()) {\n+      verify_nmethod(nm);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shared\/scavengableNMethods.cpp","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,4 @@\n-  \/\/ Remove nmethods that no longer have scavengable oops.\n-  static void prune_nmethods();\n+  \/\/ Remove nmethods that no longer have oops into young gen.\n+  static void prune_nmethods_not_into_young();\n+  \/\/ Remvoe unlinked (dead) nmethods.\n+  static void prune_unlinked_nmethods();\n","filename":"src\/hotspot\/share\/gc\/shared\/scavengableNMethods.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1825,0 +1825,1 @@\n+                            true \/* unregister_nmethods_during_purge *\/,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+                            true \/* unregister_nmethods_during_purge *\/,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -325,0 +325,1 @@\n+                            true \/* unregister_nmethods_during_purge *\/,\n","filename":"src\/hotspot\/share\/gc\/x\/xHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1321,0 +1321,1 @@\n+                            true \/* unregister_nmethods_during_purge *\/,\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}