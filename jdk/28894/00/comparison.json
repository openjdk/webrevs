{"files":[{"patch":"@@ -3067,0 +3067,124 @@\n+  void gcm_counterMode_AESCrypt_blocks(int round, Register in, Register out, Register key, Register counter,\n+                                       Register input_len, VectorRegister *working_vregs, Register blocks,\n+                                       VectorRegister vtmp1, VectorRegister vtmp2, VectorRegister vtmp3) {\n+    __ srli(blocks, input_len, 4);\n+\n+    const unsigned int BLOCK_SIZE = 16;\n+    const unsigned int MASK_VALUE = 0b1000; \/\/ we need {1, 0, 0, 0} mask value here\n+    __ vsetivli(x0, 1, Assembler::e8, Assembler::m1);\n+    __ vmv_v_i(v0, MASK_VALUE);\n+\n+    __ vsetivli(x0, 4, Assembler::e32, Assembler::m1);\n+    \/\/ load keys to working_vregs according to round\n+    aes_load_keys(key, working_vregs, round);\n+\n+    __ vle32_v(vtmp1, counter);\n+    Label L_aes_ctr_loop;\n+    __ bind(L_aes_ctr_loop);\n+      __ vmv_v_v(vtmp2, vtmp1);\n+      \/\/ encrypt counter according to round\n+      aes_encrypt(vtmp2, working_vregs, round);\n+      __ vle32_v(vtmp3, in);\n+      __ vxor_vv(vtmp2, vtmp2, vtmp3);\n+      __ vse32_v(vtmp2, out);\n+      __ addi(out, out, BLOCK_SIZE);\n+      __ addi(in, in, BLOCK_SIZE);\n+      __ sub(blocks, blocks, 1);\n+      __ vrev8_v(vtmp1, vtmp1, Assembler::VectorMask::v0_t);\n+      __ vadd_vi(vtmp1, vtmp1, 0x1, Assembler::VectorMask::v0_t);\n+      __ vrev8_v(vtmp1, vtmp1, Assembler::VectorMask::v0_t);\n+      __ bnez(blocks, L_aes_ctr_loop);\n+\n+    __ vse32_v(vtmp1, counter);\n+  }\n+\n+  void gcm_ghash_blocks(Register state, Register subkeyH, Register ct, Register input_len, Register blocks,\n+                        VectorRegister vtmp1, VectorRegister vtmp2, VectorRegister vtmp3) {\n+    __ srli(blocks, input_len, 4);\n+\n+    ghash_loop(state, subkeyH, ct, blocks, vtmp1, vtmp2, vtmp3);\n+\n+    __ mv(x10, input_len);\n+    __ leave();\n+    __ ret();\n+  }\n+\n+\n+  \/\/ Vector AES Galois Counter Mode implementation. Parameters:\n+  \/\/\n+  \/\/ in = c_rarg0\n+  \/\/ input_len = c_rarg1\n+  \/\/ ct = c_rarg2 - ciphertext that ghash will read (in for encrypt, out for decrypt)\n+  \/\/ out = c_rarg3\n+  \/\/ key = c_rarg4\n+  \/\/ state = c_rarg5 - GHASH.state\n+  \/\/ subkeyHtbl = c_rarg6 - powers of H\n+  \/\/ counter = c_rarg7 - 16 bytes of CTR\n+  \/\/ return - number of processed bytes\n+  address generate_galoisCounterMode_AESCrypt() {\n+    assert(UseGHASHIntrinsics, \"need GHASH instructions (Zvkg extension) and Zvbb support\");\n+    assert(UseAESCTRIntrinsics, \"need AES instructions (Zvkned extension) and Zbb extension support\");\n+\n+    __ align(CodeEntryAlignment);\n+    StubId stub_id = StubId::stubgen_galoisCounterMode_AESCrypt_id;\n+    StubCodeMark mark(this, stub_id);\n+\n+    const Register in         = c_rarg0;\n+    const Register input_len  = c_rarg1;\n+    const Register ct         = c_rarg2;\n+    const Register out        = c_rarg3;\n+    const Register key        = c_rarg4;\n+    const Register state      = c_rarg5;\n+    const Register subkeyHtbl = c_rarg6;\n+    const Register counter    = c_rarg7;\n+\n+    const Register keylen     = x28;\n+    const Register blocks     = x29;\n+\n+    VectorRegister working_vregs[] = {\n+      v1, v2, v3, v4, v5, v6, v7, v8,\n+      v9, v10, v11, v12, v13, v14, v15\n+    };\n+\n+    VectorRegister vtmp1      = v16;\n+    VectorRegister vtmp2      = v17;\n+    VectorRegister vtmp3      = v18;\n+\n+    const address start = __ pc();\n+    __ enter();\n+\n+    Label L_exit;\n+    \/\/ Requires PARALLEN_LEN (512) bytes to efficiently use the intrinsic\n+    __ andi(input_len, input_len, -512);\n+    __ beqz(input_len, L_exit);\n+\n+    Label L_aes128, L_aes192;\n+    \/\/ Compute #rounds for AES based on the length of the key array\n+    __ lwu(keylen, Address(key, arrayOopDesc::length_offset_in_bytes() - arrayOopDesc::base_offset_in_bytes(T_INT)));\n+    __ mv(t0, 52); \/\/ key length could be only {11, 13, 15} * 4 = {44, 52, 60}\n+    __ bltu(keylen, t0, L_aes128);\n+    __ beq(keylen, t0, L_aes192);\n+    \/\/ Else we fallthrough to the biggest case (256-bit key size)\n+\n+    \/\/ Note: the following function performs crypt with key += 15*16\n+    gcm_counterMode_AESCrypt_blocks(15, in, out, key, counter, input_len, working_vregs, blocks, vtmp1, vtmp2, vtmp3);\n+    gcm_ghash_blocks(state, subkeyHtbl, ct, input_len, blocks, vtmp1, vtmp2, vtmp3);\n+\n+    \/\/ Note: the following function performs crypt with key += 13*16\n+    __ bind(L_aes192);\n+    gcm_counterMode_AESCrypt_blocks(13, in, out, key, counter, input_len, working_vregs, blocks, vtmp1, vtmp2, vtmp3);\n+    gcm_ghash_blocks(state, subkeyHtbl, ct, input_len, blocks, vtmp1, vtmp2, vtmp3);\n+\n+    \/\/ Note: the following function performs crypt with key += 11*16\n+    __ bind(L_aes128);\n+    gcm_counterMode_AESCrypt_blocks(11, in, out, key, counter, input_len, working_vregs, blocks, vtmp1, vtmp2, vtmp3);\n+    gcm_ghash_blocks(state, subkeyHtbl, ct, input_len, blocks, vtmp1, vtmp2, vtmp3);\n+\n+    __ bind(L_exit);\n+    __ mv(x10, input_len);\n+    __ leave();\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -7293,0 +7417,4 @@\n+    if (UseAESCTRIntrinsics && UseGHASHIntrinsics) {\n+      StubRoutines::_galoisCounterMode_AESCrypt = generate_galoisCounterMode_AESCrypt();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"}]}