{"files":[{"patch":"@@ -2723,0 +2723,4 @@\n+      \/\/ If we get an out-of-range offset it is a bug in the compiler,\n+      \/\/ so we assert here.\n+      assert(Address::offset_ok_for_immed(addr.offset(), exact_log2(size_in_memory)),\n+             \"c2 compiler bug\");\n@@ -5184,1 +5188,1 @@\n-operand indOffI1(iRegP reg, immIOffset1 off)\n+operand indOffI1(iRegP reg, iRegN regn, immIOffset1 off)\n@@ -5186,0 +5190,1 @@\n+  predicate(!n->in(2)->is_DecodeN() || CompressedOops::shift() == 0);\n@@ -5188,0 +5193,1 @@\n+  match(AddP (DecodeN regn) off);\n@@ -5198,1 +5204,1 @@\n-operand indOffI2(iRegP reg, immIOffset2 off)\n+operand indOffI2(iRegP reg, iRegN regn, immIOffset2 off)\n@@ -5200,0 +5206,1 @@\n+  predicate(!n->in(2)->is_DecodeN() || CompressedOops::shift() == 0);\n@@ -5202,0 +5209,1 @@\n+  match(AddP (DecodeN regn) off);\n@@ -5212,1 +5220,1 @@\n-operand indOffI4(iRegP reg, immIOffset4 off)\n+operand indOffI4(iRegP reg, iRegN regn, immIOffset4 off)\n@@ -5214,0 +5222,1 @@\n+  predicate(!n->in(2)->is_DecodeN() || CompressedOops::shift() == 0);\n@@ -5216,0 +5225,1 @@\n+  match(AddP (DecodeN regn) off);\n@@ -5226,1 +5236,1 @@\n-operand indOffI8(iRegP reg, immIOffset8 off)\n+operand indOffI8(iRegP reg, iRegN regn, immIOffset8 off)\n@@ -5228,0 +5238,1 @@\n+  predicate(!n->in(2)->is_DecodeN() || CompressedOops::shift() == 0);\n@@ -5230,0 +5241,1 @@\n+  match(AddP (DecodeN regn) off);\n@@ -5254,1 +5266,1 @@\n-operand indOffL1(iRegP reg, immLoffset1 off)\n+operand indOffL1(iRegP reg, iRegN regn, immLoffset1 off)\n@@ -5256,0 +5268,1 @@\n+  predicate(!n->in(2)->is_DecodeN() || CompressedOops::shift() == 0);\n@@ -5258,0 +5271,1 @@\n+  match(AddP (DecodeN regn) off);\n@@ -5268,1 +5282,1 @@\n-operand indOffL2(iRegP reg, immLoffset2 off)\n+operand indOffL2(iRegP reg, iRegN regn, immLoffset2 off)\n@@ -5270,0 +5284,1 @@\n+  predicate(!n->in(2)->is_DecodeN() || CompressedOops::shift() == 0);\n@@ -5272,0 +5287,1 @@\n+  match(AddP (DecodeN regn) off);\n@@ -5282,1 +5298,1 @@\n-operand indOffL4(iRegP reg, immLoffset4 off)\n+operand indOffL4(iRegP reg, iRegN regn, immLoffset4 off)\n@@ -5284,0 +5300,1 @@\n+  predicate(!n->in(2)->is_DecodeN() || CompressedOops::shift() == 0);\n@@ -5286,0 +5303,1 @@\n+  match(AddP (DecodeN regn) off);\n@@ -5296,1 +5314,1 @@\n-operand indOffL8(iRegP reg, immLoffset8 off)\n+operand indOffL8(iRegP reg, iRegN regn, immLoffset8 off)\n@@ -5298,0 +5316,1 @@\n+  predicate(!n->in(2)->is_DecodeN() || CompressedOops::shift() == 0);\n@@ -5300,0 +5319,1 @@\n+  match(AddP (DecodeN regn) off);\n@@ -5399,120 +5419,0 @@\n-operand indOffIN1(iRegN reg, immIOffset1 off)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (DecodeN reg) off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\\t# narrow\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffLN1(iRegN reg, immLoffset1 off)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (DecodeN reg) off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\\t# narrow\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffIN2(iRegN reg, immIOffset2 off)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (DecodeN reg) off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\\t# narrow\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffLN2(iRegN reg, immLoffset2 off)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (DecodeN reg) off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\\t# narrow\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffIN4(iRegN reg, immIOffset4 off)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (DecodeN reg) off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\\t# narrow\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffLN4(iRegN reg, immLoffset4 off)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (DecodeN reg) off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\\t# narrow\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffIN8(iRegN reg, immIOffset8 off)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (DecodeN reg) off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\\t# narrow\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffLN8(iRegN reg, immLoffset8 off)\n-%{\n-  predicate(CompressedOops::shift() == 0);\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP (DecodeN reg) off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\\t# narrow\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n@@ -5752,1 +5652,1 @@\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN1, indOffLN1);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);\n@@ -5755,1 +5655,1 @@\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN2, indOffLN2);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);\n@@ -5758,1 +5658,1 @@\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN4, indOffLN4);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);\n@@ -5761,1 +5661,1 @@\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN8, indOffLN8);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);\n@@ -5766,2 +5666,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN,\n-               indOffIN1, indOffLN1, indOffIN2, indOffLN2, indOffIN4, indOffLN4, indOffIN8, indOffLN8);\n+               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":33,"deletions":134,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -252,0 +252,9 @@\n+    \/\/ If there are multiple arguments, we need to insert\n+    \/\/ parentheses for predicate so that these arguments\n+    \/\/ can be chained together logically with \"&&\".\n+    if (op->_matrule &&\n+        !(op->_matrule->_lChild == nullptr &&\n+          op->_matrule->_rChild == nullptr)) {\n+      pred = InstructForm::build_predicate(op->_matrule, op->_predicate);\n+    }\n+\n@@ -299,1 +308,1 @@\n-    Predicate *pred  =  instr->build_predicate();\n+    Predicate* pred  = InstructForm::build_predicate(instr->_matrule, instr->_predicate);\n","filename":"src\/hotspot\/share\/adlc\/archDesc.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1528,4 +1528,5 @@\n-\/\/ Build instruction predicates.  If the user uses the same operand name\n-\/\/ twice, we need to check that the operands are pointer-eequivalent in\n-\/\/ the DFA during the labeling process.\n-Predicate *InstructForm::build_predicate() {\n+\/\/ Build predicates for instructions or operands.\n+\/\/\n+\/\/ If the user uses the same operand name twice, we need to check that\n+\/\/ the operands are pointer-equivalent in the DFA during the labeling process.\n+Predicate* InstructForm::build_predicate(MatchRule* matrule, Predicate* predicate) {\n@@ -1536,2 +1537,2 @@\n-  MatchNode *mnode =\n-    strcmp(_matrule->_opType, \"Set\") ? _matrule : _matrule->_rChild;\n+  MatchNode* mnode =\n+    strcmp(matrule->_opType, \"Set\") ? matrule : matrule->_rChild;\n@@ -1542,1 +1543,1 @@\n-  if (_predicate) {\n+  if (predicate) {\n@@ -1545,1 +1546,1 @@\n-    strncpy(s, _predicate->_pred, buflen - strlen(s) - 1);\n+    strncpy(s, predicate->_pred, buflen - strlen(s) - 1);\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -224,4 +224,5 @@\n-  \/\/ Build instruction predicates.  If the user uses the same operand name\n-  \/\/ twice, we need to check that the operands are pointer-eequivalent in\n-  \/\/ the DFA during the labeling process.\n-  Predicate *build_predicate();\n+  \/\/ Build predicates for instructions or operands.\n+  \/\/\n+  \/\/ If the user uses the same operand name twice, we need to check that the\n+  \/\/ operands are pointer-equivalent in the DFA during the labeling process.\n+  static Predicate* build_predicate(MatchRule* matrule, Predicate* predicate);\n","filename":"src\/hotspot\/share\/adlc\/formssel.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -4328,1 +4328,1 @@\n-      Predicate *pred  =  instr->build_predicate();\n+      Predicate* pred  = InstructForm::build_predicate(instr->_matrule, instr->_predicate);\n@@ -4349,1 +4349,1 @@\n-          Predicate *pred2  =  instr2->build_predicate();\n+          Predicate* pred2  = InstructForm::build_predicate(instr2->_matrule, instr2->_predicate);\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,172 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Arm Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.c2.aarch64;\n-\n-import jdk.internal.misc.Unsafe;\n-import jdk.test.lib.Asserts;\n-\n-\/**\n- * @test TestUnalignedAccessCompressedOops\n- * @summary AArch64: C2 compilation hits offset_ok_for_immed: assert \"c2 compiler bug\".\n- * @bug 8319690\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- * @requires os.arch==\"aarch64\" & vm.compiler2.enabled\n- * @run main\/othervm compiler.c2.aarch64.TestUnalignedAccessCompressedOops\n- * @run main\/othervm -Xcomp -XX:-TieredCompilation -Xmx1g\n- *                   -XX:CompileCommand=compileonly,compiler.c2.aarch64.TestUnalignedAccessCompressedOops*::<clinit>\n- *                   compiler.c2.aarch64.TestUnalignedAccessCompressedOops\n- *\/\n-\n-public class TestUnalignedAccessCompressedOops {\n-\n-    public static final int LEN = 2040;\n-\n-    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-    static void sink(int x) {}\n-\n-    public static long lseed = 1;\n-    public static int iseed = 2;\n-    public static short sseed = 3;\n-    public static byte bseed = 4;\n-    public static long lres = lseed;\n-    public static int ires = iseed;\n-    public static short sres = sseed;\n-    public static byte bres = bseed;\n-\n-    public static class TestLong {\n-\n-        private static final byte[] BYTES = new byte[LEN];\n-        private static final long rawdata = 0xbeef;\n-        private static final long data;\n-\n-        static {\n-            sink(2);\n-            \/\/ Signed immediate byte offset: range -256 to 255\n-            \/\/ Positive immediate byte offset: a multiple of 8 in the range 0 to 32760\n-            \/\/ Other immediate byte offsets can't be encoded in the instruction field.\n-\n-            \/\/ 1030 can't be encoded as \"base + offset\" mode into the instruction field.\n-            UNSAFE.putLongUnaligned(BYTES, 1030, rawdata);\n-            lres += UNSAFE.getLongUnaligned(BYTES, 1030);\n-            \/\/ 127 can be encoded into simm9 field.\n-            UNSAFE.putLongUnaligned(BYTES, 127, lres);\n-            lres += UNSAFE.getLongUnaligned(BYTES, 127);\n-            \/\/ 1096 can be encoded into uimm12 field.\n-            UNSAFE.putLongUnaligned(BYTES, 1096, lres);\n-            data = UNSAFE.getLongUnaligned(BYTES, 1096);\n-        }\n-\n-    }\n-\n-    public static class TestInt {\n-\n-        private static final byte[] BYTES = new byte[LEN];\n-        private static final int rawdata = 0xbeef;\n-        private static final int data;\n-        static {\n-            sink(2);\n-            \/\/ Signed immediate byte offset: range -256 to 255\n-            \/\/ Positive immediate byte offset, a multiple of 4 in the range 0 to 16380\n-            \/\/ Other immediate byte offsets can't be encoded in the instruction field.\n-\n-            \/\/ 274 can't be encoded as \"base + offset\" mode into the instruction field.\n-            UNSAFE.putIntUnaligned(BYTES, 274, rawdata);\n-            ires += UNSAFE.getIntUnaligned(BYTES, 274);\n-            \/\/ 255 can be encoded into simm9 field.\n-            UNSAFE.putIntUnaligned(BYTES, 255, ires);\n-            ires += UNSAFE.getIntUnaligned(BYTES, 255);\n-            \/\/ 528 can be encoded into uimm12 field.\n-            UNSAFE.putIntUnaligned(BYTES, 528, ires);\n-            data = UNSAFE.getIntUnaligned(BYTES, 528);\n-        }\n-\n-    }\n-\n-    public static class TestShort {\n-\n-        private static final byte[] BYTES = new byte[LEN];\n-        private static final short rawdata = (short)0xbeef;\n-        private static final short data;\n-        static {\n-            sink(2);\n-            \/\/ Signed immediate byte offset: range -256 to 255\n-            \/\/ Positive immediate byte offset: a multiple of 2 in the range 0 to 8190\n-            \/\/ Other immediate byte offsets can't be encoded in the instruction field.\n-\n-            \/\/ 257 can't be encoded as \"base + offset\" mode into the instruction field.\n-            UNSAFE.putShortUnaligned(BYTES, 257, rawdata);\n-            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 257));\n-            \/\/ 253 can be encoded into simm9 field.\n-            UNSAFE.putShortUnaligned(BYTES, 253, sres);\n-            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 253));\n-            \/\/ 272 can be encoded into uimm12 field.\n-            UNSAFE.putShortUnaligned(BYTES, 272, sres);\n-            data = UNSAFE.getShortUnaligned(BYTES, 272);\n-        }\n-\n-    }\n-\n-    public static class TestByte {\n-\n-        private static final byte[] BYTES = new byte[LEN];\n-        private static final byte rawdata = (byte)0x3f;\n-        private static final byte data;\n-        static {\n-            sink(2);\n-            \/\/ Signed immediate byte offset: range -256 to 255\n-            \/\/ Positive immediate byte offset: range 0 to 4095\n-            \/\/ Other immediate byte offsets can't be encoded in the instruction field.\n-\n-            \/\/ 272 can be encoded into simm9 field.\n-            UNSAFE.putByte(BYTES, 272, rawdata);\n-            bres = (byte) (bres + UNSAFE.getByte(BYTES, 272));\n-            \/\/ 53 can be encoded into simm9 field.\n-            UNSAFE.putByte(BYTES, 53, bres);\n-            bres = (byte) (bres + UNSAFE.getByte(BYTES, 53));\n-            \/\/ 1027 can be encoded into uimm12 field.\n-            UNSAFE.putByte(BYTES, 1027, bres);\n-            data = UNSAFE.getByte(BYTES, 1027);\n-        }\n-\n-    }\n-\n-    static void test() {\n-        TestLong ta = new TestLong();\n-        Asserts.assertEquals(ta.data, (ta.rawdata + lseed) * 2, \"putUnaligned long failed!\");\n-\n-        TestInt tb = new TestInt();\n-        Asserts.assertEquals(tb.data, (tb.rawdata + iseed) * 2, \"putUnaligned int failed!\");\n-\n-        TestShort tc = new TestShort();\n-        Asserts.assertEquals(tc.data, (short) (((short) (tc.rawdata + sseed)) * 2), \"putUnaligned short failed!\");\n-\n-        TestByte td = new TestByte();\n-        Asserts.assertEquals(td.data, (byte) (((byte) (td.rawdata + bseed)) * 2), \"put byte failed!\");\n-    }\n-\n-    public static void main(String[] strArr) {\n-        test();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestUnalignedAccessCompressedOops.java","additions":0,"deletions":172,"binary":false,"changes":172,"status":"deleted"}]}