[{"commit":{"message":"8319690: [AArch64] C2 compilation hits offset_ok_for_immed: assert \"c2 compiler bug\"\n\nOn LP64 systems, if the heap can be moved into low virtual\naddress space (below 4GB) and the heap size is smaller than the\ninteresting threshold of 4 GB, we can use unscaled decoding\npattern for narrow klass decoding. It means that a generic field\nreference can be decoded by:\n```\ncast<64> (32-bit compressed reference) + field_offset\n```\n\nWhen the `field_offset` is an immediate, on aarch64 platform, the\nunscaled decoding pattern can match perfectly with a direct\naddressing mode, i.e., `base_plus_offset`, supported by LDR\/STR\ninstructions. But for certain data width, not all immediates can\nbe encoded in the instruction field of LDR\/STR[1]. The ranges are\ndifferent as data widths vary.\n\nFor example, when we try to load a value of long type at offset of\n`1030`, the address expression is `(AddP (DecodeN base) 1030)`.\nBefore the patch, the expression was matching with\n`operand indOffIN()`. But, for 64-bit LDR\/STR, signed immediate\nbyte offset must be in the range -256 to 255 or positive immediate\nbyte offset must be a multiple of 8 in the range 0 to 32760[2].\n`1030` can't be encoded in the instruction field. So, after\nmatching, when we do checking for instruction encoding, the\nassertion would fail.\n\nIn this patch, we're going to filter out invalid immediates\nwhen deciding if current addressing mode can be matched as\n`base_plus_offset`. We introduce `indOffIN4\/indOffLN4` and\n`indOffIN8\/indOffLN8` for 32-bit data type and 64-bit data\ntype separately in the patch. E.g., for `memory4`, we remove\nthe generic `indOffIN\/indOffLN`, which matches wrong unscaled\nimmediate range, and replace them with `indOffIN4\/indOffLN4`\ninstead.\n\nSince 8-bit and 16-bit LDR\/STR instructions also support the\nunscaled decoding pattern, we add the addressing mode in the\nlists of `memory1` and `memory2` by introducing\n`indOffIN1\/indOffLN1` and `indOffIN2\/indOffLN2`.\n\nWe also remove unused operands `indOffI\/indOffl\/indOffIN\/indOffLN`\nto avoid misuse.\n\nTier 1-3 passed on aarch64.\n\n[1] https:\/\/github.com\/openjdk\/jdk\/blob\/8db7bad992a0f31de9c7e00c2657c18670539102\/src\/hotspot\/cpu\/aarch64\/assembler_aarch64.inline.hpp#L33\n[2] https:\/\/developer.arm.com\/documentation\/ddi0602\/2023-09\/Base-Instructions\/LDR--immediate---Load-Register--immediate--?lang=en"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestUnalignedAccessCompressedOops.java"}],"sha":"1895cf3112d341b0ae8beb6dd9d332f6a2c5d5fc"}]