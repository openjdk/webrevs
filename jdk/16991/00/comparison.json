{"files":[{"patch":"@@ -5669,14 +5669,0 @@\n-operand indOffI(iRegP reg, immIOffset off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n@@ -5753,14 +5739,0 @@\n-operand indOffL(iRegP reg, immLoffset off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n@@ -5912,1 +5884,1 @@\n-operand indOffIN(iRegN reg, immIOffset off)\n+operand indOffIN1(iRegN reg, immIOffset1 off)\n@@ -5927,1 +5899,1 @@\n-operand indOffLN(iRegN reg, immLoffset off)\n+operand indOffLN1(iRegN reg, immLoffset1 off)\n@@ -5942,0 +5914,89 @@\n+operand indOffIN2(iRegN reg, immIOffset2 off)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (DecodeN reg) off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\\t# narrow\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffLN2(iRegN reg, immLoffset2 off)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (DecodeN reg) off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\\t# narrow\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffIN4(iRegN reg, immIOffset4 off)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (DecodeN reg) off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\\t# narrow\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffLN4(iRegN reg, immLoffset4 off)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (DecodeN reg) off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\\t# narrow\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffIN8(iRegN reg, immIOffset8 off)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (DecodeN reg) off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\\t# narrow\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n+operand indOffLN8(iRegN reg, immLoffset8 off)\n+%{\n+  predicate(CompressedOops::shift() == 0);\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (DecodeN reg) off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\\t# narrow\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n@@ -6192,1 +6253,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN1, indOffLN1);\n@@ -6195,1 +6256,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN2, indOffLN2);\n@@ -6198,1 +6259,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN4, indOffLN4);\n@@ -6201,1 +6262,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN8, indOffLN8);\n@@ -6206,1 +6267,2 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);\n+               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN,\n+               indOffIN1, indOffLN1, indOffIN2, indOffLN2, indOffIN4, indOffLN4, indOffIN8, indOffLN8);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":97,"deletions":35,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.aarch64;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test TestUnalignedAccessCompressedOops\n+ * @summary AArch64: C2 compilation hits offset_ok_for_immed: assert \"c2 compiler bug\".\n+ * @bug 8319690\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @requires os.arch==\"aarch64\" & vm.compiler2.enabled\n+ * @run main\/othervm compiler.c2.aarch64.TestUnalignedAccessCompressedOops\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -Xmx1g\n+ *                   -XX:CompileCommand=compileonly,compiler.c2.aarch64.TestUnalignedAccessCompressedOops*::<clinit>\n+ *                   compiler.c2.aarch64.TestUnalignedAccessCompressedOops\n+ *\/\n+\n+public class TestUnalignedAccessCompressedOops {\n+\n+    public static final int LEN = 2040;\n+\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    static void sink(int x) {}\n+\n+    public static long lseed = 1;\n+    public static int iseed = 2;\n+    public static short sseed = 3;\n+    public static byte bseed = 4;\n+    public static long lres = lseed;\n+    public static int ires = iseed;\n+    public static short sres = sseed;\n+    public static byte bres = bseed;\n+\n+    public static class TestLong {\n+\n+        private static final byte[] BYTES = new byte[LEN];\n+        private static final long rawdata = 0xbeef;\n+        private static final long data;\n+\n+        static {\n+            sink(2);\n+            \/\/ Signed immediate byte offset: range -256 to 255\n+            \/\/ Positive immediate byte offset: a multiple of 8 in the range 0 to 32760\n+            \/\/ Other immediate byte offsets can't be encoded in the instruction field.\n+\n+            \/\/ 1030 can't be encoded as \"base + offset\" mode into the instruction field.\n+            UNSAFE.putLongUnaligned(BYTES, 1030, rawdata);\n+            lres += UNSAFE.getLongUnaligned(BYTES, 1030);\n+            \/\/ 127 can be encoded into simm9 field.\n+            UNSAFE.putLongUnaligned(BYTES, 127, lres);\n+            lres += UNSAFE.getLongUnaligned(BYTES, 127);\n+            \/\/ 1096 can be encoded into uimm12 field.\n+            UNSAFE.putLongUnaligned(BYTES, 1096, lres);\n+            data = UNSAFE.getLongUnaligned(BYTES, 1096);\n+        }\n+\n+    }\n+\n+    public static class TestInt {\n+\n+        private static final byte[] BYTES = new byte[LEN];\n+        private static final int rawdata = 0xbeef;\n+        private static final int data;\n+        static {\n+            sink(2);\n+            \/\/ Signed immediate byte offset: range -256 to 255\n+            \/\/ Positive immediate byte offset, a multiple of 4 in the range 0 to 16380\n+            \/\/ Other immediate byte offsets can't be encoded in the instruction field.\n+\n+            \/\/ 274 can't be encoded as \"base + offset\" mode into the instruction field.\n+            UNSAFE.putIntUnaligned(BYTES, 274, rawdata);\n+            ires += UNSAFE.getIntUnaligned(BYTES, 274);\n+            \/\/ 255 can be encoded into simm9 field.\n+            UNSAFE.putIntUnaligned(BYTES, 255, ires);\n+            ires += UNSAFE.getIntUnaligned(BYTES, 255);\n+            \/\/ 528 can be encoded into uimm12 field.\n+            UNSAFE.putIntUnaligned(BYTES, 528, ires);\n+            data = UNSAFE.getIntUnaligned(BYTES, 528);\n+        }\n+\n+    }\n+\n+    public static class TestShort {\n+\n+        private static final byte[] BYTES = new byte[LEN];\n+        private static final short rawdata = (short)0xbeef;\n+        private static final short data;\n+        static {\n+            sink(2);\n+            \/\/ Signed immediate byte offset: range -256 to 255\n+            \/\/ Positive immediate byte offset: a multiple of 2 in the range 0 to 8190\n+            \/\/ Other immediate byte offsets can't be encoded in the instruction field.\n+\n+            \/\/ 257 can't be encoded as \"base + offset\" mode into the instruction field.\n+            UNSAFE.putShortUnaligned(BYTES, 257, rawdata);\n+            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 257));\n+            \/\/ 253 can be encoded into simm9 field.\n+            UNSAFE.putShortUnaligned(BYTES, 253, sres);\n+            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 253));\n+            \/\/ 272 can be encoded into uimm12 field.\n+            UNSAFE.putShortUnaligned(BYTES, 272, sres);\n+            data = UNSAFE.getShortUnaligned(BYTES, 272);\n+        }\n+\n+    }\n+\n+    public static class TestByte {\n+\n+        private static final byte[] BYTES = new byte[LEN];\n+        private static final byte rawdata = (byte)0x3f;\n+        private static final byte data;\n+        static {\n+            sink(2);\n+            \/\/ Signed immediate byte offset: range -256 to 255\n+            \/\/ Positive immediate byte offset: range 0 to 4095\n+            \/\/ Other immediate byte offsets can't be encoded in the instruction field.\n+\n+            \/\/ 272 can be encoded into simm9 field.\n+            UNSAFE.putByte(BYTES, 272, rawdata);\n+            bres = (byte) (bres + UNSAFE.getByte(BYTES, 272));\n+            \/\/ 53 can be encoded into simm9 field.\n+            UNSAFE.putByte(BYTES, 53, bres);\n+            bres = (byte) (bres + UNSAFE.getByte(BYTES, 53));\n+            \/\/ 1027 can be encoded into uimm12 field.\n+            UNSAFE.putByte(BYTES, 1027, bres);\n+            data = UNSAFE.getByte(BYTES, 1027);\n+        }\n+\n+    }\n+\n+    static void test() {\n+        TestLong ta = new TestLong();\n+        Asserts.assertEquals(ta.data, (ta.rawdata + lseed) * 2, \"putUnaligned long failed!\");\n+\n+        TestInt tb = new TestInt();\n+        Asserts.assertEquals(tb.data, (tb.rawdata + iseed) * 2, \"putUnaligned int failed!\");\n+\n+        TestShort tc = new TestShort();\n+        Asserts.assertEquals(tc.data, (short) (((short) (tc.rawdata + sseed)) * 2), \"putUnaligned short failed!\");\n+\n+        TestByte td = new TestByte();\n+        Asserts.assertEquals(td.data, (byte) (((byte) (td.rawdata + bseed)) * 2), \"put byte failed!\");\n+    }\n+\n+    public static void main(String[] strArr) {\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestUnalignedAccessCompressedOops.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"}]}