{"files":[{"patch":"@@ -1634,2 +1634,2 @@\n-  \/\/ Class to keep track of wins in split_through_phi.\n-  class SplitWins {\n+  \/\/ Class to keep track of wins in split_thru_phi.\n+  class SplitThruPhiWins {\n@@ -1637,0 +1637,1 @@\n+    \/\/ Sum of all wins regardless of where they happen.\n@@ -1638,0 +1639,1 @@\n+    \/\/ Number of wins on a loop entry edge, which only pays dividens once per loop execution.\n@@ -1639,0 +1641,1 @@\n+    \/\/ Number of wins on a loop back-edge, which pay dividends on every iteration.\n@@ -1642,1 +1645,1 @@\n-    SplitWins() :\n+    SplitThruPhiWins() :\n@@ -1658,4 +1661,10 @@\n-    \/\/ in the policy. In loops, we want to avoid wins on the entry edge since\n-    \/\/ that messes up the loop structure more often than not and prevents RCE\n-    \/\/ and vectorization down the line. If the policy is less than 0, every\n-    \/\/ split if profitable.\n+    \/\/ in the policy. In loops, we need to be careful when splitting, because it\n+    \/\/ can sufficiently rearrange the loop structure to prevent RCE and thus\n+    \/\/ vectorization. Thus, we only deem splitting profitable if the win of a\n+    \/\/ split is not on the entry edge, as such wins only pay off once and have\n+    \/\/ a high chance of messing up the loop structure. However, if there are\n+    \/\/ wins on the entry edge and also sufficient wins on the backadge, which\n+    \/\/ pay off on every iteration, a split is also deemed profiable.\n+    \/\/ If the policy is less than 0, a split is always profitable, i.e. we always\n+    \/\/ split. This is needed when we split a node and then must also split a\n+    \/\/ dependant node, i.e. spliting a Bool node after splitting a Cmp node.\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  SplitWins wins;\n+  SplitThruPhiWins wins;\n@@ -232,9 +232,1 @@\n-    tty->print(\"Split N%d through Phi N%d in \", n->_idx, phi->_idx);\n-    if (region->is_CountedLoop()) {\n-      tty->print(\"CountedLoop \");\n-    } else if (region->is_Loop()) {\n-      tty->print(\"Loop \");\n-    } else {\n-      tty->print(\"Region \");\n-    }\n-    tty->print_cr(\"N%d\", region->_idx);\n+    tty->print(\"Split N%d through Phi N%d in %s N%d\", n->_idx, phi->_idx, region->Name(), region->_idx);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,0 +52,5 @@\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentByteSizeLongLoopLimit.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,2 +46,5 @@\n-        f.addScenarios(new Scenario(0, \"-XX:+AlignVector\"),\n-                       new Scenario(1, \"-XX:-AlignVector\"));\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentField.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}