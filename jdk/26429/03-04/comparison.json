{"files":[{"patch":"@@ -1637,0 +1637,3 @@\n+    \/\/ Region containing the phi we are splitting through.\n+    const Node* _region;\n+\n@@ -1648,1 +1651,2 @@\n-    SplitThruPhiWins() :\n+    SplitThruPhiWins(const Node* region) :\n+      _region(region),\n@@ -1654,2 +1658,2 @@\n-    void add_win(Node* region, int ctrl_index) {\n-      if (region->is_Loop() && ctrl_index == LoopNode::EntryControl) {\n+    void add_win(int ctrl_index) {\n+      if (_region->is_Loop() && ctrl_index == LoopNode::EntryControl) {\n@@ -1657,1 +1661,1 @@\n-      } else if (region->is_Loop() && ctrl_index == LoopNode::LoopBackControl) {\n+      } else if (_region->is_Loop() && ctrl_index == LoopNode::LoopBackControl) {\n@@ -1664,10 +1668,2 @@\n-    \/\/ in the policy. In loops, we need to be careful when splitting, because it\n-    \/\/ can sufficiently rearrange the loop structure to prevent RCE and thus\n-    \/\/ vectorization. Thus, we only deem splitting profitable if the win of a\n-    \/\/ split is not on the entry edge, as such wins only pay off once and have\n-    \/\/ a high chance of messing up the loop structure. However, if there are\n-    \/\/ wins on the entry edge and also sufficient wins on the backadge, which\n-    \/\/ pay off on every iteration, a split is also deemed profiable.\n-    \/\/ If the policy is less than 0, a split is always profitable, i.e. we always\n-    \/\/ split. This is needed when we split a node and then must also split a\n-    \/\/ dependant node, i.e. spliting a Bool node after splitting a Cmp node.\n+    \/\/ in the policy. However, for loops we need to take into account where the\n+    \/\/ wins happen.\n@@ -1675,1 +1671,16 @@\n-      return policy < 0 || (_loop_entry_wins == 0 && _total_wins > policy) || _loop_back_wins > policy;\n+      assert(_region->is_Loop() || (_loop_entry_wins == 0 && _loop_back_wins == 0), \"wins on loop edges without a loop\");\n+      assert(!_region->is_Loop() || _total_wins == _loop_entry_wins + _loop_back_wins, \"missed some win\");\n+      \/\/ In loops, we need to be careful when splitting, because splitting nodes\n+      \/\/ related to the iv through the phi can sufficiently rearrange the loop\n+      \/\/ structure to prevent RCE and thus vectorization. Thus, we only deem splitting\n+      \/\/ profitable if the win of a split is not on the entry edge, as such wins\n+      \/\/ only pay off once and have a high chance of messing up the loop structure.\n+      return (_loop_entry_wins == 0 && _total_wins > policy) ||\n+      \/\/ If there are wins on the entry edge but the backadge also has sufficient wins,\n+      \/\/ there is sufficient profitability to spilt regardless of the risk of messing\n+      \/\/ up the loop structure.\n+             _loop_back_wins > policy ||\n+      \/\/ If the policy is less than 0, a split is always profitable, i.e. we always\n+      \/\/ split. This is needed when we split a node and then must also split a\n+      \/\/ dependant node, i.e. spliting a Bool node after splitting a Cmp node.\n+             policy < 0;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":26,"deletions":15,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  SplitThruPhiWins wins;\n+  SplitThruPhiWins wins(region);\n@@ -123,1 +123,1 @@\n-      wins.add_win(region, i);\n+      wins.add_win(i);\n@@ -138,1 +138,1 @@\n-        wins.add_win(region, i);\n+        wins.add_win(i);\n@@ -146,1 +146,1 @@\n-          wins.add_win(region, i);\n+          wins.add_win(i);\n@@ -233,1 +233,2 @@\n-    tty->print(\"Split N%d through Phi N%d in %s N%d\", n->_idx, phi->_idx, region->Name(), region->_idx);\n+    tty->print(\"Split %s N%d through Phi N%d in %s N%d\",\n+               n->Name(), n->_idx, phi->_idx, region->Name(), region->_idx);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -53,4 +53,2 @@\n-        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n-                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n-                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.addScenarios(new Scenario(0, \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+ShortRunningLongLoop\"));\n@@ -61,2 +59,2 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_ANY, \"> 0\",\n-                  IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY,        \"> 0\",\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE + \"min(max_int, max_long)\",        \"> 0\",\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentByteSizeLongLoopLimit.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -56,3 +56,3 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_ANY, \"> 0\",\n-                  IRNode.ADD_VB, IRNode.VECTOR_SIZE_ANY,        \"> 0\",\n-                  IRNode.STORE_VECTOR,                          \"> 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentField.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}