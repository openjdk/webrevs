{"files":[{"patch":"@@ -1632,0 +1632,45 @@\n+\n+private:\n+  \/\/ Class to keep track of wins in split_thru_phi.\n+  class SplitThruPhiWins {\n+  private:\n+    \/\/ Sum of all wins regardless of where they happen.\n+    int _total_wins;\n+    \/\/ Number of wins on a loop entry edge, which only pays dividens once per loop execution.\n+    int _loop_entry_wins;\n+    \/\/ Number of wins on a loop back-edge, which pay dividends on every iteration.\n+    int _loop_back_wins;\n+\n+  public:\n+    SplitThruPhiWins() :\n+      _total_wins(0),\n+      _loop_entry_wins(0),\n+      _loop_back_wins(0) {};\n+\n+    void reset() {_total_wins = 0; _loop_entry_wins = 0; _loop_back_wins = 0;}\n+    void add_win(Node* region, int ctrl_index) {\n+      if (region->is_Loop() && ctrl_index == LoopNode::EntryControl) {\n+        _loop_entry_wins++;\n+      } else if (region->is_Loop() && ctrl_index == LoopNode::LoopBackControl) {\n+        _loop_back_wins++;\n+      }\n+      _total_wins++;\n+    }\n+    \/\/ Is this split profitable with respect to the policy?\n+    \/\/ In general this means that the split has to have more wins than specified\n+    \/\/ in the policy. In loops, we need to be careful when splitting, because it\n+    \/\/ can sufficiently rearrange the loop structure to prevent RCE and thus\n+    \/\/ vectorization. Thus, we only deem splitting profitable if the win of a\n+    \/\/ split is not on the entry edge, as such wins only pay off once and have\n+    \/\/ a high chance of messing up the loop structure. However, if there are\n+    \/\/ wins on the entry edge and also sufficient wins on the backadge, which\n+    \/\/ pay off on every iteration, a split is also deemed profiable.\n+    \/\/ If the policy is less than 0, a split is always profitable, i.e. we always\n+    \/\/ split. This is needed when we split a node and then must also split a\n+    \/\/ dependant node, i.e. spliting a Bool node after splitting a Cmp node.\n+    bool profitable(int policy) const {\n+      return policy < 0 || (_loop_entry_wins == 0 && _total_wins > policy) || _loop_back_wins > policy;\n+    }\n+  };\n+\n+public:\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -69,1 +70,1 @@\n-  int wins = 0;\n+  SplitThruPhiWins wins;\n@@ -122,1 +123,1 @@\n-      wins++;\n+      wins.add_win(region, i);\n@@ -137,1 +138,1 @@\n-        wins++;\n+        wins.add_win(region, i);\n@@ -145,1 +146,1 @@\n-          wins++;\n+          wins.add_win(region, i);\n@@ -168,1 +169,1 @@\n-      wins = 0;\n+      wins.reset();\n@@ -173,1 +174,1 @@\n-  if (wins <= policy) {\n+  if (!wins.profitable(policy)) {\n@@ -230,0 +231,4 @@\n+  if (TraceLoopOpts) {\n+    tty->print(\"Split N%d through Phi N%d in %s N%d\", n->_idx, phi->_idx, region->Name(), region->_idx);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n@@ -384,1 +384,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n@@ -420,1 +420,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"3\"})\n+    @IR(counts = {IRNode.ADD_I, \"2\"})\n@@ -456,1 +456,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.ADD_I, \"1\"})\n@@ -492,1 +492,1 @@\n-    @IR(counts = {IRNode.ADD_I, \"2\"})\n+    @IR(counts = {IRNode.ADD_I, \"1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/InvariantCodeMotionReassociateAddSub.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -709,3 +709,5 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n-    \/\/ Interestingly, it now vectorizes for native, but not for arrays.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -723,3 +725,5 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n-    \/\/ Interestingly, it now vectorizes for native, but not for arrays.\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, \"> 0\",\n+                  IRNode.ADD_VB,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -801,6 +805,0 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.ADD_VI,        \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"false\", \"AlignVector\", \"false\" },\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -810,1 +808,1 @@\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"true\", \"AlignVector\", \"false\" },\n+        applyIf = { \"AlignVector\", \"false\" },\n@@ -813,2 +811,0 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n@@ -826,6 +822,0 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.ADD_VI,        \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"false\", \"AlignVector\", \"false\" },\n-        applyIfPlatform = {\"64-bit\", \"true\"},\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -835,1 +825,1 @@\n-        applyIfAnd = { \"ShortRunningLongLoop\", \"true\", \"AlignVector\", \"false\" },\n+        applyIf = { \"AlignVector\", \"false\" },\n@@ -838,2 +828,0 @@\n-    \/\/ FAILS: invariants are sorted differently, because of differently inserted Cast.\n-    \/\/ See: JDK-8331659\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":12,"deletions":24,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+\/*\n+ * @test\n+ * @bug 8356176\n+ * @summary Test vectorization of loops over MemorySegment with unaligned access\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentByteSizeLongLoopLimit\n+ *\/\n+\n+\n+public class TestMemorySegmentByteSizeLongLoopLimit {\n+    public static int SIZE = 10_000;\n+\n+    public static int[] a = new int[SIZE];\n+    public static long[] b = new long[SIZE];\n+\n+    public static MemorySegment msA = MemorySegment.ofArray(a);\n+    public static MemorySegment msB = MemorySegment.ofArray(b);\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_ANY, \"> 0\",\n+                  IRNode.ADD_VI, IRNode.VECTOR_SIZE_ANY,        \"> 0\",\n+                  IRNode.STORE_VECTOR,                          \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    public static void test() {\n+        for (long i = 0; i < msA.byteSize() \/ 8L; i++) {\n+            int v = msA.get(ValueLayout.JAVA_INT_UNALIGNED, i * 4L);\n+            msB.set(ValueLayout.JAVA_LONG_UNALIGNED, i * 8L, v + 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentByteSizeLongLoopLimit.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Random;\n+import java.lang.foreign.*;\n+\n+\/*\n+ * @test\n+ * @bug 8356176\n+ * @summary Test vectorization of loops over MemorySegment stored in field\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegmentField\n+ *\/\n+\n+public class TestMemorySegmentField {\n+    static int SIZE = 10_000;\n+    static MemorySegment MS = Arena.ofAuto().allocate(SIZE * 4);\n+\n+    public static void main(String[] args) {\n+        TestFramework f = new TestFramework();\n+        f.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        f.addScenarios(new Scenario(0, \"-XX:-AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(1, \"-XX:+AlignVector\", \"-XX:-ShortRunningLongLoop\"),\n+                       new Scenario(2, \"-XX:-AlignVector\", \"-XX:+ShortRunningLongLoop\"),\n+                       new Scenario(3, \"-XX:+AlignVector\", \"-XX:+ShortRunningLongLoop\"));\n+        f.start();\n+    }\n+\n+    static int zeroInvarI = 0;\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_B, IRNode.VECTOR_SIZE_ANY, \"> 0\",\n+                  IRNode.ADD_VB, IRNode.VECTOR_SIZE_ANY,        \"> 0\",\n+                  IRNode.STORE_VECTOR,                          \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    public static void testFields() {\n+        int invar = zeroInvarI;\n+        for (long i = 0; i < MS.byteSize(); i++) {\n+            long adr = (long)(i) + (long)(invar);\n+            byte v = MS.get(ValueLayout.JAVA_BYTE, adr);\n+            MS.set(ValueLayout.JAVA_BYTE, adr, (byte)(v + 1));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegmentField.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-    \/\/ The ConvI2L can be split through the AddI, creating a mix of\n+    \/\/ The ConvI2L can be pushed through the AddI, creating a mix of\n@@ -135,2 +135,1 @@\n-        counts = {IRNode.POPULATE_INDEX, \"=0\"})\n-    \/\/ See: JDK-8332878\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n@@ -158,2 +157,1 @@\n-        counts = {IRNode.POPULATE_INDEX, \"=0\"})\n-    \/\/ See: JDK-8332878\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"}]}