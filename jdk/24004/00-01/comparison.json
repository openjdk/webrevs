{"files":[{"patch":"@@ -29,0 +29,2 @@\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -34,0 +37,2 @@\n+DEBUG_ONLY(InstanceKlass* _aot_init_class = nullptr;)\n+\n@@ -96,1 +101,1 @@\n-  assert(!ArchiveBuilder::current()->is_in_buffer_space(ik), \"must be source klass\");\n+  assert(!ArchiveBuilder::is_active() || !ArchiveBuilder::current()->is_in_buffer_space(ik), \"must be source klass\");\n@@ -101,1 +106,1 @@\n-  if (!ik->is_initialized()) {\n+  if (!ik->is_initialized() && !ik->is_being_initialized()) {\n@@ -296,0 +301,1 @@\n+      {\"java\/lang\/invoke\/LambdaMetafactory\"},\n@@ -299,0 +305,1 @@\n+      {\"java\/lang\/invoke\/StringConcatFactory\"},\n@@ -318,0 +325,6 @@\n+#ifdef ASSERT\n+  if (ik == _aot_init_class) {\n+    return true;\n+  }\n+#endif\n+\n@@ -348,0 +361,30 @@\n+\n+#ifdef ASSERT\n+void AOTClassInitializer::init_test_class(TRAPS) {\n+  \/\/ -XX:AOTInitTestClass is used in regression tests for adding additional AOT-initialized classes\n+  \/\/ and heap objects into the AOT cache. The tests must be carefully written to avoid including\n+  \/\/ any classes that cannot be AOT-initialized.\n+  \/\/\n+  \/\/ -XX:AOTInitTestClass is NOT a general mechanism for including user-defined objects into\n+  \/\/ the AOT cache. Therefore, this option is NOT available in product JVM.\n+  if (AOTInitTestClass != nullptr && CDSConfig::is_initing_classes_at_dump_time()) {\n+    log_info(cds)(\"Debug build only: force initialization of AOTInitTestClass %s\", AOTInitTestClass);\n+    TempNewSymbol class_name = SymbolTable::new_symbol(AOTInitTestClass);\n+    Handle app_loader(THREAD, SystemDictionary::java_system_loader());\n+    Klass* k = SystemDictionary::resolve_or_null(class_name, app_loader, CHECK);\n+    if (k == nullptr) {\n+      vm_exit_during_initialization(\"AOTInitTestClass not found\", AOTInitTestClass);\n+    }\n+    if (!k->is_instance_klass()) {\n+      vm_exit_during_initialization(\"Invalid name for AOTInitTestClass\", AOTInitTestClass);\n+    }\n+\n+    _aot_init_class = InstanceKlass::cast(k);\n+    _aot_init_class->initialize(CHECK);\n+  }\n+}\n+\n+bool AOTClassInitializer::has_test_class() {\n+  return _aot_init_class != nullptr;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,4 @@\n+\n+  \/\/ Support for regression testing. Available in debug builds only.\n+  static void init_test_class(TRAPS) NOT_DEBUG_RETURN;\n+  static bool has_test_class() NOT_DEBUG({ return false; });\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+         (is_dumping_method_handles()       ? IS_DUMPING_METHOD_HANDLES : 0) |\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,3 +71,5 @@\n-  static const int IS_DUMPING_STATIC_ARCHIVE       = 1 << 1;\n-  static const int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 2;\n-  static const int IS_USING_ARCHIVE                = 1 << 3;\n+  static const int IS_DUMPING_METHOD_HANDLES       = 1 << 1;\n+  static const int IS_DUMPING_STATIC_ARCHIVE       = 1 << 2;\n+  static const int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 3;\n+  static const int IS_USING_ARCHIVE                = 1 << 4;\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -74,0 +74,4 @@\n+  develop(ccstr, AOTInitTestClass, nullptr,                                 \\\n+          \"For JVM internal testing only. The specified class is stored \"   \\\n+          \"in the initialized state in the AOT cache \")                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-GrowableArrayCHeap<OopHandle, mtClassShared>* HeapShared::_root_segments;\n+GrowableArrayCHeap<OopHandle, mtClassShared>* HeapShared::_root_segments = nullptr;\n@@ -228,4 +228,0 @@\n-  if (_pending_roots == nullptr) {\n-    _pending_roots = new GrowableArrayCHeap<oop, mtClassShared>(500);\n-  }\n-\n@@ -344,6 +340,0 @@\n-          AOTArtifactFinder::add_aot_inited_class(method_holder);\n-\n-          if (log_is_enabled(Debug, cds, init)) {\n-            ResourceMark rm;\n-            log_debug(cds, init)(\"%s should be aot-initialized (referenced by MethodHandle)\", method_holder->external_name());\n-          }\n@@ -417,0 +407,1 @@\n+  _pending_roots = new GrowableArrayCHeap<oop, mtClassShared>(500);\n@@ -796,0 +787,2 @@\n+      \/\/ -XX:AOTInitTestClass must be used carefully in regression tests to\n+      \/\/ include only classes that are safe to aot-initialize.\n@@ -797,1 +790,2 @@\n-             HeapShared::is_lambda_proxy_klass(ik),\n+             HeapShared::is_lambda_proxy_klass(ik) ||\n+             AOTClassInitializer::has_test_class(),\n@@ -842,0 +836,7 @@\n+#ifndef PRODUCT\n+  if (AOTClassInitializer::has_test_class()) {\n+    \/\/ The tests can cache arbitrary types of objects.\n+    return;\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassInitializer.hpp\"\n@@ -739,0 +740,1 @@\n+  AOTClassInitializer::init_test_class(CHECK);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -221,0 +221,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_NeedsClassInitBarrierForCDS(JNIEnv* env, jclass cls);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotClassInitializer.hpp\"\n@@ -3352,1 +3353,0 @@\n-  assert(k->is_klass(), \"just checking\");\n@@ -3517,0 +3517,23 @@\n+JVM_ENTRY(jboolean, JVM_NeedsClassInitBarrierForCDS(JNIEnv* env, jclass cls))\n+#if INCLUDE_CDS\n+  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));\n+  if (!k->is_instance_klass()) {\n+    return false;\n+  } else {\n+    if (InstanceKlass::cast(k)->is_enum_subclass() ||\n+        AOTClassInitializer::can_archive_initialized_mirror(InstanceKlass::cast(k))) {\n+      \/\/ This class will be cached in AOT-initialized state. No need for init barriers.\n+      return false;\n+    } else {\n+      \/\/ If we cannot cache the class in AOT-initialized state, java.lang.invoke handles\n+      \/\/ must emit barriers to ensure class initialization during production run.\n+      ResourceMark rm(THREAD);\n+      log_debug(cds)(\"NeedsClassInitBarrierForCDS: %s\", k->external_name());\n+      return true;\n+    }\n+  }\n+#else\n+  return false;\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.internal.misc.CDS;\n@@ -370,1 +371,1 @@\n-            return false;\n+            return CDS.needsClassInitBarrier(cls);\n@@ -372,1 +373,1 @@\n-        return UNSAFE.shouldBeInitialized(cls);\n+        return UNSAFE.shouldBeInitialized(cls) || CDS.needsClassInitBarrier(cls);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.CDS;\n@@ -104,1 +105,1 @@\n-            return maybeAdapt(UNSAFE.shouldBeInitialized(decl)\n+            return maybeAdapt((UNSAFE.shouldBeInitialized(decl) || CDS.needsClassInitBarrier(decl))\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -51,3 +51,4 @@\n-    private static final int IS_DUMPING_STATIC_ARCHIVE       = 1 << 1;\n-    private static final int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 2;\n-    private static final int IS_USING_ARCHIVE                = 1 << 3;\n+    private static final int IS_DUMPING_METHOD_HANDLES       = 1 << 1;\n+    private static final int IS_DUMPING_STATIC_ARCHIVE       = 1 << 2;\n+    private static final int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 3;\n+    private static final int IS_USING_ARCHIVE                = 1 << 4;\n@@ -345,0 +346,23 @@\n+    \/**\n+     * Detects if we need to emit explicit class initialization checks in\n+     * AOT-cached MethodHandles and VarHandles before accessing static fields\n+     * and methods.\n+     * @see jdk.internal.misc.Unsafe::shouldBeInitialized\n+     *\n+     * @return false only if a call to {@code ensureClassInitialized} would have\n+     * no effect during the application's production run.\n+     *\/\n+    public static boolean needsClassInitBarrier(Class<?> c) {\n+        if (c == null) {\n+            throw new NullPointerException();\n+        }\n+\n+        if ((configStatus & IS_DUMPING_METHOD_HANDLES) == 0) {\n+            return false;\n+        } else {\n+            return needsClassInitBarrier0(c);\n+        }\n+    }\n+\n+    private static native boolean needsClassInitBarrier0(Class<?> c);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,6 @@\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_misc_CDS_needsClassInitBarrier0(JNIEnv *env, jclass ignore,\n+                                                jclass c) {\n+    return JVM_NeedsClassInitBarrierForCDS(env, c);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/CDS.c","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,248 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test various test cases for archived MethodHandle and VarHandle objects.\n+ * @requires vm.cds.write.archived.java.heap\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.debug\n+ * @comment work around JDK-8345635\n+ * @requires !vm.jvmci.enabled\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build MethodHandleTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar mh.jar\n+ *             MethodHandleTestApp MethodHandleTestApp$A MethodHandleTestApp$B\n+ * @run driver MethodHandleTest AOT\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class MethodHandleTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"mh.jar\");\n+    static final String mainClass = \"MethodHandleTestApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester t = new Tester();\n+        t.run(args);\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            if (runMode == RunMode.ASSEMBLY) {\n+                return new String[] {\n+                    \"-Xlog:gc,cds+class=debug\",\n+                    \"-XX:AOTInitTestClass=MethodHandleTestApp\",\n+                    \"-Xlog:cds+map,cds+map+oops=trace:file=cds.oops.txt:none:filesize=0\",\n+                };\n+            } else {\n+                return new String[] {};\n+            }\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+                runMode.toString(),\n+            };\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            out.shouldHaveExitValue(0);\n+\n+            if (!runMode.isProductionRun()) {\n+                \/\/ MethodHandleTestApp should be initialized in the assembly phase as well,\n+                \/\/ due to -XX:AOTInitTestClass.\n+                out.shouldContain(\"MethodHandleTestApp.<clinit>\");\n+            } else {\n+                \/\/ Make sure MethodHandleTestApp is aot-initialized in the production run.\n+                out.shouldNotContain(\"MethodHandleTestApp.<clinit>\");\n+            }\n+        }\n+    }\n+}\n+\n+\/\/ This class is cached in the AOT-initialized state. At the beginning of the production\n+\/\/ run, all of the static fields in MethodHandleTestApp will retain their values\n+\/\/ at the end of the assembly phase. MethodHandleTestApp::<clinit> is NOT executed in the\n+\/\/ production run.\n+\/\/\n+\/\/ Note that the inner classes A and B are NOT cached in the AOT-initialized state.\n+class MethodHandleTestApp {\n+    static int state_A;\n+    static int state_B;\n+\n+    static class A {\n+        public void virtualMethod() {}\n+\n+        public static void staticMethod() {\n+            System.out.println(\"MethodHandleTestApp$A.staticMethod()\");\n+            state_A *= 2;\n+        }\n+\n+        static {\n+            System.out.println(\"MethodHandleTestApp$A.<clinit>\");\n+            state_A += 3;\n+        }\n+    }\n+\n+    static class B {\n+        static long staticField;\n+        long instanceField;\n+\n+        static {\n+            System.out.println(\"MethodHandleTestApp$B.<clinit>\");\n+            staticField = state_B;\n+            state_B += 1234;\n+        }\n+    }\n+\n+    static MethodHandle staticMH;\n+    static MethodHandle virtualMH;\n+\n+    static VarHandle staticVH;\n+    static VarHandle instanceVH;\n+\n+    static {\n+        System.out.println(\"MethodHandleTestApp.<clinit>\");\n+\n+        try {\n+            setupCachedStatics();\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Unexpected exception\", t);\n+        }\n+    }\n+\n+    static void setupCachedStatics() throws Throwable {\n+        MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+        virtualMH = LOOKUP.findVirtual(A.class, \"virtualMethod\", MethodType.methodType(void.class));\n+        instanceVH = LOOKUP.findVarHandle(B.class, \"instanceField\", long.class);\n+\n+        \/\/ Make sure A is initialized before create staticMH, but the AOT-cached staticMH\n+        \/\/ should still include the init barrier even if A was initialized in the assembly phase.\n+        A.staticMethod();\n+        staticMH = LOOKUP.findStatic(A.class, \"staticMethod\", MethodType.methodType(void.class));\n+\n+\n+        \/\/ Make sure B is initialized before create staticVH, but the AOT-cached staticVH\n+        \/\/ should still include the init barrier even if B was initialized in the assembly phase.\n+        B.staticField += 5678;\n+        staticVH = LOOKUP.findStaticVarHandle(B.class, \"staticField\", long.class);\n+    }\n+\n+    private static Object invoke(MethodHandle mh, Object ... args) {\n+        try {\n+            for (Object o : args) {\n+                mh = MethodHandles.insertArguments(mh, 0, o);\n+            }\n+            return mh.invoke();\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Unexpected exception\", t);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        boolean isProduction = args[0].equals(\"PRODUCTION\");\n+\n+        testMethodHandles(isProduction);\n+        testVarHandles(isProduction);\n+    }\n+\n+\n+    static void testMethodHandles(boolean isProduction) throws Throwable {\n+        state_A = 0;\n+\n+        \/\/ (1) Invoking virtual method handle should not initialize the class\n+        try {\n+            virtualMH.invoke(null);\n+            throw new RuntimeException(\"virtualMH.invoke(null) must not succeed\");\n+        } catch (NullPointerException t) {\n+            System.out.println(\"Expected: \" + t);\n+        }\n+\n+        if (isProduction) {\n+            if (state_A != 0) {\n+                throw new RuntimeException(\"state_A should be 0 but is: \" + state_A);\n+            }\n+        }\n+\n+        \/\/ (2) Invoking static method handle must ensure A is initialized.\n+        invoke(staticMH);\n+        if (isProduction) {\n+            if (state_A != 6) {\n+                \/\/ A.<clinit> must be executed before A.staticMethod.\n+                throw new RuntimeException(\"state_A should be 6 but is: \" + state_A);\n+            }\n+        }\n+    }\n+\n+    static void testVarHandles(boolean isProduction) throws Throwable {\n+        int n = 3;\n+        state_B = n;\n+\n+        \/\/ (1) Invoking virtual method handle should not initialize the class\n+        try {\n+            instanceVH.get(null);\n+            throw new RuntimeException(\"instanceVH.get(null) must not succeed\");\n+        } catch (NullPointerException t) {\n+            System.out.println(\"Expected: \" + t);\n+        }\n+\n+        if (isProduction) {\n+            if (state_B != n) {\n+                throw new RuntimeException(\"state_B should be \" + n + \" but is: \" + state_B);\n+            }\n+        }\n+\n+        \/\/ (2) Invoking static method handle must ensure B is initialized.\n+        long v = (long)staticVH.get();\n+        if (isProduction) {\n+            if (v != n) {\n+                \/\/ If you get to here, B might have been incorrectly cached in the initialized state.\n+                throw new RuntimeException(\"staticVH.get() should be \" + n + \" but is: \" + v);\n+            }\n+            if (state_B != 1234 + n) {\n+                \/\/ B.<clinit> must be executed before B.staticMethod.\n+                throw new RuntimeException(\"state_B should be \" + (1234 + n) + \" but is: \" + state_B);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/MethodHandleTest.java","additions":248,"deletions":0,"binary":false,"changes":248,"status":"added"}]}