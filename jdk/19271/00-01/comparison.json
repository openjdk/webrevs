{"files":[{"patch":"@@ -41,0 +41,1 @@\n+import java.util.Collections;\n@@ -42,0 +43,1 @@\n+import java.util.Map;\n@@ -43,0 +45,1 @@\n+import java.util.WeakHashMap;\n@@ -48,0 +51,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -656,0 +660,60 @@\n+    public void testFairDoesntLeak() throws InterruptedException {\n+        assertDoesntLeak(new SynchronousQueue<>(true));\n+    }\n+\n+    public void testUnfairDoesntLeak() throws InterruptedException {\n+        assertDoesntLeak(new SynchronousQueue<>(false));\n+    }\n+\n+    private void assertDoesntLeak(SynchronousQueue<Object> queue) throws InterruptedException {\n+        final int NUMBER_OF_ITEMS = 250;\n+        final int MAX_ROUNDS = 200;\n+        final int ROUND_WAIT_MILLIS = 50;\n+\n+        final CountDownLatch allProduced = new CountDownLatch(NUMBER_OF_ITEMS);\n+        final CountDownLatch allConsumed = new CountDownLatch(NUMBER_OF_ITEMS);\n+\n+        class Item {}\n+        final Map<Item, Void> survivors =\n+                Collections.synchronizedMap(WeakHashMap.newWeakHashMap(NUMBER_OF_ITEMS));\n+\n+        for(int i = 0;i < NUMBER_OF_ITEMS;++i) {\n+            new Thread(() -> {\n+                var item = new Item();\n+                survivors.put(item, null);\n+                while(true) {\n+                    try {\n+                        queue.put(item);\n+                        break;\n+                    } catch (InterruptedException ie) {\n+                        \/\/ Retry\n+                    }\n+                }\n+                allProduced.countDown();\n+            }).start();\n+\n+            new Thread(() -> {\n+                while(true) {\n+                    try {\n+                        queue.take();\n+                        break;\n+                    } catch (InterruptedException ie) {\n+                        \/\/ Retry\n+                    }\n+                }\n+                allConsumed.countDown();\n+            }).start();\n+        }\n+\n+        assertTrue(allProduced.await(10, TimeUnit.SECONDS));\n+        assertTrue(allConsumed.await(10, TimeUnit.SECONDS));\n+        var round = 0;\n+        while(!survivors.isEmpty() && round++ < MAX_ROUNDS) {\n+            System.gc();\n+            Thread.sleep(ROUND_WAIT_MILLIS); \/\/ We don't expect interruptions\n+        }\n+\n+        assertTrue(survivors.isEmpty());\n+        assertTrue(queue.isEmpty()); \/\/ Make sure that the queue survives until the end\n+    }\n+\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/SynchronousQueueTest.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"}]}