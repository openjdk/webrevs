{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,2 +95,2 @@\n-        String matchRegex = \"(0[xX])?[0-9a-fA-F]+[\\\\s+]?[,|};]\";\n-        String replaceRegex = \"(0[xX])|,|[\\\\s+]|[};]\";\n+        String matchRegex = \"\\\\s*(0[xX])?((?:(?!,|\\\\};).)+)(,|\\\\};)\";\n+        String replaceRegex = \"0[xX]|,|\\\\s+|\\\\};\";\n@@ -114,2 +114,6 @@\n-                            W = Integer.parseInt(token[2]);\n-                            state = 1; \/\/ after width is set\n+                            if (token[1].endsWith(\"th\")) {\n+                                W = Integer.parseInt(token[2]);\n+                            } else if (token[1].endsWith(\"t\")) {\n+                                H = Integer.parseInt(token[2]);\n+                            }\n+                            state = 1; \/\/ after first dimension is set\n@@ -117,2 +121,6 @@\n-                            H = Integer.parseInt(token[2]);\n-                            state = 2; \/\/ after height is set\n+                            if (token[1].endsWith(\"th\")) {\n+                                W = Integer.parseInt(token[2]);\n+                            } else if (token[1].endsWith(\"t\")) {\n+                                H = Integer.parseInt(token[2]);\n+                            }\n+                            state = 2; \/\/ after second dimension is set\n@@ -150,0 +158,3 @@\n+            boolean contFlag = false;\n+            StringBuilder sb = new StringBuilder();\n+\n@@ -154,7 +165,7 @@\n-                if (line.contains(\"[]\")) {\n-                    Matcher matcher = Pattern.compile(matchRegex).matcher(line);\n-                    while (matcher.find()) {\n-                        if (y >= H) {\n-                            error(\"Scan size of XBM file exceeds\"\n-                                    + \" the defined width x height\");\n-                        }\n+                if (!contFlag) {\n+                    if (line.contains(\"[]\")) {\n+                        contFlag = true;\n+                    } else {\n+                        continue;\n+                    }\n+                }\n@@ -162,3 +173,8 @@\n-                        int startIndex = matcher.start();\n-                        int endIndex = matcher.end();\n-                        String hexByte = line.substring(startIndex, endIndex);\n+                int end = line.indexOf(';');\n+                if (end >= 0) {\n+                    sb.append(line, 0, end + 1);\n+                    break;\n+                } else {\n+                    sb.append(line).append(System.lineSeparator());\n+                }\n+            }\n@@ -166,10 +182,3 @@\n-                        if (!(hexByte.startsWith(\"0x\")\n-                                || hexByte.startsWith(\"0X\"))) {\n-                            error(\"Invalid hexadecimal number at Ln#:\" + lineNum\n-                                    + \" Col#:\" + (startIndex + 1));\n-                        }\n-                        hexByte = hexByte.replaceAll(replaceRegex, \"\");\n-                        if (hexByte.length() != 2) {\n-                            error(\"Invalid hexadecimal number at Ln#:\" + lineNum\n-                                    + \" Col#:\" + (startIndex + 1));\n-                        }\n+            String resultLine = sb.toString();\n+            int cutOffIndex = resultLine.indexOf('{');\n+            resultLine = resultLine.substring(cutOffIndex + 1);\n@@ -177,15 +186,6 @@\n-                        try {\n-                            n = Integer.parseInt(hexByte, 16);\n-                        } catch (NumberFormatException nfe) {\n-                            error(\"Error parsing hexadecimal at Ln#:\" + lineNum\n-                                    + \" Col#:\" + (startIndex + 1));\n-                        }\n-                        for (int mask = 1; mask <= 0x80; mask <<= 1) {\n-                            if (x < W) {\n-                                if ((n & mask) != 0)\n-                                    raster[x] = 1;\n-                                else\n-                                    raster[x] = 0;\n-                            }\n-                            x++;\n-                        }\n+            Matcher matcher = Pattern.compile(matchRegex).matcher(resultLine);\n+            while (matcher.find()) {\n+                if (y >= H) {\n+                    error(\"Scan size of XBM file exceeds\"\n+                            + \" the defined width x height\");\n+                }\n@@ -193,8 +193,36 @@\n-                        if (x >= W) {\n-                            int result = setPixels(0, y, W, 1, model, raster, 0, W);\n-                            if (result <= 0) {\n-                                error(\"Unexpected error occurred during setPixel()\");\n-                            }\n-                            x = 0;\n-                            y++;\n-                        }\n+                int startIndex = matcher.start();\n+                int endIndex = matcher.end();\n+                String hexByte = resultLine.substring(startIndex, endIndex);\n+                hexByte = hexByte.replaceAll(\"^\\\\s+\", \"\");\n+\n+                if (!(hexByte.startsWith(\"0x\")\n+                        || hexByte.startsWith(\"0X\"))) {\n+                    error(\"Invalid hexadecimal number at Ln#:\" + lineNum\n+                            + \" Col#:\" + (startIndex + 1));\n+                }\n+                hexByte = hexByte.replaceAll(replaceRegex, \"\");\n+                if (hexByte.length() != 2) {\n+                    error(\"Invalid hexadecimal number at Ln#:\" + lineNum\n+                            + \" Col#:\" + (startIndex + 1));\n+                }\n+\n+                try {\n+                    n = Integer.parseInt(hexByte, 16);\n+                } catch (NumberFormatException nfe) {\n+                    error(\"Error parsing hexadecimal at Ln#:\" + lineNum\n+                            + \" Col#:\" + (startIndex + 1));\n+                }\n+                for (int mask = 1; mask <= 0x80; mask <<= 1) {\n+                    if (x < W) {\n+                        if ((n & mask) != 0)\n+                            raster[x] = 1;\n+                        else\n+                            raster[x] = 0;\n+                    }\n+                    x++;\n+                }\n+\n+                if (x >= W) {\n+                    int result = setPixels(0, y, W, 1, model, raster, 0, W);\n+                    if (result <= 0) {\n+                        error(\"Unexpected error occurred during setPixel()\");\n@@ -202,0 +230,2 @@\n+                    x = 0;\n+                    y++;\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/XbmImageDecoder.java","additions":80,"deletions":50,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,3 @@\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n@@ -36,0 +39,1 @@\n+import java.util.Arrays;\n@@ -60,0 +64,1 @@\n+\n@@ -64,1 +69,0 @@\n-\n@@ -67,1 +71,1 @@\n-                } else if (!validCase && isErrEmpty) {\n+                } else if (!validCase && isErrEmpty && hasPixelData(icon.getImage())) {\n@@ -71,0 +75,4 @@\n+                if (validCase && !hasPixelData(icon.getImage())) {\n+                    throw new RuntimeException(\"Test failed: the parsed image \" +\n+                            \"does not contain any pixel data\");\n+                }\n@@ -77,0 +85,14 @@\n+\n+    private static boolean hasPixelData(Image img) {\n+        int w = img.getWidth(null);\n+        int h = img.getHeight(null);\n+        BufferedImage bi = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n+        Graphics2D g = bi.createGraphics();\n+        g.drawImage(img, 0, 0, null);\n+        g.dispose();\n+        int[] pixels = bi.getRGB(0, 0, w, h, null, 0, w);\n+        if (Arrays.stream(pixels).allMatch(i -> i == 0)) {\n+            return false;\n+        }\n+        return true;\n+    }\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/XBMDecoderTest.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,6 @@\n+#define test_width 16\n+#define test_height 3\n+#define ht_x 1\n+#define ht_y 2\n+static unsigned char test_bits[] = {\n+};\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/invalid_empty.xbm","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -1,2 +1,2 @@\n-#define k_wt 16\n-#define k_ht  1\n+#define k_width 16\n+#define k_height  1\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/invalid_hex.xbm","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+#define test_width 16\n+#define test_height 2\n+static unsigned char test_bits[] = { 0x13, 0x11, 0xAB+, 0xff };\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/image\/XBMDecoder\/invalid_plus.xbm","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"}]}