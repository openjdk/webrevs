{"files":[{"patch":"@@ -172,1 +172,0 @@\n-vmTestbase\/nsk\/stress\/except\/except012.java 8297977 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297977\n+ * @summary Test that throwing OOM from reflected method gets InvocationTargetException\n+ * @run main\/othervm ReflectOutOfMemoryError\n+ *\/\n+import java.lang.reflect.*;\n+\n+\/\/ This test salvaged out of vmTestbase except tests.\n+public class ReflectOutOfMemoryError {\n+\n+    private static volatile Object pool[] = null;\n+\n+    public static void raiseOutOfMemory() throws OutOfMemoryError {\n+        try {\n+            \/\/ Repository for objects, which should be allocated:\n+            int index = 0;\n+            for (int size = 1 << 30; size > 0 && pool == null; size >>= 1)\n+                try {\n+                    pool = new Object[size];\n+                } catch (OutOfMemoryError oome) {\n+                }\n+            if (pool == null)\n+                throw new Error(\"HS bug: cannot allocate new Object[1]\");\n+\n+            \/\/ Sum up time spent, when it was hard to JVM to allocate next object\n+            \/\/ (i.e.: when JVM has spent more than 1 second to allocate new object):\n+            double totalDelay = 0;\n+            long timeMark = System.currentTimeMillis();\n+\n+            for (; index < pool.length; index++) {\n+                \/\/-------------------------\n+                pool[index] = new Object();\n+                long nextTimeMark = System.currentTimeMillis();\n+                long elapsed = nextTimeMark - timeMark;\n+                timeMark = nextTimeMark;\n+                \/\/----------------------\n+                if (elapsed > 1000) {\n+                    double seconds = elapsed \/ 1000.0;\n+                    System.out.println(\n+                            \"pool[\" + index +\n+                                    \"]=new Object(); \/\/ elapsed \" + seconds + \"s\");\n+                    totalDelay += seconds;\n+                    if (totalDelay > 300) {\n+                        System.out.println(\n+                                \"Memory allocation became slow: so heap seems exhausted.\");\n+                        throw new OutOfMemoryError();\n+                    }\n+                }\n+            }\n+\n+            \/\/ This method should never return:\n+            throw new Error(\"TEST_BUG: failed to provoke OutOfMemoryError\");\n+        } finally {\n+            \/\/ Make sure there will be enough memory for next object allocation\n+             pool = null;\n+        }\n+    }\n+\n+    public static void main(java.lang.String[] unused) throws Exception {\n+        System.out.println(\"Starting test\");\n+        Class testClass = ReflectOutOfMemoryError.class;\n+        try {\n+            Method testMethod = testClass.getMethod(\"raiseOutOfMemory\", new Class [0]);\n+            Object junk = testMethod.invoke(null, new Object [0]);\n+            throw new RuntimeException(\"InvocationTargetException should be thrown\");\n+        } catch (InvocationTargetException ite) {\n+            Throwable targetException = ite.getTargetException();\n+            if (targetException instanceof OutOfMemoryError) {\n+                System.out.println(\"OutOfMemoryError thrown as expected.\");\n+                System.out.println(\"Test passed.\");\n+            } else {\n+                throw new RuntimeException(\"Unexpected InvocationTargetException: \" + targetException);\n+            }\n+        } catch (Exception exception) {\n+            throw new RuntimeException(\"Unexpected exception: \" + exception);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/reflect\/ReflectOutOfMemoryError.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,291 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/except\/except001.\n- * VM testbase keywords: [stress, diehard, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This checks if OutOfMemoryError exception is correctly enwrapped into\n- *     InvocationTargetException when thrown inside a method invoked via\n- *     reflection.\n- *     The test tries to occupy all of memory available in the heap by\n- *     allocating lots of new Object() instances. Instances of the \"empty\"\n- *     type Object are the smallest objects, so they apparently should occupy\n- *     most fine-grained fragments in the heap. Thus, there apparently should\n- *     not remain any free space to incarnate new Throwable instance, and VM\n- *     possibly could crash while trying to throw new OutOfMemoryError and\n- *     enwrap it into new InvocationTargetException instance.\n- *     By the way, the test checks time elapsed to allocate memory. Both\n- *     classic VM and HotSpot seem to fall into poor performance of memory\n- *     allocation when heap is almost over. E.g.: HotSpot 1.3-betaH may spend\n- *     more than 1 minute to allocate next Object in this case (tested on\n- *     Pentium-II, 350MHz, 128Mb RAM). To avoid this problem, the test enforce\n- *     OutOfMemoryError if more then 5 minutes is spent to allocate \"last bytes\"\n- *     of memory.\n- * COMMENTS\n- *     HotSpot releases 1.0-fcsE (both Win32 and Sparc), and 1.3-betaH (Win32)\n- *     fail on this test due to poor performance of memory allocation.\n- *         #4248801 (P3\/S5) slow memory allocation when heap is almost exhausted\n- *     Despite this bug is treated fixed in HotSpot 1.0.1, it still does suffer\n- *     slow memory allocation when running on PC having 64Mb or less of RAM.\n- *     There is also a workaround involved to avoid the following bugs known\n- *     for HotSpot and for classic VM:\n- *         #4239841 (P1\/S5) 1.1: poor garbage collector performance  (HotSpot bug)\n- *         #4245060 (P4\/S5) poor garbage collector performance       (Classic VM bug)\n- *     However, printing of the test's error messages, warnings, and of execution\n- *     trace may fail under JDK 1.2 for Win32 even so.\n- *     HotSpot 2.0-devA (Win32) crashes due to the known HotSpot bug:\n- *         #4239828 (P1\/S4) 1.3c1: VM crashes when heap is exhausted\n- *\n- * @run main\/othervm -Xms50M -Xmx200M nsk.stress.except.except001\n- *\/\n-\n-package nsk.stress.except;\n-\n-import java.io.PrintStream;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-\n-\/**\n- * This checks if <code>OutOfMemoryError<\/code> exception is correctly\n- * enwrapped into <code>InvocationTargetException<\/code> when thrown inside\n- * a method invoked via reflection.\n- * <p>\n- * <p>The test tries to occupy all of memory available in the heap by\n- * allocating lots of new <code>Object()<\/code> instances. Instances of the\n- * ``empty'' type <code>Object<\/code> are the smallest objects, so they\n- * apparently should occupy most fine-grained fragments in the heap.\n- * Thus, there apparently should not remain any free space to incarnate new\n- * <code>Throwable<\/code> instance, and VM possibly could crash while trying\n- * to throw new <code>OutOfMemoryError<\/code> and enwrap it into new\n- * <code>InvocationTargetException<\/code> instance.\n- * <p>\n- * <p>By the way, the test checks time elapsed to allocate memory.\n- * Both classic VM and HotSpot seem to fall into poor performance of memory\n- * allocation when heap is almost over. E.g.: HotSpot 1.3-betaH may spend\n- * more than 1 minute to allocate next <code>Object<\/code> in this case\n- * (tested on Pentium-II, 350MHz, 128Mb RAM). To workaround this problem,\n- * the test enforces <code>OutOfMemoryError<\/code> if more then 5 minutes\n- * is spent to allocate ``last bytes'' of the memory.\n- *\/\n-public class except001 {\n-    \/**\n-     * This field allows or supresses printing with <code>display()<\/code>\n-     * method.\n-     *\n-     * @see #display(Object)\n-     * @see #complain(Object)\n-     * @see #out\n-     *\/\n-    private static boolean MODE_VERBOSE = true;\n-    \/*\n-    * Storage for a lot of tiny objects\n-    * \"static volatile\" keywords are for preventing heap optimization\n-    *\/\n-    private static volatile Object pool[] = null;\n-\n-    \/**\n-     * Print execution trace if <code>MODE_VERBOSE<\/code> is <code>true<\/code>\n-     * (optional).\n-     *\n-     * @see #MODE_VERBOSE\n-     * @see #complain(Object)\n-     * @see #out\n-     *\/\n-    private static void display(Object message) {\n-        if (MODE_VERBOSE)\n-            out.println(message.toString());\n-        out.flush();\n-    }\n-\n-    \/**\n-     * Print error <code>message<\/code>.\n-     *\n-     * @see #display(Object)\n-     * @see #out\n-     *\/\n-    private static void complain(Object message) {\n-        out.println(\"# \" + message);\n-        out.flush();\n-    }\n-\n-    \/**\n-     * The log-stream assigned at runtime by the method\n-     * <code>run(args,out)<\/code>.\n-     *\n-     * @see #display(Object)\n-     * @see #complain(Object)\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    private static PrintStream out;\n-\n-    \/**\n-     * Try to allocate lots of instances of the type <code>Object<\/code>.\n-     * Such instances are most fine-grained, and thus they should occupy\n-     * smallest fragments of free memory in the heap.\n-     * <p>\n-     * <p>By the way, break the test, if JVM has spent more than\n-     * 5 minutes to allocate latest portions of memory.\n-     *\/\n-    public static void raiseOutOfMemory() throws OutOfMemoryError {\n-        try {\n-            \/\/ Repository for objects, which should be allocated:\n-            int index = 0;\n-            for (int size = 1 << 30; size > 0 && pool == null; size >>= 1)\n-                try {\n-                    pool = new Object[size];\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            if (pool == null)\n-                throw new Error(\"HS bug: cannot allocate new Object[1]\");\n-\n-            \/\/ Sum up time spent, when it was hard to JVM to allocate next object\n-            \/\/ (i.e.: when JVM has spent more than 1 second to allocate new object):\n-            double totalDelay = 0;\n-            long timeMark = System.currentTimeMillis();\n-\n-            for (; index < pool.length; index++) {\n-                \/\/-------------------------\n-                pool[index] = new Object();\n-                long nextTimeMark = System.currentTimeMillis();\n-                long elapsed = nextTimeMark - timeMark;\n-                timeMark = nextTimeMark;\n-                \/\/----------------------\n-                if (elapsed > 1000) {\n-                    double seconds = elapsed \/ 1000.0;\n-                    display(\n-                            \"pool[\" + index +\n-                                    \"]=new Object(); \/\/ elapsed \" + seconds + \"s\");\n-                    totalDelay += seconds;\n-                    if (totalDelay > 300) {\n-                        complain(\n-                                \"Memory allocation became slow: so heap seems exhausted.\");\n-                        throw new OutOfMemoryError();\n-                    }\n-                }\n-            }\n-\n-            \/\/ This method should never return:\n-            throw new Error(\"TEST_BUG: failed to provoke OutOfMemoryError\");\n-        } finally {\n-            \/\/ Make sure there will be enough memory for next object allocation\n-             pool = null;\n-        }\n-    }\n-\n-    \/**\n-     * Invoke the method <code>raiseOutOfMemory()<\/code> with reflection,\n-     * and check if the exception it throws is just\n-     * <code>OutOfMemoryError<\/code> enwrapped into\n-     * <code>InvocationTargetException<\/code> instance.\n-     * <p>\n-     * <p>Before the test begins, <code>this.out<\/code> filed is assigned\n-     * to the parameter <code>out<\/code>. Parameter <code>args[]<\/code>\n-     * is ignored.\n-     *\n-     * @see #raiseOutOfMemory()\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        out.println(\"# While printing this message, JVM seems to initiate the output\");\n-        out.println(\"# stream, so that it will not need more memory to print later,\");\n-        out.println(\"# when the heap would fail to provide more memory.\");\n-        out.println(\"# \");\n-        out.println(\"# That problem is caused by the known JDK\/HotSpot bugs:\");\n-        out.println(\"#     4239841 (P1\/S5) 1.1: poor garbage collector performance\");\n-        out.println(\"#     4245060 (P4\/S5) poor garbage collector performance\");\n-        out.println(\"# \");\n-        out.println(\"# This message is just intended to work-around that problem.\");\n-        out.println(\"# If printing should fail even so.\");\n-\n-        if (args.length > 0) {\n-            if (args[0].toLowerCase().startsWith(\"-v\"))\n-                MODE_VERBOSE = true;\n-        }\n-\n-        except001.out = out;\n-        Class testClass = except001.class;\n-        try {\n-            Method testMethod = testClass.getMethod(\"raiseOutOfMemory\", new Class [0]);\n-            Object junk = testMethod.invoke(null, new Object [0]);\n-\n-        } catch (InvocationTargetException ite) {\n-            Throwable targetException = ite.getTargetException();\n-            if (targetException instanceof OutOfMemoryError) {\n-                display(\"OutOfMemoryError thrown as expected.\");\n-                display(\"Test passed.\");\n-                return 0;\n-            }\n-            complain(\"Unexpected InvocationTargetException: \" + targetException);\n-            complain(\"Test failed.\");\n-            return 2;\n-\n-        } catch (Exception exception) {\n-            complain(\"Unexpected exception: \" + exception);\n-            complain(\"Test failed.\");\n-            return 2;\n-        }\n-        \/\/\n-        complain(\"The test has finished unexpectedly.\");\n-        complain(\"Test failed.\");\n-        return 2;\n-    }\n-\n-    \/**\n-     * Re-call to <code>run(args,out)<\/code>, and return JCK-like exit status.\n-     * (The stream <code>out<\/code> is assigned to <code>System.out<\/code> here.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-            \/\/ Last try. If there is some exception outside the code, test should end correctly\n-            @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n-                try {\n-                    pool = null;\n-                    System.gc();\n-                    if (e instanceof OutOfMemoryError) {\n-                        try {\n-                            System.out.println(\"OOME : Test Skipped\");\n-                            System.exit(95);\n-                        } catch (Throwable ignore) {\n-                        } \/\/ No code in the handler can provoke correct exceptions.\n-                    } else {\n-                        e.printStackTrace();\n-                        throw (RuntimeException) e;\n-                    }\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            }\n-        });\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/except001.java","additions":0,"deletions":291,"binary":false,"changes":291,"status":"deleted"},{"patch":"@@ -1,301 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/except\/except002.\n- * VM testbase keywords: [stress, diehard, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This checks if various exceptions are thrown (and caught) correctly\n- *     when there apparently are no free space in the heap to allocate new\n- *     Throwable instance.\n- *     The test tries to occupy all of memory available in the heap by allocating\n- *     lots of new Object() instances. Instances of the type Object are the smallest\n- *     objects, so they apparently should occupy most fine-grained fragments in the\n- *     heap and leave no free space for new Throwable instance. After that, the test\n- *     provokes various exceptions (e.g.: by executing integer division by 0 and so\n- *     on), and checks if appropriate exceptions are thrown.\n- * COMMENTS\n- *     The test needs a lot of memory to start up, so it should not run under older\n- *     JDK 1.1.x release due to its poorer heap utilization. Also, some checks are\n- *     skipped when testing classic VM, because OutOfMemoryError is correctly thrown\n- *     instead of target exception.\n- *     When the test is being self-initiating (i.e.: eating heap), memory occupation\n- *     is terminated if memory allocation slows down crucially. This is a workaround\n- *     intended to avoid the HotSpot bug:\n- *         #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- *     There is also a workaround involved to avoid the following bugs known\n- *     for HotSpot and for classic VM:\n- *         #4239841 (P1\/S5) 1.1: poor garbage collector performance  (HotSpot bug)\n- *         #4245060 (P4\/S5) poor garbage collector performance       (Classic VM bug)\n- *     However, printing of the test's error messages, warnings, and of execution\n- *     trace fails under JDK 1.2 for Win32 even so. If the test fails due to this\n- *     problem, exit status 96 is returned instead of 97.\n- *     JDK 1.3 classic VM for Sparc may crash (core dump) due to the known bug:\n- *         #4245057 (P2\/S3) VM crashes when heap is exhausted\n- *\n- * @run main\/othervm -Xms50M -Xmx200M nsk.stress.except.except002\n- *\/\n-\n-package nsk.stress.except;\n-\n-import java.io.PrintStream;\n-\n-\/**\n- * This checks if various exceptions are thrown (and caught) correctly\n- * when there apparently are no free space in the heap to allocate new\n- * <code>Throwable<\/code> instance.\n- * <p>\n- * <p>The test tries to occupy all of memory available in the heap by\n- * allocating lots of new <code>Object()<\/code> instances. Instances of the\n- * type <code>Object<\/code> are the smallest objects, so they apparently should\n- * occupy most fine-grained fragments in the heap and leave no free space for\n- * new <code>Throwable<\/code> instance. After that, the test provokes various\n- * exceptions (e.g.: by executing integer division by 0 and so on), and checks\n- * if appropriate exceptions are thrown.\n- * <p>\n- * <p>Note, that memory occupation is terminated if memory allocation slows\n- * down crucially. This is a workaround intended to avoid the HotSpot bug:\n- * <br>&nbsp;&nbsp;\n- * #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- * <p>\n- * <p>There is also a workaround involved to avoid the following bugs known\n- * for HotSpot and for classic VM:\n- * <br>&nbsp;&nbsp;\n- * #4239841 (P1\/S5) 1.1: poor garbage collector performance\n- * <br>&nbsp;&nbsp;\n- * #4245060 (P4\/S5) poor garbage collector performance\n- * <br>However, printing of the test's error messages, warnings, and of\n- * execution trace may fail even so. If the test fails due to poor GC\n- * performance, exit status 96 is returned instead of 97.\n- * <p>\n- * <p>Also note, that the test needs a lot of memory to start up, so it should\n- * not run under older JDK 1.1.x release due to its poor heap utilization.\n- *\/\n-public class except002 {\n-    \/**\n-     * Either allow or supress printing of execution trace.\n-     *\/\n-    private static boolean TRACE_ON = false;\n-    \/**\n-     * Either allow or supress printing of warning messages.\n-     *\/\n-    private static final boolean WARN_ON = true;\n-    \/*\n-     * Storage for a lot of tiny objects\n-     * \"static volatile\" keywords are for preventing heap optimization\n-     *\/\n-    public static volatile Object pool[] = null;\n-    \/**\n-     * Temporary <code>log<\/code> for error messages, warnings and\/or execution trace.\n-     *\n-     * @see #messages\n-     *\/\n-    private static String log[] = new String[1000]; \/\/ up to 1000 messages\n-    \/**\n-     * How many <code>messages<\/code> were submitted to the <code>log<\/code>.\n-     *\n-     * @see #log\n-     *\/\n-    private static int messages = 0;\n-\n-    \/**\n-     * Re-call to the method <code>run(out)<\/code> (ignore <code>args[]<\/code>),\n-     * and print the test summary - either test passed of failed.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            if (args[0].toLowerCase().startsWith(\"-v\"))\n-                TRACE_ON = true;\n-        }\n-\n-        int exitCode = run(out);\n-        pool = null;\n-        System.gc();\n-        \/\/ Print the log[] and the test summary:\n-        try {\n-            for (int i = 0; i < messages; i++)\n-                out.println(log[i]);\n-            if (exitCode == 0) {\n-                if (TRACE_ON)\n-                    out.println(\"Test passed.\");\n-            } else\n-                out.println(\"Test failed.\");\n-        } catch (OutOfMemoryError oome) {\n-            \/\/ Poor performance of garbage collector:\n-            exitCode = 1;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Allocate as much <code>Object<\/code> instances as possible to bring JVM\n-     * into stress, and then check if exceptions are correctly thrown accordingly\n-     * to various situations like integer division by 0, etc.\n-     *\/\n-    private static int run(PrintStream out) {\n-        out.println(\"# While printing this message, JVM seems to initiate the output\");\n-        out.println(\"# stream, so that it will not need more memory to print later,\");\n-        out.println(\"# when the heap would fail to provide more memory.\");\n-        out.println(\"# \");\n-        out.println(\"# Note, that the test maintains especial static log[] field in\");\n-        out.println(\"# order to avoid printing when the heap seems exhausted.\");\n-        out.println(\"# Nevertheless, printing could arise OutOfMemoryError even\");\n-        out.println(\"# after all the memory allocated by the test is released.\");\n-        out.println(\"# \");\n-        out.println(\"# That problem is caused by the known JDK\/HotSpot bugs:\");\n-        out.println(\"#     4239841 (P1\/S5) 1.1: poor garbage collector performance\");\n-        out.println(\"#     4245060 (P4\/S5) poor garbage collector performance\");\n-        out.println(\"# \");\n-        out.println(\"# This message is just intended to work-around that problem.\");\n-        out.println(\"# If printing should fail even so, the test will return the\");\n-        out.println(\"# exit status 96 instead of 97 to indicate the problem.\");\n-\n-        \/\/ Prepare some items, which will be used by the test:\n-        Object trash = null;\n-\n-        \/\/ Sum up exit code:\n-        int exitCode = 0; \/\/ apparently PASSED\n-        int skipped = 0;  \/\/ some checks may correctly suffer OutOfMemoryError\n-        \/\/ Allocate repository for a lots of tiny objects:\n-        for (int size = 1 << 30; size > 0 && pool == null; size >>= 1)\n-            try {\n-                pool = new Object[size];\n-            } catch (OutOfMemoryError oome) {\n-            }\n-        if (pool == null)\n-            throw new Error(\"HS bug: cannot allocate new Object[1]\");\n-        int poolSize = pool.length;\n-        int index = 0;\n-\n-        \/\/ Sum up time spent, when it was hard to JVM to allocate next object\n-        \/\/ (i.e.: when JVM has spent more than 1 second to allocate new object):\n-        double totalDelay = 0;\n-        long timeMark = System.currentTimeMillis();\n-        try {\n-            for (; index < poolSize; index++) {\n-                \/\/-------------------------\n-                pool[index] = new Object();\n-                long nextTimeMark = System.currentTimeMillis();\n-                long elapsed = nextTimeMark - timeMark;\n-                timeMark = nextTimeMark;\n-                \/\/----------------------\n-                if (elapsed > 1000) {\n-                    double seconds = elapsed \/ 1000.0;\n-                    if (TRACE_ON)\n-                        out.println(\n-                                \"pool[\" + index + \"]=new Object(); \/\/ elapsed \" + seconds + \"s\");\n-                    totalDelay += seconds;\n-                    if (totalDelay > 60) {\n-                        if (TRACE_ON)\n-                            out.println(\n-                                    \"Memory allocation became slow; so, heap seems exhausted.\");\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (OutOfMemoryError oome) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Heap seems exhausted - OutOfMemoryError thrown.\";\n-\n-            \/\/ Do not release any byte once allocated:\n-            pool[index++] = oome;\n-        }\n-\n-        if (index > poolSize - 1000) {\n-            if (WARN_ON)\n-                log[messages++] = \"Warning: pool[] is full; so, checks would not be enough hard...\";\n-        }\n-\n-        \/\/ Check ClassNotFoundException (positive):\n-        try {\n-            trash = Class.forName(\"nsk.stress.except.except002$Abra$Cadabra\"); \/\/   correct - should pass\n-\/\/          trash = Class.forName(\"nsk.stress.except.except002.Abra.Cadabra\"); \/\/ incorrect - should fail\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: ClassNotFoundException (positive)\";\n-        } catch (ClassNotFoundException cnfe) {\n-            log[messages++] = \"Failure: ClassNotFoundException (positive)\";\n-            exitCode = 2;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: ClassNotFoundException (positive)\";\n-            skipped++;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Re-call to <code>run(args,out)<\/code>, and return JCK-like exit status.\n-     * (The stream <code>out<\/code> is assigned to <code>System.out<\/code> here.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-            \/\/ Last try. If there is some exception outside the code, test should end correctly\n-            @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n-                try {\n-                    pool = null;\n-                    log = null;\n-                    System.gc();\n-                    if (e instanceof OutOfMemoryError) {\n-                        try {\n-                            System.out.println(\"OOME : Test Skipped\");\n-                            System.exit(0);\n-                        } catch (Throwable ignore) {\n-                        } \/\/ No code in the handler can provoke correct exceptions.\n-                    } else {\n-                        e.printStackTrace();\n-                        throw (RuntimeException) e;\n-                    }\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            }\n-        });\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-    \/**\n-     * This class should be used to check <code>ClassNotFoundException<\/code>\n-     * and <code>IllegalAccessException<\/code>.\n-     *\/\n-    private static class Abra {\n-        \/**\n-         * Will try to incorrectly find this class as <code>Cadabra<\/code>\n-         * instead of <code>Abra$Cadabra<\/code>.\n-         *\/\n-        public static class Cadabra {\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/except002.java","additions":0,"deletions":301,"binary":false,"changes":301,"status":"deleted"},{"patch":"@@ -1,302 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/except\/except003.\n- * VM testbase keywords: [stress, diehard, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This checks if various exceptions are thrown (and caught) correctly\n- *     when there apparently are no free space in the heap to allocate new\n- *     Throwable instance.\n- *     The test tries to occupy all of memory available in the heap by allocating\n- *     lots of new Object() instances. Instances of the type Object are the smallest\n- *     objects, so they apparently should occupy most fine-grained fragments in the\n- *     heap and leave no free space for new Throwable instance. After that, the test\n- *     provokes various exceptions (e.g.: by executing integer division by 0 and so\n- *     on), and checks if appropriate exceptions are thrown.\n- * COMMENTS\n- *     The test needs a lot of memory to start up, so it should not run under older\n- *     JDK 1.1.x release due to its poorer heap utilization. Also, some checks are\n- *     skipped when testing classic VM, because OutOfMemoryError is correctly thrown\n- *     instead of target exception.\n- *     When the test is being self-initiating (i.e.: eating heap), memory occupation\n- *     is terminated if memory allocation slows down crucially. This is a workaround\n- *     intended to avoid the HotSpot bug:\n- *         #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- *     There is also a workaround involved to avoid the following bugs known\n- *     for HotSpot and for classic VM:\n- *         #4239841 (P1\/S5) 1.1: poor garbage collector performance  (HotSpot bug)\n- *         #4245060 (P4\/S5) poor garbage collector performance       (Classic VM bug)\n- *     However, printing of the test's error messages, warnings, and of execution\n- *     trace fails under JDK 1.2 for Win32 even so. If the test fails due to this\n- *     problem, exit status 96 is returned instead of 97.\n- *     JDK 1.3 classic VM for Sparc may crash (core dump) due to the known bug:\n- *         #4245057 (P2\/S3) VM crashes when heap is exhausted\n- *\n- * @run main\/othervm -Xms50M -Xmx200M nsk.stress.except.except003\n- *\/\n-\n-package nsk.stress.except;\n-\n-import java.io.PrintStream;\n-\n-\/**\n- * This checks if various exceptions are thrown (and caught) correctly\n- * when there apparently are no free space in the heap to allocate new\n- * <code>Throwable<\/code> instance.\n- * <p>\n- * <p>The test tries to occupy all of memory available in the heap by\n- * allocating lots of new <code>Object()<\/code> instances. Instances of the\n- * type <code>Object<\/code> are the smallest objects, so they apparently should\n- * occupy most fine-grained fragments in the heap and leave no free space for\n- * new <code>Throwable<\/code> instance. After that, the test provokes various\n- * exceptions (e.g.: by executing integer division by 0 and so on), and checks\n- * if appropriate exceptions are thrown.\n- * <p>\n- * <p>Note, that memory occupation is terminated if memory allocation slows\n- * down crucially. This is a workaround intended to avoid the HotSpot bug:\n- * <br>&nbsp;&nbsp;\n- * #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- * <p>\n- * <p>There is also a workaround involved to avoid the following bugs known\n- * for HotSpot and for classic VM:\n- * <br>&nbsp;&nbsp;\n- * #4239841 (P1\/S5) 1.1: poor garbage collector performance\n- * <br>&nbsp;&nbsp;\n- * #4245060 (P4\/S5) poor garbage collector performance\n- * <br>However, printing of the test's error messages, warnings, and of\n- * execution trace may fail even so. If the test fails due to poor GC\n- * performance, exit status 96 is returned instead of 97.\n- * <p>\n- * <p>Also note, that the test needs a lot of memory to start up, so it should\n- * not run under older JDK 1.1.x release due to its poor heap utilization.\n- *\/\n-public class except003 {\n-    \/**\n-     * Either allow or supress printing of execution trace.\n-     *\/\n-    private static boolean TRACE_ON = false;\n-    \/**\n-     * Either allow or supress printing of warning messages.\n-     *\/\n-    private static final boolean WARN_ON = true;\n-    \/*\n-    * Storage for a lot of tiny objects\n-    * \"static volatile\" keywords are for preventing heap optimization\n-    *\/\n-    private static volatile Object pool[] = null;\n-    \/**\n-     * Temporary <code>log<\/code> for error messages, warnings and\/or execution trace.\n-     *\n-     * @see #messages\n-     *\/\n-    private static String log[] = new String[1000]; \/\/ up to 1000 messages\n-    \/**\n-     * How many <code>messages<\/code> were submitted to the <code>log<\/code>.\n-     *\n-     * @see #log\n-     *\/\n-    private static int messages = 0;\n-\n-    \/**\n-     * Re-call to the method <code>run(out)<\/code> (ignore <code>args[]<\/code>),\n-     * and print the test summary - either test passed of failed.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            if (args[0].toLowerCase().startsWith(\"-v\"))\n-                TRACE_ON = true;\n-        }\n-\n-        int exitCode = run(out);\n-        pool = null;\n-        System.gc();\n-        \/\/ Print the log[] and the test summary:\n-        try {\n-            for (int i = 0; i < messages; i++)\n-                out.println(log[i]);\n-            if (exitCode == 0) {\n-                if (TRACE_ON)\n-                    out.println(\"Test passed.\");\n-            } else\n-                out.println(\"Test failed.\");\n-        } catch (OutOfMemoryError oome) {\n-            \/\/ Poor performance of garbage collector:\n-            exitCode = 1;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Allocate as much <code>Object<\/code> instances as possible to bring JVM\n-     * into stress, and then check if exceptions are correctly thrown accordingly\n-     * to various situations like integer division by 0, etc.\n-     *\/\n-    private static int run(PrintStream out) {\n-        out.println(\"# While printing this message, JVM seems to initiate the output\");\n-        out.println(\"# stream, so that it will not need more memory to print later,\");\n-        out.println(\"# when the heap would fail to provide more memory.\");\n-        out.println(\"# \");\n-        out.println(\"# Note, that the test maintains especial static log[] field in\");\n-        out.println(\"# order to avoid printing when the heap seems exhausted.\");\n-        out.println(\"# Nevertheless, printing could arise OutOfMemoryError even\");\n-        out.println(\"# after all the memory allocated by the test is released.\");\n-        out.println(\"# \");\n-        out.println(\"# That problem is caused by the known JDK\/HotSpot bugs:\");\n-        out.println(\"#     4239841 (P1\/S5) 1.1: poor garbage collector performance\");\n-        out.println(\"#     4245060 (P4\/S5) poor garbage collector performance\");\n-        out.println(\"# \");\n-        out.println(\"# This message is just intended to work-around that problem.\");\n-        out.println(\"# If printing should fail even so, the test will return the\");\n-        out.println(\"# exit status 96 instead of 97 to indicate the problem.\");\n-\n-        \/\/ Prepare some items, which will be used by the test:\n-        Object trash = null;\n-\n-        \/\/ Allocate repository for a lots of tiny objects:\n-        pool = null;\n-        \/\/ Sum up exit code:\n-        int exitCode = 0; \/\/ apparently PASSED\n-        int skipped = 0;  \/\/ some checks may correctly suffer OutOfMemoryError\n-        for (int size = 1 << 30; size > 0 && pool == null; size >>= 1)\n-            try {\n-                pool = new Object[size];\n-            } catch (OutOfMemoryError oome) {\n-            }\n-        if (pool == null)\n-            throw new Error(\"HS bug: cannot allocate new Object[1]\");\n-        int poolSize = pool.length;\n-        int index = 0;\n-\n-        \/\/ Sum up time spent, when it was hard to JVM to allocate next object\n-        \/\/ (i.e.: when JVM has spent more than 1 second to allocate new object):\n-        double totalDelay = 0;\n-        long timeMark = System.currentTimeMillis();\n-        try {\n-            for (; index < poolSize; index++) {\n-                \/\/-------------------------\n-                pool[index] = new Object();\n-                long nextTimeMark = System.currentTimeMillis();\n-                long elapsed = nextTimeMark - timeMark;\n-                timeMark = nextTimeMark;\n-                \/\/----------------------\n-                if (elapsed > 1000) {\n-                    double seconds = elapsed \/ 1000.0;\n-                    if (TRACE_ON)\n-                        out.println(\n-                                \"pool[\" + index + \"]=new Object(); \/\/ elapsed \" + seconds + \"s\");\n-                    totalDelay += seconds;\n-                    if (totalDelay > 60) {\n-                        if (TRACE_ON)\n-                            out.println(\n-                                    \"Memory allocation became slow; so, heap seems exhausted.\");\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (OutOfMemoryError oome) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Heap seems exhausted - OutOfMemoryError thrown.\";\n-\n-            \/\/ Do not release any byte once allocated:\n-            pool[index++] = oome;\n-        }\n-\n-        if (index > poolSize - 1000) {\n-            if (WARN_ON)\n-                log[messages++] = \"Warning: pool[] is full; so, checks would not be enough hard...\";\n-        }\n-\n-        \/\/ Check ClassNotFoundException (negative):\n-        try {\n-\/\/          trash = Class.forName(\"nsk.stress.except.except003$Abra$Cadabra\"); \/\/   correct - should pass\n-            trash = Class.forName(\"nsk.stress.except.except003.Abra.Cadabra\"); \/\/ incorrect - should fail\n-            log[messages++] = \"Failure: ClassNotFoundException (negative)\";\n-            exitCode = 2;\n-        } catch (ClassNotFoundException cnfe) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: ClassNotFoundException (negative)\";\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: ClassNotFoundException (negative)\";\n-            skipped++;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Re-call to <code>run(args,out)<\/code>, and return JCK-like exit status.\n-     * (The stream <code>out<\/code> is assigned to <code>System.out<\/code> here.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-            \/\/ Last try. If there is some exception outside the code, test should end correctly\n-            @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n-                try {\n-                    pool = null;\n-                    log = null;\n-                    System.gc();\n-                    if (e instanceof OutOfMemoryError) {\n-                        try {\n-                            System.out.println(\"OOME : Test Skipped\");\n-                            System.exit(95);\n-                        } catch (Throwable ignore) {\n-                        } \/\/ No code in the handler can provoke correct exceptions.\n-                    } else {\n-                        e.printStackTrace();\n-                        throw (RuntimeException) e;\n-                    }\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            }\n-        });\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-    \/**\n-     * This class should be used to check <code>ClassNotFoundException<\/code>\n-     * and <code>IllegalAccessException<\/code>.\n-     *\/\n-    private static class Abra {\n-        \/**\n-         * Will try to incorrectly find this class as <code>Cadabra<\/code>\n-         * instead of <code>Abra$Cadabra<\/code>.\n-         *\/\n-        public static class Cadabra {\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/except003.java","additions":0,"deletions":302,"binary":false,"changes":302,"status":"deleted"},{"patch":"@@ -1,555 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/except\/except004.\n- * VM testbase keywords: [stress, diehard, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This checks if various exceptions are thrown (and caught) correctly\n- *     when there apparently are no free space in the heap to allocate new\n- *     Throwable instance.\n- *     The test tries to occupy all of memory available in the heap by allocating\n- *     lots of new Object() instances. Instances of the type Object are the smallest\n- *     objects, so they apparently should occupy most fine-grained fragments in the\n- *     heap and leave no free space for new Throwable instance. After that, the test\n- *     provokes various exceptions (e.g.: by executing integer division by 0 and so\n- *     on), and checks if appropriate exceptions are thrown.\n- * COMMENTS\n- *     The test needs a lot of memory to start up, so it should not run under older\n- *     JDK 1.1.x release due to its poorer heap utilization. Also, some checks are\n- *     skipped when testing classic VM, because OutOfMemoryError is correctly thrown\n- *     instead of target exception.\n- *     When the test is being self-initiating (i.e.: eating heap), memory occupation\n- *     is terminated if memory allocation slows down crucially. This is a workaround\n- *     intended to avoid the HotSpot bug:\n- *         #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- *     There is also a workaround involved to avoid the following bugs known\n- *     for HotSpot and for classic VM:\n- *         #4239841 (P1\/S5) 1.1: poor garbage collector performance  (HotSpot bug)\n- *         #4245060 (P4\/S5) poor garbage collector performance       (Classic VM bug)\n- *     However, printing of the test's error messages, warnings, and of execution\n- *     trace fails under JDK 1.2 for Win32 even so. If the test fails due to this\n- *     problem, exit status 96 is returned instead of 97.\n- *     JDK 1.3 classic VM for Sparc may crash (core dump) due to the known bug:\n- *         #4245057 (P2\/S3) VM crashes when heap is exhausted\n- *\n- * @run main\/othervm -Xms50M -Xmx200M -XX:-UseGCOverheadLimit nsk.stress.except.except004\n- *\/\n-\n-package nsk.stress.except;\n-\n-import java.io.PrintStream;\n-import java.lang.reflect.Field;\n-\n-\/**\n- * This checks if various exceptions are thrown (and caught) correctly\n- * when there apparently are no free space in the heap to allocate new\n- * <code>Throwable<\/code> instance.\n- * <p>\n- * <p>The test tries to occupy all of memory available in the heap by\n- * allocating lots of new <code>Object()<\/code> instances. Instances of the\n- * type <code>Object<\/code> are the smallest objects, so they apparently should\n- * occupy most fine-grained fragments in the heap and leave no free space for\n- * new <code>Throwable<\/code> instance. After that, the test provokes various\n- * exceptions (e.g.: by executing integer division by 0 and so on), and checks\n- * if appropriate exceptions are thrown.\n- * <p>\n- * <p>Note, that memory occupation is terminated if memory allocation slows\n- * down crucially. This is a workaround intended to avoid the HotSpot bug:\n- * <br>&nbsp;&nbsp;\n- * #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- * <p>\n- * <p>There is also a workaround involved to avoid the following bugs known\n- * for HotSpot and for classic VM:\n- * <br>&nbsp;&nbsp;\n- * #4239841 (P1\/S5) 1.1: poor garbage collector performance\n- * <br>&nbsp;&nbsp;\n- * #4245060 (P4\/S5) poor garbage collector performance\n- * <br>However, printing of the test's error messages, warnings, and of\n- * execution trace may fail even so. If the test fails due to poor GC\n- * performance, exit status 96 is returned instead of 97.\n- * <p>\n- * <p>Also note, that the test needs a lot of memory to start up, so it should\n- * not run under older JDK 1.1.x release due to its poor heap utilization.\n- *\/\n-public class except004 {\n-    \/**\n-     * Either allow or supress printing of execution trace.\n-     *\/\n-    private static boolean TRACE_ON = false;\n-    \/**\n-     * Either allow or supress printing of warning messages.\n-     *\/\n-    private static final boolean WARN_ON = true;\n-    \/*\n-     * Storage for a lot of tiny objects\n-     * \"static volatile\" keywords are for preventing heap optimization\n-     *\/\n-    private static volatile Object pool[] = null;\n-    \/**\n-     * Temporary <code>log<\/code> for error messages, warnings and\/or execution trace.\n-     *\n-     * @see #messages\n-     *\/\n-    private static String log[] = new String[1000]; \/\/ up to 1000 messages\n-    \/**\n-     * How many <code>messages<\/code> were submitted to the <code>log<\/code>.\n-     *\n-     * @see #log\n-     *\/\n-    private static int messages = 0;\n-\n-    \/**\n-     * Re-call to the method <code>run(out)<\/code> (ignore <code>args[]<\/code>),\n-     * and print the test summary - either test passed of failed.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            if (args[0].toLowerCase().startsWith(\"-v\"))\n-                TRACE_ON = true;\n-        }\n-\n-        int exitCode;\n-        try {\n-            exitCode = run(out);\n-        } finally { \/\/ ensure we have free memory for exception processing\n-            pool = null;\n-            System.gc();\n-        }\n-        if (TRACE_ON)\n-            out.println(\"Test completed.\");\n-\n-        \/\/ Print the log[] and the test summary:\n-        try {\n-            for (int i = 0; i < messages; i++)\n-                out.println(log[i]);\n-            if (exitCode == 0) {\n-                if (TRACE_ON)\n-                    out.println(\"Test passed.\");\n-            } else\n-                out.println(\"Test failed.\");\n-        } catch (OutOfMemoryError oome) {\n-            \/\/ Poor performance of garbage collector:\n-            exitCode = 1;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Allocate as much <code>Object<\/code> instances as possible to bring JVM\n-     * into stress, and then check if exceptions are correctly thrown accordingly\n-     * to various situations like integer division by 0, etc.\n-     *\/\n-    private static int run(PrintStream out) {\n-        out.println(\"# While printing this message, JVM seems to initiate the output\");\n-        out.println(\"# stream, so that it will not need more memory to print later,\");\n-        out.println(\"# when the heap would fail to provide more memory.\");\n-        out.println(\"# \");\n-        out.println(\"# Note, that the test maintains especial static log[] field in\");\n-        out.println(\"# order to avoid printing when the heap seems exhausted.\");\n-        out.println(\"# Nevertheless, printing could cause OutOfMemoryError even\");\n-        out.println(\"# after all the memory allocated by the test is released.\");\n-        out.println(\"# \");\n-        out.println(\"# That problem is caused by the known JDK\/HotSpot bugs:\");\n-        out.println(\"#     4239841 (P1\/S5) 1.1: poor garbage collector performance\");\n-        out.println(\"#     4245060 (P4\/S5) poor garbage collector performance\");\n-        out.println(\"# \");\n-        out.println(\"# This message is just intended to work-around that problem.\");\n-        out.println(\"# If printing should fail even so, the test will return the\");\n-        out.println(\"# exit status 96 instead of 97 to indicate the problem.\");\n-\n-        \/\/ run all tests normally to ensure all needed classes are loaded and\n-        \/\/ initialized before the heap is exhausted - else we may trigger OOME\n-        \/\/ in unexpected places.\n-        try {\n-            if (TRACE_ON)\n-                out.println(\"Running without heap exhaustion\");\n-            runTests(out, false);\n-        } catch (Throwable unexpected) {\n-            out.println(\"Test pre-initialisation failed: \" + unexpected);\n-            return 2;\n-        }\n-\n-        if (TRACE_ON)\n-            out.println(\"Running with heap exhaustion\");\n-\n-        return runTests(out, true);\n-    }\n-\n-    private static int runTests(PrintStream out, boolean exhaustHeap) {\n-        \/\/ reset message index\n-        messages = 0;\n-\n-        \/\/ Prepare some items, which will be used by the test:\n-        Object stringArray[] = new String[1];\n-        Object integerValue = Integer.valueOf(0);\n-        Object doubleValue = Double.valueOf(0);\n-        Object trash = null;\n-        Field abraIntegerField;\n-        Field abraBooleanField;\n-        Field extPrivateField;\n-        try {\n-            abraIntegerField = Abra.class.getDeclaredField(\"MAIN_CYR_NUMBER\");\n-            abraBooleanField = Abra.class.getDeclaredField(\"NOT_AN_INTEGER\");\n-            extPrivateField = Ext.class.getDeclaredField(\"DONT_TOUCH_ME\");\n-        } catch (NoSuchFieldException nsfe) {\n-            out.println(\"Test initialisation failed: field not found: \" + nsfe.getMessage());\n-            return 2;\n-        }\n-\n-        Abra abra = new Abra(\"via public constructor\");\n-        Abra.Cadabra cadabra = new Abra.Cadabra();\n-        \/\/ Sum up exit code:\n-        int exitCode = 0; \/\/ apparently PASSED\n-        int skipped = 0;  \/\/ some checks may correctly suffer OutOfMemoryError\n-\n-        int poolSize = 0;\n-        int index = 0;\n-\n-        if (exhaustHeap) {\n-            pool = null;\n-            \/\/ Allocate repository for lots of tiny objects:\n-            for (int size = 1 << 30; size > 0 && pool == null; size >>= 1) {\n-                try {\n-                    pool = new Object[size];\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            }\n-            if (pool == null)\n-                throw new Error(\"HS bug: cannot allocate new Object[1]\");\n-            poolSize = pool.length;\n-            index = 0;\n-\n-            \/\/ Sum up time spent, when it was hard for JVM to allocate next object\n-            \/\/ (i.e.: when JVM has spent more than 1 second to allocate new object):\n-            double totalDelay = 0;\n-            long timeMark = System.currentTimeMillis();\n-            try {\n-                for (; index < poolSize; index++) {\n-                    \/\/-------------------------\n-                    pool[index] = new Object();\n-                    long nextTimeMark = System.currentTimeMillis();\n-                    long elapsed = nextTimeMark - timeMark;\n-                    timeMark = nextTimeMark;\n-                    \/\/----------------------\n-                    if (elapsed > 1000) {\n-                        double seconds = elapsed \/ 1000.0;\n-                        if (TRACE_ON)\n-                            out.println(\n-                                    \"pool[\" + index + \"]=new Object(); \/\/ elapsed \" + seconds + \"s\");\n-                        totalDelay += seconds;\n-                        if (totalDelay > 60) {\n-                            if (TRACE_ON)\n-                                out.println(\n-                                        \"Memory allocation became slow; so, heap seems exhausted.\");\n-                            break;\n-                        }\n-                    }\n-                }\n-            } catch (OutOfMemoryError oome) {\n-                if (TRACE_ON)\n-                    log[messages++] = \"Heap seems exhausted - OutOfMemoryError thrown.\";\n-                \/\/ Do not release any byte once allocated:\n-                pool[index++] = oome;\n-            }\n-\n-            if (index > poolSize - 1000) {\n-                if (WARN_ON)\n-                    log[messages++] = \"Warning: pool[] is full; so, checks would not be enough hard...\";\n-            }\n-        } else {\n-            \/\/ pool gets used for array index tests\n-            pool = new Object[3];\n-            poolSize = pool.length;\n-        }\n-\n-        \/\/ Check ArithmeticException:\n-        try {\n-            int x, y, z;\n-            x = y = 0;\n-            z = x \/ y;\n-            log[messages++] = \"Failure: ArithmeticException\";\n-            exitCode = 2; \/\/ FAILED\n-        } catch (ArithmeticException ae) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: ArithmeticException\";\n-            if (exhaustHeap)\n-                pool[index++] = ae;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: ArithmeticException\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check ArrayIndexOutOfBoundsException:\n-        try {\n-            pool[poolSize] = pool[0];\n-            log[messages++] = \"Failure: ArrayIndexOutOfBoundsException\";\n-            exitCode = 2; \/\/ FAILED\n-        } catch (ArrayIndexOutOfBoundsException aioobe) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: ArrayIndexOutOfBoundsException\";\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: ArrayIndexOutOfBoundsException\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check ArrayStoreException:\n-        try {\n-            stringArray[0] = integerValue;\n-            log[messages++] = \"Failure: ArrayStoreException\";\n-            exitCode = 2; \/\/ FAILED\n-        } catch (ArrayStoreException ase) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: ArrayStoreException\";\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: ArrayStoreException\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check ClassCastException:\n-        try {\n-            trash = (Double) integerValue;\n-            log[messages++] = \"Failure: ClassCastException\";\n-            exitCode = 2; \/\/ FAILED\n-        } catch (ClassCastException cce) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: ClassCastException\";\n-            if (exhaustHeap)\n-                pool[index++] = cce;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: ClassCastException\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check CloneNotSupportedException:\n-        try {\n-            trash = abra.clone();    \/\/ illegal - should fail\n-\/\/          trash = cadabra.clone(); \/\/   legal - should pass\n-            log[messages++] = \"Failure: CloneNotSupportedException\";\n-            exitCode = 2; \/\/ FAILED\n-        } catch (CloneNotSupportedException cnse) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: CloneNotSupportedException\";\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: CloneNotSupportedException\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check IllegalAccessException (positive):\n-        try {\n-            int junkIt = abraIntegerField.getInt(null); \/\/   legal - should pass\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: IllegalAccessException (positive)\";\n-        } catch (IllegalAccessException iae) {\n-            log[messages++] = \"Failure: IllegalAccessException (positive)\";\n-            exitCode = 2;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: IllegalAccessException (positive)\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check IllegalAccessException (negative):\n-        try {\n-            int junkIt = extPrivateField.getInt(null); \/\/ illegal - should fail\n-            log[messages++] = \"Failure: IllegalAccessException (negative)\";\n-            exitCode = 2; \/\/ FAILED\n-        } catch (IllegalAccessException iae) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: IllegalAccessException (negative)\";\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: IllegalAccessException (negative)\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check IllegalArgumentException (positive):\n-        try {\n-            int junkIt = abraIntegerField.getInt(null); \/\/   legal - should pass\n-\/\/          int junkIt = abraBooleanField.getInt(null); \/\/ illegal - should fail\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: IllegalArgumentException (positive)\";\n-        } catch (IllegalAccessException iae) {\n-            log[messages++] =\n-                    \"Failure: IllegalArgumentException (positive) incorrectly thrown IllegalAccessException\";\n-            exitCode = 2;\n-        } catch (IllegalArgumentException iae) {\n-            log[messages++] = \"Failure: IllegalArgumentException (positive)\";\n-            exitCode = 2;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: IllegalArgumentException (positive)\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check IllegalArgumentException (negative):\n-        try {\n-\/\/          int junkIt = abraIntegerField.getInt(null); \/\/   legal - should pass\n-            int junkIt = abraBooleanField.getInt(null); \/\/ illegal - should fail\n-            log[messages++] = \"Failure: IllegalArgumentException (negative)\";\n-            exitCode = 2; \/\/ FAILED\n-        } catch (IllegalAccessException iae) {\n-            log[messages++] =\n-                    \"Failure: IllegalArgumentException (negative) incorrectly thrown IllegalAccessException\";\n-            exitCode = 2;\n-        } catch (IllegalArgumentException iae) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: IllegalArgumentException (negative)\";\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: IllegalArgumentException (negative)\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check IllegalMonitorStateException (positive):\n-        try {\n-            synchronized (cadabra) {\n-                cadabra.notifyAll();    \/\/   legal - should pass\n-            }\n-\/\/          cadabra.notifyAll();        \/\/ illegal - should fail\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: IllegalMonitorStateException (positive)\";\n-        } catch (IllegalMonitorStateException imse) {\n-            log[messages++] = \"Failure: IllegalMonitorStateException (positive)\";\n-            exitCode = 2;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: IllegalMonitorStateException (positive)\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check IllegalMonitorStateException (negative):\n-        try {\n-\/\/          synchronized (cadabra) {\n-\/\/              cadabra.notifyAll();    \/\/   legal - should pass\n-\/\/          }\n-            cadabra.notifyAll();        \/\/ illegal - should fail\n-            log[messages++] = \"Failure: IllegalMonitorStateException (negative)\";\n-            exitCode = 2;\n-        } catch (IllegalMonitorStateException imse) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: IllegalMonitorStateException (negative)\";\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: IllegalMonitorStateException (negative)\";\n-            skipped++;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Re-call to <code>run(args,out)<\/code>, and return JCK-like exit status.\n-     * (The stream <code>out<\/code> is assigned to <code>System.out<\/code> here.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-            \/\/ Last try. If there is some exception outside the code, test should end correctly\n-            @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n-                try {\n-                    pool = null;\n-                    log = null;\n-                    System.gc();\n-                    if (e instanceof OutOfMemoryError) {\n-                        try {\n-                            System.out.println(\"OOME : Test Skipped\");\n-                            System.exit(0);\n-                        } catch (Throwable ignore) {\n-                        } \/\/ No code in the handler can provoke correct exceptions.\n-                    } else {\n-                        e.printStackTrace();\n-                        if (e instanceof RuntimeException)\n-                            throw (RuntimeException) e;\n-                        else if (e instanceof Error)\n-                            throw (Error) e;\n-                        else\n-                            throw new Error(\"Unexpected checked exception\", e);\n-                    }\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            }\n-        });\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-    \/**\n-     * This class should be used to check <code>CloneNotSupportedException<\/code>,\n-     * and <code>IllegalArgumentException<\/code>.\n-     * The class extends <code>except004<\/code> in order that its (protected)\n-     * method <code>clone()<\/code> be available from <code>except004<\/code>.\n-     *\/\n-    private static class Abra extends except004 {\n-        \/**\n-         * Will try to incorrectly find this class as <code>Cadabra<\/code>\n-         * instead of <code>Abra$Cadabra<\/code>.\n-         *\/\n-        public static class Cadabra implements Cloneable {\n-        }\n-\n-        \/**\n-         * Will try to incorrectly access to this field from outside this class.\n-         *\/\n-        public static final int MAIN_CYR_NUMBER = 47;\n-        \/**\n-         * Will try to get this field like <code>int<code> zero.\n-         *\/\n-        public static final boolean NOT_AN_INTEGER = false;\n-\n-        \/**\n-         * Will try to correctly instantiate <code>Abra.Cadabra<\/code>,\n-         * not <code>Abra<\/code>.\n-         *\/\n-        private Abra() {\n-        }\n-\n-        \/**\n-         * Yet another constructor, which is <code>public<\/code>.\n-         *\/\n-        public Abra(String nothingSpecial) {\n-        }\n-    }\n-}\n-\n-\/* Package accessible class that has non-accessible private member *\/\n-class Ext {\n-    \/**\n-     * Will try to incorrectly access to this field from outside this class.\n-     *\/\n-    private static final int DONT_TOUCH_ME = 666;\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/except004.java","additions":0,"deletions":555,"binary":false,"changes":555,"status":"deleted"},{"patch":"@@ -1,319 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/except\/except005.\n- * VM testbase keywords: [stress, diehard, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This checks if various exceptions are thrown (and caught) correctly\n- *     when there apparently are no free space in the heap to allocate new\n- *     Throwable instance.\n- *     The test tries to occupy all of memory available in the heap by allocating\n- *     lots of new Object() instances. Instances of the type Object are the smallest\n- *     objects, so they apparently should occupy most fine-grained fragments in the\n- *     heap and leave no free space for new Throwable instance. After that, the test\n- *     provokes various exceptions (e.g.: by executing integer division by 0 and so\n- *     on), and checks if appropriate exceptions are thrown.\n- * COMMENTS\n- *     The test needs a lot of memory to start up, so it should not run under older\n- *     JDK 1.1.x release due to its poorer heap utilization. Also, some checks are\n- *     skipped when testing classic VM, because OutOfMemoryError is correctly thrown\n- *     instead of target exception.\n- *     When the test is being self-initiating (i.e.: eating heap), memory occupation\n- *     is terminated if memory allocation slows down crucially. This is a workaround\n- *     intended to avoid the HotSpot bug:\n- *         #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- *     There is also a workaround involved to avoid the following bugs known\n- *     for HotSpot and for classic VM:\n- *         #4239841 (P1\/S5) 1.1: poor garbage collector performance  (HotSpot bug)\n- *         #4245060 (P4\/S5) poor garbage collector performance       (Classic VM bug)\n- *     However, printing of the test's error messages, warnings, and of execution\n- *     trace fails under JDK 1.2 for Win32 even so. If the test fails due to this\n- *     problem, exit status 96 is returned instead of 97.\n- *     JDK 1.3 classic VM for Sparc may crash (core dump) due to the known bug:\n- *         #4245057 (P2\/S3) VM crashes when heap is exhausted\n- *\n- * @run main\/othervm -Xms50M -Xmx200M nsk.stress.except.except005\n- *\/\n-\n-package nsk.stress.except;\n-\n-import java.io.PrintStream;\n-\n-\/**\n- * This checks if various exceptions are thrown (and caught) correctly\n- * when there apparently are no free space in the heap to allocate new\n- * <code>Throwable<\/code> instance.\n- * <p>\n- * <p>The test tries to occupy all of memory available in the heap by\n- * allocating lots of new <code>Object()<\/code> instances. Instances of the\n- * type <code>Object<\/code> are the smallest objects, so they apparently should\n- * occupy most fine-grained fragments in the heap and leave no free space for\n- * new <code>Throwable<\/code> instance. After that, the test provokes various\n- * exceptions (e.g.: by executing integer division by 0 and so on), and checks\n- * if appropriate exceptions are thrown.\n- * <p>\n- * <p>Note, that memory occupation is terminated if memory allocation slows\n- * down crucially. This is a workaround intended to avoid the HotSpot bug:\n- * <br>&nbsp;&nbsp;\n- * #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- * <p>\n- * <p>There is also a workaround involved to avoid the following bugs known\n- * for HotSpot and for classic VM:\n- * <br>&nbsp;&nbsp;\n- * #4239841 (P1\/S5) 1.1: poor garbage collector performance\n- * <br>&nbsp;&nbsp;\n- * #4245060 (P4\/S5) poor garbage collector performance\n- * <br>However, printing of the test's error messages, warnings, and of\n- * execution trace may fail even so. If the test fails due to poor GC\n- * performance, exit status 96 is returned instead of 97.\n- * <p>\n- * <p>Also note, that the test needs a lot of memory to start up, so it should\n- * not run under older JDK 1.1.x release due to its poor heap utilization.\n- *\/\n-public class except005 {\n-    \/**\n-     * Either allow or supress printing of execution trace.\n-     *\/\n-    private static boolean TRACE_ON = false;\n-    \/**\n-     * Either allow or supress printing of warning messages.\n-     *\/\n-    private static final boolean WARN_ON = true;\n-\n-    \/**\n-     * Temporary <code>log<\/code> for error messages, warnings and\/or execution trace.\n-     *\n-     * @see #messages\n-     *\/\n-    private static String log[] = new String[1000]; \/\/ up to 1000 messages\n-    \/**\n-     * <code>pool<\/code> to store tiny objects to fill up the Heap\n-     *\/\n-    private static volatile Object pool[] = null;\n-    \/**\n-     * How many <code>messages<\/code> were submitted to the <code>log<\/code>.\n-     *\n-     * @see #log\n-     *\/\n-    private static int messages = 0;\n-\n-    \/**\n-     * Re-call to the method <code>run(out)<\/code> (ignore <code>args[]<\/code>),\n-     * and print the test summary - either test passed of failed.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            if (args[0].toLowerCase().startsWith(\"-v\"))\n-                TRACE_ON = true;\n-        }\n-\n-        int exitCode = run(out);\n-        pool = null;\n-        System.gc();\n-        \/\/ Print the log[] and the test summary:\n-        try {\n-            for (int i = 0; i < messages; i++)\n-                out.println(log[i]);\n-            if (exitCode == 0) {\n-                if (TRACE_ON)\n-                    out.println(\"Test passed.\");\n-            } else\n-                out.println(\"Test failed.\");\n-        } catch (OutOfMemoryError oome) {\n-            \/\/ Poor performance of garbage collector:\n-            exitCode = 1;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Allocate as much <code>Object<\/code> instances as possible to bring JVM\n-     * into stress, and then check if exceptions are correctly thrown accordingly\n-     * to various situations like integer division by 0, etc.\n-     *\/\n-    private static int run(PrintStream out) {\n-        out.println(\"# Test have been updated!\");\n-        out.println(\"# stream, so that it will not need more memory to print later,\");\n-        out.println(\"# when the heap would fail to provide more memory.\");\n-        out.println(\"# \");\n-        out.println(\"# Note, that the test maintains especial static log[] field in\");\n-        out.println(\"# order to avoid printing when the heap seems exhausted.\");\n-        out.println(\"# Nevertheless, printing could arise OutOfMemoryError even\");\n-        out.println(\"# after all the memory allocated by the test is released.\");\n-        out.println(\"# \");\n-        out.println(\"# That problem is caused by the known JDK\/HotSpot bugs:\");\n-        out.println(\"#     4239841 (P1\/S5) 1.1: poor garbage collector performance\");\n-        out.println(\"#     4245060 (P4\/S5) poor garbage collector performance\");\n-        out.println(\"# \");\n-        out.println(\"# This message is just intended to work-around that problem.\");\n-        out.println(\"# If printing should fail even so, the test will try to return\");\n-        out.println(\"# the exit status 96 instead of 97 to indicate the problem.\");\n-        out.println(\"# However, the test may fail or even crash on some platforms\");\n-        out.println(\"# suffering the bug 4239841 or 4245060.\");\n-\n-        \/\/ Sum up exit code:\n-        int exitCode = 0; \/\/ apparently PASSED\n-        int skipped = 0;  \/\/ some checks may correctly suffer OutOfMemoryError\n-        \/\/ Allocate repository for a lots of tiny objects:\n-        for (int size = 1 << 30; size > 0 && pool == null; size >>= 1)\n-            try {\n-                pool = new Object[size];\n-            } catch (OutOfMemoryError oome) {\n-            }\n-        if (pool == null)\n-            throw new Error(\"HS bug: cannot allocate new Object[1]\");\n-        int poolSize = pool.length;\n-        int index = 0;\n-\n-        \/\/ Sum up time spent, when it was hard to JVM to allocate next object\n-        \/\/ (i.e.: when JVM has spent more than 1 second to allocate new object):\n-        double totalDelay = 0;\n-        long timeMark = System.currentTimeMillis();\n-        try {\n-            for (; index < poolSize; index++) {\n-                \/\/-------------------------\n-                pool[index] = new Object();\n-                long nextTimeMark = System.currentTimeMillis();\n-                long elapsed = nextTimeMark - timeMark;\n-                timeMark = nextTimeMark;\n-                \/\/----------------------\n-                if (elapsed > 1000) {\n-                    double seconds = elapsed \/ 1000.0;\n-                    if (TRACE_ON) {\n-                        out.println(\n-                                \"pool[\" + index + \"]=new Object(); \/\/ elapsed \" + seconds + \"s\");\n-                    }\n-                    totalDelay += seconds;\n-                    if (totalDelay > 60) {\n-                        if (TRACE_ON)\n-                            out.println(\n-                                    \"Memory allocation became slow; so, heap seems exhausted.\");\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (OutOfMemoryError oome) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Heap seems exhausted - OutOfMemoryError thrown.\";\n-        }\n-        if (index > poolSize - 1000) {\n-            if (WARN_ON)\n-                log[messages++] = \"Warning: pool[] is full; so, checks would not be enough hard...\";\n-        }\n-\n-        \/\/ Check InstantiationException (positive):\n-        try {\n-\/\/          Object junkIt = Abra_Cadabra.class.newInstance(); \/\/ illegal - should fail\n-            Object junkIt = Abra.Cadabra.class.newInstance(); \/\/   legal - should pass\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: InstantiationException (positive)\";\n-        } catch (IllegalAccessException iae) {\n-            log[messages++] =\n-                    \"Failure: InstantiationException (positive) incorrectly thrown IllegalAccessException\";\n-            pool[index++] = iae;\n-            exitCode = 2;\n-        } catch (InstantiationException ie) {\n-            log[messages++] = \"Failure: InstantiationException (positive)\";\n-            pool[index++] = ie;\n-            exitCode = 2;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: InstantiationException (positive)\";\n-            pool[index++] = oome;\n-            skipped++;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Re-call to <code>run(args,out)<\/code>, and return JCK-like exit status.\n-     * (The stream <code>out<\/code> is assigned to <code>System.out<\/code> here.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-            \/\/ Last try. If there is some OOME, test should end correctly\n-            @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n-                try {\n-                    pool = null;\n-                    log = null;\n-                    System.gc();\n-                    if (e instanceof OutOfMemoryError) {\n-                        try {\n-                            System.out.println(\"OOME : Test Skipped\");\n-                            System.exit(0);\n-                        } catch (Throwable ignore) {\n-                        } \/\/ No code in the handler can provoke correct exceptions.\n-                    } else {\n-                        e.printStackTrace();\n-                        throw (RuntimeException) e;\n-                    }\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            }\n-        });\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-    \/**\n-     * This class should be used to check <code>CloneNotSupportedException<\/code>,\n-     * <code>IllegalAccessException<\/code>, and <code>IllegalArgumentException<\/code>.\n-     * The class extends <code>except005<\/code> in order that its (protected)\n-     * method <code>clone()<\/code> be available from <code>except005<\/code>.\n-     *\/\n-    private static class Abra {\n-        \/**\n-         * Will correctly instantiate <code>Abra.Cadabra<\/code> object.\n-         *\/\n-        public static class Cadabra {\n-        }\n-\n-        \/**\n-         * Will try to correctly instantiate <code>Abra.Cadabra<\/code>,\n-         * not <code>Abra<\/code>.\n-         *\/\n-        private Abra() {\n-        }\n-\n-    }\n-\n-    \/**\n-     * Will try to incorrectly instantiate and object of this class.\n-     *\/\n-    private interface Abra_Cadabra {\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/except005.java","additions":0,"deletions":319,"binary":false,"changes":319,"status":"deleted"},{"patch":"@@ -1,316 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/except\/except006.\n- * VM testbase keywords: [stress, diehard, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This checks if various exceptions are thrown (and caught) correctly\n- *     when there apparently are no free space in the heap to allocate new\n- *     Throwable instance.\n- *     The test tries to occupy all of memory available in the heap by allocating\n- *     lots of new Object() instances. Instances of the type Object are the smallest\n- *     objects, so they apparently should occupy most fine-grained fragments in the\n- *     heap and leave no free space for new Throwable instance. After that, the test\n- *     provokes various exceptions (e.g.: by executing integer division by 0 and so\n- *     on), and checks if appropriate exceptions are thrown.\n- * COMMENTS\n- *     The test needs a lot of memory to start up, so it should not run under older\n- *     JDK 1.1.x release due to its poorer heap utilization. Also, some checks are\n- *     skipped when testing classic VM, because OutOfMemoryError is correctly thrown\n- *     instead of target exception.\n- *     When the test is being self-initiating (i.e.: eating heap), memory occupation\n- *     is terminated if memory allocation slows down crucially. This is a workaround\n- *     intended to avoid the HotSpot bug:\n- *         #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- *     There is also a workaround involved to avoid the following bugs known\n- *     for HotSpot and for classic VM:\n- *         #4239841 (P1\/S5) 1.1: poor garbage collector performance  (HotSpot bug)\n- *         #4245060 (P4\/S5) poor garbage collector performance       (Classic VM bug)\n- *     However, printing of the test's error messages, warnings, and of execution\n- *     trace fails under JDK 1.2 for Win32 even so. If the test fails due to this\n- *     problem, exit status 96 is returned instead of 97.\n- *     JDK 1.3 classic VM for Sparc may crash (core dump) due to the known bug:\n- *         #4245057 (P2\/S3) VM crashes when heap is exhausted\n- *\n- * @run main\/othervm -Xms50M -Xmx200M nsk.stress.except.except006\n- *\/\n-\n-package nsk.stress.except;\n-\n-import java.io.PrintStream;\n-\n-\/**\n- * This checks if various exceptions are thrown (and caught) correctly\n- * when there apparently are no free space in the heap to allocate new\n- * <code>Throwable<\/code> instance.\n- * <p>\n- * <p>The test tries to occupy all of memory available in the heap by\n- * allocating lots of new <code>Object()<\/code> instances. Instances of the\n- * type <code>Object<\/code> are the smallest objects, so they apparently should\n- * occupy most fine-grained fragments in the heap and leave no free space for\n- * new <code>Throwable<\/code> instance. After that, the test provokes various\n- * exceptions (e.g.: by executing integer division by 0 and so on), and checks\n- * if appropriate exceptions are thrown.\n- * <p>\n- * <p>Note, that memory occupation is terminated if memory allocation slows\n- * down crucially. This is a workaround intended to avoid the HotSpot bug:\n- * <br>&nbsp;&nbsp;\n- * #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- * <p>\n- * <p>There is also a workaround involved to avoid the following bugs known\n- * for HotSpot and for classic VM:\n- * <br>&nbsp;&nbsp;\n- * #4239841 (P1\/S5) 1.1: poor garbage collector performance\n- * <br>&nbsp;&nbsp;\n- * #4245060 (P4\/S5) poor garbage collector performance\n- * <br>However, printing of the test's error messages, warnings, and of\n- * execution trace may fail even so. If the test fails due to poor GC\n- * performance, exit status 96 is returned instead of 97.\n- * <p>\n- * <p>Also note, that the test needs a lot of memory to start up, so it should\n- * not run under older JDK 1.1.x release due to its poor heap utilization.\n- *\/\n-public class except006 {\n-    \/**\n-     * Either allow or supress printing of execution trace.\n-     *\/\n-    private static boolean TRACE_ON = false;\n-    \/**\n-     * Either allow or supress printing of warning messages.\n-     *\/\n-    private static final boolean WARN_ON = true;\n-    \/*\n-    * Storage for a lot of tiny objects\n-    * \"static volatile\" keywords are for preventing heap optimization\n-    *\/\n-    private static volatile Object pool[] = null;\n-    \/**\n-     * Temporary <code>log<\/code> for error messages, warnings and\/or execution trace.\n-     *\n-     * @see #messages\n-     *\/\n-    private static String log[] = new String[1000]; \/\/ up to 1000 messages\n-    \/**\n-     * How many <code>messages<\/code> were submitted to the <code>log<\/code>.\n-     *\n-     * @see #log\n-     *\/\n-    private static int messages = 0;\n-\n-    \/**\n-     * Re-call to the method <code>run(out)<\/code> (ignore <code>args[]<\/code>),\n-     * and print the test summary - either test passed of failed.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            if (args[0].toLowerCase().startsWith(\"-v\"))\n-                TRACE_ON = true;\n-        }\n-\n-        int exitCode = run(out);\n-        pool = null;\n-        System.gc();\n-        \/\/ Print the log[] and the test summary:\n-        try {\n-            for (int i = 0; i < messages; i++)\n-                out.println(log[i]);\n-            if (exitCode == 0) {\n-                if (TRACE_ON)\n-                    out.println(\"Test passed.\");\n-            } else\n-                out.println(\"Test failed.\");\n-        } catch (OutOfMemoryError oome) {\n-            \/\/ Poor performance of garbage collector:\n-            exitCode = 1;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Allocate as much <code>Object<\/code> instances as possible to bring JVM\n-     * into stress, and then check if exceptions are correctly thrown accordingly\n-     * to various situations like integer division by 0, etc.\n-     *\/\n-    private static int run(PrintStream out) {\n-        out.println(\"# While printing this message, JVM seems to initiate the output\");\n-        out.println(\"# stream, so that it will not need more memory to print later,\");\n-        out.println(\"# when the heap would fail to provide more memory.\");\n-        out.println(\"# \");\n-        out.println(\"# Note, that the test maintains especial static log[] field in\");\n-        out.println(\"# order to avoid printing when the heap seems exhausted.\");\n-        out.println(\"# Nevertheless, printing could arise OutOfMemoryError even\");\n-        out.println(\"# after all the memory allocated by the test is released.\");\n-        out.println(\"# \");\n-        out.println(\"# That problem is caused by the known JDK\/HotSpot bugs:\");\n-        out.println(\"#     4239841 (P1\/S5) 1.1: poor garbage collector performance\");\n-        out.println(\"#     4245060 (P4\/S5) poor garbage collector performance\");\n-        out.println(\"# \");\n-        out.println(\"# This message is just intended to work-around that problem.\");\n-        out.println(\"# If printing should fail even so, the test will try to return\");\n-        out.println(\"# the exit status 96 instead of 97 to indicate the problem.\");\n-        out.println(\"# However, the test may fail or even crash on some platforms\");\n-        out.println(\"# suffering the bug 4239841 or 4245060.\");\n-\n-        \/\/ Allocate repository for a lots of tiny objects:\n-        for (int size = 1 << 30; size > 0 && pool == null; size >>= 1)\n-            try {\n-                pool = new Object[size];\n-            } catch (OutOfMemoryError oome) {\n-            }\n-        if (pool == null)\n-            throw new Error(\"HS bug: cannot allocate new Object[1]\");\n-        int poolSize = pool.length;\n-        int index = 0;\n-        \/\/ Sum up exit code:\n-        int exitCode = 0; \/\/ apparently PASSED\n-        int skipped = 0;  \/\/ some checks may correctly suffer OutOfMemoryError\n-        Object junkIt;\n-        \/\/ Sum up time spent, when it was hard to JVM to allocate next object\n-        \/\/ (i.e.: when JVM has spent more than 1 second to allocate new object):\n-        double totalDelay = 0;\n-        long timeMark = System.currentTimeMillis();\n-        try {\n-            for (; index < poolSize; index++) {\n-                \/\/-------------------------\n-                pool[index] = new Object();\n-                long nextTimeMark = System.currentTimeMillis();\n-                long elapsed = nextTimeMark - timeMark;\n-                timeMark = nextTimeMark;\n-                \/\/----------------------\n-                if (elapsed > 1000) {\n-                    double seconds = elapsed \/ 1000.0;\n-                    if (TRACE_ON)\n-                        out.println(\n-                                \"pool[\" + index + \"]=new Object(); \/\/ elapsed \" + seconds + \"s\");\n-                    totalDelay += seconds;\n-                    if (totalDelay > 60) {\n-                        if (TRACE_ON)\n-                            out.println(\n-                                    \"Memory allocation became slow; so, heap seems exhausted.\");\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (OutOfMemoryError oome) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Heap seems exhausted - OutOfMemoryError thrown.\";\n-        }\n-        if (index > poolSize - 1000) {\n-            if (WARN_ON)\n-                log[messages++] = \"Warning: pool[] is full; so, checks would not be enough hard...\";\n-        }\n-\n-\n-        \/\/ Check InstantiationException (negative):\n-        try {\n-            junkIt = Abra_Cadabra.class.newInstance(); \/\/ illegal - should fail\n-\/\/          Object junkIt = Abra.Cadabra.class.newInstance(); \/\/   legal - should pass\n-            log[messages++] = \"Failure: InstantiationException (negative)\";\n-            exitCode = 2;\n-        } catch (IllegalAccessException iae) {\n-            log[messages++] =\n-                    \"Failure: InstantiationException (negative) incorrectly thrown IllegalAccessException\";\n-            exitCode = 2;\n-        } catch (InstantiationException ie) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: InstantiationException (negative)\";\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: InstantiationException (negative)\";\n-            skipped++;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Re-call to <code>run(args,out)<\/code>, and return JCK-like exit status.\n-     * (The stream <code>out<\/code> is assigned to <code>System.out<\/code> here.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-            \/\/ Last try. If there is some exception outside the code, test should end correctly\n-            @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n-                try {\n-                    pool = null;\n-                    log = null;\n-                    System.gc();\n-                    if (e instanceof OutOfMemoryError) {\n-                        try {\n-                            System.out.println(\"OOME : Test Skipped\");\n-                            System.exit(0);\n-                        } catch (Throwable ignore) {\n-                        } \/\/ No code in the handler can provoke correct exceptions.\n-                    } else {\n-                        e.printStackTrace();\n-                        throw (RuntimeException) e;\n-                    }\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            }\n-        });\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-    \/**\n-     * This class should be used to check <code>CloneNotSupportedException<\/code>,\n-     * <code>IllegalAccessException<\/code>, and <code>IllegalArgumentException<\/code>.\n-     * The class extends <code>except006<\/code> in order that its (protected)\n-     * method <code>clone()<\/code> be available from <code>except006<\/code>.\n-     *\/\n-    private static class Abra {\n-        \/**\n-         * Will correctly instantiate <code>Abra.Cadabra<\/code> object.\n-         *\/\n-        public static class Cadabra {\n-        }\n-\n-        \/**\n-         * Will try to correctly instantiate <code>Abra.Cadabra<\/code>,\n-         * not <code>Abra<\/code>.\n-         *\/\n-        private Abra() {\n-        }\n-\n-    }\n-\n-    \/**\n-     * Will try to incorrectly instantiate and object of this class.\n-     *\/\n-    private interface Abra_Cadabra {\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/except006.java","additions":0,"deletions":316,"binary":false,"changes":316,"status":"deleted"},{"patch":"@@ -1,380 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/except\/except007.\n- * VM testbase keywords: [stress, diehard, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This checks if various exceptions are thrown (and caught) correctly\n- *     when there apparently are no free space in the heap to allocate new\n- *     Throwable instance.\n- *     The test tries to occupy all of memory available in the heap by allocating\n- *     lots of new Object() instances. Instances of the type Object are the smallest\n- *     objects, so they apparently should occupy most fine-grained fragments in the\n- *     heap and leave no free space for new Throwable instance. After that, the test\n- *     provokes various exceptions (e.g.: by executing integer division by 0 and so\n- *     on), and checks if appropriate exceptions are thrown.\n- * COMMENTS\n- *     The test needs a lot of memory to start up, so it should not run under older\n- *     JDK 1.1.x release due to its poorer heap utilization. Also, some checks are\n- *     skipped when testing classic VM, because OutOfMemoryError is correctly thrown\n- *     instead of target exception.\n- *     When the test is being self-initiating (i.e.: eating heap), memory occupation\n- *     is terminated if memory allocation slows down crucially. This is a workaround\n- *     intended to avoid the HotSpot bug:\n- *         #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- *     There is also a workaround involved to avoid the following bugs known\n- *     for HotSpot and for classic VM:\n- *         #4239841 (P1\/S5) 1.1: poor garbage collector performance  (HotSpot bug)\n- *         #4245060 (P4\/S5) poor garbage collector performance       (Classic VM bug)\n- *     However, printing of the test's error messages, warnings, and of execution\n- *     trace fails under JDK 1.2 for Win32 even so. If the test fails due to this\n- *     problem, exit status 96 is returned instead of 97.\n- *     JDK 1.3 classic VM for Sparc may crash (core dump) due to the known bug:\n- *         #4245057 (P2\/S3) VM crashes when heap is exhausted\n- *\n- * @run main\/othervm -Xms50M -Xmx200M nsk.stress.except.except007\n- *\/\n-\n-package nsk.stress.except;\n-\n-import java.io.PrintStream;\n-\n-\/**\n- * This checks if various exceptions are thrown (and caught) correctly\n- * when there apparently are no free space in the heap to allocate new\n- * <code>Throwable<\/code> instance.\n- * <p>\n- * <p>The test tries to occupy all of memory available in the heap by\n- * allocating lots of new <code>Object()<\/code> instances. Instances of the\n- * type <code>Object<\/code> are the smallest objects, so they apparently should\n- * occupy most fine-grained fragments in the heap and leave no free space for\n- * new <code>Throwable<\/code> instance. After that, the test provokes various\n- * exceptions (e.g.: by executing integer division by 0 and so on), and checks\n- * if appropriate exceptions are thrown.\n- * <p>\n- * <p>Note, that memory occupation is terminated if memory allocation slows\n- * down crucially. This is a workaround intended to avoid the HotSpot bug:\n- * <br>&nbsp;&nbsp;\n- * #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- * <p>\n- * <p>There is also a workaround involved to avoid the following bugs known\n- * for HotSpot and for classic VM:\n- * <br>&nbsp;&nbsp;\n- * #4239841 (P1\/S5) 1.1: poor garbage collector performance\n- * <br>&nbsp;&nbsp;\n- * #4245060 (P4\/S5) poor garbage collector performance\n- * <br>However, printing of the test's error messages, warnings, and of\n- * execution trace may fail even so. If the test fails due to poor GC\n- * performance, exit status 96 is returned instead of 97.\n- * <p>\n- * <p>Also note, that the test needs a lot of memory to start up, so it should\n- * not run under older JDK 1.1.x release due to its poor heap utilization.\n- *\/\n-public class except007 {\n-    \/**\n-     * Either allow or supress printing of execution trace.\n-     *\/\n-    private static boolean TRACE_ON = false;\n-    \/**\n-     * Either allow or supress printing of warning messages.\n-     *\/\n-    private static final boolean WARN_ON = true;\n-    \/*\n-     * Storage for a lot of tiny objects\n-     * \"static volatile\" keywords are for preventing heap optimization\n-     *\/\n-    private static volatile Object pool[] = null;\n-    \/**\n-     * Temporary <code>log<\/code> for error messages, warnings and\/or execution trace.\n-     *\n-     * @see #messages\n-     *\/\n-    private static String log[] = new String[1000]; \/\/ up to 1000 messages\n-    \/**\n-     * How many <code>messages<\/code> were submitted to the <code>log<\/code>.\n-     *\n-     * @see #log\n-     *\/\n-    private static int messages = 0;\n-\n-    \/**\n-     * Re-call to the method <code>run(out)<\/code> (ignore <code>args[]<\/code>),\n-     * and print the test summary - either test passed of failed.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            if (args[0].toLowerCase().startsWith(\"-v\"))\n-                TRACE_ON = true;\n-        }\n-\n-        int exitCode = run(out);\n-        pool = null;\n-        System.gc();\n-        \/\/ Print the log[] and the test summary:\n-        try {\n-            for (int i = 0; i < messages; i++)\n-                out.println(log[i]);\n-            if (exitCode == 0) {\n-                if (TRACE_ON)\n-                    out.println(\"Test passed.\");\n-            } else\n-                out.println(\"Test failed.\");\n-        } catch (OutOfMemoryError oome) {\n-            \/\/ Poor performance of garbage collector:\n-            exitCode = 1;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Allocate as much <code>Object<\/code> instances as possible to bring JVM\n-     * into stress, and then check if exceptions are correctly thrown accordingly\n-     * to various situations like integer division by 0, etc.\n-     *\/\n-    private static int run(PrintStream out) {\n-        out.println(\"# While printing this message, JVM seems to initiate the output\");\n-        out.println(\"# stream, so that it will not need more memory to print later,\");\n-        out.println(\"# when the heap would fail to provide more memory.\");\n-        out.println(\"# \");\n-        out.println(\"# Note, that the test maintains especial static log[] field in\");\n-        out.println(\"# order to avoid printing when the heap seems exhausted.\");\n-        out.println(\"# Nevertheless, printing could arise OutOfMemoryError even\");\n-        out.println(\"# after all the memory allocated by the test is released.\");\n-        out.println(\"# \");\n-        out.println(\"# That problem is caused by the known JDK\/HotSpot bugs:\");\n-        out.println(\"#     4239841 (P1\/S5) 1.1: poor garbage collector performance\");\n-        out.println(\"#     4245060 (P4\/S5) poor garbage collector performance\");\n-        out.println(\"# \");\n-        out.println(\"# This message is just intended to work-around that problem.\");\n-        out.println(\"# If printing should fail even so, the test will try to return\");\n-        out.println(\"# the exit status 96 instead of 97 to indicate the problem.\");\n-        out.println(\"# However, the test may fail or even crash on some platforms\");\n-        out.println(\"# suffering the bug 4239841 or 4245060.\");\n-\n-        \/\/ Prepare some items, which will be used by the test:\n-        Thread rabbit = new Rabbit();\n-\n-        \/\/ Allocate repository for a lots of tiny objects:\n-        for (int size = 1 << 30; size > 0 && pool == null; size >>= 1)\n-            try {\n-                pool = new Object[size];\n-            } catch (OutOfMemoryError oome) {\n-            }\n-        if (pool == null)\n-            throw new Error(\"HS bug: cannot allocate new Object[1]\");\n-        int poolSize = pool.length;\n-\n-        int index = 0;\n-        pool[index++] = new Object();\n-\n-        \/\/ Sum up time spent, when it was hard to JVM to allocate next object\n-        \/\/ (i.e.: when JVM has spent more than 1 second to allocate new object):\n-        double totalDelay = 0;\n-        long timeMark = System.currentTimeMillis();\n-        try {\n-            for (; index < poolSize; index++) {\n-                \/\/-------------------------\n-                pool[index] = new Object();\n-                long nextTimeMark = System.currentTimeMillis();\n-                long elapsed = nextTimeMark - timeMark;\n-                timeMark = nextTimeMark;\n-                \/\/----------------------\n-                if (elapsed > 1000) {\n-                    double seconds = elapsed \/ 1000.0;\n-                    if (TRACE_ON)\n-                        out.println(\n-                                \"pool[\" + index + \"]=new Object(); \/\/ elapsed \" + seconds + \"s\");\n-                    totalDelay += seconds;\n-                    if (totalDelay > 60) {\n-                        if (TRACE_ON)\n-                            out.println(\n-                                    \"Memory allocation became slow; so, heap seems exhausted.\");\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (OutOfMemoryError oome) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Heap seems exhausted - OutOfMemoryError thrown.\";\n-        }\n-        if (index > poolSize - 1000) {\n-            if (WARN_ON)\n-                log[messages++] = \"Warning: pool[] is full; so, checks would not be enough hard...\";\n-        }\n-\n-        \/\/ Sum up exit code:\n-        int exitCode = 0; \/\/ apparently PASSED\n-        int skipped = 0;  \/\/ some checks may correctly suffer OutOfMemoryError\n-\n-        \/\/ Check InterruptedException:\n-        try {\n-            synchronized (rabbit) {\n-                rabbit.start();\n-                rabbit.wait();\n-            }\n-            rabbit.interrupt();\n-            while (rabbit.isAlive())\n-                rabbit.join();\n-            Throwable exception = ((Rabbit) rabbit).exception;\n-            if (exception == null) {\n-                log[messages++] = \"Failure: InterruptedException not thrown\";\n-                exitCode = 2;\n-            } else {\n-                if (exception instanceof InterruptedException) {\n-                    if (TRACE_ON)\n-                        log[messages++] =\n-                                \"Success: InterruptedException thrown as expected\";\n-                } else if (exception instanceof OutOfMemoryError) {\n-                    if (WARN_ON)\n-                        log[messages++] = \"Skipped: InterruptedException\";\n-                    skipped++;\n-                } else {\n-                    log[messages++] =\n-                            \"Failure: InterruptedException: unexpected exception thrown\";\n-                    exitCode = 2;\n-                }\n-                pool[index++] = exception;\n-            }\n-        } catch (InterruptedException ie) {\n-            log[messages++] = \"Failure: InterruptedException thrown unexpectedly\";\n-            exitCode = 2;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: InterruptedException\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check NegativeArraySizeException:\n-        try {\n-            int negative = -1;\n-            byte array[] = new byte[negative];\n-            log[messages++] = \"Failure: NegativeArraySizeException not thrown as expected\";\n-            exitCode = 2;\n-        } catch (NegativeArraySizeException ie) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: NegativeArraySizeException thrown as expected\";\n-            pool[index++] = ie;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: NegativeArraySizeException\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check NullPointerException:\n-        try {\n-            Double none = null;\n-            double oops = none.doubleValue();\n-            log[messages++] = \"Failure: NullPointerException not thrown as expected\";\n-            exitCode = 2;\n-        } catch (NullPointerException npe) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: NullPointerException thrown as expected\";\n-            pool[index++] = npe;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: NullPointerException\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check NumberFormatException:\n-        try {\n-            double oops = Double.parseDouble(\"3.14159D00\"); \/\/ FORTRAN-like\n-            log[messages++] = \"Failure: NumberFormatException not thrown as expected\";\n-            exitCode = 2;\n-        } catch (NumberFormatException nfe) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: NumberFormatException thrown as expected\";\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] = \"Skipped: NumberFormatException\";\n-            skipped++;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Will shoot a rabbit when it waits -- in order to provoke\n-     * InterruptedException.\n-     *\/\n-    private static class Rabbit extends Thread {\n-        Throwable exception = null;\n-\n-        public void run() {\n-            try {\n-                synchronized (this) {\n-                    this.notify();\n-                    this.wait();\n-                }\n-            } catch (InterruptedException ie) {\n-                exception = ie;\n-            } catch (OutOfMemoryError oome) {\n-                exception = oome;\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * Re-call to <code>run(args,out)<\/code>, and return JCK-like exit status.\n-     * (The stream <code>out<\/code> is assigned to <code>System.out<\/code> here.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-            \/\/ Last try. If there is some exception outside the code, test should end correctly\n-            @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n-                try {\n-                    pool = null;\n-                    log = null;\n-                    System.gc();\n-                    if (e instanceof OutOfMemoryError) {\n-                        try {\n-                            System.out.println(\"OOME : Test Skipped\");\n-                            System.exit(0);\n-                        } catch (Throwable ignore) {\n-                        } \/\/ No code in the handler can provoke correct exceptions.\n-                    } else {\n-                        e.printStackTrace();\n-                        throw (RuntimeException) e;\n-                    }\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            }\n-        });\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/except007.java","additions":0,"deletions":380,"binary":false,"changes":380,"status":"deleted"},{"patch":"@@ -1,363 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/except\/except008.\n- * VM testbase keywords: [stress, diehard, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This checks if various exceptions are thrown (and caught) correctly\n- *     when there apparently are no free space in the heap to allocate new\n- *     Throwable instance.\n- *     The test tries to occupy all of memory available in the heap by allocating\n- *     lots of new Object() instances. Instances of the type Object are the smallest\n- *     objects, so they apparently should occupy most fine-grained fragments in the\n- *     heap and leave no free space for new Throwable instance. After that, the test\n- *     provokes various exceptions (e.g.: by executing integer division by 0 and so\n- *     on), and checks if appropriate exceptions are thrown.\n- * COMMENTS\n- *     The test needs a lot of memory to start up, so it should not run under older\n- *     JDK 1.1.x release due to its poorer heap utilization. Also, some checks are\n- *     skipped when testing classic VM, because OutOfMemoryError is correctly thrown\n- *     instead of target exception.\n- *     When the test is being self-initiating (i.e.: eating heap), memory occupation\n- *     is terminated if memory allocation slows down crucially. This is a workaround\n- *     intended to avoid the HotSpot bug:\n- *         #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- *     There is also a workaround involved to avoid the following bugs known\n- *     for HotSpot and for classic VM:\n- *         #4239841 (P1\/S5) 1.1: poor garbage collector performance  (HotSpot bug)\n- *         #4245060 (P4\/S5) poor garbage collector performance       (Classic VM bug)\n- *     However, printing of the test's error messages, warnings, and of execution\n- *     trace fails under JDK 1.2 for Win32 even so. If the test fails due to this\n- *     problem, exit status 96 is returned instead of 97.\n- *     JDK 1.3 classic VM for Sparc may crash (core dump) due to the known bug:\n- *         #4245057 (P2\/S3) VM crashes when heap is exhausted\n- *\n- * @run main\/othervm -Xms50M -Xmx200M -XX:-UseGCOverheadLimit nsk.stress.except.except008\n- *\/\n-\n-package nsk.stress.except;\n-\n-import java.io.PrintStream;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-\n-\/**\n- * This checks if various exceptions are thrown (and caught) correctly\n- * when there apparently are no free space in the heap to allocate new\n- * <code>Throwable<\/code> instance.\n- * <p>\n- * <p>The test tries to occupy all of memory available in the heap by\n- * allocating lots of new <code>Object()<\/code> instances. Instances of the\n- * type <code>Object<\/code> are the smallest objects, so they apparently should\n- * occupy most fine-grained fragments in the heap and leave no free space for\n- * new <code>Throwable<\/code> instance. After that, the test provokes various\n- * exceptions (e.g.: by executing integer division by 0 and so on), and checks\n- * if appropriate exceptions are thrown.\n- * <p>\n- * <p>Note, that memory occupation is terminated if memory allocation slows\n- * down crucially. This is a workaround intended to avoid the HotSpot bug:\n- * <br>&nbsp;&nbsp;\n- * #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- * <p>\n- * <p>There is also a workaround involved to avoid the following bugs known\n- * for HotSpot and for classic VM:\n- * <br>&nbsp;&nbsp;\n- * #4239841 (P1\/S5) 1.1: poor garbage collector performance\n- * <br>&nbsp;&nbsp;\n- * #4245060 (P4\/S5) poor garbage collector performance\n- * <br>However, printing of the test's error messages, warnings, and of\n- * execution trace may fail even so. If the test fails due to poor GC\n- * performance, exit status 96 is returned instead of 97.\n- * <p>\n- * <p>Also note, that the test needs a lot of memory to start up, so it should\n- * not run under older JDK 1.1.x release due to its poor heap utilization.\n- *\/\n-public class except008 {\n-    \/**\n-     * Either allow or supress printing of execution trace.\n-     *\/\n-    private static boolean TRACE_ON = false;\n-    \/**\n-     * Either allow or supress printing of warning messages.\n-     *\/\n-    private static final boolean WARN_ON = true;\n-    \/*\n-     * Storage for a lot of tiny objects\n-     * \"static volatile\" keywords are for preventing heap optimization\n-     *\/\n-    private static volatile Object pool[] = null;\n-    \/**\n-     * Temporary <code>log<\/code> for error messages, warnings and\/or execution trace.\n-     *\n-     * @see #messages\n-     *\/\n-    private static String log[] = new String[1000]; \/\/ up to 1000 messages\n-    \/**\n-     * How many <code>messages<\/code> were submitted to the <code>log<\/code>.\n-     *\n-     * @see #log\n-     *\/\n-    private static int messages = 0;\n-\n-    \/**\n-     * Re-call to the method <code>run(out)<\/code> (ignore <code>args[]<\/code>),\n-     * and print the test summary - either test passed of failed.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            if (args[0].toLowerCase().startsWith(\"-v\"))\n-                TRACE_ON = true;\n-        }\n-\n-        int exitCode = run(out);\n-        pool = null;\n-        System.gc();\n-        \/\/ Print the log[] and the test summary:\n-        try {\n-            for (int i = 0; i < messages; i++)\n-                out.println(log[i]);\n-            if (exitCode == 0) {\n-                if (TRACE_ON)\n-                    out.println(\"Test passed.\");\n-            } else\n-                out.println(\"Test failed.\");\n-        } catch (OutOfMemoryError oome) {\n-            \/\/ Poor performance of garbage collector:\n-            exitCode = 1;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Allocate as much <code>Object<\/code> instances as possible to bring JVM\n-     * into stress, and then check if exceptions are correctly thrown accordingly\n-     * to various situations like integer division by 0, etc.\n-     *\/\n-    private static int run(PrintStream out) {\n-        out.println(\"# While printing this message, JVM seems to initiate the output\");\n-        out.println(\"# stream, so that it will not need more memory to print later,\");\n-        out.println(\"# when the heap would fail to provide more memory.\");\n-        out.println(\"# \");\n-        out.println(\"# Note, that the test maintains especial static log[] field in\");\n-        out.println(\"# order to avoid printing when the heap seems exhausted.\");\n-        out.println(\"# Nevertheless, printing could arise OutOfMemoryError even\");\n-        out.println(\"# after all the memory allocated by the test is released.\");\n-        out.println(\"# \");\n-        out.println(\"# That problem is caused by the known JDK\/HotSpot bugs:\");\n-        out.println(\"#     4239841 (P1\/S5) 1.1: poor garbage collector performance\");\n-        out.println(\"#     4245060 (P4\/S5) poor garbage collector performance\");\n-        out.println(\"# \");\n-        out.println(\"# This message is just intended to work-around that problem.\");\n-        out.println(\"# If printing should fail even so, the test will try to return\");\n-        out.println(\"# the exit status 96 instead of 97 to indicate the problem.\");\n-        out.println(\"# However, the test may fail or even crash on some platforms\");\n-        out.println(\"# suffering the bug 4239841 or 4245060.\");\n-\n-        \/\/ Prepare some items, which will be used by the test:\n-        Zoo zoo = new Zoo(); \/\/ load the class Zoo\n-        Class noArgs[] = new Class[0];\n-\n-        \/\/ Sum up exit code:\n-        int exitCode = 0; \/\/ apparently PASSED\n-        int skipped = 0;  \/\/ some checks may correctly suffer OutOfMemoryError\n-\n-        \/\/ Allocate repository for a lots of tiny objects:\n-        for (int size = 1 << 30; size > 0 && pool == null; size >>= 1)\n-            try {\n-                pool = new Object[size];\n-            } catch (OutOfMemoryError oome) {\n-            }\n-        if (pool == null)\n-            throw new Error(\"HS bug: cannot allocate new Object[1]\");\n-        int poolSize = pool.length;\n-\n-        int index = 0;\n-        pool[index++] = new Object();\n-\n-        \/\/ Sum up time spent, when it was hard to JVM to allocate next object\n-        \/\/ (i.e.: when JVM has spent more than 1 second to allocate new object):\n-        double totalDelay = 0;\n-        long timeMark = System.currentTimeMillis();\n-        try {\n-            for (; index < poolSize; index++) {\n-                \/\/-------------------------\n-                pool[index] = new Object();\n-                long nextTimeMark = System.currentTimeMillis();\n-                long elapsed = nextTimeMark - timeMark;\n-                timeMark = nextTimeMark;\n-                \/\/----------------------\n-                if (elapsed > 1000) {\n-                    double seconds = elapsed \/ 1000.0;\n-                    if (TRACE_ON)\n-                        out.println(\n-                                \"pool[\" + index + \"]=new Object(); \/\/ elapsed \" + seconds + \"s\");\n-                    totalDelay += seconds;\n-                    if (totalDelay > 60) {\n-                        if (TRACE_ON)\n-                            out.println(\n-                                    \"Memory allocation became slow; so, heap seems exhausted.\");\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (OutOfMemoryError oome) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Heap seems exhausted - OutOfMemoryError thrown.\";\n-        }\n-\n-        if (index > poolSize - 1000) {\n-            if (WARN_ON)\n-                log[messages++] = \"Warning: pool[] is full; so, checks would not be enough hard...\";\n-        }\n-\n-        \/\/ Check NoSuchFieldException (positive):\n-        try {\n-            Field valid = Zoo.class.getField(\"PUBLIC_FIELD\");  \/\/ should pass\n-\/\/          Field wrong = Zoo.class.getField(\"PRIVATE_FIELD\"); \/\/ should fail\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: NoSuchFieldException not thrown as expected\";\n-        } catch (NoSuchFieldException nsfe) {\n-            pool[index++] = nsfe;\n-            log[messages++] = \"Failure: NoSuchFieldException thrown unexpectedly\";\n-            exitCode = 2;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] =\n-                        \"Skipped: NoSuchFieldException positive check - OutOfMemoryError thrown\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check NoSuchFieldException (negative):\n-        try {\n-\/\/          Field valid = Zoo.class.getField(\"PUBLIC_FIELD\");  \/\/ should pass\n-            Field wrong = Zoo.class.getField(\"PRIVATE_FIELD\"); \/\/ should fail\n-            log[messages++] = \"Failure: NoSuchFieldException incorrectly not thrown\";\n-            exitCode = 2;\n-        } catch (NoSuchFieldException nsfe) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: NoSuchFieldException thrown as expected\";\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] =\n-                        \"NoSuchFieldException negative check - OutOfMemoryError thrown\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check NoSuchMethodException (positive):\n-        try {\n-            Method valid = Zoo.class.getMethod(\"PUBLIC_METHOD\", noArgs);  \/\/ should pass\n-\/\/          Method wrong = Zoo.class.getMethod(\"PRIVATE_METHOD\",noArgs); \/\/ should fail\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: NoSuchFieldException not thrown as expected\";\n-        } catch (NoSuchMethodException nsme) {\n-            pool[index++] = nsme;\n-            log[messages++] = \"Failure: NoSuchMethodException thrown unexpectedly\";\n-            exitCode = 2;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] =\n-                        \"Skipped: NoSuchMethodException positive check - OutOfMemoryError thrown\";\n-            pool[index++] = oome;\n-            skipped++;\n-        }\n-\n-        \/\/ Check NoSuchMethodException (negative):\n-        try {\n-\/\/          Method valid = Zoo.class.getMethod(\"PUBLIC_METHOD\",noArgs);  \/\/ should pass\n-            Method wrong = Zoo.class.getMethod(\"PRIVATE_METHOD\", noArgs); \/\/ should fail\n-            log[messages++] = \"Failure: NoSuchMethodException incorrectly not thrown\";\n-            exitCode = 2;\n-        } catch (NoSuchMethodException nsme) {\n-            pool[index++] = nsme;\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: NoSuchFieldException thrown as expected\";\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] =\n-                        \"Skipped: NoSuchMethodException negative check - OutOfMemoryError thrown\";\n-            skipped++;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Several items used to check reflections.\n-     *\/\n-    private static class Zoo {\n-        public String PUBLIC_FIELD = \"Accessible via reflection\";\n-        private String PRIVATE_FIELD = \"Inaccessible via reflection\";\n-\n-        public String PUBLIC_METHOD() {\n-            return \"Accessible via reflection\";\n-        }\n-\n-        private String PRIVATE_METHOD() {\n-            return \"Inaccessible via reflection\";\n-        }\n-\n-    }\n-\n-    \/**\n-     * Re-call to <code>run(args,out)<\/code>, and return JCK-like exit status.\n-     * (The stream <code>out<\/code> is assigned to <code>System.out<\/code> here.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-            \/\/ Last try. If there is some exception outside the code, test should end correctly\n-            @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n-                try {\n-                    pool = null;\n-                    log = null;\n-                    System.gc();\n-                    if (e instanceof OutOfMemoryError) {\n-                        try {\n-                            System.out.println(\"OOME : Test Skipped\");\n-                            System.exit(0);\n-                        } catch (Throwable ignore) {\n-                        } \/\/ No code in the handler can provoke correct exceptions.\n-                    } else {\n-                        e.printStackTrace();\n-                        throw (RuntimeException) e;\n-                    }\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            }\n-        });\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/except008.java","additions":0,"deletions":363,"binary":false,"changes":363,"status":"deleted"},{"patch":"@@ -1,288 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/except\/except009.\n- * VM testbase keywords: [stress, diehard, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This checks if various exceptions are thrown (and caught) correctly\n- *     when there apparently are no free space in the heap to allocate new\n- *     Throwable instance.\n- *     The test tries to occupy all of memory available in the heap by allocating\n- *     lots of new Object() instances. Instances of the type Object are the smallest\n- *     objects, so they apparently should occupy most fine-grained fragments in the\n- *     heap and leave no free space for new Throwable instance. After that, the test\n- *     provokes various exceptions (e.g.: by executing integer division by 0 and so\n- *     on), and checks if appropriate exceptions are thrown.\n- * COMMENTS\n- *     The test needs a lot of memory to start up, so it should not run under older\n- *     JDK 1.1.x release due to its poorer heap utilization. Also, some checks are\n- *     skipped when testing classic VM, because OutOfMemoryError is correctly thrown\n- *     instead of target exception.\n- *     When the test is being self-initiating (i.e.: eating heap), memory occupation\n- *     is terminated if memory allocation slows down crucially. This is a workaround\n- *     intended to avoid the HotSpot bug:\n- *         #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- *     There is also a workaround involved to avoid the following bugs known\n- *     for HotSpot and for classic VM:\n- *         #4239841 (P1\/S5) 1.1: poor garbage collector performance  (HotSpot bug)\n- *         #4245060 (P4\/S5) poor garbage collector performance       (Classic VM bug)\n- *     However, printing of the test's error messages, warnings, and of execution\n- *     trace fails under JDK 1.2 for Win32 even so. If the test fails due to this\n- *     problem, exit status 96 is returned instead of 97.\n- *     JDK 1.3 classic VM for Sparc may crash (core dump) due to the known bug:\n- *         #4245057 (P2\/S3) VM crashes when heap is exhausted\n- *\n- * @run main\/othervm -Xms50M -Xmx200M nsk.stress.except.except009\n- *\/\n-\n-package nsk.stress.except;\n-\n-import java.io.PrintStream;\n-\n-\/**\n- * This checks if various exceptions are thrown (and caught) correctly\n- * when there apparently are no free space in the heap to allocate new\n- * <code>Throwable<\/code> instance.\n- * <p>\n- * <p>The test tries to occupy all of memory available in the heap by\n- * allocating lots of new <code>Object()<\/code> instances. Instances of the\n- * type <code>Object<\/code> are the smallest objects, so they apparently should\n- * occupy most fine-grained fragments in the heap and leave no free space for\n- * new <code>Throwable<\/code> instance. After that, the test provokes various\n- * exceptions (e.g.: by executing integer division by 0 and so on), and checks\n- * if appropriate exceptions are thrown.\n- * <p>\n- * <p>Note, that memory occupation is terminated if memory allocation slows\n- * down crucially. This is a workaround intended to avoid the HotSpot bug:\n- * <br>&nbsp;&nbsp;\n- * #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- * <p>\n- * <p>There is also a workaround involved to avoid the following bugs known\n- * for HotSpot and for classic VM:\n- * <br>&nbsp;&nbsp;\n- * #4239841 (P1\/S5) 1.1: poor garbage collector performance\n- * <br>&nbsp;&nbsp;\n- * #4245060 (P4\/S5) poor garbage collector performance\n- * <br>However, printing of the test's error messages, warnings, and of\n- * execution trace may fail even so. If the test fails due to poor GC\n- * performance, exit status 96 is returned instead of 97.\n- * <p>\n- * <p>Also note, that the test needs a lot of memory to start up, so it should\n- * not run under older JDK 1.1.x release due to its poor heap utilization.\n- *\/\n-public class except009 {\n-    \/**\n-     * Either allow or supress printing of execution trace.\n-     *\/\n-    private static boolean TRACE_ON = false;\n-    \/**\n-     * Either allow or supress printing of warning messages.\n-     *\/\n-    private static final boolean WARN_ON = true;\n-    \/*\n-     * Storage for a lot of tiny objects\n-     * \"static volatile\" keywords are for preventing heap optimization\n-     *\/\n-    private static volatile Object pool[] = null;\n-    \/**\n-     * Temporary <code>log<\/code> for error messages, warnings and\/or execution trace.\n-     *\n-     * @see #messages\n-     *\/\n-    private static String log[] = new String[1000]; \/\/ up to 1000 messages\n-    \/**\n-     * How many <code>messages<\/code> were submitted to the <code>log<\/code>.\n-     *\n-     * @see #log\n-     *\/\n-    private static int messages = 0;\n-\n-    \/**\n-     * Re-call to the method <code>run(out)<\/code> (ignore <code>args[]<\/code>),\n-     * and print the test summary - either test passed of failed.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            if (args[0].toLowerCase().startsWith(\"-v\"))\n-                TRACE_ON = true;\n-        }\n-\n-        int exitCode = run(out);\n-        pool = null;\n-        System.gc();\n-        \/\/ Print the log[] and the test summary:\n-        try {\n-            for (int i = 0; i < messages; i++)\n-                out.println(log[i]);\n-            if (exitCode == 0) {\n-                if (TRACE_ON)\n-                    out.println(\"Test passed.\");\n-            } else\n-                out.println(\"Test failed.\");\n-        } catch (OutOfMemoryError oome) {\n-            \/\/ Poor performance of garbage collector:\n-            exitCode = 1;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Allocate as much <code>Object<\/code> instances as possible to bring JVM\n-     * into stress, and then check if exceptions are correctly thrown accordingly\n-     * to various situations like integer division by 0, etc.\n-     *\/\n-    private static int run(PrintStream out) {\n-        out.println(\"# While printing this message, JVM seems to initiate the output\");\n-        out.println(\"# stream, so that it will not need more memory to print later,\");\n-        out.println(\"# when the heap would fail to provide more memory.\");\n-        out.println(\"# \");\n-        out.println(\"# Note, that the test maintains especial static log[] field in\");\n-        out.println(\"# order to avoid printing when the heap seems exhausted.\");\n-        out.println(\"# Nevertheless, printing could arise OutOfMemoryError even\");\n-        out.println(\"# after all the memory allocated by the test is released.\");\n-        out.println(\"# \");\n-        out.println(\"# That problem is caused by the known JDK\/HotSpot bugs:\");\n-        out.println(\"#     4239841 (P1\/S5) 1.1: poor garbage collector performance\");\n-        out.println(\"#     4245060 (P4\/S5) poor garbage collector performance\");\n-        out.println(\"# \");\n-        out.println(\"# This message is just intended to work-around that problem.\");\n-        out.println(\"# If printing should fail even so, the test will try to return\");\n-        out.println(\"# the exit status 96 instead of 97 to indicate the problem.\");\n-        out.println(\"# However, the test may fail or even crash on some platforms\");\n-        out.println(\"# suffering the bug 4239841 or 4245060.\");\n-\n-        \/\/ Sum up exit code:\n-        int exitCode = 0; \/\/ apparently PASSED\n-        int skipped = 0;  \/\/ some checks may correctly suffer OutOfMemoryError\n-        String s = \"qwerty\";\n-        char c;\n-        \/\/ Allocate repository for a lots of tiny objects:\n-        for (int size = 1 << 30; size > 0 && pool == null; size >>= 1)\n-            try {\n-                pool = new Object[size];\n-            } catch (OutOfMemoryError oome) {\n-            }\n-        if (pool == null)\n-            throw new Error(\"HS bug: cannot allocate new Object[1]\");\n-        int poolSize = pool.length;\n-\n-        int index = 0;\n-        pool[index++] = new Object();\n-\n-        \/\/ Sum up time spent, when it was hard to JVM to allocate next object\n-        \/\/ (i.e.: when JVM has spent more than 1 second to allocate new object):\n-        double totalDelay = 0;\n-        long timeMark = System.currentTimeMillis();\n-        try {\n-            for (; index < poolSize; index++) {\n-                \/\/-------------------------\n-                pool[index] = new Object();\n-                long nextTimeMark = System.currentTimeMillis();\n-                long elapsed = nextTimeMark - timeMark;\n-                timeMark = nextTimeMark;\n-                \/\/----------------------\n-                if (elapsed > 1000) {\n-                    double seconds = elapsed \/ 1000.0;\n-                    if (TRACE_ON)\n-                        out.println(\n-                                \"pool[\" + index + \"]=new Object(); \/\/ elapsed \" + seconds + \"s\");\n-                    totalDelay += seconds;\n-                    if (totalDelay > 60) {\n-                        if (TRACE_ON)\n-                            out.println(\n-                                    \"Memory allocation became slow; so, heap seems exhausted.\");\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (OutOfMemoryError oome) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Heap seems exhausted - OutOfMemoryError thrown.\";\n-        }\n-\n-        if (index > poolSize - 1000) {\n-            if (WARN_ON)\n-                log[messages++] = \"Warning: pool[] is full; so, checks would not be enough hard...\";\n-        }\n-\n-        \/\/ Check StringIndexOutOfBoundsException:\n-        try {\n-            c = s.charAt(6); \/\/ should fail\n-            log[messages++] = \"Failure: StringIndexOutOfBoundsException incorrectly not thrown\";\n-            exitCode = 2;\n-        } catch (StringIndexOutOfBoundsException sioobe) {\n-            pool[index++] = sioobe;\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: StringIndexOutOfBoundsException thrown as expected\";\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] =\n-                        \"Skipped: StringIndexOutOfBoundsException: thrown OutOfMemoryError\";\n-            skipped++;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Re-call to <code>run(args,out)<\/code>, and return JCK-like exit status.\n-     * (The stream <code>out<\/code> is assigned to <code>System.out<\/code> here.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-            \/\/ Last try. If there is some exceprions outside the code, test should end correctly\n-            @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n-                try {\n-                    pool = null;\n-                    log = null;\n-                    System.gc();\n-                    if (e instanceof OutOfMemoryError) {\n-                        try {\n-                            System.out.println(\"OOME : Test Skipped\");\n-                            System.exit(0);\n-                        } catch (Throwable ignore) {\n-                        } \/\/ No code in the handler can provoke correct exceptions.\n-                    } else {\n-                        e.printStackTrace();\n-                        throw (RuntimeException) e;\n-                    }\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            }\n-        });\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/except009.java","additions":0,"deletions":288,"binary":false,"changes":288,"status":"deleted"},{"patch":"@@ -1,292 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/except\/except010.\n- * VM testbase keywords: [stress, diehard, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This checks if various exceptions are thrown (and caught) correctly\n- *     when there apparently are no free space in the heap to allocate new\n- *     Throwable instance.\n- *     The test tries to occupy all of memory available in the heap by allocating\n- *     lots of new Object() instances. Instances of the type Object are the smallest\n- *     objects, so they apparently should occupy most fine-grained fragments in the\n- *     heap and leave no free space for new Throwable instance. After that, the test\n- *     provokes various exceptions (e.g.: by executing integer division by 0 and so\n- *     on), and checks if appropriate exceptions are thrown.\n- * COMMENTS\n- *     The test needs a lot of memory to start up, so it should not run under older\n- *     JDK 1.1.x release due to its poorer heap utilization. Also, some checks are\n- *     skipped when testing classic VM, because OutOfMemoryError is correctly thrown\n- *     instead of target exception.\n- *     When the test is being self-initiating (i.e.: eating heap), memory occupation\n- *     is terminated if memory allocation slows down crucially. This is a workaround\n- *     intended to avoid the HotSpot bug:\n- *         #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- *     There is also a workaround involved to avoid the following bugs known\n- *     for HotSpot and for classic VM:\n- *         #4239841 (P1\/S5) 1.1: poor garbage collector performance  (HotSpot bug)\n- *         #4245060 (P4\/S5) poor garbage collector performance       (Classic VM bug)\n- *     However, printing of the test's error messages, warnings, and of execution\n- *     trace fails under JDK 1.2 for Win32 even so. If the test fails due to this\n- *     problem, exit status 96 is returned instead of 97.\n- *     JDK 1.3 classic VM for Sparc may crash (core dump) due to the known bug:\n- *         #4245057 (P2\/S3) VM crashes when heap is exhausted\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm -Xms50M -Xmx200M nsk.stress.except.except010\n- *\/\n-\n-package nsk.stress.except;\n-\n-import java.io.PrintStream;\n-\n-\/**\n- * This checks if various exceptions are thrown (and caught) correctly\n- * when there apparently are no free space in the heap to allocate new\n- * <code>Throwable<\/code> instance.\n- * <p>\n- * <p>The test tries to occupy all of memory available in the heap by\n- * allocating lots of new <code>Object()<\/code> instances. Instances of the\n- * type <code>Object<\/code> are the smallest objects, so they apparently should\n- * occupy most fine-grained fragments in the heap and leave no free space for\n- * new <code>Throwable<\/code> instance. After that, the test provokes various\n- * exceptions (e.g.: by executing integer division by 0 and so on), and checks\n- * if appropriate exceptions are thrown.\n- * <p>\n- * <p>Note, that memory occupation is terminated if memory allocation slows\n- * down crucially. This is a workaround intended to avoid the HotSpot bug:\n- * <br>&nbsp;&nbsp;\n- * #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- * <p>\n- * <p>There is also a workaround involved to avoid the following bugs known\n- * for HotSpot and for classic VM:\n- * <br>&nbsp;&nbsp;\n- * #4239841 (P1\/S5) 1.1: poor garbage collector performance\n- * <br>&nbsp;&nbsp;\n- * #4245060 (P4\/S5) poor garbage collector performance\n- * <br>However, printing of the test's error messages, warnings, and of\n- * execution trace may fail even so. If the test fails due to poor GC\n- * performance, exit status 96 is returned instead of 97.\n- * <p>\n- * <p>Also note, that the test needs a lot of memory to start up, so it should\n- * not run under older JDK 1.1.x release due to its poor heap utilization.\n- *\/\n-public class except010 {\n-    \/**\n-     * Either allow or supress printing of execution trace.\n-     *\/\n-    private static boolean TRACE_ON = false;\n-    \/**\n-     * Either allow or supress printing of warning messages.\n-     *\/\n-    private static final boolean WARN_ON = true;\n-    \/*\n-     * Storage for a lot of tiny objects\n-     * \"static volatile\" keywords are for preventing heap optimization\n-     *\/\n-    private static volatile Object pool[] = null;\n-    \/**\n-     * Temporary <code>log<\/code> for error messages, warnings and\/or execution trace.\n-     *\n-     * @see #messages\n-     *\/\n-    private static String log[] = new String[1000]; \/\/ up to 1000 messages\n-    \/**\n-     * How many <code>messages<\/code> were submitted to the <code>log<\/code>.\n-     *\n-     * @see #log\n-     *\/\n-    private static int messages = 0;\n-\n-    \/**\n-     * Re-call to the method <code>run(out)<\/code> (ignore <code>args[]<\/code>),\n-     * and print the test summary - either test passed of failed.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            if (args[0].toLowerCase().startsWith(\"-v\"))\n-                TRACE_ON = true;\n-        }\n-\n-        int exitCode = run(out);\n-        pool = null;\n-        System.gc();\n-        \/\/ Print the log[] and the test summary:\n-        try {\n-            for (int i = 0; i < messages; i++)\n-                out.println(log[i]);\n-            if (exitCode == 0) {\n-                if (TRACE_ON)\n-                    out.println(\"Test passed.\");\n-            } else\n-                out.println(\"Test failed.\");\n-        } catch (OutOfMemoryError oome) {\n-            \/\/ Poor performance of garbage collector:\n-            exitCode = 1;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Allocate as much <code>Object<\/code> instances as possible to bring JVM\n-     * into stress, and then check if exceptions are correctly thrown accordingly\n-     * to various situations like integer division by 0, etc.\n-     *\/\n-    private static int run(PrintStream out) {\n-        out.println(\"# While printing this message, JVM seems to initiate the output\");\n-        out.println(\"# stream, so that it will not need more memory to print later,\");\n-        out.println(\"# when the heap would fail to provide more memory.\");\n-        out.println(\"# \");\n-        out.println(\"# Note, that the test maintains especial static log[] field in\");\n-        out.println(\"# order to avoid printing when the heap seems exhausted.\");\n-        out.println(\"# Nevertheless, printing could arise OutOfMemoryError even\");\n-        out.println(\"# after all the memory allocated by the test is released.\");\n-        out.println(\"# \");\n-        out.println(\"# That problem is caused by the known JDK\/HotSpot bugs:\");\n-        out.println(\"#     4239841 (P1\/S5) 1.1: poor garbage collector performance\");\n-        out.println(\"#     4245060 (P4\/S5) poor garbage collector performance\");\n-        out.println(\"# \");\n-        out.println(\"# This message is just intended to work-around that problem.\");\n-        out.println(\"# If printing should fail even so, the test will try to return\");\n-        out.println(\"# the exit status 96 instead of 97 to indicate the problem.\");\n-        out.println(\"# However, the test may fail or even crash on some platforms\");\n-        out.println(\"# suffering the bug 4239841 or 4245060.\");\n-\n-        \/\/ Sum up exit code:\n-        int exitCode = 0; \/\/ apparently PASSED\n-        int skipped = 0;  \/\/ some checks may correctly suffer OutOfMemoryError\n-\n-        \/\/ Allocate repository for a lots of tiny objects:\n-        for (int size = 1 << 30; size > 0 && pool == null; size >>= 1)\n-            try {\n-                pool = new Object[size];\n-            } catch (OutOfMemoryError oome) {\n-            }\n-        if (pool == null)\n-            throw new Error(\"HS bug: cannot allocate new Object[1]\");\n-        int poolSize = pool.length;\n-\n-        int index = 0;\n-        pool[index++] = new Object();\n-\n-        \/\/ Sum up time spent, when it was hard to JVM to allocate next object\n-        \/\/ (i.e.: when JVM has spent more than 1 second to allocate new object):\n-        double totalDelay = 0;\n-        long timeMark = System.currentTimeMillis();\n-        try {\n-            for (; index < poolSize; index++) {\n-                \/\/-------------------------\n-                pool[index] = new Object();\n-                long nextTimeMark = System.currentTimeMillis();\n-                long elapsed = nextTimeMark - timeMark;\n-                timeMark = nextTimeMark;\n-                \/\/----------------------\n-                if (elapsed > 1000) {\n-                    double seconds = elapsed \/ 1000.0;\n-                    if (TRACE_ON)\n-                        out.println(\n-                                \"pool[\" + index + \"]=new Object(); \/\/ elapsed \" + seconds + \"s\");\n-                    totalDelay += seconds;\n-                    if (totalDelay > 60) {\n-                        if (TRACE_ON)\n-                            out.println(\n-                                    \"Memory allocation became slow; so, heap seems exhausted.\");\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (OutOfMemoryError oome) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Heap seems exhausted - OutOfMemoryError thrown.\";\n-        }\n-\n-        if (index > poolSize - 1000) {\n-            if (WARN_ON)\n-                log[messages++] = \"Warning: pool[] is full; so, checks would not be enough hard...\";\n-        }\n-\n-        \/\/ Check StackOverflowError:\n-        try {\n-            goIntoInfiniteRecursion();\n-            log[messages++] = \"Failure: StackOverflowError failed to throw\";\n-            exitCode = 2;\n-        } catch (StackOverflowError soe) {\n-            pool[index++] = soe;\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: StackOverflowError thrown as expected\";\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] =\n-                        \"Skipped: StackOverflowError: thrown OutOfMemoryError\";\n-            skipped++;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    private static void goIntoInfiniteRecursion() {\n-        goIntoInfiniteRecursion();\n-    }\n-\n-    \/**\n-     * Re-call to <code>run(args,out)<\/code>, and return JCK-like exit status.\n-     * (The stream <code>out<\/code> is assigned to <code>System.out<\/code> here.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-            \/\/ Last try. If there is some exceptions outside the code, test should end correctly\n-            @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n-                try {\n-                    pool = null;\n-                    log = null;\n-                    System.gc();\n-                    if (e instanceof OutOfMemoryError) {\n-                        try {\n-                            System.out.println(\"OOME : Test Skipped\");\n-                            System.exit(0);\n-                        } catch (Throwable ignore) {\n-                        } \/\/ No code in the handler can provoke correct exceptions.\n-                    } else {\n-                        e.printStackTrace();\n-                        throw (RuntimeException) e;\n-                    }\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            }\n-        });\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/except010.java","additions":0,"deletions":292,"binary":false,"changes":292,"status":"deleted"},{"patch":"@@ -1,366 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/except\/except012.\n- * VM testbase keywords: [stress, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This checks if various exceptions are thrown (and caught) correctly\n- *     when there apparently are no free space in the heap to allocate new\n- *     Throwable instance.\n- *     The test tries to occupy all of memory available in the heap by allocating\n- *     lots of new Object() instances. Instances of the type Object are the smallest\n- *     objects, so they apparently should occupy most fine-grained fragments in the\n- *     heap and leave no free space for new Throwable instance. After that, the test\n- *     provokes various exceptions (e.g.: by executing integer division by 0 and so\n- *     on), and checks if appropriate exceptions are thrown.\n- * COMMENTS\n- *     The test needs a lot of memory to start up, so it should not run under older\n- *     JDK 1.1.x release due to its poorer heap utilization. Also, some checks are\n- *     skipped when testing classic VM, because OutOfMemoryError is correctly thrown\n- *     instead of target exception.\n- *     When the test is being self-initiating (i.e.: eating heap), memory occupation\n- *     is terminated if memory allocation slows down crucially. This is a workaround\n- *     intended to avoid the HotSpot bug:\n- *         #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- *     There is also a workaround involved to avoid the following bugs known\n- *     for HotSpot and for classic VM:\n- *         #4239841 (P1\/S5) 1.1: poor garbage collector performance  (HotSpot bug)\n- *         #4245060 (P4\/S5) poor garbage collector performance       (Classic VM bug)\n- *     However, printing of the test's error messages, warnings, and of execution\n- *     trace fails under JDK 1.2 for Win32 even so. If the test fails due to this\n- *     problem, exit status 96 is returned instead of 97.\n- *     JDK 1.3 classic VM for Sparc may crash (core dump) due to the known bug:\n- *         #4245057 (P2\/S3) VM crashes when heap is exhausted\n- *\n- * @run main\/othervm -Xms50M -Xmx200M nsk.stress.except.except012\n- *\/\n-\n-package nsk.stress.except;\n-\n-import java.io.PrintStream;\n-import java.util.Random;\n-\n-\/**\n- * This checks if various exceptions are thrown (and caught) correctly\n- * when there apparently are no free space in the heap to allocate new\n- * <code>Throwable<\/code> instance.\n- * <p>\n- * <p>The test tries to occupy all of memory available in the heap by\n- * allocating lots of new <code>Object()<\/code> instances. Instances of the\n- * type <code>Object<\/code> are the smallest objects, so they apparently should\n- * occupy most fine-grained fragments in the heap and leave no free space for\n- * new <code>Throwable<\/code> instance. After that, the test provokes various\n- * exceptions (e.g.: by executing integer division by 0 and so on), and checks\n- * if appropriate exceptions are thrown.\n- * <p>\n- * <p>Note, that memory occupation is terminated if memory allocation slows\n- * down crucially. This is a workaround intended to avoid the HotSpot bug:\n- * <br>&nbsp;&nbsp;\n- * #4248801 (P1\/S5) slow memory allocation when heap is almost exhausted\n- * <p>\n- * <p>There is also a workaround involved to avoid the following bugs known\n- * for HotSpot and for classic VM:\n- * <br>&nbsp;&nbsp;\n- * #4239841 (P1\/S5) 1.1: poor garbage collector performance\n- * <br>&nbsp;&nbsp;\n- * #4245060 (P4\/S5) poor garbage collector performance\n- * <br>However, printing of the test's error messages, warnings, and of\n- * execution trace may fail even so. If the test fails due to poor GC\n- * performance, exit status 96 is returned instead of 97.\n- * <p>\n- * <p>Also note, that the test needs a lot of memory to start up, so it should\n- * not run under older JDK 1.1.x release due to its poor heap utilization.\n- *\/\n-public class except012 {\n-    \/**\n-     * Either allow or supress printing of execution trace.\n-     *\/\n-    private static boolean TRACE_ON = false;\n-    \/**\n-     * Either allow or supress printing of warning messages.\n-     *\/\n-    private static final boolean WARN_ON = true;\n-\n-    \/**\n-     * Temporary <code>log<\/code> for error messages, warnings and\/or execution trace.\n-     *\n-     * @see #messages\n-     *\/\n-    private static String log[] = new String[1000]; \/\/ up to 1000 messages\n-    \/**\n-     * How many <code>messages<\/code> were submitted to the <code>log<\/code>.\n-     *\n-     * @see #log\n-     *\/\n-    private static int messages = 0;\n-    \/*\n-     * Storage for a lot of tiny objects\n-     * \"static volatile\" keywords are for preventing heap optimization\n-     *\/\n-    private static volatile Object pool[] = null;\n-\n-    \/**\n-     * Re-call to the method <code>run(out)<\/code> (ignore <code>args[]<\/code>),\n-     * and print the test summary - either test passed of failed.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        if (args.length > 0) {\n-            if (args[0].toLowerCase().startsWith(\"-v\"))\n-                TRACE_ON = true;\n-        }\n-\n-        int exitCode = run(out);\n-        pool = null;\n-        System.gc();\n-        \/\/ Print the log[] and the test summary:\n-        try {\n-            for (int i = 0; i < messages; i++)\n-                out.println(log[i]);\n-            if (exitCode == 0) {\n-                if (TRACE_ON)\n-                    out.println(\"Test passed.\");\n-            } else\n-                out.println(\"Test failed.\");\n-        } catch (OutOfMemoryError oome) {\n-            \/\/ Poor performance of garbage collector:\n-            exitCode = 1;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Allocate as much <code>Object<\/code> instances as possible to bring JVM\n-     * into stress, and then check if exceptions are correctly thrown accordingly\n-     * to various situations like integer division by 0, etc.\n-     *\/\n-    private static int run(PrintStream out) {\n-        out.println(\"# While printing this message, JVM seems to initiate the output\");\n-        out.println(\"# stream, so that it will not need more memory to print later,\");\n-        out.println(\"# when the heap would fail to provide more memory.\");\n-        out.println(\"# \");\n-        out.println(\"# Note, that the test maintains especial static log[] field in\");\n-        out.println(\"# order to avoid printing when the heap seems exhausted.\");\n-        out.println(\"# Nevertheless, printing could arise OutOfMemoryError even\");\n-        out.println(\"# after all the memory allocated by the test is released.\");\n-        out.println(\"# \");\n-        out.println(\"# That problem is caused by the known JDK\/HotSpot bugs:\");\n-        out.println(\"#     4239841 (P1\/S5) 1.1: poor garbage collector performance\");\n-        out.println(\"#     4245060 (P4\/S5) poor garbage collector performance\");\n-        out.println(\"# \");\n-        out.println(\"# This message is just intended to work-around that problem.\");\n-        out.println(\"# If printing should fail even so, the test will try to return\");\n-        out.println(\"# the exit status 96 instead of 97 to indicate the problem.\");\n-        out.println(\"# However, the test may fail or even crash on some platforms\");\n-        out.println(\"# suffering the bug 4239841 or 4245060.\");\n-\n-        \/\/ Allocate items necessary for the test:\n-        CrazyClassLoader crazyClassLoader = new CrazyClassLoader();\n-        MustDie threadToDie = new MustDie();\n-\n-        \/\/ Sum up exit code:\n-        int exitCode = 0; \/\/ apparently PASSED\n-        int skipped = 0;  \/\/ some checks may correctly suffer OutOfMemoryError\n-        \/\/ Allocate repository for a lots of tiny objects:\n-        for (int size = 1 << 30; size > 0 && pool == null; size >>= 1)\n-            try {\n-                pool = new Object[size];\n-            } catch (OutOfMemoryError oome) {\n-            }\n-        if (pool == null)\n-            throw new Error(\"HS bug: cannot allocate new Object[1]\");\n-        int poolSize = pool.length;\n-\n-        int index = 0;\n-        pool[index++] = new Object();\n-\n-        \/\/ Sum up time spent, when it was hard to JVM to allocate next object\n-        \/\/ (i.e.: when JVM has spent more than 1 second to allocate new object):\n-        double totalDelay = 0;\n-        long timeMark = System.currentTimeMillis();\n-        try {\n-            for (; index < poolSize; index++) {\n-                \/\/-------------------------\n-                pool[index] = new Object();\n-                long nextTimeMark = System.currentTimeMillis();\n-                long elapsed = nextTimeMark - timeMark;\n-                timeMark = nextTimeMark;\n-                \/\/----------------------\n-                if (elapsed > 1000) {\n-                    double seconds = elapsed \/ 1000.0;\n-                    if (TRACE_ON)\n-                        out.println(\n-                                \"pool[\" + index + \"]=new Object(); \/\/ elapsed \" + seconds + \"s\");\n-                    totalDelay += seconds;\n-                    if (totalDelay > 60) {\n-                        if (TRACE_ON)\n-                            out.println(\n-                                    \"Memory allocation became slow; so, heap seems exhausted.\");\n-                        break;\n-                    }\n-                }\n-            }\n-        } catch (OutOfMemoryError oome) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Heap seems exhausted - OutOfMemoryError thrown.\";\n-        }\n-\n-        if (index > poolSize - 1000) {\n-            if (WARN_ON)\n-                log[messages++] = \"Warning: pool[] is full; so, checks would not be enough hard...\";\n-        }\n-\n-        \/\/ Check ClassFormatError:\n-        try {\n-            Class oops = crazyClassLoader.loadClass(\"name doesn't matter\");\n-            log[messages++] = \"Failure: ClassFormatError failed to throw\";\n-            exitCode = 2;\n-        } catch (ClassFormatError cfe) {\n-            if (TRACE_ON)\n-                log[messages++] = \"Success: ClassFormatError thrown as expected\";\n-        } catch (ClassNotFoundException cnfe) {\n-            log[messages++] =\n-                    \"Failure: ClassFormatError: unexpectedly thrown ClassNotFoundException\";\n-            exitCode = 2;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] =\n-                        \"Skipped: ClassFormatError: thrown OutOfMemoryError\";\n-            skipped++;\n-        }\n-\n-        \/\/ Check ThreadDeath:\n-        try {\n-            threadToDie.start();\n-            while (threadToDie.isAlive())\n-                threadToDie.join();\n-            Throwable exception = threadToDie.exception;\n-            if (exception == null) {\n-                log[messages++] = \"Failure: ThreadDeath failed to throw\";\n-                exitCode = 2;\n-            } else if (exception instanceof OutOfMemoryError) {\n-                if (WARN_ON)\n-                    log[messages++] =\n-                            \"Skipped: ThreadDeath: thrown OutOfMemoryError instead\";\n-            } else if (!(exception instanceof ThreadDeath)) {\n-                log[messages++] =\n-                        \"Failure: ThreadDeath: unexpected exception thrown\";\n-                exitCode = 2;\n-            } else if (TRACE_ON)\n-                log[messages++] = \"Success: ThreadDeath thrown as expected\";\n-        } catch (InterruptedException ie) {\n-            pool[index++] = ie;\n-            log[messages++] =\n-                    \"Failure: ThreadDeath: thrown InterruptedException instead\";\n-            exitCode = 2;\n-        } catch (OutOfMemoryError oome) {\n-            if (WARN_ON)\n-                log[messages++] =\n-                        \"Skipped: ThreadDeath: thrown OutOfMemoryError\";\n-            skipped++;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * This class loader provokes <code>ClassFormatError<\/code>.\n-     *\/\n-    private static class CrazyClassLoader extends ClassLoader {\n-        public Class loadClass(String name) throws ClassNotFoundException {\n-            Class crazyClass = defineClass(null, crazyBytecode, 0, crazyBytecode.length);\n-            return crazyClass; \/\/ return is unreacable, due to ClassFormatError\n-        }\n-\n-        private static byte crazyBytecode[];\n-\n-        static {\n-            crazyBytecode = new byte[1000];\n-            Random random = new Random(42);\n-            for (int i = 0; i < crazyBytecode.length; i++)\n-                crazyBytecode[i] = (byte) random.nextInt(256);\n-        }\n-\n-    }\n-\n-    \/**\n-     * This thread should die in order to check <code>ThreadDeath<\/code> error.\n-     *\/\n-    private static class MustDie extends Thread {\n-        Throwable exception = null;\n-\n-        public void run() {\n-            try {\n-                stop();\n-            } catch (Throwable throwable) {\n-                exception = throwable;\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * Re-call to <code>run(args,out)<\/code>, and return JCK-like exit status.\n-     * (The stream <code>out<\/code> is assigned to <code>System.out<\/code> here.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        Thread.currentThread().setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\n-            \/\/ Last try. If there is some OOME, test should end correctly\n-            @Override\n-            public void uncaughtException(Thread t, Throwable e) {\n-                try {\n-                    pool = null;\n-                    System.gc(); \/\/ Empty memory to be able to write to the output\n-                    if (e instanceof OutOfMemoryError) {\n-                        try {\n-                            System.out.println(\"OOME : Test Skipped\");\n-                            System.exit(0);\n-                        } catch (Throwable ignore) {\n-                        } \/\/ any of the test exceptions are handled in test.#\n-                        \/\/ No code in the handler can provoke correct exceptions.\n-                    } else if (e instanceof ThreadDeath) {\n-                    } \/\/ignore since it thrown as expected\n-                    else {\n-                        e.printStackTrace();\n-                        throw (RuntimeException) e;\n-                    }\n-                } catch (OutOfMemoryError oome) {\n-                }\n-            }\n-        });\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/except\/except012.java","additions":0,"deletions":366,"binary":false,"changes":366,"status":"deleted"}]}