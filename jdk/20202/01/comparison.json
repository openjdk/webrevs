{"files":[{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/vmError.hpp\"\n@@ -704,5 +705,4 @@\n-  \/\/ Sort\n-  JVMFlag** array = NEW_C_HEAP_ARRAY_RETURN_NULL(JVMFlag*, length, mtArguments);\n-  if (array != nullptr) {\n-    for (size_t i = 0; i < length; i++) {\n-      array[i] = &flagTable[i];\n+  \/\/ Print flags without allocating memory. Start by marking all flags clear.\n+  for (size_t i = 0; i < length; i++) {\n+    if (flagTable[i].is_unlocked() && !(skipDefaults && flagTable[i].is_default())) {\n+      flagTable[i].clear_iterated();\n@@ -710,2 +710,4 @@\n-    qsort(array, length, sizeof(JVMFlag*), compare_flags);\n-\n+  }\n+  \/\/ Print the flag with best sort value, then mark it.\n+  for (size_t j = 0; j < length; j++) {\n+    JVMFlag* best = nullptr;\n@@ -713,2 +715,4 @@\n-      if (array[i]->is_unlocked() && !(skipDefaults && array[i]->is_default())) {\n-        array[i]->print_on(out, withComments, printRanges);\n+      if (!(flagTable[i].is_iterated()) && flagTable[i].is_unlocked() && !(skipDefaults && flagTable[i].is_default())) {\n+        if ((best == nullptr) || (strcmp(best->name(), flagTable[i].name()) > 0)) {\n+          best = &flagTable[i];\n+        }\n@@ -717,7 +721,3 @@\n-    FREE_C_HEAP_ARRAY(JVMFlag*, array);\n-  } else {\n-    \/\/ OOM? Print unsorted.\n-    for (size_t i = 0; i < length; i++) {\n-      if (flagTable[i].is_unlocked() && !(skipDefaults && flagTable[i].is_default())) {\n-        flagTable[i].print_on(out, withComments, printRanges);\n-      }\n+    if (best != nullptr) {\n+      best->print_on(out, withComments, printRanges);\n+      best->set_iterated();\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+    VALUE_ITERATED          = 1 << 18,\n+\n@@ -300,0 +302,4 @@\n+  void clear_iterated()           { _flags = Flags(_flags & ~VALUE_ITERATED);                 }\n+  void set_iterated()             { _flags = Flags(_flags | VALUE_ITERATED);                  }\n+  bool is_iterated()              { return (_flags & VALUE_ITERATED) != 0;                    }\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlag.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}