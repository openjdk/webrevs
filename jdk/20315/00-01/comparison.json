{"files":[{"patch":"@@ -1,186 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8315575 8328137\n- * @summary test that records with invisible annotation can be retransformed\n- *\n- * @library \/test\/lib\n- * @run shell MakeJAR.sh retransformAgent\n- * @run main\/othervm -javaagent:retransformAgent.jar -Xlog:redefine+class=trace RetransformRecordAnnotation\n- *\/\n-\n-import java.io.File;\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-import java.lang.instrument.ClassFileTransformer;\n-import java.nio.file.Files;\n-import java.security.ProtectionDomain;\n-\n-public class RetransformRecordAnnotation extends AInstrumentationTestCase {\n-\n-    @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @interface RuntimeTypeAnno {}\n-\n-    @Retention(RetentionPolicy.RUNTIME)\n-    @interface RuntimeParamAnno {\n-        String s() default \"foo\";\n-    }\n-\n-    @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})\n-    @Retention(RetentionPolicy.CLASS)\n-    @interface ClassTypeAnno {}\n-\n-    @Retention(RetentionPolicy.CLASS)\n-    @interface ClassParamAnno {\n-        String s() default \"bar\";\n-    }\n-\n-    @RuntimeTypeAnno\n-    @RuntimeParamAnno(s = \"1\")\n-    public record VisibleAnnos(@RuntimeTypeAnno @RuntimeParamAnno(s = \"2\") Object o, Object other) {\n-    }\n-\n-    @ClassTypeAnno\n-    @ClassParamAnno(s = \"3\")\n-    public record InvisibleAnnos(@ClassTypeAnno @ClassParamAnno(s = \"4\") Object o, Object other) {\n-    }\n-\n-    @RuntimeTypeAnno\n-    @RuntimeParamAnno(s = \"5\")\n-    @ClassTypeAnno\n-    @ClassParamAnno(s = \"6\")\n-    public record MixedAnnos(@RuntimeTypeAnno @RuntimeParamAnno(s = \"7\")\n-                             @ClassTypeAnno @ClassParamAnno(s = \"8\") Object o, Object other) {\n-    }\n-\n-    public static void main (String[] args) throws Throwable {\n-        ATestCaseScaffold test = new RetransformRecordAnnotation();\n-        test.beVerbose();\n-        test.runTest();\n-    }\n-\n-    private Transformer transformer;\n-\n-    public RetransformRecordAnnotation() throws Throwable {\n-        super(\"RetransformRecordAnnotation\");\n-    }\n-\n-    private void log(Object o) {\n-        System.out.println(String.valueOf(o));\n-    }\n-\n-    \/\/ Retransforms target class using provided class bytes;\n-    private void retransform(Class targetClass, byte[] classBytes) throws Throwable {\n-        transformer.prepare(targetClass, classBytes);\n-        fInst.retransformClasses(targetClass);\n-        assertTrue(targetClass.getName() + \" was not seen by transform()\",\n-                   transformer.getSeenClassBytes() != null);\n-    }\n-\n-    protected final void doRunTest() throws Throwable {\n-        transformer = new Transformer();\n-        fInst.addTransformer(transformer, true);\n-\n-        {\n-            log(\"Sanity: retransform to original class bytes\");\n-            retransform(InvisibleAnnos.class, loadClassBytes(InvisibleAnnos.class));\n-            log(\"\");\n-        }\n-\n-        \/\/ The following testcases use null as new class bytes (i.e. no transform is performed).\n-        \/\/ However, it is enough for testing purposes as the JvmtiClassFileReconstituter is still involved\n-        \/\/ in preparation of the initial class bytes.\n-        {\n-            log(\"Test: retransform VisibleAnnos to null\");\n-            retransform(VisibleAnnos.class, null);\n-            log(\"\");\n-        }\n-\n-        {\n-            log(\"Test: retransform InvisibleAnnos to null\");\n-            retransform(InvisibleAnnos.class, null);\n-            log(\"\");\n-        }\n-\n-        {\n-            log(\"Test: retransform MixedAnnos to null\");\n-            retransform(MixedAnnos.class, null);\n-            log(\"\");\n-        }\n-    }\n-\n-    private byte[] loadClassBytes(Class cls) throws Exception {\n-        String classFileName = cls.getName() + \".class\";\n-        File classFile = new File(System.getProperty(\"test.classes\", \".\"), classFileName);\n-        log(\"Reading test class from \" + classFile);\n-        byte[] classBytes = Files.readAllBytes(classFile.toPath());\n-        log(\"Read \" + classBytes.length + \" bytes.\");\n-        return classBytes;\n-    }\n-\n-    public class Transformer implements ClassFileTransformer {\n-        private String targetClassName;\n-        private byte[] seenClassBytes;\n-        private byte[] newClassBytes;\n-\n-        public Transformer() {\n-        }\n-\n-        \/\/ Prepares transformer for Instrumentation.retransformClasses.\n-        public void prepare(Class targetClass, byte[] classBytes) {\n-            targetClassName = targetClass.getName();\n-            newClassBytes = classBytes;\n-            seenClassBytes = null;\n-        }\n-\n-        byte[] getSeenClassBytes() {\n-            return seenClassBytes;\n-        }\n-\n-        public String toString() {\n-            return Transformer.this.getClass().getName();\n-        }\n-\n-        public byte[] transform(ClassLoader loader, String className,\n-            Class<?> classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) {\n-\n-            if (className.equals(targetClassName)) {\n-                log(this + \".transform() sees '\" + className\n-                        + \"' of \" + classfileBuffer.length + \" bytes.\");\n-                seenClassBytes = classfileBuffer;\n-                if (newClassBytes != null) {\n-                    log(this + \".transform() sets new classbytes for '\" + className\n-                            + \"' of \" + newClassBytes.length + \" bytes.\");\n-                }\n-                return newClassBytes;\n-            }\n-\n-            return null;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/instrument\/RetransformRecordAnnotation.java","additions":0,"deletions":186,"binary":false,"changes":186,"status":"deleted"}]}