{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -201,0 +201,1 @@\n+        String level = \"\";\n@@ -225,0 +226,1 @@\n+            pos.writeUTF(level);\n@@ -523,0 +525,1 @@\n+                currentType.level = getString(attributes, \"level\");\n@@ -654,1 +657,1 @@\n-            out.write(\"  jlong  cutoff_ticks;\");\n+            out.write(\"  jlong  miscellaneous;\");\n","filename":"make\/src\/classes\/build\/tools\/jfr\/GenerateJfrFiles.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -203,0 +203,1 @@\n+  bool deprecated()             const { return is_loaded() && get_Method()->deprecated(); }\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -954,0 +954,2 @@\n+    _java_lang_Deprecated,\n+    _java_lang_Deprecated_for_removal,\n@@ -1125,0 +1127,1 @@\n+    b_tag_val = 'Z',  \/\/ payload is boolean\n@@ -1147,0 +1150,26 @@\n+    if (AnnotationCollector::_java_lang_Deprecated == id) {\n+      assert(count <= 2, \"change this if more element-value pairs are added to the @Deprecated annotation\");\n+      \/\/ @Deprecated can specify forRemoval=true\n+      const u1* offset = abase + member_off;\n+      for (int i = 0; i < count; ++i) {\n+        int member_index = Bytes::get_Java_u2((address)offset);\n+        offset += 2;\n+        member = check_symbol_at(cp, member_index);\n+        if (member == vmSymbols::since()) {\n+          assert(*((address)offset) == s_tag_val, \"invariant\");\n+          offset += 3;\n+          continue;\n+        }\n+        if (member == vmSymbols::for_removal()) {\n+          assert(*((address)offset) == b_tag_val, \"invariant\");\n+          const u2 boolean_value_index = Bytes::get_Java_u2((address)offset + 1);\n+          if (cp->int_at(boolean_value_index) == 1) {\n+            \/\/ forRemoval == true\n+            coll->set_annotation(AnnotationCollector::_java_lang_Deprecated_for_removal);\n+          }\n+          break;\n+        }\n+\n+      }\n+      continue;\n+    }\n@@ -1962,0 +1991,3 @@\n+    case VM_SYMBOL_ENUM_NAME(java_lang_Deprecated): {\n+      return _java_lang_Deprecated;\n+    }\n@@ -2006,0 +2038,4 @@\n+  if (has_annotation(_java_lang_Deprecated))\n+    m->set_deprecated();\n+  if (has_annotation(_java_lang_Deprecated_for_removal))\n+    m->set_deprecated_for_removal();\n@@ -2019,0 +2055,16 @@\n+  if (has_annotation(_java_lang_Deprecated)) {\n+    Array<Method*>* methods = ik->methods();\n+    int length = ik->methods()->length();\n+    for (int i = 0; i < length; i++) {\n+      Method* m = methods->at(i);\n+      m->set_deprecated();\n+    }\n+  }\n+  if (has_annotation(_java_lang_Deprecated_for_removal)) {\n+    Array<Method*>* methods = ik->methods();\n+    int length = ik->methods()->length();\n+    for (int i = 0; i < length; i++) {\n+      Method* m = methods->at(i);\n+      m->set_deprecated_for_removal();\n+    }\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -165,1 +165,3 @@\n-                                                                                                  \\\n+  template(java_lang_Deprecated,                      \"Ljava\/lang\/Deprecated;\")                   \\\n+  template(since,                                     \"since\")                                    \\\n+  template(for_removal,                               \"forRemoval\")                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"ci\/ciKlass.hpp\"\n-#include \"ci\/ciMethod.hpp\"\n-#include \"classfile\/vmSymbols.hpp\"\n-#include \"interpreter\/linkResolver.hpp\"\n-#include \"jfr\/instrumentation\/jfrResolution.hpp\"\n-#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdMacros.hpp\"\n-#include \"oops\/method.inline.hpp\"\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/vframe.inline.hpp\"\n-#ifdef COMPILER1\n-#include \"c1\/c1_GraphBuilder.hpp\"\n-#endif\n-#ifdef COMPILER2\n-#include \"opto\/parse.hpp\"\n-#endif\n-\n-static const char* const link_error_msg = \"illegal access linking method 'jdk.jfr.internal.event.EventWriterFactory.getEventWriter(long)'\";\n-\n-static const Method* ljf_sender_method(JavaThread* jt) {\n-  assert(jt != nullptr, \"invariant\");\n-  if (!jt->has_last_Java_frame()) {\n-    return nullptr;\n-  }\n-  const vframeStream ljf(jt, false, false);\n-  return ljf.method();\n-}\n-\n-void JfrResolution::on_runtime_resolution(const CallInfo & info, TRAPS) {\n-  assert(info.selected_method() != nullptr, \"invariant\");\n-  assert(info.resolved_klass() != nullptr, \"invariant\");\n-  static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();\n-  assert(event_writer_method_name != nullptr, \"invariant\");\n-  \/\/ Fast path\n-  if (info.selected_method()->name() != event_writer_method_name) {\n-    return;\n-  }\n-  static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();\n-  assert(event_writer_factory_klass_name != nullptr, \"invariant\");\n-  if (info.resolved_klass()->name() != event_writer_factory_klass_name) {\n-    return;\n-  }\n-  \/\/ Attempting to link against jdk.jfr.internal.event.EventWriterFactory.getEventWriter().\n-  \/\/ The sender, i.e. the method attempting to link, is in the ljf (if one exists).\n-  const Method* const sender = ljf_sender_method(THREAD);\n-  if (sender == nullptr) {\n-    \/\/ A compiler thread is doing linktime resolution but there is no information about the sender available.\n-    \/\/ For the compiler threads, the sender is instead found as part of bytecode parsing.\n-    return;\n-  }\n-  \/\/ Is the sender method blessed for linkage?\n-  if (IS_METHOD_BLESSED(sender)) {\n-    return;\n-  }\n-#if INCLUDE_JVMCI\n-  \/\/ JVMCI compiler is doing linktime resolution\n-  if (sender->method_holder()->name() == vmSymbols::jdk_vm_ci_hotspot_CompilerToVM()) {\n-    if (sender->name()->equals(\"lookupMethodInPool\")) {\n-      return;\n-    }\n-  }\n-#endif\n-  THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), link_error_msg);\n-}\n-\n-static inline bool is_compiler_linking_event_writer(const Symbol* holder, const Symbol* name) {\n-  static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();\n-  assert(event_writer_factory_klass_name != nullptr, \"invariant\");\n-  if (holder != event_writer_factory_klass_name) {\n-    return false;\n-  }\n-  static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();\n-  assert(event_writer_method_name != nullptr, \"invariant\");\n-  return name == event_writer_method_name;\n-}\n-\n-static inline bool is_compiler_linking_event_writer(const ciKlass * holder, const ciMethod * target) {\n-  assert(holder != nullptr, \"invariant\");\n-  assert(target != nullptr, \"invariant\");\n-  return is_compiler_linking_event_writer(holder->name()->get_symbol(), target->name()->get_symbol());\n-}\n-\n-#ifdef COMPILER1\n-\/\/ C1\n-void JfrResolution::on_c1_resolution(const GraphBuilder * builder, const ciKlass * holder, const ciMethod * target) {\n-  if (is_compiler_linking_event_writer(holder, target) && !IS_METHOD_BLESSED(builder->method()->get_Method())) {\n-    builder->bailout(link_error_msg);\n-  }\n-}\n-#endif\n-\n-#ifdef COMPILER2\n-\/\/ C2\n-void JfrResolution::on_c2_resolution(const Parse * parse, const ciKlass * holder, const ciMethod * target) {\n-  if (is_compiler_linking_event_writer(holder, target) && !IS_METHOD_BLESSED(parse->method()->get_Method())) {\n-    parse->C->record_failure(link_error_msg);\n-  }\n-}\n-#endif\n-\n-#if INCLUDE_JVMCI\n-\/\/ JVMCI\n-void JfrResolution::on_jvmci_resolution(const Method* caller, const Method* target, TRAPS) {\n-  if (is_compiler_linking_event_writer(target->method_holder()->name(), target->name())) {\n-    if (caller == nullptr || !IS_METHOD_BLESSED(caller)) {\n-      THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), link_error_msg);\n-    }\n-  }\n-}\n-#endif\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrResolution.cpp","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_JFR_INSTRUMENTATION_JFRRESOLUTION_HPP\n-#define SHARE_JFR_INSTRUMENTATION_JFRRESOLUTION_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"utilities\/exceptions.hpp\"\n-\n-class CallInfo;\n-class ciKlass;\n-class ciMethod;\n-class GraphBuilder;\n-class Parse;\n-\n-class JfrResolution : AllStatic {\n- public:\n-  static void on_runtime_resolution(const CallInfo & info, TRAPS);\n-  static void on_c1_resolution(const GraphBuilder * builder, const ciKlass * holder, const ciMethod * target);\n-  static void on_c2_resolution(const Parse * parse, const ciKlass * holder, const ciMethod * target);\n-  static void on_jvmci_resolution(const Method* caller, const Method* target, TRAPS);\n-};\n-\n-#endif \/\/ SHARE_JFR_INSTRUMENTATION_JFRRESOLUTION_HPP\n-\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrResolution.hpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"jfr\/instrumentation\/jfrResolution.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"jfr\/support\/jfrResolution.hpp\"\n@@ -70,3 +70,1 @@\n-  if (JfrRecorder::is_created()) {\n-    JfrCheckpointManager::on_unloading_classes();\n-  }\n+  JfrCheckpointManager::on_unloading_classes();\n@@ -107,0 +105,4 @@\n+void Jfr::on_deprecated_invocation(const Method* deprecated_method, JavaThread* jt) {\n+  JfrResolution::on_deprecated_invocation(deprecated_method, jt);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,1 @@\n+  static void on_deprecated_invocation(const Method* deprecated_method, JavaThread* jt);\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"jfr\/support\/jfrDeprecationManager.hpp\"\n@@ -162,4 +163,0 @@\n-NO_TRANSITION(jboolean, jfr_set_cutoff(JNIEnv* env, jclass jvm, jlong event_type_id, jlong cutoff_ticks))\n-  return JfrEventSetting::set_cutoff(event_type_id, cutoff_ticks) ? JNI_TRUE : JNI_FALSE;\n-NO_TRANSITION_END\n-\n@@ -171,0 +168,8 @@\n+NO_TRANSITION(void, jfr_set_miscellaneous(JNIEnv* env, jobject jvm, jlong event_type_id, jlong value))\n+  JfrEventSetting::set_miscellaneous(event_type_id, value);\n+  const JfrEventId typed_event_id = (JfrEventId)event_type_id;\n+  if (EventDeprecatedInvocation::eventId == typed_event_id) {\n+    JfrDeprecationManager::on_level_setting_update(value);\n+  }\n+NO_TRANSITION_END\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -130,2 +130,0 @@\n-jboolean JNICALL jfr_set_cutoff(JNIEnv* env, jclass jvm, jlong event_type_id, jlong cutoff_ticks);\n-\n@@ -134,0 +132,2 @@\n+void JNICALL jfr_set_miscellaneous(JNIEnv* env, jobject jvm, jlong id, jlong value);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-      (char*)\"setCutoff\", (char*)\"(JJ)Z\", (void*)jfr_set_cutoff,\n+      (char*)\"setMiscellaneous\", (char*)\"(JJ)V\", (void*)jfr_set_miscellaneous,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -419,1 +419,1 @@\n-static void save_type_set_blob(JfrCheckpointWriter& writer, bool copy = false) {\n+static void save_type_set_blob(JfrCheckpointWriter& writer) {\n@@ -421,1 +421,1 @@\n-  const JfrBlobHandle blob = copy ? writer.copy() : writer.move();\n+  const JfrBlobHandle blob = writer.copy();\n@@ -444,1 +444,1 @@\n-    save_type_set_blob(writer, true);\n+    save_type_set_blob(writer);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1254,0 +1254,5 @@\n+\n+  <Event name=\"DeprecatedInvocation\" description= \"A unique invocation of a method or class that is annotated with @Deprecated. Packages and modules that are deprecated are ignored.\" category=\"Java Application, Statistics\" label=\"Deprecated Method Invocation\" thread=\"false\" stackTrace=\"true\" startTime=\"false\" level=\"forRemoval,all\">\n+    <Field type=\"Method\" name=\"method\" label=\"Deprecated Method\" \/>\n+    <Field type=\"boolean\" name=\"forRemoval\" label=\"Method Deprecated For Removal\" \/>\n+  <\/Event>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,0 +75,1 @@\n+              <xs:attribute name=\"level\" type=\"xs:string\" use=\"optional\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xsd","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n- * Implementation in jfrSamples.cpp\n+ * Implementation in periodic\/sampling\/jfrThreadSampler.cpp.\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"jfr\/support\/jfrDeprecationManager.hpp\"\n@@ -69,1 +70,1 @@\n-JfrCheckpointManager* JfrCheckpointManager::create(JfrChunkWriter& cw) {\n+JfrCheckpointManager* JfrCheckpointManager::create() {\n@@ -71,1 +72,1 @@\n-  _instance = new JfrCheckpointManager(cw);\n+  _instance = new JfrCheckpointManager();\n@@ -76,3 +77,2 @@\n-  assert(_instance != nullptr, \"invariant\");\n-  delete _instance;\n-  _instance = nullptr;\n+  JfrTypeManager::destroy();\n+  JfrTraceIdLoadBarrier::destroy();\n@@ -81,1 +81,1 @@\n-JfrCheckpointManager::JfrCheckpointManager(JfrChunkWriter& cw) :\n+JfrCheckpointManager::JfrCheckpointManager() :\n@@ -85,1 +85,1 @@\n-  _chunkwriter(cw) {}\n+  _chunkwriter(nullptr) {}\n@@ -87,6 +87,1 @@\n-JfrCheckpointManager::~JfrCheckpointManager() {\n-  JfrTraceIdLoadBarrier::destroy();\n-  JfrTypeManager::destroy();\n-  delete _global_mspace;\n-  delete _thread_local_mspace;\n-}\n+JfrCheckpointManager::~JfrCheckpointManager() {}\n@@ -103,1 +98,4 @@\n-bool JfrCheckpointManager::initialize() {\n+\/\/ We expose an early initialization routine to support class unloading\n+\/\/ even though the full JFR system is not yet started. It requires\n+\/\/ backing of global buffers should it write a class unload type set blob.\n+bool JfrCheckpointManager::initialize_early() {\n@@ -134,0 +132,7 @@\n+  return true;\n+}\n+\n+\/\/ The instance is already created and so we only complete the setup of additional subsystems.\n+bool JfrCheckpointManager::initialize(JfrChunkWriter* cw) {\n+  assert(cw != nullptr, \"invariant\");\n+  _chunkwriter = cw;\n@@ -137,0 +142,9 @@\n+void JfrCheckpointManager::set_chunkwriter(JfrChunkWriter* cw) {\n+  _chunkwriter = cw;\n+}\n+\n+JfrChunkWriter& JfrCheckpointManager::chunkwriter() {\n+  assert(_chunkwriter != nullptr, \"invariant\");\n+  return *_chunkwriter;\n+}\n+\n@@ -505,1 +519,1 @@\n-  WriteOperation wo(_chunkwriter);\n+  WriteOperation wo(chunkwriter());\n@@ -513,1 +527,1 @@\n-  VirtualThreadLocalCheckpointOperation vtlco(_chunkwriter);\n+  VirtualThreadLocalCheckpointOperation vtlco(chunkwriter());\n@@ -569,2 +583,2 @@\n-  JavaThread* t = JavaThread::current();\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(t));\n+  JavaThread* thread = JavaThread::current();\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(thread));\n@@ -572,4 +586,14 @@\n-  ThreadInVMfromNative transition(t);\n-  MutexLocker cld_lock(ClassLoaderDataGraph_lock);\n-  MutexLocker module_lock(Module_lock);\n-  JfrTypeSet::clear();\n+  ThreadInVMfromNative transition(thread);\n+  MutexLocker cld_lock(thread, ClassLoaderDataGraph_lock);\n+  JfrDeprecationManager::prepare_type_set(thread); \/\/ marks leakp\n+  JfrCheckpointWriter leakp_writer(true, thread);\n+  JfrCheckpointWriter writer(true, thread);\n+  {\n+    MutexLocker module_lock(Module_lock);\n+    JfrTypeSet::clear(&writer, &leakp_writer);\n+  }\n+  JfrDeprecationManager::on_type_set(leakp_writer, nullptr, thread);\n+  \/\/ This data is not committed to the system,\n+  \/\/ because it has not started yet.\n+  writer.cancel();\n+  leakp_writer.cancel();\n@@ -586,0 +610,5 @@\n+    JfrCheckpointWriter leakp_writer(true, thread);\n+    JfrCheckpointWriter writer(true, thread);\n+    JfrDeprecationManager::prepare_type_set(thread);\n+    JfrTypeSet::serialize(&writer, &leakp_writer, false, false);\n+    JfrDeprecationManager::on_type_set(leakp_writer, _chunkwriter, thread);\n@@ -587,3 +616,0 @@\n-      JfrCheckpointWriter leakp_writer(true, thread);\n-      JfrCheckpointWriter writer(true, thread);\n-      JfrTypeSet::serialize(&writer, &leakp_writer, false, false);\n@@ -591,3 +617,0 @@\n-    } else {\n-      JfrCheckpointWriter writer(true, thread);\n-      JfrTypeSet::serialize(&writer, nullptr, false, false);\n@@ -595,0 +618,1 @@\n+    leakp_writer.cancel();\n@@ -603,0 +627,1 @@\n+  JfrDeprecationManager::on_type_set_unload(writer);\n@@ -629,1 +654,1 @@\n-    WriteOperation wo(_chunkwriter);\n+    WriteOperation wo(chunkwriter());\n@@ -636,1 +661,1 @@\n-    VirtualThreadLocalCheckpointOperation vtlco(_chunkwriter);\n+    VirtualThreadLocalCheckpointOperation vtlco(chunkwriter());\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":55,"deletions":30,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  JfrChunkWriter& _chunkwriter;\n+  JfrChunkWriter* _chunkwriter;\n@@ -67,1 +67,1 @@\n-  JfrCheckpointManager(JfrChunkWriter& cw);\n+  JfrCheckpointManager();\n@@ -70,2 +70,3 @@\n-  static JfrCheckpointManager* create(JfrChunkWriter& cw);\n-  bool initialize();\n+  static JfrCheckpointManager* create();\n+  bool initialize_early();\n+  bool initialize(JfrChunkWriter* cw);\n@@ -74,0 +75,3 @@\n+  JfrChunkWriter& chunkwriter();\n+  void set_chunkwriter(JfrChunkWriter* cw);\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -77,0 +77,14 @@\n+JfrCheckpointWriter::JfrCheckpointWriter(bool previous_epoch, bool header, Thread* thread, JfrCheckpointType type \/* GENERIC *\/) :\n+  JfrCheckpointWriterBase(JfrCheckpointManager::lease_global(thread, previous_epoch), thread),\n+  _time(JfrTicks::now()),\n+  _offset(0),\n+  _count(0),\n+  _type(type),\n+  _header(header) {\n+  assert(this->is_acquired(), \"invariant\");\n+  assert(0 == this->current_offset(), \"invariant\");\n+  if (_header) {\n+    reserve(sizeof(JfrCheckpointEntry));\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  JfrCheckpointWriter(bool previous_epoch, bool header, Thread* thread, JfrCheckpointType type = GENERIC);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -289,9 +289,0 @@\n-static void on_klass_unload(Klass* klass) {\n-  register_klass_unload(klass);\n-}\n-\n-static size_t register_unloading_klasses() {\n-  ClassLoaderDataGraph::classes_unloading_do(&on_klass_unload);\n-  return 0;\n-}\n-\n@@ -365,0 +356,57 @@\n+template <typename T>\n+static void do_previous_epoch_artifact(JfrArtifactClosure* callback, T* value) {\n+  assert(callback != nullptr, \"invariant\");\n+  assert(value != nullptr, \"invariant\");\n+  if (USED_PREVIOUS_EPOCH(value)) {\n+    callback->do_artifact(value);\n+  }\n+  if (IS_SERIALIZED(value)) {\n+    CLEAR_SERIALIZED(value);\n+  }\n+  assert(IS_NOT_SERIALIZED(value), \"invariant\");\n+}\n+\n+static void do_previous_epoch_klass(JfrArtifactClosure* callback, const Klass* value) {\n+  assert(callback != nullptr, \"invariant\");\n+  assert(value != nullptr, \"invariant\");\n+  if (USED_PREVIOUS_EPOCH(value)) {\n+    callback->do_artifact(value);\n+  }\n+}\n+\n+static void do_klass_on_clear(Klass* klass) {\n+  assert(klass != nullptr, \"invariant\");\n+  assert(_subsystem_callback != nullptr, \"invariant\");\n+  do_previous_epoch_klass(_subsystem_callback, klass);\n+}\n+\n+static void do_loader_klass_on_clear(const Klass* klass) {\n+  if (klass != nullptr && _artifacts->should_do_loader_klass(klass)) {\n+    if (_leakp_writer != nullptr) {\n+      SET_LEAKP(klass);\n+    }\n+    SET_TRANSIENT(klass);\n+    do_previous_epoch_klass(_subsystem_callback, klass);\n+  }\n+}\n+\n+static void do_classloaders_on_clear() {\n+  for (ClassHierarchyIterator iter(vmClasses::ClassLoader_klass()); !iter.done(); iter.next()) {\n+    Klass* subk = iter.klass();\n+    if (is_classloader_klass_allowed(subk)) {\n+      do_loader_klass_on_clear(subk);\n+    }\n+  }\n+}\n+\n+static void do_object_on_clear() {\n+  SET_TRANSIENT(vmClasses::Object_klass());\n+  do_klass_on_clear(vmClasses::Object_klass());\n+}\n+\n+static void do_all_klasses() {\n+  ClassLoaderDataGraph::classes_do(&do_klass_on_clear);\n+  do_classloaders_on_clear();\n+  do_object_on_clear();\n+}\n+\n@@ -417,22 +465,1 @@\n-template <typename T>\n-static void do_previous_epoch_artifact(JfrArtifactClosure* callback, T* value) {\n-  assert(callback != nullptr, \"invariant\");\n-  assert(value != nullptr, \"invariant\");\n-  if (USED_PREVIOUS_EPOCH(value)) {\n-    callback->do_artifact(value);\n-  }\n-  if (IS_SERIALIZED(value)) {\n-    CLEAR_SERIALIZED(value);\n-  }\n-  assert(IS_NOT_SERIALIZED(value), \"invariant\");\n-}\n-\n-typedef JfrArtifactCallbackHost<KlassPtr, KlassArtifactRegistrator> RegisterKlassCallback;\n-\n-static void register_klass(Klass* klass) {\n-  assert(klass != nullptr, \"invariant\");\n-  assert(_subsystem_callback != nullptr, \"invariant\");\n-  do_previous_epoch_artifact(_subsystem_callback, klass);\n-}\n-\n-static void register_klasses() {\n+static bool write_klasses_on_clear() {\n@@ -440,0 +467,2 @@\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n@@ -441,2 +470,12 @@\n-  RegisterKlassCallback callback(&_subsystem_callback, &reg);\n-  ClassLoaderDataGraph::classes_do(&register_klass);\n+  KlassWriter kw(_writer, _class_unload);\n+  KlassWriterRegistration kwr(&kw, &reg);\n+  LeakKlassWriter lkw(_leakp_writer, _class_unload);\n+  CompositeKlassWriter ckw(&lkw, &kw);\n+  CompositeKlassWriterRegistration ckwr(&ckw, &reg);\n+  CompositeKlassCallback callback(&_subsystem_callback, &ckwr);\n+  do_all_klasses();\n+  if (is_complete()) {\n+    return false;\n+  }\n+  _artifacts->tally(kw);\n+  return true;\n@@ -533,3 +572,10 @@\n-typedef JfrArtifactCallbackHost<PkgPtr, ClearArtifact<PkgPtr> > ClearPackageCallback;\n-\n-static void clear_packages() {\n+static void write_packages_on_clear() {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  PackageWriter pw(_writer, _class_unload);\n+  KlassPackageWriter kpw(&pw);\n+  LeakPackageWriter lpw(_leakp_writer, _class_unload);\n+  CompositePackageWriter cpw(&lpw, &pw);\n+  KlassCompositePackageWriter kcpw(&cpw);\n+  _artifacts->iterate_klasses(kcpw);\n@@ -537,1 +583,2 @@\n-  ClearPackageCallback callback(&_subsystem_callback, &clear);\n+  CompositePackageWriterWithClear cpwwc(&cpw, &clear);\n+  CompositePackageCallback callback(&_subsystem_callback, &cpwwc);\n@@ -539,0 +586,1 @@\n+  _artifacts->tally(pw);\n@@ -629,3 +677,10 @@\n-typedef JfrArtifactCallbackHost<ModPtr, ClearArtifact<ModPtr> > ClearModuleCallback;\n-\n-static void clear_modules() {\n+static void write_modules_on_clear() {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  ModuleWriter mw(_writer, _class_unload);\n+  KlassModuleWriter kmw(&mw);\n+  LeakModuleWriter lmw(_leakp_writer, _class_unload);\n+  CompositeModuleWriter cmw(&lmw, &mw);\n+  KlassCompositeModuleWriter kcpw(&cmw);\n+  _artifacts->iterate_klasses(kcpw);\n@@ -633,1 +688,2 @@\n-  ClearModuleCallback callback(&_subsystem_callback, &clear);\n+  CompositeModuleWriterWithClear cmwwc(&cmw, &clear);\n+  CompositeModuleCallback callback(&_subsystem_callback, &cmwwc);\n@@ -635,0 +691,1 @@\n+  _artifacts->tally(mw);\n@@ -762,3 +819,13 @@\n-typedef JfrArtifactCallbackHost<CldPtr, ClearArtifact<CldPtr> > ClearCLDCallback;\n-\n-static void clear_classloaders() {\n+static void write_classloaders_on_clear() {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  CldWriter cldw(_writer, _class_unload);\n+  KlassCldWriter kcw(&cldw);\n+  ModuleCldWriter mcw(&cldw);\n+  KlassAndModuleCldWriter kmcw(&kcw, &mcw);\n+  LeakCldWriter lcldw(_leakp_writer, _class_unload);\n+  CompositeCldWriter ccldw(&lcldw, &cldw);\n+  KlassCompositeCldWriter kccldw(&ccldw);\n+  ModuleCompositeCldWriter mccldw(&ccldw);\n+  KlassAndModuleCompositeCldWriter kmccldw(&kccldw, &mccldw);\n+  _artifacts->iterate_klasses(kmccldw);\n@@ -766,1 +833,2 @@\n-  ClearCLDCallback callback(&_subsystem_callback, &clear);\n+  CompositeCldWriterWithClear ccldwwc(&ccldw, &clear);\n+  CompositeCldCallback callback(&_subsystem_callback, &ccldwwc);\n@@ -768,0 +836,1 @@\n+  _artifacts->tally(cldw);\n@@ -779,1 +848,1 @@\n-  assert(IS_METHOD_SERIALIZED(method), \"invariant\");\n+  assert(METHOD_IS_SERIALIZED(method), \"invariant\");\n@@ -920,0 +989,11 @@\n+static void write_methods_on_clear() {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  MethodWriter mw(_writer, current_epoch(), _class_unload);\n+  LeakMethodWriter lpmw(_leakp_writer, current_epoch(), _class_unload);\n+  CompositeMethodWriter cmw(&lpmw, &mw);\n+  _artifacts->iterate_klasses(cmw);\n+  _artifacts->tally(mw);\n+}\n+\n@@ -1008,0 +1088,17 @@\n+static void write_symbols_on_clear() {\n+  assert(_writer != nullptr, \"invariant\");\n+  assert(_leakp_writer != nullptr, \"invariant\");\n+  assert(previous_epoch(), \"invariant\");\n+  SymbolEntryWriter sw(_writer, _class_unload);\n+  LeakSymbolEntryWriter lsw(_leakp_writer, _class_unload);\n+  CompositeSymbolWriter csw(&lsw, &sw);\n+  _artifacts->iterate_symbols(csw);\n+  StringEntryWriter sew(_writer, _class_unload, true); \/\/ skip header\n+  LeakStringEntryWriter lsew(_leakp_writer, _class_unload, true); \/\/ skip header\n+  CompositeStringWriter csew(&lsew, &sew);\n+  _artifacts->iterate_strings(csew);\n+  sw.add(sew.count());\n+  lsw.add(lsew.count());\n+  _artifacts->tally(sw);\n+}\n+\n@@ -1085,1 +1182,1 @@\n-void JfrTypeSet::clear() {\n+void JfrTypeSet::clear(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer) {\n@@ -1087,10 +1184,8 @@\n-  JfrKlassUnloading::clear();\n-  if (_artifacts != nullptr) {\n-    _artifacts->clear();\n-  }\n-  setup(nullptr, nullptr, false, false);\n-  register_klasses();\n-  clear_packages();\n-  clear_modules();\n-  clear_classloaders();\n-  clear_klasses_and_methods();\n+  setup(writer, leakp_writer, false, false);\n+  write_klasses_on_clear();\n+  write_packages_on_clear();\n+  write_modules_on_clear();\n+  write_classloaders_on_clear();\n+  write_methods_on_clear();\n+  write_symbols_on_clear();\n+  teardown();\n@@ -1104,4 +1199,1 @@\n-  if (JfrRecorder::is_recording()) {\n-    return serialize(writer, nullptr, true, false);\n-  }\n-  return register_unloading_klasses();\n+  return serialize(writer, nullptr, true, false);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":153,"deletions":61,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-  static void clear();\n+  static void clear(JfrCheckpointWriter* writer, JfrCheckpointWriter* leakp_writer);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+    assert(IS_NOT_LEAKP(value), \"invariant\");\n+    assert(IS_NOT_TRANSIENT(value), \"invariant\");\n@@ -106,1 +108,3 @@\n-    assert(METHOD_NOT_SERIALIZED(method), \"invariant\");\n+    assert(METHOD_IS_NOT_SERIALIZED(method), \"invariant\");\n+    assert(METHOD_IS_NOT_LEAKP(method), \"invariant\");\n+    assert(METHOD_IS_NOT_TRANSIENT(method), \"invariant\");\n@@ -131,1 +135,1 @@\n-    return _class_unload ? true : METHOD_NOT_SERIALIZED(method);\n+    return _class_unload ? true : METHOD_IS_NOT_SERIALIZED(method);\n@@ -165,1 +169,1 @@\n-      return leakp ? IS_METHOD_LEAKP_USED(method) : METHOD_FLAG_USED_THIS_EPOCH(method);\n+      return leakp ? METHOD_IS_LEAKP(method) : METHOD_FLAG_USED_THIS_EPOCH(method);\n@@ -167,1 +171,1 @@\n-    return leakp ? IS_METHOD_LEAKP_USED(method) : METHOD_FLAG_USED_PREVIOUS_EPOCH(method);\n+    return leakp ? METHOD_IS_LEAKP(method) : METHOD_FLAG_USED_PREVIOUS_EPOCH(method);\n@@ -186,1 +190,1 @@\n-    return IS_METHOD_LEAKP_USED(method);\n+    return METHOD_IS_LEAKP(method);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,0 +96,3 @@\n+  static traceid load_leakp_previous_epoch(const Klass* klass, const Method* method); \/\/ leak profiler\n+  static traceid load_no_enqueue(const Method* method);\n+  static traceid load_no_enqueue(const Klass* klass, const Method* method);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,0 +47,4 @@\n+inline traceid JfrTraceId::load_no_enqueue(const Method* method) {\n+  return JfrTraceIdLoadBarrier::load_no_enqueue(method);\n+}\n+\n@@ -51,0 +55,4 @@\n+inline traceid JfrTraceId::load_no_enqueue(const Klass* klass, const Method* method) {\n+  return JfrTraceIdLoadBarrier::load_no_enqueue(klass, method);\n+}\n+\n@@ -67,0 +75,4 @@\n+inline traceid JfrTraceId::load_leakp_previous_epoch(const Klass* klass, const Method* method) {\n+  return JfrTraceIdLoadBarrier::load_leakp_previuos_epoch(klass, method);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,0 +91,1 @@\n+  static traceid load_leakp_previuos_epoch(const Klass* klass, const Method* method); \/\/ leak profiler\n@@ -92,0 +93,2 @@\n+  static traceid load_no_enqueue(const Klass* klass, const Method* method);\n+  static traceid load_no_enqueue(const Method* method);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -102,0 +102,14 @@\n+inline traceid JfrTraceIdLoadBarrier::load_no_enqueue(const Method* method) {\n+  return load_no_enqueue(method->method_holder(), method);\n+}\n+\n+inline traceid JfrTraceIdLoadBarrier::load_no_enqueue(const Klass* klass, const Method* method) {\n+  assert(klass != nullptr, \"invariant\");\n+  assert(method != nullptr, \"invariant\");\n+  SET_METHOD_AND_CLASS_USED_THIS_EPOCH(klass);\n+  SET_METHOD_FLAG_USED_THIS_EPOCH(method);\n+  assert(METHOD_AND_CLASS_USED_THIS_EPOCH(klass), \"invariant\");\n+  assert(METHOD_FLAG_USED_THIS_EPOCH(method), \"invariant\");\n+  return (METHOD_ID(klass, method));\n+}\n+\n@@ -139,0 +153,17 @@\n+inline traceid JfrTraceIdLoadBarrier::load_leakp_previuos_epoch(const Klass* klass, const Method* method) {\n+  assert(klass != nullptr, \"invariant\");\n+  assert(METHOD_AND_CLASS_USED_PREVIOUS_EPOCH(klass), \"invariant\");\n+  assert(method != nullptr, \"invariant\");\n+  assert(klass == method->method_holder(), \"invariant\");\n+  if (METHOD_FLAG_NOT_USED_PREVIOUS_EPOCH(method)) {\n+    \/\/ the method is already logically tagged, just like the klass,\n+    \/\/ but because of redefinition, the latest Method*\n+    \/\/ representation might not have a reified tag.\n+    SET_TRANSIENT(method);\n+    assert(METHOD_FLAG_USED_PREVIOUS_EPOCH(method), \"invariant\");\n+  }\n+  SET_LEAKP(klass);\n+  SET_METHOD_LEAKP(method);\n+  return (METHOD_ID(klass, method));\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-#define METHOD_FLAG_USED_THIS_EPOCH(method)       (METHOD_FLAG_PREDICATE(method, (THIS_EPOCH_BIT)))\n+#define METHOD_FLAG_USED_THIS_EPOCH(method)       (METHOD_FLAG_PREDICATE(method, (TRANSIENT_BIT | THIS_EPOCH_BIT)))\n@@ -105,1 +105,2 @@\n-#define METHOD_FLAG_USED_PREVIOUS_EPOCH(method)   (METHOD_FLAG_PREDICATE(method, (PREVIOUS_EPOCH_BIT)))\n+#define METHOD_FLAG_USED_PREVIOUS_EPOCH(method)   (METHOD_FLAG_PREDICATE(method, (TRANSIENT_BIT | PREVIOUS_EPOCH_BIT)))\n+#define METHOD_FLAG_NOT_USED_PREVIOUS_EPOCH(method) (!(METHOD_FLAG_USED_PREVIOUS_EPOCH(method)))\n@@ -133,0 +134,1 @@\n+#define IS_NOT_LEAKP(ptr)                         (!(IS_LEAKP(ptr)))\n@@ -134,0 +136,3 @@\n+#define IS_TRANSIENT(ptr)                         (TRACE_ID_PREDICATE(ptr, TRANSIENT_BIT))\n+#define IS_NOT_TRANSIENT(ptr)                     (!(IS_TRANSIENT(ptr)))\n+#define SET_SERIALIZED(ptr)                       (TRACE_ID_META_TAG(ptr, SERIALIZED_META_BIT))\n@@ -138,1 +143,0 @@\n-#define SET_SERIALIZED(ptr)                       (TRACE_ID_META_TAG(ptr, SERIALIZED_META_BIT))\n@@ -143,4 +147,0 @@\n-#define IS_METHOD_SERIALIZED(method)              (METHOD_FLAG_PREDICATE(method, SERIALIZED_BIT))\n-#define IS_METHOD_LEAKP_USED(method)              (METHOD_FLAG_PREDICATE(method, LEAKP_BIT))\n-#define METHOD_NOT_SERIALIZED(method)             (!(IS_METHOD_SERIALIZED(method)))\n-#define SET_METHOD_LEAKP(method)                  (METHOD_META_TAG(method, LEAKP_META_BIT))\n@@ -148,0 +148,8 @@\n+#define METHOD_IS_SERIALIZED(method)              (METHOD_FLAG_PREDICATE(method, SERIALIZED_BIT))\n+#define METHOD_IS_NOT_SERIALIZED(method)          (!(METHOD_IS_SERIALIZED(method)))\n+#define SET_METHOD_LEAKP(method)                  (METHOD_META_TAG(method, LEAKP_META_BIT))\n+#define METHOD_IS_LEAKP(method)                   (METHOD_FLAG_PREDICATE(method, LEAKP_BIT))\n+#define METHOD_IS_NOT_LEAKP(method)               (!(METHOD_IS_LEAKP(method)))\n+#define SET_METHOD_TRANSIENT(method)              (METHOD_META_TAG(method, TRANSIENT_META_BIT))\n+#define METHOD_IS_TRANSIENT(method)               (METHOD_FLAG_PREDICATE(method, TRANSIENT_BIT))\n+#define METHOD_IS_NOT_TRANSIENT(method)           (!(METHOD_IS_TRANSIENT(method)))\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdMacros.hpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-bool JfrEventSetting::set_cutoff(jlong id, jlong cutoff_ticks) {\n+void JfrEventSetting::set_miscellaneous(jlong id, jlong level) {\n@@ -41,2 +41,1 @@\n-  setting(event_id).cutoff_ticks = cutoff_ticks;\n-  return true;\n+  setting(event_id).miscellaneous = level;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrEventSetting.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-  static bool set_cutoff(jlong event_id, jlong cutoff_ticks);\n+  static void set_miscellaneous(jlong event_id, jlong cutoff_ticks);\n@@ -50,0 +50,1 @@\n+  static jlong level(JfrEventId event_id);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrEventSetting.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,4 @@\n+inline jlong JfrEventSetting::level(JfrEventId event_id) {\n+  return setting(event_id).miscellaneous;\n+}\n+\n@@ -47,1 +51,1 @@\n-  return setting(event_id).cutoff_ticks;\n+  return setting(event_id).miscellaneous;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrEventSetting.inline.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,0 +80,4 @@\n+bool JfrRecorder::is_started_on_commandline() {\n+  return StartFlightRecording != nullptr;\n+}\n+\n@@ -85,0 +89,3 @@\n+\/\/ Subsystem\n+static JfrCheckpointManager* _checkpoint_manager = nullptr;\n+\n@@ -87,1 +94,1 @@\n-    if (FlightRecorder || StartFlightRecording != nullptr) {\n+    if (FlightRecorder || is_started_on_commandline()) {\n@@ -94,0 +101,6 @@\n+\n+  _checkpoint_manager = JfrCheckpointManager::create();\n+  if (_checkpoint_manager == nullptr || !_checkpoint_manager->initialize_early()) {\n+    return false;\n+  }\n+\n@@ -306,1 +319,0 @@\n-static JfrCheckpointManager* _checkpoint_manager = nullptr;\n@@ -348,1 +360,1 @@\n-  assert(_checkpoint_manager == nullptr, \"invariant\");\n+  assert(_checkpoint_manager != nullptr, \"invariant\");\n@@ -350,2 +362,1 @@\n-  _checkpoint_manager = JfrCheckpointManager::create(_repository->chunkwriter());\n-  return _checkpoint_manager != nullptr && _checkpoint_manager->initialize();\n+  return _checkpoint_manager->initialize(&_repository->chunkwriter());\n@@ -393,1 +404,1 @@\n-    _checkpoint_manager = nullptr;\n+    \/\/ do not delete the _checkpoint_manager instance\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,0 @@\n-  static bool create(bool simulate_failure);\n@@ -66,0 +65,2 @@\n+  static bool is_started_on_commandline();\n+  static bool create(bool simulate_failure);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"jfr\/support\/jfrDeprecationManager.hpp\"\n@@ -434,0 +435,1 @@\n+  JfrDeprecationManager::on_recorder_stop();\n@@ -481,0 +483,1 @@\n+  JfrDeprecationManager::on_safepoint_clear();\n@@ -509,0 +512,1 @@\n+    JfrDeprecationManager::write_events(_chunkwriter, thread, true);\n@@ -591,0 +595,1 @@\n+  JfrDeprecationManager::on_safepoint_write();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,0 @@\n-  void scavenge();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -246,0 +246,5 @@\n+\n+traceid JfrStackTraceRepository::next_id() {\n+  MutexLocker lock(JfrStacktrace_lock, Mutex::_no_safepoint_check_flag);\n+  return ++_next_id;\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+  friend class JfrDeprecatedEdge;\n@@ -67,0 +68,2 @@\n+  static traceid next_id();\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfrfiles\/jfrEventClasses.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/jfrCheckpointManager.hpp\"\n+#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n+#include \"jfr\/recorder\/repository\/jfrChunkWriter.hpp\"\n+#include \"jfr\/support\/jfrDeprecationEventWriter.hpp\"\n+#include \"jfr\/support\/jfrDeprecationManager.hpp\"\n+#include \"jfr\/support\/jfrThreadLocal.hpp\"\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"jfr\/writers\/jfrBigEndianWriter.hpp\"\n+\n+\/\/ This dual state machine for the level setting is because when multiple recordings are running,\n+\/\/ and one of them stops, the newly calculated settings for level is updated before the chunk rotates.\n+\/\/ But we need remember what the level setting was before the recording stopped.\n+constexpr const int64_t uninitialized = -1;\n+static int64_t _previous_level_setting = uninitialized;\n+static int64_t _current_level_setting = uninitialized;\n+\n+void JfrDeprecatedEventWriterState::on_initialization() {\n+  _previous_level_setting = uninitialized;\n+  _current_level_setting = uninitialized;\n+}\n+\n+void JfrDeprecatedEventWriterState::on_level_setting_update(int64_t new_level) {\n+  _previous_level_setting = _current_level_setting;\n+  _current_level_setting = new_level;\n+}\n+\n+static inline bool level() {\n+  assert(_current_level_setting != uninitialized, \"invariant\");\n+  return _previous_level_setting == uninitialized ? _current_level_setting : _previous_level_setting;\n+}\n+\n+static inline bool only_for_removal() {\n+  assert(JfrEventSetting::is_enabled(JfrDeprecatedInvocationEvent), \"invariant\");\n+  \/\/ level 0: forRemoval, level 1: = all\n+  return level() == 0;\n+}\n+\n+JfrDeprecatedBlobConstruction::JfrDeprecatedBlobConstruction(JavaThread* jt) : JfrDeprecatedEventWriterBase(jt) {\n+  assert(this->is_acquired(), \"invariant\");\n+  assert(0 == this->current_offset(), \"invariant\");\n+  assert(this->available_size() > 255, \"invariant\");\n+}\n+\n+JfrBlobHandle JfrDeprecatedBlobConstruction::event(const JfrDeprecatedEdge* edge, bool stacktrace) {\n+  assert(edge != nullptr, \"invariant\");\n+  assert(this->used_offset() == 0, \"invariant\");\n+  _size_pos = this->reserve(sizeof(u1));\n+  this->write(JfrDeprecatedInvocationEvent);\n+  this->write(JfrTicks::now());\n+  this->write(stacktrace ? edge->stacktrace_id() : 0);\n+  this->write(edge->deprecated_methodid());\n+  this->write(edge->for_removal());\n+  const size_t event_size = this->used_size();\n+  assert(event_size < 255, \"invariant\");\n+  write_at_offset(event_size, _size_pos);\n+  JfrBlobHandle blob = JfrBlob::make(this->start_pos(), event_size);\n+  this->reset();\n+  return blob;\n+}\n+\n+JfrBlobHandle JfrDeprecatedBlobConstruction::stacktrace(const JfrDeprecatedEdge* edge) {\n+  assert(edge != nullptr, \"invariant\");\n+  assert(this->used_offset() == 0, \"invariant\");\n+  this->write(edge->stacktrace_id());\n+  this->write(true); \/\/ truncated\n+  this->write(1); \/\/ number of frames\n+  this->write(edge->sender_methodid());\n+  this->write<u4>(edge->linenumber());\n+  this->write<u4>(edge->bci());\n+  this->write<u1>(edge->frame_type());\n+  JfrBlobHandle blob = JfrBlob::make(this->start_pos(), this->used_size());\n+  this->reset();\n+  return blob;\n+}\n+\n+\/\/ This op will collapse all individual stacktrace blobs into a single TYPE_STACKTRACE checkpoint.\n+JfrDeprecatedStackTraceWriter::JfrDeprecatedStackTraceWriter(JfrChunkWriter& cw) :\n+  _cw(cw), _begin_offset(cw.current_offset()), _elements_offset(0), _processed(0), _elements(0), _for_removal(only_for_removal()) {\n+    const int64_t last_checkpoint = cw.last_checkpoint_offset();\n+    const int64_t delta = last_checkpoint == 0 ? 0 : last_checkpoint - _begin_offset;\n+    cw.reserve(sizeof(uint64_t));\n+    cw.write(EVENT_CHECKPOINT);\n+    cw.write(JfrTicks::now().value());\n+    cw.write(0);\n+    cw.write(delta);\n+    cw.write(GENERIC); \/\/ Generic checkpoint type.\n+    cw.write(1); \/\/ Number of types in this checkpoint, only one, TYPE_STACKTRACE.\n+    cw.write(TYPE_STACKTRACE); \/\/ Constant pool type.\n+    _elements_offset = cw.current_offset(); \/\/ Offset for the number of entries in the TYPE_STACKTRACE constant pool.\n+    cw.reserve(sizeof(uint32_t));\n+}\n+\n+JfrDeprecatedStackTraceWriter::~JfrDeprecatedStackTraceWriter() {\n+  if (_elements == 0) {\n+    \/\/ Rewind.\n+    _cw.seek(_begin_offset);\n+    return;\n+  }\n+  const int64_t event_size = _cw.current_offset() - _begin_offset;\n+  _cw.write_padded_at_offset(_elements, _elements_offset);\n+  _cw.write_padded_at_offset(event_size, _begin_offset);\n+  _cw.set_last_checkpoint_offset(_begin_offset);\n+}\n+\n+bool JfrDeprecatedStackTraceWriter::process(const JfrDeprecatedEdge* edge) {\n+  assert(edge != nullptr, \"invariant\");\n+  assert(edge->has_stacktrace(), \"invariant\");\n+  if (_for_removal && !edge->for_removal()) {\n+    return true;\n+  }\n+  ++_elements;\n+  edge->stacktrace()->write(_cw);\n+  _processed += edge->stacktrace()->size();\n+  return true;\n+}\n+\n+static inline void write_event(const JfrDeprecatedEdge* edge, JfrChunkWriter& cw, bool has_stacktrace) {\n+  assert(edge != nullptr, \"invariant\");\n+  assert(edge->has_event(), \"invariant\");\n+  if (has_stacktrace) {\n+    edge->event()->write(cw);\n+    return;\n+  }\n+  edge->event_no_stacktrace()->write(cw);\n+}\n+\n+JfrDeprecatedEventWriter::JfrDeprecatedEventWriter(JfrChunkWriter& cw, bool stacktrace) :\n+  _cw(cw), _for_removal(only_for_removal()), _stacktrace(stacktrace), _did_write(false) {}\n+\n+bool JfrDeprecatedEventWriter::process(const JfrDeprecatedEdge* edge) {\n+  assert(edge != nullptr, \"invariant\");\n+  if (_for_removal && !edge->for_removal()) {\n+    return true;\n+  }\n+  write_event(edge, _cw, _stacktrace);\n+  if (!_did_write) {\n+    _did_write = true;\n+  }\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationEventWriter.cpp","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRDEPRECATIONEVENTWRITER_HPP\n+#define SHARE_JFR_SUPPORT_JFRDEPRECATIONEVENTWRITER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"jfr\/utilities\/jfrBlob.hpp\"\n+#include \"jfr\/writers\/jfrEventWriterHost.inline.hpp\"\n+#include \"jfr\/writers\/jfrMemoryWriterHost.inline.hpp\"\n+#include \"jfr\/writers\/jfrStorageAdapter.hpp\"\n+\n+class JfrChunkWriter;\n+class JfrDeprecatedEdge;\n+\n+typedef AcquireReleaseMemoryWriterHost<MallocAdapter<>, StackObj> JfrTransactionalDeprecatedEventWriter;\n+typedef EventWriterHost<BigEndianEncoder, CompressedIntegerEncoder, JfrTransactionalDeprecatedEventWriter> JfrDeprecatedEventWriterBase;\n+\n+class JfrDeprecatedBlobConstruction : public JfrDeprecatedEventWriterBase {\n+ private:\n+  uint64_t _size_pos;\n+ public:\n+  JfrDeprecatedBlobConstruction(JavaThread* jt);\n+  JfrBlobHandle stacktrace(const JfrDeprecatedEdge* edge);\n+  JfrBlobHandle event(const JfrDeprecatedEdge* edge, bool stacktrace);\n+};\n+\n+\/\/ This writer will collapse all individual stacktrace blobs into a single TYPE_STACKTRACE checkpoint.\n+class JfrDeprecatedStackTraceWriter : public StackObj{\n+ private:\n+  JfrChunkWriter& _cw;\n+  int64_t _begin_offset;\n+  int64_t _elements_offset;\n+  size_t _processed;\n+  uint32_t _elements;\n+  bool _for_removal;\n+ public:\n+  JfrDeprecatedStackTraceWriter(JfrChunkWriter& cw);\n+  ~JfrDeprecatedStackTraceWriter();\n+  size_t elements() const { return _elements; }\n+  size_t processed() const { return _processed; }\n+  bool process(const JfrDeprecatedEdge* edge);\n+};\n+\n+class JfrDeprecatedEventWriter : public StackObj {\n+ private:\n+  JfrChunkWriter& _cw;\n+  bool _for_removal;\n+  bool _stacktrace;\n+  bool _did_write;\n+ public:\n+  JfrDeprecatedEventWriter(JfrChunkWriter& cw, bool stacktrace);\n+  bool did_write() const { return _did_write; }\n+  bool process(const JfrDeprecatedEdge* edge);\n+};\n+\n+class JfrDeprecatedEventWriterState : AllStatic {\n+ public:\n+  static void on_initialization();\n+  static void on_level_setting_update(int64_t new_level);\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRDEPRECATIONEVENTWRITER_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationEventWriter.hpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,371 @@\n+\/*\n+* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"jfrfiles\/jfrEventIds.hpp\"\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n+#include \"jfr\/recorder\/jfrEventSetting.inline.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/jfrCheckpointWriter.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"jfr\/recorder\/repository\/jfrChunkWriter.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp\"\n+#include \"jfr\/support\/jfrDeprecationEventWriter.hpp\"\n+#include \"jfr\/support\/jfrDeprecationManager.hpp\"\n+#include \"jfr\/support\/jfrKlassUnloading.hpp\"\n+#include \"jfr\/support\/jfrMethodData.hpp\"\n+#include \"jfr\/support\/jfrMethodLookup.hpp\"\n+#include \"jfr\/utilities\/jfrBlob.hpp\"\n+#include \"jfr\/utilities\/jfrLinkedList.inline.hpp\"\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n+#include \"memory\/resourceArea.inline.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"oops\/method.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+\n+\/\/ for strstr\n+#include <string.h>\n+\n+static bool _enqueue_klasses = false;\n+\n+void JfrDeprecationManager::on_recorder_stop() {\n+  _enqueue_klasses = false;\n+}\n+\n+static inline traceid load_traceid(const Method* method) {\n+  assert(method != nullptr, \"invariant\");\n+  \/\/ If the Jfr system is not yet running we only tag the artifacts, not enqueuing klasses.\n+  return _enqueue_klasses ? JfrTraceId::load(method) : JfrTraceId::load_no_enqueue(method);\n+}\n+\n+JfrDeprecatedEdge::JfrDeprecatedEdge(const Method* method, Method* sender, int bci, u1 frame_type, JavaThread* jt) :\n+  _starttime(JfrTicks::now()),\n+  _event(),\n+  _event_no_stacktrace(),\n+  _stacktrace(),\n+  _next(nullptr),\n+  _deprecated_ik(method->method_holder()),\n+  _deprecated_methodid(load_traceid(method)),\n+  _sender_ik(sender->method_holder()),\n+  _sender_methodid(load_traceid(sender)),\n+  \/\/ Our stacktrace will be hand-rolled into a blob.\n+  \/\/ We don't need anything from the stacktrace\n+  \/\/ subsystem except for a unique id.\n+  _stack_trace_id(JfrStackTraceRepository::next_id()),\n+  _bci(bci),\n+  _linenumber(sender->line_number_from_bci(bci)),\n+  _frame_type(frame_type),\n+  _for_removal(method->deprecated_for_removal()) {}\n+\n+bool JfrDeprecatedEdge::has_event() const {\n+  return _event.valid();\n+}\n+\n+const JfrBlobHandle& JfrDeprecatedEdge::event() const {\n+  assert(has_event(), \"invariant\");\n+  return _event;\n+}\n+\n+const JfrBlobHandle& JfrDeprecatedEdge::event_no_stacktrace() const {\n+  assert(_event_no_stacktrace.valid(), \"invariant\");\n+  return _event_no_stacktrace;\n+}\n+\n+bool JfrDeprecatedEdge::has_stacktrace() const {\n+  return _stacktrace.valid();\n+}\n+\n+const JfrBlobHandle& JfrDeprecatedEdge::stacktrace() const {\n+  assert(has_stacktrace(), \"invariant\");\n+  return _stacktrace;\n+}\n+\n+typedef JfrLinkedList<JfrDeprecatedEdge> DeprecatedEdgeList;\n+\n+static DeprecatedEdgeList _list; \/\/ Newly constructed edges are concurrently added to this list.\n+static DeprecatedEdgeList _pending_list; \/\/ During epoch rotation (safepoint) entries in _list are moved onto _pending_list\n+static DeprecatedEdgeList _resolved_list; \/\/ Fully resolved edges (event and stacktrace blobs).\n+\n+static JfrDeprecatedEdge* allocate_edge(const Method* method, Method* sender, int bci, u1 frame_type, JavaThread* jt) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt);)\n+  assert(method != nullptr, \"invariant\");\n+  assert(method->deprecated(), \"invariant\");\n+  assert(sender != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  return new JfrDeprecatedEdge(method, sender, bci, frame_type, jt);\n+}\n+\n+static void create_edge(const Method* method, Method* sender, int bci, u1 frame_type, JavaThread* jt) {\n+  JfrDeprecatedEdge* edge;\n+  \/\/ We need the JavaThread to be in _thread_in_vm when creating the edge.\n+  \/\/ This is because the method artifacts needs to be tagged in the correct epoch.\n+  if (jt->thread_state() != _thread_in_vm) {\n+    assert(jt->is_Compiler_thread(), \"invariant\");\n+    \/\/ Can safepoint here.\n+    ThreadInVMfromNative transition(jt);\n+    edge = allocate_edge(method, sender, bci, frame_type, jt);\n+  } else {\n+    edge = allocate_edge(method, sender, bci, frame_type, jt);\n+  }\n+  _list.add(edge);\n+}\n+\n+static inline bool jfr_is_started_on_command_line() {\n+  return JfrRecorder::is_started_on_commandline();\n+}\n+\n+\/*\n+ * Two cases for JDK modules as outlined by JEP 200: The Modular JDK.\n+ *\n+ * The modular structure of the JDK implements the following principles:\n+ * 1. Standard modules, whose specifications are governed by the JCP, have names starting with the string \"java.\".\n+ * 2. All other modules are merely part of the JDK, and have names starting with the string \"jdk.\".\n+ * *\/\n+static inline bool is_jdk_module(const char* module_name) {\n+  assert(module_name != nullptr, \"invariant\");\n+  return strstr(module_name, \"java.\") == module_name || strstr(module_name, \"jdk.\") == module_name;\n+}\n+\n+static inline bool is_unnamed_module(const ModuleEntry* module) {\n+  return module == nullptr || !module->is_named();\n+}\n+\n+static inline bool is_jdk_module(const ModuleEntry* module, JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  if (is_unnamed_module(module)) {\n+    return false;\n+  }\n+  ResourceMark rm(jt);\n+  const Symbol* const module_symbol = module->name();\n+  assert(module_symbol != nullptr, \"invariant\");\n+  const char* const module_name = module_symbol->as_C_string();\n+  return is_jdk_module(module_name);\n+}\n+\n+static bool should_report(const Method* method, const Method* sender, JavaThread* jt) {\n+  assert(method != nullptr, \"invariant\");\n+  assert(method->deprecated(), \"invariant\");\n+  assert(sender != nullptr, \"invariant\");\n+  assert(!sender->is_native(), \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(jfr_is_started_on_command_line(), \"invariant\");\n+  const ModuleEntry* const deprecated_module = method->method_holder()->module();\n+  if (!is_jdk_module(deprecated_module, jt)) {\n+    \/\/ Only report invoked deprecated methods in the JDK.\n+    return false;\n+  }\n+  const ModuleEntry* const sender_module = sender->method_holder()->module();\n+  \/\/ Only report senders not in the JDK.\n+  return !is_jdk_module(sender_module, jt);\n+}\n+\n+\/\/ This is the entry point for newly discovered edges in JfrResolution.cpp.\n+void JfrDeprecationManager::on_link(const Method* method, Method* sender, int bci, u1 frame_type, JavaThread* jt) {\n+  assert(method != nullptr, \"invariant\");\n+  assert(method->deprecated(), \"invariant\");\n+  assert(sender != nullptr, \"invariant\");\n+  assert(!sender->is_native(), \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(JfrRecorder::is_started_on_commandline(), \"invariant\");\n+  if (JfrMethodData::mark_deprecated_call_site(sender, bci, jt)) {\n+    if (should_report(method, sender, jt)) {\n+      create_edge(method, sender, bci, frame_type, jt);\n+    }\n+  }\n+}\n+\n+static void transfer_list() {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+  assert(_pending_list.is_empty(), \"invariant\");\n+  DeprecatedEdgeList::NodePtr head = _list.cut();\n+  assert(_list.is_empty(), \"invariant\");\n+  if (head != nullptr) {\n+    _pending_list.add_list(head);\n+  }\n+}\n+\n+void JfrDeprecationManager::on_level_setting_update(int64_t new_level) {\n+  JfrDeprecatedEventWriterState::on_level_setting_update(new_level);\n+}\n+\n+void JfrDeprecationManager::on_safepoint_clear() {\n+  assert(!_enqueue_klasses, \"invariant\");\n+  \/\/ We are now starting JFR, so begin enqueuing tagged klasses.\n+  _enqueue_klasses = true;\n+  JfrDeprecatedEventWriterState::on_initialization();\n+  transfer_list();\n+}\n+\n+void JfrDeprecationManager::on_safepoint_write() {\n+  assert(_enqueue_klasses, \"invariant\");\n+  transfer_list();\n+}\n+\n+static bool is_klass_unloaded(traceid klass_id) {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  return JfrKlassUnloading::is_unloaded(klass_id, true);\n+}\n+\n+static void add_to_leakp_set(const InstanceKlass* ik, traceid method_id) {\n+  \/\/ The lock is needed to ensure the klass unloading lists do not grow in the middle of inspection.\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  assert(ik != nullptr, \"invariant\");\n+  if (is_klass_unloaded(JfrMethodLookup::klass_id(method_id))) {\n+    return;\n+  }\n+  const Method* const method = JfrMethodLookup::lookup(ik, method_id);\n+  assert(method != nullptr, \"invariant\");\n+  assert(method->method_holder() == ik, \"invariant\");\n+  JfrTraceId::load_leakp_previous_epoch(ik, method); \/\/ now has the leakp marker\n+}\n+\n+static void add_to_leakp_set(const JfrDeprecatedEdge* edge) {\n+  assert(edge != nullptr, \"invariant\");\n+  add_to_leakp_set(edge->deprecated_ik(), edge->deprecated_methodid());\n+  add_to_leakp_set(edge->sender_ik(), edge->sender_methodid());\n+}\n+\n+\/\/ Creates and install blobs.\n+void JfrDeprecatedEdge::install_blobs(JavaThread* jt) {\n+  assert(!has_event(), \"invariant\");\n+  assert(!has_stacktrace(), \"invariant\");\n+  JfrDeprecatedBlobConstruction bc(jt);\n+  _stacktrace = bc.stacktrace(this);\n+  _event = bc.event(this, true);\n+  _event_no_stacktrace = bc.event(this, false);\n+}\n+\n+\/\/ Keeps track of nodes processed from the _pending_list.\n+static DeprecatedEdgeList::NodePtr _pending_head = nullptr;\n+static DeprecatedEdgeList::NodePtr _pending_tail = nullptr;\n+\n+class PendingListProcessor {\n+ private:\n+  JavaThread* _jt;\n+ public:\n+  PendingListProcessor(JavaThread* jt) : _jt(jt) {}\n+  bool process(DeprecatedEdgeList::NodePtr edge) {\n+    assert(edge != nullptr, \"invariant\");\n+    edge->install_blobs(_jt);\n+    add_to_leakp_set(edge);\n+    if (_pending_head == nullptr) {\n+      _pending_head = edge;\n+    }\n+    _pending_tail = edge;\n+    return true;\n+  }\n+};\n+\n+void JfrDeprecationManager::prepare_type_set(JavaThread* jt) {\n+  _pending_head = nullptr;\n+  _pending_tail = nullptr;\n+  if (_pending_list.is_nonempty()) {\n+    JfrKlassUnloading::sort(true);\n+    PendingListProcessor plp(jt);\n+    _pending_list.iterate(plp);\n+    assert(_pending_head != nullptr, \"invariant\");\n+    assert(_pending_tail != nullptr, \"invariant\");\n+    assert(_pending_tail->next() == nullptr, \"invariant\");\n+    \/\/ Excise already resolved edges to link them.\n+    _pending_tail->set_next(_resolved_list.cut());\n+    \/\/ Re-insertion.\n+    _resolved_list.add_list(_pending_head);\n+    _pending_list.clear();\n+  }\n+  assert(_pending_list.is_empty(), \"invariant\");\n+}\n+\n+\/\/ A linked-list of blob handles.\n+static JfrBlobHandle type_set_blobs;\n+\n+static inline void write_type_set_blobs(JfrCheckpointWriter& writer) {\n+  type_set_blobs->write(writer);\n+}\n+\n+static void save_type_set_blob(JfrCheckpointWriter& writer) {\n+  assert(writer.has_data(), \"invariant\");\n+  const JfrBlobHandle blob = writer.copy();\n+  if (type_set_blobs.valid()) {\n+    type_set_blobs->set_next(blob);\n+  } else {\n+    type_set_blobs = blob;\n+  }\n+}\n+\n+void JfrDeprecationManager::on_type_set_unload(JfrCheckpointWriter& writer) {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  if (writer.has_data()) {\n+    save_type_set_blob(writer);\n+  }\n+}\n+\n+static inline bool stacktrace_is_enabled() {\n+  return JfrEventSetting::has_stacktrace(JfrDeprecatedInvocationEvent);\n+}\n+\n+static inline bool write_events(JfrChunkWriter& cw) {\n+  assert(_resolved_list.is_nonempty(), \"invariant\");\n+  JfrDeprecatedEventWriter ebw(cw, stacktrace_is_enabled());\n+  _resolved_list.iterate(ebw);\n+  return ebw.did_write();\n+}\n+\n+static inline void write_stacktraces(JfrChunkWriter& cw) {\n+  if (stacktrace_is_enabled()) {\n+    JfrDeprecatedStackTraceWriter scw(cw);\n+    _resolved_list.iterate(scw);\n+  }\n+}\n+\n+\/\/ First, we consolidate all stacktrace blobs into a single TYPE_STACKTRACE checkpoint and serialize it to the chunk.\n+\/\/ Secondly, we serialize all event blobs to the chunk.\n+\/\/ Thirdly, the type set blobs are written into the JfrCheckpoint system, to be serialized to the chunk\n+\/\/ just after we return from here.\n+static void write_edges(JfrChunkWriter& cw, Thread* thread, bool on_error) {\n+  write_stacktraces(cw);\n+  if (write_events(cw)) {\n+    JfrCheckpointWriter writer(!on_error, false, thread);\n+    write_type_set_blobs(writer);\n+  }\n+}\n+\n+void JfrDeprecationManager::write_events(JfrChunkWriter& cw, Thread* thread, bool on_error \/* false *\/) {\n+  if (JfrEventSetting::is_enabled(JfrDeprecatedInvocationEvent)) {\n+    if (_resolved_list.is_nonempty()) {\n+      write_edges(cw, thread, on_error);\n+    }\n+  }\n+}\n+\n+void JfrDeprecationManager::on_type_set(JfrCheckpointWriter& writer, JfrChunkWriter* cw, Thread* thread) {\n+  assert(_pending_list.is_empty(), \"invariant\");\n+  if (writer.has_data() && _pending_head != nullptr) {\n+    save_type_set_blob(writer);\n+  }\n+  if (cw != nullptr) {\n+    write_events(*cw, thread);\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.cpp","additions":371,"deletions":0,"binary":false,"changes":371,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+* Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRDEPRECATIONMANAGER_HPP\n+#define SHARE_JFR_SUPPORT_JFRDEPRECATIONMANAGER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"jfr\/utilities\/jfrBlob.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+\n+class JavaThread;\n+class JfrChunkWriter;\n+class JfrCheckpointWriter;\n+class Method;\n+class Thread;\n+\n+class JfrDeprecatedEdge : public CHeapObj<mtTracing> {\n+  template<typename, typename>\n+  friend class JfrLinkedList;\n+ private:\n+  JfrTicks _starttime;\n+  JfrBlobHandle _event;\n+  JfrBlobHandle _event_no_stacktrace;\n+  JfrBlobHandle _stacktrace;\n+  JfrDeprecatedEdge* _next;\n+  InstanceKlass* _deprecated_ik;\n+  traceid _deprecated_methodid;\n+  InstanceKlass* _sender_ik;\n+  traceid _sender_methodid;\n+  traceid _stack_trace_id;\n+  int _bci;\n+  int _linenumber;\n+  u1 _frame_type;\n+  bool _for_removal;\n+\n+ public:\n+  JfrDeprecatedEdge(const Method* method, Method* sender, int bci, u1 frame_type, JavaThread* jt);\n+\n+  const JfrDeprecatedEdge* next() const { return _next; }\n+  void set_next(JfrDeprecatedEdge* edge) { _next = edge; }\n+\n+  bool has_event() const;\n+  const JfrBlobHandle& event() const;\n+  const JfrBlobHandle& event_no_stacktrace() const;\n+  bool has_stacktrace() const;\n+  const JfrBlobHandle& stacktrace() const;\n+  void install_blobs(JavaThread* jt);\n+\n+  const InstanceKlass* deprecated_ik() const { return _deprecated_ik; }\n+  traceid deprecated_methodid() const { return _deprecated_methodid; }\n+\n+  const InstanceKlass* sender_ik() const { return _sender_ik; }\n+  traceid sender_methodid() const { return _sender_methodid; }\n+\n+  const JfrTicks& starttime() const { return _starttime; }\n+  traceid stacktrace_id() const { return _stack_trace_id; }\n+\n+  int bci() const { return _bci; }\n+  u1 frame_type() const { return _frame_type; }\n+  bool for_removal() const { return _for_removal; }\n+  int linenumber() const { return _linenumber; }\n+};\n+\n+class JfrDeprecationManager : AllStatic {\n+ public:\n+  static void on_safepoint_clear();\n+  static void on_safepoint_write();\n+  static void on_recorder_stop();\n+  static void prepare_type_set(JavaThread* jt);\n+  static void on_type_set(JfrCheckpointWriter& writer, JfrChunkWriter* cw, Thread* thread);\n+  static void on_type_set_unload(JfrCheckpointWriter& writer);\n+  static void write_events(JfrChunkWriter& cw, Thread* thread, bool on_error = false);\n+  static void on_link(const Method* method, Method* sender, int bci, u1 frame_type, JavaThread* thread);\n+  static void on_level_setting_update(int64_t new_level);\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRDEPRECATIONMANAGER_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.hpp","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jfr\/support\/jfrMethodData.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/method.inline.hpp\"\n+#include \"oops\/methodData.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+\n+ \/\/ Caller requires ResourceMark.\n+static inline BitData* get_bit_data(MethodData* mdo, int bci) {\n+  assert(mdo != nullptr, \"invariant\");\n+  BitData* const bit_data = static_cast<BitData*>(mdo->bci_to_data(bci));\n+  assert(bit_data != nullptr, \"invariant\");\n+  assert(bit_data->is_VirtualCallData() || bit_data->is_VirtualCallTypeData() ||\n+    bit_data->is_CounterData() || bit_data->is_CallTypeData(), \"invariant\");\n+  return bit_data;\n+}\n+\n+static inline MethodData* build_mdo(Method* method, JavaThread* jt) {\n+  methodHandle method_handle(jt, method);\n+  Method::build_profiling_method_data(method_handle, jt);\n+  return method->method_data();\n+}\n+\n+static inline MethodData* get_mdo(Method* method, JavaThread* jt) {\n+  MethodData* mdo = method->method_data();\n+  return mdo != nullptr ? mdo : build_mdo(method, jt);\n+}\n+\n+static bool mark_mdo(Method* method, int bci, JavaThread* jt) {\n+  assert(method != nullptr, \"invariant\");\n+  assert(!method->is_native(), \"native methods have no MDO bit data\");\n+  assert(jt != nullptr, \"invariant\");\n+  MethodData* mdo = get_mdo(method, jt);\n+  assert(mdo != nullptr, \"invariant\");\n+  \/\/ Get the datalayout for the invocation bci.\n+  BitData* const bit_data = get_bit_data(mdo, bci);\n+  \/\/ Returns true if this callsite is not yet linked and\n+  \/\/ our attempt to set the deprecated flag was succesful.\n+  if (bit_data->set_deprecated_method_call_site()) {\n+    assert(bit_data->deprecated_method_call_site(), \"invariant\");\n+    return true;\n+  }\n+  assert(bit_data->deprecated_method_call_site(), \"invariant\");\n+  return false;\n+}\n+\n+bool JfrMethodData::mark_deprecated_call_site(Method* method, int bci, JavaThread* jt) {\n+  assert(method != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(method->validate_bci(bci) >= 0, \"invariant\");\n+  ResourceMark rm(jt);\n+  return mark_mdo(method, bci, jt);\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrMethodData.cpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRMETHODDATA_HPP\n+#define SHARE_JFR_SUPPORT_JFRMETHODDATA_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class Method;\n+class JavaThread;\n+\n+class JfrMethodData : AllStatic {\n+ public:\n+  static bool mark_deprecated_call_site(Method* method, int bci, JavaThread* jt);\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRMETHODDATA_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrMethodData.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -35,1 +35,3 @@\n-  delete _start_time;\n+  if (_start_time != nullptr) {\n+    delete _start_time;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrNativeLibraryLoadEvent.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"ci\/ciKlass.hpp\"\n+#include \"ci\/ciMethod.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"interpreter\/linkResolver.hpp\"\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdMacros.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackTrace.hpp\"\n+#include \"jfr\/support\/jfrDeprecationManager.hpp\"\n+#include \"jfr\/support\/jfrResolution.hpp\"\n+#include \"memory\/resourceArea.inline.hpp\"\n+#include \"oops\/method.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/vframe.inline.hpp\"\n+#ifdef COMPILER1\n+#include \"c1\/c1_GraphBuilder.hpp\"\n+#endif\n+#ifdef COMPILER2\n+#include \"opto\/parse.hpp\"\n+#endif\n+\n+ \/\/ for strstr\n+#include <string.h>\n+\n+static constexpr const int NUM_FILTERS = 4;\n+\n+static constexpr const char* filters[NUM_FILTERS] = {\n+                                                      \"java\/lang\/invoke\/\",\n+                                                      \"jdk\/internal\/reflect\/\",\n+                                                      \"java\/lang\/reflect\/\",\n+                                                      \"sun\/invoke\/\"\n+                                                    };\n+\n+static const char* const link_error_msg = \"illegal access linking method 'jdk.jfr.internal.event.EventWriterFactory.getEventWriter(long)'\";\n+\n+static inline bool match(const char* str, const char* sub_str) {\n+  assert(str != nullptr, \"invariant\");\n+  assert(sub_str != nullptr, \"invariant\");\n+  return strstr(str, sub_str) == str;\n+}\n+\n+static inline bool exclude(const Method* method) {\n+  assert(method != nullptr, \"invariant\");\n+  \/\/ exclude native methods.\n+  if (method->is_native()) {\n+    return true;\n+  }\n+  const Klass* const klass = method->method_holder();\n+  assert(klass != nullptr, \"invariant\");\n+  const Symbol* const klass_sym = klass->name();\n+  assert(klass_sym != nullptr, \"invariant\");\n+  const char* const klass_name = klass_sym->as_C_string();\n+  assert(klass_name != nullptr, \"invariant\");\n+  for (int i = 0; i < NUM_FILTERS; ++i) {\n+    if (match(klass_name, filters[i])) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ If the caller into resolution is native, it must be java\/lang\/invoke\/MethodHandleNatives.resolve().\n+\/\/ Find the real caller.\n+static Method* locate_real_caller(vframeStream& stream, JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  assert(stream.method()->is_native(), \"invariant\");\n+  ResourceMark rm(jt);\n+  assert(strcmp(stream.method()->name()->as_C_string(), \"resolve\") == 0, \"invariant\");\n+  assert(strcmp(stream.method()->method_holder()->name()->as_C_string(), \"java\/lang\/invoke\/MethodHandleNatives\") == 0, \"invariant\");\n+  stream.next();\n+  while (!stream.at_end()) {\n+    if (!exclude(stream.method())) {\n+      break;\n+    }\n+    stream.next();\n+  }\n+  return stream.method();\n+}\n+\n+static inline bool jfr_is_started_on_command_line() {\n+  return JfrRecorder::is_started_on_commandline();\n+}\n+\n+static inline Method* frame_context(vframeStream& stream, int& bci, u1& frame_type, JavaThread* jt) {\n+  Method* method = stream.method();\n+  assert(method != nullptr, \"invariant\");\n+  if (method->is_native()) {\n+    method = locate_real_caller(stream, jt);\n+  }\n+  assert(method != nullptr, \"invariant\");\n+  assert(!method->is_native(), \"invariant\");\n+  bci = stream.bci();\n+  frame_type = stream.is_interpreted_frame() ? JfrStackFrame::FRAME_INTERPRETER : JfrStackFrame::FRAME_JIT;\n+  if (frame_type == JfrStackFrame::FRAME_JIT) {\n+    const intptr_t* const id = stream.frame_id();\n+    stream.next();\n+    if (!stream.at_end() && id == stream.frame_id()) {\n+      frame_type = JfrStackFrame::FRAME_INLINE;\n+    }\n+  }\n+  return method;\n+}\n+\n+static inline Method* ljf_sender_method(int& bci, u1& frame_type, JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  if (!jt->has_last_Java_frame()) {\n+    return nullptr;\n+  }\n+  vframeStream stream(jt, true, false);\n+  return frame_context(stream, bci, frame_type, jt);\n+}\n+\n+static inline void on_runtime_deprecated(const Method* method, JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  assert(method != nullptr, \"invariant\");\n+  assert(method->deprecated(), \"invariant\");\n+  if (jfr_is_started_on_command_line()) {\n+    int bci;\n+    u1 frame_type;\n+    Method* const sender = ljf_sender_method(bci, frame_type, jt);\n+    if (sender == nullptr) {\n+      return;\n+    }\n+    JfrDeprecationManager::on_link(method, sender, bci, frame_type, jt);\n+  }\n+}\n+\n+void JfrResolution::on_deprecated_invocation(const Method* method, JavaThread* jt) {\n+  assert(jt->has_last_Java_frame(), \"Invariant\");\n+  assert(jt->last_frame().is_runtime_frame(), \"invariant\");\n+  if (jfr_is_started_on_command_line()) {\n+    vframeStream stream(jt, true, false);\n+    assert(!stream.at_end(), \"invariant\");\n+    stream.next(); \/\/ now at caller\n+    int bci;\n+    u1 frame_type;\n+    Method* const sender = frame_context(stream, bci, frame_type, jt);\n+    if (sender == nullptr) {\n+      return;\n+    }\n+    JfrDeprecationManager::on_link(method, sender, bci, frame_type, jt);\n+  }\n+}\n+\n+static inline const Method* ljf_sender_method(JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  if (!jt->has_last_Java_frame()) {\n+    return nullptr;\n+  }\n+  const vframeStream ljf(jt, true, false);\n+  return ljf.method();\n+}\n+\n+void JfrResolution::on_runtime_resolution(const CallInfo & info, TRAPS) {\n+  assert(info.selected_method() != nullptr, \"invariant\");\n+  assert(info.resolved_klass() != nullptr, \"invariant\");\n+  static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();\n+  assert(event_writer_method_name != nullptr, \"invariant\");\n+  Method* const method = info.selected_method();\n+  assert(method != nullptr, \"invariant\");\n+  if (method->deprecated()) {\n+    on_runtime_deprecated(method, THREAD);\n+    return;\n+  }\n+  \/\/ Fast path\n+  if (method->name() != event_writer_method_name) {\n+    return;\n+  }\n+  static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();\n+  assert(event_writer_factory_klass_name != nullptr, \"invariant\");\n+  if (info.resolved_klass()->name() != event_writer_factory_klass_name) {\n+    return;\n+  }\n+  \/\/ Attempting to link against jdk.jfr.internal.event.EventWriterFactory.getEventWriter().\n+  \/\/ The sender, i.e. the method attempting to link, is in the ljf (if one exists).\n+  const Method* const sender = ljf_sender_method(THREAD);\n+  if (sender == nullptr) {\n+    \/\/ A compiler thread is doing linktime resolution but there is no information about the sender available.\n+    \/\/ For the compiler threads, the sender is instead found as part of bytecode parsing.\n+    return;\n+  }\n+  \/\/ Is the sender method blessed for linkage?\n+  if (IS_METHOD_BLESSED(sender)) {\n+    return;\n+  }\n+#if INCLUDE_JVMCI\n+  \/\/ JVMCI compiler is doing linktime resolution\n+  if (sender->method_holder()->name() == vmSymbols::jdk_vm_ci_hotspot_CompilerToVM()) {\n+    if (sender->name()->equals(\"lookupMethodInPool\")) {\n+      return;\n+    }\n+  }\n+#endif\n+  THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), link_error_msg);\n+}\n+\n+static inline bool is_compiler_linking_event_writer(const Symbol* holder, const Symbol* name) {\n+  static const Symbol* const event_writer_factory_klass_name = vmSymbols::jdk_jfr_internal_event_EventWriterFactory();\n+  assert(event_writer_factory_klass_name != nullptr, \"invariant\");\n+  if (holder != event_writer_factory_klass_name) {\n+    return false;\n+  }\n+  static const Symbol* const event_writer_method_name = vmSymbols::getEventWriter_name();\n+  assert(event_writer_method_name != nullptr, \"invariant\");\n+  return name == event_writer_method_name;\n+}\n+\n+static inline bool is_compiler_linking_event_writer(const ciKlass * holder, const ciMethod * target) {\n+  assert(holder != nullptr, \"invariant\");\n+  assert(target != nullptr, \"invariant\");\n+  return is_compiler_linking_event_writer(holder->name()->get_symbol(), target->name()->get_symbol());\n+}\n+\n+static inline void on_compiler_resolve_deprecated(const ciMethod* target, int bci, Method* sender) {\n+  assert(target != nullptr, \"invariant\");\n+  assert(sender != nullptr, \"invariant\");\n+  if (jfr_is_started_on_command_line()) {\n+    const Method* const method = target->get_Method();\n+    assert(method != nullptr, \"Invariant\");\n+    assert(method->deprecated(), \"invariant\");\n+    JfrDeprecationManager::on_link(method, sender, bci, JfrStackFrame::FRAME_JIT, JavaThread::current());\n+  }\n+}\n+\n+#ifdef COMPILER1\n+\/\/ C1\n+void JfrResolution::on_c1_resolution(const GraphBuilder * builder, const ciKlass * holder, const ciMethod * target) {\n+  Method* const sender = builder->method()->get_Method();\n+  if (target->deprecated()) {\n+    on_compiler_resolve_deprecated(target, builder->bci(), sender);\n+    return;\n+  }\n+  if (is_compiler_linking_event_writer(holder, target) && !IS_METHOD_BLESSED(sender)) {\n+    builder->bailout(link_error_msg);\n+  }\n+}\n+#endif\n+\n+#ifdef COMPILER2\n+\/\/ C2\n+void JfrResolution::on_c2_resolution(const Parse * parse, const ciKlass * holder, const ciMethod * target) {\n+  Method* const sender = parse->method()->get_Method();\n+  if (target->deprecated()) {\n+    on_compiler_resolve_deprecated(target, parse->bci(), sender);\n+    return;\n+  }\n+  if (is_compiler_linking_event_writer(holder, target) && !IS_METHOD_BLESSED(sender)) {\n+    parse->C->record_failure(link_error_msg);\n+  }\n+}\n+#endif\n+\n+#if INCLUDE_JVMCI\n+\/\/ JVMCI\n+void JfrResolution::on_jvmci_resolution(const Method* caller, const Method* target, TRAPS) {\n+  if (is_compiler_linking_event_writer(target->method_holder()->name(), target->name())) {\n+    if (caller == nullptr || !IS_METHOD_BLESSED(caller)) {\n+      THROW_MSG(vmSymbols::java_lang_IllegalAccessError(), link_error_msg);\n+    }\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrResolution.cpp","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SUPPORT_JFRRESOLUTION_HPP\n+#define SHARE_SUPPORT_JFRRESOLUTION_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+\n+class CallInfo;\n+class ciKlass;\n+class ciMethod;\n+class GraphBuilder;\n+class JavaThread;\n+class Parse;\n+\n+class JfrResolution : AllStatic {\n+ public:\n+  static void on_runtime_resolution(const CallInfo & info, TRAPS);\n+  static void on_c1_resolution(const GraphBuilder * builder, const ciKlass * holder, const ciMethod * target);\n+  static void on_c2_resolution(const Parse * parse, const ciKlass * holder, const ciMethod * target);\n+  static void on_jvmci_resolution(const Method* caller, const Method* target, TRAPS);\n+  static void on_deprecated_invocation(const Method* deprecated_method, JavaThread* jt);\n+};\n+\n+#endif \/\/ SHARE_SUPPORT_JFRRESOLUTION_HPP\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrResolution.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -60,1 +60,1 @@\n-  assert_lock_strong(ClassLoaderDataGraph_lock);\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n@@ -66,1 +66,1 @@\n-  assert_lock_strong(ClassLoaderDataGraph_lock);\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,3 @@\n+  size_t size() const {\n+    return _size;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrBlob.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+  void add_list(NodePtr first);\n@@ -52,0 +53,2 @@\n+  NodePtr cut();\n+  void clear();\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrLinkedList.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -121,0 +121,21 @@\n+template <typename NodeType, typename AllocPolicy>\n+NodeType* JfrLinkedList<NodeType, AllocPolicy>::cut() {\n+  NodePtr node;\n+  do {\n+    node = head();\n+  } while (Atomic::cmpxchg(&_head, node, (NodeType*)nullptr) != node);\n+  return node;\n+}\n+\n+template <typename NodeType, typename AllocPolicy>\n+void JfrLinkedList<NodeType, AllocPolicy>::clear() {\n+  cut();\n+}\n+\n+\n+template <typename NodeType, typename AllocPolicy>\n+inline void JfrLinkedList<NodeType, AllocPolicy>::add_list(NodeType* first) {\n+  assert(head() == nullptr, \"invariant\");\n+  Atomic::store(&_head, first);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrLinkedList.inline.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -61,0 +61,2 @@\n+   flag(deprecated                , 1 << 19) \\\n+   flag(deprecated_for_removal    , 1 << 20) \\\n","filename":"src\/hotspot\/share\/oops\/constMethodFlags.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -416,1 +416,1 @@\n-  jint int_at(int cp_index) {\n+  jint int_at(int cp_index) const {\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -252,0 +252,6 @@\n+  void set_deprecated() { constMethod()->set_deprecated(); }\n+  bool deprecated() const { return constMethod()->deprecated(); }\n+\n+  void set_deprecated_for_removal() { constMethod()->set_deprecated_for_removal(); }\n+  bool deprecated_for_removal() const { return constMethod()->deprecated_for_removal(); }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -666,3 +666,0 @@\n-  if (CompilerConfig::is_c1_simple_only() && !ProfileInterpreter) {\n-    return no_profile_data;\n-  }\n@@ -989,3 +986,0 @@\n-  if (CompilerConfig::is_c1_simple_only() && !ProfileInterpreter) {\n-    return 0;\n-  }\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-    return _header._struct._flags;\n+    return Atomic::load_acquire(&_header._struct._flags);\n@@ -207,2 +207,26 @@\n-  void set_flag_at(u1 flag_number) {\n-    _header._struct._flags |= (u1)(0x1 << flag_number);\n+  bool set_flag_at(u1 flag_number) {\n+    const u1 bit = 1 << flag_number;\n+    u1 compare_value;\n+    do {\n+      compare_value = _header._struct._flags;\n+      if ((compare_value & bit) == bit) {\n+        \/\/ already set.\n+        return false;\n+      }\n+    } while (compare_value != Atomic::cmpxchg(&_header._struct._flags, compare_value, static_cast<u1>(compare_value | bit)));\n+    return true;\n+  }\n+\n+  bool clear_flag_at(u1 flag_number) {\n+    const u1 bit = 1 << flag_number;\n+    u1 compare_value;\n+    u1 exchange_value;\n+    do {\n+      compare_value = _header._struct._flags;\n+      if ((compare_value & bit) == 0) {\n+        \/\/ already cleaed.\n+        return false;\n+      }\n+      exchange_value = compare_value & ~bit;\n+    } while (compare_value != Atomic::cmpxchg(&_header._struct._flags, compare_value, exchange_value));\n+    return true;\n@@ -210,0 +234,1 @@\n+\n@@ -211,1 +236,1 @@\n-    return (_header._struct._flags & (0x1 << flag_number)) != 0;\n+    return (flags() & (1 << flag_number)) != 0;\n@@ -494,2 +519,3 @@\n-      null_seen_flag              = DataLayout::first_flag + 0,\n-      exception_handler_entered_flag     = null_seen_flag + 1\n+      null_seen_flag                  = DataLayout::first_flag + 0,\n+      exception_handler_entered_flag  = null_seen_flag + 1,\n+      deprecated_method_callsite_flag = exception_handler_entered_flag + 1\n@@ -498,1 +524,1 @@\n-    , exception_seen_flag         = exception_handler_entered_flag + 1\n+    , exception_seen_flag             = deprecated_method_callsite_flag + 1\n@@ -522,0 +548,3 @@\n+  bool deprecated_method_call_site() const { return flag_at(deprecated_method_callsite_flag); }\n+  bool set_deprecated_method_call_site() { return data()->set_flag_at(deprecated_method_callsite_flag); }\n+  bool clear_deprecated_method_call_site() { return data()->clear_flag_at(deprecated_method_callsite_flag); }\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":36,"deletions":7,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import jdk.jfr.internal.settings.LevelSetting;\n@@ -72,0 +73,1 @@\n+    private static final Type TYPE_LEVEL = TypeLibrary.createType(LevelSetting.class);\n@@ -94,0 +96,3 @@\n+        if (eventType.hasLevel()) {\n+            addControl(Level.NAME, defineLevel(eventType));\n+        }\n@@ -340,0 +345,8 @@\n+    private static Control defineLevel(PlatformEventType type) {\n+        Level level = type.getAnnotation(Level.class);\n+        String[] values = level.value();\n+        String def = values[0];\n+        type.add(PrivateAccess.getInstance().newSettingDescriptor(TYPE_LEVEL, Level.NAME, def, Collections.emptyList()));\n+        return new Control(new LevelSetting(type, values), def);\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -662,0 +662,8 @@\n+\n+    \/**\n+     * Sets bits used for event settings, like cutoff(ticks) and level\n+     *\n+     * @param eventTypeId the id of the event type\n+     * @param value\n+     *\/\n+    public static native void setMiscellaneous(long id, long value);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Inherited;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import jdk.jfr.MetadataDefinition;\n+\n+\/**\n+ * Event annotation, determines filtering level.\n+ *\n+ * This settings is only supported for JVM events.\n+ *\n+ * @since 21\n+ *\/\n+@MetadataDefinition\n+@Target({ ElementType.TYPE })\n+@Inherited\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Level {\n+    \/**\n+     * Settings name {@code \"level\"} for configuring filtering level.\n+     *\/\n+    public static final String NAME = \"level\";\n+\n+    \/**\n+     * Levels, for example {@code \"forRemoval\", \"all\"}.\n+     *\n+     * @return the levels, default { \"forRemoval\", \"all\" }, not {@code null}\n+     *\/\n+    String[] value() default {};\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Level.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -84,0 +84,1 @@\n+        private final String level;\n@@ -106,0 +107,1 @@\n+            level = dis.readUTF();\n@@ -310,0 +312,7 @@\n+                if (!t.level.isEmpty()) {\n+                    String[] levels = t.level.split(\",\");\n+                    for (int i = 0; i < levels.length; i++) {\n+                        levels[i] = levels[i].strip();\n+                    }\n+                    aes.add(new AnnotationElement(Level.class, levels));\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataLoader.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+                pEventType.setHasLevel(eventType.getAnnotation(Level.class) != null);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+    private boolean hasLevel = false;\n@@ -145,1 +146,11 @@\n-            JVM.setCutoff(getId(), cutoffTicks);\n+            JVM.setMiscellaneous(getId(), cutoffTicks);\n+        }\n+    }\n+\n+    public void setLevel(long level) {\n+        setMiscellaneous(level);\n+    }\n+\n+    private void setMiscellaneous(long value) {\n+        if (isJVM) {\n+            JVM.setMiscellaneous(getId(), value);\n@@ -159,0 +170,8 @@\n+    public void setHasLevel(boolean hasLevel) {\n+        this.hasLevel = hasLevel;\n+    }\n+\n+    public boolean hasLevel() {\n+        return this.hasLevel;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.settings;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import jdk.jfr.Label;\n+import jdk.jfr.MetadataDefinition;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.PlatformEventType;\n+import jdk.jfr.internal.Type;\n+\n+@MetadataDefinition\n+@Label(\"Level\")\n+@Name(Type.SETTINGS_PREFIX + \"Level\")\n+public class LevelSetting extends JDKSettingControl {\n+    private final PlatformEventType eventType;\n+    private final List<String> levels;\n+    private String value;\n+\n+    public LevelSetting(PlatformEventType eventType, String[] levels) {\n+        this.eventType = Objects.requireNonNull(eventType);\n+        this.levels = Arrays.asList(Objects.requireNonNull(levels));\n+    }\n+\n+    @Override\n+    public String combine(Set<String> values) {\n+        int maxIndex = 0;\n+        for (String value : values) {\n+            maxIndex = Math.max(maxIndex, indexOf(value));\n+        }\n+        return levels.get(maxIndex);\n+    }\n+\n+    @Override\n+    public void setValue(String value) {\n+        this.value = value;\n+        this.eventType.setLevel(indexOf(value));\n+    }\n+\n+    @Override\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    private int indexOf(String value) {\n+        int index = levels.indexOf(value);\n+        return index < 0 ? 0 : index;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/LevelSetting.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.test;\n+\n+public class DeprecatedThing {\n+    public static int staticCounter;\n+    public int counter;\n+\n+    @Deprecated\n+    public void foo() {\n+        bar();\n+    }\n+\n+    @Deprecated\n+    public void zoo() {\n+        System.out.println(\"Zoo invoked\");\n+        for (int i = 0; i < 1_000_000; i++) {\n+            bar();\n+        }\n+    }\n+\n+    private void bar() {\n+        baz();\n+    }\n+\n+    public void baz() {\n+        counter++;\n+    }\n+\n+    @Deprecated(forRemoval = true)\n+    public static void deprecatedForRemovalSlow() {\n+        for (int i = 0; i < 1_000_000; i++) {\n+            deprecatedForRemovalSlow2();\n+        }\n+    }\n+\n+    @Deprecated(forRemoval = true)\n+    public static void deprecatedForRemovalSlow2() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated(forRemoval = true)\n+    public static void deprecatedForRemovalFast() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated\n+    public static void deprecated1() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated(forRemoval = true)\n+    public static void deprecated2() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated(forRemoval = true)\n+    public static void deprecated3() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated\n+    public static void reflection() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated(forRemoval = true)\n+    public static void reflectionForRemoval() {\n+        staticCounter++;\n+    }\n+\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/test\/DeprecatedThing.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -918,0 +918,6 @@\n+    <event name=\"jdk.DeprecatedInvocation\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"level\">forRemoval<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -918,0 +918,5 @@\n+    <event name=\"jdk.DeprecatedInvocation\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+      <setting name=\"level\">forRemoval<\/setting>\n+    <\/event>\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,267 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.event.runtime;\n+\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+import jdk.jfr.consumer.RecordedMethod;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedStackTrace;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.internal.test.DeprecatedThing;\n+import jdk.jfr.Recording;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Asserts.assertNull;\n+import static jdk.test.lib.Asserts.assertNotNull;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm\/timeout=300 -XX:StartFlightRecording:settings=none,+jdk.DeprecatedInvocation#enabled=true\n+ *      jdk.jfr.event.runtime.TestDeprecatedEvent Default\n+\n+ * @run main\/othervm\/timeout=300 -Xint -XX:+UseInterpreter -XX:StartFlightRecording:settings=none,+jdk.DeprecatedInvocation#enabled=true\n+ *      jdk.jfr.event.runtime.TestDeprecatedEvent Interpreter\n+ *\n+ * @run main\/othervm\/timeout=300 -Xcomp -XX:-UseInterpreter -XX:StartFlightRecording:settings=none,+jdk.DeprecatedInvocation#enabled=true\n+ *      jdk.jfr.event.runtime.TestDeprecatedEvent Compiler\n+ *\n+ * @run main\/othervm\/timeout=300 -Xcomp -XX:TieredStopAtLevel=1 -XX:-UseInterpreter -XX:StartFlightRecording:settings=none,+jdk.DeprecatedInvocation#enabled=true\n+ *      jdk.jfr.event.runtime.TestDeprecatedEvent C1\n+ *\n+ * @run main\/othervm\/timeout=300 -Xcomp -XX:TieredStopAtLevel=4 -XX:-TieredCompilation -XX:-UseInterpreter -XX:StartFlightRecording:settings=none,+jdk.DeprecatedInvocation#enabled=true\n+ *      jdk.jfr.event.runtime.TestDeprecatedEvent C2\n+ *\n+ *\/\n+public class TestDeprecatedEvent {\n+\/*\n+ *\n+ * @run main\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *      jdk.jfr.event.runtime.TestDeprecatedEvent JVMCI\n+ *\n+ *\/\n+    public static String EVENT_NAME = EventNames.DeprecatedInvocation;\n+    private static String mode;\n+    public static long threadId;\n+\n+    public static void main(String... args) throws Exception {\n+        mode = args[0];\n+        testDeprecatedLevelAll();\n+        testDeprecatedLevelAllRetained();\n+        testDeprecatedLevelForRemoval();\n+        testDeprecatedLevelForRemovalRetained();\n+        testReflectionAll();\n+        testReflectionForRemovalRetained();\n+    }\n+\n+    private static void testDeprecatedLevelAll() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME).with(\"level\", \"all\");\n+            r.start();\n+            testLevelAll();\n+            r.stop();\n+            validateLevelAll(r);\n+        }\n+    }\n+\n+    private static void testLevelAll() throws Exception {\n+        DeprecatedThing.deprecated1();\n+        DeprecatedThing.deprecatedForRemovalFast();\n+        DeprecatedThing.deprecatedForRemovalSlow();\n+        DeprecatedThing t = new DeprecatedThing();\n+        t.foo();\n+        t.zoo();\n+    }\n+\n+    \/\/ Does not invoke any deprecated methods. We only verify\n+    \/\/ that all previously invoked methods are still retained\n+    \/\/ when starting and stopping a subsequent recording.\n+    private static void testDeprecatedLevelAllRetained() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME).with(\"level\", \"all\");\n+            r.start();\n+            r.stop();\n+            validateLevelAll(r);\n+        }\n+    }\n+\n+    private static void validateLevelAll(Recording r) throws Exception {\n+        List<RecordedEvent> events = Events.fromRecording(r);\n+        printInvocations(events, \"all\");\n+        assertMethod(events, \"testLevelAll\", \"deprecated1\");\n+        assertMethod(events, \"testLevelAll\", \"deprecatedForRemovalFast\");\n+        assertMethod(events, \"testLevelAll\", \"deprecatedForRemovalSlow\");\n+        assertMethod(events, \"testLevelAll\", \"foo\");\n+        assertMethod(events, \"testLevelAll\", \"zoo\");\n+        \/\/ This is a problematic case only with the interpreter.\n+        \/\/ Because bar was already resolved when foo linked against it,\n+        \/\/ it is considered already linked also by zoo (through the cpCache).\n+        \/\/ Therefore the hook will not be issued when zoo -> bar.\n+        \/\/ assertMethod(events, \"zoo\", \"bar\");\n+    }\n+\n+\n+    private static void testDeprecatedLevelForRemoval() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME).with(\"level\", \"forRemoval\");\n+            r.start();\n+            testLevelForRemoval();\n+            r.stop();\n+            validateLevelForRemoval(r);\n+        }\n+    }\n+\n+    private static void testLevelForRemoval() throws Exception {\n+        DeprecatedThing.deprecated2();\n+    }\n+\n+    private static void testReflectionAll() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME).with(\"level\", \"all\");\n+            r.start();\n+            threadId = (long) Thread.class.getMethod(\"getId\").invoke(Thread.currentThread());\n+            DeprecatedThing.class.getMethod(\"reflection\").invoke(null);\n+            DeprecatedThing.class.getMethod(\"reflectionForRemoval\").invoke(null);\n+            r.stop();\n+            validateReflectionLevelAll(r);\n+        }\n+    }\n+\n+    private static void validateReflectionLevelAll(Recording r) throws Exception {\n+        List<RecordedEvent> events = Events.fromRecording(r);\n+        printInvocations(events, \"all\");\n+        assertMethod(events, \"testReflectionAll\", \"getId\");\n+        assertTrue(threadId != 0, \"invariant\");\n+        assertMethod(events, \"testReflectionAll\", \"reflection\");\n+        assertMethod(events, \"testReflectionAll\", \"reflectionForRemoval\");\n+    }\n+\n+    \/\/ Does not invoke any deprecated methods. We only verify\n+    \/\/ that all previously invoked methods are still retained\n+    \/\/ when starting and stopping a subsequent recording.\n+    private static void testReflectionForRemovalRetained() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME).with(\"level\", \"forRemoval\");\n+            r.start();\n+            r.stop();\n+            validateReflectionLevelForRemoval(r);\n+        }\n+    }\n+\n+\n+    private static void validateReflectionLevelForRemoval(Recording r) throws Exception {\n+        List<RecordedEvent> events = Events.fromRecording(r);\n+        printInvocations(events, \"forRemoval\");\n+        assertMethod(events, \"testReflectionAll\", \"reflectionForRemoval\");\n+    }\n+\n+    \/\/ Does not invoke any deprecated methods. We only verify\n+    \/\/ that all previously invoked methods are still retained\n+    \/\/ when starting and stopping a subsequent recording.\n+    private static void testDeprecatedLevelForRemovalRetained() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME).with(\"level\", \"forRemoval\");\n+            r.start();\n+            r.stop();\n+            validateLevelForRemoval(r);\n+        }\n+    }\n+\n+    private static void validateLevelForRemoval(Recording r) throws Exception {\n+        List<RecordedEvent> events = Events.fromRecording(r);\n+        printInvocations(events, \"forRemoval\");\n+        for (RecordedEvent e : events) {\n+            RecordedMethod deprecatedMethod = e.getValue(\"method\");\n+            if (deprecatedMethod.getName().equals(\"deprecated2\")) {\n+                assertTrue(e.getBoolean(\"forRemoval\"), \"invalid level\");\n+                RecordedStackTrace stacktrace = e.getStackTrace();\n+                assertNotNull(stacktrace, \"should have a stacktrace\");\n+                assertTrue(stacktrace.isTruncated(), \"invariant\");\n+                List<RecordedFrame> frames = stacktrace.getFrames();\n+                assertTrue(frames.size() == 1, \"invariant\");\n+                RecordedFrame frame = frames.getFirst();\n+                assertTrue(frame.isJavaFrame(), \"invariant\");\n+                RecordedMethod callerMethod = frame.getMethod();\n+                assertNotNull(callerMethod, \"invariant\");\n+                if (callerMethod.getName().equals(\"testLevelForRemoval\")) {\n+                    return;\n+                }\n+            }\n+        }\n+        throw new Exception(\"Could not find invocation forRemvoval\");\n+    }\n+\n+\n+    private static void assertMethod(List<RecordedEvent> events, String caller, String method) throws Exception {\n+        for (RecordedEvent e : events) {\n+            RecordedMethod deprecatedMethod = e.getValue(\"method\");\n+            boolean forRemoval = e.getValue(\"forRemoval\");\n+            RecordedStackTrace stacktrace = e.getStackTrace();\n+            assertNotNull(stacktrace, \"should have a stacktrace\");\n+            assertTrue(stacktrace.isTruncated(), \"invariant\");\n+            List<RecordedFrame> frames = stacktrace.getFrames();\n+            assertTrue(frames.size() == 1, \"invariant\");\n+            assertTrue(frames.getFirst().isJavaFrame(), \"invariant\");\n+            RecordedFrame frame = frames.getFirst();\n+            assertTrue(frame.isJavaFrame(), \"invariant\");\n+            RecordedMethod callerMethod = frame.getMethod();\n+            int bci = frame.getBytecodeIndex();\n+            int lineNumber = frame.getLineNumber();\n+            assertNull(e.getThread(), \"should not have a thread\");\n+            if (deprecatedMethod.getName().equals(method) && callerMethod.getName().equals(caller)){\n+                return;\n+            }\n+        }\n+        throw new Exception(\"Could not find invocation: \" + caller + \" -> \" + method);\n+    }\n+\n+\n+    private static void printInvocations(List<RecordedEvent> events, String all) {\n+        System.out.println(\"*** METHOD INVOCATION *** (\" + mode + \") level = \" + all + \" count: \" + events.size());\n+        for (RecordedEvent e : events) {\n+            RecordedMethod deprecatedMethod = e.getValue(\"method\");\n+            boolean forRemoval = e.getValue(\"forRemoval\");\n+            RecordedStackTrace stacktrace = e.getStackTrace();\n+            assertNotNull(stacktrace, \"should have a stacktrace\");\n+            assertTrue(stacktrace.isTruncated(), \"invariant\");\n+            List<RecordedFrame> frames = stacktrace.getFrames();\n+            assertTrue(frames.size() == 1, \"invariant\");\n+            RecordedFrame frame = frames.getFirst();\n+            assertTrue(frame.isJavaFrame(), \"invariant\");\n+            RecordedMethod callerMethod = frame.getMethod();\n+            int bci = frame.getBytecodeIndex();\n+            int lineNumber = frame.getLineNumber();\n+            assertNull(e.getThread(), \"should not have a thread\");\n+            System.out.println(callerMethod.getName() + \" at bci: \" + bci + \" line: \" + lineNumber + \" -> \" + deprecatedMethod.getName());\n+            System.out.println(e);\n+        }\n+        System.out.println();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestDeprecatedEvent.java","additions":267,"deletions":0,"binary":false,"changes":267,"status":"added"},{"patch":"@@ -91,0 +91,1 @@\n+    public static final String DeprecatedInvocation = PREFIX + \"DeprecatedInvocation\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}