{"files":[{"patch":"@@ -49,10 +49,7 @@\n-static constexpr const int NUM_FILTERS = 4;\n-\n-static constexpr const char* filters[NUM_FILTERS] = {\n-                                                      \"java\/lang\/invoke\/\",\n-                                                      \"jdk\/internal\/reflect\/\",\n-                                                      \"java\/lang\/reflect\/\",\n-                                                      \"sun\/invoke\/\"\n-                                                    };\n-\n-static const char* const link_error_msg = \"illegal access linking method 'jdk.jfr.internal.event.EventWriterFactory.getEventWriter(long)'\";\n+\/\/ The following packages are internal implmentation details used by reflection.\n+\/\/ We exclude matching frames on the stack in a manner similar to StackWalker.\n+static constexpr const int NUM_EXCLUDED_PACKAGES = 4;\n+static constexpr const char* excluded_packages[NUM_EXCLUDED_PACKAGES] = { \"java\/lang\/invoke\/\",\n+                                                                          \"jdk\/internal\/reflect\/\",\n+                                                                          \"java\/lang\/reflect\/\",\n+                                                                          \"sun\/invoke\/\" };\n@@ -66,1 +63,2 @@\n-static inline bool exclude(const Method* method) {\n+\/\/ Caller requires ResourceMark.\n+static inline bool exclude_frame(const Method* method) {\n@@ -78,2 +76,2 @@\n-  for (int i = 0; i < NUM_FILTERS; ++i) {\n-    if (match(klass_name, filters[i])) {\n+  for (int i = 0; i < NUM_EXCLUDED_PACKAGES; ++i) {\n+    if (match(klass_name,excluded_packages[i])) {\n@@ -87,2 +85,1 @@\n-\/\/ Find the real caller.\n-static Method* locate_real_caller(vframeStream& stream, JavaThread* jt) {\n+static Method* find_real_caller(vframeStream& stream, JavaThread* jt) {\n@@ -96,1 +93,1 @@\n-    if (!exclude(stream.method())) {\n+    if (!exclude_frame(stream.method())) {\n@@ -112,1 +109,1 @@\n-    method = locate_real_caller(stream, jt);\n+    method = find_real_caller(stream, jt);\n@@ -178,0 +175,2 @@\n+static const char* const link_error_msg = \"illegal access linking method 'jdk.jfr.internal.event.EventWriterFactory.getEventWriter(long)'\";\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrResolution.cpp","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.test;\n+\n+public class DeprecatedMethods {\n+    public static int staticCounter;\n+\n+    @Deprecated\n+    public static void deprecated() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated(since = \"0\")\n+    public static void deprecatedSince() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated(forRemoval = true)\n+    public static void deprecatedForRemoval() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated(since = \"0\", forRemoval = true)\n+    public static void deprecatedSinceForRemoval() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated\n+    public static void reflectionDeprecated() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated(since = \"0\")\n+    public static void reflectionDeprecatedSince() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated(forRemoval = true)\n+    public static void reflectionDeprecatedForRemoval() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated(since = \"0\", forRemoval = true)\n+    public static void reflectionDeprecatedSinceForRemoval() {\n+        staticCounter++;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/test\/DeprecatedMethods.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -1,92 +1,63 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jfr.internal.test;\n-\n-public class DeprecatedThing {\n-    public static int staticCounter;\n-    public int counter;\n-\n-    @Deprecated\n-    public void foo() {\n-        bar();\n-    }\n-\n-    @Deprecated\n-    public void zoo() {\n-        System.out.println(\"Zoo invoked\");\n-        for (int i = 0; i < 1_000_000; i++) {\n-            bar();\n-        }\n-    }\n-\n-    private void bar() {\n-        baz();\n-    }\n-\n-    public void baz() {\n-        counter++;\n-    }\n-\n-    @Deprecated(forRemoval = true)\n-    public static void deprecatedForRemovalSlow() {\n-        for (int i = 0; i < 1_000_000; i++) {\n-            deprecatedForRemovalSlow2();\n-        }\n-    }\n-\n-    @Deprecated(forRemoval = true)\n-    public static void deprecatedForRemovalSlow2() {\n-        staticCounter++;\n-    }\n-\n-    @Deprecated(forRemoval = true)\n-    public static void deprecatedForRemovalFast() {\n-        staticCounter++;\n-    }\n-\n-    @Deprecated\n-    public static void deprecated1() {\n-        staticCounter++;\n-    }\n-\n-    @Deprecated(forRemoval = true)\n-    public static void deprecated2() {\n-        staticCounter++;\n-    }\n-\n-    @Deprecated(forRemoval = true)\n-    public static void deprecated3() {\n-        staticCounter++;\n-    }\n-\n-    @Deprecated\n-    public static void reflection() {\n-        staticCounter++;\n-    }\n-\n-    @Deprecated(forRemoval = true)\n-    public static void reflectionForRemoval() {\n-        staticCounter++;\n-    }\n-\n-}\n+\/*\r\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+package jdk.jfr.internal.test;\r\n+\r\n+@Deprecated(since = \"0\")\r\n+public class DeprecatedThing {\r\n+    public int counter;\r\n+\r\n+    public void foo() {\r\n+        bar();\r\n+    }\r\n+\r\n+    public void zoo() {\r\n+        System.out.println(\"Zoo invoked\");\r\n+        for (int i = 0; i < 1_000_000; i++) {\r\n+            bar();\r\n+        }\r\n+    }\r\n+\r\n+    private void bar() {\r\n+        baz();\r\n+    }\r\n+\r\n+    public void baz() {\r\n+        inc();\r\n+    }\r\n+\r\n+    private void inc() {\r\n+        counter++;\r\n+    }\r\n+\r\n+    @Deprecated(forRemoval = true)\r\n+    public void instanceDeprecatedForRemoval() {\r\n+        for (int i = 0; i < 1_000_000; i++) {\r\n+           inc();\r\n+        }\r\n+    }\r\n+\r\n+    @Deprecated(since = \"0\", forRemoval = true)\r\n+    public void instanceDeprecatedSinceForRemoval() {\r\n+        counter++;\r\n+    }\r\n+}\r\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/test\/DeprecatedThing.java","additions":63,"deletions":92,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.jfr.internal.test.DeprecatedMethods;\n@@ -72,1 +73,0 @@\n-    public static long threadId;\n@@ -78,2 +78,0 @@\n-        testDeprecatedLevelForRemoval();\n-        testDeprecatedLevelForRemovalRetained();\n@@ -81,1 +79,1 @@\n-        testReflectionForRemovalRetained();\n+        testDeprecatedLevelForRemovalRetained();\n@@ -95,3 +93,7 @@\n-        DeprecatedThing.deprecated1();\n-        DeprecatedThing.deprecatedForRemovalFast();\n-        DeprecatedThing.deprecatedForRemovalSlow();\n+        \/\/ Methods individually decorated.\n+        DeprecatedMethods.deprecated();\n+        DeprecatedMethods.deprecatedSince();\n+        DeprecatedMethods.deprecatedForRemoval();\n+        DeprecatedMethods.deprecatedSinceForRemoval();\n+        \/\/ Class level @deprecated annotation\n+        \/\/ @Deprecated(since = \"0\")\n@@ -99,0 +101,2 @@\n+        t.instanceDeprecatedForRemoval();\n+        t.instanceDeprecatedSinceForRemoval();\n@@ -103,12 +107,0 @@\n-    \/\/ Does not invoke any deprecated methods. We only verify\n-    \/\/ that all previously invoked methods are still retained\n-    \/\/ when starting and stopping a subsequent recording.\n-    private static void testDeprecatedLevelAllRetained() throws Exception {\n-        try (Recording r = new Recording()) {\n-            r.enable(EVENT_NAME).with(\"level\", \"all\");\n-            r.start();\n-            r.stop();\n-            validateLevelAll(r);\n-        }\n-    }\n-\n@@ -118,3 +110,6 @@\n-        assertMethod(events, \"testLevelAll\", \"deprecated1\");\n-        assertMethod(events, \"testLevelAll\", \"deprecatedForRemovalFast\");\n-        assertMethod(events, \"testLevelAll\", \"deprecatedForRemovalSlow\");\n+        assertMethod(events, \"testLevelAll\", \"deprecated\");\n+        assertMethod(events, \"testLevelAll\", \"deprecatedSince\");\n+        assertMethod(events, \"testLevelAll\", \"deprecatedForRemoval\");\n+        assertMethod(events, \"testLevelAll\", \"deprecatedSinceForRemoval\");\n+        assertMethod(events, \"testLevelAll\", \"instanceDeprecatedForRemoval\");\n+        assertMethod(events, \"testLevelAll\", \"instanceDeprecatedSinceForRemoval\");\n@@ -123,5 +118,0 @@\n-        \/\/ This is a problematic case only with the interpreter.\n-        \/\/ Because bar was already resolved when foo linked against it,\n-        \/\/ it is considered already linked also by zoo (through the cpCache).\n-        \/\/ Therefore the hook will not be issued when zoo -> bar.\n-        \/\/ assertMethod(events, \"zoo\", \"bar\");\n@@ -130,2 +120,4 @@\n-\n-    private static void testDeprecatedLevelForRemoval() throws Exception {\n+    \/\/ Does not invoke any deprecated methods. We only verify\n+    \/\/ that all previously invoked methods are still retained\n+    \/\/ when starting and stopping a subsequent recording.\n+    private static void testDeprecatedLevelAllRetained() throws Exception {\n@@ -133,1 +125,1 @@\n-            r.enable(EVENT_NAME).with(\"level\", \"forRemoval\");\n+            r.enable(EVENT_NAME).with(\"level\", \"all\");\n@@ -135,1 +127,0 @@\n-            testLevelForRemoval();\n@@ -137,1 +128,1 @@\n-            validateLevelForRemoval(r);\n+            validateLevelAll(r);\n@@ -141,4 +132,0 @@\n-    private static void testLevelForRemoval() throws Exception {\n-        DeprecatedThing.deprecated2();\n-    }\n-\n@@ -149,3 +136,4 @@\n-            threadId = (long) Thread.class.getMethod(\"getId\").invoke(Thread.currentThread());\n-            DeprecatedThing.class.getMethod(\"reflection\").invoke(null);\n-            DeprecatedThing.class.getMethod(\"reflectionForRemoval\").invoke(null);\n+            DeprecatedMethods.class.getMethod(\"reflectionDeprecated\").invoke(null);\n+            DeprecatedMethods.class.getMethod(\"reflectionDeprecatedSince\").invoke(null);\n+            DeprecatedMethods.class.getMethod(\"reflectionDeprecatedForRemoval\").invoke(null);\n+            DeprecatedMethods.class.getMethod(\"reflectionDeprecatedSinceForRemoval\").invoke(null);\n@@ -159,24 +147,5 @@\n-        printInvocations(events, \"all\");\n-        assertMethod(events, \"testReflectionAll\", \"getId\");\n-        assertTrue(threadId != 0, \"invariant\");\n-        assertMethod(events, \"testReflectionAll\", \"reflection\");\n-        assertMethod(events, \"testReflectionAll\", \"reflectionForRemoval\");\n-    }\n-\n-    \/\/ Does not invoke any deprecated methods. We only verify\n-    \/\/ that all previously invoked methods are still retained\n-    \/\/ when starting and stopping a subsequent recording.\n-    private static void testReflectionForRemovalRetained() throws Exception {\n-        try (Recording r = new Recording()) {\n-            r.enable(EVENT_NAME).with(\"level\", \"forRemoval\");\n-            r.start();\n-            r.stop();\n-            validateReflectionLevelForRemoval(r);\n-        }\n-    }\n-\n-\n-    private static void validateReflectionLevelForRemoval(Recording r) throws Exception {\n-        List<RecordedEvent> events = Events.fromRecording(r);\n-        printInvocations(events, \"forRemoval\");\n-        assertMethod(events, \"testReflectionAll\", \"reflectionForRemoval\");\n+        printInvocations(events, \"reflectionAll\");\n+        assertMethod(events, \"testReflectionAll\", \"reflectionDeprecated\");\n+        assertMethod(events, \"testReflectionAll\", \"reflectionDeprecatedSince\");\n+        assertMethod(events, \"testReflectionAll\", \"reflectionDeprecatedForRemoval\");\n+        assertMethod(events, \"testReflectionAll\", \"reflectionDeprecatedSinceForRemoval\");\n@@ -200,19 +169,6 @@\n-        for (RecordedEvent e : events) {\n-            RecordedMethod deprecatedMethod = e.getValue(\"method\");\n-            if (deprecatedMethod.getName().equals(\"deprecated2\")) {\n-                assertTrue(e.getBoolean(\"forRemoval\"), \"invalid level\");\n-                RecordedStackTrace stacktrace = e.getStackTrace();\n-                assertNotNull(stacktrace, \"should have a stacktrace\");\n-                assertTrue(stacktrace.isTruncated(), \"invariant\");\n-                List<RecordedFrame> frames = stacktrace.getFrames();\n-                assertTrue(frames.size() == 1, \"invariant\");\n-                RecordedFrame frame = frames.getFirst();\n-                assertTrue(frame.isJavaFrame(), \"invariant\");\n-                RecordedMethod callerMethod = frame.getMethod();\n-                assertNotNull(callerMethod, \"invariant\");\n-                if (callerMethod.getName().equals(\"testLevelForRemoval\")) {\n-                    return;\n-                }\n-            }\n-        }\n-        throw new Exception(\"Could not find invocation forRemvoval\");\n+        assertMethod(events, \"testLevelAll\", \"deprecatedForRemoval\");\n+        assertMethod(events, \"testLevelAll\", \"deprecatedSinceForRemoval\");\n+        assertMethod(events, \"testLevelAll\", \"instanceDeprecatedForRemoval\");\n+        assertMethod(events, \"testLevelAll\", \"instanceDeprecatedSinceForRemoval\");\n+        assertMethod(events, \"testReflectionAll\", \"reflectionDeprecatedForRemoval\");\n+        assertMethod(events, \"testReflectionAll\", \"reflectionDeprecatedSinceForRemoval\");\n@@ -221,1 +177,0 @@\n-\n@@ -238,0 +193,3 @@\n+            if (forRemoval) {\n+                assertTrue(deprecatedMethod.getName().endsWith(\"ForRemoval\"), \"wrong filtering?\");\n+            }\n@@ -247,1 +205,1 @@\n-        System.out.println(\"*** METHOD INVOCATION *** (\" + mode + \") level = \" + all + \" count: \" + events.size());\n+        System.out.println(\"*** METHOD INVOCATION *** (\" + mode + \") level = \" + all + \" count: \" + events.size() + \" ***\\n\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestDeprecatedEvent.java","additions":42,"deletions":84,"binary":false,"changes":126,"status":"modified"}]}