{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,0 @@\n-  void scavenge();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -190,0 +190,1 @@\n+  assert(!sender->is_native(), \"invariant\");\n@@ -192,7 +193,0 @@\n-  if (sender->is_native()) {\n-    \/\/ Native methods have no mdo bit data so we cannot mark them.\n-    \/\/ An additional reason is that a native method attempting resolution\n-    \/\/ must be a JDK internal implementation, for example:\n-    \/\/ java\/lang\/invoke\/MethodHandleNatives.resolve()\n-    return;\n-  }\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrDeprecationManager.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,12 @@\n+ \/\/ for strstr\n+#include <string.h>\n+\n+static constexpr const int NUM_FILTERS = 4;\n+\n+static constexpr const char* filters[NUM_FILTERS] = {\n+                                                      \"java\/lang\/invoke\/\",\n+                                                      \"jdk\/internal\/reflect\/\",\n+                                                      \"java\/lang\/reflect\/\",\n+                                                      \"sun\/invoke\/\"\n+                                                    };\n+\n@@ -48,0 +60,44 @@\n+static inline bool match(const char* str, const char* sub_str) {\n+  assert(str != nullptr, \"invariant\");\n+  assert(sub_str != nullptr, \"invariant\");\n+  return strstr(str, sub_str) == str;\n+}\n+\n+static inline bool exclude(const Method* method) {\n+  assert(method != nullptr, \"invariant\");\n+  \/\/ exclude native methods.\n+  if (method->is_native()) {\n+    return true;\n+  }\n+  const Klass* const klass = method->method_holder();\n+  assert(klass != nullptr, \"invariant\");\n+  const Symbol* const klass_sym = klass->name();\n+  assert(klass_sym != nullptr, \"invariant\");\n+  const char* const klass_name = klass_sym->as_C_string();\n+  assert(klass_name != nullptr, \"invariant\");\n+  for (int i = 0; i < NUM_FILTERS; ++i) {\n+    if (match(klass_name, filters[i])) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ If the caller into resolution is native, it must be java\/lang\/invoke\/MethodHandleNatives.resolve().\n+\/\/ Find the real caller.\n+static Method* locate_real_caller(vframeStream& stream, JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  assert(stream.method()->is_native(), \"invariant\");\n+  ResourceMark rm(jt);\n+  assert(strcmp(stream.method()->name()->as_C_string(), \"resolve\") == 0, \"invariant\");\n+  assert(strcmp(stream.method()->method_holder()->name()->as_C_string(), \"java\/lang\/invoke\/MethodHandleNatives\") == 0, \"invariant\");\n+  stream.next();\n+  while (!stream.at_end()) {\n+    if (!exclude(stream.method())) {\n+      break;\n+    }\n+    stream.next();\n+  }\n+  return stream.method();\n+}\n+\n@@ -53,0 +109,7 @@\n+  Method* method = stream.method();\n+  assert(method != nullptr, \"invariant\");\n+  if (method->is_native()) {\n+    method = locate_real_caller(stream, jt);\n+  }\n+  assert(method != nullptr, \"invariant\");\n+  assert(!method->is_native(), \"invariant\");\n@@ -55,1 +118,0 @@\n-  Method* method = stream.method();\n@@ -100,1 +162,3 @@\n-    assert(sender != nullptr, \"invariant\");\n+    if (sender == nullptr) {\n+      return;\n+    }\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrResolution.cpp","additions":66,"deletions":2,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -81,0 +81,11 @@\n+\n+    @Deprecated\n+    public static void reflection() {\n+        staticCounter++;\n+    }\n+\n+    @Deprecated(forRemoval = true)\n+    public static void reflectionForRemoval() {\n+        staticCounter++;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/test\/DeprecatedThing.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+    public static long threadId;\n@@ -79,0 +80,2 @@\n+        testReflectionAll();\n+        testReflectionForRemovalRetained();\n@@ -142,0 +145,40 @@\n+    private static void testReflectionAll() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME).with(\"level\", \"all\");\n+            r.start();\n+            threadId = (long) Thread.class.getMethod(\"getId\").invoke(Thread.currentThread());\n+            DeprecatedThing.class.getMethod(\"reflection\").invoke(null);\n+            DeprecatedThing.class.getMethod(\"reflectionForRemoval\").invoke(null);\n+            r.stop();\n+            validateReflectionLevelAll(r);\n+        }\n+    }\n+\n+    private static void validateReflectionLevelAll(Recording r) throws Exception {\n+        List<RecordedEvent> events = Events.fromRecording(r);\n+        printInvocations(events, \"all\");\n+        assertMethod(events, \"testReflectionAll\", \"getId\");\n+        assertTrue(threadId != 0, \"invariant\");\n+        assertMethod(events, \"testReflectionAll\", \"reflection\");\n+        assertMethod(events, \"testReflectionAll\", \"reflectionForRemoval\");\n+    }\n+\n+    \/\/ Does not invoke any deprecated methods. We only verify\n+    \/\/ that all previously invoked methods are still retained\n+    \/\/ when starting and stopping a subsequent recording.\n+    private static void testReflectionForRemovalRetained() throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(EVENT_NAME).with(\"level\", \"forRemoval\");\n+            r.start();\n+            r.stop();\n+            validateReflectionLevelForRemoval(r);\n+        }\n+    }\n+\n+\n+    private static void validateReflectionLevelForRemoval(Recording r) throws Exception {\n+        List<RecordedEvent> events = Events.fromRecording(r);\n+        printInvocations(events, \"forRemoval\");\n+        assertMethod(events, \"testReflectionAll\", \"reflectionForRemoval\");\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestDeprecatedEvent.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"}]}