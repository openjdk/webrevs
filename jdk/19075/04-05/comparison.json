{"files":[{"patch":"@@ -2483,1 +2483,5 @@\n-            int exponent = 0; \/\/ Set to the exponent value, if any\n+            \/\/ Storing as long allows us to maintain accuracy of exponent\n+            \/\/ when the exponent value as well as the decimalAt nears\n+            \/\/ Integer.MAX\/MIN value. However, the final expressed value is an int\n+            long exponent = 0;\n+            boolean[] expStat = new boolean[STATUS_LENGTH];\n@@ -2585,1 +2589,0 @@\n-                    boolean[] stat = new boolean[STATUS_LENGTH];\n@@ -2588,1 +2591,1 @@\n-                    if (subparse(text, pos, \"\", symbols.getMinusSignText(), exponentDigits, true, stat)) {\n+                    if (subparse(text, pos, \"\", symbols.getMinusSignText(), exponentDigits, true, expStat)) {\n@@ -2593,11 +2596,4 @@\n-                        if (exponentDigits.fitsIntoLong(stat[STATUS_POSITIVE], true)) {\n-                            try {\n-                                exponent = Math.toIntExact(exponentDigits.getLong());\n-                                if (!stat[STATUS_POSITIVE]) {\n-                                    exponent = -exponent;\n-                                }\n-                            } catch (ArithmeticException ex) {\n-                                \/\/ For all overflow and underflow, determine\n-                                \/\/ appropriate value based off positive status\n-                                exponent = stat[STATUS_POSITIVE] ?\n-                                        Integer.MAX_VALUE : Integer.MIN_VALUE;\n+                        if (exponentDigits.fitsIntoLong(expStat[STATUS_POSITIVE], true)) {\n+                            exponent = exponentDigits.getLong();\n+                            if (!expStat[STATUS_POSITIVE]) {\n+                                exponent = -exponent;\n@@ -2606,2 +2602,2 @@\n-                            exponent = stat[STATUS_POSITIVE] ?\n-                                    Integer.MAX_VALUE : Integer.MIN_VALUE;\n+                            exponent = expStat[STATUS_POSITIVE] ?\n+                                    Long.MAX_VALUE : Long.MIN_VALUE;\n@@ -2644,6 +2640,2 @@\n-            try {\n-                digits.decimalAt = Math.addExact(digits.decimalAt, exponent);\n-            } catch (ArithmeticException ex) {\n-                \/\/ Depending on overflow\/underflow, adjust exponent value\n-                digits.decimalAt = digits.decimalAt + exponent > 0\n-                        ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n+            if (exponent != 0) {\n+                digits.decimalAt = shiftDecimalAt(digits.decimalAt, exponent);\n@@ -2663,0 +2655,23 @@\n+    \/\/ Calculate the final decimal position based off the exponent value\n+    \/\/ and the existing decimalAt position. If overflow\/underflow, the value\n+    \/\/ should be set as either Integer.MAX\/MIN\n+    private int shiftDecimalAt(int decimalAt, long exponent) {\n+        try {\n+            exponent = Math.addExact(decimalAt, exponent);\n+        } catch (ArithmeticException ex) {\n+            \/\/ If we under\/overflow a Long do not bother with the decimalAt\n+            \/\/ As it can only shift up to Integer.MAX\/MIN which has no affect\n+            if (exponent > 0 && decimalAt > 0) {\n+                return Integer.MAX_VALUE;\n+            } else {\n+                return Integer.MIN_VALUE;\n+            }\n+        }\n+        try {\n+            decimalAt = Math.toIntExact(exponent);\n+        } catch (ArithmeticException ex) {\n+            decimalAt = exponent > 0 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n+        }\n+        return decimalAt;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":37,"deletions":22,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run junit LargeExponentsTest\n+ * @run junit\/othervm --add-opens java.base\/java.text=ALL-UNNAMED LargeExponentsTest\n@@ -36,0 +36,3 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.text.DecimalFormat;\n@@ -63,0 +66,28 @@\n+    \/\/ A separate white-box test to avoid the memory consumption of testing cases\n+    \/\/ when the String is near Integer.MAX_LENGTH\n+    @ParameterizedTest\n+    @MethodSource\n+    public void largeDecimalAtExponentTest(int expected, int decimalAt, long expVal)\n+            throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n+        DecimalFormat df = new DecimalFormat();\n+        Method m = df.getClass().getDeclaredMethod(\n+                \"shiftDecimalAt\", int.class, long.class);\n+        m.setAccessible(true);\n+        assertEquals(expected, m.invoke(df, decimalAt, expVal));\n+    }\n+\n+    \/\/ Cases where we can test behavior when the String is near Integer.MAX_LENGTH\n+    private static Stream<Arguments> largeDecimalAtExponentTest() {\n+        return Stream.of(\n+                \/\/ Equivalent to testing Arguments.of(\"0.\"+\"0\".repeat(Integer.MAX_VALUE-20)+\"1\"+\"E2147483650\", 1.0E22)\n+                \/\/ This is an absurdly long decimal string with length close to Integer.MAX_VALUE\n+                \/\/ where the decimal position correctly negates the exponent value, even if it exceeds Integer.MAX_VALUE\n+                Arguments.of(23, -(Integer.MAX_VALUE-20), 3L+Integer.MAX_VALUE),\n+                Arguments.of(-23, Integer.MAX_VALUE-20, -(3L+Integer.MAX_VALUE)),\n+                Arguments.of(Integer.MIN_VALUE, -(Integer.MAX_VALUE-20), -(3L+Integer.MAX_VALUE)),\n+                Arguments.of(Integer.MAX_VALUE, Integer.MAX_VALUE-20, 3L+Integer.MAX_VALUE),\n+                Arguments.of(Integer.MAX_VALUE, -(Integer.MAX_VALUE-20), Long.MAX_VALUE),\n+                Arguments.of(Integer.MIN_VALUE, Integer.MAX_VALUE-20, Long.MIN_VALUE)\n+        );\n+    }\n+\n@@ -128,0 +159,1 @@\n+                Arguments.of(\"0.123E-2147483647\", 0.0),\n@@ -133,1 +165,1 @@\n-    \/\/ Some odd edge case values to ensure parse correctness\n+    \/\/ Some other edge case values to ensure parse correctness\n@@ -152,1 +184,7 @@\n-                Arguments.of(\"1.23E-9223372036854775808\", 0.0)\n+                Arguments.of(\"1.23E-9223372036854775808\", 0.0),\n+                \/\/ Exponent value smaller than Long.MIN_VALUE\n+                Arguments.of(\"1.23E-9223372036854775809\", 0.0),\n+                \/\/ Exponent value equal to Long.MAX_VALUE\n+                Arguments.of(\"1.23E9223372036854775807\", Double.POSITIVE_INFINITY),\n+                \/\/ Exponent value larger than Long.MAX_VALUE\n+                Arguments.of(\"1.23E9223372036854775808\", Double.POSITIVE_INFINITY)\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/LargeExponentsTest.java","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"}]}