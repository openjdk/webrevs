{"files":[{"patch":"@@ -2482,1 +2482,0 @@\n-            boolean sawExponent = false;\n@@ -2582,2 +2581,2 @@\n-                } else if (checkExponent && !isExponent && text.regionMatches(position, exponentString, 0, exponentString.length())\n-                        && !sawExponent) {\n+                } else if (checkExponent && !isExponent\n+                        && text.regionMatches(position, exponentString, 0, exponentString.length())) {\n@@ -2589,4 +2588,18 @@\n-                    if (subparse(text, pos, \"\", symbols.getMinusSignText(), exponentDigits, true, stat) &&\n-                            exponentDigits.fitsIntoLong(stat[STATUS_POSITIVE], true)) {\n-                        position = pos.index; \/\/ Advance past the exponent\n-                        exponent = (int)exponentDigits.getLong();\n+                    if (subparse(text, pos, \"\", symbols.getMinusSignText(), exponentDigits, true, stat)) {\n+                        \/\/ We parse the exponent with isExponent == true, thus fitsIntoLong()\n+                        \/\/ only returns false here if the exponent DigitList value exceeds\n+                        \/\/ Long.MAX_VALUE. We do not need to worry about false being\n+                        \/\/ returned for faulty values as they are ignored by DigitList.\n+                        if (exponentDigits.fitsIntoLong(stat[STATUS_POSITIVE], true)) {\n+                            position = pos.index; \/\/ Advance past the exponent\n+                            try {\n+                                exponent = Math.toIntExact(exponentDigits.getLong());\n+                            } catch (ArithmeticException ex) {\n+                                \/\/ If overflow, Integer.MAX_VALUE is sufficient\n+                                exponent = Integer.MAX_VALUE;\n+                            }\n+                        } else {\n+                            \/\/ Value is greater than Long.MAX_VALUE, exponent field\n+                            \/\/ is int, so assign it to the largest possible, Integer.MAX_VALUE\n+                            exponent = Integer.MAX_VALUE;\n+                        }\n@@ -2596,1 +2609,0 @@\n-                        sawExponent = true;\n@@ -2631,1 +2643,6 @@\n-            digits.decimalAt += exponent;\n+            try {\n+                digits.decimalAt = Math.addExact(digits.decimalAt, exponent);\n+            } catch (ArithmeticException ex) {\n+                \/\/ If overflow, Integer.MAX_VALUE is sufficient\n+                digits.decimalAt = Integer.MAX_VALUE;\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331485\n+ * @summary Ensure correctness when parsing large (+\/-) exponent values that\n+ *          exceed Integer.MAX_VALUE and Long.MAX_VALUE.\n+ * @run junit LargeExponentsTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/\/ We prevent odd results when parsing large exponent values by ensuring\n+\/\/ that we properly handle overflow in the implementation of DigitList\n+public class LargeExponentsTest {\n+\n+    \/\/ Exponent symbol is 'E'\n+    private static final NumberFormat FMT = NumberFormat.getInstance(Locale.US);\n+\n+    \/\/ Check that the parsed value is equal to the expected.\n+    \/\/ We are mainly checking that an exponent > Integer.MAX_VALUE no longer parses to 0\n+    \/\/ and that an exponent > Long.MAX_VALUE no longer parses to the mantissa.\n+    @ParameterizedTest\n+    @MethodSource({\"largeExponentValues\", \"smallExponentValues\", \"bugReportValues\", \"edgeCases\"})\n+    public void overflowTest(String parseString, Double expectedValue) throws ParseException {\n+        Number actualValue = FMT.parse(parseString);\n+        assertEquals(expectedValue, (double)actualValue);\n+    }\n+\n+    \/\/ Generate large enough exponents that should all be parsed as infinity\n+    \/\/ when positive. This includes exponents that exceed Long.MAX_VALUE\n+    private static List<Arguments> largeExponentValues() {\n+        return createExponentValues(false);\n+    }\n+\n+    \/\/ Same as previous provider but for negative exponent values, so expecting\n+    \/\/ a parsed value of 0.\n+    private static List<Arguments> smallExponentValues() {\n+        return createExponentValues(true);\n+    }\n+\n+    \/\/ Programmatically generate some large parse values that are expected\n+    \/\/ to be parsed as infinity or 0\n+    private static List<Arguments> createExponentValues(boolean negative) {\n+        List<Arguments> args = new ArrayList<>();\n+        \/\/ Start with a base value that should be parsed as infinity\n+        String baseValue = \"12234.123E1100\";\n+        \/\/ Continuously add to the String until we trigger the overflow condition\n+        for (int i = 0; i < 100; i++) {\n+            StringBuilder bldr = new StringBuilder();\n+            \/\/ Add to exponent\n+            bldr.append(baseValue).append(\"1\".repeat(i));\n+            \/\/ Add to mantissa\n+            bldr.insert(0, \"1\".repeat(i));\n+            args.add(Arguments.of(\n+                    \/\/ Prepend \"-\" to exponent if negative\n+                    negative ? bldr.insert(bldr.indexOf(\"E\")+1, \"-\").toString() : bldr.toString(),\n+                    \/\/ Expect 0 if negative, else infinity\n+                    negative ? 0.0 : Double.POSITIVE_INFINITY));\n+        }\n+        return args;\n+    }\n+\n+    \/\/ The provided values are all from the JBS issue\n+    \/\/ These contain exponents that exceed Integer.MAX_VALUE, but not Long.MAX_VALUE\n+    private static Stream<Arguments> bugReportValues() {\n+        return Stream.of(\n+                Arguments.of(\"0.123E1\", 1.23),\n+                Arguments.of(\"0.123E309\", 1.23E308),\n+                Arguments.of(\"0.123E310\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.123E2147483647\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.123E2147483648\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.0123E2147483648\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.0123E2147483649\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"1.23E2147483646\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"1.23E2147483647\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.123E4294967296\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.123E-322\", 9.9E-324),\n+                Arguments.of(\"0.123E-323\", 0.0),\n+                Arguments.of(\"0.123E-2147483648\", 0.0),\n+                Arguments.of(\"0.123E-2147483649\", 0.0)\n+        );\n+    }\n+\n+    \/\/ Some odd edge case values to ensure parse correctness\n+    private static Stream<Arguments> edgeCases() {\n+        return Stream.of(\n+                \/\/ Decimal in exponent, everything past decimal is ignored\n+                Arguments.of(\"1.23E33.332\", 1.23E33),\n+                \/\/ Non-numeric value in exponent, ignores subsequent chars\n+                Arguments.of(\"1.23E32ABC9920\", 1.23E32),\n+                \/\/ 0 exponent\n+                Arguments.of(\"1.23E0\", 1.23),\n+                \/\/ Leading zeroes\n+                Arguments.of(\"1.23E0000123\", 1.23E123),\n+                \/\/ Leading zeroes - Past Long.MAX_VALUE length\n+                Arguments.of(\"1.23E00000000000000000000000000000000000000000123\", 1.23E123),\n+                \/\/ Trailing zeroes\n+                Arguments.of(\"1.23E100\", 1.23E100),\n+                \/\/ Long.MAX_VALUE length\n+                Arguments.of(\"1.23E1234567891234567800\", Double.POSITIVE_INFINITY),\n+                \/\/ Long.MAX_VALUE with trailing zeroes\n+                Arguments.of(\"1.23E9223372036854775807000\", Double.POSITIVE_INFINITY),\n+                \/\/ Long.MIN_VALUE\n+                Arguments.of(\"1.23E-9223372036854775808\", 0.0)\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/LargeExponentsTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"}]}