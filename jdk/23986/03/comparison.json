{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,7 @@\n- * Utility class for ZIP file entry name and comment decoding and encoding\n+ * Utility class for ZIP file entry name and comment decoding and encoding.\n+ * <p>\n+ * The {@linkplain #UTF8 UTF-8 ZipCoder instance}, which gets returned by {@link #get(Charset)}\n+ * for {@linkplain java.nio.charset.StandardCharsets#UTF_8 UTF-8 Charset} is thread-safe\n+ * and can be used concurrently by multiple threads. All other {@code ZipCoder} instances\n+ * are not thread-safe and external synchronization is required by callers, if those\n+ * instances are to be used concurrently by multiple threads.\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,3 @@\n+    \/\/ the ZipCoder instance is derived from the Charset passed to the ZipFile constructor\n+    \/\/ and will be used for decoding the non-UTF-8 entry names and the ZIP file comment.\n+    private final ZipCoder zipCoder;\n@@ -201,1 +204,2 @@\n-        this.res = new CleanableResource(this, ZipCoder.get(charset), file, mode);\n+        this.res = new CleanableResource(this, charset, file, mode);\n+        this.zipCoder = ZipCoder.get(charset);\n@@ -268,1 +272,1 @@\n-                return res.zsrc.zc.toString(res.zsrc.comment);\n+                return zipCoder.toString(res.zsrc.comment);\n@@ -291,1 +295,1 @@\n-            EntryPos pos = res.zsrc.getEntryPos(name, true);\n+            EntryPos pos = res.zsrc.getEntryPos(name, true, zipCoder);\n@@ -331,1 +335,1 @@\n-                EntryPos entryPos = zsrc.getEntryPos(entry.name, false);\n+                EntryPos entryPos = zsrc.getEntryPos(entry.name, false, zipCoder);\n@@ -366,0 +370,10 @@\n+    \/**\n+     * {@return true if the ZIP entry corresponding to the given {@code pos} uses UTF-8\n+     * for entry name and comment field encoding, false otherwise}\n+     * @param cen the CEN\n+     * @param pos the entry position\n+     *\/\n+    private static boolean useUTF8Coder(final byte[] cen, final int pos) {\n+        return (CENFLG(cen, pos) & USE_UTF8) != 0;\n+    }\n+\n@@ -564,1 +578,1 @@\n-        ZipCoder zc = res.zsrc.zipCoderForPos(pos);\n+        ZipCoder zc = useUTF8Coder(cen, pos) ? ZipCoder.UTF8 : zipCoder;\n@@ -635,1 +649,1 @@\n-            ZipCoder zc = res.zsrc.zipCoderForPos(pos);\n+            ZipCoder zc = useUTF8Coder(cen, pos) ? ZipCoder.UTF8 : zipCoder;\n@@ -667,1 +681,1 @@\n-        CleanableResource(ZipFile zf, ZipCoder zc, File file, int mode) throws IOException {\n+        CleanableResource(ZipFile zf, Charset charset, File file, int mode) throws IOException {\n@@ -671,1 +685,1 @@\n-            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, zc);\n+            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, charset);\n@@ -1112,0 +1126,4 @@\n+    \/\/ Implementation note: This class must be thread-safe.\n+    \/\/ Each instance of Source could be shared between multiple different instances of ZipFile.\n+    \/\/ Although ZipFile isn't thread-safe, the fact that separate instances of ZipFile could\n+    \/\/ still concurrently use the same Source instance, mandates that Source must be thread-safe.\n@@ -1124,1 +1142,0 @@\n-        private final @Stable ZipCoder zc;   \/\/ ZIP coder used to decode\/encode\n@@ -1160,2 +1177,3 @@\n-        \/\/ then returns the length of the entry name.\n-        private int checkAndAddEntry(int pos, int index)\n+        \/\/ then returns the length of the entry name. Uses the given zipCoder for processing the\n+        \/\/ entry name and the entry comment (if any).\n+        private int checkAndAddEntry(final int pos, final int index, final ZipCoder zipCoder)\n@@ -1199,2 +1217,1 @@\n-                ZipCoder zcp = zipCoderForPos(pos);\n-                int hash = zcp.checkedHash(cen, entryPos, nlen);\n+                int hash = zipCoder.checkedHash(cen, entryPos, nlen);\n@@ -1205,3 +1222,3 @@\n-                entries[index++] = hash;\n-                entries[index++] = next;\n-                entries[index  ] = pos;\n+                entries[index] = hash;\n+                entries[index + 1] = next;\n+                entries[index + 2] = pos;\n@@ -1213,1 +1230,1 @@\n-                    zcp.toString(cen, start, clen);\n+                    zipCoder.toString(cen, start, clen);\n@@ -1392,5 +1409,9 @@\n-         * A class representing a key to a ZIP file. A key is based\n-         * on the file key if available, or the path value if the\n-         * file key is not available. The key is also based on the\n-         * file's last modified time to allow for cases where a ZIP\n-         * file is re-opened after it has been modified.\n+         * A class representing a key to the Source of a ZipFile.\n+         * The Key is composed of:\n+         * - The BasicFileAttributes.fileKey() if available, or the Path of the ZIP file\n+         * if the fileKey() is not available.\n+         * - The ZIP file's last modified time (to allow for cases\n+         * where a ZIP file is re-opened after it has been modified).\n+         * - The Charset, that was provided when constructing a ZipFile instance,\n+         * for reading non-UTF-8 entry names and comments.\n+         * The unique combination of these components identifies a Source of a ZipFile.\n@@ -1399,5 +1420,14 @@\n-            final BasicFileAttributes attrs;\n-            File file;\n-            final boolean utf8;\n-\n-            public Key(File file, BasicFileAttributes attrs, ZipCoder zc) {\n+            private final BasicFileAttributes attrs;\n+            private final File file;\n+            \/\/ the Charset to be used for processing non-UTF-8 entry names in the ZIP file\n+            \/\/ and the ZIP file comment\n+            private final Charset charset;\n+\n+            \/**\n+             * Constructs a {@code Key} to a {@code Source} of a {@code ZipFile}\n+             *\n+             * @param file    the ZIP file\n+             * @param attrs   the attributes of the ZIP file\n+             * @param charset the Charset that was provided when constructing the ZipFile instance\n+             *\/\n+            public Key(File file, BasicFileAttributes attrs, Charset charset) {\n@@ -1406,1 +1436,1 @@\n-                this.utf8 = zc.isUTF8();\n+                this.charset = charset;\n@@ -1409,0 +1439,1 @@\n+            @Override\n@@ -1410,1 +1441,1 @@\n-                long t = utf8 ? 0 : Long.MAX_VALUE;\n+                long t = charset.hashCode();\n@@ -1417,0 +1448,1 @@\n+            @Override\n@@ -1419,1 +1451,1 @@\n-                    if (key.utf8 != utf8) {\n+                    if (!charset.equals(key.charset)) {\n@@ -1443,1 +1475,1 @@\n-        static Source get(File file, boolean toDelete, ZipCoder zc) throws IOException {\n+        static Source get(File file, boolean toDelete, Charset charset) throws IOException {\n@@ -1448,1 +1480,1 @@\n-                                BasicFileAttributes.class), zc);\n+                                BasicFileAttributes.class), charset);\n@@ -1460,1 +1492,1 @@\n-            src = new Source(key, toDelete, zc);\n+            src = new Source(key, toDelete);\n@@ -1482,2 +1514,1 @@\n-        private Source(Key key, boolean toDelete, ZipCoder zc) throws IOException {\n-            this.zc = zc;\n+        private Source(Key key, boolean toDelete) throws IOException {\n@@ -1708,0 +1739,1 @@\n+            ZipCoder zipCoder = null;\n@@ -1719,0 +1751,13 @@\n+                \/\/ the ZipCoder for any non-UTF8 entries\n+                final ZipCoder entryZipCoder;\n+                if (useUTF8Coder(cen, pos)) {\n+                    \/\/ entry name explicitly wants UTF-8 Charset\n+                    entryZipCoder = ZipCoder.UTF8;\n+                } else {\n+                    \/\/ use the ZipCoder corresponding to the Charset that\n+                    \/\/ was provided when constructing the ZipFile\n+                    if (zipCoder == null) {\n+                        zipCoder = ZipCoder.get(key.charset);\n+                    }\n+                    entryZipCoder = zipCoder;\n+                }\n@@ -1720,1 +1765,1 @@\n-                int nlen = checkAndAddEntry(pos, idx);\n+                int nlen = checkAndAddEntry(pos, idx, entryZipCoder);\n@@ -1744,1 +1789,1 @@\n-                                int hashCode = zipCoderForPos(pos).checkedHash(cen,\n+                                int hashCode = entryZipCoder.checkedHash(cen,\n@@ -1789,1 +1834,1 @@\n-         *  to the specified entry name, or {@code null} if not found.\n+         * to the specified entry name, or {@code null} if not found.\n@@ -1791,1 +1836,2 @@\n-        private EntryPos getEntryPos(String name, boolean addSlash) {\n+        private EntryPos getEntryPos(final String name, final boolean addSlash,\n+                                     final ZipCoder zipCoder) {\n@@ -1810,2 +1856,9 @@\n-                    ZipCoder zc = zipCoderForPos(pos);\n-\n+                    final ZipCoder zc;\n+                    if (useUTF8Coder(cen, pos)) {\n+                        \/\/ entry name explicitly wants UTF-8 Charset\n+                        zc = ZipCoder.UTF8;\n+                    } else {\n+                        \/\/ use the ZipCoder corresponding to the Charset that\n+                        \/\/ was provided when constructing the ZipFile\n+                        zc = zipCoder;\n+                    }\n@@ -1836,10 +1889,0 @@\n-\n-        private ZipCoder zipCoderForPos(int pos) {\n-            if (zc.isUTF8()) {\n-                return zc;\n-            }\n-            if ((CENFLG(cen, pos) & USE_UTF8) != 0) {\n-                return ZipCoder.UTF8;\n-            }\n-            return zc;\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":95,"deletions":52,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n+\/*\n+ * @test\n+ * @bug 8347712\n+ * @summary verify that different instances of java.util.zip.ZipFile do not share\n+ *          the same instance of (non-thread-safe) java.nio.charset.CharsetEncoder\/CharsetDecoder\n+ * @run junit ZipFileSharedSourceTest\n+ *\/\n+public class ZipFileSharedSourceTest {\n+\n+    static Path createZipFile(final Charset entryNameCharset) throws Exception {\n+        final Path zipFilePath = Files.createTempFile(Path.of(\".\"), \"8347712\", \".zip\");\n+        try (OutputStream os = Files.newOutputStream(zipFilePath);\n+             ZipOutputStream zos = new ZipOutputStream(os, entryNameCharset)) {\n+            final int numEntries = 10240;\n+            for (int i = 1; i <= numEntries; i++) {\n+                final ZipEntry entry = new ZipEntry(\"entry-\" + i);\n+                zos.putNextEntry(entry);\n+                zos.write(\"foo bar\".getBytes(US_ASCII));\n+                zos.closeEntry();\n+            }\n+        }\n+        return zipFilePath;\n+    }\n+\n+    static List<Arguments> charsets() {\n+        return List.of(\n+                Arguments.of(StandardCharsets.UTF_8),\n+                Arguments.of(StandardCharsets.ISO_8859_1),\n+                Arguments.of(US_ASCII)\n+        );\n+    }\n+\n+    \/**\n+     * Creates multiple instances of java.util.zip.ZipFile with the given {@code entryNameCharset}\n+     * for the same underlying ZIP file. Then each instance of the ZipFile is iterated\n+     * over its entries, concurrently in a separate thread. Verifies that such access\n+     * to independent ZipFile instances, doesn't lead to unexpected failures contributed\n+     * by concurrent thread execution.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsets\")\n+    void testMultipleZipFileInstances(final Charset entryNameCommentCharset) throws Exception {\n+        final Path zipFilePath = createZipFile(entryNameCommentCharset);\n+        final int numTasks = 200;\n+        final CountDownLatch startLatch = new CountDownLatch(numTasks);\n+        final List<Future<Void>> results = new ArrayList<>();\n+        try (final ExecutorService executor =\n+                     Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory())) {\n+            for (int i = 0; i < numTasks; i++) {\n+                final var task = new ZipEntryIteratingTask(zipFilePath, entryNameCommentCharset,\n+                        startLatch);\n+                results.add(executor.submit(task));\n+            }\n+            System.out.println(numTasks + \" tasks submitted, waiting for them to complete\");\n+            for (final Future<Void> f : results) {\n+                f.get();\n+            }\n+        }\n+        System.out.println(\"All \" + numTasks + \" tasks completed successfully\");\n+    }\n+\n+    private static final class ZipEntryIteratingTask implements Callable<Void> {\n+        private final Path file;\n+        private final Charset entryNameCharset;\n+        private final CountDownLatch startLatch;\n+\n+        private ZipEntryIteratingTask(final Path file, final Charset entryNameCharset,\n+                                      final CountDownLatch startLatch) {\n+            this.file = file;\n+            this.entryNameCharset = entryNameCharset;\n+            this.startLatch = startLatch;\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            \/\/ let other tasks know we are ready to run\n+            this.startLatch.countDown();\n+            \/\/ wait for other tasks to be ready to run\n+            this.startLatch.await();\n+            \/\/ create a new instance of ZipFile and iterate over the entries\n+            try (final ZipFile zf = new ZipFile(this.file.toFile(), this.entryNameCharset)) {\n+                final var entries = zf.entries();\n+                while (entries.hasMoreElements()) {\n+                    entries.nextElement();\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ZipFileSharedSourceTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"}]}