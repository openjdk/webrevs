{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,7 @@\n- * Utility class for ZIP file entry name and comment decoding and encoding\n+ * Utility class for ZIP file entry name and comment decoding and encoding.\n+ * <p>\n+ * The {@linkplain #UTF8 UTF-8 ZipCoder instance}, which gets returned by {@link #get(Charset)}\n+ * for {@linkplain java.nio.charset.StandardCharsets#UTF_8 UTF-8 Charset} is thread-safe\n+ * and can be used concurrently by multiple threads. All other {@code ZipCoder} instances\n+ * are not thread-safe and external synchronization is required by callers, if those\n+ * instances are to be used concurrently by multiple threads.\n@@ -177,0 +183,7 @@\n+    \/**\n+     * {@return the {@link Charset} used this {@code ZipCoder}}\n+     *\/\n+    final Charset charset() {\n+        return this.cs;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,3 @@\n+    \/\/ the ZipCoder instance is derived from the Charset passed to the ZipFile constructor\n+    \/\/ and will be used for decoding the non-UTF-8 entry names and the ZIP file comment.\n+    private final ZipCoder zipCoder;\n@@ -201,1 +204,2 @@\n-        this.res = new CleanableResource(this, ZipCoder.get(charset), file, mode);\n+        this.zipCoder = ZipCoder.get(charset);\n+        this.res = new CleanableResource(this, zipCoder, file, mode);\n@@ -268,1 +272,1 @@\n-                return res.zsrc.zc.toString(res.zsrc.comment);\n+                return zipCoder.toString(res.zsrc.comment);\n@@ -291,1 +295,1 @@\n-            EntryPos pos = res.zsrc.getEntryPos(name, true);\n+            EntryPos pos = res.zsrc.getEntryPos(name, true, zipCoder);\n@@ -331,1 +335,1 @@\n-                EntryPos entryPos = zsrc.getEntryPos(entry.name, false);\n+                EntryPos entryPos = zsrc.getEntryPos(entry.name, false, zipCoder);\n@@ -366,0 +370,29 @@\n+    \/**\n+     * Determines and returns a {@link ZipCoder} to use for decoding\n+     * name and comment fields of the ZIP entry identified by the {@code pos}\n+     * in the ZIP file's {@code cen}.\n+     * <p>\n+     * A ZIP entry's name and comment fields may be encoded using UTF-8, in\n+     * which case this method returns a UTF-8 capable {@code ZipCoder}. If the\n+     * entry doesn't require UTF-8, then this method returns the {@code fallback}\n+     * {@code ZipCoder}.\n+     *\n+     * @param cen the CEN\n+     * @param pos the ZIP entry's position in CEN\n+     * @param fallback the fallback ZipCoder to return if the entry doesn't require UTF-8\n+     *\/\n+    private static ZipCoder zipCoderFor(final byte[] cen, final int pos, final ZipCoder fallback) {\n+        if (fallback.isUTF8()) {\n+            \/\/ the fallback ZipCoder is capable of handling UTF-8,\n+            \/\/ so no need to parse the entry flags to determine if\n+            \/\/ the entry has UTF-8 flag.\n+            return fallback;\n+        }\n+        if ((CENFLG(cen, pos) & USE_UTF8) != 0) {\n+            \/\/ entry requires a UTF-8 ZipCoder\n+            return ZipCoder.UTF8;\n+        }\n+        \/\/ entry doesn't require a UTF-8 ZipCoder\n+        return fallback;\n+    }\n+\n@@ -564,1 +597,1 @@\n-        ZipCoder zc = res.zsrc.zipCoderForPos(pos);\n+        ZipCoder zc = zipCoderFor(cen, pos, zipCoder);\n@@ -635,1 +668,1 @@\n-            ZipCoder zc = res.zsrc.zipCoderForPos(pos);\n+            ZipCoder zc = zipCoderFor(cen, pos, zipCoder);\n@@ -667,1 +700,2 @@\n-        CleanableResource(ZipFile zf, ZipCoder zc, File file, int mode) throws IOException {\n+        CleanableResource(ZipFile zf, ZipCoder zipCoder, File file, int mode) throws IOException {\n+            assert zipCoder != null : \"null ZipCoder\";\n@@ -671,1 +705,1 @@\n-            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, zc);\n+            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, zipCoder);\n@@ -1112,0 +1146,4 @@\n+    \/\/ Implementation note: This class must be thread-safe.\n+    \/\/ Each instance of Source could be shared between multiple different instances of ZipFile.\n+    \/\/ Although ZipFile isn't thread-safe, the fact that separate instances of ZipFile could\n+    \/\/ still concurrently use the same Source instance, mandates that Source must be thread-safe.\n@@ -1124,1 +1162,0 @@\n-        private final @Stable ZipCoder zc;   \/\/ ZIP coder used to decode\/encode\n@@ -1160,2 +1197,3 @@\n-        \/\/ then returns the length of the entry name.\n-        private int checkAndAddEntry(int pos, int index)\n+        \/\/ then returns the length of the entry name. Uses the given zipCoder for processing the\n+        \/\/ entry name and the entry comment (if any).\n+        private int checkAndAddEntry(final int pos, final int index, final ZipCoder zipCoder)\n@@ -1199,2 +1237,1 @@\n-                ZipCoder zcp = zipCoderForPos(pos);\n-                int hash = zcp.checkedHash(cen, entryPos, nlen);\n+                int hash = zipCoder.checkedHash(cen, entryPos, nlen);\n@@ -1205,3 +1242,3 @@\n-                entries[index++] = hash;\n-                entries[index++] = next;\n-                entries[index  ] = pos;\n+                entries[index] = hash;\n+                entries[index + 1] = next;\n+                entries[index + 2] = pos;\n@@ -1213,1 +1250,1 @@\n-                    zcp.toString(cen, start, clen);\n+                    zipCoder.toString(cen, start, clen);\n@@ -1392,5 +1429,9 @@\n-         * A class representing a key to a ZIP file. A key is based\n-         * on the file key if available, or the path value if the\n-         * file key is not available. The key is also based on the\n-         * file's last modified time to allow for cases where a ZIP\n-         * file is re-opened after it has been modified.\n+         * A class representing a key to the Source of a ZipFile.\n+         * The Key is composed of:\n+         * - The BasicFileAttributes.fileKey() if available, or the Path of the ZIP file\n+         * if the fileKey() is not available.\n+         * - The ZIP file's last modified time (to allow for cases\n+         * where a ZIP file is re-opened after it has been modified).\n+         * - The Charset, that was provided when constructing a ZipFile instance,\n+         * for reading non-UTF-8 entry names and comments.\n+         * The unique combination of these components identifies a Source of a ZipFile.\n@@ -1399,5 +1440,14 @@\n-            final BasicFileAttributes attrs;\n-            File file;\n-            final boolean utf8;\n-\n-            public Key(File file, BasicFileAttributes attrs, ZipCoder zc) {\n+            private final BasicFileAttributes attrs;\n+            private final File file;\n+            \/\/ the Charset to be used for processing non-UTF-8 entry names in the ZIP file\n+            \/\/ and the ZIP file comment\n+            private final Charset charset;\n+\n+            \/**\n+             * Constructs a {@code Key} to a {@code Source} of a {@code ZipFile}\n+             *\n+             * @param file    the ZIP file\n+             * @param attrs   the attributes of the ZIP file\n+             * @param charset the Charset that was provided when constructing the ZipFile instance\n+             *\/\n+            public Key(File file, BasicFileAttributes attrs, Charset charset) {\n@@ -1406,1 +1456,1 @@\n-                this.utf8 = zc.isUTF8();\n+                this.charset = charset;\n@@ -1409,0 +1459,1 @@\n+            @Override\n@@ -1410,1 +1461,1 @@\n-                long t = utf8 ? 0 : Long.MAX_VALUE;\n+                long t = charset.hashCode();\n@@ -1417,0 +1468,1 @@\n+            @Override\n@@ -1419,1 +1471,1 @@\n-                    if (key.utf8 != utf8) {\n+                    if (!charset.equals(key.charset)) {\n@@ -1443,1 +1495,1 @@\n-        static Source get(File file, boolean toDelete, ZipCoder zc) throws IOException {\n+        static Source get(File file, boolean toDelete, ZipCoder zipCoder) throws IOException {\n@@ -1448,1 +1500,1 @@\n-                                BasicFileAttributes.class), zc);\n+                                BasicFileAttributes.class), zipCoder.charset());\n@@ -1460,1 +1512,1 @@\n-            src = new Source(key, toDelete, zc);\n+            src = new Source(key, toDelete, zipCoder);\n@@ -1482,2 +1534,1 @@\n-        private Source(Key key, boolean toDelete, ZipCoder zc) throws IOException {\n-            this.zc = zc;\n+        private Source(Key key, boolean toDelete, ZipCoder zipCoder) throws IOException {\n@@ -1497,1 +1548,1 @@\n-                initCEN(-1);\n+                initCEN(-1, zipCoder);\n@@ -1652,1 +1703,1 @@\n-        private void initCEN(int knownTotal) throws IOException {\n+        private void initCEN(final int knownTotal, final ZipCoder zipCoder) throws IOException {\n@@ -1714,1 +1765,1 @@\n-                    initCEN(countCENHeaders(cen));\n+                    initCEN(countCENHeaders(cen), zipCoder);\n@@ -1719,0 +1770,2 @@\n+                \/\/ the ZipCoder for any non-UTF8 entries\n+                final ZipCoder entryZipCoder = zipCoderFor(cen, pos, zipCoder);\n@@ -1720,1 +1773,1 @@\n-                int nlen = checkAndAddEntry(pos, idx);\n+                int nlen = checkAndAddEntry(pos, idx, entryZipCoder);\n@@ -1744,1 +1797,1 @@\n-                                int hashCode = zipCoderForPos(pos).checkedHash(cen,\n+                                int hashCode = entryZipCoder.checkedHash(cen,\n@@ -1789,1 +1842,1 @@\n-         *  to the specified entry name, or {@code null} if not found.\n+         * to the specified entry name, or {@code null} if not found.\n@@ -1791,1 +1844,2 @@\n-        private EntryPos getEntryPos(String name, boolean addSlash) {\n+        private EntryPos getEntryPos(final String name, final boolean addSlash,\n+                                     final ZipCoder zipCoder) {\n@@ -1810,2 +1864,1 @@\n-                    ZipCoder zc = zipCoderForPos(pos);\n-\n+                    final ZipCoder zc = zipCoderFor(cen, pos, zipCoder);\n@@ -1836,10 +1889,0 @@\n-\n-        private ZipCoder zipCoderForPos(int pos) {\n-            if (zc.isUTF8()) {\n-                return zc;\n-            }\n-            if ((CENFLG(cen, pos) & USE_UTF8) != 0) {\n-                return ZipCoder.UTF8;\n-            }\n-            return zc;\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":98,"deletions":55,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.OutputStream;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n+\/*\n+ * @test\n+ * @bug 8347712\n+ * @summary verify that different instances of java.util.zip.ZipFile do not share\n+ *          the same instance of (non-thread-safe) java.nio.charset.CharsetEncoder\/CharsetDecoder\n+ * @run junit ZipFileSharedSourceTest\n+ *\/\n+public class ZipFileSharedSourceTest {\n+\n+    static Path createZipFile(final Charset charset) throws Exception {\n+        final Path zipFilePath = Files.createTempFile(Path.of(\".\"), \"8347712\", \".zip\");\n+        try (OutputStream os = Files.newOutputStream(zipFilePath);\n+             ZipOutputStream zos = new ZipOutputStream(os, charset)) {\n+            final int numEntries = 10240;\n+            for (int i = 1; i <= numEntries; i++) {\n+                final ZipEntry entry = new ZipEntry(\"entry-\" + i);\n+                zos.putNextEntry(entry);\n+                zos.write(\"foo bar\".getBytes(US_ASCII));\n+                zos.closeEntry();\n+            }\n+        }\n+        return zipFilePath;\n+    }\n+\n+    static List<Arguments> charsets() {\n+        return List.of(\n+                Arguments.of(StandardCharsets.UTF_8),\n+                Arguments.of(StandardCharsets.ISO_8859_1),\n+                Arguments.of(US_ASCII)\n+        );\n+    }\n+\n+    \/**\n+     * In this test, multiple concurrent threads each create an instance of java.util.zip.ZipFile\n+     * with the given {@code charset} for the same underlying ZIP file. Each of the threads\n+     * then iterate over the entries of their ZipFile instance. The test verifies that such access,\n+     * where each thread is accessing an independent ZipFile instance corresponding to the same\n+     * underlying ZIP file, doesn't lead to unexpected failures contributed by concurrent\n+     * threads.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"charsets\")\n+    void testMultipleZipFileInstances(final Charset charset) throws Exception {\n+        final Path zipFilePath = createZipFile(charset);\n+        final int numTasks = 200;\n+        final CountDownLatch startLatch = new CountDownLatch(numTasks);\n+        final List<Future<Void>> results = new ArrayList<>();\n+        try (final ExecutorService executor =\n+                     Executors.newThreadPerTaskExecutor(Thread.ofPlatform().factory())) {\n+            for (int i = 0; i < numTasks; i++) {\n+                final var task = new ZipEntryIteratingTask(zipFilePath, charset,\n+                        startLatch);\n+                results.add(executor.submit(task));\n+            }\n+            System.out.println(numTasks + \" tasks submitted, waiting for them to complete\");\n+            for (final Future<Void> f : results) {\n+                f.get();\n+            }\n+        }\n+        System.out.println(\"All \" + numTasks + \" tasks completed successfully\");\n+    }\n+\n+    private static final class ZipEntryIteratingTask implements Callable<Void> {\n+        private final Path file;\n+        private final Charset charset;\n+        private final CountDownLatch startLatch;\n+\n+        private ZipEntryIteratingTask(final Path file, final Charset charset,\n+                                      final CountDownLatch startLatch) {\n+            this.file = file;\n+            this.charset = charset;\n+            this.startLatch = startLatch;\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            \/\/ let other tasks know we are ready to run\n+            this.startLatch.countDown();\n+            \/\/ wait for other tasks to be ready to run\n+            this.startLatch.await();\n+            \/\/ create a new instance of ZipFile and iterate over the entries\n+            try (final ZipFile zf = new ZipFile(this.file.toFile(), this.charset)) {\n+                final var entries = zf.entries();\n+                while (entries.hasMoreElements()) {\n+                    final ZipEntry ze = entries.nextElement();\n+                    \/\/ additionally exercise the ZipFile.getEntry() method\n+                    zf.getEntry(ze.getName());\n+                }\n+            }\n+            return null;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ZipFileSharedSourceTest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"}]}