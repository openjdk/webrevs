{"files":[{"patch":"@@ -183,0 +183,7 @@\n+    \/**\n+     * {@return the {@link Charset} used this {@code ZipCoder}}\n+     *\/\n+    final Charset charset() {\n+        return this.cs;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -204,1 +204,0 @@\n-        this.res = new CleanableResource(this, charset, file, mode);\n@@ -206,0 +205,1 @@\n+        this.res = new CleanableResource(this, zipCoder, file, mode);\n@@ -371,2 +371,9 @@\n-     * {@return true if the ZIP entry corresponding to the given {@code pos} uses UTF-8\n-     * for entry name and comment field encoding, false otherwise}\n+     * Determines and returns a {@link ZipCoder} to use for decoding\n+     * name and comment fields of the ZIP entry identified by the {@code pos}\n+     * in the ZIP file's {@code cen}.\n+     * <p>\n+     * A ZIP entry's name and comment fields may be encoded using UTF-8, in\n+     * which case this method returns a UTF-8 capable {@code ZipCoder}. If the\n+     * entry doesn't require UTF-8, then this method returns the {@code fallback}\n+     * {@code ZipCoder}.\n+     *\n@@ -374,1 +381,2 @@\n-     * @param pos the entry position\n+     * @param pos the ZIP entry's position in CEN\n+     * @param fallback the fallback ZipCoder to return if the entry doesn't require UTF-8\n@@ -376,2 +384,13 @@\n-    private static boolean useUTF8Coder(final byte[] cen, final int pos) {\n-        return (CENFLG(cen, pos) & USE_UTF8) != 0;\n+    private static ZipCoder zipCoderFor(final byte[] cen, final int pos, final ZipCoder fallback) {\n+        if (fallback.isUTF8()) {\n+            \/\/ the fallback ZipCoder is capable of handling UTF-8,\n+            \/\/ so no need to parse the entry flags to determine if\n+            \/\/ the entry has UTF-8 flag.\n+            return fallback;\n+        }\n+        if ((CENFLG(cen, pos) & USE_UTF8) != 0) {\n+            \/\/ entry requires a UTF-8 ZipCoder\n+            return ZipCoder.UTF8;\n+        }\n+        \/\/ entry doesn't require a UTF-8 ZipCoder\n+        return fallback;\n@@ -578,1 +597,1 @@\n-        ZipCoder zc = useUTF8Coder(cen, pos) ? ZipCoder.UTF8 : zipCoder;\n+        ZipCoder zc = zipCoderFor(cen, pos, zipCoder);\n@@ -649,1 +668,1 @@\n-            ZipCoder zc = useUTF8Coder(cen, pos) ? ZipCoder.UTF8 : zipCoder;\n+            ZipCoder zc = zipCoderFor(cen, pos, zipCoder);\n@@ -681,1 +700,2 @@\n-        CleanableResource(ZipFile zf, Charset charset, File file, int mode) throws IOException {\n+        CleanableResource(ZipFile zf, ZipCoder zipCoder, File file, int mode) throws IOException {\n+            assert zipCoder != null : \"null ZipCoder\";\n@@ -685,1 +705,1 @@\n-            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, charset);\n+            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, zipCoder);\n@@ -1475,1 +1495,1 @@\n-        static Source get(File file, boolean toDelete, Charset charset) throws IOException {\n+        static Source get(File file, boolean toDelete, ZipCoder zipCoder) throws IOException {\n@@ -1480,1 +1500,1 @@\n-                                BasicFileAttributes.class), charset);\n+                                BasicFileAttributes.class), zipCoder.charset());\n@@ -1492,1 +1512,1 @@\n-            src = new Source(key, toDelete);\n+            src = new Source(key, toDelete, zipCoder);\n@@ -1514,1 +1534,1 @@\n-        private Source(Key key, boolean toDelete) throws IOException {\n+        private Source(Key key, boolean toDelete, ZipCoder zipCoder) throws IOException {\n@@ -1528,1 +1548,1 @@\n-                initCEN(-1);\n+                initCEN(-1, zipCoder);\n@@ -1683,1 +1703,1 @@\n-        private void initCEN(int knownTotal) throws IOException {\n+        private void initCEN(final int knownTotal, final ZipCoder zipCoder) throws IOException {\n@@ -1739,1 +1759,0 @@\n-            ZipCoder zipCoder = null;\n@@ -1746,1 +1765,1 @@\n-                    initCEN(countCENHeaders(cen));\n+                    initCEN(countCENHeaders(cen), zipCoder);\n@@ -1752,12 +1771,1 @@\n-                final ZipCoder entryZipCoder;\n-                if (useUTF8Coder(cen, pos)) {\n-                    \/\/ entry name explicitly wants UTF-8 Charset\n-                    entryZipCoder = ZipCoder.UTF8;\n-                } else {\n-                    \/\/ use the ZipCoder corresponding to the Charset that\n-                    \/\/ was provided when constructing the ZipFile\n-                    if (zipCoder == null) {\n-                        zipCoder = ZipCoder.get(key.charset);\n-                    }\n-                    entryZipCoder = zipCoder;\n-                }\n+                final ZipCoder entryZipCoder = zipCoderFor(cen, pos, zipCoder);\n@@ -1856,9 +1864,1 @@\n-                    final ZipCoder zc;\n-                    if (useUTF8Coder(cen, pos)) {\n-                        \/\/ entry name explicitly wants UTF-8 Charset\n-                        zc = ZipCoder.UTF8;\n-                    } else {\n-                        \/\/ use the ZipCoder corresponding to the Charset that\n-                        \/\/ was provided when constructing the ZipFile\n-                        zc = zipCoder;\n-                    }\n+                    final ZipCoder zc = zipCoderFor(cen, pos, zipCoder);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":39,"deletions":39,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    static Path createZipFile(final Charset entryNameCharset) throws Exception {\n+    static Path createZipFile(final Charset charset) throws Exception {\n@@ -57,1 +57,1 @@\n-             ZipOutputStream zos = new ZipOutputStream(os, entryNameCharset)) {\n+             ZipOutputStream zos = new ZipOutputStream(os, charset)) {\n@@ -78,5 +78,6 @@\n-     * Creates multiple instances of java.util.zip.ZipFile with the given {@code entryNameCharset}\n-     * for the same underlying ZIP file. Then each instance of the ZipFile is iterated\n-     * over its entries, concurrently in a separate thread. Verifies that such access\n-     * to independent ZipFile instances, doesn't lead to unexpected failures contributed\n-     * by concurrent thread execution.\n+     * In this test, multiple concurrent threads each create an instance of java.util.zip.ZipFile\n+     * with the given {@code charset} for the same underlying ZIP file. Each of the threads\n+     * then iterate over the entries of their ZipFile instance. The test verifies that such access,\n+     * where each thread is accessing an independent ZipFile instance corresponding to the same\n+     * underlying ZIP file, doesn't lead to unexpected failures contributed by concurrent\n+     * threads.\n@@ -86,2 +87,2 @@\n-    void testMultipleZipFileInstances(final Charset entryNameCommentCharset) throws Exception {\n-        final Path zipFilePath = createZipFile(entryNameCommentCharset);\n+    void testMultipleZipFileInstances(final Charset charset) throws Exception {\n+        final Path zipFilePath = createZipFile(charset);\n@@ -94,1 +95,1 @@\n-                final var task = new ZipEntryIteratingTask(zipFilePath, entryNameCommentCharset,\n+                final var task = new ZipEntryIteratingTask(zipFilePath, charset,\n@@ -108,1 +109,1 @@\n-        private final Charset entryNameCharset;\n+        private final Charset charset;\n@@ -111,1 +112,1 @@\n-        private ZipEntryIteratingTask(final Path file, final Charset entryNameCharset,\n+        private ZipEntryIteratingTask(final Path file, final Charset charset,\n@@ -114,1 +115,1 @@\n-            this.entryNameCharset = entryNameCharset;\n+            this.charset = charset;\n@@ -125,1 +126,1 @@\n-            try (final ZipFile zf = new ZipFile(this.file.toFile(), this.entryNameCharset)) {\n+            try (final ZipFile zf = new ZipFile(this.file.toFile(), this.charset)) {\n@@ -128,1 +129,3 @@\n-                    entries.nextElement();\n+                    final ZipEntry ze = entries.nextElement();\n+                    \/\/ additionally exercise the ZipFile.getEntry() method\n+                    zf.getEntry(ze.getName());\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ZipFileSharedSourceTest.java","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"}]}