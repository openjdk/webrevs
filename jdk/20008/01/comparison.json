{"files":[{"patch":"@@ -600,0 +600,1 @@\n+\n@@ -601,2 +602,2 @@\n-        int nBits = n&0x1F;\n-        int bitsInHighWord = BigInteger.bitLengthForInt(value[offset]);\n+        int nBits = n & 0x1F;\n+        int leadingZeros = Integer.numberOfLeadingZeros(value[offset]);\n@@ -605,1 +606,1 @@\n-        if (n <= (32-bitsInHighWord)) {\n+        if (n <= leadingZeros) {\n@@ -610,13 +611,9 @@\n-        int newLen = intLen + nInts +1;\n-        if (nBits <= (32-bitsInHighWord))\n-            newLen--;\n-        if (value.length < newLen) {\n-            \/\/ The array must grow\n-            int[] result = new int[newLen];\n-            for (int i=0; i < intLen; i++)\n-                result[i] = value[offset+i];\n-            setValue(result, newLen);\n-        } else if (value.length - offset >= newLen) {\n-            \/\/ Use space on right\n-            for(int i=0; i < newLen - intLen; i++)\n-                value[offset+intLen+i] = 0;\n+        int newLen = intLen + nInts;\n+        if (nBits > leadingZeros)\n+            newLen++;\n+\n+        int[] result;\n+        final int newOffset;\n+        if (value.length < newLen) { \/\/ The array must grow\n+            result = new int[newLen];\n+            newOffset = 0;\n@@ -624,6 +621,17 @@\n-            \/\/ Must use space on left\n-            for (int i=0; i < intLen; i++)\n-                value[i] = value[offset+i];\n-            for (int i=intLen; i < newLen; i++)\n-                value[i] = 0;\n-            offset = 0;\n+            result = value;\n+            newOffset = value.length - offset >= newLen ? offset : 0;\n+        }\n+\n+        int len = intLen;\n+        if (nBits != 0) {\n+            \/\/ Do primitive shift directly for speed\n+            if (nBits <= leadingZeros) {\n+                primitiveLeftShift(nBits, result, newOffset); \/\/ newOffset <= offset\n+            } else {\n+                int lastInt = value[offset + intLen - 1];\n+                primitiveRightShift(32 - nBits, result, newOffset); \/\/ newOffset <= offset\n+                result[newOffset + len] = lastInt << nBits;\n+                len++;\n+            }\n+        } else if (result != value || newOffset != offset) {\n+            System.arraycopy(value, offset, result, newOffset, intLen);\n@@ -631,0 +639,6 @@\n+\n+        \/\/ Add trailing zeros\n+        if (result == value)\n+            Arrays.fill(result, newOffset + len, newOffset + newLen, 0);\n+\n+        value = result;\n@@ -632,6 +646,1 @@\n-        if (nBits == 0)\n-            return;\n-        if (nBits <= (32-bitsInHighWord))\n-            primitiveLeftShift(nBits);\n-        else\n-            primitiveRightShift(32 -nBits);\n+        offset = newOffset;\n@@ -702,0 +711,13 @@\n+        primitiveRightShift(n, value, offset);\n+    }\n+\n+    \/**\n+     * Right shift this MutableBigInteger n bits, where n is\n+     * less than 32, placing the result in the specified array.\n+     * Assumes that intLen > 0, n > 0 for speed.\n+     * The result can be the value array of this MutableBigInteger,\n+     * but for speed the copy is not performed safely, so, in that case\n+     * the caller has to make sure that\n+     * {@code (resPos <= offset || resPos >= offset + intLen)}.\n+     *\/\n+    private final void primitiveRightShift(int n, int[] result, int resPos) {\n@@ -704,4 +726,7 @@\n-        for (int i=offset+intLen-1, c=val[i]; i > offset; i--) {\n-            int b = c;\n-            c = val[i-1];\n-            val[i] = (c << n2) | (b >>> n);\n+\n+        int b = val[offset];\n+        result[resPos] = b >>> n;\n+        for (int i = 1; i < intLen; i++) {\n+            int c = b;\n+            b = val[offset + i];\n+            result[resPos + i] = (c << n2) | (b >>> n);\n@@ -709,1 +734,0 @@\n-        val[offset] >>>= n;\n@@ -718,0 +742,13 @@\n+        primitiveLeftShift(n, value, offset);\n+    }\n+\n+    \/**\n+     * Left shift this MutableBigInteger n bits, where n is\n+     * less than 32, placing the result in the specified array.\n+     * Assumes that intLen > 0, n > 0 for speed.\n+     * The result can be the value array of this MutableBigInteger,\n+     * but for speed the copy is not performed safely, so, in that case\n+     * the caller has to make sure that\n+     * {@code (resPos <= offset || resPos >= offset + intLen)}.\n+     *\/\n+    private final void primitiveLeftShift(int n, int[] result, int resPos) {\n@@ -720,1 +757,2 @@\n-        for (int i=offset, c=val[i], m=i+intLen-1; i < m; i++) {\n+        final int m = intLen - 1;\n+        for (int i = 0, c = val[offset + i]; i < m; i++) {\n@@ -722,2 +760,2 @@\n-            c = val[i+1];\n-            val[i] = (b << n) | (c >>> n2);\n+            c = val[offset + i + 1];\n+            result[resPos + i] = (b << n) | (c >>> n2);\n@@ -725,1 +763,1 @@\n-        val[offset+intLen-1] <<= n;\n+        result[resPos + m] = val[offset + m] << n;\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":75,"deletions":37,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+import java.math.BigInteger;\n+import java.math.MutableBigIntegerBox;\n+import java.util.Random;\n+import jdk.test.lib.RandomFactory;\n+\n+import static java.math.MutableBigIntegerBox.*;\n+\n+public class MutableBigIntegerShiftTests {\n+\n+    static final int ORDER_SMALL = 60;\n+    static final int ORDER_MEDIUM = 100;\n+\n+    private static Random random = RandomFactory.getRandom();\n+\n+    static boolean failure = false;\n+\n+    public static void shift(int order) {\n+        int failCount1 = 0;\n+        int failCount2 = 0;\n+\n+        for (int i=0; i<100; i++) {\n+            MutableBigIntegerBox x = fetchNumber(order);\n+            int n = Math.abs(random.nextInt()%200);\n+\n+            if (x.shiftLeft(n).compare\n+                (x.multiply(new MutableBigIntegerBox(BigInteger.TWO.pow(n)))) != 0) {\n+                failCount1++;\n+            }\n+\n+            if (x.shiftLeft(n).shiftRight(n).compare(x) != 0)\n+                failCount2++;\n+        }\n+        report(\"baz shiftLeft for \" + order + \" bits\", failCount1);\n+        report(\"baz shiftRight for \" + order + \" bits\", failCount2);\n+    }\n+\n+    \/**\n+     * Main to interpret arguments and run several tests.\n+     *\n+     * Up to three arguments may be given to specify the SIZE of BigIntegers\n+     * used for call parameters 1, 2, and 3. The SIZE is interpreted as\n+     * the maximum number of decimal digits that the parameters will have.\n+     *\n+     *\/\n+    public static void main(String[] args) {\n+        \/\/ Some variables for sizing test numbers in bits\n+        int order1 = ORDER_MEDIUM;\n+        int order2 = ORDER_SMALL;\n+\n+        if (args.length >0)\n+            order1 = (int)((Integer.parseInt(args[0]))* 3.333);\n+        if (args.length >1)\n+            order2 = (int)((Integer.parseInt(args[1]))* 3.333);\n+\n+        shift(order1);\n+        shift(order2);\n+\n+        if (failure)\n+            throw new RuntimeException(\"Failure in MutableBigIntegerShiftTests.\");\n+    }\n+\n+    \/*\n+     * Get a random or boundary-case number. This is designed to provide\n+     * a lot of numbers that will find failure points, such as max sized\n+     * numbers, empty MutableBigIntegers, etc.\n+     *\n+     * If order is less than 2, order is changed to 2.\n+     *\/\n+    private static MutableBigIntegerBox fetchNumber(int order) {\n+        int numType = random.nextInt(7);\n+        MutableBigIntegerBox result = null;\n+        if (order < 2) order = 2;\n+\n+        switch (numType) {\n+            case 0: \/\/ Empty\n+                result = MutableBigIntegerBox.ZERO;\n+                break;\n+\n+            case 1: \/\/ One\n+                result = MutableBigIntegerBox.ONE;\n+                break;\n+\n+            case 2: \/\/ All bits set in number\n+                int numInts = (order + 31) >> 5;\n+                int[] fullBits = new int[numInts];\n+                for(int i = 0; i < numInts; i++)\n+                    fullBits[i] = -1;\n+\n+                fullBits[0] &= -1 >>> -order;\n+                result = new MutableBigIntegerBox(fullBits);\n+                break;\n+\n+            case 3: \/\/ One bit in number\n+                result = MutableBigIntegerBox.ONE.shiftLeft(random.nextInt(order));\n+                break;\n+\n+            case 4: \/\/ Random bit density\n+                int[] val = new int[(order + 31) >> 5];\n+                int iterations = random.nextInt(order);\n+                for (int i = 0; i < iterations; i++) {\n+                    int bitIdx = random.nextInt(order);\n+                    val[bitIdx >> 5] |= 1 << bitIdx;\n+                }\n+                result = new MutableBigIntegerBox(val);\n+                break;\n+            case 5: \/\/ Runs of consecutive ones and zeros\n+                result = ZERO;\n+                int remaining = order;\n+                int bit = random.nextInt(2);\n+                while (remaining > 0) {\n+                    int runLength = Math.min(remaining, random.nextInt(order));\n+                    result = result.shiftLeft(runLength);\n+                    if (bit > 0)\n+                        result = result.add(ONE.shiftLeft(runLength).subtract(ONE));\n+                    remaining -= runLength;\n+                    bit = 1 - bit;\n+                }\n+                break;\n+\n+            default: \/\/ random bits\n+                result = new MutableBigIntegerBox(new BigInteger(order, random));\n+        }\n+\n+        return result;\n+    }\n+\n+    static void report(String testName, int failCount) {\n+        System.err.println(testName+\": \" +\n+                           (failCount==0 ? \"Passed\":\"Failed(\"+failCount+\")\"));\n+        if (failCount > 0)\n+            failure = true;\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigInteger\/MutableBigIntegerShiftTests.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.math;\n+\n+\/**\n+ * A class for tests.\n+ *\/\n+public class MutableBigIntegerBox {\n+\n+    \/**\n+     * Constant zero\n+     *\/\n+    public static final MutableBigIntegerBox ZERO = new MutableBigIntegerBox(new MutableBigInteger());\n+\n+    \/**\n+     * Constant one\n+     *\/\n+    public static final MutableBigIntegerBox ONE = new MutableBigIntegerBox(MutableBigInteger.ONE);\n+\n+    \/**\n+     * Constant two\n+     *\/\n+    public static final MutableBigIntegerBox TWO = new MutableBigIntegerBox(new MutableBigInteger(2));\n+\n+    private MutableBigInteger val;\n+\n+    MutableBigIntegerBox(MutableBigInteger val) {\n+        this.val = val;\n+    }\n+\n+    \/**\n+     * Construct MutableBigIntegerBox from magnitude.\n+     * The value is normalized.\n+     * @param mag the magnitude\n+     *\/\n+    public MutableBigIntegerBox(int[] mag) {\n+        this(new MutableBigInteger(mag));\n+        val.normalize();\n+    }\n+\n+    \/**\n+     * Construct MutableBigIntegerBox from BigInteger val\n+     * @param val the value\n+     *\/\n+    public MutableBigIntegerBox(BigInteger val) {\n+        this(val.mag);\n+    }\n+\n+    \/**\n+     * Returns the bit length of this MutableBigInteger value\n+     * @return the bit length of this MutableBigInteger value\n+     *\/\n+    public long bitLength() {\n+        return val.bitLength();\n+    }\n+\n+    \/**\n+     * Return {@code this << n}\n+     * @return {@code this << n}\n+     * @param n the shift\n+     *\/\n+    public MutableBigIntegerBox shiftLeft(int n) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.safeLeftShift(n);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return {@code this >> n}\n+     * @return {@code this >> n}\n+     * @param n the shift\n+     *\/\n+    public MutableBigIntegerBox shiftRight(int n) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.safeRightShift(n);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return this + addend\n+     * @return this + addend\n+     * @param addend the addend\n+     *\/\n+    public MutableBigIntegerBox add(MutableBigIntegerBox addend) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.add(addend.val);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return this - subtraend\n+     * @return this - subtraend\n+     * @param subtraend the subtraend\n+     *\/\n+    public MutableBigIntegerBox subtract(MutableBigIntegerBox subtraend) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.subtract(subtraend.val);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return this * multiplier\n+     * @return this * multiplier\n+     * @param multiplier the multiplier\n+     *\/\n+    public MutableBigIntegerBox multiply(MutableBigIntegerBox multiplier) {\n+        MutableBigInteger res = new MutableBigInteger();\n+        if (!(val.isZero() || multiplier.val.isZero()))\n+            val.multiply(multiplier.val, res);\n+\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Compare the magnitude of two MutableBigIntegers. Returns -1, 0 or 1\n+     * as this is numerically less than, equal to, or greater than {@code b}.\n+     * @return -1, 0 or 1 as this is numerically less than, equal to, or\n+     * greater than {@code b}.\n+     * @param b the value to compare\n+     *\/\n+    public int compare(MutableBigIntegerBox b) {\n+        return val.compare(b.val);\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigInteger\/java.base\/java\/math\/MutableBigIntegerBox.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.math;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OperationsPerInvocation;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.math.MutableBigIntegerBox;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3)\n+public class MutableBigIntegersLeftShift {\n+\n+    private MutableBigIntegerBox[] shiftArray;\n+    private static final int TESTSIZE = 1000;\n+\n+    @Setup\n+    public void setup() {\n+        Random r = new Random(1123);\n+        int numbits = r.nextInt(16384);\n+\n+        shiftArray = new MutableBigIntegerBox[TESTSIZE]; \/*\n+         * Each array entry is atmost 16k bits\n+         * in size\n+         *\/\n+\n+        for (int i = 0; i < TESTSIZE; i++) {\n+            shiftArray[i] = new MutableBigIntegerBox(new BigInteger(numbits, r));\n+        }\n+    }\n+\n+    \/** Invokes the shiftLeft method of BigInteger with different values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testLeftShift(Blackhole bh) {\n+        Random rand = new Random();\n+        for (MutableBigIntegerBox s : shiftArray) {\n+            int shift = rand.nextInt((int) s.bitLength());\n+            bh.consume(s.shiftLeft(shift));\n+        }\n+    }\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @State(Scope.Thread)\n+    @Warmup(iterations = 5, time = 1)\n+    @Measurement(iterations = 5, time = 1)\n+    @Fork(value = 3)\n+    public static class SmallShifts {\n+\n+        @Param({\"32\", \"128\", \"256\"})\n+        private int maxNumbits;\n+\n+        \/*\n+         * Small numbers, bit length in range [maxNumbits - 31, maxNumbits]\n+         *\/\n+        MutableBigIntegerBox[] smallShiftArray = new MutableBigIntegerBox[TESTSIZE];\n+\n+        @Setup\n+        public void setup() {\n+            Random r = new Random(1123);\n+            for (int i = 0; i < TESTSIZE; i++) {\n+                int value = Math.abs(r.nextInt());\n+                smallShiftArray[i] = new MutableBigIntegerBox(new BigInteger(Math.max(maxNumbits - value % 32, 0), r));\n+            }\n+        }\n+\n+        \/** Invokes the shiftLeft method of small BigInteger with different values. *\/\n+        @Benchmark\n+        @OperationsPerInvocation(TESTSIZE)\n+        public void testLeftShift(Blackhole bh) {\n+            Random rand = new Random();\n+            for (MutableBigIntegerBox s : smallShiftArray) {\n+                int shift = rand.nextInt((int) s.bitLength());\n+                bh.consume(s.shiftLeft(shift));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/MutableBigIntegersLeftShift.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.math;\n+\n+\/**\n+ * A class for tests.\n+ *\/\n+public class MutableBigIntegerBox {\n+\n+    \/**\n+     * Constant zero\n+     *\/\n+    public static final MutableBigIntegerBox ZERO = new MutableBigIntegerBox(new MutableBigInteger());\n+\n+    \/**\n+     * Constant one\n+     *\/\n+    public static final MutableBigIntegerBox ONE = new MutableBigIntegerBox(MutableBigInteger.ONE);\n+\n+    \/**\n+     * Constant two\n+     *\/\n+    public static final MutableBigIntegerBox TWO = new MutableBigIntegerBox(new MutableBigInteger(2));\n+\n+    private MutableBigInteger val;\n+\n+    MutableBigIntegerBox(MutableBigInteger val) {\n+        this.val = val;\n+    }\n+\n+    \/**\n+     * Construct MutableBigIntegerBox from magnitude.\n+     * The value is normalized.\n+     * @param mag the magnitude\n+     *\/\n+    public MutableBigIntegerBox(int[] mag) {\n+        this(new MutableBigInteger(mag));\n+        val.normalize();\n+    }\n+\n+    \/**\n+     * Construct MutableBigIntegerBox from BigInteger val\n+     * @param val the value\n+     *\/\n+    public MutableBigIntegerBox(BigInteger val) {\n+        this(val.mag);\n+    }\n+\n+    \/**\n+     * Returns the bit length of this MutableBigInteger value\n+     * @return the bit length of this MutableBigInteger value\n+     *\/\n+    public long bitLength() {\n+        return val.bitLength();\n+    }\n+\n+    \/**\n+     * Return {@code this << n}\n+     * @return {@code this << n}\n+     * @param n the shift\n+     *\/\n+    public MutableBigIntegerBox shiftLeft(int n) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.safeLeftShift(n);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return {@code this >> n}\n+     * @return {@code this >> n}\n+     * @param n the shift\n+     *\/\n+    public MutableBigIntegerBox shiftRight(int n) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.safeRightShift(n);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return this + addend\n+     * @return this + addend\n+     * @param addend the addend\n+     *\/\n+    public MutableBigIntegerBox add(MutableBigIntegerBox addend) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.add(addend.val);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return this - subtraend\n+     * @return this - subtraend\n+     * @param subtraend the subtraend\n+     *\/\n+    public MutableBigIntegerBox subtract(MutableBigIntegerBox subtraend) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.subtract(subtraend.val);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return this * multiplier\n+     * @return this * multiplier\n+     * @param multiplier the multiplier\n+     *\/\n+    public MutableBigIntegerBox multiply(MutableBigIntegerBox multiplier) {\n+        MutableBigInteger res = new MutableBigInteger();\n+        if (!(val.isZero() || multiplier.val.isZero()))\n+            val.multiply(multiplier.val, res);\n+\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Compare the magnitude of two MutableBigIntegers. Returns -1, 0 or 1\n+     * as this is numerically less than, equal to, or greater than {@code b}.\n+     * @return -1, 0 or 1 as this is numerically less than, equal to, or\n+     * greater than {@code b}.\n+     * @param b the value to compare\n+     *\/\n+    public int compare(MutableBigIntegerBox b) {\n+        return val.compare(b.val);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/java.base\/java\/math\/MutableBigIntegerBox.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"}]}