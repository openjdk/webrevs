{"files":[{"patch":"@@ -600,0 +600,1 @@\n+\n@@ -601,2 +602,2 @@\n-        int nBits = n&0x1F;\n-        int bitsInHighWord = BigInteger.bitLengthForInt(value[offset]);\n+        int nBits = n & 0x1F;\n+        int leadingZeros = Integer.numberOfLeadingZeros(value[offset]);\n@@ -605,1 +606,1 @@\n-        if (n <= (32-bitsInHighWord)) {\n+        if (n <= leadingZeros) {\n@@ -610,13 +611,9 @@\n-        int newLen = intLen + nInts +1;\n-        if (nBits <= (32-bitsInHighWord))\n-            newLen--;\n-        if (value.length < newLen) {\n-            \/\/ The array must grow\n-            int[] result = new int[newLen];\n-            for (int i=0; i < intLen; i++)\n-                result[i] = value[offset+i];\n-            setValue(result, newLen);\n-        } else if (value.length - offset >= newLen) {\n-            \/\/ Use space on right\n-            for(int i=0; i < newLen - intLen; i++)\n-                value[offset+intLen+i] = 0;\n+        int newLen = intLen + nInts;\n+        if (nBits > leadingZeros)\n+            newLen++;\n+\n+        int[] result;\n+        final int newOffset;\n+        if (value.length < newLen) { \/\/ The array must grow\n+            result = new int[newLen];\n+            newOffset = 0;\n@@ -624,6 +621,2 @@\n-            \/\/ Must use space on left\n-            for (int i=0; i < intLen; i++)\n-                value[i] = value[offset+i];\n-            for (int i=intLen; i < newLen; i++)\n-                value[i] = 0;\n-            offset = 0;\n+            result = value;\n+            newOffset = value.length - offset >= newLen ? offset : 0;\n@@ -631,0 +624,20 @@\n+\n+        int trailingZerosPos = newOffset + intLen;\n+        if (nBits != 0) {\n+            \/\/ Do primitive shift directly for speed\n+            if (nBits <= leadingZeros) {\n+                primitiveLeftShift(nBits, result, newOffset); \/\/ newOffset <= offset\n+            } else {\n+                int lastInt = value[offset + intLen - 1];\n+                primitiveRightShift(32 - nBits, result, newOffset); \/\/ newOffset <= offset\n+                result[trailingZerosPos++] = lastInt << nBits;\n+            }\n+        } else if (result != value || newOffset != offset) {\n+            System.arraycopy(value, offset, result, newOffset, intLen);\n+        }\n+\n+        \/\/ Add trailing zeros\n+        if (result == value)\n+            Arrays.fill(result, trailingZerosPos, newOffset + newLen, 0);\n+\n+        value = result;\n@@ -632,6 +645,1 @@\n-        if (nBits == 0)\n-            return;\n-        if (nBits <= (32-bitsInHighWord))\n-            primitiveLeftShift(nBits);\n-        else\n-            primitiveRightShift(32 -nBits);\n+        offset = newOffset;\n@@ -701,1 +709,14 @@\n-    private final void primitiveRightShift(int n) {\n+    private void primitiveRightShift(int n) {\n+        primitiveRightShift(n, value, offset);\n+    }\n+\n+    \/**\n+     * Right shift this MutableBigInteger n bits, where n is\n+     * less than 32, placing the result in the specified array.\n+     * Assumes that intLen > 0, n > 0 for speed.\n+     * The result can be the value array of this MutableBigInteger,\n+     * but for speed the copy is not performed safely, so, in that case\n+     * the caller has to make sure that\n+     * {@code (resFrom <= offset || resFrom >= offset + intLen)}.\n+     *\/\n+    private void primitiveRightShift(int n, int[] result, int resFrom) {\n@@ -704,4 +725,7 @@\n-        for (int i=offset+intLen-1, c=val[i]; i > offset; i--) {\n-            int b = c;\n-            c = val[i-1];\n-            val[i] = (c << n2) | (b >>> n);\n+\n+        int b = val[offset];\n+        result[resFrom] = b >>> n;\n+        for (int i = 1; i < intLen; i++) {\n+            int c = b;\n+            b = val[offset + i];\n+            result[resFrom + i] = (c << n2) | (b >>> n);\n@@ -709,1 +733,0 @@\n-        val[offset] >>>= n;\n@@ -717,1 +740,14 @@\n-    private final void primitiveLeftShift(int n) {\n+    private void primitiveLeftShift(int n) {\n+        primitiveLeftShift(n, value, offset);\n+    }\n+\n+    \/**\n+     * Left shift this MutableBigInteger n bits, where n is\n+     * less than 32, placing the result in the specified array.\n+     * Assumes that intLen > 0, n > 0 for speed.\n+     * The result can be the value array of this MutableBigInteger,\n+     * but for speed the copy is not performed safely, so, in that case\n+     * the caller has to make sure that\n+     * {@code (resFrom <= offset || resFrom >= offset + intLen)}.\n+     *\/\n+    private void primitiveLeftShift(int n, int[] result, int resFrom) {\n@@ -720,4 +756,6 @@\n-        for (int i=offset, c=val[i], m=i+intLen-1; i < m; i++) {\n-            int b = c;\n-            c = val[i+1];\n-            val[i] = (b << n) | (c >>> n2);\n+        final int m = intLen - 1;\n+        int b = val[offset];\n+        for (int i = 0; i < m; i++) {\n+            int c = val[offset + i + 1];\n+            result[resFrom + i] = (b << n) | (c >>> n2);\n+            b = c;\n@@ -725,1 +763,1 @@\n-        val[offset+intLen-1] <<= n;\n+        result[resFrom + m] = b << n;\n@@ -1514,11 +1552,0 @@\n-    private static void copyAndShift(int[] src, int srcFrom, int srcLen, int[] dst, int dstFrom, int shift) {\n-        int n2 = 32 - shift;\n-        int c=src[srcFrom];\n-        for (int i=0; i < srcLen-1; i++) {\n-            int b = c;\n-            c = src[++srcFrom];\n-            dst[dstFrom+i] = (b << shift) | (c >>> n2);\n-        }\n-        dst[dstFrom+srcLen-1] = c << shift;\n-    }\n-\n@@ -1542,1 +1569,1 @@\n-            copyAndShift(div.value,div.offset,dlen,divisor,0,shift);\n+            div.primitiveLeftShift(shift, divisor, 0);\n@@ -1548,1 +1575,1 @@\n-                copyAndShift(value,offset,intLen,remarr,1,shift);\n+                this.primitiveLeftShift(shift, remarr, 1);\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":80,"deletions":53,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.RandomFactory;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.Arguments;\n+\n+import java.math.BigInteger;\n+import java.math.MutableBigIntegerBox;\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static java.math.MutableBigIntegerBox.*;\n+\n+\/**\n+ * @test\n+ * @bug 8336274\n+ * @summary Tests for correctness of MutableBigInteger.leftShift(int)\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build java.base\/java.math.MutableBigIntegerBox\n+ * @key randomness\n+ * @run junit MutableBigIntegerShiftTests\n+ *\/\n+public class MutableBigIntegerShiftTests {\n+\n+    private static final int ORDER_SMALL = 60;\n+    private static final int ORDER_MEDIUM = 100;\n+\n+    private static final Random random = RandomFactory.getRandom();\n+\n+    private static int[] orders() {\n+        return new int[] { ORDER_SMALL, ORDER_MEDIUM };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"orders\")\n+    public void shift(int order) {\n+        for (int i = 0; i < 100; i++) {\n+            test(fetchNumber(order), random.nextInt(200));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pathTargetedCases\")\n+    public void test(MutableBigIntegerBox x, int n) {\n+        leftShiftAssertions(x, n);\n+    }\n+\n+    private static Arguments[] pathTargetedCases() {\n+        return new Arguments[] {\n+                \/\/ intLen == 0\n+                Arguments.of(MutableBigIntegerBox.ZERO,\n+                        random.nextInt(33)),\n+                \/\/ intLen != 0 && n <= leadingZeros\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L, 1L << 16) }),\n+                        random.nextInt(1, 17)),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits <= leadingZeros && value.length < newLen && nBits == 0\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L, 1L << 32) }),\n+                        32),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits <= leadingZeros && value.length < newLen && nBits != 0\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L, 1L << 16) }),\n+                        32 + random.nextInt(1, 17)),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits <= leadingZeros && value.length >= newLen && nBits == 0\n+                \/\/ && newOffset != offset\n+                Arguments.of(new MutableBigIntegerBox(new int[] { random.nextInt(), (int) random.nextLong(1L, 1L << 32) }, 1, 1),\n+                        32),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits <= leadingZeros && value.length >= newLen && nBits == 0\n+                \/\/ && newOffset == offset\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L, 1L << 32), random.nextInt() }, 0, 1),\n+                        32),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits <= leadingZeros && value.length >= newLen && nBits != 0\n+                \/\/ && newOffset != offset\n+                Arguments.of(new MutableBigIntegerBox(new int[] { random.nextInt(), (int) random.nextLong(1L, 1L << 16) }, 1, 1),\n+                        32 + random.nextInt(1, 17)),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits <= leadingZeros && value.length >= newLen && nBits != 0\n+                \/\/ && newOffset == offset\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L, 1L << 16), random.nextInt() }, 0, 1),\n+                        32 + random.nextInt(1, 17)),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits > leadingZeros && value.length < newLen\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L << 15, 1L << 32) }),\n+                        random.nextInt(17, 32)),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits > leadingZeros && value.length >= newLen && newOffset != offset\n+                Arguments.of(new MutableBigIntegerBox(new int[] { random.nextInt(), (int) random.nextLong(1L << 15, 1L << 32) }, 1, 1),\n+                        random.nextInt(17, 32)),\n+                \/\/ intLen != 0 && n > leadingZeros && nBits > leadingZeros && value.length >= newLen && newOffset == offset\n+                Arguments.of(new MutableBigIntegerBox(new int[] { (int) random.nextLong(1L << 15, 1L << 32), random.nextInt() }, 0, 1),\n+                        random.nextInt(17, 32)),\n+        };\n+    }\n+\n+    private static void leftShiftAssertions(MutableBigIntegerBox x, int n) {\n+        MutableBigIntegerBox xShifted = x.shiftLeft(n);\n+        assertEquals(x.multiply(new MutableBigIntegerBox(BigInteger.TWO.pow(n))), xShifted);\n+        assertEquals(x, xShifted.shiftRight(n));\n+    }\n+\n+    \/*\n+     * Get a random or boundary-case number. This is designed to provide\n+     * a lot of numbers that will find failure points, such as max sized\n+     * numbers, empty MutableBigIntegers, etc.\n+     *\n+     * If order is less than 2, order is changed to 2.\n+     *\/\n+    private static MutableBigIntegerBox fetchNumber(int order) {\n+        int numType = random.nextInt(8);\n+        MutableBigIntegerBox result = null;\n+        if (order < 2) order = 2;\n+\n+        int[] val;\n+        switch (numType) {\n+            case 0: \/\/ Empty\n+                result = MutableBigIntegerBox.ZERO;\n+                break;\n+\n+            case 1: \/\/ One\n+                result = MutableBigIntegerBox.ONE;\n+                break;\n+\n+            case 2: \/\/ All bits set in number\n+                int numInts = (order + 31) >> 5;\n+                int[] fullBits = new int[numInts];\n+                Arrays.fill(fullBits, -1);\n+\n+                fullBits[0] &= -1 >>> -order;\n+                result = new MutableBigIntegerBox(fullBits);\n+                break;\n+\n+            case 3: \/\/ One bit in number\n+                result = MutableBigIntegerBox.ONE.shiftLeft(random.nextInt(order));\n+                break;\n+\n+            case 4: \/\/ Random bit density\n+                val = new int[(order + 31) >> 5];\n+                int iterations = random.nextInt(order);\n+                for (int i = 0; i < iterations; i++) {\n+                    int bitIdx = random.nextInt(order);\n+                    val[bitIdx >> 5] |= 1 << bitIdx;\n+                }\n+                result = new MutableBigIntegerBox(val);\n+                break;\n+            case 5: \/\/ Runs of consecutive ones and zeros\n+                result = ZERO;\n+                int remaining = order;\n+                int bit = random.nextInt(2);\n+                while (remaining > 0) {\n+                    int runLength = Math.min(remaining, random.nextInt(order));\n+                    result = result.shiftLeft(runLength);\n+                    if (bit > 0)\n+                        result = result.add(ONE.shiftLeft(runLength).subtract(ONE));\n+                    remaining -= runLength;\n+                    bit = 1 - bit;\n+                }\n+                break;\n+            case 6: \/\/ random bits with trailing space\n+                int len = random.nextInt((order + 31) >> 5) + 1;\n+                int offset = random.nextInt(len);\n+                val = new int[len << 1];\n+                for (int i = 0; i < val.length; i++)\n+                    val[i] = random.nextInt();\n+                result = new MutableBigIntegerBox(val, offset, len);\n+                break;\n+            default: \/\/ random bits\n+                result = new MutableBigIntegerBox(new BigInteger(order, random));\n+        }\n+\n+        return result;\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigInteger\/MutableBigIntegerShiftTests.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.math;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * A class for tests.\n+ *\/\n+public class MutableBigIntegerBox {\n+\n+    \/**\n+     * Constant zero\n+     *\/\n+    public static final MutableBigIntegerBox ZERO = new MutableBigIntegerBox(new MutableBigInteger());\n+\n+    \/**\n+     * Constant one\n+     *\/\n+    public static final MutableBigIntegerBox ONE = new MutableBigIntegerBox(MutableBigInteger.ONE);\n+\n+    \/**\n+     * Constant two\n+     *\/\n+    public static final MutableBigIntegerBox TWO = new MutableBigIntegerBox(new MutableBigInteger(2));\n+\n+    private MutableBigInteger val;\n+\n+    MutableBigIntegerBox(MutableBigInteger val) {\n+        this.val = val;\n+    }\n+\n+    \/**\n+     * Construct MutableBigIntegerBox from magnitude, starting from\n+     * offset and with a length of intLen ints.\n+     * The value is normalized.\n+     * @param mag the magnitude\n+     * @param offset the offset where the value starts\n+     * @param intLen the length of the value, in int words.\n+     *\/\n+    public MutableBigIntegerBox(int[] mag, int offset, int intLen) {\n+        this(new MutableBigInteger(mag));\n+        val.offset = offset;\n+        val.intLen = intLen;\n+        val.normalize();\n+    }\n+\n+    \/**\n+     * Construct MutableBigIntegerBox from magnitude.\n+     * The value is normalized.\n+     * @param mag the magnitude\n+     *\/\n+    public MutableBigIntegerBox(int[] mag) {\n+        this(mag, 0, mag.length);\n+    }\n+\n+    \/**\n+     * Construct MutableBigIntegerBox from BigInteger val\n+     * @param val the value\n+     *\/\n+    public MutableBigIntegerBox(BigInteger val) {\n+        this(val.mag);\n+    }\n+\n+    \/**\n+     * Returns the bit length of this MutableBigInteger value\n+     * @return the bit length of this MutableBigInteger value\n+     *\/\n+    public long bitLength() {\n+        return val.bitLength();\n+    }\n+\n+    \/**\n+     * Return {@code this << n}\n+     * @return {@code this << n}\n+     * @param n the shift\n+     *\/\n+    public MutableBigIntegerBox shiftLeft(int n) {\n+        MutableBigInteger res = new MutableBigInteger(val.value.clone());\n+        res.offset = val.offset;\n+        res.intLen = val.intLen;\n+\n+        res.safeLeftShift(n);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return {@code this >> n}\n+     * @return {@code this >> n}\n+     * @param n the shift\n+     *\/\n+    public MutableBigIntegerBox shiftRight(int n) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.safeRightShift(n);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return this + addend\n+     * @return this + addend\n+     * @param addend the addend\n+     *\/\n+    public MutableBigIntegerBox add(MutableBigIntegerBox addend) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.add(addend.val);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return this - subtraend\n+     * @return this - subtraend\n+     * @param subtraend the subtraend\n+     *\/\n+    public MutableBigIntegerBox subtract(MutableBigIntegerBox subtraend) {\n+        MutableBigInteger res = new MutableBigInteger(val);\n+        res.subtract(subtraend.val);\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Return this * multiplier\n+     * @return this * multiplier\n+     * @param multiplier the multiplier\n+     *\/\n+    public MutableBigIntegerBox multiply(MutableBigIntegerBox multiplier) {\n+        MutableBigInteger res = new MutableBigInteger();\n+        if (!(val.isZero() || multiplier.val.isZero()))\n+            val.multiply(multiplier.val, res);\n+\n+        return new MutableBigIntegerBox(res);\n+    }\n+\n+    \/**\n+     * Compare the magnitude of two MutableBigIntegers. Returns -1, 0 or 1\n+     * as this is numerically less than, equal to, or greater than {@code b}.\n+     * @return -1, 0 or 1 as this is numerically less than, equal to, or\n+     * greater than {@code b}.\n+     * @param b the value to compare\n+     *\/\n+    public int compare(MutableBigIntegerBox b) {\n+        return val.compare(b.val);\n+    }\n+\n+    \/**\n+     * Compares this MutableBigIntegerBox with the specified Object for equality.\n+     *\n+     * @param  x Object to which this MutableBigIntegerBox is to be compared.\n+     * @return {@code true} if and only if the specified Object is a\n+     *         MutableBigIntegerBox whose value is numerically equal to this MutableBigIntegerBox.\n+     *\/\n+    @Override\n+    public boolean equals(Object x) {\n+        return (x instanceof MutableBigIntegerBox xInt)\n+                && Arrays.equals(val.value, val.offset, val.offset + val.intLen,\n+                        xInt.val.value, xInt.val.offset, xInt.val.offset + xInt.val.intLen);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return val.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/math\/BigInteger\/java.base\/java\/math\/MutableBigIntegerBox.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"}]}