{"files":[{"patch":"@@ -37,0 +37,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -97,0 +99,2 @@\n+        requireNonNull(annotationClass);\n+        requireNonNull(elements);\n@@ -118,0 +122,1 @@\n+        requireNonNull(elements);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Annotation.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -75,0 +77,2 @@\n+        requireNonNull(name);\n+        requireNonNull(value);\n@@ -220,1 +224,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationElement.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -446,0 +448,2 @@\n+        requireNonNull(className);\n+        requireNonNull(constantName);\n@@ -464,0 +468,1 @@\n+        requireNonNull(className);\n@@ -480,0 +485,1 @@\n+        requireNonNull(value);\n@@ -496,0 +502,1 @@\n+        requireNonNull(value);\n@@ -512,0 +519,1 @@\n+        requireNonNull(value);\n@@ -528,0 +536,1 @@\n+        requireNonNull(value);\n@@ -544,0 +553,1 @@\n+        requireNonNull(value);\n@@ -560,0 +570,1 @@\n+        requireNonNull(value);\n@@ -576,0 +587,1 @@\n+        requireNonNull(value);\n@@ -592,0 +604,1 @@\n+        requireNonNull(value);\n@@ -608,0 +621,1 @@\n+        requireNonNull(value);\n@@ -625,0 +639,1 @@\n+        requireNonNull(value);\n@@ -638,0 +653,1 @@\n+        requireNonNull(values);\n@@ -665,0 +681,1 @@\n+        requireNonNull(value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,4 +27,1 @@\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Optional;\n+import java.util.*;\n@@ -36,0 +33,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -61,0 +60,1 @@\n+        requireNonNull(attr);\n@@ -79,0 +79,1 @@\n+        requireNonNull(attr);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AttributedElement.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -168,0 +169,2 @@\n+        requireNonNull(name);\n+        requireNonNull(descriptor);\n@@ -182,0 +185,3 @@\n+        requireNonNull(name);\n+        requireNonNull(descriptor);\n+        requireNonNull(handler);\n@@ -197,0 +203,2 @@\n+        requireNonNull(name);\n+        requireNonNull(descriptor);\n@@ -244,0 +252,3 @@\n+        requireNonNull(name);\n+        requireNonNull(descriptor);\n+        requireNonNull(handler);\n@@ -279,0 +290,3 @@\n+        requireNonNull(name);\n+        requireNonNull(descriptor);\n+        requireNonNull(handler);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassBuilder.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -46,1 +47,0 @@\n-import static java.util.Objects.requireNonNull;\n@@ -73,0 +73,4 @@\n+        requireNonNull(options);\n+        for (var o : options){\n+            requireNonNull(o);\n+        }\n@@ -395,0 +399,1 @@\n+        requireNonNull(moduleAttribute);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFile.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -60,0 +61,1 @@\n+        requireNonNull(e);\n@@ -82,0 +84,2 @@\n+        requireNonNull(model);\n+        requireNonNull(transform);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -105,0 +106,1 @@\n+        requireNonNull(builder);\n@@ -116,0 +118,1 @@\n+        requireNonNull(builder);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileTransform.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -85,0 +86,3 @@\n+            \/\/todo: uncomment later\n+            \/\/ this causes CorpusTest to fail\n+            \/\/ requireNonNull(superClass);\n@@ -109,0 +113,1 @@\n+        requireNonNull(other);\n@@ -173,0 +178,1 @@\n+        requireNonNull(classStreamResolver);\n@@ -184,0 +190,1 @@\n+        requireNonNull(loader);\n@@ -202,0 +209,5 @@\n+        requireNonNull(interfaces);\n+        for (var i : interfaces){\n+            requireNonNull(i);\n+        }\n+        requireNonNull(classToSuperClass);\n@@ -213,0 +225,2 @@\n+        \/\/null check here breaks WithSecurityManagerTest\n+\/\/        requireNonNull(loader);\n@@ -235,0 +249,1 @@\n+        requireNonNull(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassHierarchyResolver.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -53,0 +54,2 @@\n+            requireNonNull(builder);\n+            requireNonNull(element);\n@@ -66,0 +69,1 @@\n+        requireNonNull(supplier);\n@@ -77,0 +81,1 @@\n+        requireNonNull(finisher);\n@@ -80,0 +85,2 @@\n+                requireNonNull(builder);\n+                requireNonNull(element);\n@@ -85,0 +92,1 @@\n+                requireNonNull(builder);\n@@ -98,0 +106,1 @@\n+        requireNonNull(filter);\n@@ -114,0 +123,2 @@\n+        requireNonNull(filter);\n+        requireNonNull(xform);\n@@ -160,0 +171,1 @@\n+        requireNonNull(xform);\n@@ -172,0 +184,1 @@\n+        requireNonNull(t);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassTransform.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -265,0 +265,1 @@\n+        requireNonNull(thenHandler);\n@@ -315,0 +316,4 @@\n+        \/\/todo i don't think is is neccesary\n+        requireNonNull(opcode);\n+        requireNonNull(thenHandler);\n+        requireNonNull(elseHandler);\n@@ -406,0 +411,2 @@\n+        requireNonNull(tryHandler);\n+        requireNonNull(catchesHandler);\n@@ -614,0 +621,2 @@\n+\/\/        adding null check here causes error\n+\/\/        requireNonNull(value);\n@@ -695,0 +704,4 @@\n+        requireNonNull(start);\n+        requireNonNull(end);\n+        requireNonNull(handler);\n+        requireNonNull(catchType);\n@@ -2090,0 +2103,1 @@\n+        requireNonNull(value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -51,0 +52,2 @@\n+            requireNonNull(builder);\n+            requireNonNull(element);\n@@ -64,0 +67,1 @@\n+        requireNonNull(supplier);\n@@ -75,0 +79,1 @@\n+        requireNonNull(finisher);\n@@ -78,0 +83,2 @@\n+                requireNonNull(builder);\n+                requireNonNull(element);\n@@ -83,0 +90,1 @@\n+                requireNonNull(builder);\n@@ -97,0 +105,1 @@\n+        requireNonNull(t);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeTransform.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -52,0 +53,2 @@\n+            requireNonNull(builder);\n+            requireNonNull(element);\n@@ -65,0 +68,1 @@\n+        requireNonNull(supplier);\n@@ -76,0 +80,1 @@\n+        requireNonNull(finisher);\n@@ -79,0 +84,2 @@\n+                requireNonNull(builder);\n+                requireNonNull(element);\n@@ -97,0 +104,1 @@\n+        requireNonNull(filter);\n@@ -112,0 +120,1 @@\n+        requireNonNull(t);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/FieldTransform.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -52,0 +54,2 @@\n+            requireNonNull(builder);\n+            requireNonNull(element);\n@@ -65,0 +69,1 @@\n+        requireNonNull(supplier);\n@@ -76,0 +81,1 @@\n+        requireNonNull(finisher);\n@@ -79,0 +85,2 @@\n+                requireNonNull(builder);\n+                requireNonNull(element);\n@@ -97,0 +105,1 @@\n+        requireNonNull(filter);\n@@ -111,0 +120,1 @@\n+        requireNonNull(xform);\n@@ -123,0 +133,1 @@\n+        requireNonNull(t);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodTransform.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+\n@@ -150,0 +151,2 @@\n+            requireNonNull(className);\n+            requireNonNull(typeArgs);\n@@ -161,0 +164,1 @@\n+            requireNonNull(typeArgs);\n@@ -170,0 +174,2 @@\n+            requireNonNull(className);\n+            requireNonNull(typeArgs);\n@@ -181,0 +187,1 @@\n+            requireNonNull(typeArgs);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Signature.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -205,0 +207,2 @@\n+        requireNonNull(targetInfo);\n+        requireNonNull(annotation);\n@@ -347,0 +351,5 @@\n+            requireNonNull(targetType);\n+            requireNonNull(table);\n+            for (var r : table){\n+                requireNonNull(r);\n+            }\n@@ -384,0 +393,2 @@\n+            requireNonNull(target);\n+            requireNonNull(target);\n@@ -432,0 +443,2 @@\n+            requireNonNull(targetType);\n+            requireNonNull(target);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeAnnotation.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -67,0 +69,1 @@\n+        requireNonNull(annotationDefault);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/AnnotationDefaultAttribute.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -65,0 +67,1 @@\n+        requireNonNull(id);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CompilationIDAttribute.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -64,0 +66,1 @@\n+        requireNonNull(value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ConstantValueAttribute.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -106,0 +107,1 @@\n+        requireNonNull(className);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/EnclosingMethodAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -96,0 +97,3 @@\n+        requireNonNull(innerClass);\n+        requireNonNull(outerClass);\n+        requireNonNull(innerName);\n@@ -108,0 +112,3 @@\n+        requireNonNull(innerClass);\n+        requireNonNull(outerClass);\n+        requireNonNull(innerName);\n@@ -123,0 +130,2 @@\n+        requireNonNull(innerClass);\n+        requireNonNull(flags);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassInfo.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -85,0 +86,1 @@\n+        requireNonNull(name);\n@@ -94,0 +96,5 @@\n+        requireNonNull(name);\n+        requireNonNull(flags);\n+        for (var f : flags){\n+            requireNonNull(f);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/MethodParameterInfo.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.util.Collection;\n+import java.util.*;\n@@ -37,3 +37,0 @@\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n@@ -48,0 +45,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -143,0 +142,8 @@\n+        requireNonNull(moduleName);\n+        \/\/todo should moduleVersion be Nullable?\n+\/\/        requireNonNull(moduleVersion);\n+        requireNonNull(requires);\n+        requireNonNull(exports);\n+        requireNonNull(opens);\n+        requireNonNull(uses);\n+        requireNonNull(provides);\n@@ -167,0 +174,2 @@\n+        requireNonNull(moduleName);\n+        requireNonNull(attrHandler);\n@@ -201,0 +210,1 @@\n+            requireNonNull(moduleFlags);\n@@ -228,0 +238,3 @@\n+            requireNonNull(module);\n+            requireNonNull(requiresFlags);\n+            requireNonNull(version);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleAttribute.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -94,0 +95,2 @@\n+        requireNonNull(exports);\n+        requireNonNull(exportsTo);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleExportInfo.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -58,0 +60,2 @@\n+        requireNonNull(moduleName);\n+        requireNonNull(hash);\n@@ -67,0 +71,2 @@\n+        requireNonNull(moduleDesc);\n+        requireNonNull(hash);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleHashInfo.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -116,0 +118,2 @@\n+        requireNonNull(algorithm);\n+        requireNonNull(hashes);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleHashesAttribute.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -66,0 +68,1 @@\n+        requireNonNull(mainClass);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleMainClassAttribute.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -94,0 +95,2 @@\n+        requireNonNull(opens);\n+        requireNonNull(opensTo);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleOpenInfo.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -63,0 +65,2 @@\n+        requireNonNull(provides);\n+        requireNonNull(providesWith);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleProvideInfo.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -90,0 +91,3 @@\n+        requireNonNull(requires);\n+        \/\/todo: uncomment later after CorpusTest is fixed\n+\/\/        requireNonNull(requiresVersion);\n@@ -100,0 +104,3 @@\n+        requireNonNull(requiresVersion);\n+        requireNonNull(requiresFlags);\n+        requireNonNull(requiresVersion);\n@@ -110,0 +117,2 @@\n+        requireNonNull(requires);\n+        requireNonNull(requiresVersion);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleRequireInfo.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -85,0 +87,1 @@\n+        requireNonNull(targetPlatform);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleTargetAttribute.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -66,0 +68,1 @@\n+        requireNonNull(nestHost);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/NestHostAttribute.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -73,0 +75,2 @@\n+        requireNonNull(name);\n+        requireNonNull(descriptor);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RecordComponentInfo.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -120,0 +122,1 @@\n+        requireNonNull(signature);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SignatureAttribute.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -62,0 +64,1 @@\n+        requireNonNull(contents);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SourceDebugExtensionAttribute.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -71,0 +73,1 @@\n+        requireNonNull(sourceFile);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SourceFileAttribute.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -65,0 +67,1 @@\n+        requireNonNull(sourceId);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SourceIDAttribute.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -76,1 +78,1 @@\n-\n+        requireNonNull(target);\n@@ -150,0 +152,1 @@\n+            requireNonNull(className);\n@@ -194,0 +197,1 @@\n+            requireNonNull(newTarget);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapFrameInfo.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -196,0 +197,2 @@\n+        requireNonNull(model);\n+        requireNonNull(verbosity);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/ClassPrinter.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -67,0 +68,1 @@\n+        requireNonNull(classMap);\n@@ -78,0 +80,1 @@\n+        requireNonNull(mapFunction);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/ClassRemapper.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -65,0 +66,1 @@\n+        requireNonNull(map);\n@@ -75,0 +77,1 @@\n+        requireNonNull(mapFunction);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/CodeRelabeler.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -47,1 +49,0 @@\n-import static java.util.Objects.requireNonNull;\n@@ -483,0 +484,1 @@\n+        requireNonNull(c);\n@@ -501,0 +503,1 @@\n+        requireNonNull(c);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -63,0 +65,1 @@\n+        requireNonNull(target);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/BranchInstruction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -105,0 +107,2 @@\n+        requireNonNull(startScope);\n+        requireNonNull(endScope);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/CharacterRange.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -156,0 +158,1 @@\n+        requireNonNull(op);\n@@ -176,0 +179,1 @@\n+        requireNonNull(constant);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ConstantInstruction.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -65,0 +67,2 @@\n+        requireNonNull(fromType);\n+        requireNonNull(toType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ConvertInstruction.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -75,0 +77,1 @@\n+            requireNonNull(target);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/DiscontinuedInstruction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -81,0 +82,3 @@\n+        requireNonNull(handler);\n+        requireNonNull(tryStart);\n+        requireNonNull(tryEnd);\n@@ -91,0 +95,3 @@\n+        requireNonNull(handler);\n+        requireNonNull(tryStart);\n+        requireNonNull(tryEnd);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ExceptionCatch.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -96,0 +98,1 @@\n+        requireNonNull(field);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/FieldInstruction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -106,0 +107,1 @@\n+        requireNonNull(invokedynamic);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/InvokeDynamicInstruction.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -111,0 +113,1 @@\n+        requireNonNull(method);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/InvokeInstruction.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -96,0 +97,4 @@\n+        requireNonNull(nameEntry);\n+        requireNonNull(descriptorEntry);\n+        requireNonNull(startScope);\n+        requireNonNull(endScope);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariable.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -94,0 +95,4 @@\n+        requireNonNull(nameEntry);\n+        requireNonNull(signatureEntry);\n+        requireNonNull(startScope);\n+        requireNonNull(endScope);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LocalVariableType.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -64,0 +66,1 @@\n+        requireNonNull(defaultTarget);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LookupSwitchInstruction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -64,0 +66,1 @@\n+        requireNonNull(arrayTypeEntry);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewMultiArrayInstruction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -56,0 +58,1 @@\n+        requireNonNull(className);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewObjectInstruction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -55,0 +57,1 @@\n+        requireNonNull(componentType);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewReferenceArrayInstruction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -58,0 +60,1 @@\n+        requireNonNull(target);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/SwitchCase.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -75,0 +77,1 @@\n+        requireNonNull(defaultTarget);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/TableSwitchInstruction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -66,0 +68,1 @@\n+        requireNonNull(type);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/TypeCheckInstruction.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+\n@@ -58,0 +59,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -383,0 +386,1 @@\n+            requireNonNull(s);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+        Objects.requireNonNull(element);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BlockCodeBuilderImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.Objects;\n@@ -122,0 +123,1 @@\n+        Objects.requireNonNull(element);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -64,0 +65,1 @@\n+        Objects.requireNonNull(element);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedFieldBuilder.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-\n@@ -46,0 +45,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -75,0 +76,1 @@\n+        requireNonNull(element);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedMethodBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -60,2 +62,5 @@\n-        Objects.requireNonNull(exceptionTypes);\n-        Objects.requireNonNull(catchHandler);\n+        requireNonNull(exceptionTypes);\n+        for (var e: exceptionTypes){\n+            requireNonNull(e);\n+        }\n+        requireNonNull(catchHandler);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CatchBuilderImpl.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -50,0 +52,1 @@\n+        requireNonNull(element);\n@@ -56,0 +59,3 @@\n+        requireNonNull(name);\n+        requireNonNull(descriptor);\n+        requireNonNull(handler);\n@@ -75,0 +81,3 @@\n+        requireNonNull(name);\n+        requireNonNull(descriptor);\n+        requireNonNull(handler);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.Objects;\n@@ -62,0 +63,1 @@\n+        Objects.requireNonNull(element);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedCodeBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -53,0 +55,1 @@\n+        requireNonNull(element);\n@@ -58,1 +61,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedFieldBuilder.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Objects;\n@@ -51,0 +52,1 @@\n+        Objects.requireNonNull(element);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedMethodBuilder.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -75,0 +77,4 @@\n+        requireNonNull(options);\n+        for (var o : options){\n+            requireNonNull(o);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileImpl.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.Objects;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassHierarchyImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -93,0 +93,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -97,0 +99,2 @@\n+        requireNonNull(clb);\n+        requireNonNull(cle);\n@@ -276,0 +280,1 @@\n+        requireNonNull(desc);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.util.Objects;\n@@ -51,0 +52,2 @@\n+        Objects.requireNonNull(cob);\n+        Objects.requireNonNull(coe);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeLocalsShifterImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -51,0 +53,2 @@\n+        requireNonNull(cob);\n+        requireNonNull(coe);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeRelabelerImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,7 +59,1 @@\n-import java.util.AbstractCollection;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.NoSuchElementException;\n-import java.util.Optional;\n+import java.util.*;\n@@ -174,0 +168,2 @@\n+        Objects.requireNonNull(cb);\n+        Objects.requireNonNull(el);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeStackTrackerImpl.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -77,0 +79,1 @@\n+        requireNonNull(element);\n@@ -89,0 +92,3 @@\n+        requireNonNull(name);\n+        requireNonNull(descriptor);\n+        requireNonNull(handler);\n@@ -106,0 +112,3 @@\n+        requireNonNull(name);\n+        requireNonNull(descriptor);\n+        requireNonNull(handler);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n@@ -62,2 +65,0 @@\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n@@ -66,0 +67,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -135,0 +137,1 @@\n+        requireNonNull(element);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,3 @@\n+import static java.util.Objects.requireNonNull;\n+\n+\n@@ -57,0 +60,1 @@\n+        requireNonNull(element);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -113,0 +115,1 @@\n+        requireNonNull(element);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -68,1 +70,1 @@\n-        Objects.requireNonNull(moduleName);\n+        requireNonNull(moduleName);\n@@ -81,0 +83,1 @@\n+        requireNonNull(version);\n@@ -87,1 +90,3 @@\n-        Objects.requireNonNull(module);\n+        requireNonNull(module);\n+        \/\/ todo this crashes corpus test??\n+\/\/        requireNonNull(version);\n@@ -93,1 +98,1 @@\n-        Objects.requireNonNull(requires);\n+        requireNonNull(requires);\n@@ -100,1 +105,1 @@\n-        Objects.requireNonNull(pkge);\n+        requireNonNull(pkge);\n@@ -109,1 +114,1 @@\n-        Objects.requireNonNull(exports);\n+        requireNonNull(exports);\n@@ -116,1 +121,1 @@\n-        Objects.requireNonNull(pkge);\n+        requireNonNull(pkge);\n@@ -125,1 +130,1 @@\n-        Objects.requireNonNull(opens);\n+        requireNonNull(opens);\n@@ -132,1 +137,1 @@\n-        Objects.requireNonNull(service);\n+        requireNonNull(service);\n@@ -138,1 +143,1 @@\n-        Objects.requireNonNull(uses);\n+        requireNonNull(uses);\n@@ -145,1 +150,1 @@\n-        Objects.requireNonNull(service);\n+        requireNonNull(service);\n@@ -154,1 +159,1 @@\n-        Objects.requireNonNull(provides);\n+        requireNonNull(provides);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ModuleAttributeBuilderImpl.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.constant.ConstantDesc;\n@@ -38,0 +37,1 @@\n+\n@@ -56,0 +56,1 @@\n+import static java.util.Objects.requireNonNull;\n@@ -117,1 +118,1 @@\n-        Objects.requireNonNull(cls);\n+        requireNonNull(cls);\n@@ -133,0 +134,1 @@\n+        requireNonNull(other);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+import static java.util.Objects.requireNonNull;\n+\n@@ -190,0 +192,1 @@\n+        requireNonNull(constantPool);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TemporaryConstantPool.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Objects;\n@@ -81,0 +82,2 @@\n+            Objects.requireNonNull(builder);\n+            Objects.requireNonNull(element);\n@@ -86,0 +89,1 @@\n+            Objects.requireNonNull(builder);\n@@ -91,0 +95,1 @@\n+            Objects.requireNonNull(builder);\n@@ -177,0 +182,2 @@\n+            Objects.requireNonNull(builder);\n+            Objects.requireNonNull(element);\n@@ -182,0 +189,1 @@\n+            Objects.requireNonNull(builder);\n@@ -187,0 +195,1 @@\n+            Objects.requireNonNull(builder);\n@@ -241,0 +250,2 @@\n+            Objects.requireNonNull(builder);\n+            Objects.requireNonNull(element);\n@@ -246,0 +257,1 @@\n+            Objects.requireNonNull(builder);\n@@ -251,0 +263,1 @@\n+            Objects.requireNonNull(builder);\n@@ -281,0 +294,2 @@\n+            Objects.requireNonNull(builder);\n+            Objects.requireNonNull(element);\n@@ -286,0 +301,1 @@\n+            Objects.requireNonNull(builder);\n@@ -291,0 +307,1 @@\n+            Objects.requireNonNull(builder);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TransformImpl.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,961 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.ref\n+ *          java.base\/jdk.internal.classfile.impl\n+ * @build testdata.*\n+ * @run junit\/othervm TestNullHostile\n+ *\/\n+\n+import java.io.*;\n+import java.lang.classfile.*;\n+import java.lang.classfile.ClassFile.*;\n+import java.lang.classfile.CustomAttribute;\n+import java.lang.classfile.attribute.*;\n+import java.lang.classfile.components.*;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.classfile.instruction.*;\n+import java.lang.constant.*;\n+import java.lang.invoke.*;\n+import java.lang.reflect.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.*;\n+import java.util.*;\n+import java.util.Optional;\n+import java.util.function.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static jdk.internal.classfile.impl.ClassPrinterImpl.Style.FLOW;\n+\n+import jdk.internal.classfile.impl.*;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/**\n+ * This test makes sure that public API classes under {@link java.lang.classfile} throws NPEs whenever\n+ * nulls are provided. The test looks at all the public methods in all the listed classes, and injects\n+ * values automatically. If an API takes a reference, the test will try to inject nulls. For APIs taking\n+ * either reference arrays, or collections, the framework will also generate additional <em>replacements<\/em>\n+ * (e.g. other than just replacing the array, or collection with null), such as an array or collection\n+ * with null elements. The test can be customized by adding\/removing classes to the {@link #CLASSES} array,\n+ * by adding\/removing default mappings for standard carrier types (see {@link #DEFAULT_VALUES} or by\n+ * adding\/removing custom replacements (see {@link #REPLACEMENT_VALUES}).\n+ * <p>\n+ *\/\n+public class TestNullHostile {\n+\n+    private static final Set<String> OBJECT_METHODS = Stream.of(Object.class.getMethods())\n+            .map(Method::getName)\n+            .collect(Collectors.toSet());\n+\n+    private static final Map<Class<?>, Object> DEFAULT_VALUES = new HashMap<>();\n+    private static final Map<Class<?>, Object[]> REPLACEMENT_VALUES = new HashMap<>();\n+\n+    static <Z> void addDefaultMapping(Class<Z> carrier, Z value) {\n+        DEFAULT_VALUES.putIfAbsent(carrier, value);\n+    }\n+\n+    @SafeVarargs\n+    static <Z> void addReplacements(Class<Z> carrier, Z... value) {\n+        REPLACEMENT_VALUES.putIfAbsent(carrier, value);\n+    }\n+\n+    static final Class<?>[] CLASSES = new Class<?>[]{\n+            AccessFlags.class,\n+            Annotation.class,\n+            AnnotationElement.class,\n+            AnnotationValue.class,\n+            AnnotationValue.OfEnum.class,\n+            AnnotationValue.OfClass.class,\n+            AnnotationValue.OfString.class,\n+            AnnotationValue.OfDouble.class,\n+            AnnotationValue.OfFloat.class,\n+            AnnotationValue.OfLong.class,\n+            AnnotationValue.OfInt.class,\n+            AnnotationValue.OfShort.class,\n+            AnnotationValue.OfChar.class,\n+            AnnotationValue.OfByte.class,\n+            AnnotationValue.OfBoolean.class,\n+            AnnotationValue.OfArray.class,\n+            AnnotationValue.OfConstant.class,\n+            AnnotationValue.OfAnnotation.class,\n+            Attribute.class,\n+            AttributeMapper.class,\n+            AttributeMapper.AttributeStability.class,\n+            AttributedElement.class,\n+            Attributes.class,\n+            BootstrapMethodEntry.class,\n+            BufWriter.class,\n+            ClassBuilder.class,\n+            ClassElement.class,\n+            ClassFile.class,\n+            Option.class,\n+            AttributesProcessingOption.class,\n+            ClassFile.StackMapsOption.class,\n+            ClassFile.ShortJumpsOption.class,\n+            LineNumbersOption.class,\n+            DebugElementsOption.class,\n+            DeadLabelsOption.class,\n+            DeadCodeOption.class,\n+            ConstantPoolSharingOption.class,\n+            ClassHierarchyResolverOption.class,\n+            AttributeMapperOption.class,\n+            ClassFileBuilder.class,\n+            ClassFileElement.class,\n+            ClassFileTransform.class,\n+            ClassFileVersion.class,\n+            ClassHierarchyResolver.class,\n+            ClassHierarchyResolver.ClassHierarchyInfo.class,\n+            ClassModel.class,\n+            ClassReader.class,\n+            ClassSignature.class,\n+            ClassTransform.class,\n+            CodeBuilder.class,\n+            CodeBuilder.CatchBuilder.class,\n+            CodeBuilder.BlockCodeBuilder.class,\n+            CodeElement.class,\n+            CodeModel.class,\n+            CodeTransform.class,\n+            CompoundElement.class,\n+            CustomAttribute.class,\n+            FieldBuilder.class,\n+            FieldElement.class,\n+            FieldModel.class,\n+            FieldTransform.class,\n+            Instruction.class,\n+            Interfaces.class,\n+            Label.class,\n+            MethodBuilder.class,\n+            MethodElement.class,\n+            MethodModel.class,\n+            MethodSignature.class,\n+            MethodTransform.class,\n+            Opcode.class,\n+            Opcode.Kind.class,\n+            PseudoInstruction.class,\n+            Signature.class,\n+            Signature.ArrayTypeSig.class,\n+            Signature.BaseTypeSig.class,\n+            Signature.TypeArg.class,\n+            Signature.TypeArg.Bounded.class,\n+            Signature.TypeArg.Bounded.WildcardIndicator.class,\n+            Signature.TypeArg.Unbounded.class,\n+            Signature.ClassTypeSig.class,\n+            Signature.ThrowableSig.class,\n+            Signature.TypeParam.class,\n+            Signature.TypeVarSig.class,\n+            Signature.RefTypeSig.class,\n+            Superclass.class,\n+            TypeAnnotation.class,\n+            TypeAnnotation.TargetInfo.class,\n+            TypeAnnotation.TypePathComponent.class,\n+            TypeAnnotation.TypePathComponent.Kind.class,\n+            TypeAnnotation.TypeArgumentTarget.class,\n+            TypeAnnotation.OffsetTarget.class,\n+            TypeAnnotation.CatchTarget.class,\n+            TypeAnnotation.LocalVarTargetInfo.class,\n+            TypeAnnotation.LocalVarTarget.class,\n+            TypeAnnotation.ThrowsTarget.class,\n+            TypeAnnotation.FormalParameterTarget.class,\n+            TypeAnnotation.EmptyTarget.class,\n+            TypeAnnotation.TypeParameterBoundTarget.class,\n+            TypeAnnotation.SupertypeTarget.class,\n+            TypeAnnotation.TypeParameterTarget.class,\n+            TypeAnnotation.TargetType.class,\n+            TypeKind.class,\n+            AnnotationDefaultAttribute.class,\n+            BootstrapMethodsAttribute.class,\n+            CharacterRangeInfo.class,\n+            CharacterRangeTableAttribute.class,\n+            CodeAttribute.class,\n+            CompilationIDAttribute.class,\n+            ConstantValueAttribute.class,\n+            DeprecatedAttribute.class,\n+            EnclosingMethodAttribute.class,\n+            ExceptionsAttribute.class,\n+            InnerClassInfo.class,\n+            InnerClassesAttribute.class,\n+            LineNumberInfo.class,\n+            LineNumberTableAttribute.class,\n+            LocalVariableInfo.class,\n+            LocalVariableTableAttribute.class,\n+            LocalVariableTypeInfo.class,\n+            LocalVariableTypeTableAttribute.class,\n+            MethodParameterInfo.class,\n+            ModuleAttribute.class,\n+            ModuleAttribute.ModuleAttributeBuilder.class,\n+            ModuleExportInfo.class,\n+            ModuleHashInfo.class,\n+            ModuleHashesAttribute.class,\n+            ModuleMainClassAttribute.class,\n+            ModuleOpenInfo.class,\n+            ModulePackagesAttribute.class,\n+            ModuleProvideInfo.class,\n+            ModuleRequireInfo.class,\n+            ModuleResolutionAttribute.class,\n+            ModuleTargetAttribute.class,\n+            NestHostAttribute.class,\n+            NestMembersAttribute.class,\n+            PermittedSubclassesAttribute.class,\n+            RecordAttribute.class,\n+            RecordComponentInfo.class,\n+            RuntimeInvisibleAnnotationsAttribute.class,\n+            RuntimeInvisibleParameterAnnotationsAttribute.class,\n+            RuntimeInvisibleTypeAnnotationsAttribute.class,\n+            RuntimeVisibleAnnotationsAttribute.class,\n+            RuntimeVisibleParameterAnnotationsAttribute.class,\n+            RuntimeVisibleTypeAnnotationsAttribute.class,\n+            SignatureAttribute.class,\n+            SourceDebugExtensionAttribute.class,\n+            SourceFileAttribute.class,\n+            SourceIDAttribute.class,\n+            StackMapFrameInfo.class,\n+            StackMapFrameInfo.UninitializedVerificationTypeInfo.class,\n+            StackMapFrameInfo.ObjectVerificationTypeInfo.class,\n+            StackMapFrameInfo.SimpleVerificationTypeInfo.class,\n+            StackMapFrameInfo.VerificationTypeInfo.class,\n+            StackMapTableAttribute.class,\n+            SyntheticAttribute.class,\n+            UnknownAttribute.class,\n+            ClassPrinter.class,\n+            ClassPrinter.Verbosity.class,\n+            ClassPrinter.MapNode.class,\n+            ClassPrinter.ListNode.class,\n+            ClassPrinter.LeafNode.class,\n+            ClassPrinter.Node.class,\n+            ClassRemapper.class,\n+            CodeLocalsShifter.class,\n+            CodeRelabeler.class,\n+            CodeStackTracker.class,\n+            AnnotationConstantValueEntry.class,\n+            ClassEntry.class,\n+            ConstantDynamicEntry.class,\n+            ConstantPool.class,\n+            ConstantPoolBuilder.class,\n+            ConstantPoolException.class,\n+            ConstantValueEntry.class,\n+            DoubleEntry.class,\n+            DynamicConstantPoolEntry.class,\n+            FieldRefEntry.class,\n+            FloatEntry.class,\n+            IntegerEntry.class,\n+            InterfaceMethodRefEntry.class,\n+            InvokeDynamicEntry.class,\n+            LoadableConstantEntry.class,\n+            LongEntry.class,\n+            MemberRefEntry.class,\n+            MethodHandleEntry.class,\n+            MethodRefEntry.class,\n+            MethodTypeEntry.class,\n+            ModuleEntry.class,\n+            NameAndTypeEntry.class,\n+            PackageEntry.class,\n+            PoolEntry.class,\n+            StringEntry.class,\n+            Utf8Entry.class,\n+            ArrayLoadInstruction.class,\n+            ArrayStoreInstruction.class,\n+            BranchInstruction.class,\n+            CharacterRange.class,\n+            ConstantInstruction.class,\n+            ConstantInstruction.LoadConstantInstruction.class,\n+            ConstantInstruction.ArgumentConstantInstruction.class,\n+            ConstantInstruction.IntrinsicConstantInstruction.class,\n+            ConvertInstruction.class,\n+            DiscontinuedInstruction.class,\n+            DiscontinuedInstruction.RetInstruction.class,\n+            DiscontinuedInstruction.JsrInstruction.class,\n+            ExceptionCatch.class,\n+            FieldInstruction.class,\n+            IncrementInstruction.class,\n+            InvokeDynamicInstruction.class,\n+            LabelTarget.class,\n+            LineNumber.class,\n+            LoadInstruction.class,\n+            LocalVariable.class,\n+            LocalVariableType.class,\n+            LookupSwitchInstruction.class,\n+            MonitorInstruction.class,\n+            NewMultiArrayInstruction.class,\n+            NewObjectInstruction.class,\n+            NewPrimitiveArrayInstruction.class,\n+            NewReferenceArrayInstruction.class,\n+            NopInstruction.class,\n+            OperatorInstruction.class,\n+            ReturnInstruction.class,\n+            StackInstruction.class,\n+            StoreInstruction.class,\n+            SwitchCase.class,\n+            TableSwitchInstruction.class,\n+            ThrowInstruction.class,\n+            TypeCheckInstruction.class\n+    };\n+\n+    private static final Set<String> EXCLUDE_LIST = Set.of(\n+            \/\/the implementation of this method in CatchBuilderImpl handles nulls, is this fine?\n+            \"java.lang.classfile.CodeBuilder$CatchBuilder\/catching(java.lang.constant.ClassDesc,java.util.function.Consumer)\/0\/0\",\n+\n+            \/\/ making this method null-hostile causes a BootstapMethodError during the the build\n+            \/\/        java.lang.BootstrapMethodError: bootstrap method initialization exception\n+            \/\/        Caused by: java.lang.invoke.LambdaConversionException: Exception instantiating lambda object\n+            \"java.lang.classfile.CodeBuilder\/loadConstant(java.lang.constant.ConstantDesc)\/0\/0\",\n+            \"java.lang.classfile.CodeBuilder$BlockCodeBuilder\/loadConstant(java.lang.constant.ConstantDesc)\/0\/0\",\n+\n+\n+\n+            \/\/todo  remove from exclude list later, this breaks CorpusTest and AdvancedTransformationsTest\n+            \"java.lang.classfile.ClassHierarchyResolver$ClassHierarchyInfo\/ofClass(java.lang.constant.ClassDesc)\/0\/0\",\n+            \"java.lang.classfile.attribute.ModuleAttribute$ModuleAttributeBuilder\/requires(java.lang.constant.ModuleDesc,int,java.lang.String)\/2\/0\",\n+            \"java.lang.classfile.attribute.ModuleAttribute\/of(java.lang.classfile.constantpool.ModuleEntry,int,java.lang.classfile.constantpool.Utf8Entry,java.util.Collection,java.util.Collection,java.util.Collection,java.util.Collection,java.util.Collection)\/2\/0\",\n+            \"java.lang.classfile.attribute.ModuleRequireInfo\/of(java.lang.classfile.constantpool.ModuleEntry,int,java.lang.classfile.constantpool.Utf8Entry)\/2\/0\",\n+            \"java.lang.classfile.AttributeMapper\/readAttribute(java.lang.classfile.AttributedElement,java.lang.classfile.ClassReader,int)\/0\/0\",\n+\n+            \/\/ todo making this method null-hostile breaks a few tests\n+            \"java.lang.classfile.AttributeMapper\/readAttribute(java.lang.classfile.AttributedElement,java.lang.classfile.ClassReader,int)\/1\/0\",\n+\n+            \/\/todo - removing this breaks jdk\/java\/lang\/invoke\/MethodHandleProxies\/WithSecurityManagerTest.java\n+            \"java.lang.classfile.ClassHierarchyResolver\/ofClassLoading(java.lang.ClassLoader)\/0\/0\",\n+\n+            \/\/todo revisit these\n+            \"java.lang.classfile.ClassFileTransform\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/0\/0\",\n+            \"java.lang.classfile.ClassFileTransform\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/1\/0\",\n+            \"java.lang.classfile.ClassTransform\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/0\/0\",\n+\n+            \/\/todo- can we add stronger checks here?\n+            \"java.lang.classfile.components.CodeStackTracker\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/0\/0\",\n+            \"java.lang.classfile.components.CodeStackTracker\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/1\/0\",\n+            \"java.lang.classfile.CodeTransform\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/0\/0\",\n+            \"java.lang.classfile.CodeTransform\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/1\/0\",\n+            \"java.lang.classfile.FieldTransform\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/0\/0\",\n+            \"java.lang.classfile.FieldTransform\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/1\/0\",\n+            \"java.lang.classfile.components.CodeLocalsShifter\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/0\/0\",\n+            \"java.lang.classfile.components.CodeLocalsShifter\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/1\/0\",\n+            \"java.lang.classfile.components.CodeRelabeler\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/1\/0\",\n+            \"java.lang.classfile.components.CodeRelabeler\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/0\/0\",\n+            \"java.lang.classfile.MethodTransform\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/0\/0\",\n+            \"java.lang.classfile.MethodTransform\/accept(java.lang.classfile.ClassFileBuilder,java.lang.classfile.ClassFileElement)\/1\/0\",\n+\n+            \/\/ implementation calls these method with null\n+            \"java.lang.classfile.Signature$ClassTypeSig\/of(java.lang.classfile.Signature$ClassTypeSig,java.lang.constant.ClassDesc,java.lang.classfile.Signature$TypeArg[])\/0\/0\",\n+            \"java.lang.classfile.Signature$ClassTypeSig\/of(java.lang.classfile.Signature$ClassTypeSig,java.lang.String,java.lang.classfile.Signature$TypeArg[])\/0\/0\",\n+            \"java.lang.classfile.Signature$TypeParam\/of(java.lang.String,java.lang.classfile.Signature$RefTypeSig,java.lang.classfile.Signature$RefTypeSig[])\/1\/0\",\n+            \"java.lang.classfile.BufWriter\/writeIndexOrZero(java.lang.classfile.constantpool.PoolEntry)\/0\/0\",\n+\n+            \/\/ these are inherited from Map and other superclasses\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/remove(java.lang.Object,java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object,java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object,java.lang.Object)\/2\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/replace(java.lang.Object,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/remove(java.lang.Object,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/get(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/put(java.lang.Object,java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/put(java.lang.Object,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/putAll(java.util.Map)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/putIfAbsent(java.lang.Object,java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/remove(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/sort(java.util.Comparator)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/indexOf(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/lastIndexOf(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/add(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/add(int,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/toArray(java.lang.Object[])\/0\/1\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/contains(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/addAll(int,java.util.Collection)\/1\/1\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/addAll(java.util.Collection)\/0\/1\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/remove(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/putIfAbsent(java.lang.Object,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/compute(java.lang.Object,java.util.function.BiFunction)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/containsKey(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/computeIfAbsent(java.lang.Object,java.util.function.Function)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/containsValue(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/getOrDefault(java.lang.Object,java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/getOrDefault(java.lang.Object,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$MapNode\/computeIfPresent(java.lang.Object,java.util.function.BiFunction)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/set(int,java.lang.Object)\/1\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/addFirst(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/addLast(java.lang.Object)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/removeAll(java.util.Collection)\/0\/1\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/retainAll(java.util.Collection)\/0\/1\",\n+            \"java.lang.classfile.components.ClassPrinter$ListNode\/containsAll(java.util.Collection)\/0\/1\",\n+\n+            \/\/valueOf\n+            \"java.lang.classfile.ClassFile$AttributesProcessingOption\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.ClassFile$ShortJumpsOption\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.ClassFile$LineNumbersOption\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.ClassFile$StackMapsOption\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.ClassFile$DebugElementsOption\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.ClassFile$DeadLabelsOption\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.ClassFile$DeadCodeOption\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.ClassFile$ConstantPoolSharingOption\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.TypeKind\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.attribute.StackMapFrameInfo$SimpleVerificationTypeInfo\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.constantpool.ConstantPoolException\/initCause(java.lang.Throwable)\/0\/0\",\n+            \"java.lang.classfile.components.ClassPrinter$Verbosity\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.Signature$TypeArg$Bounded$WildcardIndicator\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.TypeAnnotation$TypePathComponent$Kind\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.TypeAnnotation$TargetType\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.Opcode\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.Opcode$Kind\/valueOf(java.lang.Class,java.lang.String)\/1\/0\",\n+            \"java.lang.classfile.AttributeMapper$AttributeStability\/valueOf(java.lang.Class,java.lang.String)\/1\/0\"\n+    );\n+\n+    static {\n+        addDefaultMapping(char.class, (char) 0);\n+        addDefaultMapping(byte.class, (byte) 0);\n+        addDefaultMapping(short.class, (short) 0);\n+        addDefaultMapping(int.class, 0);\n+        addDefaultMapping(float.class, 0f);\n+        addDefaultMapping(long.class, 0L);\n+        addDefaultMapping(double.class, 0d);\n+        addDefaultMapping(boolean.class, true);\n+        addDefaultMapping(Enum.class, ClassFileFormatVersion.RELEASE_24);\n+        addDefaultMapping(Path.class, Path.of(\"nonExistent\"));\n+        addDefaultMapping(UnaryOperator.class, UnaryOperator.identity());\n+        addDefaultMapping(String.class, \"Hello!\");\n+        addDefaultMapping(Class.class, String.class);\n+        addDefaultMapping(Object.class, new Object());\n+        addDefaultMapping(List.class, List.of());\n+        addDefaultMapping(Consumer.class, _ -> {});\n+        addDefaultMapping(Supplier.class, () -> null);\n+        addDefaultMapping(ClassLoader.class, TestNullHostile.class.getClassLoader());\n+        addDefaultMapping(Function.class, Function.identity());\n+        addDefaultMapping(CharSequence.class, \"c\");\n+        addDefaultMapping(Collection.class, new ArrayList<>());\n+        addDefaultMapping(Optional.class, Optional.of(5));\n+        addDefaultMapping(Map.class, Map.of());\n+        addDefaultMapping(MethodHandles.Lookup.class, MethodHandles.publicLookup());\n+        addDefaultMapping(Predicate.class, Predicate.not(_ -> false));\n+        BiFunction<Object, Object, Object> func = (_, _) -> 0;\n+        addDefaultMapping(BiFunction.class, func);\n+        addDefaultMapping(BiConsumer.class, (_, _) -> {});\n+        addDefaultMapping(IntFunction.class, _ -> 0);\n+        addDefaultMapping(PrintWriter.class, new PrintWriter(System.out,true));\n+        addDefaultMapping(PrintStream.class, new PrintStream(System.out,true));\n+    }\n+\n+    static {\n+        addReplacements(Collection.class, null, Stream.of(new Object[]{null}).collect(Collectors.toList()));\n+        addReplacements(List.class, null, Stream.of(new Object[]{null}).collect(Collectors.toList()));\n+        addReplacements(Set.class, null, Stream.of(new Object[]{null}).collect(Collectors.toSet()));\n+    }\n+\n+    @BeforeAll\n+    public static void getDefaultValues() throws IOException, URISyntaxException {\n+        FileSystem fs = FileSystems.getFileSystem(new URI(\"jrt:\/\"));\n+        var all = findAllClassFiles();\n+        for (var file : all) {\n+            var b = Files.readAllBytes(fs.getPath(file));\n+            try {\n+                populateClassFileMappings(b);\n+            } catch (Exception e) {\n+                \/\/do nothing - some complains about Unmatched bit position 0x in some inner final classes\n+            }\n+        }\n+    }\n+    @ParameterizedTest\n+    @MethodSource(\"cases\")\n+    void testNulls(String testName, Method meth, Object receiver, Object[] args) {\n+        try {\n+            meth.invoke(receiver, args);\n+            fail(\"Method invocation completed normally\");\n+        } catch (InvocationTargetException ex) {\n+            Class<?> cause = ex.getCause().getClass();\n+            assertEquals(NullPointerException.class, cause, \"got \" + cause.getName() + \" - expected NullPointerException\");\n+        } catch (Throwable ex) {\n+            fail(\"Unexpected exception: \" + ex);\n+        }\n+    }\n+\n+    static Iterator<Object[]> cases() {\n+        List<Object[]> cases = new ArrayList<>();\n+        for (Class<?> clazz : CLASSES) {\n+            for (Method m : clazz.getMethods()) {\n+                if (OBJECT_METHODS.contains(m.getName())) continue;\n+                boolean isStatic = (m.getModifiers() & Modifier.STATIC) != 0;\n+                List<Integer> refIndices = new ArrayList<>();\n+                for (int i = 0; i < m.getParameterCount(); i++) {\n+                    Class<?> param = m.getParameterTypes()[i];\n+                    if (!param.isPrimitive()) {\n+                        refIndices.add(i);\n+                    }\n+                }\n+                for (int i : refIndices) {\n+                    Object[] replacements = replacements(m.getParameterTypes()[i]);\n+                    for (int r = 0; r < replacements.length; r++) {\n+                        String testName = clazz.getName() + \"\/\" + shortSig(m) + \"\/\" + i + \"\/\" + r;\n+                        if (EXCLUDE_LIST.contains(testName)) continue;\n+                        Object[] args = new Object[m.getParameterCount()];\n+                        for (int j = 0; j < args.length; j++) {\n+                            args[j] = defaultValue(m.getParameterTypes()[j]);\n+                        }\n+                        args[i] = replacements[r];\n+                        Object receiver = isStatic ? null : defaultValue(clazz);\n+                        cases.add(new Object[]{testName, m, receiver, args});\n+                    }\n+                }\n+            }\n+        }\n+        return cases.iterator();\n+    }\n+\n+    static String shortSig(Method m) {\n+        StringJoiner sj = new StringJoiner(\",\", m.getName() + \"(\", \")\");\n+        for (Class<?> parameterType : m.getParameterTypes()) {\n+            sj.add(parameterType.getTypeName());\n+        }\n+        return sj.toString();\n+    }\n+\n+    static Object defaultValue(Class<?> carrier) {\n+        if (carrier.isArray()) {\n+            return Array.newInstance(carrier.componentType(), 0);\n+        }\n+        Object value = DEFAULT_VALUES.get(carrier);\n+        if (value == null) {\n+            throw new UnsupportedOperationException(carrier.getName());\n+        }\n+        return value;\n+    }\n+\n+    static Object[] replacements(Class<?> carrier) {\n+        if (carrier.isArray() && !carrier.getComponentType().isPrimitive()) {\n+            Object arr = Array.newInstance(carrier.componentType(), 1);\n+            Array.set(arr, 0, null);\n+            return new Object[]{null, arr};\n+        }\n+        return REPLACEMENT_VALUES.getOrDefault(carrier, new Object[]{null});\n+    }\n+\n+    public static List<String> findAllClassFiles() throws IOException, URISyntaxException {\n+        FileSystem fs = FileSystems.getFileSystem(new URI(\"jrt:\/\"));\n+        Path dir = fs.getPath(\"\/modules\");\n+        try (final Stream<Path> paths = Files.walk(dir)) {\n+            \/\/ each path is in the form: \/modules\/<modname>\/<pkg>\/<pkg>\/...\/name.class\n+            return paths\n+                    .filter(path -> path.getNameCount() > 2)\n+                    .map(Path::toString)\n+                    .filter(name -> name.endsWith(\".class\"))\n+                    .collect(Collectors.toList());\n+        }\n+    }\n+\n+    private static void populateClassFileMappings(byte[] classFileBytes) throws IOException {\n+\n+        ClassModel cm = ClassFile.of().parse(classFileBytes);\n+        addDefaultMapping(ClassFile.class, ClassFile.of());\n+        addDefaultMapping(ConstantPool.class, cm.constantPool());\n+        addDefaultMapping(ClassReader.class, (ClassReader) cm.constantPool());\n+\n+        var node = ClassPrinter.toTree(cm, ClassPrinter.Verbosity.TRACE_ALL);\n+        addDefaultMapping(ClassPrinter.MapNode.class, node);\n+        addDefaultMapping(ClassPrinter.Node.class, node);\n+        addDefaultMapping(ClassPrinter.Verbosity.class, ClassPrinter.Verbosity.MEMBERS_ONLY);\n+        addDefaultMapping(TypeKind.class, TypeKind.BOOLEAN);\n+        addDefaultMapping(ConstantPoolBuilder.class, ConstantPoolBuilder.of(cm));\n+        addDefaultMapping(ClassModel.class, cm);\n+        addDefaultMapping(ClassRemapper.class, ClassRemapper.of(Map.of()));\n+        addDefaultMapping(ClassHierarchyResolver.class, ClassHierarchyResolver.defaultResolver());\n+        addDefaultMapping(ClassTransform.class, ClassFileBuilder::with);\n+        addDefaultMapping(MethodTransform.class, (_, _) -> {});\n+        addDefaultMapping(FieldTransform.class, (_, _) -> {});\n+        addDefaultMapping(ClassPrinter.LeafNode.class, new ClassPrinterImpl.LeafNodeImpl(ConstantDescs.CD_Class, ConstantDescs.INIT_NAME));\n+        addDefaultMapping(ClassFileTransform.class, (ClassTransform) (_, _) -> {});\n+        addDefaultMapping(ConstantDesc.class, ConstantDescs.NULL);\n+        addDefaultMapping(CodeStackTracker.class, CodeStackTracker.of());\n+        addDefaultMapping(CodeRelabeler.class, CodeRelabeler.of());\n+        addDefaultMapping(CodeTransform.class, (_, _) -> {});\n+        addDefaultMapping(AttributesProcessingOption.class, ClassFile.AttributesProcessingOption.PASS_ALL_ATTRIBUTES);\n+        addDefaultMapping(TypeAnnotation.TargetInfo.class, TypeAnnotation.TargetInfo.ofField());\n+        addDefaultMapping(StackMapsOption.class, ClassFile.StackMapsOption.DROP_STACK_MAPS);\n+        addDefaultMapping(ShortJumpsOption.class, ClassFile.ShortJumpsOption.FIX_SHORT_JUMPS);\n+        addDefaultMapping(LineNumbersOption.class, ClassFile.LineNumbersOption.PASS_LINE_NUMBERS);\n+        addDefaultMapping(DebugElementsOption.class, ClassFile.DebugElementsOption.PASS_DEBUG);\n+        addDefaultMapping(DeadLabelsOption.class, ClassFile.DeadLabelsOption.FAIL_ON_DEAD_LABELS);\n+        addDefaultMapping(DeadCodeOption.class, ClassFile.DeadCodeOption.PATCH_DEAD_CODE);\n+        addDefaultMapping(TypeAnnotation.TargetInfo.class, TypeAnnotation.TargetInfo.ofField());\n+        addDefaultMapping(TypeAnnotation.TargetType.class, TypeAnnotation.TargetInfo.ofField().targetType());\n+        addDefaultMapping(TypeAnnotation.TypePathComponent.Kind.class, TypeAnnotation.TypePathComponent.Kind.INNER_TYPE);\n+        addDefaultMapping(ConstantPoolSharingOption.class, ClassFile.ConstantPoolSharingOption.SHARED_POOL);\n+        addDefaultMapping(PackageDesc.class, PackageDesc.of(\"java.lang.classfile\"));\n+        addDefaultMapping(ModuleDesc.class, ModuleDesc.of(\"java.base\"));\n+        addDefaultMapping(Signature.ClassTypeSig.class, Signature.ClassTypeSig.of(ClassDesc.of(\"java.util.Iterator\")));\n+        addDefaultMapping(Signature.TypeArg.Bounded.WildcardIndicator.class, Signature.TypeArg.Bounded.WildcardIndicator.NONE);\n+        addDefaultMapping(Signature.RefTypeSig.class, Signature.ClassTypeSig.of(ClassDesc.of(\"java.util.Iterator\")));\n+        addDefaultMapping(StackMapFrameInfo.SimpleVerificationTypeInfo.class, StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_DOUBLE);\n+        addDefaultMapping(MethodSignature.class, MethodSignature.parseFrom(\"<T::Ljava\/lang\/annotation\/Annotation;>(Ljava\/lang\/Class<TT;>;)[TT;^Ljava\/lang\/IOException;^Ljava\/lang\/IllegalAccessError;\"));\n+        addDefaultMapping(ClassSignature.class, ClassSignature.parseFrom(\"Ljava\/util\/LinkedHashMap<TK;TV;>.LinkedHashIterator;Ljava\/util\/Iterator<Ljava\/util\/Map$Entry<TK;TV;>;>;\"));\n+        addDefaultMapping(Opcode.Kind.class, Opcode.Kind.CONSTANT);\n+\n+        cm.flags().flags().stream().findFirst().ifPresent(flag -> addDefaultMapping(AccessFlag.class, flag));\n+        try {\n+            Runnable runnable = () -> ClassFile.of().parse(new byte[]{(byte) 0xCA, (byte) 0xFE, (byte) 0xBA, (byte) 0xBE,\n+                    0, 0, 0, 0, 0, 2, ClassFile.TAG_METHODREF, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}).thisClass();\n+            runnable.run();\n+        } catch (ConstantPoolException e) {\n+            addDefaultMapping(ConstantPoolException.class, e);\n+            addDefaultMapping(Throwable.class, e);\n+        }\n+\n+        try {\n+            addDefaultMapping(BootstrapMethodEntry.class, cm.constantPool().bootstrapMethodEntry(0));\n+            addDefaultMapping(LoadableConstantEntry.class, cm.constantPool().bootstrapMethodEntry(0).arguments().getFirst());\n+        } catch (Exception e) {\n+            \/\/ skip\n+        }\n+\n+        for (ClassFileElement ce : cm) {\n+            if (ce instanceof AttributedElement ae) {\n+                addDefaultMapping(ClassFileElement.class, ce);\n+                addDefaultMapping(AttributedElement.class, ae);\n+\n+            }\n+            if (Objects.requireNonNull(ce) instanceof CompoundElement<?> comp) {\n+                addDefaultMapping(CompoundElement.class, comp);\n+            }\n+        }\n+\n+        ModuleDesc modName = ModuleDesc.of(\"some.module.structure\");\n+        String modVsn = \"ab75\";\n+        ModuleDesc require1 = ModuleDesc.of(\"1require.some.mod\");\n+        String vsn1 = \"1the.best.version\";\n+        ModuleDesc require2 = ModuleDesc.of(\"2require.some.mod\");\n+        String vsn2 = \"2the.best.version\";\n+        ModuleDesc[] et1 = new ModuleDesc[]{ModuleDesc.of(\"1t1\"), ModuleDesc.of(\"1t2\")};\n+        ModuleDesc[] et2 = new ModuleDesc[]{ModuleDesc.of(\"2t1\")};\n+        ModuleDesc[] et3 = new ModuleDesc[]{ModuleDesc.of(\"3t1\"), ModuleDesc.of(\"3t2\"), ModuleDesc.of(\"3t3\")};\n+        ModuleDesc[] ot3 = new ModuleDesc[]{ModuleDesc.of(\"t1\"), ModuleDesc.of(\"t2\")};\n+\n+\n+        var classFile = ClassFile.of();\n+        byte[] modInfo = classFile.buildModule(\n+                ModuleAttribute.of(modName, mb -> {\n+                    addDefaultMapping(ModuleAttribute.ModuleAttributeBuilder.class, mb);\n+                    mb.moduleVersion(modVsn)\n+                            .requires(require1, 77, vsn1)\n+                            .requires(require2, 99, vsn2)\n+                            .exports(PackageDesc.of(\"0\"), 0, et1)\n+                            .exports(PackageDesc.of(\"1\"), 1, et2)\n+                            .exports(PackageDesc.of(\"2\"), 2, et3)\n+                            .exports(PackageDesc.of(\"3\"), 3)\n+                            .exports(PackageDesc.of(\"4\"), 4)\n+                            .opens(PackageDesc.of(\"o0\"), 0)\n+                            .opens(PackageDesc.of(\"o1\"), 1)\n+                            .opens(PackageDesc.of(\"o2\"), 2, ot3)\n+                            .uses(ClassDesc.of(\"some.Service\"))\n+                            .uses(ClassDesc.of(\"another.Service\"))\n+                            .provides(ClassDesc.of(\"some.nice.Feature\"), ClassDesc.of(\"impl\"), ClassDesc.of(\"another.impl\"));\n+                }),\n+                clb -> clb.with(ModuleMainClassAttribute.of(ClassDesc.of(\"main.Class\")))\n+                        .with(ModulePackagesAttribute.ofNames(PackageDesc.of(\"foo.bar.baz\"), PackageDesc.of(\"quux\")))\n+                        .with(ModuleMainClassAttribute.of(ClassDesc.of(\"overwritten.main.Class\")))\n+        );\n+\n+        final ClassModel moduleModel = classFile.parse(modInfo);\n+        final ModuleAttribute moduleAttribute = ((ModuleAttribute) moduleModel.attributes().stream()\n+                .filter(a -> a.attributeMapper() == Attributes.module())\n+                .findFirst()\n+                .orElseThrow());\n+        moduleModel.attributes().stream()\n+                .filter(a -> a.attributeMapper() == Attributes.module())\n+                .forEach(_ -> addDefaultMapping(AttributeMapper.AttributeStability.class, moduleAttribute.attributeMapper().stability()));\n+\n+        addDefaultMapping(ModuleAttribute.class, moduleAttribute);\n+        addDefaultMapping(ModuleOpenInfo.class, moduleAttribute.opens().getFirst());\n+        addDefaultMapping(ModuleRequireInfo.class, moduleAttribute.requires().getFirst());\n+        addDefaultMapping(ModuleExportInfo.class, moduleAttribute.exports().getFirst());\n+        addDefaultMapping(ModuleProvideInfo.class, moduleAttribute.provides().getFirst());\n+\n+\n+        ClassFile.of().transformClass(cm, (cb, ce) -> {\n+            addDefaultMapping(ClassBuilder.class, cb);\n+            addDefaultMapping(ClassFileBuilder.class, cb);\n+            switch (ce) {\n+                case MethodModel m -> cb.transformMethod(m, (mb, me) -> {\n+                    addDefaultMapping(MethodBuilder.class, mb);\n+                    if (!(me instanceof RuntimeVisibleAnnotationsAttribute || me instanceof RuntimeInvisibleAnnotationsAttribute))\n+                        mb.with(me);\n+                });\n+                case FieldModel f -> cb.transformField(f, (fb, fe) -> {\n+                    addDefaultMapping(FieldBuilder.class, fb);\n+                    if (!(fe instanceof RuntimeVisibleAnnotationsAttribute || fe instanceof RuntimeInvisibleAnnotationsAttribute))\n+                        fb.with(fe);\n+                });\n+                default -> cb.with(ce);\n+            }\n+        });\n+\n+\n+        var annotation = cm.findAttribute(Attributes.runtimeVisibleAnnotations());\n+        if (annotation.isPresent()) {\n+            addDefaultMapping(Annotation.class, annotation.get().annotations().getFirst());\n+            addDefaultMapping(ClassPrinter.ListNode.class, new ClassPrinterImpl.ListNodeImpl(FLOW, \"array\", cm.findAttribute(Attributes.runtimeVisibleAnnotations()).stream().map(\n+                    _ -> new ClassPrinterImpl.MapNodeImpl(FLOW, \"value\"))));\n+        }\n+\n+        for (var cpe : cm.constantPool()) {\n+            switch (cpe) {\n+                case DoubleEntry de -> {\n+                    addDefaultMapping(DoubleEntry.class, de);\n+                    addDefaultMapping(ConstantValueEntry.class, de);\n+                }\n+                case FloatEntry fe -> addDefaultMapping(FloatEntry.class, fe);\n+                case IntegerEntry ie -> {\n+                    addDefaultMapping(IntegerEntry.class, ie);\n+                    addDefaultMapping(PoolEntry.class, ie);\n+                }\n+                case LongEntry le -> addDefaultMapping(LongEntry.class, le);\n+                case Utf8Entry ue -> addDefaultMapping(Utf8Entry.class, ue);\n+                case ConstantDynamicEntry cde -> addDefaultMapping(ConstantDynamicEntry.class, cde);\n+                case InvokeDynamicEntry ide -> addDefaultMapping(InvokeDynamicEntry.class, ide);\n+                case ClassEntry ce -> addDefaultMapping(ClassEntry.class, ce);\n+                case MethodHandleEntry mhe -> {\n+                    addDefaultMapping(MethodHandleEntry.class, mhe);\n+                    addDefaultMapping(MemberRefEntry.class, mhe.reference());\n+                    addDefaultMapping(DirectMethodHandleDesc.class, mhe.asSymbol());\n+                    addDefaultMapping(DynamicConstantDesc.class, DynamicConstantDesc.of(mhe.asSymbol()));\n+                    addDefaultMapping(DynamicCallSiteDesc.class, DynamicCallSiteDesc.of(mhe.asSymbol(), cm.methods().getFirst().methodTypeSymbol()));\n+                }\n+                case FieldRefEntry fre -> addDefaultMapping(FieldRefEntry.class, fre);\n+                case InterfaceMethodRefEntry imre -> addDefaultMapping(InterfaceMethodRefEntry.class, imre);\n+                case MethodRefEntry mre -> addDefaultMapping(MethodRefEntry.class, mre);\n+                case ModuleEntry me -> addDefaultMapping(ModuleEntry.class, me);\n+                case NameAndTypeEntry nate -> addDefaultMapping(NameAndTypeEntry.class, nate);\n+                case PackageEntry pe -> addDefaultMapping(PackageEntry.class, pe);\n+                default -> {}\n+            }\n+        }\n+\n+        for (ClassElement ce : cm) {\n+            switch (ce) {\n+                case Attribute<?> a -> {\n+                    addDefaultMapping(AttributeMapper.class, a.attributeMapper());\n+                    addDefaultMapping(Attribute.class, a);\n+                }\n+                case AccessFlags af -> addDefaultMapping(AccessFlags.class, af);\n+                case FieldModel fm -> {\n+                    addDefaultMapping(FieldModel.class, fm);\n+                    addDefaultMapping(Utf8Entry.class, fm.fieldName());\n+                    addDefaultMapping(ClassDesc.class, fm.fieldTypeSymbol());\n+                    addDefaultMapping(Signature.class, Signature.of(fm.fieldTypeSymbol()));\n+                    addDefaultMapping(TypeDescriptor.OfField.class, fm.fieldTypeSymbol());\n+                    addDefaultMapping(AnnotationValue.class, AnnotationValue.of(fm.fieldTypeSymbol()));\n+                }\n+                case MethodModel mm -> {\n+                    addDefaultMapping(CodeLocalsShifter.class, CodeLocalsShifter.of(mm.flags(), mm.methodTypeSymbol()));\n+                    addDefaultMapping(MethodTypeDesc.class, mm.methodTypeSymbol());\n+                    addDefaultMapping(MethodModel.class, mm);\n+                    for (MethodElement me : mm) {\n+                        if (me instanceof CodeModel xm) {\n+                            addDefaultMapping(CodeModel.class, xm);\n+                            addDefaultMapping(CodeAttribute.class, (CodeAttribute) xm);\n+                            for (CodeElement e : xm) {\n+                                switch (e) {\n+                                    case BranchInstruction ii -> addDefaultMapping(Label.class, ii.target());\n+                                    case NewReferenceArrayInstruction c -> addDefaultMapping(Opcode.class, c.opcode());\n+                                    default -> {}\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                default -> {}\n+            }\n+        }\n+\n+        for (Attribute<?> a : cm.attributes()) {\n+            switch (a) {\n+                case ModuleAttribute attr -> addDefaultMapping(ModuleAttribute.class, attr);\n+                case RuntimeVisibleTypeAnnotationsAttribute attr ->\n+                        addDefaultMapping(RuntimeVisibleTypeAnnotationsAttribute.class, attr);\n+                case RuntimeInvisibleTypeAnnotationsAttribute attr ->\n+                        addDefaultMapping(RuntimeInvisibleTypeAnnotationsAttribute.class, attr);\n+                case RuntimeVisibleParameterAnnotationsAttribute attr ->\n+                        addDefaultMapping(RuntimeVisibleParameterAnnotationsAttribute.class, attr);\n+                case RuntimeInvisibleParameterAnnotationsAttribute attr ->\n+                        addDefaultMapping(RuntimeInvisibleParameterAnnotationsAttribute.class, attr);\n+                case SourceDebugExtensionAttribute attr -> addDefaultMapping(SourceDebugExtensionAttribute.class, attr);\n+                case SourceIDAttribute attr -> addDefaultMapping(SourceIDAttribute.class, attr);\n+                default -> {}\n+            }\n+        }\n+\n+        ClassFile.of().build(ClassDesc.of(\"C\"), cb -> cb.withMethod(\"main\", MethodTypeDesc.of(ConstantDescs.CD_String, ConstantDescs.CD_String.arrayType()),\n+                ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC, mb -> mb.withCode(xb -> {\n+                    int stringSlot = xb.allocateLocal(TypeKind.REFERENCE);\n+                    xb.loadConstant(\"S\");\n+                    xb.astore(stringSlot);\n+                    xb.trying(tb -> {\n+                        tb.aload(0);\n+                        tb.loadConstant(0);\n+                        \/\/ IndexOutOfBoundsException\n+                        tb.aaload();\n+                        \/\/ NullPointerException\n+                        tb.invokevirtual(ConstantDescs.CD_String, \"toString\", MethodType.methodType(String.class).describeConstable().get());\n+                        tb.astore(stringSlot);\n+                    }, catchBuilder -> {\n+                        catchBuilder.catching(IndexOutOfBoundsException.class.describeConstable().get(), tb -> {\n+                            tb.pop();\n+                            tb.ldc(\"IndexOutOfBoundsException\");\n+                            tb.areturn();\n+                        }).catchingAll(tb -> {\n+                            tb.pop();\n+                            tb.ldc(\"any\");\n+                            tb.areturn();\n+                        });\n+                        addDefaultMapping(CodeBuilder.CatchBuilder.class, catchBuilder);\n+                    });\n+                    xb.aload(stringSlot);\n+                    xb.areturn();\n+                })));\n+\n+\n+        ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS).build(cm.thisClass().asSymbol(), clb -> {\n+            for (var cle : cm) {\n+                switch (cle) {\n+                    case AccessFlags af -> clb.withFlags(af.flagsMask());\n+                    case Interfaces i ->\n+                            clb.withInterfaceSymbols(i.interfaces().stream().map(ClassEntry::asSymbol).toArray(ClassDesc[]::new));\n+                    case ClassFileVersion v -> clb.withVersion(v.majorVersion(), v.minorVersion());\n+                    case MethodModel mm ->\n+                            clb.withMethod(mm.methodName().stringValue(), mm.methodTypeSymbol(), mm.flags().flagsMask(), _ -> {\n+                                for (var me : mm) {\n+                                    if (Objects.requireNonNull(me) instanceof MethodParametersAttribute a) {\n+                                        var r = MethodParametersAttribute.of(\n+                                                        a.parameters().stream().map(\n+                                                                mp -> MethodParameterInfo.ofParameter(mp.name().map(Utf8Entry::stringValue), mp.flagsMask())\n+                                                        ).toArray(MethodParameterInfo[]::new)\n+                                                )\n+                                                .parameters()\n+                                                .getFirst();\n+                                        addDefaultMapping(MethodParameterInfo.class, r);\n+                                    }\n+                                }\n+                            });\n+                    case InnerClassesAttribute a ->\n+                            addDefaultMapping(InnerClassInfo.class, InnerClassesAttribute.of(a.classes().stream().map(ici -> InnerClassInfo.of(\n+                                            ici.innerClass().asSymbol(),\n+                                            ici.outerClass().map(ClassEntry::asSymbol),\n+                                            ici.innerName().map(Utf8Entry::stringValue),\n+                                            ici.flagsMask())).toArray(InnerClassInfo[]::new))\n+                                    .classes().getFirst());\n+                    case ModuleAttribute a -> clb.with(\n+                            ModuleAttribute.of(a.moduleName().asSymbol(), mob -> {\n+                                mob.moduleFlags(a.moduleFlagsMask());\n+                                a.moduleVersion().ifPresent(v -> mob.moduleVersion(v.stringValue()));\n+                                for (var req : a.requires())\n+                                    mob.requires(req.requires().asSymbol(), req.requiresFlagsMask(), req.requiresVersion().map(Utf8Entry::stringValue).orElse(\"placeholder\"));\n+                                for (var exp : a.exports())\n+                                    mob.exports(exp.exportedPackage().asSymbol(), exp.exportsFlagsMask(), exp.exportsTo().stream().map(ModuleEntry::asSymbol).toArray(ModuleDesc[]::new));\n+                                for (var opn : a.opens())\n+                                    mob.opens(opn.openedPackage().asSymbol(), opn.opensFlagsMask(), opn.opensTo().stream().map(ModuleEntry::asSymbol).toArray(ModuleDesc[]::new));\n+                                for (var use : a.uses()) mob.uses(use.asSymbol());\n+                                for (var prov : a.provides())\n+                                    mob.provides(prov.provides().asSymbol(), prov.providesWith().stream().map(ClassEntry::asSymbol).toArray(ClassDesc[]::new));\n+                            }));\n+                    case RecordAttribute a -> RecordAttribute.of(a.components().stream().map(rci -> {\n+                        var y = RecordComponentInfo.of(rci.name().stringValue(), rci.descriptorSymbol(), rci.attributes().stream().mapMulti((_, _) -> {\n+                        }).toArray(Attribute[]::new));\n+                        addDefaultMapping(RecordComponentInfo.class, y);\n+                        return RecordComponentInfo.of(rci.name().stringValue(), rci.descriptorSymbol(), rci.attributes().stream().mapMulti((_, _) -> {\n+                        }).toArray(Attribute[]::new));\n+                    }).toArray(RecordComponentInfo[]::new));\n+                    default -> {}\n+                }\n+            }\n+        });\n+\n+\n+        var testClass = \"JsrAndRetSample\";\n+        var testMethod = \"testMethod\";\n+        var cd_list = ArrayList.class.describeConstable().get();\n+        ClassFile.of().build(ClassDesc.of(testClass), clb -> clb\n+                .withVersion(ClassFile.JAVA_5_VERSION, 0)\n+                .withMethodBody(testMethod, MethodTypeDesc.of(ConstantDescs.CD_void, cd_list), ClassFile.ACC_PUBLIC | ClassFile.ACC_STATIC, cob -> cob\n+                        .block(bb -> {\n+                            addDefaultMapping(CodeBuilder.BlockCodeBuilder.class, bb);\n+\n+                            bb.loadConstant(\"Hello\")\n+                                    .with(DiscontinuedInstruction.JsrInstruction.of(bb.breakLabel()));\n+                            bb.loadConstant(\"World\")\n+                                    .with(DiscontinuedInstruction.JsrInstruction.of(Opcode.JSR_W, bb.breakLabel()))\n+                                    .return_();\n+                        })\n+                        .astore(355)\n+                        .aload(0)\n+                        .swap()\n+                        .invokevirtual(cd_list, \"add\", MethodTypeDesc.of(ConstantDescs.CD_boolean, ConstantDescs.CD_Object))\n+                        .pop()\n+                        .with(DiscontinuedInstruction.RetInstruction.of(355))));\n+\n+\n+        var root = Paths.get(URI.create(TestNullHostile.class.getResource(\"TestNullHostile.class\").toString())).getParent();\n+        var cc = ClassFile.of();\n+        Files.write(root.resolve(\"testdata\/Pattern2-split.class\"), cc.transformClass(cc.parse(root.resolve(\"testdata\/Pattern2.class\")), ClassTransform.transformingMethodBodies((cob, coe) -> {\n+            addDefaultMapping(CodeBuilder.class, cob);\n+            var dcob = (DirectCodeBuilder) cob;\n+            var curPc = dcob.curPc();\n+            switch (coe) {\n+                case LineNumber ln ->\n+                        dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.lineNumberTable()) {\n+                            @Override\n+                            public void writeBody(BufWriterImpl b) {\n+                                addDefaultMapping(BufWriter.class, b);\n+                                b.writeU2(1);\n+                                b.writeU2(curPc);\n+                                b.writeU2(ln.line());\n+                            }\n+                        });\n+                case LocalVariable lv ->\n+                        dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTable()) {\n+                            @Override\n+                            public void writeBody(BufWriterImpl b) {\n+                                b.writeU2(1);\n+                                Util.writeLocalVariable(b, lv);\n+                            }\n+                        });\n+                case LocalVariableType lvt ->\n+                        dcob.writeAttribute(new UnboundAttribute.AdHocAttribute<>(Attributes.localVariableTypeTable()) {\n+                            @Override\n+                            public void writeBody(BufWriterImpl b) {\n+                                b.writeU2(1);\n+                                Util.writeLocalVariable(b, lvt);\n+                            }\n+                        });\n+                default -> cob.with(coe);\n+            }\n+        })));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/TestNullHostile.java","additions":961,"deletions":0,"binary":false,"changes":961,"status":"added"}]}