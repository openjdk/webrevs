{"files":[{"patch":"@@ -553,1 +553,2 @@\n-     * @throws IllegalArgumentException for conversions of {@code VoidType} or {@code ReferenceType}\n+     * @throws IllegalArgumentException for conversions of {@link TypeKind#VOID void} or\n+     *         {@link TypeKind#REFERENCE reference}\n@@ -557,56 +558,47 @@\n-        return switch (fromType) {\n-            case INT, BYTE, CHAR, SHORT, BOOLEAN ->\n-                    switch (toType) {\n-                        case INT -> this;\n-                        case LONG -> i2l();\n-                        case DOUBLE -> i2d();\n-                        case FLOAT -> i2f();\n-                        case BYTE -> i2b();\n-                        case CHAR -> i2c();\n-                        case SHORT -> i2s();\n-                        case BOOLEAN -> iconst_1().iand();\n-                        case VOID, REFERENCE ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case LONG ->\n-                    switch (toType) {\n-                        case INT -> l2i();\n-                        case LONG -> this;\n-                        case DOUBLE -> l2d();\n-                        case FLOAT -> l2f();\n-                        case BYTE -> l2i().i2b();\n-                        case CHAR -> l2i().i2c();\n-                        case SHORT -> l2i().i2s();\n-                        case BOOLEAN -> l2i().iconst_1().iand();\n-                        case VOID, REFERENCE ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case DOUBLE ->\n-                    switch (toType) {\n-                        case INT -> d2i();\n-                        case LONG -> d2l();\n-                        case DOUBLE -> this;\n-                        case FLOAT -> d2f();\n-                        case BYTE -> d2i().i2b();\n-                        case CHAR -> d2i().i2c();\n-                        case SHORT -> d2i().i2s();\n-                        case BOOLEAN -> d2i().iconst_1().iand();\n-                        case VOID, REFERENCE ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case FLOAT ->\n-                    switch (toType) {\n-                        case INT -> f2i();\n-                        case LONG -> f2l();\n-                        case DOUBLE -> f2d();\n-                        case FLOAT -> this;\n-                        case BYTE -> f2i().i2b();\n-                        case CHAR -> f2i().i2c();\n-                        case SHORT -> f2i().i2s();\n-                        case BOOLEAN -> f2i().iconst_1().iand();\n-                        case VOID, REFERENCE ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case VOID, REFERENCE ->\n-                throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-        };\n+        var computationalFrom = fromType.asLoadable();\n+        var computationalTo = toType.asLoadable();\n+        if (computationalFrom != computationalTo) {\n+            switch (computationalTo) {\n+                case INT -> {\n+                    switch (computationalFrom) {\n+                        case FLOAT -> f2i();\n+                        case LONG -> l2i();\n+                        case DOUBLE -> d2i();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+                case FLOAT -> {\n+                    switch (computationalFrom) {\n+                        case INT -> i2f();\n+                        case LONG -> l2f();\n+                        case DOUBLE -> d2f();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+                case LONG -> {\n+                    switch (computationalFrom) {\n+                        case INT -> i2l();\n+                        case FLOAT -> f2l();\n+                        case DOUBLE -> d2l();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+                case DOUBLE -> {\n+                    switch (computationalFrom) {\n+                        case INT -> i2d();\n+                        case FLOAT -> f2d();\n+                        case LONG -> l2d();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+            }\n+        }\n+        if (computationalTo == TypeKind.INT && toType != TypeKind.INT) {\n+            switch (toType) {\n+                case BOOLEAN -> iconst_1().iand();\n+                case BYTE -> i2b();\n+                case CHAR -> i2c();\n+                case SHORT -> i2s();\n+            }\n+        }\n+        return this;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":49,"deletions":57,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-    \/** Load byte from array *\/\n+    \/** Load byte or boolean from array *\/\n@@ -296,1 +296,1 @@\n-    \/** Store into byte array *\/\n+    \/** Store into byte or boolean array *\/\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Opcode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n@@ -31,0 +33,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -57,0 +60,13 @@\n+    \/\/ Elements are grouped so frequently used switch ranges such as\n+    \/\/ primitives (boolean - double) and computational (int - void) are together.\n+    \/\/ Begin primitive types\n+    \/**\n+     * The primitive type {@code boolean}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. {@code 0} represents {@code false},\n+     * and {@code 1} represents {@code true}. It is zero-extended to an {@code int}\n+     * when loaded onto the operand stack and narrowed by taking the bitwise AND\n+     * with {@code 1} when stored.\n+     *\n+     * @jvms 2.3.4 The {@code boolean} Type\n+     *\/\n+    BOOLEAN(1, 4),\n@@ -63,1 +79,8 @@\n-    BYTE(\"byte\", \"B\", 8),\n+    BYTE(1, 8),\n+    \/**\n+     * The primitive type {@code char}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. It is zero-extended to an\n+     * {@code int} when loaded onto the operand stack and truncated when\n+     * stored.\n+     *\/\n+    CHAR(1, 5),\n@@ -70,9 +93,2 @@\n-    SHORT(\"short\", \"S\", 9),\n-    \/** The primitive type {@code int}. *\/\n-    INT(\"int\", \"I\", 10),\n-    \/** The primitive type {@code float}. *\/\n-    FLOAT(\"float\", \"F\", 6),\n-    \/** The primitive type {@code long}. It is of {@linkplain #slotSize() category} 2. *\/\n-    LONG(\"long\", \"J\", 11),\n-    \/** The primitive type {@code double}. It is of {@linkplain #slotSize() category} 2. *\/\n-    DOUBLE(\"double\", \"D\", 7),\n+    SHORT(1, 9),\n+    \/\/ Begin computational types\n@@ -80,2 +96,1 @@\n-     * A reference type.\n-     * @jvms 2.4 Reference Types and Values\n+     * The primitive type {@code int}.\n@@ -83,1 +98,1 @@\n-    REFERENCE(\"reference type\", \"L\", -1),\n+    INT(1, 10),\n@@ -85,4 +100,1 @@\n-     * The primitive type {@code char}. Its {@linkplain ##computational-type\n-     * computational type} is {@link #INT int}. It is zero-extended to an\n-     * {@code int} when loaded onto the operand stack and truncated when\n-     * stored.\n+     * The primitive type {@code float}.\n@@ -90,1 +102,1 @@\n-    CHAR(\"char\", \"C\", 5),\n+    FLOAT(1, 6),\n@@ -92,7 +104,11 @@\n-     * The primitive type {@code boolean}. Its {@linkplain ##computational-type\n-     * computational type} is {@link #INT int}. {@code 0} represents {@code false},\n-     * and {@code 1} represents {@code true}. It is zero-extended to an {@code int}\n-     * when loaded onto the operand stack and narrowed by taking the bitwise AND\n-     * with {@code 1} when stored.\n-     *\n-     * @jvms 2.3.4 The {@code boolean} Type\n+     *  The primitive type {@code long}. It is of {@linkplain #slotSize() category} 2.\n+     *\/\n+    LONG(2, 11),\n+    \/**\n+     * The primitive type {@code double}. It is of {@linkplain #slotSize() category} 2.\n+     *\/\n+    DOUBLE(2, 7),\n+    \/\/ End primitive types\n+    \/**\n+     * A reference type.\n+     * @jvms 2.4 Reference Types and Values\n@@ -100,1 +116,1 @@\n-    BOOLEAN(\"boolean\", \"Z\", 4),\n+    REFERENCE(1, -1),\n@@ -108,1 +124,2 @@\n-    VOID(\"void\", \"V\", -1);\n+    VOID(0, -1);\n+    \/\/ End computational types\n@@ -110,2 +127,2 @@\n-    private final String name;\n-    private final String descriptor;\n+    private @Stable ClassDesc upperBound;\n+    private final int slots;\n@@ -114,3 +131,2 @@\n-    TypeKind(String name, String descriptor, int newarrayCode) {\n-        this.name = name;\n-        this.descriptor = descriptor;\n+    TypeKind(int slots, int newarrayCode) {\n+        this.slots = slots;\n@@ -120,3 +136,0 @@\n-    \/** {@return the human-readable name corresponding to this type} *\/\n-    public String typeName() { return name; }\n-\n@@ -124,2 +137,4 @@\n-     * {@return the field descriptor character corresponding to this type, or {@code L} for\n-     * {@link #REFERENCE reference}}\n+     * {@return the most specific upper bound field descriptor that can store any value\n+     * of this type} This is the primitive class descriptor for primitive types and\n+     * {@link #VOID void} and {@link ConstantDescs#CD_Object Object} descriptor for\n+     * {@link #REFERENCE reference}.\n@@ -127,1 +142,21 @@\n-    public String descriptor() { return descriptor; }\n+    public ClassDesc upperBound() {\n+        var upper = this.upperBound;\n+        if (upper == null)\n+            return this.upperBound = fetchUpperBound();\n+        return upper;\n+    }\n+\n+    private ClassDesc fetchUpperBound() {\n+        return switch (this) {\n+            case BOOLEAN -> ConstantDescs.CD_boolean;\n+            case BYTE -> ConstantDescs.CD_byte;\n+            case CHAR -> ConstantDescs.CD_char;\n+            case SHORT -> ConstantDescs.CD_short;\n+            case INT -> ConstantDescs.CD_int;\n+            case FLOAT -> ConstantDescs.CD_float;\n+            case LONG -> ConstantDescs.CD_long;\n+            case DOUBLE -> ConstantDescs.CD_double;\n+            case REFERENCE -> ConstantDescs.CD_Object;\n+            case VOID -> ConstantDescs.CD_void;\n+        };\n+    }\n@@ -130,1 +165,1 @@\n-     * {@return the code used by the {@code newarray} instruction to create an array\n+     * {@return the code used by the {@link Opcode#NEWARRAY newarray} instruction to create an array\n@@ -142,1 +177,2 @@\n-     * regard to type (JVMS {@jvms 2.11.1}), such as {@code pop} versus {@code pop2}.\n+     * regard to type (JVMS {@jvms 2.11.1}), such as {@link Opcode#POP pop} versus {@link Opcode#POP2\n+     * pop2}.\n@@ -147,5 +183,1 @@\n-        return switch (this) {\n-            case VOID -> 0;\n-            case LONG, DOUBLE -> 2;\n-            default -> 1;\n-        };\n+        return this.slots;\n@@ -159,4 +191,1 @@\n-        return switch (this) {\n-            case BOOLEAN, BYTE, CHAR, SHORT -> TypeKind.INT;\n-            default -> this;\n-        };\n+        return ordinal() < 4 ? INT : this;\n@@ -166,1 +195,2 @@\n-     * {@return the component type described by the array code used as an operand to {@code newarray}}\n+     * {@return the component type described by the array code used as an operand to {@link Opcode#NEWARRAY\n+     * newarray}}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeKind.java","additions":80,"deletions":50,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,3 @@\n-     * {@return the component type of the array}\n+     * {@return the component type of the array} The {@link TypeKind#BYTE byte}\n+     * type load instruction {@link Opcode#BALOAD baload} also operates on\n+     * {@link TypeKind#BOOLEAN boolean} arrays.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ArrayLoadInstruction.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,3 @@\n-     * {@return the component type of the array}\n+     * {@return the component type of the array} The {@link TypeKind#BYTE byte}\n+     * type store instruction {@link Opcode#BASTORE bastore} also operates on\n+     * {@link TypeKind#BOOLEAN boolean} arrays.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ArrayStoreInstruction.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            throw new IllegalArgumentException(\"Illegal component type: \" + typeKind.typeName());\n+            throw new IllegalArgumentException(\"Illegal component type for primitive array: \" + typeKind.name());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewPrimitiveArrayInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,4 @@\n+    public static IllegalArgumentException cannotConvertException(TypeKind from, TypeKind to) {\n+        return new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+    }\n+\n@@ -206,1 +210,1 @@\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        default -> throw cannotConvertException(from, to);\n@@ -213,1 +217,1 @@\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        default -> throw cannotConvertException(from, to);\n@@ -220,1 +224,1 @@\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        default -> throw cannotConvertException(from, to);\n@@ -227,1 +231,1 @@\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        default -> throw cannotConvertException(from, to);\n@@ -229,1 +233,1 @@\n-            default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+            default -> throw cannotConvertException(from, to);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -854,1 +854,1 @@\n-                                \"descriptor\", newa.typeKind().typeName()));\n+                                \"descriptor\", newa.typeKind().upperBound().displayName()));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-                    print(\" \" + instr.typeKind().typeName());\n+                    print(\" \" + instr.typeKind().upperBound().displayName());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/CodeWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-                        new ConstantPoolEntryRecord.CpClassRecord(\"[\" + cins.typeKind().descriptor()).hashCode() + 1;\n+                        new ConstantPoolEntryRecord.CpClassRecord(\"[\" + cins.typeKind().upperBound().descriptorString()).hashCode() + 1;\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ClassRecord.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}