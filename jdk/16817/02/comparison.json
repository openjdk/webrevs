{"files":[{"patch":"@@ -732,1 +732,2 @@\n-        byte[] magnitude = randomBits(numBits, rnd);\n+        \/\/ randomBits() returns a zero length array if numBits == 0\n+        this.mag = randomBits(numBits, rnd);\n@@ -734,10 +735,5 @@\n-        try {\n-            \/\/ stripLeadingZeroBytes() returns a zero length array if len == 0\n-            this.mag = stripLeadingZeroBytes(magnitude, 0, magnitude.length);\n-\n-            if (this.mag.length == 0) {\n-                this.signum = 0;\n-            } else {\n-                this.signum = 1;\n-            }\n-            if (mag.length >= MAX_MAG_LENGTH) {\n+        if (this.mag.length == 0) {\n+            this.signum = 0;\n+        } else {\n+            this.signum = 1;\n+            if (mag.length >= MAX_MAG_LENGTH)\n@@ -745,3 +741,0 @@\n-            }\n-        } finally {\n-            Arrays.fill(magnitude, (byte)0);\n@@ -751,1 +744,1 @@\n-    private static byte[] randomBits(int numBits, Random rnd) {\n+    private static int[] randomBits(int numBits, Random rnd) {\n@@ -754,8 +747,14 @@\n-        int numBytes = (int)(((long)numBits+7)\/8); \/\/ avoid overflow\n-        byte[] randomBits = new byte[numBytes];\n-\n-        \/\/ Generate random bytes and mask out any excess bits\n-        if (numBytes > 0) {\n-            rnd.nextBytes(randomBits);\n-            int excessBits = 8*numBytes - numBits;\n-            randomBits[0] &= (byte)((1 << (8-excessBits)) - 1);\n+\n+        if (numBits == 0)\n+            return new int[0];\n+\n+        final int numInts = ((numBits - 1) >> 5) + 1;\n+        \/\/ numInts >= 1, since numBits > 0\n+\n+        int firstInt = rnd.nextInt() & (-1 >>> -numBits); \/\/ Mask out any excess bits\n+        \/\/ Skip any leading zero ints\n+        int len;\n+        if (firstInt == 0) {\n+            for (len = numInts - 1; len > 0 && (firstInt = rnd.nextInt()) == 0; len--);\n+        } else {\n+            len = numInts;\n@@ -763,0 +762,9 @@\n+\n+        int[] randomBits = new int[len];\n+        if (randomBits.length > 0) {\n+            randomBits[0] = firstInt; \/\/ firstInt != 0\n+            \/\/ Generate random ints\n+            for (int i = 1; i < randomBits.length; i++)\n+                randomBits[i] = rnd.nextInt();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":31,"deletions":23,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+package org.openjdk.bench.java.math;\n+\n+import java.math.BigInteger;\n+import java.time.Duration;\n+import java.util.Random;\n+\n+public class RandomBigIntegers {\n+\n+    public static void main(String[] args) {\n+        System.getProperties();\n+        String javaInfo = \"JVM: \";\n+        javaInfo += \" \" + System.getProperty(\"java.vm.name\");\n+        javaInfo += \" \" + System.getProperty(\"java.vm.version\");\n+        String osInfo = \"OS: \";\n+        osInfo += \" \" + System.getProperty(\"os.name\");\n+        osInfo += \" \" + System.getProperty(\"os.version\");\n+\n+        System.out.println(javaInfo);\n+        System.out.println(osInfo);\n+\n+        for (int numBits = 1; numBits >= 0; numBits <<= 1) {\n+            Random rnd = new Random();\n+            long t0, t1;\n+            t0 = System.nanoTime();\n+            new BigInteger(numBits, rnd);\n+            t1 = System.nanoTime();\n+\n+            System.out.println(\"numBits=\" + numBits + \", execution time=\" + Duration.ofNanos(t1 - t0));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/RandomBigIntegers.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"}]}