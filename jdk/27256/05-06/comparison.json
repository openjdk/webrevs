{"files":[{"patch":"@@ -528,0 +528,16 @@\n+     *\n+     * For example, having (with mismatchingCandidate == 0):\n+     * existing: R(A _, Box(var _)) {}\n+     * cadidate: R(B _, Box(var _)) {}\n+     * these are always equivalent; as all nested patterns except of\n+     * component 0 are exactly equivalent\n+     *\n+     * existing: R(A _, SubtypeOfBox _) {}\n+     * cadidate: R(A _, Box _) {}\n+     * this is only equivalent when useHashes == false; Box _ could be replaced\n+     * with a more specific SubtypeOfBox _\n+     *\n+     * existing: R(A _, Box(var _)) {}\n+     * cadidate: R(A _, Box _) {}\n+     * this is only equivalent when useHashes == false and patternEquivalence == LOOSE;\n+     * Box _ is accepted in place of the more specific record pattern\n@@ -553,1 +569,1 @@\n-                            if (!types.isSubtype(types.erasure(nestedExisting.recordType()), types.erasure(nestedCandidate.type))) {\n+                            if (!isSubtypeErasure(nestedExisting.recordType(), nestedCandidate.type)) {\n@@ -1119,2 +1135,1 @@\n-            \/\/assert?\n-            return null;\n+            throw Assert.error();\n@@ -1167,10 +1182,0 @@\n-    private Set<PatternDescription> joinSets(Collection<? extends PatternDescription> s1,\n-                                             Collection<? extends PatternDescription> s2) {\n-        Set<PatternDescription> result = new HashSet<>();\n-\n-        result.addAll(s1);\n-        result.addAll(s2);\n-\n-        return result;\n-    }\n-\n@@ -1178,4 +1183,6 @@\n-     * Based on {@code basePattern} generate new {@code RecordPattern}s such that all\n-     * components instead of {@code replaceComponent}th component, which is replaced\n-     * with values from {@code updatedNestedPatterns}. Resulting {@code RecordPatterns}s\n-     * are sent to {@code target}.\n+     * Using {@code basePattern} as a starting point, generate new {@code\n+     * RecordPattern}s, such that all corresponding components but one, are the\n+     * same. The component described by the {@code replaceComponent} index is\n+     * replaced with all {@code PatternDescription}s taken from {@code\n+     * updatedNestedPatterns} and the resulting {@code RecordPatterns}s are sent\n+     * to {@code target}.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ExhaustivenessComputer.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import com.sun.tools.javac.util.JCDiagnostic.Fragment;\n","filename":"test\/langtools\/tools\/javac\/patterns\/ExhaustivenessConvenientErrors.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}