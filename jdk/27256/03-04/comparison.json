{"files":[{"patch":"@@ -148,1 +148,1 @@\n-            CoverageResult coveredResult = computeCoverage(selector.type, patternSet, false);\n+            CoverageResult coveredResult = computeCoverage(selector.type, patternSet, PatternEquivalence.STRICT);\n@@ -173,1 +173,7 @@\n-    private CoverageResult computeCoverage(Type selectorType, Set<PatternDescription> patterns, boolean search) {\n+    \/* Given the set of patterns, runs the reductions of it as long as possible.\n+     * If the (reduced) set of patterns covers the given selector type, returns\n+     * covered == true, and incompletePatterns == null.\n+     * If the (reduced) set of patterns does not cover the given selector type,\n+     * returns covered == false, and incompletePatterns == the reduced set of patterns.\n+     *\/\n+    private CoverageResult computeCoverage(Type selectorType, Set<PatternDescription> patterns, PatternEquivalence patternEquivalence) {\n@@ -180,1 +186,1 @@\n-            updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes, search);\n+            updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes, patternEquivalence);\n@@ -273,1 +279,1 @@\n-                        Set<Symbol> permitted = allPermittedSubTypes(clazz, isPossibleSubtypePredicate(selectorType));\n+                        Set<Symbol> permitted = allPermittedSubTypes(clazz, isApplicableSubtypePredicate(selectorType));\n@@ -347,1 +353,1 @@\n-    private <C extends TypeSymbol> Predicate<C> isPossibleSubtypePredicate(Type targetType) {\n+    private <C extends TypeSymbol> Predicate<C> isApplicableSubtypePredicate(Type targetType) {\n@@ -423,1 +429,1 @@\n-                                                         boolean search) {\n+                                                         PatternEquivalence patternEquivalence) {\n@@ -475,1 +481,1 @@\n-                                nestedComponentsEquivalent(rpOne, rpOther, mismatchingCandidate, useHashes, search)) {\n+                                nestedComponentsEquivalent(rpOne, rpOther, mismatchingCandidate, useHashes, patternEquivalence)) {\n@@ -481,1 +487,1 @@\n-                        var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes, search);\n+                        var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes, patternEquivalence);\n@@ -518,0 +524,4 @@\n+     * - only if PatternEquivalence is LOOSE and the type is the same of the type\n+     *   of an existing record pattern (the binding pattern may stand in place of\n+     *   a record pattern). This is only used to compute the missing patterns that\n+     *   would make the original pattern set exhaustive.\n@@ -523,1 +533,1 @@\n-                                               boolean search) {\n+                                               PatternEquivalence patternEquivalence) {\n@@ -542,1 +552,1 @@\n-                        if (search) {\n+                        if (patternEquivalence == PatternEquivalence.LOOSE) {\n@@ -836,1 +846,1 @@\n-                \/\/try to replace binding patterns for sealed types with all their immediate permitted types:\n+                \/\/try to replace binding patterns for sealed types with all their immediate permitted applicable types:\n@@ -838,1 +848,1 @@\n-                Set<BindingPattern> viablePermittedPatterns =\n+                Set<PatternDescription> applicableDirectPermittedPatterns =\n@@ -841,1 +851,1 @@\n-                                 .filter(isPossibleSubtypePredicate(targetType))\n+                                 .filter(isApplicableSubtypePredicate(targetType))\n@@ -846,16 +856,2 @@\n-                boolean reduced = false;\n-\n-                for (Iterator<BindingPattern> it = viablePermittedPatterns.iterator(); it.hasNext(); ) {\n-                    BindingPattern current = it.next();\n-                    Set<BindingPattern> reducedPermittedPatterns = new HashSet<>(viablePermittedPatterns);\n-\n-                    reducedPermittedPatterns.remove(current);\n-\n-                    Set<PatternDescription> replaced =\n-                            replace(inMissingPatterns, toExpand, reducedPermittedPatterns);\n-\n-                    if (computeCoverage(selectorType, joinSets(basePatterns, replaced), true).covered()) {\n-                        it.remove();\n-                        reduced = true;\n-                    }\n-                }\n+                boolean reduced =\n+                        removeUnnecessaryPatterns(selectorType, bp, basePatterns, inMissingPatterns, applicableDirectPermittedPatterns);\n@@ -870,1 +866,1 @@\n-                        replace(inMissingPatterns, toExpand, viablePermittedPatterns);\n+                        replace(inMissingPatterns, toExpand, applicableDirectPermittedPatterns);\n@@ -873,1 +869,1 @@\n-                for (PatternDescription viable : viablePermittedPatterns) {\n+                for (PatternDescription viable : applicableDirectPermittedPatterns) {\n@@ -893,1 +889,1 @@\n-                    List<Type> variants;\n+                    List<Type> applicableLeafPermittedSubtypes;\n@@ -896,5 +892,6 @@\n-                        variants = leafPermittedSubTypes(componentType.tsym,\n-                                                         isPossibleSubtypePredicate(componentType))\n-                                .stream()\n-                                .map(csym -> instantiatePatternType(componentType, csym))\n-                                .collect(List.collector());\n+                        applicableLeafPermittedSubtypes =\n+                                leafPermittedSubTypes(componentType.tsym,\n+                                                      isApplicableSubtypePredicate(componentType))\n+                                    .stream()\n+                                    .map(csym -> instantiatePatternType(componentType, csym))\n+                                    .collect(List.collector());\n@@ -902,1 +899,1 @@\n-                        variants = List.of(componentType);\n+                        applicableLeafPermittedSubtypes = List.of(componentType);\n@@ -908,1 +905,1 @@\n-                        for (Type nue : variants) {\n+                        for (Type nue : applicableLeafPermittedSubtypes) {\n@@ -924,6 +921,1 @@\n-                \/\/remove unnecessary:\n-                for (Iterator<PatternDescription> it = combinatorialPatterns.iterator(); it.hasNext(); ) {\n-                    PatternDescription current = it.next();\n-                    Set<PatternDescription> reducedAdded = new HashSet<>(combinatorialPatterns);\n-\n-                    reducedAdded.remove(current);\n+                removeUnnecessaryPatterns(selectorType, bp, basePatterns, inMissingPatterns, combinatorialPatterns);\n@@ -931,9 +923,1 @@\n-                    Set<PatternDescription> combinedPatterns =\n-                            joinSets(basePatterns, replace(inMissingPatterns, bp, reducedAdded));\n-\n-                    if (computeCoverage(selectorType, combinedPatterns, true).covered()) {\n-                        it.remove();\n-                    }\n-                }\n-\n-                CoverageResult coverageResult = computeCoverage(targetType, combinatorialPatterns, true);\n+                CoverageResult coverageResult = computeCoverage(targetType, combinatorialPatterns, PatternEquivalence.LOOSE);\n@@ -948,1 +932,1 @@\n-                \/\/this is particularly for the case where the sealed supertype only has one permitted type, the record\n+                \/\/this is particularly important for the case where the sealed supertype only has one permitted type, the record\n@@ -953,14 +937,1 @@\n-                \/\/remove unnecessary:\n-                OUTER: for (Iterator<PatternDescription> it = sortedCandidates.iterator(); it.hasNext(); ) {\n-                    PatternDescription current = it.next();\n-                    Set<PatternDescription> reducedAdded = new HashSet<>(sortedCandidates);\n-\n-                    reducedAdded.remove(current);\n-\n-                    Set<PatternDescription> combinedPatterns =\n-                            joinSets(basePatterns, replace(inMissingPatterns, bp, reducedAdded));\n-\n-                    if (computeCoverage(selectorType, combinedPatterns, true).covered()) {\n-                        it.remove();\n-                    }\n-                }\n+                removeUnnecessaryPatterns(selectorType, bp, basePatterns, inMissingPatterns, sortedCandidates);\n@@ -1033,0 +1004,29 @@\n+    \/* Out of \"candidates\" remove patterns that are not necessary to achieve exhaustiveness.\n+     * Note that iteration order of \"candidates\" is important - if the set contains\n+     * two pattern, out of which either, but not both, is needed to achieve exhaustiveness,\n+     * the first one in the iteration order will be removed.\n+     *\/\n+    private boolean removeUnnecessaryPatterns(Type selectorType,\n+                                              PatternDescription toExpand,\n+                                              Set<? extends PatternDescription> basePatterns,\n+                                              Set<PatternDescription> inMissingPatterns,\n+                                              Set<PatternDescription> candidates) {\n+        boolean reduced = false;\n+\n+        for (Iterator<PatternDescription> it = candidates.iterator(); it.hasNext(); ) {\n+            PatternDescription current = it.next();\n+            Set<PatternDescription> reducedAdded = new HashSet<>(candidates);\n+\n+            reducedAdded.remove(current);\n+\n+            Set<PatternDescription> combinedPatterns =\n+                    joinSets(basePatterns, replace(inMissingPatterns, toExpand, reducedAdded));\n+\n+            if (computeCoverage(selectorType, combinedPatterns, PatternEquivalence.LOOSE).covered()) {\n+                it.remove();\n+                reduced = true;\n+            }\n+        }\n+\n+        return reduced;\n+    }\n@@ -1196,0 +1196,8 @@\n+    \/* The stricness of determining the equivalent of patterns, used in\n+     * nestedComponentsEquivalent.\n+     *\/\n+    private enum PatternEquivalence {\n+        STRICT,\n+        LOOSE;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ExhaustivenessComputer.java","additions":77,"deletions":69,"binary":false,"changes":146,"status":"modified"}]}