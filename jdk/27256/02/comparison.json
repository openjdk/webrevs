{"files":[{"patch":"@@ -44,0 +44,1 @@\n+import java.util.Collection;\n@@ -45,0 +46,3 @@\n+import java.util.LinkedHashSet;\n+import java.util.SequencedSet;\n+import java.util.function.Consumer;\n@@ -47,0 +51,1 @@\n+import java.util.stream.Stream;\n@@ -49,0 +54,1 @@\n+import static com.sun.tools.javac.code.Flags.RECORD;\n@@ -58,0 +64,2 @@\n+    private static final long DEFAULT_TIMEOUT = 5000; \/\/5s\n+\n@@ -65,0 +73,2 @@\n+    private final long missingExhaustivenessTimeout;\n+    private long startTime = -1;\n@@ -80,0 +90,13 @@\n+        Options options = Options.instance(context);\n+        String timeout = options.get(\"exhaustivityTimeout\");\n+        long computedTimeout = DEFAULT_TIMEOUT;\n+\n+        if (timeout != null) {\n+            try {\n+                computedTimeout = Long.parseLong(timeout);\n+            } catch (NumberFormatException _) {\n+                \/\/ignore invalid values and use the default timeout\n+            }\n+        }\n+\n+        missingExhaustivenessTimeout = computedTimeout;\n@@ -82,1 +105,1 @@\n-    public boolean exhausts(JCExpression selector, List<JCCase> cases) {\n+    public ExhaustivenessResult exhausts(JCExpression selector, List<JCCase> cases) {\n@@ -116,1 +139,1 @@\n-            return true;\n+            return ExhaustivenessResult.ofExhaustive();\n@@ -124,3 +147,0 @@\n-        Set<PatternDescription> patterns = patternSet;\n-        Set<Set<PatternDescription>> seenFallback = new HashSet<>();\n-        boolean useHashes = true;\n@@ -128,27 +148,3 @@\n-            boolean repeat = true;\n-            while (repeat) {\n-                Set<PatternDescription> updatedPatterns;\n-                updatedPatterns = reduceBindingPatterns(selector.type, patterns);\n-                updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n-                updatedPatterns = reduceRecordPatterns(updatedPatterns);\n-                updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n-                repeat = !updatedPatterns.equals(patterns);\n-                if (checkCovered(selector.type, patterns)) {\n-                    return true;\n-                }\n-                if (!repeat) {\n-                    \/\/there may be situation like:\n-                    \/\/class B permits S1, S2\n-                    \/\/patterns: R(S1, B), R(S2, S2)\n-                    \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n-                    \/\/but hashing in reduceNestedPatterns will not allow that\n-                    \/\/disable the use of hashing, and use subtyping in\n-                    \/\/reduceNestedPatterns to handle situations like this:\n-                    repeat = useHashes && seenFallback.add(updatedPatterns);\n-                    useHashes = false;\n-                } else {\n-                    \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n-                    \/\/is enabled, as the hashing speeds up the process significantly:\n-                    useHashes = true;\n-                }\n-                patterns = updatedPatterns;\n+            CoverageResult coveredResult = computeCoverage(selector.type, patternSet, false);\n+            if (coveredResult.covered()) {\n+                return ExhaustivenessResult.ofExhaustive();\n@@ -156,1 +152,15 @@\n-            return checkCovered(selector.type, patterns);\n+\n+            Set<String> details =\n+                    this.computeMissingPatternDescriptions(selector.type, coveredResult.incompletePatterns())\n+                        .stream()\n+                        .flatMap(pd -> {\n+                            if (pd instanceof BindingPattern bp && enum2Constants.containsKey(bp.type.tsym)) {\n+                                Symbol enumType = bp.type.tsym;\n+                                return enum2Constants.get(enumType).stream().map(c -> enumType.toString() + \".\" + c.name);\n+                            } else {\n+                                return Stream.of(pd.toString());\n+                            }\n+                        })\n+                        .collect(Collectors.toSet());\n+\n+            return ExhaustivenessResult.ofDetails(details);\n@@ -159,3 +169,37 @@\n-            return true; \/\/error recovery\n-        } finally {\n-            isSubtypeCache.clear();\n+            return ExhaustivenessResult.ofExhaustive(); \/\/error recovery\n+        }\n+    }\n+\n+    private CoverageResult computeCoverage(Type selectorType, Set<PatternDescription> patterns, boolean search) {\n+        Set<PatternDescription> updatedPatterns;\n+        Set<Set<PatternDescription>> seenPatterns = new HashSet<>();\n+        boolean useHashes = true;\n+        boolean repeat = true;\n+        do {\n+            updatedPatterns = reduceBindingPatterns(selectorType, patterns);\n+            updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes, search);\n+            updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+            updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n+            repeat = !updatedPatterns.equals(patterns);\n+            if (checkCovered(selectorType, patterns)) {\n+                return new CoverageResult(true, null);\n+            }\n+            if (!repeat) {\n+                \/\/there may be situation like:\n+                \/\/class B permits S1, S2\n+                \/\/patterns: R(S1, B), R(S2, S2)\n+                \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n+                \/\/but hashing in reduceNestedPatterns will not allow that\n+                \/\/disable the use of hashing, and use subtyping in\n+                \/\/reduceNestedPatterns to handle situations like this:\n+                repeat = useHashes && seenPatterns.add(updatedPatterns);\n+                useHashes = false;\n+            } else {\n+                \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n+                \/\/is enabled, as the hashing speeds up the process significantly:\n+                useHashes = true;\n+            }\n+            patterns = updatedPatterns;\n+        } while (repeat);\n+        if (checkCovered(selectorType, patterns)) {\n+            return new CoverageResult(true, null);\n@@ -163,0 +207,1 @@\n+        return new CoverageResult(false, patterns);\n@@ -165,0 +210,2 @@\n+    private record CoverageResult(boolean covered, Set<PatternDescription> incompletePatterns) {}\n+\n@@ -218,0 +265,1 @@\n+                        ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n@@ -225,10 +273,2 @@\n-                        Set<Symbol> permitted = allPermittedSubTypes(clazz, csym -> {\n-                            Type instantiated;\n-                            if (csym.type.allparams().isEmpty()) {\n-                                instantiated = csym.type;\n-                            } else {\n-                                instantiated = infer.instantiatePatternType(selectorType, csym);\n-                            }\n-\n-                            return instantiated != null && types.isCastable(selectorType, instantiated);\n-                        });\n+                        Set<Symbol> permitted = allPermittedSubTypes(clazz, isPossibleSubtypePredicate(selectorType));\n+                        int permittedSubtypes = permitted.size();\n@@ -260,1 +300,1 @@\n-                            toAdd.add(new BindingPattern(clazz.type));\n+                            toAdd.add(new BindingPattern(clazz.type, permittedSubtypes, Set.of()));\n@@ -301,0 +341,43 @@\n+    private <C extends TypeSymbol> Predicate<C> isPossibleSubtypePredicate(Type targetType) {\n+        return csym -> {\n+            Type instantiated = instantiatePatternType(targetType, csym);\n+\n+            return instantiated != null && types.isCastable(targetType, instantiated);\n+        };\n+    }\n+\n+    private Type instantiatePatternType(Type targetType, TypeSymbol csym) {\n+        if (csym.type.allparams().isEmpty()) {\n+            return csym.type;\n+        } else {\n+            return infer.instantiatePatternType(targetType, csym);\n+        }\n+    }\n+\n+    private Set<ClassSymbol> leafPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n+        Set<ClassSymbol> permitted = new HashSet<>();\n+        List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n+\n+        while (permittedSubtypesClosure.nonEmpty()) {\n+            ClassSymbol current = permittedSubtypesClosure.head;\n+\n+            permittedSubtypesClosure = permittedSubtypesClosure.tail;\n+\n+            current.complete();\n+\n+            if (current.isSealed() && current.isAbstract()) {\n+                for (Type t : current.getPermittedSubclasses()) {\n+                    ClassSymbol csym = (ClassSymbol) t.tsym;\n+\n+                    if (accept.test(csym)) {\n+                        permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n+                    }\n+                }\n+            } else {\n+                permitted.add(current);\n+            }\n+        }\n+\n+        return permitted;\n+    }\n+\n@@ -333,1 +416,2 @@\n-                                                         boolean useHashes) {\n+                                                         boolean useHashes,\n+                                                         boolean search) {\n@@ -365,0 +449,2 @@\n+                    checkTimeout();\n+\n@@ -383,1 +469,1 @@\n-                                nestedComponentsEquivalent(rpOne, rpOther, mismatchingCandidate, useHashes)) {\n+                                nestedComponentsEquivalent(rpOne, rpOther, mismatchingCandidate, useHashes, search)) {\n@@ -389,1 +475,1 @@\n-                        var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n+                        var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes, search);\n@@ -400,10 +486,5 @@\n-                            for (PatternDescription nested : updatedPatterns) {\n-                                PatternDescription[] newNested =\n-                                        Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                                newNested[mismatchingCandidateFin] = nested;\n-                                RecordPattern nue = new RecordPattern(rpOne.recordType(),\n-                                                                rpOne.fullComponentTypes(),\n-                                                                newNested,\n-                                                                new HashSet<>(join));\n-                                current.add(nue);\n-                            }\n+                            generatePatternsWithReplacedNestedPattern(rpOne,\n+                                                                      mismatchingCandidateFin,\n+                                                                      updatedPatterns,\n+                                                                      Set.copyOf(join),\n+                                                                      current::add);\n@@ -435,1 +516,2 @@\n-                                               boolean useHashes) {\n+                                               boolean useHashes,\n+                                               boolean search) {\n@@ -454,2 +536,7 @@\n-                        java.util.List<PatternDescription> pendingReplacedPatterns =\n-                                new ArrayList<>(nestedCandidate.sourcePatterns());\n+                        if (search) {\n+                            if (!types.isSubtype(types.erasure(nestedExisting.recordType()), types.erasure(nestedCandidate.type))) {\n+                                return false;\n+                            }\n+                        } else {\n+                            java.util.List<PatternDescription> pendingReplacedPatterns =\n+                                    new ArrayList<>(nestedCandidate.sourcePatterns());\n@@ -457,2 +544,2 @@\n-                        while (!pendingReplacedPatterns.isEmpty()) {\n-                            PatternDescription currentReplaced = pendingReplacedPatterns.removeLast();\n+                            while (!pendingReplacedPatterns.isEmpty()) {\n+                                PatternDescription currentReplaced = pendingReplacedPatterns.removeLast();\n@@ -460,4 +547,7 @@\n-                            if (nestedExisting.equals(currentReplaced)) {\n-                                \/\/candidate.nested[i] is substitutable for existing.nested[i]\n-                                \/\/continue with the next nested pattern:\n-                                continue NEXT_NESTED;\n+                                if (nestedExisting.equals(currentReplaced)) {\n+                                    \/\/candidate.nested[i] is substitutable for existing.nested[i]\n+                                    \/\/continue with the next nested pattern:\n+                                    continue NEXT_NESTED;\n+                                }\n+\n+                                pendingReplacedPatterns.addAll(currentReplaced.sourcePatterns());\n@@ -466,1 +556,1 @@\n-                            pendingReplacedPatterns.addAll(currentReplaced.sourcePatterns());\n+                            return false;\n@@ -468,2 +558,0 @@\n-\n-                        return false;\n@@ -532,1 +620,1 @@\n-                PatternDescription pd = new BindingPattern(rpOne.recordType, Set.of(pattern));\n+                PatternDescription pd = new BindingPattern(rpOne.recordType, -1, Set.of(pattern));\n@@ -560,0 +648,2 @@\n+        checkTimeout();\n+\n@@ -571,1 +661,9 @@\n-    sealed interface PatternDescription {\n+    protected void checkTimeout() {\n+        if (startTime != (-1) &&\n+            (System.currentTimeMillis() - startTime) > missingExhaustivenessTimeout) {\n+            throw new TimeoutException(null);\n+        }\n+    }\n+\n+    protected sealed interface PatternDescription {\n+        public Type type();\n@@ -574,0 +672,1 @@\n+\n@@ -608,1 +707,1 @@\n-    record BindingPattern(Type type, Set<PatternDescription> sourcePatterns) implements PatternDescription {\n+    record BindingPattern(Type type, int permittedSubtypes, Set<PatternDescription> sourcePatterns) implements PatternDescription {\n@@ -611,1 +710,1 @@\n-            this(type, Set.of());\n+            this(type, -1, Set.of());\n@@ -670,0 +769,429 @@\n+\n+        @Override\n+        public Type type() {\n+            return recordType;\n+        }\n+    }\n+\n+    public record ExhaustivenessResult(boolean exhaustive, Set<String> notExhaustiveDetails) {\n+        public static ExhaustivenessResult ofExhaustive() {\n+            return new ExhaustivenessResult(true, null);\n+        }\n+        public static ExhaustivenessResult ofDetails(Set<String> notExhaustiveDetails) {\n+            return new ExhaustivenessResult(false, notExhaustiveDetails != null ? notExhaustiveDetails : Set.of());\n+        }\n+    }\n+\n+    \/\/computation of missing patterns:\n+    protected Set<PatternDescription> computeMissingPatternDescriptions(Type selectorType,\n+                                                                        Set<PatternDescription> incompletePatterns) {\n+        if (missingExhaustivenessTimeout == 0) {\n+            return Set.of();\n+        }\n+        try {\n+            startTime = System.currentTimeMillis();\n+            PatternDescription defaultPattern = new BindingPattern(selectorType);\n+            return expandMissingPatternDescriptions(selectorType,\n+                                                    selectorType,\n+                                                    defaultPattern,\n+                                                    incompletePatterns,\n+                                                    Set.of(defaultPattern));\n+        } catch (TimeoutException ex) {\n+            return ex.missingPatterns != null ? ex.missingPatterns : Set.of();\n+        } finally {\n+            startTime = -1;\n+        }\n+    }\n+\n+    private Set<PatternDescription> expandMissingPatternDescriptions(Type selectorType,\n+                                                                     Type targetType,\n+                                                                     PatternDescription toExpand,\n+                                                                     Set<? extends PatternDescription> basePatterns,\n+                                                                     Set<PatternDescription> inMissingPatterns) {\n+        try {\n+            return doExpandMissingPatternDescriptions(selectorType, targetType,\n+                                                      toExpand, basePatterns,\n+                                                      inMissingPatterns);\n+        } catch (TimeoutException ex) {\n+            if (ex.missingPatterns == null) {\n+                ex = new TimeoutException(inMissingPatterns);\n+            }\n+            throw ex;\n+        }\n+    }\n+\n+    private Set<PatternDescription> doExpandMissingPatternDescriptions(Type selectorType,\n+                                                                       Type targetType,\n+                                                                       PatternDescription toExpand,\n+                                                                       Set<? extends PatternDescription> basePatterns,\n+                                                                       Set<PatternDescription> inMissingPatterns) {\n+        if (toExpand instanceof BindingPattern bp) {\n+            if (bp.type.tsym.isSealed()) {\n+                \/\/try to replace binding patterns for sealed types with all their immediate permitted types:\n+                List<Type> permitted = ((ClassSymbol) bp.type.tsym).getPermittedSubclasses();\n+                Set<BindingPattern> viablePermittedPatterns =\n+                        permitted.stream()\n+                                 .map(type -> type.tsym)\n+                                 .filter(isPossibleSubtypePredicate(targetType))\n+                                 .map(csym -> new BindingPattern(types.erasure(csym.type)))\n+                                 .collect(Collectors.toCollection(HashSet::new));\n+\n+                \/\/remove the permitted subtypes that are not needed to achieve exhaustivity\n+                boolean reduced = false;\n+\n+                for (Iterator<BindingPattern> it = viablePermittedPatterns.iterator(); it.hasNext(); ) {\n+                    BindingPattern current = it.next();\n+                    Set<BindingPattern> reducedPermittedPatterns = new HashSet<>(viablePermittedPatterns);\n+\n+                    reducedPermittedPatterns.remove(current);\n+\n+                    Set<PatternDescription> replaced =\n+                            replace(inMissingPatterns, toExpand, reducedPermittedPatterns);\n+\n+                    if (computeCoverage(selectorType, joinSets(basePatterns, replaced), true).covered()) {\n+                        it.remove();\n+                        reduced = true;\n+                    }\n+                }\n+\n+                if (!reduced) {\n+                    \/\/if all immediate permitted subtypes are needed\n+                    \/\/give up, and simply use the current pattern:\n+                    return inMissingPatterns;\n+                }\n+\n+                Set<PatternDescription> currentMissingPatterns =\n+                        replace(inMissingPatterns, toExpand, viablePermittedPatterns);\n+\n+                \/\/try to recursively expand on each viable pattern:\n+                for (PatternDescription viable : viablePermittedPatterns) {\n+                    currentMissingPatterns = expandMissingPatternDescriptions(selectorType, targetType,\n+                                                                              viable, basePatterns,\n+                                                                              currentMissingPatterns);\n+                }\n+\n+                return currentMissingPatterns;\n+            } else if ((bp.type.tsym.flags_field & Flags.RECORD) != 0 &&\n+                       \/\/only expand record types into record patterns if there's a chance it may change the outcome\n+                       \/\/i.e. there is a record pattern in at the spot in the original base patterns:\n+                       hasMatchingRecordPattern(basePatterns, inMissingPatterns, toExpand)) {\n+                \/\/if there is a binding pattern at a place where the original based patterns\n+                \/\/have a record pattern, try to expand the binding pattern into a record pattern\n+                \/\/create all possible combinations of record pattern components:\n+                Type[] componentTypes = ((ClassSymbol) bp.type.tsym).getRecordComponents()\n+                        .map(r -> types.memberType(bp.type, r))\n+                        .toArray(s -> new Type[s]);\n+                List<List<Type>> combinatorialNestedTypes = List.of(List.nil());\n+\n+                for (Type componentType : componentTypes) {\n+                    List<Type> variants;\n+\n+                    if (componentType.tsym.isSealed()) {\n+                        variants = leafPermittedSubTypes(componentType.tsym,\n+                                                         isPossibleSubtypePredicate(componentType))\n+                                .stream()\n+                                .map(csym -> instantiatePatternType(componentType, csym))\n+                                .collect(List.collector());\n+                    } else {\n+                        variants = List.of(componentType);\n+                    }\n+\n+                    List<List<Type>> newCombinatorialNestedTypes = List.nil();\n+\n+                    for (List<Type> existing : combinatorialNestedTypes) {\n+                        for (Type nue : variants) {\n+                            newCombinatorialNestedTypes = newCombinatorialNestedTypes.prepend(existing.append(nue));\n+                        }\n+                    }\n+\n+                    combinatorialNestedTypes = newCombinatorialNestedTypes;\n+                }\n+\n+                Set<PatternDescription> combinatorialPatterns =\n+                        combinatorialNestedTypes.stream()\n+                                                .map(combination -> new RecordPattern(bp.type,\n+                                                                                      componentTypes,\n+                                                                                      combination.map(BindingPattern::new)\n+                                                                                                 .toArray(PatternDescription[]::new)))\n+                                                .collect(Collectors.toCollection(HashSet::new));\n+\n+                \/\/remove unnecessary:\n+                for (Iterator<PatternDescription> it = combinatorialPatterns.iterator(); it.hasNext(); ) {\n+                    PatternDescription current = it.next();\n+                    Set<PatternDescription> reducedAdded = new HashSet<>(combinatorialPatterns);\n+\n+                    reducedAdded.remove(current);\n+\n+                    Set<PatternDescription> combinedPatterns =\n+                            joinSets(basePatterns, replace(inMissingPatterns, bp, reducedAdded));\n+\n+                    if (computeCoverage(selectorType, combinedPatterns, true).covered()) {\n+                        it.remove();\n+                    }\n+                }\n+\n+                CoverageResult coverageResult = computeCoverage(targetType, combinatorialPatterns, true);\n+\n+                if (!coverageResult.covered()) {\n+                    \/\/use the partially merged\/combined patterns:\n+                    combinatorialPatterns = coverageResult.incompletePatterns();\n+                }\n+\n+                \/\/combine sealed subtypes into the supertype, if all is covered.\n+                \/\/but preserve more specific record types in positions where there are record patterns in the original patterns\n+                \/\/this is particularly for the case where the sealed supertype only has one permitted type, the record\n+                \/\/the base type could be used instead of the record otherwise, which would produce less specific missing pattern:\n+                Set<PatternDescription> sortedCandidates =\n+                        partialSortPattern(combinatorialPatterns, basePatterns, combinatorialPatterns);\n+\n+                \/\/remove unnecessary:\n+                OUTER: for (Iterator<PatternDescription> it = sortedCandidates.iterator(); it.hasNext(); ) {\n+                    PatternDescription current = it.next();\n+                    Set<PatternDescription> reducedAdded = new HashSet<>(sortedCandidates);\n+\n+                    reducedAdded.remove(current);\n+\n+                    Set<PatternDescription> combinedPatterns =\n+                            joinSets(basePatterns, replace(inMissingPatterns, bp, reducedAdded));\n+\n+                    if (computeCoverage(selectorType, combinedPatterns, true).covered()) {\n+                        it.remove();\n+                    }\n+                }\n+\n+                Set<PatternDescription> currentMissingPatterns =\n+                        replace(inMissingPatterns, toExpand, sortedCandidates);\n+\n+                for (PatternDescription addedPattern : sortedCandidates) {\n+                    if (addedPattern instanceof RecordPattern addedRP) {\n+                        for (int c = 0; c < addedRP.nested.length; c++) {\n+                            currentMissingPatterns = expandMissingPatternDescriptions(selectorType,\n+                                                                                      addedRP.fullComponentTypes[c],\n+                                                                                      addedRP.nested[c],\n+                                                                                      basePatterns,\n+                                                                                      currentMissingPatterns);\n+                        }\n+                    }\n+                }\n+\n+                return currentMissingPatterns;\n+            }\n+        }\n+        return inMissingPatterns;\n+    }\n+\n+    \/*\n+     * Inside any pattern in {@code in}, in any nesting depth, replace\n+     * pattern {@code what} with patterns {@code to}.\n+     *\/\n+    private Set<PatternDescription> replace(Iterable<? extends PatternDescription> in,\n+                                            PatternDescription what,\n+                                            Collection<? extends PatternDescription> to) {\n+        Set<PatternDescription> result = new HashSet<>();\n+\n+        for (PatternDescription pd : in) {\n+            Collection<? extends PatternDescription> replaced = replace(pd, what, to);\n+            if (replaced != null) {\n+                result.addAll(replaced);\n+            } else {\n+                result.add(pd);\n+            }\n+        }\n+\n+        return result;\n+    }\n+    \/\/where:\n+        \/\/null: no change\n+        private Collection<? extends PatternDescription> replace(PatternDescription in,\n+                                                                 PatternDescription what,\n+                                                                 Collection<? extends PatternDescription> to) {\n+            if (in == what) {\n+                return to;\n+            } else if (in instanceof RecordPattern rp) {\n+                for (int c = 0; c < rp.nested.length; c++) {\n+                    Collection<? extends PatternDescription> replaced = replace(rp.nested[c], what, to);\n+                    if (replaced != null) {\n+                        Set<PatternDescription> withReplaced = new HashSet<>();\n+\n+                        generatePatternsWithReplacedNestedPattern(rp, c, replaced, Set.of(), withReplaced::add);\n+\n+                        return replace(withReplaced, what, to);\n+                    }\n+                }\n+                return null;\n+            } else {\n+                return null; \/\/binding patterns have no children\n+            }\n+        }\n+\n+    \/*\n+     * Sort patterns so that those that those that are prefered for removal\n+     * are in front of those that are preferred to remain (when there's a choice).\n+     *\/\n+    private SequencedSet<PatternDescription> partialSortPattern(Set<PatternDescription> candidates,\n+                                                                Set<? extends PatternDescription> basePatterns,\n+                                                                Set<PatternDescription> missingPatterns) {\n+        SequencedSet<PatternDescription> sortedCandidates = new LinkedHashSet<>();\n+\n+        while (!candidates.isEmpty()) {\n+            PatternDescription mostSpecific = null;\n+            for (PatternDescription current : candidates) {\n+                if (mostSpecific == null ||\n+                    shouldAppearBefore(current, mostSpecific, basePatterns, missingPatterns)) {\n+                    mostSpecific = current;\n+                }\n+            }\n+            sortedCandidates.add(mostSpecific);\n+            candidates.remove(mostSpecific);\n+        }\n+        return sortedCandidates;\n+    }\n+    \/\/where:\n+        \/\/true iff pd1 should appear before pd2\n+        \/\/false otherwise\n+        private boolean shouldAppearBefore(PatternDescription pd1,\n+                                           PatternDescription pd2,\n+                                           Set<? extends PatternDescription> basePatterns,\n+                                           Set<? extends PatternDescription> missingPatterns) {\n+            if (pd1 instanceof RecordPattern rp1 && pd2 instanceof RecordPattern rp2) {\n+                for (int c = 0; c < rp1.nested.length; c++) {\n+                    if (shouldAppearBefore((BindingPattern) rp1.nested[c],\n+                                           (BindingPattern) rp2.nested[c],\n+                                           basePatterns,\n+                                           missingPatterns)) {\n+                        return true;\n+                    }\n+                }\n+            } else if (pd1 instanceof BindingPattern bp1 && pd2 instanceof BindingPattern bp2) {\n+                Type t1 = bp1.type();\n+                Type t2 = bp2.type();\n+                boolean t1IsImportantRecord =\n+                        (t1.tsym.flags_field & RECORD) != 0 &&\n+                        hasMatchingRecordPattern(basePatterns, missingPatterns, bp1);\n+                boolean t2IsImportantRecord =\n+                        (t2.tsym.flags_field & RECORD) != 0 &&\n+                        hasMatchingRecordPattern(basePatterns, missingPatterns, bp2);\n+                if (t1IsImportantRecord && !t2IsImportantRecord) {\n+                    return false;\n+                }\n+                if (!t1IsImportantRecord && t2IsImportantRecord) {\n+                    return true;\n+                }\n+                if (!types.isSameType(t1, t2) && types.isSubtype(t1, t2)) {\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+    \/*\n+     * Do the {@code basePatterns} have a record pattern at a place that corresponds to\n+     * position of pattern {@code query} inside {@code missingPatterns}?\n+     *\/\n+    private boolean hasMatchingRecordPattern(Set<? extends PatternDescription> basePatterns,\n+                                             Set<? extends PatternDescription> missingPatterns,\n+                                             PatternDescription query) {\n+        PatternDescription root = findRootContaining(missingPatterns, query);\n+\n+        if (root == null) {\n+            return false;\n+        }\n+        return basePatternsHaveRecordPatternOnThisSpot(basePatterns, root, query);\n+    }\n+    \/\/where:\n+        private PatternDescription findRootContaining(Set<? extends PatternDescription> rootPatterns,\n+                                                      PatternDescription added) {\n+            for (PatternDescription pd : rootPatterns) {\n+                if (isUnderRoot(pd, added)) {\n+                    return pd;\n+                }\n+            }\n+\n+            \/\/assert?\n+            return null;\n+        }\n+\n+        private boolean basePatternsHaveRecordPatternOnThisSpot(Set<? extends PatternDescription> basePatterns,\n+                                                                PatternDescription rootPattern,\n+                                                                PatternDescription added) {\n+            if (rootPattern == added) {\n+                return basePatterns.stream().anyMatch(pd -> pd instanceof RecordPattern);\n+            }\n+            if (!(rootPattern instanceof RecordPattern rootPatternRecord)) {\n+                return false;\n+            }\n+            int index = -1;\n+            for (int c = 0; c < rootPatternRecord.nested.length; c++) {\n+                if (isUnderRoot(rootPatternRecord.nested[c], added)) {\n+                    index = c;\n+                    break;\n+                }\n+            }\n+            Assert.check(index != (-1));\n+\n+            int indexFin = index;\n+            Set<PatternDescription> filteredBasePatterns =\n+                    basePatterns.stream()\n+                                .filter(pd -> pd instanceof RecordPattern)\n+                                .map(rp -> (RecordPattern) rp)\n+                                .filter(rp -> types.isSameType(rp.recordType(), rootPatternRecord.recordType()))\n+                                .map(rp -> rp.nested[indexFin])\n+                                .collect(Collectors.toSet());\n+\n+            return basePatternsHaveRecordPatternOnThisSpot(filteredBasePatterns, rootPatternRecord.nested[index], added);\n+        }\n+\n+        private boolean isUnderRoot(PatternDescription root, PatternDescription searchFor) {\n+            if (root == searchFor) {\n+                return true;\n+            } else if (root instanceof RecordPattern rp) {\n+                for (int c = 0; c < rp.nested.length; c++) {\n+                    if (isUnderRoot(rp.nested[c], searchFor)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+    private Set<PatternDescription> joinSets(Collection<? extends PatternDescription> s1,\n+                                             Collection<? extends PatternDescription> s2) {\n+        Set<PatternDescription> result = new HashSet<>();\n+\n+        result.addAll(s1);\n+        result.addAll(s2);\n+\n+        return result;\n+    }\n+\n+    \/*\n+     * Based on {@code basePattern} generate new {@code RecordPattern}s such that all\n+     * components instead of {@code replaceComponent}th component, which is replaced\n+     * with values from {@code updatedNestedPatterns}. Resulting {@code RecordPatterns}s\n+     * are sent to {@code target}.\n+     *\/\n+    private void generatePatternsWithReplacedNestedPattern(RecordPattern basePattern,\n+                                                           int replaceComponent,\n+                                                           Iterable<? extends PatternDescription> updatedNestedPatterns,\n+                                                           Set<PatternDescription> sourcePatterns,\n+                                                           Consumer<RecordPattern> target) {\n+        for (PatternDescription nested : updatedNestedPatterns) {\n+            PatternDescription[] newNested =\n+                    Arrays.copyOf(basePattern.nested, basePattern.nested.length);\n+            newNested[replaceComponent] = nested;\n+            target.accept(new RecordPattern(basePattern.recordType(),\n+                                            basePattern.fullComponentTypes(),\n+                                            newNested,\n+                                            sourcePatterns));\n+        }\n+    }\n+\n+    protected static class TimeoutException extends RuntimeException {\n+        private static final long serialVersionUID = 0L;\n+        private transient final Set<PatternDescription> missingPatterns;\n+\n+        public TimeoutException(Set<PatternDescription> missingPatterns) {\n+            super(null, null, false, false);\n+            this.missingPatterns = missingPatterns;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ExhaustivenessComputer.java","additions":604,"deletions":76,"binary":false,"changes":680,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import com.sun.tools.javac.comp.ExhaustivenessComputer.ExhaustivenessResult;\n@@ -699,1 +700,0 @@\n-                tree.isExhaustive |= exhaustiveness.exhausts(tree.selector, tree.cases);\n@@ -701,1 +701,13 @@\n-                    log.error(tree, Errors.NotExhaustiveStatement);\n+                    ExhaustivenessResult exhaustivenessResult = exhaustiveness.exhausts(tree.selector, tree.cases);\n+\n+                    tree.isExhaustive = exhaustivenessResult.exhaustive();\n+\n+                    if (!tree.isExhaustive) {\n+                        if (exhaustivenessResult.notExhaustiveDetails().isEmpty()) {\n+                            log.error(tree, Errors.NotExhaustiveStatement);\n+                        } else {\n+                            List<JCDiagnostic> details =\n+                                    convertNotExhaustiveDetails(exhaustivenessResult);\n+                            log.error(tree, Errors.NotExhaustiveStatementDetails(details));\n+                        }\n+                    }\n@@ -738,2 +750,3 @@\n-                tree.isExhaustive = exhaustiveness.exhausts(tree.selector, tree.cases);\n-            }\n+                ExhaustivenessResult exhaustivenessResult = exhaustiveness.exhausts(tree.selector, tree.cases);\n+\n+                tree.isExhaustive = exhaustivenessResult.exhaustive();\n@@ -741,2 +754,9 @@\n-            if (!tree.isExhaustive) {\n-                log.error(tree, Errors.NotExhaustive);\n+                if (!tree.isExhaustive) {\n+                    if (exhaustivenessResult.notExhaustiveDetails().isEmpty()) {\n+                        log.error(tree, Errors.NotExhaustive);\n+                    } else {\n+                        List<JCDiagnostic> details =\n+                                convertNotExhaustiveDetails(exhaustivenessResult);\n+                        log.error(tree, Errors.NotExhaustiveDetails(details));\n+                    }\n+                }\n@@ -744,0 +764,1 @@\n+\n@@ -748,0 +769,8 @@\n+        private List<JCDiagnostic> convertNotExhaustiveDetails(ExhaustivenessResult exhaustivenessResult) {\n+            return exhaustivenessResult.notExhaustiveDetails()\n+                                       .stream()\n+                                       .sorted()\n+                                       .map(detail -> diags.fragment(Fragments.NotExhaustiveDetail(detail)))\n+                                       .collect(List.collector());\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1476,0 +1476,14 @@\n+# 0: list of diagnostic\n+compiler.err.not.exhaustive.details=\\\n+    the switch expression does not cover all possible input values\\n\\\n+    missing patterns: {0}\n+\n+# 0: list of diagnostic\n+compiler.err.not.exhaustive.statement.details=\\\n+    the switch statement does not cover all possible input values\\n\\\n+    missing patterns: {0}\n+\n+# 0: string\n+compiler.misc.not.exhaustive.detail=\\\n+    \\n{0}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -605,3 +605,7 @@\n-            for (Object o: d.getArgs()) {\n-                if (o instanceof JCDiagnostic) {\n-                    scanForKeys((JCDiagnostic) o, keys);\n+            List<Object> todoArgs = new ArrayList<>(Arrays.asList(d.getArgs()));\n+            while (!todoArgs.isEmpty()) {\n+                Object o = todoArgs.removeLast();\n+                if (o instanceof JCDiagnostic sd) {\n+                    scanForKeys(sd, keys);\n+                } else if (o instanceof List l) {\n+                    todoArgs.addAll(l);\n","filename":"test\/langtools\/tools\/javac\/diags\/Example.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\/\/ options: -XDexhaustivityTimeout=0\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustive.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.not.exhaustive.details\n+\/\/ key: compiler.misc.not.exhaustive.detail\n+\/\/ options: -XDexhaustivityTimeout=-1\n+\n+class NotExhaustiveDetails {\n+    int t(int i) {\n+        return switch (i) {\n+            case 0 -> -1;\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveDetails.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\/\/ options: -XDexhaustivityTimeout=0\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveStatement.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.not.exhaustive.statement.details\n+\/\/ key: compiler.misc.not.exhaustive.detail\n+\/\/ options: -XDexhaustivityTimeout=-1\n+\n+class NotExhaustiveDetails {\n+    void t(Object o) {\n+        switch (o) {\n+            case String s -> System.err.println(\"String of length: \" + s.length());\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveStatementDetails.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -2396,0 +2396,1 @@\n+                             \"-XDexhaustivityTimeout=0\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,541 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8367530\n+ * @summary Check enhanced exhaustiveness errors\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ExhaustivenessConvenientErrors\n+*\/\n+\n+import com.sun.tools.javac.api.ClientCodeWrapper.DiagnosticSourceUnwrapper;\n+import com.sun.tools.javac.util.JCDiagnostic;\n+import com.sun.tools.javac.util.JCDiagnostic.Fragment;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class ExhaustivenessConvenientErrors extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new ExhaustivenessConvenientErrors().runTests();\n+    }\n+\n+    ExhaustivenessConvenientErrors() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testExhaustiveSealedClasses(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"lib.B _\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveSealedClassesTransitive(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S1 permits S2, A {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public sealed interface S2 extends S1 permits S3, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public sealed interface S3 extends S2 permits C, D {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S1 {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S2 {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class C implements S3 {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class D implements S3 {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S1 obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case B a -> 0;\n+                           case D a -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"lib.C _\");\n+    }\n+\n+    @Test\n+    public void testTrivialRecord(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record R(S s) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"lib.R(lib.B _)\");\n+    }\n+\n+    @Test\n+    public void testNonNestedRecord(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record R(S s1, S s2) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, B b) -> 0;\n+                           case R(B b, A a) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"lib.R(lib.A _, lib.A _)\",\n+               \"lib.R(lib.B _, lib.B _)\");\n+    }\n+\n+    @Test\n+    public void testComplex1(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2() implements Base {}\n+                   record R3(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\",\n+               \"test.Test.Root(test.Test.R2 _, test.Test.Base _, test.Test.Base _)\",\n+               \"test.Test.Root(test.Test.R3 _, test.Test.Base _, test.Test.Base _)\");\n+    }\n+\n+    @Test\n+    public void testComplex2(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+\/\/                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\",\n+               \"test.Test.Root(test.Test.R2 _, test.Test.R2(test.Test.R2 _, test.Test.R2 _), test.Test.R2(test.Test.R2 _, test.Test.R2 _))\");\n+    }\n+\n+    @Test\n+    public void testComplex3(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Triple p) {\n+                       return switch (p) {\n+                           case Triple(B _, _, _) -> 0;\n+                           case Triple(_, A _, _) -> 0;\n+                           case Triple(_, _, A _) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseA _), _) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseB _), C(Underneath _, NestedBaseA _)) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseB _), C(Underneath _, NestedBaseB _)) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseB _), C(Underneath _, NestedBaseC _)) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseC _), C(Underneath _, NestedBaseA _)) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseC _), C(Underneath _, NestedBaseB _)) -> 0;\n+\/\/                           case Path(A p, C(Nested _, NestedBaseC _), C(Underneath _, NestedBaseC _)) -> 0;\n+                       };\n+                   }\n+                   record Triple(Base c1, Base c2, Base c3) {}\n+                   sealed interface Base permits A, B {}\n+                   record A(boolean key) implements Base {\n+                   }\n+                   sealed interface B extends Base {}\n+                   record C(Nested n, NestedBase b) implements B {}\n+                   record Nested() {}\n+                   sealed interface NestedBase {}\n+                   record NestedBaseA() implements NestedBase {}\n+                   record NestedBaseB() implements NestedBase {}\n+                   record NestedBaseC() implements NestedBase {}\n+               }\n+               \"\"\",\n+               \"test.Test.Triple(test.Test.A _, test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _), test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _))\");\n+    }\n+\n+    @Test\n+    public void testComplex4(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+\/\/                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+\/\/                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\",\n+               \"test.Test.Root(test.Test.R2 _, test.Test.R2(test.Test.Base _, test.Test.R2 _), test.Test.R2(test.Test.R2 _, test.Test.Base _))\");\n+               \/\/ideally, the result would be as follow, but it is difficult to split Base on two distinct places:\n+\/\/               \"test.Test.Root(test.Test.R2 _, test.Test.R2(test.Test.R1 _, test.Test.R2 _), test.Test.R2(test.Test.R2 _, test.Test.R1 _))\",\n+\/\/               \"test.Test.Root(test.Test.R2 _, test.Test.R2(test.Test.R2 _, test.Test.R2 _), test.Test.R2(test.Test.R2 _, test.Test.R2 _))\");\n+    }\n+\n+    @Test\n+    public void testComplex5(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Triple p) {\n+                       return switch (p) {\n+                           case Triple(B _, _, _) -> 0;\n+                           case Triple(_, A _, _) -> 0;\n+                           case Triple(_, _, A _) -> 0;\n+\/\/                           case Triple(A _, C(Nested _, NestedBaseA _), _) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseB _), C(Nested _, NestedBaseA _)) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseB _), C(Nested _, NestedBaseB _)) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseB _), C(Nested _, NestedBaseC _)) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseC _), C(Nested _, NestedBaseA _)) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseC _), C(Nested _, NestedBaseB _)) -> 0;\n+\/\/                           case Path(A _, C(Nested _, NestedBaseC _), C(Nested _, NestedBaseC _)) -> 0;\n+                       };\n+                   }\n+                   record Triple(Base c1, Base c2, Base c3) {}\n+                   sealed interface Base permits A, B {}\n+                   record A(boolean key) implements Base {\n+                   }\n+                   sealed interface B extends Base {}\n+                   record C(Nested n, NestedBase b) implements B {}\n+                   record Nested() {}\n+                   sealed interface NestedBase {}\n+                   record NestedBaseA() implements NestedBase {}\n+                   record NestedBaseB() implements NestedBase {}\n+                   record NestedBaseC() implements NestedBase {}\n+               }\n+               \"\"\",\n+               \"test.Test.Triple(test.Test.A _, test.Test.C(test.Test.Nested _, test.Test.NestedBaseA _), test.Test.C _)\",\n+               \/\/the following could be:\n+               \/\/test.Test.Triple(test.Test.A _, test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _), test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _))\n+               \"test.Test.Triple(test.Test.A _, test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _), test.Test.C _)\");\n+    }\n+\n+    @Test\n+    public void testNoInfiniteRecursion(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(_, _, R(_, _, _, _), String s) -> 0;\n+                           case R(_, _, R(_, _, _, String str), _) -> 0;\n+                       };\n+                   }\n+               }\n+               public record R(R r1, R r2, R r3, Object o) {}\n+               \"\"\",\n+               \"test.R(test.R _, test.R _, test.R(test.R _, test.R _, test.R _, java.lang.Object _), java.lang.Object _)\");\n+    }\n+\n+    @Test\n+    public void testEnum(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(I i) {\n+                       return switch (i) {\n+                           case E.A -> 0;\n+                           case C _ -> 1;\n+                       };\n+                   }\n+                   sealed interface I {}\n+                   enum E implements I {A, B}\n+                   final class C implements I {}\n+               }\n+               public record R(R r1, R r2, R r3, Object o) {}\n+               \"\"\",\n+               \"test.Test.E.B\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(I i) {\n+                       return switch (i) {\n+                           case C _ -> 1;\n+                       };\n+                   }\n+                   sealed interface I {}\n+                   enum E implements I {A, B}\n+                   final class C implements I {}\n+               }\n+               public record R(R r1, R r2, R r3, Object o) {}\n+               \"\"\",\n+               \"test.Test.E _\");\n+    }\n+\n+    @Test\n+    public void testInstantiateComponentTypes(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Pair<Base<Base>> p) {\n+                       return switch (p) {\n+                           case Pair(A(A(_)) -> 0;\n+                           case Pair(A(B(_)) -> 0;\n+                           case Pair(B(A(_)) -> 0;\n+                       };\n+                   }\n+                   record Pair<T>(T c) {}\n+                   sealed interface Base<T> permits A, B {}\n+                   record A<T>(T c) implements Base<T> {}\n+                   record B<T>(T c) implements Base<T> {}\n+               }\n+               \"\"\",\n+               \"test.Test.Pair(test.Test.B(test.Test.B _))\");\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode, String... expectedMissingPatterns) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        if (libraryCode.length != 0) {\n+            Path libSrc = current.resolve(\"lib-src\");\n+\n+            for (String code : libraryCode) {\n+                tb.writeJavaFiles(libSrc, code);\n+            }\n+\n+            new JavacTask(tb)\n+                    .outdir(libClasses)\n+                    .files(tb.findJavaFiles(libSrc))\n+                    .run();\n+        }\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src, testCode);\n+\n+        Path classes = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+        Set<String> missingPatterns = new HashSet<>();\n+\n+        new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"-XDdev\",\n+                     \"-Xlint:-preview\",\n+                     \"--class-path\", libClasses.toString(),\n+                     \"-XDshould-stop.at=FLOW\",\n+                     \"-XDshould-stop.ifNoError=FLOW\",\n+                     \"-XDexhaustivityTimeout=\" + Long.MAX_VALUE) \/\/never timeout\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .diagnosticListener(d -> {\n+                if (\"compiler.err.not.exhaustive.details\".equals(d.getCode())) {\n+                    if (d instanceof DiagnosticSourceUnwrapper uw) {\n+                        d = uw.d;\n+                    }\n+                    if (d instanceof JCDiagnostic diag) {\n+                        ((Collection<JCDiagnostic>) diag.getArgs()[0])\n+                                .stream()\n+                                .map(fragment -> (String) fragment.getArgs()[0])\n+                                .forEach(missingPatterns::add);\n+                    }\n+                }\n+            })\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Set<String> expectedPatterns = new HashSet<>(List.of(expectedMissingPatterns));\n+\n+        if (!expectedPatterns.equals(missingPatterns)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + expectedPatterns +\n+                                      \", actual: \" + missingPatterns);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ExhaustivenessConvenientErrors.java","additions":541,"deletions":0,"binary":false,"changes":541,"status":"added"},{"patch":"@@ -106,0 +106,1 @@\n+                .withOption(\"-XDexhaustivityTimeout=0\")\n@@ -111,0 +112,1 @@\n+                .withOption(\"-XDexhaustivityTimeout=0\")\n@@ -116,0 +118,1 @@\n+                .withOption(\"-XDexhaustivityTimeout=0\")\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfComboTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n- * @compile\/fail\/ref=PrimitivePatternsSwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitivePatternsSwitchErrors.java\n+ * @compile\/fail\/ref=PrimitivePatternsSwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW -XDexhaustivityTimeout=0 PrimitivePatternsSwitchErrors.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=SwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW SwitchErrors.java\n+ * @compile\/fail\/ref=SwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW -XDexhaustivityTimeout=0 SwitchErrors.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n- * @compile\/fail\/ref=NonExportedPermittedTypes.out -XDrawDiagnostics NonExportedPermittedTypes.java\n- * @compile\/fail\/ref=NonExportedPermittedTypes.out --release 21 -XDrawDiagnostics NonExportedPermittedTypes.java\n- * @compile\/fail\/ref=NonExportedPermittedTypes.out --release ${jdk.version} -XDrawDiagnostics NonExportedPermittedTypes.java\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out -XDrawDiagnostics -XDexhaustivityTimeout=0 NonExportedPermittedTypes.java\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out --release 21 -XDrawDiagnostics -XDexhaustivityTimeout=0 NonExportedPermittedTypes.java\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out --release ${jdk.version} -XDrawDiagnostics -XDexhaustivityTimeout=0 NonExportedPermittedTypes.java\n","filename":"test\/langtools\/tools\/javac\/platform\/NonExportedPermittedTypes.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=ExpressionSwitchNotExhaustive.out -XDrawDiagnostics ExpressionSwitchNotExhaustive.java\n+ * @compile\/fail\/ref=ExpressionSwitchNotExhaustive.out -XDrawDiagnostics -XDexhaustivityTimeout=0 ExpressionSwitchNotExhaustive.java\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExpressionSwitchNotExhaustive.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}