{"files":[{"patch":"@@ -86,0 +86,1 @@\n+        PATTERN(\"pattern\", \"PatternDescription\", \"com.sun.tools.javac.comp.ExhaustivenessComputer\"),\n","filename":"make\/langtools\/tools\/propertiesparser\/parser\/MessageType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.Collection;\n@@ -45,0 +46,3 @@\n+import java.util.LinkedHashSet;\n+import java.util.SequencedSet;\n+import java.util.function.Consumer;\n@@ -47,0 +51,1 @@\n+import java.util.stream.Stream;\n@@ -49,0 +54,1 @@\n+import static com.sun.tools.javac.code.Flags.RECORD;\n@@ -58,0 +64,2 @@\n+    private static final long DEFAULT_MAX_BASE_CHECKS = 4_000_000;\n+\n@@ -65,0 +73,2 @@\n+    private final long maxBaseChecks;\n+    private long baseChecks = -1;\n@@ -80,0 +90,13 @@\n+        Options options = Options.instance(context);\n+        String baseChecks = options.get(\"exhaustivityMaxBaseChecks\");\n+        long computedMaxBaseChecks = DEFAULT_MAX_BASE_CHECKS;\n+\n+        if (baseChecks != null) {\n+            try {\n+                computedMaxBaseChecks = Long.parseLong(baseChecks);\n+            } catch (NumberFormatException _) {\n+                \/\/ignore invalid values and use the default timeout\n+            }\n+        }\n+\n+        maxBaseChecks = computedMaxBaseChecks;\n@@ -82,1 +105,1 @@\n-    public boolean exhausts(JCExpression selector, List<JCCase> cases) {\n+    public ExhaustivenessResult exhausts(JCExpression selector, List<JCCase> cases) {\n@@ -116,1 +139,1 @@\n-            return true;\n+            return ExhaustivenessResult.ofExhaustive();\n@@ -124,3 +147,0 @@\n-        Set<PatternDescription> patterns = patternSet;\n-        Set<Set<PatternDescription>> seenFallback = new HashSet<>();\n-        boolean useHashes = true;\n@@ -128,27 +148,3 @@\n-            boolean repeat = true;\n-            while (repeat) {\n-                Set<PatternDescription> updatedPatterns;\n-                updatedPatterns = reduceBindingPatterns(selector.type, patterns);\n-                updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n-                updatedPatterns = reduceRecordPatterns(updatedPatterns);\n-                updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n-                repeat = !updatedPatterns.equals(patterns);\n-                if (checkCovered(selector.type, patterns)) {\n-                    return true;\n-                }\n-                if (!repeat) {\n-                    \/\/there may be situation like:\n-                    \/\/class B permits S1, S2\n-                    \/\/patterns: R(S1, B), R(S2, S2)\n-                    \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n-                    \/\/but hashing in reduceNestedPatterns will not allow that\n-                    \/\/disable the use of hashing, and use subtyping in\n-                    \/\/reduceNestedPatterns to handle situations like this:\n-                    repeat = useHashes && seenFallback.add(updatedPatterns);\n-                    useHashes = false;\n-                } else {\n-                    \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n-                    \/\/is enabled, as the hashing speeds up the process significantly:\n-                    useHashes = true;\n-                }\n-                patterns = updatedPatterns;\n+            CoverageResult coveredResult = computeCoverage(selector.type, patternSet, PatternEquivalence.STRICT);\n+            if (coveredResult.covered()) {\n+                return ExhaustivenessResult.ofExhaustive();\n@@ -156,1 +152,15 @@\n-            return checkCovered(selector.type, patterns);\n+\n+            Set<PatternDescription> details =\n+                    this.computeMissingPatternDescriptions(selector.type, coveredResult.incompletePatterns())\n+                        .stream()\n+                        .flatMap(pd -> {\n+                            if (pd instanceof BindingPattern bp && enum2Constants.containsKey(bp.type.tsym)) {\n+                                Symbol enumType = bp.type.tsym;\n+                                return enum2Constants.get(enumType).stream().map(c -> new EnumConstantPattern(bp.type, c.name));\n+                            } else {\n+                                return Stream.of(pd);\n+                            }\n+                        })\n+                        .collect(Collectors.toSet());\n+\n+            return ExhaustivenessResult.ofDetails(details);\n@@ -159,3 +169,1 @@\n-            return true; \/\/error recovery\n-        } finally {\n-            isSubtypeCache.clear();\n+            return ExhaustivenessResult.ofExhaustive(); \/\/error recovery\n@@ -165,0 +173,45 @@\n+    \/* Given the set of patterns, runs the reductions of it as long as possible.\n+     * If the (reduced) set of patterns covers the given selector type, returns\n+     * covered == true, and incompletePatterns == null.\n+     * If the (reduced) set of patterns does not cover the given selector type,\n+     * returns covered == false, and incompletePatterns == the reduced set of patterns.\n+     *\/\n+    private CoverageResult computeCoverage(Type selectorType, Set<PatternDescription> patterns, PatternEquivalence patternEquivalence) {\n+        Set<PatternDescription> updatedPatterns;\n+        Set<Set<PatternDescription>> seenPatterns = new HashSet<>();\n+        boolean useHashes = true;\n+        boolean repeat = true;\n+        do {\n+            updatedPatterns = reduceBindingPatterns(selectorType, patterns);\n+            updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes, patternEquivalence);\n+            updatedPatterns = reduceRecordPatterns(updatedPatterns);\n+            updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n+            repeat = !updatedPatterns.equals(patterns);\n+            if (checkCovered(selectorType, patterns)) {\n+                return new CoverageResult(true, null);\n+            }\n+            if (!repeat) {\n+                \/\/there may be situation like:\n+                \/\/class B permits S1, S2\n+                \/\/patterns: R(S1, B), R(S2, S2)\n+                \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n+                \/\/but hashing in reduceNestedPatterns will not allow that\n+                \/\/disable the use of hashing, and use subtyping in\n+                \/\/reduceNestedPatterns to handle situations like this:\n+                repeat = useHashes && seenPatterns.add(updatedPatterns);\n+                useHashes = false;\n+            } else {\n+                \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n+                \/\/is enabled, as the hashing speeds up the process significantly:\n+                useHashes = true;\n+            }\n+            patterns = updatedPatterns;\n+        } while (repeat);\n+        if (checkCovered(selectorType, patterns)) {\n+            return new CoverageResult(true, null);\n+        }\n+        return new CoverageResult(false, patterns);\n+    }\n+\n+    private record CoverageResult(boolean covered, Set<PatternDescription> incompletePatterns) {}\n+\n@@ -218,0 +271,1 @@\n+                        ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n@@ -225,10 +279,2 @@\n-                        Set<Symbol> permitted = allPermittedSubTypes(clazz, csym -> {\n-                            Type instantiated;\n-                            if (csym.type.allparams().isEmpty()) {\n-                                instantiated = csym.type;\n-                            } else {\n-                                instantiated = infer.instantiatePatternType(selectorType, csym);\n-                            }\n-\n-                            return instantiated != null && types.isCastable(selectorType, instantiated);\n-                        });\n+                        Set<Symbol> permitted = allPermittedSubTypes(clazz, isApplicableSubtypePredicate(selectorType));\n+                        int permittedSubtypes = permitted.size();\n@@ -266,1 +312,1 @@\n-                            toAdd.add(new BindingPattern(clazz.type));\n+                            toAdd.add(new BindingPattern(clazz.type, permittedSubtypes, Set.of()));\n@@ -307,0 +353,43 @@\n+    private <C extends TypeSymbol> Predicate<C> isApplicableSubtypePredicate(Type targetType) {\n+        return csym -> {\n+            Type instantiated = instantiatePatternType(targetType, csym);\n+\n+            return instantiated != null && types.isCastable(targetType, instantiated);\n+        };\n+    }\n+\n+    private Type instantiatePatternType(Type targetType, TypeSymbol csym) {\n+        if (csym.type.allparams().isEmpty()) {\n+            return csym.type;\n+        } else {\n+            return infer.instantiatePatternType(targetType, csym);\n+        }\n+    }\n+\n+    private Set<ClassSymbol> leafPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n+        Set<ClassSymbol> permitted = new HashSet<>();\n+        List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n+\n+        while (permittedSubtypesClosure.nonEmpty()) {\n+            ClassSymbol current = permittedSubtypesClosure.head;\n+\n+            permittedSubtypesClosure = permittedSubtypesClosure.tail;\n+\n+            current.complete();\n+\n+            if (current.isSealed() && current.isAbstract()) {\n+                for (Type t : current.getPermittedSubclasses()) {\n+                    ClassSymbol csym = (ClassSymbol) t.tsym;\n+\n+                    if (accept.test(csym)) {\n+                        permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n+                    }\n+                }\n+            } else {\n+                permitted.add(current);\n+            }\n+        }\n+\n+        return permitted;\n+    }\n+\n@@ -339,1 +428,2 @@\n-                                                         boolean useHashes) {\n+                                                         boolean useHashes,\n+                                                         PatternEquivalence patternEquivalence) {\n@@ -389,1 +479,1 @@\n-                                nestedComponentsEquivalent(rpOne, rpOther, mismatchingCandidate, useHashes)) {\n+                                nestedComponentsEquivalent(rpOne, rpOther, mismatchingCandidate, useHashes, patternEquivalence)) {\n@@ -395,1 +485,1 @@\n-                        var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n+                        var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes, patternEquivalence);\n@@ -406,10 +496,5 @@\n-                            for (PatternDescription nested : updatedPatterns) {\n-                                PatternDescription[] newNested =\n-                                        Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                                newNested[mismatchingCandidateFin] = nested;\n-                                RecordPattern nue = new RecordPattern(rpOne.recordType(),\n-                                                                rpOne.fullComponentTypes(),\n-                                                                newNested,\n-                                                                new HashSet<>(join));\n-                                current.add(nue);\n-                            }\n+                            generatePatternsWithReplacedNestedPattern(rpOne,\n+                                                                      mismatchingCandidateFin,\n+                                                                      updatedPatterns,\n+                                                                      Set.copyOf(join),\n+                                                                      current::add);\n@@ -437,0 +522,20 @@\n+     * - only if PatternEquivalence is LOOSE and the type is the same of the type\n+     *   of an existing record pattern (the binding pattern may stand in place of\n+     *   a record pattern). This is only used to compute the missing patterns that\n+     *   would make the original pattern set exhaustive.\n+     *\n+     * For example, having (with mismatchingCandidate == 0):\n+     * existing: R(A _, Box(var _)) {}\n+     * cadidate: R(B _, Box(var _)) {}\n+     * these are always equivalent; as all nested patterns except of\n+     * component 0 are exactly equivalent\n+     *\n+     * existing: R(A _, SubtypeOfBox _) {}\n+     * cadidate: R(A _, Box _) {}\n+     * this is only equivalent when useHashes == false; Box _ could be replaced\n+     * with a more specific SubtypeOfBox _\n+     *\n+     * existing: R(A _, Box(var _)) {}\n+     * cadidate: R(A _, Box _) {}\n+     * this is only equivalent when useHashes == false and patternEquivalence == LOOSE;\n+     * Box _ is accepted in place of the more specific record pattern\n@@ -441,1 +546,2 @@\n-                                               boolean useHashes) {\n+                                               boolean useHashes,\n+                                               PatternEquivalence patternEquivalence) {\n@@ -460,2 +566,10 @@\n-                        java.util.List<PatternDescription> pendingReplacedPatterns =\n-                                new ArrayList<>(nestedCandidate.sourcePatterns());\n+                        if (patternEquivalence == PatternEquivalence.LOOSE) {\n+                            if (!isSubtypeErasure(nestedExisting.recordType(), nestedCandidate.type)) {\n+                                return false;\n+                            }\n+                        } else {\n+                            java.util.List<PatternDescription> pendingReplacedPatterns =\n+                                    new ArrayList<>(nestedCandidate.sourcePatterns());\n+\n+                            while (!pendingReplacedPatterns.isEmpty()) {\n+                                PatternDescription currentReplaced = pendingReplacedPatterns.removeLast();\n@@ -463,2 +577,5 @@\n-                        while (!pendingReplacedPatterns.isEmpty()) {\n-                            PatternDescription currentReplaced = pendingReplacedPatterns.removeLast();\n+                                if (nestedExisting.equals(currentReplaced)) {\n+                                    \/\/candidate.nested[i] is substitutable for existing.nested[i]\n+                                    \/\/continue with the next nested pattern:\n+                                    continue NEXT_NESTED;\n+                                }\n@@ -466,4 +583,1 @@\n-                            if (nestedExisting.equals(currentReplaced)) {\n-                                \/\/candidate.nested[i] is substitutable for existing.nested[i]\n-                                \/\/continue with the next nested pattern:\n-                                continue NEXT_NESTED;\n+                                pendingReplacedPatterns.addAll(currentReplaced.sourcePatterns());\n@@ -472,1 +586,1 @@\n-                            pendingReplacedPatterns.addAll(currentReplaced.sourcePatterns());\n+                            return false;\n@@ -474,2 +588,0 @@\n-\n-                        return false;\n@@ -538,1 +650,1 @@\n-                PatternDescription pd = new BindingPattern(rpOne.recordType, Set.of(pattern));\n+                PatternDescription pd = new BindingPattern(rpOne.recordType, -1, Set.of(pattern));\n@@ -566,0 +678,2 @@\n+        checkTimeout();\n+\n@@ -577,1 +691,9 @@\n-    sealed interface PatternDescription {\n+    protected void checkTimeout() {\n+        if (baseChecks != (-1) &&\n+            ++baseChecks > maxBaseChecks) {\n+            throw new TooManyChecksException(null);\n+        }\n+    }\n+\n+    public sealed interface PatternDescription {\n+        public Type type();\n@@ -580,0 +702,1 @@\n+\n@@ -589,3 +712,1 @@\n-                componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n-                        .map(r -> types.memberType(record.type, r))\n-                        .toArray(s -> new Type[s]);\n+                componentTypes = instantiatedComponentTypes(record.type);\n@@ -614,1 +735,1 @@\n-    record BindingPattern(Type type, Set<PatternDescription> sourcePatterns) implements PatternDescription {\n+    public record BindingPattern(Type type, int permittedSubtypes, Set<PatternDescription> sourcePatterns) implements PatternDescription {\n@@ -617,1 +738,1 @@\n-            this(type, Set.of());\n+            this(type, -1, Set.of());\n@@ -634,1 +755,1 @@\n-    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription[] nested, Set<PatternDescription> sourcePatterns) implements PatternDescription {\n+    public record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription[] nested, Set<PatternDescription> sourcePatterns) implements PatternDescription {\n@@ -676,0 +797,445 @@\n+\n+        @Override\n+        public Type type() {\n+            return recordType;\n+        }\n+    }\n+\n+    public record EnumConstantPattern(Type enumType, Name enumConstant) implements PatternDescription {\n+\n+        @Override\n+        public Type type() {\n+            return enumType();\n+        }\n+\n+        @Override\n+        public Set<PatternDescription> sourcePatterns() {\n+            return Set.of();\n+        }\n+        public String toString() {\n+            return enumType() + \".\" + enumConstant();\n+        }\n+    }\n+\n+    public record ExhaustivenessResult(boolean exhaustive, Set<PatternDescription> notExhaustiveDetails) {\n+        public static ExhaustivenessResult ofExhaustive() {\n+            return new ExhaustivenessResult(true, null);\n+        }\n+        public static ExhaustivenessResult ofDetails(Set<PatternDescription> notExhaustiveDetails) {\n+            return new ExhaustivenessResult(false, notExhaustiveDetails != null ? notExhaustiveDetails : Set.of());\n+        }\n+    }\n+\n+    \/\/computation of missing patterns:\n+    protected Set<PatternDescription> computeMissingPatternDescriptions(Type selectorType,\n+                                                                        Set<PatternDescription> incompletePatterns) {\n+        if (maxBaseChecks == 0) {\n+            return Set.of();\n+        }\n+        try {\n+            baseChecks = 0;\n+            PatternDescription defaultPattern = new BindingPattern(selectorType);\n+            return expandMissingPatternDescriptions(selectorType,\n+                                                    selectorType,\n+                                                    defaultPattern,\n+                                                    incompletePatterns,\n+                                                    Set.of(defaultPattern));\n+        } catch (TooManyChecksException ex) {\n+            return ex.missingPatterns != null ? ex.missingPatterns : Set.of();\n+        } finally {\n+            baseChecks = -1;\n+        }\n+    }\n+\n+    private Set<PatternDescription> expandMissingPatternDescriptions(Type selectorType,\n+                                                                     Type targetType,\n+                                                                     PatternDescription toExpand,\n+                                                                     Set<? extends PatternDescription> basePatterns,\n+                                                                     Set<PatternDescription> inMissingPatterns) {\n+        try {\n+            return doExpandMissingPatternDescriptions(selectorType, targetType,\n+                                                      toExpand, basePatterns,\n+                                                      inMissingPatterns);\n+        } catch (TooManyChecksException ex) {\n+            if (ex.missingPatterns == null) {\n+                ex = new TooManyChecksException(inMissingPatterns);\n+            }\n+            throw ex;\n+        }\n+    }\n+\n+    private Set<PatternDescription> doExpandMissingPatternDescriptions(Type selectorType,\n+                                                                       Type targetType,\n+                                                                       PatternDescription toExpand,\n+                                                                       Set<? extends PatternDescription> basePatterns,\n+                                                                       Set<PatternDescription> inMissingPatterns) {\n+        if (toExpand instanceof BindingPattern bp) {\n+            if (bp.type.tsym.isSealed()) {\n+                \/\/try to replace binding patterns for sealed types with all their immediate permitted applicable types:\n+                List<Type> permitted = ((ClassSymbol) bp.type.tsym).getPermittedSubclasses();\n+                Set<PatternDescription> applicableDirectPermittedPatterns =\n+                        permitted.stream()\n+                                 .map(type -> type.tsym)\n+                                 .filter(isApplicableSubtypePredicate(targetType))\n+                                 .map(csym -> new BindingPattern(types.erasure(csym.type)))\n+                                 .collect(Collectors.toCollection(HashSet::new));\n+\n+                \/\/remove the permitted subtypes that are not needed to achieve exhaustivity\n+                boolean reduced =\n+                        removeUnnecessaryPatterns(selectorType, bp, basePatterns, inMissingPatterns, applicableDirectPermittedPatterns);\n+\n+                if (!reduced && !hasMatchingRecordPattern(basePatterns, inMissingPatterns, toExpand)) {\n+                    \/\/if all immediate permitted subtypes are needed\n+                    \/\/give up, and simply use the current pattern:\n+                    return inMissingPatterns;\n+                }\n+\n+                Set<PatternDescription> currentMissingPatterns =\n+                        replace(inMissingPatterns, toExpand, applicableDirectPermittedPatterns);\n+\n+                \/\/try to recursively expand on each viable pattern:\n+                for (PatternDescription viable : applicableDirectPermittedPatterns) {\n+                    currentMissingPatterns = expandMissingPatternDescriptions(selectorType, targetType,\n+                                                                              viable, basePatterns,\n+                                                                              currentMissingPatterns);\n+                }\n+\n+                return currentMissingPatterns;\n+            } else if ((bp.type.tsym.flags_field & Flags.RECORD) != 0 &&\n+                       \/\/only expand record types into record patterns if there's a chance it may change the outcome\n+                       \/\/i.e. there is a record pattern in at the spot in the original base patterns:\n+                       hasMatchingRecordPattern(basePatterns, inMissingPatterns, toExpand)) {\n+                \/\/if there is a binding pattern at a place where the original based patterns\n+                \/\/have a record pattern, try to expand the binding pattern into a record pattern\n+                \/\/create all possible combinations of record pattern components:\n+                Type[] componentTypes = instantiatedComponentTypes(bp.type);\n+                List<List<Type>> combinatorialNestedTypes = List.of(List.nil());\n+\n+                for (Type componentType : componentTypes) {\n+                    List<Type> applicableLeafPermittedSubtypes;\n+\n+                    if (componentType.tsym.isSealed()) {\n+                        applicableLeafPermittedSubtypes =\n+                                leafPermittedSubTypes(componentType.tsym,\n+                                                      isApplicableSubtypePredicate(componentType))\n+                                    .stream()\n+                                    .map(csym -> instantiatePatternType(componentType, csym))\n+                                    .collect(List.collector());\n+                    } else {\n+                        applicableLeafPermittedSubtypes = List.of(componentType);\n+                    }\n+\n+                    List<List<Type>> newCombinatorialNestedTypes = List.nil();\n+\n+                    for (List<Type> existing : combinatorialNestedTypes) {\n+                        for (Type nue : applicableLeafPermittedSubtypes) {\n+                            newCombinatorialNestedTypes = newCombinatorialNestedTypes.prepend(existing.append(nue));\n+                        }\n+                    }\n+\n+                    combinatorialNestedTypes = newCombinatorialNestedTypes;\n+                }\n+\n+                Set<PatternDescription> combinatorialPatterns =\n+                        combinatorialNestedTypes.stream()\n+                                                .map(combination -> new RecordPattern(bp.type,\n+                                                                                      componentTypes,\n+                                                                                      combination.map(BindingPattern::new)\n+                                                                                                 .toArray(PatternDescription[]::new)))\n+                                                .collect(Collectors.toCollection(HashSet::new));\n+\n+                removeUnnecessaryPatterns(selectorType, bp, basePatterns, inMissingPatterns, combinatorialPatterns);\n+\n+                CoverageResult coverageResult = computeCoverage(targetType, combinatorialPatterns, PatternEquivalence.LOOSE);\n+\n+                if (!coverageResult.covered()) {\n+                    \/\/use the partially merged\/combined patterns:\n+                    combinatorialPatterns = coverageResult.incompletePatterns();\n+                }\n+\n+                \/\/combine sealed subtypes into the supertype, if all is covered.\n+                \/\/but preserve more specific record types in positions where there are record patterns in the original patterns\n+                \/\/this is particularly important for the case where the sealed supertype only has one permitted type, the record\n+                \/\/the base type could be used instead of the record otherwise, which would produce less specific missing pattern:\n+                Set<PatternDescription> sortedCandidates =\n+                        partialSortPattern(combinatorialPatterns, basePatterns, replace(inMissingPatterns, toExpand, combinatorialPatterns));\n+\n+                removeUnnecessaryPatterns(selectorType, bp, basePatterns, inMissingPatterns, sortedCandidates);\n+\n+                Set<PatternDescription> currentMissingPatterns =\n+                        replace(inMissingPatterns, toExpand, sortedCandidates);\n+\n+                for (PatternDescription addedPattern : sortedCandidates) {\n+                    if (addedPattern instanceof RecordPattern addedRP) {\n+                        for (int c = 0; c < addedRP.nested.length; c++) {\n+                            currentMissingPatterns = expandMissingPatternDescriptions(selectorType,\n+                                                                                      addedRP.fullComponentTypes[c],\n+                                                                                      addedRP.nested[c],\n+                                                                                      basePatterns,\n+                                                                                      currentMissingPatterns);\n+                        }\n+                    }\n+                }\n+\n+                return currentMissingPatterns;\n+            }\n+        }\n+        return inMissingPatterns;\n+    }\n+\n+    \/*\n+     * Inside any pattern in {@code in}, in any nesting depth, replace\n+     * pattern {@code what} with patterns {@code to}.\n+     *\/\n+    private Set<PatternDescription> replace(Iterable<? extends PatternDescription> in,\n+                                            PatternDescription what,\n+                                            Collection<? extends PatternDescription> to) {\n+        Set<PatternDescription> result = new HashSet<>();\n+\n+        for (PatternDescription pd : in) {\n+            Collection<? extends PatternDescription> replaced = replace(pd, what, to);\n+            if (replaced != null) {\n+                result.addAll(replaced);\n+            } else {\n+                result.add(pd);\n+            }\n+        }\n+\n+        return result;\n+    }\n+    \/\/where:\n+        \/\/null: no change\n+        private Collection<? extends PatternDescription> replace(PatternDescription in,\n+                                                                 PatternDescription what,\n+                                                                 Collection<? extends PatternDescription> to) {\n+            if (in == what) {\n+                return to;\n+            } else if (in instanceof RecordPattern rp) {\n+                for (int c = 0; c < rp.nested.length; c++) {\n+                    Collection<? extends PatternDescription> replaced = replace(rp.nested[c], what, to);\n+                    if (replaced != null) {\n+                        Set<PatternDescription> withReplaced = new HashSet<>();\n+\n+                        generatePatternsWithReplacedNestedPattern(rp, c, replaced, Set.of(), withReplaced::add);\n+\n+                        return replace(withReplaced, what, to);\n+                    }\n+                }\n+                return null;\n+            } else {\n+                return null; \/\/binding patterns have no children\n+            }\n+        }\n+\n+    \/* Out of \"candidates\" remove patterns that are not necessary to achieve exhaustiveness.\n+     * Note that iteration order of \"candidates\" is important - if the set contains\n+     * two pattern, out of which either, but not both, is needed to achieve exhaustiveness,\n+     * the first one in the iteration order will be removed.\n+     *\/\n+    private boolean removeUnnecessaryPatterns(Type selectorType,\n+                                              PatternDescription toExpand,\n+                                              Set<? extends PatternDescription> basePatterns,\n+                                              Set<PatternDescription> inMissingPatterns,\n+                                              Set<PatternDescription> candidates) {\n+        boolean reduced = false;\n+\n+        for (Iterator<PatternDescription> it = candidates.iterator(); it.hasNext(); ) {\n+            PatternDescription current = it.next();\n+            Set<PatternDescription> reducedAdded = new HashSet<>(candidates);\n+\n+            reducedAdded.remove(current);\n+\n+    Set<PatternDescription> combinedPatterns =\n+              Stream.concat(basePatterns.stream(),\n+                                        replace(inMissingPatterns, toExpand, reducedAdded).stream())\n+                          .collect(Collectors.toSet());\n+\n+            if (computeCoverage(selectorType, combinedPatterns, PatternEquivalence.LOOSE).covered()) {\n+                it.remove();\n+                reduced = true;\n+            }\n+        }\n+\n+        return reduced;\n+    }\n+    \/*\n+     * Sort patterns so that those that are preferred for removal are in front\n+     * of those that are preferred to remain (when there's a choice).\n+     *\/\n+    private SequencedSet<PatternDescription> partialSortPattern(Set<PatternDescription> candidates,\n+                                                                Set<? extends PatternDescription> basePatterns,\n+                                                                Set<PatternDescription> missingPatterns) {\n+        SequencedSet<PatternDescription> sortedCandidates = new LinkedHashSet<>();\n+\n+        while (!candidates.isEmpty()) {\n+            PatternDescription mostSpecific = null;\n+            for (PatternDescription current : candidates) {\n+                if (mostSpecific == null ||\n+                    shouldAppearBefore(current, mostSpecific, basePatterns, missingPatterns)) {\n+                    mostSpecific = current;\n+                }\n+            }\n+            sortedCandidates.add(mostSpecific);\n+            candidates.remove(mostSpecific);\n+        }\n+        return sortedCandidates;\n+    }\n+    \/\/where:\n+        \/\/true iff pd1 should appear before pd2\n+        \/\/false otherwise\n+        private boolean shouldAppearBefore(PatternDescription pd1,\n+                                           PatternDescription pd2,\n+                                           Set<? extends PatternDescription> basePatterns,\n+                                           Set<? extends PatternDescription> missingPatterns) {\n+            if (pd1 instanceof RecordPattern rp1 && pd2 instanceof RecordPattern rp2) {\n+                for (int c = 0; c < rp1.nested.length; c++) {\n+                    if (shouldAppearBefore((BindingPattern) rp1.nested[c],\n+                                           (BindingPattern) rp2.nested[c],\n+                                           basePatterns,\n+                                           missingPatterns)) {\n+                        return true;\n+                    }\n+                }\n+            } else if (pd1 instanceof BindingPattern bp1 && pd2 instanceof BindingPattern bp2) {\n+                Type t1 = bp1.type();\n+                Type t2 = bp2.type();\n+                boolean t1IsImportantRecord =\n+                        (t1.tsym.flags_field & RECORD) != 0 &&\n+                        hasMatchingRecordPattern(basePatterns, missingPatterns, bp1);\n+                boolean t2IsImportantRecord =\n+                        (t2.tsym.flags_field & RECORD) != 0 &&\n+                        hasMatchingRecordPattern(basePatterns, missingPatterns, bp2);\n+                if (t1IsImportantRecord && !t2IsImportantRecord) {\n+                    return false;\n+                }\n+                if (!t1IsImportantRecord && t2IsImportantRecord) {\n+                    return true;\n+                }\n+                if (!types.isSameType(t1, t2) && types.isSubtype(t1, t2)) {\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+    \/*\n+     * Do the {@code basePatterns} have a record pattern at a place that corresponds to\n+     * position of pattern {@code query} inside {@code missingPatterns}?\n+     *\/\n+    private boolean hasMatchingRecordPattern(Set<? extends PatternDescription> basePatterns,\n+                                             Set<? extends PatternDescription> missingPatterns,\n+                                             PatternDescription query) {\n+        PatternDescription root = findRootContaining(missingPatterns, query);\n+\n+        if (root == null) {\n+            return false;\n+        }\n+        return basePatternsHaveRecordPatternOnThisSpot(basePatterns, root, query);\n+    }\n+    \/\/where:\n+        private PatternDescription findRootContaining(Set<? extends PatternDescription> rootPatterns,\n+                                                      PatternDescription added) {\n+            for (PatternDescription pd : rootPatterns) {\n+                if (isUnderRoot(pd, added)) {\n+                    return pd;\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        private boolean basePatternsHaveRecordPatternOnThisSpot(Set<? extends PatternDescription> basePatterns,\n+                                                                PatternDescription rootPattern,\n+                                                                PatternDescription added) {\n+            if (rootPattern == added) {\n+                return basePatterns.stream().anyMatch(pd -> pd instanceof RecordPattern);\n+            }\n+            if (!(rootPattern instanceof RecordPattern rootPatternRecord)) {\n+                return false;\n+            }\n+            int index = -1;\n+            for (int c = 0; c < rootPatternRecord.nested.length; c++) {\n+                if (isUnderRoot(rootPatternRecord.nested[c], added)) {\n+                    index = c;\n+                    break;\n+                }\n+            }\n+            \/\/ 'index' must be one of rootPatternRecord.nested; if not, `isUnderRoot` is inconsistent.\n+            Assert.check(index != (-1));\n+\n+            int indexFin = index;\n+            Set<PatternDescription> filteredBasePatterns =\n+                    basePatterns.stream()\n+                                .filter(pd -> pd instanceof RecordPattern)\n+                                .map(rp -> (RecordPattern) rp)\n+                                .filter(rp -> types.isSameType(rp.recordType(), rootPatternRecord.recordType()))\n+                                .map(rp -> rp.nested[indexFin])\n+                                .collect(Collectors.toSet());\n+\n+            return basePatternsHaveRecordPatternOnThisSpot(filteredBasePatterns, rootPatternRecord.nested[index], added);\n+        }\n+\n+        private boolean isUnderRoot(PatternDescription root, PatternDescription searchFor) {\n+            if (root == searchFor) {\n+                return true;\n+            } else if (root instanceof RecordPattern rp) {\n+                for (int c = 0; c < rp.nested.length; c++) {\n+                    if (isUnderRoot(rp.nested[c], searchFor)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+    \/*\n+     * Using {@code basePattern} as a starting point, generate new {@code\n+     * RecordPattern}s, such that all corresponding components but one, are the\n+     * same. The component described by the {@code replaceComponent} index is\n+     * replaced with all {@code PatternDescription}s taken from {@code\n+     * updatedNestedPatterns} and the resulting {@code RecordPatterns}s are sent\n+     * to {@code target}.\n+     *\/\n+    private void generatePatternsWithReplacedNestedPattern(RecordPattern basePattern,\n+                                                           int replaceComponent,\n+                                                           Iterable<? extends PatternDescription> updatedNestedPatterns,\n+                                                           Set<PatternDescription> sourcePatterns,\n+                                                           Consumer<RecordPattern> target) {\n+        for (PatternDescription nested : updatedNestedPatterns) {\n+            PatternDescription[] newNested =\n+                    Arrays.copyOf(basePattern.nested, basePattern.nested.length);\n+            newNested[replaceComponent] = nested;\n+            target.accept(new RecordPattern(basePattern.recordType(),\n+                                            basePattern.fullComponentTypes(),\n+                                            newNested,\n+                                            sourcePatterns));\n+        }\n+    }\n+\n+    \/* For a given record type, return the record's component types, with their\n+     * types instatiated according to the exact record type.\n+     *\/\n+    private Type[] instantiatedComponentTypes(Type recordType) {\n+        Type[] componentTypes = ((ClassSymbol) recordType.tsym).getRecordComponents()\n+                .map(r -> types.memberType(recordType, r))\n+                .toArray(s -> new Type[s]);\n+        return componentTypes;\n+    }\n+\n+    \/* The stricness of determining the equivalent of patterns, used in\n+     * nestedComponentsEquivalent.\n+     *\/\n+    private enum PatternEquivalence {\n+        STRICT,\n+        LOOSE;\n+    }\n+\n+    protected static class TooManyChecksException extends RuntimeException {\n+        private static final long serialVersionUID = 0L;\n+        private transient final Set<PatternDescription> missingPatterns;\n+\n+        public TooManyChecksException(Set<PatternDescription> missingPatterns) {\n+            super(null, null, false, false);\n+            this.missingPatterns = missingPatterns;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ExhaustivenessComputer.java","additions":646,"deletions":80,"binary":false,"changes":726,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import com.sun.tools.javac.comp.ExhaustivenessComputer.ExhaustivenessResult;\n@@ -699,1 +700,0 @@\n-                tree.isExhaustive |= exhaustiveness.exhausts(tree.selector, tree.cases);\n@@ -701,1 +701,11 @@\n-                    log.error(tree, Errors.NotExhaustiveStatement);\n+                    ExhaustivenessResult exhaustivenessResult = exhaustiveness.exhausts(tree.selector, tree.cases);\n+\n+                    tree.isExhaustive = exhaustivenessResult.exhaustive();\n+\n+                    if (!tree.isExhaustive) {\n+                        if (exhaustivenessResult.notExhaustiveDetails().isEmpty()) {\n+                            log.error(tree, Errors.NotExhaustiveStatement);\n+                        } else {\n+                            logNotExhaustiveError(tree.pos(), exhaustivenessResult, Errors.NotExhaustiveStatementDetails);\n+                        }\n+                    }\n@@ -738,2 +748,3 @@\n-                tree.isExhaustive = exhaustiveness.exhausts(tree.selector, tree.cases);\n-            }\n+                ExhaustivenessResult exhaustivenessResult = exhaustiveness.exhausts(tree.selector, tree.cases);\n+\n+                tree.isExhaustive = exhaustivenessResult.exhaustive();\n@@ -741,2 +752,7 @@\n-            if (!tree.isExhaustive) {\n-                log.error(tree, Errors.NotExhaustive);\n+                if (!tree.isExhaustive) {\n+                    if (exhaustivenessResult.notExhaustiveDetails().isEmpty()) {\n+                        log.error(tree, Errors.NotExhaustive);\n+                    } else {\n+                        logNotExhaustiveError(tree.pos(), exhaustivenessResult, Errors.NotExhaustiveDetails);\n+                    }\n+                }\n@@ -744,0 +760,1 @@\n+\n@@ -748,0 +765,14 @@\n+        private void logNotExhaustiveError(DiagnosticPosition pos,\n+                                           ExhaustivenessResult exhaustivenessResult,\n+                                           Error errorKey) {\n+            List<JCDiagnostic> details =\n+                    exhaustivenessResult.notExhaustiveDetails()\n+                                       .stream()\n+                                       .sorted((pd1, pd2) -> pd1.toString().compareTo(pd2.toString()))\n+                                       .map(detail -> diags.fragment(Fragments.NotExhaustiveDetail(detail)))\n+                                       .collect(List.collector());\n+            JCDiagnostic main = diags.error(null, log.currentSource(), pos, errorKey);\n+            JCDiagnostic d = new JCDiagnostic.MultilineDiagnostic(main, details);\n+            log.report(d);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+# patter            a pattern\/pattern description\n@@ -1479,0 +1480,12 @@\n+compiler.err.not.exhaustive.details=\\\n+    the switch expression does not cover all possible input values\\n\\\n+    missing patterns:\n+\n+compiler.err.not.exhaustive.statement.details=\\\n+    the switch statement does not cover all possible input values\\n\\\n+    missing patterns:\n+\n+# 0: pattern\n+compiler.misc.not.exhaustive.detail=\\\n+    {0}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.stream.Collectors;\n@@ -50,0 +51,3 @@\n+import com.sun.tools.javac.comp.ExhaustivenessComputer.BindingPattern;\n+import com.sun.tools.javac.comp.ExhaustivenessComputer.EnumConstantPattern;\n+import com.sun.tools.javac.comp.ExhaustivenessComputer.RecordPattern;\n@@ -233,0 +237,12 @@\n+        else if (arg instanceof BindingPattern bp) {\n+            return formatArgument(d, bp.type(), l) + \" _\";\n+        }\n+        else if (arg instanceof RecordPattern rp) {\n+            return formatArgument(d, rp.type(), l) +\n+                   Arrays.stream(rp.nested())\n+                         .map(pd -> formatArgument(d, pd, l))\n+                         .collect(Collectors.joining(\", \", \"(\", \")\"));\n+        }\n+        else if (arg instanceof EnumConstantPattern ep) {\n+            return formatArgument(d, ep.type(), l) + \".\" + ep.enumConstant();\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/AbstractDiagnosticFormatter.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -50,0 +50,3 @@\n+import com.sun.tools.javac.comp.ExhaustivenessComputer.BindingPattern;\n+import com.sun.tools.javac.comp.ExhaustivenessComputer.EnumConstantPattern;\n+import com.sun.tools.javac.comp.ExhaustivenessComputer.RecordPattern;\n@@ -52,0 +55,1 @@\n+import java.util.Arrays;\n@@ -211,0 +215,1 @@\n+        \/\/TODO: preprocess for patterns\n@@ -228,0 +233,11 @@\n+        else if (arg instanceof BindingPattern bp) {\n+            preprocessArgument(bp.type());\n+        }\n+        else if (arg instanceof RecordPattern rp) {\n+            preprocessArgument(rp.type());\n+            Arrays.stream(rp.nested())\n+                  .forEach(this::preprocessArgument);\n+        }\n+        else if (arg instanceof EnumConstantPattern ep) {\n+            preprocessArgument(ep.type());\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/RichDiagnosticFormatter.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -605,3 +605,7 @@\n-            for (Object o: d.getArgs()) {\n-                if (o instanceof JCDiagnostic) {\n-                    scanForKeys((JCDiagnostic) o, keys);\n+            List<Object> todoArgs = new ArrayList<>(Arrays.asList(d.getArgs()));\n+            while (!todoArgs.isEmpty()) {\n+                Object o = todoArgs.removeLast();\n+                if (o instanceof JCDiagnostic sd) {\n+                    scanForKeys(sd, keys);\n+                } else if (o instanceof List l) {\n+                    todoArgs.addAll(l);\n","filename":"test\/langtools\/tools\/javac\/diags\/Example.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\/\/ options: -XDexhaustivityTimeout=0\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustive.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.not.exhaustive.details\n+\/\/ key: compiler.misc.not.exhaustive.detail\n+\/\/ options: -XDexhaustivityTimeout=-1\n+\n+class NotExhaustiveDetails {\n+    int t(int i) {\n+        return switch (i) {\n+            case 0 -> -1;\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveDetails.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\/\/ options: -XDexhaustivityTimeout=0\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveStatement.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.not.exhaustive.statement.details\n+\/\/ key: compiler.misc.not.exhaustive.detail\n+\/\/ options: -XDexhaustivityTimeout=-1\n+\n+class NotExhaustiveDetails {\n+    void t(Object o) {\n+        switch (o) {\n+            case String s -> System.err.println(\"String of length: \" + s.length());\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveStatementDetails.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -2526,0 +2526,1 @@\n+                             \"-XDexhaustivityMaxBaseChecks=0\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,596 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8367530\n+ * @summary Check enhanced exhaustiveness errors\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ExhaustivenessConvenientErrors\n+*\/\n+\n+import com.sun.tools.javac.api.ClientCodeWrapper.DiagnosticSourceUnwrapper;\n+import com.sun.tools.javac.util.JCDiagnostic;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class ExhaustivenessConvenientErrors extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new ExhaustivenessConvenientErrors().runTests();\n+    }\n+\n+    ExhaustivenessConvenientErrors() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testExhaustiveSealedClasses(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"lib.B _\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveSealedClassesTransitive(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S1 permits S2, A {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public sealed interface S2 extends S1 permits S3, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public sealed interface S3 extends S2 permits C, D {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S1 {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S2 {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class C implements S3 {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class D implements S3 {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S1 obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case B a -> 0;\n+                           case D a -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"lib.C _\");\n+    }\n+\n+    @Test\n+    public void testTrivialRecord(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record R(S s) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"lib.R(lib.B _)\");\n+    }\n+\n+    @Test\n+    public void testNonNestedRecord(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record R(S s1, S s2) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, B b) -> 0;\n+                           case R(B b, A a) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"lib.R(lib.A _, lib.A _)\",\n+               \"lib.R(lib.B _, lib.B _)\");\n+    }\n+\n+    @Test\n+    public void testComplex1(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2() implements Base {}\n+                   record R3(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\",\n+               \"test.Test.Root(test.Test.R2 _, test.Test.Base _, test.Test.Base _)\",\n+               \"test.Test.Root(test.Test.R3 _, test.Test.Base _, test.Test.Base _)\");\n+    }\n+\n+    @Test\n+    public void testComplex2(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+\/\/                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\",\n+               \"test.Test.Root(test.Test.R2 _, test.Test.R2(test.Test.R2 _, test.Test.R2 _), test.Test.R2(test.Test.R2 _, test.Test.R2 _))\");\n+    }\n+\n+    @Test\n+    public void testComplex3(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Triple p) {\n+                       return switch (p) {\n+                           case Triple(B _, _, _) -> 0;\n+                           case Triple(_, A _, _) -> 0;\n+                           case Triple(_, _, A _) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseA _), _) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseB _), C(Nested _, NestedBaseA _)) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseB _), C(Nested _, NestedBaseB _)) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseB _), C(Nested _, NestedBaseC _)) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseC _), C(Nested _, NestedBaseA _)) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseC _), C(Nested _, NestedBaseB _)) -> 0;\n+\/\/                           case Path(A p, C(Nested _, NestedBaseC _), C(Nested _, NestedBaseC _)) -> 0;\n+                       };\n+                   }\n+                   record Triple(Base c1, Base c2, Base c3) {}\n+                   sealed interface Base permits A, B {}\n+                   record A(boolean key) implements Base {\n+                   }\n+                   sealed interface B extends Base {}\n+                   record C(Nested n, NestedBase b) implements B {}\n+                   record Nested() {}\n+                   sealed interface NestedBase {}\n+                   record NestedBaseA() implements NestedBase {}\n+                   record NestedBaseB() implements NestedBase {}\n+                   record NestedBaseC() implements NestedBase {}\n+               }\n+               \"\"\",\n+               \"test.Test.Triple(test.Test.A _, test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _), test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _))\");\n+    }\n+\n+    @Test\n+    public void testComplex4(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+\/\/                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+\/\/                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\",\n+               \"test.Test.Root(test.Test.R2 _, test.Test.R2(test.Test.Base _, test.Test.R2 _), test.Test.R2(test.Test.R2 _, test.Test.Base _))\");\n+               \/\/ideally, the result would be as follow, but it is difficult to split Base on two distinct places:\n+\/\/               \"test.Test.Root(test.Test.R2 _, test.Test.R2(test.Test.R1 _, test.Test.R2 _), test.Test.R2(test.Test.R2 _, test.Test.R1 _))\",\n+\/\/               \"test.Test.Root(test.Test.R2 _, test.Test.R2(test.Test.R2 _, test.Test.R2 _), test.Test.R2(test.Test.R2 _, test.Test.R2 _))\");\n+    }\n+\n+    @Test\n+    public void testComplex5(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Triple p) {\n+                       return switch (p) {\n+                           case Triple(B _, _, _) -> 0;\n+                           case Triple(_, A _, _) -> 0;\n+                           case Triple(_, _, A _) -> 0;\n+\/\/                           case Triple(A _, C(Nested _, NestedBaseA _), _) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseB _), C(Nested _, NestedBaseA _)) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseB _), C(Nested _, NestedBaseB _)) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseB _), C(Nested _, NestedBaseC _)) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseC _), C(Nested _, NestedBaseA _)) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseC _), C(Nested _, NestedBaseB _)) -> 0;\n+\/\/                           case Path(A _, C(Nested _, NestedBaseC _), C(Nested _, NestedBaseC _)) -> 0;\n+                       };\n+                   }\n+                   record Triple(Base c1, Base c2, Base c3) {}\n+                   sealed interface Base permits A, B {}\n+                   record A(boolean key) implements Base {\n+                   }\n+                   sealed interface B extends Base {}\n+                   record C(Nested n, NestedBase b) implements B {}\n+                   record Nested() {}\n+                   sealed interface NestedBase {}\n+                   record NestedBaseA() implements NestedBase {}\n+                   record NestedBaseB() implements NestedBase {}\n+                   record NestedBaseC() implements NestedBase {}\n+               }\n+               \"\"\",\n+               \"test.Test.Triple(test.Test.A _, test.Test.C(test.Test.Nested _, test.Test.NestedBaseA _), test.Test.C _)\",\n+               \/\/the following could be:\n+               \/\/test.Test.Triple(test.Test.A _, test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _), test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _))\n+               \"test.Test.Triple(test.Test.A _, test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _), test.Test.C _)\");\n+    }\n+\n+    @Test\n+    public void testNoInfiniteRecursion(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(_, _, R(_, _, _, _), String s) -> 0;\n+                           case R(_, _, R(_, _, _, String str), _) -> 0;\n+                       };\n+                   }\n+               }\n+               public record R(R r1, R r2, R r3, Object o) {}\n+               \"\"\",\n+               \"test.R(test.R _, test.R _, test.R(test.R _, test.R _, test.R _, java.lang.Object _), java.lang.Object _)\");\n+    }\n+\n+    @Test\n+    public void testEnum(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(I i) {\n+                       return switch (i) {\n+                           case E.A -> 0;\n+                           case C _ -> 1;\n+                       };\n+                   }\n+                   sealed interface I {}\n+                   enum E implements I {A, B}\n+                   final class C implements I {}\n+               }\n+               public record R(R r1, R r2, R r3, Object o) {}\n+               \"\"\",\n+               \"test.Test.E.B\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(I i) {\n+                       return switch (i) {\n+                           case C _ -> 1;\n+                       };\n+                   }\n+                   sealed interface I {}\n+                   enum E implements I {A, B}\n+                   final class C implements I {}\n+               }\n+               public record R(R r1, R r2, R r3, Object o) {}\n+               \"\"\",\n+               \"test.Test.E _\");\n+    }\n+\n+    @Test\n+    public void testInstantiateComponentTypes(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Pair<Base<Base>> p) {\n+                       return switch (p) {\n+                           case Pair(A(A(_)) -> 0;\n+                           case Pair(A(B(_)) -> 0;\n+                           case Pair(B(A(_)) -> 0;\n+                       };\n+                   }\n+                   record Pair<T>(T c) {}\n+                   sealed interface Base<T> permits A, B {}\n+                   record A<T>(T c) implements Base<T> {}\n+                   record B<T>(T c) implements Base<T> {}\n+               }\n+               \"\"\",\n+               \"test.Test.Pair(test.Test.B(test.Test.B _))\");\n+    }\n+\n+    @Test\n+    public void testNeedToExpandIfRecordExists(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+                class Test {\n+                   sealed interface A { }\n+                   record B() implements A { }\n+                   record C(A a) implements A { }\n+\n+                   void test(A a) {\n+                       switch (a) {\n+                           case C(B _) -> throw null;\n+                       }\n+                   }\n+               }               \"\"\",\n+               \"test.Test.B _\",\n+               \"test.Test.C(test.Test.C _)\");\n+    }\n+\n+    @Test\n+    public void testComplex6(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               public class Test {\n+                   sealed interface Base {}\n+                   record NoOp() implements Base {}\n+                   record Const() implements Base {}\n+                   record Pair(Base n1,\n+                               Base b2) implements Base {}\n+\n+                   int t(Base b) {\n+                       return switch (b) {\n+                           case NoOp _ -> 0;\n+                           case Const _ -> 0;\n+                           case Pair(NoOp _, _) -> 0;\n+                           case Pair(Const _, _) -> 0;\n+                           case Pair(Pair _, NoOp _) -> 0;\n+                           case Pair(Pair _, Const _) -> 0;\n+                           case Pair(Pair _, Pair(NoOp _, _)) -> 0;\n+                           case Pair(Pair _, Pair(Const _, _)) -> 0;\n+                           case Pair(Pair _, Pair(Pair(NoOp _, _), _)) -> 0;\n+                           case Pair(Pair _, Pair(Pair(Const _, _), _)) -> 0;\n+                           case Pair(Pair(NoOp _, _), Pair(Pair(Pair _, _), _)) -> 0;\n+                           case Pair(Pair(Const _, _), Pair(Pair(Pair _, _), _)) -> 0;\n+\/\/                           case Pair(Pair(Pair _, _), Pair(Pair(Pair _, _), _)) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"Test.Pair(Test.Pair(Test.Pair _, Test.Base _), Test.Pair(Test.Pair(Test.Pair _, Test.Base _), Test.Base _))\");\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode, String... expectedMissingPatterns) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        if (libraryCode.length != 0) {\n+            Path libSrc = current.resolve(\"lib-src\");\n+\n+            for (String code : libraryCode) {\n+                tb.writeJavaFiles(libSrc, code);\n+            }\n+\n+            new JavacTask(tb)\n+                    .outdir(libClasses)\n+                    .files(tb.findJavaFiles(libSrc))\n+                    .run();\n+        }\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src, testCode);\n+\n+        Path classes = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+        Set<String> missingPatterns = new HashSet<>();\n+\n+        new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"-XDdev\",\n+                     \"-Xlint:-preview\",\n+                     \"--class-path\", libClasses.toString(),\n+                     \"-XDshould-stop.at=FLOW\",\n+                     \"-XDshould-stop.ifNoError=FLOW\",\n+                     \"-XDexhaustivityMaxBaseChecks=\" + Long.MAX_VALUE) \/\/never give up\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .diagnosticListener(d -> {\n+                if (\"compiler.err.not.exhaustive.details\".equals(d.getCode()) ||\n+                    \"compiler.err.not.exhaustive.statement.details\".equals(d.getCode())) {\n+                    if (d instanceof DiagnosticSourceUnwrapper uw) {\n+                        d = uw.d;\n+                    }\n+                    if (d instanceof JCDiagnostic.MultilineDiagnostic diag) {\n+                        diag.getSubdiagnostics()\n+                                .stream()\n+                                .map(fragment -> fragment.getArgs()[0].toString())\n+                                .forEach(missingPatterns::add);\n+                    }\n+                }\n+            })\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Set<String> expectedPatterns = new HashSet<>(List.of(expectedMissingPatterns));\n+\n+        if (!expectedPatterns.equals(missingPatterns)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + expectedPatterns +\n+                                      \", actual: \" + missingPatterns);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ExhaustivenessConvenientErrors.java","additions":596,"deletions":0,"binary":false,"changes":596,"status":"added"},{"patch":"@@ -106,0 +106,1 @@\n+                .withOption(\"-XDexhaustivityTimeout=0\")\n@@ -111,0 +112,1 @@\n+                .withOption(\"-XDexhaustivityTimeout=0\")\n@@ -116,0 +118,1 @@\n+                .withOption(\"-XDexhaustivityTimeout=0\")\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfComboTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=PrimitivePatternsSwitchConstants.out -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitivePatternsSwitchConstants.java\n+ * @compile\/fail\/ref=PrimitivePatternsSwitchConstants.out -XDrawDiagnostics -XDshould-stop.at=FLOW -XDexhaustivityTimeout=0 PrimitivePatternsSwitchConstants.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchConstants.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n- * @compile\/fail\/ref=PrimitivePatternsSwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitivePatternsSwitchErrors.java\n+ * @compile\/fail\/ref=PrimitivePatternsSwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW -XDexhaustivityTimeout=0 PrimitivePatternsSwitchErrors.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=SwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW SwitchErrors.java\n+ * @compile\/fail\/ref=SwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW -XDexhaustivityTimeout=0 SwitchErrors.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n- * @compile\/fail\/ref=NonExportedPermittedTypes.out -XDrawDiagnostics NonExportedPermittedTypes.java\n- * @compile\/fail\/ref=NonExportedPermittedTypes.out --release 21 -XDrawDiagnostics NonExportedPermittedTypes.java\n- * @compile\/fail\/ref=NonExportedPermittedTypes.out --release ${jdk.version} -XDrawDiagnostics NonExportedPermittedTypes.java\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out -XDrawDiagnostics -XDexhaustivityTimeout=0 NonExportedPermittedTypes.java\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out --release 21 -XDrawDiagnostics -XDexhaustivityTimeout=0 NonExportedPermittedTypes.java\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out --release ${jdk.version} -XDrawDiagnostics -XDexhaustivityTimeout=0 NonExportedPermittedTypes.java\n","filename":"test\/langtools\/tools\/javac\/platform\/NonExportedPermittedTypes.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=ExpressionSwitchNotExhaustive.out -XDrawDiagnostics ExpressionSwitchNotExhaustive.java\n+ * @compile\/fail\/ref=ExpressionSwitchNotExhaustive.out -XDrawDiagnostics -XDexhaustivityTimeout=0 ExpressionSwitchNotExhaustive.java\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExpressionSwitchNotExhaustive.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}