{"files":[{"patch":"@@ -0,0 +1,1169 @@\n+\/*\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Set;\n+import com.sun.tools.javac.code.*;\n+import static com.sun.tools.javac.code.Flags.RECORD;\n+import com.sun.tools.javac.tree.*;\n+import com.sun.tools.javac.util.*;\n+\n+import com.sun.tools.javac.code.Symbol.*;\n+import com.sun.tools.javac.tree.JCTree.*;\n+\n+import com.sun.tools.javac.code.Kinds.Kind;\n+import com.sun.tools.javac.code.Type.TypeVar;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.IdentityHashMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.SequencedSet;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+\n+\/** A class to compute exhaustiveness of set of switch cases.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class ExhaustivenessComputer {\n+    private static final long DEFAULT_TIMEOUT = 5000; \/\/5s\n+    protected static final Context.Key<ExhaustivenessComputer> exhaustivenessKey = new Context.Key<>();\n+\n+    private final Symtab syms;\n+    private final Types types;\n+    private final Check chk;\n+    private final Infer infer;\n+    private final long missingExhaustivenessTimeout;\n+    private long startTime = -1;\n+\n+    public static ExhaustivenessComputer instance(Context context) {\n+        ExhaustivenessComputer instance = context.get(exhaustivenessKey);\n+        if (instance == null)\n+            instance = new ExhaustivenessComputer(context);\n+        return instance;\n+    }\n+\n+    @SuppressWarnings(\"this-escape\")\n+    protected ExhaustivenessComputer(Context context) {\n+        context.put(exhaustivenessKey, this);\n+        syms = Symtab.instance(context);\n+        types = Types.instance(context);\n+        chk = Check.instance(context);\n+        infer = Infer.instance(context);\n+        Options options = Options.instance(context);\n+        String timeout = options.get(\"exhaustivityTimeout\");\n+        long computedTimeout = DEFAULT_TIMEOUT;\n+\n+        if (timeout != null) {\n+            try {\n+                computedTimeout = Long.parseLong(timeout);\n+            } catch (NumberFormatException _) {\n+                \/\/ignore invalid values and use the default timeout\n+            }\n+        }\n+\n+        missingExhaustivenessTimeout = computedTimeout;\n+    }\n+\n+    public ExhaustivenessResult exhausts(JCExpression selector, List<JCCase> cases) {\n+        Set<PatternDescription> patternSet = new HashSet<>();\n+        Map<Symbol, Set<Symbol>> enum2Constants = new HashMap<>();\n+        Set<Object> booleanLiterals = new HashSet<>(Set.of(0, 1));\n+        for (JCCase c : cases) {\n+            if (!TreeInfo.unguardedCase(c))\n+                continue;\n+\n+            for (var l : c.labels) {\n+                if (l instanceof JCPatternCaseLabel patternLabel) {\n+                    for (Type component : components(selector.type)) {\n+                        patternSet.add(makePatternDescription(component, patternLabel.pat));\n+                    }\n+                } else if (l instanceof JCConstantCaseLabel constantLabel) {\n+                    if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN)) {\n+                        Object value = ((JCLiteral) constantLabel.expr).value;\n+                        booleanLiterals.remove(value);\n+                    } else {\n+                        Symbol s = TreeInfo.symbol(constantLabel.expr);\n+                        if (s != null && s.isEnum()) {\n+                            enum2Constants.computeIfAbsent(s.owner, x -> {\n+                                Set<Symbol> result = new HashSet<>();\n+                                s.owner.members()\n+                                        .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n+                                        .forEach(result::add);\n+                                return result;\n+                            }).remove(s);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.isEmpty()) {\n+            return ExhaustivenessResult.ofExhaustive();\n+        }\n+\n+        for (Entry<Symbol, Set<Symbol>> e : enum2Constants.entrySet()) {\n+            if (e.getValue().isEmpty()) {\n+                patternSet.add(new BindingPattern(e.getKey().type));\n+            }\n+        }\n+        try {\n+            CoverageResult coveredResult = computeCoverage(selector.type, patternSet, false);\n+            if (coveredResult.covered()) {\n+                return ExhaustivenessResult.ofExhaustive();\n+            }\n+\n+            Set<String> details =\n+                    this.computeMissingPatternDescriptions(selector.type, coveredResult.incompletePatterns())\n+                        .stream()\n+                        .flatMap(pd -> {\n+                            if (pd instanceof BindingPattern bp && enum2Constants.containsKey(bp.type.tsym)) {\n+                                Symbol enumType = bp.type.tsym;\n+                                return enum2Constants.get(enumType).stream().map(c -> enumType.toString() + \".\" + c.name);\n+                            } else {\n+                                return Stream.of(pd.toString());\n+                            }\n+                        })\n+                        .collect(Collectors.toSet());\n+\n+            return ExhaustivenessResult.ofDetails(details);\n+        } catch (CompletionFailure cf) {\n+            chk.completionError(selector.pos(), cf);\n+            return ExhaustivenessResult.ofExhaustive(); \/\/error recovery\n+        }\n+    }\n+\n+    private CoverageResult computeCoverage(Type selectorType, Set<PatternDescription> patterns, boolean search) {\n+        Set<PatternDescription> updatedPatterns;\n+        Map<PatternDescription, Set<PatternDescription>> replaces = new IdentityHashMap<>();\n+        Set<Set<PatternDescription>> seenPatterns = new HashSet<>();\n+        boolean useHashes = true;\n+        boolean repeat = true;\n+        do {\n+            updatedPatterns = reduceBindingPatterns(selectorType, patterns);\n+            updatedPatterns = reduceNestedPatterns(updatedPatterns, replaces, useHashes, search);\n+            updatedPatterns = reduceRecordPatterns(updatedPatterns, replaces);\n+            updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n+            repeat = !updatedPatterns.equals(patterns);\n+            if (checkCovered(selectorType, patterns)) {\n+                return new CoverageResult(true, null);\n+            }\n+            if (!repeat) {\n+                \/\/there may be situation like:\n+                \/\/class B permits S1, S2\n+                \/\/patterns: R(S1, B), R(S2, S2)\n+                \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n+                \/\/but hashing in reduceNestedPatterns will not allow that\n+                \/\/disable the use of hashing, and use subtyping in\n+                \/\/reduceNestedPatterns to handle situations like this:\n+                repeat = useHashes && seenPatterns.add(updatedPatterns);\n+                useHashes = false;\n+            } else {\n+                \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n+                \/\/is enabled, as the hashing speeds up the process significantly:\n+                useHashes = true;\n+            }\n+            patterns = updatedPatterns;\n+        } while (repeat);\n+        if (checkCovered(selectorType, patterns)) {\n+            return new CoverageResult(true, null);\n+        }\n+        return new CoverageResult(false, patterns);\n+    }\n+\n+    private record CoverageResult(boolean covered, Set<PatternDescription> incompletePatterns) {}\n+\n+    private boolean checkCovered(Type seltype, Iterable<PatternDescription> patterns) {\n+        for (Type seltypeComponent : components(seltype)) {\n+            for (PatternDescription pd : patterns) {\n+                if(isBpCovered(seltypeComponent, pd)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private List<Type> components(Type seltype) {\n+        return switch (seltype.getTag()) {\n+            case CLASS -> {\n+                if (seltype.isCompound()) {\n+                    if (seltype.isIntersection()) {\n+                        yield ((Type.IntersectionClassType) seltype).getComponents()\n+                                                                    .stream()\n+                                                                    .flatMap(t -> components(t).stream())\n+                                                                    .collect(List.collector());\n+                    }\n+                    yield List.nil();\n+                }\n+                yield List.of(types.erasure(seltype));\n+            }\n+            case TYPEVAR -> components(((TypeVar) seltype).getUpperBound());\n+            default -> List.of(types.erasure(seltype));\n+        };\n+    }\n+\n+    \/* In a set of patterns, search for a sub-set of binding patterns that\n+     * in combination exhaust their sealed supertype. If such a sub-set\n+     * is found, it is removed, and replaced with a binding pattern\n+     * for the sealed supertype.\n+     *\/\n+    private Set<PatternDescription> reduceBindingPatterns(Type selectorType, Set<PatternDescription> patterns) {\n+        Set<Symbol> existingBindings = patterns.stream()\n+                                               .filter(pd -> pd instanceof BindingPattern)\n+                                               .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                               .collect(Collectors.toSet());\n+\n+        for (PatternDescription pdOne : patterns) {\n+            if (pdOne instanceof BindingPattern bpOne) {\n+                Set<PatternDescription> toAdd = new HashSet<>();\n+\n+                for (Type sup : types.directSupertypes(bpOne.type)) {\n+                    ClassSymbol clazz = (ClassSymbol) types.erasure(sup).tsym;\n+\n+                    clazz.complete();\n+\n+                    if (clazz.isSealed() && clazz.isAbstract() &&\n+                        \/\/if a binding pattern for clazz already exists, no need to analyze it again:\n+                        !existingBindings.contains(clazz)) {\n+                        ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n+                        \/\/do not reduce to types unrelated to the selector type:\n+                        Type clazzErasure = types.erasure(clazz.type);\n+                        if (components(selectorType).stream()\n+                                                    .map(types::erasure)\n+                                                    .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n+                            continue;\n+                        }\n+\n+                        Set<Symbol> permitted = allPermittedSubTypes(clazz, isPossibleSubtypePredicate(selectorType));\n+                        int permittedSubtypes = permitted.size();\n+\n+                        for (PatternDescription pdOther : patterns) {\n+                            if (pdOther instanceof BindingPattern bpOther) {\n+                                Set<Symbol> currentPermittedSubTypes =\n+                                        allPermittedSubTypes(bpOther.type.tsym, s -> true);\n+\n+                                PERMITTED: for (Iterator<Symbol> it = permitted.iterator(); it.hasNext();) {\n+                                    Symbol perm = it.next();\n+\n+                                    for (Symbol currentPermitted : currentPermittedSubTypes) {\n+                                        if (types.isSubtype(types.erasure(currentPermitted.type),\n+                                                            types.erasure(perm.type))) {\n+                                            it.remove();\n+                                            continue PERMITTED;\n+                                        }\n+                                    }\n+                                    if (types.isSubtype(types.erasure(perm.type),\n+                                                        types.erasure(bpOther.type))) {\n+                                        it.remove();\n+                                    }\n+                                }\n+                            }\n+                        }\n+\n+                        if (permitted.isEmpty()) {\n+                            toAdd.add(new BindingPattern(clazz.type, permittedSubtypes));\n+                        }\n+                    }\n+                }\n+\n+                if (!toAdd.isEmpty()) {\n+                    Set<PatternDescription> newPatterns = new HashSet<>(patterns);\n+                    newPatterns.addAll(toAdd);\n+                    return newPatterns;\n+                }\n+            }\n+        }\n+        return patterns;\n+    }\n+\n+    private Set<Symbol> allPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n+        Set<Symbol> permitted = new HashSet<>();\n+        List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n+\n+        while (permittedSubtypesClosure.nonEmpty()) {\n+            ClassSymbol current = permittedSubtypesClosure.head;\n+\n+            permittedSubtypesClosure = permittedSubtypesClosure.tail;\n+\n+            current.complete();\n+\n+            if (current.isSealed() && current.isAbstract()) {\n+                for (Type t : current.getPermittedSubclasses()) {\n+                    ClassSymbol csym = (ClassSymbol) t.tsym;\n+\n+                    if (accept.test(csym)) {\n+                        permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n+                        permitted.add(csym);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return permitted;\n+    }\n+\n+    private <C extends TypeSymbol> Predicate<C> isPossibleSubtypePredicate(Type targetType) {\n+        return csym -> {\n+            Type instantiated = instantiatePatternType(targetType, csym);\n+\n+            return instantiated != null && types.isCastable(targetType, instantiated);\n+        };\n+    }\n+\n+    private Type instantiatePatternType(Type targetType, TypeSymbol csym) {\n+        if (csym.type.allparams().isEmpty()) {\n+            return csym.type;\n+        } else {\n+            return infer.instantiatePatternType(targetType, csym);\n+        }\n+    }\n+\n+    private Set<ClassSymbol> leafPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n+        Set<ClassSymbol> permitted = new HashSet<>();\n+        List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n+\n+        while (permittedSubtypesClosure.nonEmpty()) {\n+            ClassSymbol current = permittedSubtypesClosure.head;\n+\n+            permittedSubtypesClosure = permittedSubtypesClosure.tail;\n+\n+            current.complete();\n+\n+            if (current.isSealed() && current.isAbstract()) {\n+                for (Type t : current.getPermittedSubclasses()) {\n+                    ClassSymbol csym = (ClassSymbol) t.tsym;\n+\n+                    if (accept.test(csym)) {\n+                        permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n+                    }\n+                }\n+            } else {\n+                permitted.add(current);\n+            }\n+        }\n+\n+        return permitted;\n+    }\n+\n+    private List<ClassSymbol> baseClasses(TypeSymbol root) {\n+        if (root instanceof ClassSymbol clazz) {\n+            return List.of(clazz);\n+        } else if (root instanceof TypeVariableSymbol tvar) {\n+            ListBuffer<ClassSymbol> result = new ListBuffer<>();\n+            for (Type bound : tvar.getBounds()) {\n+                result.appendList(baseClasses(bound.tsym));\n+            }\n+            return result.toList();\n+        } else {\n+            return List.nil();\n+        }\n+    }\n+\n+    \/* Among the set of patterns, find sub-set of patterns such:\n+     * $record($prefix$, $nested, $suffix$)\n+     * Where $record, $prefix$ and $suffix$ is the same for each pattern\n+     * in the set, and the patterns only differ in one \"column\" in\n+     * the $nested pattern.\n+     * Then, the set of $nested patterns is taken, and passed recursively\n+     * to reduceNestedPatterns and to reduceBindingPatterns, to\n+     * simplify the pattern. If that succeeds, the original found sub-set\n+     * of patterns is replaced with a new set of patterns of the form:\n+     * $record($prefix$, $resultOfReduction, $suffix$)\n+     *\n+     * useHashes: when true, patterns will be subject to exact equivalence;\n+     *            when false, two binding patterns will be considered equivalent\n+     *            if one of them is more generic than the other one;\n+     *            when false, the processing will be significantly slower,\n+     *            as pattern hashes cannot be used to speed up the matching process\n+     *\/\n+    private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns,\n+                                                         Map<PatternDescription, Set<PatternDescription>> replaces,\n+                                                         boolean useHashes,\n+                                                         boolean search) {\n+        \/* implementation note:\n+         * finding a sub-set of patterns that only differ in a single\n+         * column is time-consuming task, so this method speeds it up by:\n+         * - group the patterns by their record class\n+         * - for each column (nested pattern) do:\n+         * -- group patterns by their hash\n+         * -- in each such by-hash group, find sub-sets that only differ in\n+         *    the chosen column, and then call reduceBindingPatterns and reduceNestedPatterns\n+         *    on patterns in the chosen column, as described above\n+         *\/\n+        var groupByRecordClass =\n+                patterns.stream()\n+                        .filter(pd -> pd instanceof RecordPattern)\n+                        .map(pd -> (RecordPattern) pd)\n+                        .collect(groupingBy(pd -> (ClassSymbol) pd.recordType.tsym));\n+\n+        for (var e : groupByRecordClass.entrySet()) {\n+            int nestedPatternsCount = e.getKey().getRecordComponents().size();\n+            Set<RecordPattern> current = new HashSet<>(e.getValue());\n+\n+            for (int mismatchingCandidate = 0;\n+                 mismatchingCandidate < nestedPatternsCount;\n+                 mismatchingCandidate++) {\n+                int mismatchingCandidateFin = mismatchingCandidate;\n+                var groupEquivalenceCandidates =\n+                        current\n+                         .stream()\n+                         \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n+                         .filter(pd -> pd.nested.length == nestedPatternsCount)\n+                         .collect(groupingBy(pd -> useHashes ? pd.hashCode(mismatchingCandidateFin) : 0));\n+                for (var candidates : groupEquivalenceCandidates.values()) {\n+                    checkTimeout();\n+\n+                    var candidatesArr = candidates.toArray(RecordPattern[]::new);\n+\n+                    for (int firstCandidate = 0;\n+                         firstCandidate < candidatesArr.length;\n+                         firstCandidate++) {\n+                        RecordPattern rpOne = candidatesArr[firstCandidate];\n+                        ListBuffer<RecordPattern> join = new ListBuffer<>();\n+\n+                        join.append(rpOne);\n+\n+                        NEXT_PATTERN: for (int nextCandidate = 0;\n+                                           nextCandidate < candidatesArr.length;\n+                                           nextCandidate++) {\n+                            if (firstCandidate == nextCandidate) {\n+                                continue;\n+                            }\n+\n+                            RecordPattern rpOther = candidatesArr[nextCandidate];\n+                            if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n+                                ACCEPT: for (int i = 0; i < rpOne.nested.length; i++) {\n+                                    if (i != mismatchingCandidate) {\n+                                        if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n+                                            if (useHashes) {\n+                                                continue NEXT_PATTERN;\n+                                            }\n+                                            \/\/when not using hashes,\n+                                            \/\/check if rpOne.nested[i] is\n+                                            \/\/a subtype of rpOther.nested[i]:\n+                                            if (!(rpOther.nested[i] instanceof BindingPattern bpOther)) {\n+                                                continue NEXT_PATTERN;\n+                                            }\n+                                            if (rpOne.nested[i] instanceof BindingPattern bpOne) {\n+                                                if (!types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n+                                                    continue NEXT_PATTERN;\n+                                                }\n+                                            } else if (rpOne.nested[i] instanceof RecordPattern nestedRPOne) {\n+                                                if (search) {\n+                                                    if (!types.isSubtype(types.erasure(nestedRPOne.recordType()), types.erasure(bpOther.type))) {\n+                                                        continue NEXT_PATTERN;\n+                                                    }\n+                                                } else {\n+                                                    Set<PatternDescription> pendingReplacedPatterns = new HashSet<>(replaces.getOrDefault(rpOther.nested[i], Set.of()));\n+\n+                                                    while (!pendingReplacedPatterns.isEmpty()) {\n+                                                        PatternDescription currentReplaced = pendingReplacedPatterns.iterator().next();\n+\n+                                                        pendingReplacedPatterns.remove(currentReplaced);\n+\n+                                                        if (nestedRPOne.equals(currentReplaced)) {\n+                                                            continue ACCEPT;\n+                                                        }\n+\n+                                                        pendingReplacedPatterns.addAll(replaces.getOrDefault(currentReplaced, Set.of()));\n+                                                    }\n+                                                    continue NEXT_PATTERN;\n+                                                }\n+                                            } else {\n+                                                continue NEXT_PATTERN;\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                join.append(rpOther);\n+                            }\n+                        }\n+\n+                        var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(Collectors.toSet());\n+                        var updatedPatterns = reduceNestedPatterns(nestedPatterns, replaces, useHashes, search);\n+\n+                        updatedPatterns = reduceRecordPatterns(updatedPatterns, replaces);\n+                        updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n+                        updatedPatterns = reduceBindingPatterns(rpOne.fullComponentTypes()[mismatchingCandidateFin], updatedPatterns);\n+\n+                        if (!nestedPatterns.equals(updatedPatterns)) {\n+                            if (useHashes) {\n+                                current.removeAll(join);\n+                            }\n+\n+                            generatePatternsWithReplacedNestedPattern(rpOne,\n+                                                                      mismatchingCandidateFin,\n+                                                                      updatedPatterns,\n+                                                                      nue -> {\n+                                current.add(nue);\n+                                replaces.put(nue, new HashSet<>(join));\n+                            });\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (!current.equals(new HashSet<>(e.getValue()))) {\n+                Set<PatternDescription> result = new HashSet<>(patterns);\n+                result.removeAll(e.getValue());\n+                result.addAll(current);\n+                return result;\n+            }\n+        }\n+        return patterns;\n+    }\n+\n+    \/* In the set of patterns, find those for which, given:\n+     * $record($nested1, $nested2, ...)\n+     * all the $nestedX pattern cover the given record component,\n+     * and replace those with a simple binding pattern over $record.\n+     *\/\n+    private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns, Map<PatternDescription, Set<PatternDescription>> replaces) {\n+        var newPatterns = new HashSet<PatternDescription>();\n+        boolean modified = false;\n+        for (PatternDescription pd : patterns) {\n+            if (pd instanceof RecordPattern rpOne) {\n+                PatternDescription reducedPattern = reduceRecordPattern(rpOne, replaces);\n+                if (reducedPattern != rpOne) {\n+                    newPatterns.add(reducedPattern);\n+                    modified = true;\n+                    continue;\n+                }\n+            }\n+            newPatterns.add(pd);\n+        }\n+        return modified ? newPatterns : patterns;\n+    }\n+\n+    private PatternDescription reduceRecordPattern(PatternDescription pattern, Map<PatternDescription, Set<PatternDescription>> replaces) {\n+        if (pattern instanceof RecordPattern rpOne) {\n+            Type[] componentType = rpOne.fullComponentTypes();\n+            \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n+            if (componentType.length != rpOne.nested.length) {\n+                return pattern;\n+            }\n+            PatternDescription[] reducedNestedPatterns = null;\n+            boolean covered = true;\n+            for (int i = 0; i < componentType.length; i++) {\n+                PatternDescription newNested = reduceRecordPattern(rpOne.nested[i], replaces);\n+                if (newNested != rpOne.nested[i]) {\n+                    if (reducedNestedPatterns == null) {\n+                        reducedNestedPatterns = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n+                    }\n+                    reducedNestedPatterns[i] = newNested;\n+                }\n+\n+                covered &= checkCovered(componentType[i], List.of(newNested));\n+            }\n+            if (covered) {\n+                PatternDescription pd = new BindingPattern(rpOne.recordType);\n+                replaces.put(pd, Set.of(pattern));\n+                return pd;\n+            } else if (reducedNestedPatterns != null) {\n+                PatternDescription pd = new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n+                replaces.put(pd, Set.of(pattern));\n+                return pd;\n+            }\n+        }\n+        return pattern;\n+    }\n+\n+    private Set<PatternDescription> removeCoveredRecordPatterns(Set<PatternDescription> patterns) {\n+        Set<Symbol> existingBindings = patterns.stream()\n+                                               .filter(pd -> pd instanceof BindingPattern)\n+                                               .map(pd -> ((BindingPattern) pd).type.tsym)\n+                                               .collect(Collectors.toSet());\n+        Set<PatternDescription> result = new HashSet<>(patterns);\n+\n+        for (Iterator<PatternDescription> it = result.iterator(); it.hasNext();) {\n+            PatternDescription pd = it.next();\n+            if (pd instanceof RecordPattern rp && existingBindings.contains(rp.recordType.tsym)) {\n+                it.remove();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    private boolean isBpCovered(Type componentType, PatternDescription newNested) {\n+        checkTimeout();\n+\n+        if (newNested instanceof BindingPattern bp) {\n+            Type seltype = types.erasure(componentType);\n+            Type pattype = types.erasure(bp.type);\n+\n+            return seltype.isPrimitive() ?\n+                    types.isUnconditionallyExact(seltype, pattype) :\n+                    (bp.type.isPrimitive() && types.isUnconditionallyExact(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n+        }\n+        return false;\n+    }\n+\n+    protected void checkTimeout() {\n+        if (startTime != (-1) &&\n+            (System.currentTimeMillis() - startTime) > missingExhaustivenessTimeout) {\n+            throw new TimeoutException(null);\n+        }\n+    }\n+\n+    protected sealed interface PatternDescription {\n+        public Type type();\n+    }\n+\n+    public PatternDescription makePatternDescription(Type selectorType, JCPattern pattern) {\n+        if (pattern instanceof JCBindingPattern binding) {\n+            Type type = !selectorType.isPrimitive() && types.isSubtype(selectorType, binding.type)\n+                    ? selectorType : binding.type;\n+            return new BindingPattern(type);\n+        } else if (pattern instanceof JCRecordPattern record) {\n+            Type[] componentTypes;\n+\n+            if (!record.type.isErroneous()) {\n+                componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n+                        .map(r -> types.memberType(record.type, r))\n+                        .toArray(s -> new Type[s]);\n+            }\n+            else {\n+                componentTypes = record.nested.map(t -> types.createErrorType(t.type)).toArray(s -> new Type[s]);;\n+            }\n+\n+            PatternDescription[] nestedDescriptions =\n+                    new PatternDescription[record.nested.size()];\n+            int i = 0;\n+            for (List<JCPattern> it = record.nested;\n+                 it.nonEmpty();\n+                 it = it.tail, i++) {\n+                Type componentType = i < componentTypes.length ? componentTypes[i]\n+                                                               : syms.errType;\n+                nestedDescriptions[i] = makePatternDescription(types.erasure(componentType), it.head);\n+            }\n+            return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n+        } else if (pattern instanceof JCAnyPattern) {\n+            return new BindingPattern(selectorType);\n+        } else {\n+            throw Assert.error();\n+        }\n+    }\n+    record BindingPattern(Type type, int permittedSubtypes) implements PatternDescription {\n+\n+        public BindingPattern(Type type) {\n+            this(type, -1);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return type.tsym.hashCode();\n+        }\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof BindingPattern other &&\n+                    type.tsym == other.type.tsym;\n+        }\n+        @Override\n+        public String toString() {\n+            return type.tsym + \" _\";\n+        }\n+    }\n+    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n+\n+        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n+            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return _hashCode;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof RecordPattern other &&\n+                    recordType.tsym == other.recordType.tsym &&\n+                    Arrays.equals(nested, other.nested);\n+        }\n+\n+        public int hashCode(int excludeComponent) {\n+            return hashCode(excludeComponent, recordType, nested);\n+        }\n+\n+        public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n+            int hash = 5;\n+            hash =  41 * hash + recordType.tsym.hashCode();\n+            for (int  i = 0; i < nested.length; i++) {\n+                if (i != excludeComponent) {\n+                    hash = 41 * hash + nested[i].hashCode();\n+                }\n+            }\n+            return hash;\n+        }\n+        @Override\n+        public String toString() {\n+            return recordType.tsym + \"(\" + Arrays.stream(nested)\n+                    .map(pd -> pd.toString())\n+                    .collect(Collectors.joining(\", \")) + \")\";\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return recordType;\n+        }\n+    }\n+\n+    public record ExhaustivenessResult(boolean exhaustive, Set<String> notExhaustiveDetails) {\n+        public static ExhaustivenessResult ofExhaustive() {\n+            return new ExhaustivenessResult(true, null);\n+        }\n+        public static ExhaustivenessResult ofDetails(Set<String> notExhaustiveDetails) {\n+            return new ExhaustivenessResult(false, notExhaustiveDetails != null ? notExhaustiveDetails : Set.of());\n+        }\n+    }\n+\n+    \/\/computation of missing patterns:\n+    protected Set<PatternDescription> computeMissingPatternDescriptions(Type selectorType,\n+                                                                        Set<PatternDescription> incompletePatterns) {\n+        if (missingExhaustivenessTimeout == 0) {\n+            return Set.of();\n+        }\n+        try {\n+            startTime = System.currentTimeMillis();\n+            PatternDescription defaultPattern = new BindingPattern(selectorType);\n+            return expandMissingPatternDescriptions(selectorType,\n+                                                    selectorType,\n+                                                    defaultPattern,\n+                                                    incompletePatterns,\n+                                                    Set.of(defaultPattern));\n+        } catch (TimeoutException ex) {\n+            return ex.missingPatterns != null ? ex.missingPatterns : Set.of();\n+        } finally {\n+            startTime = -1;\n+        }\n+    }\n+\n+    private Set<PatternDescription> expandMissingPatternDescriptions(Type selectorType,\n+                                                                     Type targetType,\n+                                                                     PatternDescription toExpand,\n+                                                                     Set<? extends PatternDescription> basePatterns,\n+                                                                     Set<PatternDescription> inMissingPatterns) {\n+        try {\n+            return doExpandMissingPatternDescriptions(selectorType, targetType,\n+                                                      toExpand, basePatterns,\n+                                                      inMissingPatterns);\n+        } catch (TimeoutException ex) {\n+            if (ex.missingPatterns == null) {\n+                ex = new TimeoutException(inMissingPatterns);\n+            }\n+            throw ex;\n+        }\n+    }\n+\n+    private Set<PatternDescription> doExpandMissingPatternDescriptions(Type selectorType,\n+                                                                       Type targetType,\n+                                                                       PatternDescription toExpand,\n+                                                                       Set<? extends PatternDescription> basePatterns,\n+                                                                       Set<PatternDescription> inMissingPatterns) {\n+        if (toExpand instanceof BindingPattern bp) {\n+            if (bp.type.tsym.isSealed()) {\n+                \/\/try to replace binding patterns for sealed types with all their immediate permitted types:\n+                List<Type> permitted = ((ClassSymbol) bp.type.tsym).getPermittedSubclasses();\n+                Set<BindingPattern> viablePermittedPatterns =\n+                        permitted.stream()\n+                                 .map(type -> type.tsym)\n+                                 .filter(isPossibleSubtypePredicate(targetType))\n+                                 .map(csym -> new BindingPattern(types.erasure(csym.type)))\n+                                 .collect(Collectors.toCollection(HashSet::new));\n+\n+                \/\/remove the permitted subtypes that are not needed to achieve exhaustivity\n+                boolean reduced = false;\n+\n+                for (Iterator<BindingPattern> it = viablePermittedPatterns.iterator(); it.hasNext(); ) {\n+                    BindingPattern current = it.next();\n+                    Set<BindingPattern> reducedPermittedPatterns = new HashSet<>(viablePermittedPatterns);\n+\n+                    reducedPermittedPatterns.remove(current);\n+\n+                    Set<PatternDescription> replaced =\n+                            replace(inMissingPatterns, toExpand, reducedPermittedPatterns);\n+\n+                    if (computeCoverage(selectorType, joinSets(basePatterns, replaced), true).covered()) {\n+                        it.remove();\n+                        reduced = true;\n+                    }\n+                }\n+\n+                if (!reduced) {\n+                    \/\/if all immediate permitted subtypes are needed\n+                    \/\/give up, and simply use the current pattern:\n+                    return inMissingPatterns;\n+                }\n+\n+                Set<PatternDescription> currentMissingPatterns =\n+                        replace(inMissingPatterns, toExpand, viablePermittedPatterns);\n+\n+                \/\/try to recursively expand on each viable pattern:\n+                for (PatternDescription viable : viablePermittedPatterns) {\n+                    currentMissingPatterns = expandMissingPatternDescriptions(selectorType, targetType,\n+                                                                              viable, basePatterns,\n+                                                                              currentMissingPatterns);\n+                }\n+\n+                return currentMissingPatterns;\n+            } else if ((bp.type.tsym.flags_field & Flags.RECORD) != 0 &&\n+                       \/\/only expand record types into record patterns if there's a chance it may change the outcome\n+                       \/\/i.e. there is a record pattern in at the spot in the original base patterns:\n+                       hasMatchingRecordPattern(basePatterns, inMissingPatterns, toExpand)) {\n+                \/\/if there is a binding pattern at a place where the original based patterns\n+                \/\/have a record pattern, try to expand the binding pattern into a record pattern\n+                \/\/create all possible combinations of record pattern components:\n+                Type[] componentTypes = ((ClassSymbol) bp.type.tsym).getRecordComponents()\n+                        .map(r -> types.memberType(bp.type, r))\n+                        .toArray(s -> new Type[s]);\n+                List<List<Type>> combinatorialNestedTypes = List.of(List.nil());\n+\n+                for (Type componentType : componentTypes) {\n+                    List<Type> variants;\n+\n+                    if (componentType.tsym.isSealed()) {\n+                        variants = leafPermittedSubTypes(componentType.tsym,\n+                                                         isPossibleSubtypePredicate(componentType))\n+                                .stream()\n+                                .map(csym -> instantiatePatternType(componentType, csym))\n+                                .collect(List.collector());\n+                    } else {\n+                        variants = List.of(componentType);\n+                    }\n+\n+                    List<List<Type>> newCombinatorialNestedTypes = List.nil();\n+\n+                    for (List<Type> existing : combinatorialNestedTypes) {\n+                        for (Type nue : variants) {\n+                            newCombinatorialNestedTypes = newCombinatorialNestedTypes.prepend(existing.append(nue));\n+                        }\n+                    }\n+\n+                    combinatorialNestedTypes = newCombinatorialNestedTypes;\n+                }\n+\n+                Set<PatternDescription> combinatorialPatterns =\n+                        combinatorialNestedTypes.stream()\n+                                                .map(combination -> new RecordPattern(bp.type,\n+                                                                                      componentTypes,\n+                                                                                      combination.map(BindingPattern::new)\n+                                                                                                 .toArray(PatternDescription[]::new)))\n+                                                .collect(Collectors.toCollection(HashSet::new));\n+\n+                \/\/remove unnecessary:\n+                for (Iterator<PatternDescription> it = combinatorialPatterns.iterator(); it.hasNext(); ) {\n+                    PatternDescription current = it.next();\n+                    Set<PatternDescription> reducedAdded = new HashSet<>(combinatorialPatterns);\n+\n+                    reducedAdded.remove(current);\n+\n+                    Set<PatternDescription> combinedPatterns =\n+                            joinSets(basePatterns, replace(inMissingPatterns, bp, reducedAdded));\n+\n+                    if (computeCoverage(selectorType, combinedPatterns, true).covered()) {\n+                        it.remove();\n+                    }\n+                }\n+\n+                CoverageResult coverageResult = computeCoverage(targetType, combinatorialPatterns, true);\n+\n+                if (!coverageResult.covered()) {\n+                    \/\/use the partially merged\/combined patterns:\n+                    combinatorialPatterns = coverageResult.incompletePatterns();\n+                }\n+\n+                \/\/combine sealed subtypes into the supertype, if all is covered.\n+                \/\/but preserve more specific record types in positions where there are record patterns in the original patterns\n+                \/\/this is particularly for the case where the sealed supertype only has one permitted type, the record\n+                \/\/the base type could be used instead of the record otherwise, which would produce less specific missing pattern:\n+                Set<PatternDescription> sortedCandidates =\n+                        partialSortPattern(combinatorialPatterns, basePatterns, combinatorialPatterns);\n+\n+                \/\/remove unnecessary:\n+                OUTER: for (Iterator<PatternDescription> it = sortedCandidates.iterator(); it.hasNext(); ) {\n+                    PatternDescription current = it.next();\n+                    Set<PatternDescription> reducedAdded = new HashSet<>(sortedCandidates);\n+\n+                    reducedAdded.remove(current);\n+\n+                    Set<PatternDescription> combinedPatterns =\n+                            joinSets(basePatterns, replace(inMissingPatterns, bp, reducedAdded));\n+\n+                    if (computeCoverage(selectorType, combinedPatterns, true).covered()) {\n+                        it.remove();\n+                    }\n+                }\n+\n+                Set<PatternDescription> currentMissingPatterns =\n+                        replace(inMissingPatterns, toExpand, sortedCandidates);\n+\n+                for (PatternDescription addedPattern : sortedCandidates) {\n+                    if (addedPattern instanceof RecordPattern addedRP) {\n+                        for (int c = 0; c < addedRP.nested.length; c++) {\n+                            currentMissingPatterns = expandMissingPatternDescriptions(selectorType,\n+                                                                                      addedRP.fullComponentTypes[c],\n+                                                                                      addedRP.nested[c],\n+                                                                                      basePatterns,\n+                                                                                      currentMissingPatterns);\n+                        }\n+                    }\n+                }\n+\n+                return currentMissingPatterns;\n+            }\n+        }\n+        return inMissingPatterns;\n+    }\n+\n+    \/*\n+     * Inside any pattern in {@code in}, in any nesting depth, replace\n+     * pattern {@code what} with patterns {@code to}.\n+     *\/\n+    private Set<PatternDescription> replace(Iterable<? extends PatternDescription> in,\n+                                            PatternDescription what,\n+                                            Collection<? extends PatternDescription> to) {\n+        Set<PatternDescription> result = new HashSet<>();\n+\n+        for (PatternDescription pd : in) {\n+            Collection<? extends PatternDescription> replaced = replace(pd, what, to);\n+            if (replaced != null) {\n+                result.addAll(replaced);\n+            } else {\n+                result.add(pd);\n+            }\n+        }\n+\n+        return result;\n+    }\n+    \/\/where:\n+        \/\/null: no change\n+        private Collection<? extends PatternDescription> replace(PatternDescription in,\n+                                                                 PatternDescription what,\n+                                                                 Collection<? extends PatternDescription> to) {\n+            if (in == what) {\n+                return to;\n+            } else if (in instanceof RecordPattern rp) {\n+                for (int c = 0; c < rp.nested.length; c++) {\n+                    Collection<? extends PatternDescription> replaced = replace(rp.nested[c], what, to);\n+                    if (replaced != null) {\n+                        Set<PatternDescription> withReplaced = new HashSet<>();\n+\n+                        generatePatternsWithReplacedNestedPattern(rp, c, replaced, withReplaced::add);\n+\n+                        return replace(withReplaced, what, to);\n+                    }\n+                }\n+                return null;\n+            } else {\n+                return null; \/\/binding patterns have no children\n+            }\n+        }\n+\n+    \/*\n+     * Sort patterns so that those that those that are prefered for removal\n+     * are in front of those that are preferred to remain (when there's a choice).\n+     *\/\n+    private SequencedSet<PatternDescription> partialSortPattern(Set<PatternDescription> candidates,\n+                                                                Set<? extends PatternDescription> basePatterns,\n+                                                                Set<PatternDescription> missingPatterns) {\n+        SequencedSet<PatternDescription> sortedCandidates = new LinkedHashSet<>();\n+\n+        while (!candidates.isEmpty()) {\n+            PatternDescription mostSpecific = null;\n+            for (PatternDescription current : candidates) {\n+                if (mostSpecific == null ||\n+                    shouldAppearBefore(current, mostSpecific, basePatterns, missingPatterns)) {\n+                    mostSpecific = current;\n+                }\n+            }\n+            sortedCandidates.add(mostSpecific);\n+            candidates.remove(mostSpecific);\n+        }\n+        return sortedCandidates;\n+    }\n+    \/\/where:\n+        \/\/true iff pd1 should appear before pd2\n+        \/\/false otherwise\n+        private boolean shouldAppearBefore(PatternDescription pd1,\n+                                           PatternDescription pd2,\n+                                           Set<? extends PatternDescription> basePatterns,\n+                                           Set<? extends PatternDescription> missingPatterns) {\n+            if (pd1 instanceof RecordPattern rp1 && pd2 instanceof RecordPattern rp2) {\n+                for (int c = 0; c < rp1.nested.length; c++) {\n+                    if (shouldAppearBefore((BindingPattern) rp1.nested[c],\n+                                           (BindingPattern) rp2.nested[c],\n+                                           basePatterns,\n+                                           missingPatterns)) {\n+                        return true;\n+                    }\n+                }\n+            } else if (pd1 instanceof BindingPattern bp1 && pd2 instanceof BindingPattern bp2) {\n+                Type t1 = bp1.type();\n+                Type t2 = bp2.type();\n+                boolean t1IsImportantRecord =\n+                        (t1.tsym.flags_field & RECORD) != 0 &&\n+                        hasMatchingRecordPattern(basePatterns, missingPatterns, bp1);\n+                boolean t2IsImportantRecord =\n+                        (t2.tsym.flags_field & RECORD) != 0 &&\n+                        hasMatchingRecordPattern(basePatterns, missingPatterns, bp2);\n+                if (t1IsImportantRecord && !t2IsImportantRecord) {\n+                    return false;\n+                }\n+                if (!t1IsImportantRecord && t2IsImportantRecord) {\n+                    return true;\n+                }\n+                if (!types.isSameType(t1, t2) && types.isSubtype(t1, t2)) {\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+    \/*\n+     * Do the {@code basePatterns} have a record pattern at a place that corresponds to\n+     * position of pattern {@code query} inside {@code missingPatterns}?\n+     *\/\n+    private boolean hasMatchingRecordPattern(Set<? extends PatternDescription> basePatterns,\n+                                             Set<? extends PatternDescription> missingPatterns,\n+                                             PatternDescription query) {\n+        PatternDescription root = findRootContaining(missingPatterns, query);\n+\n+        if (root == null) {\n+            return false;\n+        }\n+        return basePatternsHaveRecordPatternOnThisSpot(basePatterns, root, query);\n+    }\n+    \/\/where:\n+        private PatternDescription findRootContaining(Set<? extends PatternDescription> rootPatterns,\n+                                                      PatternDescription added) {\n+            for (PatternDescription pd : rootPatterns) {\n+                if (isUnderRoot(pd, added)) {\n+                    return pd;\n+                }\n+            }\n+\n+            \/\/assert?\n+            return null;\n+        }\n+\n+        private boolean basePatternsHaveRecordPatternOnThisSpot(Set<? extends PatternDescription> basePatterns,\n+                                                                PatternDescription rootPattern,\n+                                                                PatternDescription added) {\n+            if (rootPattern == added) {\n+                return basePatterns.stream().anyMatch(pd -> pd instanceof RecordPattern);\n+            }\n+            if (!(rootPattern instanceof RecordPattern rootPatternRecord)) {\n+                return false;\n+            }\n+            int index = -1;\n+            for (int c = 0; c < rootPatternRecord.nested.length; c++) {\n+                if (isUnderRoot(rootPatternRecord.nested[c], added)) {\n+                    index = c;\n+                    break;\n+                }\n+            }\n+            Assert.check(index != (-1));\n+\n+            int indexFin = index;\n+            Set<PatternDescription> filteredBasePatterns =\n+                    basePatterns.stream()\n+                                .filter(pd -> pd instanceof RecordPattern)\n+                                .map(rp -> (RecordPattern) rp)\n+                                .filter(rp -> types.isSameType(rp.recordType(), rootPatternRecord.recordType()))\n+                                .map(rp -> rp.nested[indexFin])\n+                                .collect(Collectors.toSet());\n+\n+            return basePatternsHaveRecordPatternOnThisSpot(filteredBasePatterns, rootPatternRecord.nested[index], added);\n+        }\n+\n+        private boolean isUnderRoot(PatternDescription root, PatternDescription searchFor) {\n+            if (root == searchFor) {\n+                return true;\n+            } else if (root instanceof RecordPattern rp) {\n+                for (int c = 0; c < rp.nested.length; c++) {\n+                    if (isUnderRoot(rp.nested[c], searchFor)) {\n+                        return true;\n+                    }\n+                }\n+            }\n+            return false;\n+        }\n+\n+    private Set<PatternDescription> joinSets(Collection<? extends PatternDescription> s1,\n+                                             Collection<? extends PatternDescription> s2) {\n+        Set<PatternDescription> result = new HashSet<>();\n+\n+        result.addAll(s1);\n+        result.addAll(s2);\n+\n+        return result;\n+    }\n+\n+    \/*\n+     * Based on {@code basePattern} generate new {@code RecordPattern}s such that all\n+     * components instead of {@code replaceComponent}th component, which is replaced\n+     * with values from {@code updatedNestedPatterns}. Resulting {@code RecordPatterns}s\n+     * are sent to {@code target}.\n+     *\/\n+    private void generatePatternsWithReplacedNestedPattern(RecordPattern basePattern,\n+                                                           int replaceComponent,\n+                                                           Iterable<? extends PatternDescription> updatedNestedPatterns,\n+                                                           Consumer<RecordPattern> target) {\n+        for (PatternDescription nested : updatedNestedPatterns) {\n+            PatternDescription[] newNested =\n+                    Arrays.copyOf(basePattern.nested, basePattern.nested.length);\n+            newNested[replaceComponent] = nested;\n+            target.accept(new RecordPattern(basePattern.recordType(),\n+                                            basePattern.fullComponentTypes(),\n+                                            newNested));\n+        }\n+    }\n+\n+    protected static class TimeoutException extends RuntimeException {\n+        private static final long serialVersionUID = 0L;\n+        private transient final Set<PatternDescription> missingPatterns;\n+\n+        public TimeoutException(Set<PatternDescription> missingPatterns) {\n+            super(null, null, false, false);\n+            this.missingPatterns = missingPatterns;\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ExhaustivenessComputer.java","additions":1169,"deletions":0,"binary":false,"changes":1169,"status":"added"},{"patch":"@@ -30,2 +30,0 @@\n-import java.util.Map;\n-import java.util.Map.Entry;\n@@ -33,1 +31,0 @@\n-import java.util.HashSet;\n@@ -35,0 +32,1 @@\n+import java.util.TreeSet;\n@@ -36,0 +34,1 @@\n+import java.util.stream.Collectors;\n@@ -54,1 +53,0 @@\n-import com.sun.tools.javac.code.Kinds.Kind;\n@@ -56,1 +54,0 @@\n-import com.sun.tools.javac.code.Type.TypeVar;\n@@ -59,0 +56,1 @@\n+import com.sun.tools.javac.comp.ExhaustivenessComputer.ExhaustivenessResult;\n@@ -62,6 +60,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-\n-import static java.util.stream.Collectors.groupingBy;\n@@ -216,0 +208,1 @@\n+    private final ExhaustivenessComputer exhaustiveness;\n@@ -217,1 +210,0 @@\n-    private final Infer infer;\n@@ -339,1 +331,1 @@\n-        infer = Infer.instance(context);\n+        exhaustiveness = ExhaustivenessComputer.instance(context);\n@@ -342,1 +334,0 @@\n-        Source source = Source.instance(context);\n@@ -712,1 +703,0 @@\n-                tree.isExhaustive |= exhausts(tree.selector, tree.cases);\n@@ -714,1 +704,13 @@\n-                    log.error(tree, Errors.NotExhaustiveStatement);\n+                    ExhaustivenessResult exhaustivenessResult = exhaustiveness.exhausts(tree.selector, tree.cases);\n+\n+                    tree.isExhaustive = exhaustivenessResult.exhaustive();\n+\n+                    if (!tree.isExhaustive) {\n+                        if (exhaustivenessResult.notExhaustiveDetails().isEmpty()) {\n+                            log.error(tree, Errors.NotExhaustiveStatement);\n+                        } else {\n+                            List<JCDiagnostic> details =\n+                                    convertNotExhaustiveDetails(exhaustivenessResult);\n+                            log.error(tree, Errors.NotExhaustiveStatementDetails(details));\n+                        }\n+                    }\n@@ -751,42 +753,1 @@\n-                tree.isExhaustive = exhausts(tree.selector, tree.cases);\n-            }\n-\n-            if (!tree.isExhaustive) {\n-                log.error(tree, Errors.NotExhaustive);\n-            }\n-            alive = prevAlive;\n-            alive = alive.or(resolveYields(tree, prevPendingExits));\n-        }\n-\n-        private boolean exhausts(JCExpression selector, List<JCCase> cases) {\n-            Set<PatternDescription> patternSet = new HashSet<>();\n-            Map<Symbol, Set<Symbol>> enum2Constants = new HashMap<>();\n-            Set<Object> booleanLiterals = new HashSet<>(Set.of(0, 1));\n-            for (JCCase c : cases) {\n-                if (!TreeInfo.unguardedCase(c))\n-                    continue;\n-\n-                for (var l : c.labels) {\n-                    if (l instanceof JCPatternCaseLabel patternLabel) {\n-                        for (Type component : components(selector.type)) {\n-                            patternSet.add(makePatternDescription(component, patternLabel.pat));\n-                        }\n-                    } else if (l instanceof JCConstantCaseLabel constantLabel) {\n-                        if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN)) {\n-                            Object value = ((JCLiteral) constantLabel.expr).value;\n-                            booleanLiterals.remove(value);\n-                        } else {\n-                            Symbol s = TreeInfo.symbol(constantLabel.expr);\n-                            if (s != null && s.isEnum()) {\n-                                enum2Constants.computeIfAbsent(s.owner, x -> {\n-                                    Set<Symbol> result = new HashSet<>();\n-                                    s.owner.members()\n-                                            .getSymbols(sym -> sym.kind == Kind.VAR && sym.isEnum())\n-                                            .forEach(result::add);\n-                                    return result;\n-                                }).remove(s);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n+                ExhaustivenessResult exhaustivenessResult = exhaustiveness.exhausts(tree.selector, tree.cases);\n@@ -794,3 +755,1 @@\n-            if (types.unboxedTypeOrType(selector.type).hasTag(TypeTag.BOOLEAN) && booleanLiterals.isEmpty()) {\n-                return true;\n-            }\n+                tree.isExhaustive = exhaustivenessResult.exhaustive();\n@@ -798,29 +757,3 @@\n-            for (Entry<Symbol, Set<Symbol>> e : enum2Constants.entrySet()) {\n-                if (e.getValue().isEmpty()) {\n-                    patternSet.add(new BindingPattern(e.getKey().type));\n-                }\n-            }\n-            Set<PatternDescription> patterns = patternSet;\n-            boolean useHashes = true;\n-            try {\n-                boolean repeat = true;\n-                while (repeat) {\n-                    Set<PatternDescription> updatedPatterns;\n-                    updatedPatterns = reduceBindingPatterns(selector.type, patterns);\n-                    updatedPatterns = reduceNestedPatterns(updatedPatterns, useHashes);\n-                    updatedPatterns = reduceRecordPatterns(updatedPatterns);\n-                    updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n-                    repeat = !updatedPatterns.equals(patterns);\n-                    if (checkCovered(selector.type, patterns)) {\n-                        return true;\n-                    }\n-                    if (!repeat) {\n-                        \/\/there may be situation like:\n-                        \/\/class B permits S1, S2\n-                        \/\/patterns: R(S1, B), R(S2, S2)\n-                        \/\/this might be joined to R(B, S2), as B could be rewritten to S2\n-                        \/\/but hashing in reduceNestedPatterns will not allow that\n-                        \/\/disable the use of hashing, and use subtyping in\n-                        \/\/reduceNestedPatterns to handle situations like this:\n-                        repeat = useHashes;\n-                        useHashes = false;\n+                if (!tree.isExhaustive) {\n+                    if (exhaustivenessResult.notExhaustiveDetails().isEmpty()) {\n+                        log.error(tree, Errors.NotExhaustive);\n@@ -828,303 +761,3 @@\n-                        \/\/if a reduction happened, make sure hashing in reduceNestedPatterns\n-                        \/\/is enabled, as the hashing speeds up the process significantly:\n-                        useHashes = true;\n-                    }\n-                    patterns = updatedPatterns;\n-                }\n-                return checkCovered(selector.type, patterns);\n-            } catch (CompletionFailure cf) {\n-                chk.completionError(selector.pos(), cf);\n-                return true; \/\/error recovery\n-            }\n-        }\n-\n-        private boolean checkCovered(Type seltype, Iterable<PatternDescription> patterns) {\n-            for (Type seltypeComponent : components(seltype)) {\n-                for (PatternDescription pd : patterns) {\n-                    if(isBpCovered(seltypeComponent, pd)) {\n-                        return true;\n-                    }\n-                }\n-            }\n-            return false;\n-        }\n-\n-        private List<Type> components(Type seltype) {\n-            return switch (seltype.getTag()) {\n-                case CLASS -> {\n-                    if (seltype.isCompound()) {\n-                        if (seltype.isIntersection()) {\n-                            yield ((Type.IntersectionClassType) seltype).getComponents()\n-                                                                        .stream()\n-                                                                        .flatMap(t -> components(t).stream())\n-                                                                        .collect(List.collector());\n-                        }\n-                        yield List.nil();\n-                    }\n-                    yield List.of(types.erasure(seltype));\n-                }\n-                case TYPEVAR -> components(((TypeVar) seltype).getUpperBound());\n-                default -> List.of(types.erasure(seltype));\n-            };\n-        }\n-\n-        \/* In a set of patterns, search for a sub-set of binding patterns that\n-         * in combination exhaust their sealed supertype. If such a sub-set\n-         * is found, it is removed, and replaced with a binding pattern\n-         * for the sealed supertype.\n-         *\/\n-        private Set<PatternDescription> reduceBindingPatterns(Type selectorType, Set<PatternDescription> patterns) {\n-            Set<Symbol> existingBindings = patterns.stream()\n-                                                   .filter(pd -> pd instanceof BindingPattern)\n-                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n-                                                   .collect(Collectors.toSet());\n-\n-            for (PatternDescription pdOne : patterns) {\n-                if (pdOne instanceof BindingPattern bpOne) {\n-                    Set<PatternDescription> toAdd = new HashSet<>();\n-\n-                    for (Type sup : types.directSupertypes(bpOne.type)) {\n-                        ClassSymbol clazz = (ClassSymbol) types.erasure(sup).tsym;\n-\n-                        clazz.complete();\n-\n-                        if (clazz.isSealed() && clazz.isAbstract() &&\n-                            \/\/if a binding pattern for clazz already exists, no need to analyze it again:\n-                            !existingBindings.contains(clazz)) {\n-                            ListBuffer<PatternDescription> bindings = new ListBuffer<>();\n-                            \/\/do not reduce to types unrelated to the selector type:\n-                            Type clazzErasure = types.erasure(clazz.type);\n-                            if (components(selectorType).stream()\n-                                                        .map(types::erasure)\n-                                                        .noneMatch(c -> types.isSubtype(clazzErasure, c))) {\n-                                continue;\n-                            }\n-\n-                            Set<Symbol> permitted = allPermittedSubTypes(clazz, csym -> {\n-                                Type instantiated;\n-                                if (csym.type.allparams().isEmpty()) {\n-                                    instantiated = csym.type;\n-                                } else {\n-                                    instantiated = infer.instantiatePatternType(selectorType, csym);\n-                                }\n-\n-                                return instantiated != null && types.isCastable(selectorType, instantiated);\n-                            });\n-\n-                            for (PatternDescription pdOther : patterns) {\n-                                if (pdOther instanceof BindingPattern bpOther) {\n-                                    Set<Symbol> currentPermittedSubTypes =\n-                                            allPermittedSubTypes(bpOther.type.tsym, s -> true);\n-\n-                                    PERMITTED: for (Iterator<Symbol> it = permitted.iterator(); it.hasNext();) {\n-                                        Symbol perm = it.next();\n-\n-                                        for (Symbol currentPermitted : currentPermittedSubTypes) {\n-                                            if (types.isSubtype(types.erasure(currentPermitted.type),\n-                                                                types.erasure(perm.type))) {\n-                                                it.remove();\n-                                                continue PERMITTED;\n-                                            }\n-                                        }\n-                                        if (types.isSubtype(types.erasure(perm.type),\n-                                                            types.erasure(bpOther.type))) {\n-                                            it.remove();\n-                                        }\n-                                    }\n-                                }\n-                            }\n-\n-                            if (permitted.isEmpty()) {\n-                                toAdd.add(new BindingPattern(clazz.type));\n-                            }\n-                        }\n-                    }\n-\n-                    if (!toAdd.isEmpty()) {\n-                        Set<PatternDescription> newPatterns = new HashSet<>(patterns);\n-                        newPatterns.addAll(toAdd);\n-                        return newPatterns;\n-                    }\n-                }\n-            }\n-            return patterns;\n-        }\n-\n-        private Set<Symbol> allPermittedSubTypes(TypeSymbol root, Predicate<ClassSymbol> accept) {\n-            Set<Symbol> permitted = new HashSet<>();\n-            List<ClassSymbol> permittedSubtypesClosure = baseClasses(root);\n-\n-            while (permittedSubtypesClosure.nonEmpty()) {\n-                ClassSymbol current = permittedSubtypesClosure.head;\n-\n-                permittedSubtypesClosure = permittedSubtypesClosure.tail;\n-\n-                current.complete();\n-\n-                if (current.isSealed() && current.isAbstract()) {\n-                    for (Type t : current.getPermittedSubclasses()) {\n-                        ClassSymbol csym = (ClassSymbol) t.tsym;\n-\n-                        if (accept.test(csym)) {\n-                            permittedSubtypesClosure = permittedSubtypesClosure.prepend(csym);\n-                            permitted.add(csym);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            return permitted;\n-        }\n-\n-        private List<ClassSymbol> baseClasses(TypeSymbol root) {\n-            if (root instanceof ClassSymbol clazz) {\n-                return List.of(clazz);\n-            } else if (root instanceof TypeVariableSymbol tvar) {\n-                ListBuffer<ClassSymbol> result = new ListBuffer<>();\n-                for (Type bound : tvar.getBounds()) {\n-                    result.appendList(baseClasses(bound.tsym));\n-                }\n-                return result.toList();\n-            } else {\n-                return List.nil();\n-            }\n-        }\n-\n-        \/* Among the set of patterns, find sub-set of patterns such:\n-         * $record($prefix$, $nested, $suffix$)\n-         * Where $record, $prefix$ and $suffix$ is the same for each pattern\n-         * in the set, and the patterns only differ in one \"column\" in\n-         * the $nested pattern.\n-         * Then, the set of $nested patterns is taken, and passed recursively\n-         * to reduceNestedPatterns and to reduceBindingPatterns, to\n-         * simplify the pattern. If that succeeds, the original found sub-set\n-         * of patterns is replaced with a new set of patterns of the form:\n-         * $record($prefix$, $resultOfReduction, $suffix$)\n-         *\n-         * useHashes: when true, patterns will be subject to exact equivalence;\n-         *            when false, two binding patterns will be considered equivalent\n-         *            if one of them is more generic than the other one;\n-         *            when false, the processing will be significantly slower,\n-         *            as pattern hashes cannot be used to speed up the matching process\n-         *\/\n-        private Set<PatternDescription> reduceNestedPatterns(Set<PatternDescription> patterns,\n-                                                             boolean useHashes) {\n-            \/* implementation note:\n-             * finding a sub-set of patterns that only differ in a single\n-             * column is time-consuming task, so this method speeds it up by:\n-             * - group the patterns by their record class\n-             * - for each column (nested pattern) do:\n-             * -- group patterns by their hash\n-             * -- in each such by-hash group, find sub-sets that only differ in\n-             *    the chosen column, and then call reduceBindingPatterns and reduceNestedPatterns\n-             *    on patterns in the chosen column, as described above\n-             *\/\n-            var groupByRecordClass =\n-                    patterns.stream()\n-                            .filter(pd -> pd instanceof RecordPattern)\n-                            .map(pd -> (RecordPattern) pd)\n-                            .collect(groupingBy(pd -> (ClassSymbol) pd.recordType.tsym));\n-\n-            for (var e : groupByRecordClass.entrySet()) {\n-                int nestedPatternsCount = e.getKey().getRecordComponents().size();\n-                Set<RecordPattern> current = new HashSet<>(e.getValue());\n-\n-                for (int mismatchingCandidate = 0;\n-                     mismatchingCandidate < nestedPatternsCount;\n-                     mismatchingCandidate++) {\n-                    int mismatchingCandidateFin = mismatchingCandidate;\n-                    var groupEquivalenceCandidates =\n-                            current\n-                             .stream()\n-                             \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n-                             .filter(pd -> pd.nested.length == nestedPatternsCount)\n-                             .collect(groupingBy(pd -> useHashes ? pd.hashCode(mismatchingCandidateFin) : 0));\n-                    for (var candidates : groupEquivalenceCandidates.values()) {\n-                        var candidatesArr = candidates.toArray(RecordPattern[]::new);\n-\n-                        for (int firstCandidate = 0;\n-                             firstCandidate < candidatesArr.length;\n-                             firstCandidate++) {\n-                            RecordPattern rpOne = candidatesArr[firstCandidate];\n-                            ListBuffer<RecordPattern> join = new ListBuffer<>();\n-\n-                            join.append(rpOne);\n-\n-                            NEXT_PATTERN: for (int nextCandidate = 0;\n-                                               nextCandidate < candidatesArr.length;\n-                                               nextCandidate++) {\n-                                if (firstCandidate == nextCandidate) {\n-                                    continue;\n-                                }\n-\n-                                RecordPattern rpOther = candidatesArr[nextCandidate];\n-                                if (rpOne.recordType.tsym == rpOther.recordType.tsym) {\n-                                    for (int i = 0; i < rpOne.nested.length; i++) {\n-                                        if (i != mismatchingCandidate) {\n-                                            if (!rpOne.nested[i].equals(rpOther.nested[i])) {\n-                                                if (useHashes ||\n-                                                    \/\/when not using hashes,\n-                                                    \/\/check if rpOne.nested[i] is\n-                                                    \/\/a subtype of rpOther.nested[i]:\n-                                                    !(rpOne.nested[i] instanceof BindingPattern bpOne) ||\n-                                                    !(rpOther.nested[i] instanceof BindingPattern bpOther) ||\n-                                                    !types.isSubtype(types.erasure(bpOne.type), types.erasure(bpOther.type))) {\n-                                                    continue NEXT_PATTERN;\n-                                                }\n-                                            }\n-                                        }\n-                                    }\n-                                    join.append(rpOther);\n-                                }\n-                            }\n-\n-                            var nestedPatterns = join.stream().map(rp -> rp.nested[mismatchingCandidateFin]).collect(Collectors.toSet());\n-                            var updatedPatterns = reduceNestedPatterns(nestedPatterns, useHashes);\n-\n-                            updatedPatterns = reduceRecordPatterns(updatedPatterns);\n-                            updatedPatterns = removeCoveredRecordPatterns(updatedPatterns);\n-                            updatedPatterns = reduceBindingPatterns(rpOne.fullComponentTypes()[mismatchingCandidateFin], updatedPatterns);\n-\n-                            if (!nestedPatterns.equals(updatedPatterns)) {\n-                                if (useHashes) {\n-                                    current.removeAll(join);\n-                                }\n-\n-                                for (PatternDescription nested : updatedPatterns) {\n-                                    PatternDescription[] newNested =\n-                                            Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                                    newNested[mismatchingCandidateFin] = nested;\n-                                    current.add(new RecordPattern(rpOne.recordType(),\n-                                                                    rpOne.fullComponentTypes(),\n-                                                                    newNested));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                if (!current.equals(new HashSet<>(e.getValue()))) {\n-                    Set<PatternDescription> result = new HashSet<>(patterns);\n-                    result.removeAll(e.getValue());\n-                    result.addAll(current);\n-                    return result;\n-                }\n-            }\n-            return patterns;\n-        }\n-\n-        \/* In the set of patterns, find those for which, given:\n-         * $record($nested1, $nested2, ...)\n-         * all the $nestedX pattern cover the given record component,\n-         * and replace those with a simple binding pattern over $record.\n-         *\/\n-        private Set<PatternDescription> reduceRecordPatterns(Set<PatternDescription> patterns) {\n-            var newPatterns = new HashSet<PatternDescription>();\n-            boolean modified = false;\n-            for (PatternDescription pd : patterns) {\n-                if (pd instanceof RecordPattern rpOne) {\n-                    PatternDescription reducedPattern = reduceRecordPattern(rpOne);\n-                    if (reducedPattern != rpOne) {\n-                        newPatterns.add(reducedPattern);\n-                        modified = true;\n-                        continue;\n+                        List<JCDiagnostic> details =\n+                                convertNotExhaustiveDetails(exhaustivenessResult);\n+                        log.error(tree, Errors.NotExhaustiveDetails(details));\n@@ -1133,1 +766,0 @@\n-                newPatterns.add(pd);\n@@ -1135,2 +767,0 @@\n-            return modified ? newPatterns : patterns;\n-        }\n@@ -1138,27 +768,2 @@\n-        private PatternDescription reduceRecordPattern(PatternDescription pattern) {\n-            if (pattern instanceof RecordPattern rpOne) {\n-                Type[] componentType = rpOne.fullComponentTypes();\n-                \/\/error recovery, ignore patterns with incorrect number of nested patterns:\n-                if (componentType.length != rpOne.nested.length) {\n-                    return pattern;\n-                }\n-                PatternDescription[] reducedNestedPatterns = null;\n-                boolean covered = true;\n-                for (int i = 0; i < componentType.length; i++) {\n-                    PatternDescription newNested = reduceRecordPattern(rpOne.nested[i]);\n-                    if (newNested != rpOne.nested[i]) {\n-                        if (reducedNestedPatterns == null) {\n-                            reducedNestedPatterns = Arrays.copyOf(rpOne.nested, rpOne.nested.length);\n-                        }\n-                        reducedNestedPatterns[i] = newNested;\n-                    }\n-\n-                    covered &= checkCovered(componentType[i], List.of(newNested));\n-                }\n-                if (covered) {\n-                    return new BindingPattern(rpOne.recordType);\n-                } else if (reducedNestedPatterns != null) {\n-                    return new RecordPattern(rpOne.recordType, rpOne.fullComponentTypes(), reducedNestedPatterns);\n-                }\n-            }\n-            return pattern;\n+            alive = prevAlive;\n+            alive = alive.or(resolveYields(tree, prevPendingExits));\n@@ -1167,15 +772,6 @@\n-        private Set<PatternDescription> removeCoveredRecordPatterns(Set<PatternDescription> patterns) {\n-            Set<Symbol> existingBindings = patterns.stream()\n-                                                   .filter(pd -> pd instanceof BindingPattern)\n-                                                   .map(pd -> ((BindingPattern) pd).type.tsym)\n-                                                   .collect(Collectors.toSet());\n-            Set<PatternDescription> result = new HashSet<>(patterns);\n-\n-            for (Iterator<PatternDescription> it = result.iterator(); it.hasNext();) {\n-                PatternDescription pd = it.next();\n-                if (pd instanceof RecordPattern rp && existingBindings.contains(rp.recordType.tsym)) {\n-                    it.remove();\n-                }\n-            }\n-\n-            return result;\n+        private List<JCDiagnostic> convertNotExhaustiveDetails(ExhaustivenessResult exhaustivenessResult) {\n+            return exhaustivenessResult.notExhaustiveDetails()\n+                                       .stream()\n+                                       .sorted()\n+                                       .map(detail -> diags.fragment(Fragments.NotExhaustiveDetail(detail)))\n+                                       .collect(List.collector());\n@@ -1329,12 +925,0 @@\n-    private boolean isBpCovered(Type componentType, PatternDescription newNested) {\n-        if (newNested instanceof BindingPattern bp) {\n-            Type seltype = types.erasure(componentType);\n-            Type pattype = types.erasure(bp.type);\n-\n-            return seltype.isPrimitive() ?\n-                    types.isUnconditionallyExact(seltype, pattype) :\n-                    (bp.type.isPrimitive() && types.isUnconditionallyExact(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n-        }\n-        return false;\n-    }\n-\n@@ -3476,89 +3060,0 @@\n-    sealed interface PatternDescription { }\n-    public PatternDescription makePatternDescription(Type selectorType, JCPattern pattern) {\n-        if (pattern instanceof JCBindingPattern binding) {\n-            Type type = !selectorType.isPrimitive() && types.isSubtype(selectorType, binding.type)\n-                    ? selectorType : binding.type;\n-            return new BindingPattern(type);\n-        } else if (pattern instanceof JCRecordPattern record) {\n-            Type[] componentTypes;\n-\n-            if (!record.type.isErroneous()) {\n-                componentTypes = ((ClassSymbol) record.type.tsym).getRecordComponents()\n-                        .map(r -> types.memberType(record.type, r))\n-                        .toArray(s -> new Type[s]);\n-            }\n-            else {\n-                componentTypes = record.nested.map(t -> types.createErrorType(t.type)).toArray(s -> new Type[s]);;\n-            }\n-\n-            PatternDescription[] nestedDescriptions =\n-                    new PatternDescription[record.nested.size()];\n-            int i = 0;\n-            for (List<JCPattern> it = record.nested;\n-                 it.nonEmpty();\n-                 it = it.tail, i++) {\n-                Type componentType = i < componentTypes.length ? componentTypes[i]\n-                                                               : syms.errType;\n-                nestedDescriptions[i] = makePatternDescription(types.erasure(componentType), it.head);\n-            }\n-            return new RecordPattern(record.type, componentTypes, nestedDescriptions);\n-        } else if (pattern instanceof JCAnyPattern) {\n-            return new BindingPattern(selectorType);\n-        } else {\n-            throw Assert.error();\n-        }\n-    }\n-    record BindingPattern(Type type) implements PatternDescription {\n-        @Override\n-        public int hashCode() {\n-            return type.tsym.hashCode();\n-        }\n-        @Override\n-        public boolean equals(Object o) {\n-            return o instanceof BindingPattern other &&\n-                    type.tsym == other.type.tsym;\n-        }\n-        @Override\n-        public String toString() {\n-            return type.tsym + \" _\";\n-        }\n-    }\n-    record RecordPattern(Type recordType, int _hashCode, Type[] fullComponentTypes, PatternDescription... nested) implements PatternDescription {\n-\n-        public RecordPattern(Type recordType, Type[] fullComponentTypes, PatternDescription[] nested) {\n-            this(recordType, hashCode(-1, recordType, nested), fullComponentTypes, nested);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            return _hashCode;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            return o instanceof RecordPattern other &&\n-                    recordType.tsym == other.recordType.tsym &&\n-                    Arrays.equals(nested, other.nested);\n-        }\n-\n-        public int hashCode(int excludeComponent) {\n-            return hashCode(excludeComponent, recordType, nested);\n-        }\n-\n-        public static int hashCode(int excludeComponent, Type recordType, PatternDescription... nested) {\n-            int hash = 5;\n-            hash =  41 * hash + recordType.tsym.hashCode();\n-            for (int  i = 0; i < nested.length; i++) {\n-                if (i != excludeComponent) {\n-                    hash = 41 * hash + nested[i].hashCode();\n-                }\n-            }\n-            return hash;\n-        }\n-        @Override\n-        public String toString() {\n-            return recordType.tsym + \"(\" + Arrays.stream(nested)\n-                    .map(pd -> pd.toString())\n-                    .collect(Collectors.joining(\", \")) + \")\";\n-        }\n-    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":34,"deletions":539,"binary":false,"changes":573,"status":"modified"},{"patch":"@@ -1476,0 +1476,14 @@\n+# 0: list of diagnostic\n+compiler.err.not.exhaustive.details=\\\n+    the switch expression does not cover all possible input values\\n\\\n+    missing patterns: {0}\n+\n+# 0: list of diagnostic\n+compiler.err.not.exhaustive.statement.details=\\\n+    the switch statement does not cover all possible input values\\n\\\n+    missing patterns: {0}\n+\n+# 0: string\n+compiler.misc.not.exhaustive.detail=\\\n+    \\n{0}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\/\/ options: -XDexhaustivityTimeout=0\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustive.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.not.exhaustive.details\n+\/\/ options: -XDexhaustivityTimeout=-1\n+\n+class NotExhaustiveDetails {\n+    int t(int i) {\n+        return switch (i) {\n+            case 0 -> -1;\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveDetails.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\/\/ options: -XDexhaustivityTimeout=0\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveStatement.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.not.exhaustive.statement.details\n+\/\/ options: -XDexhaustivityTimeout=-1\n+\n+class NotExhaustiveDetails {\n+    void t(Object o) {\n+        switch (o) {\n+            case String s -> System.err.println(\"String of length: \" + s.length());\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/NotExhaustiveStatementDetails.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169 8327368\n+ * @bug 8262891 8268871 8274363 8281100 8294670 8311038 8311815 8325215 8333169 8327368 8364991\n@@ -1639,1 +1639,2 @@\n-        variants.remove((int) (Math.random() * variants.size()));\n+        int removed = (int) (Math.random() * variants.size());\n+        variants.remove(removed);\n@@ -1642,1 +1643,1 @@\n-        System.err.println(\"analyzing:\");\n+        System.err.println(\"analyzing (removed: \" + removed + \"):\");\n@@ -2185,0 +2186,93 @@\n+    @Test \/\/JDK-8364991\n+    public void testDifferentReductionPaths(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2 _) -> 0; \/\/functionally equivalent to: Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _))\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8364991\n+    public void testDifferentReductionPathsSimplified(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test1(Root r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   private int test2(Root r) {\n+                       return switch (r) {\n+                           case Root(R2(R1 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R2 _), R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2 _,     R2(R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1) implements Base {}\n+                   record Root(R2 b2, R2 b3) {}\n+               }\n+               \"\"\");\n+    }\n+\n+    @Test \/\/JDK-8364991\n+    public void testBindingPatternDoesNotStandInPlaceOfRecordPatterns(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R2 _, R2(R1 _)) -> 0;\n+                           case Root(R2(R1 _), R2(R2 _)) -> 0;\n+                           case Root(R2(R2 _), R2 _) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b) implements Base {}\n+                   record Root(R2 b2, R2 b3) {}\n+               }\n+               \"\"\",\n+               \"Test.java:4:16: compiler.err.not.exhaustive\",\n+               \"1 error\");\n+    }\n+\n@@ -2221,0 +2315,1 @@\n+                             \"-XDexhaustivityTimeout=0\",\n","filename":"test\/langtools\/tools\/javac\/patterns\/Exhaustiveness.java","additions":99,"deletions":4,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -0,0 +1,541 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8367530\n+ * @summary Check enhanced exhaustiveness errors\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ExhaustivenessConvenientErrors\n+*\/\n+\n+import com.sun.tools.javac.api.ClientCodeWrapper.DiagnosticSourceUnwrapper;\n+import com.sun.tools.javac.util.JCDiagnostic;\n+import com.sun.tools.javac.util.JCDiagnostic.Fragment;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class ExhaustivenessConvenientErrors extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new ExhaustivenessConvenientErrors().runTests();\n+    }\n+\n+    ExhaustivenessConvenientErrors() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testExhaustiveSealedClasses(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"lib.B _\");\n+    }\n+\n+    @Test\n+    public void testExhaustiveSealedClassesTransitive(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S1 permits S2, A {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public sealed interface S2 extends S1 permits S3, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public sealed interface S3 extends S2 permits C, D {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S1 {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S2 {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class C implements S3 {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class D implements S3 {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(S1 obj) {\n+                       return switch (obj) {\n+                           case A a -> 0;\n+                           case B a -> 0;\n+                           case D a -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"lib.C _\");\n+    }\n+\n+    @Test\n+    public void testTrivialRecord(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record R(S s) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"lib.R(lib.B _)\");\n+    }\n+\n+    @Test\n+    public void testNonNestedRecord(Path base) throws Exception {\n+        doTest(base,\n+               new String[]{\"\"\"\n+                            package lib;\n+                            public sealed interface S permits A, B {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class A implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public final class B implements S {}\n+                            \"\"\",\n+                            \"\"\"\n+                            package lib;\n+                            public record R(S s1, S s2) {}\n+                            \"\"\"},\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(A a, B b) -> 0;\n+                           case R(B b, A a) -> 0;\n+                       };\n+                   }\n+               }\n+               \"\"\",\n+               \"lib.R(lib.A _, lib.A _)\",\n+               \"lib.R(lib.B _, lib.B _)\");\n+    }\n+\n+    @Test\n+    public void testComplex1(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2() implements Base {}\n+                   record R3(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\",\n+               \"test.Test.Root(test.Test.R2 _, test.Test.Base _, test.Test.Base _)\",\n+               \"test.Test.Root(test.Test.R3 _, test.Test.Base _, test.Test.Base _)\");\n+    }\n+\n+    @Test\n+    public void testComplex2(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+\/\/                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\",\n+               \"test.Test.Root(test.Test.R2 _, test.Test.R2(test.Test.R2 _, test.Test.R2 _), test.Test.R2(test.Test.R2 _, test.Test.R2 _))\");\n+    }\n+\n+    @Test\n+    public void testComplex3(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Triple p) {\n+                       return switch (p) {\n+                           case Triple(B _, _, _) -> 0;\n+                           case Triple(_, A _, _) -> 0;\n+                           case Triple(_, _, A _) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseA _), _) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseB _), C(Underneath _, NestedBaseA _)) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseB _), C(Underneath _, NestedBaseB _)) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseB _), C(Underneath _, NestedBaseC _)) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseC _), C(Underneath _, NestedBaseA _)) -> 0;\n+                           case Triple(A p, C(Nested _, NestedBaseC _), C(Underneath _, NestedBaseB _)) -> 0;\n+\/\/                           case Path(A p, C(Nested _, NestedBaseC _), C(Underneath _, NestedBaseC _)) -> 0;\n+                       };\n+                   }\n+                   record Triple(Base c1, Base c2, Base c3) {}\n+                   sealed interface Base permits A, B {}\n+                   record A(boolean key) implements Base {\n+                   }\n+                   sealed interface B extends Base {}\n+                   record C(Nested n, NestedBase b) implements B {}\n+                   record Nested() {}\n+                   sealed interface NestedBase {}\n+                   record NestedBaseA() implements NestedBase {}\n+                   record NestedBaseB() implements NestedBase {}\n+                   record NestedBaseC() implements NestedBase {}\n+               }\n+               \"\"\",\n+               \"test.Test.Triple(test.Test.A _, test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _), test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _))\");\n+    }\n+\n+    @Test\n+    public void testComplex4(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               import lib.*;\n+               public class Test {\n+                   private int test(Root r) {\n+                       return switch (r) {\n+                           case Root(R1 _, _, _) -> 0;\n+                           case Root(R2 _, R1 _, _) -> 0;\n+                           case Root(R2 _, R2 _, R1 _) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+\/\/                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R1 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R1 _), R2(R2 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R1 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R1 _, R2 _)) -> 0;\n+                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R1 _)) -> 0;\n+\/\/                           case Root(R2 _, R2(R2 _, R2 _), R2(R2 _, R2 _)) -> 0;\n+                       };\n+                   }\n+                   sealed interface Base {}\n+                   record R1() implements Base {}\n+                   record R2(Base b1, Base b2) implements Base {}\n+                   record Root(Base b1, Base b2, Base b3) {}\n+               }\n+               \"\"\",\n+               \"test.Test.Root(test.Test.R2 _, test.Test.R2(test.Test.Base _, test.Test.R2 _), test.Test.R2(test.Test.R2 _, test.Test.Base _))\");\n+               \/\/ideally, the result would be as follow, but it is difficult to split Base on two distinct places:\n+\/\/               \"test.Test.Root(test.Test.R2 _, test.Test.R2(test.Test.R1 _, test.Test.R2 _), test.Test.R2(test.Test.R2 _, test.Test.R1 _))\",\n+\/\/               \"test.Test.Root(test.Test.R2 _, test.Test.R2(test.Test.R2 _, test.Test.R2 _), test.Test.R2(test.Test.R2 _, test.Test.R2 _))\");\n+    }\n+\n+    @Test\n+    public void testComplex5(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Triple p) {\n+                       return switch (p) {\n+                           case Triple(B _, _, _) -> 0;\n+                           case Triple(_, A _, _) -> 0;\n+                           case Triple(_, _, A _) -> 0;\n+\/\/                           case Triple(A _, C(Nested _, NestedBaseA _), _) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseB _), C(Nested _, NestedBaseA _)) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseB _), C(Nested _, NestedBaseB _)) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseB _), C(Nested _, NestedBaseC _)) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseC _), C(Nested _, NestedBaseA _)) -> 0;\n+                           case Triple(A _, C(Nested _, NestedBaseC _), C(Nested _, NestedBaseB _)) -> 0;\n+\/\/                           case Path(A _, C(Nested _, NestedBaseC _), C(Nested _, NestedBaseC _)) -> 0;\n+                       };\n+                   }\n+                   record Triple(Base c1, Base c2, Base c3) {}\n+                   sealed interface Base permits A, B {}\n+                   record A(boolean key) implements Base {\n+                   }\n+                   sealed interface B extends Base {}\n+                   record C(Nested n, NestedBase b) implements B {}\n+                   record Nested() {}\n+                   sealed interface NestedBase {}\n+                   record NestedBaseA() implements NestedBase {}\n+                   record NestedBaseB() implements NestedBase {}\n+                   record NestedBaseC() implements NestedBase {}\n+               }\n+               \"\"\",\n+               \"test.Test.Triple(test.Test.A _, test.Test.C(test.Test.Nested _, test.Test.NestedBaseA _), test.Test.C _)\",\n+               \/\/the following could be:\n+               \/\/test.Test.Triple(test.Test.A _, test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _), test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _))\n+               \"test.Test.Triple(test.Test.A _, test.Test.C(test.Test.Nested _, test.Test.NestedBaseC _), test.Test.C _)\");\n+    }\n+\n+    @Test\n+    public void testNoInfiniteRecursion(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(R r) {\n+                       return switch (r) {\n+                           case R(_, _, R(_, _, _, _), String s) -> 0;\n+                           case R(_, _, R(_, _, _, String str), _) -> 0;\n+                       };\n+                   }\n+               }\n+               public record R(R r1, R r2, R r3, Object o) {}\n+               \"\"\",\n+               \"test.R(test.R _, test.R _, test.R(test.R _, test.R _, test.R _, java.lang.Object _), java.lang.Object _)\");\n+    }\n+\n+    @Test\n+    public void testEnum(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(I i) {\n+                       return switch (i) {\n+                           case E.A -> 0;\n+                           case C _ -> 1;\n+                       };\n+                   }\n+                   sealed interface I {}\n+                   enum E implements I {A, B}\n+                   final class C implements I {}\n+               }\n+               public record R(R r1, R r2, R r3, Object o) {}\n+               \"\"\",\n+               \"test.Test.E.B\");\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(I i) {\n+                       return switch (i) {\n+                           case C _ -> 1;\n+                       };\n+                   }\n+                   sealed interface I {}\n+                   enum E implements I {A, B}\n+                   final class C implements I {}\n+               }\n+               public record R(R r1, R r2, R r3, Object o) {}\n+               \"\"\",\n+               \"test.Test.E _\");\n+    }\n+\n+    @Test\n+    public void testInstantiateComponentTypes(Path base) throws Exception {\n+        doTest(base,\n+               new String[0],\n+               \"\"\"\n+               package test;\n+               public class Test {\n+                   private int test(Pair<Base<Base>> p) {\n+                       return switch (p) {\n+                           case Pair(A(A(_)) -> 0;\n+                           case Pair(A(B(_)) -> 0;\n+                           case Pair(B(A(_)) -> 0;\n+                       };\n+                   }\n+                   record Pair<T>(T c) {}\n+                   sealed interface Base<T> permits A, B {}\n+                   record A<T>(T c) implements Base<T> {}\n+                   record B<T>(T c) implements Base<T> {}\n+               }\n+               \"\"\",\n+               \"test.Test.Pair(test.Test.B(test.Test.B _))\");\n+    }\n+\n+    private void doTest(Path base, String[] libraryCode, String testCode, String... expectedMissingPatterns) throws IOException {\n+        Path current = base.resolve(\".\");\n+        Path libClasses = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+\n+        if (libraryCode.length != 0) {\n+            Path libSrc = current.resolve(\"lib-src\");\n+\n+            for (String code : libraryCode) {\n+                tb.writeJavaFiles(libSrc, code);\n+            }\n+\n+            new JavacTask(tb)\n+                    .outdir(libClasses)\n+                    .files(tb.findJavaFiles(libSrc))\n+                    .run();\n+        }\n+\n+        Path src = current.resolve(\"src\");\n+        tb.writeJavaFiles(src, testCode);\n+\n+        Path classes = current.resolve(\"libClasses\");\n+\n+        Files.createDirectories(libClasses);\n+        Set<String> missingPatterns = new HashSet<>();\n+\n+        new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"-XDdev\",\n+                     \"-Xlint:-preview\",\n+                     \"--class-path\", libClasses.toString(),\n+                     \"-XDshould-stop.at=FLOW\",\n+                     \"-XDshould-stop.ifNoError=FLOW\",\n+                     \"-XDexhaustivityTimeout=\" + Long.MAX_VALUE) \/\/never timeout\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .diagnosticListener(d -> {\n+                if (\"compiler.err.not.exhaustive.details\".equals(d.getCode())) {\n+                    if (d instanceof DiagnosticSourceUnwrapper uw) {\n+                        d = uw.d;\n+                    }\n+                    if (d instanceof JCDiagnostic diag) {\n+                        ((Collection<JCDiagnostic>) diag.getArgs()[0])\n+                                .stream()\n+                                .map(fragment -> (String) fragment.getArgs()[0])\n+                                .forEach(missingPatterns::add);\n+                    }\n+                }\n+            })\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Set<String> expectedPatterns = new HashSet<>(List.of(expectedMissingPatterns));\n+\n+        if (!expectedPatterns.equals(missingPatterns)) {\n+            throw new AssertionError(\"Incorrect errors, expected: \" + expectedPatterns +\n+                                      \", actual: \" + missingPatterns);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/ExhaustivenessConvenientErrors.java","additions":541,"deletions":0,"binary":false,"changes":541,"status":"added"},{"patch":"@@ -106,0 +106,1 @@\n+                .withOption(\"-XDexhaustivityTimeout=0\")\n@@ -111,0 +112,1 @@\n+                .withOption(\"-XDexhaustivityTimeout=0\")\n@@ -116,0 +118,1 @@\n+                .withOption(\"-XDexhaustivityTimeout=0\")\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveInstanceOfComboTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n- * @compile\/fail\/ref=PrimitivePatternsSwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitivePatternsSwitchErrors.java\n+ * @compile\/fail\/ref=PrimitivePatternsSwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW -XDexhaustivityTimeout=0 PrimitivePatternsSwitchErrors.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=SwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW SwitchErrors.java\n+ * @compile\/fail\/ref=SwitchErrors.out -XDrawDiagnostics -XDshould-stop.at=FLOW -XDexhaustivityTimeout=0 SwitchErrors.java\n","filename":"test\/langtools\/tools\/javac\/patterns\/SwitchErrors.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,3 +29,3 @@\n- * @compile\/fail\/ref=NonExportedPermittedTypes.out -XDrawDiagnostics NonExportedPermittedTypes.java\n- * @compile\/fail\/ref=NonExportedPermittedTypes.out --release 21 -XDrawDiagnostics NonExportedPermittedTypes.java\n- * @compile\/fail\/ref=NonExportedPermittedTypes.out --release ${jdk.version} -XDrawDiagnostics NonExportedPermittedTypes.java\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out -XDrawDiagnostics -XDexhaustivityTimeout=0 NonExportedPermittedTypes.java\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out --release 21 -XDrawDiagnostics -XDexhaustivityTimeout=0 NonExportedPermittedTypes.java\n+ * @compile\/fail\/ref=NonExportedPermittedTypes.out --release ${jdk.version} -XDrawDiagnostics -XDexhaustivityTimeout=0 NonExportedPermittedTypes.java\n","filename":"test\/langtools\/tools\/javac\/platform\/NonExportedPermittedTypes.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * @compile\/fail\/ref=ExpressionSwitchNotExhaustive.out -XDrawDiagnostics ExpressionSwitchNotExhaustive.java\n+ * @compile\/fail\/ref=ExpressionSwitchNotExhaustive.out -XDrawDiagnostics -XDexhaustivityTimeout=0 ExpressionSwitchNotExhaustive.java\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExpressionSwitchNotExhaustive.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}