{"files":[{"patch":"@@ -1006,0 +1006,2 @@\n+  ZArray<ZVirtualMemory> vmems;\n+\n@@ -1007,1 +1009,4 @@\n-  const ZVirtualMemory vmem = claim_virtual(size);\n+  const size_t claimed_size = claim_virtual(size, &vmems);\n+\n+  \/\/ The partition must have size available in virtual memory when priming.\n+  assert(claimed_size == size, \"must succeed %zx == %zx\", claimed_size, size);\n@@ -1010,1 +1015,1 @@\n-  increase_capacity(size);\n+  increase_capacity(claimed_size);\n@@ -1012,2 +1017,3 @@\n-  \/\/ Claim the backing physical memory\n-  claim_physical(vmem);\n+  for (ZVirtualMemory vmem : vmems) {\n+    \/\/ Claim the backing physical memory\n+    claim_physical(vmem);\n@@ -1015,2 +1021,2 @@\n-  \/\/ Commit the claimed physical memory\n-  const size_t committed = commit_physical(vmem);\n+    \/\/ Commit the claimed physical memory\n+    const size_t committed = commit_physical(vmem);\n@@ -1018,4 +1024,4 @@\n-  if (committed != vmem.size()) {\n-    \/\/ This is a failure state. We do not cleanup the maybe partially committed memory.\n-    return false;\n-  }\n+    if (committed != vmem.size()) {\n+      \/\/ This is a failure state. We do not cleanup the maybe partially committed memory.\n+      return false;\n+    }\n@@ -1023,1 +1029,1 @@\n-  map_virtual(vmem);\n+    map_virtual(vmem);\n@@ -1025,1 +1031,1 @@\n-  check_numa_mismatch(vmem, _numa_id);\n+    check_numa_mismatch(vmem, _numa_id);\n@@ -1027,5 +1033,5 @@\n-  if (AlwaysPreTouch) {\n-    \/\/ Pre-touch memory\n-    ZPreTouchTask task(vmem.start(), vmem.end());\n-    workers->run_all(&task);\n-  }\n+    if (AlwaysPreTouch) {\n+      \/\/ Pre-touch memory\n+      ZPreTouchTask task(vmem.start(), vmem.end());\n+      workers->run_all(&task);\n+    }\n@@ -1033,3 +1039,4 @@\n-  \/\/ We don't have to take a lock here as no other threads will access the cache\n-  \/\/ until we're finished\n-  _cache.insert(vmem);\n+    \/\/ We don't have to take a lock here as no other threads will access the cache\n+    \/\/ until we're finished\n+    _cache.insert(vmem);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":27,"deletions":20,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -42,3 +42,1 @@\n-         *  Xms is picked so that it is less than '16 * Xmx \/ ZForceDiscontiguousHeapReservations' as ZGC\n-         *   cannot currently handle a discontiguous heap with an initial size larger than the individual\n-         *   reservations.\n+         *  Xms is picked to be the same as Xmx\n@@ -47,1 +45,1 @@\n-        final int XmsInM = Math.min(16 * XmxInM \/ (n + 1), XmxInM);\n+        final int XmsInM = XmxInM;\n","filename":"test\/hotspot\/jtreg\/gc\/z\/TestZForceDiscontiguousHeapReservations.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}