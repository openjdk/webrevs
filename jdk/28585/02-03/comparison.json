{"files":[{"patch":"@@ -703,1 +703,1 @@\n-   do_alias(    isCompileConstant_signature,                      object_int_signature)                                 \\\n+   do_alias(    isCompileConstant_signature,                      object_boolean_signature)                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8926,1 +8926,1 @@\n-  set_result(n->is_Con() ? intcon(1) : intcon(2));\n+  set_result(n->is_Con() ? intcon(1) : intcon(0));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-        if (MethodHandleImpl.isCompileConstant(mh) == MethodHandleImpl.CONSTANT_YES) {\n+        if (MethodHandleImpl.isCompileConstant(mh)) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -624,6 +624,3 @@\n-    static final int CONSTANT_PENDING = 0;\n-    static final int CONSTANT_YES = 1;\n-    static final int CONSTANT_NO = 2;\n-\n-    \/\/ Intrinsified by C2. Returns 0 if not ready, 1 if obj is a compile-time constant,\n-    \/\/ 2 if obj is not a compile-time constant.\n+    \/\/ Intrinsified by C2. Returns true if obj is a compile-time constant.\n+    \/\/ Note that a non-constant value may be subsequently promoted to a constant,\n+    \/\/ so a false return value does not indicate obj is definitely not a constant.\n@@ -632,2 +629,2 @@\n-    static int isCompileConstant(Object obj) {\n-        return CONSTANT_PENDING;\n+    static boolean isCompileConstant(Object obj) {\n+        return false;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2019,3 +2019,4 @@\n-        \/\/ The cache for adapted MH if the access site has a constant VH\n-        \/\/ that does not match the erased type for.\n-        @Stable MethodHandle adaptedMh;\n+        \/\/ The cache for last adapted MH if the access site has a VH that does\n+        \/\/ not match the erased type for.  It can be safely reused if VH is\n+        \/\/ discovered to be a constant during C2 compilation.\n+        @Stable MethodHandle lastAdaption;\n@@ -2034,4 +2035,5 @@\n-            var constant = MethodHandleImpl.isCompileConstant(vh);\n-            var cache = adaptedMh;\n-            if (constant == MethodHandleImpl.CONSTANT_YES && cache != null) {\n-                return cache;\n+            if (MethodHandleImpl.isCompileConstant(vh)) {\n+                var cache = lastAdaption;\n+                if (cache != null) {\n+                    return cache;\n+                }\n@@ -2040,7 +2042,2 @@\n-            \/\/ This is still a hot path if vh is not constant - in this case,\n-            \/\/ asType is the bottleneck for constant folding, unfortunately\n-            var result = vh.getMethodHandle(mode).asType(symbolicMethodTypeInvoker);\n-            if (constant != MethodHandleImpl.CONSTANT_NO && cache == null) {\n-                adaptedMh = result;\n-            }\n-            return result;\n+            \/\/ Keep capturing - vh may suddenly get promoted to a constant by C2\n+            return lastAdaption = vh.getMethodHandle(mode).asType(symbolicMethodTypeInvoker);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -78,2 +78,2 @@\n-        var _ = (byte) B.getAndAdd(b2);\n-        var _ = (byte) B.getAndAdd((byte)1);\n+        B.getAndAdd(b2);\n+        B.getAndAdd((byte)1);\n@@ -88,2 +88,2 @@\n-        var _ = (short) S.getAndAdd(s2);\n-        var _ = (short) S.getAndAdd((short)1);\n+        S.getAndAdd(s2);\n+        S.getAndAdd((short)1);\n@@ -98,2 +98,2 @@\n-        var _ = (int) I.getAndAdd(i2);\n-        var _ = (int) I.getAndAdd(1);\n+        I.getAndAdd(i2);\n+        I.getAndAdd(1);\n@@ -108,2 +108,2 @@\n-        var _ = (long) L.getAndAdd(l2);\n-        var _ = (long) L.getAndAdd(1L);\n+        L.getAndAdd(l2);\n+        L.getAndAdd(1L);\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestGetAndAdd.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-        exact.set(data, (long) 42);\n+        var _ = (long) exact.getAndAdd(data, (long) 42);\n@@ -77,1 +77,6 @@\n-        generic.set(data, 42);\n+        var _ = (long) generic.getAndAdd(data, 42);\n+    }\n+\n+    @Benchmark\n+    public void generic_returnDroppingInvocation() {\n+        generic.getAndAdd(data, (long) 42);\n@@ -82,1 +87,1 @@\n-        generic.set(data, (long) 42);\n+        var _ = (long) generic.getAndAdd(data, (long) 42);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/VarHandleExact.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"}]}