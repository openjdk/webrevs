{"files":[{"patch":"@@ -129,4 +129,1 @@\n-    \/\/ Currently this void version is needed because otherwise\n-    \/\/ TestZGCBarrierElision.testAtomicThenAtomicAnotherField fails\n-    \/\/ However, testArrayAtomicThenAtomic, testAtomicThenAtomic, and\n-    \/\/ testArrayAtomicThenAtomicAtUnknownIndices works\n+    \/\/ The void bypass is necessary if a sigpoly signature (name + type) is shared by multiple handle instances\n","filename":"make\/jdk\/src\/classes\/build\/tools\/methodhandle\/VarHandleGuardMethodGenerator.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2028,3 +2028,3 @@\n-        \/\/ This heuristic assumes that each sigpoly VH call site usually sees\n-        \/\/ exactly one VarHandle instance.  Each sigpoly VH call site already\n-        \/\/ has a dedicated AccessDescriptor.\n+        \/\/ This heuristic assumes that each sigpoly VH signatures usually sees\n+        \/\/ exactly one VarHandle instance.  In one class file, each sigpoly\n+        \/\/ signature has one AccessDescriptor.\n@@ -2032,2 +2032,3 @@\n-        \/\/ However, for correctness, we must verify the incoming VarHandle;\n-        \/\/ adaptedMethodHandle may be inlined by different callers.\n+        \/\/ For correctness, we must verify the incoming VarHandle; different\n+        \/\/ sites with the same signature may exist, and adaptedMethodHandle\n+        \/\/ may be inlined by different callers.\n@@ -2038,1 +2039,1 @@\n-        \/\/ all.\n+        \/\/ all. Such an optimization applies for general MethodHandle.asType.\n@@ -2040,1 +2041,1 @@\n-        \/\/ Object indirection is the only way to ensure the vh and mh are not\n+        \/\/ Object indirection is the best way to ensure the vh and mh are not\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-package compiler.c2.irTests.constantFold;\n+package compiler.jsr292;\n@@ -32,1 +32,0 @@\n-import compiler.lib.ir_framework.Run;\n@@ -41,2 +40,1 @@\n- * @requires vm.compiler2.enabled\n- * @run driver compiler.c2.irTests.constantFold.VarHandleMismatchedTypeFold\n+ * @run driver ${test.main.class}\n@@ -66,0 +64,1 @@\n+        \/\/ This long get() must be the only get mode with ()J signature in this class file\n","filename":"test\/hotspot\/jtreg\/compiler\/jsr292\/VarHandleMismatchedTypeFold.java","additions":3,"deletions":4,"binary":false,"changes":7,"previous_filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/constantFold\/VarHandleMismatchedTypeFold.java","status":"renamed"}]}