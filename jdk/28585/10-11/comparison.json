{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,2 @@\n-    \/\/ The void bypass is necessary if a sigpoly signature (name + type) is shared by multiple handle instances\n+    \/\/ The void bypass is necessary if a (name + return-dropping type) combination has multiple call sites, each\n+    \/\/ having its own constant VarHandle. See VarHandle$AccessDescriptor for the mechanism.\n","filename":"make\/jdk\/src\/classes\/build\/tools\/methodhandle\/VarHandleGuardMethodGenerator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2017,0 +2017,6 @@\n+    \/\/ An access descriptor represents a (name, type) combination for var handle polymorphic method invocation.\n+    \/\/ The name is translated to `mode`, and the type is `symbolicMethodTypeExact`.\n+    \/\/ The access descriptor is created in MethodHandleNatives::varHandleOperationLinkerMethod.\n+    \/\/ In a class file, the JVM creates one access descriptor for one (name, type) combination.\n+    \/\/ Many call sites in one class can have the same (name, type) combination.\n+    \/\/ In this case, they share the same access descriptor.\n@@ -2024,1 +2030,1 @@\n-        \/\/ Used by adaption - if there's a caller we can better detect leaks\n+        \/\/ Used by adaption - if there's a caller we can better detect loader safety\n@@ -2028,7 +2034,17 @@\n-        \/\/ This heuristic assumes that each sigpoly VH signatures usually sees\n-        \/\/ exactly one VarHandle instance.  In one class file, each sigpoly\n-        \/\/ signature has one AccessDescriptor.\n-        \/\/ (See MethodHandleNatives::varHandleOperationLinkerMethod)\n-        \/\/ For correctness, we must verify the incoming VarHandle; different\n-        \/\/ sites with the same signature may exist, and adaptedMethodHandle\n-        \/\/ may be inlined by different callers.\n+        \/\/ We capture a first-come non-exact VarHandle and cache its asType\n+        \/\/ result in this (name, type) combination for a class file.\n+        \/\/\n+        \/\/ This heuristic assumes that, most of the time:\n+        \/\/ 1. Only one call site in a class file uses this (name, type) combination\n+        \/\/ 2. That call site only sees a constant VarHandle instance\n+        \/\/ 3. That VarHandle does not keep other class loaders alive\n+        \/\/\n+        \/\/ Condition 1 and 2 indicates this access descriptor may see a VarHandle\n+        \/\/ different from the captured VarHandle.  Condition 3 requires the\n+        \/\/ capture to be made only for loader-safe VarHandles.\n+        \/\/ Due to condition 1, we have to retain the GUARD_METHOD_TEMPLATE_V\n+        \/\/ in VarHandleGuards. One (name, return-dropping type) combination\n+        \/\/ such as compareAndSet can appear at two sites, where each site\n+        \/\/ has its own constant VarHandle. Such a usage pattern hurts adaption,\n+        \/\/ but is perfectly dealt by the getMethodType_V constant folding branch.\n+\n@@ -2061,0 +2077,2 @@\n+        \/\/ Called by VarHandle linkers - see VarHandleGuardMethodGenerator\n+        \/\/ Currently not used by Invokers::checkVarHandleGenericType but eligible\n@@ -2072,3 +2090,5 @@\n-                    \/\/ Reduce costly object allocation - if our assumption stands,\n-                    \/\/ the first adaption works, and we don't want allocations for\n-                    \/\/ every VH invocation.\n+                    \/\/ If our assumption stands, this is trivially correct.\n+                    \/\/ Otherwise, a loader-safe witness is installed.\n+                    \/\/ Adaption of the witness will constant-fold to `cache.mh`.\n+                    \/\/ Adaption of the others will fold to a `vh.getMethodHandle(mode).asType(...)`.\n+                    \/\/ Racy installation here is ok - Adaption record is not tearable\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":32,"deletions":12,"binary":false,"changes":44,"status":"modified"}]}