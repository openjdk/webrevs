{"files":[{"patch":"@@ -2019,4 +2019,18 @@\n-        \/\/ The cache for last adapted MH if the access site has a VH that does\n-        \/\/ not match the erased type for.  It can be safely reused if VH is\n-        \/\/ discovered to be a constant during C2 compilation.\n-        @Stable MethodHandle lastAdaption;\n+\n+        \/\/ Adaption mechanism to reduce overhead for non-exact access.\n+        \/\/ This heuristic assumes that each sigpoly VH call site usually sees\n+        \/\/ exactly one VarHandle instance.  Each sigpoly VH call site already\n+        \/\/ has a dedicated AccessDescriptor.\n+        \/\/ (See MethodHandleNatives::varHandleOperationLinkerMethod)\n+        \/\/ However, for correctness, we must verify the incoming VarHandle;\n+        \/\/ adaptedMethodHandle may be inlined by different callers.\n+        \/\/ In the long run, we wish to put a specific-type invoker that converts\n+        \/\/ from one fixed type (symbolicMethodTypeInvoker) to another (the\n+        \/\/ invocation type of the underlying MemberName, or MH for indirect VH),\n+        \/\/ perform a foldable lookup with a hash table, and hope C2 inline it\n+        \/\/ all.\n+\n+        \/\/ Object indirection is the only way to ensure the vh and mh are not\n+        \/\/ from two writes (they must not be tearable)\n+        private record Adaption(VarHandle vh, MethodHandle mh) {}\n+        private @Stable Adaption adaption;\n@@ -2035,5 +2049,3 @@\n-            if (MethodHandleImpl.isCompileConstant(vh)) {\n-                var cache = lastAdaption;\n-                if (cache != null) {\n-                    return cache;\n-                }\n+            var cache = adaption;\n+            if (cache != null && cache.vh == vh) {\n+                return cache.mh;\n@@ -2042,2 +2054,8 @@\n-            \/\/ Keep capturing - vh may suddenly get promoted to a constant by C2\n-            return lastAdaption = vh.getMethodHandle(mode).asType(symbolicMethodTypeInvoker);\n+            var mh = vh.getMethodHandle(mode).asType(symbolicMethodTypeInvoker);\n+            if (cache == null) {\n+                \/\/ Reduce costly object allocation - if our assumption stands,\n+                \/\/ the first adaption works, and we don't want allocations for\n+                \/\/ every VH invocation.\n+                adaption = new Adaption(vh, mh);\n+            }\n+            return mh;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandle.java","additions":29,"deletions":11,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-        exact.set(data, (long) 0, 42);\n+        var _ = (int) exact.getAndAdd(data, (long) 0, 42);\n@@ -82,1 +82,6 @@\n-        generic.set(data, 0, 42);\n+        generic.getAndAdd(data, 0, 42);\n+    }\n+\n+    @Benchmark\n+    public void generic_returnDroppingInvocation() {\n+        generic.getAndAdd(data, (long) 0, 42);\n@@ -87,1 +92,1 @@\n-        generic.set(data, (long) 0, 42);\n+        var _ = (int) generic.getAndAdd(data, (long) 0, 42);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/VarHandleExact.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-        var _ = (long) generic.getAndAdd(data, 42);\n+        generic.getAndAdd(data, 42);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/VarHandleExact.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}