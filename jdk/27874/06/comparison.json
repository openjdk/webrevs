{"files":[{"patch":"@@ -177,3 +177,2 @@\n-     * Allocated buffer size. Must never be higher than 16K. But can be lower\n-     * if smaller allocation units preferred. HTTP\/2 mandates that all\n-     * implementations support frame payloads of at least 16K.\n+     * The capacity of ephemeral {@link ByteBuffer}s allocated to pass data to and from the client.\n+     * It is ensured to have a value between 1 and 2^14 (16,384).\n@@ -181,2 +180,0 @@\n-    private static final int DEFAULT_BUFSIZE = 16 * 1024;\n-\n@@ -184,2 +181,10 @@\n-            \"jdk.httpclient.bufsize\", DEFAULT_BUFSIZE\n-    );\n+            \"jdk.httpclient.bufsize\", 1,\n+            \/\/ We cap at 2^14 (16,384) for two main reasons:\n+            \/\/ - The initial frame size is 2^14 (RFC 9113)\n+            \/\/ - SSL record layer fragments data in chunks of 2^14 bytes or less (RFC 5246)\n+            1 << 14,\n+            \/\/ We choose 2^14 (16,384) as the default, because:\n+            \/\/ 1. It maximizes throughput within the limits described above\n+            \/\/ 2. It is small enough to not create a GC bottleneck when it is partially filled\n+            1 << 14,\n+            true);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -51,1 +51,3 @@\n- * The size to use for internal allocated buffers in bytes.\n+ * The capacity of internal ephemeral buffers allocated to pass data to and from the\n+ * client, in bytes. Valid values are in the range [1, 2^14 (16384)].\n+ * If an invalid value is provided, the default value is used.\n","filename":"src\/java.net.http\/share\/classes\/module-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.net.http.HttpClient.Version.HTTP_3;\n+import static java.net.http.HttpOption.H3_DISCOVERY;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test id\n+ * @bug 8367976\n+ * @summary Verifies that setting the `jdk.httpclient.bufsize` system property\n+ *          to its lowest possible value, 1, does not wedge the client\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ * @run junit\/othervm -Djdk.httpclient.bufsize=1 BufferSize1Test\n+ *\/\n+\n+class BufferSize1Test implements HttpServerAdapters {\n+\n+    @BeforeAll\n+    static void verifyBufferSize() {\n+        assertEquals(1, Utils.BUFSIZE);\n+    }\n+\n+    static Object[][] testArgs() {\n+        return new Object[][]{\n+                {HTTP_1_1, false},\n+                {HTTP_1_1, true},\n+                {HTTP_2, false},\n+                {HTTP_2, true},\n+                {HTTP_3, true}\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testArgs\")\n+    void test(Version version, boolean secure) throws Exception {\n+\n+        \/\/ Create the server\n+        var sslContext = secure || HTTP_3.equals(version) ? new SimpleSSLContext().get() : null;\n+        try (var server = switch (version) {\n+            case HTTP_1_1, HTTP_2 -> HttpTestServer.create(version, sslContext);\n+            case HTTP_3 -> HttpTestServer.create(HTTP_3_URI_ONLY, sslContext);\n+        }) {\n+\n+            \/\/ Add the handler and start the server\n+            var serverHandlerPath = \"\/\" + BufferSize1Test.class.getSimpleName();\n+            server.addHandler(new HttpTestEchoHandler(), serverHandlerPath);\n+            server.start();\n+\n+            \/\/ Create the client\n+            try (var client = createClient(version, sslContext)) {\n+\n+                \/\/ Create the request with body to ensure that `ByteBuffer`s\n+                \/\/ will be used throughout the entire end-to-end interaction.\n+                byte[] requestBodyBytes = \"body\".repeat(1000).getBytes(StandardCharsets.US_ASCII);\n+                var request = createRequest(sslContext, server, serverHandlerPath, version, requestBodyBytes);\n+\n+                \/\/ Execute and verify the request.\n+                \/\/ Do it twice to cover code paths before and after a protocol upgrade.\n+                requestAndVerify(client, request, requestBodyBytes);\n+                requestAndVerify(client, request, requestBodyBytes);\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    private HttpClient createClient(Version version, SSLContext sslContext) {\n+        var clientBuilder = newClientBuilderForH3()\n+                .proxy(NO_PROXY)\n+                .version(version);\n+        if (sslContext != null) {\n+            clientBuilder.sslContext(sslContext);\n+        }\n+        return clientBuilder.build();\n+    }\n+\n+    private static HttpRequest createRequest(\n+            SSLContext sslContext,\n+            HttpTestServer server,\n+            String serverHandlerPath,\n+            Version version,\n+            byte[] requestBodyBytes) {\n+        var requestUri = URI.create(String.format(\n+                \"%s:\/\/%s%s\/x\",\n+                sslContext == null ? \"http\" : \"https\",\n+                server.serverAuthority(),\n+                serverHandlerPath));\n+        var requestBuilder = HttpRequest\n+                .newBuilder(requestUri)\n+                .version(version)\n+                .POST(HttpRequest.BodyPublishers.ofByteArray(requestBodyBytes));\n+        if (HTTP_3.equals(version)) {\n+            requestBuilder.setOption(H3_DISCOVERY, HTTP_3_URI_ONLY);\n+        }\n+        return requestBuilder.build();\n+    }\n+\n+    private static void requestAndVerify(HttpClient client, HttpRequest request, byte[] requestBodyBytes)\n+            throws IOException, InterruptedException {\n+        var response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());\n+        if (response.statusCode() != 200) {\n+            throw new AssertionError(\"Was expecting status code 200, found: \" + response.statusCode());\n+        }\n+        byte[] responseBodyBytes = response.body();\n+        int mismatchIndex = Arrays.mismatch(requestBodyBytes, responseBodyBytes);\n+        assertTrue(\n+                mismatchIndex < 0,\n+                String.format(\n+                        \"Response body (%s bytes) mismatches the request body (%s bytes) at index %s!\",\n+                        responseBodyBytes.length, requestBodyBytes.length, mismatchIndex));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/BufferSize1Test.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.net.http.common.Utils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Handler;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/*\n+ * @test\n+ * @bug 8367976\n+ * @summary Verifies that the `jdk.httpclient.bufsize` system property is\n+ *          clamped correctly\n+ *\n+ * @library \/test\/lib\n+ *\n+ * @comment `-Djdk.httpclient.HttpClient.log=errors` is needed to enable\n+ *          logging and verify that invalid input gets logged\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.HttpClient.log=errors\n+ *      -Djdk.httpclient.bufsize=-1\n+ *      BufferSizePropertyClampTest\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.HttpClient.log=errors\n+ *      -Djdk.httpclient.bufsize=0\n+ *      BufferSizePropertyClampTest\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.HttpClient.log=errors\n+ *      -Djdk.httpclient.bufsize=16385\n+ *      BufferSizePropertyClampTest\n+ *\/\n+\n+class BufferSizePropertyClampTest {\n+\n+    \/** Anchor to avoid the {@code Logger} instance get GC'ed *\/\n+    private static final Logger CLIENT_LOGGER =\n+            Logger.getLogger(\"jdk.httpclient.HttpClient\");\n+\n+    private static final List<String> CLIENT_LOGGER_MESSAGES =\n+            Collections.synchronizedList(new ArrayList<>());\n+\n+    @BeforeAll\n+    static void registerLoggerHandler() {\n+        CLIENT_LOGGER.addHandler(new Handler() {\n+\n+            @Override\n+            public void publish(LogRecord record) {\n+                var message = MessageFormat.format(record.getMessage(), record.getParameters());\n+                CLIENT_LOGGER_MESSAGES.add(message);\n+            }\n+\n+            @Override\n+            public void flush() {\n+                \/\/ Do nothing\n+            }\n+\n+            @Override\n+            public void close() {\n+                \/\/ Do nothing\n+            }\n+\n+        });\n+    }\n+\n+    @Test\n+    void test() throws Exception {\n+        assertEquals(16384, Utils.BUFSIZE);\n+        assertEquals(\n+                1, CLIENT_LOGGER_MESSAGES.size(),\n+                \"Unexpected number of logger messages: \" + CLIENT_LOGGER_MESSAGES);\n+        var expectedMessage = \"ERROR: Property value for jdk.httpclient.bufsize=\" +\n+                System.getProperty(\"jdk.httpclient.bufsize\") +\n+                \" not in [1..16384]: using default=16384\";\n+        assertEquals(expectedMessage, CLIENT_LOGGER_MESSAGES.getFirst().replaceAll(\",\", \"\"));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/BufferSizePropertyClampTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -46,2 +46,0 @@\n- * @run main\/othervm -Djdk.httpclient.bufsize=-1 OfByteArrayTest testInvalidBufferSize\n- * @run main\/othervm -Djdk.httpclient.bufsize=0 OfByteArrayTest testInvalidBufferSize\n@@ -91,1 +89,0 @@\n-            case \"testInvalidBufferSize\" -> testInvalidBufferSize();\n@@ -105,4 +102,0 @@\n-    private static void testInvalidBufferSize() {\n-        assertThrows(IllegalArgumentException.class, () -> HttpRequest.BodyPublishers.ofByteArray(new byte[1]));\n-    }\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/OfByteArrayTest.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}