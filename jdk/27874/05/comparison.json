{"files":[{"patch":"@@ -177,3 +177,2 @@\n-     * Allocated buffer size. Must never be higher than 16K. But can be lower\n-     * if smaller allocation units preferred. HTTP\/2 mandates that all\n-     * implementations support frame payloads of at least 16K.\n+     * The capacity of ephemeral {@link ByteBuffer}s allocated to pass data to and from the client.\n+     * It is ensured to have a value between 1 and 2^14 (16,384).\n@@ -181,2 +180,0 @@\n-    private static final int DEFAULT_BUFSIZE = 16 * 1024;\n-\n@@ -184,2 +181,10 @@\n-            \"jdk.httpclient.bufsize\", DEFAULT_BUFSIZE\n-    );\n+            \"jdk.httpclient.bufsize\", 1,\n+            \/\/ We cap at 2^14 (16,384) for two main reasons:\n+            \/\/ - The initial frame size is 2^14 (RFC 9113)\n+            \/\/ - SSL record layer fragments data in chunks of 2^14 bytes or less (RFC 5246)\n+            1 << 14,\n+            \/\/ We choose 2^14 (16,384) as the default, because:\n+            \/\/ 1. It maximizes throughput within the limits described above\n+            \/\/ 2. It is small enough to not create a GC bottleneck when it is partially filled\n+            1 << 14,\n+            true);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -51,1 +51,3 @@\n- * The size to use for internal allocated buffers in bytes.\n+ * The capacity of internal ephemeral buffers allocated to pass data to and from the\n+ * client, in bytes. Valid values are in the range [1, 2^14 (16384)].\n+ * If an invalid value is provided, the default value is used.\n","filename":"src\/java.net.http\/share\/classes\/module-info.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.net.http.HttpClient.Version.HTTP_3;\n+import static java.net.http.HttpOption.H3_DISCOVERY;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test id\n+ * @bug 8367976\n+ * @summary Verifies that setting the `jdk.httpclient.bufsize` system property\n+ *          to its lowest possible value, 1, does not wedge the client\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ * @run junit\/othervm -Djdk.httpclient.bufsize=1 BufferSize1Test\n+ *\/\n+\n+class BufferSize1Test implements HttpServerAdapters {\n+\n+    @BeforeAll\n+    static void verifyBufferSize() {\n+        assertEquals(1, Utils.BUFSIZE);\n+    }\n+\n+    static Object[][] testArgs() {\n+        return new Object[][]{\n+                {HTTP_1_1, false},\n+                {HTTP_1_1, true},\n+                {HTTP_2, false},\n+                {HTTP_2, true},\n+                {HTTP_3, true}\n+        };\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testArgs\")\n+    void test(Version version, boolean secure) throws Exception {\n+\n+        \/\/ Create the server\n+        var sslContext = secure || HTTP_3.equals(version) ? new SimpleSSLContext().get() : null;\n+        try (var server = switch (version) {\n+            case HTTP_1_1, HTTP_2 -> HttpTestServer.create(version, sslContext);\n+            case HTTP_3 -> HttpTestServer.create(HTTP_3_URI_ONLY, sslContext);\n+        }) {\n+\n+            \/\/ Add the handler and start the server\n+            var serverHandlerPath = \"\/\" + BufferSize1Test.class.getSimpleName();\n+            server.addHandler(new HttpTestEchoHandler(), serverHandlerPath);\n+            server.start();\n+\n+            \/\/ Create the client\n+            try (var client = createClient(version, sslContext)) {\n+\n+                \/\/ Create the request with body to ensure that `ByteBuffer`s\n+                \/\/ will be used throughout the entire end-to-end interaction.\n+                byte[] requestBodyBytes = \"body\".repeat(1000).getBytes(StandardCharsets.US_ASCII);\n+                var request = createRequest(sslContext, server, serverHandlerPath, version, requestBodyBytes);\n+\n+                \/\/ Execute and verify the request.\n+                \/\/ Do it twice to cover code paths before and after a protocol upgrade.\n+                requestAndVerify(client, request, requestBodyBytes);\n+                requestAndVerify(client, request, requestBodyBytes);\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    private HttpClient createClient(Version version, SSLContext sslContext) {\n+        var clientBuilder = newClientBuilderForH3()\n+                .proxy(NO_PROXY)\n+                .version(version);\n+        if (sslContext != null) {\n+            clientBuilder.sslContext(sslContext);\n+        }\n+        return clientBuilder.build();\n+    }\n+\n+    private static HttpRequest createRequest(\n+            SSLContext sslContext,\n+            HttpTestServer server,\n+            String serverHandlerPath,\n+            Version version,\n+            byte[] requestBodyBytes) {\n+        var requestUri = URI.create(String.format(\n+                \"%s:\/\/%s%s\/x\",\n+                sslContext == null ? \"http\" : \"https\",\n+                server.serverAuthority(),\n+                serverHandlerPath));\n+        var requestBuilder = HttpRequest\n+                .newBuilder(requestUri)\n+                .version(version)\n+                .POST(HttpRequest.BodyPublishers.ofByteArray(requestBodyBytes));\n+        if (HTTP_3.equals(version)) {\n+            requestBuilder.setOption(H3_DISCOVERY, HTTP_3_URI_ONLY);\n+        }\n+        return requestBuilder.build();\n+    }\n+\n+    private static void requestAndVerify(HttpClient client, HttpRequest request, byte[] requestBodyBytes)\n+            throws IOException, InterruptedException {\n+        var response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());\n+        if (response.statusCode() != 200) {\n+            throw new AssertionError(\"Was expecting status code 200, found: \" + response.statusCode());\n+        }\n+        byte[] responseBodyBytes = response.body();\n+        int mismatchIndex = Arrays.mismatch(requestBodyBytes, responseBodyBytes);\n+        assertTrue(\n+                mismatchIndex < 0,\n+                String.format(\n+                        \"Response body (%s bytes) mismatches the request body (%s bytes) at index %s!\",\n+                        responseBodyBytes.length, requestBodyBytes.length, mismatchIndex));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/BufferSize1Test.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8367976\n+ * @summary Verifies that the `jdk.httpclient.bufsize` system property is\n+ *          clamped correctly\n+ * @library \/test\/lib\n+ * @run junit BufferSizePropertyClampTest\n+ *\/\n+\n+class BufferSizePropertyClampTest {\n+\n+    private static Path scriptPath;\n+\n+    @BeforeAll\n+    static void setUp() throws IOException {\n+        \/\/ Create a Java file that prints the `Utils::BUFSIZE` value\n+        scriptPath = Path.of(\"UtilsBUFSIZE.java\");\n+        Files.write(scriptPath, List.of(\"void main() { IO.println(jdk.internal.net.http.common.Utils.BUFSIZE); }\"));\n+    }\n+\n+    @AfterAll\n+    static void tearDown() throws IOException {\n+        Files.deleteIfExists(scriptPath);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {-1, 0, (2 << 14) + 1})\n+    void test(int invalidBufferSize) throws Exception {\n+\n+        \/\/ To obtain the buffer size constant, run the Java file in a separate\n+        \/\/ process, which is needed to capture the stdout and verify the logged\n+        \/\/ error message.\n+        var outputAnalyzer = ProcessTools.executeTestJava(\n+                \"--add-exports\", \"java.net.http\/jdk.internal.net.http.common=ALL-UNNAMED\",\n+                \"-Djdk.httpclient.HttpClient.log=errors\",\n+                \"-Djdk.httpclient.bufsize=\" + invalidBufferSize,\n+                scriptPath.toString());\n+        outputAnalyzer.shouldHaveExitValue(0);\n+\n+        \/\/ Verify stderr\n+        List<String> stderrLines = outputAnalyzer.stderrAsLines();\n+        assertEquals(2, stderrLines.size(), \"Expected 2 lines, found: \" + stderrLines);\n+        assertTrue(\n+                stderrLines.get(0).endsWith(\"jdk.internal.net.http.common.Utils getIntegerNetProperty\"),\n+                \"Unexpected line: \" + stderrLines.get(0));\n+        assertEquals(\n+                \"INFO: ERROR: Property value for jdk.httpclient.bufsize=\" + invalidBufferSize + \" not in [1..16384]: using default=16384\",\n+                stderrLines.get(1).replaceAll(\",\", \"\"));\n+\n+        \/\/ Verify stdout\n+        var stdoutLines = outputAnalyzer.stdoutAsLines();\n+        assertEquals(1, stdoutLines.size(), \"Expected one line, found: \" + stdoutLines);\n+        assertEquals(\"16384\", stdoutLines.get(0));\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/BufferSizePropertyClampTest.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -46,2 +46,0 @@\n- * @run main\/othervm -Djdk.httpclient.bufsize=-1 OfByteArrayTest testInvalidBufferSize\n- * @run main\/othervm -Djdk.httpclient.bufsize=0 OfByteArrayTest testInvalidBufferSize\n@@ -91,1 +89,0 @@\n-            case \"testInvalidBufferSize\" -> testInvalidBufferSize();\n@@ -105,4 +102,0 @@\n-    private static void testInvalidBufferSize() {\n-        assertThrows(IllegalArgumentException.class, () -> HttpRequest.BodyPublishers.ofByteArray(new byte[1]));\n-    }\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/OfByteArrayTest.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}