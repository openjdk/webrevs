{"files":[{"patch":"@@ -113,1 +113,1 @@\n-  uint number_of_recorded_pause_times() const {\n+  uint max_num_of_recorded_pause_times() const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,2 +199,2 @@\n-    \/\/ We set it here to ~8%.\n-    FLAG_SET_DEFAULT(GCTimeRatio, 12);\n+    \/\/ We set it here to 4%.\n+    FLAG_SET_DEFAULT(GCTimeRatio, 24);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -721,0 +721,1 @@\n+  HeapWord* result = nullptr;\n@@ -722,1 +723,1 @@\n-    return _allocator->attempt_allocation_locked(node_index, word_size);\n+    result = _allocator->attempt_allocation_locked(node_index, word_size);\n@@ -724,1 +725,1 @@\n-    HeapWord* result = humongous_obj_allocate(word_size);\n+    result = humongous_obj_allocate(word_size);\n@@ -728,1 +729,0 @@\n-    return result;\n@@ -730,2 +730,1 @@\n-\n-  ShouldNotReachHere();\n+  return result;\n@@ -798,2 +797,1 @@\n-  resize_heap_if_necessary(allocation_word_size);\n-  uncommit_regions_if_necessary();\n+  resize_heap_after_full_collection(allocation_word_size);\n@@ -882,1 +880,11 @@\n-void G1CollectedHeap::resize_heap_if_necessary(size_t allocation_word_size) {\n+\n+void G1CollectedHeap::resize_heap(size_t resize_bytes, bool should_expand) {\n+  if (should_expand) {\n+    expand(resize_bytes, _workers);\n+  } else {\n+    shrink(resize_bytes);\n+    uncommit_regions_if_necessary();\n+  }\n+}\n+\n+void G1CollectedHeap::resize_heap_after_full_collection(size_t allocation_word_size) {\n@@ -886,1 +894,1 @@\n-  size_t resize_amount = _heap_sizing_policy->full_collection_resize_amount(should_expand, allocation_word_size);\n+  size_t resize_bytes = _heap_sizing_policy->full_collection_resize_amount(should_expand, allocation_word_size);\n@@ -888,6 +896,2 @@\n-  if (resize_amount == 0) {\n-    return;\n-  } else if (should_expand) {\n-    expand(resize_amount, _workers);\n-  } else {\n-    shrink(resize_amount);\n+  if (resize_bytes != 0) {\n+    resize_heap(resize_bytes, should_expand);\n@@ -897,0 +901,14 @@\n+void G1CollectedHeap::resize_heap_after_young_collection(size_t allocation_word_size) {\n+  Ticks start = Ticks::now();\n+\n+  bool should_expand;\n+\n+  size_t resize_bytes = _heap_sizing_policy->young_collection_resize_amount(should_expand, allocation_word_size);\n+\n+  if (resize_bytes != 0) {\n+    resize_heap(resize_bytes, should_expand);\n+  }\n+\n+  phase_times()->record_resize_heap_time((Ticks::now() - start).seconds() * 1000.0);\n+}\n+\n@@ -995,0 +1013,1 @@\n+  HeapWord* result = nullptr;\n@@ -998,2 +1017,2 @@\n-    return attempt_allocation_at_safepoint(word_size,\n-                                           false \/* expect_null_mutator_alloc_region *\/);\n+    result = attempt_allocation_at_safepoint(word_size,\n+                                             false \/* expect_null_mutator_alloc_region *\/);\n@@ -1001,1 +1020,1 @@\n-  return nullptr;\n+  return result;\n@@ -1004,1 +1023,1 @@\n-bool G1CollectedHeap::expand(size_t expand_bytes, WorkerThreads* pretouch_workers, double* expand_time_ms) {\n+bool G1CollectedHeap::expand(size_t expand_bytes, WorkerThreads* pretouch_workers) {\n@@ -1008,2 +1027,5 @@\n-  log_debug(gc, ergo, heap)(\"Expand the heap. requested expansion amount: %zuB expansion amount: %zuB\",\n-                            expand_bytes, aligned_expand_bytes);\n+  uint num_regions_to_expand = (uint)(aligned_expand_bytes \/ G1HeapRegion::GrainBytes);\n+  assert(num_regions_to_expand > 0, \"Must expand by at least one region\");\n+\n+  log_debug(gc, ergo, heap)(\"Heap resize. Requested expansion amount: %zuM aligned expansion amount: %zuM (%u regions)\",\n+                            expand_bytes \/ M, aligned_expand_bytes \/ M, num_regions_to_expand);\n@@ -1012,1 +1034,1 @@\n-    log_debug(gc, ergo, heap)(\"Did not expand the heap (heap already fully expanded)\");\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not expand the heap (heap already fully expanded)\");\n@@ -1016,3 +1038,0 @@\n-  double expand_heap_start_time_sec = os::elapsedTime();\n-  uint regions_to_expand = (uint)(aligned_expand_bytes \/ G1HeapRegion::GrainBytes);\n-  assert(regions_to_expand > 0, \"Must expand by at least one region\");\n@@ -1020,4 +1039,1 @@\n-  uint expanded_by = _hrm.expand_by(regions_to_expand, pretouch_workers);\n-  if (expand_time_ms != nullptr) {\n-    *expand_time_ms = (os::elapsedTime() - expand_heap_start_time_sec) * MILLIUNITS;\n-  }\n+  uint expanded_by = _hrm.expand_by(num_regions_to_expand, pretouch_workers);\n@@ -1048,2 +1064,5 @@\n-  size_t aligned_shrink_bytes = os::align_down_vm_page_size(shrink_bytes);\n-  aligned_shrink_bytes = align_down(aligned_shrink_bytes, G1HeapRegion::GrainBytes);\n+  assert(shrink_bytes > 0, \"must be\");\n+  assert(is_aligned(shrink_bytes, G1HeapRegion::GrainBytes),\n+         \"Shrink request for %zuM not aligned to heap region size %zuM\",\n+         shrink_bytes \/ M, G1HeapRegion::GrainBytes \/ M);\n+\n@@ -1055,2 +1074,2 @@\n-  log_debug(gc, ergo, heap)(\"Shrink the heap. requested shrinking amount: %zuB aligned shrinking amount: %zuB actual amount shrunk: %zuB\",\n-                            shrink_bytes, aligned_shrink_bytes, shrunk_bytes);\n+  log_debug(gc, ergo, heap)(\"Heap resize. Requested shrinking amount: %zuM actual shrinking amount: %zuM (%u regions)\",\n+                            shrink_bytes \/ M, shrunk_bytes \/ M, num_regions_removed);\n@@ -1058,1 +1077,0 @@\n-    log_debug(gc, heap)(\"Uncommittable regions after shrink: %u\", num_regions_removed);\n@@ -1061,1 +1079,1 @@\n-    log_debug(gc, ergo, heap)(\"Did not shrink the heap (heap shrinking operation failed)\");\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not shrink the heap (heap shrinking operation failed)\");\n@@ -1066,0 +1084,19 @@\n+  if (capacity() == min_capacity()) {\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not shrink the heap (heap already at minimum)\");\n+    return;\n+  }\n+\n+  size_t aligned_shrink_bytes = os::align_down_vm_page_size(shrink_bytes);\n+  aligned_shrink_bytes = align_down(aligned_shrink_bytes, G1HeapRegion::GrainBytes);\n+\n+  aligned_shrink_bytes = capacity() - MAX2(capacity() - aligned_shrink_bytes, min_capacity());\n+  assert(is_aligned(aligned_shrink_bytes, G1HeapRegion::GrainBytes), \"Bytes to shrink %zuB not aligned\", aligned_shrink_bytes);\n+\n+  log_debug(gc, ergo, heap)(\"Heap resize. Requested shrink amount: %zuB aligned shrink amount: %zuB\",\n+                            shrink_bytes, aligned_shrink_bytes);\n+\n+  if (aligned_shrink_bytes == 0) {\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not shrink the heap (shrink request too small)\");\n+    return;\n+  }\n+\n@@ -1077,1 +1114,1 @@\n-  shrink_helper(shrink_bytes);\n+  shrink_helper(aligned_shrink_bytes);\n@@ -1343,1 +1380,1 @@\n-                       MinHeapSize,\n+                       min_capacity(),\n@@ -2029,1 +2066,1 @@\n-  return (_policy->young_list_target_length() - _survivor.length()) * G1HeapRegion::GrainBytes;\n+  return eden_target_length() * G1HeapRegion::GrainBytes;\n@@ -2050,0 +2087,4 @@\n+size_t G1CollectedHeap::min_capacity() const {\n+  return MinHeapSize;\n+}\n+\n@@ -2395,14 +2436,1 @@\n-void G1CollectedHeap::expand_heap_after_young_collection(){\n-  size_t expand_bytes = _heap_sizing_policy->young_collection_expansion_amount();\n-  if (expand_bytes > 0) {\n-    \/\/ No need for an ergo logging here,\n-    \/\/ expansion_amount() does this when it returns a value > 0.\n-    double expand_ms = 0.0;\n-    if (!expand(expand_bytes, _workers, &expand_ms)) {\n-      \/\/ We failed to expand the heap. Cannot do anything about it.\n-    }\n-    phase_times()->record_expand_heap_time(expand_ms);\n-  }\n-}\n-\n-void G1CollectedHeap::do_collection_pause_at_safepoint() {\n+void G1CollectedHeap::do_collection_pause_at_safepoint(size_t allocation_word_size) {\n@@ -2412,1 +2440,1 @@\n-  do_collection_pause_at_safepoint_helper();\n+  do_collection_pause_at_safepoint_helper(allocation_word_size);\n@@ -2476,1 +2504,1 @@\n-void G1CollectedHeap::do_collection_pause_at_safepoint_helper() {\n+void G1CollectedHeap::do_collection_pause_at_safepoint_helper(size_t allocation_word_size) {\n@@ -2494,1 +2522,1 @@\n-  G1YoungCollector collector(gc_cause());\n+  G1YoungCollector collector(gc_cause(), allocation_word_size);\n@@ -2616,0 +2644,7 @@\n+  uint total_allocated = _survivor_evac_stats.regions_filled() + _old_evac_stats.regions_filled();\n+\n+  log_debug(gc)(\"Allocated %u survivor %u old percent total %1.2f%% (%u%%)\",\n+                _survivor_evac_stats.regions_filled(), _old_evac_stats.regions_filled(),\n+                percent_of(total_allocated, num_committed_regions() - total_allocated),\n+                G1ReservePercent);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":90,"deletions":55,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -561,1 +561,3 @@\n-  void resize_heap_if_necessary(size_t allocation_word_size);\n+  void resize_heap_after_young_collection(size_t allocation_word_size);\n+  void resize_heap_after_full_collection(size_t allocation_word_size);\n+  void resize_heap(size_t resize_bytes, bool should_expand);\n@@ -575,1 +577,1 @@\n-  bool expand(size_t expand_bytes, WorkerThreads* pretouch_workers = nullptr, double* expand_time_ms = nullptr);\n+  bool expand(size_t expand_bytes, WorkerThreads* pretouch_workers = nullptr);\n@@ -746,1 +748,1 @@\n-  void do_collection_pause_at_safepoint();\n+  void do_collection_pause_at_safepoint(size_t allocation_word_size = 0);\n@@ -750,1 +752,1 @@\n-  void do_collection_pause_at_safepoint_helper();\n+  void do_collection_pause_at_safepoint_helper(size_t allocation_word_size);\n@@ -767,2 +769,0 @@\n-  void expand_heap_after_young_collection();\n-  \/\/ Update object copying statistics.\n@@ -1025,0 +1025,2 @@\n+  bool last_gc_was_periodic() { return _gc_lastcause == GCCause::_g1_periodic_collection; }\n+\n@@ -1193,0 +1195,1 @@\n+  size_t min_capacity() const;\n@@ -1207,0 +1210,1 @@\n+  inline uint eden_target_length() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -319,0 +319,4 @@\n+inline uint G1CollectedHeap::eden_target_length() const {\n+  return _policy->young_list_target_length() - survivor_regions_count();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1464,2 +1464,3 @@\n-    _g1h->resize_heap_if_necessary(size_t(0) \/* allocation_word_size *\/);\n-    _g1h->uncommit_regions_if_necessary();\n+    if (_g1h->last_gc_was_periodic()) {\n+      _g1h->resize_heap_after_full_collection(size_t(0) \/* allocation_word_size *\/);\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  _cur_expand_heap_time_ms = 0.0;\n+  _cur_resize_heap_time_ms = 0.0;\n@@ -491,1 +491,1 @@\n-                        _cur_expand_heap_time_ms;\n+                        _cur_resize_heap_time_ms;\n@@ -540,1 +540,1 @@\n-  debug_time(\"Expand Heap After Collection\", _cur_expand_heap_time_ms);\n+  debug_time(\"Resize Heap After Collection\", _cur_resize_heap_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-  double _cur_expand_heap_time_ms;\n+  double _cur_resize_heap_time_ms;\n@@ -286,2 +286,2 @@\n-  void record_expand_heap_time(double ms) {\n-    _cur_expand_heap_time_ms = ms;\n+  void record_resize_heap_time(double ms) {\n+    _cur_resize_heap_time_ms = ms;\n@@ -408,2 +408,2 @@\n-  double cur_expand_heap_time_ms() {\n-    return _cur_expand_heap_time_ms;\n+  double cur_resize_heap_time_ms() {\n+    return _cur_resize_heap_time_ms;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -38,0 +38,4 @@\n+uint G1HeapSizingPolicy::long_term_count_limit() const {\n+  return _analytics->max_num_of_recorded_pause_times();\n+}\n+\n@@ -41,1 +45,18 @@\n-  _num_prev_pauses_for_heuristics(analytics->number_of_recorded_pause_times()) {\n+  \/\/ Bias for expansion at startup; the +1 is to counter the first sample always\n+  \/\/ being 0.0, i.e. lower than any threshold.\n+  _ratio_exceeds_threshold((MinOverThresholdForExpansion \/ 2) + 1),\n+  _recent_pause_ratios(long_term_count_limit()),\n+  _long_term_count(0) {\n+\n+  assert(_ratio_exceeds_threshold < MinOverThresholdForExpansion,\n+         \"Initial ratio counter value too high.\");\n+\n+  assert(_ratio_exceeds_threshold > -MinOverThresholdForExpansion,\n+         \"Initial ratio counter value too low.\");\n+\n+  assert(MinOverThresholdForExpansion <= long_term_count_limit(),\n+         \"Expansion threshold count must be less than %u\", long_term_count_limit());\n+\n+  assert(G1ShortTermShrinkThreshold <= long_term_count_limit(),\n+         \"Shrink threshold count must be less than %u\", long_term_count_limit());\n+}\n@@ -43,2 +64,4 @@\n-  assert(MinOverThresholdForGrowth < _num_prev_pauses_for_heuristics, \"Threshold must be less than %u\", _num_prev_pauses_for_heuristics);\n-  clear_ratio_check_data();\n+void G1HeapSizingPolicy::reset_ratio_tracking_data() {\n+  _long_term_count = 0;\n+  _ratio_exceeds_threshold = 0;\n+  \/\/ Keep the recent gc time ratio data.\n@@ -47,4 +70,4 @@\n-void G1HeapSizingPolicy::clear_ratio_check_data() {\n-  _ratio_over_threshold_count = 0;\n-  _ratio_over_threshold_sum = 0.0;\n-  _pauses_since_start = 0;\n+void G1HeapSizingPolicy::decay_ratio_tracking_data() {\n+  _long_term_count = 0;\n+  _ratio_exceeds_threshold \/= 2;\n+  \/\/ Keep the recent gc time ratio data.\n@@ -66,6 +89,20 @@\n-static void log_expansion(double short_term_pause_time_ratio,\n-                          double long_term_pause_time_ratio,\n-                          double threshold,\n-                          double pause_time_ratio,\n-                          bool fully_expanded,\n-                          size_t resize_bytes) {\n+\/\/ Logistic function, returns values in the range [0,1]\n+static double sigmoid_function(double value) {\n+  \/\/ Sigmoid Parameters:\n+  double inflection_point = 1.0; \/\/ Inflection point where acceleration begins (midpoint of sigmoid).\n+  double steepness = 6.0;\n+\n+  return 1.0 \/ (1.0 + pow(M_E, -steepness * (value - inflection_point)));\n+}\n+\n+double G1HeapSizingPolicy::scale_resize_ratio_delta(double ratio_delta,\n+                                                    double min_scale_down_factor,\n+                                                    double max_scale_up_factor) const {\n+   \/\/ We use a sigmoid function for scaling smoothly as we transition from a slow start to a fast growth\n+   \/\/ function with increasing ratio_delta. The sigmoid outputs a value in the range [0,1] which we scale to\n+   \/\/ the range [min_scale_down_factor, max_scale_up_factor]\n+  double sigmoid = sigmoid_function(ratio_delta);\n+\n+  double scale_factor = min_scale_down_factor + (max_scale_up_factor - min_scale_down_factor) * sigmoid;\n+  return scale_factor;\n+}\n@@ -73,1 +110,15 @@\n-  log_debug(gc, ergo, heap)(\"Heap expansion: \"\n+\/\/ Calculate the ratio of the difference of a and b relative to b.\n+static double rel_ratio(double a, double b) {\n+  return (a - b) \/ b;\n+}\n+\n+static void log_resize(double short_term_pause_time_ratio,\n+                       double long_term_pause_time_ratio,\n+                       double lower_threshold,\n+                       double upper_threshold,\n+                       double pause_time_ratio,\n+                       bool at_limit,\n+                       size_t resize_bytes,\n+                       bool expand) {\n+\n+  log_debug(gc, ergo, heap)(\"Heap resize: \"\n@@ -75,2 +126,2 @@\n-                            \"threshold %1.2f%% pause time ratio %1.2f%% fully expanded %s \"\n-                            \"resize by %zuB\",\n+                            \"lower threshold %1.2f%% upper threshold %1.2f%% pause time ratio %1.2f%% \"\n+                            \"at limit %s resize by %zuM expand %s\",\n@@ -79,1 +130,2 @@\n-                            threshold * 100.0,\n+                            lower_threshold * 100.0,\n+                            upper_threshold * 100.0,\n@@ -81,2 +133,3 @@\n-                            BOOL_TO_STR(fully_expanded),\n-                            resize_bytes);\n+                            BOOL_TO_STR(at_limit),\n+                            resize_bytes \/ M,\n+                            BOOL_TO_STR(expand));\n@@ -85,2 +138,2 @@\n-size_t G1HeapSizingPolicy::young_collection_expansion_amount() {\n-  assert(GCTimeRatio > 0, \"must be\");\n+size_t G1HeapSizingPolicy::young_collection_expand_amount(double delta) const {\n+  assert(delta >= 0.0, \"must be\");\n@@ -88,4 +141,6 @@\n-  double long_term_pause_time_ratio = _analytics->long_term_pause_time_ratio();\n-  double short_term_pause_time_ratio = _analytics->short_term_pause_time_ratio();\n-  const double pause_time_threshold = 1.0 \/ (1.0 + GCTimeRatio);\n-  double threshold = scale_with_heap(pause_time_threshold);\n+  size_t reserved_bytes = _g1h->max_capacity();\n+  size_t committed_bytes = _g1h->capacity();\n+  size_t uncommitted_bytes = reserved_bytes - committed_bytes;\n+  size_t expand_bytes_via_pct =\n+    uncommitted_bytes * G1ExpandByPercentOfAvailable \/ 100;\n+  size_t min_expand_bytes = MIN2(G1HeapRegion::GrainBytes, uncommitted_bytes);\n@@ -93,1 +148,6 @@\n-  size_t expand_bytes = 0;\n+  \/\/ Take the current size, or G1ExpandByPercentOfAvailable % of\n+  \/\/ the available expansion space, whichever is smaller, as the base\n+  \/\/ expansion size. Then possibly scale this size according to how much the\n+  \/\/ threshold has (on average) been exceeded by.\n+  const double MinScaleDownFactor = 0.2;\n+  const double MaxScaleUpFactor = 2.0;\n@@ -95,5 +155,31 @@\n-  if (_g1h->capacity() == _g1h->max_capacity()) {\n-    log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,\n-                  threshold, pause_time_threshold, true, 0);\n-    clear_ratio_check_data();\n-    return expand_bytes;\n+  double scale_factor = scale_resize_ratio_delta(delta,\n+                                                 MinScaleDownFactor,\n+                                                 MaxScaleUpFactor);\n+\n+  size_t resize_bytes = MIN2(expand_bytes_via_pct, committed_bytes);\n+\n+  resize_bytes = static_cast<size_t>(resize_bytes * scale_factor);\n+\n+  \/\/ Ensure the expansion size is at least the minimum growth amount\n+  \/\/ and at most the remaining uncommitted byte size.\n+  return clamp((size_t)resize_bytes, min_expand_bytes, uncommitted_bytes);\n+}\n+\n+size_t G1HeapSizingPolicy::young_collection_shrink_amount(double delta, size_t allocation_word_size) const {\n+  assert(delta >= 0.0, \"must be\");\n+\n+  double scale_factor = scale_resize_ratio_delta(delta,\n+                                                 G1ShrinkByPercentOfAvailable \/ 1000.0,\n+                                                 G1ShrinkByPercentOfAvailable \/ 100.0);\n+  assert(scale_factor <= 1.0, \"must be\");\n+\n+  \/\/ We are at the end of GC, so free regions are at maximum. Do not try to shrink\n+  \/\/ to have less than the reserve or the number of regions we are most certainly\n+  \/\/ going to use during this mutator phase.\n+  uint target_regions_to_shrink = _g1h->num_free_regions();\n+\n+  uint reserve_regions = ceil(_g1h->num_committed_regions() * G1ReservePercent \/ 100.0);\n+\n+  uint needed_for_allocation = _g1h->eden_target_length();\n+  if (_g1h->is_humongous(allocation_word_size)) {\n+    needed_for_allocation += (uint) _g1h->humongous_obj_size_in_regions(allocation_word_size);\n@@ -102,6 +188,60 @@\n-  \/\/ If the last GC time ratio is over the threshold, increment the count of\n-  \/\/ times it has been exceeded, and add this ratio to the sum of exceeded\n-  \/\/ ratios.\n-  if (short_term_pause_time_ratio > threshold) {\n-    _ratio_over_threshold_count++;\n-    _ratio_over_threshold_sum += short_term_pause_time_ratio;\n+  if (target_regions_to_shrink >= needed_for_allocation) {\n+    target_regions_to_shrink -= needed_for_allocation;\n+  } else {\n+    target_regions_to_shrink = 0;\n+  }\n+\n+  size_t resize_bytes = (double)G1HeapRegion::GrainBytes * target_regions_to_shrink * scale_factor;\n+\n+  log_debug(gc, ergo, heap)(\"Shrink log: scale factor %1.2f%% \"\n+                            \"total free regions %u \"\n+                            \"reserve regions %u \"\n+                            \"needed for alloc %u \"\n+                            \"base targeted for shrinking %u \"\n+                            \"resize_bytes %zd ( %zu regions)\",\n+                            scale_factor * 100.0,\n+                            _g1h->num_free_regions(),\n+                            reserve_regions,\n+                            needed_for_allocation,\n+                            target_regions_to_shrink,\n+                            resize_bytes,\n+                            (resize_bytes \/ G1HeapRegion::GrainBytes));\n+\n+  return resize_bytes;\n+}\n+\n+size_t G1HeapSizingPolicy::young_collection_resize_amount(bool& expand, size_t allocation_word_size) {\n+  assert(GCTimeRatio > 0, \"must be\");\n+  expand = false;\n+\n+  const double long_term_pause_time_ratio = _analytics->long_term_pause_time_ratio();\n+  const double short_term_pause_time_ratio = _analytics->short_term_pause_time_ratio();\n+\n+  \/\/ Calculate gc time ratio thresholds:\n+  \/\/ - upper threshold, directly based on GCTimeRatio. We do not want to exceed\n+  \/\/ this.\n+  \/\/ - lower threshold, we do not want to go under.\n+  \/\/ - mid threshold, halfway between upper and lower threshold, represents the\n+  \/\/ actual target when resizing the heap.\n+  double pause_time_threshold = 1.0 \/ (1.0 + GCTimeRatio);\n+\n+  pause_time_threshold = scale_with_heap(pause_time_threshold);\n+  const double min_gc_time_ratio_ratio = G1MinimumPercentOfGCTimeRatio \/ 100.0;\n+  double upper_threshold = pause_time_threshold * (1 + min_gc_time_ratio_ratio);\n+  double lower_threshold = pause_time_threshold * (1 - min_gc_time_ratio_ratio);\n+\n+  \/\/ Use threshold based relative to current GCTimeRatio to more quickly expand\n+  \/\/ and shrink at smaller heap sizes (relative to maximum).\n+  const double long_term_delta = rel_ratio(long_term_pause_time_ratio, pause_time_threshold);\n+  double short_term_ratio_delta = rel_ratio(short_term_pause_time_ratio, pause_time_threshold);\n+\n+  \/\/ If the short term GC time ratio exceeds a threshold, increment the occurrence\n+  \/\/ counter.\n+  if (short_term_pause_time_ratio > upper_threshold) {\n+    _ratio_exceeds_threshold++;\n+  } else if (short_term_pause_time_ratio < lower_threshold) {\n+    _ratio_exceeds_threshold--;\n+  }\n+  \/\/ Ignore very first sample as it is garbage.\n+  if (_long_term_count != 0 || _recent_pause_ratios.num() != 0) {\n+    _recent_pause_ratios.add(short_term_ratio_delta);\n@@ -109,0 +249,46 @@\n+  _long_term_count++;\n+\n+  log_trace(gc, ergo, heap)(\"Heap resize triggers: long term count: %u \"\n+                            \"long term interval: %u \"\n+                            \"delta: %1.2f \"\n+                            \"ratio exceeds threshold count: %d\",\n+                            _long_term_count,\n+                            long_term_count_limit(),\n+                            short_term_ratio_delta,\n+                            _ratio_exceeds_threshold);\n+\n+  log_debug(gc, ergo, heap)(\"Heap triggers: pauses-since-start: %u num-prev-pauses-for-heuristics: %u ratio-exceeds-threshold-count: %d\",\n+                            _recent_pause_ratios.num(), long_term_count_limit(), _ratio_exceeds_threshold);\n+\n+  \/\/ Check if there is a short- or long-term need for resizing, expansion first.\n+  \/\/\n+  \/\/ Short-term resizing need is detected by exceeding the upper or lower thresholds\n+  \/\/ multiple times, tracked in _ratio_exceeds_threshold. If it contains a large\n+  \/\/ positive or negative (larger than the respective thresholds), we trigger\n+  \/\/ resizing calculation.\n+  \/\/\n+  \/\/ Slowly occurring long-term changes to the actual gc time ratios are checked\n+  \/\/ only every once a while.\n+  \/\/\n+  \/\/ The _ratio_exceeds_threshold value is reset after each resize, or slowly\n+  \/\/ decayed if nothing happens.\n+\n+  size_t resize_bytes = 0;\n+\n+  const bool use_long_term_delta = (_long_term_count == long_term_count_limit());\n+  const double short_term_delta = _recent_pause_ratios.avg();\n+\n+  double delta;\n+  if (use_long_term_delta) {\n+    \/\/ For expansion, deltas are positive, and we want to expand aggressively.\n+    \/\/ For shrinking, deltas are negative, so the MAX2 below selects the least\n+    \/\/ aggressive one as we are using the absolute value for scaling.\n+    delta = MAX2(short_term_delta, long_term_delta);\n+  } else {\n+    delta = short_term_delta;\n+  }\n+  \/\/ Delta is negative when shrinking, but the calculation of the resize amount\n+  \/\/ always expects an absolute value. Do that here unconditionally.\n+  delta = fabsd(delta);\n+\n+  int ThresholdForShrink = (int)MIN2(G1ShortTermShrinkThreshold, long_term_count_limit());\n@@ -110,61 +296,9 @@\n-  log_trace(gc, ergo, heap)(\"Heap expansion triggers: pauses since start: %u \"\n-                            \"num prev pauses for heuristics: %u \"\n-                            \"ratio over threshold count: %u\",\n-                            _pauses_since_start,\n-                            _num_prev_pauses_for_heuristics,\n-                            _ratio_over_threshold_count);\n-\n-  \/\/ Check if we've had enough GC time ratio checks that were over the\n-  \/\/ threshold to trigger an expansion. We'll also expand if we've\n-  \/\/ reached the end of the history buffer and the average of all entries\n-  \/\/ is still over the threshold. This indicates a smaller number of GCs were\n-  \/\/ long enough to make the average exceed the threshold.\n-  bool filled_history_buffer = _pauses_since_start == _num_prev_pauses_for_heuristics;\n-  if ((_ratio_over_threshold_count == MinOverThresholdForGrowth) ||\n-      (filled_history_buffer && (long_term_pause_time_ratio > threshold))) {\n-    size_t min_expand_bytes = G1HeapRegion::GrainBytes;\n-    size_t reserved_bytes = _g1h->max_capacity();\n-    size_t committed_bytes = _g1h->capacity();\n-    size_t uncommitted_bytes = reserved_bytes - committed_bytes;\n-    size_t expand_bytes_via_pct =\n-      uncommitted_bytes * G1ExpandByPercentOfAvailable \/ 100;\n-    double scale_factor = 1.0;\n-\n-    \/\/ If the current size is less than 1\/4 of the Initial heap size, expand\n-    \/\/ by half of the delta between the current and Initial sizes. IE, grow\n-    \/\/ back quickly.\n-    \/\/\n-    \/\/ Otherwise, take the current size, or G1ExpandByPercentOfAvailable % of\n-    \/\/ the available expansion space, whichever is smaller, as the base\n-    \/\/ expansion size. Then possibly scale this size according to how much the\n-    \/\/ threshold has (on average) been exceeded by. If the delta is small\n-    \/\/ (less than the StartScaleDownAt value), scale the size down linearly, but\n-    \/\/ not by less than MinScaleDownFactor. If the delta is large (greater than\n-    \/\/ the StartScaleUpAt value), scale up, but adding no more than MaxScaleUpFactor\n-    \/\/ times the base size. The scaling will be linear in the range from\n-    \/\/ StartScaleUpAt to (StartScaleUpAt + ScaleUpRange). In other words,\n-    \/\/ ScaleUpRange sets the rate of scaling up.\n-    if (committed_bytes < InitialHeapSize \/ 4) {\n-      expand_bytes = (InitialHeapSize - committed_bytes) \/ 2;\n-    } else {\n-      double const MinScaleDownFactor = 0.2;\n-      double const MaxScaleUpFactor = 2;\n-      double const StartScaleDownAt = pause_time_threshold;\n-      double const StartScaleUpAt = pause_time_threshold * 1.5;\n-      double const ScaleUpRange = pause_time_threshold * 2.0;\n-\n-      double ratio_delta;\n-      if (filled_history_buffer) {\n-        ratio_delta = long_term_pause_time_ratio - threshold;\n-      } else {\n-        ratio_delta = (_ratio_over_threshold_sum \/ _ratio_over_threshold_count) - threshold;\n-      }\n-\n-      expand_bytes = MIN2(expand_bytes_via_pct, committed_bytes);\n-      if (ratio_delta < StartScaleDownAt) {\n-        scale_factor = ratio_delta \/ StartScaleDownAt;\n-        scale_factor = MAX2(scale_factor, MinScaleDownFactor);\n-      } else if (ratio_delta > StartScaleUpAt) {\n-        scale_factor = 1 + ((ratio_delta - StartScaleUpAt) \/ ScaleUpRange);\n-        scale_factor = MIN2(scale_factor, MaxScaleUpFactor);\n-      }\n+  if ((_ratio_exceeds_threshold == MinOverThresholdForExpansion) ||\n+      (use_long_term_delta && (long_term_pause_time_ratio > upper_threshold))) {\n+\n+    \/\/ Short-cut calculation if already at maximum capacity.\n+    if (_g1h->capacity() == _g1h->max_capacity()) {\n+      log_resize(short_term_pause_time_ratio, long_term_pause_time_ratio,\n+                 lower_threshold, upper_threshold, pause_time_threshold, true, 0, expand);\n+      reset_ratio_tracking_data();\n+      return resize_bytes;\n@@ -173,1 +307,2 @@\n-    expand_bytes = static_cast<size_t>(expand_bytes * scale_factor);\n+    log_trace(gc, ergo, heap)(\"expand deltas long %1.2f short %1.2f use long term %u delta %1.2f\",\n+                              long_term_delta, short_term_delta, use_long_term_delta, delta);\n@@ -175,3 +310,2 @@\n-    \/\/ Ensure the expansion size is at least the minimum growth amount\n-    \/\/ and at most the remaining uncommitted byte size.\n-    expand_bytes = clamp(expand_bytes, min_expand_bytes, uncommitted_bytes);\n+    resize_bytes = young_collection_expand_amount(delta);\n+    expand = true;\n@@ -179,11 +313,10 @@\n-    clear_ratio_check_data();\n-  } else {\n-    \/\/ An expansion was not triggered. If we've started counting, increment\n-    \/\/ the number of checks we've made in the current window.  If we've\n-    \/\/ reached the end of the window without resizing, clear the counters to\n-    \/\/ start again the next time we see a ratio above the threshold.\n-    if (_ratio_over_threshold_count > 0) {\n-      _pauses_since_start++;\n-      if (_pauses_since_start > _num_prev_pauses_for_heuristics) {\n-        clear_ratio_check_data();\n-      }\n+    reset_ratio_tracking_data();\n+  } else if ((_ratio_exceeds_threshold == -ThresholdForShrink) ||\n+             (use_long_term_delta && (long_term_pause_time_ratio < lower_threshold))) {\n+\n+    \/\/ Short-cut calculation if already at minimum capacity.\n+    if (_g1h->capacity() == _g1h->min_capacity()) {\n+      log_resize(short_term_pause_time_ratio, long_term_pause_time_ratio,\n+                 lower_threshold, upper_threshold, pause_time_threshold, true, 0, expand);\n+      reset_ratio_tracking_data();\n+      return resize_bytes;\n@@ -191,0 +324,12 @@\n+\n+    log_trace(gc, ergo, heap)(\"expand deltas long %1.2f short %1.2f use long term %u delta %1.2f\",\n+                              long_term_delta, short_term_delta, use_long_term_delta, delta);\n+\n+    resize_bytes = young_collection_shrink_amount(delta, allocation_word_size);\n+    expand = false;\n+\n+    reset_ratio_tracking_data();\n+  } else if (use_long_term_delta) {\n+    \/\/ A resize has not been triggered, but the long term counter overflowed.\n+    decay_ratio_tracking_data();\n+    expand = true; \/\/ Does not matter.\n@@ -193,2 +338,3 @@\n-  log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,\n-                threshold, pause_time_threshold, false, expand_bytes);\n+  log_resize(short_term_pause_time_ratio, long_term_pause_time_ratio,\n+             lower_threshold, upper_threshold, pause_time_threshold,\n+             false, resize_bytes, expand);\n@@ -196,1 +342,1 @@\n-  return expand_bytes;\n+  return resize_bytes;\n@@ -260,1 +406,1 @@\n-  minimum_desired_capacity = MIN2(minimum_desired_capacity, MaxHeapSize);\n+  minimum_desired_capacity = MIN2(minimum_desired_capacity, _g1h->max_capacity());\n@@ -264,1 +410,1 @@\n-  maximum_desired_capacity =  MAX2(maximum_desired_capacity, MinHeapSize);\n+  maximum_desired_capacity =  MAX2(maximum_desired_capacity, _g1h->min_capacity());\n@@ -270,4 +416,4 @@\n-    log_debug(gc, ergo, heap)(\"Attempt heap expansion (capacity lower than min desired capacity). \"\n-                              \"Capacity: %zuB occupancy: %zuB live: %zuB \"\n-                              \"min_desired_capacity: %zuB (%zu %%)\",\n-                              capacity_after_gc, used_after_gc, _g1h->used(), minimum_desired_capacity, MinHeapFreeRatio);\n+    log_debug(gc, ergo, heap)(\"Heap resize. Attempt heap expansion (capacity lower than min desired capacity). \"\n+                              \"Capacity: %zuMB occupancy: %zuMB live: %zuMB \"\n+                              \"min_desired_capacity: %zuMB (%zu %%)\",\n+                              capacity_after_gc \/ M, used_after_gc \/ M, _g1h->used() \/ M, minimum_desired_capacity \/ M, MinHeapFreeRatio);\n@@ -282,4 +428,4 @@\n-    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (capacity higher than max desired capacity). \"\n-                              \"Capacity: %zuB occupancy: %zuB live: %zuB \"\n-                              \"maximum_desired_capacity: %zuB (%zu %%)\",\n-                              capacity_after_gc, used_after_gc, _g1h->used(), maximum_desired_capacity, MaxHeapFreeRatio);\n+    log_debug(gc, ergo, heap)(\"Heap resize. Attempt heap shrinking (capacity higher than max desired capacity). \"\n+                              \"Capacity: %zuMB occupancy: %zuMB live: %zuMB \"\n+                              \"maximum_desired_capacity: %zuMB (%zu %%)\",\n+                              capacity_after_gc \/ M, used_after_gc \/ M, _g1h->used() \/ M, maximum_desired_capacity \/ M, MaxHeapFreeRatio);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":273,"deletions":127,"binary":false,"changes":400,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/numberSeq.hpp\"\n@@ -33,0 +34,35 @@\n+\/\/\n+\/\/ Contains heuristics to resize the heap, i.e. expand or shrink, during operation.\n+\/\/\n+\/\/ For young collections, this heuristics is based on gc time ratio, i.e. trying\n+\/\/ to change the heap so that current gc time ratio stays approximately as\n+\/\/ selected  by the user.\n+\/\/\n+\/\/ The heuristics tracks both short and long term GC behavior to effect heap size\n+\/\/ change.\n+\/\/\n+\/\/ Short term tracking is based on the short-term gc time ratio i.e we  count\n+\/\/ events for which short-term gc time ratio is outside the range of\n+\/\/ [GCTimeRatio * (1 - G1MinimumPercentOfGCTimeRatio \/ 100), GCTimeRatio * (1 + G1MinimumPercentOfGCTimeRatio \/ 100)]\n+\/\/ If below that range, we decrement that counter, if above, we increment it.\n+\/\/\n+\/\/ The intent of this mechanism is to filter short term events because heap sizing has\n+\/\/ some overhead.\n+\/\/\n+\/\/ If that counter reaches the MinOverThresholdForExpansion we consider expansion,\n+\/\/ if that counter reaches -G1ShortTermShrinkThreshold we consider shrinking the heap.\n+\/\/\n+\/\/ While doing so, we accumulate the relative difference to the midpoint of this range\n+\/\/ (GCTimeRatio) to guide the expansion\/shrinking amount.\n+\/\/\n+\/\/ Further, if there is no short-term based resizing event for a \"long\" time, we\n+\/\/ decay that counter, i.e. drop it towards zero again to avoid that previous\n+\/\/ intermediate length short term behavior followed by a quiet time and a single\n+\/\/ short term event causes unnecessary resizes.\n+\/\/\n+\/\/ Long term behavior is solely managed by regularly comparing actual long term gc\n+\/\/ time ratio with the boundaries of above range in regular long term  intervals.\n+\/\/ If current long term gc time ratio is outside, expand or shrink  respectively.\n+\/\/\n+\/\/ For full collections, we base resize decisions only on Min\/MaxHeapFreeRatio.\n+\/\/\n@@ -34,4 +70,3 @@\n-  \/\/ MinOverThresholdForGrowth must be less than the number of recorded\n-  \/\/ pause times in G1Analytics, representing the minimum number of pause\n-  \/\/ time ratios that exceed GCTimeRatio before a heap expansion will be triggered.\n-  const static uint MinOverThresholdForGrowth = 4;\n+  \/\/ MinOverThresholdForExpansion defines the number of actual gc time\n+  \/\/ ratios over the upper and lower thresholds respectively.\n+  const static int MinOverThresholdForExpansion = 4;\n@@ -42,5 +77,8 @@\n-  const uint _num_prev_pauses_for_heuristics;\n-  \/\/ Ratio check data for determining if heap growth is necessary.\n-  uint _ratio_over_threshold_count;\n-  double _ratio_over_threshold_sum;\n-  uint _pauses_since_start;\n+  uint long_term_count_limit() const;\n+  \/\/ Number of times short-term gc time ratio crossed the lower or upper threshold\n+  \/\/ recently; every time the upper threshold is exceeded, it is incremented,  and\n+  \/\/ decremented if the lower threshold is exceeded.\n+  int _ratio_exceeds_threshold;\n+  \/\/ Recent actual gc time ratios relative to the middle of lower and upper threshold.\n+  TruncatedSeq _recent_pause_ratios;\n+  uint _long_term_count;\n@@ -48,1 +86,6 @@\n-  \/\/ Scale \"full\" gc pause time threshold with heap size as we want to resize more\n+  \/\/ Clear ratio tracking data used by resize_amount().\n+  void reset_ratio_tracking_data();\n+  \/\/ Decay (move towards \"no changes\") ratio tracking data.\n+  void decay_ratio_tracking_data();\n+\n+  \/\/ Scale \"full\" gc time ratio threshold with heap size as we want to resize more\n@@ -52,0 +95,6 @@\n+  \/\/ Scale the ratio delta depending on the relative difference from the target gc time ratio.\n+  double scale_resize_ratio_delta(double ratio_delta, double min_scale_down_factor, double max_scale_up_factor) const;\n+\n+  size_t young_collection_expand_amount(double delta) const;\n+  size_t young_collection_shrink_amount(double delta, size_t allocation_word_size) const;\n+\n@@ -55,3 +104,4 @@\n-  \/\/ If an expansion would be appropriate, because recent GC overhead had\n-  \/\/ exceeded the desired limit, return an amount to expand by.\n-  size_t young_collection_expansion_amount();\n+  \/\/ Return by how many bytes the heap should be changed based on recent gc time\n+  \/\/ ratio after young collection. If expand is set, the heap should be expanded,\n+  \/\/ otherwise shrunk.\n+  size_t young_collection_resize_amount(bool& expand, size_t allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.hpp","additions":63,"deletions":13,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1065,1 +1065,1 @@\n-  _g1h->expand_heap_after_young_collection();\n+  _g1h->resize_heap_after_young_collection(_allocation_word_size);\n@@ -1080,1 +1080,2 @@\n-G1YoungCollector::G1YoungCollector(GCCause::Cause gc_cause) :\n+G1YoungCollector::G1YoungCollector(GCCause::Cause gc_cause,\n+                                   size_t allocation_word_size) :\n@@ -1083,0 +1084,1 @@\n+  _allocation_word_size(allocation_word_size),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,0 +82,1 @@\n+  size_t _allocation_word_size;\n@@ -140,1 +141,2 @@\n-  G1YoungCollector(GCCause::Cause gc_cause);\n+  G1YoungCollector(GCCause::Cause gc_cause,\n+                   size_t allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -164,0 +164,13 @@\n+  product(size_t, G1ShrinkByPercentOfAvailable, 50, EXPERIMENTAL,           \\\n+          \"When shrinking, maximum % of free space to claim.\")              \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n+  product(size_t, G1MinimumPercentOfGCTimeRatio, 25, EXPERIMENTAL,          \\\n+          \"Percentage of GCTimeRatio G1 will try to avoid going below.\")    \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n+  product(uint, G1ShortTermShrinkThreshold, 8, EXPERIMENTAL,                \\\n+          \"Number of consecutive GCs with the short term gc time ratio\"     \\\n+          \"below the threshold before we attempt to shrink.\")               \\\n+          range(0, 10)                                                      \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,0 +35,8 @@\n+void AbsSeq::reset() {\n+  _num = 0;\n+  _sum = 0.0;\n+  _sum_of_squares = 0.0;\n+  _davg = 0.0;\n+  _dvariance = 0.0;\n+}\n+\n@@ -140,1 +148,1 @@\n-TruncatedSeq::TruncatedSeq(int length, double alpha):\n+TruncatedSeq::TruncatedSeq(uint length, double alpha):\n@@ -143,2 +151,1 @@\n-  for (int i = 0; i < _length; ++i)\n-    _sequence[i] = 0.0;\n+  TruncatedSeq::reset();\n@@ -180,1 +187,1 @@\n-  for (int i = 1; i < _num; ++i) {\n+  for (uint i = 1; i < _num; ++i) {\n@@ -227,1 +234,1 @@\n-  for (int i = 0; i < _num; ++i) {\n+  for (uint i = 0; i < _num; ++i) {\n@@ -247,0 +254,7 @@\n+void TruncatedSeq::reset() {\n+  AbsSeq::reset();\n+  for (uint i = 0; i < _length; ++i) {\n+    _sequence[i] = 0.0;\n+  }\n+  _next = 0;\n+}\n@@ -267,1 +281,1 @@\n-  for (int i = 0; i < _length; i++) {\n+  for (uint i = 0; i < _length; i++) {\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.cpp","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-  int    _num; \/\/ the number of elements in the sequence\n+  uint    _num; \/\/ the number of elements in the sequence\n@@ -65,0 +65,1 @@\n+  virtual void reset();\n@@ -109,1 +110,1 @@\n-  enum PrivateConstants {\n+  enum PrivateConstants : uint {\n@@ -115,1 +116,1 @@\n-  int     _length; \/\/ this is L\n+  uint    _length; \/\/ this is L\n@@ -120,1 +121,1 @@\n-  TruncatedSeq(int length = DefaultSeqLength,\n+  TruncatedSeq(uint length = DefaultSeqLength,\n@@ -130,0 +131,2 @@\n+  virtual void reset();\n+  bool is_full() const { return _length == _num; }\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n@@ -43,0 +42,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -197,1 +197,1 @@\n-        new LogMessageWithLevel(\"Expand Heap After Collection:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Resize Heap After Collection:\", Level.DEBUG),\n@@ -323,2 +323,1 @@\n-        output.shouldContain(\"Expand the heap. requested expansion amount: \");\n-        output.shouldContain(\"B expansion amount: \");\n+        output.shouldContain(\"Heap resize: \");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"}]}