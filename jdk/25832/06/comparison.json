{"files":[{"patch":"@@ -113,1 +113,1 @@\n-  uint number_of_recorded_pause_times() const {\n+  static constexpr uint max_num_of_recorded_pause_times() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,2 +199,2 @@\n-    \/\/ We set it here to ~8%.\n-    FLAG_SET_DEFAULT(GCTimeRatio, 12);\n+    \/\/ We set it here to 4%.\n+    FLAG_SET_DEFAULT(GCTimeRatio, 24);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -798,2 +798,1 @@\n-  resize_heap_if_necessary(allocation_word_size);\n-  uncommit_regions_if_necessary();\n+  resize_heap_after_full_collection(allocation_word_size);\n@@ -882,1 +881,11 @@\n-void G1CollectedHeap::resize_heap_if_necessary(size_t allocation_word_size) {\n+\n+void G1CollectedHeap::resize_heap(size_t resize_bytes, bool should_expand) {\n+  if (should_expand) {\n+    expand(resize_bytes, _workers);\n+  } else {\n+    shrink(resize_bytes);\n+    uncommit_regions_if_necessary();\n+  }\n+}\n+\n+void G1CollectedHeap::resize_heap_after_full_collection(size_t allocation_word_size) {\n@@ -886,1 +895,1 @@\n-  size_t resize_amount = _heap_sizing_policy->full_collection_resize_amount(should_expand, allocation_word_size);\n+  size_t resize_bytes = _heap_sizing_policy->full_collection_resize_amount(should_expand, allocation_word_size);\n@@ -888,6 +897,2 @@\n-  if (resize_amount == 0) {\n-    return;\n-  } else if (should_expand) {\n-    expand(resize_amount, _workers);\n-  } else {\n-    shrink(resize_amount);\n+  if (resize_bytes != 0) {\n+    resize_heap(resize_bytes, should_expand);\n@@ -897,0 +902,14 @@\n+void G1CollectedHeap::resize_heap_after_young_collection(size_t allocation_word_size) {\n+  Ticks start = Ticks::now();\n+\n+  bool should_expand;\n+\n+  size_t resize_bytes = _heap_sizing_policy->young_collection_resize_amount(should_expand, allocation_word_size);\n+\n+  if (resize_bytes != 0) {\n+    resize_heap(resize_bytes, should_expand);\n+  }\n+\n+  phase_times()->record_resize_heap_time((Ticks::now() - start).seconds() * 1000.0);\n+}\n+\n@@ -1005,0 +1024,2 @@\n+  assert(expand_bytes > 0, \"precondition\");\n+\n@@ -1008,2 +1029,4 @@\n-  log_debug(gc, ergo, heap)(\"Expand the heap. requested expansion amount: %zuB expansion amount: %zuB\",\n-                            expand_bytes, aligned_expand_bytes);\n+  uint num_regions_to_expand = (uint)(aligned_expand_bytes \/ G1HeapRegion::GrainBytes);\n+\n+  log_debug(gc, ergo, heap)(\"Heap resize. Requested expansion amount: %zuB aligned expansion amount: %zuB (%u regions)\",\n+                            expand_bytes, aligned_expand_bytes, num_regions_to_expand);\n@@ -1012,1 +1035,1 @@\n-    log_debug(gc, ergo, heap)(\"Did not expand the heap (heap already fully expanded)\");\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not expand the heap (heap already fully expanded)\");\n@@ -1016,5 +1039,1 @@\n-  uint regions_to_expand = (uint)(aligned_expand_bytes \/ G1HeapRegion::GrainBytes);\n-  assert(regions_to_expand > 0, \"Must expand by at least one region\");\n-\n-  uint expanded_by = _hrm.expand_by(regions_to_expand, pretouch_workers);\n-  assert(expanded_by > 0, \"must have failed during commit.\");\n+  uint expanded_by = _hrm.expand_by(num_regions_to_expand, pretouch_workers);\n@@ -1043,2 +1062,5 @@\n-  size_t aligned_shrink_bytes = os::align_down_vm_page_size(shrink_bytes);\n-  aligned_shrink_bytes = align_down(aligned_shrink_bytes, G1HeapRegion::GrainBytes);\n+  assert(shrink_bytes > 0, \"must be\");\n+  assert(is_aligned(shrink_bytes, G1HeapRegion::GrainBytes),\n+         \"Shrink request for %zuB not aligned to heap region size %zuB\",\n+         shrink_bytes, G1HeapRegion::GrainBytes);\n+\n@@ -1050,2 +1072,2 @@\n-  log_debug(gc, ergo, heap)(\"Shrink the heap. requested shrinking amount: %zuB aligned shrinking amount: %zuB actual amount shrunk: %zuB\",\n-                            shrink_bytes, aligned_shrink_bytes, shrunk_bytes);\n+  log_debug(gc, ergo, heap)(\"Heap resize. Requested shrinking amount: %zuB actual shrinking amount: %zuB (%u regions)\",\n+                            shrink_bytes, shrunk_bytes, num_regions_removed);\n@@ -1053,1 +1075,0 @@\n-    log_debug(gc, heap)(\"Uncommittable regions after shrink: %u\", num_regions_removed);\n@@ -1056,1 +1077,1 @@\n-    log_debug(gc, ergo, heap)(\"Did not shrink the heap (heap shrinking operation failed)\");\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not shrink the heap (heap shrinking operation failed)\");\n@@ -1061,0 +1082,19 @@\n+  if (capacity() == min_capacity()) {\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not shrink the heap (heap already at minimum)\");\n+    return;\n+  }\n+\n+  size_t aligned_shrink_bytes = os::align_down_vm_page_size(shrink_bytes);\n+  aligned_shrink_bytes = align_down(aligned_shrink_bytes, G1HeapRegion::GrainBytes);\n+\n+  aligned_shrink_bytes = capacity() - MAX2(capacity() - aligned_shrink_bytes, min_capacity());\n+  assert(is_aligned(aligned_shrink_bytes, G1HeapRegion::GrainBytes), \"Bytes to shrink %zuB not aligned\", aligned_shrink_bytes);\n+\n+  log_debug(gc, ergo, heap)(\"Heap resize. Requested shrink amount: %zuB aligned shrink amount: %zuB\",\n+                            shrink_bytes, aligned_shrink_bytes);\n+\n+  if (aligned_shrink_bytes == 0) {\n+    log_debug(gc, ergo, heap)(\"Heap resize. Did not shrink the heap (shrink request too small)\");\n+    return;\n+  }\n+\n@@ -1072,1 +1112,1 @@\n-  shrink_helper(shrink_bytes);\n+  shrink_helper(aligned_shrink_bytes);\n@@ -1341,1 +1381,1 @@\n-                       MinHeapSize,\n+                       min_capacity(),\n@@ -2027,1 +2067,1 @@\n-  return (_policy->young_list_target_length() - _survivor.length()) * G1HeapRegion::GrainBytes;\n+  return eden_target_length() * G1HeapRegion::GrainBytes;\n@@ -2048,0 +2088,4 @@\n+size_t G1CollectedHeap::min_capacity() const {\n+  return MinHeapSize;\n+}\n+\n@@ -2393,14 +2437,1 @@\n-void G1CollectedHeap::expand_heap_after_young_collection(){\n-  size_t expand_bytes = _heap_sizing_policy->young_collection_expansion_amount();\n-  if (expand_bytes > 0) {\n-    \/\/ No need for an ergo logging here,\n-    \/\/ expansion_amount() does this when it returns a value > 0.\n-    Ticks expand_start = Ticks::now();\n-    if (expand(expand_bytes, _workers)) {\n-      double expand_ms = (Ticks::now() - expand_start).seconds() * MILLIUNITS;\n-      phase_times()->record_expand_heap_time(expand_ms);\n-    }\n-  }\n-}\n-\n-void G1CollectedHeap::do_collection_pause_at_safepoint() {\n+void G1CollectedHeap::do_collection_pause_at_safepoint(size_t allocation_word_size) {\n@@ -2410,1 +2441,1 @@\n-  do_collection_pause_at_safepoint_helper();\n+  do_collection_pause_at_safepoint_helper(allocation_word_size);\n@@ -2474,1 +2505,1 @@\n-void G1CollectedHeap::do_collection_pause_at_safepoint_helper() {\n+void G1CollectedHeap::do_collection_pause_at_safepoint_helper(size_t allocation_word_size) {\n@@ -2492,1 +2523,1 @@\n-  G1YoungCollector collector(gc_cause());\n+  G1YoungCollector collector(gc_cause(), allocation_word_size);\n@@ -2614,0 +2645,7 @@\n+  uint total_allocated = _survivor_evac_stats.regions_filled() + _old_evac_stats.regions_filled();\n+\n+  log_debug(gc)(\"Allocated %u survivor %u old percent total %1.2f%% (%u%%)\",\n+                _survivor_evac_stats.regions_filled(), _old_evac_stats.regions_filled(),\n+                percent_of(total_allocated, num_committed_regions() - total_allocated),\n+                G1ReservePercent);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":82,"deletions":44,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -476,0 +476,2 @@\n+  void resize_heap(size_t resize_bytes, bool should_expand);\n+\n@@ -561,1 +563,2 @@\n-  void resize_heap_if_necessary(size_t allocation_word_size);\n+  void resize_heap_after_young_collection(size_t allocation_word_size);\n+  void resize_heap_after_full_collection(size_t allocation_word_size);\n@@ -746,1 +749,1 @@\n-  void do_collection_pause_at_safepoint();\n+  void do_collection_pause_at_safepoint(size_t allocation_word_size = 0);\n@@ -750,1 +753,1 @@\n-  void do_collection_pause_at_safepoint_helper();\n+  void do_collection_pause_at_safepoint_helper(size_t allocation_word_size);\n@@ -767,2 +770,0 @@\n-  void expand_heap_after_young_collection();\n-  \/\/ Update object copying statistics.\n@@ -1025,0 +1026,2 @@\n+  bool last_gc_was_periodic() { return _gc_lastcause == GCCause::_g1_periodic_collection; }\n+\n@@ -1193,0 +1196,1 @@\n+  size_t min_capacity() const;\n@@ -1207,0 +1211,1 @@\n+  inline uint eden_target_length() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -319,0 +319,4 @@\n+inline uint G1CollectedHeap::eden_target_length() const {\n+  return _policy->young_list_target_length() - survivor_regions_count();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1453,2 +1453,3 @@\n-    _g1h->resize_heap_if_necessary(size_t(0) \/* allocation_word_size *\/);\n-    _g1h->uncommit_regions_if_necessary();\n+    if (_g1h->last_gc_was_periodic()) {\n+      _g1h->resize_heap_after_full_collection(0 \/* allocation_word_size *\/);\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  _cur_expand_heap_time_ms = 0.0;\n+  _cur_resize_heap_time_ms = 0.0;\n@@ -491,1 +491,1 @@\n-                        _cur_expand_heap_time_ms;\n+                        _cur_resize_heap_time_ms;\n@@ -540,1 +540,1 @@\n-  debug_time(\"Expand Heap After Collection\", _cur_expand_heap_time_ms);\n+  debug_time(\"Resize Heap After Collection\", _cur_resize_heap_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-  double _cur_expand_heap_time_ms;\n+  double _cur_resize_heap_time_ms;\n@@ -286,2 +286,2 @@\n-  void record_expand_heap_time(double ms) {\n-    _cur_expand_heap_time_ms = ms;\n+  void record_resize_heap_time(double ms) {\n+    _cur_resize_heap_time_ms = ms;\n@@ -408,2 +408,2 @@\n-  double cur_expand_heap_time_ms() {\n-    return _cur_expand_heap_time_ms;\n+  double cur_resize_heap_time_ms() {\n+    return _cur_resize_heap_time_ms;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -41,1 +41,6 @@\n-  _num_prev_pauses_for_heuristics(analytics->number_of_recorded_pause_times()) {\n+  \/\/ Bias for expansion at startup; the +1 is to counter the first sample always\n+  \/\/ being 0.0, i.e. lower than any threshold.\n+  _gc_cpu_usage_deviation_counter((G1CPUUsageExpandThreshold \/ 2) + 1),\n+  _recent_cpu_usage_deltas(long_term_count_limit()),\n+  _long_term_count(0) {\n+}\n@@ -43,2 +48,4 @@\n-  assert(MinOverThresholdForGrowth < _num_prev_pauses_for_heuristics, \"Threshold must be less than %u\", _num_prev_pauses_for_heuristics);\n-  clear_ratio_check_data();\n+void G1HeapSizingPolicy::reset_cpu_usage_tracking_data() {\n+  _long_term_count = 0;\n+  _gc_cpu_usage_deviation_counter = 0;\n+  \/\/ Keep the recent GC CPU usage data.\n@@ -47,4 +54,4 @@\n-void G1HeapSizingPolicy::clear_ratio_check_data() {\n-  _ratio_over_threshold_count = 0;\n-  _ratio_over_threshold_sum = 0.0;\n-  _pauses_since_start = 0;\n+void G1HeapSizingPolicy::decay_cpu_usage_tracking_data() {\n+  _long_term_count = 0;\n+  _gc_cpu_usage_deviation_counter \/= 2;\n+  \/\/ Keep the recent GC CPU usage data.\n@@ -53,2 +60,2 @@\n-double G1HeapSizingPolicy::scale_with_heap(double pause_time_threshold) {\n-  double threshold = pause_time_threshold;\n+double G1HeapSizingPolicy::scale_with_heap(double gc_cpu_usage_target) {\n+  double target = gc_cpu_usage_target;\n@@ -59,2 +66,2 @@\n-    threshold *= (double)_g1h->capacity() \/ (double)(_g1h->max_capacity() \/ 2);\n-    threshold = MAX2(threshold, 0.01);\n+    target *= (double)_g1h->capacity() \/ (double)(_g1h->max_capacity() \/ 2);\n+    target = MAX2(target, 0.01);\n@@ -63,1 +70,1 @@\n-  return threshold;\n+  return target;\n@@ -66,17 +73,21 @@\n-static void log_expansion(double short_term_pause_time_ratio,\n-                          double long_term_pause_time_ratio,\n-                          double threshold,\n-                          double pause_time_ratio,\n-                          bool fully_expanded,\n-                          size_t resize_bytes) {\n-\n-  log_debug(gc, ergo, heap)(\"Heap expansion: \"\n-                            \"short term pause time ratio %1.2f%% long term pause time ratio %1.2f%% \"\n-                            \"threshold %1.2f%% pause time ratio %1.2f%% fully expanded %s \"\n-                            \"resize by %zuB\",\n-                            short_term_pause_time_ratio * 100.0,\n-                            long_term_pause_time_ratio * 100.0,\n-                            threshold * 100.0,\n-                            pause_time_ratio * 100.0,\n-                            BOOL_TO_STR(fully_expanded),\n-                            resize_bytes);\n+static void log_resize(double short_term_cpu_usage,\n+                       double long_term_cpu_usage,\n+                       double lower_threshold,\n+                       double upper_threshold,\n+                       double cpu_usage_target,\n+                       bool at_limit,\n+                       size_t resize_bytes,\n+                       bool expand) {\n+\n+  log_debug(gc, ergo, heap)(\"Heap resize: \"\n+                            \"short term GC CPU usage %1.2f%% long term GC CPU usage %1.2f%% \"\n+                            \"lower threshold %1.2f%% upper threshold %1.2f%% GC CPU usage target %1.2f%% \"\n+                            \"at limit %s resize by %zuB expand %s\",\n+                            short_term_cpu_usage * 100.0,\n+                            long_term_cpu_usage * 100.0,\n+                            lower_threshold * 100.0,\n+                            upper_threshold * 100.0,\n+                            cpu_usage_target * 100.0,\n+                            BOOL_TO_STR(at_limit),\n+                            resize_bytes,\n+                            BOOL_TO_STR(expand));\n@@ -85,2 +96,7 @@\n-size_t G1HeapSizingPolicy::young_collection_expansion_amount() {\n-  assert(GCTimeRatio > 0, \"must be\");\n+\/\/ Logistic function, returns values in the range [0,1]\n+static double sigmoid_function(double value) {\n+  \/\/ Sigmoid Parameters:\n+  double inflection_point = 1.0; \/\/ Inflection point (midpoint of the sigmoid).\n+  double steepness = 6.0;\n+  return 1.0 \/ (1.0 + exp(-steepness * (value - inflection_point)));\n+}\n@@ -88,4 +104,33 @@\n-  double long_term_pause_time_ratio = _analytics->long_term_pause_time_ratio();\n-  double short_term_pause_time_ratio = _analytics->short_term_pause_time_ratio();\n-  const double pause_time_threshold = 1.0 \/ (1.0 + GCTimeRatio);\n-  double threshold = scale_with_heap(pause_time_threshold);\n+\/\/ Computes a smooth scaling factor based on the relative deviation of actual gc_cpu_usage\n+\/\/ from the gc_cpu_usage_target, using a sigmoid function to transition between\n+\/\/ the specified minimum and maximum scaling factors.\n+\/\/\n+\/\/ The input cpu_usage_delta represents the relative deviation of the current gc_cpu_usage to the\n+\/\/ gc_cpu_usage_target. This value is passed through a sigmoid function that produces a smooth\n+\/\/ output between 0 and 1, which is then scaled to the range [min_scale_factor, max_scale_factor].\n+\/\/\n+\/\/ The sigmoid's inflection point is set at cpu_usage_delta = 1.0 (a 100% deviation), where the scaling\n+\/\/ response increases most rapidly.\n+\/\/\n+\/\/ The steepness parameter controls how sharply the scale factor changes near the inflection point.\n+\/\/  * Low steepness (1-3): gradual scaling over a wide range of deviations (more conservative).\n+\/\/  * High steepness (7-10): rapid scaling near the inflection point; small deviations result\n+\/\/                           in very low scaling, but larger deviations ramp up scaling quickly.\n+\/\/                           Steepness at 10 is nearly a step function.\n+\/\/\n+\/\/ In this case, we choose a steepness of 6.0:\n+\/\/ - For small deviations, the sigmoid output is close to 0, resulting in scale factors near the\n+\/\/   lower bound, preventing excessive resizing.\n+\/\/ - As cpu_usage_delta grows toward 1.0, the steepness value makes the transition sharper, enabling\n+\/\/   more aggressive scaling for large deviations.\n+\/\/\n+\/\/ This helps avoid overreacting to small gc_cpu_usage deviations but respond appropriately\n+\/\/ when necessary.\n+double G1HeapSizingPolicy::scale_cpu_usage_delta(double cpu_usage_delta,\n+                                                 double min_scale_factor,\n+                                                 double max_scale_factor) const {\n+  double sigmoid = sigmoid_function(cpu_usage_delta);\n+\n+  double scale_factor = min_scale_factor + (max_scale_factor - min_scale_factor) * sigmoid;\n+  return scale_factor;\n+}\n@@ -93,1 +138,4 @@\n-  size_t expand_bytes = 0;\n+\/\/ Calculate the relative difference between a and b.\n+static double rel_diff(double a, double b) {\n+  return (a - b) \/ b;\n+}\n@@ -95,5 +143,48 @@\n-  if (_g1h->capacity() == _g1h->max_capacity()) {\n-    log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,\n-                  threshold, pause_time_threshold, true, 0);\n-    clear_ratio_check_data();\n-    return expand_bytes;\n+size_t G1HeapSizingPolicy::young_collection_expand_amount(double cpu_usage_delta) const {\n+  assert(cpu_usage_delta >= 0.0, \"must be\");\n+\n+  size_t reserved_bytes = _g1h->max_capacity();\n+  size_t committed_bytes = _g1h->capacity();\n+  size_t uncommitted_bytes = reserved_bytes - committed_bytes;\n+  size_t expand_bytes_via_pct = uncommitted_bytes * G1ExpandByPercentOfAvailable \/ 100;\n+  size_t min_expand_bytes = MIN2(G1HeapRegion::GrainBytes, uncommitted_bytes);\n+\n+  \/\/ Take the current size or G1ExpandByPercentOfAvailable % of\n+  \/\/ the available expansion space, whichever is smaller, as the base\n+  \/\/ expansion size. Then possibly scale this size according to how much the\n+  \/\/ GC CPU usage (on average) has exceeded the target.\n+  const double min_scale_factor = 0.2;\n+  const double max_scale_factor = 2.0;\n+\n+  double scale_factor = scale_cpu_usage_delta(cpu_usage_delta,\n+                                              min_scale_factor,\n+                                              max_scale_factor);\n+\n+  size_t resize_bytes = MIN2(expand_bytes_via_pct, committed_bytes);\n+\n+  resize_bytes = static_cast<size_t>(resize_bytes * scale_factor);\n+\n+  \/\/ Ensure the expansion size is at least the minimum growth amount\n+  \/\/ and at most the remaining uncommitted byte size.\n+  return clamp(resize_bytes, min_expand_bytes, uncommitted_bytes);\n+}\n+\n+size_t G1HeapSizingPolicy::young_collection_shrink_amount(double cpu_usage_delta, size_t allocation_word_size) const {\n+  assert(cpu_usage_delta >= 0.0, \"must be\");\n+\n+  const double min_scale_factor = G1ShrinkByPercentOfAvailable \/ 1000.0;\n+  const double max_scale_factor = G1ShrinkByPercentOfAvailable \/ 100.0;\n+\n+  double scale_factor = scale_cpu_usage_delta(cpu_usage_delta,\n+                                              min_scale_factor,\n+                                              max_scale_factor);\n+  assert(scale_factor <= max_scale_factor, \"must be\");\n+\n+  \/\/ We are at the end of GC, so free regions are at maximum. Do not try to shrink\n+  \/\/ to have less than the reserve or the number of regions we are most certainly\n+  \/\/ going to use during this mutator phase.\n+  uint target_regions_to_shrink = _g1h->num_free_regions();\n+\n+  uint needed_for_allocation = _g1h->eden_target_length();\n+  if (_g1h->is_humongous(allocation_word_size)) {\n+    needed_for_allocation += (uint) _g1h->humongous_obj_size_in_regions(allocation_word_size);\n@@ -102,6 +193,96 @@\n-  \/\/ If the last GC time ratio is over the threshold, increment the count of\n-  \/\/ times it has been exceeded, and add this ratio to the sum of exceeded\n-  \/\/ ratios.\n-  if (short_term_pause_time_ratio > threshold) {\n-    _ratio_over_threshold_count++;\n-    _ratio_over_threshold_sum += short_term_pause_time_ratio;\n+  if (target_regions_to_shrink >= needed_for_allocation) {\n+    target_regions_to_shrink -= needed_for_allocation;\n+  } else {\n+    target_regions_to_shrink = 0;\n+  }\n+\n+  size_t resize_bytes = (double)G1HeapRegion::GrainBytes * target_regions_to_shrink * scale_factor;\n+\n+  log_debug(gc, ergo, heap)(\"Shrink log: scale factor %1.2f%% \"\n+                            \"total free regions %u \"\n+                            \"needed for alloc %u \"\n+                            \"base targeted for shrinking %u \"\n+                            \"resize_bytes %zd ( %zu regions)\",\n+                            scale_factor * 100.0,\n+                            _g1h->num_free_regions(),\n+                            needed_for_allocation,\n+                            target_regions_to_shrink,\n+                            resize_bytes,\n+                            (resize_bytes \/ G1HeapRegion::GrainBytes));\n+\n+  return resize_bytes;\n+}\n+\n+size_t G1HeapSizingPolicy::young_collection_resize_amount(bool& expand, size_t allocation_word_size) {\n+  assert(GCTimeRatio > 0, \"must be\");\n+  expand = false;\n+\n+  const double long_term_gc_cpu_usage = _analytics->long_term_pause_time_ratio();\n+  const double short_term_gc_cpu_usage = _analytics->short_term_pause_time_ratio();\n+\n+  double gc_cpu_usage_target = 1.0 \/ (1.0 + GCTimeRatio);\n+  gc_cpu_usage_target = scale_with_heap(gc_cpu_usage_target);\n+\n+  \/\/ Calculate gc_cpu_usage acceptable deviation thresholds:\n+  \/\/ - upper_threshold, do not want to exceed this.\n+  \/\/ - lower_threshold, we do not want to go below.\n+  const double gc_cpu_usage_margin = G1CPUUsageDeviationPercent \/ 100.0;\n+  const double upper_threshold = gc_cpu_usage_target * (1 + gc_cpu_usage_margin);\n+  const double lower_threshold = gc_cpu_usage_target * (1 - gc_cpu_usage_margin);\n+\n+  \/\/ Decide to expand\/shrink based on how far the current GC CPU usage deviates\n+  \/\/ from the target. This allows the policy to respond more quickly to GC pressure\n+  \/\/ when the heap is small relative to the maximum heap.\n+  const double long_term_delta = rel_diff(long_term_gc_cpu_usage, gc_cpu_usage_target);\n+  const double short_term_delta = rel_diff(short_term_gc_cpu_usage, gc_cpu_usage_target);\n+\n+  \/\/ If the short term GC CPU usage exceeds the upper threshold, increment the deviation\n+  \/\/ counter. If it falls below the lower_threshold, decrement the deviation counter.\n+  if (short_term_gc_cpu_usage > upper_threshold) {\n+    _gc_cpu_usage_deviation_counter++;\n+  } else if (short_term_gc_cpu_usage < lower_threshold) {\n+    _gc_cpu_usage_deviation_counter--;\n+  }\n+  \/\/ Ignore very first sample as it is garbage.\n+  if (_long_term_count != 0 || _recent_cpu_usage_deltas.num() != 0) {\n+    _recent_cpu_usage_deltas.add(short_term_delta);\n+  }\n+  _long_term_count++;\n+\n+  log_trace(gc, ergo, heap)(\"Heap resize triggers: long term count: %u \"\n+                            \"long term count limit: %u \"\n+                            \"short term delta: %1.2f \"\n+                            \"recent recorded short term deltas: %u\"\n+                            \"GC CPU usage deviation counter: %d\",\n+                            _long_term_count,\n+                            long_term_count_limit(),\n+                            short_term_delta,\n+                            _recent_cpu_usage_deltas.num(),\n+                            _gc_cpu_usage_deviation_counter);\n+\n+  \/\/ Check if there is a short- or long-term need for resizing, expansion first.\n+  \/\/\n+  \/\/ Short-term resizing need is detected by exceeding the upper or lower thresholds\n+  \/\/ multiple times, tracked in _gc_cpu_usage_deviation_counter. If it contains a large\n+  \/\/ positive or negative (larger than the respective thresholds), we trigger\n+  \/\/ resizing calculation.\n+  \/\/\n+  \/\/ Slowly occurring long-term changes to the actual GC CPU usage are checked\n+  \/\/ only every once in a while.\n+  \/\/\n+  \/\/ The _gc_cpu_usage_deviation_counter value is reset after each resize, or slowly\n+  \/\/ decayed if no resizing happens.\n+\n+  size_t resize_bytes = 0;\n+\n+  const bool use_long_term_delta = (_long_term_count == long_term_count_limit());\n+  const double avg_short_term_delta = _recent_cpu_usage_deltas.avg();\n+\n+  double delta;\n+  if (use_long_term_delta) {\n+    \/\/ For expansion, deltas are positive, and we want to expand aggressively.\n+    \/\/ For shrinking, deltas are negative, so the MAX2 below selects the least\n+    \/\/ aggressive one as we are using the absolute value for scaling.\n+    delta = MAX2(avg_short_term_delta, long_term_delta);\n+  } else {\n+    delta = avg_short_term_delta;\n@@ -109,0 +290,5 @@\n+  \/\/ Delta is negative when shrinking, but the calculation of the resize amount\n+  \/\/ always expects an absolute value. Do that here unconditionally.\n+  delta = fabsd(delta);\n+\n+  int count_threshold_for_shrink = (int)G1CPUUsageShrinkThreshold;\n@@ -110,61 +296,10 @@\n-  log_trace(gc, ergo, heap)(\"Heap expansion triggers: pauses since start: %u \"\n-                            \"num prev pauses for heuristics: %u \"\n-                            \"ratio over threshold count: %u\",\n-                            _pauses_since_start,\n-                            _num_prev_pauses_for_heuristics,\n-                            _ratio_over_threshold_count);\n-\n-  \/\/ Check if we've had enough GC time ratio checks that were over the\n-  \/\/ threshold to trigger an expansion. We'll also expand if we've\n-  \/\/ reached the end of the history buffer and the average of all entries\n-  \/\/ is still over the threshold. This indicates a smaller number of GCs were\n-  \/\/ long enough to make the average exceed the threshold.\n-  bool filled_history_buffer = _pauses_since_start == _num_prev_pauses_for_heuristics;\n-  if ((_ratio_over_threshold_count == MinOverThresholdForGrowth) ||\n-      (filled_history_buffer && (long_term_pause_time_ratio > threshold))) {\n-    size_t min_expand_bytes = G1HeapRegion::GrainBytes;\n-    size_t reserved_bytes = _g1h->max_capacity();\n-    size_t committed_bytes = _g1h->capacity();\n-    size_t uncommitted_bytes = reserved_bytes - committed_bytes;\n-    size_t expand_bytes_via_pct =\n-      uncommitted_bytes * G1ExpandByPercentOfAvailable \/ 100;\n-    double scale_factor = 1.0;\n-\n-    \/\/ If the current size is less than 1\/4 of the Initial heap size, expand\n-    \/\/ by half of the delta between the current and Initial sizes. IE, grow\n-    \/\/ back quickly.\n-    \/\/\n-    \/\/ Otherwise, take the current size, or G1ExpandByPercentOfAvailable % of\n-    \/\/ the available expansion space, whichever is smaller, as the base\n-    \/\/ expansion size. Then possibly scale this size according to how much the\n-    \/\/ threshold has (on average) been exceeded by. If the delta is small\n-    \/\/ (less than the StartScaleDownAt value), scale the size down linearly, but\n-    \/\/ not by less than MinScaleDownFactor. If the delta is large (greater than\n-    \/\/ the StartScaleUpAt value), scale up, but adding no more than MaxScaleUpFactor\n-    \/\/ times the base size. The scaling will be linear in the range from\n-    \/\/ StartScaleUpAt to (StartScaleUpAt + ScaleUpRange). In other words,\n-    \/\/ ScaleUpRange sets the rate of scaling up.\n-    if (committed_bytes < InitialHeapSize \/ 4) {\n-      expand_bytes = (InitialHeapSize - committed_bytes) \/ 2;\n-    } else {\n-      double const MinScaleDownFactor = 0.2;\n-      double const MaxScaleUpFactor = 2;\n-      double const StartScaleDownAt = pause_time_threshold;\n-      double const StartScaleUpAt = pause_time_threshold * 1.5;\n-      double const ScaleUpRange = pause_time_threshold * 2.0;\n-\n-      double ratio_delta;\n-      if (filled_history_buffer) {\n-        ratio_delta = long_term_pause_time_ratio - threshold;\n-      } else {\n-        ratio_delta = (_ratio_over_threshold_sum \/ _ratio_over_threshold_count) - threshold;\n-      }\n-\n-      expand_bytes = MIN2(expand_bytes_via_pct, committed_bytes);\n-      if (ratio_delta < StartScaleDownAt) {\n-        scale_factor = ratio_delta \/ StartScaleDownAt;\n-        scale_factor = MAX2(scale_factor, MinScaleDownFactor);\n-      } else if (ratio_delta > StartScaleUpAt) {\n-        scale_factor = 1 + ((ratio_delta - StartScaleUpAt) \/ ScaleUpRange);\n-        scale_factor = MIN2(scale_factor, MaxScaleUpFactor);\n-      }\n+  if ((_gc_cpu_usage_deviation_counter == (int)G1CPUUsageExpandThreshold) ||\n+      (use_long_term_delta && (long_term_gc_cpu_usage > upper_threshold))) {\n+    expand = true;\n+\n+    \/\/ Short-cut calculation if already at maximum capacity.\n+    if (_g1h->capacity() == _g1h->max_capacity()) {\n+      log_resize(short_term_gc_cpu_usage, long_term_gc_cpu_usage,\n+                 lower_threshold, upper_threshold, gc_cpu_usage_target, true, 0, expand);\n+      reset_cpu_usage_tracking_data();\n+      return resize_bytes;\n@@ -173,1 +308,2 @@\n-    expand_bytes = static_cast<size_t>(expand_bytes * scale_factor);\n+    log_trace(gc, ergo, heap)(\"expand deltas long %1.2f short %1.2f use long term %u delta %1.2f\",\n+                              long_term_delta, avg_short_term_delta, use_long_term_delta, delta);\n@@ -175,3 +311,1 @@\n-    \/\/ Ensure the expansion size is at least the minimum growth amount\n-    \/\/ and at most the remaining uncommitted byte size.\n-    expand_bytes = clamp(expand_bytes, min_expand_bytes, uncommitted_bytes);\n+    resize_bytes = young_collection_expand_amount(delta);\n@@ -179,11 +313,10 @@\n-    clear_ratio_check_data();\n-  } else {\n-    \/\/ An expansion was not triggered. If we've started counting, increment\n-    \/\/ the number of checks we've made in the current window.  If we've\n-    \/\/ reached the end of the window without resizing, clear the counters to\n-    \/\/ start again the next time we see a ratio above the threshold.\n-    if (_ratio_over_threshold_count > 0) {\n-      _pauses_since_start++;\n-      if (_pauses_since_start > _num_prev_pauses_for_heuristics) {\n-        clear_ratio_check_data();\n-      }\n+    reset_cpu_usage_tracking_data();\n+  } else if ((_gc_cpu_usage_deviation_counter == -count_threshold_for_shrink) ||\n+           (use_long_term_delta && (long_term_gc_cpu_usage < lower_threshold))) {\n+    expand = false;\n+    \/\/ Short-cut calculation if already at minimum capacity.\n+    if (_g1h->capacity() == _g1h->min_capacity()) {\n+      log_resize(short_term_gc_cpu_usage, long_term_gc_cpu_usage,\n+                 lower_threshold, upper_threshold, gc_cpu_usage_target, true, 0, expand);\n+      reset_cpu_usage_tracking_data();\n+      return resize_bytes;\n@@ -191,0 +324,11 @@\n+\n+    log_trace(gc, ergo, heap)(\"expand deltas long %1.2f short %1.2f use long term %u delta %1.2f\",\n+                              long_term_delta, avg_short_term_delta, use_long_term_delta, delta);\n+\n+    resize_bytes = young_collection_shrink_amount(delta, allocation_word_size);\n+\n+    reset_cpu_usage_tracking_data();\n+  } else if (use_long_term_delta) {\n+    \/\/ A resize has not been triggered, but the long term counter overflowed.\n+    decay_cpu_usage_tracking_data();\n+    expand = false; \/\/ Does not matter.\n@@ -193,2 +337,3 @@\n-  log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,\n-                threshold, pause_time_threshold, false, expand_bytes);\n+  log_resize(short_term_gc_cpu_usage, long_term_gc_cpu_usage,\n+             lower_threshold, upper_threshold, gc_cpu_usage_target,\n+             false, resize_bytes, expand);\n@@ -196,1 +341,1 @@\n-  return expand_bytes;\n+  return resize_bytes;\n@@ -260,1 +405,1 @@\n-  minimum_desired_capacity = MIN2(minimum_desired_capacity, MaxHeapSize);\n+  minimum_desired_capacity = MIN2(minimum_desired_capacity, _g1h->max_capacity());\n@@ -264,1 +409,1 @@\n-  maximum_desired_capacity =  MAX2(maximum_desired_capacity, MinHeapSize);\n+  maximum_desired_capacity = MAX2(maximum_desired_capacity, _g1h->min_capacity());\n@@ -270,1 +415,1 @@\n-    log_debug(gc, ergo, heap)(\"Attempt heap expansion (capacity lower than min desired capacity). \"\n+    log_debug(gc, ergo, heap)(\"Heap resize. Attempt heap expansion (capacity lower than min desired capacity). \"\n@@ -282,1 +427,1 @@\n-    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (capacity higher than max desired capacity). \"\n+    log_debug(gc, ergo, heap)(\"Heap resize. Attempt heap shrinking (capacity higher than max desired capacity). \"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":276,"deletions":131,"binary":false,"changes":407,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1Analytics.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"utilities\/numberSeq.hpp\"\n@@ -30,1 +32,0 @@\n-class G1Analytics;\n@@ -33,0 +34,34 @@\n+\/\/\n+\/\/ Contains heuristics to resize the heap, i.e. expand or shrink, during operation.\n+\/\/\n+\/\/ For young collections, this heuristics is based on GC CPU usage, i.e. trying to\n+\/\/ change the heap so that the GC CPU usage stays approximately close to the target\n+\/\/ GC CPU usage set by the user.\n+\/\/\n+\/\/ The heuristics track both short and long term GC behavior to effect heap resizing.\n+\/\/\n+\/\/ Short term tracking is based on the short-term GC CPU usage i.e we count events\n+\/\/ for which short-term GC CPU usage is outside the range:\n+\/\/ gc_cpu_usage_target × [1 - d, 1 + d], where d = G1CPUUsageDeviationPercent \/ 100\n+\/\/ If below that range, we decrement that counter, if above, we increment it.\n+\/\/\n+\/\/ If that counter reaches the G1CPUUsageExpandThreshold we consider expansion,\n+\/\/ if that counter reaches -G1CPUUsageShrinkThreshold we consider shrinking the heap.\n+\/\/\n+\/\/ While doing so, we accumulate the relative difference to the target GC CPU usage\n+\/\/ to guide the expansion\/shrinking amount.\n+\/\/\n+\/\/ Furthermore, if there is no short-term based resizing event for a \"long\" time,\n+\/\/ we decay that counter, i.e. drop it towards zero again to avoid that previous\n+\/\/ intermediate length short term behavior followed by a quiet time and a single\n+\/\/ short term event causes unnecessary resizes.\n+\/\/\n+\/\/ Long term behavior is solely managed by regularly comparing actual long term\n+\/\/ GC CPU usage with the boundaries of acceptable deviation range. If the actual\n+\/\/ long term GC CPU usage is outside this range, expand or shrink accordingly.\n+\/\/\n+\/\/ The mechanism is meant to filter out short term events because heap resizing\n+\/\/ has some overhead.\n+\/\/\n+\/\/ For full collections, we base resize decisions only on Min\/MaxHeapFreeRatio.\n+\/\/\n@@ -34,5 +69,0 @@\n-  \/\/ MinOverThresholdForGrowth must be less than the number of recorded\n-  \/\/ pause times in G1Analytics, representing the minimum number of pause\n-  \/\/ time ratios that exceed GCTimeRatio before a heap expansion will be triggered.\n-  const static uint MinOverThresholdForGrowth = 4;\n-\n@@ -42,5 +72,12 @@\n-  const uint _num_prev_pauses_for_heuristics;\n-  \/\/ Ratio check data for determining if heap growth is necessary.\n-  uint _ratio_over_threshold_count;\n-  double _ratio_over_threshold_sum;\n-  uint _pauses_since_start;\n+  \/\/ Number of times short-term GC CPU usage crossed the lower or upper threshold\n+  \/\/ recently; every time the upper threshold is exceeded, it is incremented, and\n+  \/\/ decremented if the lower threshold is exceeded.\n+  int _gc_cpu_usage_deviation_counter;\n+  \/\/ Recent GC CPU usage deviations relative to the gc_cpu_usage_target\n+  TruncatedSeq _recent_cpu_usage_deltas;\n+  uint _long_term_count;\n+\n+  \/\/ Clear GC CPU usage tracking data used by resize_amount().\n+  void reset_cpu_usage_tracking_data();\n+  \/\/ Decay (move towards \"no changes\") GC CPU usage tracking data.\n+  void decay_cpu_usage_tracking_data();\n@@ -48,1 +85,1 @@\n-  \/\/ Scale \"full\" gc pause time threshold with heap size as we want to resize more\n+  \/\/ Scale the gc_cpu_usage_target with heap size as we want to resize more\n@@ -50,1 +87,7 @@\n-  double scale_with_heap(double pause_time_threshold);\n+  double scale_with_heap(double gc_cpu_usage_target);\n+\n+  \/\/ Scale the cpu usage delta depending on the relative difference from the target gc_cpu_usage.\n+  double scale_cpu_usage_delta(double cpu_usage_delta, double min_scale_factor, double max_scale_factor) const;\n+\n+  size_t young_collection_expand_amount(double cpu_usage_delta) const;\n+  size_t young_collection_shrink_amount(double cpu_usage_delta, size_t allocation_word_size) const;\n@@ -55,3 +98,7 @@\n-  \/\/ If an expansion would be appropriate, because recent GC overhead had\n-  \/\/ exceeded the desired limit, return an amount to expand by.\n-  size_t young_collection_expansion_amount();\n+  static constexpr uint long_term_count_limit() {\n+    return G1Analytics::max_num_of_recorded_pause_times();\n+  }\n+  \/\/ Return by how many bytes the heap should be changed based on recent GC CPU\n+  \/\/ usage after young collection. If expand is set, the heap should be expanded,\n+  \/\/ otherwise shrunk.\n+  size_t young_collection_resize_amount(bool& expand, size_t allocation_word_size);\n@@ -62,2 +109,0 @@\n-  \/\/ Clear ratio tracking data used by expansion_amount().\n-  void clear_ratio_check_data();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.hpp","additions":63,"deletions":18,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -1065,1 +1065,1 @@\n-  _g1h->expand_heap_after_young_collection();\n+  _g1h->resize_heap_after_young_collection(_allocation_word_size);\n@@ -1080,1 +1080,2 @@\n-G1YoungCollector::G1YoungCollector(GCCause::Cause gc_cause) :\n+G1YoungCollector::G1YoungCollector(GCCause::Cause gc_cause,\n+                                   size_t allocation_word_size) :\n@@ -1083,0 +1084,1 @@\n+  _allocation_word_size(allocation_word_size),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,0 +82,1 @@\n+  size_t _allocation_word_size;\n@@ -140,1 +141,2 @@\n-  G1YoungCollector(GCCause::Cause gc_cause);\n+  G1YoungCollector(GCCause::Cause gc_cause,\n+                   size_t allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -161,1 +161,2 @@\n-          \"When expanding, % of uncommitted space to claim.\")               \\\n+          \"When expanding, % of uncommitted space to expand the heap by in \"\\\n+          \"a single expand attempt.\")                                       \\\n@@ -164,0 +165,26 @@\n+  product(uint, G1ShrinkByPercentOfAvailable, 50, DIAGNOSTIC,               \\\n+          \"When shrinking, maximum % of free space to free for a single \"   \\\n+          \"shrink attempt.\")                                                \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n+  product(uint, G1CPUUsageDeviationPercent, 25, DIAGNOSTIC,                 \\\n+          \"The acceptable deviation (in percent) from the target GC CPU \"   \\\n+          \"usage (based on GCTimeRatio). Creates a tolerance range \"        \\\n+          \"around the target to deal with short-term fluctuations without \" \\\n+          \"triggering GC resizing mechanism prematurely.\")                  \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n+  product(uint, G1CPUUsageExpandThreshold, 4, DIAGNOSTIC,                   \\\n+          \"If the GC CPU usage deviation counter exceeds this threshold, \"  \\\n+          \"a heap expansion may be triggered. The counter is incremented \"  \\\n+          \"when short-term GC CPU usage exceeds the upper bound of the \"    \\\n+          \"acceptable deviation range.\")                                    \\\n+          constraint(G1CPUUsageExpandConstraintFunc, AfterErgo)             \\\n+                                                                            \\\n+  product(uint, G1CPUUsageShrinkThreshold, 8, DIAGNOSTIC,                   \\\n+          \"If the GC CPU usage deviation counter drops below the negative \" \\\n+          \"of this threshold, a heap shrink may be triggered. The counter \" \\\n+          \"is decremented when short-term GC CPU usage is below the lower \" \\\n+          \"bound of acceptable deviation range.\")                           \\\n+          constraint(G1CPUUsageShrinkConstraintFunc, AfterErgo)             \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/g1\/g1HeapSizingPolicy.hpp\"\n@@ -213,0 +214,29 @@\n+\n+JVMFlag::Error gc_cpu_usage_threshold_helper(JVMFlagsEnum flagid,\n+                                             uint value,\n+                                             bool verbose) {\n+  if (UseG1GC) {\n+    JVMFlag* flag = JVMFlag::flag_from_enum(flagid);\n+    const uint max_count = G1HeapSizingPolicy::long_term_count_limit();\n+    if (value > max_count) {\n+      JVMFlag::printError(verbose,\n+                          \"%s (%u) must be in range [0, %u]\\n\",\n+                          flag->name(),\n+                          value, max_count);\n+      return JVMFlag::VIOLATES_CONSTRAINT;\n+    }\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n+\n+JVMFlag::Error G1CPUUsageExpandConstraintFunc(uint value, bool verbose) {\n+  return gc_cpu_usage_threshold_helper(FLAG_MEMBER_ENUM(G1CPUUsageExpandThreshold),\n+                                       value,\n+                                       verbose);\n+}\n+\n+JVMFlag::Error G1CPUUsageShrinkConstraintFunc(uint value, bool verbose) {\n+  return gc_cpu_usage_threshold_helper(FLAG_MEMBER_ENUM(G1CPUUsageShrinkThreshold),\n+                                       value,\n+                                       verbose);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,4 @@\n+                                                      \\\n+  \/* G1 GC deviation counter threshold constraints *\/ \\\n+  f(uint, G1CPUUsageExpandConstraintFunc)             \\\n+  f(uint, G1CPUUsageShrinkConstraintFunc)             \\\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import jdk.test.lib.process.OutputAnalyzer;\n@@ -43,0 +42,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -197,1 +197,1 @@\n-        new LogMessageWithLevel(\"Expand Heap After Collection:\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Resize Heap After Collection:\", Level.DEBUG),\n@@ -323,2 +323,1 @@\n-        output.shouldContain(\"Expand the heap. requested expansion amount: \");\n-        output.shouldContain(\"B expansion amount: \");\n+        output.shouldContain(\"Heap resize: \");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"}]}