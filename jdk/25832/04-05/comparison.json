{"files":[{"patch":"@@ -104,1 +104,1 @@\n-\/\/ Computes a smooth scaling factor based on the relative deviation of observed gc_cpu_usage\n+\/\/ Computes a smooth scaling factor based on the relative deviation of actual gc_cpu_usage\n@@ -113,2 +113,1 @@\n-\/\/ response increases most rapidly. This ensures appropriate heap resizing when deviations become\n-\/\/ significant, while avoiding overreacting to minor deviations.\n+\/\/ response increases most rapidly.\n@@ -150,2 +149,1 @@\n-  size_t expand_bytes_via_pct =\n-    uncommitted_bytes * G1ExpandByPercentOfAvailable \/ 100;\n+  size_t expand_bytes_via_pct = uncommitted_bytes * G1ExpandByPercentOfAvailable \/ 100;\n@@ -190,2 +188,0 @@\n-  uint reserve_regions = ceil(_g1h->num_committed_regions() * G1ReservePercent \/ 100.0);\n-\n@@ -207,1 +203,0 @@\n-                            \"reserve regions %u \"\n@@ -213,1 +208,0 @@\n-                            reserve_regions,\n@@ -261,0 +255,1 @@\n+                            \"recent recorded short term deltas: %u\"\n@@ -265,0 +260,1 @@\n+                            _recent_cpu_usage_deltas.num(),\n@@ -267,3 +263,0 @@\n-  log_debug(gc, ergo, heap)(\"Heap triggers: pauses-since-start: %u num-prev-pauses-for-heuristics: %u GC CPU usage deviation counter: %d\",\n-                            _recent_cpu_usage_deltas.num(), long_term_count_limit(), _gc_cpu_usage_deviation_counter);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,3 +37,3 @@\n-\/\/ For young collections, this heuristics is based on GC CPU usage, i.e. trying\n-\/\/ to change the heap so that the GC CPU usage stays approximately close to the\n-\/\/ target GC CPU usage set by the user.\n+\/\/ For young collections, this heuristics is based on GC CPU usage, i.e. trying to\n+\/\/ change the heap so that the GC CPU usage stays approximately close to the target\n+\/\/ GC CPU usage set by the user.\n@@ -41,2 +41,1 @@\n-\/\/ The heuristics tracks both short and long term GC behavior to effect heap size\n-\/\/ change.\n+\/\/ The heuristics track both short and long term GC behavior to effect heap resizing.\n@@ -44,2 +43,2 @@\n-\/\/ Short term tracking is based on the short-term GC CPU usage i.e we count\n-\/\/ events for which short-term GC CPU usage is outside the range:\n+\/\/ Short term tracking is based on the short-term GC CPU usage i.e we count events\n+\/\/ for which short-term GC CPU usage is outside the range:\n@@ -48,2 +47,0 @@\n-\/\/ The intent of this mechanism is to filter short term events because heap sizing has\n-\/\/ some overhead.\n@@ -54,1 +51,1 @@\n-\/\/ While doing so, we accumulate the relative difference to the gc_cpu_usage_target\n+\/\/ While doing so, we accumulate the relative difference to the target GC CPU usage\n@@ -57,2 +54,2 @@\n-\/\/ Furthermore, if there is no short-term based resizing event for a \"long\" time, we\n-\/\/ decay that counter, i.e. drop it towards zero again to avoid that previous\n+\/\/ Furthermore, if there is no short-term based resizing event for a \"long\" time,\n+\/\/ we decay that counter, i.e. drop it towards zero again to avoid that previous\n@@ -63,2 +60,5 @@\n-\/\/ GC CPU usage with the boundaries of above range in regular long term intervals.\n-\/\/ If current long term GC CPU usage is outside, expand or shrink respectively.\n+\/\/ GC CPU usage with the boundaries of acceptable deviation range. If the actual\n+\/\/ long term GC CPU usage is outside this range, expand or shrink accordingly.\n+\/\/\n+\/\/ The mechanism is meant to filter out short term events because heap resizing\n+\/\/ has some overhead.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -215,3 +215,3 @@\n-JVMFlag::Error gc_cpu_usage_threshold_healper(JVMFlagsEnum flagid,\n-                                              uint value,\n-                                              bool verbose) {\n+JVMFlag::Error gc_cpu_usage_threshold_helper(JVMFlagsEnum flagid,\n+                                             uint value,\n+                                             bool verbose) {\n@@ -233,3 +233,3 @@\n-  return gc_cpu_usage_threshold_healper(FLAG_MEMBER_ENUM(G1CPUUsageExpandThreshold),\n-                                        value,\n-                                        verbose);\n+  return gc_cpu_usage_threshold_helper(FLAG_MEMBER_ENUM(G1CPUUsageExpandThreshold),\n+                                       value,\n+                                       verbose);\n@@ -239,3 +239,3 @@\n-  return gc_cpu_usage_threshold_healper(FLAG_MEMBER_ENUM(G1CPUUsageShrinkThreshold),\n-                                        value,\n-                                        verbose);\n+  return gc_cpu_usage_threshold_helper(FLAG_MEMBER_ENUM(G1CPUUsageShrinkThreshold),\n+                                       value,\n+                                       verbose);\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}