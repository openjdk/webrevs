{"files":[{"patch":"@@ -113,1 +113,1 @@\n-  uint max_num_of_recorded_pause_times() const {\n+  static constexpr uint max_num_of_recorded_pause_times() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1024,0 +1024,2 @@\n+  assert(expand_bytes > 0, \"precondition\");\n+\n@@ -1028,1 +1030,0 @@\n-  assert(num_regions_to_expand > 0, \"Must expand by at least one region\");\n@@ -1038,2 +1039,0 @@\n-\n-\n@@ -1042,2 +1041,0 @@\n-  assert(expanded_by > 0, \"must have failed during commit.\");\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -476,0 +476,2 @@\n+  void resize_heap(size_t resize_bytes, bool should_expand);\n+\n@@ -563,1 +565,0 @@\n-  void resize_heap(size_t resize_bytes, bool should_expand);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1465,1 +1465,1 @@\n-      _g1h->resize_heap_after_full_collection(size_t(0) \/* allocation_word_size *\/);\n+      _g1h->resize_heap_after_full_collection(0 \/* allocation_word_size *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,4 +38,0 @@\n-uint G1HeapSizingPolicy::long_term_count_limit() const {\n-  return _analytics->max_num_of_recorded_pause_times();\n-}\n-\n@@ -47,2 +43,2 @@\n-  _ratio_exceeds_threshold((MinOverThresholdForExpansion \/ 2) + 1),\n-  _recent_pause_ratios(long_term_count_limit()),\n+  _gc_cpu_usage_deviation_counter((G1CPUUsageExpandThreshold \/ 2) + 1),\n+  _recent_cpu_usage_deltas(long_term_count_limit()),\n@@ -50,12 +46,0 @@\n-\n-  assert(_ratio_exceeds_threshold < MinOverThresholdForExpansion,\n-         \"Initial ratio counter value too high.\");\n-\n-  assert(_ratio_exceeds_threshold > -MinOverThresholdForExpansion,\n-         \"Initial ratio counter value too low.\");\n-\n-  assert(MinOverThresholdForExpansion <= long_term_count_limit(),\n-         \"Expansion threshold count must be less than %u\", long_term_count_limit());\n-\n-  assert(G1ShortTermShrinkThreshold <= long_term_count_limit(),\n-         \"Shrink threshold count must be less than %u\", long_term_count_limit());\n@@ -64,1 +48,1 @@\n-void G1HeapSizingPolicy::reset_ratio_tracking_data() {\n+void G1HeapSizingPolicy::reset_cpu_usage_tracking_data() {\n@@ -66,2 +50,2 @@\n-  _ratio_exceeds_threshold = 0;\n-  \/\/ Keep the recent gc time ratio data.\n+  _gc_cpu_usage_deviation_counter = 0;\n+  \/\/ Keep the recent GC CPU usage data.\n@@ -70,1 +54,1 @@\n-void G1HeapSizingPolicy::decay_ratio_tracking_data() {\n+void G1HeapSizingPolicy::decay_cpu_usage_tracking_data() {\n@@ -72,2 +56,2 @@\n-  _ratio_exceeds_threshold \/= 2;\n-  \/\/ Keep the recent gc time ratio data.\n+  _gc_cpu_usage_deviation_counter \/= 2;\n+  \/\/ Keep the recent GC CPU usage data.\n@@ -76,2 +60,2 @@\n-double G1HeapSizingPolicy::scale_with_heap(double pause_time_threshold) {\n-  double threshold = pause_time_threshold;\n+double G1HeapSizingPolicy::scale_with_heap(double gc_cpu_usage_target) {\n+  double target = gc_cpu_usage_target;\n@@ -82,2 +66,2 @@\n-    threshold *= (double)_g1h->capacity() \/ (double)(_g1h->max_capacity() \/ 2);\n-    threshold = MAX2(threshold, 0.01);\n+    target *= (double)_g1h->capacity() \/ (double)(_g1h->max_capacity() \/ 2);\n+    target = MAX2(target, 0.01);\n@@ -86,27 +70,1 @@\n-  return threshold;\n-}\n-\n-\/\/ Logistic function, returns values in the range [0,1]\n-static double sigmoid_function(double value) {\n-  \/\/ Sigmoid Parameters:\n-  double inflection_point = 1.0; \/\/ Inflection point where acceleration begins (midpoint of sigmoid).\n-  double steepness = 6.0;\n-\n-  return 1.0 \/ (1.0 + pow(M_E, -steepness * (value - inflection_point)));\n-}\n-\n-double G1HeapSizingPolicy::scale_resize_ratio_delta(double ratio_delta,\n-                                                    double min_scale_down_factor,\n-                                                    double max_scale_up_factor) const {\n-   \/\/ We use a sigmoid function for scaling smoothly as we transition from a slow start to a fast growth\n-   \/\/ function with increasing ratio_delta. The sigmoid outputs a value in the range [0,1] which we scale to\n-   \/\/ the range [min_scale_down_factor, max_scale_up_factor]\n-  double sigmoid = sigmoid_function(ratio_delta);\n-\n-  double scale_factor = min_scale_down_factor + (max_scale_up_factor - min_scale_down_factor) * sigmoid;\n-  return scale_factor;\n-}\n-\n-\/\/ Calculate the ratio of the difference of a and b relative to b.\n-static double rel_ratio(double a, double b) {\n-  return (a - b) \/ b;\n+  return target;\n@@ -115,2 +73,2 @@\n-static void log_resize(double short_term_pause_time_ratio,\n-                       double long_term_pause_time_ratio,\n+static void log_resize(double short_term_cpu_usage,\n+                       double long_term_cpu_usage,\n@@ -119,1 +77,1 @@\n-                       double pause_time_ratio,\n+                       double cpu_usage_target,\n@@ -125,2 +83,2 @@\n-                            \"short term pause time ratio %1.2f%% long term pause time ratio %1.2f%% \"\n-                            \"lower threshold %1.2f%% upper threshold %1.2f%% pause time ratio %1.2f%% \"\n+                            \"short term GC CPU usage %1.2f%% long term GC CPU usage %1.2f%% \"\n+                            \"lower threshold %1.2f%% upper threshold %1.2f%% GC CPU usage target %1.2f%% \"\n@@ -128,2 +86,2 @@\n-                            short_term_pause_time_ratio * 100.0,\n-                            long_term_pause_time_ratio * 100.0,\n+                            short_term_cpu_usage * 100.0,\n+                            long_term_cpu_usage * 100.0,\n@@ -132,1 +90,1 @@\n-                            pause_time_ratio * 100.0,\n+                            cpu_usage_target * 100.0,\n@@ -138,2 +96,50 @@\n-size_t G1HeapSizingPolicy::young_collection_expand_amount(double delta) const {\n-  assert(delta >= 0.0, \"must be\");\n+\/\/ Logistic function, returns values in the range [0,1]\n+static double sigmoid_function(double value) {\n+  \/\/ Sigmoid Parameters:\n+  double inflection_point = 1.0; \/\/ Inflection point (midpoint of the sigmoid).\n+  double steepness = 6.0;\n+  return 1.0 \/ (1.0 + exp(-steepness * (value - inflection_point)));\n+}\n+\n+\/\/ Computes a smooth scaling factor based on the relative deviation of observed gc_cpu_usage\n+\/\/ from the gc_cpu_usage_target, using a sigmoid function to transition between\n+\/\/ the specified minimum and maximum scaling factors.\n+\/\/\n+\/\/ The input cpu_usage_delta represents the relative deviation of the current gc_cpu_usage to the\n+\/\/ gc_cpu_usage_target. This value is passed through a sigmoid function that produces a smooth\n+\/\/ output between 0 and 1, which is then scaled to the range [min_scale_factor, max_scale_factor].\n+\/\/\n+\/\/ The sigmoid's inflection point is set at cpu_usage_delta = 1.0 (a 100% deviation), where the scaling\n+\/\/ response increases most rapidly. This ensures appropriate heap resizing when deviations become\n+\/\/ significant, while avoiding overreacting to minor deviations.\n+\/\/\n+\/\/ The steepness parameter controls how sharply the scale factor changes near the inflection point.\n+\/\/  * Low steepness (1-3): gradual scaling over a wide range of deviations (more conservative).\n+\/\/  * High steepness (7-10): rapid scaling near the inflection point; small deviations result\n+\/\/                           in very low scaling, but larger deviations ramp up scaling quickly.\n+\/\/                           Steepness at 10 is nearly a step function.\n+\/\/\n+\/\/ In this case, we choose a steepness of 6.0:\n+\/\/ - For small deviations, the sigmoid output is close to 0, resulting in scale factors near the\n+\/\/   lower bound, preventing excessive resizing.\n+\/\/ - As cpu_usage_delta grows toward 1.0, the steepness value makes the transition sharper, enabling\n+\/\/   more aggressive scaling for large deviations.\n+\/\/\n+\/\/ This helps avoid overreacting to small gc_cpu_usage deviations but respond appropriately\n+\/\/ when necessary.\n+double G1HeapSizingPolicy::scale_cpu_usage_delta(double cpu_usage_delta,\n+                                                 double min_scale_factor,\n+                                                 double max_scale_factor) const {\n+  double sigmoid = sigmoid_function(cpu_usage_delta);\n+\n+  double scale_factor = min_scale_factor + (max_scale_factor - min_scale_factor) * sigmoid;\n+  return scale_factor;\n+}\n+\n+\/\/ Calculate the relative difference between a and b.\n+static double rel_diff(double a, double b) {\n+  return (a - b) \/ b;\n+}\n+\n+size_t G1HeapSizingPolicy::young_collection_expand_amount(double cpu_usage_delta) const {\n+  assert(cpu_usage_delta >= 0.0, \"must be\");\n@@ -148,1 +154,1 @@\n-  \/\/ Take the current size, or G1ExpandByPercentOfAvailable % of\n+  \/\/ Take the current size or G1ExpandByPercentOfAvailable % of\n@@ -151,3 +157,3 @@\n-  \/\/ threshold has (on average) been exceeded by.\n-  const double MinScaleDownFactor = 0.2;\n-  const double MaxScaleUpFactor = 2.0;\n+  \/\/ GC CPU usage (on average) has exceeded the target.\n+  const double min_scale_factor = 0.2;\n+  const double max_scale_factor = 2.0;\n@@ -155,3 +161,3 @@\n-  double scale_factor = scale_resize_ratio_delta(delta,\n-                                                 MinScaleDownFactor,\n-                                                 MaxScaleUpFactor);\n+  double scale_factor = scale_cpu_usage_delta(cpu_usage_delta,\n+                                              min_scale_factor,\n+                                              max_scale_factor);\n@@ -165,1 +171,1 @@\n-  return clamp((size_t)resize_bytes, min_expand_bytes, uncommitted_bytes);\n+  return clamp(resize_bytes, min_expand_bytes, uncommitted_bytes);\n@@ -168,2 +174,2 @@\n-size_t G1HeapSizingPolicy::young_collection_shrink_amount(double delta, size_t allocation_word_size) const {\n-  assert(delta >= 0.0, \"must be\");\n+size_t G1HeapSizingPolicy::young_collection_shrink_amount(double cpu_usage_delta, size_t allocation_word_size) const {\n+  assert(cpu_usage_delta >= 0.0, \"must be\");\n@@ -171,4 +177,7 @@\n-  double scale_factor = scale_resize_ratio_delta(delta,\n-                                                 G1ShrinkByPercentOfAvailable \/ 1000.0,\n-                                                 G1ShrinkByPercentOfAvailable \/ 100.0);\n-  assert(scale_factor <= 1.0, \"must be\");\n+  const double min_scale_factor = G1ShrinkByPercentOfAvailable \/ 1000.0;\n+  const double max_scale_factor = G1ShrinkByPercentOfAvailable \/ 100.0;\n+\n+  double scale_factor = scale_cpu_usage_delta(cpu_usage_delta,\n+                                              min_scale_factor,\n+                                              max_scale_factor);\n+  assert(scale_factor <= max_scale_factor, \"must be\");\n@@ -217,27 +226,25 @@\n-  const double long_term_pause_time_ratio = _analytics->long_term_pause_time_ratio();\n-  const double short_term_pause_time_ratio = _analytics->short_term_pause_time_ratio();\n-\n-  \/\/ Calculate gc time ratio thresholds:\n-  \/\/ - upper threshold, directly based on GCTimeRatio. We do not want to exceed\n-  \/\/ this.\n-  \/\/ - lower threshold, we do not want to go under.\n-  \/\/ - mid threshold, halfway between upper and lower threshold, represents the\n-  \/\/ actual target when resizing the heap.\n-  double pause_time_threshold = 1.0 \/ (1.0 + GCTimeRatio);\n-\n-  pause_time_threshold = scale_with_heap(pause_time_threshold);\n-  const double min_gc_time_ratio_ratio = G1MinimumPercentOfGCTimeRatio \/ 100.0;\n-  double upper_threshold = pause_time_threshold * (1 + min_gc_time_ratio_ratio);\n-  double lower_threshold = pause_time_threshold * (1 - min_gc_time_ratio_ratio);\n-\n-  \/\/ Use threshold based relative to current GCTimeRatio to more quickly expand\n-  \/\/ and shrink at smaller heap sizes (relative to maximum).\n-  const double long_term_delta = rel_ratio(long_term_pause_time_ratio, pause_time_threshold);\n-  double short_term_ratio_delta = rel_ratio(short_term_pause_time_ratio, pause_time_threshold);\n-\n-  \/\/ If the short term GC time ratio exceeds a threshold, increment the occurrence\n-  \/\/ counter.\n-  if (short_term_pause_time_ratio > upper_threshold) {\n-    _ratio_exceeds_threshold++;\n-  } else if (short_term_pause_time_ratio < lower_threshold) {\n-    _ratio_exceeds_threshold--;\n+  const double long_term_gc_cpu_usage = _analytics->long_term_pause_time_ratio();\n+  const double short_term_gc_cpu_usage = _analytics->short_term_pause_time_ratio();\n+\n+  double gc_cpu_usage_target = 1.0 \/ (1.0 + GCTimeRatio);\n+  gc_cpu_usage_target = scale_with_heap(gc_cpu_usage_target);\n+\n+  \/\/ Calculate gc_cpu_usage acceptable deviation thresholds:\n+  \/\/ - upper_threshold, do not want to exceed this.\n+  \/\/ - lower_threshold, we do not want to go below.\n+  const double gc_cpu_usage_margin = G1CPUUsageDeviationPercent \/ 100.0;\n+  const double upper_threshold = gc_cpu_usage_target * (1 + gc_cpu_usage_margin);\n+  const double lower_threshold = gc_cpu_usage_target * (1 - gc_cpu_usage_margin);\n+\n+  \/\/ Decide to expand\/shrink based on how far the current GC CPU usage deviates\n+  \/\/ from the target. This allows the policy to respond more quickly to GC pressure\n+  \/\/ when the heap is small relative to the maximum heap.\n+  const double long_term_delta = rel_diff(long_term_gc_cpu_usage, gc_cpu_usage_target);\n+  const double short_term_delta = rel_diff(short_term_gc_cpu_usage, gc_cpu_usage_target);\n+\n+  \/\/ If the short term GC CPU usage exceeds the upper threshold, increment the deviation\n+  \/\/ counter. If it falls below the lower_threshold, decrement the deviation counter.\n+  if (short_term_gc_cpu_usage > upper_threshold) {\n+    _gc_cpu_usage_deviation_counter++;\n+  } else if (short_term_gc_cpu_usage < lower_threshold) {\n+    _gc_cpu_usage_deviation_counter--;\n@@ -246,2 +253,2 @@\n-  if (_long_term_count != 0 || _recent_pause_ratios.num() != 0) {\n-    _recent_pause_ratios.add(short_term_ratio_delta);\n+  if (_long_term_count != 0 || _recent_cpu_usage_deltas.num() != 0) {\n+    _recent_cpu_usage_deltas.add(short_term_delta);\n@@ -252,3 +259,3 @@\n-                            \"long term interval: %u \"\n-                            \"delta: %1.2f \"\n-                            \"ratio exceeds threshold count: %d\",\n+                            \"long term count limit: %u \"\n+                            \"short term delta: %1.2f \"\n+                            \"GC CPU usage deviation counter: %d\",\n@@ -257,2 +264,2 @@\n-                            short_term_ratio_delta,\n-                            _ratio_exceeds_threshold);\n+                            short_term_delta,\n+                            _gc_cpu_usage_deviation_counter);\n@@ -260,2 +267,2 @@\n-  log_debug(gc, ergo, heap)(\"Heap triggers: pauses-since-start: %u num-prev-pauses-for-heuristics: %u ratio-exceeds-threshold-count: %d\",\n-                            _recent_pause_ratios.num(), long_term_count_limit(), _ratio_exceeds_threshold);\n+  log_debug(gc, ergo, heap)(\"Heap triggers: pauses-since-start: %u num-prev-pauses-for-heuristics: %u GC CPU usage deviation counter: %d\",\n+                            _recent_cpu_usage_deltas.num(), long_term_count_limit(), _gc_cpu_usage_deviation_counter);\n@@ -266,1 +273,1 @@\n-  \/\/ multiple times, tracked in _ratio_exceeds_threshold. If it contains a large\n+  \/\/ multiple times, tracked in _gc_cpu_usage_deviation_counter. If it contains a large\n@@ -270,2 +277,2 @@\n-  \/\/ Slowly occurring long-term changes to the actual gc time ratios are checked\n-  \/\/ only every once a while.\n+  \/\/ Slowly occurring long-term changes to the actual GC CPU usage are checked\n+  \/\/ only every once in a while.\n@@ -273,2 +280,2 @@\n-  \/\/ The _ratio_exceeds_threshold value is reset after each resize, or slowly\n-  \/\/ decayed if nothing happens.\n+  \/\/ The _gc_cpu_usage_deviation_counter value is reset after each resize, or slowly\n+  \/\/ decayed if no resizing happens.\n@@ -279,1 +286,1 @@\n-  const double short_term_delta = _recent_pause_ratios.avg();\n+  const double avg_short_term_delta = _recent_cpu_usage_deltas.avg();\n@@ -286,1 +293,1 @@\n-    delta = MAX2(short_term_delta, long_term_delta);\n+    delta = MAX2(avg_short_term_delta, long_term_delta);\n@@ -288,1 +295,1 @@\n-    delta = short_term_delta;\n+    delta = avg_short_term_delta;\n@@ -294,1 +301,1 @@\n-  int ThresholdForShrink = (int)MIN2(G1ShortTermShrinkThreshold, long_term_count_limit());\n+  int count_threshold_for_shrink = (int)G1CPUUsageShrinkThreshold;\n@@ -296,2 +303,3 @@\n-  if ((_ratio_exceeds_threshold == MinOverThresholdForExpansion) ||\n-      (use_long_term_delta && (long_term_pause_time_ratio > upper_threshold))) {\n+  if ((_gc_cpu_usage_deviation_counter == (int)G1CPUUsageExpandThreshold) ||\n+      (use_long_term_delta && (long_term_gc_cpu_usage > upper_threshold))) {\n+    expand = true;\n@@ -301,3 +309,3 @@\n-      log_resize(short_term_pause_time_ratio, long_term_pause_time_ratio,\n-                 lower_threshold, upper_threshold, pause_time_threshold, true, 0, expand);\n-      reset_ratio_tracking_data();\n+      log_resize(short_term_gc_cpu_usage, long_term_gc_cpu_usage,\n+                 lower_threshold, upper_threshold, gc_cpu_usage_target, true, 0, expand);\n+      reset_cpu_usage_tracking_data();\n@@ -308,1 +316,1 @@\n-                              long_term_delta, short_term_delta, use_long_term_delta, delta);\n+                              long_term_delta, avg_short_term_delta, use_long_term_delta, delta);\n@@ -311,5 +319,0 @@\n-    expand = true;\n-\n-    reset_ratio_tracking_data();\n-  } else if ((_ratio_exceeds_threshold == -ThresholdForShrink) ||\n-             (use_long_term_delta && (long_term_pause_time_ratio < lower_threshold))) {\n@@ -317,0 +320,4 @@\n+    reset_cpu_usage_tracking_data();\n+  } else if ((_gc_cpu_usage_deviation_counter == -count_threshold_for_shrink) ||\n+           (use_long_term_delta && (long_term_gc_cpu_usage < lower_threshold))) {\n+    expand = false;\n@@ -319,3 +326,3 @@\n-      log_resize(short_term_pause_time_ratio, long_term_pause_time_ratio,\n-                 lower_threshold, upper_threshold, pause_time_threshold, true, 0, expand);\n-      reset_ratio_tracking_data();\n+      log_resize(short_term_gc_cpu_usage, long_term_gc_cpu_usage,\n+                 lower_threshold, upper_threshold, gc_cpu_usage_target, true, 0, expand);\n+      reset_cpu_usage_tracking_data();\n@@ -326,1 +333,1 @@\n-                              long_term_delta, short_term_delta, use_long_term_delta, delta);\n+                              long_term_delta, avg_short_term_delta, use_long_term_delta, delta);\n@@ -329,1 +336,0 @@\n-    expand = false;\n@@ -331,1 +337,1 @@\n-    reset_ratio_tracking_data();\n+    reset_cpu_usage_tracking_data();\n@@ -334,2 +340,2 @@\n-    decay_ratio_tracking_data();\n-    expand = true; \/\/ Does not matter.\n+    decay_cpu_usage_tracking_data();\n+    expand = false; \/\/ Does not matter.\n@@ -338,2 +344,2 @@\n-  log_resize(short_term_pause_time_ratio, long_term_pause_time_ratio,\n-             lower_threshold, upper_threshold, pause_time_threshold,\n+  log_resize(short_term_gc_cpu_usage, long_term_gc_cpu_usage,\n+             lower_threshold, upper_threshold, gc_cpu_usage_target,\n@@ -410,1 +416,1 @@\n-  maximum_desired_capacity =  MAX2(maximum_desired_capacity, _g1h->min_capacity());\n+  maximum_desired_capacity = MAX2(maximum_desired_capacity, _g1h->min_capacity());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":152,"deletions":146,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1Analytics.hpp\"\n@@ -31,1 +32,0 @@\n-class G1Analytics;\n@@ -37,3 +37,3 @@\n-\/\/ For young collections, this heuristics is based on gc time ratio, i.e. trying\n-\/\/ to change the heap so that current gc time ratio stays approximately as\n-\/\/ selected  by the user.\n+\/\/ For young collections, this heuristics is based on GC CPU usage, i.e. trying\n+\/\/ to change the heap so that the GC CPU usage stays approximately close to the\n+\/\/ target GC CPU usage set by the user.\n@@ -44,3 +44,3 @@\n-\/\/ Short term tracking is based on the short-term gc time ratio i.e we  count\n-\/\/ events for which short-term gc time ratio is outside the range of\n-\/\/ [GCTimeRatio * (1 - G1MinimumPercentOfGCTimeRatio \/ 100), GCTimeRatio * (1 + G1MinimumPercentOfGCTimeRatio \/ 100)]\n+\/\/ Short term tracking is based on the short-term GC CPU usage i.e we count\n+\/\/ events for which short-term GC CPU usage is outside the range:\n+\/\/ gc_cpu_usage_target × [1 - d, 1 + d], where d = G1CPUUsageDeviationPercent \/ 100\n@@ -48,1 +48,0 @@\n-\/\/\n@@ -52,2 +51,2 @@\n-\/\/ If that counter reaches the MinOverThresholdForExpansion we consider expansion,\n-\/\/ if that counter reaches -G1ShortTermShrinkThreshold we consider shrinking the heap.\n+\/\/ If that counter reaches the G1CPUUsageExpandThreshold we consider expansion,\n+\/\/ if that counter reaches -G1CPUUsageShrinkThreshold we consider shrinking the heap.\n@@ -55,2 +54,2 @@\n-\/\/ While doing so, we accumulate the relative difference to the midpoint of this range\n-\/\/ (GCTimeRatio) to guide the expansion\/shrinking amount.\n+\/\/ While doing so, we accumulate the relative difference to the gc_cpu_usage_target\n+\/\/ to guide the expansion\/shrinking amount.\n@@ -58,1 +57,1 @@\n-\/\/ Further, if there is no short-term based resizing event for a \"long\" time, we\n+\/\/ Furthermore, if there is no short-term based resizing event for a \"long\" time, we\n@@ -63,3 +62,3 @@\n-\/\/ Long term behavior is solely managed by regularly comparing actual long term gc\n-\/\/ time ratio with the boundaries of above range in regular long term  intervals.\n-\/\/ If current long term gc time ratio is outside, expand or shrink  respectively.\n+\/\/ Long term behavior is solely managed by regularly comparing actual long term\n+\/\/ GC CPU usage with the boundaries of above range in regular long term intervals.\n+\/\/ If current long term GC CPU usage is outside, expand or shrink respectively.\n@@ -70,4 +69,0 @@\n-  \/\/ MinOverThresholdForExpansion defines the number of actual gc time\n-  \/\/ ratios over the upper and lower thresholds respectively.\n-  const static int MinOverThresholdForExpansion = 4;\n-\n@@ -77,3 +72,2 @@\n-  uint long_term_count_limit() const;\n-  \/\/ Number of times short-term gc time ratio crossed the lower or upper threshold\n-  \/\/ recently; every time the upper threshold is exceeded, it is incremented,  and\n+  \/\/ Number of times short-term GC CPU usage crossed the lower or upper threshold\n+  \/\/ recently; every time the upper threshold is exceeded, it is incremented, and\n@@ -81,3 +75,3 @@\n-  int _ratio_exceeds_threshold;\n-  \/\/ Recent actual gc time ratios relative to the middle of lower and upper threshold.\n-  TruncatedSeq _recent_pause_ratios;\n+  int _gc_cpu_usage_deviation_counter;\n+  \/\/ Recent GC CPU usage deviations relative to the gc_cpu_usage_target\n+  TruncatedSeq _recent_cpu_usage_deltas;\n@@ -86,4 +80,4 @@\n-  \/\/ Clear ratio tracking data used by resize_amount().\n-  void reset_ratio_tracking_data();\n-  \/\/ Decay (move towards \"no changes\") ratio tracking data.\n-  void decay_ratio_tracking_data();\n+  \/\/ Clear GC CPU usage tracking data used by resize_amount().\n+  void reset_cpu_usage_tracking_data();\n+  \/\/ Decay (move towards \"no changes\") GC CPU usage tracking data.\n+  void decay_cpu_usage_tracking_data();\n@@ -91,1 +85,1 @@\n-  \/\/ Scale \"full\" gc time ratio threshold with heap size as we want to resize more\n+  \/\/ Scale the gc_cpu_usage_target with heap size as we want to resize more\n@@ -93,1 +87,1 @@\n-  double scale_with_heap(double pause_time_threshold);\n+  double scale_with_heap(double gc_cpu_usage_target);\n@@ -95,2 +89,2 @@\n-  \/\/ Scale the ratio delta depending on the relative difference from the target gc time ratio.\n-  double scale_resize_ratio_delta(double ratio_delta, double min_scale_down_factor, double max_scale_up_factor) const;\n+  \/\/ Scale the cpu usage delta depending on the relative difference from the target gc_cpu_usage.\n+  double scale_cpu_usage_delta(double cpu_usage_delta, double min_scale_factor, double max_scale_factor) const;\n@@ -98,2 +92,2 @@\n-  size_t young_collection_expand_amount(double delta) const;\n-  size_t young_collection_shrink_amount(double delta, size_t allocation_word_size) const;\n+  size_t young_collection_expand_amount(double cpu_usage_delta) const;\n+  size_t young_collection_shrink_amount(double cpu_usage_delta, size_t allocation_word_size) const;\n@@ -104,2 +98,5 @@\n-  \/\/ Return by how many bytes the heap should be changed based on recent gc time\n-  \/\/ ratio after young collection. If expand is set, the heap should be expanded,\n+  static constexpr uint long_term_count_limit() {\n+    return G1Analytics::max_num_of_recorded_pause_times();\n+  }\n+  \/\/ Return by how many bytes the heap should be changed based on recent GC CPU\n+  \/\/ usage after young collection. If expand is set, the heap should be expanded,\n@@ -112,2 +109,0 @@\n-  \/\/ Clear ratio tracking data used by expansion_amount().\n-  void clear_ratio_check_data();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.hpp","additions":35,"deletions":40,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -161,1 +161,2 @@\n-          \"When expanding, % of uncommitted space to claim.\")               \\\n+          \"When expanding, % of uncommitted space to expand the heap by in \"\\\n+          \"a single expand attempt.\")                                       \\\n@@ -164,2 +165,3 @@\n-  product(uint, G1ShrinkByPercentOfAvailable, 50, EXPERIMENTAL,           \\\n-          \"When shrinking, maximum % of free space to claim.\")              \\\n+  product(uint, G1ShrinkByPercentOfAvailable, 50, DIAGNOSTIC,               \\\n+          \"When shrinking, maximum % of free space to free for a single \"   \\\n+          \"shrink attempt.\")                                                \\\n@@ -168,2 +170,5 @@\n-  product(uint, G1MinimumPercentOfGCTimeRatio, 25, EXPERIMENTAL,          \\\n-          \"Percentage of GCTimeRatio G1 will try to avoid going below.\")    \\\n+  product(uint, G1CPUUsageDeviationPercent, 25, DIAGNOSTIC,                 \\\n+          \"The acceptable deviation (in percent) from the target GC CPU \"   \\\n+          \"usage (based on GCTimeRatio). Creates a tolerance range \"        \\\n+          \"around the target to deal with short-term fluctuations without \" \\\n+          \"triggering GC resizing mechanism prematurely.\")                  \\\n@@ -172,4 +177,13 @@\n-  product(uint, G1ShortTermShrinkThreshold, 8, EXPERIMENTAL,                \\\n-          \"Number of consecutive GCs with the short term gc time ratio\"     \\\n-          \"below the threshold before we attempt to shrink.\")               \\\n-          range(0, 10)                                                      \\\n+  product(uint, G1CPUUsageExpandThreshold, 4, DIAGNOSTIC,                   \\\n+          \"If the GC CPU usage deviation counter exceeds this threshold, \"  \\\n+          \"a heap expansion may be triggered. The counter is incremented \"  \\\n+          \"when short-term GC CPU usage exceeds the upper bound of the \"    \\\n+          \"acceptable deviation range.\")                                    \\\n+          constraint(G1CPUUsageExpandConstraintFunc, AfterErgo)             \\\n+                                                                            \\\n+  product(uint, G1CPUUsageShrinkThreshold, 8, DIAGNOSTIC,                   \\\n+          \"If the GC CPU usage deviation counter drops below the negative \" \\\n+          \"of this threshold, a heap shrink may be triggered. The counter \" \\\n+          \"is decremented when short-term GC CPU usage is below the lower \" \\\n+          \"bound of acceptable deviation range.\")                           \\\n+          constraint(G1CPUUsageShrinkConstraintFunc, AfterErgo)             \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/g1\/g1HeapSizingPolicy.hpp\"\n@@ -213,0 +214,29 @@\n+\n+JVMFlag::Error gc_cpu_usage_threshold_healper(JVMFlagsEnum flagid,\n+                                              uint value,\n+                                              bool verbose) {\n+  if (UseG1GC) {\n+    JVMFlag* flag = JVMFlag::flag_from_enum(flagid);\n+    const uint max_count = G1HeapSizingPolicy::long_term_count_limit();\n+    if (value > max_count) {\n+      JVMFlag::printError(verbose,\n+                          \"%s (%u) must be in range [0, %u]\\n\",\n+                          flag->name(),\n+                          value, max_count);\n+      return JVMFlag::VIOLATES_CONSTRAINT;\n+    }\n+  }\n+  return JVMFlag::SUCCESS;\n+}\n+\n+JVMFlag::Error G1CPUUsageExpandConstraintFunc(uint value, bool verbose) {\n+  return gc_cpu_usage_threshold_healper(FLAG_MEMBER_ENUM(G1CPUUsageExpandThreshold),\n+                                        value,\n+                                        verbose);\n+}\n+\n+JVMFlag::Error G1CPUUsageShrinkConstraintFunc(uint value, bool verbose) {\n+  return gc_cpu_usage_threshold_healper(FLAG_MEMBER_ENUM(G1CPUUsageShrinkThreshold),\n+                                        value,\n+                                        verbose);\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,4 @@\n+                                                      \\\n+  \/* G1 GC deviation counter threshold constraints *\/ \\\n+  f(uint, G1CPUUsageExpandConstraintFunc)             \\\n+  f(uint, G1CPUUsageShrinkConstraintFunc)             \\\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}