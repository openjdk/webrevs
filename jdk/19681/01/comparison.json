{"files":[{"patch":"@@ -33,0 +33,1 @@\n+#include \"jfr\/recorder\/repository\/jfrChunk.hpp\"\n@@ -428,0 +429,4 @@\n+\n+NO_TRANSITION(jlong, jfr_nanos_now(JNIEnv* env, jclass jvm))\n+  return JfrChunk::nanos_now();\n+NO_TRANSITION_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -168,0 +168,2 @@\n+jlong JNICALL jfr_nanos_now(JNIEnv* env, jclass jvm);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,2 @@\n-      (char*)\"unregisterStackFilter\", (char*)\"(J)V\", (void*)jfr_unregister_stack_filter\n+      (char*)\"unregisterStackFilter\", (char*)\"(J)V\", (void*)jfr_unregister_stack_filter,\n+      (char*)\"nanosNow\", (char*)\"()J\", (void*)jfr_nanos_now\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-static jlong nanos_now() {\n+jlong JfrChunk::nanos_now() {\n@@ -150,1 +150,1 @@\n-  const jlong now = nanos_now();\n+  const jlong now = JfrChunk::nanos_now();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunk.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+ public:\n+   static jlong nanos_now();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrChunk.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+  template(jdk_jfr_internal_HiddenWait,                               \"jdk\/jfr\/internal\/HiddenWait\")                 \\\n@@ -56,1 +57,0 @@\n-  template(jfr_chunk_rotation_monitor,                                \"jdk\/jfr\/internal\/JVM$ChunkRotationMonitor\")   \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1445,1 +1445,1 @@\n-  JFR_ONLY(return vmSymbols::jfr_chunk_rotation_monitor() == monitor_klass->name();)\n+  JFR_ONLY(return vmSymbols::jdk_jfr_internal_HiddenWait() == monitor_klass->name();)\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal;\n+\n+\/**\n+ * The HiddenWait class is used to exclude jdk.JavaMonitorWait events\n+ * from being generated when Object.wait() is called on an object of this type.\n+ *\/\n+public final class HiddenWait {\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/HiddenWait.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,0 @@\n-    private static class ChunkRotationMonitor {}\n-\n@@ -48,2 +46,0 @@\n-     * The monitor type is used to exclude jdk.JavaMonitorWait events from being generated\n-     * when Object.wait() is called on this monitor.\n@@ -51,1 +47,1 @@\n-    public static final Object CHUNK_ROTATION_MONITOR = new ChunkRotationMonitor();\n+    public static final Object CHUNK_ROTATION_MONITOR = new HiddenWait();\n@@ -177,0 +173,5 @@\n+    \/**\n+     * Returns the same clock that sets the start time of a chunk (in nanos).\n+     *\/\n+    public static native long nanosNow();\n+    \n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,5 +122,1 @@\n-            try {\n-                Thread.sleep(0, 100);\n-            } catch (InterruptedException iex) {\n-                \/\/ ignore\n-            }\n+            Utils.takeNap(1);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMSupport.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+    private long lastMillis;\n+\n@@ -316,0 +318,5 @@\n+        \/\/ Each chunk needs a unique timestamp. If two chunks get the same\n+        \/\/ timestamp, the parser may stop prematurely at an earlier chunk.\n+        \/\/ The resolution needs to be measured in milliseconds as this\n+        \/\/ is what RecordingInfo:getStopTime() returns.\n+        awaitEpochMilliShift();\n@@ -317,4 +324,0 @@\n-        \/\/ Each chunk needs a unique start timestamp and\n-        \/\/ if the clock resolution is low, two chunks may\n-        \/\/ get the same timestamp. Utils.getChunkStartNanos()\n-        \/\/ ensures the timestamp is unique for the next chunk\n@@ -335,0 +338,12 @@\n+    private void awaitEpochMilliShift() {\n+        while (true) {\n+            long nanos = JVM.nanosNow();\n+            long millis = Utils.epochNanosToInstant(nanos).toEpochMilli();\n+            if (millis != lastMillis) {\n+                lastMillis = millis;\n+                return;\n+            }\n+            Utils.takeNap(1);\n+        }\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,1 +208,1 @@\n-    protected abstract boolean isRecording();\n+    protected abstract boolean isRecordingStream();\n@@ -252,1 +252,1 @@\n-            if (isRecording() && streamConfiguration.startTime == null) {\n+            if (isRecordingStream() && streamConfiguration.startTime == null) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/AbstractEventStream.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -39,0 +40,1 @@\n+import jdk.jfr.RecordingState;\n@@ -62,0 +64,1 @@\n+    private final AtomicLong streamId = new AtomicLong();\n@@ -83,0 +86,2 @@\n+        this.streamId.incrementAndGet();\n+        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, \"Stream \" + streamId + \" started.\");\n@@ -140,1 +145,1 @@\n-        boolean validStartTime = isRecording() || disp.startTime != null;\n+        boolean validStartTime = isRecordingStream() || disp.startTime != null;\n@@ -147,0 +152,1 @@\n+            logStreamEnd(\"no first chunk file found.\");\n@@ -171,1 +177,4 @@\n-                    if (currentParser.getLastFlush() > filterEnd) {\n+                    long lastFlush = currentParser.getLastFlush();\n+                    if (lastFlush  > filterEnd) {\n+                        logStreamEnd(\"end time at \" + filterEnd +\n+                                     \"ns (epoch), parser at \" + lastFlush + \"ns (epoch).\");\n@@ -180,0 +189,3 @@\n+                    String msg = \"stopped at \" + barrier.getStreamEnd() + \"ms (epoch), \";\n+                    msg += \"parser at \" + endMillis + \"ms (epoch), \" + endNanos + \"ns (epoch)\";\n+                    logStreamEnd(msg);\n@@ -183,3 +195,5 @@\n-                if (!barrier.hasStreamEnd() && isLastChunk()) {\n-                    \/\/ Recording was stopped\/closed externally, and no more data to process.\n-                    return;\n+                if (isRecordingStream()) {\n+                    if (recording.getState() == RecordingState.STOPPED && !barrier.used()) {\n+                        logStreamEnd(\"recording stopped externally.\");\n+                        return;\n+                    }\n@@ -189,1 +203,1 @@\n-                    \/\/ JVM process exited\/crashed, or repository migrated to an unknown location\n+                    logStreamEnd(\"JVM process exited\/crashed, or repository migrated to an unknown location.\");\n@@ -193,1 +207,1 @@\n-                    \/\/ Stream was closed\n+                    logStreamEnd(\"stream closed.\");\n@@ -208,1 +222,2 @@\n-                    return; \/\/ stream closed\n+                    logStreamEnd(\"no more chunk files found.\");\n+                    return;\n@@ -220,6 +235,3 @@\n-\n-    private boolean isLastChunk() {\n-        if (!isRecording()) {\n-            return false;\n-        }\n-        return recording.getFinalChunkStartNanos() >= currentParser.getStartNanos();\n+    private void logStreamEnd(String text) {\n+        String msg = \"Stream \" + streamId + \" ended, \" + text;\n+        Logger.log(LogTag.JFR_SYSTEM_PARSER, LogLevel.INFO, msg);\n@@ -228,1 +240,1 @@\n-    protected boolean isRecording() {\n+    protected boolean isRecordingStream() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":28,"deletions":16,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-    protected boolean isRecording() {\n+    protected boolean isRecordingStream() {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventFileStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+    private boolean used = false;\n@@ -65,4 +66,0 @@\n-    public synchronized boolean hasStreamEnd() {\n-        return end != Long.MAX_VALUE;\n-    }\n-\n@@ -71,0 +68,1 @@\n+        used = true;\n@@ -78,0 +76,7 @@\n+\n+    \/**\n+     * Returns {@code true) if barrier is, or has been, in active state, {@code false) otherwise.\n+     *\/\n+    public synchronized boolean used() {\n+        return used;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/StreamBarrier.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import jdk.jfr.internal.HiddenWait;\n@@ -354,0 +355,1 @@\n+        HiddenWait hiddenWait = new HiddenWait();\n@@ -355,1 +357,3 @@\n-            Thread.sleep(millis);\n+            synchronized(hiddenWait) {\n+                hiddenWait.wait(millis);\n+            }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm jdk.jfr.api.consumer.recordingstream.TestStop\n+ * @run main\/othervm -Xlog:system+parser+jfr=info jdk.jfr.api.consumer.recordingstream.TestStop\n@@ -142,1 +142,0 @@\n-                System.out.println(\"Outer dump:\");\n@@ -144,4 +143,0 @@\n-                for (RecordedEvent e : dumpOuter) {\n-                    System.out.println(eventToText(e));\n-                }\n-                System.out.println(\"Inner dump:\");\n@@ -149,12 +144,1 @@\n-                for (RecordedEvent e : dumpInner) {\n-                    System.out.println(eventToText(e));\n-                }\n-                System.out.println();\n-                System.out.println(\"Outer stream:\");\n-                for (String s : outerStream) {\n-                    System.out.println(s);\n-                }\n-                System.out.println(\"Inner stream:\");\n-                for (String s : innerStream) {\n-                    System.out.println(s);\n-                }\n+\n@@ -162,0 +146,1 @@\n+                    log(outerStream, innerStream, dumpOuter, dumpInner);\n@@ -165,0 +150,1 @@\n+                    log(outerStream, innerStream, dumpOuter, dumpInner);\n@@ -168,0 +154,1 @@\n+                    log(outerStream, innerStream, dumpOuter, dumpInner);\n@@ -171,0 +158,1 @@\n+                    log(outerStream, innerStream, dumpOuter, dumpInner);\n@@ -177,0 +165,21 @@\n+    private static void log(List<String> outerStream, List<String> innerStream, List<RecordedEvent> dumpOuter,\n+    \t\tList<RecordedEvent> dumpInner) {\n+    \tSystem.out.println(\"Outer dump:\");\n+    \tfor (RecordedEvent e : dumpOuter) {\n+    \t    System.out.println(eventToText(e));\n+    \t}\n+    \tSystem.out.println(\"Inner dump:\");\n+    \tfor (RecordedEvent e : dumpInner) {\n+    \t    System.out.println(eventToText(e));\n+    \t}\n+    \tSystem.out.println();\n+    \tSystem.out.println(\"Outer stream:\");\n+    \tfor (String s : outerStream) {\n+    \t    System.out.println(s);\n+    \t}\n+    \tSystem.out.println(\"Inner stream:\");\n+    \tfor (String s : innerStream) {\n+    \t    System.out.println(s);\n+    \t}\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestStop.java","additions":28,"deletions":19,"binary":false,"changes":47,"status":"modified"}]}