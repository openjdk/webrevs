{"files":[{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-  template(jfr_chunk_rotation_monitor,                                \"jdk\/jfr\/internal\/JVM$ChunkRotationMonitor\")   \\\n+  template(jfr_chunk_rotation_monitor,                                \"jdk\/jfr\/internal\/ChunkRotationMonitor\")       \\\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal;\n+\n+\/**\n+ * The ChunkRotationMonitor class is used to exclude jdk.JavaMonitorWait events\n+ * from being generated when Object.wait() is called on an object of this type.\n+ *\/\n+final class ChunkRotationMonitor {\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ChunkRotationMonitor.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -44,2 +44,0 @@\n-    private static class ChunkRotationMonitor {}\n-\n@@ -48,2 +46,0 @@\n-     * The monitor type is used to exclude jdk.JavaMonitorWait events from being generated\n-     * when Object.wait() is called on this monitor.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+    private static final ChunkRotationMonitor TIMESTAMP_MONITOR = new ChunkRotationMonitor();\n@@ -52,1 +53,1 @@\n-    private static Instant lastTimestamp;\n+    private static long lastTimestamp;\n@@ -105,0 +106,11 @@\n+        \/\/ Waiting before a call to JVM.getChunkStartNanos()\n+        \/\/ ensures that the returned nanosecond, used in the chunk header,\n+        \/\/ can be associated with a unique millisecond since epoch.\n+        \/\/ This is important because the method\n+        \/\/ jdk.management.jfr.RecordingInfo::getStopTime()\n+        \/\/ returns a truncated millisecond since epoch, which is used\n+        \/\/ by the parser to ensure that it doesn't parse beyond that\n+        \/\/ chunk. Without a unique millisecond since epoch, the parser\n+        \/\/ may abort prematurely at an earlier chunk.\n+        \/\/ See jdk.jfr.management.StreamBarrier.\n+        awaitUniqueTimestamp();\n@@ -113,2 +125,2 @@\n-        if (lastTimestamp == null) {\n-            lastTimestamp = Instant.now(); \/\/ lazy initialization\n+        if (lastTimestamp == 0) {\n+            lastTimestamp = Instant.now().toEpochMilli(); \/\/ lazy initialization\n@@ -117,2 +129,2 @@\n-            Instant time = Instant.now();\n-            if (!time.equals(lastTimestamp)) {\n+            long time = Instant.now().toEpochMilli();\n+            if (time != lastTimestamp) {\n@@ -122,4 +134,8 @@\n-            try {\n-                Thread.sleep(0, 100);\n-            } catch (InterruptedException iex) {\n-                \/\/ ignore\n+            \/\/ Wait on a ChunkRotationMonitor object instead of using\n+            \/\/ Thread::sleep to avoid generating ThreadSleep events.\n+            synchronized (TIMESTAMP_MONITOR) {\n+                try {\n+                    TIMESTAMP_MONITOR.wait(1);\n+                } catch (InterruptedException e) {\n+                    \/\/ ignore\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMSupport.java","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"}]}