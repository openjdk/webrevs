{"files":[{"patch":"@@ -1221,37 +1221,5 @@\n-void LIR_Assembler::type_profile_helper(Register mdo,\n-                                        ciMethodData *md, ciProfileData *data,\n-                                        Register recv, Label* update_done) {\n-\n-  \/\/ Given a profile data offset, generate an Address which points to\n-  \/\/ the corresponding slot in mdo->data().\n-  \/\/ Clobbers rscratch2.\n-  auto slot_at = [=](ByteSize offset) -> Address {\n-    return __ form_address(rscratch2, mdo,\n-                           md->byte_offset_of_slot(data, offset),\n-                           LogBytesPerWord);\n-  };\n-\n-  for (uint i = 0; i < ReceiverTypeData::row_limit(); i++) {\n-    Label next_test;\n-    \/\/ See if the receiver is receiver[n].\n-    __ ldr(rscratch1, slot_at(ReceiverTypeData::receiver_offset(i)));\n-    __ cmp(recv, rscratch1);\n-    __ br(Assembler::NE, next_test);\n-    __ addptr(slot_at(ReceiverTypeData::receiver_count_offset(i)),\n-              DataLayout::counter_increment);\n-    __ b(*update_done);\n-    __ bind(next_test);\n-  }\n-\n-  \/\/ Didn't find receiver; find next empty slot and fill it in\n-  for (uint i = 0; i < ReceiverTypeData::row_limit(); i++) {\n-    Label next_test;\n-    Address recv_addr(slot_at(ReceiverTypeData::receiver_offset(i)));\n-    __ ldr(rscratch1, recv_addr);\n-    __ cbnz(rscratch1, next_test);\n-    __ str(recv, recv_addr);\n-    __ mov(rscratch1, DataLayout::counter_increment);\n-    __ str(rscratch1, slot_at(ReceiverTypeData::receiver_count_offset(i)));\n-    __ b(*update_done);\n-    __ bind(next_test);\n-  }\n+void LIR_Assembler::type_profile_helper(Register mdo, ciMethodData *md,\n+                                        ciProfileData *data, Register recv) {\n+\n+  int mdp_offset = md->byte_offset_of_slot(data, in_ByteSize(0));\n+  __ profile_receiver_type(recv, mdo, mdp_offset);\n@@ -1319,1 +1287,0 @@\n-    Label update_done;\n@@ -1322,5 +1289,1 @@\n-    type_profile_helper(mdo, md, data, recv, &update_done);\n-    Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-    __ addptr(counter_addr, DataLayout::counter_increment);\n-\n-    __ bind(update_done);\n+    type_profile_helper(mdo, md, data, recv);\n@@ -1433,1 +1396,0 @@\n-      Label update_done;\n@@ -1436,4 +1398,1 @@\n-      type_profile_helper(mdo, md, data, recv, &update_done);\n-      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-      __ addptr(counter_addr, DataLayout::counter_increment);\n-      __ bind(update_done);\n+      type_profile_helper(mdo, md, data, recv);\n@@ -2543,4 +2502,1 @@\n-      \/\/ dynamic tests on the receiver type\n-\n-      \/\/ NOTE: we should probably put a lock around this search to\n-      \/\/ avoid collisions by concurrent compilations\n+      \/\/ dynamic tests on the receiver type.\n@@ -2548,2 +2504,1 @@\n-      uint i;\n-      for (i = 0; i < VirtualCallData::row_limit(); i++) {\n+      for (uint i = 0; i < VirtualCallData::row_limit(); i++) {\n@@ -2557,20 +2512,3 @@\n-\n-      \/\/ Receiver type not found in profile data; select an empty slot\n-\n-      \/\/ Note that this is less efficient than it should be because it\n-      \/\/ always does a write to the receiver part of the\n-      \/\/ VirtualCallData rather than just the first time\n-      for (i = 0; i < VirtualCallData::row_limit(); i++) {\n-        ciKlass* receiver = vc_data->receiver(i);\n-        if (receiver == nullptr) {\n-          __ mov_metadata(rscratch1, known_klass->constant_encoding());\n-          Address recv_addr =\n-            __ form_address(rscratch2, mdo,\n-                            md->byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)),\n-                            LogBytesPerWord);\n-          __ str(rscratch1, recv_addr);\n-          Address data_addr(mdo, md->byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)));\n-          __ addptr(data_addr, DataLayout::counter_increment);\n-          return;\n-        }\n-      }\n+      \/\/ Receiver type is not found in profile data.\n+      \/\/ Fall back to runtime helper to handle the rest at runtime.\n+      __ mov_metadata(recv, known_klass->constant_encoding());\n@@ -2579,7 +2517,0 @@\n-      Label update_done;\n-      type_profile_helper(mdo, md, data, recv, &update_done);\n-      \/\/ Receiver did not match any saved receiver and there is no empty row for it.\n-      \/\/ Increment total counter to indicate polymorphic case.\n-      __ addptr(counter_addr, DataLayout::counter_increment);\n-\n-      __ bind(update_done);\n@@ -2587,0 +2518,1 @@\n+    type_profile_helper(mdo, md, data, recv);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":13,"deletions":81,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -53,3 +53,2 @@\n-  void type_profile_helper(Register mdo,\n-                           ciMethodData *md, ciProfileData *data,\n-                           Register recv, Label* update_done);\n+  void type_profile_helper(Register mdo, ciMethodData *md,\n+                           ciProfileData *data, Register recv);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-\/\/      r2, r5\n+\/\/      r2\n@@ -248,1 +248,0 @@\n-  assert(Rsub_klass != r5, \"r5 holds 2ndary super array scan ptr\");\n@@ -251,1 +250,1 @@\n-  profile_typecheck(r2, Rsub_klass, r5); \/\/ blows r2, reloads r5\n+  profile_typecheck(r2, Rsub_klass); \/\/ blows r2\n@@ -994,1 +993,0 @@\n-                                                     Register reg2,\n@@ -1012,1 +1010,1 @@\n-    record_klass_in_profile(receiver, mdp, reg2);\n+    profile_receiver_type(receiver, mdp, 0);\n@@ -1021,125 +1019,0 @@\n-\/\/ This routine creates a state machine for updating the multi-row\n-\/\/ type profile at a virtual call site (or other type-sensitive bytecode).\n-\/\/ The machine visits each row (of receiver\/count) until the receiver type\n-\/\/ is found, or until it runs out of rows.  At the same time, it remembers\n-\/\/ the location of the first empty row.  (An empty row records null for its\n-\/\/ receiver, and can be allocated for a newly-observed receiver type.)\n-\/\/ Because there are two degrees of freedom in the state, a simple linear\n-\/\/ search will not work; it must be a decision tree.  Hence this helper\n-\/\/ function is recursive, to generate the required tree structured code.\n-\/\/ It's the interpreter, so we are trading off code space for speed.\n-\/\/ See below for example code.\n-void InterpreterMacroAssembler::record_klass_in_profile_helper(\n-                                        Register receiver, Register mdp,\n-                                        Register reg2, int start_row,\n-                                        Label& done) {\n-  if (TypeProfileWidth == 0) {\n-    increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-  } else {\n-    record_item_in_profile_helper(receiver, mdp, reg2, 0, done, TypeProfileWidth,\n-        &VirtualCallData::receiver_offset, &VirtualCallData::receiver_count_offset);\n-  }\n-}\n-\n-void InterpreterMacroAssembler::record_item_in_profile_helper(Register item, Register mdp,\n-                                        Register reg2, int start_row, Label& done, int total_rows,\n-                                        OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn) {\n-  int last_row = total_rows - 1;\n-  assert(start_row <= last_row, \"must be work left to do\");\n-  \/\/ Test this row for both the item and for null.\n-  \/\/ Take any of three different outcomes:\n-  \/\/   1. found item => increment count and goto done\n-  \/\/   2. found null => keep looking for case 1, maybe allocate this cell\n-  \/\/   3. found something else => keep looking for cases 1 and 2\n-  \/\/ Case 3 is handled by a recursive call.\n-  for (int row = start_row; row <= last_row; row++) {\n-    Label next_test;\n-    bool test_for_null_also = (row == start_row);\n-\n-    \/\/ See if the item is item[n].\n-    int item_offset = in_bytes(item_offset_fn(row));\n-    test_mdp_data_at(mdp, item_offset, item,\n-                     (test_for_null_also ? reg2 : noreg),\n-                     next_test);\n-    \/\/ (Reg2 now contains the item from the CallData.)\n-\n-    \/\/ The item is item[n].  Increment count[n].\n-    int count_offset = in_bytes(item_count_offset_fn(row));\n-    increment_mdp_data_at(mdp, count_offset);\n-    b(done);\n-    bind(next_test);\n-\n-    if (test_for_null_also) {\n-      Label found_null;\n-      \/\/ Failed the equality check on item[n]...  Test for null.\n-      if (start_row == last_row) {\n-        \/\/ The only thing left to do is handle the null case.\n-        cbz(reg2, found_null);\n-        \/\/ Item did not match any saved item and there is no empty row for it.\n-        \/\/ Increment total counter to indicate polymorphic case.\n-        increment_mdp_data_at(mdp, in_bytes(CounterData::count_offset()));\n-        b(done);\n-        bind(found_null);\n-        break;\n-      }\n-      \/\/ Since null is rare, make it be the branch-taken case.\n-      cbz(reg2, found_null);\n-\n-      \/\/ Put all the \"Case 3\" tests here.\n-      record_item_in_profile_helper(item, mdp, reg2, start_row + 1, done, total_rows,\n-        item_offset_fn, item_count_offset_fn);\n-\n-      \/\/ Found a null.  Keep searching for a matching item,\n-      \/\/ but remember that this is an empty (unused) slot.\n-      bind(found_null);\n-    }\n-  }\n-\n-  \/\/ In the fall-through case, we found no matching item, but we\n-  \/\/ observed the item[start_row] is null.\n-\n-  \/\/ Fill in the item field and increment the count.\n-  int item_offset = in_bytes(item_offset_fn(start_row));\n-  set_mdp_data_at(mdp, item_offset, item);\n-  int count_offset = in_bytes(item_count_offset_fn(start_row));\n-  mov(reg2, DataLayout::counter_increment);\n-  set_mdp_data_at(mdp, count_offset, reg2);\n-  if (start_row > 0) {\n-    b(done);\n-  }\n-}\n-\n-\/\/ Example state machine code for three profile rows:\n-\/\/   \/\/ main copy of decision tree, rooted at row[1]\n-\/\/   if (row[0].rec == rec) { row[0].incr(); goto done; }\n-\/\/   if (row[0].rec != nullptr) {\n-\/\/     \/\/ inner copy of decision tree, rooted at row[1]\n-\/\/     if (row[1].rec == rec) { row[1].incr(); goto done; }\n-\/\/     if (row[1].rec != nullptr) {\n-\/\/       \/\/ degenerate decision tree, rooted at row[2]\n-\/\/       if (row[2].rec == rec) { row[2].incr(); goto done; }\n-\/\/       if (row[2].rec != nullptr) { count.incr(); goto done; } \/\/ overflow\n-\/\/       row[2].init(rec); goto done;\n-\/\/     } else {\n-\/\/       \/\/ remember row[1] is empty\n-\/\/       if (row[2].rec == rec) { row[2].incr(); goto done; }\n-\/\/       row[1].init(rec); goto done;\n-\/\/     }\n-\/\/   } else {\n-\/\/     \/\/ remember row[0] is empty\n-\/\/     if (row[1].rec == rec) { row[1].incr(); goto done; }\n-\/\/     if (row[2].rec == rec) { row[2].incr(); goto done; }\n-\/\/     row[0].init(rec); goto done;\n-\/\/   }\n-\/\/   done:\n-\n-void InterpreterMacroAssembler::record_klass_in_profile(Register receiver,\n-                                                        Register mdp, Register reg2) {\n-  assert(ProfileInterpreter, \"must be profiling\");\n-  Label done;\n-\n-  record_klass_in_profile_helper(receiver, mdp, reg2, 0, done);\n-\n-  bind (done);\n-}\n-\n@@ -1203,1 +1076,1 @@\n-void InterpreterMacroAssembler::profile_typecheck(Register mdp, Register klass, Register reg2) {\n+void InterpreterMacroAssembler::profile_typecheck(Register mdp, Register klass) {\n@@ -1216,1 +1089,1 @@\n-      record_klass_in_profile(klass, mdp, reg2);\n+      profile_receiver_type(klass, mdp, 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":5,"deletions":132,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -276,9 +276,0 @@\n-  void record_klass_in_profile(Register receiver, Register mdp,\n-                               Register reg2);\n-  void record_klass_in_profile_helper(Register receiver, Register mdp,\n-                                      Register reg2, int start_row,\n-                                      Label& done);\n-  void record_item_in_profile_helper(Register item, Register mdp,\n-                                     Register reg2, int start_row, Label& done, int total_rows,\n-                                     OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn);\n-\n@@ -298,1 +289,0 @@\n-                            Register scratch2,\n@@ -302,1 +292,1 @@\n-  void profile_typecheck(Register mdp, Register klass, Register scratch);\n+  void profile_typecheck(Register mdp, Register klass);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2121,0 +2121,158 @@\n+\/\/ Handle the receiver type profile update given the \"recv\" klass.\n+\/\/\n+\/\/ Normally updates the ReceiverData (RD) that starts at \"mdp\" + \"mdp_offset\".\n+\/\/ If there are no matching or claimable receiver entries in RD, updates\n+\/\/ the polymorphic counter.\n+\/\/\n+\/\/ This code expected to run by either the interpreter or JIT-ed code, without\n+\/\/ extra synchronization. For safety, receiver cells are claimed atomically, which\n+\/\/ avoids grossly misrepresenting the profiles under concurrent updates. For speed,\n+\/\/ counter updates are not atomic.\n+\/\/\n+void MacroAssembler::profile_receiver_type(Register recv, Register mdp, int mdp_offset) {\n+  assert_different_registers(recv, mdp, rscratch1, rscratch2);\n+\n+  int base_receiver_offset   = in_bytes(ReceiverTypeData::receiver_offset(0));\n+  int end_receiver_offset    = in_bytes(ReceiverTypeData::receiver_offset(ReceiverTypeData::row_limit()));\n+  int poly_count_offset      = in_bytes(CounterData::count_offset());\n+  int receiver_step          = in_bytes(ReceiverTypeData::receiver_offset(1)) - base_receiver_offset;\n+  int receiver_to_count_step = in_bytes(ReceiverTypeData::receiver_count_offset(0)) - base_receiver_offset;\n+\n+  \/\/ Adjust for MDP offsets.\n+  base_receiver_offset += mdp_offset;\n+  end_receiver_offset  += mdp_offset;\n+  poly_count_offset    += mdp_offset;\n+\n+#ifdef ASSERT\n+  \/\/ We are about to walk the MDO slots without asking for offsets.\n+  \/\/ Check that our math hits all the right spots.\n+  for (uint c = 0; c < ReceiverTypeData::row_limit(); c++) {\n+    int real_recv_offset  = mdp_offset + in_bytes(ReceiverTypeData::receiver_offset(c));\n+    int real_count_offset = mdp_offset + in_bytes(ReceiverTypeData::receiver_count_offset(c));\n+    int offset = base_receiver_offset + receiver_step*c;\n+    int count_offset = offset + receiver_to_count_step;\n+    assert(offset == real_recv_offset, \"receiver slot math\");\n+    assert(count_offset == real_count_offset, \"receiver count math\");\n+  }\n+  int real_poly_count_offset = mdp_offset + in_bytes(CounterData::count_offset());\n+  assert(poly_count_offset == real_poly_count_offset, \"poly counter math\");\n+#endif\n+\n+  \/\/ Corner case: no profile table. Increment poly counter and exit.\n+  if (ReceiverTypeData::row_limit() == 0) {\n+    ldr(rscratch1, Address(mdp, poly_count_offset));\n+    add(rscratch1, rscratch1, DataLayout::counter_increment);\n+    str(rscratch1, Address(mdp, poly_count_offset));\n+    return;\n+  }\n+\n+  Register offset = rscratch1;\n+\n+  Label L_loop_search_receiver, L_loop_search_empty;\n+  Label L_restart, L_found_recv, L_found_empty, L_polymorphic, L_count_update;\n+\n+  \/\/ The code here recognizes three major cases:\n+  \/\/   A. Fastest: receiver found in the table\n+  \/\/   B. Fast: no receiver in the table, and the table is full\n+  \/\/   C. Slow: no receiver in the table, free slots in the table\n+  \/\/\n+  \/\/ The case A performance is most important, as perfectly-behaved code would end up\n+  \/\/ there, especially with larger TypeProfileWidth. The case B performance is\n+  \/\/ important as well, this is where bulk of code would land for normally megamorphic\n+  \/\/ cases. The case C performance is not essential, its job is to deal with installation\n+  \/\/ races, we optimize for code density instead. Case C needs to make sure that receiver\n+  \/\/ rows are only claimed once. This makes sure we never overwrite a row for another\n+  \/\/ receiver and never duplicate the receivers in the list, making profile type-accurate.\n+  \/\/\n+  \/\/ It is very tempting to handle these cases in a single loop, and claim the first slot\n+  \/\/ without checking the rest of the table. But, profiling code should tolerate free slots\n+  \/\/ in the table, as class unloading can clear them. After such cleanup, the receiver\n+  \/\/ we need might be _after_ the free slot. Therefore, we need to let at least full scan\n+  \/\/ to complete, before trying to install new slots. Splitting the code in several tight\n+  \/\/ loops also helpfully optimizes for cases A and B.\n+  \/\/\n+  \/\/ This code is effectively:\n+  \/\/\n+  \/\/ restart:\n+  \/\/   \/\/ Fastest: receiver is already installed\n+  \/\/   for (i = 0; i < receiver_count(); i++) {\n+  \/\/     if (receiver(i) == recv) goto found_recv(i);\n+  \/\/   }\n+  \/\/\n+  \/\/   \/\/ Fast: no receiver, but profile is full\n+  \/\/   for (i = 0; i < receiver_count(); i++) {\n+  \/\/     if (receiver(i) == null) goto found_null(i);\n+  \/\/   }\n+  \/\/   goto polymorphic\n+  \/\/\n+  \/\/   \/\/ Slow: try to install receiver\n+  \/\/ found_null(i):\n+  \/\/   CAS(&receiver(i), null, recv);\n+  \/\/   goto restart\n+  \/\/\n+  \/\/ polymorphic:\n+  \/\/   count++;\n+  \/\/   return\n+  \/\/\n+  \/\/ found_recv(i):\n+  \/\/   *receiver_count(i)++\n+  \/\/\n+\n+  bind(L_restart);\n+\n+  \/\/ Fastest: receiver is already installed\n+  mov(offset, base_receiver_offset);\n+  bind(L_loop_search_receiver);\n+    ldr(rscratch2, Address(mdp, offset));\n+    cmp(rscratch2, recv);\n+    br(Assembler::EQ, L_found_recv);\n+  add(offset, offset, receiver_step);\n+  sub(rscratch2, offset, end_receiver_offset);\n+  cbnz(rscratch2, L_loop_search_receiver);\n+\n+  \/\/ Fast: no receiver, but profile is full\n+  mov(offset, base_receiver_offset);\n+  bind(L_loop_search_empty);\n+    ldr(rscratch2, Address(mdp, offset));\n+    cbz(rscratch2, L_found_empty);\n+  add(offset, offset, receiver_step);\n+  sub(rscratch2, offset, end_receiver_offset);\n+  cbnz(rscratch2, L_loop_search_empty);\n+  b(L_polymorphic);\n+\n+  \/\/ Slow: try to install receiver\n+  bind(L_found_empty);\n+\n+  \/\/ Atomically swing receiver slot: null -> recv.\n+  \/\/\n+  \/\/ The update code uses CAS, which clobbers rscratch1. However we\n+  \/\/ will no longer need this value so we do not need to save it.\n+\n+  lea(rscratch2, Address(mdp, offset));\n+  cmpxchg(\/*addr*\/ rscratch2, \/*expected*\/ zr, \/*new*\/ recv, Assembler::xword,\n+          \/*acquire*\/ false, \/*release*\/ false, \/*weak*\/ false, noreg);\n+\n+  \/\/ CAS success means the slot now has the receiver we want. CAS failure means\n+  \/\/ something had claimed the slot concurrently: it can be the same receiver we want,\n+  \/\/ or something else. Since this is a slow path, we can optimize for code density,\n+  \/\/ and just restart the search from the beginning.\n+  b(L_restart);\n+\n+  \/\/ Counter updates:\n+\n+  \/\/ Increment polymorphic counter instead of receiver slot.\n+  bind(L_polymorphic);\n+  mov(offset, poly_count_offset);\n+  b(L_count_update);\n+\n+  \/\/ Found a receiver, convert its slot offset to corresponding count offset.\n+  bind(L_found_recv);\n+  add(offset, offset, receiver_to_count_step);\n+\n+  bind(L_count_update);\n+  ldr(rscratch2, Address(mdp, offset));\n+  add(rscratch2, rscratch2, DataLayout::counter_increment);\n+  str(rscratch2, Address(mdp, offset));\n+}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -1125,0 +1125,2 @@\n+  void profile_receiver_type(Register recv, Register mdp, int mdp_offset);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3372,1 +3372,1 @@\n-  __ profile_virtual_call(r0, rlocals, r3);\n+  __ profile_virtual_call(r0, rlocals);\n@@ -3502,1 +3502,1 @@\n-  __ profile_virtual_call(r3, r13, r19);\n+  __ profile_virtual_call(r3, r13);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}