{"files":[{"patch":"@@ -1573,2 +1573,3 @@\n-        copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset,\n-                dstSegment, ValueLayout.JAVA_BYTE, dstOffset,\n+\n+        AbstractMemorySegmentImpl.copy((AbstractMemorySegmentImpl) srcSegment, srcOffset,\n+                (AbstractMemorySegmentImpl) dstSegment, dstOffset,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -264,2 +264,12 @@\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n-        if (unsafeGetBase() == that.unsafeGetBase()) {  \/\/ both either native or heap\n+        final AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n+        if (overlaps(that)) {\n+            final long offsetToThat = that.address() - this.address();\n+            final long newOffset = offsetToThat >= 0 ? offsetToThat : 0;\n+            return Optional.of(asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat)));\n+        }\n+        return Optional.empty();\n+    }\n+\n+    @ForceInline\n+    private boolean overlaps(AbstractMemorySegmentImpl that) {\n+        if (unsafeGetBase() == that.unsafeGetBase()) {  \/\/ both either native or the same heap segment\n@@ -270,6 +280,1 @@\n-\n-            if (thisStart < thatEnd && thisEnd > thatStart) {  \/\/overlap occurs\n-                long offsetToThat = that.address() - this.address();\n-                long newOffset = offsetToThat >= 0 ? offsetToThat : 0;\n-                return Optional.of(asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat)));\n-            }\n+            return (thisStart < thatEnd && thisEnd > thatStart); \/\/overlap occurs?\n@@ -277,1 +282,1 @@\n-        return Optional.empty();\n+        return false;\n@@ -605,0 +610,58 @@\n+    \/\/ COPY_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n+    private static final long COPY_NATIVE_THRESHOLD = 1 << 6;\n+\n+    @ForceInline\n+    public static void copy(AbstractMemorySegmentImpl src, long srcOffset,\n+                            AbstractMemorySegmentImpl dst, long dstOffset,\n+                            long size) {\n+\n+        Utils.checkNonNegativeIndex(size, \"size\");\n+        \/\/ Implicit null check for src and dst\n+        src.checkAccess(srcOffset, size, true);\n+        dst.checkAccess(dstOffset, size, false);\n+\n+        if (size <= 0) {\n+            \/\/ Do nothing\n+        } else if (size < COPY_NATIVE_THRESHOLD && !src.overlaps(dst)) {\n+            \/\/ 0 < size < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+            \/\/\n+            \/\/ Strictly, we could check for !src.asSlice(srcOffset, size).overlaps(dst.asSlice(dstOffset, size) but\n+            \/\/ this is a bit slower and it likely very unusual there is any difference in the outcome. Also, if there\n+            \/\/ is an overlap, we could tolerate one particular direction of overlap (but not the other).\n+\n+            \/\/ 0...0X...X000\n+            final int limit = (int) (size & (COPY_NATIVE_THRESHOLD - 8));\n+            int offset = 0;\n+            for (; offset < limit; offset += 8) {\n+                final long v = SCOPED_MEMORY_ACCESS.getLong(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n+                SCOPED_MEMORY_ACCESS.putLong(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+            }\n+            int remaining = (int) size - offset;\n+            \/\/ 0...0X00\n+            if (remaining >= 4) {\n+                final int v = SCOPED_MEMORY_ACCESS.getInt(src.sessionImpl(), src.unsafeGetBase(),src.unsafeGetOffset() + srcOffset + offset);\n+                SCOPED_MEMORY_ACCESS.putInt(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+                offset += 4;\n+                remaining -= 4;\n+            }\n+            \/\/ 0...00X0\n+            if (remaining >= 2) {\n+                final short v = SCOPED_MEMORY_ACCESS.getShort(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n+                SCOPED_MEMORY_ACCESS.putShort(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+                offset += 2;\n+                remaining -=2;\n+            }\n+            \/\/ 0...000X\n+            if (remaining == 1) {\n+                final byte v = SCOPED_MEMORY_ACCESS.getByte(src.sessionImpl(), src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset + offset);\n+                SCOPED_MEMORY_ACCESS.putByte(dst.sessionImpl(), dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset + offset, v);\n+            }\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            \/\/ For larger sizes, the transition to native code pays off\n+            SCOPED_MEMORY_ACCESS.copyMemory(src.sessionImpl(), dst.sessionImpl(),\n+                    src.unsafeGetBase(), src.unsafeGetOffset() + srcOffset,\n+                    dst.unsafeGetBase(), dst.unsafeGetOffset() + dstOffset, size);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":72,"deletions":9,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import java.lang.invoke.MethodHandles;\n@@ -79,0 +78,88 @@\n+    @Test(dataProvider = \"conjunctSegments\")\n+    public void testCopy5ArgInvariants(MemorySegment src, MemorySegment dst) {\n+        assertThrows(IndexOutOfBoundsException.class, () -> MemorySegment.copy(src, 0, dst, 0, -1));\n+        assertThrows(IndexOutOfBoundsException.class, () -> MemorySegment.copy(src, -1, dst, 0, src.byteSize()));\n+        assertThrows(IndexOutOfBoundsException.class, () -> MemorySegment.copy(src, 0, dst, -1, src.byteSize()));\n+        assertThrows(IndexOutOfBoundsException.class, () -> MemorySegment.copy(src, 1, dst, 0, src.byteSize()));\n+        assertThrows(IndexOutOfBoundsException.class, () -> MemorySegment.copy(src, 0, dst, 1, src.byteSize()));\n+    }\n+\n+    @Test(dataProvider = \"conjunctSegments\")\n+    public void testConjunctCopy7ArgRight(MemorySegment src, MemorySegment dst) {\n+        testConjunctCopy(src, 0, dst, 1, CopyOp.of7Arg());\n+    }\n+\n+    @Test(dataProvider = \"conjunctSegments\")\n+    public void testConjunctCopy5ArgRight(MemorySegment src, MemorySegment dst) {\n+        testConjunctCopy(src, 0, dst, 1, CopyOp.of5Arg());\n+    }\n+\n+    @Test(dataProvider = \"conjunctSegments\")\n+    public void testConjunctCopy7ArgLeft(MemorySegment src, MemorySegment dst) {\n+        testConjunctCopy(src, 1, dst, 0, CopyOp.of7Arg());\n+    }\n+\n+    @Test(dataProvider = \"conjunctSegments\")\n+    public void testConjunctCopy5ArgLeft(MemorySegment src, MemorySegment dst) {\n+        testConjunctCopy(src, 1, dst, 0, CopyOp.of5Arg());\n+    }\n+\n+    void testConjunctCopy(MemorySegment src, long srcOffset, MemorySegment dst, long dstOffset, CopyOp op) {\n+        if (src.byteSize() < 4 || src.address() != dst.address()) {\n+            \/\/ Only test larger segments where the skew is zero\n+            return;\n+        }\n+\n+        try (var arena = Arena.ofConfined()) {\n+            \/\/ Create a disjoint segment for expected behavior\n+            MemorySegment disjoint = arena.allocate(dst.byteSize());\n+            disjoint.copyFrom(src);\n+            op.copy(src, srcOffset, disjoint, dstOffset, 3);\n+            byte[] expected = disjoint.toArray(JAVA_BYTE);\n+\n+            \/\/ Do a conjoint copy\n+            op.copy(src, srcOffset, dst, dstOffset, 3);\n+            byte[] actual = dst.toArray(JAVA_BYTE);\n+\n+            assertEquals(actual, expected);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    interface CopyOp {\n+        void copy(MemorySegment src, long srcOffset, MemorySegment dst, long dstOffset, long bytes);\n+\n+        static CopyOp of5Arg() {\n+            return MemorySegment::copy;\n+        }\n+\n+        static CopyOp of7Arg() {\n+            return (MemorySegment src, long srcOffset, MemorySegment dst, long dstOffset, long bytes) ->\n+                    MemorySegment.copy(src, JAVA_BYTE, srcOffset, dst, JAVA_BYTE, dstOffset, bytes);\n+        }\n+\n+    }\n+\n+    @Test(dataProvider = \"segmentKinds\")\n+    public void testByteCopySizes(SegmentKind kind1, SegmentKind kind2) {\n+\n+        record Offsets(int src, int dst){}\n+\n+        for (Offsets offsets : List.of(new Offsets(3, 7), new Offsets(7, 3))) {\n+            for (int size = 0; size < 513; size++) {\n+                MemorySegment src = kind1.makeSegment(size + offsets.src());\n+                MemorySegment dst = kind2.makeSegment(size + offsets.dst());\n+                \/\/prepare source slice\n+                for (int i = 0; i < size; i++) {\n+                    src.set(JAVA_BYTE, i + offsets.src(), (byte) i);\n+                }\n+                \/\/perform copy\n+                MemorySegment.copy(src, offsets.src(), dst, offsets.dst(), size);\n+                \/\/check that copy actually worked\n+                for (int i = 0; i < size; i++) {\n+                    assertEquals(dst.get(JAVA_BYTE, i + offsets.dst()), (byte) i);\n+                }\n+            }\n+        }\n+    }\n+\n@@ -280,0 +367,22 @@\n+    @DataProvider\n+    static Object[][] conjunctSegments() {\n+        List<Object[]> cases = new ArrayList<>();\n+        for (SegmentKind kind : SegmentKind.values()) {\n+            \/\/ Different paths might be taken in the implementation depending on the\n+            \/\/ size, type, and address of the underlying segments.\n+            for (int len : new int[]{0, 1, 7, 512}) {\n+                for (int offset : new int[]{-1, 0, 1}) {\n+                    MemorySegment segment = kind.makeSegment(len + 2);\n+                    MemorySegment src = segment.asSlice(1 + offset, len);\n+                    MemorySegment dst = segment.asSlice(1, len);\n+                    for (int i = 0; i < len; i++) {\n+                        src.set(JAVA_BYTE, i, (byte) i);\n+                    }\n+                    \/\/ src = 0, 1, ... , len-1\n+                    cases.add(new Object[]{src, dst});\n+                }\n+            }\n+        }\n+        return cases.toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":111,"deletions":2,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.foreign.ValueLayout.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class CopyTest {\n+\n+    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\",\n+            \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\",\n+            \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\", \"24\",\n+            \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\", \"32\",\n+            \"33\", \"36\", \"40\", \"44\", \"48\", \"52\", \"56\", \"60\", \"63\", \"64\", \"128\"})\n+    public int ELEM_SIZE;\n+\n+    byte[] srcArray;\n+    byte[] dstArray;\n+    MemorySegment heapSrcSegment;\n+    MemorySegment heapDstSegment;\n+    MemorySegment nativeSrcSegment;\n+    MemorySegment nativeDstSegment;\n+    ByteBuffer srcBuffer;\n+    ByteBuffer dstBuffer;\n+\n+    @Setup\n+    public void setup() {\n+        srcArray = new byte[ELEM_SIZE];\n+        dstArray = new byte[ELEM_SIZE];\n+        heapSrcSegment = MemorySegment.ofArray(srcArray);\n+        heapDstSegment = MemorySegment.ofArray(dstArray);\n+        nativeSrcSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n+        nativeDstSegment = Arena.ofAuto().allocate(ELEM_SIZE);\n+        srcBuffer = ByteBuffer.wrap(srcArray);\n+        dstBuffer = ByteBuffer.wrap(dstArray);\n+    }\n+\n+    @Benchmark\n+    public void array_copy() {\n+        System.arraycopy(srcArray, 0, dstArray, 0, ELEM_SIZE);\n+    }\n+\n+    @Benchmark\n+    public void heap_segment_copy5Arg() {\n+        MemorySegment.copy(heapSrcSegment, 0, heapDstSegment, 0, ELEM_SIZE);\n+    }\n+\n+    @Benchmark\n+    public void native_segment_copy5Arg() {\n+        MemorySegment.copy(nativeSrcSegment, 0, nativeDstSegment, 0, ELEM_SIZE);\n+    }\n+\n+    @Benchmark\n+    public void heap_segment_copy7arg() {\n+        MemorySegment.copy(heapSrcSegment, JAVA_BYTE, 0, heapDstSegment, JAVA_BYTE, 0, ELEM_SIZE);\n+    }\n+\n+    @Benchmark\n+    public void buffer_copy() {\n+        dstBuffer.put(srcBuffer);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CopyTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"}]}