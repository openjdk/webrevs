{"files":[{"patch":"@@ -184,0 +184,3 @@\n+  \/\/ active limit for this compilation, if any\n+  size_t _limit;\n+  bool _limit_crash;\n@@ -185,0 +188,1 @@\n+  \/\/ peak usage, bytes, over all arenas\n@@ -186,0 +190,1 @@\n+  \/\/ usage in node arena when total peaked\n@@ -187,0 +192,1 @@\n+  \/\/ usage in resource area when total peaked\n@@ -188,0 +194,1 @@\n+  \/\/ number of nodes (c2 only) when total peaked\n@@ -195,1 +202,1 @@\n-      _time(0), _num_recomp(0), _thread(nullptr),\n+      _time(0), _num_recomp(0), _thread(nullptr), _limit(0),\n@@ -203,0 +210,1 @@\n+  void set_limit(size_t limit) { _limit = limit; }\n@@ -221,0 +229,1 @@\n+    st->print_cr(\"  limit  : memory limit, if set\");\n@@ -228,1 +237,1 @@\n-    st->print_cr(\"total     NA        RA        result  #nodes  time    type  #rc thread              method\");\n+    st->print_cr(\"total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\");\n@@ -263,1 +272,13 @@\n-    st->print(\"%u \", _live_nodes_at_peak);\n+    if (_live_nodes_at_peak > 0) {\n+      st->print(\"%u \", _live_nodes_at_peak);\n+    } else {\n+      st->print(\"-\");\n+    }\n+    col += 8; st->fill_to(col);\n+\n+    \/\/ Limit\n+    if (_limit > 0) {\n+      st->print(PROPERFMT \" \", PROPERFMTARGS(_limit));\n+    } else {\n+      st->print(\"-\");\n+    }\n@@ -325,1 +346,1 @@\n-           unsigned live_nodes_at_peak, const char* result) {\n+           unsigned live_nodes_at_peak, size_t limit, const char* result) {\n@@ -346,0 +367,1 @@\n+    e->set_limit(limit);\n@@ -433,0 +455,1 @@\n+                    arena_stat->limit(),\n@@ -519,2 +542,2 @@\n-        ss.print(\"Hit MemLimit %s (limit: %zu now: %zu)\",\n-                 (hit_limit_before ? \"again\" : \"\"),\n+        ss.print(\"Hit MemLimit %s(limit: %zu now: %zu)\",\n+                 (hit_limit_before ? \"again \" : \"\"),\n","filename":"src\/hotspot\/share\/compiler\/compilationMemoryStatistic.cpp","additions":29,"deletions":6,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -45,0 +45,17 @@\n+\/\/ Default compile commands, if defined, are parsed before any of the\n+\/\/ explicitly defined compile commands. Thus, explicitly defined compile\n+\/\/ commands take precedence over default compile commands. The effect is\n+\/\/ as if the default compile commands had been specified at the start of\n+\/\/ the command line.\n+static const char* const default_compile_commands[] = {\n+#ifdef ASSERT\n+    \/\/ In debug builds, impose a (generous) per-compilation memory limit\n+    \/\/ to catch pathological compilations during testing. The suboption\n+    \/\/ \"crash\" will cause the JVM to assert.\n+    \/\/\n+    \/\/ Note: to disable the default limit at the command line,\n+    \/\/ set a limit of 0 (e.g. -XX:CompileCommand=MemLimit,*.*,0).\n+    \"MemLimit,*.*,1G~crash\",\n+#endif\n+    nullptr };\n+\n@@ -908,0 +925,8 @@\n+bool CompilerOracle::parse_from_line_quietly(char* line) {\n+  const bool quiet0 = _quiet;\n+  _quiet = true;\n+  const bool result = parse_from_line(line);\n+  _quiet = quiet0;\n+  return result;\n+}\n+\n@@ -1110,0 +1135,8 @@\n+  \/\/ Register default compile commands first - any commands specified via CompileCommand will\n+  \/\/ supersede these default commands.\n+  for (int i = 0; default_compile_commands[i] != nullptr; i ++) {\n+    char* s = os::strdup(default_compile_commands[i]);\n+    success = CompilerOracle::parse_from_line_quietly(s);\n+    os::free(s);\n+    assert(success, \"default compile command \\\"%s\\\" failed to parse\", default_compile_commands[i]);\n+  }\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+  static bool parse_from_line_quietly(char* line);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm -Xbatch -XX:CompileCommand=option,*::*,bool,Vectorize,true -XX:+PrintOpto -XX:+TraceLoopOpts compiler.c2.TestFindNode\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=option,*::*,bool,Vectorize,true -XX:CompileCommand=memlimit,TestFindNode::test,0 -XX:+PrintOpto -XX:+TraceLoopOpts compiler.c2.TestFindNode\n@@ -34,0 +34,2 @@\n+\/\/ Note; we disable the implicit memory limit of 1G in debug JVMs until JDK-8331283 is fixed\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestFindNode.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm\/timeout=600 -Xcomp -XX:VerifyIterativeGVN=1 -XX:CompileCommand=compileonly,compiler.loopopts.TestDeepGraphVerifyIterativeGVN::*\n+ * @run main\/othervm\/timeout=600 -Xcomp -XX:VerifyIterativeGVN=1 -XX:CompileCommand=compileonly,compiler.loopopts.TestDeepGraphVerifyIterativeGVN::* -XX:CompileCommand=memlimit,TestFindNode::test,0\n@@ -36,0 +36,2 @@\n+\/\/ Note; we disable the implicit memory limit of 1G in debug JVMs until JDK-8331295 is fixed\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestDeepGraphVerifyIterativeGVN.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024 Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +59,1 @@\n+import jdk.test.lib.Platform;\n@@ -66,0 +68,1 @@\n+    \/\/ Method we don't specify; default memlimit should apply\n@@ -67,0 +70,1 @@\n+    \/\/ Method we explicitly limit to 4K limit\n@@ -68,0 +72,2 @@\n+    \/\/ Method for which we explicitly disable a limit on the command line.\n+    final static String METHOD3 = \"method3\";\n@@ -79,7 +85,0 @@\n-        test(METHOD1, METHOD2);\n-        test(METHOD2, METHOD1);\n-    }\n-\n-    private static void test(String include, String exclude) throws Exception {\n-\n-        \/\/ A method that is known to cost compilers a bit of memory to compile\n@@ -91,0 +90,1 @@\n+        options.add(\"-XX:-CreateCoredumpOnCrash\");\n@@ -92,8 +92,9 @@\n-        \/\/ We pass a very small size to guarantee the crash\n-        options.add(\"-XX:CompileCommand=MemStat,\" + getTestMethod(include) + \",print\");\n-        if (test_crash) {\n-            options.add(\"-XX:CompileCommand=MemLimit,\" + getTestMethod(include) + \",4k~crash\");\n-            options.add(\"-XX:-CreateCoredumpOnCrash\");\n-        } else {\n-            options.add(\"-XX:CompileCommand=MemLimit,\" + getTestMethod(include) + \",4k\");\n-        }\n+\n+        \/\/ We want a final report\n+        options.add(\"-XX:CompileCommand=MemStat,*.*,print\");\n+\n+        \/\/ We limit method 2 to a very small limit that is guaranteed to trigger\n+        options.add(\"-XX:CompileCommand=MemLimit,\" + getTestMethod(METHOD2) + \",4k\" + (test_crash ? \"~crash\" : \"\"));\n+\n+        \/\/ We disable any limit set on method 3\n+        options.add(\"-XX:CompileCommand=MemLimit,\" + getTestMethod(METHOD3) + \",0\");\n@@ -112,7 +113,3 @@\n-        String expectedNameIncl = getTestMethod(include)\n-                .replace('.', '\/')\n-                .replace(\"$\", \"\\\\$\");\n-        String expectedNameExcl = getTestMethod(exclude)\n-                .replace('.', '\/')\n-                .replace(\"$\", \"\\\\$\");\n-\n+        String method1regex = testMethodNameForRegex(getTestMethod(METHOD1));\n+        String method2regex = testMethodNameForRegex(getTestMethod(METHOD2));\n+        String method3regex = testMethodNameForRegex(getTestMethod(METHOD3));\n@@ -124,2 +121,1 @@\n-            oa.shouldMatch(\"# *fatal error: \" + ct + \" *\" + expectedNameIncl + \".*: Hit MemLimit .*limit: 4096.*\");\n-            oa.shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n+            oa.shouldMatch(\"# *fatal error: \" + ct + \" *\" + method2regex + \".*: Hit MemLimit .*limit: 4096.*\");\n@@ -127,4 +123,11 @@\n-            \/\/ Should see trace output when methods are compiled\n-            oa.shouldHaveExitValue(0)\n-                    .shouldMatch(\".*\" + expectedNameIncl + \".*\")\n-                    .shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n+            oa.shouldHaveExitValue(0);\n+\n+            \/\/ In debug builds we have an inbuilt MemLimit. It is very high, so we don't expect it to fire in this test.\n+            \/\/ But it will still show up in the final report.\n+            String implicitMemoryLimit = Platform.isDebugBuild() ? \"1024M\" : \"-\";\n+\n+            \/\/ With C2, we print number of nodes, with C1 we don't\n+            String numberNodesRegex = c2 ? \"\\\\d+\" : \"-\";\n+\n+            \/\/ method 2 should have hit its tiny limit\n+            oa.shouldMatch(ct + \" \" + method2regex + \".*: Hit MemLimit \\\\(limit: 4096 now: \\\\d+\\\\)\");\n@@ -132,2 +135,3 @@\n-            \/\/ Expect this log line\n-            oa.shouldMatch(\".*\" + expectedNameIncl + \".*Hit MemLimit.*\");\n+            \/\/ neither of the other ones should have hit a limit\n+            oa.shouldNotMatch(method1regex + \".*Hit MemLimit\");\n+            oa.shouldNotMatch(method3regex + \".*Hit MemLimit\");\n@@ -135,2 +139,15 @@\n-            \/\/ Expect final output to contain \"oom\"\n-            oa.shouldMatch(\".*oom.*\" + expectedNameIncl + \".*\");\n+            \/\/ Final report:\n+            \/\/ Method 1 should show up as \"ok\" and with the default limit, e.g.\n+            \/\/ total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\n+            \/\/ 32728     0         32728     ok     -       1024M   0.045   c1    1   0x000000011b019c10  compiler\/print\/CompileCommandMemLimit$TestMain::method1(()J)\n+            oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +ok +\" + numberNodesRegex + \" +\" + implicitMemoryLimit + \" +.* +\" + method1regex);\n+\n+            \/\/ Method 2 should show up as \"oom\" and with its tiny limit, e.g.\n+            \/\/ total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\n+            \/\/ 32728     0         32728     oom     -       4096B   0.045   c1    1   0x000000011b019c10  compiler\/print\/CompileCommandMemLimit$TestMain::method1(()J)\n+            oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +oom +\" + numberNodesRegex + \" +4096B +.* +\" + method2regex);\n+\n+            \/\/ Method 3 should show up as \"ok\", and with no limit, even in debug builds, e.g.\n+            \/\/ total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\n+            \/\/ 32728     0         32728     ok     -       -        0.045   c1    1   0x000000011b019c10  compiler\/print\/CompileCommandMemLimit$TestMain::method1(()J)\n+            oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +ok +\" + numberNodesRegex + \" +- +.* +\" + method3regex);\n@@ -149,0 +166,5 @@\n+    private static String testMethodNameForRegex(String m) {\n+        return m.replace('.', '\/')\n+                .replace(\"$\", \"\\\\$\");\n+    }\n+\n@@ -153,0 +175,1 @@\n+            method3();\n@@ -159,0 +182,1 @@\n+        static void method3() {}\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandMemLimit.java","additions":57,"deletions":33,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024 Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +35,1 @@\n+import jdk.test.lib.Platform;\n@@ -71,3 +73,4 @@\n-        oa.shouldHaveExitValue(0)\n-          .shouldMatch(\".*\" + expectedNameIncl + \".*\")\n-          .shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n+        oa.shouldHaveExitValue(0).\n+                shouldMatch(\"Arena usage.*\" + expectedNameIncl + \".*\").\n+                shouldNotMatch(\"Arena usage.*\" + expectedNameExcl + \".*\");\n+\n@@ -77,5 +80,13 @@\n-        \/\/ total     NA        RA        result  #nodes  time    type  #rc thread              method\n-        \/\/ 211488    66440     77624     ok      13      0.057   c2    2   0x00007fb49428db70  compiler\/print\/CompileCommandPrintMemStat$TestMain::method1(()V)\n-        oa.shouldMatch(\"total.*method\");\n-        oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\S+ +\\\\d+.*\" + expectedNameIncl + \".*\");\n-        oa.shouldNotMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +\\\\S+ +\\\\d+.*\" + expectedNameExcl + \".*\");\n+        \/\/ total     NA        RA        result  #nodes  limit   time    type  #rc thread              method\n+        \/\/ 2149912   0         1986272   ok      -       -       0.101   c1    1   0x000000015180a600  jdk\/internal\/org\/objectweb\/asm\/Frame::execute((IILjdk\/internal\/org\/objectweb\/asm\/Symbol;Ljdk\/internal\/org\/objectweb\/asm\/SymbolTable;)V)        oa.shouldMatch(\"total.*method\");\n+        \/\/ or\n+        \/\/ 537784    98184     208536    ok      267     -       0.096   c2    1   0x0000000153019c00  jdk\/internal\/classfile\/impl\/BufWriterImpl::writeU1((I)V) 4521912   0         1986272   ok      -       -       0.101   c1    1   0x000000015180a600  jdk\/internal\/org\/objectweb\/asm\/Frame::execute((IILjdk\/internal\/org\/objectweb\/asm\/Symbol;Ljdk\/internal\/org\/objectweb\/asm\/SymbolTable;)V)        oa.shouldMatch(\"total.*method\");\n+        oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +ok +(\\\\d+|-) +.*\" + expectedNameIncl + \".*\");\n+\n+        \/\/ In debug builds, we have a default memory limit enabled. That implies MemStat. Therefore we\n+        \/\/ expect to see all methods, not just the one we specified on the command line.\n+        if (Platform.isDebugBuild()) {\n+            oa.shouldMatch(\"\\\\d+ +\\\\d+ +\\\\d+ +ok +(\\\\d+|-) +.*\" + expectedNameExcl + \".*\");\n+        } else {\n+            oa.shouldNotMatch(\".*\" + expectedNameExcl + \".*\");\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/print\/CompileCommandPrintMemStat.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"}]}