{"files":[{"patch":"@@ -226,0 +226,44 @@\n+\n+    \/**\n+     * Creates a {@link JavaFileObject} which represents the given source content.\n+     *\n+     * <p>The provided {@code uri} will be returned from {@link #toUri()}.\n+     * The provided {@code content} will be returned from {@link #getCharContent(boolean)}.\n+     * The {@link #getKind()} method will return {@link Kind#SOURCE}.\n+     *\n+     * <p>All other methods will behave as described in the documentation in this class,\n+     * as if the constructor is called with {@code uri} and {@code Kind.SOURCE}.\n+     *\n+     * <p>This method can be, for example, used to compile an in-memory String\n+     * to a set of classfile in a target directory:\n+     * {@snippet lang=\"java\":\n+     *      var code = \"\"\"\n+     *                 public class CompiledCode {}\n+     *                 \"\"\";\n+     *      var compiler = ToolProvider.getSystemJavaCompiler();\n+     *      var targetDirectory = \"...\";\n+     *      var task = compiler.getTask(null,\n+     *                                  null,\n+     *                                  null,\n+     *                                  List.of(\"-d\", targetDirectory),\n+     *                                  null,\n+     *                                  List.of(SimpleJavaFileObject.forSource(URI.create(\"CompiledCode.java\"), code)));\n+     *      if (!task.call()) {\n+     *          throw new IllegalStateException(\"Compilation failed!\");\n+     *      }\n+     * }\n+     *\n+     * @param uri that should be used for the resulting {@code JavaFileObject}\n+     * @param content the content of the {@code JavaFileObject}\n+     * @return a {@code JavaFileObject} representing the given source content.\n+     * @since 23\n+     *\/\n+    public static JavaFileObject forSource(URI uri, String content) {\n+        return new SimpleJavaFileObject(uri, Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                return content;\n+            }\n+        };\n+    }\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/tools\/SimpleJavaFileObject.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -212,6 +212,2 @@\n-                List.of(new SimpleJavaFileObject(URI.create(\"StringTemplateTest$.java\"), JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                return source;\n-            }\n-        })).call()) {\n+                List.of(SimpleJavaFileObject.forSource(URI.create(\"StringTemplateTest$.java\"), source))\n+           ).call()) {\n","filename":"test\/jdk\/java\/lang\/template\/StringTemplateTest.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -118,7 +118,2 @@\n-        return new SimpleJavaFileObject(\n-                URI.create(\"myfo:\/\/\/\" + binaryName + \".java\"), JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncoding) {\n-                return content;\n-            }\n-        };\n+        return SimpleJavaFileObject.forSource(\n+                URI.create(\"myfo:\/\/\/\" + binaryName + \".java\"), content);\n","filename":"test\/langtools\/jdk\/javadoc\/tool\/api\/basic\/APITest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -191,6 +191,2 @@\n-        return new SimpleJavaFileObject(URI.create(name), JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                return body;\n-            }\n-        };\n+        return SimpleJavaFileObject.forSource(URI.create(name),\n+                                              body);\n","filename":"test\/langtools\/tools\/doclint\/tool\/RunTest.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -78,6 +78,3 @@\n-            JavaFileObject fo = new SimpleJavaFileObject(URI.create(\"output\"), JavaFileObject.Kind.SOURCE) {\n-                @Override\n-                public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                    return out;\n-                }\n-            };\n+            JavaFileObject fo =\n+                    SimpleJavaFileObject.forSource(URI.create(\"output\"),\n+                                                   out);\n","filename":"test\/langtools\/tools\/javac\/6902720\/Test.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -56,7 +56,3 @@\n-        SimpleJavaFileObject getSource() {\n-            return new SimpleJavaFileObject(URI.create(\"myfo:\/Test.java\"), JavaFileObject.Kind.SOURCE) {\n-                @Override\n-                public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                    return sourceStr;\n-                }\n-            };\n+        JavaFileObject getSource() {\n+            return SimpleJavaFileObject.forSource(URI.create(\"myfo:\/Test.java\"),\n+                                                  sourceStr);\n","filename":"test\/langtools\/tools\/javac\/7079713\/TestCircularClassfile.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,7 +36,2 @@\n-    private static final SimpleJavaFileObject FILE = new SimpleJavaFileObject(\n-      URI.create(\"string:\/\/\/Cyclic.java\"), JavaFileObject.Kind.SOURCE) {\n-        @Override\n-        public String getCharContent(boolean ignoreEncodingErrors) {\n-            return  SOURCE;\n-        }\n-    };\n+    private static final JavaFileObject FILE = SimpleJavaFileObject.forSource(\n+            URI.create(\"string:\/\/\/Cyclic.java\"), SOURCE);\n@@ -50,1 +45,1 @@\n-        final Iterable<SimpleJavaFileObject> files = Collections.singleton(FILE);\n+        final Iterable<JavaFileObject> files = Collections.singleton(FILE);\n","filename":"test\/langtools\/tools\/javac\/Diagnostics\/8295024\/T8295024.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.io.IOException;\n@@ -43,1 +42,0 @@\n-import java.util.Objects;\n@@ -47,1 +45,0 @@\n-import javax.tools.JavaFileObject.Kind;\n@@ -76,7 +73,2 @@\n-                new SimpleJavaFileObject(URI.create(\"Test.java\"), Kind.SOURCE) {\n-                    @Override\n-                    public CharSequence getCharContent(boolean ignoreEncodingErrors)\n-                            throws IOException {\n-                        return \"class Test { void f(int x, int y) {} }\";\n-                    }\n-                };\n+                SimpleJavaFileObject.forSource(URI.create(\"Test.java\"),\n+                                               \"class Test { void f(int x, int y) {} }\");\n","filename":"test\/langtools\/tools\/javac\/MethodParameters\/LegacyOutputTest\/LegacyOutputTest.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import static javax.tools.JavaFileObject.Kind;\n@@ -45,5 +44,3 @@\n-        JavaFileObject sfo = new SimpleJavaFileObject(URI.create(\"\"),Kind.SOURCE) {\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                return \"class Test<S> { <T extends S & Runnable> void test(){}}\";\n-            }\n-        };\n+        JavaFileObject sfo =\n+            SimpleJavaFileObject.forSource(URI.create(\"\"),\n+                                           \"class Test<S> { <T extends S & Runnable> void test(){}}\");\n","filename":"test\/langtools\/tools\/javac\/api\/6608214\/T6608214.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import static javax.tools.JavaFileObject.Kind;\n@@ -55,5 +54,3 @@\n-        JavaFileObject sfo = new SimpleJavaFileObject(URI.create(\"myfo:\/Test.java\"),Kind.SOURCE) {\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                return \"\\tclass ErroneousWithTab\";\n-            }\n-        };\n+        JavaFileObject sfo =\n+            SimpleJavaFileObject.forSource(URI.create(\"myfo:\/Test.java\"),\n+                                           \"\\tclass ErroneousWithTab\");\n","filename":"test\/langtools\/tools\/javac\/api\/6733837\/T6733837.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-import static javax.tools.JavaFileObject.Kind;\n-\n@@ -51,5 +49,3 @@\n-        JavaFileObject sfo = new SimpleJavaFileObject(URI.create(\"myfo:\/Test.java\"),Kind.SOURCE) {\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                return \"class BadName { Object o = j; }\";\n-            }\n-        };\n+        JavaFileObject sfo =\n+                SimpleJavaFileObject.forSource(URI.create(\"myfo:\/Test.java\"),\n+                                               \"class BadName { Object o = j; }\");\n","filename":"test\/langtools\/tools\/javac\/api\/6852595\/T6852595.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -485,6 +485,2 @@\n-        return new SimpleJavaFileObject(getURIFromSource(source), JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                return source;\n-            }\n-        };\n+        return SimpleJavaFileObject.forSource(getURIFromSource(source),\n+                                              source);\n","filename":"test\/langtools\/tools\/javac\/api\/TestSearchPaths.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.io.IOException;\n@@ -35,1 +34,0 @@\n-import java.net.URISyntaxException;\n@@ -153,14 +151,2 @@\n-        return createFileObject(name, JavaFileObject.Kind.SOURCE, body);\n-    }\n-\n-    private JavaFileObject createFileObject(String name, JavaFileObject.Kind kind, String body) {\n-        try {\n-            return new SimpleJavaFileObject(new URI(\"myfo:\/\/\/\" + name), kind) {\n-                @Override\n-                public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                    return body;\n-                }\n-            };\n-        } catch (URISyntaxException e) {\n-            throw new IllegalArgumentException(name, e);\n-        }\n+        return SimpleJavaFileObject.forSource(URI.create(\"myfo:\/\/\/\" + name),\n+                                              body);\n","filename":"test\/langtools\/tools\/javac\/api\/taskListeners\/TestTypeElement.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -117,6 +117,2 @@\n-            file = new SimpleJavaFileObject(URI.create(\"Test.java\"), JavaFileObject.Kind.SOURCE) {\n-                @Override\n-                public CharSequence getCharContent(boolean ignoreEncoding) {\n-                    return code;\n-                }\n-            };\n+            file = SimpleJavaFileObject.forSource(URI.create(\"Test.java\"),\n+                                                  code);\n","filename":"test\/langtools\/tools\/javac\/doclint\/DocLintTest.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,5 +33,0 @@\n-import java.io.BufferedWriter;\n-import java.io.IOException;\n-import java.io.StringWriter;\n-import java.net.URI;\n-import java.net.URL;\n@@ -43,1 +38,0 @@\n-import javax.tools.StandardJavaFileManager;\n@@ -88,7 +82,3 @@\n-        SimpleJavaFileObject asJFO(java.io.File dir) {\n-            return new SimpleJavaFileObject(new java.io.File(dir, filename).toURI(), JavaFileObject.Kind.SOURCE) {\n-                @Override\n-                public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                    return contents;\n-                }\n-            };\n+        JavaFileObject asJFO(java.io.File dir) {\n+            return SimpleJavaFileObject.forSource(new java.io.File(dir, filename).toURI(),\n+                                                  contents);\n","filename":"test\/langtools\/tools\/javac\/lambda\/abort\/Abort.java","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -102,7 +102,3 @@\n-        SimpleJavaFileObject asJFO(java.io.File dir) {\n-            return new SimpleJavaFileObject(new File(dir, filename).toURI(), JavaFileObject.Kind.SOURCE) {\n-                @Override\n-                public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                    return contents;\n-                }\n-            };\n+        JavaFileObject asJFO(java.io.File dir) {\n+            return SimpleJavaFileObject.forSource(new File(dir, filename).toURI(),\n+                                                  contents);\n","filename":"test\/langtools\/tools\/javac\/lambda\/abort\/CompletionFailure.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.io.IOException;\n@@ -36,1 +35,0 @@\n-import javax.tools.JavaFileObject;\n@@ -128,6 +126,2 @@\n-        log.useSource(new SimpleJavaFileObject(new URI(\"mem:\/\/Test.java\"), JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                return test.input;\n-            }\n-        });\n+        log.useSource(SimpleJavaFileObject.forSource(URI.create(\"mem:\/\/Test.java\"),\n+                                                     test.input));\n","filename":"test\/langtools\/tools\/javac\/lexer\/JavaLexerTest.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -61,6 +61,2 @@\n-        var f = new SimpleJavaFileObject(URI.create(\"TestLambdaClass.java\"), JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                return \"@Deprecated public class TestLambdaClass {{new Thread(() -> {});}}\";\n-            }\n-        };\n+        var f = SimpleJavaFileObject.forSource(URI.create(\"TestLambdaClass.java\"),\n+                                               \"@Deprecated public class TestLambdaClass {{new Thread(() -> {});}}\");\n","filename":"test\/langtools\/tools\/javac\/main\/T8239544.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        return new SimpleJavaFileObject(\n+        return SimpleJavaFileObject.forSource(\n@@ -69,6 +69,1 @@\n-                JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                return code;\n-            }\n-        };\n+                code);\n","filename":"test\/langtools\/tools\/javac\/parser\/StringFoldingPosTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import java.io.IOException;\n@@ -53,1 +52,0 @@\n-import java.net.URISyntaxException;\n@@ -56,1 +54,0 @@\n-import javax.tools.JavaFileObject;\n@@ -70,1 +67,1 @@\n-    void runAll() throws URISyntaxException {\n+    void runAll() {\n@@ -72,22 +69,19 @@\n-        JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, null, null, null, null, List.of(new SimpleJavaFileObject(new URI(\"mem:\/\/Test.java\"), JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                return \"\"\"\n-                       interface A<T> {}\n-                       interface B<T> extends A<T> {}\n-                       interface C<X,Y> extends A<X> {}\n-                       interface D<X,Y> extends A<Y> {}\n-                       interface E<T> extends C<T,T> {}\n-                       interface F<T> extends A<B<T>> {}\n-                       interface G<T extends Number> extends A<T> {}\n-                       interface H extends A<String> {}\n-                       interface I<T> extends H {}\n-                       class Test<T1 extends CharSequence&Runnable, T2 extends Number> {\n-                       }\n-                       interface RecursiveTest1Interface<IB extends RecursiveTest1Interface<IB>> { }\n-                       interface RecursiveTest1Use<BB extends RecursiveTest1Use<BB>> extends RecursiveTest1Interface<BB> { }\n-                       interface RecursiveTest2Interface<X> { }\n-                       interface RecursiveTest2Use<X extends RecursiveTest2Use<X, Y>, Y> extends RecursiveTest2Interface<Y> { }\n-                       \"\"\";\n-            }\n-        }));\n+        String source = \"\"\"\n+                        interface A<T> {}\n+                        interface B<T> extends A<T> {}\n+                        interface C<X,Y> extends A<X> {}\n+                        interface D<X,Y> extends A<Y> {}\n+                        interface E<T> extends C<T,T> {}\n+                        interface F<T> extends A<B<T>> {}\n+                        interface G<T extends Number> extends A<T> {}\n+                        interface H extends A<String> {}\n+                        interface I<T> extends H {}\n+                        class Test<T1 extends CharSequence&Runnable, T2 extends Number> {\n+                        }\n+                        interface RecursiveTest1Interface<IB extends RecursiveTest1Interface<IB>> { }\n+                        interface RecursiveTest1Use<BB extends RecursiveTest1Use<BB>> extends RecursiveTest1Interface<BB> { }\n+                        interface RecursiveTest2Interface<X> { }\n+                        interface RecursiveTest2Use<X extends RecursiveTest2Use<X, Y>, Y> extends RecursiveTest2Interface<Y> { }\n+                        \"\"\";\n+\n+        JavacTaskImpl task = (JavacTaskImpl) compiler.getTask(null, null, null, null, null, List.of(SimpleJavaFileObject.forSource(URI.create(\"mem:\/\/Test.java\"), source)));\n","filename":"test\/langtools\/tools\/javac\/patterns\/InferenceUnitTest.java","additions":20,"deletions":26,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import javax.tools.JavaFileObject;\n@@ -51,6 +50,2 @@\n-                List.of(new SimpleJavaFileObject(URI.create(\"TestClass.java\"), JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                return \"record R(int val1, int val2) {}\";\n-            }\n-        }));\n+                List.of(SimpleJavaFileObject.forSource(URI.create(\"TestClass.java\"),\n+                                                       \"record R(int val1, int val2) {}\")));\n","filename":"test\/langtools\/tools\/javac\/records\/ElementFilterRecordComponentTest.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8325362\n+ * @summary Test SimpleJavaFileObject\n+ * @library \/tools\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ * @run main TestSimpleJavaFileObject\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.tools.Diagnostic.Kind;\n+import javax.tools.DiagnosticListener;\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+import toolbox.TestRunner;\n+\n+public class TestSimpleJavaFileObject extends TestRunner {\n+\n+    public TestSimpleJavaFileObject() {\n+        super(System.err);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        TestSimpleJavaFileObject t = new TestSimpleJavaFileObject();\n+        t.runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testForSource(Path p) throws IOException {\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        List<String> errors = new ArrayList<>();\n+        DiagnosticListener<JavaFileObject> noErrors = d -> {\n+            if (d.getKind() == Kind.ERROR) {\n+                errors.add(d.getSource().toUri().toString() + \":\" +\n+                           d.getLineNumber() + \":\" +\n+                           d.getColumnNumber() + \":\" +\n+                           d.getCode());\n+            }\n+        };\n+        try (JavaFileManager fm = compiler.getStandardFileManager(null, null, null);\n+             LoggingFileManager rfm = new LoggingFileManager(fm)) {\n+            JavaFileObject src = SimpleJavaFileObject.forSource(URI.create(\"mem:\/\/\/Test.java\"),\n+                                                                \"\"\"\n+                                                                public class Test {}\n+                                                                \"\"\");\n+            assertTrue(\"compilation didn't succeed!\",\n+                       compiler.getTask(null, rfm, noErrors, null, null, List.of(src))\n+                               .call());\n+            assertTrue(\"no compilation errors expected, but got: \" + errors,\n+                       errors.isEmpty());\n+            Set<String> expectedWrittenClasses = Set.of(\"Test\");\n+            assertTrue(\"compiled correct classes: \" + rfm.writtenClasses,\n+                       expectedWrittenClasses.equals(rfm.writtenClasses));\n+        }\n+\n+        errors.clear();\n+\n+        JavaFileObject src = SimpleJavaFileObject.forSource(URI.create(\"mem:\/\/\/Test.java\"),\n+                                                            \"\"\"\n+                                                            public class Test {\n+                                                                Unknown u;\n+                                                            }\n+                                                            \"\"\");\n+        assertTrue(\"compilation succeeded unexpectedly!\",\n+                   !compiler.getTask(null, null, noErrors, null, null, List.of(src))\n+                            .call());\n+        List<String> expectedCompilationErrors = List.of(\n+                \"mem:\/\/\/Test.java:2:5:compiler.err.cant.resolve.location\"\n+        );\n+        assertTrue(\"incorrect compilation errors, expected: \" + expectedCompilationErrors +\n+                   \"actual: \" + errors,\n+                   expectedCompilationErrors.equals(errors));\n+    }\n+\n+    private static final class LoggingFileManager extends ForwardingJavaFileManager<JavaFileManager> {\n+\n+        private final Set<String> writtenClasses = new HashSet<>();\n+\n+        public LoggingFileManager(JavaFileManager fileManager) {\n+            super(fileManager);\n+        }\n+\n+        @Override\n+        public JavaFileObject getJavaFileForOutput(Location location,\n+                                                   String className,\n+                                                   JavaFileObject.Kind kind,\n+                                                   FileObject sibling) throws IOException {\n+            writtenClasses.add(className);\n+\n+            return super.getJavaFileForOutput(location, className, kind, sibling);\n+        }\n+\n+    }\n+\n+    private static void assertTrue(String message, boolean c) {\n+        if (!c) {\n+            throw new AssertionError(message);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/toolsapi\/TestSimpleJavaFileObject.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-import java.io.FileNotFoundException;\n@@ -38,1 +37,0 @@\n-import java.util.function.Supplier;\n@@ -560,5 +558,1 @@\n-        JavaFileObject fo = new SimpleJavaFileObject(uri, JavaFileObject.Kind.SOURCE) {\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-                return compUnit;\n-            }\n-        };\n+        JavaFileObject fo = SimpleJavaFileObject.forSource(uri, compUnit);\n","filename":"test\/langtools\/tools\/lib\/snippets\/SnippetUtils.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"}]}