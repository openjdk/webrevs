{"files":[{"patch":"@@ -1065,2 +1065,2 @@\n-  Let * indicate scalar multiplication (i.e., c = a * b);\n-  Let × indicate scalar multiplication followed by reduction modulo P (i.e., c = a × b = {(a * b) mod P})\n+  Let * indicate scalar multiplication (i.e., w = u * v);\n+  Let × indicate scalar multiplication followed by reduction modulo P (i.e., z = u × v = {(u * v) mod P})\n@@ -1093,1 +1093,1 @@\n-  Define mathematical vectors as below:\n+  Define mathematical vectors (not same as SIMD vector lanes) as below:\n@@ -1096,3 +1096,3 @@\n-  Ci      = [C[4i], C[4i+1], C[4i+2], C[4i+3]] for i ∈ [0, l')\n-  Ex: C0  = [C0, C1, C2, C3]\n-  Ex: C1  = [C4, C5, C6, C7]\n+  COEF[i] = [C[4i], C[4i+1], C[4i+2], C[4i+3]] for i ∈ [0, l'). For example, COEF[0] and COEF[1] shown below.\n+  COEF[0] = [C0, C1, C2, C3]\n+  COEF[1] = [C4, C5, C6, C7]\n@@ -1100,3 +1100,3 @@\n-  ACC     = [acc, 0, 0, 0]; acc has hash from previous computations (if any)\n-  ⊗ indicates component-wise multiplication followed by modulo reduction\n-  ⊕ indicates component-wise addition, + indicates scalar addition\n+  ACC     = [acc, 0, 0, 0]; acc has hash from previous computations (if any), otherwise 0.\n+  ⊗ indicates component-wise vector multiplication followed by modulo reduction\n+  ⊕ indicates component-wise vector addition, + indicates scalar addition\n@@ -1105,2 +1105,2 @@\n-    T ← ACC\n-    T ← T ⊕ C0;\n+    T ← ACC; # load accumulator\n+    T ← T ⊕ COEF[0]; # add accumulator to the first 4 blocks\n@@ -1109,1 +1109,1 @@\n-    l' = floor(l\/4)\n+    l' = floor(l\/4); # operate on 4 blocks at a time\n@@ -1111,1 +1111,1 @@\n-      T ← (R4444 ⊗ T) ⊕ Ci;\n+      T ← (R4444 ⊗ T) ⊕ COEF[i];\n@@ -1180,1 +1180,1 @@\n-    T ← T ⊕ C0;\n+    T ← T ⊕ COEF[0];\n@@ -1375,1 +1375,1 @@\n-      T ← (R4444 ⊗ T) ⊕ Ci;\n+      T ← (R4444 ⊗ T) ⊕ COEF[i];\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"}]}