{"files":[{"patch":"@@ -418,1 +418,2 @@\n- -runtime\/signal\n+ -runtime\/signal \\\n+ -runtime\/stack\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack001.\n+ * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     Provoke StackOverflowError by infinite recursion in Java method,\n+ *     intercept the exception try to make one more invocation.\n+ * COMMENTS\n+ *     Kestrel for Solaris_JDK_1.3-b10 crashes while trying to execute\n+ *     this test with Client HS VM.\n+ *     See lots of bugs concerning similar failures:\n+ *     Evaluated:\n+ *     4217960 [native stack overflow bug] reflection test causes crash\n+ *     Accepted:\n+ *     4285716 native stack overflow causes crash on Solaris\n+ *     4281578 Second stack overflow crashes HotSpot VM\n+ *     Closed (duplicate):\n+ *     4027933     Native stack overflows not detected or handled correctly\n+ *     4134353     (hpi) sysThreadCheckStack is a no-op on win32\n+ *     4185411     Various crashes when using recursive reflection.\n+ *     4167055     infinite recursion in FindClass\n+ *     4222359     Infinite recursion crashes jvm\n+ *     Closed (will not fix):\n+ *     4231968 StackOverflowError in a native method causes Segmentation Fault\n+ *     4254634     println() while catching StackOverflowError causes hotspot VM crash\n+ *     4302288 the second stack overflow causes Classic VM to exit on win32\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack001\n+ *\/\n+\n+public class Stack001 {\n+    public static void main(String[] args) {\n+        Stack001 test = new Stack001();\n+        test.recurse(0);\n+        System.out.println(\"Maximal depth: \" + test.maxdepth);\n+    }\n+\n+    private int maxdepth;\n+\n+    private void recurse(int depth) {\n+        maxdepth = depth;\n+        try {\n+            recurse(depth + 1);\n+        } catch (StackOverflowError | OutOfMemoryError e) {\n+            if (maxdepth == depth) {\n+                recurse(depth + 1);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack001.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack002.\n+ * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     Provoke StackOverflowError by infinite recursion in Java method,\n+ *     intercept the exception and continue to invoke that method until\n+ *     the test exceeds timeout, or until Java VM crashes.\n+ * COMMENTS\n+ *     I believe that the test causes HS crashes due to the following bug:\n+ *     4330318 (P2\/S2) NSK test fails as An irrecoverable stack overflow\n+ *     See also bugs (lots of bugs!):\n+ *     Evaluated:\n+ *     4217960 [native stack overflow bug] reflection test causes crash\n+ *     Accepted:\n+ *     4285716 native stack overflow causes crash on Solaris\n+ *     4281578 Second stack overflow crashes HotSpot VM\n+ *     Closed (duplicate):\n+ *     4027933     Native stack overflows not detected or handled correctly\n+ *     4134353     (hpi) sysThreadCheckStack is a no-op on win32\n+ *     4185411     Various crashes when using recursive reflection.\n+ *     4167055     infinite recursion in FindClass\n+ *     4222359     Infinite recursion crashes jvm\n+ *     Closed (will not fix):\n+ *     4231968 StackOverflowError in a native method causes Segmentation Fault\n+ *     4254634     println() while catching StackOverflowError causes hotspot VM crash\n+ *     4302288 the second stack overflow causes Classic VM to exit on win32\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack002\n+ *\/\n+\n+public class Stack002 {\n+    static final long timeout = 10000; \/\/ 10 seconds\n+\n+    public static void main(String[] args) {\n+        Tester tester = new Tester();\n+        Timer timer = new Timer(tester);\n+        timer.start();\n+        tester.start();\n+        while (timer.isAlive()) {\n+            try {\n+                timer.join();\n+            } catch (InterruptedException e) {\n+                e.printStackTrace();\n+                throw new RuntimeException(e);\n+            }\n+        }\n+        System.out.println(\"Maximal depth: \" + tester.maxdepth);\n+    }\n+\n+    private static class Tester extends Thread {\n+        int maxdepth;\n+        public volatile boolean stop;\n+\n+        public Tester() {\n+            maxdepth = 0;\n+            stop = false;\n+        }\n+\n+        public void run() {\n+            recurse(0);\n+        }\n+\n+        void recurse(int depth) {\n+            maxdepth = depth;\n+            try {\n+                if (stop) {\n+                    return;\n+                }\n+                recurse(depth + 1);\n+            } catch (StackOverflowError | OutOfMemoryError e) {\n+                recurse(depth + 1);\n+            }\n+        }\n+    }\n+\n+    private static class Timer extends Thread {\n+        private Tester tester;\n+\n+        public Timer(Tester tester) {\n+            this.tester = tester;\n+        }\n+\n+        public void run() {\n+            long started;\n+            started = System.currentTimeMillis();\n+            while (System.currentTimeMillis() - started < timeout) {\n+                try {\n+                    Thread.sleep(1000);\n+                } catch (InterruptedException e) {\n+                    e.printStackTrace();\n+                    return;\n+                };\n+            }\n+            tester.stop = true;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack002.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack003.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking static recursive method for the given fixed depth\n+ *     of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n+ *     platforms (Win32, Solaris, Linux) in all execution modes\n+ *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n+ *     I had tryied it.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack003\n+ *\/\n+\n+public class Stack003 {\n+    final static int ITERATIONS = 100;\n+    final static int INCREMENT = 100;\n+\n+    public static void main(String[] args) {\n+\n+        int depth;\n+        for (depth = 1; ; depth += INCREMENT) {\n+            try {\n+                recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            try {\n+                recurse(2 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack003.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack004.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking final static recursive method for the given fixed\n+ *     depth of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n+ *     platforms (Win32, Solaris, Linux) in all execution modes\n+ *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n+ *     I had tryied it.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack004\n+ *\/\n+\n+public class Stack004 {\n+    public static void main(String[] args) {\n+        Stack004 test = new Stack004();\n+        test.doRun();\n+    }\n+\n+    public void doRun() {\n+        int depth;\n+        for (depth = 100; ; depth += 100) {\n+            try {\n+                recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                recurse(2 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    final static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack004.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack005.\n+ * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking final recursive method for the given fixed depth of\n+ *     recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n+ *     platforms (Win32, Solaris, Linux) in all execution modes\n+ *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n+ *     I had tryied it.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack005\n+ *\/\n+\n+public class Stack005 {\n+    public static void main(String[] args) {\n+        Stack005 test = new Stack005();\n+        int depth;\n+        for (depth = 100; ; depth += 100) {\n+            try {\n+                test.recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError soe) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                test.recurse(2 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    final void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack005.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack006.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking virtual recursive method for the given fixed depth\n+ *     of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n+ *     platforms (Win32, Solaris, Linux) in all execution modes\n+ *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n+ *     I had tryied it.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack006\n+ *\/\n+\n+public class Stack006 implements Stack006i {\n+    public static void main(String[] args) {\n+        Stack006i test = new Stack006();\n+        int depth;\n+        for (depth = 100; ; depth += 100) {\n+            try {\n+                test.recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                test.recurse(2 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    public void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n+\n+interface Stack006i {\n+    void recurse(int depth);\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack006.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack007.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invoking synchronized virtual recursive method for the given\n+ *     fixed depth of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 10000 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is 10 times that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes HS versions 1.3 and 1.4 on Win32, Solaris,\n+ *     and Linux platforms in all execution modes. However, it passes\n+ *     against HS 2.0 on Win32 platform.\n+ *     See also the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack007\n+ *\/\n+\n+public class Stack007 implements Stack007i {\n+    final static int ITERATIONS = 1000;\n+    final static int INCREMENT = 100;\n+\n+    public static void main(String[] args) {\n+        Stack007i test = new Stack007();\n+        int depth;\n+        for (depth = 100; ; depth += INCREMENT) {\n+            try {\n+                test.recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            try {\n+                test.recurse(10 * depth);\n+                System.out.println(\"?\");\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ OK.\n+            }\n+        }\n+    }\n+\n+    public synchronized void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n+\n+interface Stack007i {\n+    void recurse(int depth);\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack007.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack008.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the same thread\n+ *     by invocations via reflection. Recursive method is invoked for\n+ *     the given fixed depth of recursion (though, for a large depth).\n+ *     This test makes measures a number of recursive invocations\n+ *     before 1st StackOverflowError, and then tries to reproduce\n+ *     such StackOverflowError 100 times -- each time by trying to\n+ *     invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is twice that depth just measured).\n+ *     The test is deemed passed, if VM have not crashed.\n+ * COMMENTS\n+ *     This test crashes all HS versions (2.0, 1.3, 1.4) on Solaris,\n+ *     and crashes HS 2.0 on win32. However, it passes against HS 1.3\n+ *     and 1.4 on Win32.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *     The stack size is too small to run on systems with > 4K page size.\n+ *     Making it bigger could cause timeouts on other platform.\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @run main\/othervm\/timeout=900 -Xss200K Stack008\n+ *\/\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+public class Stack008 {\n+    public static void main(String[] args) {\n+        int depth;\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        for (depth = 100; ; depth += 100) {\n+            try {\n+                invokeRecurse(depth);\n+            } catch (Throwable exception) {\n+                Throwable target = getTargetException(exception);\n+                if ((target instanceof StackOverflowError) ||\n+                        (target instanceof OutOfMemoryError))\n+                    break; \/\/ OK.\n+                target.printStackTrace();\n+                throw new RuntimeException(exception);\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + depth);\n+        \/\/\n+        \/\/ Provoke stack overflow multiple times:\n+        \/\/\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                invokeRecurse(2 * depth);\n+\/\/              System.out.println(\"?\");\n+            } catch (Throwable exception) {\n+                Throwable target = getTargetException(exception);\n+                if ((target instanceof StackOverflowError) ||\n+                        (target instanceof OutOfMemoryError))\n+                    continue; \/\/ OK.\n+                target.printStackTrace();\n+                throw new RuntimeException(exception);\n+            }\n+        }\n+    }\n+\n+    private static Throwable getTargetException(Throwable exception) {\n+        Throwable target;\n+        \/\/\n+        \/\/ Unwrap deep chain of exceptions:\n+        \/\/\n+        for (\n+                target = exception;\n+                target instanceof InvocationTargetException;\n+                target = ((InvocationTargetException) target).getTargetException()\n+                )\n+            ;\n+        return target;\n+    }\n+\n+    static Method method = null;\n+    static Stack008 instance = null;\n+    static Object params[] = null;\n+\n+    private static void invokeRecurse(int depth) throws Exception {\n+        if (method == null) {\n+            \/\/\n+            \/\/ Optimization trick: allocate once, use everywhere.\n+            \/\/\n+            instance = new Stack008();\n+            method = Stack008.class.getMethod(\"recurse\");\n+            params = new Object[]{};\n+        }\n+        \/\/\n+        \/\/ Note, that the same instance.depth is used in all invocations:\n+        \/\/\n+        instance.depth = depth;\n+        method.invoke(instance, params);\n+    }\n+\n+    int depth = 0;\n+\n+    public void recurse() throws Exception {\n+        if (depth > 0) {\n+            \/\/\n+            \/\/ Self-invoke via reflection:\n+            \/\/\n+            invokeRecurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack008.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack009.\n+ * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test provokes second stack overflow from within the\n+ *     stack overflow handler.\n+ *     This test measures a number of recursive invocations until\n+ *     StackOverflowError, and then tries to make an invocation\n+ *     for the fixed invocations depth from within the \"catch\"\n+ *     block just caught the 1st stack overflow. The depth of new\n+ *     invocations is 10 times that depth seen at the 1st stack\n+ *     overflow; so that another stack overflow occurs.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if there is no exception thrown other than due to stack\n+ *     overflow.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on Win32\n+ *     and Solaris platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack009\n+ *\/\n+\n+public class Stack009 {\n+    public static void main(String[] args) {\n+        for (int depth = 100; ; depth += 100) {\n+            try {\n+                recurse(depth);\n+            } catch (StackOverflowError | OutOfMemoryError error1) {\n+\n+                System.out.println(\"Max. depth: \" + depth);\n+\n+                try {\n+                    recurse(10 * depth);\n+                    System.out.println(\"?\");\n+                } catch (StackOverflowError | OutOfMemoryError error2) {\n+                    \/\/ ignore\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack009.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack010.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking static recursive method for the given\n+ *     fixed depth of recursion (though, for a large depth).\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, 1.4 on Win32 and Solaris\n+ *     platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack010\n+ *\/\n+\n+public class Stack010 extends Thread {\n+    final static int THREADS = 1;\n+    final static int CYCLES = 1;\n+\n+    public static void main(String[] args) {\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack010 threads[] = new Stack010[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack010();\n+            threads[i].depthToTry = 100 * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were not thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    int depthToTry = 0;\n+    Throwable thrown = null;\n+\n+    public void run() {\n+        for (int i = 0; i < CYCLES; i++) {\n+            try {\n+                System.out.println(\"depth = \" +depthToTry);\n+                recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+\n+    static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack010.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack011.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking final static recursive method for the\n+ *     given fixed depth of recursion (though, for a large depth).\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, 1.4 on Win32 and Solaris\n+ *     platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack011\n+ *\/\n+\n+public class Stack011 extends Thread {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+\n+    public static void main(String[] args) {\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError soe) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack011 threads[] = new Stack011[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack011();\n+            threads[i].depthToTry = 10 * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were not thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    int depthToTry = 0;\n+    Throwable thrown = null;\n+\n+    public void run() {\n+        for (int i = 0; i < CYCLES; i++) {\n+            try {\n+                recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+\n+    final static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack011.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack012.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking final recursive method for the given\n+ *     fixed depth of recursion (though, for a large depth).\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 1.3, 1.4 on Win32, and HS versions\n+ *     2.0, 1.3, and 1.4 on Solaris. However, it passes against HS 2.0\n+ *     on Win32.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack012\n+ *\/\n+\n+public class Stack012 extends Thread {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+\n+    public static void main(String[] args) {\n+        Stack012 test = new Stack012();\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                test.recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack012 threads[] = new Stack012[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack012();\n+            threads[i].depthToTry = 10 * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were not thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    int depthToTry = 0;\n+    Throwable thrown = null;\n+\n+    public void run() {\n+        for (int i = 0; i < CYCLES; i++) {\n+            try {\n+                this.recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+\n+    final void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack012.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack013.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking virtual recursive method for the given\n+ *     fixed depth of recursion (though, for a large depth).\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both Win32\n+ *     and Solaris platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack013\n+ *\/\n+\n+public class Stack013 extends Stack013i {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+\n+    public static void main(String[] args) {\n+        Stack013i test = new Stack013();\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                test.recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack013i threads[] = new Stack013i[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack013();\n+            threads[i].depthToTry = 10 * maxDepth;\n+            threads[i].cycles = CYCLES;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n+\n+abstract class Stack013i extends Thread {\n+    \/\/\n+    \/\/ Pure virtual method:\n+    \/\/\n+    abstract void recurse(int depth);\n+\n+    Throwable thrown = null;\n+    int depthToTry;\n+    int cycles;\n+\n+    public void run() {\n+        \/\/\n+        \/\/ Provoke multiple stack overflows:\n+        \/\/\n+        for (int i = 0; i < cycles; i++) {\n+            try {\n+                recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack013.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack014.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking synchronized virtual recursive method\n+ *     for the given fixed depth of recursion (though, for a large\n+ *     depth). Note however, that different threads are not actual\n+ *     synchronized, because different instances having the recursive\n+ *     method are used.\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on Solaris.\n+ *     However, it passes against all these HS versions on Win32.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack014\n+ *\/\n+\n+public class Stack014 extends Stack014i {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+\n+    public static void main(String[] args) {\n+        Stack014i test = new Stack014();\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 10; ; depth += 10) {\n+            try {\n+                test.recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack014i threads[] = new Stack014i[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack014();\n+            threads[i].depthToTry = 10 * maxDepth;\n+            threads[i].cycles = CYCLES;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    synchronized void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+}\n+\n+abstract class Stack014i extends Thread {\n+    \/\/\n+    \/\/ Pure virtual method:\n+    \/\/\n+    abstract void recurse(int depth);\n+\n+    Throwable thrown = null;\n+    int depthToTry;\n+    int cycles;\n+\n+    public void run() {\n+        \/\/\n+        \/\/ Provoke multiple stack overflows:\n+        \/\/\n+        for (int i = 0; i < cycles; i++) {\n+            try {\n+                recurse(depthToTry);\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack014.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack015.\n+ * VM testbase keywords: [stress, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows in the multiple\n+ *     threads -- by invoking synchronized virtual recursive method\n+ *     for the given fixed depth of recursion from within another\n+ *     recursive method already deeply invoked.\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     in 10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on Solaris.\n+ *     However, it passes against all these HS versions on Win32.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires vm.opt.DeoptimizeALot != true\n+ * @run main\/othervm\/timeout=900 Stack015\n+ *\/\n+\n+public class Stack015 extends Stack015i {\n+    final static int THREADS = 10;\n+    final static int CYCLES = 10;\n+    final static int STEP = 10;\n+    final static int RESERVE = 10;\n+\n+    public static void main(String[] args) {\n+        \/\/\n+        \/\/ The test will invoke the particular Stack015.recurse()\n+        \/\/ method via abstract test.recurse() invocations.\n+        \/\/\n+        Stack015i test = new Stack015();\n+        Stack015i.test = test;\n+\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (int depth = 0; ; depth += STEP) {\n+            try {\n+                test.recurse(depth);\n+                maxDepth = depth;\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Max. depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n+        \/\/\n+        Stack015i threads[] = new Stack015i[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack015();\n+            threads[i].depthToTry = RESERVE * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    synchronized void syncRecurse(int depth) {\n+        if (depth > 0) {\n+            syncRecurse(depth - 1);\n+        }\n+    }\n+}\n+\n+abstract class Stack015i extends Thread {\n+    \/\/\n+    \/\/ Pure virtual method:\n+    \/\/\n+    abstract void syncRecurse(int depth);\n+\n+    void recurse(int depth) {\n+        \/\/\n+        \/\/ Stack overflow must occur here:\n+        \/\/\n+        syncRecurse(Stack015.STEP);\n+        \/\/\n+        \/\/ If no stack overflow occured, try again with deeper stack:\n+        \/\/\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+\n+    Throwable thrown = null;\n+    int depthToTry;\n+\n+    static Stack015i test;\n+\n+    public void run() {\n+        \/\/\n+        \/\/ Provoke multiple stack overflows:\n+        \/\/\n+        for (int i = 0; i < Stack015.CYCLES; i++) {\n+            try {\n+                \/\/\n+                \/\/ All threads invoke the same synchronized method:\n+                \/\/\n+                test.recurse(depthToTry);\n+\n+                throw new Exception(\n+                        \"TEST_RFE: no stack overflow thrown\" +\n+                                \", need to try deeper recursion?\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack015.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack016.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test provokes second stack overflow from within the\n+ *     stack overflow handler -- repeatedly multiple times, and\n+ *     in multiple threads.\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     in 10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before,\n+ *     and then trying to invoke that recursive method once again\n+ *     from within the catch clause just caught StackOverflowError.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\")\n+ * @run main\/othervm\/timeout=900 -Xint -Xss448K Stack016\n+ * @run main\/othervm\/timeout=900 -Xcomp -Xss448K Stack016\n+ * @run main\/othervm\/timeout=900 -Xcomp -XX:-TieredCompilation -Xss448K Stack016\n+ *\/\n+\n+public class Stack016 extends Thread {\n+    private final static int THREADS = 10;\n+    private final static int CYCLES = 10;\n+    private final static int STEP = 10;\n+    private final static int RESERVE = 10;\n+    private final static int PROBES = STEP * RESERVE;\n+\n+    public static void main(String[] args) {\n+        Stack016 test = new Stack016();\n+        test.doRun();\n+    }\n+\n+    private void doRun() {\n+        \/\/\n+        \/\/ Measure recursive depth before stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (depthToTry = 0; ; depthToTry += STEP) {\n+            try {\n+                trickyRecurse(depthToTry);\n+                maxDepth = depthToTry;\n+            } catch (StackOverflowError | OutOfMemoryError ex) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        Stack016 threads[] = new Stack016[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack016();\n+            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n+            threads[i].depthToTry = RESERVE * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    private int stackTop = 0;\n+    private int depthToTry = 0;\n+    private Throwable thrown = null;\n+\n+    private void trickyRecurse(int depth) {\n+        stackTop = depthToTry - depth;\n+        if (depth > 0) {\n+            try {\n+                trickyRecurse(depth - 1);\n+            } catch (StackOverflowError | OutOfMemoryError error) {\n+                \/\/\n+                \/\/ Provoke more stack overflow,\n+                \/\/ if current stack is deep enough:\n+                \/\/\n+                if (depthToTry - depth < stackTop - PROBES)\n+                    throw error;\n+                recurse(depthToTry);\n+\n+                throw new Error(\"TEST_RFE: try deeper recursion!\");\n+            }\n+        }\n+    }\n+\n+    private static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+\n+    public void run() {\n+        String threadName = Thread.currentThread().getName();\n+        for (int i = 1; i <= CYCLES; i++) {\n+            try {\n+                System.out.println(threadName + \", iteration: \" + i + \"\/\" + CYCLES +\n+                        \", depthToTry: \" + depthToTry);\n+                trickyRecurse(depthToTry);\n+                throw new Error(\n+                        \"TEST_BUG: trickyRecursion() must throw an error anyway!\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack016.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack017.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test invokes infinitely recursive method from within stack\n+ *     overflow handler  -- repeatedly multiple times, and in multiple\n+ *     threads.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @run main\/othervm\/timeout=900 -Xss220K Stack017\n+ *\/\n+\n+public class Stack017 extends Thread {\n+    private final static int THREADS = 10;\n+    private final static int CYCLES = 10;\n+    private final static int PROBES = 100;\n+\n+    public static void main(String[] args) {\n+        Stack017 test = new Stack017();\n+        test.doRun();\n+    }\n+\n+    private static int depthToTry;\n+\n+    private void doRun() {\n+        \/\/\n+        \/\/ Measure recursive depth before stack overflow:\n+        \/\/\n+        try {\n+            recurse(0);\n+        } catch (StackOverflowError | OutOfMemoryError err) {\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+        depthToTry = maxDepth;\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        Stack017 threads[] = new Stack017[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack017();\n+            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    private int maxDepth = 0;\n+\n+    private void recurse(int depth) {\n+        maxDepth = depth;\n+        recurse(depth + 1);\n+    }\n+\n+    private void trickyRecurse(int depth) {\n+        try {\n+            maxDepth = depth;\n+            trickyRecurse(depth + 1);\n+        } catch (StackOverflowError | OutOfMemoryError error) {\n+            \/\/\n+            \/\/ Stack problem caught: provoke it again,\n+            \/\/ if current stack is enough deep:\n+            \/\/\n+            if (depth < depthToTry - PROBES)\n+                throw error;\n+            recurse(depth + 1);\n+        }\n+    }\n+\n+    private Throwable thrown = null;\n+\n+    public void run() {\n+        String threadName = Thread.currentThread().getName();\n+        for (int i = 1; i <= CYCLES; i++)\n+            try {\n+                System.out.println(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n+                trickyRecurse(0);\n+                throw new Exception(\n+                        \"TEST_BUG: stack overflow was expected!\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack017.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack018.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     This test provokes multiple stack overflows by invocations via\n+ *     reflection -- repeatedly multiple times, and in multiple threads.\n+ *     Recursive method is invoked for the given fixed depth of recursion\n+ *     (though, for a large depth). The test measures a number of recursive\n+ *     invocations until stack overflow, and then tries to reproduce similar\n+ *     stack overflows 10 times in each of 10 threads -- each time by trying\n+ *     to invoke the same recursive method for the given fixed depth\n+ *     of invocations (which is 100 times that crucial depth just measured).\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @run main\/othervm\/timeout=900 -Xss220K Stack018\n+ *\/\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+public class Stack018 extends Thread {\n+    private final static int THREADS = 10;\n+    private final static int CYCLES = 10;\n+    private final static int STEP = 100;\n+    private final static int RESERVE = 100;\n+\n+    public static void main(String[] args) {\n+        Stack018 test = new Stack018();\n+        test.doRun();\n+    }\n+\n+    private void doRun() {\n+        \/\/\n+        \/\/ Measure maximal recursion depth until stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (depthToTry = 0; ; depthToTry += STEP) {\n+            try {\n+                invokeRecurse(depthToTry);\n+                maxDepth = depthToTry;\n+            } catch (Throwable exception) {\n+                Throwable target = getTargetException(exception);\n+                if ((target instanceof StackOverflowError) ||\n+                        (target instanceof OutOfMemoryError))\n+                    break; \/\/ OK.\n+                target.printStackTrace();\n+                throw new RuntimeException(exception);\n+            }\n+        }\n+\n+        if (maxDepth == 0) {\n+            \/\/ The depth STEP was enough to cause StackOverflowError or OutOfMemoryError.\n+            maxDepth = STEP;\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        Stack018 threads[] = new Stack018[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack018();\n+            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n+            threads[i].depthToTry = RESERVE * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        int exitCode = 0;\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                System.out.println(\"# \" + threads[i].getName()\n+                        + \": \" + threads[i].thrown);\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    private int depthToTry = 0;\n+    private Throwable thrown = null;\n+\n+    public void run() {\n+        String threadName = Thread.currentThread().getName();\n+        for (int i = 1; i <= CYCLES; i++)\n+            try {\n+                System.out.println(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n+                invokeRecurse(depthToTry);\n+                throw new Error(\"TEST_RFE: try deeper invocations!\");\n+\n+            } catch (Throwable exception) {\n+                Throwable target = getTargetException(exception);\n+                if ((target instanceof StackOverflowError) ||\n+                        (target instanceof OutOfMemoryError))\n+                    continue; \/\/ OK.\n+                thrown = target;\n+                break;\n+            }\n+    }\n+\n+    private static Throwable getTargetException(Throwable exception) {\n+        Throwable target;\n+        \/\/\n+        \/\/ Unwrap deep chain of exceptions to find StackOverflowError:\n+        \/\/\n+        for (\n+                target = exception;\n+                target instanceof InvocationTargetException;\n+                target = ((InvocationTargetException) target).getTargetException()\n+                )\n+            ;\n+        return target;\n+    }\n+\n+    private Method method = null;\n+    private Object params[] = null;\n+\n+    private void invokeRecurse(int depth) throws Exception {\n+        if (method == null) {\n+            \/\/\n+            \/\/ Optimization trick: allocate once, use everywhere.\n+            \/\/\n+            method = Stack018.class.getMethod(\"recurse\");\n+            params = new Object[]{};\n+        }\n+        this.depth = depth; \/\/ actual parameter\n+        method.invoke(this, params);\n+    }\n+\n+    private int depth = 0; \/\/ actual parameter for recurse()\n+\n+    public void recurse() throws Exception {\n+        if (depth > 0) {\n+            \/\/\n+            \/\/ Self-invoke via reflection:\n+            \/\/\n+            invokeRecurse(depth - 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack018.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack019.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test invokes infinitely recursive method from within stack\n+ *     overflow handler -- repeatedly multiple times in a single thread.\n+ *     The test is deemed passed, if VM have not crashed, and if exception\n+ *     other than due to stack overflow was not thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *     The stack size is too small to run on systems with > 4K page size.\n+ *     Making it bigger could cause timeouts on other platform.\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @requires os.family != \"windows\"\n+ * @run main\/othervm\/timeout=900 -Xss200K Stack019\n+ *\/\n+\n+public class Stack019 {\n+    private final static int CYCLES = 50;\n+    private final static int PROBES = 50;\n+\n+    public static void main(String[] args) {\n+        \/\/\n+        \/\/ Measure recursive depth before stack overflow:\n+        \/\/\n+        try {\n+            recurse(0);\n+        } catch (StackOverflowError | OutOfMemoryError err) {\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+        depthToTry = maxDepth;\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        for (int i = 0; i < CYCLES; i++) {\n+            try {\n+                System.out.println(\"Iteration: \" + i + \"\/\" + CYCLES);\n+                trickyRecurse(0);\n+                throw new RuntimeException(\"# TEST_BUG: stack overflow was expected!\");\n+            } catch (StackOverflowError | OutOfMemoryError error) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                throw new RuntimeException(throwable);\n+            }\n+        }\n+    }\n+\n+    private static int maxDepth;\n+    private static int depthToTry;\n+\n+    private static void recurse(int depth) {\n+        maxDepth = depth;\n+        recurse(depth + 1);\n+    }\n+\n+    private static void trickyRecurse(int depth) {\n+        try {\n+            maxDepth = depth;\n+            trickyRecurse(depth + 1);\n+        } catch (StackOverflowError | OutOfMemoryError error){\n+            \/\/\n+            \/\/ Stack problem caught: provoke it again,\n+            \/\/ if current stack is enough deep:\n+            \/\/\n+            if (depth < depthToTry - PROBES) {\n+                throw error;\n+            }\n+            recurse(depth + 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack019.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -57,1 +57,1 @@\n-        Terminator.java, TimeoutHandler.java\n+        TimeoutHandler.java\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/README","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,172 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.share;\n-\n-\/**\n- * Terminator is used to terminate a stress test with PASS exit status\n- * before the test is terminated as timed out (and so failed).\n- *\n- * <p>Terminator class holds a thread which sleeps for the given amount\n- * of time, and then wakes up and executes <tt>System.exit()<\/tt>\n- * with the given exit status. That thread is daemon, so it doesn't\n- * prevent application from exiting once all its threads finish\n- * before it's time for termination. Appointing terminator in zero\n- * delay implies immediate <tt>exit()<\/tt>.\n- *\n- * <p>There is a limitation: you may appoint no more than one terminator\n- * per application.\n- *\/\n-public class Terminator {\n-    \/**\n-     * Use specific <tt>appoint()<\/tt> method to appoint terminator.\n-     *\n-     * @see #appoint(int)\n-     * @see #appoint(int,int)\n-     *\/\n-    protected Terminator() {}\n-\n-    \/**\n-     * One terminator per application, or <tt>null<\/tt> (by default).\n-     *\/\n-    private static Thread terminator = null;\n-\n-    \/**\n-     * <p>Return timeout (or waittime) value munus the margin\n-     * value (which is assumed 1 minute by default).\n-     *\n-     * <p>Treat <tt>args[0]<\/tt> as <tt>$TIMEOUT<\/tt> value, or seek for\n-     * <tt>-waittime=$WAITTIME<\/tt> value. If both parameters\n-     * (or either none of them) are assigned, throw an exception to\n-     * report parameters inconsistency.\n-     *\n-     * <p>Also, seek for <tt>-margin=...<\/tt> assignment, or assume margin\n-     * is 1 minute.\n-     *\n-     * @param args Is usually obtained via the application's command-line.\n-     *\n-     * @throws IllegalArgumentException If <tt>args[]<\/tt> is inconsistent.\n-     *\n-     * @see #appoint(int)\n-     * @see #appoint(int,int)\n-     *\/\n-    public static int parseAppointment(String args[]) {\n-        int timeout=-1, margin=1;\n-        int timeouts=0, waittimes=0, margins=0;\n-        for (int i=0; i<args.length; i++) {\n-            if (args[i].startsWith(\"-\")) {\n-                if (args[i].startsWith(\"-waittime=\")) {\n-                    timeout = Integer.parseInt(args[i].substring(10));\n-                    waittimes++;\n-                }\n-                if (args[i].startsWith(\"-margin=\")) {\n-                    margin = Integer.parseInt(args[i].substring(8));\n-                    margins++;\n-                }\n-            } else {\n-                if (i == 0) {\n-                    timeout = Integer.parseInt(args[i]);\n-                    timeouts++;\n-                }\n-            }\n-        };\n-        if (timeouts==0 && waittimes==0)\n-            throw new IllegalArgumentException(\n-                \"no $TIMEOUT, nor -waittime=$WAITTIME is set\");\n-        if (waittimes > 1)\n-            throw new IllegalArgumentException(\n-                \"more than one -waittime=... is set\");\n-        if (margins > 1)\n-            throw new IllegalArgumentException(\n-                \"more than one -margin=... is set\");\n-\n-        int result = timeout - margin;\n-        if (result <= 0)\n-            throw new IllegalArgumentException(\n-                \"delay appointment must be greater than \"+margin+\" minutes\");\n-        return result;\n-    }\n-\n-    \/**\n-     * Appoint terminator after the given amount of <tt>minutes<\/tt>,\n-     * so that exit status would be 95 (to simulate JCK-like PASS\n-     * status).\n-     *\n-     * @throws IllegalStateException If terminator is already appointed.\n-     *\n-     * @see #appoint(int,int)\n-     * @see #parseAppointment(String[])\n-     *\/\n-    public static void appoint(int minutes) {\n-        appoint(minutes,95); \/\/ JCK-like PASS status\n-    }\n-\n-    \/**\n-     * Appoint Terminator for the given amount of <tt>minutes<\/tt>,\n-     * so that the given <tt>status<\/tt> would be exited when time\n-     * is over.\n-     *\n-     * @throws IllegalStateException If terminator is already appointed.\n-     *\n-     * @see #appoint(int)\n-     * @see #parseAppointment(String[])\n-     *\/\n-    public static void appoint(int minutes, int status) {\n-        if (terminator != null)\n-            throw new IllegalStateException(\"Terminator is already appointed.\");\n-\n-        final long timeToExit = System.currentTimeMillis() + 60*1000L*minutes;\n-        final int  exitStatus = status;\n-\n-        terminator = new Thread(Terminator.class.getName()) {\n-            public void run() {\n-                long timeToSleep = timeToExit - System.currentTimeMillis();\n-                if (timeToSleep > 0)\n-                    try {\n-                        \/\/\n-                        \/\/ Use wait() instead of sleep(), because Java 2\n-                        \/\/ specification doesn't guarantee the method\n-                        \/\/ sleep() to yield to other threads.\n-                        \/\/\n-                        Object someDummyObject = new Object();\n-                        synchronized (someDummyObject) {\n-                            someDummyObject.wait(timeToSleep);\n-                        }\n-                    } catch (InterruptedException exception) {\n-                        exception.printStackTrace(System.err);\n-                        return;\n-                    };\n-                \/\/\n-                \/\/ OK, lets do it now:\n-                \/\/\n-                System.err.println(\n-                    \"#\\n# Terminator: prescheduled program termination.\\n#\");\n-                System.exit(exitStatus); \/\/ terminator to all threads\n-            }\n-        };\n-\n-        terminator.setPriority(Thread.MAX_PRIORITY);\n-        terminator.setDaemon(true);\n-        terminator.start();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/Terminator.java","additions":0,"deletions":172,"binary":false,"changes":172,"status":"deleted"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack001.\n- * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     Provoke StackOverflowError by infinite recursion in Java method,\n- *     intercept the exception try to make one more invocation.\n- * COMMENTS\n- *     Kestrel for Solaris_JDK_1.3-b10 crashes while trying to execute\n- *     this test with Client HS VM.\n- *     See lots of bugs concerning similar failures:\n- *     Evaluated:\n- *     4217960 [native stack overflow bug] reflection test causes crash\n- *     Accepted:\n- *     4285716 native stack overflow causes crash on Solaris\n- *     4281578 Second stack overflow crashes HotSpot VM\n- *     Closed (duplicate):\n- *     4027933     Native stack overflows not detected or handled correctly\n- *     4134353     (hpi) sysThreadCheckStack is a no-op on win32\n- *     4185411     Various crashes when using recursive reflection.\n- *     4167055     infinite recursion in FindClass\n- *     4222359     Infinite recursion crashes jvm\n- *     Closed (will not fix):\n- *     4231968 StackOverflowError in a native method causes Segmentation Fault\n- *     4254634     println() while catching StackOverflowError causes hotspot VM crash\n- *     4302288 the second stack overflow causes Classic VM to exit on win32\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack001\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack001 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack001 test = new stack001();\n-        test.recurse(0);\n-        out.println(\"Maximal depth: \" + test.maxdepth);\n-        return 0;\n-    }\n-\n-    private int maxdepth;\n-\n-    private void recurse(int depth) {\n-        maxdepth = depth;\n-        try {\n-            recurse(depth + 1);\n-        } catch (Error error) {\n-            if (!(error instanceof StackOverflowError) &&\n-                    !(error instanceof OutOfMemoryError))\n-                throw error;\n-\n-            if (maxdepth == depth)\n-                recurse(depth + 1);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack001.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack002.\n- * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     Provoke StackOverflowError by infinite recursion in Java method,\n- *     intercept the exception and continue to invoke that method until\n- *     the test exceeds timeout, or until Java VM crashes.\n- * COMMENTS\n- *     I believe that the test causes HS crashes due to the following bug:\n- *     4330318 (P2\/S2) NSK test fails as An irrecoverable stack overflow\n- *     See also bugs (lots of bugs!):\n- *     Evaluated:\n- *     4217960 [native stack overflow bug] reflection test causes crash\n- *     Accepted:\n- *     4285716 native stack overflow causes crash on Solaris\n- *     4281578 Second stack overflow crashes HotSpot VM\n- *     Closed (duplicate):\n- *     4027933     Native stack overflows not detected or handled correctly\n- *     4134353     (hpi) sysThreadCheckStack is a no-op on win32\n- *     4185411     Various crashes when using recursive reflection.\n- *     4167055     infinite recursion in FindClass\n- *     4222359     Infinite recursion crashes jvm\n- *     Closed (will not fix):\n- *     4231968 StackOverflowError in a native method causes Segmentation Fault\n- *     4254634     println() while catching StackOverflowError causes hotspot VM crash\n- *     4302288 the second stack overflow causes Classic VM to exit on win32\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack002\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack002 {\n-    static final long timeout = 10000; \/\/ 10 seconds\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        Tester tester = new Tester(out);\n-        Timer timer = new Timer(tester);\n-        timer.start();\n-        tester.start();\n-        while (timer.isAlive()) {\n-            try {\n-                timer.join();\n-            } catch (InterruptedException e) {\n-                e.printStackTrace(out);\n-                return 2;\n-            }\n-        }\n-        out.println(\"Maximal depth: \" + tester.maxdepth);\n-        return 0;\n-    }\n-\n-    private static class Tester extends Thread {\n-        int maxdepth;\n-        PrintStream out;\n-        public volatile boolean stop;\n-\n-        public Tester(PrintStream out) {\n-            this.out = out;\n-            maxdepth = 0;\n-            stop = false;\n-        }\n-\n-        public void run() {\n-            recurse(0);\n-        }\n-\n-        void recurse(int depth) {\n-            maxdepth = depth;\n-            try {\n-                if (stop) {\n-                    return;\n-                }\n-                recurse(depth + 1);\n-            } catch (Error error) {\n-                if (!(error instanceof StackOverflowError) &&\n-                        !(error instanceof OutOfMemoryError))\n-                    throw error;\n-                recurse(depth + 1);\n-            }\n-        }\n-    }\n-\n-    private static class Timer extends Thread {\n-        private Tester tester;\n-\n-        public Timer(Tester tester) {\n-            this.tester = tester;\n-        }\n-\n-        public void run() {\n-            long started;\n-            started = System.currentTimeMillis();\n-            while (System.currentTimeMillis() - started < timeout) {\n-                try {\n-                    this.sleep(1000);\n-                } catch (InterruptedException e) {\n-                    e.printStackTrace(tester.out);\n-                    return;\n-                };\n-            }\n-            tester.stop = true;\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack002.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack003.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking static recursive method for the given fixed depth\n- *     of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n- *     platforms (Win32, Solaris, Linux) in all execution modes\n- *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n- *     I had tryied it.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack003\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack003 {\n-    final static int ITERATIONS = 100;\n-    final static int INCREMENT = 100;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        int depth;\n-        for (depth = 1; ; depth += INCREMENT)\n-            try {\n-                recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < ITERATIONS; i++)\n-            try {\n-                recurse(2 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack003.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack004.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking final static recursive method for the given fixed\n- *     depth of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n- *     platforms (Win32, Solaris, Linux) in all execution modes\n- *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n- *     I had tryied it.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack004\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack004 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack004 test = new stack004();\n-        int exitCode = test.doRun(args, out);\n-        return exitCode;\n-    }\n-\n-    public int doRun(String args[], PrintStream out) {\n-        int depth;\n-        for (depth = 100; ; depth += 100)\n-            try {\n-                recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < 100; i++)\n-            try {\n-                recurse(2 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    final static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack004.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack005.\n- * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking final recursive method for the given fixed depth of\n- *     recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n- *     platforms (Win32, Solaris, Linux) in all execution modes\n- *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n- *     I had tryied it.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack005\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack005 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack005 test = new stack005();\n-        int depth;\n-        for (depth = 100; ; depth += 100)\n-            try {\n-                test.recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < 100; i++)\n-            try {\n-                test.recurse(2 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    final void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack005.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack006.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking virtual recursive method for the given fixed depth\n- *     of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on all\n- *     platforms (Win32, Solaris, Linux) in all execution modes\n- *     (-Xint, -Xmixed, -Xcomp) in 100% of executions in which\n- *     I had tryied it.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack006\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack006 implements stack006i {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack006i test = new stack006();\n-        int depth;\n-        for (depth = 100; ; depth += 100)\n-            try {\n-                test.recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < 100; i++)\n-            try {\n-                test.recurse(2 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    public void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n-\n-interface stack006i {\n-    void recurse(int depth);\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack006.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack007.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invoking synchronized virtual recursive method for the given\n- *     fixed depth of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 10000 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is 10 times that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes HS versions 1.3 and 1.4 on Win32, Solaris,\n- *     and Linux platforms in all execution modes. However, it passes\n- *     against HS 2.0 on Win32 platform.\n- *     See also the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack007\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack007 implements stack007i {\n-    final static int ITERATIONS = 1000;\n-    final static int INCREMENT = 100;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack007i test = new stack007();\n-        int depth;\n-        for (depth = 100; ; depth += INCREMENT)\n-            try {\n-                test.recurse(depth);\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        for (int i = 0; i < ITERATIONS; i++)\n-            try {\n-                test.recurse(10 * depth);\n-                out.println(\"?\");\n-            } catch (StackOverflowError soe) {\n-                \/\/ OK.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK.\n-            }\n-        return 0;\n-    }\n-\n-    public synchronized void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n-\n-interface stack007i {\n-    void recurse(int depth);\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack007.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,149 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack008.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the same thread\n- *     by invocations via reflection. Recursive method is invoked for\n- *     the given fixed depth of recursion (though, for a large depth).\n- *     This test makes measures a number of recursive invocations\n- *     before 1st StackOverflowError, and then tries to reproduce\n- *     such StackOverflowError 100 times -- each time by trying to\n- *     invoke the same recursive method for the given fixed depth\n- *     of invocations (which is twice that depth just measured).\n- *     The test is deemed passed, if VM have not crashed.\n- * COMMENTS\n- *     This test crashes all HS versions (2.0, 1.3, 1.4) on Solaris,\n- *     and crashes HS 2.0 on win32. However, it passes against HS 1.3\n- *     and 1.4 on Win32.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *     The stack size is too small to run on systems with > 4K page size.\n- *     Making it bigger could cause timeouts on other platform.\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @run main\/othervm\/timeout=900 -Xss200K nsk.stress.stack.stack008\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-\n-public class stack008 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        int depth;\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        for (depth = 100; ; depth += 100)\n-            try {\n-                invokeRecurse(depth);\n-            } catch (Throwable exception) {\n-                Throwable target = getTargetException(exception);\n-                if ((target instanceof StackOverflowError) ||\n-                        (target instanceof OutOfMemoryError))\n-                    break; \/\/ OK.\n-                target.printStackTrace(out);\n-                if (target instanceof ThreadDeath)\n-                    throw (ThreadDeath) target;\n-                return 2;\n-            }\n-        out.println(\"Max. depth: \" + depth);\n-        \/\/\n-        \/\/ Provoke stack overflow multiple times:\n-        \/\/\n-        for (int i = 0; i < 100; i++)\n-            try {\n-                invokeRecurse(2 * depth);\n-\/\/              out.println(\"?\");\n-            } catch (Throwable exception) {\n-                Throwable target = getTargetException(exception);\n-                if ((target instanceof StackOverflowError) ||\n-                        (target instanceof OutOfMemoryError))\n-                    continue; \/\/ OK.\n-                target.printStackTrace(out);\n-                if (target instanceof ThreadDeath)\n-                    throw (ThreadDeath) target;\n-                return 2;\n-            }\n-        return 0;\n-    }\n-\n-    private static Throwable getTargetException(Throwable exception) {\n-        Throwable target;\n-        \/\/\n-        \/\/ Unwrap deep chain of exceptions:\n-        \/\/\n-        for (\n-                target = exception;\n-                target instanceof InvocationTargetException;\n-                target = ((InvocationTargetException) target).getTargetException()\n-                )\n-            ;\n-        return target;\n-    }\n-\n-    static Method method = null;\n-    static stack008 instance = null;\n-    static Object params[] = null;\n-\n-    private static void invokeRecurse(int depth) throws Exception {\n-        if (method == null) {\n-            \/\/\n-            \/\/ Optimization trick: allocate once, use everywhere.\n-            \/\/\n-            instance = new stack008();\n-            method = stack008.class.getMethod(\"recurse\");\n-            params = new Object[]{};\n-        }\n-        \/\/\n-        \/\/ Note, that the same instance.depth is used in all invocations:\n-        \/\/\n-        instance.depth = depth;\n-        method.invoke(instance, params);\n-    }\n-\n-    int depth = 0;\n-\n-    public void recurse() throws Exception {\n-        if (depth > 0)\n-            \/\/\n-            \/\/ Self-invoke via reflection:\n-            \/\/\n-            invokeRecurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack008.java","additions":0,"deletions":149,"binary":false,"changes":149,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack009.\n- * VM testbase keywords: [stress, quick, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test provokes second stack overflow from within the\n- *     stack overflow handler.\n- *     This test measures a number of recursive invocations until\n- *     StackOverflowError, and then tries to make an invocation\n- *     for the fixed invocations depth from within the \"catch\"\n- *     block just caught the 1st stack overflow. The depth of new\n- *     invocations is 10 times that depth seen at the 1st stack\n- *     overflow; so that another stack overflow occurs.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if there is no exception thrown other than due to stack\n- *     overflow.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on Win32\n- *     and Solaris platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack009\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack009 {\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        for (int depth = 100; ; depth += 100)\n-            try {\n-                recurse(depth);\n-            } catch (Error error1) {\n-                if (!(error1 instanceof StackOverflowError) &&\n-                        !(error1 instanceof OutOfMemoryError))\n-                    throw error1;\n-\n-                out.println(\"Max. depth: \" + depth);\n-\n-                try {\n-                    recurse(10 * depth);\n-                    out.println(\"?\");\n-                } catch (Error error2) {\n-                    if (!(error2 instanceof StackOverflowError) &&\n-                            !(error2 instanceof OutOfMemoryError))\n-                        throw error2;\n-\n-                    \/\/ Stack overflow is OK here.\n-                }\n-\n-                break;\n-            }\n-        return 0;\n-    }\n-\n-    static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack009.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack010.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking static recursive method for the given\n- *     fixed depth of recursion (though, for a large depth).\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, 1.4 on Win32 and Solaris\n- *     platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack010\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack010 extends Thread {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack010 threads[] = new stack010[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack010();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were not thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    int depthToTry = 0;\n-    Throwable thrown = null;\n-\n-    public void run() {\n-        for (int i = 0; i < CYCLES; i++)\n-            try {\n-                recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError soe) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: out of memory may indacate stack overflow.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-\n-    static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack010.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack011.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking final static recursive method for the\n- *     given fixed depth of recursion (though, for a large depth).\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, 1.4 on Win32 and Solaris\n- *     platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack011\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack011 extends Thread {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack011 threads[] = new stack011[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack011();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were not thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    int depthToTry = 0;\n-    Throwable thrown = null;\n-\n-    public void run() {\n-        for (int i = 0; i < CYCLES; i++)\n-            try {\n-                recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: recursion may result in memory lack.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-\n-    final static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack011.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack012.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking final recursive method for the given\n- *     fixed depth of recursion (though, for a large depth).\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 1.3, 1.4 on Win32, and HS versions\n- *     2.0, 1.3, and 1.4 on Solaris. However, it passes against HS 2.0\n- *     on Win32.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack012\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack012 extends Thread {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack012 test = new stack012();\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                test.recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack012 threads[] = new stack012[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack012();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were not thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    int depthToTry = 0;\n-    Throwable thrown = null;\n-\n-    public void run() {\n-        for (int i = 0; i < CYCLES; i++)\n-            try {\n-                this.recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: invocation may result in out of memory.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-\n-    final void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack012.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack013.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking virtual recursive method for the given\n- *     fixed depth of recursion (though, for a large depth).\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both Win32\n- *     and Solaris platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack013\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack013 extends stack013i {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack013i test = new stack013();\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                test.recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack013i threads[] = new stack013i[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack013();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].cycles = CYCLES;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n-\n-abstract class stack013i extends Thread {\n-    \/\/\n-    \/\/ Pure virtual method:\n-    \/\/\n-    abstract void recurse(int depth);\n-\n-    Throwable thrown = null;\n-    int depthToTry;\n-    int cycles;\n-\n-    public void run() {\n-        \/\/\n-        \/\/ Provoke multiple stack overflows:\n-        \/\/\n-        for (int i = 0; i < cycles; i++)\n-            try {\n-                recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: out of memory is eligible here.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack013.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack014.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking synchronized virtual recursive method\n- *     for the given fixed depth of recursion (though, for a large\n- *     depth). Note however, that different threads are not actual\n- *     synchronized, because different instances having the recursive\n- *     method are used.\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on Solaris.\n- *     However, it passes against all these HS versions on Win32.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack014\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack014 extends stack014i {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        stack014i test = new stack014();\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 10; ; depth += 10)\n-            try {\n-                test.recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack014i threads[] = new stack014i[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack014();\n-            threads[i].depthToTry = 10 * maxDepth;\n-            threads[i].cycles = CYCLES;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    synchronized void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-}\n-\n-abstract class stack014i extends Thread {\n-    \/\/\n-    \/\/ Pure virtual method:\n-    \/\/\n-    abstract void recurse(int depth);\n-\n-    Throwable thrown = null;\n-    int depthToTry;\n-    int cycles;\n-\n-    public void run() {\n-        \/\/\n-        \/\/ Provoke multiple stack overflows:\n-        \/\/\n-        for (int i = 0; i < cycles; i++)\n-            try {\n-                recurse(depthToTry);\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: if there is no memory for stack expansion.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack014.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -1,183 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack015.\n- * VM testbase keywords: [stress, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows in the multiple\n- *     threads -- by invoking synchronized virtual recursive method\n- *     for the given fixed depth of recursion from within another\n- *     recursive method already deeply invoked.\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     in 10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on Solaris.\n- *     However, it passes against all these HS versions on Win32.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires vm.opt.DeoptimizeALot != true\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack015\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import java.io.PrintStream;\n-\n-public class stack015 extends stack015i {\n-    final static int THREADS = 10;\n-    final static int CYCLES = 10;\n-    final static int STEP = 10;\n-    final static int RESERVE = 10;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        \/\/\n-        \/\/ The test will invoke the particular stack015.recurse()\n-        \/\/ method via abstract test.recurse() invocations.\n-        \/\/\n-        stack015i test = new stack015();\n-        stack015i.test = test;\n-\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (int depth = 0; ; depth += STEP)\n-            try {\n-                test.recurse(depth);\n-                maxDepth = depth;\n-            } catch (StackOverflowError soe) {\n-                break;\n-            } catch (OutOfMemoryError oome) {\n-                break;\n-            }\n-        out.println(\"Max. depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Execute multiple threads repeatedly provoking stack overflows:\n-        \/\/\n-        stack015i threads[] = new stack015i[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack015();\n-            threads[i].depthToTry = RESERVE * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    synchronized void syncRecurse(int depth) {\n-        if (depth > 0)\n-            syncRecurse(depth - 1);\n-    }\n-}\n-\n-abstract class stack015i extends Thread {\n-    \/\/\n-    \/\/ Pure virtual method:\n-    \/\/\n-    abstract void syncRecurse(int depth);\n-\n-    void recurse(int depth) {\n-        \/\/\n-        \/\/ Stack overflow must occur here:\n-        \/\/\n-        syncRecurse(stack015.STEP);\n-        \/\/\n-        \/\/ If no stack overflow occured, try again with deeper stack:\n-        \/\/\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-\n-    Throwable thrown = null;\n-    int depthToTry;\n-\n-    static stack015i test;\n-\n-    public void run() {\n-        \/\/\n-        \/\/ Provoke multiple stack overflows:\n-        \/\/\n-        for (int i = 0; i < stack015.CYCLES; i++)\n-            try {\n-                \/\/\n-                \/\/ All threads invoke the same synchronized method:\n-                \/\/\n-                test.recurse(depthToTry);\n-\n-                throw new Exception(\n-                        \"TEST_RFE: no stack overflow thrown\" +\n-                                \", need to try deeper recursion?\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK: there may be no memory for stack expansion.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack015.java","additions":0,"deletions":183,"binary":false,"changes":183,"status":"deleted"},{"patch":"@@ -1,210 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack016.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test provokes second stack overflow from within the\n- *     stack overflow handler -- repeatedly multiple times, and\n- *     in multiple threads.\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     in 10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before,\n- *     and then trying to invoke that recursive method once again\n- *     from within the catch clause just caught StackOverflowError.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\")\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xint -Xss448K nsk.stress.stack.stack016 -eager\n- * @run main\/othervm\/timeout=900 -Xcomp -Xss448K nsk.stress.stack.stack016 -eager\n- * @run main\/othervm\/timeout=900 -Xcomp -XX:-TieredCompilation -Xss448K nsk.stress.stack.stack016 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-import java.io.PrintStream;\n-\n-public class stack016 extends Thread {\n-    private final static int THREADS = 10;\n-    private final static int CYCLES = 10;\n-    private final static int STEP = 10;\n-    private final static int RESERVE = 10;\n-    private final static int PROBES = STEP * RESERVE;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        verbose = false;\n-        boolean eager = false;\n-        for (int i = 0; i < args.length; i++)\n-            if (args[i].toLowerCase().equals(\"-verbose\"))\n-                verbose = true;\n-            else if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        if (!eager)\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        stack016.out = out;\n-        stack016 test = new stack016();\n-        return test.doRun();\n-    }\n-\n-    private static boolean verbose;\n-    private static PrintStream out;\n-\n-    private void display(Object message) {\n-        if (!verbose)\n-            return;\n-        synchronized (out) {\n-            out.println(message.toString());\n-        }\n-    }\n-\n-    private int doRun() {\n-        \/\/\n-        \/\/ Measure recursive depth before stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (depthToTry = 0; ; depthToTry += STEP) {\n-            try {\n-                trickyRecurse(depthToTry);\n-                maxDepth = depthToTry;\n-            } catch (StackOverflowError | OutOfMemoryError ex) {\n-                break;\n-            }\n-        }\n-        out.println(\"Maximal recursion depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        stack016 threads[] = new stack016[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack016();\n-            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n-            threads[i].depthToTry = RESERVE * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++) {\n-            if (threads[i].isAlive()) {\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-            }\n-        }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++) {\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-        }\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    private int stackTop = 0;\n-    private int depthToTry = 0;\n-    private Throwable thrown = null;\n-\n-    private void trickyRecurse(int depth) {\n-        stackTop = depthToTry - depth;\n-        if (depth > 0) {\n-            try {\n-                trickyRecurse(depth - 1);\n-            } catch (Error error) {\n-                if (!(error instanceof StackOverflowError) &&\n-                        !(error instanceof OutOfMemoryError))\n-                    throw error;\n-\n-                \/\/\n-                \/\/ Provoke more stack overflow,\n-                \/\/ if current stack is deep enough:\n-                \/\/\n-                if (depthToTry - depth < stackTop - PROBES)\n-                    throw error;\n-                recurse(depthToTry);\n-\n-                throw new Error(\"TEST_RFE: try deeper recursion!\");\n-            }\n-        }\n-    }\n-\n-    private static void recurse(int depth) {\n-        if (depth > 0)\n-            recurse(depth - 1);\n-    }\n-\n-    public void run() {\n-        String threadName = Thread.currentThread().getName();\n-        for (int i = 1; i <= CYCLES; i++) {\n-            try {\n-                display(threadName + \", iteration: \" + i + \"\/\" + CYCLES +\n-                        \", depthToTry: \" + depthToTry);\n-                trickyRecurse(depthToTry);\n-                throw new Error(\n-                        \"TEST_BUG: trickyRecursion() must throw an error anyway!\");\n-\n-            } catch (StackOverflowError error) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK, if there is no memory for stack expansion.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                thrown = throwable;\n-                break;\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack016.java","additions":0,"deletions":210,"binary":false,"changes":210,"status":"deleted"},{"patch":"@@ -1,190 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack017.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test invokes infinitely recursive method from within stack\n- *     overflow handler  -- repeatedly multiple times, and in multiple\n- *     threads.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xss220K nsk.stress.stack.stack017 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-import java.io.PrintStream;\n-\n-public class stack017 extends Thread {\n-    private final static int THREADS = 10;\n-    private final static int CYCLES = 10;\n-    private final static int PROBES = 100;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        verbose = false;\n-        boolean eager = false;\n-        for (int i = 0; i < args.length; i++)\n-            if (args[i].toLowerCase().equals(\"-verbose\"))\n-                verbose = true;\n-            else if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        if (!eager)\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        stack017.out = out;\n-        stack017 test = new stack017();\n-        return test.doRun();\n-    }\n-\n-    private static boolean verbose;\n-    private static PrintStream out;\n-\n-    private void display(Object message) {\n-        if (!verbose)\n-            return;\n-        synchronized (out) {\n-            out.println(message.toString());\n-        }\n-    }\n-\n-    private static int depthToTry;\n-\n-    private int doRun() {\n-        \/\/\n-        \/\/ Measure recursive depth before stack overflow:\n-        \/\/\n-        try {\n-            recurse(0);\n-        } catch (StackOverflowError soe) {\n-        } catch (OutOfMemoryError oome) {\n-        }\n-        out.println(\"Maximal recursion depth: \" + maxDepth);\n-        depthToTry = maxDepth;\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        stack017 threads[] = new stack017[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack017();\n-            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    private int maxDepth = 0;\n-\n-    private void recurse(int depth) {\n-        maxDepth = depth;\n-        recurse(depth + 1);\n-    }\n-\n-    private void trickyRecurse(int depth) {\n-        try {\n-            maxDepth = depth;\n-            trickyRecurse(depth + 1);\n-        } catch (Error error) {\n-            if (!(error instanceof StackOverflowError) &&\n-                    !(error instanceof OutOfMemoryError))\n-                throw error;\n-\n-            \/\/\n-            \/\/ Stack problem caught: provoke it again,\n-            \/\/ if current stack is enough deep:\n-            \/\/\n-            if (depth < depthToTry - PROBES)\n-                throw error;\n-            recurse(depth + 1);\n-        }\n-    }\n-\n-    private Throwable thrown = null;\n-\n-    public void run() {\n-        String threadName = Thread.currentThread().getName();\n-        for (int i = 1; i <= CYCLES; i++)\n-            try {\n-                display(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n-                trickyRecurse(0);\n-                throw new Exception(\n-                        \"TEST_BUG: stack overflow was expected!\");\n-\n-            } catch (StackOverflowError oome) {\n-                \/\/ It's OK: stack overflow was expected.\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ Also OK, if there is no memory for stack expansion.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack017.java","additions":0,"deletions":190,"binary":false,"changes":190,"status":"deleted"},{"patch":"@@ -1,224 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack018.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test provokes multiple stack overflows by invocations via\n- *     reflection -- repeatedly multiple times, and in multiple threads.\n- *     Recursive method is invoked for the given fixed depth of recursion\n- *     (though, for a large depth). The test measures a number of recursive\n- *     invocations until stack overflow, and then tries to reproduce similar\n- *     stack overflows 10 times in each of 10 threads -- each time by trying\n- *     to invoke the same recursive method for the given fixed depth\n- *     of invocations (which is 100 times that crucial depth just measured).\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xss220K nsk.stress.stack.stack018 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-import java.io.PrintStream;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-\n-public class stack018 extends Thread {\n-    private final static int THREADS = 10;\n-    private final static int CYCLES = 10;\n-    private final static int STEP = 100;\n-    private final static int RESERVE = 100;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        verbose = false;\n-        boolean eager = false;\n-        for (int i = 0; i < args.length; i++)\n-            if (args[i].toLowerCase().equals(\"-verbose\"))\n-                verbose = true;\n-            else if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        if (!eager)\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        stack018.out = out;\n-        stack018 test = new stack018();\n-        return test.doRun();\n-    }\n-\n-    private static boolean verbose;\n-    private static PrintStream out;\n-\n-    private void display(Object message) {\n-        if (!verbose)\n-            return;\n-        synchronized (out) {\n-            out.println(message.toString());\n-        }\n-    }\n-\n-    private int doRun() {\n-        \/\/\n-        \/\/ Measure maximal recursion depth until stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (depthToTry = 0; ; depthToTry += STEP) {\n-            try {\n-                invokeRecurse(depthToTry);\n-                maxDepth = depthToTry;\n-            } catch (Throwable exception) {\n-                Throwable target = getTargetException(exception);\n-                if ((target instanceof StackOverflowError) ||\n-                        (target instanceof OutOfMemoryError))\n-                    break; \/\/ OK.\n-                target.printStackTrace(out);\n-                if (target instanceof ThreadDeath)\n-                    throw (ThreadDeath) target;\n-                return 2;\n-            }\n-        }\n-\n-        if (maxDepth == 0) {\n-            \/\/ The depth STEP was enough to cause StackOverflowError or OutOfMemoryError.\n-            maxDepth = STEP;\n-        }\n-        out.println(\"Maximal recursion depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        stack018 threads[] = new stack018[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack018();\n-            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n-            threads[i].depthToTry = RESERVE * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].isAlive())\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    exception.printStackTrace(out);\n-                    return 2;\n-                }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        int exitCode = 0;\n-        for (int i = 0; i < threads.length; i++)\n-            if (threads[i].thrown != null) {\n-                out.println(\"# \" + threads[i].getName()\n-                        + \": \" + threads[i].thrown);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0)\n-            out.println(\"# TEST FAILED\");\n-        return exitCode;\n-    }\n-\n-    private int depthToTry = 0;\n-    private Throwable thrown = null;\n-\n-    public void run() {\n-        String threadName = Thread.currentThread().getName();\n-        for (int i = 1; i <= CYCLES; i++)\n-            try {\n-                display(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n-                invokeRecurse(depthToTry);\n-                throw new Error(\"TEST_RFE: try deeper invocations!\");\n-\n-            } catch (Throwable exception) {\n-                Throwable target = getTargetException(exception);\n-                if ((target instanceof StackOverflowError) ||\n-                        (target instanceof OutOfMemoryError))\n-                    continue; \/\/ OK.\n-                if (target instanceof ThreadDeath)\n-                    throw (ThreadDeath) target;\n-                thrown = target;\n-                break;\n-            }\n-    }\n-\n-    private static Throwable getTargetException(Throwable exception) {\n-        Throwable target;\n-        \/\/\n-        \/\/ Unwrap deep chain of exceptions to find StackOverflowError:\n-        \/\/\n-        for (\n-                target = exception;\n-                target instanceof InvocationTargetException;\n-                target = ((InvocationTargetException) target).getTargetException()\n-                )\n-            ;\n-        return target;\n-    }\n-\n-    private Method method = null;\n-    private Object params[] = null;\n-\n-    private void invokeRecurse(int depth) throws Exception {\n-        if (method == null) {\n-            \/\/\n-            \/\/ Optimization trick: allocate once, use everywhere.\n-            \/\/\n-            method = stack018.class.getMethod(\"recurse\");\n-            params = new Object[]{};\n-        }\n-        this.depth = depth; \/\/ actual parameter\n-        method.invoke(this, params);\n-    }\n-\n-    private int depth = 0; \/\/ actual parameter for recurse()\n-\n-    public void recurse() throws Exception {\n-        if (depth > 0)\n-            \/\/\n-            \/\/ Self-invoke via reflection:\n-            \/\/\n-            invokeRecurse(depth - 1);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack018.java","additions":0,"deletions":224,"binary":false,"changes":224,"status":"deleted"},{"patch":"@@ -1,137 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack019.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test invokes infinitely recursive method from within stack\n- *     overflow handler -- repeatedly multiple times in a single thread.\n- *     The test is deemed passed, if VM have not crashed, and if exception\n- *     other than due to stack overflow was not thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *     The stack size is too small to run on systems with > 4K page size.\n- *     Making it bigger could cause timeouts on other platform.\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @requires os.family != \"windows\"\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xss200K nsk.stress.stack.stack019 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-import java.io.PrintStream;\n-\n-public class stack019 {\n-    private final static int CYCLES = 50;\n-    private final static int PROBES = 50;\n-\n-    public static void main(String[] args) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-    }\n-\n-    public static int run(String args[], PrintStream out) {\n-        boolean verbose = false, eager = false;\n-        for (int i = 0; i < args.length; i++)\n-            if (args[i].toLowerCase().equals(\"-verbose\"))\n-                verbose = true;\n-            else if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        if (!eager)\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        \/\/\n-        \/\/ Measure recursive depth before stack overflow:\n-        \/\/\n-        try {\n-            recurse(0);\n-        } catch (StackOverflowError soe) {\n-        } catch (OutOfMemoryError oome) {\n-        }\n-        out.println(\"Maximal recursion depth: \" + maxDepth);\n-        depthToTry = maxDepth;\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        for (int i = 0; i < CYCLES; i++) {\n-            try {\n-                out.println(\"Iteration: \" + i + \"\/\" + CYCLES);\n-                trickyRecurse(0);\n-                out.println(\"# TEST_BUG: stack overflow was expected!\");\n-                return 2;\n-\n-            } catch (StackOverflowError error) {\n-            } catch (OutOfMemoryError oome) {\n-                \/\/ It's OK: stack overflow was expected.\n-\n-            } catch (Throwable throwable) {\n-                if (throwable instanceof ThreadDeath)\n-                    throw (ThreadDeath) throwable;\n-                throwable.printStackTrace(out);\n-                return 2;\n-            }\n-        }\n-        return 0;\n-    }\n-\n-    private static int maxDepth;\n-    private static int depthToTry;\n-\n-    private static void recurse(int depth) {\n-        maxDepth = depth;\n-        recurse(depth + 1);\n-    }\n-\n-    private static void trickyRecurse(int depth) {\n-        try {\n-            maxDepth = depth;\n-            trickyRecurse(depth + 1);\n-        } catch (Error error) {\n-            if (!(error instanceof StackOverflowError) &&\n-                    !(error instanceof OutOfMemoryError))\n-                throw error;\n-\n-            \/\/\n-            \/\/ Stack problem caught: provoke it again,\n-            \/\/ if current stack is enough deep:\n-            \/\/\n-            if (depth < depthToTry - PROBES)\n-                throw error;\n-            recurse(depth + 1);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack019.java","additions":0,"deletions":137,"binary":false,"changes":137,"status":"deleted"}]}