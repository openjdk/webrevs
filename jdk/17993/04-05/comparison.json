{"files":[{"patch":"@@ -57,1 +57,1 @@\n-        Terminator.java, TimeoutHandler.java\n+        TimeoutHandler.java\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/README","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,172 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.share;\n-\n-\/**\n- * Terminator is used to terminate a stress test with PASS exit status\n- * before the test is terminated as timed out (and so failed).\n- *\n- * <p>Terminator class holds a thread which sleeps for the given amount\n- * of time, and then wakes up and executes <tt>System.exit()<\/tt>\n- * with the given exit status. That thread is daemon, so it doesn't\n- * prevent application from exiting once all its threads finish\n- * before it's time for termination. Appointing terminator in zero\n- * delay implies immediate <tt>exit()<\/tt>.\n- *\n- * <p>There is a limitation: you may appoint no more than one terminator\n- * per application.\n- *\/\n-public class Terminator {\n-    \/**\n-     * Use specific <tt>appoint()<\/tt> method to appoint terminator.\n-     *\n-     * @see #appoint(int)\n-     * @see #appoint(int,int)\n-     *\/\n-    protected Terminator() {}\n-\n-    \/**\n-     * One terminator per application, or <tt>null<\/tt> (by default).\n-     *\/\n-    private static Thread terminator = null;\n-\n-    \/**\n-     * <p>Return timeout (or waittime) value munus the margin\n-     * value (which is assumed 1 minute by default).\n-     *\n-     * <p>Treat <tt>args[0]<\/tt> as <tt>$TIMEOUT<\/tt> value, or seek for\n-     * <tt>-waittime=$WAITTIME<\/tt> value. If both parameters\n-     * (or either none of them) are assigned, throw an exception to\n-     * report parameters inconsistency.\n-     *\n-     * <p>Also, seek for <tt>-margin=...<\/tt> assignment, or assume margin\n-     * is 1 minute.\n-     *\n-     * @param args Is usually obtained via the application's command-line.\n-     *\n-     * @throws IllegalArgumentException If <tt>args[]<\/tt> is inconsistent.\n-     *\n-     * @see #appoint(int)\n-     * @see #appoint(int,int)\n-     *\/\n-    public static int parseAppointment(String args[]) {\n-        int timeout=-1, margin=1;\n-        int timeouts=0, waittimes=0, margins=0;\n-        for (int i=0; i<args.length; i++) {\n-            if (args[i].startsWith(\"-\")) {\n-                if (args[i].startsWith(\"-waittime=\")) {\n-                    timeout = Integer.parseInt(args[i].substring(10));\n-                    waittimes++;\n-                }\n-                if (args[i].startsWith(\"-margin=\")) {\n-                    margin = Integer.parseInt(args[i].substring(8));\n-                    margins++;\n-                }\n-            } else {\n-                if (i == 0) {\n-                    timeout = Integer.parseInt(args[i]);\n-                    timeouts++;\n-                }\n-            }\n-        };\n-        if (timeouts==0 && waittimes==0)\n-            throw new IllegalArgumentException(\n-                \"no $TIMEOUT, nor -waittime=$WAITTIME is set\");\n-        if (waittimes > 1)\n-            throw new IllegalArgumentException(\n-                \"more than one -waittime=... is set\");\n-        if (margins > 1)\n-            throw new IllegalArgumentException(\n-                \"more than one -margin=... is set\");\n-\n-        int result = timeout - margin;\n-        if (result <= 0)\n-            throw new IllegalArgumentException(\n-                \"delay appointment must be greater than \"+margin+\" minutes\");\n-        return result;\n-    }\n-\n-    \/**\n-     * Appoint terminator after the given amount of <tt>minutes<\/tt>,\n-     * so that exit status would be 95 (to simulate JCK-like PASS\n-     * status).\n-     *\n-     * @throws IllegalStateException If terminator is already appointed.\n-     *\n-     * @see #appoint(int,int)\n-     * @see #parseAppointment(String[])\n-     *\/\n-    public static void appoint(int minutes) {\n-        appoint(minutes,95); \/\/ JCK-like PASS status\n-    }\n-\n-    \/**\n-     * Appoint Terminator for the given amount of <tt>minutes<\/tt>,\n-     * so that the given <tt>status<\/tt> would be exited when time\n-     * is over.\n-     *\n-     * @throws IllegalStateException If terminator is already appointed.\n-     *\n-     * @see #appoint(int)\n-     * @see #parseAppointment(String[])\n-     *\/\n-    public static void appoint(int minutes, int status) {\n-        if (terminator != null)\n-            throw new IllegalStateException(\"Terminator is already appointed.\");\n-\n-        final long timeToExit = System.currentTimeMillis() + 60*1000L*minutes;\n-        final int  exitStatus = status;\n-\n-        terminator = new Thread(Terminator.class.getName()) {\n-            public void run() {\n-                long timeToSleep = timeToExit - System.currentTimeMillis();\n-                if (timeToSleep > 0)\n-                    try {\n-                        \/\/\n-                        \/\/ Use wait() instead of sleep(), because Java 2\n-                        \/\/ specification doesn't guarantee the method\n-                        \/\/ sleep() to yield to other threads.\n-                        \/\/\n-                        Object someDummyObject = new Object();\n-                        synchronized (someDummyObject) {\n-                            someDummyObject.wait(timeToSleep);\n-                        }\n-                    } catch (InterruptedException exception) {\n-                        exception.printStackTrace(System.err);\n-                        return;\n-                    };\n-                \/\/\n-                \/\/ OK, lets do it now:\n-                \/\/\n-                System.err.println(\n-                    \"#\\n# Terminator: prescheduled program termination.\\n#\");\n-                System.exit(exitStatus); \/\/ terminator to all threads\n-            }\n-        };\n-\n-        terminator.setPriority(Thread.MAX_PRIORITY);\n-        terminator.setDaemon(true);\n-        terminator.start();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/Terminator.java","additions":0,"deletions":172,"binary":false,"changes":172,"status":"deleted"}]}