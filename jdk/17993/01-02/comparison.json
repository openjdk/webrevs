{"files":[{"patch":"@@ -55,1 +55,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack001\n+ * @run main\/othervm\/timeout=900 Stack001\n@@ -58,3 +58,1 @@\n-package nsk.stress.stack;\n-\n-public class stack001 {\n+public class Stack001 {\n@@ -62,1 +60,1 @@\n-        stack001 test = new stack001();\n+        Stack001 test = new Stack001();\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack001.java","additions":3,"deletions":5,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack001.java","status":"renamed"},{"patch":"@@ -56,1 +56,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack002\n+ * @run main\/othervm\/timeout=900 Stack002\n@@ -59,3 +59,1 @@\n-package nsk.stress.stack;\n-\n-public class stack002 {\n+public class Stack002 {\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack002.java","additions":2,"deletions":4,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack002.java","status":"renamed"},{"patch":"@@ -50,1 +50,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack003\n+ * @run main\/othervm\/timeout=900 Stack003\n@@ -53,3 +53,1 @@\n-package nsk.stress.stack;\n-\n-public class stack003 {\n+public class Stack003 {\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack003.java","additions":2,"deletions":4,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack003.java","status":"renamed"},{"patch":"@@ -50,1 +50,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack004\n+ * @run main\/othervm\/timeout=900 Stack004\n@@ -53,3 +53,1 @@\n-package nsk.stress.stack;\n-\n-public class stack004 {\n+public class Stack004 {\n@@ -57,1 +55,1 @@\n-        stack004 test = new stack004();\n+        Stack004 test = new Stack004();\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack004.java","additions":3,"deletions":5,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack004.java","status":"renamed"},{"patch":"@@ -50,1 +50,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack005\n+ * @run main\/othervm\/timeout=900 Stack005\n@@ -53,3 +53,1 @@\n-package nsk.stress.stack;\n-\n-public class stack005 {\n+public class Stack005 {\n@@ -57,1 +55,1 @@\n-        stack005 test = new stack005();\n+        Stack005 test = new Stack005();\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack005.java","additions":3,"deletions":5,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack005.java","status":"renamed"},{"patch":"@@ -50,1 +50,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack006\n+ * @run main\/othervm\/timeout=900 Stack006\n@@ -53,3 +53,1 @@\n-package nsk.stress.stack;\n-\n-public class stack006 implements stack006i {\n+public class Stack006 implements Stack006i {\n@@ -57,1 +55,1 @@\n-        stack006i test = new stack006();\n+        Stack006i test = new Stack006();\n@@ -84,1 +82,1 @@\n-interface stack006i {\n+interface Stack006i {\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack006.java","additions":4,"deletions":6,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack006.java","status":"renamed"},{"patch":"@@ -49,1 +49,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack007\n+ * @run main\/othervm\/timeout=900 Stack007\n@@ -52,3 +52,1 @@\n-package nsk.stress.stack;\n-\n-public class stack007 implements stack007i {\n+public class Stack007 implements Stack007i {\n@@ -59,1 +57,1 @@\n-        stack007i test = new stack007();\n+        Stack007i test = new Stack007();\n@@ -86,1 +84,1 @@\n-interface stack007i {\n+interface Stack007i {\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack007.java","additions":4,"deletions":6,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack007.java","status":"renamed"},{"patch":"@@ -51,1 +51,1 @@\n- * @run main\/othervm\/timeout=900 -Xss200K nsk.stress.stack.stack008\n+ * @run main\/othervm\/timeout=900 -Xss200K Stack008\n@@ -54,2 +54,0 @@\n-package nsk.stress.stack;\n-\n@@ -59,1 +57,1 @@\n-public class stack008 {\n+public class Stack008 {\n@@ -111,1 +109,1 @@\n-    static stack008 instance = null;\n+    static Stack008 instance = null;\n@@ -119,2 +117,2 @@\n-            instance = new stack008();\n-            method = stack008.class.getMethod(\"recurse\");\n+            instance = new Stack008();\n+            method = Stack008.class.getMethod(\"recurse\");\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack008.java","additions":5,"deletions":7,"binary":false,"changes":12,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack008.java","status":"renamed"},{"patch":"@@ -50,1 +50,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack009\n+ * @run main\/othervm\/timeout=900 Stack009\n@@ -53,3 +53,1 @@\n-package nsk.stress.stack;\n-\n-public class stack009 {\n+public class Stack009 {\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack009.java","additions":2,"deletions":4,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack009.java","status":"renamed"},{"patch":"@@ -50,1 +50,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack010\n+ * @run main\/othervm\/timeout=900 Stack010\n@@ -53,3 +53,1 @@\n-package nsk.stress.stack;\n-\n-public class stack010 extends Thread {\n+public class Stack010 extends Thread {\n@@ -77,1 +75,1 @@\n-        stack010 threads[] = new stack010[THREADS];\n+        Stack010 threads[] = new Stack010[THREADS];\n@@ -79,1 +77,1 @@\n-            threads[i] = new stack010();\n+            threads[i] = new Stack010();\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack010.java","additions":4,"deletions":6,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack010.java","status":"renamed"},{"patch":"@@ -50,1 +50,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack011\n+ * @run main\/othervm\/timeout=900 Stack011\n@@ -53,3 +53,1 @@\n-package nsk.stress.stack;\n-\n-public class stack011 extends Thread {\n+public class Stack011 extends Thread {\n@@ -77,1 +75,1 @@\n-        stack011 threads[] = new stack011[THREADS];\n+        Stack011 threads[] = new Stack011[THREADS];\n@@ -79,1 +77,1 @@\n-            threads[i] = new stack011();\n+            threads[i] = new Stack011();\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack011.java","additions":4,"deletions":6,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack011.java","status":"renamed"},{"patch":"@@ -51,1 +51,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack012\n+ * @run main\/othervm\/timeout=900 Stack012\n@@ -54,3 +54,1 @@\n-package nsk.stress.stack;\n-\n-public class stack012 extends Thread {\n+public class Stack012 extends Thread {\n@@ -61,1 +59,1 @@\n-        stack012 test = new stack012();\n+        Stack012 test = new Stack012();\n@@ -79,1 +77,1 @@\n-        stack012 threads[] = new stack012[THREADS];\n+        Stack012 threads[] = new Stack012[THREADS];\n@@ -81,1 +79,1 @@\n-            threads[i] = new stack012();\n+            threads[i] = new Stack012();\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack012.java","additions":5,"deletions":7,"binary":false,"changes":12,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack012.java","status":"renamed"},{"patch":"@@ -50,1 +50,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack013\n+ * @run main\/othervm\/timeout=900 Stack013\n@@ -53,3 +53,1 @@\n-package nsk.stress.stack;\n-\n-public class stack013 extends stack013i {\n+public class Stack013 extends Stack013i {\n@@ -60,1 +58,1 @@\n-        stack013i test = new stack013();\n+        Stack013i test = new Stack013();\n@@ -78,1 +76,1 @@\n-        stack013i threads[] = new stack013i[THREADS];\n+        Stack013i threads[] = new Stack013i[THREADS];\n@@ -80,1 +78,1 @@\n-            threads[i] = new stack013();\n+            threads[i] = new Stack013();\n@@ -112,1 +110,1 @@\n-abstract class stack013i extends Thread {\n+abstract class Stack013i extends Thread {\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack013.java","additions":6,"deletions":8,"binary":false,"changes":14,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack013.java","status":"renamed"},{"patch":"@@ -53,1 +53,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack014\n+ * @run main\/othervm\/timeout=900 Stack014\n@@ -56,3 +56,1 @@\n-package nsk.stress.stack;\n-\n-public class stack014 extends stack014i {\n+public class Stack014 extends Stack014i {\n@@ -63,1 +61,1 @@\n-        stack014i test = new stack014();\n+        Stack014i test = new Stack014();\n@@ -81,1 +79,1 @@\n-        stack014i threads[] = new stack014i[THREADS];\n+        Stack014i threads[] = new Stack014i[THREADS];\n@@ -83,1 +81,1 @@\n-            threads[i] = new stack014();\n+            threads[i] = new Stack014();\n@@ -115,1 +113,1 @@\n-abstract class stack014i extends Thread {\n+abstract class Stack014i extends Thread {\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack014.java","additions":6,"deletions":8,"binary":false,"changes":14,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack014.java","status":"renamed"},{"patch":"@@ -51,1 +51,1 @@\n- * @run main\/othervm\/timeout=900 nsk.stress.stack.stack015\n+ * @run main\/othervm\/timeout=900 Stack015\n@@ -54,3 +54,1 @@\n-package nsk.stress.stack;\n-\n-public class stack015 extends stack015i {\n+public class Stack015 extends Stack015i {\n@@ -64,1 +62,1 @@\n-        \/\/ The test will invoke the particular stack015.recurse()\n+        \/\/ The test will invoke the particular Stack015.recurse()\n@@ -67,2 +65,2 @@\n-        stack015i test = new stack015();\n-        stack015i.test = test;\n+        Stack015i test = new Stack015();\n+        Stack015i.test = test;\n@@ -87,1 +85,1 @@\n-        stack015i threads[] = new stack015i[THREADS];\n+        Stack015i threads[] = new Stack015i[THREADS];\n@@ -89,1 +87,1 @@\n-            threads[i] = new stack015();\n+            threads[i] = new Stack015();\n@@ -120,1 +118,1 @@\n-abstract class stack015i extends Thread {\n+abstract class Stack015i extends Thread {\n@@ -130,1 +128,1 @@\n-        syncRecurse(stack015.STEP);\n+        syncRecurse(Stack015.STEP);\n@@ -142,1 +140,1 @@\n-    static stack015i test;\n+    static Stack015i test;\n@@ -148,1 +146,1 @@\n-        for (int i = 0; i < stack015.CYCLES; i++) {\n+        for (int i = 0; i < Stack015.CYCLES; i++) {\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack015.java","additions":11,"deletions":13,"binary":false,"changes":24,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack015.java","status":"renamed"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack016.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test provokes second stack overflow from within the\n+ *     stack overflow handler -- repeatedly multiple times, and\n+ *     in multiple threads.\n+ *     This test measures a number of recursive invocations until\n+ *     stack overflow, and then tries to provoke similar stack overflows\n+ *     in 10 times in each of 10 threads. Each provocation consists of\n+ *     invoking that recursive method for the given fixed depth\n+ *     of invocations which is 10 times that depth measured before,\n+ *     and then trying to invoke that recursive method once again\n+ *     from within the catch clause just caught StackOverflowError.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\")\n+ * @run main\/othervm\/timeout=900 -Xint -Xss448K Stack016\n+ * @run main\/othervm\/timeout=900 -Xcomp -Xss448K Stack016\n+ * @run main\/othervm\/timeout=900 -Xcomp -XX:-TieredCompilation -Xss448K Stack016\n+ *\/\n+\n+public class Stack016 extends Thread {\n+    private final static int THREADS = 10;\n+    private final static int CYCLES = 10;\n+    private final static int STEP = 10;\n+    private final static int RESERVE = 10;\n+    private final static int PROBES = STEP * RESERVE;\n+\n+    public static void main(String[] args) {\n+        Stack016 test = new Stack016();\n+        test.doRun();\n+    }\n+\n+    private void doRun() {\n+        \/\/\n+        \/\/ Measure recursive depth before stack overflow:\n+        \/\/\n+        int maxDepth = 0;\n+        for (depthToTry = 0; ; depthToTry += STEP) {\n+            try {\n+                trickyRecurse(depthToTry);\n+                maxDepth = depthToTry;\n+            } catch (StackOverflowError | OutOfMemoryError ex) {\n+                break;\n+            }\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        Stack016 threads[] = new Stack016[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack016();\n+            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n+            threads[i].depthToTry = RESERVE * maxDepth;\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    private int stackTop = 0;\n+    private int depthToTry = 0;\n+    private Throwable thrown = null;\n+\n+    private void trickyRecurse(int depth) {\n+        stackTop = depthToTry - depth;\n+        if (depth > 0) {\n+            try {\n+                trickyRecurse(depth - 1);\n+            } catch (StackOverflowError | OutOfMemoryError error) {\n+                \/\/\n+                \/\/ Provoke more stack overflow,\n+                \/\/ if current stack is deep enough:\n+                \/\/\n+                if (depthToTry - depth < stackTop - PROBES)\n+                    throw error;\n+                recurse(depthToTry);\n+\n+                throw new Error(\"TEST_RFE: try deeper recursion!\");\n+            }\n+        }\n+    }\n+\n+    private static void recurse(int depth) {\n+        if (depth > 0) {\n+            recurse(depth - 1);\n+        }\n+    }\n+\n+    public void run() {\n+        String threadName = Thread.currentThread().getName();\n+        for (int i = 1; i <= CYCLES; i++) {\n+            try {\n+                System.out.println(threadName + \", iteration: \" + i + \"\/\" + CYCLES +\n+                        \", depthToTry: \" + depthToTry);\n+                trickyRecurse(depthToTry);\n+                throw new Error(\n+                        \"TEST_BUG: trickyRecursion() must throw an error anyway!\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                thrown = throwable;\n+                break;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack016.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack017.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test invokes infinitely recursive method from within stack\n+ *     overflow handler  -- repeatedly multiple times, and in multiple\n+ *     threads.\n+ *     The test is deemed passed, if VM have not crashed, and\n+ *     if exception other than due to stack overflow was not\n+ *     thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @run main\/othervm\/timeout=900 -Xss220K Stack017\n+ *\/\n+\n+public class Stack017 extends Thread {\n+    private final static int THREADS = 10;\n+    private final static int CYCLES = 10;\n+    private final static int PROBES = 100;\n+\n+    public static void main(String[] args) {\n+        Stack017 test = new Stack017();\n+        test.doRun();\n+    }\n+\n+    private static int depthToTry;\n+\n+    private void doRun() {\n+        \/\/\n+        \/\/ Measure recursive depth before stack overflow:\n+        \/\/\n+        try {\n+            recurse(0);\n+        } catch (StackOverflowError | OutOfMemoryError err) {\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+        depthToTry = maxDepth;\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        Stack017 threads[] = new Stack017[THREADS];\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new Stack017();\n+            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n+            threads[i].start();\n+        }\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].isAlive()) {\n+                try {\n+                    threads[i].join();\n+                } catch (InterruptedException exception) {\n+                    throw new RuntimeException(exception);\n+                }\n+            }\n+        }\n+        \/\/\n+        \/\/ Check if unexpected exceptions were thrown:\n+        \/\/\n+        for (int i = 0; i < threads.length; i++) {\n+            if (threads[i].thrown != null) {\n+                threads[i].thrown.printStackTrace();\n+                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n+            }\n+        }\n+    }\n+\n+    private int maxDepth = 0;\n+\n+    private void recurse(int depth) {\n+        maxDepth = depth;\n+        recurse(depth + 1);\n+    }\n+\n+    private void trickyRecurse(int depth) {\n+        try {\n+            maxDepth = depth;\n+            trickyRecurse(depth + 1);\n+        } catch (StackOverflowError | OutOfMemoryError error) {\n+            \/\/\n+            \/\/ Stack problem caught: provoke it again,\n+            \/\/ if current stack is enough deep:\n+            \/\/\n+            if (depth < depthToTry - PROBES)\n+                throw error;\n+            recurse(depth + 1);\n+        }\n+    }\n+\n+    private Throwable thrown = null;\n+\n+    public void run() {\n+        String threadName = Thread.currentThread().getName();\n+        for (int i = 1; i <= CYCLES; i++)\n+            try {\n+                System.out.println(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n+                trickyRecurse(0);\n+                throw new Exception(\n+                        \"TEST_BUG: stack overflow was expected!\");\n+\n+            } catch (StackOverflowError | OutOfMemoryError err) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                \/\/ It isn't OK!\n+                thrown = throwable;\n+                break;\n+            }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack017.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -50,3 +50,1 @@\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xss220K nsk.stress.stack.stack018 -eager\n+ * @run main\/othervm\/timeout=900 -Xss220K Stack018\n@@ -55,5 +53,0 @@\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n@@ -63,1 +56,1 @@\n-public class stack018 extends Thread {\n+public class Stack018 extends Thread {\n@@ -70,10 +63,1 @@\n-        boolean eager = false;\n-        for (int i = 0; i < args.length; i++) {\n-            if (args[i].toLowerCase().equals(\"-eager\")) {\n-                eager = true;\n-            }\n-        }\n-        if (!eager) {\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        }\n-        stack018 test = new stack018();\n+        Stack018 test = new Stack018();\n@@ -111,1 +95,1 @@\n-        stack018 threads[] = new stack018[THREADS];\n+        Stack018 threads[] = new Stack018[THREADS];\n@@ -113,1 +97,1 @@\n-            threads[i] = new stack018();\n+            threads[i] = new Stack018();\n@@ -183,1 +167,1 @@\n-            method = stack018.class.getMethod(\"recurse\");\n+            method = Stack018.class.getMethod(\"recurse\");\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack018.java","additions":6,"deletions":22,"binary":false,"changes":28,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack018.java","status":"renamed"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress\n+ *\n+ * @summary converted from VM testbase nsk\/stress\/stack\/stack019.\n+ * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n+ * VM testbase readme:\n+ * DESCRIPTION\n+ *     The test invokes infinitely recursive method from within stack\n+ *     overflow handler -- repeatedly multiple times in a single thread.\n+ *     The test is deemed passed, if VM have not crashed, and if exception\n+ *     other than due to stack overflow was not thrown.\n+ * COMMENTS\n+ *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n+ *     Solaris and Win32 platforms.\n+ *     See the bug:\n+ *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n+ *     The stack size is too small to run on systems with > 4K page size.\n+ *     Making it bigger could cause timeouts on other platform.\n+ *\n+ * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n+ * @requires os.family != \"windows\"\n+ * @run main\/othervm\/timeout=900 -Xss200K Stack019\n+ *\/\n+\n+public class Stack019 {\n+    private final static int CYCLES = 50;\n+    private final static int PROBES = 50;\n+\n+    public static void main(String[] args) {\n+        \/\/\n+        \/\/ Measure recursive depth before stack overflow:\n+        \/\/\n+        try {\n+            recurse(0);\n+        } catch (StackOverflowError | OutOfMemoryError err) {\n+        }\n+        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n+        depthToTry = maxDepth;\n+\n+        \/\/\n+        \/\/ Run the tested threads:\n+        \/\/\n+        for (int i = 0; i < CYCLES; i++) {\n+            try {\n+                System.out.println(\"Iteration: \" + i + \"\/\" + CYCLES);\n+                trickyRecurse(0);\n+                throw new RuntimeException(\"# TEST_BUG: stack overflow was expected!\");\n+            } catch (StackOverflowError | OutOfMemoryError error) {\n+                \/\/ It's OK\n+            } catch (Throwable throwable) {\n+                throw new RuntimeException(throwable);\n+            }\n+        }\n+    }\n+\n+    private static int maxDepth;\n+    private static int depthToTry;\n+\n+    private static void recurse(int depth) {\n+        maxDepth = depth;\n+        recurse(depth + 1);\n+    }\n+\n+    private static void trickyRecurse(int depth) {\n+        try {\n+            maxDepth = depth;\n+            trickyRecurse(depth + 1);\n+        } catch (StackOverflowError | OutOfMemoryError error){\n+            \/\/\n+            \/\/ Stack problem caught: provoke it again,\n+            \/\/ if current stack is enough deep:\n+            \/\/\n+            if (depth < depthToTry - PROBES) {\n+                throw error;\n+            }\n+            recurse(depth + 1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stack\/Stack019.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"","filename":"test\/hotspot\/jtreg\/runtime\/stack\/TEST.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/TEST.properties","status":"renamed"},{"patch":"@@ -1,189 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack016.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test provokes second stack overflow from within the\n- *     stack overflow handler -- repeatedly multiple times, and\n- *     in multiple threads.\n- *     This test measures a number of recursive invocations until\n- *     stack overflow, and then tries to provoke similar stack overflows\n- *     in 10 times in each of 10 threads. Each provocation consists of\n- *     invoking that recursive method for the given fixed depth\n- *     of invocations which is 10 times that depth measured before,\n- *     and then trying to invoke that recursive method once again\n- *     from within the catch clause just caught StackOverflowError.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\")\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xint -Xss448K nsk.stress.stack.stack016 -eager\n- * @run main\/othervm\/timeout=900 -Xcomp -Xss448K nsk.stress.stack.stack016 -eager\n- * @run main\/othervm\/timeout=900 -Xcomp -XX:-TieredCompilation -Xss448K nsk.stress.stack.stack016 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-public class stack016 extends Thread {\n-    private final static int THREADS = 10;\n-    private final static int CYCLES = 10;\n-    private final static int STEP = 10;\n-    private final static int RESERVE = 10;\n-    private final static int PROBES = STEP * RESERVE;\n-\n-    public static void main(String[] args) {\n-        verbose = false;\n-        boolean eager = false;\n-        for (int i = 0; i < args.length; i++) {\n-            if (args[i].toLowerCase().equals(\"-verbose\"))\n-                verbose = true;\n-            else if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        }\n-        if (!eager) {\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        }\n-        stack016 test = new stack016();\n-        test.doRun();\n-    }\n-\n-    private static boolean verbose;\n-\n-    private void display(Object message) {\n-        if (!verbose) {\n-            return;\n-        }\n-        System.out.println(message.toString());\n-    }\n-\n-    private void doRun() {\n-        \/\/\n-        \/\/ Measure recursive depth before stack overflow:\n-        \/\/\n-        int maxDepth = 0;\n-        for (depthToTry = 0; ; depthToTry += STEP) {\n-            try {\n-                trickyRecurse(depthToTry);\n-                maxDepth = depthToTry;\n-            } catch (StackOverflowError | OutOfMemoryError ex) {\n-                break;\n-            }\n-        }\n-        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        stack016 threads[] = new stack016[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack016();\n-            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n-            threads[i].depthToTry = RESERVE * maxDepth;\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++) {\n-            if (threads[i].isAlive()) {\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    throw new RuntimeException(exception);\n-                }\n-            }\n-        }\n-\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        for (int i = 0; i < threads.length; i++) {\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace();\n-                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n-            }\n-        }\n-    }\n-\n-    private int stackTop = 0;\n-    private int depthToTry = 0;\n-    private Throwable thrown = null;\n-\n-    private void trickyRecurse(int depth) {\n-        stackTop = depthToTry - depth;\n-        if (depth > 0) {\n-            try {\n-                trickyRecurse(depth - 1);\n-            } catch (StackOverflowError | OutOfMemoryError error) {\n-                \/\/\n-                \/\/ Provoke more stack overflow,\n-                \/\/ if current stack is deep enough:\n-                \/\/\n-                if (depthToTry - depth < stackTop - PROBES)\n-                    throw error;\n-                recurse(depthToTry);\n-\n-                throw new Error(\"TEST_RFE: try deeper recursion!\");\n-            }\n-        }\n-    }\n-\n-    private static void recurse(int depth) {\n-        if (depth > 0) {\n-            recurse(depth - 1);\n-        }\n-    }\n-\n-    public void run() {\n-        String threadName = Thread.currentThread().getName();\n-        for (int i = 1; i <= CYCLES; i++) {\n-            try {\n-                display(threadName + \", iteration: \" + i + \"\/\" + CYCLES +\n-                        \", depthToTry: \" + depthToTry);\n-                trickyRecurse(depthToTry);\n-                throw new Error(\n-                        \"TEST_BUG: trickyRecursion() must throw an error anyway!\");\n-\n-            } catch (StackOverflowError | OutOfMemoryError err) {\n-                \/\/ It's OK\n-            } catch (Throwable throwable) {\n-                thrown = throwable;\n-                break;\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack016.java","additions":0,"deletions":189,"binary":false,"changes":189,"status":"deleted"},{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack017.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test invokes infinitely recursive method from within stack\n- *     overflow handler  -- repeatedly multiple times, and in multiple\n- *     threads.\n- *     The test is deemed passed, if VM have not crashed, and\n- *     if exception other than due to stack overflow was not\n- *     thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xss220K nsk.stress.stack.stack017 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-\n-import nsk.share.Terminator;\n-\n-public class stack017 extends Thread {\n-    private final static int THREADS = 10;\n-    private final static int CYCLES = 10;\n-    private final static int PROBES = 100;\n-\n-    public static void main(String[] args) {\n-        boolean eager = false;\n-        for (int i = 0; i < args.length; i++) {\n-            if (args[i].toLowerCase().equals(\"-eager\")) {\n-                eager = true;\n-            }\n-        }\n-        if (!eager) {\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        }\n-        stack017 test = new stack017();\n-        test.doRun();\n-    }\n-\n-    private static int depthToTry;\n-\n-    private void doRun() {\n-        \/\/\n-        \/\/ Measure recursive depth before stack overflow:\n-        \/\/\n-        try {\n-            recurse(0);\n-        } catch (StackOverflowError | OutOfMemoryError err) {\n-        }\n-        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n-        depthToTry = maxDepth;\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        stack017 threads[] = new stack017[THREADS];\n-        for (int i = 0; i < threads.length; i++) {\n-            threads[i] = new stack017();\n-            threads[i].setName(\"Thread: \" + (i + 1) + \"\/\" + THREADS);\n-            threads[i].start();\n-        }\n-        for (int i = 0; i < threads.length; i++) {\n-            if (threads[i].isAlive()) {\n-                try {\n-                    threads[i].join();\n-                } catch (InterruptedException exception) {\n-                    throw new RuntimeException(exception);\n-                }\n-            }\n-        }\n-        \/\/\n-        \/\/ Check if unexpected exceptions were thrown:\n-        \/\/\n-        for (int i = 0; i < threads.length; i++) {\n-            if (threads[i].thrown != null) {\n-                threads[i].thrown.printStackTrace();\n-                throw new RuntimeException(\"Exception in the thread \" + threads[i], threads[i].thrown);\n-            }\n-        }\n-    }\n-\n-    private int maxDepth = 0;\n-\n-    private void recurse(int depth) {\n-        maxDepth = depth;\n-        recurse(depth + 1);\n-    }\n-\n-    private void trickyRecurse(int depth) {\n-        try {\n-            maxDepth = depth;\n-            trickyRecurse(depth + 1);\n-        } catch (StackOverflowError | OutOfMemoryError error) {\n-            \/\/\n-            \/\/ Stack problem caught: provoke it again,\n-            \/\/ if current stack is enough deep:\n-            \/\/\n-            if (depth < depthToTry - PROBES)\n-                throw error;\n-            recurse(depth + 1);\n-        }\n-    }\n-\n-    private Throwable thrown = null;\n-\n-    public void run() {\n-        String threadName = Thread.currentThread().getName();\n-        for (int i = 1; i <= CYCLES; i++)\n-            try {\n-                System.out.println(threadName + \", iteration: \" + i + \"\/\" + CYCLES);\n-                trickyRecurse(0);\n-                throw new Exception(\n-                        \"TEST_BUG: stack overflow was expected!\");\n-\n-            } catch (StackOverflowError | OutOfMemoryError err) {\n-                \/\/ It's OK\n-            } catch (Throwable throwable) {\n-                \/\/ It isn't OK!\n-                thrown = throwable;\n-                break;\n-            }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack017.java","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/stack\/stack019.\n- * VM testbase keywords: [stress, diehard, stack, nonconcurrent]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     The test invokes infinitely recursive method from within stack\n- *     overflow handler -- repeatedly multiple times in a single thread.\n- *     The test is deemed passed, if VM have not crashed, and if exception\n- *     other than due to stack overflow was not thrown.\n- * COMMENTS\n- *     This test crashes HS versions 2.0, 1.3, and 1.4 on both\n- *     Solaris and Win32 platforms.\n- *     See the bug:\n- *     4366625 (P4\/S4) multiple stack overflow causes HS crash\n- *     The stack size is too small to run on systems with > 4K page size.\n- *     Making it bigger could cause timeouts on other platform.\n- *\n- * @requires (vm.opt.DeoptimizeALot != true & vm.compMode != \"Xcomp\" & vm.pageSize == 4096)\n- * @requires os.family != \"windows\"\n- * @library \/vmTestbase\n- * @build nsk.share.Terminator\n- * @run main\/othervm\/timeout=900 -Xss200K nsk.stress.stack.stack019 -eager\n- *\/\n-\n-package nsk.stress.stack;\n-\n-import nsk.share.Terminator;\n-\n-public class stack019 {\n-    private final static int CYCLES = 50;\n-    private final static int PROBES = 50;\n-\n-    public static void main(String[] args) {\n-        boolean eager = false;\n-        for (int i = 0; i < args.length; i++)\n-             if (args[i].toLowerCase().equals(\"-eager\"))\n-                eager = true;\n-        if (!eager) {\n-            Terminator.appoint(Terminator.parseAppointment(args));\n-        }\n-        \/\/\n-        \/\/ Measure recursive depth before stack overflow:\n-        \/\/\n-        try {\n-            recurse(0);\n-        } catch (StackOverflowError | OutOfMemoryError err) {\n-        }\n-        System.out.println(\"Maximal recursion depth: \" + maxDepth);\n-        depthToTry = maxDepth;\n-\n-        \/\/\n-        \/\/ Run the tested threads:\n-        \/\/\n-        for (int i = 0; i < CYCLES; i++) {\n-            try {\n-                System.out.println(\"Iteration: \" + i + \"\/\" + CYCLES);\n-                trickyRecurse(0);\n-                throw new RuntimeException(\"# TEST_BUG: stack overflow was expected!\");\n-            } catch (StackOverflowError | OutOfMemoryError error) {\n-                \/\/ It's OK\n-            } catch (Throwable throwable) {\n-                throw new RuntimeException(throwable);\n-            }\n-        }\n-    }\n-\n-    private static int maxDepth;\n-    private static int depthToTry;\n-\n-    private static void recurse(int depth) {\n-        maxDepth = depth;\n-        recurse(depth + 1);\n-    }\n-\n-    private static void trickyRecurse(int depth) {\n-        try {\n-            maxDepth = depth;\n-            trickyRecurse(depth + 1);\n-        } catch (StackOverflowError | OutOfMemoryError error){\n-            \/\/\n-            \/\/ Stack problem caught: provoke it again,\n-            \/\/ if current stack is enough deep:\n-            \/\/\n-            if (depth < depthToTry - PROBES) {\n-                throw error;\n-            }\n-            recurse(depth + 1);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack019.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"}]}