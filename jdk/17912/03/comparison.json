{"files":[{"patch":"@@ -155,1 +155,2 @@\n-      if (!expand()) {\n+      size_t desired_capacity = bucket_size(bucket) * 2;\n+      if (!try_expand_to(desired_capacity)) {\n@@ -199,1 +200,1 @@\n-bool G1CMMarkStack::ChunkAllocator::expand() {\n+bool G1CMMarkStack::ChunkAllocator::try_expand_to(size_t desired_capacity) {\n@@ -204,0 +205,1 @@\n+\n@@ -205,2 +207,1 @@\n-  \/\/ Double capacity if possible.\n-  size_t new_capacity = MIN2(old_capacity * 2, _max_capacity);\n+  desired_capacity = MIN2(desired_capacity, _max_capacity);\n@@ -208,1 +209,1 @@\n-  if (reserve(new_capacity)) {\n+  if (reserve(desired_capacity)) {\n@@ -210,1 +211,1 @@\n-                  old_capacity, new_capacity);\n+                  old_capacity, desired_capacity);\n@@ -216,0 +217,5 @@\n+bool G1CMMarkStack::ChunkAllocator::try_expand() {\n+  size_t new_capacity = _capacity * 2;\n+  return try_expand_to(new_capacity);\n+}\n+\n@@ -237,0 +243,3 @@\n+  \/\/ Allocate all buckets associated with indexes between the current capacity (_capacity)\n+  \/\/ and the new capacity (new_capacity). This step ensures that there are no gaps in the\n+  \/\/ array and that the capacity accurately reflects the reserved memory.\n@@ -264,1 +273,1 @@\n-  _chunk_allocator.expand();\n+  _chunk_allocator.try_expand();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-    \/\/ Illustration of the Growable Array data structure.\n+    \/\/ Illustration of the growable array data structure.\n@@ -177,1 +177,1 @@\n-              _min_capacity * ( 1ULL << (bucket -1));\n+              _min_capacity * ( 1ULL << (bucket - 1));\n@@ -228,1 +228,3 @@\n-    bool expand();\n+    \/\/ Expand the mark stack doubling its size.\n+    bool try_expand();\n+    bool try_expand_to(size_t desired_capacity);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}