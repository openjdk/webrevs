{"files":[{"patch":"@@ -0,0 +1,700 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+import java.util.Arrays;\n+\n+\/**\n+ * This benchmark is here to measure vectorized peformance for some simple bulk operations:\n+ * - fill\n+ * - copy\n+ *\n+ * We may add more in the future, for example:\n+ * - comparison\n+ * - find index\n+ * - filter\n+ * - ...\n+ *\n+ * One important feature of this benchmark, is that we control for alignment and 4k-aliasing,\n+ * something almost no benchmarks have considered up to now. But it is important to get more\n+ * precise, clean and reliable results.\n+ *\n+ * Note, you may want to play with \"-XX:-OptimizeFill\" for the fill benchmarks, so that we do\n+ * not use the fill-intrinsic, but auto-vectorize. Though I'm currently not seeing a difference,\n+ * maybe the loop is not recognized properly? Maybe the alignment \"randomization\" prevents it.\n+ *\n+ * Please also look at the companion benchmark:\n+ *   VectorBulkOperationsMemorySegment.java\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 1)\n+public class VectorBulkOperationsArray {\n+    @Param({  \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",  \"8\",  \"9\",\n+             \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n+             \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n+             \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n+             \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n+             \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n+             \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n+             \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n+             \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n+             \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\",\n+            \"100\",\"101\",\"102\",\"103\",\"104\",\"105\",\"106\",\"107\",\"108\",\"109\",\n+            \"110\",\"111\",\"112\",\"113\",\"114\",\"115\",\"116\",\"117\",\"118\",\"119\",\n+            \"120\",\"121\",\"122\",\"123\",\"124\",\"125\",\"126\",\"127\",\"128\",\"129\",\n+            \"130\",\"131\",\"132\",\"133\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\n+            \"140\",\"141\",\"142\",\"143\",\"144\",\"145\",\"146\",\"147\",\"148\",\"149\",\n+            \"150\",\"151\",\"152\",\"153\",\"154\",\"155\",\"156\",\"157\",\"158\",\"159\",\n+            \"160\",\"161\",\"162\",\"163\",\"164\",\"165\",\"166\",\"167\",\"168\",\"169\",\n+            \"170\",\"171\",\"172\",\"173\",\"174\",\"175\",\"176\",\"177\",\"178\",\"179\",\n+            \"180\",\"181\",\"182\",\"183\",\"184\",\"185\",\"186\",\"187\",\"188\",\"189\",\n+            \"190\",\"191\",\"192\",\"193\",\"194\",\"195\",\"196\",\"197\",\"198\",\"199\",\n+            \"200\",\"201\",\"202\",\"203\",\"204\",\"205\",\"206\",\"207\",\"208\",\"209\",\n+            \"210\",\"211\",\"212\",\"213\",\"214\",\"215\",\"216\",\"217\",\"218\",\"219\",\n+            \"220\",\"221\",\"222\",\"223\",\"224\",\"225\",\"226\",\"227\",\"228\",\"229\",\n+            \"230\",\"231\",\"232\",\"233\",\"234\",\"235\",\"236\",\"237\",\"238\",\"239\",\n+            \"240\",\"241\",\"242\",\"243\",\"244\",\"245\",\"246\",\"247\",\"248\",\"249\",\n+            \"250\",\"251\",\"252\",\"253\",\"254\",\"255\",\"256\",\"257\",\"258\",\"259\",\n+            \"260\",\"261\",\"262\",\"263\",\"264\",\"265\",\"266\",\"267\",\"268\",\"269\",\n+            \"270\",\"271\",\"272\",\"273\",\"274\",\"275\",\"276\",\"277\",\"278\",\"279\",\n+            \"280\",\"281\",\"282\",\"283\",\"284\",\"285\",\"286\",\"287\",\"288\",\"289\",\n+            \"290\",\"291\",\"292\",\"293\",\"294\",\"295\",\"296\",\"297\",\"298\",\"299\",\n+            \"300\"})\n+    public static int NUM_ACCESS_ELEMENTS;\n+\n+    \/\/ Every array has two regions:\n+    \/\/ - read region\n+    \/\/ - write region\n+    \/\/ We should make sure that the region is a multiple of 4k, so that the\n+    \/\/ 4k-aliasing prevention trick can work.\n+    \/\/\n+    \/\/ It would be ince to set REGION_SIZE statically, but we want to keep it rather small if possible,\n+    \/\/ to avoid running out of cache. But it might be quite large if NUM_ACCESS_ELEMENTS is large.\n+    public static int REGION_SIZE = -1024;\n+    public static final int REGION_2_BYTE_OFFSET   = 1024 * 2; \/\/ prevent 4k-aliasing\n+    public static final int REGION_2_SHORT_OFFSET  = REGION_2_BYTE_OFFSET \/ 2;\n+    public static final int REGION_2_CHAR_OFFSET   = REGION_2_BYTE_OFFSET \/ 2;\n+    public static final int REGION_2_INT_OFFSET    = REGION_2_BYTE_OFFSET \/ 4;\n+    public static final int REGION_2_LONG_OFFSET   = REGION_2_BYTE_OFFSET \/ 8;\n+    public static final int REGION_2_FLOAT_OFFSET  = REGION_2_BYTE_OFFSET \/ 4;\n+    public static final int REGION_2_DOUBLE_OFFSET = REGION_2_BYTE_OFFSET \/ 8;\n+    \/\/ For Objects, it could be 4 or 8 bytes. Dividing by 8 gives us something\n+    \/\/ reasonable for both cases.\n+    public static final int REGION_2_OBJECT_OFFSET = REGION_2_BYTE_OFFSET \/ 8;\n+\n+    \/\/ The arrays with the two regions each\n+    private byte[] aB;\n+    private short[] aS;\n+    private char[] aC;\n+    private int[] aI;\n+    private long[] aL;\n+    private float[] aF;\n+    private double[] aD;\n+\n+    \/\/ Used when we need variable values in fill.\n+    private byte varB = 42;\n+    private short varS = 42;\n+    private char varC = 42;\n+    private int varI = 42;\n+    private long varL = 42;\n+    private float varF = 42;\n+    private double varD = 42;\n+\n+    \/\/ Classes for Object arrays.\n+    static class A {\n+        int x;\n+        A(int x) {\n+            this.x = x;\n+        }\n+    }\n+    static class B extends A {\n+        int y;\n+        B(int x, int y) {\n+            super(x);\n+            this.y = y;\n+        }\n+    }\n+    private A[] aOA;\n+    private B[] aOB;\n+    private A varOA = new A(-1);\n+    private B varOB = new B(-1, -1);\n+\n+    \/\/ Number of repetitions, to randomize the offsets.\n+    public static final int REPETITIONS = 64 * 64;\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int offsetLoad(int i) { return i & 63; } \/\/ bits 0-7, value from 0-63\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static int offsetStore(int i) { return (i >> 8) & 63; } \/\/ bits 8-15, value from 0-63\n+\n+    @Param(\"42\")\n+    private int seed;\n+    private Random r = new Random(seed);\n+\n+    public static int roundUp4k(int i) {\n+        return (i + 4*1024-1) & (-4*1024);\n+    }\n+\n+    @Setup\n+    public void init() {\n+        \/\/ Make sure we can fit the longs, and then some whiggle room for alignment.\n+        REGION_SIZE = roundUp4k(NUM_ACCESS_ELEMENTS * 8 + 1024 + REGION_2_BYTE_OFFSET);\n+        aB = new byte[2 * REGION_SIZE];\n+        aC = new char[2 * REGION_SIZE];\n+        aS = new short[2 * REGION_SIZE];\n+        aI = new int[2 * REGION_SIZE];\n+        aL = new long[2 * REGION_SIZE];\n+        aF = new float[2 * REGION_SIZE];\n+        aD = new double[2 * REGION_SIZE];\n+        aOA = new A[2 * REGION_SIZE];\n+        aOB = new B[2 * REGION_SIZE];\n+\n+        for (int i = 0; i < 2 * REGION_SIZE; i++) {\n+            aB[i] = (byte) r.nextInt();\n+            aS[i] = (short) r.nextInt();\n+            aC[i] = (char) r.nextInt();\n+            aI[i] = r.nextInt();\n+            aL[i] = r.nextLong();\n+            aF[i] = r.nextFloat();\n+            aD[i] = r.nextDouble();\n+            aOA[i] = switch (i % 4) {\n+                case 0, 1 -> new A(i);\n+                case 2    -> new B(i, i);\n+                default   -> null;\n+            };\n+            aOB[i] = (i % 3 != 0) ? new B(i, i) : null;\n+        }\n+    }\n+\n+    \/\/ -------------------------------- BYTE ------------------------------\n+\n+    @Benchmark\n+    public void fill_zero_byte_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aB[i + offset_store] = 0;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_byte_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aB[i + offset_store] = varB;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_zero_byte_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            Arrays.fill(aB, offset_store, offset_store + NUM_ACCESS_ELEMENTS, (byte)0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_byte_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            Arrays.fill(aB, offset_store, offset_store + NUM_ACCESS_ELEMENTS, varB);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_byte_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aB[i + offset_store] = aB[i + offset_load];\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_byte_system_arraycopy() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            System.arraycopy(aB, offset_load, aB, offset_store, NUM_ACCESS_ELEMENTS);\n+        }\n+    }\n+\n+    \/\/ -------------------------------- CHAR ------------------------------\n+\n+    @Benchmark\n+    public void fill_zero_char_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_CHAR_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aC[i + offset_store] = 0;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_char_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_CHAR_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aC[i + offset_store] = varC;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_zero_char_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_CHAR_OFFSET;\n+            Arrays.fill(aC, offset_store, offset_store + NUM_ACCESS_ELEMENTS, (char)0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_char_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_CHAR_OFFSET;\n+            Arrays.fill(aC, offset_store, offset_store + NUM_ACCESS_ELEMENTS, varC);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_char_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_CHAR_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aC[i + offset_store] = aC[i + offset_load];\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_char_system_arraycopy() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_CHAR_OFFSET;\n+            System.arraycopy(aC, offset_load, aC, offset_store, NUM_ACCESS_ELEMENTS);\n+        }\n+    }\n+\n+    \/\/ -------------------------------- SHORT ------------------------------\n+\n+    @Benchmark\n+    public void fill_zero_short_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_SHORT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aS[i + offset_store] = 0;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_short_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_SHORT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aS[i + offset_store] = varS;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_zero_short_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_SHORT_OFFSET;\n+            Arrays.fill(aS, offset_store, offset_store + NUM_ACCESS_ELEMENTS, (short)0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_short_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_SHORT_OFFSET;\n+            Arrays.fill(aS, offset_store, offset_store + NUM_ACCESS_ELEMENTS, varS);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_short_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_SHORT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aS[i + offset_store] = aS[i + offset_load];\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_short_system_arraycopy() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_SHORT_OFFSET;\n+            System.arraycopy(aS, offset_load, aS, offset_store, NUM_ACCESS_ELEMENTS);\n+        }\n+    }\n+\n+    \/\/ -------------------------------- INT ------------------------------\n+\n+    @Benchmark\n+    public void fill_zero_int_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_INT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aI[i + offset_store] = 0;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_int_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_INT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aI[i + offset_store] = varI;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_zero_int_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_INT_OFFSET;\n+            Arrays.fill(aI, offset_store, offset_store + NUM_ACCESS_ELEMENTS, (int)0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_int_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_INT_OFFSET;\n+            Arrays.fill(aI, offset_store, offset_store + NUM_ACCESS_ELEMENTS, varI);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_int_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_INT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aI[i + offset_store] = aI[i + offset_load];\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_int_system_arraycopy() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_INT_OFFSET;\n+            System.arraycopy(aI, offset_load, aI, offset_store, NUM_ACCESS_ELEMENTS);\n+        }\n+    }\n+\n+    \/\/ -------------------------------- LONG ------------------------------\n+\n+    @Benchmark\n+    public void fill_zero_long_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_LONG_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aL[i + offset_store] = 0;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_long_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_LONG_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aL[i + offset_store] = varL;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_zero_long_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_LONG_OFFSET;\n+            Arrays.fill(aL, offset_store, offset_store + NUM_ACCESS_ELEMENTS, (long)0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_long_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_LONG_OFFSET;\n+            Arrays.fill(aL, offset_store, offset_store + NUM_ACCESS_ELEMENTS, varL);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_long_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_LONG_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aL[i + offset_store] = aL[i + offset_load];\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_long_system_arraycopy() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_LONG_OFFSET;\n+            System.arraycopy(aL, offset_load, aL, offset_store, NUM_ACCESS_ELEMENTS);\n+        }\n+    }\n+\n+    \/\/ -------------------------------- FLOAT ------------------------------\n+\n+    @Benchmark\n+    public void fill_zero_float_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_FLOAT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aF[i + offset_store] = 0;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_float_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_FLOAT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aF[i + offset_store] = varF;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_zero_float_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_FLOAT_OFFSET;\n+            Arrays.fill(aF, offset_store, offset_store + NUM_ACCESS_ELEMENTS, (float)0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_float_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_FLOAT_OFFSET;\n+            Arrays.fill(aF, offset_store, offset_store + NUM_ACCESS_ELEMENTS, varF);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_float_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_FLOAT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aF[i + offset_store] = aF[i + offset_load];\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_float_system_arraycopy() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_FLOAT_OFFSET;\n+            System.arraycopy(aF, offset_load, aF, offset_store, NUM_ACCESS_ELEMENTS);\n+        }\n+    }\n+\n+    \/\/ -------------------------------- DOUBLE ------------------------------\n+\n+    @Benchmark\n+    public void fill_zero_double_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_DOUBLE_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aD[i + offset_store] = 0;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_double_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_DOUBLE_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aD[i + offset_store] = varD;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_zero_double_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_DOUBLE_OFFSET;\n+            Arrays.fill(aD, offset_store, offset_store + NUM_ACCESS_ELEMENTS, (double)0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_double_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_DOUBLE_OFFSET;\n+            Arrays.fill(aD, offset_store, offset_store + NUM_ACCESS_ELEMENTS, varD);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_double_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_DOUBLE_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aD[i + offset_store] = aD[i + offset_load];\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_double_system_arraycopy() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_DOUBLE_OFFSET;\n+            System.arraycopy(aD, offset_load, aD, offset_store, NUM_ACCESS_ELEMENTS);\n+        }\n+    }\n+\n+    \/\/ -------------------------------- OBJECT ------------------------------\n+\n+    @Benchmark\n+    public void fill_null_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_OBJECT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aOA[i + offset_store] = null;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_A2A_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_OBJECT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aOA[i + offset_store] = varOA;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_B2A_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_OBJECT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aOA[i + offset_store] = varOB;\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_null_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_OBJECT_OFFSET;\n+            Arrays.fill(aOA, offset_store, offset_store + NUM_ACCESS_ELEMENTS, null);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_A2A_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_OBJECT_OFFSET;\n+            Arrays.fill(aOA, offset_store, offset_store + NUM_ACCESS_ELEMENTS, varOA);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_B2A_arrays_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_OBJECT_OFFSET;\n+            Arrays.fill(aOA, offset_store, offset_store + NUM_ACCESS_ELEMENTS, varOB);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_A2A_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_OBJECT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aOA[i + offset_store] = aOA[i + offset_load];\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_B2A_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_OBJECT_OFFSET;\n+            for (int i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                aOA[i + offset_store] = aOB[i + offset_load];\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_A2A_system_arraycopy() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_OBJECT_OFFSET;\n+            System.arraycopy(aOA, offset_load, aOA, offset_store, NUM_ACCESS_ELEMENTS);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_B2A_system_arraycopy() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            int offset_load = offsetLoad(r);\n+            int offset_store = offsetStore(r) + REGION_SIZE + REGION_2_OBJECT_OFFSET;\n+            System.arraycopy(aOB, offset_load, aOA, offset_store, NUM_ACCESS_ELEMENTS);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorBulkOperationsArray.java","additions":700,"deletions":0,"binary":false,"changes":700,"status":"added"},{"patch":"@@ -0,0 +1,355 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+\n+import java.lang.foreign.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+import java.util.Arrays;\n+\n+\/**\n+ * This benchmark is here to measure vectorized peformance for some simple bulk operations:\n+ * - fill\n+ * - copy\n+ *\n+ * We may add more in the future, for example:\n+ * - comparison\n+ * - find index\n+ * - filter\n+ * - ...\n+ *\n+ * One important feature of this benchmark, is that we control for alignment and 4k-aliasing,\n+ * something almost no benchmarks have considered up to now. But it is important to get more\n+ * precise, clean and reliable results.\n+ *\n+ * Please also look at the companion benchmark:\n+ *   VectorBulkOperationsArray.java\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 5, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Fork(value = 1)\n+public class VectorBulkOperationsMemorySegment {\n+    @Param({  \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",  \"8\",  \"9\",\n+             \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n+             \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n+             \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n+             \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n+             \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n+             \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n+             \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n+             \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n+             \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\",\n+            \"100\",\"101\",\"102\",\"103\",\"104\",\"105\",\"106\",\"107\",\"108\",\"109\",\n+            \"110\",\"111\",\"112\",\"113\",\"114\",\"115\",\"116\",\"117\",\"118\",\"119\",\n+            \"120\",\"121\",\"122\",\"123\",\"124\",\"125\",\"126\",\"127\",\"128\",\"129\",\n+            \"130\",\"131\",\"132\",\"133\",\"134\",\"135\",\"136\",\"137\",\"138\",\"139\",\n+            \"140\",\"141\",\"142\",\"143\",\"144\",\"145\",\"146\",\"147\",\"148\",\"149\",\n+            \"150\",\"151\",\"152\",\"153\",\"154\",\"155\",\"156\",\"157\",\"158\",\"159\",\n+            \"160\",\"161\",\"162\",\"163\",\"164\",\"165\",\"166\",\"167\",\"168\",\"169\",\n+            \"170\",\"171\",\"172\",\"173\",\"174\",\"175\",\"176\",\"177\",\"178\",\"179\",\n+            \"180\",\"181\",\"182\",\"183\",\"184\",\"185\",\"186\",\"187\",\"188\",\"189\",\n+            \"190\",\"191\",\"192\",\"193\",\"194\",\"195\",\"196\",\"197\",\"198\",\"199\",\n+            \"200\",\"201\",\"202\",\"203\",\"204\",\"205\",\"206\",\"207\",\"208\",\"209\",\n+            \"210\",\"211\",\"212\",\"213\",\"214\",\"215\",\"216\",\"217\",\"218\",\"219\",\n+            \"220\",\"221\",\"222\",\"223\",\"224\",\"225\",\"226\",\"227\",\"228\",\"229\",\n+            \"230\",\"231\",\"232\",\"233\",\"234\",\"235\",\"236\",\"237\",\"238\",\"239\",\n+            \"240\",\"241\",\"242\",\"243\",\"244\",\"245\",\"246\",\"247\",\"248\",\"249\",\n+            \"250\",\"251\",\"252\",\"253\",\"254\",\"255\",\"256\",\"257\",\"258\",\"259\",\n+            \"260\",\"261\",\"262\",\"263\",\"264\",\"265\",\"266\",\"267\",\"268\",\"269\",\n+            \"270\",\"271\",\"272\",\"273\",\"274\",\"275\",\"276\",\"277\",\"278\",\"279\",\n+            \"280\",\"281\",\"282\",\"283\",\"284\",\"285\",\"286\",\"287\",\"288\",\"289\",\n+            \"290\",\"291\",\"292\",\"293\",\"294\",\"295\",\"296\",\"297\",\"298\",\"299\",\n+            \"300\"})\n+    public static long NUM_ACCESS_ELEMENTS;\n+\n+    @Param({\"native\", \"array_byte\", \"array_int\", \"array_long\"})\n+    public static String BACKING_TYPE;\n+\n+    \/\/ Every array has two regions:\n+    \/\/ - read region\n+    \/\/ - write region\n+    \/\/ We should make sure that the region is a multiple of 4k, so that the\n+    \/\/ 4k-aliasing prevention trick can work.\n+    \/\/\n+    \/\/ It would be ince to set REGION_SIZE statically, but we want to keep it rather small if possible,\n+    \/\/ to avoid running out of cache. But it might be quite large if NUM_ACCESS_ELEMENTS is large.\n+    public static long REGION_SIZE = -1024;\n+    public static final long REGION_2_BYTE_OFFSET   = 1024 * 2; \/\/ prevent 4k-aliasing\n+\n+    \/\/ TDOO: see what is still actie up here.\n+\n+    \/\/ Just one MemorySegment for all cases, backed by whatever BACKING_TYPE.\n+    MemorySegment ms;\n+\n+    \/\/ Used when we need variable values in fill.\n+    private byte varB = 42;\n+    private short varS = 42;\n+    private char varC = 42;\n+    private int varI = 42;\n+    private long varL = 42;\n+    private float varF = 42;\n+    private double varD = 42;\n+\n+    \/\/ Number of repetitions, to randomize the offsets.\n+    public static final int REPETITIONS = 64 * 64;\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long offsetLoad(long i) { return i & 63; } \/\/ bits 0-7, value from 0-63\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    public static long offsetStore(long i) { return (i >> 8) & 63; } \/\/ bits 8-15, value from 0-63\n+\n+    @Param(\"42\")\n+    private int seed;\n+    private Random r = new Random(seed);\n+\n+    public static long roundUp4k(long i) {\n+        return (i + 4*1024-1) & (-4*1024L);\n+    }\n+\n+    @Setup\n+    public void init() {\n+        \/\/ Make sure we can fit the longs, and then some whiggle room for alignment.\n+        REGION_SIZE = roundUp4k(NUM_ACCESS_ELEMENTS * 8 + 1024 + REGION_2_BYTE_OFFSET);\n+        ms = switch(BACKING_TYPE) {\n+            case \"native\"     -> Arena.ofAuto().allocate(2 * REGION_SIZE, 4 * 1024);\n+            case \"array_byte\" -> MemorySegment.ofArray(new byte[(int)(2 * REGION_SIZE)]);\n+            case \"array_int\"  -> MemorySegment.ofArray(new int[(int)(2 * REGION_SIZE \/ 4)]);\n+            case \"array_long\" -> MemorySegment.ofArray(new long[(int)(2 * REGION_SIZE \/ 8)]);\n+            default -> throw new RuntimeException(\"not implemented: \" + BACKING_TYPE);\n+        };\n+    }\n+\n+    \/\/ -------------------------------- BYTE ------------------------------\n+\n+    @Benchmark\n+    public void fill_zero_byte_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_store = offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                ms.set(ValueLayout.JAVA_BYTE, i + offset_store, (byte)0);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_byte_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_store = offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                ms.set(ValueLayout.JAVA_BYTE, i + offset_store, varB);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_zero_byte_MS_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_store = offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            \/\/ The API does not allow us to fill a sub-segment directly, so we have to slice.\n+            MemorySegment slice = ms.asSlice(offset_store, NUM_ACCESS_ELEMENTS);\n+            slice.fill((byte)0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void fill_var_byte_MS_fill() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_store = offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            \/\/ The API does not allow us to fill a sub-segment directly, so we have to slice.\n+            MemorySegment slice = ms.asSlice(offset_store, NUM_ACCESS_ELEMENTS);\n+            slice.fill(varB);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_byte_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_load = offsetLoad(r);\n+            long offset_store = offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                byte v = ms.get(ValueLayout.JAVA_BYTE, i + offset_load);\n+                ms.set(ValueLayout.JAVA_BYTE, i + offset_store, v);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_byte_MemorySegment_copy() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_load = offsetLoad(r);\n+            long offset_store = offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            MemorySegment.copy(ms, offset_load, ms, offset_store, NUM_ACCESS_ELEMENTS);\n+        }\n+    }\n+\n+    \/\/ -------------------------------- CHAR ------------------------------\n+\n+    @Benchmark\n+    public void fill_var_char_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_store = 2L * offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                ms.set(ValueLayout.JAVA_CHAR_UNALIGNED, 2L * i + offset_store, varC);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_char_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_load = 2L * offsetLoad(r);\n+            long offset_store = 2L * offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                char v = ms.get(ValueLayout.JAVA_CHAR_UNALIGNED, 2L * i + offset_load);\n+                ms.set(ValueLayout.JAVA_CHAR_UNALIGNED, 2L * i + offset_store, v);\n+            }\n+        }\n+    }\n+\n+    \/\/ -------------------------------- SHORT ------------------------------\n+\n+    @Benchmark\n+    public void fill_var_short_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_store = 2L * offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                ms.set(ValueLayout.JAVA_SHORT_UNALIGNED, 2L * i + offset_store, varS);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_short_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_load = 2L * offsetLoad(r);\n+            long offset_store = 2L * offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                short v = ms.get(ValueLayout.JAVA_SHORT_UNALIGNED, 2L * i + offset_load);\n+                ms.set(ValueLayout.JAVA_SHORT_UNALIGNED, 2L * i + offset_store, v);\n+            }\n+        }\n+    }\n+\n+    \/\/ -------------------------------- INT ------------------------------\n+\n+    @Benchmark\n+    public void fill_var_int_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_store = 4L * offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                ms.set(ValueLayout.JAVA_INT_UNALIGNED, 4L * i + offset_store, varI);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_int_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_load = 4L * offsetLoad(r);\n+            long offset_store = 4L * offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                int v = ms.get(ValueLayout.JAVA_INT_UNALIGNED, 4L * i + offset_load);\n+                ms.set(ValueLayout.JAVA_INT_UNALIGNED, 4L * i + offset_store, v);\n+            }\n+        }\n+    }\n+\n+    \/\/ -------------------------------- LONG ------------------------------\n+\n+    @Benchmark\n+    public void fill_var_long_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_store = 8L * offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                ms.set(ValueLayout.JAVA_LONG_UNALIGNED, 8L * i + offset_store, varL);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_long_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_load = 8L * offsetLoad(r);\n+            long offset_store = 8L * offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                long v = ms.get(ValueLayout.JAVA_LONG_UNALIGNED, 8L * i + offset_load);\n+                ms.set(ValueLayout.JAVA_LONG_UNALIGNED, 8L * i + offset_store, v);\n+            }\n+        }\n+    }\n+\n+    \/\/ -------------------------------- FLOAT ------------------------------\n+\n+    @Benchmark\n+    public void fill_var_float_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_store = 4L * offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                ms.set(ValueLayout.JAVA_FLOAT_UNALIGNED, 4L * i + offset_store, varS);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_float_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_load = 4L * offsetLoad(r);\n+            long offset_store = 4L * offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                float v = ms.get(ValueLayout.JAVA_FLOAT_UNALIGNED, 4L * i + offset_load);\n+                ms.set(ValueLayout.JAVA_FLOAT_UNALIGNED, 4L * i + offset_store, v);\n+            }\n+        }\n+    }\n+\n+    \/\/ -------------------------------- DOUBLE ------------------------------\n+\n+    @Benchmark\n+    public void fill_var_double_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_store = 8L * offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                ms.set(ValueLayout.JAVA_DOUBLE_UNALIGNED, 8L * i + offset_store, varS);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void copy_double_loop() {\n+        for (int r = 0; r < REPETITIONS; r++) {\n+            long offset_load = 8L * offsetLoad(r);\n+            long offset_store = 8L * offsetStore(r) + REGION_SIZE + REGION_2_BYTE_OFFSET;\n+            for (long i = 0; i < NUM_ACCESS_ELEMENTS; i++) {\n+                double v = ms.get(ValueLayout.JAVA_DOUBLE_UNALIGNED, 8L * i + offset_load);\n+                ms.set(ValueLayout.JAVA_DOUBLE_UNALIGNED, 8L * i + offset_store, v);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorBulkOperationsMemorySegment.java","additions":355,"deletions":0,"binary":false,"changes":355,"status":"added"}]}