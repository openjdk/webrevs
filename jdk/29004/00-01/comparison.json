{"files":[{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.sun.misc;\n+\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import javax.imageio.ImageIO;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageConsumer;\n+import java.awt.image.IndexColorModel;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.Hashtable;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 20)\n+@Fork(3)\n+@State(Scope.Thread)\n+public class PNGImageDecoder_8bit_uninterlaced {\n+\n+    byte[] pngImageData;\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        pngImageData = createImageData(2_500);\n+\n+        \/\/ verify correctness:\n+        BufferedImage expected = ImageIO.read(\n+                new ByteArrayInputStream(pngImageData));\n+        Image img = Toolkit.getDefaultToolkit().createImage(pngImageData);\n+        BufferedImage actual = createBufferedImage(img);\n+        testCorrectness(expected, actual);\n+    }\n+\n+    @Benchmark\n+    public void measurePNGImageDecoder(Blackhole bh) throws Exception {\n+        Image img = Toolkit.getDefaultToolkit().createImage(pngImageData);\n+        BufferedImage bi = createBufferedImage(img);\n+        bi.flush();\n+        bh.consume(bi);\n+    }\n+\n+    \/**\n+     * Create a large sample image stored as an 8-bit PNG.\n+     *\n+     * @return the byte representation of the PNG image.\n+     *\/\n+    private static byte[] createImageData(int squareSize) throws Exception {\n+        BufferedImage bi = new BufferedImage(squareSize, squareSize,\n+                BufferedImage.TYPE_BYTE_INDEXED);\n+        Random r = new Random(0);\n+        Graphics2D g = bi.createGraphics();\n+        for (int a = 0; a < 20000; a++) {\n+            g.setColor(new Color(r.nextInt(0xffffff)));\n+            int radius = 10 + r.nextInt(90);\n+            g.fillOval(r.nextInt(bi.getWidth()), r.nextInt(bi.getHeight()),\n+                    radius, radius);\n+        }\n+        g.dispose();\n+\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+            ImageIO.write(bi, \"png\", out);\n+            return out.toByteArray();\n+        }\n+    }\n+\n+    static BufferedImage createBufferedImage(Image img)\n+            throws ExecutionException, InterruptedException {\n+        CompletableFuture<BufferedImage> future = new CompletableFuture<>();\n+        img.getSource().startProduction(new ImageConsumer() {\n+            private int imageWidth, imageHeight;\n+            private BufferedImage bi;\n+\n+            @Override\n+            public void setDimensions(int width, int height) {\n+                imageWidth = width;\n+                imageHeight = height;\n+            }\n+\n+            @Override\n+            public void setProperties(Hashtable<?, ?> props) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setColorModel(ColorModel model) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setHints(int hintflags) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  byte[] pixels, int off, int scansize) {\n+                if (bi == null) {\n+                    bi = new BufferedImage(imageWidth, imageHeight,\n+                            BufferedImage.TYPE_BYTE_INDEXED,\n+                            (IndexColorModel) model);\n+                }\n+                if (h != 1)\n+                    throw new UnsupportedOperationException(\n+                            \"this test expects sequential rows of pixels\");\n+                if (off != 0)\n+                    throw new UnsupportedOperationException(\n+                            \"this test expects the incoming pixels to start \" +\n+                                    \"at index zero\");\n+\n+                bi.getRaster().setDataElements(x, y, w, 1, pixels);\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  int[] pixels, int off, int scansize) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public void imageComplete(int status) {\n+                future.complete(bi);\n+            }\n+        });\n+        return future.get();\n+    }\n+\n+    \/**\n+     * This unit test is intended to accompany a performance enhancement for\n+     * PNGImageDecoder. This method makes sure the enhancement didn't cost us\n+     * any accuracy.\n+     *\/\n+    private static void testCorrectness(BufferedImage expected,\n+                                        BufferedImage actual) {\n+        if (expected.getWidth() != actual.getWidth())\n+            throw new Error();\n+        if (expected.getHeight() != actual.getHeight())\n+            throw new Error();\n+        for (int y = 0; y < expected.getHeight(); y++) {\n+            for (int x = 0; x < expected.getWidth(); x++) {\n+                int argb1 = expected.getRGB(x, y);\n+                int argb2 = actual.getRGB(x, y);\n+                if (argb1 != argb2) {\n+                    throw new Error(\"x = \" + x + \", y = \" + y);\n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/sun\/awt\/image\/PNGImageDecoder_8bit_uninterlaced.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"}]}