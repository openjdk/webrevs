{"files":[{"patch":"@@ -1,248 +0,0 @@\n-\/*\n- * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8374377\n- * @summary This test confirms the PNGImageProducer decodes 8-bit interlaced\n- * and non-interlaced PNGs correctly.\n- *\/\n-\n-import javax.imageio.IIOImage;\n-import javax.imageio.ImageIO;\n-import javax.imageio.ImageWriteParam;\n-import javax.imageio.ImageWriter;\n-import javax.imageio.stream.ImageOutputStream;\n-import java.awt.Color;\n-import java.awt.Graphics2D;\n-import java.awt.Image;\n-import java.awt.Toolkit;\n-import java.awt.image.BufferedImage;\n-import java.awt.image.ColorModel;\n-import java.awt.image.ImageConsumer;\n-import java.awt.image.IndexColorModel;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.InputStream;\n-import java.util.Hashtable;\n-import java.util.Iterator;\n-import java.util.Random;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-\n-\/**\n- * The proposed change for 8374377 affects how 8-bit PNGs are decoded.\n- * So this test confirms that 8-bit PNGs (both interlaced and non-interlaced)\n- * are still decoded by the PNGImageDecoder so they match what ImageIO decodes.\n- *\n- * This test has never failed.\n- *\/\n-public class PNGImageDecoder_8bit_performance {\n-\n-    interface Model {\n-        BufferedImage load(byte[] imagedata) throws Exception;\n-    }\n-\n-    \/**\n-     * This creates a BufferedImage using ImageIO.\n-     *\/\n-    static class ImageIOModel implements Model {\n-\n-        @Override\n-        public BufferedImage load(byte[] imagedata) throws Exception {\n-            try (InputStream in = new ByteArrayInputStream(imagedata)) {\n-                return ImageIO.read(in);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * This creates a BufferedImage using an ImageConsumer and ImageProducer.\n-     *\/\n-    static class ImageConsumerModel implements Model {\n-\n-        @Override\n-        public BufferedImage load(byte[] imagedata) throws Exception {\n-            Image img = Toolkit.getDefaultToolkit().createImage(imagedata);\n-            return createBufferedImage(img);\n-        }\n-    }\n-\n-    static BufferedImage createBufferedImage(Image img)\n-            throws ExecutionException, InterruptedException {\n-        CompletableFuture<BufferedImage> future = new CompletableFuture<>();\n-        img.getSource().startProduction(new ImageConsumer() {\n-            private int imageWidth, imageHeight;\n-            private BufferedImage bi;\n-\n-            @Override\n-            public void setDimensions(int width, int height) {\n-                imageWidth = width;\n-                imageHeight = height;\n-            }\n-\n-            @Override\n-            public void setProperties(Hashtable<?, ?> props) {\n-                \/\/ intentionally empty\n-            }\n-\n-            @Override\n-            public void setColorModel(ColorModel model) {\n-                \/\/ intentionally empty\n-            }\n-\n-            @Override\n-            public void setHints(int hintflags) {\n-                \/\/ intentionally empty\n-            }\n-\n-            @Override\n-            public void setPixels(int x, int y, int w, int h, ColorModel model,\n-                                  byte[] pixels, int off, int scansize) {\n-                if (bi == null) {\n-                    bi = new BufferedImage(imageWidth, imageHeight,\n-                            BufferedImage.TYPE_BYTE_INDEXED,\n-                            (IndexColorModel) model);\n-                }\n-\n-                if (w == imageWidth && h == imageHeight) {\n-                    \/\/ this is how interlaced PNGs are decoded:\n-                    bi.getRaster().setDataElements(0, 0,\n-                            imageWidth, imageHeight, pixels);\n-                    return;\n-                }\n-\n-                if (h != 1) {\n-                    throw new UnsupportedOperationException(\n-                            \"this test requires h = 1\");\n-                }\n-                if (off != 0) {\n-                    throw new UnsupportedOperationException(\n-                            \"this test requires off = 0\");\n-                }\n-\n-                bi.getRaster().setDataElements(x, y, w, 1, pixels);\n-            }\n-\n-            @Override\n-            public void setPixels(int x, int y, int w, int h, ColorModel model,\n-                                  int[] pixels, int off, int scansize) {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            public void imageComplete(int status) {\n-                future.complete(bi);\n-            }\n-        });\n-        return future.get();\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        Model[] models = new Model[]{\n-                new ImageIOModel(),\n-                new ImageConsumerModel()\n-        };\n-\n-        for (boolean interlace : new boolean[] { false, true} ) {\n-            System.out.println(\"Testing interlacing = \"+ interlace);\n-            byte[] imageData = createImageData(6000, interlace);\n-\n-            BufferedImage expected = models[0].load(imageData);\n-            BufferedImage actual = models[1].load(imageData);\n-\n-            testCorrectness(expected, actual);\n-        }\n-        System.out.println(\"Confirmed that 8-bit PNGs render correctly \" +\n-                \"whether we use ImageIO or ImageConsumers. We tested both \" +\n-                \"an interlaced and an non-interlaced PNG image.\");\n-    }\n-\n-    \/**\n-     * Create a large sample image stored as an 8-bit PNG.\n-     *\n-     * @return the byte representation of the PNG image.\n-     *\/\n-    private static byte[] createImageData(int squareSize,\n-                                          boolean interlace) throws Exception {\n-        BufferedImage bi = new BufferedImage(squareSize, squareSize,\n-                BufferedImage.TYPE_BYTE_INDEXED);\n-        Random r = new Random(0);\n-        Graphics2D g = bi.createGraphics();\n-        for (int a = 0; a < 20000; a++) {\n-            g.setColor(new Color(r.nextInt(0xffffff)));\n-            int radius = 10 + r.nextInt(90);\n-            g.fillOval(r.nextInt(bi.getWidth()), r.nextInt(bi.getHeight()),\n-                    radius, radius);\n-        }\n-        g.dispose();\n-\n-        Iterator<ImageWriter> writers =\n-                ImageIO.getImageWritersByFormatName(\"png\");\n-        if (!writers.hasNext()) {\n-            throw new IllegalStateException(\"No PNG writers found\");\n-        }\n-        ImageWriter writer = writers.next();\n-\n-        ImageWriteParam param = writer.getDefaultWriteParam();\n-        if (interlace) {\n-            param.setProgressiveMode(ImageWriteParam.MODE_DEFAULT);\n-        }\n-\n-        try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n-             ImageOutputStream imageOut =\n-                     ImageIO.createImageOutputStream(byteOut)) {\n-            writer.setOutput(imageOut);\n-            writer.write(null, new IIOImage(bi, null, null), param);\n-            return byteOut.toByteArray();\n-        } finally {\n-            writer.dispose();\n-        }\n-    }\n-\n-    \/**\n-     * This throws an Error if the two images are not identical.\n-     * <p>\n-     * This unit test is intended to accompany a performance enhancement for\n-     * PNGImageDecoder. This method makes sure the enhancement didn't cost us\n-     * any accuracy.\n-     *\/\n-    private static void testCorrectness(BufferedImage expected,\n-                                        BufferedImage actual) {\n-        if (expected.getWidth() != actual.getWidth()) {\n-            throw new Error();\n-        }\n-        if (expected.getHeight() != actual.getHeight()) {\n-            throw new Error();\n-        }\n-        for (int y = 0; y < expected.getHeight(); y++) {\n-            for (int x = 0; x < expected.getWidth(); x++) {\n-                int argb1 = expected.getRGB(x, y);\n-                int argb2 = actual.getRGB(x, y);\n-                if (argb1 != argb2) {\n-                    throw new Error(\"x = \" + x + \", y = \" + y);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/awt\/image\/png\/PNGImageDecoder_8bit_performance.java","additions":0,"deletions":248,"binary":false,"changes":248,"status":"deleted"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8374377\n+ * @summary This test confirms the PNGImageProducer decodes 8-bit interlaced\n+ * and non-interlaced PNGs correctly.\n+ *\/\n+\n+import javax.imageio.IIOImage;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageWriteParam;\n+import javax.imageio.ImageWriter;\n+import javax.imageio.stream.ImageOutputStream;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageConsumer;\n+import java.awt.image.IndexColorModel;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+\/**\n+ * The proposed change for 8374377 affects how 8-bit PNGs are decoded.\n+ * So this test confirms that 8-bit PNGs (both interlaced and non-interlaced)\n+ * are still decoded by the PNGImageDecoder so they match what ImageIO decodes.\n+ *\n+ * This test has never failed.\n+ *\/\n+public class PngImageDecoder8BitTest {\n+\n+    static BufferedImage createBufferedImage(Image img)\n+            throws ExecutionException, InterruptedException {\n+        CompletableFuture<BufferedImage> future = new CompletableFuture<>();\n+        img.getSource().startProduction(new ImageConsumer() {\n+            private int imageWidth, imageHeight;\n+            private BufferedImage bi;\n+\n+            @Override\n+            public void setDimensions(int width, int height) {\n+                imageWidth = width;\n+                imageHeight = height;\n+            }\n+\n+            @Override\n+            public void setProperties(Hashtable<?, ?> props) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setColorModel(ColorModel model) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setHints(int hintflags) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  byte[] pixels, int off, int scansize) {\n+                if (bi == null) {\n+                    bi = new BufferedImage(imageWidth, imageHeight,\n+                            BufferedImage.TYPE_BYTE_INDEXED,\n+                            (IndexColorModel) model);\n+                }\n+\n+                if (w == imageWidth && h == imageHeight) {\n+                    \/\/ this is how interlaced PNGs are decoded:\n+                    bi.getRaster().setDataElements(0, 0,\n+                            imageWidth, imageHeight, pixels);\n+                    return;\n+                }\n+\n+                if (h != 1) {\n+                    throw new UnsupportedOperationException(\n+                            \"this test requires h = 1\");\n+                }\n+                if (off != 0) {\n+                    throw new UnsupportedOperationException(\n+                            \"this test requires off = 0\");\n+                }\n+\n+                bi.getRaster().setDataElements(x, y, w, 1, pixels);\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  int[] pixels, int off, int scansize) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public void imageComplete(int status) {\n+                future.complete(bi);\n+            }\n+        });\n+        return future.get();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        BufferedImage expected = createImageData();\n+        for (boolean interlace : new boolean[] { false, true} ) {\n+            System.out.println(\"Testing interlacing = \"+ interlace);\n+            byte[] imageData = encodePNG(expected, interlace);\n+\n+            Image i = Toolkit.getDefaultToolkit().createImage(imageData);\n+            BufferedImage actual = createBufferedImage(i);\n+\n+            testCorrectness(expected, actual);\n+        }\n+        System.out.println(\"Confirmed that 8-bit PNGs decode correctly \" +\n+                \"whether we use interlacing or not.\");\n+    }\n+\n+    \/**\n+     * Create a large sample image stored as an 8-bit PNG.\n+     *\/\n+    private static BufferedImage createImageData() {\n+        BufferedImage bi = new BufferedImage(6000, 6000,\n+                BufferedImage.TYPE_BYTE_INDEXED);\n+        Random r = new Random(0);\n+        Graphics2D g = bi.createGraphics();\n+        for (int a = 0; a < 20000; a++) {\n+            g.setColor(new Color(r.nextInt(0xffffff)));\n+            int radius = 10 + r.nextInt(90);\n+            g.fillOval(r.nextInt(bi.getWidth()), r.nextInt(bi.getHeight()),\n+                    radius, radius);\n+        }\n+        g.dispose();\n+        return bi;\n+    }\n+\n+    \/**\n+     * Encode an image as 8-bit PNG.\n+     *\/\n+    private static byte[] encodePNG(BufferedImage bi, boolean interlace)\n+            throws IOException {\n+        Iterator<ImageWriter> writers =\n+                ImageIO.getImageWritersByFormatName(\"png\");\n+        if (!writers.hasNext()) {\n+            throw new IllegalStateException(\"No PNG writers found\");\n+        }\n+        ImageWriter writer = writers.next();\n+\n+        ImageWriteParam param = writer.getDefaultWriteParam();\n+        if (interlace) {\n+            param.setProgressiveMode(ImageWriteParam.MODE_DEFAULT);\n+        }\n+\n+        try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+             ImageOutputStream imageOut =\n+                     ImageIO.createImageOutputStream(byteOut)) {\n+            writer.setOutput(imageOut);\n+            writer.write(null, new IIOImage(bi, null, null), param);\n+            return byteOut.toByteArray();\n+        } finally {\n+            writer.dispose();\n+        }\n+    }\n+\n+    \/**\n+     * This throws an Error if the two images are not identical.\n+     * <p>\n+     * This unit test is intended to accompany a performance enhancement for\n+     * PNGImageDecoder. This method makes sure the enhancement didn't cost us\n+     * any accuracy.\n+     *\/\n+    private static void testCorrectness(BufferedImage expected,\n+                                        BufferedImage actual) {\n+        if (expected.getWidth() != actual.getWidth()) {\n+            throw new RuntimeException(\"expected.getWidth() = \" +\n+                    expected.getWidth() + \", actual.getWidth() = \" +\n+                    actual.getWidth());\n+        }\n+        if (expected.getHeight() != actual.getHeight()) {\n+            throw new RuntimeException(\"expected.getHeight() = \" +\n+                    expected.getHeight() + \", actual.getHeight() = \" +\n+                    actual.getHeight());\n+        }\n+        for (int y = 0; y < expected.getHeight(); y++) {\n+            for (int x = 0; x < expected.getWidth(); x++) {\n+                int argb1 = expected.getRGB(x, y);\n+                int argb2 = actual.getRGB(x, y);\n+                if (argb1 != argb2) {\n+                    throw new RuntimeException(\"x = \" + x + \", y = \" + y +\n+                            \" argb1 = \" + Integer.toUnsignedString(argb1, 16) +\n+                            \" argb2 = \" + Integer.toUnsignedString(argb2, 16));\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/png\/PngImageDecoder8BitTest.java","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -23,1 +23,1 @@\n-package org.openjdk.bench.sun.misc;\n+package org.openjdk.bench.sun.awt.image;\n@@ -26,0 +26,1 @@\n+import org.openjdk.jmh.annotations.Benchmark;\n@@ -31,0 +32,1 @@\n+import org.openjdk.jmh.annotations.Setup;\n@@ -65,7 +67,0 @@\n-\n-        \/\/ verify correctness:\n-        BufferedImage expected = ImageIO.read(\n-                new ByteArrayInputStream(pngImageData));\n-        Image img = Toolkit.getDefaultToolkit().createImage(pngImageData);\n-        BufferedImage actual = createBufferedImage(img);\n-        testCorrectness(expected, actual);\n@@ -166,22 +161,0 @@\n-\n-    \/**\n-     * This unit test is intended to accompany a performance enhancement for\n-     * PNGImageDecoder. This method makes sure the enhancement didn't cost us\n-     * any accuracy.\n-     *\/\n-    private static void testCorrectness(BufferedImage expected,\n-                                        BufferedImage actual) {\n-        if (expected.getWidth() != actual.getWidth())\n-            throw new Error();\n-        if (expected.getHeight() != actual.getHeight())\n-            throw new Error();\n-        for (int y = 0; y < expected.getHeight(); y++) {\n-            for (int x = 0; x < expected.getWidth(); x++) {\n-                int argb1 = expected.getRGB(x, y);\n-                int argb2 = actual.getRGB(x, y);\n-                if (argb1 != argb2) {\n-                    throw new Error(\"x = \" + x + \", y = \" + y);\n-                }\n-            }\n-        }\n-    }\n","filename":"test\/micro\/org\/openjdk\/bench\/sun\/awt\/image\/PNGImageDecoder_8bit_uninterlaced.java","additions":3,"deletions":30,"binary":false,"changes":33,"status":"modified"}]}