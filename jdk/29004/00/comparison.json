{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,2 +305,10 @@\n-            if(interlaceMethod==0) { pass = -1; passLimit = 0; }\n-            else { pass = 0; passLimit = 7; }\n+            boolean isDirectByteCopy;\n+            if(interlaceMethod==0) {\n+                pass = -1;\n+                passLimit = 0;\n+                isDirectByteCopy = bPixels != null && bitDepth == 8;\n+            } else {\n+                pass = 0;\n+                passLimit = 7;\n+                isDirectByteCopy = false;\n+            }\n@@ -337,1 +345,5 @@\n-                        if(wPixels !=null) {\n+                        if (isDirectByteCopy) {\n+                            System.arraycopy(rowByteBuffer, spos, bPixels, col + rowOffset, width);\n+                            spos += width;\n+                            break;\n+                        } else if(wPixels !=null) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/PNGImageDecoder.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,275 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8374377\n+ * @summary This test makes sure the PNGImageProducer performs comparable to\n+ * ImageIO when reading an 8-bit non-interlaced png.\n+ *\/\n+\n+import javax.imageio.ImageIO;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageConsumer;\n+import java.awt.image.IndexColorModel;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.Hashtable;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+\/**\n+ * This test makes sure an 8-bit PNG image is converted into a BufferedImage\n+ * in approximately the same amount of time whether we use ImageIO or\n+ * an ImageConsumer\/ImageProducer.\n+ *\/\n+public class PNGImageDecoder_8bit_performance {\n+\n+    interface Model {\n+        BufferedImage load(byte[] imagedata) throws Exception;\n+    }\n+\n+    \/**\n+     * This creates a BufferedImage using ImageIO.\n+     *\/\n+    static class ImageIOModel implements Model {\n+\n+        @Override\n+        public BufferedImage load(byte[] imagedata) throws Exception {\n+            try (InputStream in = new ByteArrayInputStream(imagedata)) {\n+                return ImageIO.read(in);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * This creates a BufferedImage using an ImageConsumer and ImageProducer.\n+     *\/\n+    static class ImageConsumerModel implements Model {\n+\n+        @Override\n+        public BufferedImage load(byte[] imagedata) throws Exception {\n+            Image img = Toolkit.getDefaultToolkit().createImage(imagedata);\n+            return createBufferedImage(img);\n+        }\n+    }\n+\n+    static BufferedImage createBufferedImage(Image img)\n+            throws ExecutionException, InterruptedException {\n+        CompletableFuture<BufferedImage> future = new CompletableFuture<>();\n+        img.getSource().startProduction(new ImageConsumer() {\n+            private int imageWidth, imageHeight;\n+            private BufferedImage bi;\n+\n+            @Override\n+            public void setDimensions(int width, int height) {\n+                imageWidth = width;\n+                imageHeight = height;\n+            }\n+\n+            @Override\n+            public void setProperties(Hashtable<?, ?> props) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setColorModel(ColorModel model) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setHints(int hintflags) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  byte[] pixels, int off, int scansize) {\n+                if (bi == null) {\n+                    bi = new BufferedImage(imageWidth, imageHeight,\n+                            BufferedImage.TYPE_BYTE_INDEXED,\n+                            (IndexColorModel) model);\n+                }\n+                if (h != 1) {\n+                    throw new UnsupportedOperationException(\n+                            \"this test requires h = 1\");\n+                }\n+                if (off != 0) {\n+                    throw new UnsupportedOperationException(\n+                            \"this test requires off = 0\");\n+                }\n+\n+                bi.getRaster().setDataElements(x, y, w, 1, pixels);\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  int[] pixels, int off, int scansize) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public void imageComplete(int status) {\n+                future.complete(bi);\n+            }\n+        });\n+        return future.get();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int squareSize = 4_000; squareSize <= 10_000;\n+             squareSize += 2_000) {\n+            byte[] imagedata = createImageData(squareSize);\n+\n+            Model[] models = new Model[]{\n+                    new ImageIOModel(),\n+                    new ImageConsumerModel()\n+            };\n+\n+            BufferedImage expected = models[0].load(imagedata);\n+            BufferedImage actual = models[1].load(imagedata);\n+\n+            testCorrectness(expected, actual);\n+\n+            \/\/ both of these constants are arbitrary. IMO they help demonstrate\n+            \/\/ the problem with reasonable accuracy & without excess waiting\n+\n+            \/\/ run our test sampleCount-many times, and only report the median:\n+            int sampleCount = 7;\n+\n+            \/\/ each sample creates the image loopCount-many times\n+            int loopCount = 10;\n+\n+            long[][] samples = new long[models.length][sampleCount];\n+            for (int sampleIndex = 0; sampleIndex < sampleCount;\n+                 sampleIndex++) {\n+                for (int modelIndex = 0; modelIndex < models.length;\n+                     modelIndex++) {\n+\n+                    long t = System.currentTimeMillis();\n+                    for (int b = 0; b < loopCount; b++) {\n+                        models[modelIndex].load(imagedata).flush();\n+                    }\n+                    t = System.currentTimeMillis() - t;\n+                    samples[modelIndex][sampleIndex] = t;\n+                }\n+            }\n+            long[] results = new long[models.length];\n+            long firstMedian = -1;\n+            for (int modelIndex = 0; modelIndex < models.length;\n+                 modelIndex++) {\n+                long[] modelSamples = samples[modelIndex];\n+                Arrays.sort(modelSamples);\n+                long median = modelSamples[modelSamples.length \/ 2];\n+                results[modelIndex] = median;\n+            }\n+\n+            System.out.println();\n+            System.out.println(\"Square Size\\t%\\tImageIOModel\\t\" +\n+                    \"ImageConsumerModel\");\n+\n+            StringBuilder sb = new StringBuilder(Integer.toString(squareSize));\n+            int imageConsumerPercentRelImageIO = Math.round(\n+                    results[1] * 100f \/ results[0]);\n+            sb.append(\"\\t\" + imageConsumerPercentRelImageIO);\n+\n+            for (int a = 0; a < results.length; a++) {\n+                sb.append(\"\\t\" + results[a]);\n+            }\n+\n+            System.out.println(sb);\n+\n+            System.out.println(\"The ImageConsumer approach took \" +\n+                    imageConsumerPercentRelImageIO + \"% of the time the \" +\n+                    \"ImageIO approach took.\");\n+\n+            \/\/ in my tests the MINIMUM percent that we saw before this\n+            \/\/ enhancement was 109.9% and the MAXIMUM we saw after this\n+            \/\/ enhancement was 104.4%, so a midway point is 107%. We should\n+            \/\/ always be under 107%\n+\n+            if (imageConsumerPercentRelImageIO > 107) {\n+                throw new Error(\"The ImageConsumer model should always take \" +\n+                        \"close to 100% of what the ImageIO model takes.\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Create a large sample image stored as an 8-bit PNG.\n+     *\n+     * @return the byte representation of the PNG image.\n+     *\/\n+    private static byte[] createImageData(int squareSize) throws Exception {\n+        BufferedImage bi = new BufferedImage(squareSize, squareSize,\n+                BufferedImage.TYPE_BYTE_INDEXED);\n+        Random r = new Random(0);\n+        Graphics2D g = bi.createGraphics();\n+        for (int a = 0; a < 20000; a++) {\n+            g.setColor(new Color(r.nextInt(0xffffff)));\n+            int radius = 10 + r.nextInt(90);\n+            g.fillOval(r.nextInt(bi.getWidth()), r.nextInt(bi.getHeight()),\n+                    radius, radius);\n+        }\n+        g.dispose();\n+\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+            ImageIO.write(bi, \"png\", out);\n+            return out.toByteArray();\n+        }\n+    }\n+\n+    \/**\n+     * This throws an Error if the two images are not identical.\n+     * <p>\n+     * This unit test is intended to accompany a performance enhancement for\n+     * PNGImageDecoder. This method makes sure the enhancement didn't cost us\n+     * any accuracy.\n+     *\/\n+    private static void testCorrectness(BufferedImage expected,\n+                                        BufferedImage actual) {\n+        if (expected.getWidth() != actual.getWidth()) {\n+            throw new Error();\n+        }\n+        if (expected.getHeight() != actual.getHeight()) {\n+            throw new Error();\n+        }\n+        for (int y = 0; y < expected.getHeight(); y++) {\n+            for (int x = 0; x < expected.getWidth(); x++) {\n+                int argb1 = expected.getRGB(x, y);\n+                int argb2 = actual.getRGB(x, y);\n+                if (argb1 != argb2) {\n+                    throw new Error(\"x = \" + x + \", y = \" + y);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/png\/PNGImageDecoder_8bit_performance.java","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"}]}