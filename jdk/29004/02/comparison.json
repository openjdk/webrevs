{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,2 +305,10 @@\n-            if(interlaceMethod==0) { pass = -1; passLimit = 0; }\n-            else { pass = 0; passLimit = 7; }\n+            boolean isDirectByteCopy;\n+            if(interlaceMethod==0) {\n+                pass = -1;\n+                passLimit = 0;\n+                isDirectByteCopy = bPixels != null && bitDepth == 8;\n+            } else {\n+                pass = 0;\n+                passLimit = 7;\n+                isDirectByteCopy = false;\n+            }\n@@ -337,1 +345,5 @@\n-                        if(wPixels !=null) {\n+                        if (isDirectByteCopy) {\n+                            System.arraycopy(rowByteBuffer, spos, bPixels, col + rowOffset, width);\n+                            spos += width;\n+                            break;\n+                        } else if(wPixels !=null) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/PNGImageDecoder.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,248 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8374377\n+ * @summary This test confirms the PNGImageProducer decodes 8-bit interlaced\n+ * and non-interlaced PNGs correctly.\n+ *\/\n+\n+import javax.imageio.IIOImage;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageWriteParam;\n+import javax.imageio.ImageWriter;\n+import javax.imageio.stream.ImageOutputStream;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageConsumer;\n+import java.awt.image.IndexColorModel;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.util.Hashtable;\n+import java.util.Iterator;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+\/**\n+ * The proposed change for 8374377 affects how 8-bit PNGs are decoded.\n+ * So this test confirms that 8-bit PNGs (both interlaced and non-interlaced)\n+ * are still decoded by the PNGImageDecoder so they match what ImageIO decodes.\n+ *\n+ * This test has never failed.\n+ *\/\n+public class PNGImageDecoder_8bit_performance {\n+\n+    interface Model {\n+        BufferedImage load(byte[] imagedata) throws Exception;\n+    }\n+\n+    \/**\n+     * This creates a BufferedImage using ImageIO.\n+     *\/\n+    static class ImageIOModel implements Model {\n+\n+        @Override\n+        public BufferedImage load(byte[] imagedata) throws Exception {\n+            try (InputStream in = new ByteArrayInputStream(imagedata)) {\n+                return ImageIO.read(in);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * This creates a BufferedImage using an ImageConsumer and ImageProducer.\n+     *\/\n+    static class ImageConsumerModel implements Model {\n+\n+        @Override\n+        public BufferedImage load(byte[] imagedata) throws Exception {\n+            Image img = Toolkit.getDefaultToolkit().createImage(imagedata);\n+            return createBufferedImage(img);\n+        }\n+    }\n+\n+    static BufferedImage createBufferedImage(Image img)\n+            throws ExecutionException, InterruptedException {\n+        CompletableFuture<BufferedImage> future = new CompletableFuture<>();\n+        img.getSource().startProduction(new ImageConsumer() {\n+            private int imageWidth, imageHeight;\n+            private BufferedImage bi;\n+\n+            @Override\n+            public void setDimensions(int width, int height) {\n+                imageWidth = width;\n+                imageHeight = height;\n+            }\n+\n+            @Override\n+            public void setProperties(Hashtable<?, ?> props) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setColorModel(ColorModel model) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setHints(int hintflags) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  byte[] pixels, int off, int scansize) {\n+                if (bi == null) {\n+                    bi = new BufferedImage(imageWidth, imageHeight,\n+                            BufferedImage.TYPE_BYTE_INDEXED,\n+                            (IndexColorModel) model);\n+                }\n+\n+                if (w == imageWidth && h == imageHeight) {\n+                    \/\/ this is how interlaced PNGs are decoded:\n+                    bi.getRaster().setDataElements(0, 0,\n+                            imageWidth, imageHeight, pixels);\n+                    return;\n+                }\n+\n+                if (h != 1) {\n+                    throw new UnsupportedOperationException(\n+                            \"this test requires h = 1\");\n+                }\n+                if (off != 0) {\n+                    throw new UnsupportedOperationException(\n+                            \"this test requires off = 0\");\n+                }\n+\n+                bi.getRaster().setDataElements(x, y, w, 1, pixels);\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  int[] pixels, int off, int scansize) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public void imageComplete(int status) {\n+                future.complete(bi);\n+            }\n+        });\n+        return future.get();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Model[] models = new Model[]{\n+                new ImageIOModel(),\n+                new ImageConsumerModel()\n+        };\n+\n+        for (boolean interlace : new boolean[] { false, true} ) {\n+            System.out.println(\"Testing interlacing = \"+ interlace);\n+            byte[] imageData = createImageData(6000, interlace);\n+\n+            BufferedImage expected = models[0].load(imageData);\n+            BufferedImage actual = models[1].load(imageData);\n+\n+            testCorrectness(expected, actual);\n+        }\n+        System.out.println(\"Confirmed that 8-bit PNGs render correctly \" +\n+                \"whether we use ImageIO or ImageConsumers. We tested both \" +\n+                \"an interlaced and an non-interlaced PNG image.\");\n+    }\n+\n+    \/**\n+     * Create a large sample image stored as an 8-bit PNG.\n+     *\n+     * @return the byte representation of the PNG image.\n+     *\/\n+    private static byte[] createImageData(int squareSize,\n+                                          boolean interlace) throws Exception {\n+        BufferedImage bi = new BufferedImage(squareSize, squareSize,\n+                BufferedImage.TYPE_BYTE_INDEXED);\n+        Random r = new Random(0);\n+        Graphics2D g = bi.createGraphics();\n+        for (int a = 0; a < 20000; a++) {\n+            g.setColor(new Color(r.nextInt(0xffffff)));\n+            int radius = 10 + r.nextInt(90);\n+            g.fillOval(r.nextInt(bi.getWidth()), r.nextInt(bi.getHeight()),\n+                    radius, radius);\n+        }\n+        g.dispose();\n+\n+        Iterator<ImageWriter> writers =\n+                ImageIO.getImageWritersByFormatName(\"png\");\n+        if (!writers.hasNext()) {\n+            throw new IllegalStateException(\"No PNG writers found\");\n+        }\n+        ImageWriter writer = writers.next();\n+\n+        ImageWriteParam param = writer.getDefaultWriteParam();\n+        if (interlace) {\n+            param.setProgressiveMode(ImageWriteParam.MODE_DEFAULT);\n+        }\n+\n+        try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+             ImageOutputStream imageOut =\n+                     ImageIO.createImageOutputStream(byteOut)) {\n+            writer.setOutput(imageOut);\n+            writer.write(null, new IIOImage(bi, null, null), param);\n+            return byteOut.toByteArray();\n+        } finally {\n+            writer.dispose();\n+        }\n+    }\n+\n+    \/**\n+     * This throws an Error if the two images are not identical.\n+     * <p>\n+     * This unit test is intended to accompany a performance enhancement for\n+     * PNGImageDecoder. This method makes sure the enhancement didn't cost us\n+     * any accuracy.\n+     *\/\n+    private static void testCorrectness(BufferedImage expected,\n+                                        BufferedImage actual) {\n+        if (expected.getWidth() != actual.getWidth()) {\n+            throw new Error();\n+        }\n+        if (expected.getHeight() != actual.getHeight()) {\n+            throw new Error();\n+        }\n+        for (int y = 0; y < expected.getHeight(); y++) {\n+            for (int x = 0; x < expected.getWidth(); x++) {\n+                int argb1 = expected.getRGB(x, y);\n+                int argb2 = actual.getRGB(x, y);\n+                if (argb1 != argb2) {\n+                    throw new Error(\"x = \" + x + \", y = \" + y);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/png\/PNGImageDecoder_8bit_performance.java","additions":248,"deletions":0,"binary":false,"changes":248,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.sun.misc;\n+\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import javax.imageio.ImageIO;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageConsumer;\n+import java.awt.image.IndexColorModel;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.util.Hashtable;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 20)\n+@Fork(3)\n+@State(Scope.Thread)\n+public class PNGImageDecoder_8bit_uninterlaced {\n+\n+    byte[] pngImageData;\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        pngImageData = createImageData(2_500);\n+\n+        \/\/ verify correctness:\n+        BufferedImage expected = ImageIO.read(\n+                new ByteArrayInputStream(pngImageData));\n+        Image img = Toolkit.getDefaultToolkit().createImage(pngImageData);\n+        BufferedImage actual = createBufferedImage(img);\n+        testCorrectness(expected, actual);\n+    }\n+\n+    @Benchmark\n+    public void measurePNGImageDecoder(Blackhole bh) throws Exception {\n+        Image img = Toolkit.getDefaultToolkit().createImage(pngImageData);\n+        BufferedImage bi = createBufferedImage(img);\n+        bi.flush();\n+        bh.consume(bi);\n+    }\n+\n+    \/**\n+     * Create a large sample image stored as an 8-bit PNG.\n+     *\n+     * @return the byte representation of the PNG image.\n+     *\/\n+    private static byte[] createImageData(int squareSize) throws Exception {\n+        BufferedImage bi = new BufferedImage(squareSize, squareSize,\n+                BufferedImage.TYPE_BYTE_INDEXED);\n+        Random r = new Random(0);\n+        Graphics2D g = bi.createGraphics();\n+        for (int a = 0; a < 20000; a++) {\n+            g.setColor(new Color(r.nextInt(0xffffff)));\n+            int radius = 10 + r.nextInt(90);\n+            g.fillOval(r.nextInt(bi.getWidth()), r.nextInt(bi.getHeight()),\n+                    radius, radius);\n+        }\n+        g.dispose();\n+\n+        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n+            ImageIO.write(bi, \"png\", out);\n+            return out.toByteArray();\n+        }\n+    }\n+\n+    static BufferedImage createBufferedImage(Image img)\n+            throws ExecutionException, InterruptedException {\n+        CompletableFuture<BufferedImage> future = new CompletableFuture<>();\n+        img.getSource().startProduction(new ImageConsumer() {\n+            private int imageWidth, imageHeight;\n+            private BufferedImage bi;\n+\n+            @Override\n+            public void setDimensions(int width, int height) {\n+                imageWidth = width;\n+                imageHeight = height;\n+            }\n+\n+            @Override\n+            public void setProperties(Hashtable<?, ?> props) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setColorModel(ColorModel model) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setHints(int hintflags) {\n+                \/\/ intentionally empty\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  byte[] pixels, int off, int scansize) {\n+                if (bi == null) {\n+                    bi = new BufferedImage(imageWidth, imageHeight,\n+                            BufferedImage.TYPE_BYTE_INDEXED,\n+                            (IndexColorModel) model);\n+                }\n+                if (h != 1)\n+                    throw new UnsupportedOperationException(\n+                            \"this test expects sequential rows of pixels\");\n+                if (off != 0)\n+                    throw new UnsupportedOperationException(\n+                            \"this test expects the incoming pixels to start \" +\n+                                    \"at index zero\");\n+\n+                bi.getRaster().setDataElements(x, y, w, 1, pixels);\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h, ColorModel model,\n+                                  int[] pixels, int off, int scansize) {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public void imageComplete(int status) {\n+                future.complete(bi);\n+            }\n+        });\n+        return future.get();\n+    }\n+\n+    \/**\n+     * This unit test is intended to accompany a performance enhancement for\n+     * PNGImageDecoder. This method makes sure the enhancement didn't cost us\n+     * any accuracy.\n+     *\/\n+    private static void testCorrectness(BufferedImage expected,\n+                                        BufferedImage actual) {\n+        if (expected.getWidth() != actual.getWidth())\n+            throw new Error();\n+        if (expected.getHeight() != actual.getHeight())\n+            throw new Error();\n+        for (int y = 0; y < expected.getHeight(); y++) {\n+            for (int x = 0; x < expected.getWidth(); x++) {\n+                int argb1 = expected.getRGB(x, y);\n+                int argb2 = actual.getRGB(x, y);\n+                if (argb1 != argb2) {\n+                    throw new Error(\"x = \" + x + \", y = \" + y);\n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/sun\/awt\/image\/PNGImageDecoder_8bit_uninterlaced.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"}]}