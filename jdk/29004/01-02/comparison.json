{"files":[{"patch":"@@ -27,2 +27,2 @@\n- * @summary This test makes sure the PNGImageProducer performs comparable to\n- * ImageIO when reading an 8-bit non-interlaced png.\n+ * @summary This test confirms the PNGImageProducer decodes 8-bit interlaced\n+ * and non-interlaced PNGs correctly.\n@@ -31,0 +31,1 @@\n+import javax.imageio.IIOImage;\n@@ -32,0 +33,3 @@\n+import javax.imageio.ImageWriteParam;\n+import javax.imageio.ImageWriter;\n+import javax.imageio.stream.ImageOutputStream;\n@@ -43,1 +47,0 @@\n-import java.util.Arrays;\n@@ -45,0 +48,1 @@\n+import java.util.Iterator;\n@@ -50,3 +54,5 @@\n- * This test makes sure an 8-bit PNG image is converted into a BufferedImage\n- * in approximately the same amount of time whether we use ImageIO or\n- * an ImageConsumer\/ImageProducer.\n+ * The proposed change for 8374377 affects how 8-bit PNGs are decoded.\n+ * So this test confirms that 8-bit PNGs (both interlaced and non-interlaced)\n+ * are still decoded by the PNGImageDecoder so they match what ImageIO decodes.\n+ *\n+ * This test has never failed.\n@@ -121,0 +127,8 @@\n+\n+                if (w == imageWidth && h == imageHeight) {\n+                    \/\/ this is how interlaced PNGs are decoded:\n+                    bi.getRaster().setDataElements(0, 0,\n+                            imageWidth, imageHeight, pixels);\n+                    return;\n+                }\n+\n@@ -148,3 +162,4 @@\n-        for (int squareSize = 4_000; squareSize <= 10_000;\n-             squareSize += 2_000) {\n-            byte[] imagedata = createImageData(squareSize);\n+        Model[] models = new Model[]{\n+                new ImageIOModel(),\n+                new ImageConsumerModel()\n+        };\n@@ -152,4 +167,3 @@\n-            Model[] models = new Model[]{\n-                    new ImageIOModel(),\n-                    new ImageConsumerModel()\n-            };\n+        for (boolean interlace : new boolean[] { false, true} ) {\n+            System.out.println(\"Testing interlacing = \"+ interlace);\n+            byte[] imageData = createImageData(6000, interlace);\n@@ -157,2 +171,2 @@\n-            BufferedImage expected = models[0].load(imagedata);\n-            BufferedImage actual = models[1].load(imagedata);\n+            BufferedImage expected = models[0].load(imageData);\n+            BufferedImage actual = models[1].load(imageData);\n@@ -161,62 +175,0 @@\n-\n-            \/\/ both of these constants are arbitrary. IMO they help demonstrate\n-            \/\/ the problem with reasonable accuracy & without excess waiting\n-\n-            \/\/ run our test sampleCount-many times, and only report the median:\n-            int sampleCount = 7;\n-\n-            \/\/ each sample creates the image loopCount-many times\n-            int loopCount = 10;\n-\n-            long[][] samples = new long[models.length][sampleCount];\n-            for (int sampleIndex = 0; sampleIndex < sampleCount;\n-                 sampleIndex++) {\n-                for (int modelIndex = 0; modelIndex < models.length;\n-                     modelIndex++) {\n-\n-                    long t = System.currentTimeMillis();\n-                    for (int b = 0; b < loopCount; b++) {\n-                        models[modelIndex].load(imagedata).flush();\n-                    }\n-                    t = System.currentTimeMillis() - t;\n-                    samples[modelIndex][sampleIndex] = t;\n-                }\n-            }\n-            long[] results = new long[models.length];\n-            long firstMedian = -1;\n-            for (int modelIndex = 0; modelIndex < models.length;\n-                 modelIndex++) {\n-                long[] modelSamples = samples[modelIndex];\n-                Arrays.sort(modelSamples);\n-                long median = modelSamples[modelSamples.length \/ 2];\n-                results[modelIndex] = median;\n-            }\n-\n-            System.out.println();\n-            System.out.println(\"Square Size\\t%\\tImageIOModel\\t\" +\n-                    \"ImageConsumerModel\");\n-\n-            StringBuilder sb = new StringBuilder(Integer.toString(squareSize));\n-            int imageConsumerPercentRelImageIO = Math.round(\n-                    results[1] * 100f \/ results[0]);\n-            sb.append(\"\\t\" + imageConsumerPercentRelImageIO);\n-\n-            for (int a = 0; a < results.length; a++) {\n-                sb.append(\"\\t\" + results[a]);\n-            }\n-\n-            System.out.println(sb);\n-\n-            System.out.println(\"The ImageConsumer approach took \" +\n-                    imageConsumerPercentRelImageIO + \"% of the time the \" +\n-                    \"ImageIO approach took.\");\n-\n-            \/\/ in my tests the MINIMUM percent that we saw before this\n-            \/\/ enhancement was 109.9% and the MAXIMUM we saw after this\n-            \/\/ enhancement was 104.4%, so a midway point is 107%. We should\n-            \/\/ always be under 107%\n-\n-            if (imageConsumerPercentRelImageIO > 107) {\n-                throw new Error(\"The ImageConsumer model should always take \" +\n-                        \"close to 100% of what the ImageIO model takes.\");\n-            }\n@@ -224,0 +176,3 @@\n+        System.out.println(\"Confirmed that 8-bit PNGs render correctly \" +\n+                \"whether we use ImageIO or ImageConsumers. We tested both \" +\n+                \"an interlaced and an non-interlaced PNG image.\");\n@@ -231,1 +186,2 @@\n-    private static byte[] createImageData(int squareSize) throws Exception {\n+    private static byte[] createImageData(int squareSize,\n+                                          boolean interlace) throws Exception {\n@@ -244,3 +200,20 @@\n-        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {\n-            ImageIO.write(bi, \"png\", out);\n-            return out.toByteArray();\n+        Iterator<ImageWriter> writers =\n+                ImageIO.getImageWritersByFormatName(\"png\");\n+        if (!writers.hasNext()) {\n+            throw new IllegalStateException(\"No PNG writers found\");\n+        }\n+        ImageWriter writer = writers.next();\n+\n+        ImageWriteParam param = writer.getDefaultWriteParam();\n+        if (interlace) {\n+            param.setProgressiveMode(ImageWriteParam.MODE_DEFAULT);\n+        }\n+\n+        try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+             ImageOutputStream imageOut =\n+                     ImageIO.createImageOutputStream(byteOut)) {\n+            writer.setOutput(imageOut);\n+            writer.write(null, new IIOImage(bi, null, null), param);\n+            return byteOut.toByteArray();\n+        } finally {\n+            writer.dispose();\n","filename":"test\/jdk\/sun\/awt\/image\/png\/PNGImageDecoder_8bit_performance.java","additions":54,"deletions":81,"binary":false,"changes":135,"status":"modified"}]}