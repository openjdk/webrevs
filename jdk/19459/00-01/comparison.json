{"files":[{"patch":"@@ -168,0 +168,30 @@\n+uint32_t MacroAssembler::get_membar_kind(address addr) {\n+  assert_cond(addr != nullptr);\n+  assert(is_membar(addr), \"no membar found\");\n+\n+  uint32_t insn = Bytes::get_native_u4(addr);\n+\n+  uint32_t predecessor = Assembler::extract(insn, 27, 24);\n+  uint32_t successor = Assembler::extract(insn, 23, 20);\n+\n+  return MacroAssembler::pred_succ_to_membar_mask(predecessor, successor);\n+}\n+\n+void MacroAssembler::set_membar_kind(address addr, uint32_t order_kind) {\n+  assert_cond(addr != nullptr);\n+  assert(is_membar(addr), \"no membar found\");\n+\n+  uint32_t predecessor = 0;\n+  uint32_t successor = 0;\n+\n+  MacroAssembler::membar_mask_to_pred_succ(order_kind, predecessor, successor);\n+\n+  uint32_t insn = Bytes::get_native_u4(addr);\n+  address pInsn = (address) &insn;\n+  Assembler::patch(pInsn, 27, 24, predecessor);\n+  Assembler::patch(pInsn, 23, 20, successor);\n+\n+  address membar = addr;\n+  Assembler::sd_instr(membar, insn);\n+}\n+\n@@ -2864,2 +2894,1 @@\n-  if (last != nullptr && nativeInstruction_at(last)->is_membar() && prev == last) {\n-    NativeMembar *bar = NativeMembar_at(prev);\n+  if (last != nullptr && is_membar(last) && prev == last) {\n@@ -2868,1 +2897,1 @@\n-    bar->set_kind(bar->get_kind() | order_constraint);\n+    set_membar_kind(prev, get_membar_kind(prev) | order_constraint);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":32,"deletions":3,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -256,0 +256,7 @@\n+ private:\n+\n+  static bool is_membar(address addr) {\n+    return (Bytes::get_native_u4(addr) & 0x7f) == 0b1111 && extract_funct3(addr) == 0;\n+  }\n+  static uint32_t get_membar_kind(address addr);\n+  static void set_membar_kind(address addr, uint32_t order_kind);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -339,24 +339,0 @@\n-uint32_t NativeMembar::get_kind() {\n-  uint32_t insn = uint_at(0);\n-\n-  uint32_t predecessor = Assembler::extract(insn, 27, 24);\n-  uint32_t successor = Assembler::extract(insn, 23, 20);\n-\n-  return MacroAssembler::pred_succ_to_membar_mask(predecessor, successor);\n-}\n-\n-void NativeMembar::set_kind(uint32_t order_kind) {\n-  uint32_t predecessor = 0;\n-  uint32_t successor = 0;\n-\n-  MacroAssembler::membar_mask_to_pred_succ(order_kind, predecessor, successor);\n-\n-  uint32_t insn = uint_at(0);\n-  address pInsn = (address) &insn;\n-  Assembler::patch(pInsn, 27, 24, predecessor);\n-  Assembler::patch(pInsn, 23, 20, successor);\n-\n-  address membar = addr_at(0);\n-  Assembler::sd_instr(membar, insn);\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -104,4 +104,0 @@\n-\n-  bool is_membar() {\n-    return (uint_at(0) & 0x7f) == 0b1111 && MacroAssembler::extract_funct3(addr_at(0)) == 0;\n-  }\n@@ -393,12 +389,0 @@\n-class NativeMembar : public NativeInstruction {\n-public:\n-  uint32_t get_kind();\n-  void set_kind(uint32_t order_kind);\n-};\n-\n-inline NativeMembar *NativeMembar_at(address addr) {\n-  assert_cond(addr != nullptr);\n-  assert(nativeInstruction_at(addr)->is_membar(), \"no membar found\");\n-  return (NativeMembar*)addr;\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"}]}