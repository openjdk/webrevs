{"files":[{"patch":"@@ -43,223 +43,0 @@\n- public:\n-  enum {\n-    instruction_size = 4,\n-    compressed_instruction_size = 2,\n-\n-    \/\/ Refer to function emit_trampoline_stub.\n-    trampoline_stub_instruction_size = 3 * instruction_size + wordSize, \/\/ auipc + ld + jr + target address\n-    trampoline_stub_data_offset      = 3 * instruction_size,            \/\/ auipc + ld + jr\n-\n-    \/\/ movptr\n-    movptr1_instruction_size = 6 * instruction_size, \/\/ lui, addi, slli, addi, slli, addi.  See movptr1().\n-    movptr2_instruction_size = 5 * instruction_size, \/\/ lui, lui, slli, add, addi.  See movptr2().\n-    load_pc_relative_instruction_size = 2 * instruction_size \/\/ auipc, ld\n-  };\n-\n-  static bool is_load_pc_relative_at(address branch);\n-  static bool is_li16u_at(address instr);\n-\n-  static bool is_trampoline_stub_at(address addr) {\n-    \/\/ Ensure that the stub is exactly\n-    \/\/      ld   t0, L--->auipc + ld\n-    \/\/      jr   t0\n-    \/\/ L:\n-\n-    \/\/ judge inst + register + imm\n-    \/\/ 1). check the instructions: auipc + ld + jalr\n-    \/\/ 2). check if auipc[11:7] == t0 and ld[11:7] == t0 and ld[19:15] == t0 && jr[19:15] == t0\n-    \/\/ 3). check if the offset in ld[31:20] equals the data_offset\n-    assert_cond(addr != nullptr);\n-    const int instr_size = instruction_size;\n-    if (is_auipc_at(addr) &&\n-        is_ld_at(addr + instr_size) &&\n-        is_jalr_at(addr + 2 * instr_size) &&\n-        (extract_rd(addr)                    == x5) &&\n-        (extract_rd(addr + instr_size)       == x5) &&\n-        (extract_rs1(addr + instr_size)      == x5) &&\n-        (extract_rs1(addr + 2 * instr_size)  == x5) &&\n-        (Assembler::extract(Assembler::ld_instr(addr + 4), 31, 20) == trampoline_stub_data_offset)) {\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  static bool is_call_at(address instr) {\n-    if (is_jal_at(instr) || is_jalr_at(instr)) {\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  static bool is_jal_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1101111; }\n-  static bool is_jalr_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1100111 && extract_funct3(instr) == 0b000; }\n-  static bool is_branch_at(address instr)     { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1100011; }\n-  static bool is_ld_at(address instr)         { assert_cond(instr != nullptr); return is_load_at(instr) && extract_funct3(instr) == 0b011; }\n-  static bool is_load_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0000011; }\n-  static bool is_float_load_at(address instr) { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0000111; }\n-  static bool is_auipc_at(address instr)      { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0010111; }\n-  static bool is_jump_at(address instr)       { assert_cond(instr != nullptr); return is_branch_at(instr) || is_jal_at(instr) || is_jalr_at(instr); }\n-  static bool is_add_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0110011 && extract_funct3(instr) == 0b000; }\n-  static bool is_addi_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0010011 && extract_funct3(instr) == 0b000; }\n-  static bool is_addiw_at(address instr)      { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0011011 && extract_funct3(instr) == 0b000; }\n-  static bool is_addiw_to_zr_at(address instr){ assert_cond(instr != nullptr); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n-  static bool is_lui_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0110111; }\n-  static bool is_lui_to_zr_at(address instr)  { assert_cond(instr != nullptr); return is_lui_at(instr) && extract_rd(instr) == zr; }\n-\n-  static bool is_srli_at(address instr) {\n-    assert_cond(instr != nullptr);\n-    return extract_opcode(instr) == 0b0010011 &&\n-           extract_funct3(instr) == 0b101 &&\n-           Assembler::extract(((unsigned*)instr)[0], 31, 26) == 0b000000;\n-  }\n-\n-  static bool is_slli_shift_at(address instr, uint32_t shift) {\n-    assert_cond(instr != nullptr);\n-    return (extract_opcode(instr) == 0b0010011 && \/\/ opcode field\n-            extract_funct3(instr) == 0b001 &&     \/\/ funct3 field, select the type of operation\n-            Assembler::extract(Assembler::ld_instr(instr), 25, 20) == shift);    \/\/ shamt field\n-  }\n-\n-  static bool is_movptr1_at(address instr);\n-  static bool is_movptr2_at(address instr);\n-\n-  static bool is_lwu_to_zr(address instr);\n-\n- private:\n-  static Register extract_rs1(address instr);\n-  static Register extract_rs2(address instr);\n-  static Register extract_rd(address instr);\n-  static uint32_t extract_opcode(address instr);\n-  static uint32_t extract_funct3(address instr);\n-\n-  \/\/ the instruction sequence of movptr is as below:\n-  \/\/     lui\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\/jalr\/load\n-  static bool check_movptr1_data_dependency(address instr) {\n-    address lui = instr;\n-    address addi1 = lui + instruction_size;\n-    address slli1 = addi1 + instruction_size;\n-    address addi2 = slli1 + instruction_size;\n-    address slli2 = addi2 + instruction_size;\n-    address last_instr = slli2 + instruction_size;\n-    return extract_rs1(addi1) == extract_rd(lui) &&\n-           extract_rs1(addi1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(slli2) &&\n-           extract_rs1(last_instr) == extract_rd(slli2);\n-  }\n-\n-  \/\/ the instruction sequence of movptr2 is as below:\n-  \/\/     lui\n-  \/\/     lui\n-  \/\/     slli\n-  \/\/     add\n-  \/\/     addi\/jalr\/load\n-  static bool check_movptr2_data_dependency(address instr) {\n-    address lui1 = instr;\n-    address lui2 = lui1 + instruction_size;\n-    address slli = lui2 + instruction_size;\n-    address add  = slli + instruction_size;\n-    address last_instr = add + instruction_size;\n-    return extract_rd(add) == extract_rd(lui2) &&\n-           extract_rs1(add) == extract_rd(lui2) &&\n-           extract_rs2(add) == extract_rd(slli) &&\n-           extract_rs1(slli) == extract_rd(lui1) &&\n-           extract_rd(slli) == extract_rd(lui1) &&\n-           extract_rs1(last_instr) == extract_rd(add);\n-  }\n-\n-  \/\/ the instruction sequence of li64 is as below:\n-  \/\/     lui\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  static bool check_li64_data_dependency(address instr) {\n-    address lui = instr;\n-    address addi1 = lui + instruction_size;\n-    address slli1 = addi1 + instruction_size;\n-    address addi2 = slli1 + instruction_size;\n-    address slli2 = addi2 + instruction_size;\n-    address addi3 = slli2 + instruction_size;\n-    address slli3 = addi3 + instruction_size;\n-    address addi4 = slli3 + instruction_size;\n-    return extract_rs1(addi1) == extract_rd(lui) &&\n-           extract_rs1(addi1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(addi4);\n-  }\n-\n-  \/\/ the instruction sequence of li16u is as below:\n-  \/\/     lui\n-  \/\/     srli\n-  static bool check_li16u_data_dependency(address instr) {\n-    address lui = instr;\n-    address srli = lui + instruction_size;\n-\n-    return extract_rs1(srli) == extract_rd(lui) &&\n-           extract_rs1(srli) == extract_rd(srli);\n-  }\n-\n-  \/\/ the instruction sequence of li32 is as below:\n-  \/\/     lui\n-  \/\/     addiw\n-  static bool check_li32_data_dependency(address instr) {\n-    address lui = instr;\n-    address addiw = lui + instruction_size;\n-\n-    return extract_rs1(addiw) == extract_rd(lui) &&\n-           extract_rs1(addiw) == extract_rd(addiw);\n-  }\n-\n-  \/\/ the instruction sequence of pc-relative is as below:\n-  \/\/     auipc\n-  \/\/     jalr\/addi\/load\/float_load\n-  static bool check_pc_relative_data_dependency(address instr) {\n-    address auipc = instr;\n-    address last_instr = auipc + instruction_size;\n-\n-    return extract_rs1(last_instr) == extract_rd(auipc);\n-  }\n-\n-  \/\/ the instruction sequence of load_label is as below:\n-  \/\/     auipc\n-  \/\/     load\n-  static bool check_load_pc_relative_data_dependency(address instr) {\n-    address auipc = instr;\n-    address load = auipc + instruction_size;\n-\n-    return extract_rd(load) == extract_rd(auipc) &&\n-           extract_rs1(load) == extract_rd(load);\n-  }\n-\n-  static bool is_li32_at(address instr);\n-  static bool is_li64_at(address instr);\n-  static bool is_pc_relative_at(address branch);\n-\n-  static bool is_membar(address addr) {\n-    return (Bytes::get_native_u4(addr) & 0x7f) == 0b1111 && extract_funct3(addr) == 0;\n-  }\n-  static uint32_t get_membar_kind(address addr);\n-  static void set_membar_kind(address addr, uint32_t order_kind);\n-\n@@ -1768,0 +1545,220 @@\n+\n+public:\n+  enum {\n+    \/\/ Refer to function emit_trampoline_stub.\n+    trampoline_stub_instruction_size = 3 * instruction_size + wordSize, \/\/ auipc + ld + jr + target address\n+    trampoline_stub_data_offset      = 3 * instruction_size,            \/\/ auipc + ld + jr\n+\n+    \/\/ movptr\n+    movptr1_instruction_size = 6 * instruction_size, \/\/ lui, addi, slli, addi, slli, addi.  See movptr1().\n+    movptr2_instruction_size = 5 * instruction_size, \/\/ lui, lui, slli, add, addi.  See movptr2().\n+    load_pc_relative_instruction_size = 2 * instruction_size \/\/ auipc, ld\n+  };\n+\n+  static bool is_load_pc_relative_at(address branch);\n+  static bool is_li16u_at(address instr);\n+\n+  static bool is_trampoline_stub_at(address addr) {\n+    \/\/ Ensure that the stub is exactly\n+    \/\/      ld   t0, L--->auipc + ld\n+    \/\/      jr   t0\n+    \/\/ L:\n+\n+    \/\/ judge inst + register + imm\n+    \/\/ 1). check the instructions: auipc + ld + jalr\n+    \/\/ 2). check if auipc[11:7] == t0 and ld[11:7] == t0 and ld[19:15] == t0 && jr[19:15] == t0\n+    \/\/ 3). check if the offset in ld[31:20] equals the data_offset\n+    assert_cond(addr != nullptr);\n+    const int instr_size = instruction_size;\n+    if (is_auipc_at(addr) &&\n+        is_ld_at(addr + instr_size) &&\n+        is_jalr_at(addr + 2 * instr_size) &&\n+        (extract_rd(addr)                    == x5) &&\n+        (extract_rd(addr + instr_size)       == x5) &&\n+        (extract_rs1(addr + instr_size)      == x5) &&\n+        (extract_rs1(addr + 2 * instr_size)  == x5) &&\n+        (Assembler::extract(Assembler::ld_instr(addr + 4), 31, 20) == trampoline_stub_data_offset)) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static bool is_call_at(address instr) {\n+    if (is_jal_at(instr) || is_jalr_at(instr)) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static bool is_jal_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1101111; }\n+  static bool is_jalr_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1100111 && extract_funct3(instr) == 0b000; }\n+  static bool is_branch_at(address instr)     { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1100011; }\n+  static bool is_ld_at(address instr)         { assert_cond(instr != nullptr); return is_load_at(instr) && extract_funct3(instr) == 0b011; }\n+  static bool is_load_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0000011; }\n+  static bool is_float_load_at(address instr) { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0000111; }\n+  static bool is_auipc_at(address instr)      { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0010111; }\n+  static bool is_jump_at(address instr)       { assert_cond(instr != nullptr); return is_branch_at(instr) || is_jal_at(instr) || is_jalr_at(instr); }\n+  static bool is_add_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0110011 && extract_funct3(instr) == 0b000; }\n+  static bool is_addi_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0010011 && extract_funct3(instr) == 0b000; }\n+  static bool is_addiw_at(address instr)      { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0011011 && extract_funct3(instr) == 0b000; }\n+  static bool is_addiw_to_zr_at(address instr){ assert_cond(instr != nullptr); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n+  static bool is_lui_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0110111; }\n+  static bool is_lui_to_zr_at(address instr)  { assert_cond(instr != nullptr); return is_lui_at(instr) && extract_rd(instr) == zr; }\n+\n+  static bool is_srli_at(address instr) {\n+    assert_cond(instr != nullptr);\n+    return extract_opcode(instr) == 0b0010011 &&\n+           extract_funct3(instr) == 0b101 &&\n+           Assembler::extract(((unsigned*)instr)[0], 31, 26) == 0b000000;\n+  }\n+\n+  static bool is_slli_shift_at(address instr, uint32_t shift) {\n+    assert_cond(instr != nullptr);\n+    return (extract_opcode(instr) == 0b0010011 && \/\/ opcode field\n+            extract_funct3(instr) == 0b001 &&     \/\/ funct3 field, select the type of operation\n+            Assembler::extract(Assembler::ld_instr(instr), 25, 20) == shift);    \/\/ shamt field\n+  }\n+\n+  static bool is_movptr1_at(address instr);\n+  static bool is_movptr2_at(address instr);\n+\n+  static bool is_lwu_to_zr(address instr);\n+\n+private:\n+  static Register extract_rs1(address instr);\n+  static Register extract_rs2(address instr);\n+  static Register extract_rd(address instr);\n+  static uint32_t extract_opcode(address instr);\n+  static uint32_t extract_funct3(address instr);\n+\n+  \/\/ the instruction sequence of movptr is as below:\n+  \/\/     lui\n+  \/\/     addi\n+  \/\/     slli\n+  \/\/     addi\n+  \/\/     slli\n+  \/\/     addi\/jalr\/load\n+  static bool check_movptr1_data_dependency(address instr) {\n+    address lui = instr;\n+    address addi1 = lui + instruction_size;\n+    address slli1 = addi1 + instruction_size;\n+    address addi2 = slli1 + instruction_size;\n+    address slli2 = addi2 + instruction_size;\n+    address last_instr = slli2 + instruction_size;\n+    return extract_rs1(addi1) == extract_rd(lui) &&\n+           extract_rs1(addi1) == extract_rd(addi1) &&\n+           extract_rs1(slli1) == extract_rd(addi1) &&\n+           extract_rs1(slli1) == extract_rd(slli1) &&\n+           extract_rs1(addi2) == extract_rd(slli1) &&\n+           extract_rs1(addi2) == extract_rd(addi2) &&\n+           extract_rs1(slli2) == extract_rd(addi2) &&\n+           extract_rs1(slli2) == extract_rd(slli2) &&\n+           extract_rs1(last_instr) == extract_rd(slli2);\n+  }\n+\n+  \/\/ the instruction sequence of movptr2 is as below:\n+  \/\/     lui\n+  \/\/     lui\n+  \/\/     slli\n+  \/\/     add\n+  \/\/     addi\/jalr\/load\n+  static bool check_movptr2_data_dependency(address instr) {\n+    address lui1 = instr;\n+    address lui2 = lui1 + instruction_size;\n+    address slli = lui2 + instruction_size;\n+    address add  = slli + instruction_size;\n+    address last_instr = add + instruction_size;\n+    return extract_rd(add) == extract_rd(lui2) &&\n+           extract_rs1(add) == extract_rd(lui2) &&\n+           extract_rs2(add) == extract_rd(slli) &&\n+           extract_rs1(slli) == extract_rd(lui1) &&\n+           extract_rd(slli) == extract_rd(lui1) &&\n+           extract_rs1(last_instr) == extract_rd(add);\n+  }\n+\n+  \/\/ the instruction sequence of li64 is as below:\n+  \/\/     lui\n+  \/\/     addi\n+  \/\/     slli\n+  \/\/     addi\n+  \/\/     slli\n+  \/\/     addi\n+  \/\/     slli\n+  \/\/     addi\n+  static bool check_li64_data_dependency(address instr) {\n+    address lui = instr;\n+    address addi1 = lui + instruction_size;\n+    address slli1 = addi1 + instruction_size;\n+    address addi2 = slli1 + instruction_size;\n+    address slli2 = addi2 + instruction_size;\n+    address addi3 = slli2 + instruction_size;\n+    address slli3 = addi3 + instruction_size;\n+    address addi4 = slli3 + instruction_size;\n+    return extract_rs1(addi1) == extract_rd(lui) &&\n+           extract_rs1(addi1) == extract_rd(addi1) &&\n+           extract_rs1(slli1) == extract_rd(addi1) &&\n+           extract_rs1(slli1) == extract_rd(slli1) &&\n+           extract_rs1(addi2) == extract_rd(slli1) &&\n+           extract_rs1(addi2) == extract_rd(addi2) &&\n+           extract_rs1(slli2) == extract_rd(addi2) &&\n+           extract_rs1(slli2) == extract_rd(slli2) &&\n+           extract_rs1(addi3) == extract_rd(slli2) &&\n+           extract_rs1(addi3) == extract_rd(addi3) &&\n+           extract_rs1(slli3) == extract_rd(addi3) &&\n+           extract_rs1(slli3) == extract_rd(slli3) &&\n+           extract_rs1(addi4) == extract_rd(slli3) &&\n+           extract_rs1(addi4) == extract_rd(addi4);\n+  }\n+\n+  \/\/ the instruction sequence of li16u is as below:\n+  \/\/     lui\n+  \/\/     srli\n+  static bool check_li16u_data_dependency(address instr) {\n+    address lui = instr;\n+    address srli = lui + instruction_size;\n+\n+    return extract_rs1(srli) == extract_rd(lui) &&\n+           extract_rs1(srli) == extract_rd(srli);\n+  }\n+\n+  \/\/ the instruction sequence of li32 is as below:\n+  \/\/     lui\n+  \/\/     addiw\n+  static bool check_li32_data_dependency(address instr) {\n+    address lui = instr;\n+    address addiw = lui + instruction_size;\n+\n+    return extract_rs1(addiw) == extract_rd(lui) &&\n+           extract_rs1(addiw) == extract_rd(addiw);\n+  }\n+\n+  \/\/ the instruction sequence of pc-relative is as below:\n+  \/\/     auipc\n+  \/\/     jalr\/addi\/load\/float_load\n+  static bool check_pc_relative_data_dependency(address instr) {\n+    address auipc = instr;\n+    address last_instr = auipc + instruction_size;\n+\n+    return extract_rs1(last_instr) == extract_rd(auipc);\n+  }\n+\n+  \/\/ the instruction sequence of load_label is as below:\n+  \/\/     auipc\n+  \/\/     load\n+  static bool check_load_pc_relative_data_dependency(address instr) {\n+    address auipc = instr;\n+    address load = auipc + instruction_size;\n+\n+    return extract_rd(load) == extract_rd(auipc) &&\n+           extract_rs1(load) == extract_rd(load);\n+  }\n+\n+  static bool is_li32_at(address instr);\n+  static bool is_li64_at(address instr);\n+  static bool is_pc_relative_at(address branch);\n+\n+  static bool is_membar(address addr) {\n+    return (Bytes::get_native_u4(addr) & 0x7f) == 0b1111 && extract_funct3(addr) == 0;\n+  }\n+  static uint32_t get_membar_kind(address addr);\n+  static void set_membar_kind(address addr, uint32_t order_kind);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":220,"deletions":223,"binary":false,"changes":443,"status":"modified"}]}