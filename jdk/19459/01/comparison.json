{"files":[{"patch":"@@ -632,1 +632,1 @@\n-      assert(NativeInstruction::is_li16u_at(addr), \"invalide zgc barrier\");\n+      assert(MacroAssembler::is_li16u_at(addr), \"invalide zgc barrier\");\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"nativeInst_riscv.hpp\"\n@@ -68,0 +67,132 @@\n+\n+\n+Register MacroAssembler::extract_rs1(address instr) {\n+  assert_cond(instr != nullptr);\n+  return as_Register(Assembler::extract(Assembler::ld_instr(instr), 19, 15));\n+}\n+\n+Register MacroAssembler::extract_rs2(address instr) {\n+  assert_cond(instr != nullptr);\n+  return as_Register(Assembler::extract(Assembler::ld_instr(instr), 24, 20));\n+}\n+\n+Register MacroAssembler::extract_rd(address instr) {\n+  assert_cond(instr != nullptr);\n+  return as_Register(Assembler::extract(Assembler::ld_instr(instr), 11, 7));\n+}\n+\n+uint32_t MacroAssembler::extract_opcode(address instr) {\n+  assert_cond(instr != nullptr);\n+  return Assembler::extract(Assembler::ld_instr(instr), 6, 0);\n+}\n+\n+uint32_t MacroAssembler::extract_funct3(address instr) {\n+  assert_cond(instr != nullptr);\n+  return Assembler::extract(Assembler::ld_instr(instr), 14, 12);\n+}\n+\n+bool MacroAssembler::is_pc_relative_at(address instr) {\n+  \/\/ auipc + jalr\n+  \/\/ auipc + addi\n+  \/\/ auipc + load\n+  \/\/ auipc + fload_load\n+  return (is_auipc_at(instr)) &&\n+         (is_addi_at(instr + instruction_size) ||\n+          is_jalr_at(instr + instruction_size) ||\n+          is_load_at(instr + instruction_size) ||\n+          is_float_load_at(instr + instruction_size)) &&\n+         check_pc_relative_data_dependency(instr);\n+}\n+\n+\/\/ ie:ld(Rd, Label)\n+bool MacroAssembler::is_load_pc_relative_at(address instr) {\n+  return is_auipc_at(instr) && \/\/ auipc\n+         is_ld_at(instr + instruction_size) && \/\/ ld\n+         check_load_pc_relative_data_dependency(instr);\n+}\n+\n+bool MacroAssembler::is_movptr1_at(address instr) {\n+  return is_lui_at(instr) && \/\/ Lui\n+         is_addi_at(instr + instruction_size) && \/\/ Addi\n+         is_slli_shift_at(instr + instruction_size * 2, 11) && \/\/ Slli Rd, Rs, 11\n+         is_addi_at(instr + instruction_size * 3) && \/\/ Addi\n+         is_slli_shift_at(instr + instruction_size * 4, 6) && \/\/ Slli Rd, Rs, 6\n+         (is_addi_at(instr + instruction_size * 5) ||\n+          is_jalr_at(instr + instruction_size * 5) ||\n+          is_load_at(instr + instruction_size * 5)) && \/\/ Addi\/Jalr\/Load\n+         check_movptr1_data_dependency(instr);\n+}\n+\n+bool MacroAssembler::is_movptr2_at(address instr) {\n+  return is_lui_at(instr) && \/\/ lui\n+         is_lui_at(instr + instruction_size) && \/\/ lui\n+         is_slli_shift_at(instr + instruction_size * 2, 18) && \/\/ slli Rd, Rs, 18\n+         is_add_at(instr + instruction_size * 3) &&\n+         (is_addi_at(instr + instruction_size * 4) ||\n+          is_jalr_at(instr + instruction_size * 4) ||\n+          is_load_at(instr + instruction_size * 4)) && \/\/ Addi\/Jalr\/Load\n+         check_movptr2_data_dependency(instr);\n+}\n+\n+bool MacroAssembler::is_li16u_at(address instr) {\n+  return is_lui_at(instr) && \/\/ lui\n+         is_srli_at(instr + instruction_size) && \/\/ srli\n+         check_li16u_data_dependency(instr);\n+}\n+\n+bool MacroAssembler::is_li32_at(address instr) {\n+  return is_lui_at(instr) && \/\/ lui\n+         is_addiw_at(instr + instruction_size) && \/\/ addiw\n+         check_li32_data_dependency(instr);\n+}\n+\n+bool MacroAssembler::is_li64_at(address instr) {\n+  return is_lui_at(instr) && \/\/ lui\n+         is_addi_at(instr + instruction_size) && \/\/ addi\n+         is_slli_shift_at(instr + instruction_size * 2, 12) &&  \/\/ Slli Rd, Rs, 12\n+         is_addi_at(instr + instruction_size * 3) && \/\/ addi\n+         is_slli_shift_at(instr + instruction_size * 4, 12) &&  \/\/ Slli Rd, Rs, 12\n+         is_addi_at(instr + instruction_size * 5) && \/\/ addi\n+         is_slli_shift_at(instr + instruction_size * 6, 8) &&   \/\/ Slli Rd, Rs, 8\n+         is_addi_at(instr + instruction_size * 7) && \/\/ addi\n+         check_li64_data_dependency(instr);\n+}\n+\n+bool MacroAssembler::is_lwu_to_zr(address instr) {\n+  assert_cond(instr != nullptr);\n+  return (extract_opcode(instr) == 0b0000011 &&\n+          extract_funct3(instr) == 0b110 &&\n+          extract_rd(instr) == zr);         \/\/ zr\n+}\n+\n+uint32_t MacroAssembler::get_membar_kind(address addr) {\n+  assert_cond(addr != nullptr);\n+  assert(is_membar(addr), \"no membar found\");\n+\n+  uint32_t insn = Bytes::get_native_u4(addr);\n+\n+  uint32_t predecessor = Assembler::extract(insn, 27, 24);\n+  uint32_t successor = Assembler::extract(insn, 23, 20);\n+\n+  return MacroAssembler::pred_succ_to_membar_mask(predecessor, successor);\n+}\n+\n+void MacroAssembler::set_membar_kind(address addr, uint32_t order_kind) {\n+  assert_cond(addr != nullptr);\n+  assert(is_membar(addr), \"no membar found\");\n+\n+  uint32_t predecessor = 0;\n+  uint32_t successor = 0;\n+\n+  MacroAssembler::membar_mask_to_pred_succ(order_kind, predecessor, successor);\n+\n+  uint32_t insn = Bytes::get_native_u4(addr);\n+  address pInsn = (address) &insn;\n+  Assembler::patch(pInsn, 27, 24, predecessor);\n+  Assembler::patch(pInsn, 23, 20, successor);\n+\n+  address membar = addr;\n+  Assembler::sd_instr(membar, insn);\n+}\n+\n+\n@@ -1408,1 +1539,1 @@\n-  return NativeInstruction::instruction_size;                                   \/\/ only one instruction\n+  return MacroAssembler::instruction_size;                                   \/\/ only one instruction\n@@ -1418,1 +1549,1 @@\n-  return NativeInstruction::instruction_size;                                   \/\/ only one instruction\n+  return MacroAssembler::instruction_size;                                   \/\/ only one instruction\n@@ -1425,1 +1556,1 @@\n-  return PC_RELATIVE_INSTRUCTION_NUM * NativeInstruction::instruction_size;\n+  return PC_RELATIVE_INSTRUCTION_NUM * MacroAssembler::instruction_size;\n@@ -1435,1 +1566,1 @@\n-  return NativeMovConstReg::movptr1_instruction_size;\n+  return MacroAssembler::movptr1_instruction_size;\n@@ -1447,2 +1578,2 @@\n-  Assembler::patch(instruction_address + (NativeInstruction::instruction_size * 0), 31, 12, (upper18 & 0xfffff)); \/\/ Lui\n-  Assembler::patch(instruction_address + (NativeInstruction::instruction_size * 1), 31, 12, (mid18   & 0xfffff)); \/\/ Lui\n+  Assembler::patch(instruction_address + (MacroAssembler::instruction_size * 0), 31, 12, (upper18 & 0xfffff)); \/\/ Lui\n+  Assembler::patch(instruction_address + (MacroAssembler::instruction_size * 1), 31, 12, (mid18   & 0xfffff)); \/\/ Lui\n@@ -1451,1 +1582,1 @@\n-  Assembler::patch(instruction_address + (NativeInstruction::instruction_size * 4), 31, 20, low12 & 0xfff);      \/\/ Addi\/Jalr\/Load\n+  Assembler::patch(instruction_address + (MacroAssembler::instruction_size * 4), 31, 20, low12 & 0xfff);      \/\/ Addi\/Jalr\/Load\n@@ -1455,1 +1586,1 @@\n-  return NativeMovConstReg::movptr2_instruction_size;\n+  return MacroAssembler::movptr2_instruction_size;\n@@ -1476,1 +1607,1 @@\n-  return LI64_INSTRUCTIONS_NUM * NativeInstruction::instruction_size;\n+  return LI64_INSTRUCTIONS_NUM * MacroAssembler::instruction_size;\n@@ -1481,1 +1612,1 @@\n-  return NativeInstruction::instruction_size;\n+  return MacroAssembler::instruction_size;\n@@ -1492,1 +1623,1 @@\n-  return LI32_INSTRUCTIONS_NUM * NativeInstruction::instruction_size;\n+  return LI32_INSTRUCTIONS_NUM * MacroAssembler::instruction_size;\n@@ -1540,2 +1671,2 @@\n-  int32_t upper18 = ((Assembler::sextract(Assembler::ld_instr(insn_addr + NativeInstruction::instruction_size * 0), 31, 12)) & 0xfffff); \/\/ Lui\n-  int32_t mid18   = ((Assembler::sextract(Assembler::ld_instr(insn_addr + NativeInstruction::instruction_size * 1), 31, 12)) & 0xfffff); \/\/ Lui\n+  int32_t upper18 = ((Assembler::sextract(Assembler::ld_instr(insn_addr + MacroAssembler::instruction_size * 0), 31, 12)) & 0xfffff); \/\/ Lui\n+  int32_t mid18   = ((Assembler::sextract(Assembler::ld_instr(insn_addr + MacroAssembler::instruction_size * 1), 31, 12)) & 0xfffff); \/\/ Lui\n@@ -1544,1 +1675,1 @@\n-  int32_t low12  = ((Assembler::sextract(Assembler::ld_instr(insn_addr + NativeInstruction::instruction_size * 4), 31, 20))); \/\/ Addi\/Jalr\/Load.\n+  int32_t low12  = ((Assembler::sextract(Assembler::ld_instr(insn_addr + MacroAssembler::instruction_size * 4), 31, 20))); \/\/ Addi\/Jalr\/Load.\n@@ -1571,1 +1702,1 @@\n-  if (NativeInstruction::is_jal_at(instruction_address)) {                         \/\/ jal\n+  if (MacroAssembler::is_jal_at(instruction_address)) {                         \/\/ jal\n@@ -1573,1 +1704,1 @@\n-  } else if (NativeInstruction::is_branch_at(instruction_address)) {               \/\/ beq\/bge\/bgeu\/blt\/bltu\/bne\n+  } else if (MacroAssembler::is_branch_at(instruction_address)) {               \/\/ beq\/bge\/bgeu\/blt\/bltu\/bne\n@@ -1575,1 +1706,1 @@\n-  } else if (NativeInstruction::is_pc_relative_at(instruction_address)) {          \/\/ auipc, addi\/jalr\/load\n+  } else if (MacroAssembler::is_pc_relative_at(instruction_address)) {          \/\/ auipc, addi\/jalr\/load\n@@ -1577,1 +1708,1 @@\n-  } else if (NativeInstruction::is_movptr1_at(instruction_address)) {              \/\/ movptr1\n+  } else if (MacroAssembler::is_movptr1_at(instruction_address)) {              \/\/ movptr1\n@@ -1579,1 +1710,1 @@\n-  } else if (NativeInstruction::is_movptr2_at(instruction_address)) {              \/\/ movptr2\n+  } else if (MacroAssembler::is_movptr2_at(instruction_address)) {              \/\/ movptr2\n@@ -1581,1 +1712,1 @@\n-  } else if (NativeInstruction::is_li64_at(instruction_address)) {                 \/\/ li64\n+  } else if (MacroAssembler::is_li64_at(instruction_address)) {                 \/\/ li64\n@@ -1583,1 +1714,1 @@\n-  } else if (NativeInstruction::is_li32_at(instruction_address)) {                 \/\/ li32\n+  } else if (MacroAssembler::is_li32_at(instruction_address)) {                 \/\/ li32\n@@ -1586,1 +1717,1 @@\n-  } else if (NativeInstruction::is_li16u_at(instruction_address)) {\n+  } else if (MacroAssembler::is_li16u_at(instruction_address)) {\n@@ -1603,1 +1734,1 @@\n-  if (NativeInstruction::is_jal_at(insn_addr)) {                     \/\/ jal\n+  if (MacroAssembler::is_jal_at(insn_addr)) {                     \/\/ jal\n@@ -1605,1 +1736,1 @@\n-  } else if (NativeInstruction::is_branch_at(insn_addr)) {           \/\/ beq\/bge\/bgeu\/blt\/bltu\/bne\n+  } else if (MacroAssembler::is_branch_at(insn_addr)) {           \/\/ beq\/bge\/bgeu\/blt\/bltu\/bne\n@@ -1607,1 +1738,1 @@\n-  } else if (NativeInstruction::is_pc_relative_at(insn_addr)) {      \/\/ auipc, addi\/jalr\/load\n+  } else if (MacroAssembler::is_pc_relative_at(insn_addr)) {      \/\/ auipc, addi\/jalr\/load\n@@ -1609,1 +1740,1 @@\n-  } else if (NativeInstruction::is_movptr1_at(insn_addr)) {          \/\/ movptr1\n+  } else if (MacroAssembler::is_movptr1_at(insn_addr)) {          \/\/ movptr1\n@@ -1611,1 +1742,1 @@\n-  } else if (NativeInstruction::is_movptr2_at(insn_addr)) {          \/\/ movptr2\n+  } else if (MacroAssembler::is_movptr2_at(insn_addr)) {          \/\/ movptr2\n@@ -1613,1 +1744,1 @@\n-  } else if (NativeInstruction::is_li64_at(insn_addr)) {             \/\/ li64\n+  } else if (MacroAssembler::is_li64_at(insn_addr)) {             \/\/ li64\n@@ -1615,1 +1746,1 @@\n-  } else if (NativeInstruction::is_li32_at(insn_addr)) {             \/\/ li32\n+  } else if (MacroAssembler::is_li32_at(insn_addr)) {             \/\/ li32\n@@ -1627,1 +1758,1 @@\n-  if (NativeInstruction::is_li32_at(insn_addr)) {\n+  if (MacroAssembler::is_li32_at(insn_addr)) {\n@@ -1631,1 +1762,1 @@\n-  } else if (NativeInstruction::is_movptr1_at(insn_addr)) {\n+  } else if (MacroAssembler::is_movptr1_at(insn_addr)) {\n@@ -1634,1 +1765,1 @@\n-  } else if (NativeInstruction::is_movptr2_at(insn_addr)) {\n+  } else if (MacroAssembler::is_movptr2_at(insn_addr)) {\n@@ -2760,1 +2891,1 @@\n-  address prev = pc() - NativeMembar::instruction_size;\n+  address prev = pc() - MacroAssembler::instruction_size;\n@@ -2763,2 +2894,1 @@\n-  if (last != nullptr && nativeInstruction_at(last)->is_membar() && prev == last) {\n-    NativeMembar *bar = NativeMembar_at(prev);\n+  if (last != nullptr && is_membar(last) && prev == last) {\n@@ -2767,1 +2897,1 @@\n-    bar->set_kind(bar->get_kind() | order_constraint);\n+    set_membar_kind(prev, get_membar_kind(prev) | order_constraint);\n@@ -3634,1 +3764,1 @@\n-  return (NativeInstruction::instruction_size * (2 \/* 2 loads *\/ + 1 \/* branch *\/)) +\n+  return (MacroAssembler::instruction_size * (2 \/* 2 loads *\/ + 1 \/* branch *\/)) +\n@@ -3701,1 +3831,1 @@\n-  align(wordSize, NativeCallTrampolineStub::data_offset);\n+  align(wordSize, MacroAssembler::trampoline_stub_data_offset);\n@@ -3714,1 +3844,1 @@\n-    assert(offset() - stub_start_offset == NativeCallTrampolineStub::data_offset,\n+    assert(offset() - stub_start_offset == MacroAssembler::trampoline_stub_data_offset,\n@@ -3722,1 +3852,1 @@\n-  assert(is_NativeCallTrampolineStub_at(stub_start_addr), \"doesn't look like a trampoline\");\n+  assert(MacroAssembler::is_trampoline_stub_at(stub_start_addr), \"doesn't look like a trampoline\");\n@@ -3730,1 +3860,1 @@\n-  return NativeInstruction::instruction_size + NativeCallTrampolineStub::instruction_size;\n+  return MacroAssembler::instruction_size + MacroAssembler::trampoline_stub_instruction_size;\n@@ -3735,1 +3865,1 @@\n-  return 11 * NativeInstruction::instruction_size;\n+  return 11 * MacroAssembler::instruction_size;\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":173,"deletions":43,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"nativeInst_riscv.hpp\"\n@@ -45,0 +44,222 @@\n+  enum {\n+    instruction_size = 4,\n+    compressed_instruction_size = 2,\n+\n+    \/\/ Refer to function emit_trampoline_stub.\n+    trampoline_stub_instruction_size = 3 * instruction_size + wordSize, \/\/ auipc + ld + jr + target address\n+    trampoline_stub_data_offset      = 3 * instruction_size,            \/\/ auipc + ld + jr\n+\n+    \/\/ movptr\n+    movptr1_instruction_size = 6 * instruction_size, \/\/ lui, addi, slli, addi, slli, addi.  See movptr1().\n+    movptr2_instruction_size = 5 * instruction_size, \/\/ lui, lui, slli, add, addi.  See movptr2().\n+    load_pc_relative_instruction_size = 2 * instruction_size \/\/ auipc, ld\n+  };\n+\n+  static bool is_jal_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1101111; }\n+  static bool is_jalr_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1100111 && extract_funct3(instr) == 0b000; }\n+  static bool is_branch_at(address instr)     { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1100011; }\n+  static bool is_ld_at(address instr)         { assert_cond(instr != nullptr); return is_load_at(instr) && extract_funct3(instr) == 0b011; }\n+  static bool is_load_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0000011; }\n+  static bool is_float_load_at(address instr) { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0000111; }\n+  static bool is_auipc_at(address instr)      { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0010111; }\n+  static bool is_jump_at(address instr)       { assert_cond(instr != nullptr); return is_branch_at(instr) || is_jal_at(instr) || is_jalr_at(instr); }\n+  static bool is_add_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0110011 && extract_funct3(instr) == 0b000; }\n+  static bool is_addi_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0010011 && extract_funct3(instr) == 0b000; }\n+  static bool is_addiw_at(address instr)      { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0011011 && extract_funct3(instr) == 0b000; }\n+  static bool is_addiw_to_zr_at(address instr){ assert_cond(instr != nullptr); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n+  static bool is_lui_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0110111; }\n+  static bool is_lui_to_zr_at(address instr)  { assert_cond(instr != nullptr); return is_lui_at(instr) && extract_rd(instr) == zr; }\n+\n+  static bool is_srli_at(address instr) {\n+    assert_cond(instr != nullptr);\n+    return extract_opcode(instr) == 0b0010011 &&\n+           extract_funct3(instr) == 0b101 &&\n+           Assembler::extract(((unsigned*)instr)[0], 31, 26) == 0b000000;\n+  }\n+\n+  static bool is_slli_shift_at(address instr, uint32_t shift) {\n+    assert_cond(instr != nullptr);\n+    return (extract_opcode(instr) == 0b0010011 && \/\/ opcode field\n+            extract_funct3(instr) == 0b001 &&     \/\/ funct3 field, select the type of operation\n+            Assembler::extract(Assembler::ld_instr(instr), 25, 20) == shift);    \/\/ shamt field\n+  }\n+\n+  static Register extract_rs1(address instr);\n+  static Register extract_rs2(address instr);\n+  static Register extract_rd(address instr);\n+  static uint32_t extract_opcode(address instr);\n+  static uint32_t extract_funct3(address instr);\n+\n+  \/\/ the instruction sequence of movptr is as below:\n+  \/\/     lui\n+  \/\/     addi\n+  \/\/     slli\n+  \/\/     addi\n+  \/\/     slli\n+  \/\/     addi\/jalr\/load\n+  static bool check_movptr1_data_dependency(address instr) {\n+    address lui = instr;\n+    address addi1 = lui + instruction_size;\n+    address slli1 = addi1 + instruction_size;\n+    address addi2 = slli1 + instruction_size;\n+    address slli2 = addi2 + instruction_size;\n+    address last_instr = slli2 + instruction_size;\n+    return extract_rs1(addi1) == extract_rd(lui) &&\n+           extract_rs1(addi1) == extract_rd(addi1) &&\n+           extract_rs1(slli1) == extract_rd(addi1) &&\n+           extract_rs1(slli1) == extract_rd(slli1) &&\n+           extract_rs1(addi2) == extract_rd(slli1) &&\n+           extract_rs1(addi2) == extract_rd(addi2) &&\n+           extract_rs1(slli2) == extract_rd(addi2) &&\n+           extract_rs1(slli2) == extract_rd(slli2) &&\n+           extract_rs1(last_instr) == extract_rd(slli2);\n+  }\n+\n+  \/\/ the instruction sequence of movptr2 is as below:\n+  \/\/     lui\n+  \/\/     lui\n+  \/\/     slli\n+  \/\/     add\n+  \/\/     addi\/jalr\/load\n+  static bool check_movptr2_data_dependency(address instr) {\n+    address lui1 = instr;\n+    address lui2 = lui1 + instruction_size;\n+    address slli = lui2 + instruction_size;\n+    address add  = slli + instruction_size;\n+    address last_instr = add + instruction_size;\n+    return extract_rd(add) == extract_rd(lui2) &&\n+           extract_rs1(add) == extract_rd(lui2) &&\n+           extract_rs2(add) == extract_rd(slli) &&\n+           extract_rs1(slli) == extract_rd(lui1) &&\n+           extract_rd(slli) == extract_rd(lui1) &&\n+           extract_rs1(last_instr) == extract_rd(add);\n+  }\n+\n+  \/\/ the instruction sequence of li64 is as below:\n+  \/\/     lui\n+  \/\/     addi\n+  \/\/     slli\n+  \/\/     addi\n+  \/\/     slli\n+  \/\/     addi\n+  \/\/     slli\n+  \/\/     addi\n+  static bool check_li64_data_dependency(address instr) {\n+    address lui = instr;\n+    address addi1 = lui + instruction_size;\n+    address slli1 = addi1 + instruction_size;\n+    address addi2 = slli1 + instruction_size;\n+    address slli2 = addi2 + instruction_size;\n+    address addi3 = slli2 + instruction_size;\n+    address slli3 = addi3 + instruction_size;\n+    address addi4 = slli3 + instruction_size;\n+    return extract_rs1(addi1) == extract_rd(lui) &&\n+           extract_rs1(addi1) == extract_rd(addi1) &&\n+           extract_rs1(slli1) == extract_rd(addi1) &&\n+           extract_rs1(slli1) == extract_rd(slli1) &&\n+           extract_rs1(addi2) == extract_rd(slli1) &&\n+           extract_rs1(addi2) == extract_rd(addi2) &&\n+           extract_rs1(slli2) == extract_rd(addi2) &&\n+           extract_rs1(slli2) == extract_rd(slli2) &&\n+           extract_rs1(addi3) == extract_rd(slli2) &&\n+           extract_rs1(addi3) == extract_rd(addi3) &&\n+           extract_rs1(slli3) == extract_rd(addi3) &&\n+           extract_rs1(slli3) == extract_rd(slli3) &&\n+           extract_rs1(addi4) == extract_rd(slli3) &&\n+           extract_rs1(addi4) == extract_rd(addi4);\n+  }\n+\n+  \/\/ the instruction sequence of li16u is as below:\n+  \/\/     lui\n+  \/\/     srli\n+  static bool check_li16u_data_dependency(address instr) {\n+    address lui = instr;\n+    address srli = lui + instruction_size;\n+\n+    return extract_rs1(srli) == extract_rd(lui) &&\n+           extract_rs1(srli) == extract_rd(srli);\n+  }\n+\n+  \/\/ the instruction sequence of li32 is as below:\n+  \/\/     lui\n+  \/\/     addiw\n+  static bool check_li32_data_dependency(address instr) {\n+    address lui = instr;\n+    address addiw = lui + instruction_size;\n+\n+    return extract_rs1(addiw) == extract_rd(lui) &&\n+           extract_rs1(addiw) == extract_rd(addiw);\n+  }\n+\n+  \/\/ the instruction sequence of pc-relative is as below:\n+  \/\/     auipc\n+  \/\/     jalr\/addi\/load\/float_load\n+  static bool check_pc_relative_data_dependency(address instr) {\n+    address auipc = instr;\n+    address last_instr = auipc + instruction_size;\n+\n+    return extract_rs1(last_instr) == extract_rd(auipc);\n+  }\n+\n+  \/\/ the instruction sequence of load_label is as below:\n+  \/\/     auipc\n+  \/\/     load\n+  static bool check_load_pc_relative_data_dependency(address instr) {\n+    address auipc = instr;\n+    address load = auipc + instruction_size;\n+\n+    return extract_rd(load) == extract_rd(auipc) &&\n+           extract_rs1(load) == extract_rd(load);\n+  }\n+\n+  static bool is_movptr1_at(address instr);\n+  static bool is_movptr2_at(address instr);\n+  static bool is_li16u_at(address instr);\n+  static bool is_li32_at(address instr);\n+  static bool is_li64_at(address instr);\n+  static bool is_pc_relative_at(address branch);\n+  static bool is_load_pc_relative_at(address branch);\n+\n+  static bool is_call_at(address instr) {\n+    if (is_jal_at(instr) || is_jalr_at(instr)) {\n+      return true;\n+    }\n+    return false;\n+  }\n+  static bool is_lwu_to_zr(address instr);\n+\n+  static bool is_trampoline_stub_at(address addr) {\n+    \/\/ Ensure that the stub is exactly\n+    \/\/      ld   t0, L--->auipc + ld\n+    \/\/      jr   t0\n+    \/\/ L:\n+\n+    \/\/ judge inst + register + imm\n+    \/\/ 1). check the instructions: auipc + ld + jalr\n+    \/\/ 2). check if auipc[11:7] == t0 and ld[11:7] == t0 and ld[19:15] == t0 && jr[19:15] == t0\n+    \/\/ 3). check if the offset in ld[31:20] equals the data_offset\n+    assert_cond(addr != nullptr);\n+    const int instr_size = instruction_size;\n+    if (is_auipc_at(addr) &&\n+        is_ld_at(addr + instr_size) &&\n+        is_jalr_at(addr + 2 * instr_size) &&\n+        (extract_rd(addr)                    == x5) &&\n+        (extract_rd(addr + instr_size)       == x5) &&\n+        (extract_rs1(addr + instr_size)      == x5) &&\n+        (extract_rs1(addr + 2 * instr_size)  == x5) &&\n+        (Assembler::extract(Assembler::ld_instr(addr + 4), 31, 20) == trampoline_stub_data_offset)) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+ private:\n+\n+  static bool is_membar(address addr) {\n+    return (Bytes::get_native_u4(addr) & 0x7f) == 0b1111 && extract_funct3(addr) == 0;\n+  }\n+  static uint32_t get_membar_kind(address addr);\n+  static void set_membar_kind(address addr, uint32_t order_kind);\n+\n+ public:\n+\n@@ -52,1 +273,1 @@\n-  static inline void assert_alignment(address pc, int alignment = NativeInstruction::instruction_size) {\n+  static inline void assert_alignment(address pc, int alignment = MacroAssembler::instruction_size) {\n@@ -1235,1 +1456,1 @@\n-  int ic_check(int end_alignment = NativeInstruction::instruction_size);\n+  int ic_check(int end_alignment = MacroAssembler::instruction_size);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":224,"deletions":3,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -42,92 +42,0 @@\n-Register NativeInstruction::extract_rs1(address instr) {\n-  assert_cond(instr != nullptr);\n-  return as_Register(Assembler::extract(Assembler::ld_instr(instr), 19, 15));\n-}\n-\n-Register NativeInstruction::extract_rs2(address instr) {\n-  assert_cond(instr != nullptr);\n-  return as_Register(Assembler::extract(Assembler::ld_instr(instr), 24, 20));\n-}\n-\n-Register NativeInstruction::extract_rd(address instr) {\n-  assert_cond(instr != nullptr);\n-  return as_Register(Assembler::extract(Assembler::ld_instr(instr), 11, 7));\n-}\n-\n-uint32_t NativeInstruction::extract_opcode(address instr) {\n-  assert_cond(instr != nullptr);\n-  return Assembler::extract(Assembler::ld_instr(instr), 6, 0);\n-}\n-\n-uint32_t NativeInstruction::extract_funct3(address instr) {\n-  assert_cond(instr != nullptr);\n-  return Assembler::extract(Assembler::ld_instr(instr), 14, 12);\n-}\n-\n-bool NativeInstruction::is_pc_relative_at(address instr) {\n-  \/\/ auipc + jalr\n-  \/\/ auipc + addi\n-  \/\/ auipc + load\n-  \/\/ auipc + fload_load\n-  return (is_auipc_at(instr)) &&\n-         (is_addi_at(instr + instruction_size) ||\n-          is_jalr_at(instr + instruction_size) ||\n-          is_load_at(instr + instruction_size) ||\n-          is_float_load_at(instr + instruction_size)) &&\n-         check_pc_relative_data_dependency(instr);\n-}\n-\n-\/\/ ie:ld(Rd, Label)\n-bool NativeInstruction::is_load_pc_relative_at(address instr) {\n-  return is_auipc_at(instr) && \/\/ auipc\n-         is_ld_at(instr + instruction_size) && \/\/ ld\n-         check_load_pc_relative_data_dependency(instr);\n-}\n-\n-bool NativeInstruction::is_movptr1_at(address instr) {\n-  return is_lui_at(instr) && \/\/ Lui\n-         is_addi_at(instr + instruction_size) && \/\/ Addi\n-         is_slli_shift_at(instr + instruction_size * 2, 11) && \/\/ Slli Rd, Rs, 11\n-         is_addi_at(instr + instruction_size * 3) && \/\/ Addi\n-         is_slli_shift_at(instr + instruction_size * 4, 6) && \/\/ Slli Rd, Rs, 6\n-         (is_addi_at(instr + instruction_size * 5) ||\n-          is_jalr_at(instr + instruction_size * 5) ||\n-          is_load_at(instr + instruction_size * 5)) && \/\/ Addi\/Jalr\/Load\n-         check_movptr1_data_dependency(instr);\n-}\n-\n-bool NativeInstruction::is_movptr2_at(address instr) {\n-  return is_lui_at(instr) && \/\/ lui\n-         is_lui_at(instr + instruction_size) && \/\/ lui\n-         is_slli_shift_at(instr + instruction_size * 2, 18) && \/\/ slli Rd, Rs, 18\n-         is_add_at(instr + instruction_size * 3) &&\n-         (is_addi_at(instr + instruction_size * 4) ||\n-          is_jalr_at(instr + instruction_size * 4) ||\n-          is_load_at(instr + instruction_size * 4)) && \/\/ Addi\/Jalr\/Load\n-         check_movptr2_data_dependency(instr);\n-}\n-\n-bool NativeInstruction::is_li16u_at(address instr) {\n-  return is_lui_at(instr) && \/\/ lui\n-         is_srli_at(instr + instruction_size) && \/\/ srli\n-         check_li16u_data_dependency(instr);\n-}\n-\n-bool NativeInstruction::is_li32_at(address instr) {\n-  return is_lui_at(instr) && \/\/ lui\n-         is_addiw_at(instr + instruction_size) && \/\/ addiw\n-         check_li32_data_dependency(instr);\n-}\n-\n-bool NativeInstruction::is_li64_at(address instr) {\n-  return is_lui_at(instr) && \/\/ lui\n-         is_addi_at(instr + instruction_size) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 2, 12) &&  \/\/ Slli Rd, Rs, 12\n-         is_addi_at(instr + instruction_size * 3) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 4, 12) &&  \/\/ Slli Rd, Rs, 12\n-         is_addi_at(instr + instruction_size * 5) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 6, 8) &&   \/\/ Slli Rd, Rs, 8\n-         is_addi_at(instr + instruction_size * 7) && \/\/ addi\n-         check_li64_data_dependency(instr);\n-}\n-\n@@ -135,1 +43,1 @@\n-  assert(NativeCall::is_call_at((address)this), \"unexpected code at call site\");\n+  assert(MacroAssembler::is_call_at((address)this), \"unexpected code at call site\");\n@@ -140,1 +48,1 @@\n-  assert(NativeInstruction::is_jal_at(instruction_address()), \"inst must be jal.\");\n+  assert(MacroAssembler::is_jal_at(instruction_address()), \"inst must be jal.\");\n@@ -147,1 +55,1 @@\n-  if (nm != nullptr && nm->stub_contains(destination) && is_NativeCallTrampolineStub_at(destination)) {\n+  if (nm != nullptr && nm->stub_contains(destination) && MacroAssembler::is_trampoline_stub_at(destination)) {\n@@ -171,1 +79,1 @@\n-  assert(NativeCall::is_call_at(addr_call), \"unexpected code at call site\");\n+  assert(MacroAssembler::is_call_at(addr_call), \"unexpected code at call site\");\n@@ -176,1 +84,1 @@\n-    assert (!is_NativeCallTrampolineStub_at(dest), \"chained trampolines\");\n+    assert (!MacroAssembler::is_trampoline_stub_at(dest), \"chained trampolines\");\n@@ -198,1 +106,1 @@\n-  if (code != nullptr && code->contains(jal_destination) && is_NativeCallTrampolineStub_at(jal_destination)) {\n+  if (code != nullptr && code->contains(jal_destination) && MacroAssembler::is_trampoline_stub_at(jal_destination)) {\n@@ -344,8 +252,1 @@\n-  return is_lwu_to_zr(address(this));\n-}\n-\n-bool NativeInstruction::is_lwu_to_zr(address instr) {\n-  assert_cond(instr != nullptr);\n-  return (extract_opcode(instr) == 0b0000011 &&\n-          extract_funct3(instr) == 0b110 &&\n-          extract_rd(instr) == zr);         \/\/ zr\n+  return MacroAssembler::is_lwu_to_zr(address(this));\n@@ -438,24 +339,0 @@\n-uint32_t NativeMembar::get_kind() {\n-  uint32_t insn = uint_at(0);\n-\n-  uint32_t predecessor = Assembler::extract(insn, 27, 24);\n-  uint32_t successor = Assembler::extract(insn, 23, 20);\n-\n-  return MacroAssembler::pred_succ_to_membar_mask(predecessor, successor);\n-}\n-\n-void NativeMembar::set_kind(uint32_t order_kind) {\n-  uint32_t predecessor = 0;\n-  uint32_t successor = 0;\n-\n-  MacroAssembler::membar_mask_to_pred_succ(order_kind, predecessor, successor);\n-\n-  uint32_t insn = uint_at(0);\n-  address pInsn = (address) &insn;\n-  Assembler::patch(pInsn, 27, 24, predecessor);\n-  Assembler::patch(pInsn, 23, 20, successor);\n-\n-  address membar = addr_at(0);\n-  Assembler::sd_instr(membar, insn);\n-}\n-\n@@ -484,1 +361,1 @@\n-  assert(is_lui_to_zr_at(addr_at(4)) && is_addiw_to_zr_at(addr_at(8)), \"must be\");\n+  assert(MacroAssembler::is_lui_to_zr_at(addr_at(4)) && MacroAssembler::is_addiw_to_zr_at(addr_at(8)), \"must be\");\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":8,"deletions":131,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"macroAssembler_riscv.hpp\"\n@@ -55,1 +56,0 @@\n-  friend bool is_NativeCallTrampolineStub_at(address);\n@@ -58,2 +58,2 @@\n-    instruction_size = 4,\n-    compressed_instruction_size = 2,\n+    instruction_size = MacroAssembler::instruction_size,\n+    compressed_instruction_size = MacroAssembler::compressed_instruction_size,\n@@ -66,181 +66,8 @@\n-  bool is_jal()                             const { return is_jal_at(addr_at(0));         }\n-  bool is_movptr()                          const { return is_movptr1_at(addr_at(0)) ||\n-                                                           is_movptr2_at(addr_at(0));     }\n-  bool is_movptr1()                         const { return is_movptr1_at(addr_at(0));     }\n-  bool is_movptr2()                         const { return is_movptr2_at(addr_at(0));     }\n-  bool is_auipc()                           const { return is_auipc_at(addr_at(0));       }\n-  bool is_call()                            const { return is_call_at(addr_at(0));        }\n-  bool is_jump()                            const { return is_jump_at(addr_at(0));        }\n-\n-  static bool is_jal_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1101111; }\n-  static bool is_jalr_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1100111 && extract_funct3(instr) == 0b000; }\n-  static bool is_branch_at(address instr)     { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b1100011; }\n-  static bool is_ld_at(address instr)         { assert_cond(instr != nullptr); return is_load_at(instr) && extract_funct3(instr) == 0b011; }\n-  static bool is_load_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0000011; }\n-  static bool is_float_load_at(address instr) { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0000111; }\n-  static bool is_auipc_at(address instr)      { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0010111; }\n-  static bool is_jump_at(address instr)       { assert_cond(instr != nullptr); return is_branch_at(instr) || is_jal_at(instr) || is_jalr_at(instr); }\n-  static bool is_add_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0110011 && extract_funct3(instr) == 0b000; }\n-  static bool is_addi_at(address instr)       { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0010011 && extract_funct3(instr) == 0b000; }\n-  static bool is_addiw_at(address instr)      { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0011011 && extract_funct3(instr) == 0b000; }\n-  static bool is_addiw_to_zr_at(address instr){ assert_cond(instr != nullptr); return is_addiw_at(instr) && extract_rd(instr) == zr; }\n-  static bool is_lui_at(address instr)        { assert_cond(instr != nullptr); return extract_opcode(instr) == 0b0110111; }\n-  static bool is_lui_to_zr_at(address instr)  { assert_cond(instr != nullptr); return is_lui_at(instr) && extract_rd(instr) == zr; }\n-\n-  static bool is_srli_at(address instr) {\n-    assert_cond(instr != nullptr);\n-    return extract_opcode(instr) == 0b0010011 &&\n-           extract_funct3(instr) == 0b101 &&\n-           Assembler::extract(((unsigned*)instr)[0], 31, 26) == 0b000000;\n-  }\n-\n-  static bool is_slli_shift_at(address instr, uint32_t shift) {\n-    assert_cond(instr != nullptr);\n-    return (extract_opcode(instr) == 0b0010011 && \/\/ opcode field\n-            extract_funct3(instr) == 0b001 &&     \/\/ funct3 field, select the type of operation\n-            Assembler::extract(Assembler::ld_instr(instr), 25, 20) == shift);    \/\/ shamt field\n-  }\n-\n-  static Register extract_rs1(address instr);\n-  static Register extract_rs2(address instr);\n-  static Register extract_rd(address instr);\n-  static uint32_t extract_opcode(address instr);\n-  static uint32_t extract_funct3(address instr);\n-\n-  \/\/ the instruction sequence of movptr is as below:\n-  \/\/     lui\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\/jalr\/load\n-  static bool check_movptr1_data_dependency(address instr) {\n-    address lui = instr;\n-    address addi1 = lui + instruction_size;\n-    address slli1 = addi1 + instruction_size;\n-    address addi2 = slli1 + instruction_size;\n-    address slli2 = addi2 + instruction_size;\n-    address last_instr = slli2 + instruction_size;\n-    return extract_rs1(addi1) == extract_rd(lui) &&\n-           extract_rs1(addi1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(slli2) &&\n-           extract_rs1(last_instr) == extract_rd(slli2);\n-  }\n-\n-  \/\/ the instruction sequence of movptr2 is as below:\n-  \/\/     lui\n-  \/\/     lui\n-  \/\/     slli\n-  \/\/     add\n-  \/\/     addi\/jalr\/load\n-  static bool check_movptr2_data_dependency(address instr) {\n-    address lui1 = instr;\n-    address lui2 = lui1 + instruction_size;\n-    address slli = lui2 + instruction_size;\n-    address add  = slli + instruction_size;\n-    address last_instr = add + instruction_size;\n-    return extract_rd(add) == extract_rd(lui2) &&\n-           extract_rs1(add) == extract_rd(lui2) &&\n-           extract_rs2(add) == extract_rd(slli) &&\n-           extract_rs1(slli) == extract_rd(lui1) &&\n-           extract_rd(slli) == extract_rd(lui1) &&\n-           extract_rs1(last_instr) == extract_rd(add);\n-  }\n-\n-  \/\/ the instruction sequence of li64 is as below:\n-  \/\/     lui\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  static bool check_li64_data_dependency(address instr) {\n-    address lui = instr;\n-    address addi1 = lui + instruction_size;\n-    address slli1 = addi1 + instruction_size;\n-    address addi2 = slli1 + instruction_size;\n-    address slli2 = addi2 + instruction_size;\n-    address addi3 = slli2 + instruction_size;\n-    address slli3 = addi3 + instruction_size;\n-    address addi4 = slli3 + instruction_size;\n-    return extract_rs1(addi1) == extract_rd(lui) &&\n-           extract_rs1(addi1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(addi4);\n-  }\n-\n-  \/\/ the instruction sequence of li16u is as below:\n-  \/\/     lui\n-  \/\/     srli\n-  static bool check_li16u_data_dependency(address instr) {\n-    address lui = instr;\n-    address srli = lui + instruction_size;\n-\n-    return extract_rs1(srli) == extract_rd(lui) &&\n-           extract_rs1(srli) == extract_rd(srli);\n-  }\n-\n-  \/\/ the instruction sequence of li32 is as below:\n-  \/\/     lui\n-  \/\/     addiw\n-  static bool check_li32_data_dependency(address instr) {\n-    address lui = instr;\n-    address addiw = lui + instruction_size;\n-\n-    return extract_rs1(addiw) == extract_rd(lui) &&\n-           extract_rs1(addiw) == extract_rd(addiw);\n-  }\n-\n-  \/\/ the instruction sequence of pc-relative is as below:\n-  \/\/     auipc\n-  \/\/     jalr\/addi\/load\/float_load\n-  static bool check_pc_relative_data_dependency(address instr) {\n-    address auipc = instr;\n-    address last_instr = auipc + instruction_size;\n-\n-    return extract_rs1(last_instr) == extract_rd(auipc);\n-  }\n-\n-  \/\/ the instruction sequence of load_label is as below:\n-  \/\/     auipc\n-  \/\/     load\n-  static bool check_load_pc_relative_data_dependency(address instr) {\n-    address auipc = instr;\n-    address load = auipc + instruction_size;\n-\n-    return extract_rd(load) == extract_rd(auipc) &&\n-           extract_rs1(load) == extract_rd(load);\n-  }\n-\n-  static bool is_movptr1_at(address instr);\n-  static bool is_movptr2_at(address instr);\n-  static bool is_li16u_at(address instr);\n-  static bool is_li32_at(address instr);\n-  static bool is_li64_at(address instr);\n-  static bool is_pc_relative_at(address branch);\n-  static bool is_load_pc_relative_at(address branch);\n-\n-  static bool is_call_at(address instr) {\n-    if (is_jal_at(instr) || is_jalr_at(instr)) {\n-      return true;\n-    }\n-    return false;\n-  }\n-  static bool is_lwu_to_zr(address instr);\n+  bool is_jal()                             const { return MacroAssembler::is_jal_at(addr_at(0));         }\n+  bool is_movptr()                          const { return MacroAssembler::is_movptr1_at(addr_at(0)) ||\n+                                                           MacroAssembler::is_movptr2_at(addr_at(0));     }\n+  bool is_movptr1()                         const { return MacroAssembler::is_movptr1_at(addr_at(0));     }\n+  bool is_movptr2()                         const { return MacroAssembler::is_movptr2_at(addr_at(0));     }\n+  bool is_auipc()                           const { return MacroAssembler::is_auipc_at(addr_at(0));       }\n+  bool is_call()                            const { return MacroAssembler::is_call_at(addr_at(0));        }\n+  bool is_jump()                            const { return MacroAssembler::is_jump_at(addr_at(0));        }\n@@ -275,5 +102,1 @@\n-    return is_auipc_at(instr);\n-  }\n-\n-  bool is_membar() {\n-    return (uint_at(0) & 0x7f) == 0b1111 && extract_funct3(addr_at(0)) == 0;\n+    return MacroAssembler::is_auipc_at(instr);\n@@ -335,1 +158,1 @@\n-    return is_call_at(return_address - NativeCall::return_address_offset);\n+    return MacroAssembler::is_call_at(return_address - NativeCall::return_address_offset);\n@@ -380,3 +203,3 @@\n-    movptr1_instruction_size            =    6 * NativeInstruction::instruction_size, \/\/ lui, addi, slli, addi, slli, addi.  See movptr1().\n-    movptr2_instruction_size            =    5 * NativeInstruction::instruction_size, \/\/ lui, lui, slli, add, addi.  See movptr2().\n-    load_pc_relative_instruction_size   =    2 * NativeInstruction::instruction_size  \/\/ auipc, ld\n+    movptr1_instruction_size            =    MacroAssembler::movptr1_instruction_size, \/\/ lui, addi, slli, addi, slli, addi.  See movptr1().\n+    movptr2_instruction_size            =    MacroAssembler::movptr2_instruction_size, \/\/ lui, lui, slli, add, addi.  See movptr2().\n+    load_pc_relative_instruction_size   =    MacroAssembler::load_pc_relative_instruction_size \/\/ auipc, ld\n@@ -392,2 +215,2 @@\n-    if (is_movptr1_at(instruction_address())) {\n-      if (is_addi_at(addr_at(movptr1_instruction_size - NativeInstruction::instruction_size))) {\n+    if (MacroAssembler::is_movptr1_at(instruction_address())) {\n+      if (MacroAssembler::is_addi_at(addr_at(movptr1_instruction_size - NativeInstruction::instruction_size))) {\n@@ -400,2 +223,2 @@\n-    } else if (is_movptr2_at(instruction_address())) {\n-      if (is_addi_at(addr_at(movptr2_instruction_size - NativeInstruction::instruction_size))) {\n+    } else if (MacroAssembler::is_movptr2_at(instruction_address())) {\n+      if (MacroAssembler::is_addi_at(addr_at(movptr2_instruction_size - NativeInstruction::instruction_size))) {\n@@ -408,1 +231,1 @@\n-    } else if (is_load_pc_relative_at(instruction_address())) {\n+    } else if (MacroAssembler::is_load_pc_relative_at(instruction_address())) {\n@@ -551,2 +374,2 @@\n-    instruction_size = 3 * NativeInstruction::instruction_size + wordSize, \/\/ auipc + ld + jr + target address\n-    data_offset      = 3 * NativeInstruction::instruction_size,            \/\/ auipc + ld + jr\n+    instruction_size = MacroAssembler::trampoline_stub_instruction_size, \/\/ auipc + ld + jr + target address\n+    data_offset      = MacroAssembler::trampoline_stub_data_offset,      \/\/ auipc + ld + jr\n@@ -560,25 +383,0 @@\n-inline bool is_NativeCallTrampolineStub_at(address addr) {\n-  \/\/ Ensure that the stub is exactly\n-  \/\/      ld   t0, L--->auipc + ld\n-  \/\/      jr   t0\n-  \/\/ L:\n-\n-  \/\/ judge inst + register + imm\n-  \/\/ 1). check the instructions: auipc + ld + jalr\n-  \/\/ 2). check if auipc[11:7] == t0 and ld[11:7] == t0 and ld[19:15] == t0 && jr[19:15] == t0\n-  \/\/ 3). check if the offset in ld[31:20] equals the data_offset\n-  assert_cond(addr != nullptr);\n-  const int instr_size = NativeInstruction::instruction_size;\n-  if (NativeInstruction::is_auipc_at(addr) &&\n-      NativeInstruction::is_ld_at(addr + instr_size) &&\n-      NativeInstruction::is_jalr_at(addr + 2 * instr_size) &&\n-      (NativeInstruction::extract_rd(addr)                    == x5) &&\n-      (NativeInstruction::extract_rd(addr + instr_size)       == x5) &&\n-      (NativeInstruction::extract_rs1(addr + instr_size)      == x5) &&\n-      (NativeInstruction::extract_rs1(addr + 2 * instr_size)  == x5) &&\n-      (Assembler::extract(Assembler::ld_instr(addr + 4), 31, 20) == NativeCallTrampolineStub::data_offset)) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n@@ -587,1 +385,1 @@\n-  assert(is_NativeCallTrampolineStub_at(addr), \"no call trampoline found\");\n+  assert(MacroAssembler::is_trampoline_stub_at(addr), \"no call trampoline found\");\n@@ -591,12 +389,0 @@\n-class NativeMembar : public NativeInstruction {\n-public:\n-  uint32_t get_kind();\n-  void set_kind(uint32_t order_kind);\n-};\n-\n-inline NativeMembar *NativeMembar_at(address addr) {\n-  assert_cond(addr != nullptr);\n-  assert(nativeInstruction_at(addr)->is_membar(), \"no membar found\");\n-  return (NativeMembar*)addr;\n-}\n-\n@@ -616,1 +402,1 @@\n-    return is_nop() && is_lui_to_zr_at(addr_at(4));\n+    return is_nop() && MacroAssembler::is_lui_to_zr_at(addr_at(4));\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":25,"deletions":239,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-      if (NativeInstruction::is_load_pc_relative_at(addr())) {\n+      if (MacroAssembler::is_load_pc_relative_at(addr())) {\n@@ -63,1 +63,1 @@\n-  if (NativeCall::is_call_at(addr())) {\n+  if (MacroAssembler::is_call_at(addr())) {\n@@ -84,1 +84,1 @@\n-  if (NativeCall::is_call_at(addr())) {\n+  if (MacroAssembler::is_call_at(addr())) {\n@@ -97,1 +97,1 @@\n-  assert(NativeCall::is_load_pc_relative_at(addr()), \"Not the expected instruction sequence!\");\n+  assert(MacroAssembler::is_load_pc_relative_at(addr()), \"Not the expected instruction sequence!\");\n","filename":"src\/hotspot\/cpu\/riscv\/relocInfo_riscv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}