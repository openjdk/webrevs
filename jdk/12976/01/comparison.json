{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -633,1 +633,1 @@\n-                            Stream<T> s = c.getStream(1);\n+                            Stream<T> s = c.getInitialStream();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import jdk.internal.net.http.common.HeaderDecoder;\n@@ -66,0 +67,1 @@\n+import jdk.internal.net.http.common.ValidatingHeadersConsumer;\n@@ -320,0 +322,1 @@\n+    private volatile Stream<?> initialStream;\n@@ -373,0 +376,1 @@\n+        this.initialStream = initialStream;\n@@ -811,1 +815,1 @@\n-                    DecodingCallback decoder = new ValidatingHeadersConsumer();\n+                    DecodingCallback decoder = new ValidatingHeadersConsumer()::onDecoded;\n@@ -913,1 +917,1 @@\n-        decodeHeaders(pp, decoder);\n+        decodeHeaders(pp, decoder::onDecoded);\n@@ -925,1 +929,1 @@\n-        decodeHeaders(cf, pcs.pushContDecoder);\n+        decodeHeaders(cf, pcs.pushContDecoder::onDecoded);\n@@ -1207,0 +1211,15 @@\n+    \/**\n+     * Called do get the initial stream after a connection upgrade.\n+     * If the stream was cancelled, it might no longer be in the\n+     * stream map. Therefore - we use the initialStream field\n+     * instead, and reset it to null after returning it.\n+     * @param <T> the response type\n+     * @return the initial stream created during the upgrade.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    <T> Stream<T> getInitialStream() {\n+         var s = (Stream<T>) initialStream;\n+         initialStream = null;\n+         return s;\n+    }\n+\n@@ -1539,70 +1558,0 @@\n-    static class HeaderDecoder extends ValidatingHeadersConsumer {\n-\n-        HttpHeadersBuilder headersBuilder;\n-\n-        HeaderDecoder() {\n-            this.headersBuilder = new HttpHeadersBuilder();\n-        }\n-\n-        @Override\n-        public void onDecoded(CharSequence name, CharSequence value) {\n-            String n = name.toString();\n-            String v = value.toString();\n-            super.onDecoded(n, v);\n-            headersBuilder.addHeader(n, v);\n-        }\n-\n-        HttpHeaders headers() {\n-            return headersBuilder.build();\n-        }\n-    }\n-\n-    \/*\n-     * Checks RFC 7540 rules (relaxed) compliance regarding pseudo-headers.\n-     *\/\n-    static class ValidatingHeadersConsumer implements DecodingCallback {\n-\n-        private static final Set<String> PSEUDO_HEADERS =\n-                Set.of(\":authority\", \":method\", \":path\", \":scheme\", \":status\");\n-\n-        \/** Used to check that if there are pseudo-headers, they go first *\/\n-        private boolean pseudoHeadersEnded;\n-\n-        \/**\n-         * Called when END_HEADERS was received. This consumer may be invoked\n-         * again after reset() is called, but for a whole new set of headers.\n-         *\/\n-        void reset() {\n-            pseudoHeadersEnded = false;\n-        }\n-\n-        @Override\n-        public void onDecoded(CharSequence name, CharSequence value)\n-                throws UncheckedIOException\n-        {\n-            String n = name.toString();\n-            if (n.startsWith(\":\")) {\n-                if (pseudoHeadersEnded) {\n-                    throw newException(\"Unexpected pseudo-header '%s'\", n);\n-                } else if (!PSEUDO_HEADERS.contains(n)) {\n-                    throw newException(\"Unknown pseudo-header '%s'\", n);\n-                }\n-            } else {\n-                pseudoHeadersEnded = true;\n-                if (!Utils.isValidName(n)) {\n-                    throw newException(\"Bad header name '%s'\", n);\n-                }\n-            }\n-            String v = value.toString();\n-            if (!Utils.isValidValue(v)) {\n-                throw newException(\"Bad header value '%s'\", v);\n-            }\n-        }\n-\n-        private UncheckedIOException newException(String message, String header)\n-        {\n-            return new UncheckedIOException(\n-                    new IOException(String.format(message, header)));\n-        }\n-    }\n-\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":22,"deletions":73,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -503,1 +503,1 @@\n-        return rspHeadersConsumer;\n+        return rspHeadersConsumer::onDecoded;\n@@ -1580,1 +1580,1 @@\n-    private class HeadersConsumer extends Http2Connection.ValidatingHeadersConsumer {\n+    private class HeadersConsumer extends ValidatingHeadersConsumer {\n@@ -1582,1 +1582,2 @@\n-        void reset() {\n+        @Override\n+        public void reset() {\n@@ -1592,7 +1593,15 @@\n-            String n = name.toString();\n-            String v = value.toString();\n-            super.onDecoded(n, v);\n-            responseHeadersBuilder.addHeader(n, v);\n-            if (Log.headers() && Log.trace()) {\n-                Log.logTrace(\"RECEIVED HEADER (streamid={0}): {1}: {2}\",\n-                             streamid, n, v);\n+            try {\n+                String n = name.toString();\n+                String v = value.toString();\n+                super.onDecoded(n, v);\n+                responseHeadersBuilder.addHeader(n, v);\n+                if (Log.headers() && Log.trace()) {\n+                    Log.logTrace(\"RECEIVED HEADER (streamid={0}): {1}: {2}\",\n+                            streamid, n, v);\n+                }\n+            } catch (UncheckedIOException uio) {\n+                \/\/ reset stream: From RFC 7540, section-8.1.2.6\n+                \/\/ Malformed requests or responses that are detected MUST be\n+                \/\/ treated as a stream error (Section 5.4.2) of type\n+                \/\/ PROTOCOL_ERROR.\n+                onProtocolError(uio.getCause());\n@@ -1601,0 +1610,5 @@\n+\n+        @Override\n+        protected String formatMessage(String message, String header) {\n+            return \"malformed response: \" + super.formatMessage(message, header);\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.net.http.common;\n+\n+import java.net.http.HttpHeaders;\n+\n+public class HeaderDecoder extends ValidatingHeadersConsumer {\n+\n+    private final HttpHeadersBuilder headersBuilder;\n+\n+    public HeaderDecoder() {\n+        this.headersBuilder = new HttpHeadersBuilder();\n+    }\n+\n+    @Override\n+    public void onDecoded(CharSequence name, CharSequence value) {\n+        String n = name.toString();\n+        String v = value.toString();\n+        super.onDecoded(n, v);\n+        headersBuilder.addHeader(n, v);\n+    }\n+\n+    public HttpHeaders headers() {\n+        return headersBuilder.build();\n+    }\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/HeaderDecoder.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -434,0 +434,2 @@\n+    private static final boolean[] LOWER_CASE_CHARS = new boolean[128];\n+\n@@ -439,5 +441,8 @@\n-        char[] allowedTokenChars =\n-                (\"!#$%&'*+-.^_`|~0123456789\" +\n-                 \"abcdefghijklmnopqrstuvwxyz\" +\n-                 \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").toCharArray();\n-        for (char c : allowedTokenChars) {\n+        char[] lcase = (\"!#$%&'*+-.^_`|~0123456789\" +\n+                \"abcdefghijklmnopqrstuvwxyz\").toCharArray();\n+        for (char c : lcase) {\n+            tchar[c] = true;\n+            LOWER_CASE_CHARS[c] = true;\n+        }\n+        char[] ucase = (\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\").toCharArray();\n+        for (char c : ucase) {\n@@ -452,0 +457,10 @@\n+    public static boolean isValidLowerCaseName(String token) {\n+        for (int i = 0; i < token.length(); i++) {\n+            char c = token.charAt(i);\n+            if (c > 255 || !LOWER_CASE_CHARS[c]) {\n+                return false;\n+            }\n+        }\n+        return !token.isEmpty();\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.net.http.common;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Set;\n+\n+\/*\n+ * Checks RFC 7540 rules (relaxed) compliance regarding pseudo-headers.\n+ *\/\n+public class ValidatingHeadersConsumer {\n+\n+    private static final Set<String> PSEUDO_HEADERS =\n+            Set.of(\":authority\", \":method\", \":path\", \":scheme\", \":status\");\n+\n+    \/** Used to check that if there are pseudo-headers, they go first *\/\n+    private boolean pseudoHeadersEnded;\n+\n+    \/**\n+     * Called when END_HEADERS was received. This consumer may be invoked\n+     * again after reset() is called, but for a whole new set of headers.\n+     *\/\n+    public void reset() {\n+        pseudoHeadersEnded = false;\n+    }\n+\n+    \/**\n+     * Called when a header field (name, value) pair has been decoded\n+     * @param name    the decoded name\n+     * @param value   the decoded value\n+     * @throws UncheckedIOException if the name or value are illegal\n+     *\/\n+    public void onDecoded(CharSequence name, CharSequence value)\n+            throws UncheckedIOException\n+    {\n+        String n = name.toString();\n+        if (n.startsWith(\":\")) {\n+            if (pseudoHeadersEnded) {\n+                throw newException(\"Unexpected pseudo-header '%s'\", n);\n+            } else if (!PSEUDO_HEADERS.contains(n)) {\n+                throw newException(\"Unknown pseudo-header '%s'\", n);\n+            }\n+        } else {\n+            pseudoHeadersEnded = true;\n+            \/\/ RFC-9113, section 8.2.1 for HTTP\/2 and RFC-9114, section 4.2 state that\n+            \/\/ header name MUST be lowercase (and allowed characters)\n+            if (!Utils.isValidLowerCaseName(n)) {\n+                throw newException(\"Bad header name '%s'\", n);\n+            }\n+        }\n+        String v = value.toString();\n+        if (!Utils.isValidValue(v)) {\n+            throw newException(\"Bad header value '%s'\", v);\n+        }\n+    }\n+\n+    protected String formatMessage(String message, String header) {\n+        return String.format(message, header);\n+    }\n+\n+    protected UncheckedIOException newException(String message, String header)\n+    {\n+        return new UncheckedIOException(\n+                new IOException(formatMessage(message, header)));\n+    }\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/ValidatingHeadersConsumer.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+ * @bug 8303965\n@@ -205,14 +206,20 @@\n-        assertTrue(throwable instanceof IOException,\n-                   \"Expected IOException, got, \" + throwable);\n-        assertTrue(throwable.getMessage().contains(\"protocol error\"),\n-                \"Expected \\\"protocol error\\\" in: \" + throwable.getMessage());\n-\n-        if (iterationIndex == 0) { \/\/ unknown\n-            assertTrue(throwable.getMessage().contains(\"Unknown pseudo-header\"),\n-                    \"Expected \\\"Unknown pseudo-header\\\" in: \" + throwable.getMessage());\n-        } else if (iterationIndex == 4) { \/\/ unexpected\n-            assertTrue(throwable.getMessage().contains(\" Unexpected pseudo-header\"),\n-                    \"Expected \\\" Unexpected pseudo-header\\\" in: \" + throwable.getMessage());\n-        } else {\n-            assertTrue(throwable.getMessage().contains(\"Bad header\"),\n-                    \"Expected \\\"Bad header\\\" in: \" + throwable.getMessage());\n+        try {\n+            assertTrue(throwable instanceof IOException,\n+                    \"Expected IOException, got, \" + throwable);\n+            assertTrue(throwable.getMessage().contains(\"malformed response\"),\n+                    \"Expected \\\"malformed response\\\" in: \" + throwable.getMessage());\n+\n+            if (iterationIndex == 0) { \/\/ unknown\n+                assertTrue(throwable.getMessage().contains(\"Unknown pseudo-header\"),\n+                        \"Expected \\\"Unknown pseudo-header\\\" in: \" + throwable.getMessage());\n+            } else if (iterationIndex == 4) { \/\/ unexpected\n+                assertTrue(throwable.getMessage().contains(\" Unexpected pseudo-header\"),\n+                        \"Expected \\\" Unexpected pseudo-header\\\" in: \" + throwable.getMessage());\n+            } else {\n+                assertTrue(throwable.getMessage().contains(\"Bad header\"),\n+                        \"Expected \\\"Bad header\\\" in: \" + throwable.getMessage());\n+            }\n+        } catch (AssertionError e) {\n+            System.out.println(\"Exception does not match expectation: \" + throwable);\n+            throwable.printStackTrace(System.out);\n+            throw e;\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/BadHeadersTest.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"}]}