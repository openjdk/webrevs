{"files":[{"patch":"@@ -424,2 +424,17 @@\n-        return exchImpl.sendBodyAsync()\n-                        .thenCompose(exIm -> exIm.getResponseAsync(executor));\n+        \/\/ don't wait until the body has been fully sent to\n+        \/\/ parse and return the response headers\n+        var sendBody = exchImpl.sendBodyAsync();\n+        CompletableFuture<Response> cf = exchImpl.getResponseAsync(executor);\n+        sendBody.exceptionally((t) -> {\n+            exchImpl.cancel(failed(Utils.toIOException(t)));\n+            cf.completeExceptionally(t);\n+            return exchImpl;\n+        });\n+        if (upgrading && !upgraded && request.bodyPublisher().isPresent()) {\n+            \/\/ when upgrading we must wait until the body has been sent\n+            \/\/ before creating the HTTP\/2 stream\n+            return cf.thenCompose(r -> r.statusCode == 101 \/\/ upgraded\n+                    ? CompletableFuture.allOf(sendBody, cf).thenCompose(rr -> cf)\n+                    : cf);\n+        }\n+        return cf;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-            } catch(Throwable t) {\n+            } catch (Throwable t) {\n@@ -272,1 +272,1 @@\n-        Throwable failed = null;\n+        Throwable failed;\n@@ -405,1 +405,2 @@\n-                        .thenAccept((s) -> requestMoreBody());\n+                        .thenAcceptAsync((s) -> requestMoreBody(),\n+                                exchange.executor().safeDelegate());\n@@ -453,4 +454,1 @@\n-        CompletableFuture<T> bodyCF = response.readBody(bs,\n-                                                        returnConnectionToPool,\n-                                                        executor);\n-        return bodyCF;\n+        return response.readBody(bs, returnConnectionToPool, executor);\n@@ -462,3 +460,1 @@\n-        Http1ResponseBodySubscriber<T> bs =\n-                new Http1ResponseBodySubscriber<T>(subscriber, this);\n-        return bs;\n+        return new Http1ResponseBodySubscriber<T>(subscriber, this);\n@@ -671,1 +667,1 @@\n-        final Executor exec = executor;\n+        final DelegatingExecutor exec = executor;\n@@ -707,1 +703,1 @@\n-                    exec.execute(this::requestMoreBody);\n+                    exec.ensureExecutedAsync(this::requestMoreBody);\n@@ -785,1 +781,1 @@\n-                        \/\/ fall trough to HEADERS\n+                        \/\/ fall through to HEADERS\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Exchange.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,0 +148,1 @@\n+        private final Executor safeDelegate;\n@@ -154,0 +155,1 @@\n+            this.safeDelegate = this::ensureExecutedAsync;\n@@ -161,1 +163,3 @@\n-\n+        Executor safeDelegate() {\n+            return safeDelegate;\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1103,0 +1103,13 @@\n+        private void tryRequestMore() {\n+            try {\n+                subscription.request(1);\n+            } catch (Throwable ex) {\n+                requestBodyCF.completeExceptionally(ex);\n+                \/\/ need to cancel the stream to 1. tell the server\n+                \/\/ we don't want to receive any more data and\n+                \/\/ 2. ensure that the operation ref count will be\n+                \/\/ decremented on the HttpClient.\n+                cancelImpl(ex);\n+            }\n+        }\n+\n@@ -1111,1 +1124,1 @@\n-            subscription.request(1);\n+            exchange.executor().safeDelegate().execute(this::tryRequestMore);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -389,0 +389,6 @@\n+    public static IOException toIOException(Throwable x) {\n+        Throwable cause = getCompletionCause(x);\n+        if (cause instanceof IOException io) return io;\n+        return new IOException(cause.getMessage(), x);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,605 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8350451\n+ * @summary Test posting back the response body input stream\n+ *          into a POST request body\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker PostFromGetTest\n+ * @run testng\/othervm -Djdk.httpclient.enableAllMethodRetry=true\n+ *                     -Djdk.httpclient.windowsize=65536\n+ *                     -Djdk.httpclient.connectionWindowSize=65536\n+ *                     PostFromGetTest\n+ *\/\n+import jdk.internal.net.http.common.OperationTrackers.Tracker;\n+import jdk.internal.net.http.common.SequentialScheduler;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.ITestContext;\n+import org.testng.ITestResult;\n+import org.testng.SkipException;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.ref.Reference;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublisher;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+\n+import static java.lang.System.out;\n+import static java.lang.System.err;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class PostFromGetTest implements HttpServerAdapters {\n+\n+    static final int K = 1024;\n+    static final long H2_STREAM_WINDOW =\n+            Math.max(16L*K, Long.getLong(\"jdk.httpclient.windowsize\", 16*K*K));\n+    static final long H2_CONN_WINDOW = Math.max(H2_STREAM_WINDOW,\n+            Long.getLong(\"jdk.httpclient.connectionWindowSize\", 32*K*K));\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;    \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;   \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+    ExecutorService serverExecutor;\n+\n+    static final int ITERATION_COUNT = 3;\n+    \/\/ a shared executor helps reduce the amount of threads created by the test\n+    static final Executor executor = new TestExecutor(Executors.newCachedThreadPool());\n+    static final ConcurrentMap<String, Throwable> FAILURES = new ConcurrentHashMap<>();\n+    static volatile boolean tasksFailed;\n+    static final AtomicLong serverCount = new AtomicLong();\n+    static final AtomicLong clientCount = new AtomicLong();\n+    static final long start = System.nanoTime();\n+    public static String now() {\n+        long now = System.nanoTime() - start;\n+        long secs = now \/ 1000_000_000;\n+        long mill = (now % 1000_000_000) \/ 1000_000;\n+        long nan = now % 1000_000;\n+        return String.format(\"[%s s, %s ms, %s ns] \", secs, mill, nan);\n+    }\n+\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+    private volatile HttpClient sharedClient;\n+\n+    static class TestExecutor implements Executor {\n+        final AtomicLong tasks = new AtomicLong();\n+        Executor executor;\n+        TestExecutor(Executor executor) {\n+            this.executor = executor;\n+        }\n+\n+        @Override\n+        public void execute(Runnable command) {\n+            long id = tasks.incrementAndGet();\n+            executor.execute(() -> {\n+                try {\n+                    command.run();\n+                } catch (Throwable t) {\n+                    tasksFailed = true;\n+                    out.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    err.printf(now() + \"Task %s failed: %s%n\", id, t);\n+                    FAILURES.putIfAbsent(\"Task \" + id, t);\n+                    throw t;\n+                }\n+            });\n+        }\n+    }\n+\n+    protected boolean stopAfterFirstFailure() {\n+        return Boolean.getBoolean(\"jdk.internal.httpclient.debug\");\n+    }\n+\n+    final AtomicReference<SkipException> skiptests = new AtomicReference<>();\n+    void checkSkip() {\n+        var skip = skiptests.get();\n+        if (skip != null) throw skip;\n+    }\n+    static String name(ITestResult result) {\n+        var params = result.getParameters();\n+        return result.getName()\n+                + (params == null ? \"()\" : Arrays.toString(result.getParameters()));\n+    }\n+\n+    @BeforeMethod\n+    void beforeMethod(ITestContext context) {\n+        if (stopAfterFirstFailure() && context.getFailedTests().size() > 0) {\n+            if (skiptests.get() == null) {\n+                SkipException skip = new SkipException(\"some tests failed\");\n+                skip.setStackTrace(new StackTraceElement[0]);\n+                skiptests.compareAndSet(null, skip);\n+            }\n+        }\n+    }\n+\n+    @AfterClass\n+    static void printFailedTests(ITestContext context) {\n+        out.println(\"\\n=========================\");\n+        var failed = context.getFailedTests().getAllResults().stream()\n+                .collect(Collectors.toMap(PostFromGetTest::name, ITestResult::getThrowable));\n+        FAILURES.putAll(failed);\n+        try {\n+            out.printf(\"%n%sCreated %d servers and %d clients%n\",\n+                    now(), serverCount.get(), clientCount.get());\n+            if (FAILURES.isEmpty()) return;\n+            out.println(\"Failed tests: \");\n+            FAILURES.forEach((key, value) -> {\n+                out.printf(\"\\t%s: %s%n\", key, value);\n+                value.printStackTrace(out);\n+            });\n+            if (tasksFailed) {\n+                System.out.println(\"WARNING: Some tasks failed\");\n+            }\n+        } finally {\n+            out.println(\"\\n=========================\\n\");\n+        }\n+    }\n+\n+    private String[] uris() {\n+        return new String[] {\n+                http2URI,\n+                https2URI,\n+                httpsURI,\n+                httpURI,\n+        };\n+    }\n+\n+    @DataProvider(name = \"urls\")\n+    public Object[][] alltests() {\n+        String[] uris = uris();\n+        Object[][] result = new Object[uris.length * 2][];\n+        int i = 0;\n+        for (boolean sameClient : List.of(true, false)) {\n+            for (String uri : uris()) {\n+                String path = sameClient ? \"same\" : \"new\";\n+                result[i++] = new Object[]{uri + path, sameClient};\n+            }\n+        }\n+        assert i == uris.length * 2;\n+        return result;\n+    }\n+\n+    private HttpClient makeNewClient() {\n+        clientCount.incrementAndGet();\n+        return TRACKER.track(HttpClient.newBuilder()\n+                .proxy(HttpClient.Builder.NO_PROXY)\n+                .executor(executor)\n+                .sslContext(sslContext)\n+                .build());\n+    }\n+\n+    HttpClient newHttpClient(boolean share) {\n+        if (!share) return makeNewClient();\n+        HttpClient shared = sharedClient;\n+        if (shared != null) return shared;\n+        synchronized (this) {\n+            shared = sharedClient;\n+            if (shared == null) {\n+                shared = sharedClient = makeNewClient();\n+            }\n+            return shared;\n+        }\n+    }\n+\n+    static class TestPublisher implements Publisher<ByteBuffer> {\n+        final Publisher<List<ByteBuffer>> publisher;\n+        volatile BBListSubscriber bblistsubscriber;\n+        volatile BBListSubscriber.BBSubscription bbSubscription;\n+        TestPublisher(Publisher<List<ByteBuffer>> publisher) {\n+            this.publisher = publisher;\n+        }\n+\n+        class BBListSubscriber implements Subscriber<List<ByteBuffer>> {\n+            final Subscriber<? super ByteBuffer> subscriber;\n+            BBListSubscriber(Subscriber<? super ByteBuffer> subscriber) {\n+                this.subscriber = subscriber;\n+                out.printf(\"%s: BBListSubscriber(%s) created%n\", now(), subscriber);\n+            }\n+\n+            final ConcurrentLinkedQueue<ByteBuffer> queue = new ConcurrentLinkedQueue<>();\n+            final AtomicReference<Throwable> error = new AtomicReference<>();\n+            volatile boolean completed;\n+            final SequentialScheduler scheduler = SequentialScheduler.lockingScheduler(this::deliver);\n+\n+            class BBSubscription implements Subscription {\n+                Subscription bblistsubscription;\n+                AtomicLong pending = new AtomicLong();\n+                BBSubscription(Subscription subscription) {\n+                    bblistsubscription = subscription;\n+                }\n+\n+                @Override\n+                public void request(long n) {\n+                    out.printf(\"%s: BBSubscription.request(%s)%n\", now(), n);\n+                    boolean requestMore;\n+                    synchronized (this) {\n+                        requestMore = pending.getAndAdd(n) == 0 && queue.isEmpty();\n+                    }\n+                    if (requestMore) {\n+                        bblistsubscription.request(1);\n+                    }\n+                    if (!queue.isEmpty()) {\n+                        scheduler.runOrSchedule();\n+                    }\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    bblistsubscription.cancel();\n+                }\n+            }\n+\n+            private void deliver() {\n+                while (!queue.isEmpty() && bbSubscription.pending.get() != 0) {\n+                    ByteBuffer bb;\n+                    synchronized (this) {\n+                        long n = bbSubscription.pending.decrementAndGet();\n+                        if (n < 0) {\n+                            bbSubscription.pending.incrementAndGet();\n+                            continue;\n+                        }\n+                        bb = queue.poll();\n+                        if (bb == null) {\n+                            bbSubscription.pending.incrementAndGet();\n+                            continue;\n+                        }\n+                    }\n+                    out.printf(\"%s: deliver %s%n\", now(), bb.remaining());\n+                    bblistsubscriber.subscriber.onNext(bb);\n+                }\n+                if (queue.isEmpty() && error.get() != null) {\n+                    bblistsubscriber.subscriber.onError(error.get());\n+                    scheduler.stop();\n+                }\n+                if (queue.isEmpty() && completed) {\n+                    bblistsubscriber.subscriber.onComplete();\n+                    scheduler.stop();\n+                }\n+                if (queue.isEmpty() && bbSubscription.pending.get() > 0) {\n+                    bbSubscription.bblistsubscription.request(1);\n+                }\n+            }\n+\n+            @Override\n+            public void onSubscribe(Subscription subscription) {\n+                out.printf(\"%s: BBListSubscriber.onSubscribe(%s)%n\", now(), subscription);\n+                bbSubscription = new BBSubscription(subscription);\n+                bblistsubscriber.subscriber.onSubscribe(bbSubscription);\n+            }\n+\n+            @Override\n+            public void onNext(List<ByteBuffer> item) {\n+                out.printf(\"%s: BBListSubscriber.onNext(List[%s]=%s)%n\", now(),\n+                        item.stream().map(ByteBuffer::remaining).toList(), Utils.remaining(item));\n+                queue.addAll(item);\n+                scheduler.runOrSchedule();\n+            }\n+\n+            @Override\n+            public void onError(Throwable throwable) {\n+                out.printf(\"%s: BBListSubscriber.onError(%s)%n\", now(), throwable);\n+                throwable.printStackTrace(out);\n+                error.compareAndSet(null, throwable);\n+                scheduler.runOrSchedule();\n+            }\n+\n+            @Override\n+            public void onComplete() {\n+                out.printf(\"%s: BBListSubscriber.onComplete(queue:%s)%n\", now(), queue.size());\n+                completed = true;\n+                scheduler.runOrSchedule();\n+            }\n+        }\n+\n+        @Override\n+        public void subscribe(Subscriber<? super ByteBuffer> subscriber) {\n+            this.bblistsubscriber = new BBListSubscriber(subscriber);\n+            publisher.subscribe(bblistsubscriber);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"urls\")\n+    public void testGetPostPublisher(String uri, boolean sameClient)\n+            throws Exception {\n+        Supplier<BodyHandler<Publisher<List<ByteBuffer>>>> handlerSuplier =\n+                BodyHandlers::ofPublisher;\n+        Function<Publisher<List<ByteBuffer>>, BodyPublisher> publisherSupplier =\n+                (p) -> BodyPublishers.fromPublisher(new TestPublisher(p));\n+        testGetPost(uri, sameClient, handlerSuplier, publisherSupplier);\n+    }\n+\n+    @Test(dataProvider = \"urls\")\n+    public void testGetPostInputStream(String uri, boolean sameClient)\n+            throws Exception {\n+        Supplier<BodyHandler<InputStream>> handlerSuplier =\n+                BodyHandlers::ofInputStream;\n+        Function<InputStream, BodyPublisher> publisherSupplier =\n+                (p) -> BodyPublishers.ofInputStream(() -> p);\n+        testGetPost(uri, sameClient, handlerSuplier, publisherSupplier);\n+    }\n+\n+    private <T> void testGetPost(String uri, boolean sameClient,\n+                            Supplier<BodyHandler<T>> handleSupplier,\n+                            Function<T, BodyPublisher> publisherSupplier)\n+            throws Exception {\n+        checkSkip();\n+        HttpClient client = null;\n+        int size = 64 * 1024 * 64;\n+        String geturi = uri + \"\/get\/?\" + size;\n+        String posturi = uri + \"\/post\/?\" + size;\n+        out.printf(\"%n%n%s testGetSendAsync(%s, %b)%n\", now(), uri, sameClient);\n+        for (int i=0; i< ITERATION_COUNT; i++) {\n+            if (!sameClient || client == null)\n+                client = newHttpClient(sameClient);\n+            Tracker tracker = TRACKER.getTracker(client);\n+\n+            HttpRequest getreq = HttpRequest.newBuilder(URI.create(geturi))\n+                    .GET()\n+                    .build();\n+            HttpResponse<T> getresponse =\n+                    client.send(getreq, handleSupplier.get());\n+\n+            HttpRequest postreq = HttpRequest.newBuilder(URI.create(posturi))\n+                    .POST(publisherSupplier.apply(getresponse.body()))\n+                    .build();\n+            HttpResponse<InputStream> postresponse = client.send(postreq, BodyHandlers.ofInputStream());\n+            int count = 0;\n+            try (var is = postresponse.body()) {\n+                int c;\n+                while ((c = is.read()) >= 0) {\n+                    assertEquals(c, count % 256);\n+                    count++;\n+                    if (count % (8*1024) == 0) {\n+                        out.printf(\"Post response: %s\/%s bytes, %s%%%n\",\n+                                count, size, (long)((((double)count)\/((double)size))*100f));\n+                    }\n+                }\n+                assertEquals(count, size);\n+            }\n+\n+            var error = TRACKER.check(tracker, 1000,\n+                    (t) -> t.getOutstandingOperations() > 0 || t.getOutstandingSubscribers() > 0,\n+                    \"subscribers for testGetSendAsync(%s)\\n\\t step [%s]\".formatted(uri, i),\n+                    false);\n+            Reference.reachabilityFence(client);\n+            if (error != null) throw error;\n+        }\n+        assert client != null;\n+        if (!sameClient) client.close();\n+    }\n+\n+\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        serverExecutor = Executors.newCachedThreadPool\n+                (Thread.ofPlatform().daemon().name(\"Server\").factory());\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        \/\/ HTTP\/1.1\n+        HttpTestHandler h1_chunkHandler = new H1GetPostHandler();\n+        httpTestServer = HttpTestServer.create(HTTP_1_1, null, serverExecutor);\n+        httpTestServer.addHandler(h1_chunkHandler, \"\/http1\/x\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/x\/\";\n+\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext, serverExecutor);\n+        httpsTestServer.addHandler(h1_chunkHandler, \"\/https1\/x\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/x\/\";\n+\n+        \/\/ HTTP\/2\n+        HttpTestHandler h2_chunkedHandler = new H2GetPostHandler();\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2, null, serverExecutor);\n+        http2TestServer.addHandler(h2_chunkedHandler, \"\/http2\/x\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/x\/\";\n+\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext, serverExecutor);\n+        https2TestServer.addHandler(h2_chunkedHandler, \"\/https2\/x\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/x\/\";\n+\n+        serverCount.addAndGet(4);\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        String sharedClientName =\n+                sharedClient == null ? null : sharedClient.toString();\n+        sharedClient = null;\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.check(500);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+            serverExecutor.close();\n+        } finally {\n+            if (fail != null) {\n+                if (sharedClientName != null) {\n+                    err.println(\"Shared client name is: \" + sharedClientName);\n+                }\n+                throw fail;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A handler that returns a body of a given size specified in the URI\n+     * query parameter upon a GET request, and streams back the request\n+     * body upon a POST request.\n+     *\n+     * When using HTTP\/2, this test uses a single connection to perform both\n+     * requests.\n+     *\n+     * The test code (client) pumps the GET response, streams it back to the server,\n+     * and pump the POST response (which is an echo of the request body).\n+     * What happens is that the GET bytes will only be pumped if the client can\n+     * send POST-request bytes. The server will only allow the client to send\n+     * POST-request bytes if it can process them (that's what triggers sending the\n+     * WINDOW_UPDATE).\n+     * So if the connection window (credits given by the client to the server) is all used\n+     * up by pending GET response bytes, the server will not be able to send POST-response\n+     * bytes, so it will not be able to process POST-request bytes, which in turn means\n+     * that the client won’t be able to send more POST-request bytes, which means it won’t\n+     * be able to pump the GET-response bytes, and therefore everything could get wedged\n+     * because the GET-response bytes are not being processed, so no WINDOW_UPDATE is sent\n+     * to the server at that point.\n+     *\n+     * To avoid this issue, the handler uses semaphore to ensure that GET response will\n+     * stop sending bytes before it fills up the whole connection window.\n+     * The get response will be allowed to resume after some bytes from the POST response\n+     * have been sent.\n+     *\n+     * The get response acquires the semaphore before sending each 8K chunks, and the POST\n+     * response releases it after sending each 8k chunks.\n+     * The semaphore is initialized with connectionWindowSize\/8K to make sure\n+     * the get response will pause before the connection window is filled.\n+     *\/\n+    static abstract class HTTPGetPostHandler implements HttpTestHandler {\n+        final long connectionWindow;\n+        final Semaphore sem;\n+\n+        HTTPGetPostHandler(long connectionWindow) {\n+            this.connectionWindow = connectionWindow;\n+            sem = new Semaphore((int) (connectionWindow\/(8*K)));\n+            assert sem.availablePermits() > 0;\n+        }\n+\n+        @Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            try (var exch = t) {\n+                var uri = exch.getRequestURI();\n+                out.printf(\"%s: Server HTTPGetPostHandler received request to %s%n\", now(), uri);\n+                err.printf(\"%n%s: Server HTTPGetPostHandler received request to %s%n\", now(), uri);\n+                long size = Long.parseLong(uri.getQuery());\n+                boolean post = uri.getPath().contains(\"\/post\/\");\n+                long count = 0;\n+                if (post) {\n+                    exch.sendResponseHeaders(200, -1);\n+                    try (var os = new BufferedOutputStream(exch.getResponseBody())) {\n+                        try (var is = exch.getRequestBody()) {\n+                            int c;\n+                            while ((c = is.read()) >= 0) {\n+                                assertEquals(c, (int) (count % 256));\n+                                os.write(c);\n+                                count++;\n+                                if ((count % (K * 8) == 0)) {\n+                                    sem.release();\n+                                }\n+                            }\n+                        }\n+                    }\n+                    out.printf(\"%s: Server: echoed %s bytes for %s%n\", now(), count, uri);\n+                } else {\n+                    try (var is = exch.getRequestBody()) {\n+                        is.readAllBytes();\n+                    }\n+                    exch.sendResponseHeaders(200, size);\n+                    try (var os = new BufferedOutputStream(exch.getResponseBody())) {\n+                        while (count < size) {\n+                            if ((count % (K * 8)) == 0) sem.acquire();\n+                            int c = (int) (count % 256);\n+                            os.write(c);\n+                            count++;\n+                        }\n+                    } catch (InterruptedException x) {\n+                        fail(\"Unexpected interruption\", x);\n+                    }\n+                    out.printf(\"%s: Server: replied %s bytes for %s%n\", now(), count, uri);\n+                }\n+                err.printf(\"%s: Server: %s: sent %s bytes%n\", now(), uri, count);\n+                if (count != size) {\n+                    String msg = \"Error: count=%s, size=%s for %s\".formatted(count, size, uri);\n+                    fail(msg);\n+                }\n+            }\n+        }\n+    }\n+\n+    static final class H1GetPostHandler extends HTTPGetPostHandler {\n+        H1GetPostHandler() {\n+            \/\/ We could use any value we want here, but to get\n+            \/\/ comparable results we use same settings as H2\n+            super(H2_CONN_WINDOW);\n+        }\n+    }\n+\n+    static final class H2GetPostHandler extends HTTPGetPostHandler {\n+        H2GetPostHandler() {\n+            super(H2_CONN_WINDOW);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/PostFromGetTest.java","additions":605,"deletions":0,"binary":false,"changes":605,"status":"added"}]}