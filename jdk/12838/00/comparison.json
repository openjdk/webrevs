{"files":[{"patch":"@@ -50,12 +50,35 @@\n- * An unbounded {@linkplain BlockingQueue blocking queue} of\n- * {@code Delayed} elements, in which an element can only be taken\n- * when its delay has expired.  The <em>head<\/em> of the queue is that\n- * {@code Delayed} element whose delay expired furthest in the\n- * past.  If no delay has expired there is no head and {@code poll}\n- * will return {@code null}. Expiration occurs when an element's\n- * {@code getDelay(TimeUnit.NANOSECONDS)} method returns a value less\n- * than or equal to zero.  Even though unexpired elements cannot be\n- * removed using {@code take} or {@code poll}, they are otherwise\n- * treated as normal elements. For example, the {@code size} method\n- * returns the count of both expired and unexpired elements.\n- * This queue does not permit null elements.\n+ * An unbounded {@linkplain BlockingQueue blocking queue} of {@link Delayed}\n+ * elements, in which an element generally becomes eligible for removal when its\n+ * delay has expired.\n+ *\n+ * <p><a id=\"expired\">An element is considered <em>expired<\/em> when its\n+ * {@code getDelay(TimeUnit.NANOSECONDS)} method would return a value less than\n+ * or equal to zero.<\/a>\n+ *\n+ * <p><a id=\"head\">An element is considered the <em>head<\/em> of the queue if it\n+ * is the element with the earliest expiration time, whether in the past or the\n+ * future, if there is such an element.<\/a>\n+ *\n+ * <p><a id=\"expired-head\">An element is considered the <em>expired head<\/em> of\n+ * the queue if it is the <em>expired<\/em> element with the earliest expiration\n+ * time in the past, if there is such an element.\n+ * The <em>expired head<\/em>, when present, is also the <em>head<\/em>.<\/a>\n+ *\n+ * <p>While this class implements the {@code BlockingQueue} interface, it\n+ * intentionally violates the general contract of {@code BlockingQueue}, in that\n+ * the following methods disregard the presence of unexpired elements and only\n+ * ever remove the <em>expired head<\/em>:\n+ *\n+ * <ul>\n+ * <li> {@link #poll()}\n+ * <li> {@link #poll(long,TimeUnit)}\n+ * <li> {@link #take()}\n+ * <li> {@link #remove()}\n+ * <\/ul>\n+ *\n+ * <p>All other methods operate on both expired and unexpired elements.\n+ * For example, the {@link #size()} method returns the count of all elements.\n+ * Method {@link #peek()} may return the (non-null) <em>head<\/em> even when\n+ * {@code take()} would block waiting for that element to expire.\n+ *\n+ * <p>This queue does not permit null elements.\n@@ -184,2 +207,3 @@\n-     * Retrieves and removes the head of this queue, or returns {@code null}\n-     * if this queue has no elements with an expired delay.\n+     * Retrieves and removes the <a href=\"#expired-head\">expired head<\/a> of\n+     * this queue, or returns {@code null} if this queue has no\n+     * <a href=\"#expired\">expired elements<\/a>\n@@ -187,1 +211,1 @@\n-     * @return the head of this queue, or {@code null} if this\n+     * @return the <em>expired head<\/em> of this queue, or {@code null} if this\n@@ -204,2 +228,3 @@\n-     * Retrieves and removes the head of this queue, waiting if necessary\n-     * until an element with an expired delay is available on this queue.\n+     * Retrieves and removes the <a href=\"#expired-head\">expired head<\/a> of\n+     * this queue, waiting if necessary until an\n+     * <a href=\"#expired\">expired element<\/a> is available on this queue.\n@@ -207,1 +232,1 @@\n-     * @return the head of this queue\n+     * @return the <em>expired head<\/em> of this queue\n@@ -245,2 +270,3 @@\n-     * Retrieves and removes the head of this queue, waiting if necessary\n-     * until an element with an expired delay is available on this queue,\n+     * Retrieves and removes the <a href=\"#expired-head\">expired head<\/a> of\n+     * this queue, waiting if necessary until an\n+     * <a href=\"#expired\">expired element<\/a> is available on this queue,\n@@ -249,1 +275,1 @@\n-     * @return the head of this queue, or {@code null} if the\n+     * @return the <em>expired head<\/em> of this queue, or {@code null} if the\n@@ -296,5 +322,17 @@\n-     * Retrieves, but does not remove, the head of this queue, or\n-     * returns {@code null} if this queue is empty.  Unlike\n-     * {@code poll}, if no expired elements are available in the queue,\n-     * this method returns the element that will expire next,\n-     * if one exists.\n+     * Retrieves and removes the <a href=\"#expired-head\">expired head<\/a> of\n+     * this queue, or throws an exception if this queue has no\n+     * <a href=\"#expired\">expired elements<\/a>.\n+     *\n+     * @return the <em>expired head<\/em> of this queue\n+     * @throws NoSuchElementException if this queue has no elements with an\n+     *         expired delay\n+     *\/\n+    public E remove() {\n+        return super.remove();\n+    }\n+\n+    \/**\n+     * Retrieves, but does not remove, the <a href=\"#head\">head<\/a> of this\n+     * queue, or returns {@code null} if this queue is empty.\n+     * Unlike {@code poll}, if no expired elements are available in the queue,\n+     * this method returns the element that will expire next, if one exists.\n@@ -302,1 +340,1 @@\n-     * @return the head of this queue, or {@code null} if this\n+     * @return the <em>head<\/em> of this queue, or {@code null} if this\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/DelayQueue.java","additions":65,"deletions":27,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import static java.util.concurrent.TimeUnit.DAYS;\n@@ -37,0 +38,2 @@\n+import static java.util.concurrent.TimeUnit.MICROSECONDS;\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n@@ -44,0 +47,1 @@\n+import java.util.concurrent.CompletableFuture;\n@@ -49,0 +53,1 @@\n+import java.util.concurrent.ThreadLocalRandom;\n@@ -107,1 +112,2 @@\n-     * Delayed implementation that actually delays\n+     * Delayed implementation that actually delays.\n+     * Only for use in DelayQueue<SimpleDelay>.\n@@ -109,1 +115,1 @@\n-    static class NanoDelay implements Delayed {\n+    static class SimpleDelay implements Delayed {\n@@ -111,3 +117,0 @@\n-        NanoDelay(long i) {\n-            trigger = System.nanoTime() + i;\n-        }\n@@ -115,2 +118,2 @@\n-        public int compareTo(Delayed y) {\n-            return Long.compare(trigger, ((NanoDelay)y).trigger);\n+        SimpleDelay(long delay, TimeUnit unit) {\n+            trigger = System.nanoTime() + unit.toNanos(delay);\n@@ -119,3 +122,3 @@\n-        public boolean equals(Object other) {\n-            return (other instanceof NanoDelay) &&\n-                this.trigger == ((NanoDelay)other).trigger;\n+        public int compareTo(Delayed y) {\n+            long now = System.nanoTime();\n+            return Long.compare(trigger - now, ((SimpleDelay)y).trigger - now);\n@@ -124,3 +127,0 @@\n-        \/\/ suppress [overrides] javac warning\n-        public int hashCode() { return (int) trigger; }\n-\n@@ -128,2 +128,1 @@\n-            long n = trigger - System.nanoTime();\n-            return unit.convert(n, TimeUnit.NANOSECONDS);\n+            return unit.convert(trigger - System.nanoTime(), NANOSECONDS);\n@@ -132,3 +131,1 @@\n-        public long getTriggerTime() {\n-            return trigger;\n-        }\n+        public long getTriggerTime() { return trigger; }\n@@ -703,3 +700,6 @@\n-        DelayQueue<NanoDelay> q = new DelayQueue<>();\n-        for (int i = 0; i < SIZE; ++i)\n-            q.add(new NanoDelay(1000000L * (SIZE - i)));\n+        DelayQueue<SimpleDelay> q = new DelayQueue<>();\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+        for (int i = 0; i < SIZE; ++i) {\n+            long micros = rnd.nextLong(SIZE);\n+            q.add(new SimpleDelay(micros, MICROSECONDS));\n+        }\n@@ -709,1 +709,1 @@\n-            NanoDelay e = q.take();\n+            SimpleDelay e = q.take();\n@@ -723,3 +723,28 @@\n-        DelayQueue<NanoDelay> q = new DelayQueue<>();\n-        q.add(new NanoDelay(Long.MAX_VALUE));\n-        assertNotNull(q.peek());\n+        DelayQueue<SimpleDelay> q = new DelayQueue<>();\n+        SimpleDelay unexpired = new SimpleDelay(1L, DAYS);\n+        SimpleDelay expired = new SimpleDelay(0L, DAYS);\n+        q.add(unexpired);\n+        assertSame(unexpired, q.peek());\n+        q.add(expired);\n+        assertSame(expired, q.peek());\n+    }\n+\n+    \/**\n+     * remove(Object) disregards the expiration state\n+     *\/\n+    public void testRemoveObject() {\n+        DelayQueue<SimpleDelay> q = new DelayQueue<>();\n+        ThreadLocalRandom rnd = ThreadLocalRandom.current();\n+        var xs = new ArrayList<SimpleDelay>();\n+        int size = 8;\n+        for (int i = 0; i < size; i++) {\n+            long days = rnd.nextLong(-size, size);\n+            var x = new SimpleDelay(days, DAYS);\n+            xs.add(x);\n+            q.add(x);\n+        }\n+        for (SimpleDelay x : xs) {\n+            assertTrue(q.remove(x));\n+            assertFalse(q.remove(x));\n+        }\n+        assertTrue(q.isEmpty());\n@@ -732,2 +757,4 @@\n-        DelayQueue<NanoDelay> q = new DelayQueue<>();\n-        q.add(new NanoDelay(Long.MAX_VALUE));\n+        DelayQueue<SimpleDelay> q = new DelayQueue<>();\n+        SimpleDelay unexpired = new SimpleDelay(1L, DAYS);\n+        SimpleDelay expired = new SimpleDelay(0L, DAYS);\n+        q.add(unexpired);\n@@ -735,0 +762,4 @@\n+        q.add(expired);\n+        assertSame(expired, q.poll());\n+        assertNull(q.poll());\n+        assertSame(unexpired, q.peek());\n@@ -741,2 +772,4 @@\n-        DelayQueue<NanoDelay> q = new DelayQueue<>();\n-        q.add(new NanoDelay(LONG_DELAY_MS * 1000000L));\n+        DelayQueue<SimpleDelay> q = new DelayQueue<>();\n+        SimpleDelay unexpired = new SimpleDelay(1L, DAYS);\n+        SimpleDelay expired = new SimpleDelay(0L, DAYS);\n+        q.add(unexpired);\n@@ -746,0 +779,34 @@\n+        q.add(expired);\n+        assertSame(expired, q.poll(1L, DAYS));\n+        assertNull(q.poll(0L, DAYS));\n+        assertSame(unexpired, q.peek());\n+    }\n+\n+    \/**\n+     * q.take() waits for an expired element.\n+     *\/\n+    public void testTakeDelayed() throws InterruptedException {\n+        DelayQueue<SimpleDelay> q = new DelayQueue<>();\n+        SimpleDelay unexpired = new SimpleDelay(1L, DAYS);\n+        SimpleDelay expired = new SimpleDelay(0L, DAYS);\n+        q.add(unexpired);\n+        CompletableFuture.runAsync(() -> q.add(expired));\n+        assertSame(expired, q.take());\n+        assertSame(unexpired, q.peek());\n+    }\n+\n+    \/**\n+     * q.remove() throws NoSuchElementException if no expired elements.\n+     *\/\n+    public void testRemoveDelayed() throws InterruptedException {\n+        DelayQueue<SimpleDelay> q = new DelayQueue<>();\n+        SimpleDelay unexpired = new SimpleDelay(1L, DAYS);\n+        SimpleDelay expired = new SimpleDelay(0L, DAYS);\n+        q.add(unexpired);\n+        try {\n+            q.remove();\n+            shouldThrow();\n+        } catch (NoSuchElementException success) {}\n+        q.add(expired);\n+        assertSame(expired, q.remove());\n+        assertSame(unexpired, q.peek());\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/DelayQueueTest.java","additions":96,"deletions":29,"binary":false,"changes":125,"status":"modified"}]}