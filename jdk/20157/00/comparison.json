{"files":[{"patch":"@@ -2748,4 +2748,1 @@\n-      \/* If we get an out-of-range offset it is a bug in the compiler,\n-         so we assert here. *\/\n-      assert(Address::offset_ok_for_immed(disp, exact_log2(size_in_memory)), \"c2 compiler bug\");\n-      \/* Fix up any out-of-range offsets. *\/\n+      \/\/ Fix up any out-of-range offsets.\n@@ -3351,1 +3348,5 @@\n-      __ prfm(Address(base, disp), PSTL1KEEP);\n+      \/\/ Fix up any out-of-range offsets.\n+      assert_different_registers(rscratch1, base);\n+      Address addr = Address(base, disp);\n+      addr = __ legitimize_address(addr, 8, rscratch1);\n+      __ prfm(addr, PSTL1KEEP);\n@@ -4232,1 +4233,1 @@\n-operand immLoffset()\n+operand immLOffset()\n@@ -4234,1 +4235,1 @@\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 0));\n+  predicate(n->get_long() >= -256 && n->get_long() <= 65520);\n@@ -5344,0 +5345,28 @@\n+operand indirectX2P(iRegL reg)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(CastX2P reg);\n+  op_cost(0);\n+  format %{ \"[$reg]\\t# long -> ptr\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp(0x0);\n+  %}\n+%}\n+\n+operand indOffX2P(iRegL reg, immLOffset off)\n+%{\n+  constraint(ALLOC_IN_RC(ptr_reg));\n+  match(AddP (CastX2P reg) off);\n+  op_cost(0);\n+  format %{ \"[$reg, $off]\\t# long -> ptr\" %}\n+  interface(MEMORY_INTER) %{\n+    base($reg);\n+    index(0xffffffff);\n+    scale(0x0);\n+    disp($off);\n+  %}\n+%}\n+\n@@ -5434,1 +5463,1 @@\n-operand indOffLN(iRegN reg, immLoffset off)\n+operand indOffLN(iRegN reg, immLOffset off)\n@@ -5667,0 +5696,11 @@\n+operand iRegL2P(iRegL reg) %{\n+\n+  op_cost(0);\n+\n+  match(CastX2P reg);\n+\n+  format %{ \"l2p($reg)\" %}\n+\n+  interface(REG_INTER)\n+%}\n+\n@@ -5683,1 +5723,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n@@ -5686,1 +5726,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n@@ -5689,1 +5729,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n@@ -5692,1 +5732,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);\n+                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n@@ -5697,1 +5737,1 @@\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN);\n+               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n@@ -5714,0 +5754,1 @@\n+opclass iRegPorL2P(iRegP, iRegL2P);\n@@ -9814,1 +9855,1 @@\n-instruct addP_reg_reg(iRegPNoSp dst, iRegP src1, iRegL src2) %{\n+instruct addP_reg_reg(iRegPNoSp dst, iRegPorL2P src1, iRegL src2) %{\n@@ -9829,1 +9870,1 @@\n-instruct addP_reg_reg_ext(iRegPNoSp dst, iRegP src1, iRegIorL2I src2) %{\n+instruct addP_reg_reg_ext(iRegPNoSp dst, iRegPorL2P src1, iRegIorL2I src2) %{\n@@ -9844,1 +9885,1 @@\n-instruct addP_reg_reg_lsl(iRegPNoSp dst, iRegP src1, iRegL src2, immIScale scale) %{\n+instruct addP_reg_reg_lsl(iRegPNoSp dst, iRegPorL2P src1, iRegL src2, immIScale scale) %{\n@@ -9859,1 +9900,1 @@\n-instruct addP_reg_reg_ext_shift(iRegPNoSp dst, iRegP src1, iRegIorL2I src2, immIScale scale) %{\n+instruct addP_reg_reg_ext_shift(iRegPNoSp dst, iRegPorL2P src1, iRegIorL2I src2, immIScale scale) %{\n@@ -9892,1 +9933,1 @@\n-instruct addP_reg_imm(iRegPNoSp dst, iRegP src1, immLAddSub src2) %{\n+instruct addP_reg_imm(iRegPNoSp dst, iRegPorL2P src1, immLAddSub src2) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":59,"deletions":18,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,7 @@\n-    const Address ref_addr = mem2address($mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    Address ref_addr = mem2address($mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    if (ref_addr.getMode() == Address::base_plus_offset) {\n+      \/\/ Fix up any out-of-range offsets.\n+      assert_different_registers(rscratch1, as_Register($mem$$base));\n+      assert_different_registers(rscratch1, $dst$$Register);\n+      ref_addr = __ legitimize_address(ref_addr, 8, rscratch1);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/x\/x_aarch64.ad","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,1 +114,7 @@\n-    const Address ref_addr = mem2address($mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    Address ref_addr = mem2address($mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+    if (ref_addr.getMode() == Address::base_plus_offset) {\n+      \/\/ Fix up any out-of-range offsets.\n+      assert_different_registers(rscratch2, as_Register($mem$$base));\n+      assert_different_registers(rscratch2, $dst$$Register);\n+      ref_addr = __ legitimize_address(ref_addr, 8, rscratch2);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -398,1 +398,8 @@\n-  if (t->isa_intptr_t() && offset != 0 && offset != Type::OffsetBot) {\n+\n+  if (t->isa_intptr_t() &&\n+#if !defined(AARCH64)\n+      \/\/ AArch64 supports the addressing mode:\n+      \/\/ [base, 0], in which [base] is converted from a long value\n+      offset != 0 &&\n+#endif\n+      offset != Type::OffsetBot) {\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test TestCastX2P\n+ * @summary AArch64: remove extra register copy when converting from long to pointer.\n+ * @bug 8336245\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:-TieredCompilation compiler.c2.TestCastX2P\n+ *\/\n+\n+public class TestCastX2P {\n+\n+    public static final int LEN = 2040;\n+\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    public static long lseed = 0xbeef;\n+    public static int iseed = 0xbeef;\n+    public static short sseed = (short) (0xef);\n+    public static byte bseed = (byte) (0xe);\n+\n+    public static long off1 = 16;\n+    public static long off2 = 32;\n+    public static long off3 = 64;\n+\n+    public static class TestLong {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 10_000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putLong(address+i, lseed);\n+                }\n+            }\n+\n+            UNSAFE.putLong(address + off1 + 1030, lseed);\n+            UNSAFE.putLong(address + 1023, lseed);\n+            UNSAFE.putLong(address + off2 + 1001, lseed);\n+        }\n+    }\n+\n+    public static class TestLongIndirect {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 1000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putLong(address+i, lseed);\n+                }\n+            }\n+\n+            UNSAFE.putLong(address + off1, lseed);\n+            UNSAFE.putLong(address + off1 + off2, lseed);\n+            UNSAFE.putLong(address + off3, lseed);\n+        }\n+    }\n+\n+    public static class TestInt {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 10_000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putInt(address+i, iseed);\n+                }\n+            }\n+\n+            UNSAFE.putInt(address + off1 + 274, iseed);\n+            UNSAFE.putInt(address + 278, iseed);\n+            UNSAFE.putInt(address + off2 + 282, iseed);\n+        }\n+    }\n+\n+    public static class TestIntIndirect {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 1000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putInt(address+i, iseed);\n+                }\n+            }\n+\n+            UNSAFE.putInt(address + off1, iseed);\n+            UNSAFE.putInt(address + off1 + off2, iseed);\n+            UNSAFE.putInt(address + off3, iseed);\n+        }\n+    }\n+\n+    public static class TestShort {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 10_000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putShort(address+i, sseed);\n+                }\n+            }\n+\n+            UNSAFE.putShort(address + off1 + 257, sseed);\n+            UNSAFE.putShort(address + 277, sseed);\n+            UNSAFE.putShort(address + off2 + 283, sseed);\n+        }\n+    }\n+\n+    public static class TestShortIndirect {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 1000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putShort(address+i, sseed);\n+                }\n+            }\n+\n+            UNSAFE.putShort(address + off1, sseed);\n+            UNSAFE.putShort(address + off1 + off2, sseed);\n+            UNSAFE.putShort(address + off3, sseed);\n+        }\n+    }\n+\n+    public static class TestByte {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 10_000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putByte(address+i, bseed);\n+                }\n+            }\n+\n+            UNSAFE.putByte(address + off1 + 257, bseed);\n+            UNSAFE.putByte(address + 277, bseed);\n+            UNSAFE.putByte(address + off2 + 283, bseed);\n+        }\n+    }\n+\n+    public static class TestByteIndirect {\n+\n+        private static long address = UNSAFE.allocateMemory(LEN);\n+\n+        static {\n+            for (int k = 0; k < 1000; k++) {\n+                for (int i = 0; i < LEN\/2; i++) {\n+                    UNSAFE.putByte(address+i, bseed);\n+                }\n+            }\n+\n+            UNSAFE.putByte(address + off1, bseed);\n+            UNSAFE.putByte(address + off1 + off2, bseed);\n+            UNSAFE.putByte(address + off3, bseed);\n+        }\n+    }\n+\n+    static void test() {\n+        TestLong t1 = new TestLong();\n+        Asserts.assertEquals(UNSAFE.getLong(t1.address + off1 + 1030), lseed, \"put long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLong(t1.address + 1023), lseed, \"put long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLong(t1.address + off2 + 1001), lseed, \"put long failed!\");\n+\n+        TestLongIndirect t2 = new TestLongIndirect();\n+        Asserts.assertEquals(UNSAFE.getLong(t2.address + off1), lseed, \"put long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLong(t2.address + off1 + off2), lseed, \"put long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLong(t2.address + off3), lseed, \"put long failed!\");\n+\n+        TestInt t3 = new TestInt();\n+        Asserts.assertEquals(UNSAFE.getInt(t3.address + off1 + 274), iseed, \"put int failed!\");\n+        Asserts.assertEquals(UNSAFE.getInt(t3.address + 278), iseed, \"put int failed!\");\n+        Asserts.assertEquals(UNSAFE.getInt(t3.address + off2 + 282), iseed, \"put int failed!\");\n+\n+        TestIntIndirect t4 = new TestIntIndirect();\n+        Asserts.assertEquals(UNSAFE.getInt(t4.address + off1), iseed, \"put int failed!\");\n+        Asserts.assertEquals(UNSAFE.getInt(t4.address + off1 + off2), iseed, \"put int failed!\");\n+        Asserts.assertEquals(UNSAFE.getInt(t4.address + off3), iseed, \"put int failed!\");\n+\n+        TestShort t5 = new TestShort();\n+        Asserts.assertEquals(UNSAFE.getShort(t5.address + off1 + 257), sseed, \"put short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShort(t5.address + 277), sseed, \"put short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShort(t5.address + off2 + 283), sseed, \"put short failed!\");\n+\n+        TestShortIndirect t6 = new TestShortIndirect();\n+        Asserts.assertEquals(UNSAFE.getShort(t6.address + off1), sseed, \"put short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShort(t6.address + off1 + off2), sseed, \"put short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShort(t6.address + off3), sseed, \"put short failed!\");\n+\n+        TestByte t7 = new TestByte();\n+        Asserts.assertEquals(UNSAFE.getByte(t7.address + off1 + 257), bseed, \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(t7.address + 277), bseed, \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(t7.address + off2 + 283), bseed, \"put byte failed!\");\n+\n+        TestByteIndirect t8 = new TestByteIndirect();\n+        Asserts.assertEquals(UNSAFE.getByte(t8.address + off1), bseed, \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(t8.address + off1 + off2), bseed, \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(t8.address + off3), bseed, \"put byte failed!\");\n+    }\n+\n+    public static void main(String[] strArr) {\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestCastX2P.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"}]}