{"files":[{"patch":"@@ -5637,6 +5637,10 @@\n-            \/\/ Check that all extended classes and interfaces\n-            \/\/ are compatible (i.e. no two define methods with same arguments\n-            \/\/ yet different return types).  (JLS 8.4.8.3)\n-            chk.checkCompatibleSupertypes(tree.pos(), c.type);\n-            chk.checkDefaultMethodClashes(tree.pos(), c.type);\n-            chk.checkPotentiallyAmbiguousOverloads(tree, c.type);\n+            try {\n+                \/\/ Check that all extended classes and interfaces\n+                \/\/ are compatible (i.e. no two define methods with same arguments\n+                \/\/ yet different return types).  (JLS 8.4.8.3)\n+                chk.checkCompatibleSupertypes(tree.pos(), c.type);\n+                chk.checkDefaultMethodClashes(tree.pos(), c.type);\n+                chk.checkPotentiallyAmbiguousOverloads(tree, c.type);\n+            } catch (CompletionFailure cf) {\n+                chk.completionError(tree.pos(), cf);\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301580 8322159 8333107 8332230 8338678 8351260 8366196 8372336\n+ * @bug 8301580 8322159 8333107 8332230 8338678 8351260 8366196 8372336 8373094\n@@ -35,0 +35,1 @@\n+import com.sun.source.tree.IdentifierTree;\n@@ -36,0 +37,1 @@\n+import com.sun.source.tree.MemberSelectTree;\n@@ -37,0 +39,1 @@\n+import com.sun.source.tree.MethodTree;\n@@ -44,0 +47,1 @@\n+import java.util.ArrayList;\n@@ -49,0 +53,1 @@\n+import java.util.stream.Stream;\n@@ -498,0 +503,151 @@\n+\n+    @Test \/\/JDK-8373094\n+    public void testSensibleAttribution() throws Exception {\n+        Path curPath = Path.of(\".\");\n+        Path lib = curPath.resolve(\"lib\");\n+        Path classes = lib.resolve(\"classes\");\n+        Files.createDirectories(classes);\n+        new JavacTask(tb)\n+            .outdir(classes)\n+            .sources(\"\"\"\n+                     package test;\n+                     public class Intermediate<T> extends Base<T> {}\n+                     \"\"\",\n+                     \"\"\"\n+                     package test;\n+                     public class Base<T> {\n+                         public void t(Missing<T> m) {}\n+                     }\n+                     \"\"\",\n+                     \"\"\"\n+                     package test;\n+                     public class Missing<T> {\n+                     }\n+                     \"\"\")\n+            .run()\n+            .writeAll();\n+\n+        Files.delete(classes.resolve(\"test\").resolve(\"Missing.class\"));\n+\n+        record TestCase(String code, List<String> options, String... expectedErrors) {}\n+        TestCase[] testCases = new TestCase[] {\n+            new TestCase(\"\"\"\n+                         package test;\n+                         public class Test extends Intermediate<String> {\n+                             private void test() {\n+                                 int i = 0;\n+                                 System.err.println(i);\n+                                 while (true) {\n+                                     break;\n+                                 }\n+                             }\n+                         }\n+                         \"\"\",\n+                         List.of(),\n+                         \"Test.java:2:8: compiler.err.cant.access: test.Missing, (compiler.misc.class.file.not.found: test.Missing)\",\n+                         \"1 error\"),\n+            new TestCase(\"\"\"\n+                         package test;\n+                         public class Test extends Intermediate<String> {\n+                             private void test() {\n+                                 int i = 0;\n+                                 System.err.println(i);\n+                                 while (true) {\n+                                    break;\n+                                 }\n+                             }\n+                         }\n+                         \"\"\",\n+                         List.of(\"-XDshould-stop.at=FLOW\"),\n+                         \"Test.java:2:8: compiler.err.cant.access: test.Missing, (compiler.misc.class.file.not.found: test.Missing)\",\n+                         \"1 error\"),\n+        };\n+\n+        for (TestCase tc : testCases) {\n+            List<String> attributes = new ArrayList<>();\n+            List<String> actual = new JavacTask(tb)\n+                    .options(Stream.concat(List.of(\"-XDrawDiagnostics\", \"-XDdev\").stream(),\n+                                           tc.options.stream()).toList())\n+                    .classpath(classes)\n+                    .sources(tc.code())\n+                    .outdir(curPath)\n+                    .callback(task -> {\n+                        task.addTaskListener(new TaskListener() {\n+                            @Override\n+                            public void finished(TaskEvent e) {\n+                                if (e.getKind() != TaskEvent.Kind.ANALYZE) {\n+                                    return ;\n+                                }\n+                                Trees trees = Trees.instance(task);\n+                                new TreePathScanner<Void, Void>() {\n+                                    boolean check;\n+\n+                                    @Override\n+                                    public Void visitMethod(MethodTree node, Void p) {\n+                                        if (node.getName().contentEquals(\"test\")) {\n+                                            check = true;\n+                                            try {\n+                                                return super.visitMethod(node, p);\n+                                            } finally {\n+                                                check = false;\n+                                            }\n+                                        }\n+\n+                                        return super.visitMethod(node, p);\n+                                    }\n+\n+                                    @Override\n+                                    public Void visitMethodInvocation(MethodInvocationTree node, Void p) {\n+                                        if (!node.toString().contains(\"super\")) {\n+                                            verifyElement();\n+                                        }\n+                                        return super.visitMethodInvocation(node, p);\n+                                    }\n+\n+                                    @Override\n+                                    public Void visitIdentifier(IdentifierTree node, Void p) {\n+                                        verifyElement();\n+                                        return super.visitIdentifier(node, p);\n+                                    }\n+\n+                                    @Override\n+                                    public Void visitMemberSelect(MemberSelectTree node, Void p) {\n+                                        verifyElement();\n+                                        return super.visitMemberSelect(node, p);\n+                                    }\n+\n+                                    private void verifyElement() {\n+                                        if (!check) {\n+                                            return ;\n+                                        }\n+\n+                                        Element el = trees.getElement(getCurrentPath());\n+                                        if (el == null) {\n+                                            error(\"Unattributed tree: \" + getCurrentPath().getLeaf());\n+                                        } else {\n+                                            attributes.add(el.toString());\n+                                        }\n+                                    }\n+                                }.scan(e.getCompilationUnit(), null);\n+                            }\n+                        });\n+                    })\n+                    .run(Expect.FAIL)\n+                    .writeAll()\n+                    .getOutputLines(OutputKind.DIRECT);\n+\n+            List<String> expectedErrors = List.of(tc.expectedErrors);\n+\n+            if (!Objects.equals(actual, expectedErrors)) {\n+                error(\"Expected: \" + expectedErrors + \", but got: \" + actual);\n+            }\n+\n+            List<String> expectedAttributes =\n+                    List.of(\"println(int)\", \"println(int)\", \"err\", \"java.lang.System\", \"i\");\n+\n+            if (!Objects.equals(attributes, expectedAttributes)) {\n+                error(\"Expected: \" + expectedAttributes + \", but got: \" + attributes);\n+            }\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":157,"deletions":1,"binary":false,"changes":158,"status":"modified"}]}