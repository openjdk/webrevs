{"files":[{"patch":"@@ -1198,1 +1198,1 @@\n-Node* MaxNode::build_min_max_int(Node* a, Node* b, bool is_max) {\n+Node* MinMaxNode::build_min_max_int(Node* a, Node* b, bool is_max) {\n@@ -1206,1 +1206,1 @@\n-Node* MaxNode::build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max) {\n+Node* MinMaxNode::build_min_max_long(PhaseGVN* phase, Node* a, Node* b, bool is_max) {\n@@ -1214,1 +1214,1 @@\n-Node* MaxNode::build_min_max(Node* a, Node* b, bool is_max, bool is_unsigned, const Type* t, PhaseGVN& gvn) {\n+Node* MinMaxNode::build_min_max(Node* a, Node* b, bool is_max, bool is_unsigned, const Type* t, PhaseGVN& gvn) {\n@@ -1246,1 +1246,1 @@\n-Node* MaxNode::build_min_max_diff_with_zero(Node* a, Node* b, bool is_max, const Type* t, PhaseGVN& gvn) {\n+Node* MinMaxNode::build_min_max_diff_with_zero(Node* a, Node* b, bool is_max, const Type* t, PhaseGVN& gvn) {\n@@ -1293,1 +1293,1 @@\n-Node* MaxNode::extract_add(PhaseGVN* phase, ConstAddOperands x_operands, ConstAddOperands y_operands) {\n+Node* MinMaxNode::extract_add(PhaseGVN* phase, ConstAddOperands x_operands, ConstAddOperands y_operands) {\n@@ -1330,1 +1330,1 @@\n-Node* MaxNode::IdealI(PhaseGVN* phase, bool can_reshape) {\n+Node* MinMaxNode::IdealI(PhaseGVN* phase, bool can_reshape) {\n@@ -1404,1 +1404,1 @@\n-  return MaxNode::Identity(phase);\n+  return MinMaxNode::Identity(phase);\n@@ -1437,1 +1437,1 @@\n-  return MaxNode::Identity(phase);\n+  return MinMaxNode::Identity(phase);\n@@ -1567,1 +1567,1 @@\n-  return MaxNode::Identity(phase);\n+  return MinMaxNode::Identity(phase);\n@@ -1599,1 +1599,1 @@\n-  return MaxNode::Identity(phase);\n+  return MinMaxNode::Identity(phase);\n@@ -1613,1 +1613,1 @@\n-int MaxNode::opposite_opcode() const {\n+int MinMaxNode::opposite_opcode() const {\n@@ -1624,1 +1624,1 @@\n-Node* MaxNode::find_identity_operation(Node* operation, Node* operand) {\n+Node* MinMaxNode::find_identity_operation(Node* operation, Node* operand) {\n@@ -1648,1 +1648,1 @@\n-Node* MaxNode::Identity(PhaseGVN* phase) {\n+Node* MinMaxNode::Identity(PhaseGVN* phase) {\n@@ -1653,1 +1653,1 @@\n-  Node* identity_1 = MaxNode::find_identity_operation(in(2), in(1));\n+  Node* identity_1 = MinMaxNode::find_identity_operation(in(2), in(1));\n@@ -1658,1 +1658,1 @@\n-  Node* identity_2 = MaxNode::find_identity_operation(in(1), in(2));\n+  Node* identity_2 = MinMaxNode::find_identity_operation(in(1), in(2));\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-class MaxNode : public AddNode {\n+class MinMaxNode : public AddNode {\n@@ -334,1 +334,3 @@\n-  MaxNode( Node *in1, Node *in2 ) : AddNode(in1,in2) {}\n+  MinMaxNode(Node* in1, Node* in2) : AddNode(in1, in2) {\n+    init_class_id(Class_MinMax);\n+  }\n@@ -376,1 +378,1 @@\n-class MaxINode : public MaxNode {\n+class MaxINode : public MinMaxNode {\n@@ -378,1 +380,1 @@\n-  MaxINode( Node *in1, Node *in2 ) : MaxNode(in1,in2) {}\n+  MaxINode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -393,1 +395,1 @@\n-class MinINode : public MaxNode {\n+class MinINode : public MinMaxNode {\n@@ -395,1 +397,1 @@\n-  MinINode( Node *in1, Node *in2 ) : MaxNode(in1,in2) {}\n+  MinINode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -409,1 +411,1 @@\n-class MaxLNode : public MaxNode {\n+class MaxLNode : public MinMaxNode {\n@@ -411,1 +413,1 @@\n-  MaxLNode(Compile* C, Node* in1, Node* in2) : MaxNode(in1, in2) {\n+  MaxLNode(Compile* C, Node* in1, Node* in2) : MinMaxNode(in1, in2) {\n@@ -428,1 +430,1 @@\n-class MinLNode : public MaxNode {\n+class MinLNode : public MinMaxNode {\n@@ -430,1 +432,1 @@\n-  MinLNode(Compile* C, Node* in1, Node* in2) : MaxNode(in1, in2) {\n+  MinLNode(Compile* C, Node* in1, Node* in2) : MinMaxNode(in1, in2) {\n@@ -447,1 +449,1 @@\n-class MaxFNode : public MaxNode {\n+class MaxFNode : public MinMaxNode {\n@@ -449,1 +451,1 @@\n-  MaxFNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}\n+  MaxFNode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -461,1 +463,1 @@\n-class MinFNode : public MaxNode {\n+class MinFNode : public MinMaxNode {\n@@ -463,1 +465,1 @@\n-  MinFNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}\n+  MinFNode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -475,1 +477,1 @@\n-class MaxHFNode : public MaxNode {\n+class MaxHFNode : public MinMaxNode {\n@@ -477,1 +479,1 @@\n-  MaxHFNode(Node* in1, Node* in2) : MaxNode(in1, in2) {}\n+  MaxHFNode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -489,1 +491,1 @@\n-class MinHFNode : public MaxNode {\n+class MinHFNode : public MinMaxNode {\n@@ -491,1 +493,1 @@\n-  MinHFNode(Node* in1, Node* in2) : MaxNode(in1, in2) {}\n+  MinHFNode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -503,1 +505,1 @@\n-class MaxDNode : public MaxNode {\n+class MaxDNode : public MinMaxNode {\n@@ -505,1 +507,1 @@\n-  MaxDNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}\n+  MaxDNode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n@@ -517,1 +519,1 @@\n-class MinDNode : public MaxNode {\n+class MinDNode : public MinMaxNode {\n@@ -519,1 +521,1 @@\n-  MinDNode(Node *in1, Node *in2) : MaxNode(in1, in2) {}\n+  MinDNode(Node* in1, Node* in2) : MinMaxNode(in1, in2) {}\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -982,1 +982,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(limit, outer_phi, TypeInteger::bottom(bt), _igvn);\n+    inner_iters_max = MinMaxNode::max_diff_with_zero(limit, outer_phi, TypeInteger::bottom(bt), _igvn);\n@@ -984,1 +984,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(outer_phi, limit, TypeInteger::bottom(bt), _igvn);\n+    inner_iters_max = MinMaxNode::max_diff_with_zero(outer_phi, limit, TypeInteger::bottom(bt), _igvn);\n@@ -992,1 +992,1 @@\n-  Node* inner_iters_actual = MaxNode::unsigned_min(inner_iters_max, inner_iters_limit, inner_iters_actual_range, _igvn);\n+  Node* inner_iters_actual = MinMaxNode::unsigned_min(inner_iters_max, inner_iters_limit, inner_iters_actual_range, _igvn);\n@@ -1621,1 +1621,1 @@\n-      R = MaxNode::unsigned_min(R, max_range, TypeLong::POS, _igvn);\n+      R = MinMaxNode::unsigned_min(R, max_range, TypeLong::POS, _igvn);\n@@ -1720,1 +1720,1 @@\n-  Node* min = MaxNode::signed_min(R, H, TypeLong::LONG, _igvn);\n+  Node* min = MinMaxNode::signed_min(R, H, TypeLong::LONG, _igvn);\n@@ -1722,1 +1722,1 @@\n-  Node* max = MaxNode::signed_max(L, min, TypeLong::LONG, _igvn);\n+  Node* max = MinMaxNode::signed_max(L, min, TypeLong::LONG, _igvn);\n@@ -3488,1 +3488,1 @@\n-      max = MaxNode::max_diff_with_zero(limit, iv_phi, TypeInt::INT, *igvn);\n+      max = MinMaxNode::max_diff_with_zero(limit, iv_phi, TypeInt::INT, *igvn);\n@@ -3490,1 +3490,1 @@\n-      max = MaxNode::max_diff_with_zero(iv_phi, limit, TypeInt::INT, *igvn);\n+      max = MinMaxNode::max_diff_with_zero(iv_phi, limit, TypeInt::INT, *igvn);\n@@ -3495,1 +3495,1 @@\n-    Node* min = MaxNode::unsigned_min(max, const_iters, TypeInt::make(0, scaled_iters, Type::WidenMin), *igvn);\n+    Node* min = MinMaxNode::unsigned_min(max, const_iters, TypeInt::make(0, scaled_iters, Type::WidenMin), *igvn);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2580,1 +2580,1 @@\n-        Node* repl = MaxNode::signed_max(n->in(1), n->in(2), _igvn.type(n), _igvn);\n+        Node* repl = MinMaxNode::signed_max(n->in(1), n->in(2), _igvn.type(n), _igvn);\n@@ -2584,1 +2584,1 @@\n-        Node* repl = MaxNode::signed_min(n->in(1), n->in(2), _igvn.type(n), _igvn);\n+        Node* repl = MinMaxNode::signed_min(n->in(1), n->in(2), _igvn.type(n), _igvn);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-    return MaxNode::build_min_max_long(phase, cmp_l, cmp_r, is_max);\n+    return MinMaxNode::build_min_max_long(phase, cmp_l, cmp_r, is_max);\n@@ -276,1 +276,1 @@\n-    return MaxNode::build_min_max_int(cmp_l, cmp_r, is_max);\n+    return MinMaxNode::build_min_max_int(cmp_l, cmp_r, is_max);\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+class MinMaxNode;\n@@ -812,0 +813,1 @@\n+      DEFINE_CLASS_ID(MinMax,      Add, 0)\n@@ -989,0 +991,1 @@\n+  DEFINE_CLASS_QUERY(MinMax)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1974,21 +1974,0 @@\n-    \/\/ MaxNode::find_identity_operation\n-    \/\/  Finds patterns like Max(A, Max(A, B)) -> Max(A, B)\n-    \/\/  This can be a 2-hop search, so maybe notification is not\n-    \/\/  good enough.\n-    \/\/\n-    \/\/ Found with:\n-    \/\/   compiler\/codegen\/TestBooleanVect.java\n-    \/\/   -XX:VerifyIterativeGVN=1110\n-    case Op_MaxL:\n-    case Op_MinL:\n-    case Op_MaxI:\n-    case Op_MinI:\n-    case Op_MaxF:\n-    case Op_MinF:\n-    case Op_MaxHF:\n-    case Op_MinHF:\n-    case Op_MaxD:\n-    case Op_MinD:\n-      return false;\n-\n-\n@@ -2626,0 +2605,9 @@\n+  \/\/ Check for Max\/Min(A, Max\/Min(B, C)) where A == B or A == C\n+  if (use->is_MinMax()) {\n+    for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n+      Node* u = use->fast_out(i2);\n+      if (u->Opcode() == use->Opcode()) {\n+        worklist.push(u);\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":9,"deletions":21,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1125,1 +1125,1 @@\n-  Node* last_clamped = MaxNode::build_min_max_long(&igvn, initL, last, stride > 0);\n+  Node* last_clamped = MinMaxNode::build_min_max_long(&igvn, initL, last, stride > 0);\n","filename":"src\/hotspot\/share\/opto\/vectorization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8373134\n+ * @summary Verify that min\/max add identity optimizations get applied correctly\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib \/\n+ * @run driver ${test.main.class}\n+ *\/\n+\n+package compiler.igvn;\n+\n+import compiler.lib.compile_framework.CompileFramework;\n+import compiler.lib.template_framework.Template;\n+import compiler.lib.template_framework.TemplateToken;\n+import compiler.lib.template_framework.library.CodeGenerationDataNameType;\n+import compiler.lib.template_framework.library.PrimitiveType;\n+import compiler.lib.template_framework.library.TestFrameworkClass;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+\n+import static compiler.lib.template_framework.Template.let;\n+import static compiler.lib.template_framework.Template.scope;\n+\n+public class TestMinMaxIdentity {\n+    public static void main(String[] args) {\n+        \/\/ Create a new CompileFramework instance.\n+        CompileFramework comp = new CompileFramework();\n+\n+        \/\/ Add a java source file.\n+        comp.addJavaSourceCode(\"compiler.igvn.templated.MinMaxIdentity\", generate(comp));\n+\n+        \/\/ Compile the source file.\n+        comp.compile(\"--add-modules=jdk.incubator.vector\");\n+\n+        comp.invoke(\"compiler.igvn.templated.MinMaxIdentity\", \"main\", new Object[] {new String[] {\n+            \"--add-modules=jdk.incubator.vector\",\n+            \"--add-opens\", \"jdk.incubator.vector\/jdk.incubator.vector=ALL-UNNAMED\"\n+        }});\n+    }\n+\n+    private static String generate(CompileFramework comp) {\n+        \/\/ Create a list to collect all tests.\n+        List<TemplateToken> testTemplateTokens = new ArrayList<>();\n+\n+        Stream.of(MinMaxOp.values())\n+            .flatMap(MinMaxOp::generate)\n+            .forEach(testTemplateTokens::add);\n+\n+        Stream.of(Fp16MinMaxOp.values())\n+            .flatMap(Fp16MinMaxOp::generate)\n+            .forEach(testTemplateTokens::add);\n+\n+        \/\/ Create the test class, which runs all testTemplateTokens.\n+        return TestFrameworkClass.render(\n+            \/\/ package and class name.\n+            \"compiler.igvn.templated\", \"MinMaxIdentity\",\n+            \/\/ List of imports.\n+            Set.of(\"jdk.incubator.vector.Float16\"),\n+            \/\/ classpath, so the Test VM has access to the compiled class files.\n+            comp.getEscapedClassPathOfCompiledClasses(),\n+            \/\/ The list of tests.\n+            testTemplateTokens);\n+    }\n+\n+    enum MinMaxOp {\n+        MIN_D(\"min\", CodeGenerationDataNameType.doubles()),\n+        MAX_D(\"max\", CodeGenerationDataNameType.doubles()),\n+        MIN_F(\"min\", CodeGenerationDataNameType.floats()),\n+        MAX_F(\"max\", CodeGenerationDataNameType.floats()),\n+        MIN_I(\"min\", CodeGenerationDataNameType.ints()),\n+        MAX_I(\"max\", CodeGenerationDataNameType.ints()),\n+        MIN_L(\"min\", CodeGenerationDataNameType.longs()),\n+        MAX_L(\"max\", CodeGenerationDataNameType.longs());\n+\n+        final String functionName;\n+        final PrimitiveType type;\n+\n+        MinMaxOp(String functionName, PrimitiveType type) {\n+            this.functionName = functionName;\n+            this.type = type;\n+        }\n+\n+        Stream<TemplateToken> generate() {\n+            return Stream.of(template(\"a\", \"b\"), template(\"b\", \"a\")).\n+                map(Template.ZeroArgs::asToken);\n+        }\n+\n+        private Template.ZeroArgs template(String arg1, String arg2) {\n+            return Template.make(() -> scope(\n+                let(\"boxedTypeName\", type.boxedTypeName()),\n+                let(\"op\", name()),\n+                let(\"type\", type.name()),\n+                let(\"functionName\", functionName),\n+                let(\"arg1\", arg1),\n+                let(\"arg2\", arg2),\n+                \"\"\"\n+                @Test\n+                @IR(counts = {IRNode.#op, \"= 1\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+                @Arguments(values = {Argument.NUMBER_42, Argument.NUMBER_42})\n+                public #type $test(#type #arg1, #type #arg2) {\n+                    int i;\n+                    for (i = -10; i < 1; i++) {\n+                    }\n+                    #type c = a * i;\n+                    return #boxedTypeName.#functionName(a, #boxedTypeName.#functionName(b, c));\n+                }\n+                \"\"\"\n+            ));\n+        }\n+    }\n+\n+    enum Fp16MinMaxOp {\n+        MAX_HF(\"max\"),\n+        MIN_HF(\"min\");\n+\n+        final String functionName;\n+\n+        Fp16MinMaxOp(String functionName) {\n+            this.functionName = functionName;\n+        }\n+\n+        Stream<TemplateToken> generate() {\n+            return Stream.of(template(\"a\", \"b\"), template(\"b\", \"a\")).\n+                map(Template.ZeroArgs::asToken);\n+        }\n+\n+        private Template.ZeroArgs template(String arg1, String arg2) {\n+            return Template.make(() -> scope(\n+                let(\"op\", name()),\n+                let(\"functionName\", functionName),\n+                let(\"arg1\", arg1),\n+                let(\"arg2\", arg2),\n+                \"\"\"\n+                @Setup\n+                private static Object[] $setup() {\n+                    return new Object[] {Float16.valueOf(42), Float16.valueOf(42)};\n+                }\n+\n+                @Test\n+                @IR(counts = {IRNode.#op, \"= 1\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION,\n+                    applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n+                @IR(counts = {IRNode.#op, \"= 1\"},\n+                    phase = CompilePhase.BEFORE_MACRO_EXPANSION,\n+                    applyIfCPUFeatureAnd = {\"fphp\", \"true\", \"asimdhp\", \"true\"})\n+                @Arguments(setup = \"$setup\")\n+                public Float16 $test(Float16 #arg1, Float16 #arg2) {\n+                    int i;\n+                    for (i = -10; i < 1; i++) {\n+                    }\n+                    Float16 c = Float16.multiply(a, Float16.valueOf(i));\n+                    return Float16.#functionName(a, Float16.#functionName(b, c));\n+                }\n+                \"\"\"\n+            ));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/igvn\/TestMinMaxIdentity.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"}]}