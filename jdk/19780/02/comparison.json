{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,2 @@\n-\/* convert jstring to C string *\/\n-static void jstring_to_cstring(JNIEnv* env, jstring jstr, char* cstr, int len);\n+\/* Converts jstring to C string, returns JNI_FALSE if the string has been truncated. *\/\n+static jboolean jstring_to_cstring(JNIEnv* env, jstring jstr, char* cstr, size_t cstr_buf_size);\n@@ -78,3 +78,3 @@\n-   char cmd[MAX_CMD_LENGTH];                \/* \"load\", \"dump\", ...      *\/\n-   char arg[MAX_ARGS][MAX_ARG_LENGTH];      \/* arguments to command     *\/\n-   char pipename[MAX_PIPE_NAME_LENGTH];\n+   char cmd[MAX_CMD_LENGTH + 1];            \/* \"load\", \"dump\", ...      *\/\n+   char arg[MAX_ARGS][MAX_ARG_LENGTH + 1];  \/* arguments to command     *\/\n+   char pipename[MAX_PIPE_NAME_LENGTH + 1];\n@@ -380,1 +380,0 @@\n-\n@@ -413,1 +412,5 @@\n-    jstring_to_cstring(env, cmd, data.cmd, MAX_CMD_LENGTH);\n+    if (!jstring_to_cstring(env, cmd, data.cmd, sizeof(data.cmd))) {\n+        JNU_ThrowByName(env, \"com\/sun\/tools\/attach\/AttachOperationFailedException\",\n+                        \"command is too long\");\n+        return;\n+    }\n@@ -426,1 +429,5 @@\n-                jstring_to_cstring(env, obj, data.arg[i], MAX_ARG_LENGTH);\n+                if (!jstring_to_cstring(env, obj, data.arg[i], sizeof(data.arg[i]))) {\n+                    JNU_ThrowByName(env, \"com\/sun\/tools\/attach\/AttachOperationFailedException\",\n+                                    \"argument is too long\");\n+                    return;\n+                }\n@@ -436,1 +443,5 @@\n-    jstring_to_cstring(env, pipename, data.pipename, MAX_PIPE_NAME_LENGTH);\n+    if (!jstring_to_cstring(env, pipename, data.pipename, sizeof(data.pipename))) {\n+        JNU_ThrowByName(env, \"com\/sun\/tools\/attach\/AttachOperationFailedException\",\n+                        \"pipe name is too long\");\n+        return;\n+    }\n@@ -618,2 +629,2 @@\n-\/* convert jstring to C string *\/\n-static void jstring_to_cstring(JNIEnv* env, jstring jstr, char* cstr, int len) {\n+\/* Converts jstring to C string, returns JNI_FALSE if the string has been truncated. *\/\n+static jboolean jstring_to_cstring(JNIEnv* env, jstring jstr, char* cstr, size_t cstr_buf_size) {\n@@ -622,0 +633,1 @@\n+    jboolean result = JNI_TRUE;\n@@ -627,1 +639,6 @@\n-        if ((*env)->ExceptionOccurred(env)) return;\n+        if ((*env)->ExceptionOccurred(env)) {\n+            return result;\n+        }\n+        if (strlen(str) >= cstr_buf_size) {\n+            result = JNI_FALSE;\n+        }\n@@ -629,2 +646,2 @@\n-        strncpy(cstr, str, len);\n-        cstr[len-1] = '\\0';\n+        strncpy(cstr, str, cstr_buf_size);\n+        cstr[cstr_buf_size - 1] = '\\0';\n@@ -635,0 +652,1 @@\n+    return result;\n","filename":"src\/jdk.attach\/windows\/native\/libattach\/VirtualMachineImpl.c","additions":33,"deletions":15,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests that long arguments of attach operation are not truncated\n+ * @bug 8334168\n+ * @library \/test\/lib\n+ * @modules jdk.attach\/sun.tools.attach\n+ * @run main LongArgTest\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+import com.sun.tools.attach.VirtualMachine;\n+import sun.tools.attach.HotSpotVirtualMachine;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+\n+public class LongArgTest {\n+\n+    \/\/ current restriction: max arg size is 1024\n+    private static int MAX_ARG_SIZE = 1024;\n+\n+    public static void main(String[] args) throws Exception {\n+        LingeredApp app = null;\n+        try {\n+            app = LingeredApp.startApp();\n+\n+            \/\/ sanity\n+            test(app)\n+                .mustSucceed()\n+                .run();\n+\n+            test(app)\n+                .valueLength(MAX_ARG_SIZE)\n+                .mustSucceed()\n+                .run();\n+\n+            test(app)\n+                .valueLength(MAX_ARG_SIZE + 1)\n+                .run();\n+\n+            \/\/ more than max args (3) with MAX_ARG_SIZE\n+            test(app)\n+                .valueLength(3 * MAX_ARG_SIZE + 1)\n+                .run();\n+\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+    }\n+\n+    private static Test test(LingeredApp app) {\n+        return new Test(app);\n+    }\n+\n+    \/\/ For simplicity, the test uses internal HotSpotVirtualMachine,\n+    \/\/ sets\/gets \"HeapDumpPath\" flag value (string flag, not validated by JVM).\n+    private static class Test {\n+        private LingeredApp app;\n+        private String flagName = \"HeapDumpPath\";\n+        private String flagValue = generateValue(5);\n+        private boolean setFlagMustSucceed = false;\n+\n+        Test(LingeredApp app) {\n+            this.app = app;\n+        }\n+\n+        Test valueLength(int len) {\n+            flagValue = generateValue(len);\n+            return this;\n+        }\n+\n+        Test mustSucceed() {\n+            setFlagMustSucceed = true;\n+            return this;\n+        }\n+\n+        void run() throws Exception {\n+            System.out.println(\"======== Start ========\");\n+            System.out.println(\"Arg size = \" + flagValue.length());\n+\n+            HotSpotVirtualMachine vm = (HotSpotVirtualMachine)VirtualMachine.attach(String.valueOf(app.getPid()));\n+\n+            if (setFlag(vm)) {\n+                String actualValue = getFlag(vm);\n+\n+                if (!flagValue.equals(actualValue)) {\n+                    String msg = \"Actual value is different: \";\n+                    if (actualValue == null) {\n+                        msg += \"null\";\n+                    } else if (flagValue.startsWith(actualValue)) {\n+                        msg += \"truncated from \" + flagValue.length() + \" to \" + actualValue.length();\n+                    } else {\n+                        msg += actualValue + \", expected value: \" + flagValue;\n+                    }\n+                    System.out.println(msg);\n+                    vm.detach();\n+                    throw new RuntimeException(msg);\n+                } else {\n+                    System.out.println(\"Actual value matches: \" + actualValue);\n+                }\n+            }\n+\n+            vm.detach();\n+\n+            System.out.println(\"======== End ========\");\n+            System.out.println();\n+        }\n+\n+        \/\/ Sets the flag value, return true on success.\n+        private boolean setFlag(HotSpotVirtualMachine vm) throws Exception {\n+            BufferedReader replyReader = null;\n+            try {\n+                replyReader = new BufferedReader(new InputStreamReader(\n+                    vm.setFlag(flagName, flagValue)));\n+            } catch (IOException ex) {\n+                if (setFlagMustSucceed) {\n+                    throw ex;\n+                }\n+                System.out.println(\"OK: setFlag() thrown exception:\");\n+                ex.printStackTrace(System.out);\n+                return false;\n+            }\n+\n+            String line;\n+            while ((line = replyReader.readLine()) != null) {\n+                System.out.println(\"setFlag: \" + line);\n+            }\n+            replyReader.close();\n+            return true;\n+        }\n+\n+        private String getFlag(HotSpotVirtualMachine vm) throws Exception {\n+            \/\/ Then read and make sure we get back the same value.\n+            BufferedReader replyReader = new BufferedReader(new InputStreamReader(vm.printFlag(flagName)));\n+\n+            String prefix = \"-XX:\" + flagName + \"=\";\n+            String value = null;\n+            String line;\n+            while((line = replyReader.readLine()) != null) {\n+                System.out.println(\"getFlag: \" + line);\n+                if (line.startsWith(prefix)) {\n+                    value = line.substring(prefix.length());\n+                }\n+            }\n+            return value;\n+        }\n+\n+        private String generateValue(int len) {\n+            return \"X\" + \"A\".repeat(len - 2) + \"X\";\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/LongArgTest.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"}]}