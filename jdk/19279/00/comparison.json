{"files":[{"patch":"@@ -86,12 +86,1 @@\n-void MutableNUMASpace::set_top_for_allocations(HeapWord* v) {\n-  assert(false, \"Do not mangle MutableNUMASpace's\");\n-}\n-void MutableNUMASpace::set_top_for_allocations() {\n-  \/\/ This method should do nothing.\n-}\n-void MutableNUMASpace::check_mangled_unused_area(HeapWord* limit) {\n-  \/\/ This method should do nothing.\n-}\n-void MutableNUMASpace::check_mangled_unused_area_complete() {\n-  \/\/ This method should do nothing.\n-}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -178,4 +178,0 @@\n-  virtual void check_mangled_unused_area(HeapWord* limit) PRODUCT_RETURN;\n-  virtual void check_mangled_unused_area_complete() PRODUCT_RETURN;\n-  virtual void set_top_for_allocations(HeapWord* v) PRODUCT_RETURN;\n-  virtual void set_top_for_allocations() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n@@ -39,1 +38,0 @@\n-  _mangler(nullptr),\n@@ -48,5 +46,0 @@\n-  _mangler = new MutableSpaceMangler(this);\n-}\n-\n-MutableSpace::~MutableSpace() {\n-  delete _mangler;\n@@ -155,7 +148,0 @@\n-void MutableSpace::check_mangled_unused_area(HeapWord* limit) {\n-  mangler()->check_mangled_unused_area(limit);\n-}\n-\n-void MutableSpace::check_mangled_unused_area_complete() {\n-  mangler()->check_mangled_unused_area_complete();\n-}\n@@ -163,3 +149,0 @@\n-\/\/ Mangle only the unused space that has not previously\n-\/\/ been mangled and that has not been allocated since being\n-\/\/ mangled.\n@@ -167,1 +150,1 @@\n-  mangler()->mangle_unused_area();\n+  mangle_region(MemRegion(_top, _end));\n@@ -174,7 +157,0 @@\n-void MutableSpace::set_top_for_allocations(HeapWord* v) {\n-  mangler()->set_top_for_allocations(v);\n-}\n-\n-void MutableSpace::set_top_for_allocations() {\n-  mangler()->set_top_for_allocations(top());\n-}\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-class MutableSpaceMangler;\n-\n@@ -54,2 +52,0 @@\n-  \/\/ Helper for mangling unused space in debug builds\n-  MutableSpaceMangler* _mangler;\n@@ -63,2 +59,0 @@\n-  MutableSpaceMangler* mangler() { return _mangler; }\n-\n@@ -71,1 +65,1 @@\n-  virtual ~MutableSpace();\n+  virtual ~MutableSpace() = default;\n@@ -110,1 +104,0 @@\n-  \/\/ Methods used in mangling.  See descriptions under SpaceMangler.\n@@ -112,7 +105,1 @@\n-\n-  virtual void check_mangled_unused_area(HeapWord* limit) PRODUCT_RETURN;\n-  virtual void check_mangled_unused_area_complete() PRODUCT_RETURN;\n-  virtual void set_top_for_allocations(HeapWord* v) PRODUCT_RETURN;\n-\n-  \/\/ Used to save the space's current top for later use during mangling.\n-  virtual void set_top_for_allocations() PRODUCT_RETURN;\n+  virtual void mangle_region(MemRegion mr) PRODUCT_RETURN;\n@@ -122,2 +109,0 @@\n-  virtual void mangle_region(MemRegion mr) PRODUCT_RETURN;\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.hpp","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -844,18 +844,0 @@\n-#ifndef PRODUCT\n-void ParallelScavengeHeap::record_gen_tops_before_GC() {\n-  if (ZapUnusedHeapArea) {\n-    young_gen()->record_spaces_top();\n-    old_gen()->record_spaces_top();\n-  }\n-}\n-\n-void ParallelScavengeHeap::gen_mangle_unused_area() {\n-  if (ZapUnusedHeapArea) {\n-    young_gen()->eden_space()->mangle_unused_area();\n-    young_gen()->to_space()->mangle_unused_area();\n-    young_gen()->from_space()->mangle_unused_area();\n-    old_gen()->object_space()->mangle_unused_area();\n-  }\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -246,6 +246,0 @@\n-  \/\/ Save the tops of the spaces in all generations\n-  void record_gen_tops_before_GC() PRODUCT_RETURN;\n-\n-  \/\/ Mangle the unused parts of all spaces in the heap\n-  void gen_mangle_unused_area() PRODUCT_RETURN;\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n@@ -379,7 +378,0 @@\n-\n-#ifndef PRODUCT\n-void PSOldGen::record_spaces_top() {\n-  assert(ZapUnusedHeapArea, \"Not mangling unused space\");\n-  object_space()->set_top_for_allocations();\n-}\n-#endif\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -159,3 +159,0 @@\n-  \/\/ Debugging support\n-  \/\/ Save the tops of all spaces for later use during mangling.\n-  void record_spaces_top() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n@@ -966,2 +965,10 @@\n-    \/\/ Update top().  Must be done after clearing the bitmap and summary data.\n-    _space_info[id].publish_new_top();\n+    {\n+      MutableSpace* space = _space_info[id].space();\n+      HeapWord* top = space->top();\n+      HeapWord* new_top = _space_info[id].new_top();\n+      if (ZapUnusedHeapArea && new_top < top) {\n+        space->mangle_region(MemRegion(new_top, top));\n+      }\n+      \/\/ Update top().  Must be done after clearing the bitmap and summary data.\n+      space->set_top(new_top);\n+    }\n@@ -1010,4 +1017,0 @@\n-  if (ZapUnusedHeapArea) {\n-    heap->gen_mangle_unused_area();\n-  }\n-\n@@ -1310,5 +1313,0 @@\n-  if (ZapUnusedHeapArea) {\n-    \/\/ Save information needed to minimize mangling\n-    heap->record_gen_tops_before_GC();\n-  }\n-\n@@ -1472,4 +1470,0 @@\n-  if (ZapUnusedHeapArea) {\n-    old_gen->object_space()->check_mangled_unused_area_complete();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n@@ -625,14 +624,0 @@\n-\n-    \/\/ If not mangling the spaces, do some checking to verify that\n-    \/\/ the spaces are already mangled.\n-    \/\/ The spaces should be correctly mangled at this point so\n-    \/\/ do some checking here. Note that they are not being mangled\n-    \/\/ in the calls to initialize().\n-    \/\/ Must check mangling before the spaces are reshaped.  Otherwise,\n-    \/\/ the bottom or end of one space may have moved into an area\n-    \/\/ covered by another space and a failure of the check may\n-    \/\/ not correctly indicate which space is not properly mangled.\n-    HeapWord* limit = (HeapWord*) virtual_space()->high();\n-    eden_space()->check_mangled_unused_area(limit);\n-    from_space()->check_mangled_unused_area(limit);\n-      to_space()->check_mangled_unused_area(limit);\n@@ -836,9 +821,0 @@\n-\n-#ifndef PRODUCT\n-void PSYoungGen::record_spaces_top() {\n-  assert(ZapUnusedHeapArea, \"Not mangling unused space\");\n-  eden_space()->set_top_for_allocations();\n-  from_space()->set_top_for_allocations();\n-  to_space()->set_top_for_allocations();\n-}\n-#endif\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -155,2 +155,0 @@\n-\n-  void record_spaces_top() PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n@@ -334,15 +334,0 @@\n-  \/\/ If not clearing the spaces, do some checking to verify that\n-  \/\/ the space are already mangled.\n-  if (!clear_space) {\n-    \/\/ Must check mangling before the spaces are reshaped.  Otherwise,\n-    \/\/ the bottom or end of one space may have moved into another\n-    \/\/ a failure of the check may not correctly indicate which space\n-    \/\/ is not properly mangled.\n-    if (ZapUnusedHeapArea) {\n-      HeapWord* limit = (HeapWord*) _virtual_space.high();\n-      eden()->check_mangled_unused_area(limit);\n-      from()->check_mangled_unused_area(limit);\n-        to()->check_mangled_unused_area(limit);\n-    }\n-  }\n-\n@@ -720,10 +705,0 @@\n-    if (ZapUnusedHeapArea) {\n-      \/\/ This is now done here because of the piece-meal mangling which\n-      \/\/ can check for valid mangling at intermediate points in the\n-      \/\/ collection(s).  When a young collection fails to collect\n-      \/\/ sufficient space resizing of the young generation can occur\n-      \/\/ an redistribute the spaces in the young generation.  Mangle\n-      \/\/ here so that unzapped regions don't get distributed to\n-      \/\/ other spaces.\n-      to()->mangle_unused_area();\n-    }\n@@ -895,1 +870,1 @@\n-    to()->mangle_unused_area_complete();\n+    to()->mangle_unused_area();\n@@ -953,6 +928,0 @@\n-  if (ZapUnusedHeapArea) {\n-    eden()->check_mangled_unused_area_complete();\n-    from()->check_mangled_unused_area_complete();\n-    to()->check_mangled_unused_area_complete();\n-  }\n-\n@@ -964,7 +933,0 @@\n-void DefNewGeneration::record_spaces_top() {\n-  assert(ZapUnusedHeapArea, \"Not mangling unused space\");\n-  eden()->set_top_for_allocations();\n-  to()->set_top_for_allocations();\n-  from()->set_top_for_allocations();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":2,"deletions":40,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -235,3 +235,0 @@\n-  \/\/ Save the tops for eden, from, and to\n-  void record_spaces_top();\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -368,0 +368,1 @@\n+      HeapWord* new_top = get_compaction_top(i);\n@@ -369,3 +370,3 @@\n-      space->set_top(get_compaction_top(i));\n-      if (ZapUnusedHeapArea) {\n-        space->mangle_unused_area();\n+      space->set_top(new_top);\n+      if (ZapUnusedHeapArea && new_top < top) {\n+        space->mangle_unused_area(MemRegion(new_top, top));\n","filename":"src\/hotspot\/share\/gc\/serial\/serialFullGC.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -456,1 +456,0 @@\n-  record_gen_tops_before_GC();\n@@ -959,9 +958,0 @@\n-\n-#ifndef PRODUCT\n-void SerialHeap::record_gen_tops_before_GC() {\n-  if (ZapUnusedHeapArea) {\n-    _young_gen->record_spaces_top();\n-    _old_gen->record_spaces_top();\n-  }\n-}\n-#endif  \/\/ not PRODUCT\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -297,3 +297,0 @@\n-  \/\/ Save the tops of the spaces in all generations\n-  void record_gen_tops_before_GC() PRODUCT_RETURN;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-      MemRegion mangle_region(space()->end(),\n-      (HeapWord*)_virtual_space.high());\n+      MemRegion mangle_region(space()->end(), (HeapWord*)_virtual_space.high());\n@@ -488,8 +487,0 @@\n-  if (ZapUnusedHeapArea) {\n-    _the_space->check_mangled_unused_area_complete();\n-  }\n-}\n-\n-void TenuredGeneration::record_spaces_top() {\n-  assert(ZapUnusedHeapArea, \"Not mangling unused space\");\n-  _the_space->set_top_for_allocations();\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -159,2 +159,0 @@\n-  void record_spaces_top();\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n@@ -45,7 +45,1 @@\n-  _top(nullptr) {\n-  _mangler = new GenSpaceMangler(this);\n-}\n-\n-ContiguousSpace::~ContiguousSpace() {\n-  delete _mangler;\n-}\n+  _top(nullptr) {}\n@@ -76,5 +70,2 @@\n-void ContiguousSpace::set_top_for_allocations() {\n-  mangler()->set_top_for_allocations(top());\n-}\n-void ContiguousSpace::check_mangled_unused_area(HeapWord* limit) {\n-  mangler()->check_mangled_unused_area(limit);\n+void ContiguousSpace::mangle_unused_area() {\n+  mangle_unused_area(MemRegion(_top, _end));\n@@ -83,2 +74,2 @@\n-void ContiguousSpace::check_mangled_unused_area_complete() {\n-  mangler()->check_mangled_unused_area_complete();\n+void ContiguousSpace::mangle_unused_area(MemRegion mr) {\n+  SpaceMangler::mangle_region(mr);\n@@ -87,9 +78,0 @@\n-\/\/ Mangled only the unused space that has not previously\n-\/\/ been mangled and that has not been allocated since being\n-\/\/ mangled.\n-void ContiguousSpace::mangle_unused_area() {\n-  mangler()->mangle_unused_area();\n-}\n-void ContiguousSpace::mangle_unused_area_complete() {\n-  mangler()->mangle_unused_area_complete();\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":6,"deletions":24,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -44,3 +44,0 @@\n-\/\/ Forward decls.\n-class GenSpaceMangler;\n-\n@@ -60,4 +57,0 @@\n-  \/\/ A helper for mangling the unused area of the space in debug builds.\n-  GenSpaceMangler* _mangler;\n-\n-  GenSpaceMangler* mangler() { return _mangler; }\n@@ -71,1 +64,0 @@\n-  ~ContiguousSpace();\n@@ -118,9 +110,0 @@\n-  \/\/ Used to save the space's current top for later use during mangling.\n-  void set_top_for_allocations() PRODUCT_RETURN;\n-\n-  \/\/ For detecting GC bugs.  Should only be called at GC boundaries, since\n-  \/\/ some unused space may be used as scratch space during GC's.\n-  \/\/ We also call this when expanding a space to satisfy an allocation\n-  \/\/ request. See bug #4668531\n-  \/\/ Mangle regions in the space from the current top up to the\n-  \/\/ previously mangled part of the space.\n@@ -128,8 +111,1 @@\n-  \/\/ Mangle [top, end)\n-  void mangle_unused_area_complete() PRODUCT_RETURN;\n-\n-  \/\/ Do some sparse checking on the area that should have been mangled.\n-  void check_mangled_unused_area(HeapWord* limit) PRODUCT_RETURN;\n-  \/\/ Check the complete area that should have been mangled.\n-  \/\/ This code may be null depending on the macro DEBUG_MANGLING.\n-  void check_mangled_unused_area_complete() PRODUCT_RETURN;\n+  void mangle_unused_area(MemRegion mr) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-#include \"gc\/parallel\/mutableSpace.hpp\"\n-#include \"gc\/shared\/space.hpp\"\n-#include \"gc\/shared\/spaceDecorator.inline.hpp\"\n-#include \"logging\/log.hpp\"\n+#include \"gc\/shared\/spaceDecorator.hpp\"\n@@ -32,2 +29,0 @@\n-\/\/ Catch-all file for utility classes\n-\n@@ -36,48 +31,0 @@\n-\/\/ Returns true is the location q matches the mangling\n-\/\/ pattern.\n-bool SpaceMangler::is_mangled(HeapWord* q) {\n-  \/\/ This test loses precision but is good enough\n-  return badHeapWord == (max_juint & reinterpret_cast<uintptr_t>(*q));\n-}\n-\n-\n-void SpaceMangler::set_top_for_allocations(HeapWord* v)  {\n-  if (v < end()) {\n-    assert(!CheckZapUnusedHeapArea || is_mangled(v),\n-      \"The high water mark is not mangled\");\n-  }\n-  _top_for_allocations = v;\n-}\n-\n-\/\/ Mangle only the unused space that has not previously\n-\/\/ been mangled and that has not been allocated since being\n-\/\/ mangled.\n-void SpaceMangler::mangle_unused_area() {\n-  assert(ZapUnusedHeapArea, \"Mangling should not be in use\");\n-  \/\/ Mangle between top and the high water mark.  Safeguard\n-  \/\/ against the space changing since top_for_allocations was\n-  \/\/ set.\n-  HeapWord* mangled_end = MIN2(top_for_allocations(), end());\n-  if (top() < mangled_end) {\n-    MemRegion mangle_mr(top(), mangled_end);\n-    SpaceMangler::mangle_region(mangle_mr);\n-    \/\/ Light weight check of mangling.\n-    check_mangled_unused_area(end());\n-  }\n-  \/\/ Complete check of unused area which is functional when\n-  \/\/ DEBUG_MANGLING is defined.\n-  check_mangled_unused_area_complete();\n-}\n-\n-\/\/ A complete mangle is expected in the\n-\/\/ exceptional case where top_for_allocations is not\n-\/\/ properly tracking the high water mark for mangling.\n-\/\/ This can be the case when to-space is being used for\n-\/\/ scratch space during a mark-sweep-compact.  See\n-\/\/ contribute_scratch().\n-void SpaceMangler::mangle_unused_area_complete() {\n-  assert(ZapUnusedHeapArea, \"Mangling should not be in use\");\n-  MemRegion mangle_mr(top(), end());\n-  SpaceMangler::mangle_region(mangle_mr);\n-}\n-\n@@ -92,47 +39,0 @@\n-\/\/ Check that top, top_for_allocations and the last\n-\/\/ word of the space are mangled.  In a tight memory\n-\/\/ situation even this light weight mangling could\n-\/\/ cause paging by touching the end of the space.\n-void  SpaceMangler::check_mangled_unused_area(HeapWord* limit) {\n-  if (CheckZapUnusedHeapArea) {\n-    \/\/ This method can be called while the spaces are\n-    \/\/ being reshaped so skip the test if the end of the\n-    \/\/ space is beyond the specified limit;\n-    if (end() > limit) return;\n-\n-    assert(top() == end() ||\n-           (is_mangled(top())), \"Top not mangled\");\n-    assert((top_for_allocations() < top()) ||\n-           (top_for_allocations() >= end()) ||\n-           (is_mangled(top_for_allocations())),\n-           \"Older unused not mangled\");\n-    assert(top() == end() ||\n-           (is_mangled(end() - 1)), \"End not properly mangled\");\n-    \/\/ Only does checking when DEBUG_MANGLING is defined.\n-    check_mangled_unused_area_complete();\n-  }\n-}\n-\n-#undef DEBUG_MANGLING\n-\/\/ This should only be used while debugging the mangling\n-\/\/ because of the high cost of checking the completeness.\n-void  SpaceMangler::check_mangled_unused_area_complete() {\n-  if (CheckZapUnusedHeapArea) {\n-    assert(ZapUnusedHeapArea, \"Not mangling unused area\");\n-#ifdef DEBUG_MANGLING\n-    HeapWord* q = top();\n-    HeapWord* limit = end();\n-\n-    bool passed = true;\n-    while (q < limit) {\n-      if (!is_mangled(q)) {\n-        passed = false;\n-        break;\n-      }\n-      q++;\n-    }\n-    assert(passed, \"Mangling is not complete\");\n-#endif\n-  }\n-}\n-#undef DEBUG_MANGLING\n","filename":"src\/hotspot\/share\/gc\/shared\/spaceDecorator.cpp","additions":1,"deletions":101,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-class SpaceDecorator: public AllStatic {\n+class SpaceDecorator : AllStatic {\n@@ -41,78 +41,1 @@\n-\/\/ Functionality for use with class Space and class MutableSpace.\n-\/\/   The approach taken with the mangling is to mangle all\n-\/\/ the space initially and then to mangle areas that have\n-\/\/ been allocated since the last collection.  Mangling is\n-\/\/ done in the context of a generation and in the context\n-\/\/ of a space.\n-\/\/   The space in a generation is mangled when it is first\n-\/\/ initialized and when the generation grows.  The spaces\n-\/\/ are not necessarily up-to-date when this mangling occurs\n-\/\/ and the method mangle_region() is used.\n-\/\/   After allocations have been done in a space, the space generally\n-\/\/ need to be remangled.  Remangling is only done on the\n-\/\/ recently allocated regions in the space.  Typically, that is\n-\/\/ the region between the new top and the top just before a\n-\/\/ garbage collection.\n-\/\/   An exception to the usual mangling in a space is done when the\n-\/\/ space is used for an extraordinary purpose.  Specifically, when\n-\/\/ to-space is used as scratch space for a mark-sweep-compact\n-\/\/ collection.\n-\/\/   Spaces are mangled after a collection.  If the generation\n-\/\/ grows after a collection, the added space is mangled as part of\n-\/\/ the growth of the generation.  No additional mangling is needed when the\n-\/\/ spaces are resized after an expansion.\n-\/\/   The class SpaceMangler keeps a pointer to the top of the allocated\n-\/\/ area and provides the methods for doing the piece meal mangling.\n-\/\/ Methods for doing spaces and full checking of the mangling are\n-\/\/ included.  The full checking is done if DEBUG_MANGLING is defined.\n-\/\/   GenSpaceMangler is used with the SerialHeap collectors and\n-\/\/ MutableSpaceMangler is used with the ParallelScavengeHeap collectors.\n-\/\/ These subclasses abstract the differences in the types of spaces used\n-\/\/ by each heap.\n-\n-class SpaceMangler: public CHeapObj<mtGC> {\n-  friend class VMStructs;\n-\n-  \/\/ High water mark for allocations.  Typically, the space above\n-  \/\/ this point have been mangle previously and don't need to be\n-  \/\/ touched again.  Space below this point has been allocated\n-  \/\/ and remangling is needed between the current top and this\n-  \/\/ high water mark.\n-  HeapWord* _top_for_allocations;\n-  HeapWord* top_for_allocations() { return _top_for_allocations; }\n-\n- public:\n-\n-  \/\/ Setting _top_for_allocations to null at initialization\n-  \/\/ makes it always below top so that mangling done as part\n-  \/\/ of the initialize() call of a space does nothing (as it\n-  \/\/ should since the mangling is done as part of the constructor\n-  \/\/ for the space.\n-  SpaceMangler() : _top_for_allocations(nullptr) {}\n-\n-  \/\/ Methods for top and end that delegate to the specific\n-  \/\/ space type.\n-  virtual HeapWord* top() const = 0;\n-  virtual HeapWord* end() const = 0;\n-\n-  \/\/ Return true if q matches the mangled pattern.\n-  static bool is_mangled(HeapWord* q) PRODUCT_RETURN0;\n-\n-  \/\/ Used to save the address in a space for later use during mangling.\n-  void set_top_for_allocations(HeapWord* v);\n-\n-  \/\/ Overwrites the unused portion of this space.\n-  \/\/ Mangle only the region not previously mangled [top, top_previously_mangled)\n-  void mangle_unused_area();\n-  \/\/ Mangle all the unused region [top, end)\n-  void mangle_unused_area_complete();\n-  \/\/ Do some sparse checking on the area that should have been mangled.\n-  void check_mangled_unused_area(HeapWord* limit) PRODUCT_RETURN;\n-  \/\/ Do a complete check of the area that should be mangled.\n-  void check_mangled_unused_area_complete() PRODUCT_RETURN;\n-\n-  \/\/ Mangle the MemRegion.  This is a non-space specific mangler.  It\n-  \/\/ is used during the initial mangling of a space before the space\n-  \/\/ is fully constructed.  Also is used when a generation is expanded\n-  \/\/ and possibly before the spaces have been reshaped to to the new\n-  \/\/ size of the generation.\n+struct SpaceMangler : AllStatic {\n@@ -122,29 +45,0 @@\n-class ContiguousSpace;\n-class MutableSpace;\n-\n-\/\/ For use with SerialHeap's\n-class GenSpaceMangler: public SpaceMangler {\n-  ContiguousSpace* _sp;\n-\n-  ContiguousSpace* sp() { return _sp; }\n-\n-  HeapWord* top() const;\n-  HeapWord* end() const;\n-\n- public:\n-  GenSpaceMangler(ContiguousSpace* sp) : SpaceMangler(), _sp(sp) {}\n-};\n-\n-\/\/ For use with ParallelScavengeHeap's.\n-class MutableSpaceMangler: public SpaceMangler {\n-  MutableSpace* _sp;\n-\n-  MutableSpace* sp() { return _sp; }\n-\n-  HeapWord* top() const;\n-  HeapWord* end() const;\n-\n- public:\n-  MutableSpaceMangler(MutableSpace* sp) : SpaceMangler(), _sp(sp) {}\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/spaceDecorator.hpp","additions":2,"deletions":108,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_SPACEDECORATOR_INLINE_HPP\n-#define SHARE_GC_SHARED_SPACEDECORATOR_INLINE_HPP\n-\n-#include \"gc\/shared\/spaceDecorator.hpp\"\n-\n-#include \"gc\/parallel\/mutableSpace.hpp\"\n-#include \"gc\/shared\/space.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-inline HeapWord* GenSpaceMangler::top() const { return _sp->top(); }\n-inline HeapWord* GenSpaceMangler::end() const { return _sp->end(); }\n-\n-inline HeapWord* MutableSpaceMangler::top() const { return _sp->top(); }\n-inline HeapWord* MutableSpaceMangler::end() const { return _sp->end(); }\n-\n-#endif \/\/ SHARE_GC_SHARED_SPACEDECORATOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/spaceDecorator.inline.hpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -476,3 +476,0 @@\n-  develop(bool, CheckZapUnusedHeapArea, false,                              \\\n-          \"Check zapping of unused heap space\")                             \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}