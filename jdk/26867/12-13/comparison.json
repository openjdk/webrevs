{"files":[{"patch":"@@ -181,1 +181,2 @@\n-    assert(region->garbage_before_padded_for_promote() < old_garbage_threshold, \"Region %zu has too much garbage for promotion\", region->index());\n+    assert(region->garbage_before_padded_for_promote() < old_garbage_threshold,\n+           \"Region %zu has too much garbage for promotion\", region->index());\n@@ -237,1 +238,1 @@\n-    \/\/ is_collector_free range.\n+    \/\/ is_collector_free range.  We'll add it to that range below.\n@@ -239,0 +240,1 @@\n+#ifdef ASSERT\n@@ -241,0 +243,1 @@\n+#endif\n@@ -246,15 +249,1 @@\n-    \/\/ Unconditionally transfer one region from young to old. This represents the newly promoted region.\n-    \/\/ This expands old and shrinks new by the size of one region.  Strictly, we do not \"need\" to expand old\n-    \/\/ if there are already enough unaffiliated regions in old to account for this newly promoted region.\n-    \/\/ However, if we do not transfer the capacities, we end up reducing the amount of memory that would have\n-    \/\/ otherwise been available to hold old evacuations, because old available is max_capacity - used and now\n-    \/\/ we would be trading a fully empty region for a partially used region.\n-\n-    size_t available_in_region = region->free();\n-    size_t plab_min_size_in_bytes = _heap->plab_min_size() * HeapWordSize;\n-    if (available_in_region < plab_min_size_in_bytes) {\n-      \/\/ The available memory in young had been retired.  Retire it in old also.\n-      region_to_be_used_in_old += available_in_region;\n-    }\n-\n-    \/\/ add_old_collector_free_region() increases promoted_reserve() if available space exceeds plab_min_size()\n+    \/\/ Transfer this region from young to old, increasing promoted_reserve if available space exceeds plab_min_size()\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalEvacuationTask.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"}]}