{"files":[{"patch":"@@ -2001,4 +2001,1 @@\n-  if ((young_unaffiliated_regions() > 0) &&\n-      ((_partitions.get_capacity(ShenandoahFreeSetPartitionId::OldCollector) + region_size_bytes)\n-       <= gen_heap->generation_sizer()->max_size_for(old_gen)) &&\n-      ((total_young_regions() - 1) * region_size_bytes >= gen_heap->generation_sizer()->min_size_for(young_gen))) {\n+  if (young_unaffiliated_regions() > 0) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1145,2 +1145,0 @@\n-  \/\/ We defer generation resizing actions until after cset regions have been recycled.  We do this even following an\n-  \/\/ abbreviated cycle.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"gc\/shenandoah\/shenandoahGeneration.hpp\"\n-#include \"gc\/shenandoah\/shenandoahGenerationSizer.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n-#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n-#include \"gc\/shenandoah\/shenandoahOldGeneration.hpp\"\n-#include \"gc\/shenandoah\/shenandoahYoungGeneration.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"runtime\/globals_extension.hpp\"\n-\n-\n-ShenandoahGenerationSizer::ShenandoahGenerationSizer()\n-        : _sizer_kind(SizerDefaults),\n-          _min_desired_young_regions(0),\n-          _max_desired_young_regions(0) {\n-\n-  if (FLAG_IS_CMDLINE(NewRatio)) {\n-    if (FLAG_IS_CMDLINE(NewSize) || FLAG_IS_CMDLINE(MaxNewSize)) {\n-      log_warning(gc, ergo)(\"-XX:NewSize and -XX:MaxNewSize override -XX:NewRatio\");\n-    } else {\n-      _sizer_kind = SizerNewRatio;\n-      return;\n-    }\n-  }\n-\n-  if (NewSize > MaxNewSize) {\n-    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-      log_warning(gc, ergo)(\"NewSize (%zuk) is greater than the MaxNewSize (%zuk). \"\n-                            \"A new max generation size of %zuk will be used.\",\n-              NewSize\/K, MaxNewSize\/K, NewSize\/K);\n-    }\n-    FLAG_SET_ERGO(MaxNewSize, NewSize);\n-  }\n-\n-  if (FLAG_IS_CMDLINE(NewSize)) {\n-    _min_desired_young_regions = MAX2(uint(NewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n-    if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-      _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n-      _sizer_kind = SizerMaxAndNewSize;\n-    } else {\n-      _sizer_kind = SizerNewSizeOnly;\n-    }\n-  } else if (FLAG_IS_CMDLINE(MaxNewSize)) {\n-    _max_desired_young_regions = MAX2(uint(MaxNewSize \/ ShenandoahHeapRegion::region_size_bytes()), 1U);\n-    _sizer_kind = SizerMaxNewSizeOnly;\n-  }\n-}\n-\n-size_t ShenandoahGenerationSizer::calculate_min_young_regions(size_t heap_region_count) {\n-  size_t min_young_regions = (heap_region_count * ShenandoahMinYoungPercentage) \/ 100;\n-  return MAX2(min_young_regions, (size_t) 1U);\n-}\n-\n-size_t ShenandoahGenerationSizer::calculate_max_young_regions(size_t heap_region_count) {\n-  size_t max_young_regions = (heap_region_count * ShenandoahMaxYoungPercentage) \/ 100;\n-  return MAX2(max_young_regions, (size_t) 1U);\n-}\n-\n-void ShenandoahGenerationSizer::recalculate_min_max_young_length(size_t heap_region_count) {\n-  assert(heap_region_count > 0, \"Heap must be initialized\");\n-\n-  switch (_sizer_kind) {\n-    case SizerDefaults:\n-      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n-      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n-      break;\n-    case SizerNewSizeOnly:\n-      _max_desired_young_regions = calculate_max_young_regions(heap_region_count);\n-      _max_desired_young_regions = MAX2(_min_desired_young_regions, _max_desired_young_regions);\n-      break;\n-    case SizerMaxNewSizeOnly:\n-      _min_desired_young_regions = calculate_min_young_regions(heap_region_count);\n-      _min_desired_young_regions = MIN2(_min_desired_young_regions, _max_desired_young_regions);\n-      break;\n-    case SizerMaxAndNewSize:\n-      \/\/ Do nothing. Values set on the command line, don't update them at runtime.\n-      break;\n-    case SizerNewRatio:\n-      _min_desired_young_regions = MAX2(uint(heap_region_count \/ (NewRatio + 1)), 1U);\n-      _max_desired_young_regions = _min_desired_young_regions;\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-\n-  assert(_min_desired_young_regions <= _max_desired_young_regions, \"Invalid min\/max young gen size values\");\n-}\n-\n-void ShenandoahGenerationSizer::heap_size_changed(size_t heap_size) {\n-  recalculate_min_max_young_length(heap_size \/ ShenandoahHeapRegion::region_size_bytes());\n-}\n-\n-size_t ShenandoahGenerationSizer::max_size_for(ShenandoahGeneration* generation) const {\n-  switch (generation->type()) {\n-    case YOUNG:\n-      return max_young_size();\n-    case OLD:\n-      \/\/ On the command line, max size of OLD is specified indirectly, by setting a minimum size of young.\n-      \/\/ OLD is what remains within the heap after YOUNG has been sized.\n-      return ShenandoahHeap::heap()->max_capacity() - min_young_size();\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n-\n-size_t ShenandoahGenerationSizer::min_size_for(ShenandoahGeneration* generation) const {\n-  switch (generation->type()) {\n-    case YOUNG:\n-      return min_young_size();\n-    case OLD:\n-      \/\/ On the command line, min size of OLD is specified indirectly, by setting a maximum size of young.\n-      \/\/ OLD is what remains within the heap after YOUNG has been sized.\n-      return ShenandoahHeap::heap()->max_capacity() - max_young_size();\n-    default:\n-      ShouldNotReachHere();\n-      return 0;\n-  }\n-}\n-\n-size_t ShenandoahGenerationSizer::min_young_size() const {\n-  return min_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n-}\n-\n-size_t ShenandoahGenerationSizer::max_young_size() const {\n-  return max_young_regions() * ShenandoahHeapRegion::region_size_bytes();\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationSizer.cpp","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -1,80 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n-#define SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-class ShenandoahGeneration;\n-class ShenandoahGenerationalHeap;\n-\n-class ShenandoahGenerationSizer {\n-private:\n-  enum SizerKind {\n-    SizerDefaults,\n-    SizerNewSizeOnly,\n-    SizerMaxNewSizeOnly,\n-    SizerMaxAndNewSize,\n-    SizerNewRatio\n-  };\n-  SizerKind _sizer_kind;\n-\n-  size_t _min_desired_young_regions;\n-  size_t _max_desired_young_regions;\n-\n-  static size_t calculate_min_young_regions(size_t heap_region_count);\n-  static size_t calculate_max_young_regions(size_t heap_region_count);\n-\n-  \/\/ Update the given values for minimum and maximum young gen length in regions\n-  \/\/ given the number of heap regions depending on the kind of sizing algorithm.\n-  void recalculate_min_max_young_length(size_t heap_region_count);\n-\n-public:\n-  ShenandoahGenerationSizer();\n-\n-  \/\/ Return the configured maximum size in bytes for the given generation.\n-  size_t max_size_for(ShenandoahGeneration* generation) const;\n-\n-  \/\/ Return the configured minimum size in bytes for the given generation.\n-  size_t min_size_for(ShenandoahGeneration* generation) const;\n-\n-  \/\/ Calculate the maximum length of the young gen given the number of regions\n-  \/\/ depending on the sizing algorithm.\n-  void heap_size_changed(size_t heap_size);\n-\n-  \/\/ Minimum size of young generation in bytes as multiple of region size.\n-  size_t min_young_size() const;\n-  size_t min_young_regions() const {\n-    return _min_desired_young_regions;\n-  }\n-\n-  \/\/ Maximum size of young generation in bytes as multiple of region size.\n-  size_t max_young_size() const;\n-  size_t max_young_regions() const {\n-    return _max_desired_young_regions;\n-  }\n-};\n-\n-#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHGENERATIONSIZER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationSizer.hpp","additions":0,"deletions":80,"binary":false,"changes":80,"status":"deleted"},{"patch":"@@ -111,3 +111,4 @@\n-  _generation_sizer.heap_size_changed(max_capacity());\n-  size_t initial_capacity_young = _generation_sizer.max_young_size();\n-  size_t max_capacity_young = _generation_sizer.max_young_size();\n+  size_t region_count = num_regions();\n+  size_t max_young_regions = MAX2((region_count * ShenandoahMaxYoungPercentage) \/ 100, (size_t) 1U);\n+  size_t initial_capacity_young = max_young_regions * ShenandoahHeapRegion::region_size_bytes();\n+  size_t max_capacity_young = initial_capacity_young;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -138,2 +138,0 @@\n-  const ShenandoahGenerationSizer* generation_sizer()  const { return &_generation_sizer;  }\n-\n@@ -163,2 +161,0 @@\n-\n-  ShenandoahGenerationSizer     _generation_sizer;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"gc\/shenandoah\/shenandoahGenerationSizer.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}