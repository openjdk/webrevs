{"files":[{"patch":"@@ -281,0 +281,3 @@\n+  \/\/ Estimated size of the node barrier in number of C2 Ideal nodes.\n+  \/\/ This is used to guide heuristics in C2, e.g. whether to unroll a loop.\n+  virtual uint estimated_barrier_size(const Node* node) const { return 0; }\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -323,0 +323,14 @@\n+uint ZBarrierSetC2::estimated_barrier_size(const Node* node) const {\n+  uint8_t barrier_data = MemNode::barrier_data(node);\n+  assert(barrier_data != 0, \"should be a barrier node\");\n+  uint uncolor_or_color_size = node->is_Load() ? 1 : 2;\n+  if ((barrier_data & ZBarrierElided) != 0) {\n+    return uncolor_or_color_size;\n+  }\n+  \/\/ A compare and branch corresponds to approximately five Ideal nodes (Cmp,\n+  \/\/ Bool, If, IfTrue, IfFalse). The runtime call corresponds to approximately\n+  \/\/ seven more nodes (CallLeaf, control Proj, memory Proj, data Proj, Region,\n+  \/\/ memory Phi, data Phi).\n+  return uncolor_or_color_size + 12;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+  virtual uint estimated_barrier_size(const Node* node) const;\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/c2\/barrierSetC2.hpp\"\n@@ -999,1 +1001,1 @@\n-  \/\/ Also count ModL, DivL and MulL which expand mightly\n+  \/\/ Also count ModL, DivL, MulL, and other nodes that expand mightly\n@@ -1002,0 +1004,3 @@\n+    if (MemNode::barrier_data(n) != 0) {\n+      body_size += BarrierSet::barrier_set()->barrier_set_c2()->estimated_barrier_size(n);\n+    }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -842,0 +842,9 @@\n+uint8_t MemNode::barrier_data(const Node* n) {\n+  if (n->is_LoadStore()) {\n+    return n->as_LoadStore()->barrier_data();\n+  } else if (n->is_Mem()) {\n+    return n->as_Mem()->barrier_data();\n+  }\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -129,0 +129,3 @@\n+  \/\/ Return the barrier data of n, if available, or 0 otherwise.\n+  static uint8_t barrier_data(const Node* n);\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.gcbarriers;\n+\n+import compiler.lib.ir_framework.*;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.MethodHandles;\n+\n+\/**\n+ * @test\n+ * @summary Test that the expanded size of ZGC barriers is taken into account in\n+ *          C2's loop unrolling heuristics so that over-unrolling is avoided.\n+ *          The tests use volatile memory accesses to prevent C2 from simply\n+ *          optimizing them away.\n+ * @library \/test\/lib \/\n+ * @requires vm.gc.ZGenerational\n+ * @run driver compiler.gcbarriers.TestZGCUnrolling\n+ *\/\n+\n+public class TestZGCUnrolling {\n+\n+    static class Outer {\n+        Object f;\n+    }\n+\n+    static final VarHandle fVarHandle;\n+    static {\n+        MethodHandles.Lookup l = MethodHandles.lookup();\n+        try {\n+            fVarHandle = l.findVarHandle(Outer.class, \"f\", Object.class);\n+        } catch (Exception e) {\n+            throw new Error(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:+UseZGC\", \"-XX:+ZGenerational\",\n+                                   \"-XX:LoopUnrollLimit=32\");\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE_P, \"1\"})\n+    public static void testNoUnrolling(Outer o, Object o1) {\n+        for (int i = 0; i < 64; i++) {\n+            fVarHandle.setVolatile(o, o1);\n+        }\n+    }\n+\n+    @Run(test = {\"testNoUnrolling\"})\n+    void run() {\n+        testNoUnrolling(new Outer(), new Object());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCUnrolling.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}