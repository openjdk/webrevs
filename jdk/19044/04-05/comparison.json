{"files":[{"patch":"@@ -1298,1 +1298,6 @@\n-    \/\/ has a higher rank than the monitor we are about to enter.\n+    \/\/ has a higher rank than the monitor we are about to enter. Also, if we are\n+    \/\/ entering a leaf monitor, make sure we don't already hold a leaf monitor.\n+    \/\/ The loop normally starts with the first monitor (0) and stops at rank-1 \n+    \/\/ However, if the monitor we are entering is a leaf monitor,\n+    \/\/ then we must iterate over all the leaf monitors no matter what the rank is.\n+    \/\/ Thus the special \"highestRankCheck\" logic.\n@@ -1300,3 +1305,3 @@\n-    DebugRawMonitorRank firstRank =\n-        (rank < FIRST_LEAF_DEBUG_RAW_MONITOR ? rank : FIRST_LEAF_DEBUG_RAW_MONITOR);\n-    for (i = firstRank; i < NUM_DEBUG_RAW_MONITORS; i++) {\n+    DebugRawMonitorRank highestRankCheck =\n+        (rank > LAST_LEAF_DEBUG_RAW_MONITOR ? rank - 1 : LAST_LEAF_DEBUG_RAW_MONITOR);\n+    for (i = 0; i <= highestRankCheck; i++) {\n@@ -1307,1 +1312,0 @@\n-        JDI_ASSERT(i == dbg_monitor->rank);\n@@ -1316,6 +1320,8 @@\n-         * dbg_monitor is a monitor that the thread currently holds. We need to\n-         * do two verificatons of its rank:\n-         *   1. The held monitor's rank is not higher than the rank of the monitor\n-         *      we are trying to enter.\n-         *   2. The held monitor is not a leaf monitor, because we should not be entering\n-         *      any additional monitors while holding a leaf monitor.\n+         * At this point we already know we have some sort of rank violation because\n+         * we know that we own the monitor we are iterating over, and one or both\n+         * of the following are true:\n+         *  - The monitor has a lower rank than the monitor we are entering.\n+         *  - The monitor is a leaf monitor, and we can't enter any monitor\n+         *    while holding a leaf monitor.\n+         * We just need to figure out which rank violation it is. It's also possible\n+         * for both to be true, so we print two error messages in that case.\n@@ -1323,18 +1329,18 @@\n-        if (dbg_monitor->rank > rank || dbg_monitor->rank >= FIRST_LEAF_DEBUG_RAW_MONITOR ) {\n-          \/\/ At this point we have found a rank order violation.\n-          if (dbg_monitor->rank == popFrameEventLock_Rank && rank == popFrameProceedLock_Rank) {\n-              \/\/ For reasons too complex to explain here, this is one exception that is safe so\n-              \/\/ we allow it. See the long comment for these locks in threadControl.c.\n-              continue;\n-          }\n-          char* threadName = getThreadName(thread);\n-          if (dbg_monitor->rank > rank) {\n-              tty_message(\"DebugRawMonitor rank failure: (%s: %d > %d) for thread (%s)\",\n-                          dbg_monitor->name, dbg_monitor->rank, rank, threadName);\n-          } else {\n-              tty_message(\"DebugRawMonitor rank failure: (%s is a held leaf monitor) for thread (%s)\",\n-                          dbg_monitor->name, threadName);\n-          }\n-          jvmtiDeallocate(threadName);\n-          dumpRawMonitors();\n-          JDI_ASSERT(JNI_FALSE);\n+\n+        if (dbg_monitor->rank == popFrameEventLock_Rank && rank == popFrameProceedLock_Rank) {\n+            \/\/ For reasons too complex to explain here, this is one exception that is safe so\n+            \/\/ we allow it. See the long comment for these locks in threadControl.c.\n+            continue;\n+        }\n+\n+        char* threadName = getThreadName(thread);\n+        jboolean rank_error = JNI_FALSE;\n+        if (dbg_monitor->rank > rank) {\n+            tty_message(\"DebugRawMonitor rank failure: (%s: %d > %d) for thread (%s)\",\n+                        dbg_monitor->name, dbg_monitor->rank, rank, threadName);\n+            rank_error = JNI_TRUE;\n+        } \n+        if (dbg_monitor->rank < LAST_LEAF_DEBUG_RAW_MONITOR ) {\n+            tty_message(\"DebugRawMonitor rank failure: (%s is a held leaf monitor) for thread (%s)\",\n+                        dbg_monitor->name, threadName);\n+            rank_error = JNI_TRUE;\n@@ -1342,0 +1348,4 @@\n+        JDI_ASSERT(rank_error); \/\/ We better have found something wrong with the rank\n+        jvmtiDeallocate(threadName);\n+        dumpRawMonitors();\n+        JDI_ASSERT(JNI_FALSE);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":39,"deletions":29,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -357,2 +357,2 @@\n- * the debug agent uses. Locks must be aquired in rank order (lowest numbered\n- * rank first).\n+ * the debug agent uses. Locks must be aquired in rank order (highest numbered\n+ * rank first). The list is in order from lowest rank to highest rank.\n@@ -361,13 +361,5 @@\n-    \/\/ This lock is held by debugLoop_run() while replying to commands, so it needs\n-    \/\/ to be ranked before the sendLock. Also it needs to come before the handlerLock\n-    \/\/ since handlers are installed while holding this lock. Lastly it needs\n-    \/\/ to be ranked before callbackLock because of the rare case where\n-    \/\/ debugLoop_run() is holding this lock (as it always does) but ends up\n-    \/\/ triggering a JVMTI event, which will cause callbackBlock to be entered.\n-    vmDeathLockForDebugLoop_Rank = 0, \/\/ debug loop lock\n-\n-    \/\/ cbVMDeath() enters callbackBlock before callbackLock. All other event handlers\n-    \/\/ are executed while holding callbackLock, so it needs to rank before all the\n-    \/\/ other locks since they are all used during event handling.\n-    callbackBlock_Rank, \/\/ event handler lock\n-    callbackLock_Rank, \/\/ event handler lock\n+    sendLock_Rank = 0, \/\/ transport lock\n+    cmdQueueLock_Rank, \/\/ debug loop lock\n+    blockCommandLoopLock_Rank, \/\/ event helper lock\n+    initMonitor_Rank, \/\/ debug init lock\n+    LAST_LEAF_DEBUG_RAW_MONITOR = initMonitor_Rank,\n@@ -375,3 +367,2 @@\n-    \/\/ This lock is grabbed in commandLoop(), which eventually leads to\n-    \/\/ threadControl getLocks() grabbing the group of 7 locks a bit further below.\n-    vmDeathLock_Rank, \/\/ event helper lock\n+    \/\/ Only non-leaf locks below this point. No other locks should be entered\n+    \/\/ while any of the above leaf locks are held.\n@@ -379,4 +370,2 @@\n-    \/\/ popFrameProceedLock must be ranked before popFrameEventLock, which must\n-    \/\/ be ranked before threadLock. popFrameEventLock must be ranked after vmDeathLock.\n-    popFrameProceedLock_Rank, \/\/ thread control lock\n-    popFrameEventLock_Rank, \/\/ thread control lock\n+    \/\/ Must rank higher than initMonitor\n+    listenerLock_Rank, \/\/ transport lock\n@@ -384,1 +373,1 @@\n-    \/\/ This part of this list is determined by the order that locks are acquired in\n+    \/\/ This part of the list is determined by the order that locks are acquired in\n@@ -386,6 +375,0 @@\n-    handlerLock_Rank, \/\/ event handler lock\n-    stepLock_Rank,\n-    invokerLock_Rank,\n-    commandQueueLock_Rank, \/\/ event helper lock\n-    commandCompleteLock_Rank, \/\/ event helper lock\n-    threadLock_Rank, \/\/ thread control lock\n@@ -393,0 +376,6 @@\n+    threadLock_Rank, \/\/ thread control lock\n+    commandCompleteLock_Rank, \/\/ event helper lock\n+    commandQueueLock_Rank, \/\/ event helper lock\n+    invokerLock_Rank,\n+    stepLock_Rank,\n+    handlerLock_Rank, \/\/ event handler lock\n@@ -394,2 +383,5 @@\n-    \/\/ Must come before initMonitor\n-    listenerLock_Rank,  \/\/ transport lock\n+    \/\/ popFrameEventLock and popFrameProceedLock have special handling in\n+    \/\/ verifyMonitorRank(). See comment there. They must be ranked higher than\n+    \/\/ threadLock. popFrameEventLock must be ranked lower than vmDeathLock.\n+    popFrameEventLock_Rank, \/\/ thread control lock\n+    popFrameProceedLock_Rank, \/\/ thread control lock\n@@ -397,7 +389,18 @@\n-    \/\/ Only leaf locks below this point. No other locks should be entered\n-    \/\/ while any of these locks are held\n-    FIRST_LEAF_DEBUG_RAW_MONITOR,\n-    sendLock_Rank = FIRST_LEAF_DEBUG_RAW_MONITOR, \/\/ transport lock\n-    cmdQueueLock_Rank, \/\/ debug loop lock\n-    blockCommandLoopLock_Rank, \/\/ event helper lock\n-    initMonitor_Rank, \/\/ debug init lock\n+    \/\/ This lock is grabbed in commandLoop(), which eventually leads to\n+    \/\/ threadControl getLocks() grabbing the group of 7 locks\n+    \/\/ above, so it must be ranked higher than handlerLock.\n+    vmDeathLock_Rank, \/\/ event helper lock\n+\n+    \/\/ cbVMDeath() enters callbackBlock before callbackLock. All other event handlers\n+    \/\/ are executed while holding callbackLock, so it needs to rank higher than all\n+    \/\/ the other locks since they are all used during event handling.\n+    callbackLock_Rank, \/\/ event handler lock\n+    callbackBlock_Rank, \/\/ event handler lock\n+\n+    \/\/ This lock is held by debugLoop_run() while replying to commands, so it needs\n+    \/\/ to be ranked higher than sendLock. Also it needs to rank higher than handlerLock\n+    \/\/ since handlers are installed while holding this lock. Lastly it needs\n+    \/\/ to be ranked higher than callbackBlock because of the rare case where\n+    \/\/ debugLoop_run() is holding this lock (as it always does) but ends up\n+    \/\/ triggering a JVMTI event, which will cause callbackBlock to be entered.\n+    vmDeathLockForDebugLoop_Rank, \/\/ debug loop lock\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":41,"deletions":38,"binary":false,"changes":79,"status":"modified"}]}