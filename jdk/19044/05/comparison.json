{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -407,1 +407,1 @@\n-    gdata->refLock = debugMonitorCreate(\"JDWP Reference Table Monitor\");\n+    gdata->refLock = debugMonitorCreate(refLock_Rank, \"JDWP Reference Table Monitor\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/commonRef.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-static jrawMonitorID initMonitor;\n+static DebugRawMonitor* initMonitor;\n@@ -670,1 +670,0 @@\n-    commonRef_initialize();\n@@ -672,0 +671,1 @@\n+    commonRef_initialize();\n@@ -679,1 +679,1 @@\n-    initMonitor = debugMonitorCreate(\"JDWP Initialization Monitor\");\n+    initMonitor = debugMonitorCreate(initMonitor_Rank, \"JDWP Initialization Monitor\");\n@@ -998,0 +998,2 @@\n+    gdata->rankedMonitors = JNI_TRUE;\n+\n@@ -1100,0 +1102,11 @@\n+        } else if (strcmp(buf, \"rankedMonitors\") == 0) {\n+            if (!get_tok(&str, current, (int)(end - current), ',')) {\n+                goto syntax_error;\n+            }\n+            if (strcmp(current, \"y\") == 0) {\n+                gdata->rankedMonitors = JNI_TRUE;\n+            } else if (strcmp(current, \"n\") == 0) {\n+                gdata->rankedMonitors = JNI_FALSE;\n+            } else {\n+                goto syntax_error;\n+            }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-static jrawMonitorID cmdQueueLock;\n-static jrawMonitorID vmDeathLock;\n+static DebugRawMonitor* cmdQueueLock;\n+static DebugRawMonitor* vmDeathLock;\n@@ -66,1 +66,1 @@\n-    vmDeathLock = debugMonitorCreate(\"JDWP VM_DEATH Lock\");\n+    vmDeathLock = debugMonitorCreate(vmDeathLockForDebugLoop_Rank, \"JDWP VM_DEATH Lock\");\n@@ -90,1 +90,1 @@\n-    cmdQueueLock = debugMonitorCreate(\"JDWP Command Queue Lock\");\n+    cmdQueueLock = debugMonitorCreate(cmdQueueLock_Rank, \"JDWP Command Queue Lock\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugLoop.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,2 +78,2 @@\n-static jrawMonitorID callbackLock;\n-static jrawMonitorID callbackBlock;\n+static DebugRawMonitor* callbackLock;\n+static DebugRawMonitor* callbackBlock;\n@@ -156,1 +156,1 @@\n-static jrawMonitorID handlerLock;\n+static DebugRawMonitor* handlerLock;\n@@ -1479,4 +1479,3 @@\n-    callbackLock = debugMonitorCreate(\"JDWP Callback Lock\");\n-    callbackBlock = debugMonitorCreate(\"JDWP Callback Block\");\n-\n-    handlerLock = debugMonitorCreate(\"JDWP Event Handler Lock\");\n+    callbackLock = debugMonitorCreate(callbackLock_Rank, \"JDWP Callback Lock\");\n+    callbackBlock = debugMonitorCreate(callbackBlock_Rank, \"JDWP Callback Block\");\n+    handlerLock = debugMonitorCreate(handlerLock_Rank, \"JDWP Event Handler Lock\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,4 +125,4 @@\n-static jrawMonitorID commandQueueLock;\n-static jrawMonitorID commandCompleteLock;\n-static jrawMonitorID blockCommandLoopLock;\n-static jrawMonitorID vmDeathLock;\n+static DebugRawMonitor* commandQueueLock;\n+static DebugRawMonitor* commandCompleteLock;\n+static DebugRawMonitor* blockCommandLoopLock;\n+static DebugRawMonitor* vmDeathLock;\n@@ -747,4 +747,4 @@\n-    commandQueueLock = debugMonitorCreate(\"JDWP Event Helper Queue Monitor\");\n-    commandCompleteLock = debugMonitorCreate(\"JDWP Event Helper Completion Monitor\");\n-    blockCommandLoopLock = debugMonitorCreate(\"JDWP Event Block CommandLoop Monitor\");\n-    vmDeathLock = debugMonitorCreate(\"JDWP VM_DEATH CommandLoop Monitor\");\n+    commandQueueLock     = debugMonitorCreate(commandQueueLock_Rank, \"JDWP Event Helper Queue Monitor\");\n+    commandCompleteLock  = debugMonitorCreate(commandCompleteLock_Rank, \"JDWP Event Helper Completion Monitor\");\n+    blockCommandLoopLock = debugMonitorCreate(blockCommandLoopLock_Rank, \"JDWP Event Block CommandLoop Monitor\");\n+    vmDeathLock          = debugMonitorCreate(vmDeathLock_Rank, \"JDWP VM_DEATH CommandLoop Monitor\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHelper.c","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-static jrawMonitorID invokerLock;\n+static DebugRawMonitor* invokerLock;\n@@ -38,1 +38,1 @@\n-    invokerLock = debugMonitorCreate(\"JDWP Invocation Lock\");\n+    invokerLock = debugMonitorCreate(invokerLock_Rank, \"JDWP Invocation Lock\");\n@@ -723,0 +723,1 @@\n+    stepControl_lock();  \/* for proper lock order in threadControl getLocks() *\/\n@@ -793,0 +794,1 @@\n+    stepControl_unlock();\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/invoker.c","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-static jrawMonitorID stepLock;\n+static DebugRawMonitor* stepLock;\n@@ -697,1 +697,1 @@\n-    stepLock = debugMonitorCreate(\"JDWP Step Handler Lock\");\n+    stepLock = debugMonitorCreate(stepLock_Rank, \"JDWP Step Handler Lock\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/stepControl.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-static jrawMonitorID popFrameEventLock = NULL;\n+static DebugRawMonitor* popFrameEventLock = NULL;\n@@ -106,1 +106,1 @@\n-static jrawMonitorID popFrameProceedLock = NULL;\n+static DebugRawMonitor* popFrameProceedLock = NULL;\n@@ -108,1 +108,1 @@\n-static jrawMonitorID threadLock;\n+static DebugRawMonitor* threadLock;\n@@ -645,0 +645,3 @@\n+     *\n+     * stepControl_beginStep() grabs the eventHandler lock and stepControl lock\n+     * before eventually ending up here, so we need to maintain that order here.\n@@ -646,1 +649,0 @@\n-\n@@ -648,0 +650,1 @@\n+    stepControl_lock();\n@@ -650,2 +653,0 @@\n-    stepControl_lock();\n-    commonRef_lock();\n@@ -653,1 +654,4 @@\n-\n+    commonRef_lock();\n+    if (gdata->rankedMonitors) {\n+        dbgRawMonitor_lock();\n+    }\n@@ -659,1 +663,3 @@\n-    debugMonitorExit(threadLock);\n+    if (gdata->rankedMonitors) {\n+        dbgRawMonitor_unlock();\n+    }\n@@ -661,1 +667,1 @@\n-    stepControl_unlock();\n+    debugMonitorExit(threadLock);\n@@ -664,0 +670,1 @@\n+    stepControl_unlock();\n@@ -675,1 +682,1 @@\n-    threadLock = debugMonitorCreate(\"JDWP Thread Lock\");\n+    threadLock = debugMonitorCreate(threadLock_Rank, \"JDWP Thread Lock\");\n@@ -1723,0 +1730,58 @@\n+\/*** Start of support for StackFrame.PopFrames ***\/\n+\n+\/*\n+ * Synchronization with popFrameEventLock and popFrameProceedLock\n+ *\n+ * StackFrame.PopFrames support has some complicated synchronization because\n+ * JVMTI PopFrame() is called on the JDWP Command Reader thread (that's where\n+ * the StackFrame.PopFrames command arrived on), but it needs to co-ordinate\n+ * with the PopFrames target thread. The Command Reader thread has to call JVMTI\n+ * PopFrame() on the target thread one frame at a time, resume the target thread,\n+ * and then know when the target thread is done with the PopFrame() so it can be\n+ * suspended so the next PopFrame() can then be done. Part of what makes this\n+ * complex is that the target thread needs to have SINGLE_STEP enabled so we\n+ * can tell when the PopFrame() has completed. (For reasons I don't understand,\n+ * we don't rely on FRAME_POP events).\n+ *\n+ * Synchronization is done via the popFrameProceedLock and popFrameEventLock. Both\n+ * the JDWP Command Reader thread and the PopFrame() target thread will grab\n+ * both of these locks. However, one curious trait of these two locks is that\n+ * the these two threads do not both grab them in the same order (and they need\n+ * to do it this way). This seems like it should lead to a deadlock, but doesn't\n+ * because of how each thread grabs these locks and waits or notifies on them.\n+ *\n+ * Command Reader Thread:\n+ *  grab popFrameEventLock (which is always available)\n+ *  for each frame\n+ *    call PopFrame() on target thread\n+ *    resume target thread\n+ *    wait on popFrameEventLock (which releases it)\n+ *    grab popFrameProceedLock\n+ *    suspend target thread\n+ *    notify on popFrameProceedLock\n+ *    release popFrameProceedLock\n+ *  }\n+ *  release popFrameEventLock\n+ *\n+ * Target Thread:\n+ *   for each frame pop (indicated by a SingleStep event)\n+ *     grab popFrameProceedLock (which is always available)\n+ *     grab popFrameEventLock (which Command Reader Thread is waiting on)\n+ *     notify on popFrameEventLock\n+ *     release popFrameEventLock\n+ *     wait on popFrameProceedLock\n+ *     release popFrameProceedLock\n+ *   }\n+ *\n+ * The reason we don't get a deadlock is because the Reader thread always\n+ * starts the process, so it always enters popFrameEventLock and then\n+ * waits on it (which releases the lock). Therefore there is never a race for\n+ * popFrameEventLock. Meanwhile when the target thread gets the SINGLE_STEP event,\n+ * it always enters popFrameProceedLock first (which is always available), then\n+ * popFrameProceedLock second. It will always succeed because the Reader thread\n+ * only entered popFrameEventLock, but is waiting on it, so doesn't currently hold\n+ * either lock. The target thread then notifies on popFrameEventLock and releases\n+ * it (unblocking the Reader thread), and then waits on popFrameProceedLock. The\n+ * Reader thread resumes and can enter popFrameProceedLock and notify on it.\n+*\/\n+\n@@ -1724,1 +1789,1 @@\n-initLocks(void)\n+initPopFrameLocks(void)\n@@ -1727,2 +1792,2 @@\n-        popFrameEventLock = debugMonitorCreate(\"JDWP PopFrame Event Lock\");\n-        popFrameProceedLock = debugMonitorCreate(\"JDWP PopFrame Proceed Lock\");\n+        popFrameEventLock = debugMonitorCreate(popFrameEventLock_Rank, \"JDWP PopFrame Event Lock\");\n+        popFrameProceedLock = debugMonitorCreate(popFrameProceedLock_Rank, \"JDWP PopFrame Proceed Lock\");\n@@ -1933,1 +1998,1 @@\n-    initLocks();\n+    initPopFrameLocks();\n@@ -2030,0 +2095,2 @@\n+\/*** End of support for StackFrame.PopFrames ***\/\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":81,"deletions":14,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-static jrawMonitorID listenerLock;\n-static jrawMonitorID sendLock;\n+static DebugRawMonitor* listenerLock;\n+static DebugRawMonitor* sendLock;\n@@ -400,2 +400,2 @@\n-    listenerLock = debugMonitorCreate(\"JDWP Transport Listener Monitor\");\n-    sendLock = debugMonitorCreate(\"JDWP Transport Send Monitor\");\n+    listenerLock = debugMonitorCreate(listenerLock_Rank, \"JDWP Transport Listener Monitor\");\n+    sendLock = debugMonitorCreate(sendLock_Rank, \"JDWP Transport Send Monitor\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/transport.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+static void createDbgRawMonitor();\n@@ -182,0 +183,4 @@\n+    if (gdata->rankedMonitors) {\n+        createDbgRawMonitor();\n+    }\n+\n@@ -994,0 +999,2 @@\n+    JNIEnv *env = getEnv();\n+    JNI_FUNC_PTR(env,DeleteLocalRef)(env, thread);\n@@ -1006,2 +1013,2 @@\n-void\n-debugMonitorEnter(jrawMonitorID monitor)\n+static void\n+debugMonitorEnter_norank(jrawMonitorID monitor)\n@@ -1018,2 +1025,2 @@\n-void\n-debugMonitorExit(jrawMonitorID monitor)\n+static void\n+debugMonitorExit_norank(jrawMonitorID monitor)\n@@ -1031,2 +1038,2 @@\n-void\n-debugMonitorWait(jrawMonitorID monitor)\n+static void\n+debugMonitorWait_norank(jrawMonitorID monitor)\n@@ -1076,2 +1083,2 @@\n-void\n-debugMonitorNotify(jrawMonitorID monitor)\n+static void\n+debugMonitorNotify_norank(jrawMonitorID monitor)\n@@ -1089,2 +1096,2 @@\n-void\n-debugMonitorNotifyAll(jrawMonitorID monitor)\n+static void\n+debugMonitorNotifyAll_norank(jrawMonitorID monitor)\n@@ -1102,2 +1109,79 @@\n-jrawMonitorID\n-debugMonitorCreate(char *name)\n+\/*\n+ * A DebugRawMonitor is an encapsulation of a jrawMonitorID. It is used to\n+ * store other information about the jrawMonitorID that is needed for ranked\n+ * monitors support, such as the thread that currently owns the monitor.\n+ *\/\n+struct DebugRawMonitor {\n+    jrawMonitorID monitor;\n+    const char* name;\n+    DebugRawMonitorRank rank;\n+    volatile jthread ownerThread; \/\/ Access protected by dbgRawMonitor\n+    int entryCount; \/\/ Only ownerThread should ever access this field\n+};\n+\n+static DebugRawMonitor dbg_monitors[NUM_DEBUG_RAW_MONITORS];\n+\n+\n+\/*\n+ * The dbgRawMonitor controls access to the DebugRawMonitor->ownerThread field.\n+ * It must be held whenever modifying ownerThread and also must be held whenever\n+ * accessing ownerThread unless we know the current thread already owns the monitor.\n+ * Only the owner of the DebugRawMonitor will ever modify ownerThread. The main thing\n+ * we are trying to protect from is a thread checking to see if it is the owner of\n+ * the DebugRawMonitor, and having the ownerThread field change while doing this.\n+ * The check is made using:\n+ *    isSameObject(env, dbg_monitor->ownerThread, current_thread)\n+ * We don't want ownerThread changing in the middle of this check since it can lead\n+ * to a crash if the JNI handle gets freed. So this check is always protected by\n+ * dbgRawMonitor as are modifications to ownerThread.\n+ *\n+ * There is also one other minor role that dbgRawMonitor plays. In verifyMonitorRank()\n+ * we iterate over all monitors, and need to make sure the monitor we are checking has\n+ * been initialized. If it hasn't been, then it is skipped. There can be a race and\n+ * we catch it in the middle of intialization. Since dbgRawMonitor is held during\n+ * verifyMonitorRank(), we should also hold it during monitor initialization.\n+ *\/\n+\n+static jrawMonitorID dbgRawMonitor;\n+\n+static void\n+createDbgRawMonitor()\n+{\n+    JDI_ASSERT(gdata->rankedMonitors);\n+    jvmtiError error;\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,CreateRawMonitor)\n+            (gdata->jvmti, \"Debug Raw Monitor\", &dbgRawMonitor);\n+    if (error != JVMTI_ERROR_NONE) {\n+        EXIT_ERROR(error, \"on creation of dbgRawMonitor\");\n+    }\n+    JDI_ASSERT(dbgRawMonitor != NULL);\n+}\n+\n+void\n+dbgRawMonitor_lock()\n+{\n+    JDI_ASSERT(gdata->rankedMonitors);\n+    jvmtiError error;\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorEnter)\n+            (gdata->jvmti, dbgRawMonitor);\n+    error = ignore_vm_death(error);\n+    if (error != JVMTI_ERROR_NONE) {\n+      EXIT_ERROR(error, \"on dbgRawMonitor enter\");\n+    }\n+}\n+\n+void\n+dbgRawMonitor_unlock()\n+{\n+    JDI_ASSERT(gdata->rankedMonitors);\n+    jvmtiError error;\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorExit)\n+            (gdata->jvmti, dbgRawMonitor);\n+    error = ignore_vm_death(error);\n+    if (error != JVMTI_ERROR_NONE) {\n+      EXIT_ERROR(error, \"on dbgRawMonitor exit\");\n+    }\n+}\n+\n+DebugRawMonitor*\n+debugMonitorCreate(DebugRawMonitorRank dbg_monitor_rank, char *name)\n@@ -1107,0 +1191,2 @@\n+    DebugRawMonitor* dbg_monitor = &dbg_monitors[dbg_monitor_rank];\n+    JDI_ASSERT(dbg_monitor->monitor == NULL);\n@@ -1113,1 +1199,16 @@\n-    return monitor;\n+\n+    JDI_ASSERT(monitor != NULL);\n+\n+    \/\/ Need to lock during initialization so verifyMonitorRank() can be guaranteed that\n+    \/\/ if the monitor field is not NULL, then the monitor is fully initialized.\n+    if (gdata->rankedMonitors) {\n+        dbgRawMonitor_lock();\n+    }\n+    dbg_monitor->monitor = monitor;\n+    dbg_monitor->rank = dbg_monitor_rank;\n+    dbg_monitor->name = name;\n+    if (gdata->rankedMonitors) {\n+        dbgRawMonitor_unlock();\n+    }\n+\n+    return dbg_monitor;\n@@ -1117,1 +1218,1 @@\n-debugMonitorDestroy(jrawMonitorID monitor)\n+debugMonitorDestroy(DebugRawMonitor *dbg_monitor)\n@@ -1120,0 +1221,1 @@\n+    JDI_ASSERT(dbg_monitor != NULL);\n@@ -1122,1 +1224,1 @@\n-                (gdata->jvmti, monitor);\n+                (gdata->jvmti, dbg_monitor->monitor);\n@@ -1127,0 +1229,299 @@\n+\n+    dbg_monitor->monitor = NULL;\n+}\n+\n+static char*\n+getThreadName(jthread thread)\n+{\n+    jvmtiThreadInfo info;\n+    jvmtiError error;\n+    JNIEnv *env = getEnv();\n+\n+    memset(&info, 0, sizeof(info));\n+    WITH_LOCAL_REFS(env, 2) {\n+        error = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadInfo)\n+                (gdata->jvmti, thread, &info);\n+    } END_WITH_LOCAL_REFS(env);\n+    return info.name;\n+}\n+\n+void\n+dumpRawMonitor(DebugRawMonitor *dbg_monitor) {\n+    tty_message(\"DebugRawMonitor(%d)\", dbg_monitor->rank);\n+    tty_message(\"\\tname: %s\", dbg_monitor->name);\n+    if (dbg_monitor->ownerThread != NULL) {\n+        char* threadName = getThreadName(dbg_monitor->ownerThread);\n+        tty_message(\"\\townerThreadName: %s\", threadName);\n+        jvmtiDeallocate(threadName);\n+    }\n+}\n+\n+void\n+dumpRawMonitors() {\n+    int i;\n+    for (i = 0; i < NUM_DEBUG_RAW_MONITORS; i++) {\n+        DebugRawMonitor* dbg_monitor = &dbg_monitors[i];\n+        if (dbg_monitor->monitor == NULL) {\n+            continue;\n+        }\n+        jthread thread = dbg_monitor->ownerThread;\n+        if (thread == NULL) {\n+            continue;\n+        }\n+        dumpRawMonitor(dbg_monitor);\n+    }\n+}\n+\n+static void\n+assertIsCurrentThread(JNIEnv *env, jthread thread, jthread current_thread)\n+{\n+    if (!gdata->assertOn) {\n+        return;\n+    }\n+    if (gdata->vmDead) {\n+        return; \/\/ This assert is not reliable if the VM is exiting\n+    }\n+    if (!isSameObject(env, thread, current_thread)) {\n+        tty_message(\"ERROR: Threads are not the same: \\\"%s\\\" \\\"%s\\\"\",\n+                    getThreadName(thread), getThreadName(current_thread));\n+        dumpRawMonitors();\n+        JDI_ASSERT(JNI_FALSE);\n+    }\n+}\n+\n+static void\n+verifyMonitorRank(JNIEnv *env, DebugRawMonitorRank rank, jthread thread)\n+{\n+    \/\/ We must hold the dbgRawMonitor when calling verifyMonitorRank()\n+\n+    \/\/ Iterate over all the monitors and make sure we don't already hold one that\n+    \/\/ has a higher rank than the monitor we are about to enter. Also, if we are\n+    \/\/ entering a leaf monitor, make sure we don't already hold a leaf monitor.\n+    \/\/ The loop normally starts with the first monitor (0) and stops at rank-1 \n+    \/\/ However, if the monitor we are entering is a leaf monitor,\n+    \/\/ then we must iterate over all the leaf monitors no matter what the rank is.\n+    \/\/ Thus the special \"highestRankCheck\" logic.\n+    DebugRawMonitorRank i;\n+    DebugRawMonitorRank highestRankCheck =\n+        (rank > LAST_LEAF_DEBUG_RAW_MONITOR ? rank - 1 : LAST_LEAF_DEBUG_RAW_MONITOR);\n+    for (i = 0; i <= highestRankCheck; i++) {\n+        DebugRawMonitor* dbg_monitor = &dbg_monitors[i];\n+        if (dbg_monitor->monitor == NULL) {\n+            continue; \/\/ ignore uninitialzed monitors\n+        }\n+        if (dbg_monitor->ownerThread == NULL) {\n+            continue; \/\/ ignore unowned monitors\n+        }\n+        if (!isSameObject(env, dbg_monitor->ownerThread, thread)) {\n+            continue; \/\/ ignore monitors not owned by this thread\n+        }\n+\n+        \/*\n+         * At this point we already know we have some sort of rank violation because\n+         * we know that we own the monitor we are iterating over, and one or both\n+         * of the following are true:\n+         *  - The monitor has a lower rank than the monitor we are entering.\n+         *  - The monitor is a leaf monitor, and we can't enter any monitor\n+         *    while holding a leaf monitor.\n+         * We just need to figure out which rank violation it is. It's also possible\n+         * for both to be true, so we print two error messages in that case.\n+         *\/\n+\n+        if (dbg_monitor->rank == popFrameEventLock_Rank && rank == popFrameProceedLock_Rank) {\n+            \/\/ For reasons too complex to explain here, this is one exception that is safe so\n+            \/\/ we allow it. See the long comment for these locks in threadControl.c.\n+            continue;\n+        }\n+\n+        char* threadName = getThreadName(thread);\n+        jboolean rank_error = JNI_FALSE;\n+        if (dbg_monitor->rank > rank) {\n+            tty_message(\"DebugRawMonitor rank failure: (%s: %d > %d) for thread (%s)\",\n+                        dbg_monitor->name, dbg_monitor->rank, rank, threadName);\n+            rank_error = JNI_TRUE;\n+        } \n+        if (dbg_monitor->rank < LAST_LEAF_DEBUG_RAW_MONITOR ) {\n+            tty_message(\"DebugRawMonitor rank failure: (%s is a held leaf monitor) for thread (%s)\",\n+                        dbg_monitor->name, threadName);\n+            rank_error = JNI_TRUE;\n+        }\n+        JDI_ASSERT(rank_error); \/\/ We better have found something wrong with the rank\n+        jvmtiDeallocate(threadName);\n+        dumpRawMonitors();\n+        JDI_ASSERT(JNI_FALSE);\n+    }\n+}\n+\n+void\n+debugMonitorEnter(DebugRawMonitor *dbg_monitor)\n+{\n+    jrawMonitorID monitor = dbg_monitor->monitor;\n+\n+    if (!gdata->rankedMonitors) {\n+        debugMonitorEnter_norank(monitor);\n+        return;\n+    }\n+\n+    JNIEnv *env = getEnv();\n+    jthread current_thread = threadControl_currentThread();\n+\n+    if (gdata->vmDead && current_thread == NULL) {\n+        return;\n+    }\n+    JDI_ASSERT(current_thread != NULL);\n+\n+    dbgRawMonitor_lock();\n+    if (isSameObject(env, dbg_monitor->ownerThread, current_thread)) {\n+        \/\/ We have already entered this monitor, so nothing to do except bump entryCount below.\n+        dbgRawMonitor_unlock();\n+    } else {\n+        \/\/ We must hold the dbgRawMonitor when calling verifyMonitorRank()\n+        verifyMonitorRank(env, dbg_monitor->rank, current_thread);\n+        dbgRawMonitor_unlock();\n+\n+        debugMonitorEnter_norank(monitor);\n+\n+        \/\/ Once we have entered the monitor, claim ownership of the DebugRawMonitor\n+        \/\/ by saving the thread into it.\n+        dbgRawMonitor_lock();\n+        JDI_ASSERT(dbg_monitor->ownerThread == NULL);\n+        JDI_ASSERT(dbg_monitor->entryCount == 0);\n+        saveGlobalRef(env, current_thread, (jobject*)&(dbg_monitor->ownerThread));\n+        dbgRawMonitor_unlock();\n+    }\n+\n+    dbg_monitor->entryCount++;\n+    JNI_FUNC_PTR(env,DeleteLocalRef)(env, current_thread);\n+}\n+\n+void\n+debugMonitorExit(DebugRawMonitor *dbg_monitor)\n+{\n+    jrawMonitorID monitor = dbg_monitor->monitor;\n+\n+    if (!gdata->rankedMonitors) {\n+        debugMonitorExit_norank(monitor);\n+        return;\n+    }\n+\n+    jthread current_thread = threadControl_currentThread();\n+\n+    if (gdata->vmDead && current_thread == NULL) {\n+        return;\n+    }\n+\n+    JDI_ASSERT(dbg_monitor->entryCount > 0);\n+\n+    \/\/ Assert that the current thread owns this monitor.\n+    JNIEnv *env = getEnv();\n+    assertIsCurrentThread(env, dbg_monitor->ownerThread, current_thread);\n+    JNI_FUNC_PTR(env,DeleteLocalRef)(env, current_thread);\n+\n+    dbg_monitor->entryCount--;\n+    if (dbg_monitor->entryCount == 0) {\n+        \/\/ Release ownership of the DebugRawMonitor before RawMonitorExit actually exits it.\n+        dbgRawMonitor_lock();\n+        tossGlobalRef(env, (jobject*)&(dbg_monitor->ownerThread));\n+        dbgRawMonitor_unlock();\n+\n+        debugMonitorExit_norank(monitor);\n+    }\n+}\n+\n+void\n+debugMonitorWait(DebugRawMonitor *dbg_monitor)\n+{\n+    jrawMonitorID monitor = dbg_monitor->monitor;\n+\n+    if (!gdata->rankedMonitors) {\n+        debugMonitorWait_norank(monitor);\n+        return;\n+    }\n+\n+    JNIEnv *env = getEnv();\n+    jthread savedOwnerThread = dbg_monitor->ownerThread;\n+    int savedEntryCount = dbg_monitor->entryCount;\n+    jthread current_thread = threadControl_currentThread();\n+\n+    if (gdata->vmDead && current_thread == NULL) {\n+        return;\n+    }\n+\n+    JDI_ASSERT(savedOwnerThread != NULL);\n+\n+    \/\/ Assert that the current thread owns this monitor.\n+    assertIsCurrentThread(env, savedOwnerThread, current_thread);\n+\n+    {\n+      dbgRawMonitor_lock();\n+\n+      \/\/ Release ownership of the DebugRawMonitor before RawMonitorWait actually exits it.\n+      dbg_monitor->ownerThread = NULL;\n+      dbg_monitor->entryCount = 0;\n+\n+      \/\/ Doing a wait ends up doing an exit and then an enter after the wait completes.\n+      \/\/ We must do the same rank verificaton as is done during a monitor enter.\n+      \/\/ We must hold the dbgRawMonitor when calling verifyMonitorRank()\n+      verifyMonitorRank(env, dbg_monitor->rank, current_thread);\n+\n+      dbgRawMonitor_unlock();\n+    }\n+\n+    debugMonitorWait_norank(monitor);\n+\n+    \/\/ Now that we have re-entered the monitor, reclaim ownership of the DebugRawMonitor\n+    \/\/ by saving the thread into it and restoring the entry count.\n+    dbgRawMonitor_lock();\n+    dbg_monitor->ownerThread = savedOwnerThread;\n+    dbg_monitor->entryCount = savedEntryCount;\n+    dbgRawMonitor_unlock();\n+\n+    JNI_FUNC_PTR(env,DeleteLocalRef)(env, current_thread);\n+}\n+\n+void\n+debugMonitorNotify(DebugRawMonitor *dbg_monitor)\n+{\n+    jrawMonitorID monitor = dbg_monitor->monitor;\n+\n+    if (!gdata->rankedMonitors) {\n+        debugMonitorNotify_norank(monitor);\n+        return;\n+    }\n+\n+    jthread current_thread = threadControl_currentThread();\n+\n+    if (gdata->vmDead && current_thread == NULL) {\n+        return;\n+    }\n+\n+    \/\/ Assert that the current thread owns this monitor.\n+    JNIEnv *env = getEnv();\n+    assertIsCurrentThread(env, dbg_monitor->ownerThread, current_thread);\n+    JNI_FUNC_PTR(env,DeleteLocalRef)(env, current_thread);\n+\n+    debugMonitorNotify_norank(monitor);\n+}\n+\n+void\n+debugMonitorNotifyAll(DebugRawMonitor *dbg_monitor)\n+{\n+    jrawMonitorID monitor = dbg_monitor->monitor;\n+\n+    if (!gdata->rankedMonitors) {\n+        debugMonitorNotifyAll_norank(monitor);\n+        return;\n+    }\n+\n+    jthread current_thread = threadControl_currentThread();\n+\n+    if (gdata->vmDead && current_thread == NULL) {\n+        return;\n+    }\n+\n+    \/\/ Assert that the current thread owns this monitor.\n+    JNIEnv *env = getEnv();\n+    assertIsCurrentThread(env, dbg_monitor->ownerThread, current_thread);\n+    JNI_FUNC_PTR(env,DeleteLocalRef)(env, current_thread);\n+\n+    debugMonitorNotifyAll_norank(monitor);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":416,"deletions":15,"binary":false,"changes":431,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+typedef struct DebugRawMonitor DebugRawMonitor;\n@@ -93,0 +94,1 @@\n+    jboolean rankedMonitors;\n@@ -132,1 +134,1 @@\n-    jrawMonitorID refLock;\n+    DebugRawMonitor* refLock;\n@@ -353,7 +355,67 @@\n-jrawMonitorID debugMonitorCreate(char *name);\n-void debugMonitorEnter(jrawMonitorID theLock);\n-void debugMonitorExit(jrawMonitorID theLock);\n-void debugMonitorWait(jrawMonitorID theLock);\n-void debugMonitorNotify(jrawMonitorID theLock);\n-void debugMonitorNotifyAll(jrawMonitorID theLock);\n-void debugMonitorDestroy(jrawMonitorID theLock);\n+\/*\n+ * The following enum represents the rank of each lock (JVMTI RawMonitor) that\n+ * the debug agent uses. Locks must be aquired in rank order (highest numbered\n+ * rank first). The list is in order from lowest rank to highest rank.\n+ *\/\n+typedef enum {\n+    sendLock_Rank = 0, \/\/ transport lock\n+    cmdQueueLock_Rank, \/\/ debug loop lock\n+    blockCommandLoopLock_Rank, \/\/ event helper lock\n+    initMonitor_Rank, \/\/ debug init lock\n+    LAST_LEAF_DEBUG_RAW_MONITOR = initMonitor_Rank,\n+\n+    \/\/ Only non-leaf locks below this point. No other locks should be entered\n+    \/\/ while any of the above leaf locks are held.\n+\n+    \/\/ Must rank higher than initMonitor\n+    listenerLock_Rank, \/\/ transport lock\n+\n+    \/\/ This part of the list is determined by the order that locks are acquired in\n+    \/\/ the threadControl getLocks() function.\n+    refLock_Rank, \/\/ common ref lock\n+    threadLock_Rank, \/\/ thread control lock\n+    commandCompleteLock_Rank, \/\/ event helper lock\n+    commandQueueLock_Rank, \/\/ event helper lock\n+    invokerLock_Rank,\n+    stepLock_Rank,\n+    handlerLock_Rank, \/\/ event handler lock\n+\n+    \/\/ popFrameEventLock and popFrameProceedLock have special handling in\n+    \/\/ verifyMonitorRank(). See comment there. They must be ranked higher than\n+    \/\/ threadLock. popFrameEventLock must be ranked lower than vmDeathLock.\n+    popFrameEventLock_Rank, \/\/ thread control lock\n+    popFrameProceedLock_Rank, \/\/ thread control lock\n+\n+    \/\/ This lock is grabbed in commandLoop(), which eventually leads to\n+    \/\/ threadControl getLocks() grabbing the group of 7 locks\n+    \/\/ above, so it must be ranked higher than handlerLock.\n+    vmDeathLock_Rank, \/\/ event helper lock\n+\n+    \/\/ cbVMDeath() enters callbackBlock before callbackLock. All other event handlers\n+    \/\/ are executed while holding callbackLock, so it needs to rank higher than all\n+    \/\/ the other locks since they are all used during event handling.\n+    callbackLock_Rank, \/\/ event handler lock\n+    callbackBlock_Rank, \/\/ event handler lock\n+\n+    \/\/ This lock is held by debugLoop_run() while replying to commands, so it needs\n+    \/\/ to be ranked higher than sendLock. Also it needs to rank higher than handlerLock\n+    \/\/ since handlers are installed while holding this lock. Lastly it needs\n+    \/\/ to be ranked higher than callbackBlock because of the rare case where\n+    \/\/ debugLoop_run() is holding this lock (as it always does) but ends up\n+    \/\/ triggering a JVMTI event, which will cause callbackBlock to be entered.\n+    vmDeathLockForDebugLoop_Rank, \/\/ debug loop lock\n+\n+    NUM_DEBUG_RAW_MONITORS\n+} DebugRawMonitorRank;\n+\n+void dbgRawMonitor_lock();\n+\n+void dbgRawMonitor_unlock();\n+\n+DebugRawMonitor* debugMonitorCreate(DebugRawMonitorRank dbg_monitor, char *name);\n+void debugMonitorEnter(DebugRawMonitor* dbg_monitor);\n+void debugMonitorExit(DebugRawMonitor* dbg_monitor);\n+void debugMonitorWait(DebugRawMonitor* dbg_monitor);\n+void debugMonitorNotify(DebugRawMonitor* dbg_monitor);\n+void debugMonitorNotifyAll(DebugRawMonitor* dbg_monitor);\n+void debugMonitorDestroy(DebugRawMonitor* dbg_monitor);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":70,"deletions":8,"binary":false,"changes":78,"status":"modified"}]}