{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -407,1 +407,1 @@\n-    gdata->refLock = debugMonitorCreate(\"JDWP Reference Table Monitor\");\n+    gdata->refLock = debugMonitorCreate(refLock_Rank, \"JDWP Reference Table Monitor\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/commonRef.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-static jrawMonitorID initMonitor;\n+static DebugRawMonitor* initMonitor;\n@@ -667,1 +667,0 @@\n-    commonRef_initialize();\n@@ -669,0 +668,1 @@\n+    commonRef_initialize();\n@@ -676,1 +676,1 @@\n-    initMonitor = debugMonitorCreate(\"JDWP Initialization Monitor\");\n+    initMonitor = debugMonitorCreate(initMonitor_Rank, \"JDWP Initialization Monitor\");\n@@ -994,0 +994,1 @@\n+    gdata->rankedMonitors = JNI_TRUE;\n@@ -1098,0 +1099,11 @@\n+        } else if (strcmp(buf, \"rankedMonitors\") == 0) {\n+            if (!get_tok(&str, current, (int)(end - current), ',')) {\n+                goto syntax_error;\n+            }\n+            if (strcmp(current, \"y\") == 0) {\n+                gdata->rankedMonitors = JNI_TRUE;\n+            } else if (strcmp(current, \"n\") == 0) {\n+                gdata->rankedMonitors = JNI_FALSE;\n+            } else {\n+                goto syntax_error;\n+            }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-static jrawMonitorID cmdQueueLock;\n-static jrawMonitorID vmDeathLock;\n+static DebugRawMonitor* cmdQueueLock;\n+static DebugRawMonitor* vmDeathLock;\n@@ -66,1 +66,1 @@\n-    vmDeathLock = debugMonitorCreate(\"JDWP VM_DEATH Lock\");\n+    vmDeathLock = debugMonitorCreate(vmDeathLockForDebugLoop_Rank, \"JDWP VM_DEATH Lock\");\n@@ -91,1 +91,1 @@\n-      cmdQueueLock = debugMonitorCreate(\"JDWP Command Queue Lock\");\n+        cmdQueueLock = debugMonitorCreate(cmdQueueLock_Rank, \"JDWP Command Queue Lock\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugLoop.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -78,2 +78,2 @@\n-static jrawMonitorID callbackLock;\n-static jrawMonitorID callbackBlock;\n+static DebugRawMonitor* callbackLock;\n+static DebugRawMonitor* callbackBlock;\n@@ -100,0 +100,17 @@\n+static void allowSelfSuspend() {\n+#if 0\n+  struct timespec req;\n+  req.tv_sec = 0;\n+  req.tv_nsec = 1;\n+\n+  nanosleep(&req, NULL);\n+\n+  jthread current_thread = threadControl_currentThread();\n+  JNIEnv *env = getEnv();\n+  if (!FUNC_PTR(env,IsSameObject)(env, current_thread, current_thread)) {\n+    EXIT_ERROR(-1, \"on isSameObject\");\n+  }\n+  JNI_FUNC_PTR(env,DeleteLocalRef)(env, current_thread);\n+#endif\n+}\n+\n@@ -113,0 +130,1 @@\n+            allowSelfSuspend();                                         \\\n@@ -139,0 +157,1 @@\n+                allowSelfSuspend();                                     \\\n@@ -156,1 +175,1 @@\n-static jrawMonitorID handlerLock;\n+static DebugRawMonitor* handlerLock;\n@@ -1358,0 +1377,1 @@\n+    dumpRawMonitors();\n@@ -1508,4 +1528,3 @@\n-    callbackLock = debugMonitorCreate(\"JDWP Callback Lock\");\n-    callbackBlock = debugMonitorCreate(\"JDWP Callback Block\");\n-\n-    handlerLock = debugMonitorCreate(\"JDWP Event Handler Lock\");\n+    callbackLock = debugMonitorCreate(callbackLock_Rank, \"JDWP Callback Lock\");\n+    callbackBlock = debugMonitorCreate(callbackBlock_Rank, \"JDWP Callback Block\");\n+    handlerLock = debugMonitorCreate(handlerLock_Rank, \"JDWP Event Handler Lock\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -125,4 +125,4 @@\n-static jrawMonitorID commandQueueLock;\n-static jrawMonitorID commandCompleteLock;\n-static jrawMonitorID blockCommandLoopLock;\n-static jrawMonitorID vmDeathLock;\n+static DebugRawMonitor* commandQueueLock;\n+static DebugRawMonitor* commandCompleteLock;\n+static DebugRawMonitor* blockCommandLoopLock;\n+static DebugRawMonitor* vmDeathLock;\n@@ -747,4 +747,4 @@\n-    commandQueueLock = debugMonitorCreate(\"JDWP Event Helper Queue Monitor\");\n-    commandCompleteLock = debugMonitorCreate(\"JDWP Event Helper Completion Monitor\");\n-    blockCommandLoopLock = debugMonitorCreate(\"JDWP Event Block CommandLoop Monitor\");\n-    vmDeathLock = debugMonitorCreate(\"JDWP VM_DEATH CommandLoop Monitor\");\n+    commandQueueLock     = debugMonitorCreate(commandQueueLock_Rank, \"JDWP Event Helper Queue Monitor\");\n+    commandCompleteLock  = debugMonitorCreate(commandCompleteLock_Rank, \"JDWP Event Helper Completion Monitor\");\n+    blockCommandLoopLock = debugMonitorCreate(blockCommandLoopLock_Rank, \"JDWP Event Block CommandLoop Monitor\");\n+    vmDeathLock          = debugMonitorCreate(vmDeathLock_Rank, \"JDWP VM_DEATH CommandLoop Monitor\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHelper.c","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-static jrawMonitorID invokerLock;\n+static DebugRawMonitor* invokerLock;\n@@ -38,1 +38,1 @@\n-    invokerLock = debugMonitorCreate(\"JDWP Invocation Lock\");\n+    invokerLock = debugMonitorCreate(invokerLock_Rank, \"JDWP Invocation Lock\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/invoker.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-static jrawMonitorID stepLock;\n+static DebugRawMonitor* stepLock;\n@@ -697,1 +697,1 @@\n-    stepLock = debugMonitorCreate(\"JDWP Step Handler Lock\");\n+    stepLock = debugMonitorCreate(stepLock_Rank, \"JDWP Step Handler Lock\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/stepControl.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-static jrawMonitorID popFrameEventLock = NULL;\n+static DebugRawMonitor* popFrameEventLock = NULL;\n@@ -106,1 +106,1 @@\n-static jrawMonitorID popFrameProceedLock = NULL;\n+static DebugRawMonitor* popFrameProceedLock = NULL;\n@@ -108,1 +108,1 @@\n-static jrawMonitorID threadLock;\n+static DebugRawMonitor* threadLock;\n@@ -653,0 +653,3 @@\n+    if (gdata->rankedMonitors) {\n+        dbgRawMonitor_lock();\n+    }\n@@ -658,0 +661,3 @@\n+    if (gdata->rankedMonitors) {\n+        dbgRawMonitor_unlock();\n+    }\n@@ -675,1 +681,1 @@\n-    threadLock = debugMonitorCreate(\"JDWP Thread Lock\");\n+    threadLock = debugMonitorCreate(threadLock_Rank, \"JDWP Thread Lock\");\n@@ -1723,0 +1729,58 @@\n+\/*** Start of support for StackFrame.PopFrames ***\/\n+\n+\/*\n+ * Synchronization with popFrameEventLock and popFrameProceedLock\n+ *\n+ * StackFrame.PopFrames support has some complicated synchronization because\n+ * JVMTI PopFrame() is called on the JDWP Command Reader thread (that's where\n+ * the StackFrame.PopFrames command arrived on), but it needs to co-ordinate\n+ * with the PopFrames target thread. The Command Reader thread has to call JVMTI\n+ * PopFrame() on the target thread one frame at a time, resume the target thread,\n+ * and then know when the target thread is done with the PopFrame() so it can be\n+ * suspended so the next PopFrame() can then be done. Part of what makes this\n+ * complex is that the target thread needs to have SINGLE_STEP enabled so we\n+ * can tell when the PopFrame() has completed. (For reasons I don't understand,\n+ * we don't rely on FRAME_POP events).\n+ *\n+ * Synchronization is done via the popFrameProceedLock and popFrameEventLock. Both\n+ * the JDWP Command Reader thread and the PopFrame() target thread will grab\n+ * both of these locks. However, one curious trait of these two locks is that\n+ * the two threads do not both grab them in the same order (and they need\n+ * to do it this way). This seems like it should lead to a deadlock, but doesn't\n+ * because of how each thread grabs these locks and waits or notifies on them.\n+ *\n+ * Command Reader Thread:\n+ *  grab popFrameEventLock (which is always available)\n+ *  for each frame\n+ *    call PopFrame() on target thread\n+ *    resume target thread\n+ *    wait on popFrameEventLock (which releases it)\n+ *    grab popFrameProceedLock\n+ *    suspend target thread\n+ *    notify on popFrameProceedLock\n+ *    release popFrameProceedLock\n+ *  }\n+ *  release popFrameEventLock\n+ *\n+ * Target Thread:\n+ *   for each frame pop (indicated by a SingleStep event)\n+ *     grab popFrameProceedLock (which is always available)\n+ *     grab popFrameEventLock (which Command Reader Thread is waiting on)\n+ *     notify on popFrameEventLock\n+ *     release popFrameEventLock\n+ *     wait on popFrameProceedLock\n+ *     release popFrameProceedLock\n+ *   }\n+ *\n+ * The reason we don't get a deadlock is because the Reader thread always\n+ * starts the process, so it always enters popFrameEventLock and then\n+ * waits on it (which releases the lock). Therefore there is never a race for\n+ * popFrameEventLock. Meanwhile when the target thread gets the SINGLE_STEP event,\n+ * it always enters popFrameProceedLock first (which is always available), then\n+ * popFrameEventLock second. It will always succeed because the Reader thread\n+ * only entered popFrameEventLock, but is waiting on it, so doesn't currently hold\n+ * either lock. The target thread then notifies on popFrameEventLock and releases\n+ * it (unblocking the Reader thread), and then waits on popFrameProceedLock. The\n+ * Reader thread resumes and can enter popFrameProceedLock and notify on it.\n+*\/\n+\n@@ -1724,1 +1788,1 @@\n-initLocks(void)\n+initPopFrameLocks(void)\n@@ -1727,2 +1791,2 @@\n-        popFrameEventLock = debugMonitorCreate(\"JDWP PopFrame Event Lock\");\n-        popFrameProceedLock = debugMonitorCreate(\"JDWP PopFrame Proceed Lock\");\n+        popFrameEventLock = debugMonitorCreate(popFrameEventLock_Rank, \"JDWP PopFrame Event Lock\");\n+        popFrameProceedLock = debugMonitorCreate(popFrameProceedLock_Rank, \"JDWP PopFrame Proceed Lock\");\n@@ -1933,1 +1997,1 @@\n-    initLocks();\n+    initPopFrameLocks();\n@@ -2030,0 +2094,2 @@\n+\/*** End of support for StackFrame.PopFrames ***\/\n+\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":74,"deletions":8,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-static jrawMonitorID listenerLock;\n-static jrawMonitorID sendLock;\n+static DebugRawMonitor* listenerLock;\n+static DebugRawMonitor* sendLock;\n@@ -395,2 +395,2 @@\n-    listenerLock = debugMonitorCreate(\"JDWP Transport Listener Monitor\");\n-    sendLock = debugMonitorCreate(\"JDWP Transport Send Monitor\");\n+    listenerLock = debugMonitorCreate(listenerLock_Rank, \"JDWP Transport Listener Monitor\");\n+    sendLock = debugMonitorCreate(sendLock_Rank, \"JDWP Transport Send Monitor\");\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/transport.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+static void createDbgRawMonitor();\n@@ -171,0 +172,4 @@\n+    if (gdata->rankedMonitors) {\n+        createDbgRawMonitor();\n+    }\n+\n@@ -983,0 +988,2 @@\n+    JNIEnv *env = getEnv();\n+    JNI_FUNC_PTR(env,DeleteLocalRef)(env, thread);\n@@ -995,2 +1002,2 @@\n-void\n-debugMonitorEnter(jrawMonitorID monitor)\n+static void\n+debugMonitorEnter_norank(jrawMonitorID monitor)\n@@ -1007,2 +1014,2 @@\n-void\n-debugMonitorExit(jrawMonitorID monitor)\n+static void\n+debugMonitorExit_norank(jrawMonitorID monitor)\n@@ -1020,2 +1027,2 @@\n-void\n-debugMonitorWait(jrawMonitorID monitor)\n+static void\n+debugMonitorWait_norank(jrawMonitorID monitor)\n@@ -1065,2 +1072,2 @@\n-void\n-debugMonitorNotify(jrawMonitorID monitor)\n+static void\n+debugMonitorNotify_norank(jrawMonitorID monitor)\n@@ -1078,2 +1085,2 @@\n-void\n-debugMonitorNotifyAll(jrawMonitorID monitor)\n+static void\n+debugMonitorNotifyAll_norank(jrawMonitorID monitor)\n@@ -1091,2 +1098,79 @@\n-jrawMonitorID\n-debugMonitorCreate(char *name)\n+\/*\n+ * A DebugRawMonitor is an encapsulation of a jrawMonitorID. It is used to\n+ * store other information about the jrawMonitorID that is needed for ranked\n+ * monitors support, such as the thread that currently owns the monitor.\n+ *\/\n+struct DebugRawMonitor {\n+    jrawMonitorID monitor;\n+    const char* name;\n+    DebugRawMonitorRank rank;\n+    volatile jthread ownerThread; \/\/ Access protected by dbgRawMonitor\n+    int entryCount; \/\/ Only ownerThread should ever access this field\n+};\n+\n+static DebugRawMonitor dbg_monitors[NUM_DEBUG_RAW_MONITORS];\n+\n+\n+\/*\n+ * The dbgRawMonitor controls access to the DebugRawMonitor->ownerThread field.\n+ * It must be held whenever modifying ownerThread and also must be held whenever\n+ * accessing ownerThread unless we know the current thread already owns the monitor.\n+ * Only the owner of the DebugRawMonitor will ever modify ownerThread. The main thing\n+ * we are trying to protect from is a thread checking to see if it is the owner of\n+ * the DebugRawMonitor, and having the ownerThread field change while doing this.\n+ * The check is made using:\n+ *    isSameObject(env, dbg_monitor->ownerThread, current_thread)\n+ * We don't want ownerThread changing in the middle of this check since it can lead\n+ * to a crash if the JNI handle gets freed. So this check is always protected by\n+ * dbgRawMonitor as are modifications to ownerThread.\n+ *\n+ * There is also one other minor role that dbgRawMonitor plays. In verifyMonitorRank()\n+ * we iterate over all monitors, and need to make sure the monitor we are checking has\n+ * been initialized. If it hasn't been, then it is skipped. There can be a race and\n+ * we catch it in the middle of intialization. Since dbgRawMonitor is held during\n+ * verifyMonitorRank(), we should also hold it during monitor initialization.\n+ *\/\n+\n+static jrawMonitorID dbgRawMonitor;\n+\n+static void\n+createDbgRawMonitor()\n+{\n+    JDI_ASSERT(gdata->rankedMonitors);\n+    jvmtiError error;\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,CreateRawMonitor)\n+            (gdata->jvmti, \"Debug Raw Monitor\", &dbgRawMonitor);\n+    if (error != JVMTI_ERROR_NONE) {\n+        EXIT_ERROR(error, \"on creation of dbgRawMonitor\");\n+    }\n+    JDI_ASSERT(dbgRawMonitor != NULL);\n+}\n+\n+void\n+dbgRawMonitor_lock()\n+{\n+    JDI_ASSERT(gdata->rankedMonitors);\n+    jvmtiError error;\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorEnter)\n+            (gdata->jvmti, dbgRawMonitor);\n+    error = ignore_vm_death(error);\n+    if (error != JVMTI_ERROR_NONE) {\n+      EXIT_ERROR(error, \"on dbgRawMonitor enter\");\n+    }\n+}\n+\n+void\n+dbgRawMonitor_unlock()\n+{\n+    JDI_ASSERT(gdata->rankedMonitors);\n+    jvmtiError error;\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorExit)\n+            (gdata->jvmti, dbgRawMonitor);\n+    error = ignore_vm_death(error);\n+    if (error != JVMTI_ERROR_NONE) {\n+      EXIT_ERROR(error, \"on dbgRawMonitor exit\");\n+    }\n+}\n+\n+DebugRawMonitor*\n+debugMonitorCreate(DebugRawMonitorRank dbg_monitor_rank, char *name)\n@@ -1096,0 +1180,2 @@\n+    DebugRawMonitor* dbg_monitor = &dbg_monitors[dbg_monitor_rank];\n+    JDI_ASSERT(dbg_monitor->monitor == NULL);\n@@ -1102,1 +1188,16 @@\n-    return monitor;\n+\n+    JDI_ASSERT(monitor != NULL);\n+\n+    \/\/ Need to lock during initialization so verifyMonitorRank() can be guaranteed that\n+    \/\/ if the monitor field is not NULL, then the monitor is fully initialized.\n+    if (gdata->rankedMonitors) {\n+        dbgRawMonitor_lock();\n+    }\n+    dbg_monitor->monitor = monitor;\n+    dbg_monitor->rank = dbg_monitor_rank;\n+    dbg_monitor->name = name;\n+    if (gdata->rankedMonitors) {\n+        dbgRawMonitor_unlock();\n+    }\n+\n+    return dbg_monitor;\n@@ -1106,1 +1207,1 @@\n-debugMonitorDestroy(jrawMonitorID monitor)\n+debugMonitorDestroy(DebugRawMonitor *dbg_monitor)\n@@ -1109,0 +1210,1 @@\n+    JDI_ASSERT(dbg_monitor != NULL);\n@@ -1111,1 +1213,1 @@\n-                (gdata->jvmti, monitor);\n+                (gdata->jvmti, dbg_monitor->monitor);\n@@ -1116,0 +1218,282 @@\n+\n+    dbg_monitor->monitor = NULL;\n+}\n+\n+static char*\n+getThreadName(jthread thread)\n+{\n+    jvmtiThreadInfo info;\n+    jvmtiError error;\n+    JNIEnv *env = getEnv();\n+\n+    memset(&info, 0, sizeof(info));\n+    WITH_LOCAL_REFS(env, 2) {\n+        error = JVMTI_FUNC_PTR(gdata->jvmti,GetThreadInfo)\n+                (gdata->jvmti, thread, &info);\n+    } END_WITH_LOCAL_REFS(env);\n+    return info.name;\n+}\n+\n+void\n+dumpRawMonitor(DebugRawMonitor *dbg_monitor) {\n+    tty_message(\"DebugRawMonitor(%d)\", dbg_monitor->rank);\n+    tty_message(\"\\tname: %s\", dbg_monitor->name);\n+    if (dbg_monitor->ownerThread != NULL) {\n+        char* threadName = getThreadName(dbg_monitor->ownerThread);\n+        tty_message(\"\\townerThreadName: %s\", threadName);\n+        jvmtiDeallocate(threadName);\n+    }\n+}\n+\n+void\n+dumpRawMonitors() {\n+    tty_message(\"\\nRaw Monitor Dump:\");\n+    int i;\n+    for (i = 0; i < NUM_DEBUG_RAW_MONITORS; i++) {\n+        DebugRawMonitor* dbg_monitor = &dbg_monitors[i];\n+        if (dbg_monitor->monitor == NULL) {\n+            continue;\n+        }\n+        jthread thread = dbg_monitor->ownerThread;\n+        if (thread == NULL) {\n+            continue;\n+        }\n+        dumpRawMonitor(dbg_monitor);\n+    }\n+}\n+\n+static void\n+assertIsCurrentThread(JNIEnv *env, jthread thread, jthread current_thread)\n+{\n+    if (!gdata->assertOn) {\n+        return;\n+    }\n+    if (gdata->vmDead) {\n+        return; \/\/ This assert is not reliable if the VM is exiting\n+    }\n+    if (!isSameObject(env, thread, current_thread)) {\n+        tty_message(\"ERROR: Threads are not the same: \\\"%s\\\" \\\"%s\\\"\",\n+                    getThreadName(thread), getThreadName(current_thread));\n+        dumpRawMonitors();\n+        JDI_ASSERT(JNI_FALSE);\n+    }\n+}\n+\n+static void\n+verifyMonitorRank(JNIEnv *env, DebugRawMonitorRank rank, jthread thread)\n+{\n+    \/\/ We must hold the dbgRawMonitor when calling verifyMonitorRank()\n+\n+    \/\/ Iterate over all the monitors and make sure we don't already hold one that\n+    \/\/ has a higher rank than the monitor we are about to enter. The loop starts\n+    \/\/ with the lowest ranked monitor (0) and stops at rank-1. None of the\n+    \/\/ monitors in this set should be held by the current thread.\n+    DebugRawMonitorRank i;\n+    for (i = 0; i < rank; i++) {\n+        DebugRawMonitor* dbg_monitor = &dbg_monitors[i];\n+        if (dbg_monitor->monitor == NULL) {\n+            continue; \/\/ ignore uninitialzed monitors\n+        }\n+        if (dbg_monitor->ownerThread == NULL) {\n+            continue; \/\/ ignore unowned monitors\n+        }\n+        if (!isSameObject(env, dbg_monitor->ownerThread, thread)) {\n+            continue; \/\/ ignore monitors not owned by this thread\n+        }\n+\n+        \/*\n+         * At this point we know we have some sort of rank violation because we know that\n+         * the current thread owns the monitor we are iterating over, and it has a lower rank\n+         * than the monitor we are entering.\n+         *\/\n+\n+        if (dbg_monitor->rank == popFrameEventLock_Rank && rank == popFrameProceedLock_Rank) {\n+            \/\/ For reasons too complex to explain here, this is one exception that is safe so\n+            \/\/ we allow it. See the long comment for these locks in threadControl.c.\n+            continue;\n+        }\n+\n+        JDI_ASSERT(dbg_monitor->rank < rank);\n+        char* threadName = getThreadName(thread);\n+        tty_message(\"DebugRawMonitor rank failure: (%d:\\\"%s\\\" > %d:\\\"%s\\\") for thread (%s)\",\n+                    dbg_monitor->rank, dbg_monitor->name,\n+                    rank, dbg_monitors[rank].name, threadName);\n+        jvmtiDeallocate(threadName);\n+        dumpRawMonitors();\n+        JDI_ASSERT(JNI_FALSE);\n+    }\n+}\n+\n+void\n+debugMonitorEnter(DebugRawMonitor *dbg_monitor)\n+{\n+    jrawMonitorID monitor = dbg_monitor->monitor;\n+\n+    if (!gdata->rankedMonitors) {\n+        debugMonitorEnter_norank(monitor);\n+        return;\n+    }\n+\n+    JNIEnv *env = getEnv();\n+    jthread current_thread = threadControl_currentThread();\n+\n+    if (gdata->vmDead && current_thread == NULL) {\n+        return;\n+    }\n+    JDI_ASSERT(current_thread != NULL);\n+\n+    dbgRawMonitor_lock();\n+    if (isSameObject(env, dbg_monitor->ownerThread, current_thread)) {\n+        \/\/ We have already entered this monitor, so nothing to do except bump entryCount below.\n+        dbgRawMonitor_unlock();\n+    } else {\n+        \/\/ We must hold the dbgRawMonitor when calling verifyMonitorRank()\n+        verifyMonitorRank(env, dbg_monitor->rank, current_thread);\n+        dbgRawMonitor_unlock();\n+\n+        debugMonitorEnter_norank(monitor);\n+\n+        \/\/ Once we have entered the monitor, claim ownership of the DebugRawMonitor\n+        \/\/ by saving the thread into it.\n+        dbgRawMonitor_lock();\n+        JDI_ASSERT(dbg_monitor->ownerThread == NULL);\n+        JDI_ASSERT(dbg_monitor->entryCount == 0);\n+        saveGlobalRef(env, current_thread, (jobject*)&(dbg_monitor->ownerThread));\n+        dbgRawMonitor_unlock();\n+    }\n+\n+    dbg_monitor->entryCount++;\n+    JNI_FUNC_PTR(env,DeleteLocalRef)(env, current_thread);\n+}\n+\n+void\n+debugMonitorExit(DebugRawMonitor *dbg_monitor)\n+{\n+    jrawMonitorID monitor = dbg_monitor->monitor;\n+\n+    if (!gdata->rankedMonitors) {\n+        debugMonitorExit_norank(monitor);\n+        return;\n+    }\n+\n+    jthread current_thread = threadControl_currentThread();\n+\n+    if (gdata->vmDead && current_thread == NULL) {\n+        return;\n+    }\n+\n+    JDI_ASSERT(dbg_monitor->entryCount > 0);\n+\n+    \/\/ Assert that the current thread owns this monitor.\n+    JNIEnv *env = getEnv();\n+    assertIsCurrentThread(env, dbg_monitor->ownerThread, current_thread);\n+    JNI_FUNC_PTR(env,DeleteLocalRef)(env, current_thread);\n+\n+    dbg_monitor->entryCount--;\n+    if (dbg_monitor->entryCount == 0) {\n+        \/\/ Release ownership of the DebugRawMonitor before RawMonitorExit actually exits it.\n+        dbgRawMonitor_lock();\n+        tossGlobalRef(env, (jobject*)&(dbg_monitor->ownerThread));\n+        dbgRawMonitor_unlock();\n+\n+        debugMonitorExit_norank(monitor);\n+    }\n+}\n+\n+void\n+debugMonitorWait(DebugRawMonitor *dbg_monitor)\n+{\n+    jrawMonitorID monitor = dbg_monitor->monitor;\n+\n+    if (!gdata->rankedMonitors) {\n+        debugMonitorWait_norank(monitor);\n+        return;\n+    }\n+\n+    JNIEnv *env = getEnv();\n+    jthread savedOwnerThread = dbg_monitor->ownerThread;\n+    int savedEntryCount = dbg_monitor->entryCount;\n+    jthread current_thread = threadControl_currentThread();\n+\n+    if (gdata->vmDead && current_thread == NULL) {\n+        return;\n+    }\n+\n+    JDI_ASSERT(savedOwnerThread != NULL);\n+\n+    \/\/ Assert that the current thread owns this monitor.\n+    assertIsCurrentThread(env, savedOwnerThread, current_thread);\n+\n+    {\n+      dbgRawMonitor_lock();\n+\n+      \/\/ Release ownership of the DebugRawMonitor before RawMonitorWait actually exits it.\n+      dbg_monitor->ownerThread = NULL;\n+      dbg_monitor->entryCount = 0;\n+\n+      \/\/ Doing a wait ends up doing an exit and then an enter after the wait completes.\n+      \/\/ We must do the same rank verificaton as is done during a monitor enter.\n+      \/\/ We must hold the dbgRawMonitor when calling verifyMonitorRank()\n+      verifyMonitorRank(env, dbg_monitor->rank, current_thread);\n+\n+      dbgRawMonitor_unlock();\n+    }\n+\n+    debugMonitorWait_norank(monitor);\n+\n+    \/\/ Now that we have re-entered the monitor, reclaim ownership of the DebugRawMonitor\n+    \/\/ by saving the thread into it and restoring the entry count.\n+    dbgRawMonitor_lock();\n+    dbg_monitor->ownerThread = savedOwnerThread;\n+    dbg_monitor->entryCount = savedEntryCount;\n+    dbgRawMonitor_unlock();\n+\n+    JNI_FUNC_PTR(env,DeleteLocalRef)(env, current_thread);\n+}\n+\n+void\n+debugMonitorNotify(DebugRawMonitor *dbg_monitor)\n+{\n+    jrawMonitorID monitor = dbg_monitor->monitor;\n+\n+    if (!gdata->rankedMonitors) {\n+        debugMonitorNotify_norank(monitor);\n+        return;\n+    }\n+\n+    jthread current_thread = threadControl_currentThread();\n+\n+    if (gdata->vmDead && current_thread == NULL) {\n+        return;\n+    }\n+\n+    \/\/ Assert that the current thread owns this monitor.\n+    JNIEnv *env = getEnv();\n+    assertIsCurrentThread(env, dbg_monitor->ownerThread, current_thread);\n+    JNI_FUNC_PTR(env,DeleteLocalRef)(env, current_thread);\n+\n+    debugMonitorNotify_norank(monitor);\n+}\n+\n+void\n+debugMonitorNotifyAll(DebugRawMonitor *dbg_monitor)\n+{\n+    jrawMonitorID monitor = dbg_monitor->monitor;\n+\n+    if (!gdata->rankedMonitors) {\n+        debugMonitorNotifyAll_norank(monitor);\n+        return;\n+    }\n+\n+    jthread current_thread = threadControl_currentThread();\n+\n+    if (gdata->vmDead && current_thread == NULL) {\n+        return;\n+    }\n+\n+    \/\/ Assert that the current thread owns this monitor.\n+    JNIEnv *env = getEnv();\n+    assertIsCurrentThread(env, dbg_monitor->ownerThread, current_thread);\n+    JNI_FUNC_PTR(env,DeleteLocalRef)(env, current_thread);\n+\n+    debugMonitorNotifyAll_norank(monitor);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":399,"deletions":15,"binary":false,"changes":414,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+typedef struct DebugRawMonitor DebugRawMonitor;\n@@ -93,0 +94,1 @@\n+    jboolean rankedMonitors;\n@@ -133,1 +135,1 @@\n-    jrawMonitorID refLock;\n+    DebugRawMonitor* refLock;\n@@ -354,7 +356,66 @@\n-jrawMonitorID debugMonitorCreate(char *name);\n-void debugMonitorEnter(jrawMonitorID theLock);\n-void debugMonitorExit(jrawMonitorID theLock);\n-void debugMonitorWait(jrawMonitorID theLock);\n-void debugMonitorNotify(jrawMonitorID theLock);\n-void debugMonitorNotifyAll(jrawMonitorID theLock);\n-void debugMonitorDestroy(jrawMonitorID theLock);\n+\/*\n+ * The following enum represents the rank of each lock (JVMTI RawMonitor) that\n+ * the debug agent uses. Locks must be aquired in rank order (highest numbered\n+ * rank first). The list is in order from lowest rank to highest rank.\n+ *\/\n+typedef enum {\n+    \/\/ These first few are leaf monitors so their order doesn't matter. They just\n+    \/\/ need to be ranked lower than the non-leaf monitors.\n+    sendLock_Rank = 0, \/\/ transport lock\n+    cmdQueueLock_Rank, \/\/ debug loop lock\n+    blockCommandLoopLock_Rank, \/\/ event helper lock\n+    initMonitor_Rank, \/\/ debug init lock\n+\n+    \/\/ Must rank higher than initMonitor\n+    listenerLock_Rank, \/\/ transport lock\n+\n+    \/\/ This part of the list is determined by the order that locks are acquired in\n+    \/\/ the threadControl getLocks() function.\n+    refLock_Rank, \/\/ common ref lock\n+    threadLock_Rank, \/\/ thread control lock\n+    commandCompleteLock_Rank, \/\/ event helper lock\n+    commandQueueLock_Rank, \/\/ event helper lock\n+    invokerLock_Rank,\n+    stepLock_Rank,\n+    handlerLock_Rank, \/\/ event handler lock\n+    callbackLock_Rank, \/\/ event handler lock\n+\n+    \/\/ cbVMDeath() enters callbackBlock before callbackLock, so its rank must\n+    \/\/ be higher than callbacklock.\n+    callbackBlock_Rank, \/\/ event handler lock\n+\n+    \/\/ popFrameEventLock and popFrameProceedLock have special handling in\n+    \/\/ verifyMonitorRank(). See comment there. They must be ranked higher than\n+    \/\/ threadLock. popFrameEventLock must be ranked lower than vmDeathLock.\n+    popFrameEventLock_Rank, \/\/ thread control lock\n+    popFrameProceedLock_Rank, \/\/ thread control lock\n+\n+    \/\/ This lock is grabbed in commandLoop(), which eventually leads to\n+    \/\/ threadControl getLocks() grabbing the group of 8 locks\n+    \/\/ above, so it must be ranked higher than callbackLock.\n+    vmDeathLock_Rank, \/\/ event helper lock\n+\n+    \/\/ This lock is held by debugLoop_run() while replying to commands, so it needs\n+    \/\/ to be ranked higher than sendLock. Also it needs to rank higher than handlerLock\n+    \/\/ since handlers are installed while holding this lock. Lastly it needs\n+    \/\/ to be ranked higher than callbackBlock because of the rare case where\n+    \/\/ debugLoop_run() is holding this lock (as it always does) but ends up\n+    \/\/ triggering a JVMTI event, which will cause callbackBlock to be entered.\n+    vmDeathLockForDebugLoop_Rank, \/\/ debug loop lock\n+\n+    NUM_DEBUG_RAW_MONITORS\n+} DebugRawMonitorRank;\n+\n+void dbgRawMonitor_lock();\n+\n+void dbgRawMonitor_unlock();\n+\n+void dumpRawMonitors();\n+\n+DebugRawMonitor* debugMonitorCreate(DebugRawMonitorRank dbg_monitor, char *name);\n+void debugMonitorEnter(DebugRawMonitor* dbg_monitor);\n+void debugMonitorExit(DebugRawMonitor* dbg_monitor);\n+void debugMonitorWait(DebugRawMonitor* dbg_monitor);\n+void debugMonitorNotify(DebugRawMonitor* dbg_monitor);\n+void debugMonitorNotifyAll(DebugRawMonitor* dbg_monitor);\n+void debugMonitorDestroy(DebugRawMonitor* dbg_monitor);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":69,"deletions":8,"binary":false,"changes":77,"status":"modified"}]}