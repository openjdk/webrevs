{"files":[{"patch":"@@ -27,1 +27,1 @@\n-# Rules to create $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/java\/util\/regex\/EmojiData.java\n+# Rules to create $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/util\/regex\/EmojiData.java\n@@ -30,1 +30,1 @@\n-GENSRC_EMOJIDATA := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/java\/util\/regex\/EmojiData.java\n+GENSRC_EMOJIDATA := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/util\/regex\/EmojiData.java\n@@ -32,1 +32,1 @@\n-EMOJIDATATEMP = $(MODULE_SRC)\/share\/classes\/java\/util\/regex\/EmojiData.java.template\n+EMOJIDATATEMP = $(MODULE_SRC)\/share\/classes\/jdk\/internal\/util\/regex\/EmojiData.java.template\n","filename":"make\/modules\/java.base\/gensrc\/GensrcEmojiData.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,6 @@\n+ * @implNote The default implementation of the character boundary analysis\n+ * conforms to the Unicode Consortium's Extended Grapheme Cluster breaks.\n+ * For more detail, refer to\n+ * <a href=\"https:\/\/www.unicode.org\/reports\/tr29\/#Grapheme_Cluster_Boundaries\">\n+ * Grapheme Cluster Boundaries<\/a> section in the Unicode Standard Annex #29.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/text\/BreakIterator.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.util.regex.Grapheme;\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package java.util.regex;\n+package jdk.internal.util.regex;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/regex\/EmojiData.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/util\/regex\/EmojiData.java.template","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.util.regex;\n+package jdk.internal.util.regex;\n@@ -30,1 +30,1 @@\n-final class Grapheme {\n+public final class Grapheme {\n@@ -46,2 +46,2 @@\n-    static int nextBoundary(CharSequence src, int off, int limit) {\n-        Objects.checkFromToIndex(off, limit, src.length());\n+    public static int nextBoundary(CharSequence src, int off, int limit) {\n+        Objects.checkFromToIndex(0, limit - off, src.length());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/regex\/Grapheme.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Grapheme.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -30,0 +29,1 @@\n+import java.text.CharacterIterator;\n@@ -31,0 +31,3 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n@@ -35,0 +38,2 @@\n+\n+import jdk.internal.util.regex.Grapheme;\n@@ -48,1 +53,0 @@\n-    private static final int CHARACTER_INDEX = 0;\n@@ -130,4 +134,1 @@\n-        return getBreakInstance(locale,\n-                                CHARACTER_INDEX,\n-                                \"CharacterData\",\n-                                \"CharacterDictionary\");\n+        return new GraphemeBreakIterator();\n@@ -196,0 +197,147 @@\n+\n+    static final class GraphemeBreakIterator extends BreakIterator {\n+        CharacterIterator ci;\n+        int offset;\n+        List<Integer> boundaries;\n+        int boundaryIndex;\n+\n+        GraphemeBreakIterator() {\n+            setText(\"\");\n+        }\n+\n+        @Override\n+        public int first() {\n+            boundaryIndex = 0;\n+            return current();\n+        }\n+\n+        @Override\n+        public int last() {\n+            boundaryIndex = boundaries.size() - 1;\n+            return current();\n+        }\n+\n+        @Override\n+        public int next(int n) {\n+            if (n == 0) {\n+                return offset;\n+            }\n+\n+            boundaryIndex = boundaryIndex + n;\n+            if (boundaryIndex < 0) {\n+                boundaryIndex = 0;\n+                current();\n+                return DONE;\n+            } else if (boundaryIndex >= boundaries.size()) {\n+                boundaryIndex = boundaries.size() - 1;\n+                current();\n+                return DONE;\n+            } else {\n+                return current();\n+            }\n+        }\n+\n+        @Override\n+        public int next() {\n+            return next(1);\n+        }\n+\n+        @Override\n+        public int previous() {\n+            return next(-1);\n+        }\n+\n+        @Override\n+        public int following(int offset) {\n+            var lastBoundary = boundaries.get(boundaries.size() - 1);\n+\n+            if (offset < boundaries.get(0) || offset > lastBoundary) {\n+                throw new IllegalArgumentException(\"offset is out of bounds: \" + offset);\n+            } else if (offset == this.offset && this.offset == lastBoundary) {\n+                return DONE;\n+            }\n+\n+            boundaryIndex = Collections.binarySearch(boundaries, Math.min(offset + 1, lastBoundary));\n+            if (boundaryIndex < 0) {\n+                boundaryIndex = -boundaryIndex - 1;\n+            }\n+\n+            return current();\n+        }\n+\n+        @Override\n+        public int current() {\n+            offset = boundaries.get(boundaryIndex);\n+            return offset;\n+        }\n+\n+        @Override\n+        public CharacterIterator getText() {\n+            return ci;\n+        }\n+\n+        @Override\n+        public void setText(CharacterIterator newText) {\n+            ci = newText;\n+            var text = new CharacterIteratorCharSequence(ci);\n+            var end = ci.getEndIndex();\n+            boundaries = new ArrayList<>();\n+\n+            for (int b = ci.getBeginIndex(); b < end;) {\n+                boundaries.add(b);\n+                b = Grapheme.nextBoundary(text, b, end);\n+            }\n+            boundaries.add(end);\n+            boundaryIndex = 0;\n+            offset = ci.getIndex();\n+        }\n+\n+        \/\/ Had to override to suppress the bug in the BreakIterator's default impl.\n+        \/\/ See the comments in the default impl.\n+        @Override\n+        public boolean isBoundary(int offset) {\n+            if (offset < boundaries.get(0) || offset > boundaries.get(boundaries.size() - 1)) {\n+                throw new IllegalArgumentException(\"offset is out of bounds: \" + offset);\n+            }\n+            return Collections.binarySearch(boundaries, offset) >= 0;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(ci, offset, boundaries, boundaryIndex);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            return o instanceof GraphemeBreakIterator that &&\n+                    ci.equals(that.ci) &&\n+                    offset == that.offset &&\n+                    boundaries.equals(that.boundaries) &&\n+                    boundaryIndex == that.boundaryIndex;\n+        }\n+    }\n+\n+    \/\/ Implementation only for calling Grapheme.nextBoundary()\n+    static final class CharacterIteratorCharSequence implements CharSequence {\n+        CharacterIterator src;\n+        CharacterIteratorCharSequence(CharacterIterator ci) {\n+            src = ci;\n+        }\n+\n+        @Override\n+        public int length() {\n+            return src.getEndIndex() - src.getBeginIndex();\n+        }\n+\n+        @Override\n+        public char charAt(int index) {\n+            src.setIndex(index);\n+            return src.current();\n+        }\n+\n+        @Override\n+        public CharSequence subSequence(int start, int end) {\n+            \/\/ not expected to be called\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/provider\/BreakIteratorProviderImpl.java","additions":155,"deletions":7,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- *      4152416 4153072 4158381 4214367 4217703 4638433 8264765\n+ *      4152416 4153072 4158381 4214367 4217703 4638433 8264765 8291660\n@@ -70,0 +70,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n@@ -71,1 +73,0 @@\n-import java.text.CharacterIterator;\n@@ -73,0 +74,1 @@\n+import java.util.Arrays;\n@@ -75,2 +77,2 @@\n-import java.util.Enumeration;\n-import java.io.*;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n@@ -1452,0 +1454,17 @@\n+    private static final Pattern CODEPOINT = Pattern.compile(\"([0-9A-F]{4,5})\");\n+    public void TestGraphemeBreak() throws Exception {\n+        Files.lines(Paths.get(System.getProperty(\"test.root\"),\n+                \"..\/..\/src\/java.base\/share\/data\/unicodedata\/auxiliary\/GraphemeBreakTest.txt\"))\n+                .map(ln -> ln.replaceFirst(\"#.*\", \"\"))\n+                .filter(Predicate.not(String::isEmpty))\n+                .map(line -> line.split(\"\\\\s*÷[\\\\s\\\\t]*\"))\n+                .forEach(sa -> {\n+                    Vector<String> expected = new Vector<>(\n+                        Arrays.stream(sa)\n+                            .map(line -> CODEPOINT.matcher(line).replaceAll(mr -> Character.toString(Integer.valueOf(mr.group(),16))))\n+                            .map(line -> line.replaceAll(\"\\\\s×\\\\s\", \"\"))\n+                            .filter(Predicate.not(String::isEmpty))\n+                            .toList());\n+                    generalIteratorTest(characterBreak, expected);\n+                });\n+    }\n","filename":"test\/jdk\/java\/text\/BreakIterator\/BreakIteratorTest.java","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-        \/\/ Call the default impelementation in BreakIterator\n+        \/\/ Call the default implementation in BreakIterator\n","filename":"test\/jdk\/java\/text\/BreakIterator\/MirroredBreakIterator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4052440 8062588 8165804 8210406\n+ * @bug 4052440 8062588 8165804 8210406 8291660\n@@ -105,1 +105,2 @@\n-                for (int i = 0; i < 4; i++) {\n+                jresResult[0] = \"sun.util.locale.provider.BreakIteratorProviderImpl$GraphemeBreakIterator\";\n+                for (int i = 1; i < 4; i++) {\n","filename":"test\/jdk\/java\/util\/PluggableLocale\/BreakIteratorProviderTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7071819 8221431 8239383 8273430\n+ * @bug 7071819 8221431 8239383 8273430 8291660\n@@ -29,1 +29,1 @@\n- * @build java.base\/java.util.regex.GraphemeTestAccessor\n+ * @modules java.base\/jdk.internal.util.regex:+open\n@@ -33,1 +33,2 @@\n-import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -36,0 +37,1 @@\n+import jdk.internal.util.regex.Grapheme;\n@@ -37,0 +39,1 @@\n+import org.testng.annotations.BeforeClass;\n@@ -40,1 +43,0 @@\n-import java.util.regex.GraphemeTestAccessor;\n@@ -44,0 +46,7 @@\n+    private static MethodHandles.Lookup lookup;\n+\n+    @BeforeClass\n+    public static void setup() throws IllegalAccessException {\n+        lookup = MethodHandles.privateLookupIn(Grapheme.class, MethodHandles.lookup());\n+    }\n+\n@@ -55,3 +64,5 @@\n-    public static void testExcludedSpacingMarks() {\n-        assertFalse(GraphemeTestAccessor.isExcludedSpacingMark(0x1065));\n-        assertFalse(GraphemeTestAccessor.isExcludedSpacingMark(0x1066));\n+    public static void testExcludedSpacingMarks() throws Throwable {\n+        var mh = lookup.findStatic(\n+                Grapheme.class, \"isExcludedSpacingMark\", MethodType.methodType(boolean.class, int.class));\n+        assertFalse((boolean)mh.invokeExact(0x1065));\n+        assertFalse((boolean)mh.invokeExact(0x1066));\n@@ -60,1 +71,3 @@\n-    private static void testProps(Path path) throws IOException {\n+    private static void testProps(Path path) throws Throwable {\n+        var mh = lookup.findStatic(\n+                Grapheme.class, \"getType\", MethodType.methodType(int.class, int.class));\n@@ -86,9 +99,13 @@\n-                        if (!expected.equals(types[GraphemeTestAccessor.getType(cp)])) {\n-                            if (\"Extend\".equals(expected) &&\n-                                    \"SpacingMark\".equals(types[GraphemeTestAccessor.getType(cp)]))\n-                                System.out.printf(\"[%x]  [%s][%d] -> [%s]%n\",\n-                                        cp, expected, Character.getType(cp), types[GraphemeTestAccessor.getType(cp)]);\n-                            else\n-                                fail(String.format(\n-                                        \"cp=[%x], expected:[%s] result:[%s]%n\",\n-                                        cp, expected, types[GraphemeTestAccessor.getType(cp)]));\n+                        try {\n+                            if (!expected.equals(types[(int) mh.invokeExact(cp)])) {\n+                                if (\"Extend\".equals(expected) &&\n+                                        \"SpacingMark\".equals(types[(int) mh.invokeExact(cp)]))\n+                                    System.out.printf(\"[%x]  [%s][%d] -> [%s]%n\",\n+                                            cp, expected, Character.getType(cp), types[(int) mh.invokeExact(cp)]);\n+                                else\n+                                    fail(String.format(\n+                                            \"cp=[%x], expected:[%s] result:[%s]%n\",\n+                                            cp, expected, types[(int) mh.invokeExact(cp)]));\n+                            }\n+                        } catch (Throwable e) {\n+                            throw new RuntimeException(e);\n","filename":"test\/jdk\/java\/util\/regex\/whitebox\/GraphemeTest.java","additions":34,"deletions":17,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.util.regex;\n-\n-public class GraphemeTestAccessor {\n-\n-    public static boolean isExcludedSpacingMark(int cp) {\n-        return Grapheme.isExcludedSpacingMark(cp);\n-    }\n-\n-    public static int getType(int cp) {\n-        return Grapheme.getType(cp);\n-    }\n-}\n-\n-\n-\n-\n","filename":"test\/jdk\/java\/util\/regex\/whitebox\/java.base\/java\/util\/regex\/GraphemeTestAccessor.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"}]}