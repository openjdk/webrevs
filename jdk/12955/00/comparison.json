{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.hotspot.igv.graph.Figure;\n@@ -63,0 +64,10 @@\n+\n+    protected static String getFirstMatchingProperty(Figure figure, String[] propertyNames) {\n+        for (String propertyName : propertyNames) {\n+            String s = figure.getProperties().resolveString(propertyName);\n+            if (s != null && !s.isEmpty()) {\n+                return s;\n+            }\n+        }\n+        return null;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/AbstractFilter.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import com.sun.hotspot.igv.data.Properties;\n-import com.sun.hotspot.igv.data.Properties.PropertyMatcher;\n@@ -30,1 +28,0 @@\n-import java.util.HashSet;\n@@ -32,1 +29,0 @@\n-import java.util.Set;\n@@ -56,1 +52,0 @@\n-        Properties.PropertySelector<Figure> selector = new Properties.PropertySelector<>(diagram.getFigures());\n@@ -59,3 +54,3 @@\n-            List<Figure> list = selector.selectMultiple(r.getFirstMatcher());\n-            Set<Figure> figuresToRemove = new HashSet<>();\n-            for (Figure f : list) {\n+            List<Figure> first = r.getFirstSelector().selected(diagram);\n+            List<Figure> second = r.getSecondSelector().selected(diagram);\n+            for (Figure f : first) {\n@@ -78,2 +73,2 @@\n-                        if (r.getShortProperty() != null) {\n-                            String s = f.getProperties().get(r.getShortProperty());\n+                        if (r.getPropertyNames() != null && r.getPropertyNames().length > 0) {\n+                            String s = r.getFirstMatchingProperty(f);\n@@ -106,2 +101,0 @@\n-\n-                        figuresToRemove.add(f);\n@@ -112,3 +105,2 @@\n-                        if (succ.getPredecessors().size() == 1 && succ.getInputSlots().size() == 1) {\n-                            if (succ.getProperties().selectSingle(r.getSecondMatcher()) != null && succ.getOutputSlots().size() == 1) {\n-\n+                        if (succ.getPredecessors().size() == 1) {\n+                            if (second.contains(succ) && succ.getOutputSlots().size() <= 1) {\n@@ -127,1 +119,5 @@\n-                                OutputSlot nextSlot = succ.getOutputSlots().get(0);\n+                                OutputSlot nextSlot = null;\n+                                if (succ.getOutputSlots().size() == 1) {\n+                                    nextSlot = succ.getOutputSlots().get(0);\n+                                }\n+\n@@ -134,2 +130,2 @@\n-                                if (r.getShortProperty() != null) {\n-                                    String s = succ.getProperties().get(r.getShortProperty());\n+                                if (r.getPropertyNames() != null && r.getPropertyNames().length > 0) {\n+                                    String s = r.getFirstMatchingProperty(succ);\n@@ -158,4 +154,6 @@\n-                                for (FigureConnection c : nextSlot.getConnections()) {\n-                                    FigureConnection newConn = diagram.createConnection(c.getInputSlot(), slot, c.getLabel());\n-                                    newConn.setColor(c.getColor());\n-                                    newConn.setStyle(c.getStyle());\n+                                if (nextSlot != null) {\n+                                    for (FigureConnection c : nextSlot.getConnections()) {\n+                                        FigureConnection newConn = diagram.createConnection(c.getInputSlot(), slot, c.getLabel());\n+                                        newConn.setColor(c.getColor());\n+                                        newConn.setStyle(c.getStyle());\n+                                    }\n@@ -164,2 +162,1 @@\n-\n-                                figuresToRemove.add(succ);\n+                                diagram.removeFigure(succ);\n@@ -175,2 +172,0 @@\n-\n-            diagram.removeAllFigures(figuresToRemove);\n@@ -186,2 +181,2 @@\n-        private PropertyMatcher first;\n-        private PropertyMatcher second;\n+        private Selector first;\n+        private Selector second;\n@@ -189,1 +184,1 @@\n-        private String shortProperty;\n+        private String[] propertyNames;\n@@ -191,10 +186,1 @@\n-        public CombineRule(PropertyMatcher first, PropertyMatcher second) {\n-            this(first, second, false);\n-\n-        }\n-\n-        public CombineRule(PropertyMatcher first, PropertyMatcher second, boolean reversed) {\n-            this(first, second, reversed, null);\n-        }\n-\n-        public CombineRule(PropertyMatcher first, PropertyMatcher second, boolean reversed, String shortProperty) {\n+        public CombineRule(Selector first, Selector second, boolean reversed, String[] propertyNames) {\n@@ -204,1 +190,1 @@\n-            this.shortProperty = shortProperty;\n+            this.propertyNames = propertyNames;\n@@ -211,1 +197,1 @@\n-        public PropertyMatcher getFirstMatcher() {\n+        public Selector getFirstSelector() {\n@@ -215,1 +201,1 @@\n-        public PropertyMatcher getSecondMatcher() {\n+        public Selector getSecondSelector() {\n@@ -219,2 +205,6 @@\n-        public String getShortProperty() {\n-            return shortProperty;\n+        public String[] getPropertyNames() {\n+            return propertyNames;\n+        }\n+\n+        public String getFirstMatchingProperty(Figure figure) {\n+            return AbstractFilter.getFirstMatchingProperty(figure, propertyNames);\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/CombineFilter.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.filter;\n+\n+import com.sun.hotspot.igv.graph.Diagram;\n+import com.sun.hotspot.igv.graph.Figure;\n+import com.sun.hotspot.igv.graph.Selector;\n+import java.util.function.UnaryOperator;\n+import java.util.List;\n+\n+public class EditPropertyFilter extends AbstractFilter {\n+\n+    private String name;\n+    private Selector selector;\n+    private final String inputPropertyName;\n+    private final String outputPropertyName;\n+    private final UnaryOperator<String> editFunction;\n+\n+    public EditPropertyFilter(String name, Selector selector,\n+                              String inputPropertyName, String outputPropertyName,\n+                              UnaryOperator<String> editFunction) {\n+        this.name = name;\n+        this.selector = selector;\n+        this.inputPropertyName = inputPropertyName;\n+        this.outputPropertyName = outputPropertyName;\n+        this.editFunction = editFunction;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public void apply(Diagram diagram) {\n+        List<Figure> list = selector.selected(diagram);\n+        for (Figure f : list) {\n+            String inputVal = f.getProperties().get(inputPropertyName);\n+            String outputVal = editFunction.apply(inputVal);\n+            f.getProperties().setProperty(outputPropertyName, outputVal);\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/EditPropertyFilter.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.Comparator;\n@@ -76,1 +77,1 @@\n-    public void apply(Diagram d, FilterChain sequence) {\n+    public void applyInOrder(Diagram d, FilterChain sequence, FilterChain ordering) {\n@@ -78,0 +79,1 @@\n+        List<Filter> candidates = new ArrayList<>(sequence.getFilters().size());\n@@ -80,1 +82,1 @@\n-                f.apply(d);\n+                candidates.add(f);\n@@ -84,2 +86,0 @@\n-\n-\n@@ -88,1 +88,1 @@\n-                f.apply(d);\n+                candidates.add(f);\n@@ -91,0 +91,4 @@\n+        candidates.sort(Comparator.comparingInt(ordering.getFilters()::indexOf));\n+        for (Filter f : candidates) {\n+            f.apply(d);\n+        }\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/FilterChain.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.filter;\n+\n+import com.sun.hotspot.igv.graph.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class RemoveEmptySlotsFilter extends AbstractFilter {\n+\n+    private String name;\n+    private Selector selector;\n+\n+    public RemoveEmptySlotsFilter(String name, Selector selector) {\n+        this.name = name;\n+        this.selector = selector;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    @Override\n+    public void apply(Diagram diagram) {\n+        List<Figure> list = selector.selected(diagram);\n+        for (Figure f : list) {\n+            List<InputSlot> empty = new ArrayList<>();\n+            for (InputSlot is : f.getInputSlots()) {\n+                if (is.getConnections().isEmpty()) {\n+                    empty.add(is);\n+                }\n+            }\n+            for (InputSlot is : empty) {\n+                f.removeSlot(is);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/RemoveEmptySlotsFilter.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n-\n@@ -53,2 +52,2 @@\n-\n-            List<Figure> list = r.getSelector().selected(diagram);\n+            List<Figure> list = r.getNodeSelector().selected(diagram);\n+            List<Figure> slotList = r.getSlotSelector().selected(diagram);\n@@ -56,2 +55,0 @@\n-                int z = 0;\n-                List<InputSlot> last = new ArrayList<>();\n@@ -59,31 +56,5 @@\n-                    if (z >= r.getStartingIndex() && z <= r.getEndIndex() && is.getConnections().size() > 0) {\n-                        StringBuilder sb = new StringBuilder();\n-                        List<FigureConnection> conns = is.getConnections();\n-                        for (int i = 0; i < conns.size(); i++) {\n-                            FigureConnection c = conns.get(i);\n-                            OutputSlot os = c.getOutputSlot();\n-                            Figure pred = os.getFigure();\n-                            if (i != 0) {\n-                                sb.append(\"<BR>\");\n-                            }\n-                            sb.append(pred.getLines()[0]);\n-                        }\n-                        is.removeAllConnections();\n-                        is.setShortName(\"X\");\n-                        is.setText(sb.toString());\n-                        last.add(is);\n-                    } else {\n-                        last.clear();\n-                    }\n-                    z++;\n-                }\n-\n-                if (last.size() > 3) {\n-                    InputSlot first = last.get(0);\n-                    first.setShortName(\"XX\");\n-\n-                    StringBuilder sb = new StringBuilder();\n-                    for (int i = 0; i < last.size(); i++) {\n-                        InputSlot is2 = last.get(i);\n-                        if (i != 0) {\n-                            sb.append(\"<BR>\");\n+                    List<FigureConnection> conns = is.getConnections();\n+                    if (conns.size() == 1) {\n+                        Figure i = conns.get(0).getOutputSlot().getFigure();\n+                        if (slotList.contains(i)) {\n+                            is.removeAllConnections();\n@@ -91,7 +62,0 @@\n-                        sb.append(is2.getText());\n-                    }\n-\n-                    first.setText(sb.toString());\n-\n-                    for (int i = 1; i < last.size(); i++) {\n-                        f.removeSlot(last.get(i));\n@@ -110,17 +74,2 @@\n-        private Selector selector;\n-        private int startingIndex;\n-        private int endIndex;\n-\n-        public RemoveInputsRule(Selector selector) {\n-            this(selector, 0);\n-        }\n-\n-        public RemoveInputsRule(Selector selector, int startIndex) {\n-            this(selector, startIndex, Integer.MAX_VALUE);\n-        }\n-\n-        public RemoveInputsRule(Selector selector, int startIndex, int endIndex) {\n-            this.startingIndex = startIndex;\n-            this.endIndex = endIndex;\n-            this.selector = selector;\n-        }\n+        private Selector nodeSelector;\n+        private Selector slotSelector;\n@@ -128,2 +77,3 @@\n-        public int getStartingIndex() {\n-            return startingIndex;\n+        public RemoveInputsRule(Selector nodeSelector, Selector slotSelector) {\n+            this.nodeSelector = nodeSelector;\n+            this.slotSelector = slotSelector;\n@@ -132,2 +82,2 @@\n-        public int getEndIndex() {\n-            return endIndex;\n+        public Selector getNodeSelector() {\n+            return nodeSelector;\n@@ -136,2 +86,2 @@\n-        public Selector getSelector() {\n-            return selector;\n+        public Selector getSlotSelector() {\n+            return slotSelector;\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/RemoveInputsFilter.java","additions":17,"deletions":67,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    private String propertyName;\n+    private String[] propertyNames;\n@@ -39,1 +39,1 @@\n-    public SplitFilter(String name, Selector selector, String propertyName) {\n+    public SplitFilter(String name, Selector selector, String[] propertyNames) {\n@@ -42,1 +42,1 @@\n-        this.propertyName = propertyName;\n+        this.propertyNames = propertyNames;\n@@ -55,17 +55,1 @@\n-\n-            for (InputSlot is : f.getInputSlots()) {\n-                for (FigureConnection c : is.getConnections()) {\n-                    OutputSlot os = c.getOutputSlot();\n-                    if (f.getInputNode() != null) {\n-                        os.getSource().addSourceNode(f.getInputNode());\n-                        os.setColor(f.getColor());\n-                    }\n-\n-\n-                    String s = f.getProperties().resolveString(propertyName);\n-                    if (s != null) {\n-                        os.setShortName(s);\n-                    }\n-\n-                }\n-            }\n+            String s = AbstractFilter.getFirstMatchingProperty(f, propertyNames);\n@@ -79,2 +63,0 @@\n-\n-                    String s = f.getProperties().resolveString(propertyName);\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/java\/com\/sun\/hotspot\/igv\/filter\/SplitFilter.java","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n- \n+\n@@ -29,2 +29,38 @@\n- \n-function colorize(property, regexp, color) {\n+\n+\/\/ Split a string by whitespace, collapsing repeated ones.\n+function split_string(s) {\n+    return s.split(\/(\\s+)\/).filter(function(e) {return e.trim().length > 0;});\n+}\n+\n+\/\/ Select the node union in a list of selectors.\n+function or(selectors) {\n+    return new OrSelector(selectors);\n+}\n+\n+\/\/ Select the node intersection in a list of selectors.\n+function and(selectors) {\n+    return new AndSelector(selectors);\n+}\n+\n+\/\/ Select the nodes that are not selected by a given selector.\n+function not(selector) {\n+    return new InvertSelector(selector);\n+}\n+\n+\/\/ Select the nodes that succeed those given by a selector.\n+function successorOf(selector) {\n+    return new SuccessorSelector(selector);\n+}\n+\n+\/\/ Select the blocks where at least one node is selected by the given selector.\n+function hasAnyNode(selector) {\n+    return new AnySelector(selector);\n+}\n+\n+\/\/ Select the nodes whose given property matches a given regular expression.\n+function matches(property, regexp) {\n+    return new MatcherSelector(new Properties.RegexpPropertyMatcher(property, regexp));\n+}\n+\n+\/\/ Color the selected nodes.\n+function colorize(selector, color) {\n@@ -32,2 +68,13 @@\n-    f.addRule(new ColorFilter.ColorRule(new MatcherSelector(new Properties.RegexpPropertyMatcher(property, regexp)), color));\n-    f.apply(graph); \n+    f.addRule(new ColorFilter.ColorRule(selector, color));\n+    f.apply(graph);\n+}\n+\n+\/\/ Invisible connection style (used to hide edges).\n+invisibleConnection = Connection.ConnectionStyle.INVISIBLE;\n+\n+\/\/ Apply a given style (e.g. invisible) and color to the out edges of the\n+\/\/ selected nodes.\n+function styleOutputConnections(selector, color, style) {\n+    var f = new ConnectionFilter(\"\");\n+    f.addRule(new ConnectionFilter.ConnectionStyleRule(selector, color, style));\n+    f.apply(graph);\n@@ -36,0 +83,3 @@\n+\/\/ Display a warning with the contents of a given property ('propertyToShow') in\n+\/\/ the nodes whose given property ('propertyToMatch') matches a regular\n+\/\/ expression.\n@@ -38,1 +88,1 @@\n-    f.addRule(new WarningFilter.WarningRule(new MatcherSelector(new Properties.RegexpPropertyMatcher(propertyToMatch, regexp))));\n+    f.addRule(new WarningFilter.WarningRule(matches(propertyToMatch, regexp)));\n@@ -42,1 +92,8 @@\n-function remove(property, regexp) {\n+\/\/ Remove edges with the same source and destination node.\n+function removeSelfLoops() {\n+    var f = new RemoveSelfLoopsFilter(\"\");\n+    f.apply(graph);\n+}\n+\n+\/\/ Remove the selected nodes.\n+function remove(selector) {\n@@ -44,1 +101,1 @@\n-    f.addRule(new RemoveFilter.RemoveRule(new MatcherSelector(new Properties.RegexpPropertyMatcher(property, regexp))));\n+    f.addRule(new RemoveFilter.RemoveRule(selector));\n@@ -48,0 +105,1 @@\n+\/\/ Remove the selected nodes and nodes that become orphan after the removal.\n@@ -54,3 +112,5 @@\n-function split(property, regexp, propertyName) {\n-    if (propertyName == undefined) {\n-        propertyName = graph.getNodeText();\n+\/\/ Inline the selected nodes into their successors and display the first found\n+\/\/ property in the given property list in the resulting input slots.\n+function split(selector, propertyNames) {\n+    if (propertyNames == undefined) {\n+        propertyNames = [];\n@@ -58,2 +118,1 @@\n-    var f = new SplitFilter(\"\", new MatcherSelector(new Properties.RegexpPropertyMatcher(property, regexp)), propertyName);\n-    f.apply(graph);\n+    new SplitFilter(\"\", selector, propertyNames).apply(graph);\n@@ -62,8 +121,6 @@\n-function removeInputs(property, regexp, from, to) {\n-    var f = new RemoveInputsFilter(\"\");\n-    if(from == undefined && to == undefined) {\n-        f.addRule(new RemoveInputsFilter.RemoveInputsRule(new MatcherSelector(new Properties.RegexpPropertyMatcher(property, regexp))));\n-    } else if(to == undefined) {\n-        f.addRule(new RemoveInputsFilter.RemoveInputsRule(new MatcherSelector(new Properties.RegexpPropertyMatcher(property, regexp)), from));\n-    } else {\n-        f.addRule(new RemoveInputsFilter.RemoveInputsRule(new MatcherSelector(new Properties.RegexpPropertyMatcher(property, regexp)), from, to));\n+\/\/ Combine the selected (second) nodes into their selected (first) predecessors\n+\/\/ and display the first found property in the given property list in the\n+\/\/ resulting output slots.\n+function combine(first, second, propertyNames) {\n+    if (propertyNames == undefined) {\n+        propertyNames = [];\n@@ -71,0 +128,2 @@\n+    var f = new CombineFilter(\"\");\n+    f.addRule(new CombineFilter.CombineRule(first, second, false, propertyNames));\n@@ -74,0 +133,1 @@\n+\/\/ Remove (input and\/or output) slots without connecting edges.\n@@ -79,0 +139,1 @@\n+\/\/ Color nodes using a gradient based on the given property and min\/max values.\n@@ -87,0 +148,2 @@\n+\/\/ Color nodes using a gradient based on the given property, min\/max values, and\n+\/\/ mode (\"LINEAR\" or \"LOGARITHMIC\").\n@@ -96,0 +159,3 @@\n+\/\/ Color nodes using a custom gradient based on the given property, min\/max\n+\/\/ values, mode (\"LINEAR\" or \"LOGARITHMIC\"), list of colors, list of fractions,\n+\/\/ and number of shades.\n@@ -108,0 +174,1 @@\n+\/\/ Pre-defined colors for coloring filters.\n@@ -121,0 +188,35 @@\n+\n+\/\/ Update the value of the given property in the selected nodes according to a\n+\/\/ function that takes as input the old property value and returns the new\n+\/\/ property value.\n+function editSameProperty(selector, propertyName, editFunction) {\n+    var f = new EditPropertyFilter(\"\", selector, propertyName, propertyName, editFunction);\n+    f.apply(graph);\n+}\n+\n+\/\/ Update the value of the given property ('outputPropertyName') in the selected\n+\/\/ nodes according to a function that takes as input the value of a possibly\n+\/\/ different property ('inputPropertyName') and returns the new property value.\n+function editProperty(selector, inputPropertyName, outputPropertyName, editFunction) {\n+    var f = new EditPropertyFilter(\"\", selector, inputPropertyName, outputPropertyName, editFunction);\n+    f.apply(graph);\n+}\n+\n+\/\/ Remove edges that go from the selected slots into the selected nodes.\n+function removeInputs(nodeSelector, slotSelector) {\n+    var f = new RemoveInputsFilter(\"\");\n+    f.addRule(new RemoveInputsFilter.RemoveInputsRule(nodeSelector, slotSelector));\n+    f.apply(graph);\n+}\n+\n+\/\/ Remove empty slots in the selected nodes, condensing all inputs as a result.\n+function removeEmptySlots(selector) {\n+    new RemoveEmptySlotsFilter(\"\", selector).apply(graph);\n+}\n+\n+\/\/ Remove the selected block.\n+function removeBlock(selector) {\n+    var f = new RemoveBlockFilter(\"\");\n+    f.addRule(new RemoveBlockFilter.RemoveBlockRule(selector));\n+    f.apply(graph);\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Filter\/src\/main\/resources\/com\/sun\/hotspot\/igv\/filter\/helper.js","additions":124,"deletions":22,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,1 @@\n-    private Selector selector1;\n-    private Selector selector2;\n+    private Selector[] selectors;\n@@ -38,3 +37,2 @@\n-    public AndSelector(Selector s1, Selector s2) {\n-        this.selector1 = s1;\n-        this.selector2 = s2;\n+    public AndSelector(Selector[] selectors) {\n+        this.selectors = selectors;\n@@ -45,6 +43,8 @@\n-        List<Figure> l1 = selector1.selected(d);\n-        List<Figure> l2 = selector2.selected(d);\n-        List<Figure> result = new ArrayList<>();\n-        for (Figure f : l2) {\n-            if (l1.contains(f)) {\n-                result.add(f);\n+        List<Figure> result = d.getFigures();\n+        for (Selector s : selectors) {\n+            List<Figure> selected = s.selected(d);\n+            List<Figure> newResult = new ArrayList<>();\n+            for (Figure f : result) {\n+                if (selected.contains(f)) {\n+                    newResult.add(f);\n+                }\n@@ -52,0 +52,1 @@\n+            result = newResult;\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/AndSelector.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,0 +116,8 @@\n+        for (Figure f : figures) {\n+            int i = 0;\n+            for (InputSlot inputSlot : f.getInputSlots()) {\n+                inputSlot.setOriginalIndex(i);\n+                i++;\n+            }\n+        }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Diagram.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,3 @@\n+        if (getProperties().get(\"extra_label\") != null) {\n+            lines++;\n+        }\n@@ -167,1 +170,1 @@\n-        return diagram.isCFG() && !getPredecessors().isEmpty();\n+        return diagram.isCFG() && !getInputSlots().isEmpty();\n@@ -323,2 +326,26 @@\n-            for (Figure p : getPredecessors()) {\n-                inputs.add(p.getProperties().resolveString(diagram.getTinyNodeText()));\n+            for (InputSlot is : getInputSlots()) {\n+                String inputLabel = null;\n+                if (is.getConnections().isEmpty()) {\n+                    if (is.hasSourceNodes() && is.shouldShowName()) {\n+                        inputLabel = \"[\" + is.getShortName() + \"]\";\n+                    } else {\n+                        inputLabel = \"_\";\n+                    }\n+                } else {\n+                    OutputSlot os = is.getConnections().get(0).getOutputSlot();\n+                    Figure f = os.getFigure();\n+                    String nodeTinyLabel = f.getProperties().resolveString(diagram.getTinyNodeText());\n+                    if (os.hasSourceNodes() && os.shouldShowName()) {\n+                        nodeTinyLabel += \":\" + os.getShortName();\n+                    }\n+                    inputLabel = nodeTinyLabel;\n+                }\n+                if (inputLabel != null) {\n+                    int gapSize = is.gapSize();\n+                    if (gapSize == 1) {\n+                        inputs.add(\"_\");\n+                    } else if (gapSize > 1) {\n+                        inputs.add(\"…\");\n+                    }\n+                    inputs.add(inputLabel);\n+                }\n@@ -336,0 +363,5 @@\n+        String extraLabel = getProperties().get(\"extra_label\");\n+        if (extraLabel != null) {\n+            result.add(extraLabel);\n+        }\n+\n@@ -337,5 +369,14 @@\n-        \/\/ Set the \"label\" property of the input node, so that by default\n-        \/\/ search is done on the node label (without line breaks). See also\n-        \/\/ class NodeQuickSearch in the View module.\n-        String label = inputNode.getProperties().resolveString(diagram.getNodeText());\n-        inputNode.getProperties().setProperty(\"label\", label.replaceAll(\"\\\\R\", \" \"));\n+        \/\/ Set the \"label\" property of the input node (and the slots' source\n+        \/\/ nodes), so that by default search is done on their labels (without\n+        \/\/ line breaks). See also class NodeQuickSearch in the View module.\n+        setLabelProperty(inputNode, null);\n+        for (InputSlot is : getInputSlots()) {\n+            for (InputNode in : is.getSource().getSourceNodes()) {\n+                setLabelProperty(in, is.shouldShowName() ? is.getShortName() : null);\n+            }\n+        }\n+        for (OutputSlot os : getOutputSlots()) {\n+            for (InputNode on : os.getSource().getSourceNodes()) {\n+                setLabelProperty(on, os.shouldShowName() ? os.getShortName() : null);\n+            }\n+        }\n@@ -348,0 +389,9 @@\n+    private void setLabelProperty(InputNode n, String shortName) {\n+        String label = n.getProperties().resolveString(diagram.getNodeText());\n+        String singleLineLabel = label.replaceAll(\"\\\\R\", \" \");\n+        if (shortName != null) {\n+            singleLineLabel += \" [\" + shortName + \"]\";\n+        }\n+        n.getProperties().setProperty(\"label\", singleLineLabel);\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/Figure.java","additions":59,"deletions":9,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-               .append(getInputSlot().getPosition())\n+               .append(getInputSlot().getOriginalIndex())\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/FigureConnection.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+    private int originalIndex;\n+\n@@ -37,0 +39,1 @@\n+        this.originalIndex = -1;\n@@ -50,0 +53,17 @@\n+\n+    public int getOriginalIndex() {\n+        return originalIndex;\n+    }\n+\n+    public void setOriginalIndex(int originalIndex) {\n+        this.originalIndex = originalIndex;\n+    }\n+\n+    public int gapSize() {\n+        int index = getPosition();\n+        int originalIndex = getOriginalIndex();\n+        InputSlot prevSlot = index > 0 ? getFigure().getInputSlots().get(index - 1) : null;\n+        int prevOriginalIndex = index > 0 ? prevSlot.getOriginalIndex() : -1;\n+        return originalIndex - prevOriginalIndex - 1;\n+    }\n+\n@@ -59,0 +79,5 @@\n+    @Override\n+    public String getToolTipText() {\n+        return super.getToolTipText() + \" [\" + originalIndex + \"]\";\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/InputSlot.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.util.ArrayList;\n@@ -34,2 +35,1 @@\n-    private Selector selector1;\n-    private Selector selector2;\n+    private Selector[] selectors;\n@@ -37,4 +37,2 @@\n-    \/** Creates a new instance of OrSelector *\/\n-    public OrSelector(Selector s1, Selector s2) {\n-        this.selector1 = s1;\n-        this.selector2 = s2;\n+    public OrSelector(Selector[] selectors) {\n+        this.selectors = selectors;\n@@ -45,7 +43,6 @@\n-\n-        List<Figure> l1 = selector1.selected(d);\n-        List<Figure> l2 = selector2.selected(d);\n-\n-        for (Figure f : l2) {\n-            if (!l1.contains(f)) {\n-                l1.add(f);\n+        List<Figure> result = new ArrayList<>();\n+        for (Selector s : selectors) {\n+            for (Figure f : s.selected(d)) {\n+                if (!result.contains(f)) {\n+                    result.add(f);\n+                }\n@@ -54,2 +51,1 @@\n-\n-        return l1;\n+        return result;\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/main\/java\/com\/sun\/hotspot\/igv\/graph\/OrSelector.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -49,0 +49,10 @@\n+## Defining Custom Filters\n+\n+IGV has a powerful filter mechanism with which nodes and blocks can be colored,\n+hidden, updated, etc. according to user-defined rules. Filters are programmed in\n+JavaScript using a set of predefined primitives and auxiliary functions. For\n+more information, see the documentation in\n+`Filter\/src\/main\/resources\/com\/sun\/hotspot\/igv\/filter\/helper.js` and the default\n+filters in\n+`ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters`.\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/README.md","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -13,5 +13,5 @@\n-colorize(\"category\", \"data\", dataNodeColor);\n-colorize(\"category\", \"memory\", memoryNodeColor);\n-colorize(\"category\", \"mixed\", mixedNodeColor);\n-colorize(\"category\", \"control\", controlNodeColor);\n-colorize(\"category\", \"other\", otherNodeColor);\n+colorize(matches(\"category\", \"data\"), dataNodeColor);\n+colorize(matches(\"category\", \"memory\"), memoryNodeColor);\n+colorize(matches(\"category\", \"mixed\"), mixedNodeColor);\n+colorize(matches(\"category\", \"control\"), controlNodeColor);\n+colorize(matches(\"category\", \"other\"), otherNodeColor);\n@@ -20,5 +20,5 @@\n-f.addRule(new ColorFilter.ColorRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"data\")), null, dataEdgeColor, null));\n-f.addRule(new ColorFilter.ColorRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"memory\")), null, memoryEdgeColor, null));\n-f.addRule(new ColorFilter.ColorRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"mixed\")), null, mixedEdgeColor, null));\n-f.addRule(new ColorFilter.ColorRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"control\")), null, controlEdgeColor, null));\n-f.addRule(new ColorFilter.ColorRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"other\")), null, otherEdgeColor, null));\n+f.addRule(new ColorFilter.ColorRule(matches(\"category\", \"data\"), null, dataEdgeColor, null));\n+f.addRule(new ColorFilter.ColorRule(matches(\"category\", \"memory\"), null, memoryEdgeColor, null));\n+f.addRule(new ColorFilter.ColorRule(matches(\"category\", \"mixed\"), null, mixedEdgeColor, null));\n+f.addRule(new ColorFilter.ColorRule(matches(\"category\", \"control\"), null, controlEdgeColor, null));\n+f.addRule(new ColorFilter.ColorRule(matches(\"category\", \"other\"), null, otherEdgeColor, null));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/color.filter","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/\/ Condense the graph without information loss and make the structure of the\n+\/\/ intermediate representation more explicit. This filter is most effective in\n+\/\/ combination with \"Simplify graph\".\n+\n+\/\/ Pretty-print Bool nodes to be shown as output slots.\n+function replaceComparisonWithSign(dump_spec) {\n+  var comparison = dump_spec.replace('[','').replace(']','')\n+  switch (comparison) {\n+    case \"eq\":  return \"=\";\n+    case \"gt\":  return \">\";\n+    case \"lt\":  return \"<\";\n+    case \"ne\":  return \"≠\";\n+    case \"le\":  return \"≤\";\n+    case \"ge\":  return \"≥\";\n+    default:    return comparison;\n+  }\n+}\n+editSameProperty(matches(\"name\", \"Bool\"), \"dump_spec\", replaceComparisonWithSign);\n+\n+\/\/ Add a more informative text for null-pointer input slots.\n+editSameProperty(and([matches(\"name\", \"ConP|ConN\"), matches(\"dump_spec\", \"#.*NULL\")]),\n+                 \"short_name\",\n+                 function(t) {return \"null\";});\n+\n+\/\/ Pretty-print CatchProj nodes.\n+function catchProjShortText(con) {\n+  switch (con) {\n+    case \"0\": return \"F\"; \/\/ fall-through\n+    case \"1\": return \"T\"; \/\/ throw\n+    default:  return \"?\";\n+  }\n+}\n+editProperty(matches(\"name\", \"CatchProj\"), \"con\", \"short_name\", catchProjShortText);\n+\n+\/\/ Add short text to inlined Mach data parameters.\n+editProperty(and([matches(\"name\", \"MachProj\"),\n+                  matches(\"category\", \"data\"),\n+                  successorOf(matches(\"name\", \"Start\"))]),\n+             \"dump_spec\", \"short_name\",\n+             function(dump_spec) {return dump_spec;});\n+\n+\/\/ Condense inputs in all nodes.\n+var anyNode = matches(\"name\", \".*\");\n+removeEmptySlots(anyNode);\n+\n+\/\/ Inline (\"split\") Parm and start MachProj nodes, except control ones.\n+split(and([matches(\"name\", \"Parm|MachProj\"),\n+           not(matches(\"category\", \"control\")),\n+           successorOf(matches(\"name\", \"Start\"))]),\n+      [\"[short_name]\"]);\n+\n+\/\/ Combine single-input nodes.\n+combine(anyNode, matches(\"name\", \"Proj|IfFalse|IfTrue|JProj|MachProj|JumpProj|CatchProj|Parm\"));\n+combine(anyNode, matches(\"name\", \"SCMemProj\"), [\"SCM\"]);\n+combine(matches(\"name\", \"SubTypeCheck|Cmp.*\"), matches(\"name\", \"Bool\"), [\"[dump_spec]\"]);\n+combine(anyNode, matches(\"name\", \"Decode(N|NarrowPtr|NKlass)\"), [\"DC\"]);\n+combine(anyNode, matches(\"name\", \"Conv2B\"), [\"2B\"]);\n+combine(anyNode, matches(\"name\", \"Conv[LFD]2I\"), [\"2I\"]);\n+combine(anyNode, matches(\"name\", \"Conv[IFD]2L\"), [\"2L\"]);\n+combine(anyNode, matches(\"name\", \"Conv[ILD]2F\"), [\"2F\"]);\n+combine(anyNode, matches(\"name\", \"Conv[ILF]2D\"), [\"2D\"]);\n+\n+\/\/ Inline (\"split\") constant nodes.\n+split(matches(\"name\", \"MachTemp\"), [\"T\"]);\n+split(matches(\"name\", \"ThreadLocal\"), [\"TL\"]);\n+split(matches(\"name\", \"(Con[A-Z]?)|ConNKlass|(loadCon.*)\"), [\"[short_name]\", \"[name]\"]);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/condenseGraph.filter","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/\/ This filter add a new line to the label of selected nodes with custom\n+\/\/ information. This is achieved by adding a special property 'extra_label' to\n+\/\/ them with information extracted from other properties, typically 'dump_spec'.\n+\n+\/\/ Add extra line to method calls with callee information.\n+function callJavaInfo(dump_spec, regularPos, trapPos) {\n+  dump_components = split_string(dump_spec);\n+  if (dump_components.length < (trapPos + 1)) {\n+    return null;\n+  }\n+  var tm = \/(uncommon_trap\\(reason=\\'(\\w*)\\')\/.exec(dump_components[trapPos]);\n+  if (tm == null || typeof tm[2] == 'undefined') {\n+    return dump_components[regularPos];\n+  }\n+  return \"trap: \" + tm[2];\n+}\n+editProperty(matches(\"name\", \"CallStaticJava|CallDynamicJava|CallJava\"), \"dump_spec\", \"extra_label\",\n+             function(dump_spec) {return callJavaInfo(dump_spec, 2, 2);});\n+editProperty(matches(\"name\", \"CallStaticJavaDirect|CallDynamicJavaDirect\"), \"dump_spec\", \"extra_label\",\n+             function(dump_spec) {return callJavaInfo(dump_spec, 1, 3);});\n+\n+function callLeafInfo(dump_spec, pos) {\n+  dump_components = split_string(dump_spec);\n+  if (dump_components.length < pos + 1) {\n+    return null;\n+  }\n+  return dump_components[pos];\n+}\n+editProperty(matches(\"name\", \"CallLeaf|CallLeafNoFP\"), \"dump_spec\", \"extra_label\",\n+             function(dump_spec) {return callLeafInfo(dump_spec, 1);});\n+editProperty(matches(\"name\", \"CallLeafDirect|CallLeafDirectVector|CallLeafNoFPDirect\"), \"dump_spec\", \"extra_label\",\n+             function(dump_spec) {return callLeafInfo(dump_spec, 0);});\n+\n+\/\/ Add extra line to exception creation nodes with the name of the exception.\n+function exceptionInfo(dump_spec) {\n+  dump_spec2 = dump_spec.replace('#','')\n+  dump_components = split_string(dump_spec2);\n+  if (dump_components.length < 1) {\n+    return null;\n+  }\n+  \/\/ dump_components[0] has a form like e.g. java\/lang\/NumberFormatException:NotNull,\n+  \/\/ we want to return only the simple class name (\"NumberFormatException\").\n+  simple_classname = dump_components[0].split(\"\/\").pop();\n+  return simple_classname.split(\":\")[0];\n+}\n+editProperty(matches(\"name\", \"CreateEx|CreateException\"), \"dump_spec\", \"extra_label\", exceptionInfo);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/customNodeInfo.filter","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -1,3 +1,1 @@\n-var f = new RemoveFilter(\"Hide control subgraph\");\n-f.addRule(new RemoveFilter.RemoveRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"control\"))));\n-f.apply(graph);\n+remove(matches(\"category\", \"control\"));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideControl.filter","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,5 +1,1 @@\n-var f = new ConnectionFilter(\"Hide control edges\");\n-f.addRule(new ConnectionFilter.ConnectionStyleRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"control\")),\n-                                                   white,\n-                                                   Connection.ConnectionStyle.INVISIBLE));\n-f.apply(graph);\n+styleOutputConnections(matches(\"category\", \"control\"), white, invisibleConnection);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideControlEdges.filter","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,3 +1,1 @@\n-var f = new RemoveFilter(\"Hide data subgraph\");\n-f.addRule(new RemoveFilter.RemoveRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"data\"))));\n-f.apply(graph);\n+remove(matches(\"category\", \"data\"));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideData.filter","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,5 +1,1 @@\n-var f = new ConnectionFilter(\"Hide data edges\");\n-f.addRule(new ConnectionFilter.ConnectionStyleRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"data\")),\n-                                                   white,\n-                                                   Connection.ConnectionStyle.INVISIBLE));\n-f.apply(graph);\n+styleOutputConnections(matches(\"category\", \"data\"), white, invisibleConnection);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideDataEdges.filter","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,17 +2,1 @@\n-\n-var f = new RemoveBlockFilter(\"Hide exception blocks\");\n-f.addRule(\n-  new RemoveBlockFilter.RemoveBlockRule(\n-    new AnySelector(\n-      new OrSelector(\n-        new MatcherSelector(\n-          new Properties.StringPropertyMatcher(\"name\", \"Rethrow\")\n-        ),\n-        new MatcherSelector(\n-          new Properties.StringPropertyMatcher(\"name\", \"RethrowException\")\n-        )\n-      )\n-    )\n-  )\n-);\n-f.apply(graph);\n+removeBlock(hasAnyNode(matches(\"name\", \"Rethrow|RethrowException\")));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideExceptionBlocks.filter","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,3 +1,1 @@\n-var f = new RemoveFilter(\"Hide memory subgraph\");\n-f.addRule(new RemoveFilter.RemoveRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"memory\"))));\n-f.apply(graph);\n+remove(matches(\"category\", \"memory\"));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideMemory.filter","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,5 +1,1 @@\n-var f = new ConnectionFilter(\"Hide memory edges\");\n-f.addRule(new ConnectionFilter.ConnectionStyleRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"memory\")),\n-                                                   white,\n-                                                   Connection.ConnectionStyle.INVISIBLE));\n-f.apply(graph);\n+styleOutputConnections(matches(\"category\", \"memory\"), white, invisibleConnection);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideMemoryEdges.filter","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,3 +1,1 @@\n-var f = new RemoveFilter(\"Hide mixed subgraph\");\n-f.addRule(new RemoveFilter.RemoveRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"mixed\"))));\n-f.apply(graph);\n+remove(matches(\"category\", \"mixed\"));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideMixed.filter","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,5 +1,1 @@\n-var f = new ConnectionFilter(\"Hide mixed edges\");\n-f.addRule(new ConnectionFilter.ConnectionStyleRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"mixed\")),\n-                                                   white,\n-                                                   Connection.ConnectionStyle.INVISIBLE));\n-f.apply(graph);\n+styleOutputConnections(matches(\"category\", \"mixed\"), white, invisibleConnection);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideMixedEdges.filter","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,3 +1,1 @@\n-var f = new RemoveFilter(\"Hide other subgraph\");\n-f.addRule(new RemoveFilter.RemoveRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"other\"))));\n-f.apply(graph);\n+remove(matches(\"category\", \"other\"));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideOther.filter","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,5 +1,1 @@\n-var f = new ConnectionFilter(\"Hide other edges\");\n-f.addRule(new ConnectionFilter.ConnectionStyleRule(new MatcherSelector(new Properties.StringPropertyMatcher(\"category\", \"other\")),\n-                                                   white,\n-                                                   Connection.ConnectionStyle.INVISIBLE));\n-f.apply(graph);\n+styleOutputConnections(matches(\"category\", \"other\"), white, invisibleConnection);\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideOtherEdges.filter","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,12 +2,1 @@\n-\n-var f = new RemoveBlockFilter(\"Hide root block\");\n-f.addRule(\n-  new RemoveBlockFilter.RemoveBlockRule(\n-    new AnySelector(\n-      new MatcherSelector(\n-        new Properties.RegexpPropertyMatcher(\"name\", \"Root\")\n-      )\n-    )\n-  )\n-);\n-f.apply(graph);\n+removeBlock(hasAnyNode(matches(\"name\", \"Root\")));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideRootBlock.filter","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,12 +2,1 @@\n-\n-var f = new RemoveBlockFilter(\"Hide uncommon trap blocks\");\n-f.addRule(\n-  new RemoveBlockFilter.RemoveBlockRule(\n-    new AnySelector(\n-      new MatcherSelector(\n-        new Properties.RegexpPropertyMatcher(\"dump_spec\", \".*uncommon_trap.*\")\n-      )\n-    )\n-  )\n-);\n-f.apply(graph);\n+removeBlock(hasAnyNode(matches(\"dump_spec\", \".*uncommon_trap.*\")));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/hideUncommonTrapBlocks.filter","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,25 +3,4 @@\n-\n-var f = new RemoveFilter(\"Show only control flow\");\n-f.addRule(\n-  new RemoveFilter.RemoveRule(\n-    new InvertSelector(\n-      new OrSelector(\n-        new MatcherSelector(\n-          new Properties.RegexpPropertyMatcher(\"category\", \"control|mixed\")\n-        ),\n-        new AndSelector(\n-          new SuccessorSelector(\n-            new MatcherSelector(\n-              new Properties.RegexpPropertyMatcher(\"type\", \"control\")\n-            )\n-          ),\n-          new MatcherSelector(\n-            new Properties.RegexpPropertyMatcher(\"type\", \"bottom\")\n-          )\n-        )\n-      )\n-    ),\n-    false\n-  )\n-);\n-f.apply(graph);\n\\ No newline at end of file\n+remove(not(or([matches(\"name\", \"Root\"),\n+               matches(\"category\", \"control|mixed\"),\n+               and([matches(\"type\", \"bottom\"),\n+                    successorOf(matches(\"type\", \"control\"))])])));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/onlyControlFlow.filter","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,16 @@\n+\/\/ Hide graph elements that are typically (but not always) unnecessary to\n+\/\/ analyze the intermediate representation. This filter is most effective in\n+\/\/ combination with \"Condense graph\".\n+\n+\/\/ Remove self-loops (typical for region-like control nodes).\n+removeSelfLoops();\n+\n+\/\/ Hide secondary edges.\n+remove(matches(\"short_name\", \"FP|RA|IO|RP\"));\n+\n+\/\/ Remove back-edges to the Root node.\n+removeInputs(matches(\"name\", \"Root\"), matches(\"name\", \".*\"));\n+\n+\/\/ Remove top inputs from call-like nodes.\n+removeInputs(matches(\"name\", \"SafePoint|CallStaticJava|CallDynamicJava|CallJava|CallLeaf|CallRuntime|AbstractLock|CallLeafNoFP|Call|CallStaticJavaDirect|Halt|Rethrow|ShouldNotReachHere|RethrowException|Return|Ret|MergeMem|Initialize|MemBarAcquire|MemBarRelease|Unlock|Lock|Allocate|AllocateArray\"),\n+             and([matches(\"name\", \"Con\"), matches(\"type\", \"top\")]));\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/simplifyGraph.filter","additions":16,"deletions":0,"binary":false,"changes":16,"status":"added"},{"patch":"@@ -1,19 +0,0 @@\n-\/\/ Hide secondary edges.\n-remove(\"dump_spec\", \"FramePtr|ReturnAdr|I_O\");\n-removeInputs(\"name\", \"Root\");\n-var f = new RemoveSelfLoopsFilter(\"Remove Self-Loops\");\n-f.apply(graph);\n-removeInputs(\"name\", \"SafePoint|CallStaticJava|CallDynamicJava|CallJava|CallLeaf|CallRuntime|AbstractLock|CallLeafNoFP|Call|CallStaticJavaDirect\", 5);\n-removeInputs(\"name\", \"Unlock|Lock\", 7);\n-removeInputs(\"name\", \"Allocate\", 7);\n-removeInputs(\"name\", \"AllocateArray\", 9);\n-\n-\/\/ Combine projection nodes.\n-var f = new CombineFilter(\"Combine Filter\");\n-f.addRule(new CombineFilter.CombineRule(new Properties.RegexpPropertyMatcher(\"name\", \".*\"), new Properties.RegexpPropertyMatcher(\"name\", \"Proj|IfFalse|IfTrue|JProj|MachProj|JumpProj|CatchProj\")));\n-f.addRule(new CombineFilter.CombineRule(new Properties.RegexpPropertyMatcher(\"name\", \"Cmp.*\"), new Properties.RegexpPropertyMatcher(\"name\", \"Bool\")));\n-f.apply(graph);\n-\n-\/\/ Inline (split) constant nodes.\n-split(\"name\", \"BoxLock\");\n-split(\"name\", \"(Con.*)|(loadCon.*)\", \"[dump_spec]\");\n\\ No newline at end of file\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/filters\/structural.filter","additions":0,"deletions":19,"binary":false,"changes":19,"status":"deleted"},{"patch":"@@ -16,1 +16,5 @@\n-        <file name=\"Simplify graph\" url=\"filters\/structural.filter\">\n+        <file name=\"Show custom node info\" url=\"filters\/customNodeInfo.filter\">\n+            <attr name=\"enabled\" boolvalue=\"true\"\/>\n+            <attr name=\"after\" stringvalue=\"Color by execution frequency\"\/>\n+        <\/file>\n+        <file name=\"Simplify graph\" url=\"filters\/simplifyGraph.filter\">\n@@ -18,1 +22,1 @@\n-            <attr name=\"after\" stringvalue=\"Show node warnings\"\/>\n+            <attr name=\"after\" stringvalue=\"Show custom node info\"\/>\n@@ -20,1 +24,1 @@\n-        <file name=\"Hide data subgraph\" url=\"filters\/hideData.filter\">\n+        <file name=\"Condense graph\" url=\"filters\/condenseGraph.filter\">\n@@ -24,0 +28,4 @@\n+        <file name=\"Hide data subgraph\" url=\"filters\/hideData.filter\">\n+            <attr name=\"enabled\" boolvalue=\"false\"\/>\n+            <attr name=\"after\" stringvalue=\"Condense graph\"\/>\n+        <\/file>\n","filename":"src\/utils\/IdealGraphVisualizer\/ServerCompiler\/src\/main\/resources\/com\/sun\/hotspot\/igv\/servercompiler\/layer.xml","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-                setFigureSelection(selectedFigures);\n+                setObjectSelection(selectedFigures);\n@@ -524,1 +524,1 @@\n-                setFigureSelection(Collections.singleton(figure));\n+                setObjectSelection(Collections.singleton(figure));\n@@ -629,1 +629,1 @@\n-        setFigureSelection(model.getSelectedFigures());\n+        setObjectSelection(model.getSelectedFigures());\n@@ -882,1 +882,1 @@\n-        Set<Figure> selectedFigures = new HashSet<>();\n+        Set<Object> selectedObjects = new HashSet<>();\n@@ -885,1 +885,11 @@\n-                selectedFigures.add(figure);\n+                selectedObjects.add(figure);\n+            }\n+            for (InputSlot is : figure.getInputSlots()) {\n+                if (is.hasSourceNodes() && nodeIds.contains(is.getSource().getSourceNodes().get(0).getId())) {\n+                    selectedObjects.add(is);\n+                }\n+            }\n+            for (OutputSlot os : figure.getOutputSlots()) {\n+                if (os.hasSourceNodes() && nodeIds.contains(os.getSource().getSourceNodes().get(0).getId())) {\n+                    selectedObjects.add(os);\n+                }\n@@ -888,1 +898,1 @@\n-        setFigureSelection(selectedFigures);\n+        setObjectSelection(selectedObjects);\n@@ -949,2 +959,2 @@\n-    private void setFigureSelection(Set<Figure> list) {\n-        super.setSelectedObjects(new HashSet<>(list));\n+    private void setObjectSelection(Set<?> selection) {\n+        super.setSelectedObjects(new HashSet<>(selection));\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    private final FilterChain filterSequence;\n@@ -154,0 +155,1 @@\n+            filterSequence = new FilterChain();\n@@ -156,0 +158,1 @@\n+            filterSequence = provider.getSequence();\n@@ -293,4 +296,0 @@\n-    public FilterChain getSequenceFilterChain() {\n-        return filterChain;\n-    }\n-\n@@ -315,1 +314,1 @@\n-        getFilterChain().apply(diagram, getSequenceFilterChain());\n+        getFilterChain().applyInOrder(diagram, filterChain, filterSequence);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.graph.Diagram;\n@@ -27,0 +28,1 @@\n+import com.sun.hotspot.igv.graph.FigureConnection;\n@@ -29,0 +31,5 @@\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics2D;\n+import java.awt.geom.Rectangle2D;\n@@ -39,0 +46,1 @@\n+    private DiagramScene scene;\n@@ -43,0 +51,1 @@\n+        this.scene = scene;\n@@ -61,0 +70,61 @@\n+\n+    @Override\n+    protected void paintWidget() {\n+        super.paintWidget();\n+        if (getScene().getZoomFactor() < TEXT_ZOOM_FACTOR) {\n+            return;\n+        }\n+        \/\/ If there is a gap between the current slot and the previous one, and\n+        \/\/ both are visible, draw a label in between signaling the gap.\n+        int index = inputSlot.getPosition();\n+        int originalIndex = inputSlot.getOriginalIndex();\n+        InputSlot prevSlot = index > 0 ? inputSlot.getFigure().getInputSlots().get(index - 1) : null;\n+        int prevOriginalIndex = index > 0 ? prevSlot.getOriginalIndex() : -1;\n+        if (originalIndex > prevOriginalIndex + 1 &&\n+            hasVisibleConnection(inputSlot) && hasVisibleConnection(prevSlot) &&\n+            !scene.getModel().getShowCFG()) {\n+            Graphics2D g = scene.getGraphics();\n+            String label = \"...\";\n+            g.setColor(Color.BLACK);\n+            g.setFont(Diagram.SLOT_FONT.deriveFont(Font.BOLD));\n+            Rectangle2D labelRect = new Canvas().getFontMetrics(Diagram.SLOT_FONT).getStringBounds(label, g);\n+            int slotWidth = this.calculateClientArea().width;\n+            int xStart = this.getBounds().x + (inputSlot.hasSourceNodes() ? 0 : (slotWidth \/ 2));\n+            int prevXEnd;\n+            if (index > 0) {\n+                \/\/ Compute X coordinates of previous input slot comparing its\n+                \/\/ calculateClientArea() with that of the current slot.\n+                InputSlotWidget prevWidget = (InputSlotWidget)scene.findWidget(prevSlot);\n+                int prevSlotWidth = prevWidget.calculateClientArea().width;\n+                int xStartAbs = inputSlot.getRelativePosition().x - (slotWidth \/ 2);\n+                int prevXStartAbs = prevSlot.getRelativePosition().x - (prevSlotWidth \/ 2);\n+                int prevXStart = prevXStartAbs - xStartAbs;\n+                prevXEnd = prevXStart + (prevSlot.hasSourceNodes() ? prevSlotWidth : (prevSlotWidth \/ 2));\n+            } else {\n+                \/\/ No previous input slot, just set its position to the left of\n+                \/\/ the current one.\n+                prevXEnd = xStart - (int) (labelRect.getWidth()) - 4;\n+            }\n+            int midX = (prevXEnd + xStart) \/ 2;\n+            g.drawString(label, midX - (int)(labelRect.getWidth() \/ 2), 3);\n+        }\n+    }\n+\n+    \/\/ This method needs to be called at painting time, so that the right\n+    \/\/ FigureWidget::isVisible() result is picked up.\n+    private boolean hasVisibleConnection(InputSlot slot) {\n+        if (slot == null) {\n+            return true;\n+        }\n+        if (slot.hasSourceNodes()) {\n+            return true;\n+        }\n+        for (FigureConnection c : slot.getConnections()) {\n+            Figure f = c.getOutputSlot().getFigure();\n+            FigureWidget fw = (FigureWidget)scene.findWidget(f);\n+            if (fw.isVisible()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/InputSlotWidget.java","additions":71,"deletions":1,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,2 @@\n-    private static double TEXT_ZOOM_FACTOR = 0.9;\n-    private static double ZOOM_FACTOR = 0.6;\n+    protected static double TEXT_ZOOM_FACTOR = 0.9;\n+    protected static double ZOOM_FACTOR = 0.6;\n@@ -61,1 +61,2 @@\n-        this.setCheckClipping(true);\n+        \/\/ No clipping, to let input slots draw gap markers outside their bounds.\n+        this.setCheckClipping(false);\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/SlotWidget.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}