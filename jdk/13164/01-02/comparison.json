{"files":[{"patch":"@@ -200,3 +200,11 @@\n- * Note that due to limited ABI specification coverage, none of the native linker implementations supports\n- * packed structs (those that lack the padding needed to align their fields) or structs with excess padding\n- * (more than is required to align a field) being passed by value.\n+ * Due to limited ABI specification coverage, all the native linker implementations limit the function\n+ * descriptors that they support to those that contain only so-called <em>canonical<\/em> layouts. These layouts\n+ * have the following restrictions:\n+ * <ol>\n+ * <li>The layout must have its alignment constraint set to its <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a><\/li>\n+ * <li>If the layout is a {@link ValueLayout}, it must have a {@linkplain ValueLayout#order() byte order} that matches\n+ * the {@linkplain ByteOrder#nativeOrder() native byte order}<\/li>\n+ * <li>If the layout is a {@link GroupLayout}, its size must be a multiple of its alignment constraint<\/li>\n+ * <li>If the layout is a {@link GroupLayout}, it must not contain excess padding. Padding is considered excess if it is\n+ * not strictly required to align a non-padding layout, or to satisfy constraint 3<\/li>\n+ * <\/ol>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import java.lang.foreign.UnionLayout;\n@@ -113,2 +114,2 @@\n-        descriptor.returnLayout().ifPresent(l -> checkLayoutsRecursive(l, 0, 0));\n-        descriptor.argumentLayouts().forEach(l -> checkLayoutsRecursive(l, 0, 0));\n+        descriptor.returnLayout().ifPresent(this::checkLayoutsRecursive);\n+        descriptor.argumentLayouts().forEach(this::checkLayoutsRecursive);\n@@ -117,1 +118,1 @@\n-    private void checkLayoutsRecursive(MemoryLayout layout, long lastUnpaddedOffset , long offset) {\n+    private void checkLayoutsRecursive(MemoryLayout layout) {\n@@ -119,1 +120,0 @@\n-        checkOffset(layout, lastUnpaddedOffset, offset);\n@@ -121,10 +121,12 @@\n-        if (layout instanceof GroupLayout gl) {\n-            checkGroupSize(gl);\n-            for (MemoryLayout member : gl.memberLayouts()) {\n-                checkLayoutsRecursive(member, lastUnpaddedOffset, offset);\n-\n-                if (gl instanceof StructLayout) {\n-                    offset += member.bitSize();\n-                    if (!(member instanceof PaddingLayout)) {\n-                        lastUnpaddedOffset = offset;\n-                    }\n+        if (layout instanceof StructLayout sl) {\n+            long offset = 0;\n+            long lastUnpaddedOffset = 0;\n+            for (MemoryLayout member : sl.memberLayouts()) {\n+                \/\/ check element offset before recursing so that an error points at the\n+                \/\/ outermost layout first\n+                checkMemberOffset(sl, member, lastUnpaddedOffset, offset);\n+                checkLayoutsRecursive(member);\n+\n+                offset += member.bitSize();\n+                if (!(member instanceof PaddingLayout)) {\n+                    lastUnpaddedOffset = offset;\n@@ -133,0 +135,10 @@\n+            checkGroupSize(sl, lastUnpaddedOffset);\n+        } else if (layout instanceof UnionLayout ul) {\n+            long maxUnpaddedLayout = 0;\n+            for (MemoryLayout member : ul.memberLayouts()) {\n+                checkLayoutsRecursive(member);\n+                if (!(member instanceof PaddingLayout)) {\n+                    maxUnpaddedLayout = Long.max(maxUnpaddedLayout, member.bitSize());\n+                }\n+            }\n+            checkGroupSize(ul, maxUnpaddedLayout);\n@@ -134,1 +146,1 @@\n-            checkLayoutsRecursive(sl.elementLayout(), lastUnpaddedOffset, offset);\n+            checkLayoutsRecursive(sl.elementLayout());\n@@ -139,3 +151,5 @@\n-    private static void checkGroupSize(GroupLayout gl) {\n-        if (gl.bitSize() % gl.bitAlignment() != 0) {\n-            throw new IllegalArgumentException(\"Layout lacks trailing padding: \" + gl);\n+    private static void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n+        long expectedSize = Utils.alignUp(maxUnpaddedOffset, gl.bitAlignment());\n+        if (gl.bitSize() != expectedSize) {\n+            throw new IllegalArgumentException(\"Layout '\" + gl + \"' has unexpected size: \"\n+                    + gl.bitSize() + \" != \" + expectedSize);\n@@ -145,2 +159,1 @@\n-    \/\/ checks both that a layout is aligned within the root,\n-    \/\/ and also that there is no excess padding between it and\n+    \/\/ checks both that there is no excess padding between 'memberLayout' and\n@@ -148,2 +161,3 @@\n-    private static void checkOffset(MemoryLayout layout, long lastUnpaddedOffset, long offset) {\n-        long expectedOffset = Utils.alignUp(lastUnpaddedOffset, layout.bitAlignment());\n+    private static void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n+                                          long lastUnpaddedOffset, long offset) {\n+        long expectedOffset = Utils.alignUp(lastUnpaddedOffset, memberLayout.bitAlignment());\n@@ -151,1 +165,1 @@\n-            throw new IllegalArgumentException(\"Layout '\" + layout + \"'\" +\n+            throw new IllegalArgumentException(\"Member layout '\" + memberLayout + \"', of '\" + parent + \"'\" +\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":37,"deletions":23,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -194,1 +194,7 @@\n-                    \"Layout lacks trailing padding\"\n+                    \"has unexpected size\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_INT,\n+                            MemoryLayout.paddingLayout(32))), \/\/ too much trailing padding\n+                    \"has unexpected size\"\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"}]}