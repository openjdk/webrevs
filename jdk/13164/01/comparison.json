{"files":[{"patch":"@@ -37,0 +37,1 @@\n+import java.nio.ByteOrder;\n@@ -198,0 +199,4 @@\n+ * <p>\n+ * Note that due to limited ABI specification coverage, none of the native linker implementations supports\n+ * packed structs (those that lack the padding needed to align their fields) or structs with excess padding\n+ * (more than is required to align a field) being passed by value.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -43,0 +44,1 @@\n+import java.lang.foreign.PaddingLayout;\n@@ -44,0 +46,2 @@\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -46,0 +50,1 @@\n+import java.nio.ByteOrder;\n@@ -65,1 +70,1 @@\n-        checkHasNaturalAlignment(function);\n+        checkLayouts(function);\n@@ -83,1 +88,1 @@\n-        checkHasNaturalAlignment(function);\n+        checkLayouts(function);\n@@ -104,6 +109,6 @@\n-    \/\/ Current limitation of the implementation:\n-    \/\/ We don't support packed structs on some platforms,\n-    \/\/ so reject them here explicitly\n-    private static void checkHasNaturalAlignment(FunctionDescriptor descriptor) {\n-        descriptor.returnLayout().ifPresent(AbstractLinker::checkHasNaturalAlignmentRecursive);\n-        descriptor.argumentLayouts().forEach(AbstractLinker::checkHasNaturalAlignmentRecursive);\n+    \/** {@return byte order used by this linker} *\/\n+    protected abstract ByteOrder linkerByteOrder();\n+\n+    private void checkLayouts(FunctionDescriptor descriptor) {\n+        descriptor.returnLayout().ifPresent(l -> checkLayoutsRecursive(l, 0, 0));\n+        descriptor.argumentLayouts().forEach(l -> checkLayoutsRecursive(l, 0, 0));\n@@ -112,1 +117,1 @@\n-    private static void checkHasNaturalAlignmentRecursive(MemoryLayout layout) {\n+    private void checkLayoutsRecursive(MemoryLayout layout, long lastUnpaddedOffset , long offset) {\n@@ -114,0 +119,2 @@\n+        checkOffset(layout, lastUnpaddedOffset, offset);\n+        checkByteOrder(layout);\n@@ -115,0 +122,1 @@\n+            checkGroupSize(gl);\n@@ -116,1 +124,8 @@\n-                checkHasNaturalAlignmentRecursive(member);\n+                checkLayoutsRecursive(member, lastUnpaddedOffset, offset);\n+\n+                if (gl instanceof StructLayout) {\n+                    offset += member.bitSize();\n+                    if (!(member instanceof PaddingLayout)) {\n+                        lastUnpaddedOffset = offset;\n+                    }\n+                }\n@@ -119,1 +134,19 @@\n-            checkHasNaturalAlignmentRecursive(sl.elementLayout());\n+            checkLayoutsRecursive(sl.elementLayout(), lastUnpaddedOffset, offset);\n+        }\n+    }\n+\n+    \/\/ check for trailing padding\n+    private static void checkGroupSize(GroupLayout gl) {\n+        if (gl.bitSize() % gl.bitAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Layout lacks trailing padding: \" + gl);\n+        }\n+    }\n+\n+    \/\/ checks both that a layout is aligned within the root,\n+    \/\/ and also that there is no excess padding between it and\n+    \/\/ the previous layout\n+    private static void checkOffset(MemoryLayout layout, long lastUnpaddedOffset, long offset) {\n+        long expectedOffset = Utils.alignUp(lastUnpaddedOffset, layout.bitAlignment());\n+        if (expectedOffset != offset) {\n+            throw new IllegalArgumentException(\"Layout '\" + layout + \"'\" +\n+                    \" found at unexpected offset: \" + offset + \" != \" + expectedOffset);\n@@ -128,0 +161,7 @@\n+\n+    private void checkByteOrder(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout vl\n+                && vl.order() != linkerByteOrder()) {\n+            throw new IllegalArgumentException(\"Layout does not have the right byte order: \" + layout);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":51,"deletions":11,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.ByteOrder;\n@@ -63,0 +64,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.ByteOrder;\n@@ -63,0 +64,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.ByteOrder;\n@@ -60,0 +61,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.nio.ByteOrder;\n@@ -120,0 +121,5 @@\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.nativeOrder();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.ByteOrder;\n@@ -59,0 +60,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.ByteOrder;\n@@ -61,0 +62,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.nio.ByteOrder;\n@@ -60,0 +61,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                    e.getMessage() + \" != \" + expectedExceptionMessage);\n+                    e.getMessage() + \" does not contain \" + expectedExceptionMessage);\n@@ -157,0 +157,39 @@\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            C_CHAR.withName(\"x\"),\n+                            C_INT.withName(\"y\"), \/\/ not aligned\n+                            MemoryLayout.paddingLayout(24))),\n+                    \"unexpected offset\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_INT,\n+                            ValueLayout.ADDRESS, \/\/ not aligned\n+                            MemoryLayout.paddingLayout(32))),\n+                    \"unexpected offset\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_INT,\n+                            MemoryLayout.paddingLayout(32), \/\/ no excess padding\n+                            ValueLayout.JAVA_INT)),\n+                    \"unexpected offset\"\n+            },\n+            {\n+                    FunctionDescriptor.of(C_INT.withOrder(nonNativeOrder())),\n+                    \"Layout does not have the right byte order\"\n+            },\n+            {\n+                    FunctionDescriptor.of(MemoryLayout.structLayout(C_INT.withOrder(nonNativeOrder()))),\n+                    \"Layout does not have the right byte order\"\n+            },\n+            {\n+                    FunctionDescriptor.of(MemoryLayout.structLayout(MemoryLayout.sequenceLayout(C_INT.withOrder(nonNativeOrder())))),\n+                    \"Layout does not have the right byte order\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_LONG,\n+                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n+                    \"Layout lacks trailing padding\"\n+            },\n@@ -160,0 +199,6 @@\n+    private static ByteOrder nonNativeOrder() {\n+        return ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                ? ByteOrder.BIG_ENDIAN\n+                : ByteOrder.LITTLE_ENDIAN;\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":46,"deletions":1,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-        C_INT.withName(\"p2\")\n+        C_INT.withName(\"p2\"),\n+        MemoryLayout.paddingLayout(32)\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}