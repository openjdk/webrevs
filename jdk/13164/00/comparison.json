{"files":[{"patch":"@@ -37,0 +37,1 @@\n+import java.nio.ByteOrder;\n@@ -198,0 +199,4 @@\n+ * <p>\n+ * Note that due to limited ABI specification coverage, none of the native linker implementations supports\n+ * packed structs (those that lack the padding needed to align their fields) or structs with excess padding\n+ * (more than is required to align a field) being passed by value.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -43,0 +44,1 @@\n+import java.lang.foreign.PaddingLayout;\n@@ -44,0 +46,1 @@\n+import java.lang.foreign.StructLayout;\n@@ -109,3 +112,0 @@\n-    \/\/ Current limitation of the implementation:\n-    \/\/ We don't support packed structs on some platforms,\n-    \/\/ so reject them here explicitly\n@@ -113,2 +113,2 @@\n-        descriptor.returnLayout().ifPresent(this::checkLayoutsRecursive);\n-        descriptor.argumentLayouts().forEach(this::checkLayoutsRecursive);\n+        descriptor.returnLayout().ifPresent(l -> checkLayoutsRecursive(l, 0, 0));\n+        descriptor.argumentLayouts().forEach(l -> checkLayoutsRecursive(l, 0, 0));\n@@ -117,1 +117,1 @@\n-    private void checkLayoutsRecursive(MemoryLayout layout) {\n+    private void checkLayoutsRecursive(MemoryLayout layout, long lastUnpaddedOffset , long offset) {\n@@ -119,0 +119,1 @@\n+        checkOffset(layout, lastUnpaddedOffset, offset);\n@@ -121,0 +122,1 @@\n+            checkGroupSize(gl);\n@@ -122,1 +124,8 @@\n-                checkLayoutsRecursive(member);\n+                checkLayoutsRecursive(member, lastUnpaddedOffset, offset);\n+\n+                if (gl instanceof StructLayout) {\n+                    offset += member.bitSize();\n+                    if (!(member instanceof PaddingLayout)) {\n+                        lastUnpaddedOffset = offset;\n+                    }\n+                }\n@@ -125,1 +134,19 @@\n-            checkLayoutsRecursive(sl.elementLayout());\n+            checkLayoutsRecursive(sl.elementLayout(), lastUnpaddedOffset, offset);\n+        }\n+    }\n+\n+    \/\/ check for trailing padding\n+    private static void checkGroupSize(GroupLayout gl) {\n+        if (gl.bitSize() % gl.bitAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Layout lacks trailing padding: \" + gl);\n+        }\n+    }\n+\n+    \/\/ checks both that a layout is aligned within the root,\n+    \/\/ and also that there is no excess padding between it and\n+    \/\/ the previous layout\n+    private static void checkOffset(MemoryLayout layout, long lastUnpaddedOffset, long offset) {\n+        long expectedOffset = Utils.alignUp(lastUnpaddedOffset, layout.bitAlignment());\n+        if (expectedOffset != offset) {\n+            throw new IllegalArgumentException(\"Layout '\" + layout + \"'\" +\n+                    \" found at unexpected offset: \" + offset + \" != \" + expectedOffset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                    e.getMessage() + \" != \" + expectedExceptionMessage);\n+                    e.getMessage() + \" does not contain \" + expectedExceptionMessage);\n@@ -157,0 +157,21 @@\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            C_CHAR.withName(\"x\"),\n+                            C_INT.withName(\"y\"), \/\/ not aligned\n+                            MemoryLayout.paddingLayout(24))),\n+                    \"unexpected offset\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_INT,\n+                            ValueLayout.ADDRESS, \/\/ not aligned\n+                            MemoryLayout.paddingLayout(32))),\n+                    \"unexpected offset\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_INT,\n+                            MemoryLayout.paddingLayout(32), \/\/ no excess padding\n+                            ValueLayout.JAVA_INT)),\n+                    \"unexpected offset\"\n+            },\n@@ -169,0 +190,6 @@\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_LONG,\n+                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n+                    \"Layout lacks trailing padding\"\n+            },\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-        C_INT.withName(\"p2\")\n+        C_INT.withName(\"p2\"),\n+        MemoryLayout.paddingLayout(32)\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}