{"files":[{"patch":"@@ -37,0 +37,1 @@\n+import java.nio.ByteOrder;\n@@ -198,0 +199,12 @@\n+ * <p>\n+ * Due to limited ABI specification coverage, all the native linker implementations limit the function\n+ * descriptors that they support to those that contain only so-called <em>canonical<\/em> layouts. These layouts\n+ * have the following restrictions:\n+ * <ol>\n+ * <li>The layout must have its alignment constraint set to its <a href=\"MemoryLayout.html#layout-align\">natural alignment<\/a><\/li>\n+ * <li>If the layout is a {@link ValueLayout}, it must have a {@linkplain ValueLayout#order() byte order} that matches\n+ * the {@linkplain ByteOrder#nativeOrder() native byte order}<\/li>\n+ * <li>If the layout is a {@link GroupLayout}, its size must be a multiple of its alignment constraint<\/li>\n+ * <li>If the layout is a {@link GroupLayout}, it must not contain excess padding. Padding is considered excess if it is\n+ * not strictly required to align a non-padding layout, or to satisfy constraint 3<\/li>\n+ * <\/ol>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -43,0 +44,1 @@\n+import java.lang.foreign.PaddingLayout;\n@@ -44,0 +46,3 @@\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.UnionLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -46,0 +51,1 @@\n+import java.nio.ByteOrder;\n@@ -65,1 +71,1 @@\n-        checkHasNaturalAlignment(function);\n+        checkLayouts(function);\n@@ -83,1 +89,1 @@\n-        checkHasNaturalAlignment(function);\n+        checkLayouts(function);\n@@ -104,6 +110,6 @@\n-    \/\/ Current limitation of the implementation:\n-    \/\/ We don't support packed structs on some platforms,\n-    \/\/ so reject them here explicitly\n-    private static void checkHasNaturalAlignment(FunctionDescriptor descriptor) {\n-        descriptor.returnLayout().ifPresent(AbstractLinker::checkHasNaturalAlignmentRecursive);\n-        descriptor.argumentLayouts().forEach(AbstractLinker::checkHasNaturalAlignmentRecursive);\n+    \/** {@return byte order used by this linker} *\/\n+    protected abstract ByteOrder linkerByteOrder();\n+\n+    private void checkLayouts(FunctionDescriptor descriptor) {\n+        descriptor.returnLayout().ifPresent(this::checkLayoutsRecursive);\n+        descriptor.argumentLayouts().forEach(this::checkLayoutsRecursive);\n@@ -112,1 +118,1 @@\n-    private static void checkHasNaturalAlignmentRecursive(MemoryLayout layout) {\n+    private void checkLayoutsRecursive(MemoryLayout layout) {\n@@ -114,3 +120,23 @@\n-        if (layout instanceof GroupLayout gl) {\n-            for (MemoryLayout member : gl.memberLayouts()) {\n-                checkHasNaturalAlignmentRecursive(member);\n+        checkByteOrder(layout);\n+        if (layout instanceof StructLayout sl) {\n+            long offset = 0;\n+            long lastUnpaddedOffset = 0;\n+            for (MemoryLayout member : sl.memberLayouts()) {\n+                \/\/ check element offset before recursing so that an error points at the\n+                \/\/ outermost layout first\n+                checkMemberOffset(sl, member, lastUnpaddedOffset, offset);\n+                checkLayoutsRecursive(member);\n+\n+                offset += member.bitSize();\n+                if (!(member instanceof PaddingLayout)) {\n+                    lastUnpaddedOffset = offset;\n+                }\n+            }\n+            checkGroupSize(sl, lastUnpaddedOffset);\n+        } else if (layout instanceof UnionLayout ul) {\n+            long maxUnpaddedLayout = 0;\n+            for (MemoryLayout member : ul.memberLayouts()) {\n+                checkLayoutsRecursive(member);\n+                if (!(member instanceof PaddingLayout)) {\n+                    maxUnpaddedLayout = Long.max(maxUnpaddedLayout, member.bitSize());\n+                }\n@@ -118,0 +144,1 @@\n+            checkGroupSize(ul, maxUnpaddedLayout);\n@@ -119,1 +146,21 @@\n-            checkHasNaturalAlignmentRecursive(sl.elementLayout());\n+            checkLayoutsRecursive(sl.elementLayout());\n+        }\n+    }\n+\n+    \/\/ check for trailing padding\n+    private static void checkGroupSize(GroupLayout gl, long maxUnpaddedOffset) {\n+        long expectedSize = Utils.alignUp(maxUnpaddedOffset, gl.bitAlignment());\n+        if (gl.bitSize() != expectedSize) {\n+            throw new IllegalArgumentException(\"Layout '\" + gl + \"' has unexpected size: \"\n+                    + gl.bitSize() + \" != \" + expectedSize);\n+        }\n+    }\n+\n+    \/\/ checks both that there is no excess padding between 'memberLayout' and\n+    \/\/ the previous layout\n+    private static void checkMemberOffset(StructLayout parent, MemoryLayout memberLayout,\n+                                          long lastUnpaddedOffset, long offset) {\n+        long expectedOffset = Utils.alignUp(lastUnpaddedOffset, memberLayout.bitAlignment());\n+        if (expectedOffset != offset) {\n+            throw new IllegalArgumentException(\"Member layout '\" + memberLayout + \"', of '\" + parent + \"'\" +\n+                    \" found at unexpected offset: \" + offset + \" != \" + expectedOffset);\n@@ -128,0 +175,7 @@\n+\n+    private void checkByteOrder(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout vl\n+                && vl.order() != linkerByteOrder()) {\n+            throw new IllegalArgumentException(\"Layout does not have the right byte order: \" + layout);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":67,"deletions":13,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.ByteOrder;\n@@ -63,0 +64,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.ByteOrder;\n@@ -63,0 +64,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.ByteOrder;\n@@ -60,0 +61,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import java.nio.ByteOrder;\n@@ -120,0 +121,5 @@\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.nativeOrder();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.nio.ByteOrder;\n@@ -59,0 +60,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/riscv64\/linux\/LinuxRISCV64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.nio.ByteOrder;\n@@ -61,0 +62,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.nio.ByteOrder;\n@@ -60,0 +61,5 @@\n+\n+    @Override\n+    protected ByteOrder linkerByteOrder() {\n+        return ByteOrder.LITTLE_ENDIAN;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                    e.getMessage() + \" != \" + expectedExceptionMessage);\n+                    e.getMessage() + \" does not contain \" + expectedExceptionMessage);\n@@ -157,0 +157,45 @@\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            C_CHAR.withName(\"x\"),\n+                            C_INT.withName(\"y\"), \/\/ not aligned\n+                            MemoryLayout.paddingLayout(24))),\n+                    \"unexpected offset\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_INT,\n+                            ValueLayout.ADDRESS, \/\/ not aligned\n+                            MemoryLayout.paddingLayout(32))),\n+                    \"unexpected offset\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_INT,\n+                            MemoryLayout.paddingLayout(32), \/\/ no excess padding\n+                            ValueLayout.JAVA_INT)),\n+                    \"unexpected offset\"\n+            },\n+            {\n+                    FunctionDescriptor.of(C_INT.withOrder(nonNativeOrder())),\n+                    \"Layout does not have the right byte order\"\n+            },\n+            {\n+                    FunctionDescriptor.of(MemoryLayout.structLayout(C_INT.withOrder(nonNativeOrder()))),\n+                    \"Layout does not have the right byte order\"\n+            },\n+            {\n+                    FunctionDescriptor.of(MemoryLayout.structLayout(MemoryLayout.sequenceLayout(C_INT.withOrder(nonNativeOrder())))),\n+                    \"Layout does not have the right byte order\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_LONG,\n+                            ValueLayout.JAVA_INT)), \/\/ missing trailing padding\n+                    \"has unexpected size\"\n+            },\n+            {\n+                    FunctionDescriptor.ofVoid(MemoryLayout.structLayout(\n+                            ValueLayout.JAVA_INT,\n+                            MemoryLayout.paddingLayout(32))), \/\/ too much trailing padding\n+                    \"has unexpected size\"\n+            },\n@@ -160,0 +205,6 @@\n+    private static ByteOrder nonNativeOrder() {\n+        return ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN\n+                ? ByteOrder.BIG_ENDIAN\n+                : ByteOrder.LITTLE_ENDIAN;\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-        C_INT.withName(\"p2\")\n+        C_INT.withName(\"p2\"),\n+        MemoryLayout.paddingLayout(32)\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}