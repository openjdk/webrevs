{"files":[{"patch":"@@ -35,5 +35,0 @@\n-\/\/ explicit rounding operations are required to implement the strictFP mode\n-enum {\n-  pd_strict_fp_requires_explicit_rounding = false\n-};\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Defs_aarch64.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -410,1 +410,1 @@\n-  set_result(x, round_item(reg));\n+  set_result(x, reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,3 +118,0 @@\n-  \/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-  static const bool strict_fp_requires_explicit_rounding = false;\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/matcher_aarch64.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4513,12 +4513,0 @@\n-\/\/ instruct roundDouble_nop(regD dst) %{\n-\/\/   match(Set dst (RoundDouble dst));\n-\/\/   ins_pipe(empty);\n-\/\/ %}\n-\n-\n-\/\/ instruct roundFloat_nop(regF dst) %{\n-\/\/   match(Set dst (RoundFloat dst));\n-\/\/   ins_pipe(empty);\n-\/\/ %}\n-\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,5 +34,0 @@\n-\/\/ explicit rounding operations are required to implement the strictFP mode\n-enum {\n-  pd_strict_fp_requires_explicit_rounding = false\n-};\n-\n","filename":"src\/hotspot\/cpu\/arm\/c1_Defs_arm.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -104,3 +104,0 @@\n-  \/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-  static const bool strict_fp_requires_explicit_rounding = false;\n-\n","filename":"src\/hotspot\/cpu\/arm\/matcher_arm.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,6 +41,0 @@\n-\/\/ Explicit rounding operations are not required to implement the strictFP mode.\n-enum {\n-  pd_strict_fp_requires_explicit_rounding = false\n-};\n-\n-\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Defs_ppc.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -118,3 +118,0 @@\n-  \/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-  static const bool strict_fp_requires_explicit_rounding = false;\n-\n","filename":"src\/hotspot\/cpu\/ppc\/matcher_ppc.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -9540,22 +9540,0 @@\n-instruct roundDouble_nop(regD dst) %{\n-  match(Set dst (RoundDouble dst));\n-  ins_cost(0);\n-\n-  format %{ \" -- \\t\/\/ RoundDouble not needed - empty\" %}\n-  size(0);\n-  \/\/ PPC results are already \"rounded\" (i.e., normal-format IEEE).\n-  ins_encode( \/*empty*\/ );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n-instruct roundFloat_nop(regF dst) %{\n-  match(Set dst (RoundFloat dst));\n-  ins_cost(0);\n-\n-  format %{ \" -- \\t\/\/ RoundFloat not needed - empty\" %}\n-  size(0);\n-  \/\/ PPC results are already \"rounded\" (i.e., normal-format IEEE).\n-  ins_encode( \/*empty*\/ );\n-  ins_pipe(pipe_class_default);\n-%}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,5 +35,0 @@\n-\/\/ explicit rounding operations are required to implement the strictFP mode\n-enum {\n-  pd_strict_fp_requires_explicit_rounding = false\n-};\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Defs_riscv.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -358,1 +358,1 @@\n-  set_result(x, round_item(reg));\n+  set_result(x, reg);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,3 +117,0 @@\n-  \/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-  static const bool strict_fp_requires_explicit_rounding = false;\n-\n","filename":"src\/hotspot\/cpu\/riscv\/matcher_riscv.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,5 +35,0 @@\n-\/\/ Explicit rounding operations are not required to implement the strictFP mode.\n-enum {\n-  pd_strict_fp_requires_explicit_rounding = false\n-};\n-\n","filename":"src\/hotspot\/cpu\/s390\/c1_Defs_s390.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -111,3 +111,0 @@\n-  \/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-  static const bool strict_fp_requires_explicit_rounding = false;\n-\n","filename":"src\/hotspot\/cpu\/s390\/matcher_s390.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5320,17 +5320,0 @@\n-instruct roundDouble_nop(regD dst) %{\n-  match(Set dst (RoundDouble dst));\n-  ins_cost(0);\n-  \/\/ TODO: s390 port size(FIXED_SIZE);\n-  \/\/ z\/Architecture results are already \"rounded\" (i.e., normal-format IEEE).\n-  ins_encode();\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n-instruct roundFloat_nop(regF dst) %{\n-  match(Set dst (RoundFloat dst));\n-  ins_cost(0);\n-  \/\/ TODO: s390 port size(FIXED_SIZE);\n-  \/\/ z\/Architecture results are already \"rounded\" (i.e., normal-format IEEE).\n-  ins_encode();\n-  ins_pipe(pipe_class_dummy);\n-%}\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,6 +34,0 @@\n-\/\/ explicit rounding operations are required to implement the strictFP mode\n-enum {\n-  pd_strict_fp_requires_explicit_rounding = LP64_ONLY( false ) NOT_LP64 ( true )\n-};\n-\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_Defs_x86.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -348,1 +348,1 @@\n-  set_result(x, round_item(reg));\n+  set_result(x, reg);\n@@ -436,1 +436,1 @@\n-    set_result(x, round_item(reg));\n+    set_result(x, reg);\n@@ -457,1 +457,1 @@\n-  set_result(x, round_item(reg));\n+  set_result(x, reg);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -627,10 +627,0 @@\n-    case lir_roundfp: {\n-      assert(in->is_fpu_register() && !in->is_xmm_register(), \"input must be in register\");\n-      assert(res->is_stack(), \"result must be on stack\");\n-\n-      insert_exchange(in);\n-      new_in = to_fpu_stack_top(in);\n-      pop_if_last_use(op1, in);\n-      break;\n-    }\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_LinearScan_x86.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -124,7 +124,0 @@\n-  \/\/ Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.\n-#ifdef _LP64\n-  static const bool strict_fp_requires_explicit_rounding = false;\n-#else\n-  static const bool strict_fp_requires_explicit_rounding = true;\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/matcher_x86.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4228,1 +4228,0 @@\n-        strcmp(opType,\"RoundDouble\")==0 ||\n@@ -4230,1 +4229,0 @@\n-        strcmp(opType,\"RoundFloat\")==0 ||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -843,1 +843,0 @@\n-void Canonicalizer::do_RoundFP        (RoundFP*         x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-  virtual void do_RoundFP        (RoundFP*         x);\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,7 +47,0 @@\n-\n-\/\/ the processor may require explicit rounding operations to implement the strictFP mode\n-enum {\n-  strict_fp_requires_explicit_rounding = pd_strict_fp_requires_explicit_rounding\n-};\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Defs.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -676,11 +676,0 @@\n-    if (strict_fp_requires_explicit_rounding && load->type()->is_float_kind()) {\n-#ifdef IA32\n-      if (UseSSE < 2) {\n-        \/\/ can't skip load since value might get rounded as a side effect\n-        return load;\n-      }\n-#else\n-      Unimplemented();\n-#endif \/\/ IA32\n-    }\n-\n@@ -1055,1 +1044,1 @@\n-  state->store_local(index, round_fp(x));\n+  state->store_local(index, x);\n@@ -1207,4 +1196,1 @@\n-  \/\/ Note: currently single-precision floating-point rounding on Intel is handled at the LIRGenerator level\n-  res = append(res);\n-  res = round_fp(res);\n-  push(type, res);\n+  push(type, append(res));\n@@ -2231,1 +2217,1 @@\n-    push(result_type, round_fp(result));\n+    push(result_type, result);\n@@ -2359,23 +2345,0 @@\n-Value GraphBuilder::round_fp(Value fp_value) {\n-  if (strict_fp_requires_explicit_rounding) {\n-#ifdef IA32\n-    \/\/ no rounding needed if SSE2 is used\n-    if (UseSSE < 2) {\n-      \/\/ Must currently insert rounding node for doubleword values that\n-      \/\/ are results of expressions (i.e., not loads from memory or\n-      \/\/ constants)\n-      if (fp_value->type()->tag() == doubleTag &&\n-          fp_value->as_Constant() == nullptr &&\n-          fp_value->as_Local() == nullptr &&       \/\/ method parameters need no rounding\n-          fp_value->as_RoundFP() == nullptr) {\n-        return append(new RoundFP(fp_value));\n-      }\n-    }\n-#else\n-    Unimplemented();\n-#endif \/\/ IA32\n-  }\n-  return fp_value;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":3,"deletions":40,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -269,1 +269,0 @@\n-  Value round_fp(Value fp_value);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-class   RoundFP;\n@@ -190,1 +189,0 @@\n-  virtual void do_RoundFP        (RoundFP*         x) = 0;\n@@ -559,1 +557,0 @@\n-  virtual RoundFP*          as_RoundFP()         { return nullptr; }\n@@ -2145,24 +2142,0 @@\n-\/\/ Models needed rounding for floating-point values on Intel.\n-\/\/ Currently only used to represent rounding of double-precision\n-\/\/ values stored into local variables, but could be used to model\n-\/\/ intermediate rounding of single-precision values as well.\n-LEAF(RoundFP, Instruction)\n- private:\n-  Value _input;             \/\/ floating-point value to be rounded\n-\n- public:\n-  RoundFP(Value input)\n-  : Instruction(input->type()) \/\/ Note: should not be used for constants\n-  , _input(input)\n-  {\n-    ASSERT_VALUES\n-  }\n-\n-  \/\/ accessors\n-  Value input() const                            { return _input; }\n-\n-  \/\/ generic\n-  virtual void input_values_do(ValueVisitor* f)   { f->visit(&_input); }\n-};\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -782,6 +782,0 @@\n-\n-void InstructionPrinter::do_RoundFP(RoundFP* x) {\n-  output()->print(\"round_fp \");\n-  print_value(x->input());\n-}\n-\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -123,1 +123,0 @@\n-  virtual void do_RoundFP        (RoundFP*         x);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -553,14 +553,0 @@\n-\/\/ LIR_OpRoundFP;\n-    case lir_roundfp: {\n-      assert(op->as_OpRoundFP() != nullptr, \"must be\");\n-      LIR_OpRoundFP* opRoundFP = (LIR_OpRoundFP*)op;\n-\n-      assert(op->_info == nullptr, \"info not used by this instruction\");\n-      assert(opRoundFP->_tmp->is_illegal(), \"not used\");\n-      do_input(opRoundFP->_opr);\n-      do_output(opRoundFP->_result);\n-\n-      break;\n-    }\n-\n-\n@@ -1734,1 +1720,0 @@\n-     case lir_roundfp:               s = \"roundfp\";       break;\n@@ -1979,6 +1964,0 @@\n-void LIR_OpRoundFP::print_instr(outputStream* out) const {\n-  _opr->print(out);         out->print(\" \");\n-  tmp()->print(out);        out->print(\" \");\n-  result_opr()->print(out); out->print(\" \");\n-}\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -887,1 +887,0 @@\n-class      LIR_OpRoundFP;\n@@ -941,1 +940,0 @@\n-      , lir_roundfp\n@@ -1150,1 +1148,0 @@\n-  virtual LIR_OpRoundFP* as_OpRoundFP() { return nullptr; }\n@@ -1530,17 +1527,0 @@\n-\/\/ LIR_OpRoundFP\n-class LIR_OpRoundFP : public LIR_Op1 {\n- friend class LIR_OpVisitState;\n-\n- private:\n-  LIR_Opr _tmp;\n-\n- public:\n-  LIR_OpRoundFP(LIR_Opr reg, LIR_Opr stack_loc_temp, LIR_Opr result)\n-    : LIR_Op1(lir_roundfp, reg, result)\n-    , _tmp(stack_loc_temp) {}\n-\n-  LIR_Opr tmp() const                            { return _tmp; }\n-  virtual LIR_OpRoundFP* as_OpRoundFP()          { return this; }\n-  void print_instr(outputStream* out) const PRODUCT_RETURN;\n-};\n-\n@@ -2208,1 +2188,0 @@\n-  void roundfp(LIR_Opr reg, LIR_Opr stack_loc_temp, LIR_Opr result) { append(new LIR_OpRoundFP(reg, stack_loc_temp, result)); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -522,6 +522,0 @@\n-    case lir_roundfp: {\n-      LIR_OpRoundFP* round_op = op->as_OpRoundFP();\n-      roundfp_op(round_op->in_opr(), round_op->tmp(), round_op->result_opr(), round_op->pop_fpu_stack());\n-      break;\n-    }\n-\n@@ -778,10 +772,0 @@\n-void LIR_Assembler::roundfp_op(LIR_Opr src, LIR_Opr tmp, LIR_Opr dest, bool pop_fpu_stack) {\n-  assert(strict_fp_requires_explicit_rounding, \"not required\");\n-  assert((src->is_single_fpu() && dest->is_single_stack()) ||\n-         (src->is_double_fpu() && dest->is_double_stack()),\n-         \"round_fp: rounds register -> stack location\");\n-\n-  reg2stack (src, dest, src->type(), pop_fpu_stack);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -218,1 +218,0 @@\n-  void roundfp_op(LIR_Opr src, LIR_Opr tmp, LIR_Opr dest, bool pop_fpu_stack);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -884,21 +884,0 @@\n-LIR_Opr LIRGenerator::round_item(LIR_Opr opr) {\n-  assert(opr->is_register(), \"why spill if item is not register?\");\n-\n-  if (strict_fp_requires_explicit_rounding) {\n-#ifdef IA32\n-    if (UseSSE < 1 && opr->is_single_fpu()) {\n-      LIR_Opr result = new_register(T_FLOAT);\n-      set_vreg_flag(result, must_start_in_memory);\n-      assert(opr->is_register(), \"only a register can be spilled\");\n-      assert(opr->value_type()->is_float(), \"rounding only for floats available\");\n-      __ roundfp(opr, LIR_OprFact::illegalOpr, result);\n-      return result;\n-    }\n-#else\n-    Unimplemented();\n-#endif \/\/ IA32\n-  }\n-  return opr;\n-}\n-\n-\n@@ -2056,19 +2035,0 @@\n-void LIRGenerator::do_RoundFP(RoundFP* x) {\n-  assert(strict_fp_requires_explicit_rounding, \"not required\");\n-\n-  LIRItem input(x->input(), this);\n-  input.load_item();\n-  LIR_Opr input_opr = input.result();\n-  assert(input_opr->is_register(), \"why round if value is not in a register?\");\n-  assert(input_opr->is_single_fpu() || input_opr->is_double_fpu(), \"input should be floating-point value\");\n-  if (input_opr->is_single_fpu()) {\n-    set_result(x, round_item(input_opr)); \/\/ This code path not currently taken\n-  } else {\n-    LIR_Opr result = new_register(T_DOUBLE);\n-    set_vreg_flag(result, must_start_in_memory);\n-    __ roundfp(input_opr, LIR_OprFact::illegalOpr, result);\n-    set_result(x, result);\n-  }\n-}\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -236,1 +236,0 @@\n-  LIR_Opr round_item(LIR_Opr opr);\n@@ -582,1 +581,0 @@\n-  virtual void do_RoundFP        (RoundFP*         x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5891,1 +5891,0 @@\n-    \/\/ used for lir_roundfp: rounding is done by store to stack and reload later\n@@ -6773,1 +6772,0 @@\n-        case lir_roundfp:\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -580,1 +580,0 @@\n-  void do_RoundFP        (RoundFP*         x);\n@@ -765,1 +764,0 @@\n-void NullCheckVisitor::do_RoundFP        (RoundFP*         x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,1 +157,0 @@\n-    void do_RoundFP        (RoundFP*         x) { \/* nothing to do *\/ };\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -206,1 +206,0 @@\n-  void do_RoundFP        (RoundFP*         x) { \/* nothing to do *\/ }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,5 +152,0 @@\n-    if (bt == T_DOUBLE) {\n-      Node* new_val = kit->dprecision_rounding(val.node());\n-      val.set_node(new_val);\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -316,1 +316,0 @@\n-macro(RoundDouble)\n@@ -319,1 +318,0 @@\n-macro(RoundFloat)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,10 +184,0 @@\n-\/\/------------------------------Ideal------------------------------------------\n-\/\/ If converting to an int type, skip any rounding nodes\n-Node *ConvD2INode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  if (in(1)->Opcode() == Op_RoundDouble) {\n-    set_req(1, in(1)->in(1));\n-    return this;\n-  }\n-  return nullptr;\n-}\n-\n@@ -220,10 +210,0 @@\n-\/\/------------------------------Ideal------------------------------------------\n-\/\/ If converting to an int type, skip any rounding nodes\n-Node *ConvD2LNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  if (in(1)->Opcode() == Op_RoundDouble) {\n-    set_req(1, in(1)->in(1));\n-    return this;\n-  }\n-  return nullptr;\n-}\n-\n@@ -303,10 +283,0 @@\n-\/\/------------------------------Ideal------------------------------------------\n-\/\/ If converting to an int type, skip any rounding nodes\n-Node *ConvF2INode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  if (in(1)->Opcode() == Op_RoundFloat) {\n-    set_req(1, in(1)->in(1));\n-    return this;\n-  }\n-  return nullptr;\n-}\n-\n@@ -332,10 +302,0 @@\n-\/\/------------------------------Ideal------------------------------------------\n-\/\/ If converting to an int type, skip any rounding nodes\n-Node *ConvF2LNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  if (in(1)->Opcode() == Op_RoundFloat) {\n-    set_req(1, in(1)->in(1));\n-    return this;\n-  }\n-  return nullptr;\n-}\n-\n@@ -868,46 +828,0 @@\n-\n-\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-\/\/ Remove redundant roundings\n-Node* RoundFloatNode::Identity(PhaseGVN* phase) {\n-  assert(Matcher::strict_fp_requires_explicit_rounding, \"should only generate for Intel\");\n-  \/\/ Do not round constants\n-  if (phase->type(in(1))->base() == Type::FloatCon)  return in(1);\n-  int op = in(1)->Opcode();\n-  \/\/ Redundant rounding\n-  if( op == Op_RoundFloat ) return in(1);\n-  \/\/ Already rounded\n-  if( op == Op_Parm ) return in(1);\n-  if( op == Op_LoadF ) return in(1);\n-  return this;\n-}\n-\n-\/\/------------------------------Value------------------------------------------\n-const Type* RoundFloatNode::Value(PhaseGVN* phase) const {\n-  return phase->type( in(1) );\n-}\n-\n-\/\/=============================================================================\n-\/\/------------------------------Identity---------------------------------------\n-\/\/ Remove redundant roundings.  Incoming arguments are already rounded.\n-Node* RoundDoubleNode::Identity(PhaseGVN* phase) {\n-  assert(Matcher::strict_fp_requires_explicit_rounding, \"should only generate for Intel\");\n-  \/\/ Do not round constants\n-  if (phase->type(in(1))->base() == Type::DoubleCon)  return in(1);\n-  int op = in(1)->Opcode();\n-  \/\/ Redundant rounding\n-  if( op == Op_RoundDouble ) return in(1);\n-  \/\/ Already rounded\n-  if( op == Op_Parm ) return in(1);\n-  if( op == Op_LoadD ) return in(1);\n-  if( op == Op_ConvF2D ) return in(1);\n-  if( op == Op_ConvI2D ) return in(1);\n-  return this;\n-}\n-\n-\/\/------------------------------Value------------------------------------------\n-const Type* RoundDoubleNode::Value(PhaseGVN* phase) const {\n-  return phase->type( in(1) );\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":0,"deletions":86,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -94,1 +93,0 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -127,1 +125,0 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -139,1 +136,0 @@\n-  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -257,22 +253,0 @@\n-\/\/-----------------------------RoundFloatNode----------------------------------\n-class RoundFloatNode: public Node {\n-  public:\n-  RoundFloatNode(Node* c, Node *in1): Node(c, in1) {}\n-  virtual int   Opcode() const;\n-  virtual const Type *bottom_type() const { return Type::FLOAT; }\n-  virtual uint  ideal_reg() const { return Op_RegF; }\n-  virtual Node* Identity(PhaseGVN* phase);\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-};\n-\n-\n-\/\/-----------------------------RoundDoubleNode---------------------------------\n-class RoundDoubleNode: public Node {\n-  public:\n-  RoundDoubleNode(Node* c, Node *in1): Node(c, in1) {}\n-  virtual int   Opcode() const;\n-  virtual const Type *bottom_type() const { return Type::DOUBLE; }\n-  virtual uint  ideal_reg() const { return Op_RegD; }\n-  virtual Node* Identity(PhaseGVN* phase);\n-  virtual const Type* Value(PhaseGVN* phase) const;\n-};\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -651,2 +651,0 @@\n-  \/\/ Round double arguments before call\n-  round_double_arguments(cg->method());\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2367,45 +2367,0 @@\n-void GraphKit::round_double_arguments(ciMethod* dest_method) {\n-  if (Matcher::strict_fp_requires_explicit_rounding) {\n-    \/\/ (Note:  TypeFunc::make has a cache that makes this fast.)\n-    const TypeFunc* tf    = TypeFunc::make(dest_method);\n-    int             nargs = tf->domain()->cnt() - TypeFunc::Parms;\n-    for (int j = 0; j < nargs; j++) {\n-      const Type *targ = tf->domain()->field_at(j + TypeFunc::Parms);\n-      if (targ->basic_type() == T_DOUBLE) {\n-        \/\/ If any parameters are doubles, they must be rounded before\n-        \/\/ the call, dprecision_rounding does gvn.transform\n-        Node *arg = argument(j);\n-        arg = dprecision_rounding(arg);\n-        set_argument(j, arg);\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ rounding for strict float precision conformance\n-Node* GraphKit::precision_rounding(Node* n) {\n-  if (Matcher::strict_fp_requires_explicit_rounding) {\n-#ifdef IA32\n-    if (UseSSE == 0) {\n-      return _gvn.transform(new RoundFloatNode(nullptr, n));\n-    }\n-#else\n-    Unimplemented();\n-#endif \/\/ IA32\n-  }\n-  return n;\n-}\n-\n-\/\/ rounding for strict double precision conformance\n-Node* GraphKit::dprecision_rounding(Node *n) {\n-  if (Matcher::strict_fp_requires_explicit_rounding) {\n-#ifdef IA32\n-    if (UseSSE < 2) {\n-      return _gvn.transform(new RoundDoubleNode(nullptr, n));\n-    }\n-#else\n-    Unimplemented();\n-#endif \/\/ IA32\n-  }\n-  return n;\n-}\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -755,9 +755,0 @@\n-  \/\/ Helper function to round double arguments before a call\n-  void round_double_arguments(ciMethod* dest_method);\n-\n-  \/\/ rounding for strict float precision conformance\n-  Node* precision_rounding(Node* n);\n-\n-  \/\/ rounding for strict double precision conformance\n-  Node* dprecision_rounding(Node* n);\n-\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1724,14 +1724,0 @@\n-\/\/--------------------------round_double_node--------------------------------\n-\/\/ Round a double node if necessary.\n-Node* LibraryCallKit::round_double_node(Node* n) {\n-  if (Matcher::strict_fp_requires_explicit_rounding) {\n-#ifdef IA32\n-    if (UseSSE < 2) {\n-      n = _gvn.transform(new RoundDoubleNode(nullptr, n));\n-    }\n-#else\n-    Unimplemented();\n-#endif \/\/ IA32\n-  }\n-  return n;\n-}\n@@ -1746,1 +1732,1 @@\n-  Node* arg = round_double_node(argument(0));\n+  Node* arg = argument(0);\n@@ -1757,1 +1743,1 @@\n-  case vmIntrinsics::_dcopySign: n = CopySignDNode::make(_gvn, arg, round_double_node(argument(2))); break;\n+  case vmIntrinsics::_dcopySign: n = CopySignDNode::make(_gvn, arg, argument(2)); break;\n@@ -1791,2 +1777,2 @@\n-  Node* a = round_double_node(argument(0));\n-  Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? round_double_node(argument(2)) : nullptr;\n+  Node* a = argument(0);\n+  Node* b = (call_type == OptoRuntime::Math_DD_D_Type()) ? argument(2) : nullptr;\n@@ -1810,1 +1796,1 @@\n-  Node* exp = round_double_node(argument(2));\n+  Node* exp = argument(2);\n@@ -1815,1 +1801,1 @@\n-      Node* base = round_double_node(argument(0));\n+      Node* base = argument(0);\n@@ -1820,1 +1806,1 @@\n-      Node* base = round_double_node(argument(0));\n+      Node* base = argument(0);\n@@ -1966,2 +1952,2 @@\n-      a = round_double_node(argument(0));\n-      b = round_double_node(argument(2));\n+      a = argument(0);\n+      b = argument(2);\n@@ -8486,3 +8472,3 @@\n-    a = round_double_node(argument(0));\n-    b = round_double_node(argument(2));\n-    c = round_double_node(argument(4));\n+    a = argument(0);\n+    b = argument(2);\n+    c = argument(4);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":12,"deletions":26,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-  Node* round_double_node(Node* n);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2065,1 +2065,1 @@\n-    set_pair_local( 0, dprecision_rounding(pop_pair()) );\n+    set_pair_local( 0, pop_pair() );\n@@ -2068,1 +2068,1 @@\n-    set_pair_local( 1, dprecision_rounding(pop_pair()) );\n+    set_pair_local( 1, pop_pair() );\n@@ -2071,1 +2071,1 @@\n-    set_pair_local( 2, dprecision_rounding(pop_pair()) );\n+    set_pair_local( 2, pop_pair() );\n@@ -2074,1 +2074,1 @@\n-    set_pair_local( 3, dprecision_rounding(pop_pair()) );\n+    set_pair_local( 3, pop_pair() );\n@@ -2077,1 +2077,1 @@\n-    set_pair_local( iter().get_index(), dprecision_rounding(pop_pair()) );\n+    set_pair_local( iter().get_index(), pop_pair() );\n@@ -2259,2 +2259,1 @@\n-    d = precision_rounding(c);\n-    push( d );\n+    push(c);\n@@ -2267,2 +2266,1 @@\n-    d = precision_rounding(c);\n-    push( d );\n+    push(c);\n@@ -2275,2 +2273,1 @@\n-    d = precision_rounding(c);\n-    push( d );\n+    push(c);\n@@ -2283,2 +2280,1 @@\n-    d = precision_rounding(c);\n-    push( d );\n+    push(c);\n@@ -2334,2 +2330,0 @@\n-    \/\/ This breaks _227_mtrt (speed & correctness) and _222_mpegaudio (speed)\n-    \/\/b = _gvn.transform(new RoundFloatNode(nullptr, b) );\n@@ -2343,5 +2337,0 @@\n-      \/\/ For x86_32.ad, FILD doesn't restrict precision to 24 or 53 bits.\n-      \/\/ Rather than storing the result into an FP register then pushing\n-      \/\/ out to memory to round, the machine instruction that implements\n-      \/\/ ConvL2D is responsible for rounding.\n-      \/\/ c = precision_rounding(b);\n@@ -2357,2 +2346,0 @@\n-    \/\/ For x86_32.ad, rounding is always necessary (see _l2f above).\n-    \/\/ c = dprecision_rounding(b);\n@@ -2378,2 +2365,1 @@\n-    d = dprecision_rounding(c);\n-    push_pair( d );\n+    push_pair(c);\n@@ -2386,2 +2372,1 @@\n-    d = dprecision_rounding(c);\n-    push_pair( d );\n+    push_pair(c);\n@@ -2394,2 +2379,1 @@\n-    d = dprecision_rounding(c);\n-    push_pair( d );\n+    push_pair(c);\n@@ -2402,2 +2386,1 @@\n-    d = dprecision_rounding(c);\n-    push_pair( d );\n+    push_pair(c);\n@@ -2588,2 +2571,1 @@\n-    c = precision_rounding(b);\n-    push (b);\n+    push(b);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":14,"deletions":32,"binary":false,"changes":46,"status":"modified"}]}