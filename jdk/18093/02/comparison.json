{"files":[{"patch":"@@ -192,0 +192,10 @@\n+\/\/ If there is a virtual thread mounted then return vthread() oop.\n+\/\/ Otherwise, return threadObj().\n+oop JavaThread::vthread_or_thread() const {\n+  oop result = vthread();\n+  if (result == nullptr) {\n+    result = threadObj();\n+  }\n+  return result;\n+}\n+\n@@ -560,1 +570,2 @@\n-  bool interrupted = java_lang_Thread::interrupted(threadObj());\n+  oop thread_oop = vthread_or_thread();\n+  bool interrupted = java_lang_Thread::interrupted(thread_oop);\n@@ -579,1 +590,5 @@\n-    java_lang_Thread::set_interrupted(threadObj(), false);\n+    java_lang_Thread::set_interrupted(thread_oop, false);\n+    if (thread_oop != threadObj()) {\n+      \/\/ thread_oop is virtual, clear carrier thread interrupt status as well\n+      java_lang_Thread::set_interrupted(threadObj(), false);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -527,0 +527,1 @@\n+  oop vthread_or_thread() const;\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @bug 8325187\n+ * @summary Verifies JVMTI InterruptThread works for virtual threads.\n+ * @run main\/othervm\/native -agentlib:InterruptRawMonitor InterruptRawMonitor\n+ *\n+ * @test id=virtual\n+ * @bug 8325187\n+ * @summary Verifies JVMTI InterruptThread works for virtual threads.\n+ * @run main\/othervm\/native -agentlib:InterruptRawMonitor InterruptRawMonitor -v\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class InterruptRawMonitor {\n+    private static final String AGENT_LIB = \"InterruptRawMonitor\";\n+    static native void test();\n+    static native void waitForCondition(Thread t);\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread thread;\n+        if (args.length > 0 && \"-v\".equals(args[0])) {\n+            thread = Thread.ofVirtual().unstarted(InterruptRawMonitor::test);\n+        } else {\n+            thread = Thread.ofPlatform().unstarted(InterruptRawMonitor::test);\n+        }\n+        System.out.println(thread);\n+        thread.start();\n+        waitForCondition(thread);\n+        thread.interrupt();\n+        thread.join();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/InterruptRawMonitor\/InterruptRawMonitor.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti = nullptr;\n+static jrawMonitorID monitor = nullptr;\n+static bool is_waiting = false;\n+ \n+static void check_thread_not_interrupted(JNIEnv *jni, int check_idx) {\n+  jint state = get_thread_state(jvmti, jni, nullptr);\n+\n+  LOG(\"\\ntest: check #%d: Thread State: (0x%x) %s\\n\",\n+      check_idx, state, TranslateState(state));\n+\n+  if ((state & JVMTI_THREAD_STATE_INTERRUPTED) != 0) {\n+    fatal(jni, \"Failed: JVMTI_THREAD_STATE_INTERRUPTED bit expected to be cleared\");\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_InterruptRawMonitor_waitForCondition(JNIEnv *jni, jclass clazz, jthread thread) {\n+  jint state = 0;\n+  RawMonitorLocker rml(jvmti, jni, monitor);\n+\n+  while (!is_waiting) {\n+    state = get_thread_state(jvmti, jni, thread);\n+    LOG(\"main: waitForCondition: target Thread State: (0x%x) %s\\n\",\n+        state, TranslateState(state));\n+    rml.wait(10); \n+  }\n+  state = get_thread_state(jvmti, jni, thread);\n+  LOG(\"main: waitForCondition: target Thread State: (0x%x) %s\\n\\n\",\n+      state, TranslateState(state));\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_InterruptRawMonitor_test(JNIEnv *jni, jclass clazz) {\n+  RawMonitorLocker rml(jvmti, jni, monitor);\n+\n+  check_thread_not_interrupted(jni, 0);\n+  is_waiting = true;\n+\n+  \/\/ expected to be interrupted\n+  jvmtiError err = jvmti->RawMonitorWait(monitor, 0);\n+  LOG(\"test: JVMTI RawMonitorWait returned expected error code: (%d) %s\\n\",\n+      err, TranslateError(err));\n+  if (err != JVMTI_ERROR_INTERRUPT) {\n+    fatal(jni, \"Failed: expected JVMTI_ERROR_INTERRUPT from RawMonitorWait\");\n+  }\n+\n+  check_thread_not_interrupted(jni, 1);\n+\n+  rml.wait(10); \/\/ expected to be non-interrupted\n+\n+  check_thread_not_interrupted(jni, 2);\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"Agent_OnLoad started\\n\");\n+  if (jvm->GetEnv((void **)(&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  monitor = create_raw_monitor(jvmti, \"Test Monitor\");\n+  LOG(\"test: JVMTI_THREAD_STATE_INTERRUPTED bit: 0x%x\\n\", JVMTI_THREAD_STATE_INTERRUPTED);\n+\n+  LOG(\"Agent_OnLoad finished\\n\");\n+  return JNI_OK;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/InterruptRawMonitor\/libInterruptRawMonitor.cpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}