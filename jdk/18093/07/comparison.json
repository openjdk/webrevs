{"files":[{"patch":"@@ -1544,0 +1544,1 @@\n+int java_lang_Thread::_interruptLock_offset;\n@@ -1557,0 +1558,1 @@\n+  macro(_interruptLock_offset, k, \"interruptLock\", object_signature, false); \\\n@@ -1639,0 +1641,3 @@\n+oop java_lang_Thread::interrupt_lock(oop java_thread) {\n+  return java_thread->obj_field(_interruptLock_offset);\n+}\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -358,0 +358,1 @@\n+  static int _interruptLock_offset;\n@@ -377,0 +378,2 @@\n+  \/\/ interruptLock\n+  static oop interrupt_lock(oop java_thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -192,0 +192,10 @@\n+\/\/ If there is a virtual thread mounted then return vthread() oop.\n+\/\/ Otherwise, return threadObj().\n+oop JavaThread::vthread_or_thread() const {\n+  oop result = vthread();\n+  if (result == nullptr) {\n+    result = threadObj();\n+  }\n+  return result;\n+}\n+\n@@ -560,1 +570,8 @@\n-  bool interrupted = java_lang_Thread::interrupted(threadObj());\n+  oop thread_oop = vthread_or_thread();\n+  bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n+  bool interrupted = java_lang_Thread::interrupted(thread_oop);\n+\n+  if (!(interrupted && clear_interrupted)) {\n+    return interrupted;\n+  }\n+  assert(this == Thread::current(), \"only the current thread can clear\");\n@@ -577,2 +594,1 @@\n-  if (interrupted && clear_interrupted) {\n-    assert(this == Thread::current(), \"only the current thread can clear\");\n+  if (!is_virtual) { \/\/ platform thread\n@@ -581,0 +597,1 @@\n+    return interrupted;\n@@ -583,0 +600,15 @@\n+  \/\/ Virtual thread: clear interrupt status for both virtual and\n+  \/\/ carrier threads under the interruptLock protection.\n+  JavaThread* current = JavaThread::current();\n+  HandleMark hm(current);\n+  Handle thread_h(current, thread_oop);\n+  ObjectLocker lock(Handle(current, java_lang_Thread::interrupt_lock(thread_h())), current);\n+\n+  \/\/ re-check the interrupt status under the interruptLock protection\n+  interrupted = java_lang_Thread::interrupted(thread_h());\n+\n+  if (interrupted) {\n+    java_lang_Thread::set_interrupted(thread_h(), false);  \/\/ clear for virtual\n+    java_lang_Thread::set_interrupted(threadObj(), false); \/\/ clear for carrier\n+    WINDOWS_ONLY(osthread()->set_interrupted(false);)\n+  }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -527,0 +527,1 @@\n+  oop vthread_or_thread() const;\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -376,5 +376,0 @@\n-        } catch (InterruptedException e) {\n-            Thread thread = Thread.currentThread();\n-            if (thread.isVirtual())\n-                thread.getAndClearInterrupt();\n-            throw e;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Object.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @bug 8325187\n+ * @summary Verifies JVMTI InterruptThread works for virtual threads.\n+ * @run main\/othervm\/native -agentlib:InterruptRawMonitor InterruptRawMonitor\n+ *\n+ * @test id=virtual\n+ * @bug 8325187\n+ * @summary Verifies JVMTI InterruptThread works for virtual threads.\n+ * @run main\/othervm\/native -agentlib:InterruptRawMonitor InterruptRawMonitor -v\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class InterruptRawMonitor {\n+    private static final String AGENT_LIB = \"InterruptRawMonitor\";\n+    static native void test();\n+    static native void waitForCondition(Thread t);\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread thread;\n+        if (args.length > 0 && \"-v\".equals(args[0])) {\n+            thread = Thread.ofVirtual().unstarted(InterruptRawMonitor::test);\n+        } else {\n+            thread = Thread.ofPlatform().unstarted(InterruptRawMonitor::test);\n+        }\n+        System.out.println(thread);\n+        thread.start();\n+        waitForCondition(thread);\n+        thread.interrupt();\n+        thread.join();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/InterruptRawMonitor\/InterruptRawMonitor.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti = nullptr;\n+static jrawMonitorID monitor = nullptr;\n+static bool is_waiting = false;\n+\n+static void check_thread_not_interrupted(JNIEnv *jni, int check_idx) {\n+  jint state = get_thread_state(jvmti, jni, nullptr);\n+\n+  LOG(\"\\ntest: check #%d: Thread State: (0x%x) %s\\n\",\n+      check_idx, state, TranslateState(state));\n+\n+  if ((state & JVMTI_THREAD_STATE_INTERRUPTED) != 0) {\n+    fatal(jni, \"Failed: JVMTI_THREAD_STATE_INTERRUPTED bit expected to be cleared\");\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_InterruptRawMonitor_waitForCondition(JNIEnv *jni, jclass clazz, jthread thread) {\n+  jint state = 0;\n+  RawMonitorLocker rml(jvmti, jni, monitor);\n+\n+  while (!is_waiting) {\n+    state = get_thread_state(jvmti, jni, thread);\n+    LOG(\"main: waitForCondition: target Thread State: (0x%x) %s\\n\",\n+        state, TranslateState(state));\n+    rml.wait(10);\n+  }\n+  state = get_thread_state(jvmti, jni, thread);\n+  LOG(\"main: waitForCondition: target Thread State: (0x%x) %s\\n\\n\",\n+      state, TranslateState(state));\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_InterruptRawMonitor_test(JNIEnv *jni, jclass clazz) {\n+  RawMonitorLocker rml(jvmti, jni, monitor);\n+\n+  check_thread_not_interrupted(jni, 0);\n+  is_waiting = true;\n+\n+  \/\/ expected to be interrupted\n+  jvmtiError err = jvmti->RawMonitorWait(monitor, 0);\n+  LOG(\"test: JVMTI RawMonitorWait returned expected error code: (%d) %s\\n\",\n+      err, TranslateError(err));\n+  if (err != JVMTI_ERROR_INTERRUPT) {\n+    fatal(jni, \"Failed: expected JVMTI_ERROR_INTERRUPT from RawMonitorWait\");\n+  }\n+\n+  check_thread_not_interrupted(jni, 1);\n+\n+  rml.wait(10); \/\/ expected to be non-interrupted\n+\n+  check_thread_not_interrupted(jni, 2);\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"Agent_OnLoad started\\n\");\n+  if (jvm->GetEnv((void **)(&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  monitor = create_raw_monitor(jvmti, \"Test Monitor\");\n+  LOG(\"test: JVMTI_THREAD_STATE_INTERRUPTED bit: 0x%x\\n\", JVMTI_THREAD_STATE_INTERRUPTED);\n+\n+  LOG(\"Agent_OnLoad finished\\n\");\n+  return JNI_OK;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/InterruptRawMonitor\/libInterruptRawMonitor.cpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}