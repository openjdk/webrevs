{"files":[{"patch":"@@ -569,0 +569,1 @@\n+\n@@ -570,0 +571,1 @@\n+  bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n@@ -575,0 +577,22 @@\n+  assert(this == Thread::current(), \"only the current thread can clear\");\n+\n+  \/\/ NOTE that since there is no \"lock\" around the interrupt and\n+  \/\/ is_interrupted operations, there is the possibility that the\n+  \/\/ interrupted flag will be \"false\" but that the\n+  \/\/ low-level events will be in the signaled state. This is\n+  \/\/ intentional. The effect of this is that Object.wait() and\n+  \/\/ LockSupport.park() will appear to have a spurious wakeup, which\n+  \/\/ is allowed and not harmful, and the possibility is so rare that\n+  \/\/ it is not worth the added complexity to add yet another lock.\n+  \/\/ For the sleep event an explicit reset is performed on entry\n+  \/\/ to JavaThread::sleep, so there is no early return. It has also been\n+  \/\/ recommended not to put the interrupted flag into the \"event\"\n+  \/\/ structure because it hides the issue.\n+  \/\/ Also, because there is no lock, we must only clear the interrupt\n+  \/\/ state if we are going to report that we were interrupted; otherwise\n+  \/\/ an interrupt that happens just after we read the field would be lost.\n+  if (!is_virtual) { \/\/ platform thread\n+    java_lang_Thread::set_interrupted(threadObj(), false);\n+    WINDOWS_ONLY(osthread()->set_interrupted(false);)\n+    return interrupted;\n+  }\n@@ -576,0 +600,2 @@\n+  \/\/ Virtual thread: clear interrupt status for both virtual and\n+  \/\/ carrier threads under the interruptLock protection.\n@@ -581,1 +607,1 @@\n-  \/\/ re-check under the interruptLock protection\n+  \/\/ re-check the interrupt status under the interruptLock protection\n@@ -585,6 +611,2 @@\n-    assert(this == Thread::current(), \"only the current thread can clear\");\n-    java_lang_Thread::set_interrupted(thread_h(), false);\n-    if (thread_h() != threadObj()) {\n-      \/\/ thread_oop is virtual, clear carrier thread interrupt status as well\n-      java_lang_Thread::set_interrupted(threadObj(), false);\n-    }\n+    java_lang_Thread::set_interrupted(thread_h(), false);  \/\/ clear for virtual\n+    java_lang_Thread::set_interrupted(threadObj(), false); \/\/ clear for carrier\n@@ -593,1 +615,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":29,"deletions":8,"binary":false,"changes":37,"status":"modified"}]}