{"files":[{"patch":"@@ -98,0 +98,1 @@\n+    _is_heap_almost_full(false),\n@@ -291,1 +292,2 @@\n-         || GCLocker::is_active_and_needs_gc();\n+         || GCLocker::is_active_and_needs_gc()\n+         || _is_heap_almost_full;\n@@ -954,0 +956,13 @@\n+  if (_is_heap_almost_full) {\n+    \/\/ Reset the emergency state if eden is empty after a young\/full gc\n+    if (_young_gen->eden()->is_empty()) {\n+      _is_heap_almost_full = false;\n+    }\n+  } else {\n+    if (full && !_young_gen->eden()->is_empty()) {\n+      \/\/ Usually eden should be empty after a full GC, so heap is probably too\n+      \/\/ full now; entering emergency state.\n+      _is_heap_almost_full = true;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -98,0 +98,7 @@\n+  \/\/ Indicate whether heap is almost or approaching full.\n+  \/\/ Usually, there is some memory headroom for application\/gc to run properly.\n+  \/\/ However, in extreme cases, e.g. young-gen is non-empty after a full gc, we\n+  \/\/ will attempt some uncommon measures, e.g. alllocating small objs in\n+  \/\/ old-gen.\n+  bool _is_heap_almost_full;\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}