{"files":[{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n@@ -237,1 +236,1 @@\n-  size_t available = _space_info->soft_available();\n+  size_t available = _space_info->soft_available_exclude_evac_reserve();\n@@ -240,2 +239,3 @@\n-  log_debug(gc)(\"should_start_gc? available: %zu, soft_max_capacity: %zu\"\n-                \", allocated: %zu\", available, capacity, allocated);\n+  log_debug(gc, ergo)(\"should_start_gc calculation: available: \" PROPERFMT \", soft_max_capacity: \"  PROPERFMT \", \"\n+                \"allocated_since_gc_start: \"  PROPERFMT,\n+                PROPERFMTARGS(available), PROPERFMTARGS(capacity), PROPERFMTARGS(allocated));\n@@ -255,1 +255,1 @@\n-    log_trigger(\"Free (%zu%s) is below minimum threshold (%zu%s)\",\n+    log_trigger(\"Free (Soft) (%zu%s) is below minimum threshold (%zu%s)\",\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n@@ -50,1 +49,0 @@\n-  size_t max_capacity = _space_info->max_capacity();\n@@ -52,1 +50,2 @@\n-  size_t available = _space_info->available();\n+  size_t available = _space_info->soft_available_exclude_evac_reserve();\n+  size_t bytes_allocated = _space_info->bytes_allocated_since_gc_start();\n@@ -54,3 +53,3 @@\n-  \/\/ Make sure the code below treats available without the soft tail.\n-  size_t soft_tail = max_capacity - capacity;\n-  available = (available > soft_tail) ? (available - soft_tail) : 0;\n+  log_debug(gc, ergo)(\"should_start_gc calculation: available: \" PROPERFMT \", soft_max_capacity: \"  PROPERFMT \", \"\n+                \"allocated_since_gc_start: \"  PROPERFMT,\n+                PROPERFMTARGS(available), PROPERFMTARGS(capacity), PROPERFMTARGS(bytes_allocated));\n@@ -62,1 +61,1 @@\n-    log_trigger(\"Free (%zu%s) is below minimum threshold (%zu%s)\",\n+    log_trigger(\"Free (Soft) (%zu%s) is below minimum threshold (%zu%s)\",\n@@ -69,1 +68,0 @@\n-  size_t bytes_allocated = _space_info->bytes_allocated_since_gc_start();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahCompactHeuristics.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  virtual size_t soft_available() const = 0;\n+  virtual size_t soft_available_exclude_evac_reserve() const = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahSpaceInfo.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shenandoah\/shenandoahFreeSet.hpp\"\n@@ -44,1 +43,0 @@\n-  size_t max_capacity = _space_info->max_capacity();\n@@ -46,1 +44,2 @@\n-  size_t available = _space_info->available();\n+  size_t available = _space_info->soft_available_exclude_evac_reserve();\n+  size_t allocated = _space_info->bytes_allocated_since_gc_start();\n@@ -48,3 +47,3 @@\n-  \/\/ Make sure the code below treats available without the soft tail.\n-  size_t soft_tail = max_capacity - capacity;\n-  available = (available > soft_tail) ? (available - soft_tail) : 0;\n+  log_debug(gc, ergo)(\"should_start_gc calculation: available: \" PROPERFMT \", soft_max_capacity: \"  PROPERFMT \", \"\n+                \"allocated_since_gc_start: \"  PROPERFMT,\n+                PROPERFMTARGS(available), PROPERFMTARGS(capacity), PROPERFMTARGS(allocated));\n@@ -55,1 +54,1 @@\n-    log_trigger(\"Free (%zu%s) is below minimum threshold (%zu%s)\",\n+    log_trigger(\"Free (Soft) (%zu%s) is below minimum threshold (%zu%s)\",\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahStaticHeuristics.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3038,0 +3038,23 @@\n+void ShenandoahFreeSet::log_freeset_stats(ShenandoahFreeSetPartitionId partition_id, LogStream& ls) {\n+  size_t max = 0;\n+  size_t total_free = 0;\n+  size_t total_used = 0;\n+\n+  for (idx_t idx = _partitions.leftmost(partition_id);\n+        idx <= _partitions.rightmost(partition_id); idx++) {\n+    if (_partitions.in_free_set(partition_id, idx)) {\n+      ShenandoahHeapRegion *r = _heap->get_region(idx);\n+      size_t free = alloc_capacity(r);\n+      max = MAX2(max, free);\n+      total_free += free;\n+      total_used += r->used();\n+    }\n+  }\n+\n+  ls.print(\" %s freeset stats: Partition count: %zu, Reserved: %zu%s, Max free available in a single region: %zu%s;\",\n+            partition_name(partition_id),\n+            _partitions.count(partition_id),\n+            byte_size_in_proper_unit(total_free), proper_unit_for_byte_size(total_free),\n+            byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max));\n+}\n+\n@@ -3158,1 +3181,1 @@\n-      ls.print(\"Free: %zu%s, Max: %zu%s regular, %zu%s humongous, \",\n+      ls.print(\"Whole heap stats: Total free: %zu%s, Total used: %zu%s, Max free in a single region: %zu%s, Max humongous: %zu%s; \",\n@@ -3160,0 +3183,1 @@\n+               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used),\n@@ -3164,1 +3188,1 @@\n-      ls.print(\"Frag: \");\n+      ls.print(\"Frag stats: \");\n@@ -3171,1 +3195,1 @@\n-      ls.print(\"%zu%% external, \", frag_ext);\n+      ls.print(\"External: %zu%%, \", frag_ext);\n@@ -3180,25 +3204,1 @@\n-      ls.print(\"%zu%% internal; \", frag_int);\n-      ls.print(\"Used: %zu%s, Mutator Free: %zu\",\n-               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used),\n-               _partitions.count(ShenandoahFreeSetPartitionId::Mutator));\n-    }\n-\n-    {\n-      size_t max = 0;\n-      size_t total_free = 0;\n-      size_t total_used = 0;\n-\n-      for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::Collector);\n-           idx <= _partitions.rightmost(ShenandoahFreeSetPartitionId::Collector); idx++) {\n-        if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::Collector, idx)) {\n-          ShenandoahHeapRegion *r = _heap->get_region(idx);\n-          size_t free = alloc_capacity(r);\n-          max = MAX2(max, free);\n-          total_free += free;\n-          total_used += r->used();\n-        }\n-      }\n-      ls.print(\" Collector Reserve: %zu%s, Max: %zu%s; Used: %zu%s\",\n-               byte_size_in_proper_unit(total_free), proper_unit_for_byte_size(total_free),\n-               byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max),\n-               byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used));\n+      ls.print(\"Internal: %zu%%; \", frag_int);\n@@ -3207,0 +3207,2 @@\n+    log_freeset_stats(ShenandoahFreeSetPartitionId::Mutator, ls);\n+    log_freeset_stats(ShenandoahFreeSetPartitionId::Collector, ls);\n@@ -3208,18 +3210,1 @@\n-      size_t max = 0;\n-      size_t total_free = 0;\n-      size_t total_used = 0;\n-\n-      for (idx_t idx = _partitions.leftmost(ShenandoahFreeSetPartitionId::OldCollector);\n-           idx <= _partitions.rightmost(ShenandoahFreeSetPartitionId::OldCollector); idx++) {\n-        if (_partitions.in_free_set(ShenandoahFreeSetPartitionId::OldCollector, idx)) {\n-          ShenandoahHeapRegion *r = _heap->get_region(idx);\n-          size_t free = alloc_capacity(r);\n-          max = MAX2(max, free);\n-          total_free += free;\n-          total_used += r->used();\n-        }\n-      }\n-      ls.print_cr(\" Old Collector Reserve: %zu%s, Max: %zu%s; Used: %zu%s\",\n-                  byte_size_in_proper_unit(total_free), proper_unit_for_byte_size(total_free),\n-                  byte_size_in_proper_unit(max),        proper_unit_for_byte_size(max),\n-                  byte_size_in_proper_unit(total_used), proper_unit_for_byte_size(total_used));\n+      log_freeset_stats(ShenandoahFreeSetPartitionId::OldCollector, ls);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":31,"deletions":46,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -632,0 +632,1 @@\n+  void log_freeset_stats(ShenandoahFreeSetPartitionId partition_id, LogStream& ls);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -939,2 +939,2 @@\n-size_t ShenandoahGeneration::soft_available() const {\n-  size_t result = available(ShenandoahHeap::heap()->soft_max_capacity());\n+size_t ShenandoahGeneration::soft_available_exclude_evac_reserve() const {\n+  size_t result = available(ShenandoahHeap::heap()->soft_max_capacity() * (100.0 - ShenandoahEvacReserve) \/ 100);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-  size_t soft_available() const override;\n+  size_t soft_available_exclude_evac_reserve() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,7 +81,6 @@\n-size_t ShenandoahGlobalGeneration::soft_available() const {\n-  size_t available = this->available();\n-\n-  \/\/ Make sure the code below treats available without the soft tail.\n-  assert(max_capacity() >= ShenandoahHeap::heap()->soft_max_capacity(), \"Max capacity must be greater than soft max capacity.\");\n-  size_t soft_tail = max_capacity() - ShenandoahHeap::heap()->soft_max_capacity();\n-  return (available > soft_tail) ? (available - soft_tail) : 0;\n+size_t ShenandoahGlobalGeneration::soft_available_exclude_evac_reserve() const {\n+  size_t soft_max =  ShenandoahHeap::heap()->soft_max_capacity();\n+  assert(max_capacity() >= soft_max, \"Max capacity must be greater than soft max capacity.\");\n+  size_t used = this->used();\n+  size_t mutator_soft_max = soft_max * ((100.0 - ShenandoahEvacReserve) \/ 100);\n+  return (mutator_soft_max > used) ? (mutator_soft_max - used) : 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  size_t soft_available() const override;\n+  size_t soft_available_exclude_evac_reserve() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGlobalGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -141,2 +141,2 @@\n-size_t ShenandoahYoungGeneration::soft_available() const {\n-  size_t available = this->ShenandoahGeneration::soft_available();\n+size_t ShenandoahYoungGeneration::soft_available_exclude_evac_reserve() const {\n+  size_t available = this->ShenandoahGeneration::soft_available_exclude_evac_reserve();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  size_t soft_available() const override;\n+  size_t soft_available_exclude_evac_reserve() const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/**\n+ * @test id=satb-adaptive\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ * @bug 8372543\n+ * @summary When soft max heap size < Xmx, we had a bug reported in JBS-8372543 where available size was undercalculated.\n+ *          This caused excessive GC runs.\n+ *\n+ * @run main\/othervm -XX:SoftMaxHeapSize=512m -Xmx2g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info\n+ *      -XX:ShenandoahGCMode=satb\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -XX:ShenandoahGCHeuristics=adaptive\n+ *      TestSoftMaxHeapSizeAvailableCalc\n+ *\/\n+\n+\/**\n+ * @test id=satb-static\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:SoftMaxHeapSize=512m -Xmx2g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info\n+ *      -XX:ShenandoahGCMode=satb\n+ *      -XX:+ShenandoahDegeneratedGC\n+ *      -XX:ShenandoahGCHeuristics=static\n+ *      TestSoftMaxHeapSizeAvailableCalc\n+ *\/\n+\n+\/**\n+ * @test id=generational\n+ * @requires vm.gc.Shenandoah\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -XX:SoftMaxHeapSize=512m -Xmx2g -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions\n+ *      -XX:+UseShenandoahGC -Xlog:gc=info\n+ *      -XX:ShenandoahGCMode=generational\n+ *      -XX:ShenandoahGCHeuristics=adaptive\n+ *      TestSoftMaxHeapSizeAvailableCalc\n+ *\n+ *\/\n+import java.lang.management.ManagementFactory;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+\n+import com.sun.management.GarbageCollectorMXBean;\n+\n+public class TestSoftMaxHeapSizeAvailableCalc {\n+    public static void main(String[] args) throws Exception {\n+        Allocate.test();\n+    }\n+\n+    \/\/ This test runs an app that has a stable heap of ~300M and allocates temporary garbage at ~100M\/s\n+    \/\/ Soft max: 512M, ShenandoahMinFreeThreshold: 10 (default), ShenandoahEvacReserve: 5 (default)\n+    \/\/ Soft max for mutator: 512M * (100.0 - 5) \/ 100 = 486.4M\n+    \/\/ Threshold to trigger gc: 486.4M - 512 * 10 \/ 100.0 = 435.2M, just above (300 + 100)M.\n+    \/\/ Expect gc count to be less than 1 \/ sec.\n+    public static class Allocate {\n+        static final List<byte[]> longLived = new ArrayList<>();\n+\n+        public static void test() throws Exception {\n+            final int expectedMaxGcCount = Integer.getInteger(\"expectedMaxGcCount\", 30);\n+            List<java.lang.management.GarbageCollectorMXBean> collectors = ManagementFactory.getGarbageCollectorMXBeans();\n+            java.lang.management.GarbageCollectorMXBean cycleCollector = null;\n+            for (java.lang.management.GarbageCollectorMXBean bean : collectors) {\n+                if (bean.getName().contains(\"Cycles\")) {\n+                    cycleCollector = bean;\n+                }\n+            }\n+\n+            \/\/ Allocate ~300MB of long-lived objects\n+            for (int i = 0; i < 300; i++) {\n+                longLived.add(new byte[1_000_000]);\n+            }\n+\n+            \/\/ allocate short-lived garbage to the heap\n+            long end = System.currentTimeMillis() + 30_000; \/\/ 30 seconds\n+\n+            while (System.currentTimeMillis() < end) {\n+                byte[] garbage = new byte[1_000_000];\n+                garbage[0] = 1; \/\/ prevent optimization\n+\n+                Thread.sleep(10); \/\/ Pace to generate garbage at speed of ~100M\/s\n+            }\n+\n+            long gcCount = cycleCollector.getCollectionCount();\n+            Asserts.assertLessThan(gcCount, (long) expectedMaxGcCount, \"GC was triggered too many times. Expected to be less than: \" + expectedMaxGcCount + \", triggered: \" + gcCount);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestSoftMaxHeapSizeAvailableCalc.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"}]}