{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -893,2 +893,0 @@\n- \"debugflags=flags             debug flags (bitmask)           none\\n\"\n- \"                               USE_ITERATE_THROUGH_HEAP 0x01\\n\"\n@@ -1195,7 +1193,0 @@\n-        } else if (strcmp(buf, \"debugflags\") == 0) {\n-            \/*LINTED*\/\n-            if (!get_tok(&str, current, (int)(end - current), ',')) {\n-                goto syntax_error;\n-            }\n-            \/*LINTED*\/\n-            gdata->debugflags = (unsigned)strtol(current, NULL, 0);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2733,4 +2733,0 @@\n-\/* Two different cbObjectCounter's, one for FollowReferences, one for\n- *    IterateThroughHeap. Pick a card, any card.\n- *\/\n-\n@@ -2798,32 +2794,0 @@\n-\/* Callback for instance count heap traversal (heap_iteration_callback) *\/\n-static jint JNICALL\n-cbObjectCounter(jlong class_tag, jlong size, jlong* tag_ptr, jint length,\n-                        void* user_data)\n-{\n-    ClassCountData  *data;\n-    int              index;\n-\n-    \/* Check data structure *\/\n-    data = (ClassCountData*)user_data;\n-    if (data == NULL) {\n-        return JVMTI_VISIT_ABORT;\n-    }\n-\n-    \/* Classes with no tag should be filtered out. *\/\n-    if ( class_tag == (jlong)0 ) {\n-        data->error = AGENT_ERROR_INTERNAL;\n-        return JVMTI_VISIT_ABORT;\n-    }\n-\n-    \/* Class tag is actually an index into data arrays *\/\n-    index = CLASSTAG2INDEX(class_tag);\n-    if (index < 0 || index >= data->classCount) {\n-        data->error = AGENT_ERROR_ILLEGAL_ARGUMENT;\n-        return JVMTI_VISIT_ABORT;\n-    }\n-\n-    \/* Bump instance count on this class *\/\n-    data->counts[index]++;\n-    return JVMTI_VISIT_OBJECTS;\n-}\n-\n@@ -2882,39 +2846,13 @@\n-        \/* Check debug flags to see how to do this. *\/\n-        if ( (gdata->debugflags & USE_ITERATE_THROUGH_HEAP) == 0 ) {\n-\n-            \/* Using FollowReferences only gives us live objects, but we\n-             *   need to tag the objects to avoid counting them twice since\n-             *   the callback is per reference.\n-             *   The jclass objects have been tagged with their index in the\n-             *   supplied list, and that tag may flip to negative if it\n-             *   is also an object of interest.\n-             *   All other objects being counted that weren't in the\n-             *   supplied classes list will have a negative classCount\n-             *   tag value. So all objects counted will have negative tags.\n-             *   If the absolute tag value is an index in the supplied\n-             *   list, then it's one of the supplied classes.\n-             *\/\n-            data.negObjTag = -INDEX2CLASSTAG(classCount);\n-\n-            \/* Setup callbacks, only using object reference callback *\/\n-            heap_callbacks.heap_reference_callback = &cbObjectCounterFromRef;\n-\n-            \/* Follow references, no initiating object, tagged classes only *\/\n-            error = JVMTI_FUNC_PTR(jvmti,FollowReferences)\n-                          (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,\n-                           NULL, NULL, &heap_callbacks, &data);\n-\n-        } else {\n-\n-            \/* Using IterateThroughHeap means that we will visit each object\n-             *   once, so no special tag tricks here. Just simple counting.\n-             *   However in this case the object might not be live, so we do\n-             *   a GC beforehand to make sure we minimize this.\n-             *\/\n-\n-            \/* FIXUP: Need some kind of trigger here to avoid excessive GC's? *\/\n-            error = JVMTI_FUNC_PTR(jvmti,ForceGarbageCollection)(jvmti);\n-            if ( error != JVMTI_ERROR_NONE ) {\n-\n-                \/* Setup callbacks, just need object callback *\/\n-                heap_callbacks.heap_iteration_callback = &cbObjectCounter;\n+        \/* Using FollowReferences only gives us live objects, but we\n+         *   need to tag the objects to avoid counting them twice since\n+         *   the callback is per reference.\n+         *   The jclass objects have been tagged with their index in the\n+         *   supplied list, and that tag may flip to negative if it\n+         *   is also an object of interest.\n+         *   All other objects being counted that weren't in the\n+         *   supplied classes list will have a negative classCount\n+         *   tag value. So all objects counted will have negative tags.\n+         *   If the absolute tag value is an index in the supplied\n+         *   list, then it's one of the supplied classes.\n+         *\/\n+        data.negObjTag = -INDEX2CLASSTAG(classCount);\n@@ -2922,4 +2860,2 @@\n-                \/* Iterate through entire heap, tagged classes only *\/\n-                error = JVMTI_FUNC_PTR(jvmti,IterateThroughHeap)\n-                              (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,\n-                               NULL, &heap_callbacks, &data);\n+        \/* Setup callbacks, only using object reference callback *\/\n+        heap_callbacks.heap_reference_callback = &cbObjectCounterFromRef;\n@@ -2927,2 +2863,4 @@\n-            }\n-        }\n+        \/* Follow references, no initiating object, tagged classes only *\/\n+        error = JVMTI_FUNC_PTR(jvmti,FollowReferences)\n+                      (jvmti, JVMTI_HEAP_FILTER_CLASS_UNTAGGED,\n+                       NULL, NULL, &heap_callbacks, &data);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":20,"deletions":82,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,6 +95,0 @@\n-    \/* Debug flags (bit mask) *\/\n-    int      debugflags;\n-\n-    \/* Possible debug flags *\/\n-    #define USE_ITERATE_THROUGH_HEAP 0X001\n-\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"}]}