{"files":[{"patch":"@@ -3840,1 +3840,1 @@\n-    private List<Type> intersect(boolean lubWillBeErased, List<Type> cl1, List<Type> cl2) {\n+    public List<Type> intersect(List<Type> cl1, List<Type> cl2) {\n@@ -3846,1 +3846,1 @@\n-            return intersect(lubWillBeErased, cl1.tail, cl2);\n+            return intersect(cl1.tail, cl2);\n@@ -3848,1 +3848,1 @@\n-            return intersect(lubWillBeErased, cl1, cl2.tail);\n+            return intersect(cl1, cl2.tail);\n@@ -3850,1 +3850,1 @@\n-            return intersect(lubWillBeErased, cl1.tail, cl2.tail).prepend(cl1.head);\n+            return intersect(cl1.tail, cl2.tail).prepend(cl1.head);\n@@ -3854,2 +3854,2 @@\n-                Type merge = merge(lubWillBeErased, cl1.head, cl2.head);\n-                return intersect(lubWillBeErased, cl1.tail, cl2.tail).prepend(merge);\n+                Type merge = merge(cl1.head,cl2.head);\n+                return intersect(cl1.tail, cl2.tail).prepend(merge);\n@@ -3858,1 +3858,1 @@\n-                return intersect(lubWillBeErased, cl1.tail, cl2.tail).prepend(erasure(cl1.head));\n+                return intersect(cl1.tail, cl2.tail).prepend(erasure(cl1.head));\n@@ -3860,1 +3860,1 @@\n-        return intersect(lubWillBeErased, cl1.tail, cl2.tail);\n+        return intersect(cl1.tail, cl2.tail);\n@@ -3883,1 +3883,1 @@\n-        private Type merge(boolean lubWillBeErased, Type c1, Type c2) {\n+        private Type merge(Type c1, Type c2) {\n@@ -3900,1 +3900,1 @@\n-                        m = new WildcardType(lub(lubWillBeErased, wildUpperBound(act1.head),\n+                        m = new WildcardType(lub(wildUpperBound(act1.head),\n@@ -3979,5 +3979,1 @@\n-        return lub(false, ts);\n-    }\n-\n-    public Type lub(boolean lubWillBeErased, List<Type> ts) {\n-        return lub(lubWillBeErased, ts.toArray(new Type[ts.length()]));\n+        return lub(ts.toArray(new Type[ts.length()]));\n@@ -3991,4 +3987,0 @@\n-        return lub(false, ts);\n-    }\n-\n-    public Type lub(boolean lubWillBeErased, Type... ts) {\n@@ -4053,1 +4045,1 @@\n-            return new ArrayType(lub(lubWillBeErased, elements), syms.arrayClass);\n+            return new ArrayType(lub(elements), syms.arrayClass);\n@@ -4072,1 +4064,1 @@\n-                    cl = intersect(lubWillBeErased, cl, erasedSupertypes(t));\n+                    cl = intersect(cl, erasedSupertypes(t));\n@@ -4075,7 +4067,1 @@\n-            List<Type> mec = null;\n-            if (lubWillBeErased && !cl.isEmpty()) {\n-                cl = List.of(cl.head);\n-                mec = cl;\n-            } else {\n-                mec = closureMin(cl);\n-            }\n+            List<Type> mec = closureMin(cl);\n@@ -4088,1 +4074,1 @@\n-                    lci = intersect(lubWillBeErased, lci, superType != null ? List.of(superType) : List.nil());\n+                    lci = intersect(lci, superType != null ? List.of(superType) : List.nil());\n@@ -4104,1 +4090,1 @@\n-            return lub(lubWillBeErased, classes);\n+            return lub(classes);\n@@ -4108,1 +4094,1 @@\n-        List<Type> erasedSupertypes(Type t) {\n+        public List<Type> erasedSupertypes(Type t) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":17,"deletions":31,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import static com.sun.tools.javac.code.TypeTag.ARRAY;\n@@ -1827,1 +1828,1 @@\n-                Type lub = types.lub(true, t1, t2);\n+                List<Type> ec = types.intersect(getErasedSuperTypes(t1), getErasedSuperTypes(t2));\n@@ -1829,1 +1830,1 @@\n-                if (lub.hasTag(BOT)) {\n+                if (ec.isEmpty() || ec.head.hasTag(BOT)) {\n@@ -1834,1 +1835,1 @@\n-                return types.erasure(lub);\n+                return types.erasure(ec.head);\n@@ -1838,0 +1839,6 @@\n+        List<Type> getErasedSuperTypes(Type t) {\n+            return t.hasTag(ARRAY) ?\n+                    List.of(syms.serializableType, syms.cloneableType, syms.objectType) :\n+                    types.erasedSupertypes(t);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExpressionSwitchComplexIntersectionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}