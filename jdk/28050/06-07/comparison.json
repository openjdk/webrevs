{"files":[{"patch":"@@ -1829,2 +1829,2 @@\n-                List<Type> es = erasedSuper(t1, t2);\n-                if (es.isEmpty() || es.head.hasTag(BOT)) {\n+                Type es = erasedSuper(t1, t2);\n+                if (es == null || es.hasTag(BOT)) {\n@@ -1834,10 +1834,1 @@\n-\n-                return types.erasure(es.head);\n-            }\n-        }\n-\n-        private List<Type> erasedSuper(Type... ts) {\n-            if (ts[0].hasTag(ARRAY) && ts[1].hasTag(ARRAY)) {\n-                return List.of(allArray(ts));\n-            } else {\n-                return types.intersect(getErasedSuperTypes(ts[0]), getErasedSuperTypes(ts[1]));\n+                return es;\n@@ -1847,16 +1838,8 @@\n-        private Type allArray(Type... ts) {\n-            Type[] elements = new Type[ts.length];\n-            for (int i = 0 ; i < ts.length ; i++) {\n-                Type elem = elements[i] = types.elemTypeFun.apply(ts[i]);\n-                if (elem.isPrimitive()) {\n-                    \/\/ if a primitive type is found, then return\n-                    \/\/ arraySuperType unless all the types are the\n-                    \/\/ same\n-                    Type first = ts[0];\n-                    for (int j = 1 ; j < ts.length ; j++) {\n-                        if (!types.isSameType(first, ts[j])) {\n-                            return types.arraySuperType();\n-                        }\n-                    }\n-                    \/\/ all the array types are the same, return one\n-                    return first;\n+        private Type erasedSuper(Type t1, Type t2) {\n+            if (t1.hasTag(ARRAY) && t2.hasTag(ARRAY)) {\n+                Type elem1 = types.elemtype(t1);\n+                Type elem2 = types.elemtype(t2);\n+                if (elem1.isPrimitive() || elem2.isPrimitive()) {\n+                    return (elem1.tsym == elem2.tsym) ? t1 : syms.serializableType;\n+                } else { \/\/ both are arrays of references\n+                    return new ArrayType(erasedSuper(elem1, elem2), syms.arrayClass);\n@@ -1864,0 +1847,11 @@\n+            } else {\n+                t1 = types.skipTypeVars(t1, false);\n+                t2 = types.skipTypeVars(t2, false);\n+                List<Type> intersection = types.intersect(\n+                        t1.hasTag(ARRAY) ?\n+                                List.of(syms.serializableType, syms.cloneableType, syms.objectType) :\n+                                types.erasedSupertypes(t1),\n+                        t2.hasTag(ARRAY) ?\n+                                List.of(syms.serializableType, syms.cloneableType, syms.objectType) :\n+                                types.erasedSupertypes(t2));\n+                return intersection.head;\n@@ -1865,12 +1859,0 @@\n-            return new ArrayType(erasedSuper(elements).head, syms.arrayClass);\n-        }\n-\n-        private List<Type> getErasedSuperTypes(Type t) {\n-            if (t.hasTag(TYPEVAR)) {\n-                do {\n-                    t = t.getUpperBound();\n-                } while (t.hasTag(TYPEVAR));\n-            }\n-            return t.hasTag(ARRAY) ?\n-                    List.of(syms.serializableType, syms.cloneableType, syms.objectType) :\n-                    types.erasedSupertypes(t);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":22,"deletions":40,"binary":false,"changes":62,"status":"modified"}]}