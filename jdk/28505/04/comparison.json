{"files":[{"patch":"@@ -64,1 +64,1 @@\n-    _array.append(path);\n+    _array.append(ClassLoader::get_slash_delimited_canonical_path(path));\n@@ -454,1 +454,1 @@\n-  ResourceMark rm;\n+  ResourceMark rm(THREAD);\n@@ -457,0 +457,1 @@\n+  const char* const jrt_entry_name = ClassLoader::get_slash_delimited_canonical_path(ClassLoader::get_jrt_entry()->name());\n@@ -458,1 +459,1 @@\n-  AOTClassLocation* jrt = AOTClassLocation::allocate(THREAD, ClassLoader::get_jrt_entry()->name(),\n+  AOTClassLocation* jrt = AOTClassLocation::allocate(THREAD, jrt_entry_name,\n@@ -968,1 +969,1 @@\n-  const char* jrt = ClassLoader::get_jrt_entry()->name();\n+  const char* const jrt = ClassLoader::get_slash_delimited_canonical_path(ClassLoader::get_jrt_entry()->name());\n@@ -1079,1 +1080,1 @@\n-      path = ClassLoader::get_jrt_entry()->name();\n+      path = ClassLoader::get_slash_delimited_canonical_path(ClassLoader::get_jrt_entry()->name());\n","filename":"src\/hotspot\/share\/cds\/aotClassLocation.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -372,1 +372,1 @@\n-    SystemDictionary::post_class_load_event(&class_load_start_event, lambda_ik, ClassLoaderData::class_loader_data(class_loader()));\n+    JFR_ONLY(SystemDictionary::post_class_load_event(&class_load_start_event, lambda_ik, ClassLoaderData::class_loader_data(class_loader()));)\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,3 +91,0 @@\n-#if INCLUDE_JFR\n-#include \"jfr\/support\/jfrTraceIdExtension.hpp\"\n-#endif\n@@ -5289,2 +5286,0 @@\n-  JFR_ONLY(INIT_ID(ik);)\n-\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -503,0 +503,2 @@\n+  const ClassFileStream& stream() const { return *_stream; }\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -1530,0 +1531,15 @@\n+\/\/ Caller needs ResourceMark.\n+char* ClassLoader::get_slash_delimited_canonical_path(const char* orig) {\n+  char* cp = get_canonical_path(orig, Thread::current());\n+#ifdef _WINDOWS\n+  const char separator = os::file_separator()[0];\n+  const char slash = '\/';\n+  char* replace = cp;\n+  while ((replace = strchr(replace, separator)) != nullptr) {\n+    *replace = slash;\n+    ++replace;\n+  }\n+#endif\n+  return cp;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -248,0 +248,1 @@\n+  static char* get_slash_delimited_canonical_path(const char* orig);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"jfr\/support\/jfrKlassExtension.hpp\"\n+#include \"jfr\/jfr.hpp\"\n@@ -102,0 +102,3 @@\n+\n+      JFR_ONLY(Jfr::on_klass_creation(new_ik, parser, THREAD);)\n+\n@@ -216,1 +219,1 @@\n-  JFR_ONLY(ON_KLASS_CREATION(result, parser, THREAD);)\n+  JFR_ONLY(Jfr::on_klass_creation(result, parser, THREAD);)\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -563,9 +563,0 @@\n-void SystemDictionary::post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {\n-  assert(event != nullptr, \"invariant\");\n-  assert(k != nullptr, \"invariant\");\n-  event->set_loadedClass(k);\n-  event->set_definingClassLoader(k->class_loader_data());\n-  event->set_initiatingClassLoader(init_cld);\n-  event->commit();\n-}\n-\n@@ -585,1 +576,1 @@\n-  EventClassLoad class_load_start_event;\n+  EventClassLoad class_load_event;\n@@ -716,2 +707,2 @@\n-  if (class_load_start_event.should_commit()) {\n-    post_class_load_event(&class_load_start_event, loaded_class, loader_data);\n+  if (class_load_event.should_commit()) {\n+    JFR_ONLY(post_class_load_event(&class_load_event, loaded_class, loader_data);)\n@@ -792,1 +783,1 @@\n-  EventClassLoad class_load_start_event;\n+  EventClassLoad class_load_event;\n@@ -822,0 +813,4 @@\n+  if (class_load_event.should_commit()) {\n+    JFR_ONLY(post_class_load_event(&class_load_event, k, loader_data);)\n+  }\n+\n@@ -828,3 +823,0 @@\n-  if (class_load_start_event.should_commit()) {\n-    post_class_load_event(&class_load_start_event, k, loader_data);\n-  }\n@@ -1157,0 +1149,11 @@\n+#if INCLUDE_JFR\n+void SystemDictionary::post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {\n+  assert(event != nullptr, \"invariant\");\n+  assert(k != nullptr, \"invariant\");\n+  event->set_loadedClass(k);\n+  event->set_definingClassLoader(k->class_loader_data());\n+  event->set_initiatingClassLoader(init_cld);\n+  event->commit();\n+}\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -1185,0 +1188,2 @@\n+  EventClassLoad class_load;\n+\n@@ -1206,0 +1211,5 @@\n+  if (class_load.should_commit()) {\n+    JFR_ONLY(post_class_load_event(&class_load, ik, loader_data);)\n+  }\n+\n+  assert(java_lang_Class::module(java_mirror) != nullptr, \"must have been archived\");\n@@ -1383,9 +1393,0 @@\n-static void post_class_define_event(InstanceKlass* k, const ClassLoaderData* def_cld) {\n-  EventClassDefine event;\n-  if (event.should_commit()) {\n-    event.set_definedClass(k);\n-    event.set_definingClassLoader(def_cld);\n-    event.commit();\n-  }\n-}\n-\n@@ -1443,1 +1444,0 @@\n-  post_class_define_event(k, loader_data);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-  \/\/ Used by AOTLinkedClassBulkLoader, LambdaProxyClassDictionary, and SystemDictionaryShared\n+  \/\/ Used by AOTLinkedClassBulkLoader, LambdaProxyClassDictionary, VMClasses and SystemDictionaryShared\n@@ -333,1 +333,0 @@\n-  static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld);\n@@ -345,0 +344,3 @@\n+  JFR_ONLY(static void post_class_load_event(EventClassLoad* event,\n+                                             const InstanceKlass* k,\n+                                             const ClassLoaderData* init_cld);)\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"jfr\/jfrEvents.hpp\"\n@@ -243,0 +244,2 @@\n+  EventClassLoad class_load;\n+\n@@ -264,0 +267,4 @@\n+\n+  if (class_load.should_commit()) {\n+    JFR_ONLY(SystemDictionary::post_class_load_event(&class_load, klass, loader_data);)\n+  }\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1430,0 +1430,1 @@\n+  JfrClassTransformer::copy_traceid(ik, new_ik);\n@@ -1433,1 +1434,0 @@\n-  JfrClassTransformer::copy_traceid(ik, new_ik);\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/classFileParser.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"jfr\/support\/jfrClassDefineEvent.hpp\"\n@@ -81,0 +83,1 @@\n+  JfrTraceId::assign(ik);\n@@ -83,3 +86,1 @@\n-    return;\n-  }\n-  if (JfrMethodTracer::in_use()) {\n+  } else if (JfrMethodTracer::in_use()) {\n@@ -88,0 +89,3 @@\n+  if (!parser.is_internal()) {\n+    JfrClassDefineEvent::on_creation(ik, parser, THREAD);\n+  }\n@@ -171,0 +175,8 @@\n+\n+void Jfr::on_restoration(const Klass* k, JavaThread* jt) {\n+  assert(k != nullptr, \"invariant\");\n+  JfrTraceId::restore(k);\n+  if (k->is_instance_klass()) {\n+    JfrClassDefineEvent::on_restoration(InstanceKlass::cast(k), jt);\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n@@ -81,0 +82,1 @@\n+  static void on_restoration(const Klass* k, JavaThread* jt);\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -218,0 +218,1 @@\n+    <Field type=\"Symbol\" name=\"source\" label=\"Location\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.inline.hpp\"\n@@ -38,0 +38,1 @@\n+#include \"jfr\/support\/jfrSymbolTable.inline.hpp\"\n@@ -1265,1 +1266,1 @@\n-    _artifacts->increment_checkpoint_id();\n+    _artifacts->clear();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"jfr\/support\/jfrSymbolTable.inline.hpp\"\n@@ -32,2 +33,1 @@\n-JfrArtifactSet::JfrArtifactSet(bool class_unload, bool previous_epoch) : _symbol_table(nullptr),\n-                                                                         _klass_set(nullptr),\n+JfrArtifactSet::JfrArtifactSet(bool class_unload, bool previous_epoch) : _klass_set(nullptr),\n@@ -37,1 +37,2 @@\n-                                                                         _class_unload(class_unload) {\n+                                                                         _class_unload(class_unload),\n+                                                                         _previous_epoch(previous_epoch) {\n@@ -50,6 +51,1 @@\n-  if (_symbol_table == nullptr) {\n-    _symbol_table = JfrSymbolTable::create();\n-    assert(_symbol_table != nullptr, \"invariant\");\n-  }\n-  assert(_symbol_table != nullptr, \"invariant\");\n-  _symbol_table->set_class_unload(class_unload);\n+  _previous_epoch = previous_epoch;\n@@ -66,3 +62,4 @@\n-  if (_symbol_table != nullptr) {\n-    _symbol_table->clear();\n-  }\n+  assert(_previous_epoch, \"invariant\");\n+  JfrSymbolTable::clear_previous_epoch();\n+  assert(_klass_loader_leakp_set != nullptr, \"invariant\");\n+  initial_klass_loader_leakp_set_size = MAX2(initial_klass_loader_leakp_set_size, _klass_loader_leakp_set->table_size());\n@@ -72,1 +69,0 @@\n-  delete _symbol_table;\n@@ -78,10 +74,1 @@\n-  return _symbol_table->bootstrap_name(leakp);\n-}\n-\n-traceid JfrArtifactSet::mark_hidden_klass_name(const Klass* klass, bool leakp) {\n-  assert(klass->is_instance_klass(), \"invariant\");\n-  return _symbol_table->mark_hidden_klass_name((const InstanceKlass*)klass, leakp);\n-}\n-\n-traceid JfrArtifactSet::mark(uintptr_t hash, const Symbol* sym, bool leakp) {\n-  return _symbol_table->mark(hash, sym, leakp);\n+  return JfrSymbolTable::bootstrap_name(leakp);\n@@ -91,1 +78,1 @@\n-  return _symbol_table->mark(klass, leakp);\n+  return JfrSymbolTable::mark(klass, leakp, _class_unload, _previous_epoch);\n@@ -95,5 +82,1 @@\n-  return _symbol_table->mark(symbol, leakp);\n-}\n-\n-traceid JfrArtifactSet::mark(uintptr_t hash, const char* const str, bool leakp) {\n-  return _symbol_table->mark(hash, str, leakp);\n+  return JfrSymbolTable::mark(symbol, leakp, _class_unload, _previous_epoch);\n@@ -105,0 +88,1 @@\n+\n@@ -132,7 +116,0 @@\n-\n-void JfrArtifactSet::increment_checkpoint_id() {\n-  assert(_symbol_table != nullptr, \"invariant\");\n-  _symbol_table->increment_checkpoint_id();\n-  assert(_klass_loader_leakp_set != nullptr, \"invariant\");\n-  initial_klass_loader_leakp_set_size = MAX2(initial_klass_loader_leakp_set_size, _klass_loader_leakp_set->table_size());\n-}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":13,"deletions":36,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -210,1 +210,0 @@\n-  JfrSymbolTable* _symbol_table;\n@@ -216,0 +215,1 @@\n+  bool _previous_epoch;\n@@ -225,1 +225,0 @@\n-  traceid mark(uintptr_t hash, const Symbol* sym, bool leakp);\n@@ -228,2 +227,0 @@\n-  traceid mark(uintptr_t hash, const char* const str, bool leakp);\n-  traceid mark_hidden_klass_name(const Klass* klass, bool leakp);\n@@ -232,4 +229,0 @@\n-  const JfrSymbolTable::SymbolEntry* map_symbol(const Symbol* symbol) const;\n-  const JfrSymbolTable::SymbolEntry* map_symbol(uintptr_t hash) const;\n-  const JfrSymbolTable::StringEntry* map_string(uintptr_t hash) const;\n-\n@@ -240,1 +233,0 @@\n-  void increment_checkpoint_id();\n@@ -243,3 +235,1 @@\n-  void iterate_symbols(T& functor) {\n-    _symbol_table->iterate_symbols(functor);\n-  }\n+  void iterate_symbols(T& functor);\n@@ -248,3 +238,1 @@\n-  void iterate_strings(T& functor) {\n-    _symbol_table->iterate_strings(functor);\n-  }\n+  void iterate_strings(T& functor);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_CHECKPOINT_TYPES_JFRTYPESETUTILS_INLINE_HPP\n+#define SHARE_JFR_RECORDER_CHECKPOINT_TYPES_JFRTYPESETUTILS_INLINE_HPP\n+\n+#include \"jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp\"\n+\n+#include \"jfr\/support\/jfrSymbolTable.inline.hpp\"\n+\n+template <typename T>\n+inline void JfrArtifactSet::iterate_symbols(T& functor) {\n+  JfrSymbolTable::iterate_symbols(functor, _previous_epoch);\n+}\n+\n+template <typename T>\n+inline void JfrArtifactSet::iterate_strings(T& functor) {\n+  JfrSymbolTable::iterate_strings(functor, _previous_epoch);\n+}\n+\n+#endif \/\/ SHARE_JFR_RECORDER_CHECKPOINT_TYPES_JFRTYPESETUTILS_INLINE_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.inline.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -112,0 +112,1 @@\n+  assert(klass->trace_id() == 0, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"jfr\/support\/jfrSymbolTable.hpp\"\n@@ -318,0 +319,3 @@\n+  if (!create_symbol_table()) {\n+    return false;\n+  }\n@@ -416,0 +420,4 @@\n+bool JfrRecorder::create_symbol_table() {\n+  return JfrSymbolTable::create();\n+}\n+\n@@ -456,0 +464,1 @@\n+  JfrSymbolTable::destroy();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  static bool create_symbol_table();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"jfr\/support\/jfrSymbolTable.inline.hpp\"\n@@ -453,0 +454,1 @@\n+  JfrSymbolTable::allocate_next_epoch();\n@@ -561,0 +563,1 @@\n+  JfrSymbolTable::allocate_next_epoch();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotClassLocation.hpp\"\n+#include \"classfile\/classFileParser.hpp\"\n+#include \"classfile\/classFileStream.hpp\"\n+#include \"classfile\/classLoaderData.inline.hpp\"\n+#include \"jfr\/instrumentation\/jfrClassTransformer.hpp\"\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.inline.hpp\"\n+#include \"jfr\/support\/jfrClassDefineEvent.hpp\"\n+#include \"jfr\/support\/jfrSymbolTable.hpp\"\n+#include \"jfrfiles\/jfrEventClasses.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+\n+ \/*\n+  * Two cases for JDK modules as outlined by JEP 200: The Modular JDK.\n+  *\n+  * The modular structure of the JDK implements the following principles:\n+  * 1. Standard modules, whose specifications are governed by the JCP, have names starting with the string \"java.\".\n+  * 2. All other modules are merely part of the JDK, and have names starting with the string \"jdk.\".\n+  * *\/\n+static inline bool is_jdk_module(const char* module_name) {\n+  assert(module_name != nullptr, \"invariant\");\n+  return strstr(module_name, \"java.\") == module_name || strstr(module_name, \"jdk.\") == module_name;\n+}\n+\n+static inline bool is_unnamed_module(const ModuleEntry* module) {\n+  return module == nullptr || !module->is_named();\n+}\n+\n+static inline bool is_jdk_module(const ModuleEntry* module, JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  if (is_unnamed_module(module)) {\n+    return false;\n+  }\n+  const Symbol* const module_symbol = module->name();\n+  assert(module_symbol != nullptr, \"invariant\");\n+  return is_jdk_module(module_symbol->as_C_string());\n+}\n+\n+static inline bool is_jdk_module(const InstanceKlass* ik, JavaThread* jt) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  return is_jdk_module(ik->module(), jt);\n+}\n+\n+static traceid module_path(const InstanceKlass* ik, JavaThread* jt) {\n+  assert(ik != nullptr, \"invariant\");\n+  const ModuleEntry* const module_entry = ik->module();\n+  if (is_unnamed_module(module_entry)) {\n+    return 0;\n+  }\n+  const char* const module_name = module_entry->name()->as_C_string();\n+  assert(module_name != nullptr, \"invariant\");\n+  if (is_jdk_module(module_name)) {\n+    const size_t module_name_len = strlen(module_name);\n+    char* const path = NEW_RESOURCE_ARRAY_IN_THREAD(jt, char, module_name_len + 6); \/\/ \"jrt:\/\"\n+    jio_snprintf(path, module_name_len + 6, \"%s%s\", \"jrt:\/\", module_name);\n+    return JfrSymbolTable::add(path);\n+  }\n+  return 0;\n+}\n+\n+static traceid caller_path(const InstanceKlass* ik, JavaThread* jt) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(ik->class_loader_data()->is_the_null_class_loader_data(), \"invariant\");\n+  const Klass* const caller = jt->security_get_caller_class(1);\n+  \/\/ caller can be null, for example, during a JVMTI VM_Init hook\n+  if (caller != nullptr) {\n+    const char* caller_name = caller->external_name();\n+    assert(caller_name != nullptr, \"invariant\");\n+    const size_t caller_name_len = strlen(caller_name);\n+    char* const path = NEW_RESOURCE_ARRAY_IN_THREAD(jt, char, caller_name_len + 13); \/\/ \"instance of \"\n+    jio_snprintf(path, caller_name_len + 13, \"%s%s\", \"instance of \", caller_name);\n+    return JfrSymbolTable::add(path);\n+  }\n+  return 0;\n+}\n+\n+static traceid class_loader_path(const InstanceKlass* ik, JavaThread* jt) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+  assert(!ik->class_loader_data()->is_the_null_class_loader_data(), \"invariant\");\n+  oop class_loader = ik->class_loader_data()->class_loader();\n+  const char* class_loader_name = class_loader->klass()->external_name();\n+  return class_loader_name != nullptr ? JfrSymbolTable::add(class_loader_name) : 0;\n+}\n+\n+static inline bool is_not_retransforming(const InstanceKlass* ik, JavaThread* jt) {\n+  return JfrClassTransformer::find_existing_klass(ik, jt) == nullptr;\n+}\n+\n+static traceid get_source(const InstanceKlass* ik, JavaThread* jt) {\n+  traceid source_id = 0;\n+  if (is_jdk_module(ik, jt)) {\n+    source_id = module_path(ik, jt);\n+  } else if (ik->class_loader_data()->is_the_null_class_loader_data()) {\n+    source_id = caller_path(ik, jt);\n+  } else {\n+    source_id = class_loader_path(ik, jt);\n+  }\n+  return source_id;\n+}\n+\n+static traceid get_source(const AOTClassLocation* cl, JavaThread* jt) {\n+  assert(cl != nullptr, \"invariant\");\n+  assert(!cl->is_modules_image(), \"invariant\");\n+  const char* const path = cl->path();\n+  assert(path != nullptr, \"invariant\");\n+  size_t len = strlen(path);\n+  const char* file_type = cl->file_type_string();\n+  assert(file_type != nullptr, \"invariant\");\n+  len += strlen(file_type) + 3; \/\/ \":\/\" + null\n+  char* const url = NEW_RESOURCE_ARRAY_IN_THREAD(jt, char, len);\n+  jio_snprintf(url, len, \"%s%s%s\", file_type, \":\/\", path);\n+  return JfrSymbolTable::add(url);\n+}\n+\n+static inline void send_event(const InstanceKlass* ik, traceid source_id) {\n+  EventClassDefine event;\n+  event.set_definedClass(ik);\n+  event.set_definingClassLoader(ik->class_loader_data());\n+  event.set_source(source_id);\n+  event.commit();\n+}\n+\n+void JfrClassDefineEvent::on_creation(const InstanceKlass* ik, const ClassFileParser& parser, JavaThread* jt) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(ik->trace_id() != 0, \"invariant\");\n+  assert(!parser.is_internal(), \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+\n+  if (EventClassDefine::is_enabled() && is_not_retransforming(ik, jt)) {\n+    ResourceMark rm(jt);\n+    traceid source_id = 0;\n+    const ClassFileStream& stream = parser.stream();\n+    if (stream.source() != nullptr) {\n+      if (stream.from_boot_loader_modules_image()) {\n+        assert(is_jdk_module(ik, jt), \"invariant\");\n+        source_id = module_path(ik, jt);\n+      } else {\n+        source_id = JfrSymbolTable::add(stream.source());\n+      }\n+    } else {\n+      source_id = get_source(ik, jt);\n+    }\n+    send_event(ik, source_id);\n+  }\n+}\n+\n+void JfrClassDefineEvent::on_restoration(const InstanceKlass* ik, JavaThread* jt) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(ik->trace_id() != 0, \"invariant\");\n+  assert(jt != nullptr, \"invariant\");\n+\n+  if (EventClassDefine::is_enabled()) {\n+    ResourceMark rm(jt);\n+    assert(is_not_retransforming(ik, jt), \"invariant\");\n+    const int index = ik->shared_classpath_index();\n+    assert(index >= 0, \"invariant\");\n+    const AOTClassLocation* const cl = AOTClassLocationConfig::runtime()->class_location_at(index);\n+    assert(cl != nullptr, \"invariant\");\n+    send_event(ik, cl->is_modules_image() ? module_path(ik, jt) : get_source(cl, jt));\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrClassDefineEvent.cpp","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRCLASSDEFINEEVENT_HPP\n+#define SHARE_JFR_SUPPORT_JFRCLASSDEFINEEVENT_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+\n+class ClassFileParser;\n+class InstanceKlass;\n+class JavaThread;\n+\n+class JfrClassDefineEvent : AllStatic {\n+ public:\n+  static void on_creation(const InstanceKlass* ik, const ClassFileParser& parser, JavaThread* jt);\n+  static void on_restoration(const InstanceKlass* ik, JavaThread* jt);\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRCLASSDEFINEEVENT_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrClassDefineEvent.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -43,1 +43,0 @@\n-#define ON_KLASS_CREATION(k, p, t) Jfr::on_klass_creation(k, p, t)\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassExtension.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-#include \"jfr\/support\/jfrSymbolTable.hpp\"\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n+#include \"jfr\/support\/jfrSymbolTable.inline.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"runtime\/atomicAccess.hpp\"\n@@ -32,2 +34,3 @@\n-\/\/ incremented on each rotation\n-static u8 checkpoint_id = 1;\n+JfrSymbolTable::Impl* JfrSymbolTable::_epoch_0 = nullptr;\n+JfrSymbolTable::Impl* JfrSymbolTable::_epoch_1 = nullptr;\n+JfrSymbolTable::StringEntry* JfrSymbolTable::_bootstrap = nullptr;\n@@ -35,3 +38,1 @@\n-\/\/ creates a unique id by combining a checkpoint relative symbol id (2^24)\n-\/\/ with the current checkpoint id (2^40)\n-#define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id << 24) | sym_id)))\n+JfrSymbolCallback::JfrSymbolCallback() : _id_counter(2) {} \/\/ 1 is reserved for \"bootstrap\" entry\n@@ -39,2 +40,5 @@\n-static traceid create_symbol_id(traceid artifact_id) {\n-  return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;\n+template <typename T>\n+inline void JfrSymbolCallback::assign_id(const T* entry) {\n+  assert(entry != nullptr, \"invariant\");\n+  assert(entry->id() == 0, \"invariant\");\n+  entry->set_id(AtomicAccess::fetch_then_add(&_id_counter, (traceid)1));\n@@ -43,2 +47,3 @@\n-static uintptr_t string_hash(const char* str) {\n-  return java_lang_String::hash_code(reinterpret_cast<const jbyte*>(str), static_cast<int>(strlen(str)));\n+void JfrSymbolCallback::on_link(const JfrSymbolTable::SymbolEntry* entry) {\n+  assign_id(entry);\n+  const_cast<Symbol*>(entry->literal())->increment_refcount();\n@@ -47,1 +52,4 @@\n-static JfrSymbolTable::StringEntry* bootstrap = nullptr;\n+void JfrSymbolCallback::on_unlink(const JfrSymbolTable::SymbolEntry* entry) {\n+  assert(entry != nullptr, \"invariant\");\n+  const_cast<Symbol*>(entry->literal())->decrement_refcount();\n+}\n@@ -49,1 +57,8 @@\n-static JfrSymbolTable* _instance = nullptr;\n+static const char* resource_to_c_heap_string(const char* resource_str) {\n+  assert(resource_str != nullptr, \"invariant\");\n+  const size_t length = strlen(resource_str);\n+  char* const c_string = JfrCHeapObj::new_array<char>(length + 1);\n+  assert(c_string != nullptr, \"invariant\");\n+  strncpy(c_string, resource_str, length + 1);\n+  return c_string;\n+}\n@@ -51,3 +66,3 @@\n-static JfrSymbolTable& instance() {\n-  assert(_instance != nullptr, \"invariant\");\n-  return *_instance;\n+void JfrSymbolCallback::on_link(const JfrSymbolTable::StringEntry* entry) {\n+  assign_id(entry);\n+  const_cast<JfrSymbolTable::StringEntry*>(entry)->set_literal(resource_to_c_heap_string(entry->literal()));\n@@ -56,5 +71,3 @@\n-JfrSymbolTable* JfrSymbolTable::create() {\n-  assert(_instance == nullptr, \"invariant\");\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  _instance = new JfrSymbolTable();\n-  return _instance;\n+void JfrSymbolCallback::on_unlink(const JfrSymbolTable::StringEntry* entry) {\n+  assert(entry != nullptr, \"invariant\");\n+  JfrCHeapObj::free(const_cast<char*>(entry->literal()), strlen(entry->literal() + 1));\n@@ -63,24 +76,10 @@\n-void JfrSymbolTable::destroy() {\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  if (_instance != nullptr) {\n-    delete _instance;\n-    _instance = nullptr;\n-  }\n-  assert(_instance == nullptr, \"invariant\");\n-}\n-\n-JfrSymbolTable::JfrSymbolTable() :\n-  _symbols(new Symbols(this)),\n-  _strings(new Strings(this)),\n-  _symbol_list(nullptr),\n-  _string_list(nullptr),\n-  _symbol_query(nullptr),\n-  _string_query(nullptr),\n-  _id_counter(1),\n-  _class_unload(false) {\n-  assert(_symbols != nullptr, \"invariant\");\n-  assert(_strings != nullptr, \"invariant\");\n-  bootstrap = new StringEntry(0, (const char*)&BOOTSTRAP_LOADER_NAME);\n-  assert(bootstrap != nullptr, \"invariant\");\n-  bootstrap->set_id(create_symbol_id(1));\n-  _string_list = bootstrap;\n+static JfrSymbolCallback* _callback = nullptr;\n+\n+template <typename T, typename IdType>\n+JfrSymbolTableEntry<T, IdType>::JfrSymbolTableEntry(unsigned hash, const T& data) :\n+  JfrConcurrentHashtableEntry<T, IdType>(hash, data), _serialized(false), _unloading(false), _leakp(false) {}\n+\n+template <typename T, typename IdType>\n+bool JfrSymbolTableEntry<T, IdType>::on_equals(const char* str) {\n+  assert(str != nullptr, \"invariant\");\n+  return strncmp((const char*)this->literal(), str, strlen(str)) == 0;\n@@ -89,5 +88,16 @@\n-JfrSymbolTable::~JfrSymbolTable() {\n-  clear();\n-  delete _symbols;\n-  delete _strings;\n-  delete bootstrap;\n+static const constexpr unsigned max_capacity = 1 << 30;\n+\n+static inline unsigned calculate_capacity(unsigned size, unsigned capacity) {\n+  assert(is_power_of_2(capacity), \"invariant\");\n+  assert(capacity <= max_capacity, \"invariant\");\n+  double load_factor = (double)size \/ (double)capacity;\n+  if (load_factor < 0.75) {\n+    return capacity;\n+  }\n+  do {\n+    capacity <<= 1;\n+    assert(is_power_of_2(capacity), \"invariant\");\n+    guarantee(capacity <= max_capacity, \"overflow\");\n+    load_factor = (double)size \/ (double)capacity;\n+  } while (load_factor >= 0.75);\n+  return capacity;\n@@ -96,4 +106,11 @@\n-void JfrSymbolTable::clear() {\n-  assert(_symbols != nullptr, \"invariant\");\n-  if (_symbols->has_entries()) {\n-    _symbols->clear_entries();\n+bool JfrSymbolTable::create() {\n+  assert(_callback == nullptr, \"invariant\");\n+  \/\/ Allocate callback instance before tables.\n+  _callback = new JfrSymbolCallback();\n+  if (_callback == nullptr) {\n+    return false;\n+  }\n+  assert(_bootstrap == nullptr, \"invariant\");\n+  _bootstrap = new StringEntry(0, (const char*)&BOOTSTRAP_LOADER_NAME);\n+  if (_bootstrap == nullptr) {\n+    return false;\n@@ -101,1 +118,10 @@\n-  assert(!_symbols->has_entries(), \"invariant\");\n+  _bootstrap->set_id(1);\n+  assert(this_epoch_table() == nullptr, \"invariant\");\n+  Impl* table = new JfrSymbolTable::Impl();\n+  if (table == nullptr) {\n+    return false;\n+  }\n+  set_this_epoch(table);\n+  assert(previous_epoch_table() == nullptr, \"invariant\");\n+  return true;\n+}\n@@ -103,3 +129,12 @@\n-  assert(_strings != nullptr, \"invariant\");\n-  if (_strings->has_entries()) {\n-    _strings->clear_entries();\n+void JfrSymbolTable::destroy() {\n+  if (_callback != nullptr) {\n+    delete _callback;\n+    _callback = nullptr;\n+  }\n+  if (_bootstrap != nullptr) {\n+    delete _bootstrap;\n+    _bootstrap = nullptr;\n+  }\n+  if (_epoch_0 != nullptr) {\n+    delete _epoch_0;\n+    _epoch_0 = nullptr;\n@@ -107,1 +142,5 @@\n-  assert(!_strings->has_entries(), \"invariant\");\n+  if (_epoch_1 != nullptr) {\n+    delete _epoch_1;\n+    _epoch_1 = nullptr;\n+  }\n+}\n@@ -109,2 +148,12 @@\n-  _symbol_list = nullptr;\n-  _id_counter = 1;\n+void JfrSymbolTable::allocate_next_epoch() {\n+  assert(nullptr == previous_epoch_table(), \"invariant\");\n+  const Impl* const current = this_epoch_table();\n+  assert(current != nullptr, \"invariant\");\n+  const unsigned next_symbols_capacity = calculate_capacity(current->symbols_size(), current->symbols_capacity());\n+  const unsigned next_strings_capacity = calculate_capacity(current->strings_size(), current->strings_capacity());\n+  assert(_callback != nullptr, \"invariant\");\n+  \/\/ previous epoch to become the next epoch.\n+  set_previous_epoch(new JfrSymbolTable::Impl(next_symbols_capacity, next_strings_capacity));\n+  assert(this_epoch_table() != nullptr, \"invariant\");\n+  assert(previous_epoch_table() != nullptr, \"invariant\");\n+}\n@@ -112,2 +161,9 @@\n-  _symbol_query = nullptr;\n-  _string_query = nullptr;\n+void JfrSymbolTable::clear_previous_epoch() {\n+  Impl* const table = previous_epoch_table();\n+  assert(table != nullptr, \"invariant\");\n+  set_previous_epoch(nullptr);\n+  delete table;\n+  assert(_bootstrap != nullptr, \"invariant\");\n+  _bootstrap->reset();\n+  assert(!_bootstrap->is_serialized(), \"invariant\");\n+}\n@@ -115,3 +171,8 @@\n-  assert(bootstrap != nullptr, \"invariant\");\n-  bootstrap->reset();\n-  _string_list = bootstrap;\n+void JfrSymbolTable::set_this_epoch(JfrSymbolTable::Impl* table) {\n+  assert(table != nullptr, \"invariant\");\n+  const u1 epoch = JfrTraceIdEpoch::current();\n+  if (epoch == 0) {\n+    _epoch_0 = table;\n+  } else {\n+    _epoch_1 = table;\n+  }\n@@ -120,2 +181,7 @@\n-void JfrSymbolTable::set_class_unload(bool class_unload) {\n-  _class_unload = class_unload;\n+void JfrSymbolTable::set_previous_epoch(JfrSymbolTable::Impl* table) {\n+  const u1 epoch = JfrTraceIdEpoch::previous();\n+  if (epoch == 0) {\n+    _epoch_0 = table;\n+  } else {\n+    _epoch_1 = table;\n+  }\n@@ -124,4 +190,2 @@\n-void JfrSymbolTable::increment_checkpoint_id() {\n-  assert_lock_strong(ClassLoaderDataGraph_lock);\n-  clear();\n-  ++checkpoint_id;\n+inline bool JfrSymbolTable::Impl::has_symbol_entries() const {\n+  return _symbols->is_nonempty();\n@@ -130,5 +194,2 @@\n-template <typename T>\n-inline void JfrSymbolTable::assign_id(T* entry) {\n-  assert(entry != nullptr, \"invariant\");\n-  assert(entry->id() == 0, \"invariant\");\n-  entry->set_id(create_symbol_id(++_id_counter));\n+inline bool JfrSymbolTable::Impl::has_string_entries() const {\n+  return _strings->is_nonempty();\n@@ -137,5 +198,2 @@\n-void JfrSymbolTable::on_link(const SymbolEntry* entry) {\n-  assign_id(entry);\n-  const_cast<Symbol*>(entry->literal())->increment_refcount();\n-  entry->set_list_next(_symbol_list);\n-  _symbol_list = entry;\n+inline bool JfrSymbolTable::Impl::has_entries() const {\n+  return has_symbol_entries() || has_string_entries();\n@@ -144,5 +202,2 @@\n-bool JfrSymbolTable::on_equals(uintptr_t hash, const SymbolEntry* entry) {\n-  assert(entry != nullptr, \"invariant\");\n-  assert(entry->hash() == hash, \"invariant\");\n-  assert(_symbol_query != nullptr, \"invariant\");\n-  return _symbol_query == entry->literal();\n+inline unsigned JfrSymbolTable::Impl::symbols_capacity() const {\n+  return _symbols->capacity();\n@@ -151,3 +206,2 @@\n-void JfrSymbolTable::on_unlink(const SymbolEntry* entry) {\n-  assert(entry != nullptr, \"invariant\");\n-  const_cast<Symbol*>(entry->literal())->decrement_refcount();\n+inline unsigned JfrSymbolTable::Impl::symbols_size() const {\n+  return _symbols->size();\n@@ -156,7 +210,2 @@\n-static const char* resource_to_c_heap_string(const char* resource_str) {\n-  assert(resource_str != nullptr, \"invariant\");\n-  const size_t length = strlen(resource_str);\n-  char* const c_string = JfrCHeapObj::new_array<char>(length + 1);\n-  assert(c_string != nullptr, \"invariant\");\n-  strncpy(c_string, resource_str, length + 1);\n-  return c_string;\n+inline unsigned JfrSymbolTable::Impl::strings_capacity() const {\n+  return _strings->capacity();\n@@ -165,5 +214,2 @@\n-void JfrSymbolTable::on_link(const StringEntry* entry) {\n-  assign_id(entry);\n-  const_cast<StringEntry*>(entry)->set_literal(resource_to_c_heap_string(entry->literal()));\n-  entry->set_list_next(_string_list);\n-  _string_list = entry;\n+inline unsigned JfrSymbolTable::Impl::strings_size() const {\n+  return _strings->size();\n@@ -172,5 +218,4 @@\n-static bool string_compare(const char* query, const char* candidate) {\n-  assert(query != nullptr, \"invariant\");\n-  assert(candidate != nullptr, \"invariant\");\n-  const size_t length = strlen(query);\n-  return strncmp(query, candidate, length) == 0;\n+bool JfrSymbolTable::has_entries(bool previous_epoch \/* false *\/) {\n+  const Impl* table = previous_epoch ? previous_epoch_table() : this_epoch_table();\n+  assert(table != nullptr, \"invariant\");\n+  return table->has_entries();\n@@ -179,5 +224,4 @@\n-bool JfrSymbolTable::on_equals(uintptr_t hash, const StringEntry* entry) {\n-  assert(entry != nullptr, \"invariant\");\n-  assert(entry->hash() == hash, \"invariant\");\n-  assert(_string_query != nullptr, \"invariant\");\n-  return string_compare(_string_query, entry->literal());\n+bool JfrSymbolTable::has_symbol_entries(bool previous_epoch \/* false *\/) {\n+  const Impl* table = previous_epoch ? previous_epoch_table() : this_epoch_table();\n+  assert(table != nullptr, \"invariant\");\n+  return table->has_symbol_entries();\n@@ -186,3 +230,4 @@\n-void JfrSymbolTable::on_unlink(const StringEntry* entry) {\n-  assert(entry != nullptr, \"invariant\");\n-  JfrCHeapObj::free(const_cast<char*>(entry->literal()), strlen(entry->literal() + 1));\n+bool JfrSymbolTable::has_string_entries(bool previous_epoch \/* false *\/) {\n+  const Impl* table = previous_epoch ? previous_epoch_table() : this_epoch_table();\n+  assert(table != nullptr, \"invariant\");\n+  return table->has_string_entries();\n@@ -192,1 +237,1 @@\n-  assert(bootstrap != nullptr, \"invariant\");\n+  assert(_bootstrap != nullptr, \"invariant\");\n@@ -194,1 +239,1 @@\n-    bootstrap->set_leakp();\n+    _bootstrap->set_leakp();\n@@ -196,1 +241,1 @@\n-  return bootstrap->id();\n+  return _bootstrap->id();\n@@ -199,1 +244,9 @@\n-traceid JfrSymbolTable::mark(const Symbol* sym, bool leakp \/* false *\/) {\n+JfrSymbolTable::Impl::Impl(unsigned symbols_capacity \/* 0*\/, unsigned strings_capacity \/* 0 *\/) :\n+  _symbols(new Symbols(_callback, symbols_capacity)), _strings(new Strings(_callback, strings_capacity)) {}\n+\n+JfrSymbolTable::Impl::~Impl() {\n+  delete _symbols;\n+  delete _strings;\n+}\n+\n+traceid JfrSymbolTable::Impl::mark(const Symbol* sym, bool leakp \/* false *\/, bool class_unload \/* false *\/) {\n@@ -201,1 +254,1 @@\n-  return mark(sym->identity_hash(), sym, leakp);\n+  return mark(sym->identity_hash(), sym, leakp, class_unload);\n@@ -204,1 +257,1 @@\n-traceid JfrSymbolTable::mark(uintptr_t hash, const Symbol* sym, bool leakp) {\n+traceid JfrSymbolTable::Impl::mark(unsigned hash, const Symbol* sym, bool leakp, bool class_unload \/* false *\/) {\n@@ -207,5 +260,2 @@\n-  _symbol_query = sym;\n-  const SymbolEntry& entry = _symbols->lookup_put(hash, sym);\n-  if (_class_unload) {\n-    entry.set_unloading();\n-  }\n+  const SymbolEntry* entry = _symbols->lookup_put(hash, sym);\n+  assert(entry != nullptr, \"invariant\");\n@@ -213,1 +263,3 @@\n-    entry.set_leakp();\n+    entry->set_leakp();\n+  } else if (class_unload) {\n+    entry->set_unloading();\n@@ -215,1 +267,11 @@\n-  return entry.id();\n+  return entry->id();\n+}\n+\n+traceid JfrSymbolTable::mark(const Symbol* sym, bool leakp \/* false *\/, bool class_unload \/* false *\/, bool previous_epoch \/* false *\/) {\n+  Impl* const table = previous_epoch ? previous_epoch_table() : this_epoch_table();\n+  assert(table != nullptr, \"invariant\");\n+  return table->mark(sym->identity_hash(), sym, leakp, class_unload);\n+}\n+\n+static inline unsigned string_hash(const char* str) {\n+  return java_lang_String::hash_code(reinterpret_cast<const jbyte*>(str), static_cast<int>(strlen(str)));\n@@ -218,2 +280,2 @@\n-traceid JfrSymbolTable::mark(const char* str, bool leakp \/* false*\/) {\n-  return mark(string_hash(str), str, leakp);\n+traceid JfrSymbolTable::Impl::mark(const char* str, bool leakp \/* false*\/, bool class_unload \/* false *\/) {\n+  return mark(string_hash(str), str, leakp, class_unload);\n@@ -222,1 +284,1 @@\n-traceid JfrSymbolTable::mark(uintptr_t hash, const char* str, bool leakp) {\n+traceid JfrSymbolTable::Impl::mark(unsigned hash, const char* str, bool leakp, bool class_unload \/* false *\/) {\n@@ -225,5 +287,2 @@\n-  _string_query = str;\n-  const StringEntry& entry = _strings->lookup_put(hash, str);\n-  if (_class_unload) {\n-    entry.set_unloading();\n-  }\n+  const StringEntry* entry = _strings->lookup_put(hash, str);\n+  assert(entry != nullptr, \"invariant\");\n@@ -231,1 +290,3 @@\n-    entry.set_leakp();\n+    entry->set_leakp();\n+  } else if (class_unload) {\n+    entry->set_unloading();\n@@ -233,1 +294,7 @@\n-  return entry.id();\n+  return entry->id();\n+}\n+\n+traceid JfrSymbolTable::mark(unsigned hash, const char* str, bool leakp, bool class_unload \/* false *\/, bool previous_epoch \/* false *\/) {\n+  Impl* const table = previous_epoch ? previous_epoch_table() : this_epoch_table();\n+  assert(table != nullptr, \"invariant\");\n+  return table->mark(hash, str, leakp, class_unload);\n@@ -244,1 +311,1 @@\n-traceid JfrSymbolTable::mark_hidden_klass_name(const Klass* k, bool leakp) {\n+inline traceid JfrSymbolTable::Impl::mark_hidden_klass_name(const Klass* k, bool leakp, bool class_unload \/* false *\/) {\n@@ -247,2 +314,1 @@\n-  const uintptr_t hash = k->name()->identity_hash();\n-  return mark(hash, k->external_name(), leakp);\n+  return mark(k->name()->identity_hash(), k->external_name(), leakp, class_unload);\n@@ -251,1 +317,1 @@\n-traceid JfrSymbolTable::mark(const Klass* k, bool leakp) {\n+traceid JfrSymbolTable::Impl::mark(const Klass* k, bool leakp, bool class_unload \/* false *\/) {\n@@ -255,1 +321,1 @@\n-    symbol_id = mark_hidden_klass_name(k, leakp);\n+    symbol_id = mark_hidden_klass_name(k, leakp, class_unload);\n@@ -259,1 +325,1 @@\n-      symbol_id = mark(sym, leakp);\n+      symbol_id = mark(sym, leakp, class_unload);\n@@ -266,2 +332,7 @@\n-template <typename T>\n-traceid JfrSymbolTable::add_impl(const T* sym) {\n+traceid JfrSymbolTable::mark(const Klass* k, bool leakp, bool class_unload \/* false *\/, bool previous_epoch \/* false *\/) {\n+  Impl* const table = previous_epoch ? previous_epoch_table() : this_epoch_table();\n+  assert(table != nullptr, \"invariant\");\n+  return table->mark(k, leakp, class_unload);\n+}\n+\n+inline traceid JfrSymbolTable::Impl::add(const Symbol* sym) {\n@@ -269,3 +340,6 @@\n-  assert(_instance != nullptr, \"invariant\");\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  return instance().mark(sym);\n+  return _symbols->lookup_put(sym->identity_hash(), sym)->id();\n+}\n+\n+traceid JfrSymbolTable::Impl::add(const char* str) {\n+  assert(str != nullptr, \"invariant\");\n+  return _strings->lookup_put(string_hash(str), str)->id();\n@@ -274,2 +348,2 @@\n-traceid JfrSymbolTable::add(const Symbol* sym) {\n-  return add_impl(sym);\n+inline traceid JfrSymbolTable::add(const Symbol* sym) {\n+  return this_epoch_table()->add(sym);\n@@ -279,1 +353,1 @@\n-  return add_impl(str);\n+  return this_epoch_table()->add(str);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":225,"deletions":151,"binary":false,"changes":376,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-#include \"jfr\/utilities\/jfrHashtable.hpp\"\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+#include \"jfr\/utilities\/jfrConcurrentHashtable.hpp\"\n@@ -32,1 +33,1 @@\n-class ListEntry : public JfrHashtableEntry<T, IdType> {\n+class JfrSymbolTableEntry : public JfrConcurrentHashtableEntry<T, IdType> {\n@@ -34,7 +35,1 @@\n-  ListEntry(uintptr_t hash, const T& data) : JfrHashtableEntry<T, IdType>(hash, data),\n-    _list_next(nullptr), _serialized(false), _unloading(false), _leakp(false) {}\n-  const ListEntry<T, IdType>* list_next() const { return _list_next; }\n-  void reset() const {\n-    _list_next = nullptr; _serialized = false; _unloading = false; _leakp = false;\n-  }\n-  void set_list_next(const ListEntry<T, IdType>* next) const { _list_next = next; }\n+  JfrSymbolTableEntry(unsigned hash, const T& data);\n@@ -47,0 +42,13 @@\n+  void reset() const {\n+    _serialized = false;\n+    _unloading = false;\n+    _leakp = false;\n+  }\n+\n+  bool on_equals(const Symbol* sym) {\n+    assert(sym != nullptr, \"invariant\");\n+    return sym == (const Symbol*)this->literal();\n+  }\n+\n+  bool on_equals(const char* str);\n+\n@@ -48,1 +56,0 @@\n-  mutable const ListEntry<T, IdType>* _list_next;\n@@ -54,0 +61,19 @@\n+class JfrSymbolCallback : public JfrCHeapObj {\n+  friend class JfrSymbolTable;\n+ public:\n+  typedef JfrConcurrentHashTableHost<const Symbol*, traceid, JfrSymbolTableEntry, JfrSymbolCallback> Symbols;\n+  typedef JfrConcurrentHashTableHost<const char*, traceid, JfrSymbolTableEntry, JfrSymbolCallback> Strings;\n+\n+  void on_link(const Symbols::Entry* entry);\n+  void on_unlink(const Symbols::Entry* entry);\n+  void on_link(const Strings::Entry* entry);\n+  void on_unlink(const Strings::Entry* entry);\n+\n+ private:\n+  traceid _id_counter;\n+\n+  JfrSymbolCallback();\n+  template <typename T>\n+  void assign_id(const T* entry);\n+};\n+\n@@ -61,3 +87,0 @@\n- * The table is cleared as part of rotation.\n- *\n- * Caller must ensure mutual exclusion by means of the ClassLoaderDataGraph_lock or by safepointing.\n@@ -65,5 +88,1 @@\n-class JfrSymbolTable : public JfrCHeapObj {\n-  template <typename, typename, template<typename, typename> class, typename, size_t>\n-  friend class HashTableHost;\n-  typedef HashTableHost<const Symbol*, traceid, ListEntry, JfrSymbolTable> Symbols;\n-  typedef HashTableHost<const char*, traceid, ListEntry, JfrSymbolTable> Strings;\n+class JfrSymbolTable : public AllStatic {\n@@ -71,0 +90,8 @@\n+  template <typename, typename, template<typename, typename> class, typename, unsigned>\n+  friend class JfrConcurrentHashTableHost;\n+  friend class JfrRecorder;\n+  friend class JfrRecorderService;\n+  friend class JfrSymbolCallback;\n+\n+  typedef JfrConcurrentHashTableHost<const Symbol*, traceid, JfrSymbolTableEntry, JfrSymbolCallback> Symbols;\n+  typedef JfrConcurrentHashTableHost<const char*, traceid, JfrSymbolTableEntry, JfrSymbolCallback> Strings;\n@@ -73,2 +100,2 @@\n-  typedef Symbols::HashEntry SymbolEntry;\n-  typedef Strings::HashEntry StringEntry;\n+  typedef Symbols::Entry SymbolEntry;\n+  typedef Strings::Entry StringEntry;\n@@ -80,8 +107,32 @@\n-  Symbols* _symbols;\n-  Strings* _strings;\n-  const SymbolEntry* _symbol_list;\n-  const StringEntry* _string_list;\n-  const Symbol* _symbol_query;\n-  const char* _string_query;\n-  traceid _id_counter;\n-  bool _class_unload;\n+  class Impl : public JfrCHeapObj {\n+    friend class JfrSymbolTable;\n+   private:\n+    Symbols* _symbols;\n+    Strings* _strings;\n+\n+    Impl(unsigned symbol_capacity = 0, unsigned string_capacity = 0);\n+    ~Impl();\n+\n+    void clear();\n+\n+    traceid add(const Symbol* sym);\n+    traceid add(const char* str);\n+\n+    traceid mark(unsigned hash, const Symbol* sym, bool leakp, bool class_unload = false);\n+    traceid mark(const Klass* k, bool leakp, bool class_unload = false);\n+    traceid mark(const Symbol* sym, bool leakp = false, bool class_unload = false);\n+    traceid mark(const char* str, bool leakp = false, bool class_unload = false);\n+    traceid mark(unsigned hash, const char* str, bool leakp, bool class_unload = false);\n+    traceid mark_hidden_klass_name(const Klass* k, bool leakp, bool class_unload = false);\n+\n+    bool has_entries() const;\n+    bool has_symbol_entries() const;\n+    bool has_string_entries() const;\n+\n+    unsigned symbols_capacity() const;\n+    unsigned symbols_size() const;\n+    unsigned strings_capacity() const;\n+    unsigned strings_size() const;\n+\n+    template <typename Functor>\n+    void iterate_symbols(Functor& functor);\n@@ -89,3 +140,9 @@\n-  JfrSymbolTable();\n-  ~JfrSymbolTable();\n-  static JfrSymbolTable* create();\n+    template <typename Functor>\n+    void iterate_strings(Functor& functor);\n+  };\n+\n+  static Impl* _epoch_0;\n+  static Impl* _epoch_1;\n+  static StringEntry* _bootstrap;\n+\n+  static bool create();\n@@ -94,23 +151,5 @@\n-  void clear();\n-  void increment_checkpoint_id();\n-  void set_class_unload(bool class_unload);\n-\n-  traceid mark(uintptr_t hash, const Symbol* sym, bool leakp);\n-  traceid mark(const Klass* k, bool leakp);\n-  traceid mark(const Symbol* sym, bool leakp = false);\n-  traceid mark(const char* str, bool leakp = false);\n-  traceid mark(uintptr_t hash, const char* str, bool leakp);\n-  traceid mark_hidden_klass_name(const Klass* k, bool leakp);\n-  traceid bootstrap_name(bool leakp);\n-\n-  bool has_entries() const { return has_symbol_entries() || has_string_entries(); }\n-  bool has_symbol_entries() const { return _symbol_list != nullptr; }\n-  bool has_string_entries() const { return _string_list != nullptr; }\n-\n-  \/\/ hashtable(s) callbacks\n-  void on_link(const SymbolEntry* entry);\n-  bool on_equals(uintptr_t hash, const SymbolEntry* entry);\n-  void on_unlink(const SymbolEntry* entry);\n-  void on_link(const StringEntry* entry);\n-  bool on_equals(uintptr_t hash, const StringEntry* entry);\n-  void on_unlink(const StringEntry* entry);\n+  static Impl* this_epoch_table();\n+  static Impl* previous_epoch_table();\n+  static Impl* epoch_table_selector(u1 epoch);\n+  static void set_this_epoch(Impl* table);\n+  static void set_previous_epoch(Impl* table);\n@@ -118,2 +157,2 @@\n-  template <typename T>\n-  static traceid add_impl(const T* sym);\n+  static void clear_previous_epoch();\n+  static void allocate_next_epoch();\n@@ -121,2 +160,3 @@\n-  template <typename T>\n-  void assign_id(T* entry);\n+  static bool has_entries(bool previous_epoch = false);\n+  static bool has_symbol_entries(bool previous_epoch = false);\n+  static bool has_string_entries(bool previous_epoch = false);\n@@ -124,4 +164,4 @@\n-  template <typename Functor>\n-  void iterate_symbols(Functor& functor) {\n-    iterate(functor, _symbol_list);\n-  }\n+  static traceid mark(const Klass* k, bool leakp, bool class_unload = false, bool previous_epoch = false);\n+  static traceid mark(const Symbol* sym, bool leakp = false, bool class_unload = false, bool previous_epoch = false);\n+  static traceid mark(unsigned hash, const char* str, bool leakp, bool class_unload = false, bool previous_epoch = false);\n+  static traceid bootstrap_name(bool leakp);\n@@ -130,3 +170,1 @@\n-  void iterate_strings(Functor& functor) {\n-    iterate(functor, _string_list);\n-  }\n+  static void iterate_symbols(Functor& functor, bool previous_epoch = false);\n@@ -134,9 +172,2 @@\n-  template <typename Functor, typename T>\n-  void iterate(Functor& functor, const T* list) {\n-    const T* symbol = list;\n-    while (symbol != nullptr) {\n-      const T* next = symbol->list_next();\n-      functor(symbol);\n-      symbol = next;\n-    }\n-  }\n+  template <typename Functor>\n+  static void iterate_strings(Functor& functor, bool previous_epoch = false);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.hpp","additions":106,"deletions":75,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRSYMBOLTABLE_INLINE_HPP\n+#define SHARE_JFR_SUPPORT_JFRSYMBOLTABLE_INLINE_HPP\n+\n+#include \"jfr\/support\/jfrSymbolTable.hpp\"\n+\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n+#include \"jfr\/utilities\/jfrConcurrentHashtable.inline.hpp\"\n+\n+inline JfrSymbolTable::Impl* JfrSymbolTable::epoch_table_selector(u1 epoch) {\n+  return epoch == 0 ? _epoch_0 : _epoch_1;\n+}\n+\n+inline JfrSymbolTable::Impl* JfrSymbolTable::this_epoch_table() {\n+  return epoch_table_selector(JfrTraceIdEpoch::current());\n+}\n+\n+inline JfrSymbolTable::Impl* JfrSymbolTable::previous_epoch_table() {\n+  return epoch_table_selector(JfrTraceIdEpoch::previous());\n+}\n+\n+template <typename Functor>\n+inline void JfrSymbolTable::Impl::iterate_symbols(Functor& functor) {\n+  _symbols->iterate_entry(functor);\n+}\n+\n+template <typename Functor>\n+inline void JfrSymbolTable::iterate_symbols(Functor& functor, bool previous_epoch \/* false *\/) {\n+  Impl* const table = previous_epoch ? previous_epoch_table() : this_epoch_table();\n+  assert(table != nullptr, \"invariant\");\n+  table->iterate_symbols(functor);\n+}\n+\n+template <typename Functor>\n+inline void JfrSymbolTable::Impl::iterate_strings(Functor& functor) {\n+  _strings->iterate_entry(functor);\n+}\n+\n+template <typename Functor>\n+inline void JfrSymbolTable::iterate_strings(Functor& functor, bool previous_epoch \/* false *\/) {\n+  Impl* const table = previous_epoch ? previous_epoch_table() : this_epoch_table();\n+  assert(table != nullptr, \"invariant\");\n+  if (!functor(_bootstrap)) {\n+    return;\n+  }\n+  table->iterate_strings(functor);\n+}\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRSYMBOLTABLE_INLINE_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.inline.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -45,1 +45,0 @@\n-#define RESTORE_ID(k) JfrTraceId::restore(k);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTraceIdExtension.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_UTILITIES_JFRCONCURRENTHASHTABLE_HPP\n+#define SHARE_JFR_UTILITIES_JFRCONCURRENTHASHTABLE_HPP\n+\n+#include \"jfr\/utilities\/jfrLinkedList.hpp\"\n+#include \"memory\/allocation.hpp\"\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry>\n+class JfrConcurrentAscendingId {\n+private:\n+  IdType _id;\n+public:\n+  JfrConcurrentAscendingId() : _id(1) {}\n+  \/\/ Callbacks.\n+  void on_link(TableEntry<T, IdType>* entry);\n+  bool on_equals(unsigned hash, const TableEntry<T, IdType>* entry);\n+};\n+\n+template <typename T, typename IdType>\n+class JfrConcurrentHashtableEntry : public CHeapObj<mtTracing> {\n+  template <typename, typename>\n+  friend class JfrLinkedList;\n+ private:\n+  typedef JfrConcurrentHashtableEntry<T, IdType> Entry;\n+  Entry* _next;\n+  T _literal;          \/\/ ref to item in table.\n+  mutable IdType _id;\n+  unsigned _hash;\n+\n+ public:\n+  JfrConcurrentHashtableEntry(unsigned hash, const T& data) : _next(nullptr), _literal(data), _id(0), _hash(hash) {}\n+  unsigned hash() const { return _hash; }\n+  T literal() const { return _literal; }\n+  T* literal_addr() { return &_literal; }\n+  void set_literal(T s) { _literal = s; }\n+  void set_next(Entry* next) { _next = next; }\n+  Entry* next() const { return _next; }\n+  Entry** next_addr() { return &_next; }\n+  IdType id() const { return _id; }\n+  void set_id(IdType id) const { _id = id; }\n+  T& value() const { return *const_cast<Entry*>(this)->literal_addr(); }\n+  const T* value_addr() const { return const_cast<Entry*>(this)->literal_addr(); }\n+};\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry>\n+class JfrConcurrentHashtable : public CHeapObj<mtTracing> {\n+ public:\n+  typedef TableEntry<T, IdType> Entry;\n+  typedef JfrLinkedList<Entry> Bucket;\n+\n+  unsigned capacity() const { return _capacity; }\n+  unsigned size() const;\n+\n+ protected:\n+  JfrConcurrentHashtable(unsigned size);\n+  ~JfrConcurrentHashtable();\n+\n+  unsigned index(unsigned hash) const {\n+    return hash & _mask;\n+  }\n+\n+  Bucket& bucket(unsigned idx) { return _buckets[idx]; }\n+  Bucket* bucket_addr(unsigned idx) { return &_buckets[idx]; }\n+  Entry* head(unsigned idx) { return bucket(idx).head(); }\n+\n+  bool try_add(unsigned idx, Entry* entry, Entry* next);\n+\n+  template <typename Callback>\n+  void iterate(Callback& cb);\n+\n+  template <typename Callback>\n+  void iterate(unsigned idx, Callback& cb);\n+\n+  template <typename Callback>\n+  static void iterate(Entry* entry, Callback& cb);\n+\n+  void unlink_entry(Entry* entry);\n+\n+ private:\n+  Bucket* _buckets;\n+  unsigned _capacity;\n+  unsigned _mask;\n+  unsigned _size;\n+};\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry,\n+  typename Callback = JfrConcurrentAscendingId<IdType,T, TableEntry>, unsigned TABLE_CAPACITY = 1024>\n+class JfrConcurrentHashTableHost : public JfrConcurrentHashtable<T, IdType, TableEntry> {\n+ public:\n+  typedef TableEntry<T, IdType> Entry;\n+  JfrConcurrentHashTableHost(unsigned initial_capacity = 0);\n+  JfrConcurrentHashTableHost(Callback* cb, unsigned initial_capacity = 0);\n+  ~JfrConcurrentHashTableHost();\n+\n+  \/\/ lookup entry, will put if not found\n+  Entry* lookup_put(unsigned hash, const T& data);\n+\n+  \/\/ id retrieval\n+  IdType id(unsigned hash, const T& data);\n+\n+  void clear();\n+  bool is_empty() const;\n+  bool is_nonempty() const { return !is_empty(); }\n+\n+\n+  template <typename Functor>\n+  void iterate_value(Functor& f);\n+\n+  template <typename Functor>\n+  void iterate_entry(Functor& f);\n+\n+ private:\n+  Callback* _callback;\n+\n+  Entry* new_entry(unsigned hash, const T& data);\n+};\n+\n+#endif \/\/ SHARE_JFR_UTILITIES_JFRCONCURRENTHASHTABLE_HPP\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrConcurrentHashtable.hpp","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_UTILITIES_JFRCONCURRENTHASHTABLE_INLINE_HPP\n+#define SHARE_JFR_UTILITIES_JFRCONCURRENTHASHTABLE_INLINE_HPP\n+\n+#include \"jfr\/utilities\/jfrConcurrentHashtable.hpp\"\n+\n+#include \"jfr\/utilities\/jfrLinkedList.inline.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"nmt\/memTracker.hpp\"\n+#include \"runtime\/atomicAccess.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry>\n+inline void JfrConcurrentAscendingId<T, IdType, TableEntry>::on_link(TableEntry<T, IdType>* entry) {\n+  assert(entry != nullptr, \"invariant\");\n+  assert(entry->id() == 0, \"invariant\");\n+  entry->set_id(AtomicAccess::fetch_then_and(&_id, static_cast<IdType>(1)));\n+}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry>\n+inline bool JfrConcurrentAscendingId<T, IdType, TableEntry>::on_equals(unsigned hash, const TableEntry<T, IdType>* entry) {\n+  assert(entry != nullptr, \"invariant\");\n+  assert(entry->hash() == hash, \"invariant\");\n+  return true;\n+}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry>\n+inline JfrConcurrentHashtable<T, IdType, TableEntry>::JfrConcurrentHashtable(unsigned initial_capacity) :\n+  _buckets(nullptr), _capacity(initial_capacity), _mask(initial_capacity - 1), _size(0) {\n+  assert(initial_capacity >= 2, \"invariant\");\n+  assert(is_power_of_2(initial_capacity), \"invariant\");\n+  _buckets = NEW_C_HEAP_ARRAY2(Bucket, initial_capacity, mtTracing, CURRENT_PC);\n+  memset((void*)_buckets, 0, initial_capacity * sizeof(Bucket));\n+}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry>\n+inline JfrConcurrentHashtable<T, IdType, TableEntry>::~JfrConcurrentHashtable() {\n+  FREE_C_HEAP_ARRAY(Bucket, _buckets);\n+}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry>\n+inline unsigned JfrConcurrentHashtable<T, IdType, TableEntry>::size() const {\n+  return AtomicAccess::load(&_size);\n+}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry>\n+template <typename Callback>\n+inline void JfrConcurrentHashtable<T, IdType, TableEntry>::iterate(unsigned idx, Callback& cb) {\n+  assert(idx < _capacity, \"invariant\");\n+  bucket(idx).iterate(cb);\n+}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry>\n+template <typename Callback>\n+inline void JfrConcurrentHashtable<T, IdType, TableEntry>::iterate(Callback& cb) {\n+  for (unsigned i = 0; i < _capacity; ++i) {\n+    iterate(i, cb);\n+  }\n+}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry>\n+template <typename Callback>\n+inline void JfrConcurrentHashtable<T, IdType, TableEntry>::iterate(TableEntry<T, IdType>* entry, Callback& cb) {\n+  Bucket::iterate(entry, cb);\n+}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry>\n+inline bool JfrConcurrentHashtable<T, IdType, TableEntry>::try_add(unsigned idx, TableEntry<T, IdType>* entry, TableEntry<T, IdType>* next) {\n+  assert(entry != nullptr, \"invariant\");\n+  entry->set_next(next);\n+  const bool added = bucket(idx).try_add(entry, next);\n+  if (added) {\n+    AtomicAccess::inc(&_size);\n+  }\n+  return added;\n+}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry>\n+inline void JfrConcurrentHashtable<T, IdType, TableEntry>::unlink_entry(TableEntry<T, IdType>* entry) {\n+  AtomicAccess::dec(&_size);\n+}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry, typename Callback, unsigned TABLE_CAPACITY>\n+inline JfrConcurrentHashTableHost<T, IdType, TableEntry, Callback, TABLE_CAPACITY>::JfrConcurrentHashTableHost(unsigned initial_capacity \/* 0 *\/) :\n+  JfrConcurrentHashtable<T, IdType, TableEntry>(initial_capacity == 0 ? TABLE_CAPACITY : initial_capacity), _callback(new Callback()) {}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry, typename Callback, unsigned TABLE_CAPACITY>\n+inline JfrConcurrentHashTableHost<T, IdType, TableEntry, Callback, TABLE_CAPACITY>::JfrConcurrentHashTableHost(Callback* cb, unsigned initial_capacity \/* 0 *\/) :\n+  JfrConcurrentHashtable<T, IdType, TableEntry>(initial_capacity == 0 ? TABLE_CAPACITY : initial_capacity), _callback(cb) {}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry, typename Callback, unsigned TABLE_CAPACITY>\n+inline JfrConcurrentHashTableHost<T, IdType, TableEntry, Callback, TABLE_CAPACITY>::~JfrConcurrentHashTableHost() {\n+  clear();\n+}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry, typename Callback, unsigned TABLE_CAPACITY>\n+inline bool JfrConcurrentHashTableHost<T, IdType, TableEntry, Callback, TABLE_CAPACITY>::is_empty() const {\n+  return this->size() == 0;\n+}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry, typename Callback, unsigned TABLE_CAPACITY>\n+inline TableEntry<T, IdType>* JfrConcurrentHashTableHost<T, IdType, TableEntry, Callback, TABLE_CAPACITY>::new_entry(unsigned hash, const T& data) {\n+  Entry* const entry = new Entry(hash, data);\n+  assert(entry != nullptr, \"invariant\");\n+  assert(0 == entry->id(), \"invariant\");\n+  _callback->on_link(entry);\n+  assert(0 != entry->id(), \"invariant\");\n+  return entry;\n+}\n+\n+template <typename T, typename Entry, typename Callback>\n+class JfrConcurrentHashtableLookup {\n+ private:\n+  Callback* const _cb;\n+  const T& _data;\n+  Entry* _found;\n+  unsigned _hash;\n+ public:\n+  JfrConcurrentHashtableLookup(unsigned hash, const T& data, Callback* cb) : _cb(cb), _data(data), _found(nullptr), _hash(hash) {}\n+\n+  bool process(Entry* entry) {\n+    assert(entry != nullptr, \"invariant\");\n+    if (entry->hash() == _hash && entry->on_equals(_data)) {\n+      _found = entry;\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  bool found() const { return _found != nullptr; }\n+  Entry* result() const { return _found; }\n+};\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry, typename Callback, unsigned TABLE_CAPACITY>\n+inline TableEntry<T, IdType>* JfrConcurrentHashTableHost<T, IdType, TableEntry, Callback, TABLE_CAPACITY>::lookup_put(unsigned hash, const T& data) {\n+  JfrConcurrentHashtableLookup<T, Entry, Callback> lookup(hash, data, _callback);\n+  const unsigned idx = this->index(hash);\n+  Entry* entry = nullptr;\n+  while (true) {\n+    assert(!lookup.found(), \"invariant\");\n+    Entry* next = this->head(idx);\n+    if (next != nullptr) {\n+      JfrConcurrentHashtable<T, IdType, TableEntry>::iterate(next, lookup);\n+      if (lookup.found()) {\n+        if (entry != nullptr) {\n+          _callback->on_unlink(entry);\n+          delete entry;\n+        }\n+        entry = lookup.result();\n+        break;\n+      }\n+    }\n+    if (entry == nullptr) {\n+      entry = new_entry(hash, data);\n+    }\n+    assert(entry != nullptr, \"invariant\");\n+    if (this->try_add(idx, entry, next)) {\n+      break;\n+    }\n+    \/\/ Concurrent insertion to this bucket. Retry.\n+  }\n+  assert(entry != nullptr, \"invariant\");\n+  return entry;\n+}\n+\n+\/\/ id retrieval\n+template <typename T, typename IdType, template <typename, typename> class TableEntry, typename Callback, unsigned TABLE_CAPACITY>\n+inline IdType JfrConcurrentHashTableHost<T, IdType, TableEntry, Callback, TABLE_CAPACITY>::id(unsigned hash, const T& data) {\n+  assert(data != nullptr, \"invariant\");\n+  const Entry* const entry = lookup_put(hash, data);\n+  assert(entry != nullptr, \"invariant\");\n+  assert(entry->id() > 0, \"invariant\");\n+  return entry->id();\n+}\n+\n+template <typename Entry, typename Callback>\n+class JfrConcurrentHashtableClear {\n+ private:\n+  Callback* const _cb;\n+ public:\n+  JfrConcurrentHashtableClear(Callback* cb) : _cb(cb) {}\n+\n+  bool process(const Entry* entry) {\n+    assert(entry != nullptr, \"invariant\");\n+    _cb->on_unlink(entry);\n+    delete entry;\n+    return true;\n+  }\n+};\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry, typename Callback, unsigned TABLE_CAPACITY>\n+inline void JfrConcurrentHashTableHost<T, IdType, TableEntry, Callback, TABLE_CAPACITY>::clear() {\n+  JfrConcurrentHashtableClear<Entry, Callback> cls(_callback);\n+  this->iterate(cls);\n+  memset((void*)this->bucket_addr(0), 0, this->capacity() * sizeof(typename JfrConcurrentHashtable<T, IdType, TableEntry>::Bucket));\n+}\n+\n+template <typename Entry, typename Functor>\n+class JfrConcurrentHashtableValueDelegator {\n+ private:\n+  Functor& _f;\n+ public:\n+  JfrConcurrentHashtableValueDelegator(Functor& f) : _f(f) {}\n+  bool process(const Entry* entry) {\n+    assert(entry != nullptr, \"invariant\");\n+    return _f(entry->value());\n+  }\n+};\n+\n+template <typename Entry, typename Functor>\n+class JfrConcurrentHashtableEntryDelegator {\n+ private:\n+  Functor& _f;\n+ public:\n+  JfrConcurrentHashtableEntryDelegator(Functor& f) : _f(f) {}\n+  bool process(const Entry* entry) {\n+    assert(entry != nullptr, \"invariant\");\n+    return _f(entry);\n+  }\n+};\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry, typename Callback, unsigned TABLE_CAPACITY>\n+template <typename Functor>\n+inline void JfrConcurrentHashTableHost<T, IdType, TableEntry, Callback, TABLE_CAPACITY>::iterate_value(Functor& f) {\n+  JfrConcurrentHashtableValueDelegator<Entry, Functor> delegator(f);\n+  this->iterate(delegator);\n+}\n+\n+template <typename T, typename IdType, template <typename, typename> class TableEntry, typename Callback, unsigned TABLE_CAPACITY>\n+template <typename Functor>\n+inline void JfrConcurrentHashTableHost<T, IdType, TableEntry, Callback, TABLE_CAPACITY>::iterate_entry(Functor& f) {\n+  JfrConcurrentHashtableEntryDelegator<Entry, Functor> delegator(f);\n+  this->iterate(delegator);\n+}\n+\n+#endif \/\/ SHARE_JFR_UTILITIES_JFRCONCURRENTHASHTABLE_INLINE_HPP\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrConcurrentHashtable.inline.hpp","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+  bool try_add(NodePtr node, NodePtr next);\n@@ -50,0 +51,2 @@\n+  template <typename Callback>\n+  static void iterate(NodePtr node, Callback& cb);\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrLinkedList.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,0 +65,7 @@\n+template <typename NodeType, typename AllocPolicy>\n+inline bool JfrLinkedList<NodeType, AllocPolicy>::try_add(NodeType* node, NodeType* next) {\n+  assert(node != nullptr, \"invariant\");\n+  assert(node->_next == next, \"invariant\");\n+  return head() == next && AtomicAccess::cmpxchg(&_head, next, node) == next;\n+}\n+\n@@ -79,5 +86,10 @@\n-void JfrLinkedList<NodeType, AllocPolicy>::iterate(Callback& cb) {\n-  NodePtr current = head();\n-  while (current != nullptr) {\n-    NodePtr next = (NodePtr)current->_next;\n-    if (!cb.process(current)) {\n+inline void JfrLinkedList<NodeType, AllocPolicy>::iterate(Callback& cb) {\n+  JfrLinkedList<NodeType, AllocPolicy>::iterate(head(), cb);\n+}\n+\n+template <typename NodeType, typename AllocPolicy>\n+template <typename Callback>\n+inline void JfrLinkedList<NodeType, AllocPolicy>::iterate(NodeType* node, Callback& cb) {\n+  while (node != nullptr) {\n+    NodePtr next = (NodePtr)node->_next;\n+    if (!cb.process(node)) {\n@@ -86,1 +98,1 @@\n-    current = next;\n+    node = next;\n@@ -91,1 +103,1 @@\n-NodeType* JfrLinkedList<NodeType, AllocPolicy>::excise(NodeType* prev, NodeType* node) {\n+inline NodeType* JfrLinkedList<NodeType, AllocPolicy>::excise(NodeType* prev, NodeType* node) {\n@@ -109,1 +121,1 @@\n-bool JfrLinkedList<NodeType, AllocPolicy>::in_list(const NodeType* node) const {\n+inline bool JfrLinkedList<NodeType, AllocPolicy>::in_list(const NodeType* node) const {\n@@ -122,1 +134,1 @@\n-NodeType* JfrLinkedList<NodeType, AllocPolicy>::cut() {\n+inline NodeType* JfrLinkedList<NodeType, AllocPolicy>::cut() {\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrLinkedList.inline.hpp","additions":21,"deletions":9,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -60,0 +60,4 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n+\n@@ -865,1 +869,0 @@\n-  JFR_ONLY(RESTORE_ID(this);)\n@@ -879,0 +882,1 @@\n+\n@@ -883,0 +887,2 @@\n+  JFR_ONLY(Jfr::on_restoration(this, THREAD);)\n+\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,0 +73,2 @@\n+                Asserts.assertTrue(event.getString(\"source\").startsWith(\"file:\/\"), \"Invalid source location\");\n+                Asserts.assertTrue(event.getString(\"source\").endsWith(TEST_CLASS_NAME.substring(TEST_CLASS_NAME.lastIndexOf('.') + 1) + \".class\"), \"Invalid source location\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestClassDefineEvent.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}