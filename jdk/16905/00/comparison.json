{"files":[{"patch":"@@ -73,1 +73,1 @@\n-#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n+#include \"gc\/g1\/g1YoungGCAllocationFailureInjector.hpp\"\n@@ -1149,1 +1149,1 @@\n-  _evac_failure_injector(),\n+  _allocation_failure_injector(),\n@@ -1437,1 +1437,1 @@\n-  evac_failure_injector()->reset();\n+  allocation_failure_injector()->reset();\n@@ -2953,3 +2953,0 @@\n-    \/\/ Reset the G1EvacuationFailureALot counters and flags\n-    evac_failure_injector()->reset();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n+#include \"gc\/g1\/g1YoungGCAllocationFailureInjector.hpp\"\n@@ -223,1 +223,1 @@\n-  G1YoungGCEvacFailureInjector _evac_failure_injector;\n+  G1YoungGCAllocationFailureInjector _allocation_failure_injector;\n@@ -552,1 +552,1 @@\n-  G1YoungGCEvacFailureInjector* evac_failure_injector() { return &_evac_failure_injector; }\n+  G1YoungGCAllocationFailureInjector* allocation_failure_injector() { return &_allocation_failure_injector; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/g1\/g1YoungGCEvacFailureInjector.inline.hpp\"\n+#include \"gc\/g1\/g1YoungGCAllocationFailureInjector.inline.hpp\"\n@@ -88,1 +88,1 @@\n-    EVAC_FAILURE_INJECTOR_ONLY(_evac_failure_inject_counter(0) COMMA)\n+    ALLOCATION_FAILURE_INJECTOR_ONLY(_evac_failure_inject_counter(0) COMMA)\n@@ -430,1 +430,1 @@\n-#if EVAC_FAILURE_INJECTOR\n+#if ALLOCATION_FAILURE_INJECTOR\n@@ -432,1 +432,1 @@\n-  return _g1h->evac_failure_injector()->evacuation_should_fail(_evac_failure_inject_counter, region_idx);\n+  return _g1h->allocation_failure_injector()->allocation_should_fail(_evac_failure_inject_counter, region_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n+#include \"gc\/g1\/g1YoungGCAllocationFailureInjector.hpp\"\n@@ -107,1 +107,1 @@\n-  EVAC_FAILURE_INJECTOR_ONLY(size_t _evac_failure_inject_counter;)\n+  ALLOCATION_FAILURE_INJECTOR_ONLY(size_t _evac_failure_inject_counter;)\n@@ -123,1 +123,1 @@\n-  bool inject_allocation_failure(uint region_idx) EVAC_FAILURE_INJECTOR_RETURN_( return false; );\n+  bool inject_allocation_failure(uint region_idx) ALLOCATION_FAILURE_INJECTOR_RETURN_( return false; );\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n@@ -49,0 +48,1 @@\n+#include \"gc\/g1\/g1YoungGCAllocationFailureInjector.hpp\"\n@@ -246,2 +246,2 @@\n-G1YoungGCEvacFailureInjector* G1YoungCollector::evac_failure_injector() const {\n-  return _g1h->evac_failure_injector();\n+G1YoungGCAllocationFailureInjector* G1YoungCollector::allocation_failure_injector() const {\n+  return _g1h->allocation_failure_injector();\n@@ -537,1 +537,1 @@\n-  evac_failure_injector()->arm_if_needed();\n+  allocation_failure_injector()->arm_if_needed();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n+#include \"gc\/g1\/g1YoungGCAllocationFailureInjector.hpp\"\n@@ -52,1 +52,1 @@\n-class G1YoungGCEvacFailureInjector;\n+class G1YoungGCAllocationFailureInjector;\n@@ -81,1 +81,1 @@\n-  G1YoungGCEvacFailureInjector* evac_failure_injector() const;\n+  G1YoungGCAllocationFailureInjector* allocation_failure_injector() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1YoungGCAllocationFailureInjector.inline.hpp\"\n+#include \"gc\/g1\/g1_globals.hpp\"\n+\n+#if ALLOCATION_FAILURE_INJECTOR\n+\n+class SelectAllocationFailureRegionClosure : public HeapRegionClosure {\n+  CHeapBitMap& _allocation_failure_regions;\n+  size_t _allocation_failure_regions_num;\n+\n+public:\n+  SelectAllocationFailureRegionClosure(CHeapBitMap& allocation_failure_regions, size_t cset_length) :\n+    _allocation_failure_regions(allocation_failure_regions),\n+    _allocation_failure_regions_num(cset_length * G1AllocationFailureALotCSetPercent \/ 100) { }\n+\n+  bool do_heap_region(HeapRegion* r) override {\n+    assert(r->in_collection_set(), \"must be\");\n+    if (_allocation_failure_regions_num > 0) {\n+      _allocation_failure_regions.set_bit(r->hrm_index());\n+      --_allocation_failure_regions_num;\n+    }\n+    return _allocation_failure_regions_num == 0;\n+  }\n+};\n+\n+G1YoungGCAllocationFailureInjector::G1YoungGCAllocationFailureInjector()\n+  : _inject_allocation_failure_for_current_gc(),\n+    _last_collection_with_allocation_failure(),\n+    _allocation_failure_regions(mtGC) {}\n+\n+void G1YoungGCAllocationFailureInjector::select_allocation_failure_regions() {\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  _allocation_failure_regions.reinitialize(g1h->max_reserved_regions());\n+  SelectAllocationFailureRegionClosure closure(_allocation_failure_regions, g1h->collection_set()->cur_length());\n+  g1h->collection_set_iterate_all(&closure);\n+}\n+\n+bool G1YoungGCAllocationFailureInjector::arm_if_needed_for_gc_type(bool for_young_only_phase,\n+                                                                   bool during_concurrent_start,\n+                                                                   bool mark_or_rebuild_in_progress) {\n+  bool res = false;\n+  if (mark_or_rebuild_in_progress) {\n+    res |= G1AllocationFailureALotDuringConcMark;\n+  }\n+  if (during_concurrent_start) {\n+    res |= G1AllocationFailureALotDuringConcurrentStart;\n+  }\n+  if (for_young_only_phase) {\n+    res |= G1AllocationFailureALotDuringYoungGC;\n+  } else {\n+    \/\/ GCs are mixed\n+    res |= G1AllocationFailureALotDuringMixedGC;\n+  }\n+  return res;\n+}\n+\n+void G1YoungGCAllocationFailureInjector::arm_if_needed() {\n+  if (G1AllocationFailureALot) {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    \/\/ Check if we have gone over the interval.\n+    const size_t gc_num = g1h->total_collections();\n+    const size_t elapsed_gcs = gc_num - _last_collection_with_allocation_failure;\n+\n+    _inject_allocation_failure_for_current_gc = (elapsed_gcs >= G1AllocationFailureALotInterval);\n+\n+    \/\/ Now check if evacuation failure injection should be enabled for the current GC.\n+    G1CollectorState* collector_state = g1h->collector_state();\n+    const bool in_young_only_phase = collector_state->in_young_only_phase();\n+    const bool in_concurrent_start_gc = collector_state->in_concurrent_start_gc();\n+    const bool mark_or_rebuild_in_progress = collector_state->mark_or_rebuild_in_progress();\n+\n+    _inject_allocation_failure_for_current_gc &=\n+      arm_if_needed_for_gc_type(in_young_only_phase,\n+                                in_concurrent_start_gc,\n+                                mark_or_rebuild_in_progress);\n+\n+    if (_inject_allocation_failure_for_current_gc) {\n+      select_allocation_failure_regions();\n+    }\n+  }\n+}\n+\n+void G1YoungGCAllocationFailureInjector::reset() {\n+  _last_collection_with_allocation_failure = G1CollectedHeap::heap()->total_collections();\n+  _inject_allocation_failure_for_current_gc = false;\n+}\n+\n+#endif \/\/ #if ALLOCATION_FAILURE_INJECTOR\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.cpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1YOUNGGCALLOCATIONFAILUREINJECTOR_HPP\n+#define SHARE_GC_G1_G1YOUNGGCALLOCATIONFAILUREINJECTOR_HPP\n+\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#if ALLOCATION_FAILURE_INJECTOR\n+#define ALLOCATION_FAILURE_INJECTOR_RETURN\n+#define ALLOCATION_FAILURE_INJECTOR_RETURN_(code)\n+#define ALLOCATION_FAILURE_INJECTOR_ONLY(code) code\n+#else\n+#define ALLOCATION_FAILURE_INJECTOR_RETURN { return; }\n+#define ALLOCATION_FAILURE_INJECTOR_RETURN_(code) { code }\n+#define ALLOCATION_FAILURE_INJECTOR_ONLY(code)\n+#endif \/\/ ALLOCATION_FAILURE_INJECTOR\n+\n+\/\/ Support for injecting allocation failures based on the G1AllocationFailureALot*\n+\/\/ flags. Analogous to PromotionFailureALot for the other collectors.\n+\/\/\n+\/\/ Every G1AllocationFailureALotInterval collections without evacuation failure\n+\/\/ in between we \"arm\" the injector to induce allocation failures after\n+\/\/ G1AllocationFailureALotCount successful evacuations.\n+\/\/\n+\/\/ Available only when ALLOCATION_FAILURE_INJECTOR is defined.\n+class G1YoungGCAllocationFailureInjector {\n+#if ALLOCATION_FAILURE_INJECTOR\n+  \/\/ Should we inject evacuation failures in the current GC.\n+  bool _inject_allocation_failure_for_current_gc;\n+\n+  \/\/ Records the number of the last collection when allocation failure happened.\n+  \/\/ Used to determine whether allocation failure injection should be in effect\n+  \/\/ for the current GC.\n+  size_t _last_collection_with_allocation_failure;\n+\n+  \/\/ Records the regions that will fail evacuation.\n+  CHeapBitMap _allocation_failure_regions;\n+#endif\n+\n+  bool arm_if_needed_for_gc_type(bool for_young_only_phase,\n+                                 bool during_concurrent_start,\n+                                 bool mark_or_rebuild_in_progress) ALLOCATION_FAILURE_INJECTOR_RETURN_( return false; );\n+\n+  \/\/ Selects the regions that will fail allocation by G1AllocationFailureALotCSetPercent.\n+  void select_allocation_failure_regions() ALLOCATION_FAILURE_INJECTOR_RETURN;\n+public:\n+\n+  G1YoungGCAllocationFailureInjector() ALLOCATION_FAILURE_INJECTOR_RETURN;\n+\n+  \/\/ Arm the allocation failure injector if needed for the current\n+  \/\/ GC (based upon the type of GC and which command line flags are set);\n+  void arm_if_needed() ALLOCATION_FAILURE_INJECTOR_RETURN;\n+\n+  \/\/ Return true if it's time to cause an allocation failure; the caller\n+  \/\/ provides the (preferably thread-local) counter to minimize performance impact.\n+  bool allocation_should_fail(size_t& counter, uint region_idx) ALLOCATION_FAILURE_INJECTOR_RETURN_( return false; );\n+\n+  \/\/ Reset the allocation failure injection counters. Should be called at\n+  \/\/ the end of an evacuation pause in which an allocation failure occurred.\n+  void reset() ALLOCATION_FAILURE_INJECTOR_RETURN;\n+};\n+\n+#endif \/* SHARE_GC_G1_G1YOUNGGCALLOCATIONFAILUREINJECTOR_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1YOUNGGCALLOCATIONFAILUREINJECTOR_INLINE_HPP\n+#define SHARE_GC_G1_G1YOUNGGCALLOCATIONFAILUREINJECTOR_INLINE_HPP\n+\n+#include \"gc\/g1\/g1YoungGCAllocationFailureInjector.hpp\"\n+\n+#include \"gc\/g1\/g1_globals.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+\n+#if ALLOCATION_FAILURE_INJECTOR\n+\n+inline bool G1YoungGCAllocationFailureInjector::allocation_should_fail(size_t& counter, uint region_idx) {\n+  if (!_inject_allocation_failure_for_current_gc) {\n+    return false;\n+  }\n+  if (!_allocation_failure_regions.at(region_idx)) {\n+    return false;\n+  }\n+  if (++counter < G1AllocationFailureALotCount) {\n+    return false;\n+  }\n+  counter = 0;\n+  return true;\n+}\n+\n+#endif  \/\/ #if ALLOCATION_FAILURE_INJECTOR\n+\n+#endif \/* SHARE_GC_G1_G1YOUNGGCALLOCATIONFAILUREINJECTOR_INLINE_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCAllocationFailureInjector.inline.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n-#include \"gc\/g1\/g1YoungGCEvacFailureInjector.inline.hpp\"\n-#include \"gc\/g1\/g1_globals.hpp\"\n-\n-#if EVAC_FAILURE_INJECTOR\n-\n-class SelectEvacFailureRegionClosure : public HeapRegionClosure {\n-  CHeapBitMap& _evac_failure_regions;\n-  size_t _evac_failure_regions_num;\n-\n-public:\n-  SelectEvacFailureRegionClosure(CHeapBitMap& evac_failure_regions, size_t cset_length) :\n-    _evac_failure_regions(evac_failure_regions),\n-    _evac_failure_regions_num(cset_length * G1EvacuationFailureALotCSetPercent \/ 100) { }\n-\n-  bool do_heap_region(HeapRegion* r) override {\n-    assert(r->in_collection_set(), \"must be\");\n-    if (_evac_failure_regions_num > 0) {\n-      _evac_failure_regions.set_bit(r->hrm_index());\n-      --_evac_failure_regions_num;\n-    }\n-    return _evac_failure_regions_num == 0;\n-  }\n-};\n-\n-G1YoungGCEvacFailureInjector::G1YoungGCEvacFailureInjector()\n-  : _inject_evacuation_failure_for_current_gc(),\n-    _last_collection_with_evacuation_failure(),\n-    _evac_failure_regions(mtGC) {}\n-\n-void G1YoungGCEvacFailureInjector::select_evac_failure_regions() {\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  _evac_failure_regions.reinitialize(g1h->max_reserved_regions());\n-  SelectEvacFailureRegionClosure closure(_evac_failure_regions, g1h->collection_set()->cur_length());\n-  g1h->collection_set_iterate_all(&closure);\n-}\n-\n-bool G1YoungGCEvacFailureInjector::arm_if_needed_for_gc_type(bool for_young_only_phase,\n-                                                             bool during_concurrent_start,\n-                                                             bool mark_or_rebuild_in_progress) {\n-  bool res = false;\n-  if (mark_or_rebuild_in_progress) {\n-    res |= G1EvacuationFailureALotDuringConcMark;\n-  }\n-  if (during_concurrent_start) {\n-    res |= G1EvacuationFailureALotDuringConcurrentStart;\n-  }\n-  if (for_young_only_phase) {\n-    res |= G1EvacuationFailureALotDuringYoungGC;\n-  } else {\n-    \/\/ GCs are mixed\n-    res |= G1EvacuationFailureALotDuringMixedGC;\n-  }\n-  return res;\n-}\n-\n-void G1YoungGCEvacFailureInjector::arm_if_needed() {\n-  if (G1EvacuationFailureALot) {\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-    \/\/ Check if we have gone over the interval.\n-    const size_t gc_num = g1h->total_collections();\n-    const size_t elapsed_gcs = gc_num - _last_collection_with_evacuation_failure;\n-\n-    _inject_evacuation_failure_for_current_gc = (elapsed_gcs >= G1EvacuationFailureALotInterval);\n-\n-    \/\/ Now check if evacuation failure injection should be enabled for the current GC.\n-    G1CollectorState* collector_state = g1h->collector_state();\n-    const bool in_young_only_phase = collector_state->in_young_only_phase();\n-    const bool in_concurrent_start_gc = collector_state->in_concurrent_start_gc();\n-    const bool mark_or_rebuild_in_progress = collector_state->mark_or_rebuild_in_progress();\n-\n-    _inject_evacuation_failure_for_current_gc &=\n-      arm_if_needed_for_gc_type(in_young_only_phase,\n-                                in_concurrent_start_gc,\n-                                mark_or_rebuild_in_progress);\n-\n-    if (_inject_evacuation_failure_for_current_gc) {\n-      select_evac_failure_regions();\n-    }\n-  }\n-}\n-\n-void G1YoungGCEvacFailureInjector::reset() {\n-  _last_collection_with_evacuation_failure = G1CollectedHeap::heap()->total_collections();\n-  _inject_evacuation_failure_for_current_gc = false;\n-}\n-\n-#endif \/\/ #if EVAC_FAILURE_INJECTOR\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.cpp","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1YOUNGGCEVACUATIONFAILUREINJECTOR_HPP\n-#define SHARE_GC_G1_G1YOUNGGCEVACUATIONFAILUREINJECTOR_HPP\n-\n-#include \"gc\/g1\/g1_globals.hpp\"\n-#include \"memory\/allStatic.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-#if EVAC_FAILURE_INJECTOR\n-#define EVAC_FAILURE_INJECTOR_RETURN\n-#define EVAC_FAILURE_INJECTOR_RETURN_(code)\n-#define EVAC_FAILURE_INJECTOR_ONLY(code) code\n-#else\n-#define EVAC_FAILURE_INJECTOR_RETURN { return; }\n-#define EVAC_FAILURE_INJECTOR_RETURN_(code) { code }\n-#define EVAC_FAILURE_INJECTOR_ONLY(code)\n-#endif \/\/ EVAC_FAILURE_INJECTOR\n-\n-\/\/ Support for injecting evacuation failures based on the G1EvacuationFailureALot*\n-\/\/ flags. Analogous to PromotionFailureALot for the other collectors.\n-\/\/\n-\/\/ Every G1EvacuationFailureALotInterval collections without evacuation failure\n-\/\/ in between we \"arm\" the injector to induce evacuation failures after\n-\/\/ G1EvacuationFailureALotCount successful evacuations.\n-\/\/\n-\/\/ Available only when EVAC_FAILURE_INJECTOR is defined.\n-class G1YoungGCEvacFailureInjector {\n-#if EVAC_FAILURE_INJECTOR\n-  \/\/ Should we inject evacuation failures in the current GC.\n-  bool _inject_evacuation_failure_for_current_gc;\n-\n-  \/\/ Records the number of the last collection when evacuation failure happened.\n-  \/\/ Used to determine whether evacuation failure injection should be in effect\n-  \/\/ for the current GC.\n-  size_t _last_collection_with_evacuation_failure;\n-\n-  \/\/ Records the regions that will fail evacuation.\n-  CHeapBitMap _evac_failure_regions;\n-#endif\n-\n-  bool arm_if_needed_for_gc_type(bool for_young_only_phase,\n-                                 bool during_concurrent_start,\n-                                 bool mark_or_rebuild_in_progress) EVAC_FAILURE_INJECTOR_RETURN_( return false; );\n-\n-  \/\/ Selects the regions that will fail evacuation by G1EvacuationFailureALotCSetPercent.\n-  void select_evac_failure_regions() EVAC_FAILURE_INJECTOR_RETURN;\n-public:\n-\n-  G1YoungGCEvacFailureInjector() EVAC_FAILURE_INJECTOR_RETURN;\n-\n-  \/\/ Arm the evacuation failure injector if needed for the current\n-  \/\/ GC (based upon the type of GC and which command line flags are set);\n-  void arm_if_needed() EVAC_FAILURE_INJECTOR_RETURN;\n-\n-  \/\/ Return true if it's time to cause an evacuation failure; the caller\n-  \/\/ provides the (preferably thread-local) counter to minimize performance impact.\n-  bool evacuation_should_fail(size_t& counter, uint region_idx) EVAC_FAILURE_INJECTOR_RETURN_( return false; );\n-\n-  \/\/ Reset the evacuation failure injection counters. Should be called at\n-  \/\/ the end of an evacuation pause in which an evacuation failure occurred.\n-  void reset() EVAC_FAILURE_INJECTOR_RETURN;\n-};\n-\n-#endif \/* SHARE_GC_G1_G1YOUNGGCEVACUATIONFAILUREINJECTOR_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.hpp","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1YOUNGGCEVACUATIONFAILUREINJECTOR_INLINE_HPP\n-#define SHARE_GC_G1_G1YOUNGGCEVACUATIONFAILUREINJECTOR_INLINE_HPP\n-\n-#include \"gc\/g1\/g1YoungGCEvacFailureInjector.hpp\"\n-\n-#include \"gc\/g1\/g1_globals.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n-\n-#if EVAC_FAILURE_INJECTOR\n-\n-inline bool G1YoungGCEvacFailureInjector::evacuation_should_fail(size_t& counter, uint region_idx) {\n-  if (!_inject_evacuation_failure_for_current_gc) {\n-    return false;\n-  }\n-  if (!_evac_failure_regions.at(region_idx)) {\n-    return false;\n-  }\n-  if (++counter < G1EvacuationFailureALotCount) {\n-    return false;\n-  }\n-  counter = 0;\n-  return true;\n-}\n-\n-#endif  \/\/ #if EVAC_FAILURE_INJECTOR\n-\n-#endif \/* SHARE_GC_G1_G1YOUNGGCEVACUATIONFAILUREINJECTOR_INLINE_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.inline.hpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -70,0 +70,1 @@\n+  bool _allocation_failed;\n@@ -72,1 +73,4 @@\n-  RecalculateUsedTask(bool evacuation_failed) : G1AbstractSubTask(G1GCPhaseTimes::RecalculateUsed), _evacuation_failed(evacuation_failed) { }\n+  RecalculateUsedTask(bool evacuation_failed, bool allocation_failed) :\n+    G1AbstractSubTask(G1GCPhaseTimes::RecalculateUsed),\n+    _evacuation_failed(evacuation_failed),\n+    _allocation_failed(allocation_failed) { }\n@@ -79,1 +83,7 @@\n-  void do_work(uint worker_id) override { G1CollectedHeap::heap()->update_used_after_gc(_evacuation_failed); }\n+  void do_work(uint worker_id) override {\n+    G1CollectedHeap::heap()->update_used_after_gc(_evacuation_failed);\n+    if (_allocation_failed) {\n+      \/\/ Reset the G1AllocationFailureALot counters and flags\n+      G1CollectedHeap::heap()->allocation_failure_injector()->reset();\n+    }\n+  }\n@@ -312,0 +322,1 @@\n+  bool alloc_failed = evac_failure_regions->has_regions_alloc_failed();\n@@ -314,1 +325,1 @@\n-  add_serial_task(new RecalculateUsedTask(evac_failed));\n+  add_serial_task(new RecalculateUsedTask(evac_failed, alloc_failed));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-\/\/ Enable evacuation failure injector by default in non-product builds.\n+\/\/ Enable allocation failure injector by default in non-product builds.\n@@ -32,2 +32,2 @@\n-#ifdef EVAC_FAILURE_INJECTOR\n-#error \"EVAC_FAILURE_INJECTOR already defined\"\n+#ifdef ALLOCATION_FAILURE_INJECTOR\n+#error \"ALLOCATION_FAILURE_INJECTOR already defined\"\n@@ -36,1 +36,1 @@\n-#define EVAC_FAILURE_INJECTOR 1\n+#define ALLOCATION_FAILURE_INJECTOR 1\n@@ -38,1 +38,1 @@\n-#define EVAC_FAILURE_INJECTOR 0\n+#define ALLOCATION_FAILURE_INJECTOR 0\n@@ -41,1 +41,1 @@\n-#if EVAC_FAILURE_INJECTOR\n+#if ALLOCATION_FAILURE_INJECTOR\n@@ -50,1 +50,1 @@\n-  product(bool, G1EvacuationFailureALot, false,                             \\\n+  product(bool, G1AllocationFailureALot, false,                             \\\n@@ -54,1 +54,1 @@\n-  product(uintx, G1EvacuationFailureALotCount, 1000,                        \\\n+  product(uintx, G1AllocationFailureALotCount, 1000,                        \\\n@@ -58,1 +58,1 @@\n-  product(uintx, G1EvacuationFailureALotInterval, 5,                        \\\n+  product(uintx, G1AllocationFailureALotInterval, 5,                        \\\n@@ -62,1 +62,1 @@\n-  product(bool, G1EvacuationFailureALotDuringConcMark, true,                \\\n+  product(bool, G1AllocationFailureALotDuringConcMark, true,                \\\n@@ -66,1 +66,1 @@\n-  product(bool, G1EvacuationFailureALotDuringConcurrentStart, true,         \\\n+  product(bool, G1AllocationFailureALotDuringConcurrentStart, true,         \\\n@@ -70,1 +70,1 @@\n-  product(bool, G1EvacuationFailureALotDuringYoungGC, true,                 \\\n+  product(bool, G1AllocationFailureALotDuringYoungGC, true,                 \\\n@@ -74,1 +74,1 @@\n-  product(bool, G1EvacuationFailureALotDuringMixedGC, true,                 \\\n+  product(bool, G1AllocationFailureALotDuringMixedGC, true,                 \\\n@@ -78,1 +78,1 @@\n-  product(uint, G1EvacuationFailureALotCSetPercent, 100,                    \\\n+  product(uint, G1AllocationFailureALotCSetPercent, 100,                    \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package gc.g1;\n+\n+\/*\n+ * @test TestAllocationFailure\n+ * @summary Ensure the output for a minor GC with G1 that has allocation failure contains the correct strings.\n+ * @requires vm.gc.G1\n+ * @requires vm.debug\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   gc.g1.TestAllocationFailure\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestAllocationFailure {\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n+                                                                             \"-Xmx32M\",\n+                                                                             \"-Xmn16M\",\n+                                                                             \"-XX:+G1AllocationFailureALot\",\n+                                                                             \"-XX:G1AllocationFailureALotCount=100\",\n+                                                                             \"-XX:G1AllocationFailureALotInterval=1\",\n+                                                                             \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                                             \"-Xlog:gc\",\n+                                                                             GCTestWithAllocationFailure.class.getName());\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        System.out.println(output.getStdout());\n+        output.shouldContain(\"(Evacuation Failure:\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    static class GCTestWithAllocationFailure {\n+        private static byte[] garbage;\n+        private static byte[] largeObject;\n+        private static Object[] holder = new Object[200]; \/\/ Must be larger than G1AllocationFailureALotCount\n+\n+        public static void main(String [] args) {\n+            largeObject = new byte[16 * 1024 * 1024];\n+            System.out.println(\"Creating garbage\");\n+            \/\/ Create 16 MB of garbage. This should result in at least one GC,\n+            \/\/ (Heap size is 32M, we use 17MB for the large object above)\n+            \/\/ which is larger than G1AllocationFailureALotInterval.\n+            for (int i = 0; i < 16 * 1024; i++) {\n+                holder[i % holder.length] = new byte[1024];\n+            }\n+            System.out.println(\"Done\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestAllocationFailure.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.g1;\n-\n-\/*\n- * @test TestEvacuationFailure\n- * @summary Ensure the output for a minor GC with G1 that has allocation failure contains the correct strings.\n- * @requires vm.gc.G1\n- * @requires vm.debug\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *                   gc.g1.TestEvacuationFailure\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class TestEvacuationFailure {\n-\n-    public static void main(String[] args) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XX:+UseG1GC\",\n-                                                                             \"-Xmx32M\",\n-                                                                             \"-Xmn16M\",\n-                                                                             \"-XX:+G1EvacuationFailureALot\",\n-                                                                             \"-XX:G1EvacuationFailureALotCount=100\",\n-                                                                             \"-XX:G1EvacuationFailureALotInterval=1\",\n-                                                                             \"-XX:+UnlockDiagnosticVMOptions\",\n-                                                                             \"-Xlog:gc\",\n-                                                                             GCTestWithEvacuationFailure.class.getName());\n-\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        System.out.println(output.getStdout());\n-        output.shouldContain(\"(Evacuation Failure:\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    static class GCTestWithEvacuationFailure {\n-        private static byte[] garbage;\n-        private static byte[] largeObject;\n-        private static Object[] holder = new Object[200]; \/\/ Must be larger than G1EvacuationFailureALotCount\n-\n-        public static void main(String [] args) {\n-            largeObject = new byte[16 * 1024 * 1024];\n-            System.out.println(\"Creating garbage\");\n-            \/\/ Create 16 MB of garbage. This should result in at least one GC,\n-            \/\/ (Heap size is 32M, we use 17MB for the large object above)\n-            \/\/ which is larger than G1EvacuationFailureALotInterval.\n-            for (int i = 0; i < 16 * 1024; i++) {\n-                holder[i % holder.length] = new byte[1024];\n-            }\n-            System.out.println(\"Done\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEvacuationFailure.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -278,3 +278,3 @@\n-                                                                             \"-XX:+G1EvacuationFailureALot\",\n-                                                                             \"-XX:G1EvacuationFailureALotCount=100\",\n-                                                                             \"-XX:G1EvacuationFailureALotInterval=1\",\n+                                                                             \"-XX:+G1AllocationFailureALot\",\n+                                                                             \"-XX:G1AllocaitonFailureALotCount=100\",\n+                                                                             \"-XX:G1AllocationFailureALotInterval=1\",\n@@ -283,1 +283,1 @@\n-                                                                             GCTestWithEvacuationFailure.class.getName());\n+                                                                             GCTestWithAllocationFailure.class.getName());\n@@ -349,1 +349,1 @@\n-    static class GCTestWithEvacuationFailure {\n+    static class GCTestWithAllocationFailure {\n@@ -352,1 +352,1 @@\n-        private static Object[] holder = new Object[200]; \/\/ Must be larger than G1EvacuationFailureALotCount\n+        private static Object[] holder = new Object[200]; \/\/ Must be larger than G1AllocationFailureALotCount\n@@ -359,1 +359,1 @@\n-            \/\/ which is larger than G1EvacuationFailureALotInterval.\n+            \/\/ which is larger than G1AllocationFailureALotInterval.\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -125,3 +125,3 @@\n-                                          new String[] {\"-XX:+G1EvacuationFailureALot\",\n-                                                        \"-XX:G1EvacuationFailureALotCount=100\",\n-                                                        \"-XX:G1EvacuationFailureALotInterval=1\",\n+                                          new String[] {\"-XX:+G1AllocationFailureALot\",\n+                                                        \"-XX:G1AllocationFailureALotCount=100\",\n+                                                        \"-XX:G1AllocationFailureALotInterval=1\",\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerifyGCType.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n- *          -Xmx32m -Xms32m -XX:+UnlockExperimentalVMOptions -XX:+G1EvacuationFailureALot\n- *          -XX:G1EvacuationFailureALotCount=100 -XX:G1EvacuationFailureALotInterval=1\n+ *          -Xmx32m -Xms32m -XX:+UnlockExperimentalVMOptions -XX:+G1AllocationFailureALot\n+ *          -XX:G1AllocationFailureALotCount=100 -XX:G1AllocationFailureALotInterval=1\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/detailed\/TestEvacuationFailedEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}