{"files":[{"patch":"@@ -2279,0 +2279,8 @@\n+void C2_MacroAssembler::movsxl(BasicType typ, Register dst) {\n+  if (typ == T_BYTE) {\n+    movsbl(dst, dst);\n+  } else if (typ == T_SHORT) {\n+    movswl(dst, dst);\n+  }\n+}\n+\n@@ -2290,4 +2298,1 @@\n-      if (typ == T_BYTE)\n-        movsbl(dst, dst);\n-      else if (typ == T_SHORT)\n-        movswl(dst, dst);\n+      movsxl(typ, dst);\n@@ -2297,0 +2302,1 @@\n+    movsxl(typ, dst);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+  void movsxl(BasicType typ, Register dst);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+\/*\n+ * @test\n+ * @bug 8303508\n+ * @summary Vector.lane() gets wrong value on x86\n+ * @modules jdk.incubator.vector\n+ * @library \/test\/lib\n+ *\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation -ea compiler.vectorapi.Test8303508\n+ *\/\n+public class Test8303508 {\n+\n+    static final VectorSpecies<Byte> BSPECIES_128 = ByteVector.SPECIES_128;\n+    static final VectorSpecies<Short> SSPECIES_128 = ShortVector.SPECIES_128;\n+\n+    static final byte[] ba = {0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15};\n+    static final short[] sa = {0, -1, -2, -3, -4, -5, -6, -7};\n+\n+    private static byte vec_extract_byte(int idx) {\n+        var bv = ByteVector.fromArray(BSPECIES_128, ba, 0);\n+        return bv.lane(idx);\n+    }\n+\n+    private static short vec_extract_short(int idx) {\n+        var sv = ShortVector.fromArray(SSPECIES_128, sa, 0);\n+        return sv.lane(idx);\n+    }\n+\n+    public static void main(String[] args) {\n+        int idx = 0;\n+        int actual = 0;\n+        int expected = 0;\n+        for (int i = 0; i < 10000; i++) {\n+            idx = i & 0xF;\n+            actual = vec_extract_byte(idx);\n+            expected = ba[idx];\n+            if (actual != expected) {\n+                throw new AssertionError(\"incorrect result byte extraction, actual = \" + actual + \" expected = \" + expected);\n+            }\n+            idx = i & 0x7;\n+            actual = vec_extract_short(idx);\n+            expected = sa[idx];\n+            if (actual != expected) {\n+                throw new AssertionError(\"incorrect result short extraction, actual = \" + actual + \" expected = \" + expected);\n+            }\n+        }\n+        System.out.println(\"PASS\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/Test8303508.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"}]}