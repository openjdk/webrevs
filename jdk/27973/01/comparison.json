{"files":[{"patch":"@@ -502,1 +502,0 @@\n-            Optional<Duration> timeout = client().connectTimeout();\n@@ -507,1 +506,2 @@\n-            if (timeout.isPresent()) {\n+            Duration timeout = client().connectTimeout().orElse(null);\n+            if (timeout != null) {\n@@ -509,1 +509,7 @@\n-                debug.log(\"setting up quic connect timeout: \" + timeout.get().toMillis());\n+                debug.log(\"setting up quic connect timeout: \" + timeout);\n+                long timeoutMillis;\n+                try {\n+                    timeoutMillis = timeout.toMillis();\n+                } catch (ArithmeticException _) {\n+                    timeoutMillis = Long.MAX_VALUE;\n+                }\n@@ -512,1 +518,1 @@\n-                        timeout.get().toMillis(), TimeUnit.MILLISECONDS);\n+                        timeoutMillis, TimeUnit.MILLISECONDS);\n@@ -517,1 +523,1 @@\n-            if (timeout.isPresent() || directTimeout.isPresent()) {\n+            if (timeout != null || directTimeout.isPresent()) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpQuicConnection.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,0 @@\n-import java.time.temporal.Temporal;\n-import java.time.temporal.TemporalAccessor;\n-import java.time.temporal.TemporalAmount;\n@@ -38,1 +35,9 @@\n- * A Deadline represents an instant on a {@linkplain TimeLine time line}.\n+ * An instantaneous point on the {@linkplain TimeLine time-line}.\n+ * <p>\n+ * This class is immutable and thread-safe.\n+ * <p>\n+ * On <b>numeric overflows<\/b>, all {@code Deadline} methods will return a\n+ * semantically meaningful extremum instead of throwing. For instance, on a\n+ * numeric overflow, {@link #plus(Duration) plus()} will return\n+ * {@link Deadline#MAX} if the provided duration is positive,\n+ * {@link Deadline#MIN} otherwise.\n@@ -52,1 +57,1 @@\n-     * Returns a copy of this deadline with the specified duration in nanoseconds added.\n+     * {@return a deadline with the specified duration in nanoseconds added}\n@@ -55,0 +60,3 @@\n+     * <p>\n+     * On numeric overflows, this method will return {@link Deadline#MAX} if\n+     * the provided duration is positive, {@link Deadline#MIN} otherwise.\n@@ -57,3 +65,0 @@\n-     * @return a {@code Deadline} based on this deadline with the specified nanoseconds added, not null\n-     * @throws DateTimeException if the result exceeds the maximum or minimum deadline\n-     * @throws ArithmeticException if numeric overflow occurs\n@@ -62,1 +67,7 @@\n-        return new Deadline(deadline.plusNanos(nanosToAdd));\n+        if (nanosToAdd == 0) return this;\n+        try {\n+            return new Deadline(deadline.plusNanos(nanosToAdd));\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            return nanosToAdd > 0 ? Deadline.MAX : Deadline.MIN;\n+        }\n@@ -92,5 +103,1 @@\n-     * Returns a copy of this deadline with the specified amount subtracted.\n-     * <p>\n-     * This returns a {@code Deadline}, based on this one, with the specified amount subtracted.\n-     * The amount is typically {@link Duration} but may be any other type implementing\n-     * the {@link TemporalAmount} interface.\n+     * {@return a deadline with the specified amount subtracted from this deadline}\n@@ -99,0 +106,3 @@\n+     * <p>\n+     * On numeric overflows, this method will return {@link Deadline#MIN} if\n+     * the provided duration is positive, {@link Deadline#MAX} otherwise.\n@@ -100,4 +110,1 @@\n-     * @param amountToSubtract  the amount to subtract, not null\n-     * @return a {@code Deadline} based on this deadline with the subtraction made, not null\n-     * @throws DateTimeException if the subtraction cannot be made\n-     * @throws ArithmeticException if numeric overflow occurs\n+     * @param duration the amount to subtract, not null\n@@ -105,2 +112,8 @@\n-    public Deadline minus(TemporalAmount amountToSubtract) {\n-        return Deadline.of(deadline.minus(amountToSubtract));\n+    public Deadline minus(Duration duration) {\n+        if (duration.isZero()) return this;\n+        try {\n+            return Deadline.of(deadline.minus(duration));\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            return duration.isPositive() ? Deadline.MIN : Deadline.MAX;\n+        }\n@@ -110,1 +123,1 @@\n-     * Returns a copy of this deadline with the specified amount added.\n+     * {@return a deadline with the specified amount added to this deadline}\n@@ -117,0 +130,3 @@\n+     * <p>\n+     * On numeric overflows, this method will return {@link Deadline#MAX} if\n+     * the provided amount is positive, {@link Deadline#MIN} otherwise.\n@@ -122,2 +138,0 @@\n-     * @return a {@code Deadline} based on this deadline with the specified amount added, not null\n-     * @throws DateTimeException if the addition cannot be made\n@@ -125,1 +139,0 @@\n-     * @throws ArithmeticException if numeric overflow occurs\n@@ -129,1 +142,6 @@\n-        return Deadline.of(deadline.plus(amountToAdd, unit));\n+        try {\n+            return Deadline.of(deadline.plus(amountToAdd, unit));\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            return amountToAdd > 0 ? Deadline.MAX : Deadline.MIN;\n+        }\n@@ -133,1 +151,1 @@\n-     * Returns a copy of this deadline with the specified duration in seconds added.\n+     * {@return a deadline with the specified duration in seconds added to this deadline}\n@@ -136,0 +154,3 @@\n+     * <p>\n+     * On numeric overflows, this method will return {@link Deadline#MAX} if\n+     * the provided duration is positive, {@link Deadline#MIN} otherwise.\n@@ -138,3 +159,0 @@\n-     * @return a {@code Deadline} based on this deadline with the specified seconds added, not null\n-     * @throws DateTimeException if the result exceeds the maximum or minimum deadline\n-     * @throws ArithmeticException if numeric overflow occurs\n@@ -144,1 +162,6 @@\n-        return Deadline.of(deadline.plusSeconds(secondsToAdd));\n+        try {\n+            return Deadline.of(deadline.plusSeconds(secondsToAdd));\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            return secondsToAdd > 0 ? Deadline.MAX : Deadline.MIN;\n+        }\n@@ -148,1 +171,1 @@\n-     * Returns a copy of this deadline with the specified duration in milliseconds added.\n+     * {@return a deadline with the specified duration in milliseconds added to this deadline}\n@@ -151,0 +174,3 @@\n+     * <p>\n+     * On numeric overflows, this method will return {@link Deadline#MAX} if\n+     * the provided duration is positive, {@link Deadline#MIN} otherwise.\n@@ -153,3 +179,0 @@\n-     * @return a {@code Deadline} based on this deadline with the specified milliseconds added, not null\n-     * @throws DateTimeException if the result exceeds the maximum or minimum deadline\n-     * @throws ArithmeticException if numeric overflow occurs\n@@ -159,1 +182,6 @@\n-        return Deadline.of(deadline.plusMillis(millisToAdd));\n+        try {\n+            return Deadline.of(deadline.plusMillis(millisToAdd));\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            return millisToAdd > 0 ? Deadline.MAX : Deadline.MIN;\n+        }\n@@ -163,5 +191,1 @@\n-     * Returns a copy of this deadline with the specified amount added.\n-     * <p>\n-     * This returns a {@code Deadline}, based on this one, with the specified amount added.\n-     * The amount is typically {@link Duration} but may be any other type implementing\n-     * the {@link TemporalAmount} interface.\n+     * {@return a deadline with the specified duration added to this deadline}\n@@ -170,0 +194,3 @@\n+     * <p>\n+     * On numeric overflows, this method will return {@link Deadline#MAX} if\n+     * the provided duration is positive, {@link Deadline#MIN} otherwise.\n@@ -171,4 +198,1 @@\n-     * @param amountToAdd  the amount to add, not null\n-     * @return a {@code Deadline} based on this deadline with the addition made, not null\n-     * @throws DateTimeException if the addition cannot be made\n-     * @throws ArithmeticException if numeric overflow occurs\n+     * @param duration the duration to add, not null\n@@ -176,2 +200,8 @@\n-    public Deadline plus(TemporalAmount amountToAdd) {\n-        return Deadline.of(deadline.plus(amountToAdd));\n+    public Deadline plus(Duration duration) {\n+        if (duration.isZero()) return this;\n+        try {\n+            return Deadline.of(deadline.plus(duration));\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            return duration.isPositive() ? Deadline.MAX : Deadline.MIN;\n+        }\n@@ -191,0 +221,4 @@\n+     * <p>\n+     * On numeric overflows, this method will return {@link Long#MAX_VALUE} if\n+     * the current deadline is before the provided end deadline,\n+     * {@link Long#MIN_VALUE} otherwise.\n@@ -195,1 +229,0 @@\n-     * @throws DateTimeException if the amount cannot be calculated\n@@ -197,1 +230,0 @@\n-     * @throws ArithmeticException if numeric overflow occurs\n@@ -200,1 +232,7 @@\n-        return deadline.until(endExclusive.deadline, unit);\n+        try {\n+            return deadline.until(endExclusive.deadline, unit);\n+        } catch (DateTimeException |        \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException _) {   \/\/ \"long overflow\"\n+            int delta = compareTo(endExclusive);\n+            return delta < 0 ? Long.MAX_VALUE : Long.MIN_VALUE;\n+        }\n@@ -269,2 +307,0 @@\n-     * @throws DateTimeException if the seconds between the deadline cannot be obtained\n-     * @throws ArithmeticException if the calculation exceeds the capacity of {@code Duration}\n@@ -273,1 +309,10 @@\n-        return Duration.between(startInclusive.deadline, endExclusive.deadline);\n+        if (startInclusive.equals(endExclusive)) return Duration.ZERO;\n+        try {\n+            return Duration.between(startInclusive.deadline, endExclusive.deadline);\n+        } catch (DateTimeException |                \/\/ \"Instant exceeds minimum or maximum instant\"\n+                 ArithmeticException exception) {   \/\/ \"long overflow\"\n+            \/\/ `Deadline` works with `Instant` under the hood.\n+            \/\/ Delta between `Instant.MIN` and `Instant.MAX` fits in a `Duration`.\n+            \/\/ Hence, we should never receive a numeric overflow while calculating the delta between two deadlines.\n+            throw new IllegalStateException(\"Unexpected overflow\", exception);\n+        }\n@@ -275,0 +320,1 @@\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Deadline.java","additions":99,"deletions":53,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -0,0 +1,347 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestEchoHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpOption;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static jdk.httpclient.test.lib.common.HttpServerAdapters.createClientBuilderFor;\n+\n+\/*\n+ * @test id=withoutPropertyConfig\n+ * @bug 8368528\n+ * @summary Verifies that `Duration`-accepting programmatic public APIs, either\n+ *          individually, or in combination, work with arbitrarily large values\n+ *\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ *\n+ * @run junit DurationOverflowTest\n+ *\/\n+\n+\/*\n+ * @test id=withPropertyConfig\n+ * @bug 8368528\n+ * @summary Verifies that `Duration`-accepting programmatic public APIs, either\n+ *          individually, or in combination, work with arbitrarily large values\n+ *          when combined with duration-accepting property-based public APIs.\n+ *\n+ * @library \/test\/jdk\/java\/net\/httpclient\/lib\n+ *          \/test\/lib\n+ *\n+ * @comment 9223372036854775807 is the value of `Long.MAX_VALUE`\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.keepalive.timeout=9223372036854775807\n+ *      DurationOverflowTest\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.keepalive.timeout.h2=9223372036854775807\n+ *      -DallowedInfras=h2,h2s\n+ *      DurationOverflowTest\n+ *\n+ * @run junit\/othervm\n+ *      -Djdk.httpclient.keepalive.timeout.h3=9223372036854775807\n+ *      -DallowedInfras=h3\n+ *      DurationOverflowTest\n+ *\/\n+\n+public class DurationOverflowTest {\n+\n+    private static final String CLASS_NAME = DurationOverflowTest.class.getSimpleName();\n+\n+    private static final Logger LOGGER = Utils.getDebugLogger(CLASS_NAME::toString, Utils.DEBUG);\n+\n+    private static final SSLContext SSL_CONTEXT = createSslContext();\n+\n+    private static SSLContext createSslContext() {\n+        try {\n+            return new SimpleSSLContext().get();\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+\n+    private static final List<Infra> INFRAS = loadInfras();\n+\n+    private static final class Infra implements AutoCloseable {\n+\n+        private static final AtomicInteger SERVER_COUNTER = new AtomicInteger();\n+\n+        private final String serverId;\n+\n+        private final HttpTestServer server;\n+\n+        private final Supplier<HttpClient.Builder> clientBuilderSupplier;\n+\n+        private final Supplier<HttpRequest.Builder> requestBuilderSupplier;\n+\n+        private final boolean secure;\n+\n+        private Infra(\n+                String serverId,\n+                HttpTestServer server,\n+                Supplier<HttpClient.Builder> clientBuilderSupplier,\n+                Supplier<HttpRequest.Builder> requestBuilderSupplier,\n+                boolean secure) {\n+            this.serverId = serverId;\n+            this.server = server;\n+            this.clientBuilderSupplier = clientBuilderSupplier;\n+            this.requestBuilderSupplier = requestBuilderSupplier;\n+            this.secure = secure;\n+        }\n+\n+        private static Infra of(Version version, boolean secure) {\n+\n+            \/\/ Create the server and the request URI\n+            var sslContext = secure ? SSL_CONTEXT : null;\n+            var server = createServer(version, sslContext);\n+            server.getVersion();\n+            var handlerPath = \"\/%s\/\".formatted(CLASS_NAME);\n+            var requestUriScheme = secure ? \"https\" : \"http\";\n+            var requestUri = URI.create(\"%s:\/\/%s%s-\".formatted(requestUriScheme, server.serverAuthority(), handlerPath));\n+\n+            \/\/ Register the request handler\n+            var serverId = \"\" + SERVER_COUNTER.getAndIncrement();\n+            server.addHandler(\n+                    \/\/ Intentionally opting for receiving a body to cover code paths associated with its retrieval\n+                    new HttpTestEchoHandler(false),\n+                    handlerPath);\n+\n+            \/\/ Create client & request builders\n+            Supplier<HttpClient.Builder> clientBuilderSupplier =\n+                    () -> createClientBuilderFor(version)\n+                            .version(version)\n+                            .sslContext(SSL_CONTEXT)\n+                            .proxy(NO_PROXY);\n+            Supplier<HttpRequest.Builder> requestBuilderSupplier =\n+                    () -> createRequestBuilder(requestUri, version);\n+\n+            \/\/ Create the pair\n+            var pair = new Infra(serverId, server, clientBuilderSupplier, requestBuilderSupplier, secure);\n+            pair.server.start();\n+            LOGGER.log(\"Server[%s] is started at `%s`\", serverId, server.serverAuthority());\n+            return pair;\n+\n+        }\n+\n+        private static HttpTestServer createServer(Version version, SSLContext sslContext) {\n+            try {\n+                return switch (version) {\n+                    case HTTP_1_1, HTTP_2 -> HttpTestServer.create(version, sslContext, null);\n+                    case HTTP_3 -> HttpTestServer.create(HTTP_3_URI_ONLY, sslContext, null);\n+                };\n+            } catch (IOException exception) {\n+                throw new UncheckedIOException(exception);\n+            }\n+        }\n+\n+        private static HttpRequest.Builder createRequestBuilder(URI uri, Version version) {\n+            var requestBuilder = HttpRequest.newBuilder(uri).version(version).HEAD();\n+            if (Version.HTTP_3.equals(version)) {\n+                requestBuilder.setOption(HttpOption.H3_DISCOVERY, HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY);\n+            }\n+            return requestBuilder;\n+        }\n+\n+        @Override\n+        public void close() {\n+            LOGGER.log(\"Server[%s] is stopping\", serverId);\n+            server.stop();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            var version = server.getVersion();\n+            var versionString = version.toString();\n+            return switch (version) {\n+                case HTTP_1_1, HTTP_2 -> secure ? versionString.replaceFirst(\"_\", \"S_\") : versionString;\n+                case HTTP_3 -> versionString;\n+            };\n+        }\n+\n+    }\n+\n+    private static List<Infra> loadInfras() {\n+        return Stream\n+                .of(System.getProperty(\"allowedInfras\", \"h1,h1s,h2,h2s,h3\").split(\",\"))\n+                .map(infra -> {\n+                    LOGGER.log(\"Loading test infrastructure: `%s`\", infra);\n+                    return switch (infra) {\n+                        case \"h1\" -> Infra.of(Version.HTTP_1_1, false);\n+                        case \"h1s\" -> Infra.of(Version.HTTP_1_1, true);\n+                        case \"h2\" -> Infra.of(Version.HTTP_2, false);\n+                        case \"h2s\" -> Infra.of(Version.HTTP_2, true);\n+                        case \"h3\" -> Infra.of(Version.HTTP_3, true);\n+                        default -> throw new IllegalArgumentException(\"Unknown test infrastructure: \" + infra);\n+                    };\n+                })\n+                .toList();\n+    }\n+\n+    @AfterAll\n+    static void tearDownInfras() {\n+        LOGGER.log(\"Tearing down test infrastructure\");\n+        Exception[] exceptionRef = {null};\n+        infras().forEach(infra -> {\n+            try {\n+                infra.close();\n+            } catch (Exception exception) {\n+                if (exceptionRef[0] == null) {\n+                    exceptionRef[0] = exception;\n+                } else {\n+                    exceptionRef[0].addSuppressed(exception);\n+                }\n+            }\n+        });\n+        if (exceptionRef[0] != null) {\n+            throw new RuntimeException(\"Failed tearing down one or more test infrastructures\", exceptionRef[0]);\n+        }\n+    }\n+\n+    private static Stream<Infra> infras() {\n+        return INFRAS.stream();\n+    }\n+\n+    public static final Set<Duration> EXCESSIVE_DURATIONS = Set.of(\n+            Duration.MAX,\n+            \/\/ This triggers different exceptions than the ones triggered by `Duration.MAX`\n+            Duration.ofMillis(Long.MAX_VALUE));\n+\n+    private static Stream<InfraDurationPair> infraDurationPairs() {\n+        return infras().flatMap(infra -> EXCESSIVE_DURATIONS.stream()\n+                .map(duration -> new InfraDurationPair(infra, duration)));\n+    }\n+\n+    private record InfraDurationPair(Infra infra, Duration duration) {}\n+\n+    @ParameterizedTest\n+    @MethodSource(\"infraDurationPairs\")\n+    void testClientConnectTimeout(InfraDurationPair pair) throws Exception {\n+        testConfig(pair.infra, clientBuilder -> clientBuilder.connectTimeout(pair.duration), null);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"infraDurationPairs\")\n+    void testRequestTimeout(InfraDurationPair pair) throws Exception {\n+        testConfig(pair.infra, null, requestBuilder -> requestBuilder.timeout(pair.duration));\n+    }\n+\n+    private static Stream<InfraDurationDurationTriple> infraDurationDurationTriples() {\n+        return infras().flatMap(infra -> EXCESSIVE_DURATIONS.stream()\n+                .flatMap(duration1 -> EXCESSIVE_DURATIONS.stream()\n+                        .map(duration2 -> new InfraDurationDurationTriple(infra, duration1, duration2))));\n+    }\n+\n+    private record InfraDurationDurationTriple(Infra infra, Duration duration1, Duration duration2) {}\n+\n+    @ParameterizedTest\n+    @MethodSource(\"infraDurationDurationTriples\")\n+    void testClientConnectTimeoutAndRequestTimeout(InfraDurationDurationTriple triple) throws Exception {\n+        testConfig(\n+                triple.infra,\n+                clientBuilder -> clientBuilder.connectTimeout(triple.duration1),\n+                requestBuilder -> requestBuilder.timeout(triple.duration2));\n+    }\n+\n+    private static void testConfig(\n+            Infra infra,\n+            Consumer<HttpClient.Builder> clientBuilderConsumer,\n+            Consumer<HttpRequest.Builder> requestBuilderConsumer)\n+            throws Exception {\n+\n+        \/\/ Create the client\n+        var clientBuilder = infra.clientBuilderSupplier.get();\n+        if (clientBuilderConsumer != null) {\n+            clientBuilderConsumer.accept(clientBuilder);\n+        }\n+        try (var client = clientBuilder.build()) {\n+\n+            \/\/ Create the request\n+            byte[] expectedBytes = \"abc\".repeat(8192).getBytes(US_ASCII);\n+            var requestBuilder = infra.requestBuilderSupplier.get()\n+                    \/\/ Intentionally opting for sending a body to cover code paths associated with its delivery\n+                    .POST(BodyPublishers.ofByteArray(expectedBytes));\n+            if (requestBuilderConsumer != null) {\n+                requestBuilderConsumer.accept(requestBuilder);\n+            }\n+            var request = requestBuilder.build();\n+\n+            \/\/ Execute the request.\n+            \/\/ Doing it twice to touch code paths before & after a protocol upgrade, if present.\n+            for (int requestIndex = 0; requestIndex < 2; requestIndex++) {\n+                LOGGER.log(\"Executing request (attempt=%s)\", requestIndex + 1);\n+                var response = client.send(request, BodyHandlers.ofByteArray());\n+\n+                \/\/ Verify the response status code\n+                if (response.statusCode() != 200) {\n+                    var message = String.format(\n+                            \"Unexpected status code: %s (attempt=%s)\",\n+                            response.statusCode(), requestIndex + 1);\n+                    throw new AssertionError(message);\n+                }\n+\n+                \/\/ Verify the response body\n+                int mismatchIndex = Arrays.mismatch(expectedBytes, response.body());\n+                if (mismatchIndex > 0) {\n+                    var message = String.format(\n+                            \"Body mismatch at index %s (attempt=%s)\",\n+                            mismatchIndex, requestIndex + 1);\n+                    throw new AssertionError(message);\n+                }\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/DurationOverflowTest.java","additions":347,"deletions":0,"binary":false,"changes":347,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8368528\n+ * @summary Verifies that `Deadline` returns extremums on numeric overflows\n+ * @modules java.net.http\/jdk.internal.net.http.common:+open\n+ * @run junit java.net.http\/jdk.internal.net.http.common.DeadlineOverflowTest\n+ *\/\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/DeadlineOverflowTestDriver.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http.common;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+\n+import static java.time.temporal.ChronoUnit.NANOS;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+class DeadlineOverflowTest {\n+\n+    @Test\n+    void test_DeadlineOf_InstantMin() {\n+        assertEquals(Instant.MIN, Deadline.of(Instant.MIN).asInstant());\n+    }\n+\n+    @Test\n+    void test_DeadlineOf_InstantMax() {\n+        assertEquals(Instant.MAX, Deadline.of(Instant.MAX).asInstant());\n+    }\n+\n+    @Test\n+    void test_plusNanos_min() {\n+        assertEquals(Deadline.MIN, Deadline.MIN.plusNanos(-1));\n+    }\n+\n+    @Test\n+    void test_plusNanos_max() {\n+        assertEquals(Deadline.MAX, Deadline.MAX.plusNanos(1));\n+    }\n+\n+    @Test\n+    void test_minus_min() {\n+        assertEquals(Deadline.MIN, Deadline.MIN.minus(Duration.ofNanos(1)));\n+    }\n+\n+    @Test\n+    void test_minus_max() {\n+        assertEquals(Deadline.MAX, Deadline.MAX.minus(Duration.ofNanos(-1)));\n+    }\n+\n+    @Test\n+    void test_plusAmount_min() {\n+        assertEquals(Deadline.MIN, Deadline.MIN.plus(-1, ChronoUnit.NANOS));\n+    }\n+\n+    @Test\n+    void test_plusAmount_max() {\n+        assertEquals(Deadline.MAX, Deadline.MAX.plus(1, ChronoUnit.NANOS));\n+    }\n+\n+    @Test\n+    void test_plusSeconds_min() {\n+        assertEquals(Deadline.MIN, Deadline.MIN.plusSeconds(-1));\n+    }\n+\n+    @Test\n+    void test_plusSeconds_max() {\n+        assertEquals(Deadline.MAX, Deadline.MAX.plusSeconds(1));\n+    }\n+\n+    @Test\n+    void test_plusMillis_min() {\n+        assertEquals(Deadline.MIN, Deadline.MIN.plusMillis(-1));\n+    }\n+\n+    @Test\n+    void test_plusMillis_max() {\n+        assertEquals(Deadline.MAX, Deadline.MAX.plusMillis(1));\n+    }\n+\n+    @Test\n+    void test_plusDuration_min() {\n+        assertEquals(Deadline.MIN, Deadline.MIN.plus(Duration.ofNanos(-1)));\n+    }\n+\n+    @Test\n+    void test_plusDuration_max() {\n+        assertEquals(Deadline.MAX, Deadline.MAX.plus(Duration.ofNanos(1)));\n+    }\n+\n+    @Test\n+    void test_until_min() {\n+        assertEquals(Long.MIN_VALUE, Deadline.MAX.until(Deadline.MIN, NANOS));\n+    }\n+\n+    @Test\n+    void test_until_max() {\n+        assertEquals(Long.MAX_VALUE, Deadline.MIN.until(Deadline.MAX, NANOS));\n+    }\n+\n+    @Test\n+    void test_between_min() {\n+        Duration delta = Duration.between(Instant.MAX, Instant.MIN);\n+        assertEquals(delta, Deadline.between(Deadline.MAX, Deadline.MIN));\n+    }\n+\n+    @Test\n+    void test_between_max() {\n+        Duration delta = Duration.between(Instant.MIN, Instant.MAX);\n+        assertEquals(delta, Deadline.between(Deadline.MIN, Deadline.MAX));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/common\/DeadlineOverflowTest.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"}]}