{"files":[{"patch":"@@ -116,0 +116,1 @@\n+     * @throws IllegalArgumentException if any of {@code arguments} is void\n@@ -122,1 +123,1 @@\n-                                                      List.of(arguments));\n+                                                      SignaturesImpl.validateArgumentList(arguments));\n@@ -134,0 +135,1 @@\n+     * @throws IllegalArgumentException if any of {@code arguments} is void\n@@ -143,1 +145,1 @@\n-                List.of(arguments));\n+                SignaturesImpl.validateArgumentList(arguments));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodSignature.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,5 @@\n+ * <p>\n+ * Names in signatures are <dfn id=\"#identifier\">identifiers<\/dfn>, which must\n+ * not be empty and must not contain any of the ASCII characters {@code\n+ * . ; [ \/ < > :}.  Top-level class and interface names are denoted by\n+ * slash-separated identifiers.\n@@ -76,0 +81,3 @@\n+     * @throws IllegalArgumentException if the field descriptor cannot be\n+     *         {@linkplain ##identifier denoted}, such as due to the presence\n+     *         of ASCII characters {@code < > :}\n@@ -191,1 +199,3 @@\n-         *         represent a class or interface\n+         *         represent a class or interface, or if it cannot be\n+         *         {@linkplain ##identifier denoted}, such as due to the\n+         *         presence of ASCII characters {@code < > :}\n@@ -194,1 +204,1 @@\n-            return of(null, className, typeArgs);\n+            return of(null, Util.toInternalName(className), typeArgs);\n@@ -204,1 +214,8 @@\n-         *         represent a class or interface\n+         *         represent a class or interface, or if it cannot be\n+         *         {@linkplain ##identifier denoted}, such as due to the\n+         *         presence of ASCII characters {@code < > :}\n+         * @deprecated\n+         * The resulting signature does not denote the class represented by\n+         * {@code className} when {@code outerType} is not null.  Use {@link\n+         * #of(ClassTypeSig, String, TypeArg...) of(ClassTypeSig, String, TypeArg...)}\n+         * instead.\n@@ -206,0 +223,1 @@\n+        @Deprecated(since = \"26\", forRemoval = true)\n@@ -216,0 +234,3 @@\n+         * @throws IllegalArgumentException if {@code className} cannot be\n+         *         {@linkplain ##identifier denoted}, such as due to the\n+         *         presence of ASCII characters {@code < > :}\n@@ -225,0 +246,1 @@\n+         *        to indicate this is a top-level class or interface\n@@ -227,0 +249,3 @@\n+         * @throws IllegalArgumentException if {@code className} cannot be\n+         *         {@linkplain ##identifier denoted}, such as due to the\n+         *         presence of ASCII characters {@code < > :}\n@@ -229,2 +254,6 @@\n-            requireNonNull(className);\n-            return new SignaturesImpl.ClassTypeSigImpl(Optional.ofNullable(outerType), className.replace(\".\", \"\/\"), List.of(typeArgs));\n+            if (outerType != null) {\n+                SignaturesImpl.validateIdentifier(className);\n+            } else {\n+                SignaturesImpl.validatePackageSpecifierPlusIdentifier(className);\n+            }\n+            return new SignaturesImpl.ClassTypeSigImpl(Optional.ofNullable(outerType), className, List.of(typeArgs));\n@@ -386,0 +415,3 @@\n+         * @throws IllegalArgumentException if the name cannot be {@linkplain\n+         *         ##identifier denoted}, such as due to the presence of ASCII\n+         *         characters {@code < > :}\n@@ -388,1 +420,1 @@\n-            return new SignaturesImpl.TypeVarSigImpl(requireNonNull(identifier));\n+            return new SignaturesImpl.TypeVarSigImpl(SignaturesImpl.validateIdentifier(identifier));\n@@ -411,0 +443,1 @@\n+         * @throws IllegalArgumentException if the component type is void\n@@ -413,1 +446,1 @@\n-            return of(1, requireNonNull(componentSignature));\n+            return of(1, SignaturesImpl.validateNonVoid(componentSignature));\n@@ -421,1 +454,2 @@\n-         *         resulting array type exceeds 255 dimensions\n+         *         resulting array type exceeds 255 dimensions or the component\n+         *         type is void\n@@ -424,1 +458,1 @@\n-            requireNonNull(componentSignature);\n+            SignaturesImpl.validateNonVoid(componentSignature);\n@@ -472,0 +506,3 @@\n+         * @throws IllegalArgumentException if the name cannot be {@linkplain\n+         *         ##identifier denoted}, such as due to the presence of ASCII\n+         *         characters {@code < > :}\n@@ -475,1 +512,1 @@\n-                    requireNonNull(identifier),\n+                    SignaturesImpl.validateIdentifier(identifier),\n@@ -486,0 +523,3 @@\n+         * @throws IllegalArgumentException if the name cannot be {@linkplain\n+         *         ##identifier denoted}, such as due to the presence of ASCII\n+         *         characters {@code < > :}\n@@ -489,1 +529,1 @@\n-                    requireNonNull(identifier),\n+                    SignaturesImpl.validateIdentifier(identifier),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Signature.java","additions":51,"deletions":11,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,1 +312,1 @@\n-                        map(cts.classDesc()),\n+                        Util.toInternalName(map(cts.classDesc())), \/\/ wrong, needs fix with InnerClasses\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-                paramTypes.add(typeSig());\n+                paramTypes.add(validateNonVoid(typeSig()));\n@@ -229,1 +229,0 @@\n-        l:\n@@ -231,5 +230,2 @@\n-            switch (sig.charAt(sigp)) {\n-                case '.', ';', '[', '\/', '<', '>', ':' -> {\n-                    break l;\n-                }\n-            }\n+            if (isNonIdentifierChar(sig.charAt(sigp)))\n+                break;\n@@ -244,0 +240,71 @@\n+    \/\/ Non-identifier chars in ascii 0 to 63, note [ is larger\n+    private static final long SMALL_NON_IDENTIFIER_CHARS_SET = (1L << '.')\n+            | (1L << ';')\n+            | (1L << '\/')\n+            | (1L << '<')\n+            | (1L << '>')\n+            | (1L << ':');\n+\n+    private static boolean isNonIdentifierChar(char c) {\n+        return c < Long.SIZE ? (SMALL_NON_IDENTIFIER_CHARS_SET & (1L << c)) != 0 : c == '[';\n+    }\n+\n+    \/\/\/ {@return exclusive end of the next identifier}\n+    public static int nextIdentifierEnd(String st, int start) {\n+        int end = st.length();\n+        for (int i = start; i < end; i++) {\n+            if (isNonIdentifierChar(st.charAt(i))) {\n+                return i;\n+            }\n+        }\n+        return end;\n+    }\n+\n+    \/\/\/ Validates this string as a simple identifier.\n+    public static String validateIdentifier(String st) {\n+        var len = st.length(); \/\/ implicit null check\n+        if (len == 0 || nextIdentifierEnd(st, 0) != len) {\n+            throw new IllegalArgumentException(\"Not a valid identifier: \" + st);\n+        }\n+        return st;\n+    }\n+\n+    \/\/\/ Validates this string as slash-separated one or more identifiers.\n+    public static String validatePackageSpecifierPlusIdentifier(String st) {\n+        int nextIdentifierStart = 0;\n+        int len = st.length();\n+        while (nextIdentifierStart < len) {\n+            int end = nextIdentifierEnd(st, nextIdentifierStart);\n+            if (end == len)\n+                return st;\n+            if (end == nextIdentifierStart || st.charAt(end) != '\/')\n+                throw new IllegalArgumentException(\"Not a class name: \" + st);\n+            nextIdentifierStart = end + 1;\n+        }\n+        \/\/ Couldn't get an identifier initially or after a separator.\n+        throw new IllegalArgumentException(\"Not a class name: \" + st);\n+    }\n+\n+    \/\/\/ Validates the signature to be non-void (a valid field type).\n+    public static Signature validateNonVoid(Signature incoming) {\n+        Objects.requireNonNull(incoming);\n+        if (incoming instanceof Signature.BaseTypeSig baseType && baseType.baseType() == 'V')\n+            throw new IllegalArgumentException(\"void\");\n+        return incoming;\n+    }\n+\n+    \/\/\/ Returns the validated immutable argument list or fails with IAE.\n+    public static List<Signature> validateArgumentList(Signature[] signatures) {\n+        return validateArgumentList(List.of(signatures));\n+    }\n+\n+    \/\/\/ Returns the validated immutable argument list or fails with IAE.\n+    public static List<Signature> validateArgumentList(List<Signature> signatures) {\n+        var res = List.copyOf(signatures); \/\/ deep null checks\n+        for (var sig : signatures) {\n+            if (sig instanceof Signature.BaseTypeSig baseType && baseType.baseType() == 'V')\n+                throw new IllegalArgumentException(\"void\");\n+        }\n+        return res;\n+    }\n+\n@@ -319,1 +386,1 @@\n-        if (typeParameters != null && !typeParameters.isEmpty()) {\n+        if (!typeParameters.isEmpty()) {\n@@ -325,1 +392,1 @@\n-                if (tp.interfaceBounds() != null) for (var is : tp.interfaceBounds())\n+                for (var is : tp.interfaceBounds())\n@@ -340,1 +407,1 @@\n-            if (superinterfaceSignatures != null) for (var in : superinterfaceSignatures)\n+            for (var in : superinterfaceSignatures)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":78,"deletions":11,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,3 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n@@ -66,1 +69,1 @@\n-                                ClassDesc.of(\"LinkedHashIterator\")),\n+                                \"LinkedHashIterator\"),\n@@ -122,0 +125,61 @@\n+    @Test\n+    void testGenericCreationChecks() {\n+        var weirdNameClass = ClassDesc.of(\"<Unsupported>\");\n+        var voidSig = BaseTypeSig.of('V');\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> Signature.of(weirdNameClass));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> BaseTypeSig.of(CD_Object));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> BaseTypeSig.of(CD_int.arrayType()));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(CD_int));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(CD_Object.arrayType()));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(weirdNameClass));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ArrayTypeSig.of(voidSig));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ArrayTypeSig.of(255, voidSig));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> MethodSignature.of(voidSig, voidSig));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> MethodSignature.of(List.of(), List.of(), voidSig, voidSig));\n+    }\n+\n+    static Stream<String> goodIdentifiers() {\n+        return Stream.of(\"T\", \"Hello\", \"Mock\", \"(Weird)\", \" Huh? \");\n+    }\n+\n+    static Stream<String> badIdentifiers() {\n+        return Stream.of(\"\", \";\", \".\", \"\/\", \"<\", \">\", \"[\", \":\",\n+                \"<Unsupported>\", \"has.chars\", \"\/Outer\", \"test\/\", \"test\/\/Outer\");\n+    }\n+\n+    static Stream<String> slashedIdentifiers() {\n+        return Stream.of(\"test\/Outer\", \"java\/lang\/Integer\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource({\"badIdentifiers\", \"slashedIdentifiers\"})\n+    void testBadSimpleIdentifier(String st) {\n+        ClassTypeSig outer = ClassTypeSig.of(\"test\/Outer\");\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(outer, st));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> TypeVarSig.of(st));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> TypeParam.of(st, (RefTypeSig) null));\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> TypeParam.of(st, Optional.empty()));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"goodIdentifiers\")\n+    void testGoodSimpleIdentifier(String st) {\n+        ClassTypeSig outer = ClassTypeSig.of(\"test\/Outer\");\n+        ClassTypeSig.of(outer, st);\n+        TypeVarSig.of(st);\n+        TypeParam.of(st, (RefTypeSig) null);\n+        TypeParam.of(st, Optional.empty());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"badIdentifiers\")\n+    void testBadSlashedIdentifier(String st) {\n+        Assertions.assertThrows(IllegalArgumentException.class, () -> ClassTypeSig.of(st));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource({\"goodIdentifiers\", \"slashedIdentifiers\"})\n+    void testGoodSlashedIdentifier(String st) {\n+        ClassTypeSig.of(st);\n+    }\n+\n@@ -234,0 +298,1 @@\n+        [V\n@@ -300,0 +365,1 @@\n+        (V)V\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":68,"deletions":2,"binary":false,"changes":70,"status":"modified"}]}