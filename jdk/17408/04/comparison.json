{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, JetBrains s.r.o.. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.awt.AWTException;\n@@ -29,0 +30,1 @@\n+import java.awt.Composite;\n@@ -33,0 +35,3 @@\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n@@ -34,0 +39,1 @@\n+import java.awt.Insets;\n@@ -35,0 +41,1 @@\n+import java.awt.Point;\n@@ -36,0 +43,1 @@\n+import java.awt.Rectangle;\n@@ -38,0 +46,2 @@\n+import java.awt.Toolkit;\n+import java.awt.Transparency;\n@@ -39,0 +49,2 @@\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentEvent;\n@@ -41,0 +53,1 @@\n+\n@@ -51,0 +64,1 @@\n+import java.awt.image.VolatileImage;\n@@ -52,0 +66,2 @@\n+import java.io.File;\n+import java.io.FileOutputStream;\n@@ -53,1 +69,3 @@\n-import java.lang.reflect.InvocationTargetException;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+\n@@ -55,0 +73,4 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n@@ -56,0 +78,5 @@\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n@@ -57,1 +84,1 @@\n-import java.util.concurrent.CountDownLatch;\n+import java.util.Set;\n@@ -59,0 +86,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -61,0 +89,3 @@\n+import java.util.function.IntBinaryOperator;\n+import java.util.regex.Pattern;\n+\n@@ -63,0 +94,1 @@\n+import javax.swing.JLabel;\n@@ -67,2 +99,6 @@\n-public class RenderPerfTest {\n-    private static HashSet<String> ignoredTests = new HashSet<>();\n+\n+public final class RenderPerfTest {\n+\n+    private final static String VERSION = \"RenderPerfTest 2024.02\";\n+\n+    private static final HashSet<String> ignoredTests = new HashSet<>();\n@@ -71,2 +107,3 @@\n-       \/\/ add ignored tests here\n-       \/\/ ignoredTests.add(\"testMyIgnoredTest\");\n+        \/\/ add ignored tests here\n+        \/\/ ignoredTests.add(\"testMyIgnoredTest\");\n+        ignoredTests.add(\"testCalibration\"); \/\/ not from command line\n@@ -75,1 +112,47 @@\n-    private final static int N = 1000;\n+    private final static String EXEC_MODE_ROBOT = \"robot\";\n+    private final static String EXEC_MODE_BUFFER = \"buffer\";\n+    private final static String EXEC_MODE_VOLATILE = \"volatile\";\n+    private final static String EXEC_MODE_DEFAULT = EXEC_MODE_ROBOT;\n+\n+    public final static List<String> EXEC_MODES = Arrays.asList(EXEC_MODE_ROBOT, EXEC_MODE_BUFFER, EXEC_MODE_VOLATILE);\n+\n+    private static String EXEC_MODE = EXEC_MODE_DEFAULT;\n+\n+    private final static String GC_MODE_DEF = \"def\";\n+    private final static String GC_MODE_ALL = \"all\";\n+\n+    private static String GC_MODE = GC_MODE_DEF;\n+\n+    \/\/ System properties:\n+    private final static boolean CALIBRATION = \"true\".equalsIgnoreCase(System.getProperty(\"CALIBRATION\", \"false\"));\n+    private final static boolean REPORT_OVERALL_FPS = \"true\".equalsIgnoreCase(System.getProperty(\"REPORT_OVERALL_FPS\", \"false\"));\n+\n+    private final static boolean DUMP_SAMPLES = \"true\".equalsIgnoreCase(System.getProperty(\"DUMP_SAMPLES\", \"false\"));\n+    private final static boolean TRACE = \"true\".equalsIgnoreCase(System.getProperty(\"TRACE\", \"false\"));\n+    private final static boolean TRACE_CONFIGURE = \"true\".equalsIgnoreCase(System.getProperty(\"TRACE_CONFIGURE\", \"false\"));\n+    private final static boolean TRACE_SYNC = \"true\".equalsIgnoreCase(System.getProperty(\"TRACE_SYNC\", \"false\"));\n+\n+    private final static boolean DELAY_START = \"true\".equalsIgnoreCase(System.getProperty(\"DelayStart\", \"false\"));\n+    private final static boolean DELAY_TEST = \"true\".equalsIgnoreCase(System.getProperty(\"DelayTest\", \"false\"));\n+\n+    private final static boolean ROBOT_TIME_DELAY = \"true\".equalsIgnoreCase(System.getProperty(\"ROBOT_TIME_DELAY\", \"true\"));\n+    private final static boolean ROBOT_TIME_ROUND = \"true\".equalsIgnoreCase(System.getProperty(\"ROBOT_TIME_ROUND\", \"false\"));\n+\n+    private final static boolean TEXT_VERSION = \"true\".equalsIgnoreCase(System.getProperty(\"TEXT_VERSION\", \"true\"));\n+\n+    \/\/ time scale multiplier to get more samples so refined metrics:\n+    private final static int TIME_SCALE = Integer.getInteger(\"TIME_SCALE\", 1);\n+\n+    \/\/ default settings:\n+    private static boolean VERBOSE = false;\n+    private static boolean VERBOSE_FONT_CONFIG = false;\n+    private static boolean VERBOSE_GRAPHICS_CONFIG = false;\n+\n+    private static int REPEATS = 1;\n+\n+    private static boolean USE_FPS = true;\n+\n+    private static int NW = 1;\n+\n+    private final static int N_DEFAULT = 1000;\n+    private static int N = N_DEFAULT;\n@@ -81,3 +164,22 @@\n-    private final static int COUNT = 600;\n-    private final static int CYCLE_DELAY = 3;\n-    private final static int MAX_FRAME_CYCLES = 3000\/CYCLE_DELAY;\n+    private final static int IMAGE_W = (int) (WIDTH + BW);\n+    private final static int IMAGE_H = (int) (HEIGHT + BH);\n+\n+    \/\/ Test attributes:\n+    private static String TEXT_STR = TEXT_VERSION ? VERSION : \"The quick brown fox jumps over the lazy dog\";\n+\n+    private static String TEXT_FONT = Font.DIALOG;\n+    private static int TEXT_SIZE_DEFAULT = 12;\n+    private static int TEXT_SIZE_LARGE = 32;\n+\n+    private final static int COUNT = 600 * TIME_SCALE;\n+    private final static int MIN_COUNT = 20;\n+    private final static int MAX_SAMPLE_COUNT = 2 * COUNT;\n+\n+    private static int WARMUP_COUNT = MIN_COUNT;\n+\n+    private final static int DELAY = 1;\n+    private final static int CYCLE_DELAY = DELAY;\n+\n+    private final static long MIN_MEASURE_TIME_NS = 1000L * 1000 * 1000 * TIME_SCALE; \/\/ 1s min\n+    private final static long MAX_MEASURE_TIME_NS = 6000L * 1000 * 1000 * TIME_SCALE; \/\/ 6s max\n+    private final static int MAX_FRAME_CYCLES = 1000 * TIME_SCALE \/ CYCLE_DELAY;\n@@ -86,1 +188,0 @@\n-    private final static int MAX_MEASURE_CYCLES = 6000\/CYCLE_DELAY;\n@@ -88,1 +189,6 @@\n-    private final static Color[] marker = {Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW, Color.ORANGE, Color.MAGENTA};\n+    private final static Color[] MARKER = {Color.RED, Color.BLUE, Color.GREEN};\n+\n+    private final static Toolkit TOOLKIT = Toolkit.getDefaultToolkit();\n+\n+    private final static long FRAME_MAX = 60;\n+    private final static long FRAME_PREC_IN_NANOS = (1000L * 1000 * 1000) \/ (2L * FRAME_MAX);\n@@ -91,1 +197,1 @@\n-        void configure(Graphics2D g2d);\n+        void configure(Graphics2D g2d, boolean enabled);\n@@ -94,4 +200,50 @@\n-    interface Renderable {\n-        void setup(Graphics2D g2d);\n-        void render(Graphics2D g2d);\n-        void update();\n+    final static class ConfigurableAA implements Configurable {\n+        @Override\n+        public void configure(final Graphics2D g2d, final boolean enabled) {\n+            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                    enabled ? RenderingHints.VALUE_ANTIALIAS_ON\n+                            : RenderingHints.VALUE_ANTIALIAS_OFF);\n+        }\n+    }\n+\n+    final static class ConfigurableTextAA implements Configurable {\n+        @Override\n+        public void configure(final Graphics2D g2d, final boolean enabled) {\n+            g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                    enabled ? RenderingHints.VALUE_TEXT_ANTIALIAS_ON\n+                            : RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);\n+        }\n+    }\n+\n+    final static class ConfigurableTextLCD implements Configurable {\n+        @Override\n+        public void configure(final Graphics2D g2d, final boolean enabled) {\n+            g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                    enabled ? RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB\n+                            : RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);\n+        }\n+    }\n+\n+    final static class ConfigurableXORMode implements Configurable {\n+        @Override\n+        public void configure(final Graphics2D g2d, final boolean enabled) {\n+            if (enabled) {\n+                g2d.setXORMode(Color.WHITE);\n+            } else {\n+                g2d.setPaintMode();\n+            }\n+        }\n+    }\n+\n+    final static class ConfigurableXORModeTextLCD implements Configurable {\n+        @Override\n+        public void configure(final Graphics2D g2d, final boolean enabled) {\n+            if (enabled) {\n+                g2d.setXORMode(Color.WHITE);\n+            } else {\n+                g2d.setPaintMode();\n+            }\n+            g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                    enabled ? RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB\n+                            : RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT);\n+        }\n@@ -100,7 +252,7 @@\n-    static class Particles {\n-        private float[] bx;\n-        private float[] by;\n-        private float[] vx;\n-        private float[] vy;\n-        private float r;\n-        private int n;\n+    final static class Particles {\n+        private final float[] bx;\n+        private final float[] by;\n+        private final float[] vx;\n+        private final float[] vy;\n+        private final float r;\n+        private final int n;\n@@ -108,4 +260,4 @@\n-        private float x0;\n-        private float y0;\n-        private float width;\n-        private float height;\n+        private final float x0;\n+        private final float y0;\n+        private final float width;\n+        private final float height;\n@@ -146,1 +298,0 @@\n-\n@@ -148,1 +299,0 @@\n-\n@@ -151,2 +301,6 @@\n-    ParticleRenderable createPR(ParticleRenderer renderer) {\n-        return new ParticleRenderable(renderer);\n+    interface Renderable {\n+        void setup(Graphics2D g2d, boolean enabled);\n+\n+        void render(Graphics2D g2d);\n+\n+        void update();\n@@ -155,3 +309,4 @@\n-    static class ParticleRenderable implements Renderable {\n-        ParticleRenderer renderer;\n-        Configurable configure;\n+    final static class ParticleRenderable implements Renderable {\n+        final Particles balls;\n+        final ParticleRenderer renderer;\n+        Configurable configure = null;\n@@ -159,1 +314,2 @@\n-        ParticleRenderable(ParticleRenderer renderer, Configurable configure) {\n+        ParticleRenderable(final Particles balls, final ParticleRenderer renderer) {\n+            this.balls = balls;\n@@ -161,5 +317,0 @@\n-            this.configure = configure;\n-        }\n-\n-        ParticleRenderable(ParticleRenderer renderer) {\n-            this(renderer, null);\n@@ -169,2 +320,7 @@\n-        public void setup(Graphics2D g2d) {\n-            if (configure != null) configure.configure(g2d);\n+        public void setup(final Graphics2D g2d, final boolean enabled) {\n+            if (configure != null) {\n+                if (TRACE_CONFIGURE) {\n+                    System.out.println(\"configure(\" + configure.getClass().getSimpleName() + \"): \" + enabled);\n+                }\n+                configure.configure(g2d, enabled);\n+            }\n@@ -183,1 +339,1 @@\n-        public ParticleRenderable configure(Configurable configure) {\n+        public ParticleRenderable configure(final Configurable configure) {\n@@ -191,0 +347,30 @@\n+    }\n+\n+    final static class CalibrationParticleRenderer implements ParticleRenderer {\n+\n+        CalibrationParticleRenderer() {\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            \/\/ no-op\n+        }\n+    }\n+\n+    final static class MixedParticleRenderer implements ParticleRenderer {\n+\n+        private final ParticleRenderer[] renderers;\n+\n+        MixedParticleRenderer(ParticleRenderer... renderers) {\n+            this.renderers = renderers;\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            renderers[id % renderers.length].render(g2d, id, x, y, vx, vy);\n+        }\n+    }\n+\n+    final static class BatchedParticleRenderer implements ParticleRenderer {\n+\n+        private final ParticleRenderer[] renderers;\n@@ -192,0 +378,9 @@\n+        BatchedParticleRenderer(ParticleRenderer... renderers) {\n+            this.renderers = renderers;\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            final int step = N \/ renderers.length;\n+            renderers[(id \/ step) % renderers.length].render(g2d, id, x, y, vx, vy);\n+        }\n@@ -210,1 +405,1 @@\n-            g2d.fillOval((int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r));\n+            g2d.fillOval((int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r));\n@@ -231,0 +426,1 @@\n+\n@@ -232,1 +428,2 @@\n-        float r;\n+        final float r;\n+        final Font font;\n@@ -235,0 +432,4 @@\n+            this(r, TEXT_SIZE_DEFAULT);\n+        }\n+\n+        WhiteTextParticleRenderer(float r, int fontSize) {\n@@ -236,0 +437,1 @@\n+            font = new Font(TEXT_FONT, Font.PLAIN, fontSize);\n@@ -245,6 +447,4 @@\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)(y[id] - r));\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)y[id]);\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)(y[id] + r));\n+            g2d.setFont(font);\n+            g2d.drawString(TEXT_STR, (int) (x[id] - r), (int) (y[id] - r));\n+            g2d.drawString(TEXT_STR, (int) (x[id] - r), (int) y[id]);\n+            g2d.drawString(TEXT_STR, (int) (x[id] - r), (int) (y[id] + r));\n@@ -260,1 +460,5 @@\n-            super(r);\n+            this(n,r, TEXT_SIZE_DEFAULT);\n+        }\n+\n+        TextParticleRenderer(int n, float r, int fontSize) {\n+            super(r, fontSize);\n@@ -277,1 +481,1 @@\n-            super(n, r);\n+            super(n, r, TEXT_SIZE_LARGE);\n@@ -282,1 +486,0 @@\n-            setPaint(g2d, id);\n@@ -284,8 +487,1 @@\n-            Font font = new Font(\"LucidaGrande\", Font.PLAIN, 32);\n-            g2d.setFont(font);\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)(y[id] - r));\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)y[id]);\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)(y[id] + r));\n+            super.render(g2d, id, x, y, vx, vy);\n@@ -297,1 +493,0 @@\n-\n@@ -317,1 +512,1 @@\n-                g2d.fillOval(-(int)r, (int)(-0.5*r), (int) (2 * r), (int)r);\n+                g2d.fillOval(-(int) r, (int) (-0.5 * r), (int) (2 * r), (int) r);\n@@ -320,1 +515,1 @@\n-                g2d.fillOval((int)(x[id] - r), (int)(y[id] - 0.5*r),\n+                g2d.fillOval((int) (x[id] - r), (int) (y[id] - 0.5 * r),\n@@ -328,1 +523,0 @@\n-\n@@ -335,2 +529,2 @@\n-            Point2D start = new Point2D.Double(- r,  - 0.5*r);\n-            Point2D end = new Point2D.Double( 2 * r, r);\n+            Point2D start = new Point2D.Double(-r, -0.5 * r);\n+            Point2D end = new Point2D.Double(2 * r, r);\n@@ -338,3 +532,2 @@\n-            Color[] cls = {colors[id %colors.length], colors[(colors.length - id) %colors.length]};\n-            LinearGradientPaint p =\n-                    new LinearGradientPaint(start, end, dist, cls);\n+            Color[] cls = {colors[id % colors.length], colors[(colors.length - id) % colors.length]};\n+            LinearGradientPaint p = new LinearGradientPaint(start, end, dist, cls);\n@@ -347,1 +540,0 @@\n-\n@@ -354,2 +546,2 @@\n-            Point2D start = new Point2D.Double(- r,  - 0.5*r);\n-            Point2D end = new Point2D.Double( 2 * r, r);\n+            Point2D start = new Point2D.Double(-r, -0.5 * r);\n+            Point2D end = new Point2D.Double(2 * r, r);\n@@ -358,5 +550,4 @@\n-                colors[id %colors.length],\n-                colors[(colors.length - id) %colors.length],\n-                colors[(id*5) %colors.length]};\n-            LinearGradientPaint p =\n-                new LinearGradientPaint(start, end, dist, cls);\n+                    colors[id % colors.length],\n+                    colors[(colors.length - id) % colors.length],\n+                    colors[(id * 5) % colors.length]};\n+            LinearGradientPaint p = new LinearGradientPaint(start, end, dist, cls);\n@@ -369,1 +560,0 @@\n-\n@@ -379,5 +569,4 @@\n-                colors[id %colors.length],\n-                colors[(colors.length - id) %colors.length],\n-                colors[(id*5) %colors.length]};\n-            RadialGradientPaint p =\n-                new RadialGradientPaint(start, r, dist, cls);\n+                    colors[id % colors.length],\n+                    colors[(colors.length - id) % colors.length],\n+                    colors[(id * 5) % colors.length]};\n+            RadialGradientPaint p = new RadialGradientPaint(start, r, dist, cls);\n@@ -390,1 +579,0 @@\n-\n@@ -394,0 +582,1 @@\n+\n@@ -397,2 +586,1 @@\n-            g2d.fillRect((int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r));\n-\n+            g2d.fillRect((int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r));\n@@ -400,1 +588,0 @@\n-\n@@ -405,1 +592,0 @@\n-\n@@ -409,0 +595,1 @@\n+\n@@ -437,1 +624,1 @@\n-            g2d.drawImage(dukeImg, (int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r), null);\n+            g2d.drawImage(dukeImg, (int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r), null);\n@@ -442,1 +629,36 @@\n-    static class FlatBoxRotParticleRenderer extends FlatParticleRenderer {\n+    static class VolImgParticleRenderer extends ImgParticleRenderer {\n+        VolatileImage volImg;\n+\n+        VolImgParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            GraphicsConfiguration config = g2d.getDeviceConfiguration();\n+            if (volImg == null) {\n+                volImg = config.createCompatibleVolatileImage(dukeImg.getWidth(), dukeImg.getHeight(),\n+                        Transparency.TRANSLUCENT);\n+                Graphics2D g = volImg.createGraphics();\n+                g.setComposite(AlphaComposite.Src);\n+                g.drawImage(dukeImg, null, null);\n+                g.dispose();\n+            } else {\n+                int status = volImg.validate(config);\n+                if (status == VolatileImage.IMAGE_INCOMPATIBLE) {\n+                    volImg = config.createCompatibleVolatileImage(dukeImg.getWidth(), dukeImg.getHeight(),\n+                            Transparency.TRANSLUCENT);\n+                }\n+                if (status != VolatileImage.IMAGE_OK) {\n+                    Graphics2D g = volImg.createGraphics();\n+                    g.setComposite(AlphaComposite.Src);\n+                    g.drawImage(dukeImg, null, null);\n+                    g.dispose();\n+                }\n+            }\n+            Composite savedComposite = g2d.getComposite();\n+            g2d.setComposite(AlphaComposite.SrcOver);\n+            g2d.drawImage(volImg, (int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r), null);\n+            g2d.setComposite(savedComposite);\n+        }\n+    }\n@@ -444,0 +666,1 @@\n+    static class FlatBoxRotParticleRenderer extends FlatParticleRenderer {\n@@ -448,0 +671,1 @@\n+\n@@ -459,1 +683,1 @@\n-                g2d.fillRect(-(int)r, -(int)r, (int) (2 * r), (int) (2 * r));\n+                g2d.fillRect(-(int) r, -(int) r, (int) (2 * r), (int) (2 * r));\n@@ -462,1 +686,1 @@\n-                g2d.fillRect((int)(x[id] - r), (int)(y[id] - r),\n+                g2d.fillRect((int) (x[id] - r), (int) (y[id] - r),\n@@ -470,1 +694,0 @@\n-\n@@ -474,0 +697,1 @@\n+\n@@ -477,1 +701,1 @@\n-            g2d.drawOval((int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r));\n+            g2d.drawOval((int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r));\n@@ -479,1 +703,0 @@\n-\n@@ -481,0 +704,1 @@\n+\n@@ -490,1 +714,1 @@\n-            g2d.drawRect((int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r));\n+            g2d.drawRect((int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r));\n@@ -492,1 +716,0 @@\n-\n@@ -494,0 +717,1 @@\n+\n@@ -502,3 +726,3 @@\n-            double v = Math.sqrt(vx[id]*vx[id]+vy[id]*vy[id]);\n-            float nvx = (float) (vx[id]\/v);\n-            float nvy = (float) (vy[id]\/v);\n+            double v = Math.sqrt(vx[id] * vx[id] + vy[id] * vy[id]);\n+            float nvx = (float) (vx[id] \/ v);\n+            float nvy = (float) (vy[id] \/ v);\n@@ -506,2 +730,2 @@\n-            g2d.drawLine((int)(x[id] - r*nvx), (int)(y[id] - r*nvy),\n-                    (int)(x[id] + 2*r*nvx), (int)(y[id] + 2*r*nvy));\n+            g2d.drawLine((int) (x[id] - r * nvx), (int) (y[id] - r * nvy),\n+                    (int) (x[id] + 2 * r * nvx), (int) (y[id] + 2 * r * nvy));\n@@ -509,1 +733,0 @@\n-\n@@ -512,1 +735,0 @@\n-\n@@ -523,1 +745,1 @@\n-                g2d.draw(new QuadCurve2D.Float(x[id-3], y[id-3], x[id-2], y[id-2], x[id-1], y[id-1]));\n+                g2d.draw(new QuadCurve2D.Float(x[id - 3], y[id - 3], x[id - 2], y[id - 2], x[id - 1], y[id - 1]));\n@@ -525,1 +747,0 @@\n-\n@@ -539,1 +760,1 @@\n-                g2d.fill(new QuadCurve2D.Float(x[id-3], y[id-3], x[id-2], y[id-2], x[id-1], y[id-1]));\n+                g2d.fill(new QuadCurve2D.Float(x[id - 3], y[id - 3], x[id - 2], y[id - 2], x[id - 1], y[id - 1]));\n@@ -541,1 +762,0 @@\n-\n@@ -556,1 +776,1 @@\n-            g2d.drawImage(image, (int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r), null);\n+            g2d.drawImage(image, (int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r), null);\n@@ -568,1 +788,0 @@\n-\n@@ -605,2 +824,5 @@\n-    static class PerfMeter {\n-        private String name;\n+    final static class PerfMeter {\n+\n+        private final FrameHandler fh;\n+        private final String name;\n+        private final PerfMeterExecutor executor;\n@@ -608,0 +830,5 @@\n+        PerfMeter(final FrameHandler fh, String name) {\n+            this.fh = fh;\n+            this.name = name;\n+            executor = getExecutor();\n+        }\n@@ -609,1 +836,3 @@\n-        private JPanel panel;\n+        void exec(final Renderable renderable) throws Exception {\n+            executor.exec(name, renderable);\n+        }\n@@ -611,4 +840,14 @@\n-        private double execTime = 0;\n-        private AtomicInteger markerIdx = new AtomicInteger(0);\n-        private int renderedMarkerIdx = -1;\n-        private AtomicLong markerPaintTime = new AtomicLong(0);\n+        private PerfMeterExecutor getExecutor() {\n+            switch (EXEC_MODE) {\n+                default:\n+                case EXEC_MODE_ROBOT:\n+                    return new PerfMeterRobot(fh);\n+                case EXEC_MODE_BUFFER:\n+                    fh.prepareImageProvider(false);\n+                    return new PerfMeterImageProvider(fh);\n+                case EXEC_MODE_VOLATILE:\n+                    fh.prepareImageProvider(true);\n+                    return new PerfMeterImageProvider(fh);\n+            }\n+        }\n+    }\n@@ -616,2 +855,7 @@\n-        private double fps;\n-        private int skippedFrame = 0;\n+    static void paintTest(final Renderable renderable, final Graphics2D g2d,\n+                          final Color markerColor, final boolean doSync) {\n+        \/\/ clip to frame:\n+        g2d.setClip(0, 0, IMAGE_W, IMAGE_H);\n+        \/\/ clear background:\n+        g2d.setColor(Color.BLACK);\n+        g2d.fillRect(0, 0, IMAGE_W, IMAGE_H);\n@@ -619,2 +863,13 @@\n-        PerfMeter(String name) {\n-            this.name = name;\n+        \/\/ render test:\n+        renderable.setup(g2d, true);\n+        renderable.render(g2d);\n+        renderable.setup(g2d, false);\n+\n+        \/\/ draw marker at end:\n+        g2d.setClip(0, 0, BW, BH);\n+        g2d.setColor(markerColor);\n+        g2d.fillRect(0, 0, BW, BH);\n+\n+        if (doSync) {\n+            \/\/ synchronize toolkit:\n+            TOOLKIT.sync();\n@@ -622,0 +877,1 @@\n+    }\n@@ -623,2 +879,1 @@\n-        PerfMeter exec(final Renderable renderable) throws Exception {\n-            final CountDownLatch latchFrame = new CountDownLatch(1);\n+    final static class FrameHandler {\n@@ -626,7 +881,1 @@\n-            final JFrame f = new JFrame();\n-            f.addWindowListener(new WindowAdapter() {\n-                @Override\n-                public void windowClosed(WindowEvent e) {\n-                    latchFrame.countDown();\n-                }\n-            });\n+        private boolean calibrate = VERBOSE;\n@@ -634,3 +883,2 @@\n-            SwingUtilities.invokeAndWait(new Runnable() {\n-                @Override\n-                public void run() {\n+        private int threadId = -1;\n+        private int frameId = -1;\n@@ -638,8 +886,1 @@\n-                    panel = new JPanel() {\n-                        @Override\n-                        protected void paintComponent(Graphics g) {\n-                            super.paintComponent(g);\n-                            int idx = markerIdx.get();\n-                            if (idx != renderedMarkerIdx) {\n-                                markerPaintTime.set(System.nanoTime());\n-                            }\n+        private final GraphicsConfiguration gc;\n@@ -647,10 +888,1 @@\n-                            Graphics2D g2d = (Graphics2D) g.create();\n-                            renderable.setup(g2d);\n-                            renderable.render(g2d);\n-                            g2d.setClip(null);\n-                            g2d.setPaintMode();\n-                            g2d.setColor(marker[idx]);\n-                            g2d.fillRect(0, 0, BW, BH);\n-                            renderedMarkerIdx = idx;\n-                        }\n-                    };\n+        private JFrame frame = null;\n@@ -658,8 +890,2 @@\n-                    panel.setPreferredSize(new Dimension((int) (WIDTH + BW), (int) (HEIGHT + BH)));\n-                    panel.setBackground(Color.BLACK);\n-                    f.add(panel);\n-                    f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n-                    f.pack();\n-                    f.setVisible(true);\n-                }\n-            });\n+        private final CountDownLatch latchShownFrame = new CountDownLatch(1);\n+        private final CountDownLatch latchClosedFrame = new CountDownLatch(1);\n@@ -667,11 +893,1 @@\n-            Robot robot = new Robot();\n-            int cycle = 0;\n-            int frame = 0;\n-            long paintTime = 0;\n-            int maxFrameCycle = -1;\n-            while (frame < COUNT) {\n-                long t;\n-                if ((t = markerPaintTime.getAndSet(0)) > 0) {\n-                    paintTime = t;\n-                    maxFrameCycle = cycle + MAX_FRAME_CYCLES;\n-                }\n+        private ImageProvider imageProvider = null;\n@@ -679,19 +895,17 @@\n-                if (paintTime > 0) {\n-                    Color c = robot.getPixelColor(\n-                            panel.getTopLevelAncestor().getX() + panel.getTopLevelAncestor().getInsets().left + BW \/ 2,\n-                            panel.getTopLevelAncestor().getY() + panel.getTopLevelAncestor().getInsets().top + BW \/ 2);\n-\n-                    if (isAlmostEqual(c, marker[markerIdx.get()])) {\n-                        execTime += System.nanoTime() - paintTime;\n-                        frame++;\n-                        paintTime = 0;\n-                        maxFrameCycle = -1;\n-                        markerIdx.accumulateAndGet(marker.length, (x, y) -> (x + 1) % y);\n-                        renderable.update();\n-                        panel.getParent().repaint();\n-                    } else if (cycle >= maxFrameCycle) {\n-                        skippedFrame++;\n-                        paintTime = 0;\n-                        maxFrameCycle = -1;\n-                        markerIdx.accumulateAndGet(marker.length, (x, y) -> (x + 1) % y);\n-                        panel.getParent().repaint();\n+        FrameHandler(GraphicsConfiguration gc) {\n+            this.gc = gc;\n+        }\n+\n+        void setIds(int threadId, int frameId) {\n+            this.threadId = threadId;\n+            this.frameId = frameId;\n+        }\n+\n+        void prepareFrameEDT(final String title) {\n+            if (frame == null) {\n+                frame = new JFrame(gc);\n+                frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+                frame.addComponentListener(new ComponentAdapter() {\n+                    @Override\n+                    public void componentShown(ComponentEvent e) {\n+                        latchShownFrame.countDown();\n@@ -699,10 +913,7 @@\n-                }\n-                try {\n-                    Thread.sleep(CYCLE_DELAY);\n-                } catch (InterruptedException ex) {\n-                    ex.printStackTrace();\n-                }\n-                if (cycle >= MAX_MEASURE_CYCLES) {\n-                    break;\n-                }\n-                cycle++;\n+                });\n+                frame.addWindowListener(new WindowAdapter() {\n+                    @Override\n+                    public void windowClosed(WindowEvent e) {\n+                        latchClosedFrame.countDown();\n+                    }\n+                });\n@@ -710,4 +921,2 @@\n-            SwingUtilities.invokeAndWait(() -> {\n-                f.setVisible(false);\n-                f.dispose();\n-            });\n+            frame.setTitle(title);\n+        }\n@@ -715,5 +924,23 @@\n-            latchFrame.await();\n-            if (execTime != 0 && frame != 0) {\n-                fps = 1e9 \/ (execTime \/ frame);\n-            } else {\n-                fps = 0;\n+        void showFrameEDT(final JPanel panel) {\n+            if (frame != null) {\n+                panel.setPreferredSize(new Dimension(IMAGE_W, IMAGE_H));\n+                panel.setBackground(Color.BLACK);\n+\n+                frame.getContentPane().removeAll();\n+                frame.getContentPane().add(panel);\n+                frame.getContentPane().revalidate();\n+\n+                if (!frame.isVisible()) {\n+                    if (frameId != -1) {\n+                        final int off = (frameId - 1) * 100;\n+                        final Rectangle gcBounds = gc.getBounds();\n+                        final int xoff = gcBounds.x + off;\n+                        final int yoff = gcBounds.y + off;\n+\n+                        if ((xoff != 0) || (yoff != 0)) {\n+                            frame.setLocation(xoff, yoff);\n+                        }\n+                    }\n+                    frame.pack();\n+                    frame.setVisible(true);\n+                }\n@@ -721,0 +948,1 @@\n+        }\n@@ -722,1 +950,14 @@\n-            return this;\n+        void waitFrameShown() throws Exception {\n+            latchShownFrame.await();\n+        }\n+\n+        void resetFrame() throws Exception {\n+            if (frame != null) {\n+                SwingUtilities.invokeAndWait(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        frame.getContentPane().removeAll();\n+                        frame.getContentPane().revalidate();\n+                    }\n+                });\n+            }\n@@ -725,3 +966,8 @@\n-        private void report() {\n-            if (skippedFrame > 0) {\n-                System.err.println(skippedFrame + \" frame(s) skipped\");\n+        void repaintFrame() throws Exception {\n+            if (frame != null) {\n+                SwingUtilities.invokeAndWait(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        frame.repaint();\n+                    }\n+                });\n@@ -729,1 +975,0 @@\n-            System.err.println(name + \" : \" + String.format(\"%.2f FPS\", fps));\n@@ -732,4 +977,17 @@\n-        private boolean isAlmostEqual(Color c1, Color c2) {\n-            return Math.abs(c1.getRed() - c2.getRed()) < COLOR_TOLERANCE &&\n-                    Math.abs(c1.getGreen() - c2.getGreen()) < COLOR_TOLERANCE &&\n-                    Math.abs(c1.getBlue() - c2.getBlue()) < COLOR_TOLERANCE;\n+        private void waitFrameHidden() throws Exception {\n+            latchClosedFrame.await();\n+        }\n+\n+        void hideFrameAndWait() throws Exception {\n+            if (frame != null) {\n+                SwingUtilities.invokeAndWait(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        frame.setVisible(false);\n+                        frame.dispose();\n+                        frame = null;\n+                    }\n+                });\n+                waitFrameHidden();\n+            }\n+        }\n@@ -737,0 +995,4 @@\n+        void prepareImageProvider(final boolean useVolatile) {\n+            if (this.imageProvider == null) {\n+                this.imageProvider = new ImageProvider(useVolatile);\n+            }\n@@ -740,23 +1002,1 @@\n-    private static final Particles balls = new Particles(N, R, BW, BH, WIDTH, HEIGHT);\n-    private static final ParticleRenderer flatRenderer = new FlatParticleRenderer(N, R);\n-    private static final ParticleRenderer clipFlatRenderer = new ClipFlatParticleRenderer(N, R);\n-    private static final ParticleRenderer flatOvalRotRenderer = new FlatOvalRotParticleRenderer(N, R);\n-    private static final ParticleRenderer flatBoxRenderer = new FlatBoxParticleRenderer(N, R);\n-    private static final ParticleRenderer clipFlatBoxParticleRenderer = new ClipFlatBoxParticleRenderer(N, R);\n-    private static final ParticleRenderer flatBoxRotRenderer = new FlatBoxRotParticleRenderer(N, R);\n-    private static final ParticleRenderer linGradOvalRotRenderer = new LinGradOvalRotParticleRenderer(N, R);\n-    private static final ParticleRenderer linGrad3OvalRotRenderer = new LinGrad3OvalRotParticleRenderer(N, R);\n-    private static final ParticleRenderer radGrad3OvalRotRenderer = new RadGrad3OvalRotParticleRenderer(N, R);\n-    private static final ParticleRenderer wiredRenderer = new WiredParticleRenderer(N, R);\n-    private static final ParticleRenderer wiredBoxRenderer = new WiredBoxParticleRenderer(N, R);\n-    private static final ParticleRenderer segRenderer = new SegParticleRenderer(N, R);\n-    private static final ParticleRenderer flatQuadRenderer = new FlatQuadParticleRenderer(N, R);\n-    private static final ParticleRenderer wiredQuadRenderer = new WiredQuadParticleRenderer(N, R);\n-    private static final ParticleRenderer imgRenderer = new ImgParticleRenderer(N, R);\n-    private static final ParticleRenderer textRenderer = new TextParticleRenderer(N, R);\n-    private static final ParticleRenderer largeTextRenderer = new LargeTextParticleRenderer(N, R);\n-    private static final ParticleRenderer whiteTextRenderer = new WhiteTextParticleRenderer(R);\n-    private static final ParticleRenderer argbSwBlitImageRenderer = new SwBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_ARGB);\n-    private static final ParticleRenderer bgrSwBlitImageRenderer = new SwBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_BGR);\n-    private static final ParticleRenderer argbSurfaceBlitImageRenderer = new SurfaceBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_ARGB);\n-    private static final ParticleRenderer bgrSurfaceBlitImageRenderer = new SurfaceBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_BGR);\n+    static abstract class PerfMeterExecutor {\n@@ -764,3 +1004,3 @@\n-    private static final Configurable AA = (Graphics2D g2d) ->\n-        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n-            RenderingHints.VALUE_ANTIALIAS_ON);\n+        protected final static int SCORE_MAIN = 0;\n+        protected final static int SCORE_ERROR = 1;\n+        protected final static int SCORE_OTHER = 2;\n@@ -768,3 +1008,7 @@\n-    private static final Configurable TextLCD = (Graphics2D g2d) ->\n-        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n-                RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);\n+        protected final static int PCT_00 = 0;\n+        protected final static int PCT_10 = 1;\n+        protected final static int PCT_25 = 2;\n+        protected final static int PCT_50 = 3;\n+        protected final static int PCT_75 = 4;\n+        protected final static int PCT_90 = 5;\n+        protected final static int PCT_100 = 6;\n@@ -772,3 +1016,5 @@\n-    private static final Configurable TextAA = (Graphics2D g2d) ->\n-        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n-                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+        private final static IntBinaryOperator INC_MOD_FUNC = new IntBinaryOperator() {\n+            public int applyAsInt(int x, int y) {\n+                return (x + 1) % y;\n+            }\n+        };\n@@ -776,2 +1022,1 @@\n-    private static final Configurable XORMode = (Graphics2D g2d) ->\n-        {g2d.setXORMode(Color.WHITE);};\n+        private static final AtomicInteger headerMark = new AtomicInteger(1);\n@@ -779,4 +1024,3 @@\n-    private static final Configurable XORModeLCDText = (Graphics2D g2d) ->\n-        {g2d.setXORMode(Color.WHITE);\n-         g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n-         RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);};\n+        \/* members *\/\n+        protected final FrameHandler fh;\n+        protected final boolean skipWait;\n@@ -784,0 +1028,4 @@\n+        protected final AtomicInteger paintIdx = new AtomicInteger(0);\n+        protected final AtomicInteger markerIdx = new AtomicInteger(0);\n+        protected final AtomicLong markerStartTime = new AtomicLong(0);\n+        protected final AtomicLong markerPaintTime = new AtomicLong(0);\n@@ -785,3 +1033,2 @@\n-    public void testFlatOval() throws Exception {\n-        (new PerfMeter(\"FlatOval\")).exec(createPR(flatRenderer)).report();\n-    }\n+        protected String name = null;\n+        protected int skippedFrames = 0;\n@@ -789,3 +1036,5 @@\n-    public void testFlatOvalAA() throws Exception {\n-        (new PerfMeter(\"FlatOvalAA\")).exec(createPR(flatRenderer).configure(AA)).report();\n-    }\n+        protected int frames = 0;\n+        \/\/ test timestamp data:\n+        protected long[] testTimestamp = new long[MAX_SAMPLE_COUNT];\n+        \/\/ test duration data (ns):\n+        protected long[] testTime = new long[MAX_SAMPLE_COUNT];\n@@ -793,3 +1042,2 @@\n-    public void testClipFlatOval() throws Exception {\n-        (new PerfMeter(\"ClipFlatOval\")).exec(createPR(clipFlatRenderer)).report();\n-    }\n+        protected final double[] scores = new double[SCORE_OTHER + 1];\n+        protected final double[] results = new double[PCT_100 + 1];\n@@ -797,3 +1045,4 @@\n-    public void testClipFlatOvalAA() throws Exception {\n-        (new PerfMeter(\"ClipFlatOvalAA\")).exec(createPR(clipFlatRenderer).configure(AA)).report();\n-    }\n+        protected PerfMeterExecutor(final boolean skipWait, final FrameHandler fh) {\n+            this.skipWait = skipWait;\n+            this.fh = fh;\n+        }\n@@ -801,3 +1050,2 @@\n-    public void testFlatBox() throws Exception {\n-        (new PerfMeter(\"FlatBox\")).exec(createPR(flatBoxRenderer)).report();\n-    }\n+        protected void beforeExec() {\n+        }\n@@ -805,3 +1053,2 @@\n-    public void testFlatBoxAA() throws Exception {\n-        (new PerfMeter(\"FlatBoxAA\")).exec(createPR(flatBoxRenderer).configure(AA)).report();\n-    }\n+        protected void afterExec() {\n+        }\n@@ -809,3 +1056,6 @@\n-    public void testClipFlatBox() throws Exception {\n-        (new PerfMeter(\"ClipFlatBox\")).exec(createPR(clipFlatBoxParticleRenderer)).report();\n-    }\n+        protected void reset() {\n+            paintIdx.set(0);\n+            markerIdx.set(0);\n+            markerStartTime.set(0);\n+            markerPaintTime.set(0);\n+        }\n@@ -813,3 +1063,3 @@\n-    public void testClipFlatBoxAA() throws Exception {\n-        (new PerfMeter(\"ClipFlatBoxAA\")).exec(createPR(clipFlatBoxParticleRenderer).configure(AA)).report();\n-    }\n+        protected void updateMarkerIdx() {\n+            markerIdx.accumulateAndGet(MARKER.length, INC_MOD_FUNC);\n+        }\n@@ -817,3 +1067,3 @@\n-    public void testImage() throws Exception {\n-        (new PerfMeter(\"Image\")).exec(createPR(imgRenderer)).report();\n-    }\n+        protected final void exec(final String testName, final Renderable renderable) throws Exception {\n+            if (TRACE) System.out.print(\"\\n!\");\n+            this.name = testName + (isMultiThreads() ? (\"-\" + fh.threadId) : \"\");\n@@ -821,3 +1071,6 @@\n-    public void testImageAA() throws Exception {\n-        (new PerfMeter(\"ImageAA\")).exec(createPR(imgRenderer).configure(AA)).report();\n-    }\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                @Override\n+                public void run() {\n+                    fh.prepareFrameEDT(name);\n+                    \/\/ call beforeExec() after frame is created:\n+                    beforeExec();\n@@ -825,3 +1078,12 @@\n-    public void testRotatedBox() throws Exception {\n-        (new PerfMeter(\"RotatedBox\")).exec(createPR(flatBoxRotRenderer)).report();\n-    }\n+                    final JPanel panel = new JPanel() {\n+                        @Override\n+                        protected void paintComponent(Graphics g) {\n+                            if (TRACE) System.out.print(\"P\");\n+                            paintPanel(renderable, g);\n+                            if (TRACE) System.out.print(\"Q\");\n+                        }\n+                    };\n+                    fh.showFrameEDT(panel);\n+                    if (TRACE) System.out.print(\">>\");\n+                }\n+            });\n@@ -829,3 +1091,2 @@\n-    public void testRotatedBoxAA() throws Exception {\n-        (new PerfMeter(\"RotatedBoxAA\")).exec(createPR(flatBoxRotRenderer).configure(AA)).report();\n-    }\n+            \/\/ Wait frame to be shown:\n+            fh.waitFrameShown();\n@@ -833,3 +1094,1 @@\n-    public void testRotatedOval() throws Exception {\n-        (new PerfMeter(\"RotatedOval\")).exec(createPR(flatOvalRotRenderer)).report();\n-    }\n+            if (TRACE) System.out.print(\":\");\n@@ -837,3 +1096,2 @@\n-    public void testRotatedOvalAA() throws Exception {\n-        (new PerfMeter(\"RotatedOvalAA\")).exec(createPR(flatOvalRotRenderer).configure(AA)).report();\n-    }\n+            \/\/ Reset before warmup:\n+            reset();\n@@ -841,3 +1099,17 @@\n-    public void testLinGrad3RotatedOval() throws Exception {\n-        (new PerfMeter(\"LinGrad3RotatedOval\")).exec(createPR(linGrad3OvalRotRenderer)).report();\n-    }\n+            if (WARMUP_COUNT > 0) {\n+                \/\/ Warmup to prepare frame synchronization:\n+                for (int i = 0; i < WARMUP_COUNT; i++) {\n+                    updateMarkerIdx();\n+                    renderable.update();\n+                    fh.repaintFrame();\n+                    sleep(10);\n+                    while (markerStartTime.get() == 0) {\n+                        if (TRACE) System.out.print(\"-\");\n+                        sleep(1);\n+                    }\n+                    markerStartTime.set(0);\n+                }\n+                \/\/ Reset before measurements:\n+                reset();\n+            }\n+            if (TRACE) System.out.print(\":>>\");\n@@ -845,3 +1117,3 @@\n-    public void testLinGrad3RotatedOvalAA() throws Exception {\n-        (new PerfMeter(\"LinGrad3RotatedOvalAA\")).exec(createPR(linGrad3OvalRotRenderer).configure(AA)).report();\n-    }\n+            \/\/ signal thread is ready for test\n+            readyCount.countDown();\n+            if (TRACE_SYNC) traceSync(name + \" ready => waiting start signal...\");\n@@ -849,3 +1121,4 @@\n-    public void testRadGrad3RotatedOval() throws Exception {\n-        (new PerfMeter(\"RadGrad3RotatedOval\")).exec(createPR(radGrad3OvalRotRenderer)).report();\n-    }\n+            \/\/ wait start signal:\n+            triggerStart.await();\n+            \/\/ Run Benchmark (all threads):\n+            if (TRACE_SYNC) traceSync(name + \" benchmark started\");\n@@ -853,3 +1126,5 @@\n-    public void testRadGrad3RotatedOvalAA() throws Exception {\n-        (new PerfMeter(\"RadGrad3RotatedOvalAA\")).exec(createPR(radGrad3OvalRotRenderer).configure(AA)).report();\n-    }\n+            int cycles = 0;\n+            frames = 0;\n+            long paintStartTime = 0L;\n+            long paintElapsedTime = 0L;\n+            long lastFrameTime = 0L;\n@@ -857,3 +1132,3 @@\n-    public void testLinGradRotatedOval() throws Exception {\n-        (new PerfMeter(\"LinGradRotatedOval\")).exec(createPR(linGradOvalRotRenderer)).report();\n-    }\n+            final long startTime = System.nanoTime();\n+            final long minTime = startTime + MIN_MEASURE_TIME_NS;\n+            final long endTime = startTime + MAX_MEASURE_TIME_NS;\n@@ -861,2 +1136,625 @@\n-    public void testLinGradRotatedOvalAA() throws Exception {\n-        (new PerfMeter(\"LinGradRotatedOvalAA\")).exec(createPR(linGradOvalRotRenderer).configure(AA)).report();\n+            \/\/ Start 1st measurement:\n+            fh.repaintFrame();\n+\n+            for (; ; ) {\n+                long t;\n+                if ((t = markerStartTime.getAndSet(0L)) > 0L) {\n+                    paintStartTime = t;\n+                    if (TRACE) System.out.print(\"|\");\n+                }\n+\n+                boolean wait = true;\n+\n+                if (paintStartTime > 0L) {\n+                    \/\/ get optional elapsed time:\n+                    paintElapsedTime = markerPaintTime.get();\n+\n+                    if (TRACE) System.out.print(\".\");\n+                    wait = !skipWait;\n+                    final Color c = getMarkerColor();\n+\n+                    if (isAlmostEqual(c, MARKER[markerIdx.get()])) {\n+                        final long durationNs = getElapsedTime((paintElapsedTime != 0L) ? paintElapsedTime : paintStartTime);\n+                        if ((durationNs > 0L) && (frames < MAX_SAMPLE_COUNT)) {\n+                            testTimestamp[frames] = paintStartTime - startTime;\n+                            testTime[frames] = durationNs;\n+                        }\n+                        if (REPORT_OVERALL_FPS) {\n+                            lastFrameTime = System.nanoTime();\n+                        }\n+                        if (TRACE) System.out.print(\"R\");\n+                        frames++;\n+                        paintStartTime = 0L;\n+                        paintElapsedTime = 0L;\n+                        cycles = 0;\n+                        updateMarkerIdx();\n+                        renderable.update();\n+                        fh.repaintFrame();\n+                    } else if (cycles >= MAX_FRAME_CYCLES) {\n+                        if (TRACE) System.out.print(\"M\");\n+                        skippedFrames++;\n+                        paintStartTime = 0L;\n+                        paintElapsedTime = 0L;\n+                        cycles = 0;\n+                        updateMarkerIdx();\n+                        fh.repaintFrame();\n+                    } else {\n+                        if (TRACE) System.out.print(\"-\");\n+                    }\n+                }\n+                final long currentTime = System.nanoTime();\n+                if ((frames >= MIN_COUNT) && (currentTime >= endTime)) {\n+                    break;\n+                }\n+                if ((frames >= COUNT) && (currentTime >= minTime)) {\n+                    break;\n+                }\n+                if (wait) {\n+                    sleep(CYCLE_DELAY);\n+                }\n+                cycles++;\n+            } \/\/ end measurements\n+\n+            \/\/ signal test completed:\n+            completedCount.countDown();\n+            if (TRACE_SYNC) traceSync(name + \" completed => waiting stop signal...\");\n+\n+            \/\/ wait stop signal:\n+            triggerStop.await();\n+            \/\/ Stop Benchmark (all threads):\n+            if (TRACE_SYNC) traceSync(name + \" stopped\");\n+\n+            if (DELAY_TEST) {\n+                sleep(1000);\n+            }\n+            fh.resetFrame();\n+\n+            \/\/ Process results:\n+            if (REPORT_OVERALL_FPS && (lastFrameTime != 0)) {\n+                final double elapsedTime = (lastFrameTime - startTime);\n+                final double elapsedFPS = 1000000000.0 * frames \/ elapsedTime;\n+\n+                System.err.println(frames + \" in \" + (elapsedTime \/ 1000000) + \" ms: ~ \" + elapsedFPS + \" FPS\");\n+            }\n+\n+            processTimes();\n+\n+            if (TRACE) System.out.print(\"<<\\n\");\n+            afterExec();\n+\n+            \/\/ Log header once:\n+            if (headerMark.getAndDecrement() == 1) {\n+                System.err.println(getHeader());\n+            }\n+\n+            \/\/ Log report:\n+            System.err.println(getResults());\n+\n+            \/\/ signal test done:\n+            doneCount.countDown();\n+            if (TRACE_SYNC) traceSync(name + \" done => waiting exit signal...\");\n+\n+            \/\/ wait exit signal:\n+            triggerExit.await();\n+            \/\/ Stop Benchmark (all threads):\n+            if (TRACE_SYNC) traceSync(name + \" exited\");\n+        }\n+\n+        protected abstract void paintPanel(final Renderable renderable, final Graphics g);\n+\n+        protected abstract long getElapsedTime(long paintTime);\n+\n+        protected abstract Color getMarkerColor() throws Exception;\n+\n+        protected boolean isAlmostEqual(Color c1, Color c2) {\n+            return (Math.abs(c1.getRed() - c2.getRed()) < COLOR_TOLERANCE) &&\n+                    (Math.abs(c1.getGreen() - c2.getGreen()) < COLOR_TOLERANCE) &&\n+                    (Math.abs(c1.getBlue() - c2.getBlue()) < COLOR_TOLERANCE);\n+        }\n+\n+        protected void processTimes() {\n+            if (frames != 0) {\n+                frames = Math.min(frames, MAX_SAMPLE_COUNT);\n+\n+                if (DUMP_SAMPLES) {\n+                    \/\/ Dump all results:\n+                    final File file = new File(\".\/rp-\" + replaceNonFileNameChars(name) + \"-samples.csv\");\n+                    System.out.println(\"Writing samples to : \" + file.getAbsolutePath());\n+\n+                    try (final PrintWriter w = new PrintWriter(file, Charset.forName(\"UTF-8\"))) {\n+                        w.write(\"# \");\n+                        w.write(VERSION);\n+                        w.write(\" - \");\n+                        w.write(\"Test: \");\n+                        w.write(name);\n+                        w.write('\\n');\n+\n+                        for (int i = 0; i < frames; i++) {\n+                            w.write(Double.toString(millis(testTimestamp[i])));\n+                            w.write(',');\n+                            w.write(Double.toString(millis(testTime[i])));\n+                            w.write('\\n');\n+                        }\n+                    } catch (IOException ioe) {\n+                        System.err.println(\"IO exception:\");\n+                        ioe.printStackTrace();\n+                    }\n+                }\n+                \/\/ Ignore first 10% (warmup at the beginning):\n+                final int first = (int) Math.floor(frames * 0.10);\n+                final int last = frames - 1;\n+\n+                \/\/ free testTimestamp to avoid any future usage:\n+                testTimestamp = null;\n+\n+                \/\/ note: testTime array is modified below:\n+                \/\/ Sort values to get percentiles:\n+                Arrays.sort(testTime, first, frames);\n+\n+                final long[] pcts = getPercentiles(testTime, first, last);\n+\n+                final long median = pcts[PCT_50];\n+\n+                if (USE_FPS) {\n+                    scores[SCORE_MAIN] = fps(median);\n+\n+                    results[PCT_100] = fps(pcts[PCT_00]);\n+                    results[PCT_90] = fps(pcts[PCT_10]);\n+                    results[PCT_75] = fps(pcts[PCT_25]);\n+                    results[PCT_50] = fps(pcts[PCT_50]);\n+                    results[PCT_25] = fps(pcts[PCT_75]);\n+                    results[PCT_10] = fps(pcts[PCT_90]);\n+                    results[PCT_00] = fps(pcts[PCT_100]);\n+\n+                    \/\/ STDDEV = IQR \/ 1.35 = (Q3 - Q1) * 20 \/ 27\n+                    scores[SCORE_ERROR] = (results[PCT_75] - results[PCT_25]) * 20L \/ 27L;\n+                    scores[SCORE_OTHER] = millis(median);\n+                } else {\n+                    scores[SCORE_MAIN] = millis(median);\n+\n+                    results[PCT_00] = millis(pcts[PCT_00]);\n+                    results[PCT_10] = millis(pcts[PCT_10]);\n+                    results[PCT_25] = millis(pcts[PCT_25]);\n+                    results[PCT_50] = millis(pcts[PCT_50]);\n+                    results[PCT_75] = millis(pcts[PCT_75]);\n+                    results[PCT_90] = millis(pcts[PCT_90]);\n+                    results[PCT_100] = millis(pcts[PCT_100]);\n+\n+                    \/\/ STDDEV = IQR \/ 1.35 = (Q3 - Q1) * 20 \/ 27 (normal distribution ?)\n+                    scores[SCORE_ERROR] = (results[PCT_75] - results[PCT_25]) * 20L \/ 27L;\n+                    scores[SCORE_OTHER] = fps(median);\n+\n+                    \/\/ System.out.println(\"stddev(IQR) = \" + scores[SCORE_ERROR]);\n+\n+                    \/\/ MAD = Median Absolute Deviation:\n+                    for (int i = first; i <= last; i++) {\n+                        testTime[i] = Math.abs(testTime[i] - median);\n+                    }\n+                    \/\/ Sort values to get percentiles:\n+                    Arrays.sort(testTime, first, frames);\n+\n+                    \/\/ STDDEV = 1.4826 * MAD (normal distribution ?)\n+                    scores[SCORE_ERROR] = 1.4826 * millis(testTime[pctIndex(first, last, 0.50)]); \/\/ 50% (median)\n+\n+                    \/\/ System.out.println(\"stddev(MAD) = \" + scores[SCORE_ERROR]);\n+                }\n+                \/\/ free testTime to avoid any future usage:\n+                testTime = null;\n+            }\n+        }\n+\n+        protected static String getHeader() {\n+            if (VERBOSE) {\n+                return String.format(\"%-25s : %s ± %s %s [%s] (p00: ... p10: ... p25: ... p50: ... p75: ... p90: ... p100: ... %s) (... frames)\",\n+                        \"Test Name\", (USE_FPS ? \"Median(FPS)\" : \"Median(TimeMs)\"), (USE_FPS ? \"Stddev(FPS)\" : \"Stddev(TimeMs)\"), \"Unit\",\n+                        (!USE_FPS ? \"Median(FPS)\" : \"Median(TimeMs)\"), \"Unit\");\n+            }\n+            return String.format(\"%-25s : %s ± %s %s\",\n+                    \"Test Name\", (USE_FPS ? \"Median(FPS)\" : \"Median(TimeMs)\"), (USE_FPS ? \"Stddev(FPS)\" : \"Stddev(TimeMs)\"), \"Unit\");\n+\n+        }\n+\n+        protected String getResults() {\n+            if (skippedFrames > 0) {\n+                System.err.println(name + \" : \" + skippedFrames + \" frame(s) skipped\");\n+            }\n+            if (VERBOSE) {\n+                return String.format(\"%-25s : %.3f ± %.3f %s [%.3f %s] (p00: %.3f p10: %.3f p25: %.3f p50: %.3f p75: %.3f p90: %.3f p100: %.3f %s) (%d frames)\",\n+                    name, scores[SCORE_MAIN], scores[SCORE_ERROR], (USE_FPS ? \"FPS\" : \"ms\"),\n+                    scores[SCORE_OTHER], (USE_FPS ? \"ms\" : \"FPS\"),\n+                    results[PCT_00], results[PCT_10], results[PCT_25], results[PCT_50], results[PCT_75], results[PCT_90], results[PCT_100],\n+                    (USE_FPS ? \"FPS\" : \"ms\"),\n+                    frames);\n+            }\n+            return String.format(\"%-25s : %.3f ± %.3f %s\",\n+                     name, scores[SCORE_MAIN], scores[SCORE_ERROR], (USE_FPS ? \"FPS\" : \"ms\"));\n+        }\n+\n+        protected double fps(long timeNs) {\n+            return 1e9 \/ timeNs;\n+        }\n+\n+        protected double millis(long timeNs) {\n+            return 1e-6 * timeNs;\n+        }\n+\n+        protected static long[] getPercentiles(final long[] data, final int first, final int last) {\n+            final long[] pcts = new long[PCT_100 + 1];\n+            pcts[PCT_00] = data[first]; \/\/ 0% (min)\n+            pcts[PCT_10] = data[pctIndex(first, last, 0.10)]; \/\/  10%\n+            pcts[PCT_25] = data[pctIndex(first, last, 0.25)]; \/\/  25% (Q1)\n+            pcts[PCT_50] = data[pctIndex(first, last, 0.50)]; \/\/  50% (Median)\n+            pcts[PCT_75] = data[pctIndex(first, last, 0.75)]; \/\/  75% (Q3)\n+            pcts[PCT_90] = data[pctIndex(first, last, 0.90)]; \/\/  90%\n+            pcts[PCT_100] = data[pctIndex(first, last, 1.00)]; \/\/ 100% (max)\n+            return pcts;\n+        }\n+\n+        protected static int pctIndex(final int min, final int last, final double pct) {\n+            return min + (int) Math.round((last - min) * pct);\n+        }\n+    }\n+\n+    final static class PerfMeterRobot extends PerfMeterExecutor {\n+\n+        private int nRobotTimes = 0;\n+        private long[] robotTime = (fh.calibrate) ? new long[COUNT] : null;\n+\n+        private int nDelayTimes = 0;\n+        private long[] delayTime = (ROBOT_TIME_DELAY) ? null : new long[COUNT];\n+\n+        private long lastPaintTime = 0L;\n+        private int renderedMarkerIdx = -1;\n+\n+        private Robot robot = null;\n+\n+        PerfMeterRobot(final FrameHandler fh) {\n+            super(true, fh);\n+        }\n+\n+        protected void beforeExec() {\n+            try {\n+                robot = new Robot();\n+            } catch (AWTException ae) {\n+                throw new RuntimeException(ae);\n+            }\n+        }\n+\n+        protected void reset() {\n+            super.reset();\n+            nRobotTimes = 0;\n+            nDelayTimes = 0;\n+            lastPaintTime = 0L;\n+            renderedMarkerIdx = -1;\n+        }\n+\n+        protected void paintPanel(final Renderable renderable, final Graphics g) {\n+            final int idx = markerIdx.get();\n+            final long start = System.nanoTime();\n+\n+            final Graphics2D g2d = (Graphics2D) g.create();\n+            try {\n+                paintTest(renderable, g2d, MARKER[idx], false);\n+            } finally {\n+                g2d.dispose();\n+            }\n+\n+            \/\/ Update paintIdx:\n+            paintIdx.incrementAndGet();\n+\n+            \/\/ publish start time:\n+            if (idx != renderedMarkerIdx) {\n+                renderedMarkerIdx = idx;\n+                markerStartTime.set(start);\n+            }\n+        }\n+\n+        protected long getElapsedTime(final long paintTime) {\n+            final long now = System.nanoTime();\n+            long duration = (!ROBOT_TIME_DELAY) ? roundDuration(now - paintTime) : 0L;\n+            if (lastPaintTime != 0L) {\n+                final long delay = roundDuration(now - lastPaintTime);\n+                if (ROBOT_TIME_DELAY) {\n+                    duration = delay;\n+                } else if (nDelayTimes < COUNT) {\n+                    delayTime[nDelayTimes++] = delay;\n+                }\n+            }\n+            lastPaintTime = now;\n+            return duration;\n+        }\n+\n+        private static long roundDuration(final long durationNs) {\n+            return (durationNs <= 0L) ? 0L : (\n+                    (ROBOT_TIME_ROUND) ?\n+                            FRAME_PREC_IN_NANOS * (long) Math.rint(((double) durationNs) \/ FRAME_PREC_IN_NANOS) : durationNs\n+            );\n+        }\n+\n+        protected Color getMarkerColor() {\n+            final Point frameOffset = fh.frame.getLocationOnScreen();\n+            final Insets insets = fh.frame.getInsets();\n+            final int px = frameOffset.x + insets.left + BW \/ 2;\n+            final int py = frameOffset.y + insets.top + BH \/ 2;\n+\n+            final long beforeRobot = (fh.calibrate) ? System.nanoTime() : 0L;\n+\n+            final Color c = robot.getPixelColor(px, py);\n+\n+            if ((fh.calibrate) && (nRobotTimes < COUNT)) {\n+                robotTime[nRobotTimes++] = System.nanoTime() - beforeRobot;\n+            }\n+            return c;\n+        }\n+\n+        protected String getResults() {\n+            if (fh.calibrate && (nRobotTimes != 0)) {\n+                fh.calibrate = false; \/\/ only first time\n+\n+                Arrays.sort(robotTime);\n+\n+                final long[] pcts = getPercentiles(robotTime, 0, nRobotTimes - 1);\n+\n+                \/\/ free testTime to avoid any future usage:\n+                testTime = null;\n+\n+                System.err.printf(\"%-25s : %.3f ms (p00: %.3f p10: %.3f p25: %.3f p50: %.3f p75: %.3f p90: %.3f p100: %.3f ms) (%d times)%n\",\n+                        \"Robot\" + (isMultiThreads() ? (\"-\" + fh.threadId) : \"\"), millis(pcts[PCT_50]),\n+                        millis(pcts[PCT_00]), millis(pcts[PCT_10]), millis(pcts[PCT_25]), millis(pcts[PCT_50]),\n+                        millis(pcts[PCT_75]), millis(pcts[PCT_90]), millis(pcts[PCT_100]), nRobotTimes);\n+            }\n+            if (nDelayTimes != 0) {\n+                Arrays.sort(delayTime);\n+\n+                final long[] pcts = getPercentiles(robotTime, 0, nDelayTimes - 1);\n+\n+                \/\/ free delayTime to avoid any future usage:\n+                delayTime = null;\n+\n+                System.err.printf(\"%-25s : %.3f ms [%.3f FPS] (p00: %.3f p10: %.3f p25: %.3f p50: %.3f p75: %.3f p90: %.3f p100: %.3f ms) (%d times)%n\",\n+                        \"DelayTime-\" + name + (isMultiThreads() ? (\"-\" + fh.threadId) : \"\"), millis(pcts[PCT_50]), fps(pcts[PCT_50]),\n+                        millis(pcts[PCT_00]), millis(pcts[PCT_10]), millis(pcts[PCT_25]), millis(pcts[PCT_50]),\n+                        millis(pcts[PCT_75]), millis(pcts[PCT_90]), millis(pcts[PCT_100]), nDelayTimes);\n+            }\n+            return super.getResults();\n+        }\n+    }\n+\n+    final static class PerfMeterImageProvider extends PerfMeterExecutor {\n+        private final ImageProvider imageProvider;\n+\n+        PerfMeterImageProvider(final FrameHandler fh) {\n+            super(false, fh);\n+            this.imageProvider = fh.imageProvider;\n+        }\n+\n+        protected void beforeExec() {\n+            imageProvider.create(fh.frame.getGraphicsConfiguration(), IMAGE_W, IMAGE_H);\n+        }\n+\n+        protected void afterExec() {\n+            imageProvider.reset();\n+        }\n+\n+        protected void paintPanel(final Renderable renderable, final Graphics g) {\n+            \/\/ suppose image provider is ready yet\n+            final int idx = markerIdx.get();\n+            long start = System.nanoTime();\n+\n+            \/\/ Get Graphics from image provider:\n+            final Graphics2D g2d = imageProvider.createGraphics();\n+            try {\n+                paintTest(renderable, g2d, MARKER[idx], true);\n+            } finally {\n+                g2d.dispose();\n+            }\n+\n+            final long now = System.nanoTime();\n+\n+            \/\/ Update paintIdx:\n+            paintIdx.incrementAndGet();\n+\n+            \/\/ publish start time:\n+            markerStartTime.set(start);\n+            \/\/ publish elapsed time:\n+            markerPaintTime.set(now - start);\n+\n+            \/\/ Draw image on screen:\n+            g.drawImage(imageProvider.getImage(), 0, 0, null);\n+        }\n+\n+        protected long getElapsedTime(long paintTime) {\n+            return paintTime;\n+        }\n+\n+        protected Color getMarkerColor() {\n+            final int px = BW \/ 2;\n+            final int py = BH \/ 2;\n+\n+            return new Color(imageProvider.getSnapshot().getRGB(px, py));\n+        }\n+    }\n+\n+    private final static class ImageProvider {\n+        private final static int TRANSPARENCY = Transparency.TRANSLUCENT;\n+\n+        private final boolean useVolatile;\n+        private Image image = null;\n+\n+        private ImageProvider(boolean useVolatile) {\n+            this.useVolatile = useVolatile;\n+        }\n+\n+        void create(GraphicsConfiguration gc, int width, int height) {\n+            this.image = (useVolatile) ? gc.createCompatibleVolatileImage(width, height, TRANSPARENCY)\n+                    : gc.createCompatibleImage(width, height, TRANSPARENCY);\n+        }\n+\n+        public void reset() {\n+            image = null;\n+        }\n+\n+        public Image getImage() {\n+            return image;\n+        }\n+\n+        public Graphics2D createGraphics() {\n+            return (useVolatile) ? ((VolatileImage) image).createGraphics()\n+                    : ((BufferedImage) image).createGraphics();\n+        }\n+\n+        public BufferedImage getSnapshot() {\n+            return (useVolatile) ? ((VolatileImage) image).getSnapshot()\n+                    : (BufferedImage) image;\n+        }\n+    }\n+\n+    private final FrameHandler fh;\n+\n+    private final Particles balls = new Particles(N, R, BW, BH, WIDTH, HEIGHT);\n+\n+    private final ParticleRenderer calibRenderer = new CalibrationParticleRenderer();\n+    private final ParticleRenderer flatRenderer = new FlatParticleRenderer(N, R);\n+    private final ParticleRenderer clipFlatRenderer = new ClipFlatParticleRenderer(N, R);\n+    private final ParticleRenderer flatOvalRotRenderer = new FlatOvalRotParticleRenderer(N, R);\n+    private final ParticleRenderer flatBoxRenderer = new FlatBoxParticleRenderer(N, R);\n+    private final ParticleRenderer clipFlatBoxParticleRenderer = new ClipFlatBoxParticleRenderer(N, R);\n+    private final ParticleRenderer flatBoxRotRenderer = new FlatBoxRotParticleRenderer(N, R);\n+    private final ParticleRenderer linGradOvalRotRenderer = new LinGradOvalRotParticleRenderer(N, R);\n+    private final ParticleRenderer linGrad3OvalRotRenderer = new LinGrad3OvalRotParticleRenderer(N, R);\n+    private final ParticleRenderer radGrad3OvalRotRenderer = new RadGrad3OvalRotParticleRenderer(N, R);\n+    private final ParticleRenderer wiredRenderer = new WiredParticleRenderer(N, R);\n+    private final ParticleRenderer wiredBoxRenderer = new WiredBoxParticleRenderer(N, R);\n+    private final ParticleRenderer segRenderer = new SegParticleRenderer(N, R);\n+    private final ParticleRenderer flatQuadRenderer = new FlatQuadParticleRenderer(N, R);\n+    private final ParticleRenderer wiredQuadRenderer = new WiredQuadParticleRenderer(N, R);\n+    private final ParticleRenderer imgRenderer = new ImgParticleRenderer(N, R);\n+    private final ParticleRenderer volImgRenderer = new VolImgParticleRenderer(N, R);\n+    private final ParticleRenderer textRenderer = new TextParticleRenderer(N, R);\n+    private final ParticleRenderer largeTextRenderer = new LargeTextParticleRenderer(N, R);\n+    private final ParticleRenderer whiteTextRenderer = new WhiteTextParticleRenderer(R);\n+    private final ParticleRenderer argbSwBlitImageRenderer = new SwBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_ARGB);\n+    private final ParticleRenderer bgrSwBlitImageRenderer = new SwBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_BGR);\n+    private final ParticleRenderer argbSurfaceBlitImageRenderer = new SurfaceBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_ARGB);\n+    private final ParticleRenderer bgrSurfaceBlitImageRenderer = new SurfaceBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_BGR);\n+\n+    private final ParticleRenderer textWiredQuadBatchedRenderer = new BatchedParticleRenderer(textRenderer, wiredQuadRenderer);\n+    private final ParticleRenderer textWiredQuadMixedRenderer = new MixedParticleRenderer(textRenderer, wiredQuadRenderer);\n+\n+    private final ParticleRenderer volImgFlatBoxBatchedRenderer = new BatchedParticleRenderer(volImgRenderer, flatBoxRenderer);\n+    private final ParticleRenderer volImgFlatBoxMixedRenderer = new MixedParticleRenderer(volImgRenderer, flatBoxRenderer);\n+\n+    private final ParticleRenderer volImgWiredQuadBatchedRenderer = new BatchedParticleRenderer(volImgRenderer, wiredQuadRenderer);\n+    private final ParticleRenderer volImgWiredQuadMixedRenderer = new MixedParticleRenderer(volImgRenderer, wiredQuadRenderer);\n+\n+    private final ParticleRenderer volImgTextBatchedRenderer = new BatchedParticleRenderer(volImgRenderer, textRenderer);\n+    private final ParticleRenderer volImgTextMixedRenderer = new MixedParticleRenderer(volImgRenderer, textRenderer);\n+\n+    private final static Configurable AA = new ConfigurableAA();\n+    private final static Configurable TextAA = new ConfigurableTextAA();\n+    private final static Configurable TextLCD = new ConfigurableTextLCD();\n+    private final static Configurable XORMode = new ConfigurableXORMode();\n+    private final static Configurable XORModeLCDText = new ConfigurableXORModeTextLCD();\n+\n+    RenderPerfTest(final GraphicsConfiguration gc) {\n+        fh = new FrameHandler(gc);\n+    }\n+\n+    ParticleRenderable createPR(final ParticleRenderer renderer) {\n+        return new ParticleRenderable(balls, renderer);\n+    }\n+\n+    PerfMeter createPerfMeter(final String name) {\n+        return new PerfMeter(fh, name);\n+    }\n+\n+    public void testCalibration() throws Exception {\n+        createPerfMeter(testName).exec(createPR(calibRenderer));\n+    }\n+\n+    public void testFlatOval() throws Exception {\n+        createPerfMeter(testName).exec(createPR(flatRenderer));\n+    }\n+\n+    public void testFlatOvalAA() throws Exception {\n+        createPerfMeter(testName).exec(createPR(flatRenderer).configure(AA));\n+    }\n+\n+    public void testClipFlatOval() throws Exception {\n+        createPerfMeter(testName).exec(createPR(clipFlatRenderer));\n+    }\n+\n+    public void testClipFlatOvalAA() throws Exception {\n+        createPerfMeter(testName).exec(createPR(clipFlatRenderer).configure(AA));\n+    }\n+\n+    public void testFlatBox() throws Exception {\n+        createPerfMeter(testName).exec(createPR(flatBoxRenderer));\n+    }\n+\n+    public void testFlatBoxAA() throws Exception {\n+        createPerfMeter(testName).exec(createPR(flatBoxRenderer).configure(AA));\n+    }\n+\n+    public void testClipFlatBox() throws Exception {\n+        createPerfMeter(testName).exec(createPR(clipFlatBoxParticleRenderer));\n+    }\n+\n+    public void testClipFlatBoxAA() throws Exception {\n+        createPerfMeter(testName).exec(createPR(clipFlatBoxParticleRenderer).configure(AA));\n+    }\n+\n+    public void testImage() throws Exception {\n+        createPerfMeter(testName).exec(createPR(imgRenderer));\n+    }\n+\n+    public void testImageAA() throws Exception {\n+        createPerfMeter(testName).exec(createPR(imgRenderer).configure(AA));\n+    }\n+\n+    public void testVolImage() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgRenderer));\n+    }\n+\n+    public void testVolImageAA() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgRenderer).configure(AA));\n+    }\n+\n+    public void testRotatedBox() throws Exception {\n+        createPerfMeter(testName).exec(createPR(flatBoxRotRenderer));\n+    }\n+\n+    public void testRotatedBoxAA() throws Exception {\n+        createPerfMeter(testName).exec(createPR(flatBoxRotRenderer).configure(AA));\n+    }\n+\n+    public void testRotatedOval() throws Exception {\n+        createPerfMeter(testName).exec(createPR(flatOvalRotRenderer));\n+    }\n+\n+    public void testRotatedOvalAA() throws Exception {\n+        createPerfMeter(testName).exec(createPR(flatOvalRotRenderer).configure(AA));\n+    }\n+\n+    public void testLinGrad3RotatedOval() throws Exception {\n+        createPerfMeter(testName).exec(createPR(linGrad3OvalRotRenderer));\n+    }\n+\n+    public void testLinGrad3RotatedOvalAA() throws Exception {\n+        createPerfMeter(testName).exec(createPR(linGrad3OvalRotRenderer).configure(AA));\n+    }\n+\n+    public void testRadGrad3RotatedOval() throws Exception {\n+        createPerfMeter(testName).exec(createPR(radGrad3OvalRotRenderer));\n+    }\n+\n+    public void testRadGrad3RotatedOvalAA() throws Exception {\n+        createPerfMeter(testName).exec(createPR(radGrad3OvalRotRenderer).configure(AA));\n+    }\n+\n+    public void testLinGradRotatedOval() throws Exception {\n+        createPerfMeter(testName).exec(createPR(linGradOvalRotRenderer));\n+    }\n+\n+    public void testLinGradRotatedOvalAA() throws Exception {\n+        createPerfMeter(testName).exec(createPR(linGradOvalRotRenderer).configure(AA));\n@@ -866,1 +1764,1 @@\n-        (new PerfMeter(\"WiredBubbles\")).exec(createPR(wiredRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(wiredRenderer));\n@@ -870,1 +1768,1 @@\n-        (new PerfMeter(\"WiredBubblesAA\")).exec(createPR(wiredRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(wiredRenderer).configure(AA));\n@@ -874,1 +1772,1 @@\n-        (new PerfMeter(\"WiredBox\")).exec(createPR(wiredBoxRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(wiredBoxRenderer));\n@@ -878,1 +1776,1 @@\n-        (new PerfMeter(\"WiredBoxAA\")).exec(createPR(wiredBoxRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(wiredBoxRenderer).configure(AA));\n@@ -882,1 +1780,1 @@\n-        (new PerfMeter(\"Lines\")).exec(createPR(segRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(segRenderer));\n@@ -886,1 +1784,1 @@\n-        (new PerfMeter(\"LinesAA\")).exec(createPR(segRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(segRenderer).configure(AA));\n@@ -890,1 +1788,1 @@\n-        (new PerfMeter(\"FlatQuad\")).exec(createPR(flatQuadRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(flatQuadRenderer));\n@@ -894,1 +1792,1 @@\n-        (new PerfMeter(\"FlatQuadAA\")).exec(createPR(flatQuadRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(flatQuadRenderer).configure(AA));\n@@ -898,1 +1796,1 @@\n-        (new PerfMeter(\"WiredQuad\")).exec(createPR(wiredQuadRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(wiredQuadRenderer));\n@@ -902,1 +1800,1 @@\n-        (new PerfMeter(\"WiredQuadAA\")).exec(createPR(wiredQuadRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(wiredQuadRenderer).configure(AA));\n@@ -906,1 +1804,1 @@\n-        (new PerfMeter(\"TextNoAA\")).exec(createPR(textRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(textRenderer));\n@@ -910,1 +1808,1 @@\n-        (new PerfMeter(\"TextLCD\")).exec(createPR(textRenderer).configure(TextLCD)).report();\n+        createPerfMeter(testName).exec(createPR(textRenderer).configure(TextLCD));\n@@ -914,1 +1812,1 @@\n-        (new PerfMeter(\"TextGray\")).exec(createPR(textRenderer).configure(TextAA)).report();\n+        createPerfMeter(testName).exec(createPR(textRenderer).configure(TextAA));\n@@ -918,1 +1816,1 @@\n-        (new PerfMeter(\"LargeTextNoAA\")).exec(createPR(largeTextRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(largeTextRenderer));\n@@ -922,1 +1820,1 @@\n-        (new PerfMeter(\"LargeTextLCD\")).exec(createPR(largeTextRenderer).configure(TextLCD)).report();\n+        createPerfMeter(testName).exec(createPR(largeTextRenderer).configure(TextLCD));\n@@ -926,1 +1824,1 @@\n-        (new PerfMeter(\"LargeTextGray\")).exec(createPR(largeTextRenderer).configure(TextAA)).report();\n+        createPerfMeter(testName).exec(createPR(largeTextRenderer).configure(TextAA));\n@@ -928,0 +1826,1 @@\n+\n@@ -929,1 +1828,1 @@\n-        (new PerfMeter(\"WhiteTextNoAA\")).exec(createPR(whiteTextRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(whiteTextRenderer));\n@@ -933,1 +1832,1 @@\n-        (new PerfMeter(\"WhiteTextLCD\")).exec(createPR(whiteTextRenderer).configure(TextLCD)).report();\n+        createPerfMeter(testName).exec(createPR(whiteTextRenderer).configure(TextLCD));\n@@ -937,1 +1836,1 @@\n-        (new PerfMeter(\"WhiteTextGray\")).exec(createPR(whiteTextRenderer).configure(TextAA)).report();\n+        createPerfMeter(testName).exec(createPR(whiteTextRenderer).configure(TextAA));\n@@ -941,1 +1840,1 @@\n-        (new PerfMeter(\"ArgbSwBlitImage\")).exec(createPR(argbSwBlitImageRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(argbSwBlitImageRenderer));\n@@ -945,1 +1844,1 @@\n-        (new PerfMeter(\"BgrSwBlitImage\")).exec(createPR(bgrSwBlitImageRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(bgrSwBlitImageRenderer));\n@@ -949,1 +1848,1 @@\n-        (new PerfMeter(\"ArgbSurfaceBlitImageRenderer\")).exec(createPR(argbSurfaceBlitImageRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(argbSurfaceBlitImageRenderer));\n@@ -953,1 +1852,1 @@\n-        (new PerfMeter(\"BgrSurfaceBlitImage\")).exec(createPR(bgrSurfaceBlitImageRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(bgrSurfaceBlitImageRenderer));\n@@ -956,0 +1855,1 @@\n+    \/\/ XOR mode:\n@@ -957,1 +1857,1 @@\n-        (new PerfMeter(\"FlatOval_XOR\")).exec(createPR(flatRenderer).configure(XORMode)).report();\n+        createPerfMeter(testName).exec(createPR(flatRenderer).configure(XORMode));\n@@ -961,1 +1861,1 @@\n-        (new PerfMeter(\"RotatedBox_XOR\")).exec(createPR(flatBoxRotRenderer).configure(XORMode)).report();\n+        createPerfMeter(testName).exec(createPR(flatBoxRotRenderer).configure(XORMode));\n@@ -965,1 +1865,1 @@\n-        (new PerfMeter(\"Lines_XOR\")).exec(createPR(segRenderer).configure(XORMode)).report();\n+        createPerfMeter(testName).exec(createPR(segRenderer).configure(XORMode));\n@@ -969,1 +1869,1 @@\n-        (new PerfMeter(\"Image_XOR\")).exec(createPR(imgRenderer).configure(XORMode)).report();\n+        createPerfMeter(testName).exec(createPR(imgRenderer).configure(XORMode));\n@@ -973,1 +1873,1 @@\n-        (new PerfMeter(\"TextNoAA_XOR\")).exec(createPR(textRenderer).configure(XORMode)).report();\n+        createPerfMeter(testName).exec(createPR(textRenderer).configure(XORMode));\n@@ -977,1 +1877,113 @@\n-        (new PerfMeter(\"TextLCD_XOR\")).exec(createPR(textRenderer).configure(XORModeLCDText)).report();\n+        createPerfMeter(testName).exec(createPR(textRenderer).configure(XORModeLCDText));\n+    }\n+\n+    \/\/ Mixed\/Batched mode:\n+    public void testTextWiredQuadBat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(textWiredQuadBatchedRenderer));\n+    }\n+\n+    public void testTextWiredQuadMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(textWiredQuadMixedRenderer));\n+    }\n+\n+    public void testTextWiredQuadAABat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(textWiredQuadBatchedRenderer).configure(AA));\n+    }\n+\n+    public void testTextWiredQuadAAMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(textWiredQuadMixedRenderer).configure(AA));\n+    }\n+\n+    public void testVolImageFlatBoxBat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgFlatBoxBatchedRenderer));\n+    }\n+\n+    public void testVolImageFlatBoxMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgFlatBoxMixedRenderer));\n+    }\n+\n+    public void testVolImageFlatBoxAABat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgFlatBoxBatchedRenderer).configure(AA));\n+    }\n+\n+    public void testVolImageFlatBoxAAMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgFlatBoxMixedRenderer).configure(AA));\n+    }\n+\n+    public void testVolImageWiredQuadBat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgWiredQuadBatchedRenderer));\n+    }\n+\n+    public void testVolImageWiredQuadMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgWiredQuadMixedRenderer));\n+    }\n+\n+    public void testVolImageWiredQuadAABat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgWiredQuadBatchedRenderer).configure(AA));\n+    }\n+\n+    public void testVolImageWiredQuadAAMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgWiredQuadMixedRenderer).configure(AA));\n+    }\n+\n+    public void testVolImageTextNoAABat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgTextBatchedRenderer));\n+    }\n+\n+    public void testVolImageTextNoAAMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgTextMixedRenderer));\n+    }\n+\n+    private static void help() {\n+        System.out.print(\"##############################################################\\n\");\n+        System.out.printf(\"# %s\\n\", VERSION);\n+        System.out.print(\"##############################################################\\n\");\n+        System.out.println(\"# java ... RenderPerfTest <args> <tests>\");\n+        System.out.println(\"#\");\n+        System.out.println(\"# Supported arguments <args>:\");\n+        System.out.println(\"# -h                        : display this help\");\n+        System.out.println(\"# -v                        : set verbose output\");\n+        System.out.println(\"#\");\n+        System.out.println(\"# -e=<mode>                  : set the execution mode (default: \" + EXEC_MODE_DEFAULT\n+                                + \") among \" + EXEC_MODES);\n+        System.out.println(\"#\");\n+        System.out.println(\"# -f                        : use FPS unit (default)\");\n+        System.out.println(\"# -t                        : use TIME(ms) unit\");\n+        System.out.println(\"#\");\n+        System.out.println(\"# -g=all|\\\"0-0,0-1...\\\"       : use 'all' or specific graphics configurations\");\n+        System.out.println(\"#\");\n+        System.out.println(\"# -font=\\\"<name>\\\"            : set the font name used by all text renderers\");\n+        System.out.println(\"# -fontSize=<number>        : set the font size used by Text renderers\");\n+        System.out.println(\"# -fontSizeLarge=<number>   : set the font size used by LargeText renderers\");\n+        System.out.println(\"# -text=\\\"<string>\\\"          : set the text drawn by all text renderers\");\n+        System.out.println(\"#\");\n+        System.out.println(\"# -lf                       : list available font names\");\n+        System.out.println(\"# -lg                       : list available graphics configurations\");\n+        System.out.println(\"#\");\n+        System.out.println(\"# -n=<number>               : set number of primitives (default: \" + N_DEFAULT + \")\");\n+        System.out.println(\"# -r=<number>               : set number of test repeats (default: 1)\");\n+        System.out.println(\"#\");\n+        System.out.println(\"#\");\n+        System.out.println(\"# -w=<number>               : use number of test frames (default: 1) per screen\");\n+        System.out.println(\"#\");\n+        System.out.println(\"# -u=<number>               : set number of warmup iterations (default: \" + MIN_COUNT + \")\");\n+        System.out.println(\"#\");\n+\n+        System.out.print(\"# Supported test arguments <tests>:\");\n+\n+        final ArrayList<Method> testCases = new ArrayList<>();\n+        for (Method m : RenderPerfTest.class.getDeclaredMethods()) {\n+            if (m.getName().startsWith(\"test\") && !ignoredTests.contains(m.getName())) {\n+                testCases.add(m);\n+            }\n+        }\n+        testCases.sort(Comparator.comparing(Method::getName));\n+        for (Method m : testCases) {\n+            System.out.print(extractTestName(m));\n+            System.out.print(\" \");\n+        }\n+        System.out.println();\n+    }\n+\n+    private static String extractTestName(final Method m) {\n+        return m.getName().substring(\"test\".length());\n@@ -981,12 +1993,95 @@\n-            throws InvocationTargetException, IllegalAccessException, NoSuchMethodException\n-    {\n-        RenderPerfTest test = new RenderPerfTest();\n-\n-        if (args.length > 0) {\n-            for (String testCase : args) {\n-                Method m = RenderPerfTest.class.getDeclaredMethod(\"test\" + testCase);\n-                m.invoke(test);\n-            }\n-        } else {\n-            Method[] methods = RenderPerfTest.class.getDeclaredMethods();\n-            for (Method m : methods) {\n+            throws NoSuchMethodException, NumberFormatException {\n+        \/\/ Set the default locale to en-US locale (for Numerical Fields \".\" \",\")\n+        Locale.setDefault(Locale.US);\n+\n+        boolean help = false;\n+        final ArrayList<Method> testCases = new ArrayList<>();\n+\n+        for (String arg : args) {\n+            if (arg.length() >= 2) {\n+                if (arg.startsWith(\"-\")) {\n+                    switch (arg.substring(1, 2)) {\n+                        case \"e\":\n+                            if (arg.length() >= 3) {\n+                                EXEC_MODE = arg.substring(3).toLowerCase();\n+                            }\n+                            break;\n+                        case \"f\":\n+                            if (arg.length() == 2) {\n+                                USE_FPS = true;\n+                            } else {\n+                                if ((arg.length() > 6) && \"font=\".equalsIgnoreCase(arg.substring(1, 6))) {\n+                                    TEXT_FONT = arg.substring(6);\n+                                    break;\n+                                }\n+                                if ((arg.length() > 10) && \"fontSize=\".equalsIgnoreCase(arg.substring(1, 10))) {\n+                                    TEXT_SIZE_DEFAULT = Integer.parseInt(arg.substring(10));\n+                                    break;\n+                                }\n+                                if ((arg.length() > 15) && \"fontSizeLarge=\".equalsIgnoreCase(arg.substring(1, 15))) {\n+                                    TEXT_SIZE_LARGE = Integer.parseInt(arg.substring(15));\n+                                    break;\n+                                }\n+                            }\n+                            break;\n+                        case \"g\":\n+                            if (arg.length() >= 3) {\n+                                GC_MODE = arg.substring(3).toLowerCase();\n+                            }\n+                            break;\n+                        case \"h\":\n+                            help = true;\n+                            break;\n+                        case \"l\":\n+                            if (arg.length() == 3) {\n+                                if (\"f\".equalsIgnoreCase(arg.substring(2, 3))) {\n+                                    VERBOSE_FONT_CONFIG = true;\n+                                } else if (\"g\".equalsIgnoreCase(arg.substring(2, 3))) {\n+                                    VERBOSE_GRAPHICS_CONFIG = true;\n+                                }\n+                            }\n+                            break;\n+                        case \"t\":\n+                            if (arg.length() == 2) {\n+                                USE_FPS = false;\n+                            } else {\n+                                if ((arg.length() > 6) && \"text=\".equalsIgnoreCase(arg.substring(1, 6))) {\n+                                    TEXT_STR = arg.substring(6);\n+                                }\n+                            }\n+                            break;\n+                        case \"n\":\n+                            if (arg.length() >= 3) {\n+                                N = Integer.parseInt(arg.substring(3));\n+                            }\n+                            break;\n+                        case \"r\":\n+                            if (arg.length() >= 3) {\n+                                REPEATS = Integer.parseInt(arg.substring(3));\n+                            }\n+                            break;\n+                        case \"v\":\n+                            VERBOSE = true;\n+                            break;\n+                        case \"w\":\n+                            if (arg.length() >= 3) {\n+                                NW = Integer.parseInt(arg.substring(3));\n+                            }\n+                            break;\n+                        case \"u\":\n+                            if (arg.length() >= 3) {\n+                                WARMUP_COUNT = Integer.parseInt(arg.substring(3));\n+                            }\n+                            break;\n+                        default:\n+                            System.err.println(\"Unsupported argument '\" + arg + \"' !\");\n+                            help = true;\n+                    }\n+                } else {\n+                    Method m = RenderPerfTest.class.getDeclaredMethod(\"test\" + arg);\n+                    testCases.add(m);\n+                }\n+            }\n+        }\n+        if (testCases.isEmpty()) {\n+            for (Method m : RenderPerfTest.class.getDeclaredMethods()) {\n@@ -994,1 +2089,1 @@\n-                    m.invoke(test);\n+                    testCases.add(m);\n@@ -997,0 +2092,52 @@\n+            testCases.sort(Comparator.comparing(Method::getName));\n+        }\n+\n+        if (help) {\n+            help();\n+        }\n+\n+        if (CALIBRATION) {\n+            Method m = RenderPerfTest.class.getDeclaredMethod(\"testCalibration\");\n+            testCases.add(0, m); \/\/ first\n+        }\n+\n+        if (VERBOSE) {\n+            System.out.print(\"##############################################################\\n\");\n+            System.out.printf(\"# %s\\n\", VERSION);\n+            System.out.print(\"##############################################################\\n\");\n+            System.out.printf(\"# Java: %s\\n\", System.getProperty(\"java.runtime.version\"));\n+            System.out.printf(\"#   VM: %s %s (%s)\\n\", System.getProperty(\"java.vm.name\"), System.getProperty(\"java.vm.version\"), System.getProperty(\"java.vm.info\"));\n+            System.out.printf(\"#   OS: %s %s (%s)\\n\", System.getProperty(\"os.name\"), System.getProperty(\"os.version\"), System.getProperty(\"os.arch\"));\n+            System.out.printf(\"# CPUs: %d (virtual)\\n\", Runtime.getRuntime().availableProcessors());\n+            System.out.print(\"##############################################################\\n\");\n+            System.out.printf(\"# AWT Toolkit:                %s \\n\", TOOLKIT.getClass().getSimpleName());\n+            System.out.printf(\"# Execution mode:             %s\\n\", EXEC_MODE);\n+            System.out.printf(\"# GraphicsConfiguration mode: %s\\n\", GC_MODE);\n+            System.out.print(\"##############################################################\\n\");\n+            System.out.printf(\"# Repeats:                    %d\\n\", REPEATS);\n+            System.out.printf(\"# NW:                         %d\\n\", NW);\n+            System.out.printf(\"# N:                          %d\\n\", N);\n+            System.out.printf(\"# WARMUP_COUNT:               %d\\n\", WARMUP_COUNT);\n+            System.out.printf(\"# Unit:                       %s\\n\", USE_FPS ? \"FPS\" : \"TIME(ms)\");\n+            System.out.print(\"##############################################################\\n\");\n+            System.out.printf(\"# Font:                      '%s'\\n\", TEXT_FONT);\n+            System.out.printf(\"# Text: '%s'\\n\", TEXT_STR);\n+            System.out.printf(\"# FontSize:                   %s\\n\", TEXT_SIZE_DEFAULT);\n+            System.out.printf(\"# FontSizeLarge:              %s\\n\", TEXT_SIZE_LARGE);\n+            System.out.print(\"##############################################################\\n\");\n+        }\n+\n+        \/\/ Graphics Configuration handling:\n+        final Set<String> fontNames = new LinkedHashSet<>();\n+        final Map<String, GraphicsConfiguration> gcByID = new LinkedHashMap<>();\n+        final Map<GraphicsConfiguration, String> idByGC = new HashMap<>();\n+\n+        final GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+\n+        for (String name : ge.getAvailableFontFamilyNames()) {\n+            fontNames.add(name);\n+        }\n+        \/\/ Check font:\n+        if (!fontNames.contains(TEXT_FONT)) {\n+            System.err.println(\"Bad font name: [\" + TEXT_FONT + \"] !\");\n+            VERBOSE_FONT_CONFIG = true;\n@@ -998,0 +2145,268 @@\n+\n+        if (VERBOSE_FONT_CONFIG) {\n+            System.out.print(\"# Available font names: \");\n+\n+            for (String name : fontNames) {\n+                System.out.print(\"'\");\n+                System.out.print(name);\n+                System.out.print(\"' \");\n+            }\n+            System.out.println();\n+        }\n+\n+        final GraphicsDevice[] gds = ge.getScreenDevices();\n+\n+        if (VERBOSE_GRAPHICS_CONFIG) {\n+            System.out.println(\"# Available GraphicsDevice(s) and their GraphicsConfiguration(s):\");\n+        }\n+\n+        for (int gdIdx = 0; gdIdx < gds.length; gdIdx++) {\n+            final GraphicsDevice gd = gds[gdIdx];\n+            if (VERBOSE_GRAPHICS_CONFIG) {\n+                System.out.println(\"# [\" + gdIdx + \"] = GraphicsDevice[\" + gd.getIDstring() + \"]\");\n+            }\n+\n+            final GraphicsConfiguration[] gcs = gd.getConfigurations();\n+\n+            for (int gcIdx = 0; gcIdx < gcs.length; gcIdx++) {\n+                final GraphicsConfiguration gc = gcs[gcIdx];\n+                final String gcId = gdIdx + \"-\" + gcIdx;\n+                gcByID.put(gcId, gc);\n+                idByGC.put(gc, gcId);\n+                if (VERBOSE_GRAPHICS_CONFIG) {\n+                    System.out.println(\"# - [\" + gcId + \"] = GraphicsConfiguration[\" + gc + \"] bounds:\" + gc.getBounds());\n+                }\n+            }\n+        }\n+\n+        final Set<GraphicsConfiguration> gcSet = new LinkedHashSet<>();\n+\n+        if (GC_MODE != null) {\n+            if (!GC_MODE_DEF.equals(GC_MODE)) {\n+                if (GC_MODE_ALL.equals(GC_MODE)) {\n+                    gcSet.addAll(gcByID.values());\n+                } else {\n+                    for (String gcKey : GC_MODE.split(\",\")) {\n+                        final GraphicsConfiguration gc = gcByID.get(gcKey);\n+                        if (gc != null) {\n+                            gcSet.add(gc);\n+                        } else {\n+                            System.err.println(\"Bad GraphicsConfiguration identifier 'x-y' where x is GraphicsDevice ID \" +\n+                                    \"and y GraphicsConfiguration ID : [\" + gcKey + \"] ! (available values: \" + gcByID.keySet() + \")\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        if (gcSet.isEmpty()) {\n+            final GraphicsDevice gdDef = ge.getDefaultScreenDevice();\n+            final GraphicsConfiguration gcDef = gdDef.getDefaultConfiguration();\n+            final String gcId = idByGC.get(gcDef);\n+\n+            if (VERBOSE_GRAPHICS_CONFIG) {\n+                System.out.println(\"# Using default [\" + gcId + \"] = GraphicsConfiguration[\" + gcDef + \"] bounds:\" + gcDef.getBounds());\n+            }\n+            gcSet.add(gcDef);\n+        }\n+\n+        final List<GraphicsConfiguration> gcList = new ArrayList<>(gcSet);\n+        final int NGC = gcList.size();\n+\n+        System.out.print(\"#  Using GraphicsConfiguration(s): \");\n+        for (GraphicsConfiguration gc : gcList) {\n+            final String gcId = idByGC.get(gc);\n+            System.out.print(\"[\" + gcId + \"][\" + gc + \"]\");\n+            System.out.print(\" \");\n+        }\n+        System.out.println();\n+\n+        final List<RenderPerfTest> instances = new ArrayList<>();\n+        int retCode = 0;\n+        try {\n+            if (!help) {\n+                final List<Thread> threads = new ArrayList<>();\n+\n+                for (int i = 0; i < NGC; i++) {\n+                    final GraphicsConfiguration gc = gcList.get(i);\n+\n+                    for (int j = 0; j < NW; j++) {\n+                        final RenderPerfTest rp = new RenderPerfTest(gc);\n+                        instances.add(rp);\n+                        threads.add(rp.createThreadTests(threads.size() + 1, j + 1, testCases));\n+                    }\n+                }\n+                if (TRACE_SYNC) traceSync(\"testCount: \" + testCount);\n+\n+                initThreads(threads.size());\n+                initBarrierStart();\n+\n+                for (Thread thread : threads) {\n+                    if (TRACE_SYNC) traceSync(thread.getName() + \" starting...\");\n+                    thread.start();\n+                }\n+\n+                for (int n = 0; n < testCount; n++) {\n+                    if (VERBOSE) {\n+                        final int k = n \/ REPEATS;\n+                        final String methodName = extractTestName(testCases.get(k));\n+                        System.out.println(\"# --- Test [\" + (n + 1) + \" \/ \" + testCount + \"] = \" + methodName + \" ---\");\n+                    }\n+\n+                    \/\/ reset stop barrier (to be ready):\n+                    initBarrierStop();\n+\n+                    if (TRACE_SYNC) traceSync(\"Waiting \" + threadCount + \" threads to be ready...\");\n+                    readyCount.await();\n+\n+                    if (TRACE_SYNC) traceSync(\"Threads are ready => starting benchmark on \" + threadCount + \" threads now\");\n+                    triggerStart.countDown();\n+\n+                    \/\/ reset done barrier (to be ready):\n+                    initBarrierDone();\n+\n+                    if (TRACE_SYNC) traceSync(\"Waiting \" + threadCount + \" threads to complete benchmark...\");\n+                    completedCount.await();\n+\n+                    if (TRACE_SYNC) traceSync(\"Test completed on \" + threadCount + \" threads => stopping benchmark on all threads now\");\n+                    triggerStop.countDown();\n+\n+                    \/\/ reset start barrier (to be ready):\n+                    initBarrierStart();\n+\n+                    if (TRACE_SYNC) traceSync(\"Waiting \" + threadCount + \" threads to exit test...\");\n+                    doneCount.await();\n+\n+                    if (TRACE_SYNC) traceSync(\"Test exited on \" + threadCount + \" threads => finalize benchmark on all threads now\");\n+                    triggerExit.countDown();\n+                }\n+\n+                for (Thread thread : threads) {\n+                    thread.join();\n+                    if (TRACE_SYNC) traceSync(thread.getName() + \" terminated\");\n+                }\n+            }\n+        } catch (Throwable th) {\n+            System.err.println(\"Exception occurred during :\");\n+            th.printStackTrace(System.err);\n+            retCode = 1;\n+        } finally {\n+            for (RenderPerfTest rp : instances) {\n+                try {\n+                    rp.fh.hideFrameAndWait();\n+                } catch (Throwable th) {\n+                    System.err.println(\"Exception occurred in hideFrameAndWait():\");\n+                    th.printStackTrace(System.err);\n+                    retCode = 1;\n+                }\n+            }\n+            \/\/ ensure jvm immediate shutdown:\n+            System.exit(retCode);\n+        }\n+    }\n+\n+    \/\/ thread synchronization\n+\n+    private static int threadCount = 0;\n+\n+    private static int testCount = 0;\n+    private static volatile String testName = null;\n+\n+    private static volatile CountDownLatch readyCount = null;\n+    private static volatile CountDownLatch triggerStart = null;\n+\n+    private static volatile CountDownLatch completedCount = null;\n+    private static volatile CountDownLatch triggerStop = null;\n+\n+    private static volatile CountDownLatch doneCount = null;\n+    private static volatile CountDownLatch triggerExit = null;\n+\n+    static void traceSync(final String msg) {\n+        System.out.println(\"[\" + System.nanoTime() + \"] \" + msg);\n+    }\n+\n+    private static void initThreads(int count) {\n+        threadCount = count;\n+        if (TRACE_SYNC) traceSync(\"initThreads(): threadCount: \" + threadCount);\n+    }\n+\n+    static boolean isMultiThreads() {\n+        return threadCount > 1;\n+    }\n+\n+    private static void initBarrierStart() {\n+        readyCount = new CountDownLatch(threadCount);\n+        triggerStart = new CountDownLatch(1);\n+    }\n+\n+    private static void initBarrierStop() {\n+        completedCount = new CountDownLatch(threadCount);\n+        triggerStop = new CountDownLatch(1);\n+    }\n+\n+    private static void initBarrierDone() {\n+        doneCount = new CountDownLatch(threadCount);\n+        triggerExit = new CountDownLatch(1);\n+    }\n+\n+    public Thread createThreadTests(final int threadId, final int frameId,\n+                                    final ArrayList<Method> testCases) throws Exception {\n+        fh.setIds(threadId, frameId);\n+\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                fh.prepareFrameEDT(VERSION + \" [\" + fh.threadId + \"]\");\n+\n+                final JLabel label = new JLabel((DELAY_START) ? \"Waiting 3s before starting benchmark...\" : \"Starting benchmark...\");\n+                label.setForeground(Color.WHITE);\n+\n+                final JPanel panel = new JPanel();\n+                panel.add(label);\n+\n+                fh.showFrameEDT(panel);\n+            }\n+        });\n+\n+        \/\/ Wait frame to be shown:\n+        fh.waitFrameShown();\n+\n+        \/\/ Set test count per thread:\n+        testCount = testCases.size() * REPEATS;\n+\n+        final RenderPerfTest rp = this;\n+        return new Thread(\"RenderPerfThread[\" + threadId + \"]\") {\n+            @Override\n+            public void run() {\n+                if (DELAY_START) {\n+                    RenderPerfTest.sleep(3000);\n+                }\n+                try {\n+                    for (Method m : testCases) {\n+                        for (int i = 0; i < REPEATS; i++) {\n+                            testName = extractTestName(m);\n+                            m.invoke(rp);\n+                        }\n+                    }\n+                } catch (Throwable th) {\n+                    System.err.println(\"Exception occurred in RenderPerfThread[\" + threadId + \"]:\");\n+                    th.printStackTrace(System.err);\n+                }\n+            }\n+        };\n+    }\n+\n+    private static void sleep(final long millis) {\n+        if (millis > 0) {\n+            try {\n+                Thread.sleep(millis);\n+            } catch (InterruptedException ie) {\n+                ie.printStackTrace(System.err);\n+            }\n+        }\n+    }\n+\n+    \/** regular expression used to match characters different than alpha\/numeric\/_\/-\/. (1..n) *\/\n+    private final static Pattern PATTERN_NON_FILE_NAME = Pattern.compile(\"[^a-zA-Z0-9\\\\-_\\\\.]\");\n+\n+    private static String replaceNonFileNameChars(final String value) {\n+        return PATTERN_NON_FILE_NAME.matcher(value).replaceAll(\"_\");\n","filename":"test\/jdk\/performance\/client\/RenderPerfTest\/src\/renderperf\/RenderPerfTest.java","additions":1776,"deletions":361,"binary":false,"changes":2137,"status":"modified"}]}