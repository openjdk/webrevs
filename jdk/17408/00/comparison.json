{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2022, JetBrains s.r.o.. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, JetBrains s.r.o.. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.awt.AWTException;\n@@ -29,0 +30,1 @@\n+import java.awt.Composite;\n@@ -33,0 +35,3 @@\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n@@ -34,0 +39,1 @@\n+import java.awt.Insets;\n@@ -35,0 +41,1 @@\n+import java.awt.Point;\n@@ -36,0 +43,1 @@\n+import java.awt.Rectangle;\n@@ -38,0 +46,2 @@\n+import java.awt.Toolkit;\n+import java.awt.Transparency;\n@@ -39,0 +49,2 @@\n+import java.awt.event.ComponentAdapter;\n+import java.awt.event.ComponentEvent;\n@@ -41,0 +53,1 @@\n+\n@@ -51,0 +64,1 @@\n+import java.awt.image.VolatileImage;\n@@ -53,1 +67,0 @@\n-import java.lang.reflect.InvocationTargetException;\n@@ -55,0 +68,5 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n@@ -56,0 +74,5 @@\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n@@ -57,1 +80,1 @@\n-import java.util.concurrent.CountDownLatch;\n+import java.util.Set;\n@@ -59,0 +82,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -61,0 +85,2 @@\n+import java.util.function.IntBinaryOperator;\n+\n@@ -63,0 +89,1 @@\n+import javax.swing.JLabel;\n@@ -67,2 +94,5 @@\n-public class RenderPerfTest {\n-    private static HashSet<String> ignoredTests = new HashSet<>();\n+\n+public final class RenderPerfTest {\n+\n+    private final static String VERSION = \"Render_Perf_Test 2023.12\";\n+    private static final HashSet<String> ignoredTests = new HashSet<>();\n@@ -71,2 +101,3 @@\n-       \/\/ add ignored tests here\n-       \/\/ ignoredTests.add(\"testMyIgnoredTest\");\n+        \/\/ add ignored tests here\n+        \/\/ ignoredTests.add(\"testMyIgnoredTest\");\n+        ignoredTests.add(\"testCalibration\"); \/\/ not from command line\n@@ -75,1 +106,40 @@\n-    private final static int N = 1000;\n+    private final static String EXEC_MODE_ROBOT = \"robot\";\n+    private final static String EXEC_MODE_BUFFER = \"buffer\";\n+    private final static String EXEC_MODE_VOLATILE = \"volatile\";\n+    private final static String EXEC_MODE_DEFAULT = EXEC_MODE_ROBOT;\n+\n+    public final static List<String> EXEC_MODES = Arrays.asList(EXEC_MODE_ROBOT, EXEC_MODE_BUFFER, EXEC_MODE_VOLATILE);\n+\n+    private static String EXEC_MODE = EXEC_MODE_DEFAULT;\n+\n+    private final static String GC_MODE_DEF = \"def\";\n+    private final static String GC_MODE_ALL = \"all\";\n+\n+    private static String GC_MODE = GC_MODE_DEF;\n+\n+    private final static boolean CALIBRATION = \"true\".equalsIgnoreCase(System.getProperty(\"CALIBRATION\", \"false\"));\n+    private final static boolean REPORT_OVERALL_FPS = \"true\".equalsIgnoreCase(System.getProperty(\"REPORT_OVERALL_FPS\", \"false\"));\n+\n+    private final static boolean TRACE = \"true\".equalsIgnoreCase(System.getProperty(\"TRACE\", \"false\"));\n+    private final static boolean TRACE_CONFIGURE = \"true\".equalsIgnoreCase(System.getProperty(\"TRACE_CONFIGURE\", \"false\"));\n+    private final static boolean TRACE_SYNC = \"true\".equalsIgnoreCase(System.getProperty(\"TRACE_SYNC\", \"false\"));\n+\n+    private final static boolean DELAY_START = \"true\".equalsIgnoreCase(System.getProperty(\"DelayStart\", \"false\"));\n+    private final static boolean DELAY_TEST = \"true\".equalsIgnoreCase(System.getProperty(\"DelayTest\", \"false\"));\n+\n+    private final static boolean ROBOT_TIME_DELAY = \"true\".equalsIgnoreCase(System.getProperty(\"ROBOT_TIME_DELAY\", \"true\"));\n+    private final static boolean ROBOT_TIME_ROUND = \"true\".equalsIgnoreCase(System.getProperty(\"ROBOT_TIME_ROUND\", \"false\"));\n+\n+    private final static boolean TEXT_VERSION = \"true\".equalsIgnoreCase(System.getProperty(\"TEXT_VERSION\", \"true\"));\n+\n+    private static boolean VERBOSE = false;\n+    private static boolean VERBOSE_GRAPHICS_CONFIG = false;\n+\n+    private static int REPEATS = 1;\n+\n+    private static boolean USE_FPS = true;\n+\n+    private static int NW = 1;\n+\n+    private final static int N_DEFAULT = 1000;\n+    private static int N = N_DEFAULT;\n@@ -81,0 +151,5 @@\n+    private final static int IMAGE_W = (int) (WIDTH + BW);\n+    private final static int IMAGE_H = (int) (HEIGHT + BH);\n+\n+    private final static String TEST_TEXT = TEXT_VERSION ? VERSION : \"The quick brown fox jumps over the lazy dog\";\n+\n@@ -82,2 +157,9 @@\n-    private final static int CYCLE_DELAY = 3;\n-    private final static int MAX_FRAME_CYCLES = 3000\/CYCLE_DELAY;\n+    private final static int MIN_COUNT = 20;\n+    private final static int WARMUP_COUNT = MIN_COUNT;\n+\n+    private final static int DELAY = 1;\n+    private final static int CYCLE_DELAY = DELAY;\n+\n+    private final static long MIN_MEASURE_TIME_NS = 1000L * 1000 * 1000;\n+    private final static long MAX_MEASURE_TIME_NS = 6000L * 1000 * 1000;\n+    private final static int MAX_FRAME_CYCLES = 3000 \/ CYCLE_DELAY;\n@@ -86,1 +168,0 @@\n-    private final static int MAX_MEASURE_CYCLES = 6000\/CYCLE_DELAY;\n@@ -88,1 +169,6 @@\n-    private final static Color[] marker = {Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW, Color.ORANGE, Color.MAGENTA};\n+    private final static Color[] MARKER = {Color.RED, Color.BLUE, Color.GREEN};\n+\n+    private final static Toolkit TOOLKIT = Toolkit.getDefaultToolkit();\n+\n+    private final static long FRAME_MAX = 60;\n+    private final static long FRAME_PREC_IN_NANOS = (1000L * 1000 * 1000) \/ (2L * FRAME_MAX);\n@@ -91,1 +177,1 @@\n-        void configure(Graphics2D g2d);\n+        void configure(Graphics2D g2d, boolean enabled);\n@@ -94,4 +180,36 @@\n-    interface Renderable {\n-        void setup(Graphics2D g2d);\n-        void render(Graphics2D g2d);\n-        void update();\n+    final static class ConfigurableAA implements Configurable {\n+        @Override\n+        public void configure(final Graphics2D g2d, final boolean enabled) {\n+            g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                    enabled ? RenderingHints.VALUE_ANTIALIAS_ON\n+                            : RenderingHints.VALUE_ANTIALIAS_OFF);\n+        }\n+    }\n+\n+    final static class ConfigurableTextAA implements Configurable {\n+        @Override\n+        public void configure(final Graphics2D g2d, final boolean enabled) {\n+            g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                    enabled ? RenderingHints.VALUE_TEXT_ANTIALIAS_ON\n+                            : RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);\n+        }\n+    }\n+\n+    final static class ConfigurableTextLCD implements Configurable {\n+        @Override\n+        public void configure(final Graphics2D g2d, final boolean enabled) {\n+            g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                    enabled ? RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB\n+                            : RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT);\n+        }\n+    }\n+\n+    final static class ConfigurableXORMode implements Configurable {\n+        @Override\n+        public void configure(final Graphics2D g2d, final boolean enabled) {\n+            if (enabled) {\n+                g2d.setXORMode(Color.WHITE);\n+            } else {\n+                g2d.setPaintMode();\n+            }\n+        }\n@@ -100,7 +218,21 @@\n-    static class Particles {\n-        private float[] bx;\n-        private float[] by;\n-        private float[] vx;\n-        private float[] vy;\n-        private float r;\n-        private int n;\n+    final static class ConfigurableXORModeTextLCD implements Configurable {\n+        @Override\n+        public void configure(final Graphics2D g2d, final boolean enabled) {\n+            if (enabled) {\n+                g2d.setXORMode(Color.WHITE);\n+            } else {\n+                g2d.setPaintMode();\n+            }\n+            g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                    enabled ? RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB\n+                            : RenderingHints.VALUE_TEXT_ANTIALIAS_DEFAULT);\n+        }\n+    }\n+\n+    final static class Particles {\n+        private final float[] bx;\n+        private final float[] by;\n+        private final float[] vx;\n+        private final float[] vy;\n+        private final float r;\n+        private final int n;\n@@ -108,4 +240,4 @@\n-        private float x0;\n-        private float y0;\n-        private float width;\n-        private float height;\n+        private final float x0;\n+        private final float y0;\n+        private final float width;\n+        private final float height;\n@@ -146,1 +278,0 @@\n-\n@@ -148,1 +279,0 @@\n-\n@@ -151,2 +281,6 @@\n-    ParticleRenderable createPR(ParticleRenderer renderer) {\n-        return new ParticleRenderable(renderer);\n+    interface Renderable {\n+        void setup(Graphics2D g2d, boolean enabled);\n+\n+        void render(Graphics2D g2d);\n+\n+        void update();\n@@ -155,3 +289,4 @@\n-    static class ParticleRenderable implements Renderable {\n-        ParticleRenderer renderer;\n-        Configurable configure;\n+    final static class ParticleRenderable implements Renderable {\n+        final Particles balls;\n+        final ParticleRenderer renderer;\n+        Configurable configure = null;\n@@ -159,1 +294,2 @@\n-        ParticleRenderable(ParticleRenderer renderer, Configurable configure) {\n+        ParticleRenderable(final Particles balls, final ParticleRenderer renderer) {\n+            this.balls = balls;\n@@ -161,5 +297,0 @@\n-            this.configure = configure;\n-        }\n-\n-        ParticleRenderable(ParticleRenderer renderer) {\n-            this(renderer, null);\n@@ -169,2 +300,7 @@\n-        public void setup(Graphics2D g2d) {\n-            if (configure != null) configure.configure(g2d);\n+        public void setup(final Graphics2D g2d, final boolean enabled) {\n+            if (configure != null) {\n+                if (TRACE_CONFIGURE) {\n+                    System.out.println(\"configure(\" + configure.getClass().getSimpleName() + \"): \" + enabled);\n+                }\n+                configure.configure(g2d, enabled);\n+            }\n@@ -183,1 +319,1 @@\n-        public ParticleRenderable configure(Configurable configure) {\n+        public ParticleRenderable configure(final Configurable configure) {\n@@ -191,0 +327,20 @@\n+    }\n+\n+    final static class CalibrationParticleRenderer implements ParticleRenderer {\n+\n+        CalibrationParticleRenderer() {\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            \/\/ no-op\n+        }\n+    }\n+\n+    final static class MixedParticleRenderer implements ParticleRenderer {\n+\n+        private final ParticleRenderer[] renderers;\n+\n+        MixedParticleRenderer(ParticleRenderer... renderers) {\n+            this.renderers = renderers;\n+        }\n@@ -192,0 +348,19 @@\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            renderers[id % renderers.length].render(g2d, id, x, y, vx, vy);\n+        }\n+    }\n+\n+    final static class BatchedParticleRenderer implements ParticleRenderer {\n+\n+        private final ParticleRenderer[] renderers;\n+\n+        BatchedParticleRenderer(ParticleRenderer... renderers) {\n+            this.renderers = renderers;\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            final int step = N \/ renderers.length;\n+            renderers[(id \/ step) % renderers.length].render(g2d, id, x, y, vx, vy);\n+        }\n@@ -210,1 +385,1 @@\n-            g2d.fillOval((int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r));\n+            g2d.fillOval((int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r));\n@@ -231,0 +406,1 @@\n+\n@@ -245,6 +421,3 @@\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)(y[id] - r));\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)y[id]);\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)(y[id] + r));\n+            g2d.drawString(TEST_TEXT, (int) (x[id] - r), (int) (y[id] - r));\n+            g2d.drawString(TEST_TEXT, (int) (x[id] - r), (int) y[id]);\n+            g2d.drawString(TEST_TEXT, (int) (x[id] - r), (int) (y[id] + r));\n@@ -276,0 +449,2 @@\n+        private Font font = null;\n+\n@@ -284,1 +459,3 @@\n-            Font font = new Font(\"LucidaGrande\", Font.PLAIN, 32);\n+            if (font == null) {\n+                font = new Font(\"LucidaGrande\", Font.PLAIN, 32);\n+            }\n@@ -286,6 +463,3 @@\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)(y[id] - r));\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)y[id]);\n-            g2d.drawString(\"The quick brown fox jumps over the lazy dog\",\n-                    (int)(x[id] - r), (int)(y[id] + r));\n+            g2d.drawString(TEST_TEXT, (int) (x[id] - r), (int) (y[id] - r));\n+            g2d.drawString(TEST_TEXT, (int) (x[id] - r), (int) y[id]);\n+            g2d.drawString(TEST_TEXT, (int) (x[id] - r), (int) (y[id] + r));\n@@ -297,1 +471,0 @@\n-\n@@ -317,1 +490,1 @@\n-                g2d.fillOval(-(int)r, (int)(-0.5*r), (int) (2 * r), (int)r);\n+                g2d.fillOval(-(int) r, (int) (-0.5 * r), (int) (2 * r), (int) r);\n@@ -320,1 +493,1 @@\n-                g2d.fillOval((int)(x[id] - r), (int)(y[id] - 0.5*r),\n+                g2d.fillOval((int) (x[id] - r), (int) (y[id] - 0.5 * r),\n@@ -328,1 +501,0 @@\n-\n@@ -335,2 +507,2 @@\n-            Point2D start = new Point2D.Double(- r,  - 0.5*r);\n-            Point2D end = new Point2D.Double( 2 * r, r);\n+            Point2D start = new Point2D.Double(-r, -0.5 * r);\n+            Point2D end = new Point2D.Double(2 * r, r);\n@@ -338,3 +510,2 @@\n-            Color[] cls = {colors[id %colors.length], colors[(colors.length - id) %colors.length]};\n-            LinearGradientPaint p =\n-                    new LinearGradientPaint(start, end, dist, cls);\n+            Color[] cls = {colors[id % colors.length], colors[(colors.length - id) % colors.length]};\n+            LinearGradientPaint p = new LinearGradientPaint(start, end, dist, cls);\n@@ -347,1 +518,0 @@\n-\n@@ -354,2 +524,2 @@\n-            Point2D start = new Point2D.Double(- r,  - 0.5*r);\n-            Point2D end = new Point2D.Double( 2 * r, r);\n+            Point2D start = new Point2D.Double(-r, -0.5 * r);\n+            Point2D end = new Point2D.Double(2 * r, r);\n@@ -358,5 +528,4 @@\n-                colors[id %colors.length],\n-                colors[(colors.length - id) %colors.length],\n-                colors[(id*5) %colors.length]};\n-            LinearGradientPaint p =\n-                new LinearGradientPaint(start, end, dist, cls);\n+                    colors[id % colors.length],\n+                    colors[(colors.length - id) % colors.length],\n+                    colors[(id * 5) % colors.length]};\n+            LinearGradientPaint p = new LinearGradientPaint(start, end, dist, cls);\n@@ -369,1 +538,0 @@\n-\n@@ -379,5 +547,4 @@\n-                colors[id %colors.length],\n-                colors[(colors.length - id) %colors.length],\n-                colors[(id*5) %colors.length]};\n-            RadialGradientPaint p =\n-                new RadialGradientPaint(start, r, dist, cls);\n+                    colors[id % colors.length],\n+                    colors[(colors.length - id) % colors.length],\n+                    colors[(id * 5) % colors.length]};\n+            RadialGradientPaint p = new RadialGradientPaint(start, r, dist, cls);\n@@ -390,1 +557,0 @@\n-\n@@ -394,0 +560,1 @@\n+\n@@ -397,2 +564,1 @@\n-            g2d.fillRect((int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r));\n-\n+            g2d.fillRect((int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r));\n@@ -400,1 +566,0 @@\n-\n@@ -405,1 +570,0 @@\n-\n@@ -409,0 +573,1 @@\n+\n@@ -437,1 +602,1 @@\n-            g2d.drawImage(dukeImg, (int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r), null);\n+            g2d.drawImage(dukeImg, (int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r), null);\n@@ -442,1 +607,2 @@\n-    static class FlatBoxRotParticleRenderer extends FlatParticleRenderer {\n+    static class VolImgParticleRenderer extends ImgParticleRenderer {\n+        VolatileImage volImg;\n@@ -444,0 +610,35 @@\n+        VolImgParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void render(Graphics2D g2d, int id, float[] x, float[] y, float[] vx, float[] vy) {\n+            GraphicsConfiguration config = g2d.getDeviceConfiguration();\n+            if (volImg == null) {\n+                volImg = config.createCompatibleVolatileImage(dukeImg.getWidth(), dukeImg.getHeight(),\n+                        Transparency.TRANSLUCENT);\n+                Graphics2D g = volImg.createGraphics();\n+                g.setComposite(AlphaComposite.Src);\n+                g.drawImage(dukeImg, null, null);\n+                g.dispose();\n+            } else {\n+                int status = volImg.validate(config);\n+                if (status == VolatileImage.IMAGE_INCOMPATIBLE) {\n+                    volImg = config.createCompatibleVolatileImage(dukeImg.getWidth(), dukeImg.getHeight(),\n+                            Transparency.TRANSLUCENT);\n+                }\n+                if (status != VolatileImage.IMAGE_OK) {\n+                    Graphics2D g = volImg.createGraphics();\n+                    g.setComposite(AlphaComposite.Src);\n+                    g.drawImage(dukeImg, null, null);\n+                    g.dispose();\n+                }\n+            }\n+            Composite savedComposite = g2d.getComposite();\n+            g2d.setComposite(AlphaComposite.SrcOver);\n+            g2d.drawImage(volImg, (int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r), null);\n+            g2d.setComposite(savedComposite);\n+        }\n+    }\n+\n+    static class FlatBoxRotParticleRenderer extends FlatParticleRenderer {\n@@ -448,0 +649,1 @@\n+\n@@ -459,1 +661,1 @@\n-                g2d.fillRect(-(int)r, -(int)r, (int) (2 * r), (int) (2 * r));\n+                g2d.fillRect(-(int) r, -(int) r, (int) (2 * r), (int) (2 * r));\n@@ -462,1 +664,1 @@\n-                g2d.fillRect((int)(x[id] - r), (int)(y[id] - r),\n+                g2d.fillRect((int) (x[id] - r), (int) (y[id] - r),\n@@ -470,1 +672,0 @@\n-\n@@ -474,0 +675,1 @@\n+\n@@ -477,1 +679,1 @@\n-            g2d.drawOval((int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r));\n+            g2d.drawOval((int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r));\n@@ -479,1 +681,0 @@\n-\n@@ -481,0 +682,1 @@\n+\n@@ -490,1 +692,1 @@\n-            g2d.drawRect((int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r));\n+            g2d.drawRect((int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r));\n@@ -492,1 +694,0 @@\n-\n@@ -494,0 +695,1 @@\n+\n@@ -502,3 +704,3 @@\n-            double v = Math.sqrt(vx[id]*vx[id]+vy[id]*vy[id]);\n-            float nvx = (float) (vx[id]\/v);\n-            float nvy = (float) (vy[id]\/v);\n+            double v = Math.sqrt(vx[id] * vx[id] + vy[id] * vy[id]);\n+            float nvx = (float) (vx[id] \/ v);\n+            float nvy = (float) (vy[id] \/ v);\n@@ -506,2 +708,2 @@\n-            g2d.drawLine((int)(x[id] - r*nvx), (int)(y[id] - r*nvy),\n-                    (int)(x[id] + 2*r*nvx), (int)(y[id] + 2*r*nvy));\n+            g2d.drawLine((int) (x[id] - r * nvx), (int) (y[id] - r * nvy),\n+                    (int) (x[id] + 2 * r * nvx), (int) (y[id] + 2 * r * nvy));\n@@ -509,1 +711,0 @@\n-\n@@ -512,1 +713,0 @@\n-\n@@ -523,1 +723,1 @@\n-                g2d.draw(new QuadCurve2D.Float(x[id-3], y[id-3], x[id-2], y[id-2], x[id-1], y[id-1]));\n+                g2d.draw(new QuadCurve2D.Float(x[id - 3], y[id - 3], x[id - 2], y[id - 2], x[id - 1], y[id - 1]));\n@@ -525,1 +725,0 @@\n-\n@@ -539,1 +738,1 @@\n-                g2d.fill(new QuadCurve2D.Float(x[id-3], y[id-3], x[id-2], y[id-2], x[id-1], y[id-1]));\n+                g2d.fill(new QuadCurve2D.Float(x[id - 3], y[id - 3], x[id - 2], y[id - 2], x[id - 1], y[id - 1]));\n@@ -541,1 +740,0 @@\n-\n@@ -556,1 +754,1 @@\n-            g2d.drawImage(image, (int)(x[id] - r), (int)(y[id] - r), (int)(2*r), (int)(2*r), null);\n+            g2d.drawImage(image, (int) (x[id] - r), (int) (y[id] - r), (int) (2 * r), (int) (2 * r), null);\n@@ -568,1 +766,0 @@\n-\n@@ -605,2 +802,1 @@\n-    static class PerfMeter {\n-        private String name;\n+    final static class PerfMeter {\n@@ -608,0 +804,3 @@\n+        private final FrameHandler fh;\n+        private final String name;\n+        private final PerfMeterExecutor executor;\n@@ -609,1 +808,5 @@\n-        private JPanel panel;\n+        PerfMeter(final FrameHandler fh, String name) {\n+            this.fh = fh;\n+            this.name = name;\n+            executor = getExecutor();\n+        }\n@@ -611,4 +814,18 @@\n-        private double execTime = 0;\n-        private AtomicInteger markerIdx = new AtomicInteger(0);\n-        private int renderedMarkerIdx = -1;\n-        private AtomicLong markerPaintTime = new AtomicLong(0);\n+        void exec(final Renderable renderable) throws Exception {\n+            executor.exec(name, renderable);\n+        }\n+\n+        private PerfMeterExecutor getExecutor() {\n+            switch (EXEC_MODE) {\n+                default:\n+                case EXEC_MODE_ROBOT:\n+                    return new PerfMeterRobot(fh);\n+                case EXEC_MODE_BUFFER:\n+                    fh.prepareImageProvider(false);\n+                    return new PerfMeterImageProvider(fh);\n+                case EXEC_MODE_VOLATILE:\n+                    fh.prepareImageProvider(true);\n+                    return new PerfMeterImageProvider(fh);\n+            }\n+        }\n+    }\n@@ -616,2 +833,7 @@\n-        private double fps;\n-        private int skippedFrame = 0;\n+    static void paintTest(final Renderable renderable, final Graphics2D g2d,\n+                          final Color markerColor, final boolean doSync) {\n+        \/\/ clip to frame:\n+        g2d.setClip(0, 0, IMAGE_W, IMAGE_H);\n+        \/\/ clear background:\n+        g2d.setColor(Color.BLACK);\n+        g2d.fillRect(0, 0, IMAGE_W, IMAGE_H);\n@@ -619,2 +841,13 @@\n-        PerfMeter(String name) {\n-            this.name = name;\n+        \/\/ render test:\n+        renderable.setup(g2d, true);\n+        renderable.render(g2d);\n+        renderable.setup(g2d, false);\n+\n+        \/\/ draw marker at end:\n+        g2d.setClip(0, 0, BW, BH);\n+        g2d.setColor(markerColor);\n+        g2d.fillRect(0, 0, BW, BH);\n+\n+        if (doSync) {\n+            \/\/ synchronize toolkit:\n+            TOOLKIT.sync();\n@@ -622,0 +855,1 @@\n+    }\n@@ -623,2 +857,1 @@\n-        PerfMeter exec(final Renderable renderable) throws Exception {\n-            final CountDownLatch latchFrame = new CountDownLatch(1);\n+    final static class FrameHandler {\n@@ -626,5 +859,65 @@\n-            final JFrame f = new JFrame();\n-            f.addWindowListener(new WindowAdapter() {\n-                @Override\n-                public void windowClosed(WindowEvent e) {\n-                    latchFrame.countDown();\n+        private boolean calibrate = VERBOSE;\n+\n+        private int threadId = -1;\n+        private int frameId = -1;\n+\n+        private final GraphicsConfiguration gc;\n+\n+        private JFrame frame = null;\n+\n+        private final CountDownLatch latchShownFrame = new CountDownLatch(1);\n+        private final CountDownLatch latchClosedFrame = new CountDownLatch(1);\n+\n+        private ImageProvider imageProvider = null;\n+\n+        FrameHandler(GraphicsConfiguration gc) {\n+            this.gc = gc;\n+        }\n+\n+        void setIds(int threadId, int frameId) {\n+            this.threadId = threadId;\n+            this.frameId = frameId;\n+        }\n+\n+        void prepareFrameEDT(final String title) {\n+            if (frame == null) {\n+                frame = new JFrame(gc);\n+                frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n+                frame.addComponentListener(new ComponentAdapter() {\n+                    @Override\n+                    public void componentShown(ComponentEvent e) {\n+                        latchShownFrame.countDown();\n+                    }\n+                });\n+                frame.addWindowListener(new WindowAdapter() {\n+                    @Override\n+                    public void windowClosed(WindowEvent e) {\n+                        latchClosedFrame.countDown();\n+                    }\n+                });\n+            }\n+            frame.setTitle(title);\n+        }\n+\n+        void showFrameEDT(final JPanel panel) {\n+            if (frame != null) {\n+                panel.setPreferredSize(new Dimension(IMAGE_W, IMAGE_H));\n+                panel.setBackground(Color.BLACK);\n+\n+                frame.getContentPane().removeAll();\n+                frame.getContentPane().add(panel);\n+                frame.getContentPane().revalidate();\n+\n+                if (!frame.isVisible()) {\n+                    if (frameId != -1) {\n+                        final int off = (frameId - 1) * 100;\n+                        final Rectangle gcBounds = gc.getBounds();\n+                        final int xoff = gcBounds.x + off;\n+                        final int yoff = gcBounds.y + off;\n+\n+                        if ((xoff != 0) || (yoff != 0)) {\n+                            frame.setLocation(xoff, yoff);\n+                        }\n+                    }\n+                    frame.pack();\n+                    frame.setVisible(true);\n@@ -632,1 +925,97 @@\n-            });\n+            }\n+        }\n+\n+        void waitFrameShown() throws Exception {\n+            latchShownFrame.await();\n+        }\n+\n+        void resetFrame() throws Exception {\n+            if (frame != null) {\n+                SwingUtilities.invokeAndWait(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        frame.getContentPane().removeAll();\n+                        frame.getContentPane().revalidate();\n+                    }\n+                });\n+            }\n+        }\n+\n+        void repaintFrame() throws Exception {\n+            if (frame != null) {\n+                SwingUtilities.invokeAndWait(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        frame.repaint();\n+                    }\n+                });\n+            }\n+        }\n+\n+        private void waitFrameHidden() throws Exception {\n+            latchClosedFrame.await();\n+        }\n+\n+        void hideFrameAndWait() throws Exception {\n+            if (frame != null) {\n+                SwingUtilities.invokeAndWait(new Runnable() {\n+                    @Override\n+                    public void run() {\n+                        frame.setVisible(false);\n+                        frame.dispose();\n+                        frame = null;\n+                    }\n+                });\n+                waitFrameHidden();\n+            }\n+        }\n+\n+        void prepareImageProvider(final boolean useVolatile) {\n+            if (this.imageProvider == null) {\n+                this.imageProvider = new ImageProvider(useVolatile);\n+            }\n+        }\n+    }\n+\n+    static abstract class PerfMeterExecutor {\n+\n+        private final static IntBinaryOperator INC_MOD_FUNC = new IntBinaryOperator() {\n+            public int applyAsInt(int x, int y) {\n+                return (x + 1) % y;\n+            }\n+        };\n+\n+        protected final FrameHandler fh;\n+        protected final AtomicInteger markerIdx = new AtomicInteger(0);\n+        protected final AtomicLong markerPaintTime = new AtomicLong(0);\n+\n+        protected String name = null;\n+        protected int skippedFrames = 0;\n+        protected final ArrayList<Long> testTime = new ArrayList<>(COUNT);\n+\n+        protected final double[] scores = new double[3];\n+        protected final double[] results = new double[4];\n+        private int nData = 0;\n+\n+        protected PerfMeterExecutor(final FrameHandler fh) {\n+            this.fh = fh;\n+        }\n+\n+        protected void beforeExec() {\n+        }\n+\n+        protected void afterExec() {\n+        }\n+\n+        protected void reset() {\n+            markerIdx.set(0);\n+            markerPaintTime.set(0);\n+        }\n+\n+        protected void updateMarkerIdx() {\n+            markerIdx.accumulateAndGet(MARKER.length, INC_MOD_FUNC);\n+        }\n+\n+        protected final void exec(final String testName, final Renderable renderable) throws Exception {\n+            if (TRACE) System.out.print(\"\\n!\");\n+            this.name = testName + \"[\" + fh.threadId + \"]\";\n@@ -637,0 +1026,3 @@\n+                    fh.prepareFrameEDT(name);\n+                    \/\/ call beforeExec() after frame is created:\n+                    beforeExec();\n@@ -638,1 +1030,1 @@\n-                    panel = new JPanel() {\n+                    final JPanel panel = new JPanel() {\n@@ -641,14 +1033,3 @@\n-                            super.paintComponent(g);\n-                            int idx = markerIdx.get();\n-                            if (idx != renderedMarkerIdx) {\n-                                markerPaintTime.set(System.nanoTime());\n-                            }\n-\n-                            Graphics2D g2d = (Graphics2D) g.create();\n-                            renderable.setup(g2d);\n-                            renderable.render(g2d);\n-                            g2d.setClip(null);\n-                            g2d.setPaintMode();\n-                            g2d.setColor(marker[idx]);\n-                            g2d.fillRect(0, 0, BW, BH);\n-                            renderedMarkerIdx = idx;\n+                            if (TRACE) System.out.print(\"P\");\n+                            paintPanel(renderable, g);\n+                            if (TRACE) System.out.print(\"Q\");\n@@ -657,7 +1038,2 @@\n-\n-                    panel.setPreferredSize(new Dimension((int) (WIDTH + BW), (int) (HEIGHT + BH)));\n-                    panel.setBackground(Color.BLACK);\n-                    f.add(panel);\n-                    f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n-                    f.pack();\n-                    f.setVisible(true);\n+                    fh.showFrameEDT(panel);\n+                    if (TRACE) System.out.print(\">>\");\n@@ -667,6 +1043,46 @@\n-            Robot robot = new Robot();\n-            int cycle = 0;\n-            int frame = 0;\n-            long paintTime = 0;\n-            int maxFrameCycle = -1;\n-            while (frame < COUNT) {\n+            \/\/ Wait frame to be shown:\n+            fh.waitFrameShown();\n+\n+            if (TRACE) System.out.print(\":\");\n+\n+            \/\/ Reset before warmup:\n+            reset();\n+\n+            \/\/ Warmup to prepare frame synchronization:\n+            for (int i = 0; i < WARMUP_COUNT; i++) {\n+                updateMarkerIdx();\n+                renderable.update();\n+                fh.repaintFrame();\n+                sleep(10);\n+                while (markerPaintTime.get() == 0) {\n+                    if (TRACE) System.out.print(\"-\");\n+                    sleep(1);\n+                }\n+                markerPaintTime.set(0);\n+            }\n+            \/\/ Reset before measurements:\n+            reset();\n+            if (TRACE) System.out.print(\":>>\");\n+\n+            int cycles = 0;\n+            int frames = 0;\n+            long paintTime = 0L;\n+            long lastFrameTime = 0L;\n+\n+            \/\/ signal thread is ready for test\n+            readyCount.countDown();\n+            if (TRACE_SYNC) traceSync(name + \" ready => waiting start signal...\");\n+\n+            \/\/ wait start signal:\n+            triggerStart.await();\n+            \/\/ Run Benchmark (all threads):\n+            if (TRACE_SYNC) traceSync(name + \" benchmark started\");\n+\n+            final long startTime = System.nanoTime();\n+            final long minTime = startTime + MIN_MEASURE_TIME_NS;\n+            final long endTime = startTime + MAX_MEASURE_TIME_NS;\n+\n+            \/\/ Start 1st measurement:\n+            fh.repaintFrame();\n+\n+            for (; ; ) {\n@@ -674,1 +1090,1 @@\n-                if ((t = markerPaintTime.getAndSet(0)) > 0) {\n+                if ((t = markerPaintTime.getAndSet(0L)) > 0L) {\n@@ -676,1 +1092,1 @@\n-                    maxFrameCycle = cycle + MAX_FRAME_CYCLES;\n+                    if (TRACE) System.out.print(\"|\");\n@@ -679,4 +1095,6 @@\n-                if (paintTime > 0) {\n-                    Color c = robot.getPixelColor(\n-                            panel.getTopLevelAncestor().getX() + panel.getTopLevelAncestor().getInsets().left + BW \/ 2,\n-                            panel.getTopLevelAncestor().getY() + panel.getTopLevelAncestor().getInsets().top + BW \/ 2);\n+                boolean wait = true;\n+\n+                if (paintTime > 0L) {\n+                    if (TRACE) System.out.print(\".\");\n+                    wait = false;\n+                    final Color c = getMarkerColor();\n@@ -684,3 +1102,10 @@\n-                    if (isAlmostEqual(c, marker[markerIdx.get()])) {\n-                        execTime += System.nanoTime() - paintTime;\n-                        frame++;\n+                    if (isAlmostEqual(c, MARKER[markerIdx.get()])) {\n+                        final long duration = getElapsedTime(paintTime);\n+                        if (duration > 0L) {\n+                            testTime.add(duration);\n+                        }\n+                        if (REPORT_OVERALL_FPS) {\n+                            lastFrameTime = System.nanoTime();\n+                        }\n+                        if (TRACE) System.out.print(\"R\");\n+                        frames++;\n@@ -688,2 +1113,2 @@\n-                        maxFrameCycle = -1;\n-                        markerIdx.accumulateAndGet(marker.length, (x, y) -> (x + 1) % y);\n+                        cycles = 0;\n+                        updateMarkerIdx();\n@@ -691,3 +1116,4 @@\n-                        panel.getParent().repaint();\n-                    } else if (cycle >= maxFrameCycle) {\n-                        skippedFrame++;\n+                        fh.repaintFrame();\n+                    } else if (cycles >= MAX_FRAME_CYCLES) {\n+                        if (TRACE) System.out.print(\"M\");\n+                        skippedFrames++;\n@@ -695,3 +1121,5 @@\n-                        maxFrameCycle = -1;\n-                        markerIdx.accumulateAndGet(marker.length, (x, y) -> (x + 1) % y);\n-                        panel.getParent().repaint();\n+                        cycles = 0;\n+                        updateMarkerIdx();\n+                        fh.repaintFrame();\n+                    } else {\n+                        if (TRACE) System.out.print(\"-\");\n@@ -700,4 +1128,3 @@\n-                try {\n-                    Thread.sleep(CYCLE_DELAY);\n-                } catch (InterruptedException ex) {\n-                    ex.printStackTrace();\n+                final long currentTime = System.nanoTime();\n+                if ((frames >= MIN_COUNT) && (currentTime >= endTime)) {\n+                    break;\n@@ -705,1 +1132,1 @@\n-                if (cycle >= MAX_MEASURE_CYCLES) {\n+                if ((frames >= COUNT) && (currentTime >= minTime)) {\n@@ -708,1 +1135,17 @@\n-                cycle++;\n+                if (wait) {\n+                    sleep(CYCLE_DELAY);\n+                }\n+                cycles++;\n+            } \/\/ end measurements\n+\n+            \/\/ signal test completed:\n+            completedCount.countDown();\n+            if (TRACE_SYNC) traceSync(name + \" completed => waiting stop signal...\");\n+\n+            \/\/ wait stop signal:\n+            triggerStop.await();\n+            \/\/ Stop Benchmark (all threads):\n+            if (TRACE_SYNC) traceSync(name + \" stopped\");\n+\n+            if (DELAY_TEST) {\n+                sleep(1000);\n@@ -710,4 +1153,1 @@\n-            SwingUtilities.invokeAndWait(() -> {\n-                f.setVisible(false);\n-                f.dispose();\n-            });\n+            fh.resetFrame();\n@@ -715,5 +1155,6 @@\n-            latchFrame.await();\n-            if (execTime != 0 && frame != 0) {\n-                fps = 1e9 \/ (execTime \/ frame);\n-            } else {\n-                fps = 0;\n+            \/\/ Process results:\n+            if (REPORT_OVERALL_FPS && (lastFrameTime != 0)) {\n+                final double elapsedTime = (lastFrameTime - startTime);\n+                final double elapsedFPS = 1000000000.0 * frames \/ elapsedTime;\n+\n+                System.err.println(frames + \" in \" + (elapsedTime \/ 1000000) + \" ms: ~ \" + elapsedFPS + \" FPS\");\n@@ -722,1 +1163,69 @@\n-            return this;\n+            if (!testTime.isEmpty()) {\n+                processTimes();\n+            }\n+            if (TRACE) System.out.print(\"<<\\n\");\n+            afterExec();\n+\n+            \/\/ Log report:\n+            System.err.println(getResults());\n+\n+            \/\/ signal test done:\n+            doneCount.countDown();\n+            if (TRACE_SYNC) traceSync(name + \" done => waiting exit signal...\");\n+\n+            \/\/ wait exit signal:\n+            triggerExit.await();\n+            \/\/ Stop Benchmark (all threads):\n+            if (TRACE_SYNC) traceSync(name + \" exited\");\n+        }\n+\n+        protected abstract void paintPanel(final Renderable renderable, final Graphics g);\n+\n+        protected abstract long getElapsedTime(long paintTime);\n+\n+        protected abstract Color getMarkerColor() throws Exception;\n+\n+        protected boolean isAlmostEqual(Color c1, Color c2) {\n+            return (Math.abs(c1.getRed() - c2.getRed()) < COLOR_TOLERANCE) &&\n+                    (Math.abs(c1.getGreen() - c2.getGreen()) < COLOR_TOLERANCE) &&\n+                    (Math.abs(c1.getBlue() - c2.getBlue()) < COLOR_TOLERANCE);\n+        }\n+\n+        protected void processTimes() {\n+            nData = testTime.size();\n+\n+            if (!testTime.isEmpty()) {\n+                \/\/ Ignore first 10% (warmup at the beginning):\n+                final int thIdx = (int) Math.ceil(testTime.size() * 0.10);\n+\n+                final ArrayList<Long> times = new ArrayList<>(nData - thIdx);\n+                for (int i = thIdx; i < nData; i++) {\n+                    times.add(testTime.get(i));\n+                }\n+\n+                \/\/ Sort values to get percentiles:\n+                Collections.sort(times);\n+                final int last = times.size() - 1;\n+\n+                if (USE_FPS) {\n+                    scores[0] = fps(times.get(pctIndex(last, 0.5000))); \/\/    50% (median)\n+\n+                    results[3] = fps(times.get(0)); \/\/ 0.0 (min)\n+                    results[2] = fps(times.get(pctIndex(last, 0.1587))); \/\/ 15.87% (-1 stddev)\n+                    results[1] = fps(times.get(pctIndex(last, 0.8413))); \/\/ 84.13% (+1 stddev)\n+                    results[0] = fps(times.get(pctIndex(last, 1.0000))); \/\/ 100% (max)\n+\n+                    scores[1] = (results[2] - results[1]) \/ 2.0;\n+                    scores[2] = millis(times.get(pctIndex(last, 0.5000))); \/\/    50% (median)\n+                } else {\n+                    scores[0] = millis(times.get(pctIndex(last, 0.5000))); \/\/    50% (median)\n+\n+                    results[0] = millis(times.get(0)); \/\/ 0.0 (min)\n+                    results[1] = millis(times.get(pctIndex(last, 0.1587))); \/\/ 15.87% (-1 stddev)\n+                    results[2] = millis(times.get(pctIndex(last, 0.8413))); \/\/ 84.13% (+1 stddev)\n+                    results[3] = millis(times.get(pctIndex(last, 1.0000))); \/\/ 100% (max)\n+\n+                    scores[1] = (results[2] - results[1]) \/ 2.0;\n+                    scores[2] = fps(times.get(pctIndex(last, 0.5000))); \/\/    50% (median)\n+                }\n+            }\n@@ -725,3 +1234,11 @@\n-        private void report() {\n-            if (skippedFrame > 0) {\n-                System.err.println(skippedFrame + \" frame(s) skipped\");\n+        protected String getResults() {\n+            if (skippedFrames > 0) {\n+                System.err.println(name + \" : \" + skippedFrames + \" frame(s) skipped\");\n+            }\n+            if (VERBOSE) {\n+                return String.format(\"%-25s : %.3f (%.3f) %s [%.3f %s] (p00: %.3f p15: %.3f p50: %.3f p85: %.3f p100: %.3f %s) (%d frames)\",\n+                        name, scores[0], scores[1], (USE_FPS ? \"FPS\" : \"ms\"),\n+                        scores[2], (USE_FPS ? \"ms\" : \"FPS\"),\n+                        results[0], results[1], scores[0], results[2], results[3],\n+                        (USE_FPS ? \"FPS\" : \"ms\"),\n+                        nData);\n@@ -729,1 +1246,1 @@\n-            System.err.println(name + \" : \" + String.format(\"%.2f FPS\", fps));\n+            return String.format(\"%-25s : %.3f (%.3f) %s\", name, scores[0], scores[1], (USE_FPS ? \"FPS\" : \"ms\"));\n@@ -732,4 +1249,3 @@\n-        private boolean isAlmostEqual(Color c1, Color c2) {\n-            return Math.abs(c1.getRed() - c2.getRed()) < COLOR_TOLERANCE &&\n-                    Math.abs(c1.getGreen() - c2.getGreen()) < COLOR_TOLERANCE &&\n-                    Math.abs(c1.getBlue() - c2.getBlue()) < COLOR_TOLERANCE;\n+        protected double fps(long timeNs) {\n+            return 1e9 \/ timeNs;\n+        }\n@@ -737,0 +1253,6 @@\n+        protected double millis(long timeNs) {\n+            return 1e-6 * timeNs;\n+        }\n+\n+        protected int pctIndex(final int last, final double pct) {\n+            return (int) Math.round(last * pct);\n@@ -740,23 +1262,90 @@\n-    private static final Particles balls = new Particles(N, R, BW, BH, WIDTH, HEIGHT);\n-    private static final ParticleRenderer flatRenderer = new FlatParticleRenderer(N, R);\n-    private static final ParticleRenderer clipFlatRenderer = new ClipFlatParticleRenderer(N, R);\n-    private static final ParticleRenderer flatOvalRotRenderer = new FlatOvalRotParticleRenderer(N, R);\n-    private static final ParticleRenderer flatBoxRenderer = new FlatBoxParticleRenderer(N, R);\n-    private static final ParticleRenderer clipFlatBoxParticleRenderer = new ClipFlatBoxParticleRenderer(N, R);\n-    private static final ParticleRenderer flatBoxRotRenderer = new FlatBoxRotParticleRenderer(N, R);\n-    private static final ParticleRenderer linGradOvalRotRenderer = new LinGradOvalRotParticleRenderer(N, R);\n-    private static final ParticleRenderer linGrad3OvalRotRenderer = new LinGrad3OvalRotParticleRenderer(N, R);\n-    private static final ParticleRenderer radGrad3OvalRotRenderer = new RadGrad3OvalRotParticleRenderer(N, R);\n-    private static final ParticleRenderer wiredRenderer = new WiredParticleRenderer(N, R);\n-    private static final ParticleRenderer wiredBoxRenderer = new WiredBoxParticleRenderer(N, R);\n-    private static final ParticleRenderer segRenderer = new SegParticleRenderer(N, R);\n-    private static final ParticleRenderer flatQuadRenderer = new FlatQuadParticleRenderer(N, R);\n-    private static final ParticleRenderer wiredQuadRenderer = new WiredQuadParticleRenderer(N, R);\n-    private static final ParticleRenderer imgRenderer = new ImgParticleRenderer(N, R);\n-    private static final ParticleRenderer textRenderer = new TextParticleRenderer(N, R);\n-    private static final ParticleRenderer largeTextRenderer = new LargeTextParticleRenderer(N, R);\n-    private static final ParticleRenderer whiteTextRenderer = new WhiteTextParticleRenderer(R);\n-    private static final ParticleRenderer argbSwBlitImageRenderer = new SwBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_ARGB);\n-    private static final ParticleRenderer bgrSwBlitImageRenderer = new SwBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_BGR);\n-    private static final ParticleRenderer argbSurfaceBlitImageRenderer = new SurfaceBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_ARGB);\n-    private static final ParticleRenderer bgrSurfaceBlitImageRenderer = new SurfaceBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_BGR);\n+    final static class PerfMeterRobot extends PerfMeterExecutor {\n+\n+        private final ArrayList<Long> robotTime = (fh.calibrate) ? new ArrayList<>(COUNT) : null;\n+\n+        private long lastPaintTime = 0;\n+        private final ArrayList<Long> delayTime = new ArrayList<>(COUNT);\n+\n+        private int renderedMarkerIdx = -1;\n+\n+        private Robot robot = null;\n+\n+        PerfMeterRobot(final FrameHandler fh) {\n+            super(fh);\n+        }\n+\n+        protected void beforeExec() {\n+            try {\n+                robot = new Robot();\n+            } catch (AWTException ae) {\n+                throw new RuntimeException(ae);\n+            }\n+        }\n+\n+        protected void reset() {\n+            super.reset();\n+            renderedMarkerIdx = -1;\n+        }\n+\n+        protected void paintPanel(final Renderable renderable, final Graphics g) {\n+            final int idx = markerIdx.get();\n+            final long start = System.nanoTime();\n+\n+            final Graphics2D g2d = (Graphics2D) g.create();\n+            try {\n+                paintTest(renderable, g2d, MARKER[idx], false);\n+            } finally {\n+                g2d.dispose();\n+            }\n+\n+            \/\/ publish start time:\n+            if (idx != renderedMarkerIdx) {\n+                renderedMarkerIdx = idx;\n+                markerPaintTime.set(start);\n+            }\n+        }\n+\n+        protected long getElapsedTime(long paintTime) {\n+            final long now = System.nanoTime();\n+            long duration = (!ROBOT_TIME_DELAY) ? roundDuration(now - paintTime) : 0L;\n+            if (lastPaintTime != 0) {\n+                final long delay = roundDuration(now - lastPaintTime);\n+                if (ROBOT_TIME_DELAY) {\n+                    duration = delay;\n+                } else {\n+                    delayTime.add(delay);\n+                }\n+            }\n+            lastPaintTime = now;\n+            return duration;\n+        }\n+\n+        private static long roundDuration(final long durationNs) {\n+            return (durationNs <= 0L) ? 0L : (\n+                    (ROBOT_TIME_ROUND) ?\n+                            FRAME_PREC_IN_NANOS * (long) Math.rint(((double) durationNs) \/ FRAME_PREC_IN_NANOS) : durationNs\n+            );\n+        }\n+\n+        protected Color getMarkerColor() {\n+            final Point frameOffset = fh.frame.getLocationOnScreen();\n+            final Insets insets = fh.frame.getInsets();\n+            final int px = frameOffset.x + insets.left + BW \/ 2;\n+            final int py = frameOffset.y + insets.top + BH \/ 2;\n+\n+            final long beforeRobot = (fh.calibrate) ? System.nanoTime() : 0L;\n+\n+            final Color c = robot.getPixelColor(px, py);\n+\n+            if (fh.calibrate) {\n+                robotTime.add((System.nanoTime() - beforeRobot));\n+            }\n+            return c;\n+        }\n+\n+        protected String getResults() {\n+            if (fh.calibrate && !robotTime.isEmpty()) {\n+                fh.calibrate = false; \/\/ only first time\n+\n+                Collections.sort(robotTime);\n+                final int last = robotTime.size() - 1;\n@@ -764,3 +1353,13 @@\n-    private static final Configurable AA = (Graphics2D g2d) ->\n-        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n-            RenderingHints.VALUE_ANTIALIAS_ON);\n+                final double[] robotStats = new double[5];\n+                robotStats[0] = millis(robotTime.get(0)); \/\/ 0.0 (min)\n+                robotStats[1] = millis(robotTime.get(pctIndex(last, 0.1587))); \/\/ 15.87% (-1 stddev)\n+                robotStats[2] = millis(robotTime.get(pctIndex(last, 0.5000))); \/\/    50% (median)\n+                robotStats[3] = millis(robotTime.get(pctIndex(last, 0.8413))); \/\/ 84.13% (+1 stddev)\n+                robotStats[4] = millis(robotTime.get(pctIndex(last, 1.0000))); \/\/   100% (max)\n+\n+                System.err.printf(\"%-25s : %.3f ms (p00: %.3f p15: %.3f p50: %.3f p85: %.3f p100: %.3f ms) (%d times)%n\",\n+                        \"Robot [\" + fh.threadId + \"]\", robotStats[2], robotStats[0], robotStats[1], robotStats[2], robotStats[3], robotStats[4], last + 1);\n+            }\n+            if (!delayTime.isEmpty()) {\n+                Collections.sort(delayTime);\n+                final int last = delayTime.size() - 1;\n@@ -768,3 +1367,6 @@\n-    private static final Configurable TextLCD = (Graphics2D g2d) ->\n-        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n-                RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);\n+                final double[] delayStats = new double[5];\n+                delayStats[0] = millis(delayTime.get(0)); \/\/ 0.0 (min)\n+                delayStats[1] = millis(delayTime.get(pctIndex(last, 0.1587))); \/\/ 15.87% (-1 stddev)\n+                delayStats[2] = millis(delayTime.get(pctIndex(last, 0.5000))); \/\/    50% (median)\n+                delayStats[3] = millis(delayTime.get(pctIndex(last, 0.8413))); \/\/ 84.13% (+1 stddev)\n+                delayStats[4] = millis(delayTime.get(pctIndex(last, 1.0000))); \/\/   100% (max)\n@@ -772,3 +1374,1 @@\n-    private static final Configurable TextAA = (Graphics2D g2d) ->\n-        g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n-                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+                final double fps = fps(delayTime.get(pctIndex(last, 0.5000))); \/\/    50% (median)\n@@ -776,2 +1376,6 @@\n-    private static final Configurable XORMode = (Graphics2D g2d) ->\n-        {g2d.setXORMode(Color.WHITE);};\n+                System.err.printf(\"%-25s : %.3f ms [%.3f FPS] (p00: %.3f p15: %.3f p50: %.3f p85: %.3f p100: %.3f ms) (%d times)%n\",\n+                        \"DT-\" + name, delayStats[2], fps, delayStats[0], delayStats[1], delayStats[2], delayStats[3], delayStats[4], last + 1);\n+            }\n+            return super.getResults();\n+        }\n+    }\n@@ -779,4 +1383,2 @@\n-    private static final Configurable XORModeLCDText = (Graphics2D g2d) ->\n-        {g2d.setXORMode(Color.WHITE);\n-         g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n-         RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB);};\n+    final static class PerfMeterImageProvider extends PerfMeterExecutor {\n+        private final ImageProvider imageProvider;\n@@ -784,0 +1386,141 @@\n+        PerfMeterImageProvider(final FrameHandler fh) {\n+            super(fh);\n+            this.imageProvider = fh.imageProvider;\n+        }\n+\n+        protected void beforeExec() {\n+            imageProvider.create(fh.frame.getGraphicsConfiguration(), IMAGE_W, IMAGE_H);\n+        }\n+\n+        protected void afterExec() {\n+            imageProvider.reset();\n+        }\n+\n+        protected void paintPanel(final Renderable renderable, final Graphics g) {\n+            \/\/ suppose image provider is ready yet\n+            final int idx = markerIdx.get();\n+            long start = System.nanoTime();\n+\n+            \/\/ Get Graphics from image provider:\n+            final Graphics2D g2d = imageProvider.createGraphics();\n+            try {\n+                paintTest(renderable, g2d, MARKER[idx], true);\n+            } finally {\n+                g2d.dispose();\n+            }\n+\n+            \/\/ publish elapsed time:\n+            markerPaintTime.set(System.nanoTime() - start);\n+\n+            \/\/ Draw image on screen:\n+            g.drawImage(imageProvider.getImage(), 0, 0, null);\n+        }\n+\n+        protected long getElapsedTime(long paintTime) {\n+            return paintTime;\n+        }\n+\n+        protected Color getMarkerColor() {\n+            final int px = BW \/ 2;\n+            final int py = BH \/ 2;\n+\n+            return new Color(imageProvider.getSnapshot().getRGB(px, py));\n+        }\n+    }\n+\n+    private final static class ImageProvider {\n+        private final static int TRANSPARENCY = Transparency.TRANSLUCENT;\n+\n+        private final boolean useVolatile;\n+        private Image image = null;\n+\n+        private ImageProvider(boolean useVolatile) {\n+            this.useVolatile = useVolatile;\n+        }\n+\n+        void create(GraphicsConfiguration gc, int width, int height) {\n+            this.image = (useVolatile) ? gc.createCompatibleVolatileImage(width, height, TRANSPARENCY)\n+                    : gc.createCompatibleImage(width, height, TRANSPARENCY);\n+        }\n+\n+        public void reset() {\n+            image = null;\n+        }\n+\n+        public Image getImage() {\n+            return image;\n+        }\n+\n+        public Graphics2D createGraphics() {\n+            return (useVolatile) ? ((VolatileImage) image).createGraphics()\n+                    : ((BufferedImage) image).createGraphics();\n+        }\n+\n+        public BufferedImage getSnapshot() {\n+            return (useVolatile) ? ((VolatileImage) image).getSnapshot()\n+                    : (BufferedImage) image;\n+        }\n+    }\n+\n+    private final FrameHandler fh;\n+\n+    private final Particles balls = new Particles(N, R, BW, BH, WIDTH, HEIGHT);\n+\n+    private final ParticleRenderer calibRenderer = new CalibrationParticleRenderer();\n+    private final ParticleRenderer flatRenderer = new FlatParticleRenderer(N, R);\n+    private final ParticleRenderer clipFlatRenderer = new ClipFlatParticleRenderer(N, R);\n+    private final ParticleRenderer flatOvalRotRenderer = new FlatOvalRotParticleRenderer(N, R);\n+    private final ParticleRenderer flatBoxRenderer = new FlatBoxParticleRenderer(N, R);\n+    private final ParticleRenderer clipFlatBoxParticleRenderer = new ClipFlatBoxParticleRenderer(N, R);\n+    private final ParticleRenderer flatBoxRotRenderer = new FlatBoxRotParticleRenderer(N, R);\n+    private final ParticleRenderer linGradOvalRotRenderer = new LinGradOvalRotParticleRenderer(N, R);\n+    private final ParticleRenderer linGrad3OvalRotRenderer = new LinGrad3OvalRotParticleRenderer(N, R);\n+    private final ParticleRenderer radGrad3OvalRotRenderer = new RadGrad3OvalRotParticleRenderer(N, R);\n+    private final ParticleRenderer wiredRenderer = new WiredParticleRenderer(N, R);\n+    private final ParticleRenderer wiredBoxRenderer = new WiredBoxParticleRenderer(N, R);\n+    private final ParticleRenderer segRenderer = new SegParticleRenderer(N, R);\n+    private final ParticleRenderer flatQuadRenderer = new FlatQuadParticleRenderer(N, R);\n+    private final ParticleRenderer wiredQuadRenderer = new WiredQuadParticleRenderer(N, R);\n+    private final ParticleRenderer imgRenderer = new ImgParticleRenderer(N, R);\n+    private final ParticleRenderer volImgRenderer = new VolImgParticleRenderer(N, R);\n+    private final ParticleRenderer textRenderer = new TextParticleRenderer(N, R);\n+    private final ParticleRenderer largeTextRenderer = new LargeTextParticleRenderer(N, R);\n+    private final ParticleRenderer whiteTextRenderer = new WhiteTextParticleRenderer(R);\n+    private final ParticleRenderer argbSwBlitImageRenderer = new SwBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_ARGB);\n+    private final ParticleRenderer bgrSwBlitImageRenderer = new SwBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_BGR);\n+    private final ParticleRenderer argbSurfaceBlitImageRenderer = new SurfaceBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_ARGB);\n+    private final ParticleRenderer bgrSurfaceBlitImageRenderer = new SurfaceBlitImageParticleRenderer(N, R, BufferedImage.TYPE_INT_BGR);\n+\n+    private final ParticleRenderer textWiredQuadBatchedRenderer = new BatchedParticleRenderer(textRenderer, wiredQuadRenderer);\n+    private final ParticleRenderer textWiredQuadMixedRenderer = new MixedParticleRenderer(textRenderer, wiredQuadRenderer);\n+\n+    private final ParticleRenderer volImgFlatBoxBatchedRenderer = new BatchedParticleRenderer(volImgRenderer, flatBoxRenderer);\n+    private final ParticleRenderer volImgFlatBoxMixedRenderer = new MixedParticleRenderer(volImgRenderer, flatBoxRenderer);\n+\n+    private final ParticleRenderer volImgWiredQuadBatchedRenderer = new BatchedParticleRenderer(volImgRenderer, wiredQuadRenderer);\n+    private final ParticleRenderer volImgWiredQuadMixedRenderer = new MixedParticleRenderer(volImgRenderer, wiredQuadRenderer);\n+\n+    private final ParticleRenderer volImgTextBatchedRenderer = new BatchedParticleRenderer(volImgRenderer, textRenderer);\n+    private final ParticleRenderer volImgTextMixedRenderer = new MixedParticleRenderer(volImgRenderer, textRenderer);\n+\n+    private final static Configurable AA = new ConfigurableAA();\n+    private final static Configurable TextAA = new ConfigurableTextAA();\n+    private final static Configurable TextLCD = new ConfigurableTextLCD();\n+    private final static Configurable XORMode = new ConfigurableXORMode();\n+    private final static Configurable XORModeLCDText = new ConfigurableXORModeTextLCD();\n+\n+    RenderPerfTest(final GraphicsConfiguration gc) {\n+        fh = new FrameHandler(gc);\n+    }\n+\n+    ParticleRenderable createPR(final ParticleRenderer renderer) {\n+        return new ParticleRenderable(balls, renderer);\n+    }\n+\n+    PerfMeter createPerfMeter(final String name) {\n+        return new PerfMeter(fh, name);\n+    }\n+\n+    public void testCalibration() throws Exception {\n+        createPerfMeter(testName).exec(createPR(calibRenderer));\n+    }\n@@ -786,1 +1529,1 @@\n-        (new PerfMeter(\"FlatOval\")).exec(createPR(flatRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(flatRenderer));\n@@ -790,1 +1533,1 @@\n-        (new PerfMeter(\"FlatOvalAA\")).exec(createPR(flatRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(flatRenderer).configure(AA));\n@@ -794,1 +1537,1 @@\n-        (new PerfMeter(\"ClipFlatOval\")).exec(createPR(clipFlatRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(clipFlatRenderer));\n@@ -798,1 +1541,1 @@\n-        (new PerfMeter(\"ClipFlatOvalAA\")).exec(createPR(clipFlatRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(clipFlatRenderer).configure(AA));\n@@ -802,1 +1545,1 @@\n-        (new PerfMeter(\"FlatBox\")).exec(createPR(flatBoxRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(flatBoxRenderer));\n@@ -806,1 +1549,1 @@\n-        (new PerfMeter(\"FlatBoxAA\")).exec(createPR(flatBoxRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(flatBoxRenderer).configure(AA));\n@@ -810,1 +1553,1 @@\n-        (new PerfMeter(\"ClipFlatBox\")).exec(createPR(clipFlatBoxParticleRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(clipFlatBoxParticleRenderer));\n@@ -814,1 +1557,1 @@\n-        (new PerfMeter(\"ClipFlatBoxAA\")).exec(createPR(clipFlatBoxParticleRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(clipFlatBoxParticleRenderer).configure(AA));\n@@ -818,1 +1561,1 @@\n-        (new PerfMeter(\"Image\")).exec(createPR(imgRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(imgRenderer));\n@@ -822,1 +1565,9 @@\n-        (new PerfMeter(\"ImageAA\")).exec(createPR(imgRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(imgRenderer).configure(AA));\n+    }\n+\n+    public void testVolImage() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgRenderer));\n+    }\n+\n+    public void testVolImageAA() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgRenderer).configure(AA));\n@@ -826,1 +1577,1 @@\n-        (new PerfMeter(\"RotatedBox\")).exec(createPR(flatBoxRotRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(flatBoxRotRenderer));\n@@ -830,1 +1581,1 @@\n-        (new PerfMeter(\"RotatedBoxAA\")).exec(createPR(flatBoxRotRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(flatBoxRotRenderer).configure(AA));\n@@ -834,1 +1585,1 @@\n-        (new PerfMeter(\"RotatedOval\")).exec(createPR(flatOvalRotRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(flatOvalRotRenderer));\n@@ -838,1 +1589,1 @@\n-        (new PerfMeter(\"RotatedOvalAA\")).exec(createPR(flatOvalRotRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(flatOvalRotRenderer).configure(AA));\n@@ -842,1 +1593,1 @@\n-        (new PerfMeter(\"LinGrad3RotatedOval\")).exec(createPR(linGrad3OvalRotRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(linGrad3OvalRotRenderer));\n@@ -846,1 +1597,1 @@\n-        (new PerfMeter(\"LinGrad3RotatedOvalAA\")).exec(createPR(linGrad3OvalRotRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(linGrad3OvalRotRenderer).configure(AA));\n@@ -850,1 +1601,1 @@\n-        (new PerfMeter(\"RadGrad3RotatedOval\")).exec(createPR(radGrad3OvalRotRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(radGrad3OvalRotRenderer));\n@@ -854,1 +1605,1 @@\n-        (new PerfMeter(\"RadGrad3RotatedOvalAA\")).exec(createPR(radGrad3OvalRotRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(radGrad3OvalRotRenderer).configure(AA));\n@@ -858,1 +1609,1 @@\n-        (new PerfMeter(\"LinGradRotatedOval\")).exec(createPR(linGradOvalRotRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(linGradOvalRotRenderer));\n@@ -862,1 +1613,1 @@\n-        (new PerfMeter(\"LinGradRotatedOvalAA\")).exec(createPR(linGradOvalRotRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(linGradOvalRotRenderer).configure(AA));\n@@ -866,1 +1617,1 @@\n-        (new PerfMeter(\"WiredBubbles\")).exec(createPR(wiredRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(wiredRenderer));\n@@ -870,1 +1621,1 @@\n-        (new PerfMeter(\"WiredBubblesAA\")).exec(createPR(wiredRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(wiredRenderer).configure(AA));\n@@ -874,1 +1625,1 @@\n-        (new PerfMeter(\"WiredBox\")).exec(createPR(wiredBoxRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(wiredBoxRenderer));\n@@ -878,1 +1629,1 @@\n-        (new PerfMeter(\"WiredBoxAA\")).exec(createPR(wiredBoxRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(wiredBoxRenderer).configure(AA));\n@@ -882,1 +1633,1 @@\n-        (new PerfMeter(\"Lines\")).exec(createPR(segRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(segRenderer));\n@@ -886,1 +1637,1 @@\n-        (new PerfMeter(\"LinesAA\")).exec(createPR(segRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(segRenderer).configure(AA));\n@@ -890,1 +1641,1 @@\n-        (new PerfMeter(\"FlatQuad\")).exec(createPR(flatQuadRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(flatQuadRenderer));\n@@ -894,1 +1645,1 @@\n-        (new PerfMeter(\"FlatQuadAA\")).exec(createPR(flatQuadRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(flatQuadRenderer).configure(AA));\n@@ -898,1 +1649,1 @@\n-        (new PerfMeter(\"WiredQuad\")).exec(createPR(wiredQuadRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(wiredQuadRenderer));\n@@ -902,1 +1653,1 @@\n-        (new PerfMeter(\"WiredQuadAA\")).exec(createPR(wiredQuadRenderer).configure(AA)).report();\n+        createPerfMeter(testName).exec(createPR(wiredQuadRenderer).configure(AA));\n@@ -906,1 +1657,1 @@\n-        (new PerfMeter(\"TextNoAA\")).exec(createPR(textRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(textRenderer));\n@@ -910,1 +1661,1 @@\n-        (new PerfMeter(\"TextLCD\")).exec(createPR(textRenderer).configure(TextLCD)).report();\n+        createPerfMeter(testName).exec(createPR(textRenderer).configure(TextLCD));\n@@ -914,1 +1665,1 @@\n-        (new PerfMeter(\"TextGray\")).exec(createPR(textRenderer).configure(TextAA)).report();\n+        createPerfMeter(testName).exec(createPR(textRenderer).configure(TextAA));\n@@ -918,1 +1669,1 @@\n-        (new PerfMeter(\"LargeTextNoAA\")).exec(createPR(largeTextRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(largeTextRenderer));\n@@ -922,1 +1673,1 @@\n-        (new PerfMeter(\"LargeTextLCD\")).exec(createPR(largeTextRenderer).configure(TextLCD)).report();\n+        createPerfMeter(testName).exec(createPR(largeTextRenderer).configure(TextLCD));\n@@ -926,1 +1677,1 @@\n-        (new PerfMeter(\"LargeTextGray\")).exec(createPR(largeTextRenderer).configure(TextAA)).report();\n+        createPerfMeter(testName).exec(createPR(largeTextRenderer).configure(TextAA));\n@@ -928,0 +1679,1 @@\n+\n@@ -929,1 +1681,1 @@\n-        (new PerfMeter(\"WhiteTextNoAA\")).exec(createPR(whiteTextRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(whiteTextRenderer));\n@@ -933,1 +1685,1 @@\n-        (new PerfMeter(\"WhiteTextLCD\")).exec(createPR(whiteTextRenderer).configure(TextLCD)).report();\n+        createPerfMeter(testName).exec(createPR(whiteTextRenderer).configure(TextLCD));\n@@ -937,1 +1689,1 @@\n-        (new PerfMeter(\"WhiteTextGray\")).exec(createPR(whiteTextRenderer).configure(TextAA)).report();\n+        createPerfMeter(testName).exec(createPR(whiteTextRenderer).configure(TextAA));\n@@ -941,1 +1693,1 @@\n-        (new PerfMeter(\"ArgbSwBlitImage\")).exec(createPR(argbSwBlitImageRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(argbSwBlitImageRenderer));\n@@ -945,1 +1697,1 @@\n-        (new PerfMeter(\"BgrSwBlitImage\")).exec(createPR(bgrSwBlitImageRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(bgrSwBlitImageRenderer));\n@@ -949,1 +1701,1 @@\n-        (new PerfMeter(\"ArgbSurfaceBlitImageRenderer\")).exec(createPR(argbSurfaceBlitImageRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(argbSurfaceBlitImageRenderer));\n@@ -953,1 +1705,1 @@\n-        (new PerfMeter(\"BgrSurfaceBlitImage\")).exec(createPR(bgrSurfaceBlitImageRenderer)).report();\n+        createPerfMeter(testName).exec(createPR(bgrSurfaceBlitImageRenderer));\n@@ -956,0 +1708,1 @@\n+    \/\/ XOR mode:\n@@ -957,1 +1710,1 @@\n-        (new PerfMeter(\"FlatOval_XOR\")).exec(createPR(flatRenderer).configure(XORMode)).report();\n+        createPerfMeter(testName).exec(createPR(flatRenderer).configure(XORMode));\n@@ -961,1 +1714,1 @@\n-        (new PerfMeter(\"RotatedBox_XOR\")).exec(createPR(flatBoxRotRenderer).configure(XORMode)).report();\n+        createPerfMeter(testName).exec(createPR(flatBoxRotRenderer).configure(XORMode));\n@@ -965,1 +1718,1 @@\n-        (new PerfMeter(\"Lines_XOR\")).exec(createPR(segRenderer).configure(XORMode)).report();\n+        createPerfMeter(testName).exec(createPR(segRenderer).configure(XORMode));\n@@ -969,1 +1722,1 @@\n-        (new PerfMeter(\"Image_XOR\")).exec(createPR(imgRenderer).configure(XORMode)).report();\n+        createPerfMeter(testName).exec(createPR(imgRenderer).configure(XORMode));\n@@ -973,1 +1726,1 @@\n-        (new PerfMeter(\"TextNoAA_XOR\")).exec(createPR(textRenderer).configure(XORMode)).report();\n+        createPerfMeter(testName).exec(createPR(textRenderer).configure(XORMode));\n@@ -977,1 +1730,101 @@\n-        (new PerfMeter(\"TextLCD_XOR\")).exec(createPR(textRenderer).configure(XORModeLCDText)).report();\n+        createPerfMeter(testName).exec(createPR(textRenderer).configure(XORModeLCDText));\n+    }\n+\n+    \/\/ Mixed\/Batched mode:\n+    public void testTextWiredQuadBat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(textWiredQuadBatchedRenderer));\n+    }\n+\n+    public void testTextWiredQuadMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(textWiredQuadMixedRenderer));\n+    }\n+\n+    public void testTextWiredQuadAABat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(textWiredQuadBatchedRenderer).configure(AA));\n+    }\n+\n+    public void testTextWiredQuadAAMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(textWiredQuadMixedRenderer).configure(AA));\n+    }\n+\n+    public void testVolImageFlatBoxBat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgFlatBoxBatchedRenderer));\n+    }\n+\n+    public void testVolImageFlatBoxMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgFlatBoxMixedRenderer));\n+    }\n+\n+    public void testVolImageFlatBoxAABat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgFlatBoxBatchedRenderer).configure(AA));\n+    }\n+\n+    public void testVolImageFlatBoxAAMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgFlatBoxMixedRenderer).configure(AA));\n+    }\n+\n+    public void testVolImageWiredQuadBat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgWiredQuadBatchedRenderer));\n+    }\n+\n+    public void testVolImageWiredQuadMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgWiredQuadMixedRenderer));\n+    }\n+\n+    public void testVolImageWiredQuadAABat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgWiredQuadBatchedRenderer).configure(AA));\n+    }\n+\n+    public void testVolImageWiredQuadAAMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgWiredQuadMixedRenderer).configure(AA));\n+    }\n+\n+    public void testVolImageTextNoAABat() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgTextBatchedRenderer));\n+    }\n+\n+    public void testVolImageTextNoAAMix() throws Exception {\n+        createPerfMeter(testName).exec(createPR(volImgTextMixedRenderer));\n+    }\n+\n+    private static void help() {\n+        System.out.print(\"##############################################################\\n\");\n+        System.out.printf(\"# %s\\n\", VERSION);\n+        System.out.print(\"##############################################################\\n\");\n+        System.out.println(\"# java ... RenderPerfTest <args>\");\n+        System.out.println(\"#\");\n+        System.out.println(\"# Supported Arguments <args>:\");\n+        System.out.println(\"#\");\n+        System.out.println(\"# -h         : display this help\");\n+        System.out.println(\"# -v         : set verbose outputs\");\n+        System.out.println(\"# -e<mode>   : set execution mode (default: \" + EXEC_MODE_DEFAULT + \") among \" + EXEC_MODES);\n+        System.out.println(\"#\");\n+        System.out.println(\"# -f         : use FPS unit (default)\");\n+        System.out.println(\"# -t         : use TIME(ms) unit\");\n+        System.out.println(\"#\");\n+        System.out.println(\"# -l         : list available graphics configurations\");\n+        System.out.println(\"# -g=all|0:0,0:1... : use all or specific graphics configurations\");\n+        System.out.println(\"#\");\n+        System.out.println(\"# -w<number> : use number of test frames (default: 1)\");\n+        System.out.println(\"#\");\n+        System.out.println(\"# -n<number> : set number of primitives (default: \" + N_DEFAULT + \")\");\n+        System.out.println(\"# -r<number> : set number of test repeats (default: 1)\");\n+        System.out.println(\"#\");\n+        System.out.print(\"# Test arguments: \");\n+\n+        final ArrayList<Method> testCases = new ArrayList<>();\n+        for (Method m : RenderPerfTest.class.getDeclaredMethods()) {\n+            if (m.getName().startsWith(\"test\") && !ignoredTests.contains(m.getName())) {\n+                testCases.add(m);\n+            }\n+        }\n+        testCases.sort(Comparator.comparing(Method::getName));\n+        for (Method m : testCases) {\n+            System.out.print(extractTestName(m));\n+            System.out.print(\" \");\n+        }\n+        System.out.println();\n+    }\n+\n+    private static String extractTestName(final Method m) {\n+        return m.getName().substring(\"test\".length());\n@@ -981,12 +1834,53 @@\n-            throws InvocationTargetException, IllegalAccessException, NoSuchMethodException\n-    {\n-        RenderPerfTest test = new RenderPerfTest();\n-\n-        if (args.length > 0) {\n-            for (String testCase : args) {\n-                Method m = RenderPerfTest.class.getDeclaredMethod(\"test\" + testCase);\n-                m.invoke(test);\n-            }\n-        } else {\n-            Method[] methods = RenderPerfTest.class.getDeclaredMethods();\n-            for (Method m : methods) {\n+            throws NoSuchMethodException, NumberFormatException {\n+        \/\/ Set the default locale to en-US locale (for Numerical Fields \".\" \",\")\n+        Locale.setDefault(Locale.US);\n+\n+        boolean help = false;\n+        final ArrayList<Method> testCases = new ArrayList<>();\n+\n+        for (String arg : args) {\n+            if (arg.length() >= 2) {\n+                if (arg.startsWith(\"-\")) {\n+                    switch (arg.substring(1, 2)) {\n+                        case \"e\":\n+                            EXEC_MODE = arg.substring(2).toLowerCase();\n+                            break;\n+                        case \"f\":\n+                            USE_FPS = true;\n+                            break;\n+                        case \"g\":\n+                            GC_MODE = arg.substring(3).toLowerCase();\n+                            break;\n+                        case \"h\":\n+                            help = true;\n+                            break;\n+                        case \"l\":\n+                            VERBOSE_GRAPHICS_CONFIG = true;\n+                            break;\n+                        case \"t\":\n+                            USE_FPS = false;\n+                            break;\n+                        case \"n\":\n+                            N = Integer.parseInt(arg.substring(2));\n+                            break;\n+                        case \"r\":\n+                            REPEATS = Integer.parseInt(arg.substring(2));\n+                            break;\n+                        case \"v\":\n+                            VERBOSE = true;\n+                            break;\n+                        case \"w\":\n+                            NW = Integer.parseInt(arg.substring(2));\n+                            break;\n+                        default:\n+                            System.err.println(\"Unsupported argument '\" + arg + \"' !\");\n+                            help = true;\n+                    }\n+                } else {\n+                    Method m = RenderPerfTest.class.getDeclaredMethod(\"test\" + arg);\n+                    testCases.add(m);\n+                }\n+            }\n+        }\n+        if (testCases.isEmpty()) {\n+            for (Method m : RenderPerfTest.class.getDeclaredMethods()) {\n@@ -994,1 +1888,76 @@\n-                    m.invoke(test);\n+                    testCases.add(m);\n+                }\n+            }\n+            testCases.sort(Comparator.comparing(Method::getName));\n+        }\n+\n+        if (CALIBRATION) {\n+            Method m = RenderPerfTest.class.getDeclaredMethod(\"testCalibration\");\n+            testCases.add(0, m); \/\/ first\n+        }\n+\n+        if (VERBOSE) {\n+            System.out.print(\"##############################################################\\n\");\n+            System.out.printf(\"# %s\\n\", VERSION);\n+            System.out.print(\"##############################################################\\n\");\n+            System.out.printf(\"# Java: %s\\n\", System.getProperty(\"java.runtime.version\"));\n+            System.out.printf(\"#   VM: %s %s (%s)\\n\", System.getProperty(\"java.vm.name\"), System.getProperty(\"java.vm.version\"), System.getProperty(\"java.vm.info\"));\n+            System.out.printf(\"#   OS: %s %s (%s)\\n\", System.getProperty(\"os.name\"), System.getProperty(\"os.version\"), System.getProperty(\"os.arch\"));\n+            System.out.printf(\"# CPUs: %d (virtual)\\n\", Runtime.getRuntime().availableProcessors());\n+            System.out.print(\"##############################################################\\n\");\n+            System.out.printf(\"# AWT Toolkit   :             %s \\n\", TOOLKIT.getClass().getSimpleName());\n+            System.out.printf(\"# Execution mode:             %s\\n\", EXEC_MODE);\n+            System.out.printf(\"# GraphicsConfiguration mode: %s\\n\", GC_MODE);\n+            System.out.printf(\"# Repeats: %d\\n\", REPEATS);\n+            System.out.printf(\"# NW:      %d\\n\", NW);\n+            System.out.printf(\"# N:       %d\\n\", N);\n+            System.out.printf(\"# Unit:    %s\\n\", USE_FPS ? \"FPS\" : \"TIME(ms)\");\n+            System.out.print(\"##############################################################\\n\");\n+        }\n+\n+        \/\/ Graphics Configuration handling:\n+        final Map<String, GraphicsConfiguration> gcByID = new LinkedHashMap<>();\n+        final Map<GraphicsConfiguration, String> idByGC = new HashMap<>();\n+\n+        final GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        final GraphicsDevice[] gds = ge.getScreenDevices();\n+\n+        if (VERBOSE_GRAPHICS_CONFIG) {\n+            System.out.println(\"Available GraphicsDevice(s) and their GraphicsConfiguration(s):\");\n+        }\n+\n+        for (int gdIdx = 0; gdIdx < gds.length; gdIdx++) {\n+            final GraphicsDevice gd = gds[gdIdx];\n+            if (VERBOSE_GRAPHICS_CONFIG) {\n+                System.out.println(\"[\" + gdIdx + \"] = GraphicsDevice[\" + gd.getIDstring() + \"]\");\n+            }\n+\n+            final GraphicsConfiguration[] gcs = gd.getConfigurations();\n+\n+            for (int gcIdx = 0; gcIdx < gcs.length; gcIdx++) {\n+                final GraphicsConfiguration gc = gcs[gcIdx];\n+                final String gcId = gdIdx + \":\" + gcIdx;\n+                gcByID.put(gcId, gc);\n+                idByGC.put(gc, gcId);\n+                if (VERBOSE_GRAPHICS_CONFIG) {\n+                    System.out.println(\"- [\" + gcId + \"] = GraphicsConfiguration[\" + gc + \"] bounds:\" + gc.getBounds());\n+                }\n+            }\n+        }\n+\n+        final Set<GraphicsConfiguration> gcSet = new LinkedHashSet<>();\n+\n+        if (GC_MODE != null) {\n+            if (!GC_MODE_DEF.equals(GC_MODE)) {\n+                if (GC_MODE_ALL.equals(GC_MODE)) {\n+                    gcSet.addAll(gcByID.values());\n+                } else {\n+                    for (String gcKey : GC_MODE.split(\",\")) {\n+                        final GraphicsConfiguration gc = gcByID.get(gcKey);\n+                        if (gc != null) {\n+                            gcSet.add(gc);\n+                        } else {\n+                            System.err.println(\"Bad GraphicsConfiguration identifier [x:y] where x is GraphicsDevice ID \" +\n+                                    \"and y GraphicsConfiguration ID : [\" + gcKey + \"] ! (available values: \" + gcByID.keySet() + \")\");\n+                        }\n+                    }\n@@ -998,0 +1967,206 @@\n+        if (gcSet.isEmpty()) {\n+            final GraphicsDevice gdDef = ge.getDefaultScreenDevice();\n+            final GraphicsConfiguration gcDef = gdDef.getDefaultConfiguration();\n+            final String gcId = idByGC.get(gcDef);\n+\n+            if (VERBOSE_GRAPHICS_CONFIG) {\n+                System.out.println(\"Using default [\" + gcId + \"] = GraphicsConfiguration[\" + gcDef + \"] bounds:\" + gcDef.getBounds());\n+            }\n+            gcSet.add(gcDef);\n+        }\n+\n+        final List<GraphicsConfiguration> gcList = new ArrayList<>(gcSet);\n+        final int NGC = gcList.size();\n+\n+        System.out.print(\"Using GraphicsConfiguration(s): \");\n+        for (GraphicsConfiguration gc : gcList) {\n+            final String gcId = idByGC.get(gc);\n+            System.out.print(\"[\" + gcId + \"][\" + gc + \"]\");\n+            System.out.print(\" \");\n+        }\n+        System.out.println();\n+\n+        final List<RenderPerfTest> instances = new ArrayList<>();\n+        int retCode = 0;\n+        try {\n+            if (help) {\n+                help();\n+            } else {\n+                final List<Thread> threads = new ArrayList<>();\n+\n+                for (int i = 0; i < NGC; i++) {\n+                    final GraphicsConfiguration gc = gcList.get(i);\n+\n+                    for (int j = 0; j < NW; j++) {\n+                        final RenderPerfTest rp = new RenderPerfTest(gc);\n+                        instances.add(rp);\n+                        threads.add(rp.createThreadTests(threads.size() + 1, j + 1, testCases));\n+                    }\n+                }\n+                if (TRACE_SYNC) traceSync(\"testCount: \" + testCount);\n+\n+                initThreads(threads.size());\n+                initBarrierStart();\n+\n+                for (Thread thread : threads) {\n+                    if (TRACE_SYNC) traceSync(thread.getName() + \" starting...\");\n+                    thread.start();\n+                }\n+\n+                for (int n = 0; n < testCount; n++) {\n+                    if (VERBOSE) {\n+                        final int k = n \/ REPEATS;\n+                        final String methodName = extractTestName(testCases.get(k));\n+                        System.out.println(\"--- Test [\" + (n + 1) + \" \/ \" + testCount + \"] = \" + methodName + \" ---\");\n+                    }\n+\n+                    \/\/ reset stop barrier (to be ready):\n+                    initBarrierStop();\n+\n+                    if (TRACE_SYNC) traceSync(\"Waiting \" + threadCount + \" threads to be ready...\");\n+                    readyCount.await();\n+\n+                    if (TRACE_SYNC)\n+                        traceSync(\"Threads are ready => starting benchmark on \" + threadCount + \" threads now\");\n+                    triggerStart.countDown();\n+\n+                    \/\/ reset done barrier (to be ready):\n+                    initBarrierDone();\n+\n+                    if (TRACE_SYNC) traceSync(\"Waiting \" + threadCount + \" threads to complete benchmark...\");\n+                    completedCount.await();\n+\n+                    if (TRACE_SYNC)\n+                        traceSync(\"Test completed on \" + threadCount + \" threads => stopping benchmark on all threads now\");\n+                    triggerStop.countDown();\n+\n+                    \/\/ reset start barrier (to be ready):\n+                    initBarrierStart();\n+\n+                    if (TRACE_SYNC) traceSync(\"Waiting \" + threadCount + \" threads to exit test...\");\n+                    doneCount.await();\n+\n+                    if (TRACE_SYNC)\n+                        traceSync(\"Test exited on \" + threadCount + \" threads => finalize benchmark on all threads now\");\n+                    triggerExit.countDown();\n+                }\n+\n+                for (Thread thread : threads) {\n+                    thread.join();\n+                    if (TRACE_SYNC) traceSync(thread.getName() + \" terminated\");\n+                }\n+            }\n+        } catch (Throwable th) {\n+            System.err.println(\"Exception occurred during :\");\n+            th.printStackTrace(System.err);\n+            retCode = 1;\n+        } finally {\n+            for (RenderPerfTest rp : instances) {\n+                try {\n+                    rp.fh.hideFrameAndWait();\n+                } catch (Throwable th) {\n+                    System.err.println(\"Exception occurred in hideFrameAndWait():\");\n+                    th.printStackTrace(System.err);\n+                    retCode = 1;\n+                }\n+            }\n+            \/\/ ensure jvm shutdown now (wayland)\n+            System.exit(retCode);\n+        }\n+    }\n+\n+    \/\/ thread synchronization\n+\n+    private static int threadCount = 0;\n+\n+    private static int testCount = 0;\n+    private static volatile String testName = null;\n+\n+    private static volatile CountDownLatch readyCount = null;\n+    private static volatile CountDownLatch triggerStart = null;\n+\n+    private static volatile CountDownLatch completedCount = null;\n+    private static volatile CountDownLatch triggerStop = null;\n+\n+    private static volatile CountDownLatch doneCount = null;\n+    private static volatile CountDownLatch triggerExit = null;\n+\n+    static void traceSync(final String msg) {\n+        System.out.println(\"[\" + System.nanoTime() + \"] \" + msg);\n+    }\n+\n+    private static void initThreads(int count) {\n+        threadCount = count;\n+        if (TRACE_SYNC) traceSync(\"initThreads(): threadCount: \" + threadCount);\n+    }\n+\n+    private static void initBarrierStart() {\n+        readyCount = new CountDownLatch(threadCount);\n+        triggerStart = new CountDownLatch(1);\n+    }\n+\n+    private static void initBarrierStop() {\n+        completedCount = new CountDownLatch(threadCount);\n+        triggerStop = new CountDownLatch(1);\n+    }\n+\n+    private static void initBarrierDone() {\n+        doneCount = new CountDownLatch(threadCount);\n+        triggerExit = new CountDownLatch(1);\n+    }\n+\n+    public Thread createThreadTests(final int threadId, final int frameId,\n+                                    final ArrayList<Method> testCases) throws Exception {\n+        fh.setIds(threadId, frameId);\n+\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                fh.prepareFrameEDT(VERSION + \" [\" + fh.threadId + \"]\");\n+\n+                final JLabel label = new JLabel((DELAY_START) ? \"Waiting 3s before starting benchmark...\" : \"Starting benchmark...\");\n+                label.setForeground(Color.WHITE);\n+\n+                final JPanel panel = new JPanel();\n+                panel.add(label);\n+\n+                fh.showFrameEDT(panel);\n+            }\n+        });\n+\n+        \/\/ Wait frame to be shown:\n+        fh.waitFrameShown();\n+\n+        \/\/ Set test count per thread:\n+        testCount = testCases.size() * REPEATS;\n+\n+        final RenderPerfTest rp = this;\n+        return new Thread(\"RenderPerfThread[\" + threadId + \"]\") {\n+            @Override\n+            public void run() {\n+                if (DELAY_START) {\n+                    RenderPerfTest.sleep(3000);\n+                }\n+                try {\n+                    for (Method m : testCases) {\n+                        for (int i = 0; i < REPEATS; i++) {\n+                            testName = extractTestName(m);\n+                            m.invoke(rp);\n+                        }\n+                    }\n+                } catch (Throwable th) {\n+                    System.err.println(\"Exception occurred in RenderPerfThread[\" + threadId + \"]:\");\n+                    th.printStackTrace(System.err);\n+                }\n+            }\n+        };\n+    }\n+\n+    private static void sleep(long millis) {\n+        if (millis > 0) {\n+            try {\n+                Thread.sleep(millis);\n+            } catch (InterruptedException ie) {\n+                ie.printStackTrace(System.err);\n+            }\n+        }\n","filename":"test\/jdk\/performance\/client\/RenderPerfTest\/src\/renderperf\/RenderPerfTest.java","additions":1472,"deletions":297,"binary":false,"changes":1769,"status":"modified"}]}