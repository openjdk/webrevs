{"files":[{"patch":"@@ -38,0 +38,4 @@\n+import java.lang.invoke.VarHandle;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n@@ -40,0 +44,1 @@\n+import java.util.concurrent.locks.LockSupport;\n@@ -41,0 +46,1 @@\n+import java.util.stream.IntStream;\n@@ -50,0 +56,2 @@\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n@@ -274,0 +282,37 @@\n+    private static final VarHandle LONG_HANDLE = JAVA_LONG.varHandle();\n+\n+    \/**\n+     * The objective of this test is to try to provoke a situation where threads are\n+     * competing to use allocated pooled memory and then trying to make sure no thread\n+     * can see the same shared memory another thread is using.\n+     *\/\n+    @Test\n+    void stress() throws InterruptedException {\n+        \/\/ Just use one pool variant as testing here is fairly expensive.\n+        final CarrierLocalArenaPools pool = pools().limit(1).findFirst().orElseThrow();\n+        \/\/ Make sure it works for both virtual and platform threads (as they are handled differently)\n+        for (var threadBuilder : List.of(Thread.ofVirtual(), Thread.ofPlatform())) {\n+            final Thread[] threads = IntStream.range(0, 1024).mapToObj(_ ->\n+                    threadBuilder.start(() -> {\n+                        final long threadId = Thread.currentThread().threadId();\n+                        while (!Thread.interrupted()) {\n+                            for (int i = 0; i < 1_000_000; i++) {\n+                                try (Arena arena = pool.take()) {\n+                                    \/\/ Try to assert no two threads get allocated the same memory region.\n+                                    final MemorySegment segment = arena.allocate(JAVA_LONG);\n+                                    LONG_HANDLE.setVolatile(segment, 0L, threadId);\n+                                    assertEquals(threadId, (long) LONG_HANDLE.getVolatile(segment, 0L));\n+                                }\n+                            }\n+                            Thread.yield(); \/\/ make sure the driver thread gets a chance.\n+                        }\n+                    })).toArray(Thread[]::new);\n+            Thread.sleep(Duration.of(5, SECONDS));\n+            Arrays.stream(threads).forEach(\n+                    thread -> {\n+                        assertTrue(thread.isAlive());\n+                        thread.interrupt();\n+                    });\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestCarrierLocalArenaPools.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"}]}