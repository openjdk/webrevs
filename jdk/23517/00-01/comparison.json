{"files":[{"patch":"@@ -38,1 +38,0 @@\n-import java.util.HashMap;\n@@ -41,1 +40,2 @@\n-import java.util.stream.Collectors;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n@@ -43,0 +43,4 @@\n+\/**\n+ * An internal utility class that can be used to adapt system-call-styled method handles\n+ * for efficient and easy use.\n+ *\/\n@@ -45,3 +49,2 @@\n-    private static final MemoryLayout CAPTURE_LAYOUT = Linker.Option.captureStateLayout();\n-    \/\/private static final CarrierLocalArenaPools POOL = CarrierLocalArenaPools.create(CAPTURE_LAYOUT);\n-    private static final CarrierLocalArenaPools POOL = CarrierLocalArenaPools.create(16);\n+    private static final StructLayout CAPTURE_LAYOUT = Linker.Option.captureStateLayout();\n+    private static final CarrierLocalArenaPools POOL = CarrierLocalArenaPools.create(CAPTURE_LAYOUT);\n@@ -51,0 +54,2 @@\n+    \/\/ The method handles below are bound to static methods residing in this class\n+\n@@ -87,37 +92,34 @@\n-    \/\/ (int.class | long.class) ->\n-    \/\/   ({\"GetLastError\" | \"WSAGetLastError\"} | \"errno\") ->\n-    \/\/     MethodHandle\n-    private static final Map<Class<?>, Map<String, MethodHandle>> INNER_HANDLES;\n-\n-    static {\n-\n-        final StructLayout stateLayout = Linker.Option.captureStateLayout();\n-        final Map<Class<?>, Map<String, MethodHandle>> classMap = new HashMap<>();\n-        for (var returnType : new Class<?>[]{int.class, long.class}) {\n-            Map<String, MethodHandle> handles = stateLayout\n-                    .memberLayouts().stream()\n-                    .collect(Collectors.toUnmodifiableMap(\n-                            member -> member.name().orElseThrow(),\n-                            member -> {\n-                                VarHandle vh = stateLayout.varHandle(MemoryLayout.PathElement.groupElement(member.name().orElseThrow()));\n-                                \/\/ (MemorySegment, long)int\n-                                MethodHandle intExtractor = vh.toMethodHandle(VarHandle.AccessMode.GET);\n-                                \/\/ (MemorySegment)int\n-                                intExtractor = MethodHandles.insertArguments(intExtractor, 1, 0L);\n-\n-                                if (returnType.equals(int.class)) {\n-                                    \/\/ (int, MemorySegment)int\n-                                    return MethodHandles.guardWithTest(\n-                                            NON_NEGATIVE_INT_MH,\n-                                            SUCCESS_INT_MH,\n-                                            ERROR_INT_MH.bindTo(intExtractor));\n-                                } else {\n-                                    \/\/ (long, MemorySegment)long\n-                                    return MethodHandles.guardWithTest(\n-                                            NON_NEGATIVE_LONG_MH,\n-                                            SUCCESS_LONG_MH,\n-                                            ERROR_LONG_MH.bindTo(intExtractor));\n-                                }\n-                            }\n-                    ));\n-            classMap.put(returnType, handles);\n+    \/\/ The `BASIC_HANDLE_CACHE` contains the common \"basic handles\" that can be reused for\n+    \/\/ all adapted method handles. Keeping as much as possible reusable reduces the number\n+    \/\/ of combinators needed to form an adapted method handle.\n+    \/\/ The map is lazily computed.\n+    \/\/\n+    private static final Map<BasicKey, MethodHandle> BASIC_HANDLE_CACHE =\n+            new ConcurrentHashMap<>();\n+\n+    \/\/ A key that holds both the `returnType` and the `stateName` needed to look up a\n+    \/\/ specific \"basic handle\" in the `BASIC_HANDLE_CACHE`.\n+    \/\/   returnType E {int.class | long.class}\n+    \/\/   stateName can be anything non-null but should E {\"GetLastError\" | \"WSAGetLastError\"} | \"errno\")}\n+    record BasicKey(Class<?> returnType, String stateName) {\n+\n+        BasicKey(MethodHandle target, String stateName) {\n+            this(returnType(target), Objects.requireNonNull(stateName));\n+        }\n+\n+        static Class<?> returnType(MethodHandle target) {\n+            \/\/ Implicit null check\n+            final Class<?> returnType = target.type().returnType();\n+\n+            if (!(returnType.equals(int.class) || returnType.equals(long.class))) {\n+                throw illegalArgDoesNot(target, \"return an int or a long\");\n+            }\n+            if (target.type().parameterCount() == 0 || target.type().parameterType(0) != MemorySegment.class) {\n+                throw illegalArgDoesNot(target, \"have a MemorySegment as the first parameter\");\n+            }\n+            return returnType;\n+        }\n+\n+        private static IllegalArgumentException illegalArgDoesNot(MethodHandle target, String info) {\n+            return new IllegalArgumentException(\"The provided target \" + target\n+                    + \" does not \" + info);\n@@ -125,2 +127,0 @@\n-        INNER_HANDLES = Map.copyOf(classMap);\n-    }\n@@ -128,1 +128,0 @@\n-    private CaptureStateUtil() {\n@@ -131,0 +130,2 @@\n+    private CaptureStateUtil() {}\n+\n@@ -133,2 +134,3 @@\n-     *          directly returns the same value as the {@code target} if it is\n-     *          non-negative, otherwise returns the negated errno}\n+     * directly returns the same value as the {@code target} if it is non-negative,\n+     * otherwise returns the negated captured state defined by the provided\n+     * {@code stateName}}\n@@ -144,1 +146,2 @@\n-     *      static final MethodHandle OPEN = CaptureStateUtil.adaptSystemCall(Pooling.GLOBAL, CAPTURING_OPEN, \"errno\");\n+     *      static final MethodHandle OPEN = CaptureStateUtil\n+     *             .adaptSystemCall(CAPTURING_OPEN, \"errno\");\n@@ -147,1 +150,1 @@\n-     *         int fh = (int)OPEN.invoke(pathName, flags);\n+     *         int fh = (int)OPEN.invokeExact(pathName, flags);\n@@ -157,2 +160,0 @@\n-     * For a method handle that takes a MemorySegment and two int parameters using GLOBAL,\n-     * the method combinators are doing the equivalent of:\n@@ -160,0 +161,4 @@\n+     * For a {@code target} method handle that takes a {@code MemorySegment} and two\n+     * {@code int} parameters and returns an {@code int} value, the method returns a new\n+     * method handle that is doing the equivalent of:\n+     * <p>\n@@ -161,5 +166,17 @@\n-     *         public int invoke(int a, int b) {\n-     *             final MemorySegment segment = acquireSegment();\n-     *             final int result = (int) handle.invoke(segment, a, b);\n-     *             if (result >= 0) {\n-     *                 return result;\n+     *         private static final MemoryLayout CAPTURE_LAYOUT =\n+     *                 Linker.Option.captureStateLayout();\n+     *         private static final CarrierLocalArenaPools POOL =\n+     *                 CarrierLocalArenaPools.create(CAPTURE_LAYOUT);\n+     *\n+     *         public int invoke(MethodHandle target,\n+     *                           String stateName,\n+     *                           int a, int b) {\n+     *             try (var arena = POOL.take()) {\n+     *                 final MemorySegment segment = arena.allocate(CAPTURE_LAYOUT);\n+     *                 final int result = (int) handle.invoke(segment, a, b);\n+     *                 if (result >= 0) {\n+     *                     return result;\n+     *                 }\n+     *                 return -(int) CAPTURE_LAYOUT\n+     *                     .varHandle(MemoryLayout.PathElement.groupElement(stateName))\n+     *                         .get(segment, 0);\n@@ -167,1 +184,0 @@\n-     *             return -(int) errorHandle.get(segment);\n@@ -170,3 +186,3 @@\n-     * Where {@code handle} is the original method handle with the coordinated\n-     * {@code (MemorySegment, int, int)int} and {@code errnoHandle} is a method handle\n-     * that retrieves the error code from the capturing segment.\n+     * except it is more performant. In the above {@code stateName} is the name of the\n+     * captured state (e.g. {@code errno}). The static {@code CAPTURE_LAYOUT} is shared\n+     * across all target method handles adapted by this method.\n@@ -174,5 +190,4 @@\n-     *\n-     * @param target    method handle that returns an {@code int} or a {@code long} and has\n-     *                  a capturing state MemorySegment as its first parameter\n-     * @param stateName the name of the capturing state member layout\n-     *                  (i.e. \"errno\",\"GetLastError\", or \"WSAGetLastError\")\n+     * @param target    method handle that returns an {@code int} or a {@code long} and\n+     *                  has a capturing state MemorySegment as its first parameter\n+     * @param stateName the name of the capturing state member layout (i.e. \"errno\",\n+     *                  \"GetLastError\", or \"WSAGetLastError\")\n@@ -183,2 +198,2 @@\n-     * @throws IllegalArgumentException if the provided {@code stateName} is unknown\n-     *                                  on the current platform\n+     * @throws IllegalArgumentException if the provided {@code stateName} is unknown on\n+     *                                  the current platform\n@@ -188,10 +203,2 @@\n-        \/\/ Implicit null check\n-        final Class<?> returnType = target.type().returnType();\n-        Objects.requireNonNull(stateName);\n-\n-        if (!(returnType.equals(int.class) || returnType.equals(long.class))) {\n-            throw illegalArgDoesNot(target, \"return an int or a long\");\n-        }\n-        if (target.type().parameterCount() == 0 || target.type().parameterType(0) != MemorySegment.class) {\n-            throw illegalArgDoesNot(target, \"have a MemorySegment as the first parameter\");\n-        }\n+        \/\/ Invariants checked in the BasicKey record\n+        final BasicKey basicKey = new BasicKey(target, stateName);\n@@ -200,10 +207,14 @@\n-        MethodHandle inner = INNER_HANDLES\n-                .get(returnType)\n-                .get(stateName);\n-        if (inner == null) {\n-            throw new IllegalArgumentException(\"Unknown state name: \" + stateName +\n-                    \". Known on this platform: \" + Linker.Option.captureStateLayout());\n-        }\n-\n-        \/\/ Make `target` specific adaptations\n-\n+        final MethodHandle basicHandle = BASIC_HANDLE_CACHE\n+                \/\/ Do not use a lambda in order to allow early use in the init sequence\n+                \/\/ This is equivalent to:\n+                \/\/   computeIfAbsent(basicKey, CaptureStateUtil::basicHandleFor);\n+                .computeIfAbsent(basicKey, new Function<>() {\n+                    @Override\n+                    public MethodHandle apply(BasicKey basicKey) {\n+                        return basicHandleFor(basicKey);\n+                    }\n+                });\n+\n+        \/\/ Make `target` specific adaptations of the basic handle\n+\n+        \/\/ Pre-pend all the parameters from the `target` MH.\n@@ -211,1 +222,1 @@\n-        inner = MethodHandles.collectArguments(inner, 0, target);\n+        MethodHandle innerAdapted = MethodHandles.collectArguments(basicHandle, 0, target);\n@@ -213,1 +224,1 @@\n-        int[] perm = new int[target.type().parameterCount() + 1];\n+        final int[] perm = new int[target.type().parameterCount() + 1];\n@@ -217,0 +228,1 @@\n+        \/\/ Last takes first\n@@ -218,1 +230,1 @@\n-        \/\/ Deduplicate the first and last coordinate and only use the first\n+        \/\/ Deduplicate the first and last coordinate and only use the first one.\n@@ -220,1 +232,3 @@\n-        inner = MethodHandles.permuteArguments(inner, target.type(), perm);\n+        innerAdapted = MethodHandles.permuteArguments(innerAdapted, target.type(), perm);\n+\n+        \/\/ Use an `Arena` for the first argument instead and extract a segment from it.\n@@ -222,1 +236,1 @@\n-        inner = MethodHandles.collectArguments(inner, 0, ALLOCATE_MH);\n+        innerAdapted = MethodHandles.collectArguments(innerAdapted, 0, ALLOCATE_MH);\n@@ -224,0 +238,1 @@\n+        \/\/ Add an identity function for the result of the cleanup action.\n@@ -225,1 +240,3 @@\n-        MethodHandle cleanup = MethodHandles.identity(returnType);\n+        MethodHandle cleanup = MethodHandles.identity(basicKey.returnType());\n+        \/\/ Add a dummy `Throwable` argument for the cleanup action.\n+        \/\/ This means, anything thrown will just be propagated.\n@@ -228,0 +245,3 @@\n+        \/\/ Add the first `Arena` parameter of the `innerAdapted` method handle to the\n+        \/\/ cleanup action and invoke `Arena::close` when it is run. The `cleanup` handle\n+        \/\/ does not have to have all parameters. It can have zero or more.\n@@ -229,1 +249,0 @@\n-        \/\/ Cleanup does not have to have all parameters. It can have zero or more.\n@@ -232,0 +251,1 @@\n+        \/\/ Combine the `innerAdapted` and `cleanup` action into a try\/finally block.\n@@ -233,1 +253,1 @@\n-        MethodHandle tryFinally = MethodHandles.tryFinally(inner, cleanup);\n+        final MethodHandle tryFinally = MethodHandles.tryFinally(innerAdapted, cleanup);\n@@ -235,1 +255,3 @@\n-        \/\/ Finally we arrive at (C1-Cn)(int|long)\n+        \/\/ Acquire the arena from the global pool.\n+        \/\/ With this, we finally arrive at the intended method handle:\n+        \/\/ (C1-Cn)(int|long)\n@@ -239,3 +261,37 @@\n-    private static IllegalArgumentException illegalArgDoesNot(MethodHandle target, String info) {\n-        return new IllegalArgumentException(\"The provided target \" + target\n-                + \" does not \" + info);\n+    private static MethodHandle basicHandleFor(BasicKey basicKey) {\n+        final VarHandle vh = CAPTURE_LAYOUT.varHandle(\n+                MemoryLayout.PathElement.groupElement(basicKey.stateName()));\n+        \/\/ This MH is used to extract the named captured state\n+        \/\/ from the capturing `MemorySegment`.\n+        \/\/ (MemorySegment, long)int\n+        MethodHandle intExtractor = vh.toMethodHandle(VarHandle.AccessMode.GET);\n+        \/\/ As the MH is already adapted to use the appropriate\n+        \/\/ offset, we just insert `0L` for the offset.\n+        \/\/ (MemorySegment)int\n+        intExtractor = MethodHandles.insertArguments(intExtractor, 1, 0L);\n+\n+        \/\/ If X is the `returnType` (either `int` or `long`) then\n+        \/\/ the code below is equivalent to:\n+        \/\/\n+        \/\/ X handle(X returnValue, MemorySegment segment)\n+        \/\/     if (returnValue >= 0) {\n+        \/\/         \/\/ Ignore the segment\n+        \/\/         return returnValue;\n+        \/\/     } else {\n+        \/\/         \/\/ ignore the returnValue\n+        \/\/         return -(X)intExtractor.invokeExact(segment);\n+        \/\/     }\n+        \/\/ }\n+        if (basicKey.returnType().equals(int.class)) {\n+            \/\/ (int, MemorySegment)int\n+            return MethodHandles.guardWithTest(\n+                    NON_NEGATIVE_INT_MH,\n+                    SUCCESS_INT_MH,\n+                    ERROR_INT_MH.bindTo(intExtractor));\n+        } else {\n+            \/\/ (long, MemorySegment)long\n+            return MethodHandles.guardWithTest(\n+                    NON_NEGATIVE_LONG_MH,\n+                    SUCCESS_LONG_MH,\n+                    ERROR_LONG_MH.bindTo(intExtractor));\n+        }\n@@ -264,1 +320,2 @@\n-    private static int success(int value, MemorySegment segment) {\n+    private static int success(int value,\n+                               MemorySegment segment) {\n@@ -269,1 +326,3 @@\n-    private static int error(MethodHandle errorHandle, int value, MemorySegment segment) throws Throwable {\n+    private static int error(MethodHandle errorHandle,\n+                             int value,\n+                             MemorySegment segment) throws Throwable {\n@@ -279,1 +338,2 @@\n-    private static long success(long value, MemorySegment segment) {\n+    private static long success(long value,\n+                                MemorySegment segment) {\n@@ -284,1 +344,3 @@\n-    private static long error(MethodHandle errorHandle, long value, MemorySegment segment) throws Throwable {\n+    private static long error(MethodHandle errorHandle,\n+                              long value,\n+                              MemorySegment segment) throws Throwable {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil.java","additions":165,"deletions":103,"binary":false,"changes":268,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-        assertTrue(wrongCaptureName.getMessage().startsWith(\"Unknown state name: foo\"), wrongCaptureName.getMessage());\n+        assertTrue(wrongCaptureName.getMessage().startsWith(\"Bad layout path: cannot resolve 'foo' in layout [\"), wrongCaptureName.getMessage());\n@@ -127,1 +127,1 @@\n-        assertThrows(NullPointerException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, null));\n+        assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, null));\n","filename":"test\/jdk\/java\/foreign\/TestCaptureStateUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}