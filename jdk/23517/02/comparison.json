{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.NoInitSegmentAllocator;\n@@ -723,2 +724,2 @@\n-        return this instanceof ArenaImpl arenaImpl ?\n-                arenaImpl.allocateNoInit(byteSize, 1) :\n+        return this instanceof NoInitSegmentAllocator noInit ?\n+                noInit.allocateNoInit(byteSize, 1) :\n@@ -730,2 +731,2 @@\n-        return this instanceof ArenaImpl arenaImpl ?\n-                arenaImpl.allocateNoInit(layout.byteSize(), layout.byteAlignment()) :\n+        return this instanceof NoInitSegmentAllocator noInit ?\n+                noInit.allocateNoInit(layout.byteSize(), layout.byteAlignment()) :\n@@ -737,2 +738,2 @@\n-        return this instanceof ArenaImpl arenaImpl ?\n-                arenaImpl.allocateNoInit(layout.byteSize() * size, layout.byteAlignment()) :\n+        return this instanceof NoInitSegmentAllocator noInit ?\n+                noInit.allocateNoInit(layout.byteSize() * size, layout.byteAlignment()) :\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SegmentAllocator.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.vm.annotation.ForceInline;\n+\n@@ -31,1 +33,1 @@\n-public final class ArenaImpl implements Arena {\n+public final class ArenaImpl implements Arena, NoInitSegmentAllocator {\n@@ -50,0 +52,2 @@\n+    @ForceInline\n+    @Override\n@@ -55,0 +59,1 @@\n+    @ForceInline\n@@ -57,3 +62,1 @@\n-        NativeMemorySegmentImpl segment = allocateNoInit(byteSize, byteAlignment);\n-        segment.fill((byte)0);\n-        return segment;\n+        return NoInitSegmentAllocator.super.allocate(byteSize, byteAlignment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ArenaImpl.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,350 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.invoke.MhUtil;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+\/**\n+ * An internal utility class that can be used to adapt system-call-styled method handles\n+ * for efficient and easy use.\n+ *\/\n+public final class CaptureStateUtil {\n+\n+    private static final StructLayout CAPTURE_LAYOUT = Linker.Option.captureStateLayout();\n+    private static final CarrierLocalArenaPools POOL = CarrierLocalArenaPools.create(CAPTURE_LAYOUT);\n+\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+\n+    \/\/ The method handles below are bound to static methods residing in this class\n+\n+    private static final MethodHandle NON_NEGATIVE_INT_MH =\n+            MhUtil.findStatic(LOOKUP, \"nonNegative\",\n+                    MethodType.methodType(boolean.class, int.class));\n+\n+    private static final MethodHandle SUCCESS_INT_MH =\n+            MhUtil.findStatic(LOOKUP, \"success\",\n+                    MethodType.methodType(int.class, int.class, MemorySegment.class));\n+\n+    private static final MethodHandle ERROR_INT_MH =\n+            MhUtil.findStatic(LOOKUP, \"error\",\n+                    MethodType.methodType(int.class, MethodHandle.class, int.class, MemorySegment.class));\n+\n+    private static final MethodHandle NON_NEGATIVE_LONG_MH =\n+            MhUtil.findStatic(LOOKUP, \"nonNegative\",\n+                    MethodType.methodType(boolean.class, long.class));\n+\n+    private static final MethodHandle SUCCESS_LONG_MH =\n+            MhUtil.findStatic(LOOKUP, \"success\",\n+                    MethodType.methodType(long.class, long.class, MemorySegment.class));\n+\n+    private static final MethodHandle ERROR_LONG_MH =\n+            MhUtil.findStatic(LOOKUP, \"error\",\n+                    MethodType.methodType(long.class, MethodHandle.class, long.class, MemorySegment.class));\n+\n+    private static final MethodHandle ACQUIRE_ARENA_MH =\n+            MhUtil.findStatic(LOOKUP, \"acquireArena\",\n+                    MethodType.methodType(Arena.class));\n+\n+    private static final MethodHandle ALLOCATE_MH =\n+            MhUtil.findStatic(LOOKUP, \"allocate\",\n+                    MethodType.methodType(MemorySegment.class, Arena.class));\n+\n+    private static final MethodHandle ARENA_CLOSE_MH =\n+            MhUtil.findVirtual(LOOKUP, Arena.class, \"close\",\n+                    MethodType.methodType(void.class));\n+\n+    \/\/ The `BASIC_HANDLE_CACHE` contains the common \"basic handles\" that can be reused for\n+    \/\/ all adapted method handles. Keeping as much as possible reusable reduces the number\n+    \/\/ of combinators needed to form an adapted method handle.\n+    \/\/ The map is lazily computed.\n+    \/\/\n+    private static final Map<BasicKey, MethodHandle> BASIC_HANDLE_CACHE =\n+            new ConcurrentHashMap<>();\n+\n+    \/\/ A key that holds both the `returnType` and the `stateName` needed to look up a\n+    \/\/ specific \"basic handle\" in the `BASIC_HANDLE_CACHE`.\n+    \/\/   returnType E {int.class | long.class}\n+    \/\/   stateName can be anything non-null but should E {\"GetLastError\" | \"WSAGetLastError\"} | \"errno\")}\n+    record BasicKey(Class<?> returnType, String stateName) {\n+\n+        BasicKey(MethodHandle target, String stateName) {\n+            this(returnType(target), Objects.requireNonNull(stateName));\n+        }\n+\n+        static Class<?> returnType(MethodHandle target) {\n+            \/\/ Implicit null check\n+            final Class<?> returnType = target.type().returnType();\n+\n+            if (!(returnType.equals(int.class) || returnType.equals(long.class))) {\n+                throw illegalArgDoesNot(target, \"return an int or a long\");\n+            }\n+            if (target.type().parameterCount() == 0 || target.type().parameterType(0) != MemorySegment.class) {\n+                throw illegalArgDoesNot(target, \"have a MemorySegment as the first parameter\");\n+            }\n+            return returnType;\n+        }\n+\n+        private static IllegalArgumentException illegalArgDoesNot(MethodHandle target, String info) {\n+            return new IllegalArgumentException(\"The provided target \" + target\n+                    + \" does not \" + info);\n+        }\n+\n+    }\n+\n+    private CaptureStateUtil() {}\n+\n+    \/**\n+     * {@return a new MethodHandle that adapts the provided {@code target} so that it\n+     * directly returns the same value as the {@code target} if it is non-negative,\n+     * otherwise returns the negated captured state defined by the provided\n+     * {@code stateName}}\n+     * <p>\n+     * This method is suitable for adapting system-call method handles(e.g.\n+     * {@code open()}, {@code read()}, and {@code close()}). Clients can check the return\n+     * value as shown in this example:\n+     * {@snippet lang = java:\n+     *       \/\/ (MemorySegment capture, MemorySegment pathname, int flags)int\n+     *       static final MethodHandle CAPTURING_OPEN = ...\n+     *\n+     *      \/\/ (MemorySegment pathname, int flags)int\n+     *      static final MethodHandle OPEN = CaptureStateUtil\n+     *             .adaptSystemCall(CAPTURING_OPEN, \"errno\");\n+     *\n+     *      try {\n+     *         int fh = (int)OPEN.invokeExact(pathName, flags);\n+     *         if (fh < 0) {\n+     *             throw new IOException(\"Error opening file: errno = \" + (-fh));\n+     *         }\n+     *         processFile(fh);\n+     *      } catch (Throwable t) {\n+     *           throw new RuntimeException(t);\n+     *      }\n+     *\n+     *}\n+     *\n+     * For a {@code target} method handle that takes a {@code MemorySegment} and two\n+     * {@code int} parameters and returns an {@code int} value, the method returns a new\n+     * method handle that is doing the equivalent of:\n+     * <p>\n+     * {@snippet lang = java:\n+     *         private static final MemoryLayout CAPTURE_LAYOUT =\n+     *                 Linker.Option.captureStateLayout();\n+     *         private static final CarrierLocalArenaPools POOL =\n+     *                 CarrierLocalArenaPools.create(CAPTURE_LAYOUT);\n+     *\n+     *         public int invoke(MethodHandle target,\n+     *                           String stateName,\n+     *                           int a, int b) {\n+     *             try (var arena = POOL.take()) {\n+     *                 final MemorySegment segment = arena.allocate(CAPTURE_LAYOUT);\n+     *                 final int result = (int) handle.invoke(segment, a, b);\n+     *                 if (result >= 0) {\n+     *                     return result;\n+     *                 }\n+     *                 return -(int) CAPTURE_LAYOUT\n+     *                     .varHandle(MemoryLayout.PathElement.groupElement(stateName))\n+     *                         .get(segment, 0);\n+     *             }\n+     *         }\n+     *}\n+     * except it is more performant. In the above {@code stateName} is the name of the\n+     * captured state (e.g. {@code errno}). The static {@code CAPTURE_LAYOUT} is shared\n+     * across all target method handles adapted by this method.\n+     *\n+     * @param target    method handle that returns an {@code int} or a {@code long} and\n+     *                  has a capturing state MemorySegment as its first parameter\n+     * @param stateName the name of the capturing state member layout (i.e. \"errno\",\n+     *                  \"GetLastError\", or \"WSAGetLastError\")\n+     * @throws IllegalArgumentException if the provided {@code target}'s return type is\n+     *                                  not {@code int} or {@code long}\n+     * @throws IllegalArgumentException if the provided {@code target}'s first parameter\n+     *                                  type is not {@linkplain MemorySegment}\n+     * @throws IllegalArgumentException if the provided {@code stateName} is unknown on\n+     *                                  the current platform\n+     *\/\n+    public static MethodHandle adaptSystemCall(MethodHandle target,\n+                                               String stateName) {\n+        \/\/ Invariants checked in the BasicKey record\n+        final BasicKey basicKey = new BasicKey(target, stateName);\n+\n+        \/\/ ((int | long), MemorySegment)(int | long)\n+        final MethodHandle basicHandle = BASIC_HANDLE_CACHE\n+                \/\/ Do not use a lambda in order to allow early use in the init sequence\n+                \/\/ This is equivalent to:\n+                \/\/   computeIfAbsent(basicKey, CaptureStateUtil::basicHandleFor);\n+                .computeIfAbsent(basicKey, new Function<>() {\n+                    @Override\n+                    public MethodHandle apply(BasicKey basicKey) {\n+                        return basicHandleFor(basicKey);\n+                    }\n+                });\n+\n+        \/\/ Make `target` specific adaptations of the basic handle\n+\n+        \/\/ Pre-pend all the parameters from the `target` MH.\n+        \/\/ (C0=MemorySegment, C1-Cn, MemorySegment)(int|long)\n+        MethodHandle innerAdapted = MethodHandles.collectArguments(basicHandle, 0, target);\n+\n+        final int[] perm = new int[target.type().parameterCount() + 1];\n+        for (int i = 0; i < target.type().parameterCount(); i++) {\n+            perm[i] = i;\n+        }\n+        \/\/ Last takes first\n+        perm[target.type().parameterCount()] = 0;\n+        \/\/ Deduplicate the first and last coordinate and only use the first one.\n+        \/\/ (C0=MemorySegment, C1-Cn)(int|long)\n+        innerAdapted = MethodHandles.permuteArguments(innerAdapted, target.type(), perm);\n+\n+        \/\/ Use an `Arena` for the first argument instead and extract a segment from it.\n+        \/\/ (C0=Arena, C1-Cn)(int|long)\n+        innerAdapted = MethodHandles.collectArguments(innerAdapted, 0, ALLOCATE_MH);\n+\n+        \/\/ Add an identity function for the result of the cleanup action.\n+        \/\/ ((int|long))(int|long)\n+        MethodHandle cleanup = MethodHandles.identity(basicKey.returnType());\n+        \/\/ Add a dummy `Throwable` argument for the cleanup action.\n+        \/\/ This means, anything thrown will just be propagated.\n+        \/\/ (Throwable, (int|long))(int|long)\n+        cleanup = MethodHandles.dropArguments(cleanup, 0, Throwable.class);\n+        \/\/ Add the first `Arena` parameter of the `innerAdapted` method handle to the\n+        \/\/ cleanup action and invoke `Arena::close` when it is run. The `cleanup` handle\n+        \/\/ does not have to have all parameters. It can have zero or more.\n+        \/\/ (Throwable, (int|long), Arena)(int|long)\n+        cleanup = MethodHandles.collectArguments(cleanup, 2, ARENA_CLOSE_MH);\n+\n+        \/\/ Combine the `innerAdapted` and `cleanup` action into a try\/finally block.\n+        \/\/ (Arena, C1-Cn)(int|long)\n+        final MethodHandle tryFinally = MethodHandles.tryFinally(innerAdapted, cleanup);\n+\n+        \/\/ Acquire the arena from the global pool.\n+        \/\/ With this, we finally arrive at the intended method handle:\n+        \/\/ (C1-Cn)(int|long)\n+        return MethodHandles.collectArguments(tryFinally, 0, ACQUIRE_ARENA_MH);\n+    }\n+\n+    private static MethodHandle basicHandleFor(BasicKey basicKey) {\n+        final VarHandle vh = CAPTURE_LAYOUT.varHandle(\n+                MemoryLayout.PathElement.groupElement(basicKey.stateName()));\n+        \/\/ This MH is used to extract the named captured state\n+        \/\/ from the capturing `MemorySegment`.\n+        \/\/ (MemorySegment, long)int\n+        MethodHandle intExtractor = vh.toMethodHandle(VarHandle.AccessMode.GET);\n+        \/\/ As the MH is already adapted to use the appropriate\n+        \/\/ offset, we just insert `0L` for the offset.\n+        \/\/ (MemorySegment)int\n+        intExtractor = MethodHandles.insertArguments(intExtractor, 1, 0L);\n+\n+        \/\/ If X is the `returnType` (either `int` or `long`) then\n+        \/\/ the code below is equivalent to:\n+        \/\/\n+        \/\/ X handle(X returnValue, MemorySegment segment)\n+        \/\/     if (returnValue >= 0) {\n+        \/\/         \/\/ Ignore the segment\n+        \/\/         return returnValue;\n+        \/\/     } else {\n+        \/\/         \/\/ ignore the returnValue\n+        \/\/         return -(X)intExtractor.invokeExact(segment);\n+        \/\/     }\n+        \/\/ }\n+        if (basicKey.returnType().equals(int.class)) {\n+            \/\/ (int, MemorySegment)int\n+            return MethodHandles.guardWithTest(\n+                    NON_NEGATIVE_INT_MH,\n+                    SUCCESS_INT_MH,\n+                    ERROR_INT_MH.bindTo(intExtractor));\n+        } else {\n+            \/\/ (long, MemorySegment)long\n+            return MethodHandles.guardWithTest(\n+                    NON_NEGATIVE_LONG_MH,\n+                    SUCCESS_LONG_MH,\n+                    ERROR_LONG_MH.bindTo(intExtractor));\n+        }\n+    }\n+\n+    \/\/ The methods below are reflective used via static MethodHandles\n+\n+    @ForceInline\n+    private static Arena acquireArena() {\n+        return POOL.take();\n+    }\n+\n+    @ForceInline\n+    private static MemorySegment allocate(Arena arena) {\n+        \/\/ We do not need to zero out the segment.\n+        return ((NoInitSegmentAllocator) arena)\n+                .allocateNoInit(CAPTURE_LAYOUT.byteSize(), CAPTURE_LAYOUT.byteAlignment());\n+    }\n+\n+    @ForceInline\n+    private static boolean nonNegative(int value) {\n+        return value >= 0;\n+    }\n+\n+    @ForceInline\n+    private static int success(int value,\n+                               MemorySegment segment) {\n+        return value;\n+    }\n+\n+    @ForceInline\n+    private static int error(MethodHandle errorHandle,\n+                             int value,\n+                             MemorySegment segment) throws Throwable {\n+        return -(int) errorHandle.invokeExact(segment);\n+    }\n+\n+    @ForceInline\n+    private static boolean nonNegative(long value) {\n+        return value >= 0L;\n+    }\n+\n+    @ForceInline\n+    private static long success(long value,\n+                                MemorySegment segment) {\n+        return value;\n+    }\n+\n+    @ForceInline\n+    private static long error(MethodHandle errorHandle,\n+                              long value,\n+                              MemorySegment segment) throws Throwable {\n+        return -(int) errorHandle.invokeExact(segment);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"added"},{"patch":"@@ -0,0 +1,282 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.CarrierThread;\n+import jdk.internal.misc.TerminatingThreadLocal;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.util.Objects;\n+\n+public final class CarrierLocalArenaPools {\n+\n+    @Stable\n+    private final TerminatingThreadLocal<LocalArenaPoolImpl> tl;\n+\n+    private CarrierLocalArenaPools(long byteSize, long byteAlignment) {\n+        this.tl = new TerminatingThreadLocal<>() {\n+\n+            private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+            @Override\n+            protected LocalArenaPoolImpl initialValue() {\n+                if (JLA.currentCarrierThread() instanceof CarrierThread) {\n+                    \/\/ Only a carrier thread that is an instance of `CarrierThread` can\n+                    \/\/ ever carry virtual threads. (Notably, a `CarrierThread` can also\n+                    \/\/ carry a platform thread.) This means a `CarrierThread` can carry\n+                    \/\/ any number of virtual threads, and they can be mounted\/unmounted\n+                    \/\/ from the carrier thread at almost any time. Therefore, we must use\n+                    \/\/ stronger-than-plain semantics when dealing with mutual exclusion\n+                    \/\/ of thread local resources.\n+                    return new LocalArenaPoolImpl.OfCarrier(byteSize, byteAlignment);\n+                } else {\n+                    \/\/ A carrier thread that is not an instance of `CarrierThread` can\n+                    \/\/ never carry a virtual thread. Because of this, only one thread will\n+                    \/\/ be mounted on such a carrier thread. Therefore, we can use plain\n+                    \/\/ memory semantics when dealing with mutual exclusion of thread local\n+                    \/\/ resources.\n+                    return new LocalArenaPoolImpl.OfPlatform(byteSize, byteAlignment);\n+                }\n+            }\n+\n+            @Override\n+            protected void threadTerminated(LocalArenaPoolImpl stack) {\n+                stack.close();\n+            }\n+        };\n+    }\n+\n+    @ForceInline\n+    public Arena take() {\n+        return tl.get()\n+                .take();\n+    }\n+\n+    private static sealed abstract class LocalArenaPoolImpl {\n+\n+        static final int AVAILABLE = 0;\n+        static final int TAKEN = 1;\n+\n+        @Stable\n+        private final Arena pooledArena;\n+        @Stable\n+        private final MemorySegment segment;\n+        \/\/ Used both directly and reflectively\n+        int segmentAvailability;\n+\n+        private LocalArenaPoolImpl(long byteSize,\n+                                   long byteAlignment) {\n+            this.pooledArena = Arena.ofConfined();\n+            this.segment = pooledArena.allocate(byteSize, byteAlignment);\n+        }\n+\n+        @ForceInline\n+        public final Arena take() {\n+            final Arena arena = Arena.ofConfined();\n+            return tryAcquireSegment()\n+                    ? new SlicingArena((ArenaImpl) arena, segment)\n+                    : arena;\n+        }\n+\n+        public final void close() {\n+            pooledArena.close();\n+        }\n+\n+        \/**\n+         * {@return {@code true } if the segment was acquired for exclusive use, {@code\n+         * false} otherwise}\n+         *\/\n+        abstract boolean tryAcquireSegment();\n+\n+        \/**\n+         * Unconditionally releases the acquired segment if it was previously acquired,\n+         * otherwise this is a no-op.\n+         *\/\n+        abstract void releaseSegment();\n+\n+        \/**\n+         * Thread safe implementation.\n+         *\/\n+        public static final class OfCarrier\n+                extends LocalArenaPoolImpl {\n+\n+            \/\/ Unsafe allows earlier use in the init sequence and\n+            \/\/ better start and warmup properties.\n+            static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+            static final long SEG_AVAIL_OFFSET =\n+                    UNSAFE.objectFieldOffset(LocalArenaPoolImpl.class, \"segmentAvailability\");\n+\n+            public OfCarrier(long byteSize,\n+                             long byteAlignment) {\n+                super(byteSize, byteAlignment);\n+            }\n+\n+            @ForceInline\n+            boolean tryAcquireSegment() {\n+                return UNSAFE.compareAndSetInt(this, SEG_AVAIL_OFFSET, AVAILABLE, TAKEN);\n+            }\n+\n+            @ForceInline\n+            void releaseSegment() {\n+                UNSAFE.putIntVolatile(this, SEG_AVAIL_OFFSET, AVAILABLE);\n+            }\n+        }\n+\n+        \/**\n+         * No need for thread-safe implementation here as a platform thread is exclusively\n+         * mounted on a particular carrier thread.\n+         *\/\n+        public static final class OfPlatform\n+                extends LocalArenaPoolImpl {\n+\n+            public OfPlatform(long byteSize,\n+                              long byteAlignment) {\n+                super(byteSize, byteAlignment);\n+            }\n+\n+            @ForceInline\n+            boolean tryAcquireSegment() {\n+                if (segmentAvailability == TAKEN) {\n+                    return false;\n+                } else {\n+                    segmentAvailability = TAKEN;\n+                    return true;\n+                }\n+            }\n+\n+            @ForceInline\n+            void releaseSegment() {\n+                segmentAvailability = AVAILABLE;\n+            }\n+        }\n+\n+        \/**\n+         * A SlicingArena is similar to a {@linkplain SlicingAllocator} but if the backing\n+         * segment cannot be used for allocation, a fall-back arena is used instead. This\n+         * means allocation never fails due to the size and alignment of the backing\n+         * segment.\n+         * <p>\n+         * Todo: Should we expose a variant of this class as a complement\n+         *       to SlicingAllocator?\n+         *\/\n+        private final class SlicingArena implements Arena, NoInitSegmentAllocator {\n+\n+            @Stable\n+            private final ArenaImpl delegate;\n+            @Stable\n+            private final MemorySegment segment;\n+\n+            private long sp = 0L;\n+\n+            @ForceInline\n+            private SlicingArena(ArenaImpl arena,\n+                                 MemorySegment segment) {\n+                this.delegate = arena;\n+                this.segment = segment;\n+            }\n+\n+            @ForceInline\n+            @Override\n+            public MemorySegment.Scope scope() {\n+                return delegate.scope();\n+            }\n+\n+            @ForceInline\n+            @Override\n+            public NativeMemorySegmentImpl allocate(long byteSize, long byteAlignment) {\n+                return NoInitSegmentAllocator.super.allocate(byteSize, byteAlignment);\n+            }\n+\n+            @SuppressWarnings(\"restricted\")\n+            @ForceInline\n+            public NativeMemorySegmentImpl allocateNoInit(long byteSize, long byteAlignment) {\n+                final long min = segment.address();\n+                final long start = Utils.alignUp(min + sp, byteAlignment) - min;\n+                if (start + byteSize <= segment.byteSize()) {\n+                    Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+                    final MemorySegment slice = segment.asSlice(start, byteSize, byteAlignment);\n+                    sp = start + byteSize;\n+                    return fastReinterpret(delegate, (NativeMemorySegmentImpl) slice, byteSize);\n+                } else {\n+                    return delegate.allocateNoInit(byteSize, byteAlignment);\n+                }\n+            }\n+\n+            @ForceInline\n+            @Override\n+            public void close() {\n+                delegate.close();\n+                \/\/ Intentionally do not releaseSegment() in a finally clause as\n+                \/\/ the segment still is in play if close() initially fails (e.g. is closed\n+                \/\/ from a non-owner thread). Later on the close() method might be\n+                \/\/ successfully re-invoked (e.g. from its owner thread).\n+                LocalArenaPoolImpl.this.releaseSegment();\n+            }\n+        }\n+    }\n+\n+    \/\/ Equivalent to:\n+    \/\/     return (NativeMemorySegmentImpl) slice\n+    \/\/             .reinterpret(byteSize, delegate, null); *\/\n+    @ForceInline\n+    static NativeMemorySegmentImpl fastReinterpret(ArenaImpl arena,\n+                                                   NativeMemorySegmentImpl segment,\n+                                                   long byteSize) {\n+        \/\/ We already know the segment:\n+        \/\/  * is native\n+        \/\/  * we have native access\n+        \/\/  * there is no cleanup action\n+        \/\/  * the segment is read\/write\n+        return SegmentFactories.makeNativeSegmentUnchecked(segment.address(), byteSize,\n+                MemorySessionImpl.toMemorySession(arena), false, null);\n+    }\n+\n+    public static CarrierLocalArenaPools create(long byteSize) {\n+        if (byteSize < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        return new CarrierLocalArenaPools(byteSize, 1L);\n+    }\n+\n+    public static CarrierLocalArenaPools create(long byteSize,\n+                                                long byteAlignment) {\n+        Utils.checkAllocationSizeAndAlign(byteSize, byteAlignment);\n+        return new CarrierLocalArenaPools(byteSize, byteAlignment);\n+    }\n+\n+    public static CarrierLocalArenaPools create(MemoryLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return new CarrierLocalArenaPools(layout.byteSize(), layout.byteAlignment());\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CarrierLocalArenaPools.java","additions":282,"deletions":0,"binary":false,"changes":282,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.SegmentAllocator;\n+\n+public interface NoInitSegmentAllocator extends SegmentAllocator {\n+\n+    NativeMemorySegmentImpl allocateNoInit(long byteSize, long byteAlignment);\n+\n+    @ForceInline\n+    @Override\n+    default NativeMemorySegmentImpl allocate(long byteSize, long byteAlignment) {\n+        NativeMemorySegmentImpl segment = allocateNoInit(byteSize, byteAlignment);\n+        segment.fill((byte)0);\n+        return segment;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NoInitSegmentAllocator.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,10 @@\n+    public static MethodHandle findStatic(MethodHandles.Lookup lookup,\n+                                           String name,\n+                                           MethodType type) {\n+        try {\n+            return lookup.findStatic(lookup.lookupClass(), name, type);\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/MhUtil.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test CaptureStateUtil\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run junit TestCaptureStateUtil\n+ *\/\n+\n+import jdk.internal.foreign.CaptureStateUtil;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestCaptureStateUtil {\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n+            .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n+\n+    private static final MethodHandle INT_DUMMY_HANDLE;\n+    private static final MethodHandle LONG_DUMMY_HANDLE;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            INT_DUMMY_HANDLE = lookup\n+                    .findStatic(TestCaptureStateUtil.class, \"dummy\",\n+                            MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+            LONG_DUMMY_HANDLE = lookup\n+                    .findStatic(TestCaptureStateUtil.class, \"dummy\",\n+                            MethodType.methodType(long.class, MemorySegment.class, long.class, int.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static final MethodHandle ADAPTED_INT = CaptureStateUtil\n+            .adaptSystemCall(INT_DUMMY_HANDLE, ERRNO_NAME);\n+    private static final MethodHandle ADAPTED_LONG = CaptureStateUtil\n+            .adaptSystemCall(LONG_DUMMY_HANDLE, ERRNO_NAME);\n+\n+    @Test\n+    void successfulInt() throws Throwable {\n+        int r = (int) ADAPTED_INT.invokeExact(1, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    private static final int EACCES = 13; \/* Permission denied *\/\n+\n+    @Test\n+    void errorInt() throws Throwable {\n+        int r = (int) ADAPTED_INT.invokeExact(-1, EACCES);\n+        assertEquals(-EACCES, r);\n+    }\n+\n+    @Test\n+    void successfulLong() throws Throwable {\n+        long r = (long) ADAPTED_LONG.invokeExact(1L, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    @Test\n+    void errorLong() throws Throwable {\n+        long r = (long) ADAPTED_LONG.invokeExact(-1L, EACCES);\n+        assertEquals(-EACCES, r);\n+    }\n+\n+    @Test\n+    void successfulIntPerHandle() throws Throwable {\n+        MethodHandle handle = CaptureStateUtil\n+                .adaptSystemCall(INT_DUMMY_HANDLE, ERRNO_NAME);\n+        int r = (int) handle.invokeExact(1, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    @Test\n+    void invariants() throws Throwable {\n+        MethodHandle noSegment = MethodHandles.lookup()\n+                .findStatic(TestCaptureStateUtil.class, \"wrongType\",\n+                        MethodType.methodType(long.class, long.class, int.class));\n+\n+        var noSegEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, ERRNO_NAME));\n+        assertTrue(noSegEx.getMessage().contains(\"does not have a MemorySegment as the first parameter\"));\n+\n+        MethodHandle wrongReturnType = MethodHandles.lookup()\n+                .findStatic(TestCaptureStateUtil.class, \"wrongType\",\n+                        MethodType.methodType(short.class, MemorySegment.class, long.class, int.class));\n+\n+        var wrongRetEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(wrongReturnType, ERRNO_NAME));\n+        assertTrue(wrongRetEx.getMessage().contains(\"does not return an int or a long\"));\n+\n+        var wrongCaptureName = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(LONG_DUMMY_HANDLE, \"foo\"));\n+        assertTrue(wrongCaptureName.getMessage().startsWith(\"Bad layout path: cannot resolve 'foo' in layout [\"), wrongCaptureName.getMessage());\n+\n+        assertThrows(NullPointerException.class, () -> CaptureStateUtil.adaptSystemCall(null, ERRNO_NAME));\n+        assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, null));\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int dummy(MemorySegment segment, int result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static long dummy(MemorySegment segment, long result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    private static long wrongType(long result, int errno) {\n+        return 0;\n+    }\n+\n+    private static short wrongType(MemorySegment segment, long result, int errno) {\n+        return 0;\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/TestCaptureStateUtil.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,340 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test TestCarrierLocalArenaPools\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run junit TestCarrierLocalArenaPools\n+ *\/\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.VarHandle;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.foreign.CarrierLocalArenaPools;\n+import jdk.test.lib.thread.VThreadRunner;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_LONG;\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestCarrierLocalArenaPools {\n+\n+    private static final long POOL_SIZE = 64;\n+    private static final long SMALL_ALLOC_SIZE = 8;\n+    private static final long VERY_LARGE_ALLOC_SIZE = 1L << 10;\n+\n+    @Test\n+    void invariants1LongArg() {\n+        assertThrows(IllegalArgumentException.class, () -> CarrierLocalArenaPools.create(-1));\n+        CarrierLocalArenaPools pool = CarrierLocalArenaPools.create(0);\n+        try (var arena = pool.take()) {\n+            \/\/ This should come from the underlying arena and not from recyclable memory\n+            assertDoesNotThrow(() -> arena.allocate(1));\n+            try (var arena2 = pool.take()) {\n+                assertDoesNotThrow(() -> arena.allocate(1));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void invariants2LongArgs() {\n+        assertThrows(IllegalArgumentException.class, () -> CarrierLocalArenaPools.create(-1, 2));\n+        assertThrows(IllegalArgumentException.class, () -> CarrierLocalArenaPools.create(1, -1));\n+        assertThrows(IllegalArgumentException.class, () -> CarrierLocalArenaPools.create(1, 3));\n+        CarrierLocalArenaPools pool = CarrierLocalArenaPools.create(0, 16);\n+        try (var arena = pool.take()) {\n+            \/\/ This should come from the underlying arena and not from recyclable memory\n+            assertDoesNotThrow(() -> arena.allocate(1));\n+            try (var arena2 = pool.take()) {\n+                assertDoesNotThrow(() -> arena.allocate(1));\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void negativeAlloc(CarrierLocalArenaPools pool) {\n+        Consumer<Arena> action = arena ->\n+                assertThrows(IllegalArgumentException.class, () -> arena.allocate(-1));\n+        doInTwoStackedArenas(pool, action, action);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void negativeAllocVt(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> negativeAlloc(pool));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void allocateConfinement(CarrierLocalArenaPools pool) {\n+        Consumer<Arena> allocateAction = arena ->\n+                assertThrows(WrongThreadException.class, () -> {\n+                    CompletableFuture<Arena> future = CompletableFuture.supplyAsync(pool::take);\n+                    var otherThreadArena = future.get();\n+                    otherThreadArena.allocate(SMALL_ALLOC_SIZE);\n+                    \/\/ Intentionally do not close the otherThreadArena here.\n+                });\n+        doInTwoStackedArenas(pool, allocateAction, allocateAction);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void allocateConfinementVt(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> allocateConfinement(pool));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void closeConfinement(CarrierLocalArenaPools pool) {\n+        Consumer<Arena> closeAction = arena -> {\n+            CompletableFuture<Arena> future = CompletableFuture.supplyAsync(pool::take);\n+            Arena otherThreadArena = null;\n+            try {\n+                otherThreadArena = future.get();\n+            } catch (InterruptedException | ExecutionException e) {\n+                fail(e);\n+            }\n+            assertThrows(WrongThreadException.class, otherThreadArena::close);\n+        };\n+        doInTwoStackedArenas(pool, closeAction, closeAction);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void closeConfinementVt(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> closeConfinement(pool));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void reuse(CarrierLocalArenaPools pool) {\n+        MemorySegment firstSegment;\n+        MemorySegment secondSegment;\n+        try (var arena = pool.take()) {\n+            firstSegment = arena.allocate(SMALL_ALLOC_SIZE);\n+        }\n+        try (var arena = pool.take()) {\n+            secondSegment = arena.allocate(SMALL_ALLOC_SIZE);\n+        }\n+        assertNotSame(firstSegment, secondSegment);\n+        assertNotSame(firstSegment.scope(), secondSegment.scope());\n+        assertEquals(firstSegment.address(), secondSegment.address());\n+        assertThrows(IllegalStateException.class, () -> firstSegment.get(JAVA_BYTE, 0));\n+        assertThrows(IllegalStateException.class, () -> secondSegment.get(JAVA_BYTE, 0));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void reuseVt(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> reuse(pool));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void largeAlloc(CarrierLocalArenaPools pool) {\n+        try (var arena = pool.take()) {\n+            var segment = arena.allocate(VERY_LARGE_ALLOC_SIZE);\n+            assertEquals(VERY_LARGE_ALLOC_SIZE, segment.byteSize());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void largeAllocSizeVt(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> largeAlloc(pool));\n+    }\n+\n+    @Test\n+    void allocationSameAsPoolSize() {\n+        var pool = CarrierLocalArenaPools.create(4);\n+        long firstAddress;\n+        try (var arena = pool.take()) {\n+            var segment = arena.allocate(4);\n+            firstAddress = segment.address();\n+        }\n+        try (var arena = pool.take()) {\n+            var segment = arena.allocate(4 + 1);\n+            assertNotEquals(firstAddress, segment.address());\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            try (var arena = pool.take()) {\n+                var segment = arena.allocate(4);\n+                assertEquals(firstAddress, segment.address());\n+                var segmentTwo = arena.allocate(4);\n+                assertNotEquals(firstAddress, segmentTwo.address());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void allocationCaptureStateLayout() {\n+        var layout = Linker.Option.captureStateLayout();\n+        var pool = CarrierLocalArenaPools.create(layout);\n+        long firstAddress;\n+        try (var arena = pool.take()) {\n+            var segment = arena.allocate(layout);\n+            firstAddress = segment.address();\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            try (var arena = pool.take()) {\n+                var segment = arena.allocate(layout);\n+                assertEquals(firstAddress, segment.address());\n+                var segmentTwo = arena.allocate(layout);\n+                assertNotEquals(firstAddress, segmentTwo.address());\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void outOfOrderUse(CarrierLocalArenaPools pool) {\n+        Arena firstArena = pool.take();\n+        Arena secondArena = pool.take();\n+        firstArena.close();\n+        Arena thirdArena = pool.take();\n+        secondArena.close();\n+        thirdArena.close();\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void zeroing(CarrierLocalArenaPools pool) {\n+        try (var arena = pool.take()) {\n+            var seg = arena.allocate(SMALL_ALLOC_SIZE);\n+            seg.fill((byte) 1);\n+        }\n+        try (var arena = pool.take()) {\n+            var seg = arena.allocate(SMALL_ALLOC_SIZE);\n+            for (int i = 0; i < SMALL_ALLOC_SIZE; i++) {\n+                assertEquals((byte) 0, seg.get(JAVA_BYTE, i));\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void zeroingVt(CarrierLocalArenaPools pool) {\n+        VThreadRunner.run(() -> zeroing(pool));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void useAfterFree(CarrierLocalArenaPools pool) {\n+        MemorySegment segment = null;\n+        try (var arena = pool.take()){\n+            segment = arena.allocate(SMALL_ALLOC_SIZE);\n+        }\n+        final var closedSegment = segment;\n+        var e = assertThrows(IllegalStateException.class, () -> closedSegment.get(ValueLayout.JAVA_INT, 0));\n+        assertEquals(\"Already closed\", e.getMessage());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void toStringTest(CarrierLocalArenaPools pool) {\n+        assertTrue(pool.toString().contains(\"ArenaPool\"));\n+        try (var arena = pool.take()) {\n+            assertTrue(arena.toString().contains(\"SlicingArena\"));\n+        }\n+    }\n+\n+    private static final VarHandle LONG_HANDLE = JAVA_LONG.varHandle();\n+\n+    \/**\n+     * The objective of this test is to try to provoke a situation where threads are\n+     * competing to use allocated pooled memory and then trying to make sure no thread\n+     * can see the same shared memory another thread is using.\n+     *\/\n+    @Test\n+    void stress() throws InterruptedException {\n+        \/\/ Just use one pool variant as testing here is fairly expensive.\n+        final CarrierLocalArenaPools pool = pools().limit(1).findFirst().orElseThrow();\n+        \/\/ Make sure it works for both virtual and platform threads (as they are handled differently)\n+        for (var threadBuilder : List.of(Thread.ofVirtual(), Thread.ofPlatform())) {\n+            final Thread[] threads = IntStream.range(0, 1024).mapToObj(_ ->\n+                    threadBuilder.start(() -> {\n+                        final long threadId = Thread.currentThread().threadId();\n+                        while (!Thread.interrupted()) {\n+                            for (int i = 0; i < 1_000_000; i++) {\n+                                try (Arena arena = pool.take()) {\n+                                    \/\/ Try to assert no two threads get allocated the same memory region.\n+                                    final MemorySegment segment = arena.allocate(JAVA_LONG);\n+                                    LONG_HANDLE.setVolatile(segment, 0L, threadId);\n+                                    assertEquals(threadId, (long) LONG_HANDLE.getVolatile(segment, 0L));\n+                                }\n+                            }\n+                            Thread.yield(); \/\/ make sure the driver thread gets a chance.\n+                        }\n+                    })).toArray(Thread[]::new);\n+            Thread.sleep(Duration.of(5, SECONDS));\n+            Arrays.stream(threads).forEach(\n+                    thread -> {\n+                        assertTrue(thread.isAlive());\n+                        thread.interrupt();\n+                    });\n+        }\n+    }\n+\n+    \/\/ Factories and helper methods\n+\n+    static Stream<CarrierLocalArenaPools> pools() {\n+        return Stream.of(\n+                CarrierLocalArenaPools.create(POOL_SIZE),\n+                CarrierLocalArenaPools.create(POOL_SIZE, 16),\n+                CarrierLocalArenaPools.create(MemoryLayout.sequenceLayout(POOL_SIZE, JAVA_BYTE))\n+        );\n+    }\n+\n+    static void doInTwoStackedArenas(CarrierLocalArenaPools pool,\n+                                     Consumer<Arena> firstAction,\n+                                     Consumer<Arena> secondAction) {\n+        try (var firstArena = pool.take()) {\n+            firstAction.accept(firstArena);\n+            try (var secondArena = pool.take()) {\n+                secondAction.accept(secondArena);\n+            }\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/TestCarrierLocalArenaPools.java","additions":340,"deletions":0,"binary":false,"changes":340,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ *  Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import jdk.internal.foreign.CarrierLocalArenaPools;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\n+        \"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\",\n+        \"--enable-native-access=ALL-UNNAMED\"})\n+public class ArenaPoolBench {\n+\n+    private static final CarrierLocalArenaPools POOLS = CarrierLocalArenaPools.create(64, 8);\n+\n+    @Param({\"4\", \"16\", \"64\", \"512\"})\n+    public int ELEM_SIZE;\n+\n+    @Benchmark\n+    public long confined() {\n+        try (var arena = Arena.ofConfined()) {\n+            return arena.allocate(ELEM_SIZE).address();\n+        }\n+    }\n+\n+    @Benchmark\n+    public long pooled() {\n+        try (var arena = POOLS.take()) {\n+            return arena.allocate(ELEM_SIZE).address();\n+        }\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = \"-Djmh.executor=VIRTUAL\")\n+    public static class OfVirtual extends ArenaPoolBench {\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ArenaPoolBench.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ *  Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import jdk.internal.foreign.CarrierLocalArenaPools;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\n+        \"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\",\n+        \"--enable-native-access=ALL-UNNAMED\"})\n+public class ArenaPoolFromBench {\n+\n+    private static final CarrierLocalArenaPools POOLS = CarrierLocalArenaPools.create(32);\n+\n+    private static final String TEXT = \"The quick brown fox\";\n+\n+    @Benchmark\n+    public long confinedInt() {\n+        try (var arena = Arena.ofConfined()) {\n+            return arena.allocateFrom(ValueLayout.JAVA_INT, 42).address();\n+        }\n+    }\n+\n+    @Benchmark\n+    public long confinedSting() {\n+        try (var arena = Arena.ofConfined()) {\n+            return arena.allocateFrom(TEXT).address();\n+        }\n+    }\n+\n+    @Benchmark\n+    public long pooledInt() {\n+        try (var arena = POOLS.take()) {\n+            return arena.allocateFrom(ValueLayout.JAVA_INT, 42).address();\n+        }\n+    }\n+\n+    @Benchmark\n+    public long pooledString() {\n+        try (var arena = POOLS.take()) {\n+            return arena.allocateFrom(TEXT).address();\n+        }\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = \"-Djmh.executor=VIRTUAL\")\n+    public static class OfVirtual extends ArenaPoolFromBench {\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/ArenaPoolFromBench.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import jdk.internal.foreign.CaptureStateUtil;\n+import jdk.internal.foreign.CarrierLocalArenaPools;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\",\n+        \"--enable-native-access=ALL-UNNAMED\"})\n+public class CaptureStateUtilBench {\n+\n+    private static final CarrierLocalArenaPools POOLS = CarrierLocalArenaPools.create(16);\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n+            .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n+\n+    private static final long SIZE = Linker.Option.captureStateLayout().byteSize();\n+\n+    private static final MethodHandle DUMMY_EXPLICIT_ALLOC = dummyExplicitAlloc();\n+    private static final MethodHandle DUMMY_TL_ALLOC = dummyTlAlloc();\n+\n+    @Benchmark\n+    public int explicitAllocationSuccess() throws Throwable {\n+        try (var arena = Arena.ofConfined()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), 0, 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int explicitAllocationFail() throws Throwable {\n+        try (var arena = Arena.ofConfined()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), -1, 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int tlAllocationSuccess() throws Throwable {\n+        try (var arena = POOLS.take()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), 0, 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int tlAllocationFail() throws Throwable {\n+        try (var arena = POOLS.take()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), -1, 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int adaptedSysCallSuccess() throws Throwable {\n+        return (int) DUMMY_TL_ALLOC.invokeExact(0, 0);\n+    }\n+\n+    @Benchmark\n+    public int adaptedSysCallFail() throws Throwable {\n+        return (int) DUMMY_TL_ALLOC.invokeExact( -1, 1);\n+    }\n+\n+    private static MethodHandle dummyExplicitAlloc() {\n+        try {\n+            return MethodHandles.lookup().findStatic(CaptureStateUtilBench.class,\n+                    \"dummy\", MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+        } catch (ReflectiveOperationException roe) {\n+            throw new RuntimeException(roe);\n+        }\n+    }\n+\n+    private static MethodHandle dummyTlAlloc() {\n+        final MethodHandle handle = dummyExplicitAlloc();\n+        return CaptureStateUtil.adaptSystemCall(handle, ERRNO_NAME);\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int dummy(MemorySegment segment, int result, int errno) {\n+        if (errno != 0) {\n+            \/\/ Assuming the capture state is only modified upon detecting an error.\n+            ERRNO_HANDLE.set(segment, 0, errno);\n+        }\n+        return result;\n+    }\n+\n+    @Fork(value = 3, jvmArgsAppend = \"-Djmh.executor=VIRTUAL\")\n+    public static class OfVirtual extends CaptureStateUtilBench {}\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CaptureStateUtilBench.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}