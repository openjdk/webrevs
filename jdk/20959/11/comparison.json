{"files":[{"patch":"@@ -102,0 +102,1 @@\n+Array<Method*>* MetaspaceShared::_archived_method_handle_intrinsics = nullptr;\n@@ -312,0 +313,1 @@\n+\/\/ Extra java.lang.Strings to be added to the archive\n@@ -313,0 +315,1 @@\n+\/\/ Extra Symbols to be added to the archive\n@@ -314,0 +317,2 @@\n+\/\/ Methods managed by SystemDictionary::find_method_handle_intrinsic() to be added to the archive\n+static GrowableArray<Method*>* _pending_method_handle_intrinsics = NULL;\n@@ -364,0 +369,19 @@\n+void MetaspaceShared::make_method_handle_intrinsics_shareable() {\n+  for (int i = 0; i < _pending_method_handle_intrinsics->length(); i++) {\n+    Method* m = ArchiveBuilder::current()->get_buffered_addr(_pending_method_handle_intrinsics->at(i));\n+    m->remove_unshareable_info();\n+    \/\/ Each method has its own constant pool (which is distinct from m->method_holder()->constants());\n+    m->constants()->remove_unshareable_info();\n+  }\n+}\n+\n+void MetaspaceShared::write_method_handle_intrinsics() {\n+  int len = _pending_method_handle_intrinsics->length();\n+  _archived_method_handle_intrinsics = ArchiveBuilder::new_ro_array<Method*>(len);\n+  for (int i = 0; i < len; i++) {\n+    ArchiveBuilder::current()->write_pointer_in_buffer(_archived_method_handle_intrinsics->adr_at(i),\n+                                                       _pending_method_handle_intrinsics->at(i));\n+  }\n+  log_info(cds)(\"Archived %d method handle intrinsics\", len);\n+}\n+\n@@ -409,0 +433,2 @@\n+  soc->do_ptr((void**)&_archived_method_handle_intrinsics);\n+\n@@ -495,0 +521,4 @@\n+\n+    for (int i = 0; i < _pending_method_handle_intrinsics->length(); i++) {\n+      it->push(_pending_method_handle_intrinsics->adr_at(i));\n+    }\n@@ -503,0 +533,1 @@\n+  MetaspaceShared::write_method_handle_intrinsics();\n@@ -522,0 +553,7 @@\n+  _pending_method_handle_intrinsics = new (mtClassShared) GrowableArray<Method*>(256, mtClassShared);\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    \/\/ When dumping AOT-linked classes, some classes may have direct references to a method handle\n+    \/\/ intrinsic. The easiest thing is to save all of them into the AOT cache.\n+    SystemDictionary::get_all_method_handle_intrinsics(_pending_method_handle_intrinsics);\n+  }\n+\n@@ -545,0 +583,1 @@\n+  MetaspaceShared::make_method_handle_intrinsics_shareable();\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class Method;\n@@ -41,0 +42,1 @@\n+template<class E> class Array;\n@@ -59,0 +61,1 @@\n+  static Array<Method*>* _archived_method_handle_intrinsics;\n@@ -113,0 +116,3 @@\n+  static void make_method_handle_intrinsics_shareable() NOT_CDS_RETURN;\n+  static void write_method_handle_intrinsics() NOT_CDS_RETURN;\n+  static Array<Method*>* archived_method_handle_intrinsics() { return _archived_method_handle_intrinsics; }\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -2061,0 +2062,46 @@\n+#if INCLUDE_CDS\n+void SystemDictionary::get_all_method_handle_intrinsics(GrowableArray<Method*>* methods) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"must be\");\n+  auto do_method = [&] (InvokeMethodKey& key, Method*& m) {\n+    methods->append(m);\n+  };\n+  _invoke_method_intrinsic_table->iterate_all(do_method);\n+}\n+\n+void SystemDictionary::restore_archived_method_handle_intrinsics() {\n+  if (UseSharedSpaces) {\n+    EXCEPTION_MARK;\n+    restore_archived_method_handle_intrinsics_impl(THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      \/\/ This is probably caused by OOM -- other parts of the CDS archive have direct pointers to\n+      \/\/ the archived method handle intrinsics, so we can't really recover from this failure.\n+      vm_exit_during_initialization(err_msg(\"Failed to restore archived method handle intrinsics. Try to increase heap size.\"));\n+    }\n+  }\n+}\n+\n+void SystemDictionary::restore_archived_method_handle_intrinsics_impl(TRAPS) {\n+  Array<Method*>* list = MetaspaceShared::archived_method_handle_intrinsics();\n+  for (int i = 0; i < list->length(); i++) {\n+    methodHandle m(THREAD, list->at(i));\n+    Method::restore_archived_method_handle_intrinsic(m, CHECK);\n+    m->constants()->restore_unshareable_info(CHECK);\n+    if (!Arguments::is_interpreter_only() || m->intrinsic_id() == vmIntrinsics::_linkToNative) {\n+      AdapterHandlerLibrary::create_native_wrapper(m);\n+      if (!m->has_compiled_code()) {\n+        ResourceMark rm(THREAD);\n+        vm_exit_during_initialization(err_msg(\"Failed to initialize method %s\", m->external_name()));\n+      }\n+    }\n+\n+    \/\/ There's no need to grab the InvokeMethodIntrinsicTable_lock, as we are still very early in\n+    \/\/ VM start-up -- in init_globals2() -- so we are still running a single Java thread. It's not\n+    \/\/ possible to have a contention.\n+    const int iid_as_int = vmIntrinsics::as_int(m->intrinsic_id());\n+    InvokeMethodKey key(m->signature(), iid_as_int);\n+    bool created = _invoke_method_intrinsic_table->put(key, m());\n+    assert(created, \"unexpected contention\");\n+  }\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+template <class E> class GrowableArray;\n+\n@@ -243,0 +245,3 @@\n+  static void get_all_method_handle_intrinsics(GrowableArray<Method*>* methods) NOT_CDS_RETURN;\n+  static void restore_archived_method_handle_intrinsics() NOT_CDS_RETURN;\n+\n@@ -338,0 +343,1 @@\n+  static void restore_archived_method_handle_intrinsics_impl(TRAPS) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -352,0 +352,5 @@\n+  if (is_for_method_handle_intrinsic()) {\n+    \/\/ See the same check in remove_unshareable_info() below.\n+    assert(cache() == NULL, \"must not have cpCache\");\n+    return;\n+  }\n@@ -391,0 +396,8 @@\n+  if (is_for_method_handle_intrinsic()) {\n+    \/\/ This CP was created by Method::make_method_handle_intrinsic() and has nothing\n+    \/\/ that need to be removed\/restored. It has no cpCache since the intrinsic methods\n+    \/\/ don't have any bytecodes.\n+    assert(cache() == NULL, \"must not have cpCache\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -112,1 +112,2 @@\n-    _has_dynamic_constant = 8\n+    _has_dynamic_constant = 8,\n+    _is_for_method_handle_intrinsic = 16\n@@ -219,0 +220,3 @@\n+  bool is_for_method_handle_intrinsic() const  { return (_flags & _is_for_method_handle_intrinsic) != 0; }\n+  void set_is_for_method_handle_intrinsic()    { _flags |= _is_for_method_handle_intrinsic; }\n+\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1434,0 +1434,1 @@\n+  cp->set_is_for_method_handle_intrinsic();\n@@ -1482,0 +1483,10 @@\n+#if INCLUDE_CDS\n+void Method::restore_archived_method_handle_intrinsic(methodHandle m, TRAPS) {\n+  m->link_method(m, CHECK);\n+\n+  if (m->intrinsic_id() == vmIntrinsics::_linkToNative) {\n+    m->set_interpreter_entry(m->adapter()->get_i2c_entry());\n+  }\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+  static void restore_archived_method_handle_intrinsic(methodHandle m, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -193,0 +194,1 @@\n+  SystemDictionary::restore_archived_method_handle_intrinsics();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}