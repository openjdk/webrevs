{"files":[{"patch":"@@ -461,0 +461,1 @@\n+ *  loader:  the loader to use\n@@ -471,1 +472,1 @@\n-JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,\n+JVM_LookupDefineClass(JNIEnv *env, jobject loader, jclass lookup, const char *name, const jbyte *buf,\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -935,1 +935,1 @@\n-static jclass jvm_lookup_define_class(jclass lookup, const char *name,\n+static jclass jvm_lookup_define_class(jobject loader, jclass lookup, const char *name,\n@@ -947,1 +947,1 @@\n-  Handle class_loader (THREAD, lookup_k->class_loader());\n+  Handle class_loader (THREAD, JNIHandles::resolve(loader));\n@@ -1065,1 +1065,1 @@\n-JVM_ENTRY(jclass, JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,\n+JVM_ENTRY(jclass, JVM_LookupDefineClass(JNIEnv *env, jobject loader, jclass lookup, const char *name, const jbyte *buf,\n@@ -1074,1 +1074,1 @@\n-  return jvm_lookup_define_class(lookup, name, buf, len, pd, initialize, flags, classData, THREAD);\n+  return jvm_lookup_define_class(loader, lookup, name, buf, len, pd, initialize, flags, classData, THREAD);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,0 +58,1 @@\n+import jdk.internal.reflect.ReflectionFactory;\n@@ -542,16 +543,42 @@\n-            byte[] proxyClassFile = ProxyGenerator.generateProxyClass(loader, proxyName, interfaces,\n-                                                                      context.accessFlags() | Modifier.FINAL);\n-            try {\n-                Class<?> pc = JLA.defineClass(loader, proxyName, proxyClassFile,\n-                                              null, \"__dynamic_proxy__\");\n-                reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE);\n-                return pc;\n-            } catch (ClassFormatError e) {\n-                \/*\n-                 * A ClassFormatError here means that (barring bugs in the\n-                 * proxy class generation code) there was some other\n-                 * invalid aspect of the arguments supplied to the proxy\n-                 * class creation (such as virtual machine limitations\n-                 * exceeded).\n-                 *\/\n-                throw new IllegalArgumentException(e.toString());\n+            int access = context.accessFlags() | Modifier.FINAL;\n+\n+            Class<?> pc;\n+\n+            if (ReflectionFactory.useLegacyProxyImpl()) {\n+                byte[] proxyClassFile = ProxyGeneratorLegacy.generateProxyClass(loader, proxyName, interfaces, access);\n+\n+                try {\n+                    pc = JLA.defineClass(loader, proxyName, proxyClassFile,\n+                            null, \"__dynamic_proxy__\");\n+                } catch (ClassFormatError e) {\n+                    \/*\n+                     * A ClassFormatError here means that (barring bugs in the\n+                     * proxy class generation code) there was some other\n+                     * invalid aspect of the arguments supplied to the proxy\n+                     * class creation (such as virtual machine limitations\n+                     * exceeded).\n+                     *\/\n+                    throw new IllegalArgumentException(e.toString());\n+                }\n+            } else {\n+                var cd = ProxyGenerator.generateProxyClass(loader, proxyName, interfaces, access);\n+\n+                try {\n+                    pc = JLA.defineClass(loader,\n+                            Proxy.class, \/\/ NestHost, unused\n+                            proxyName, \/\/ binary name\n+                            cd.bytecode(), \/\/ bytes\n+                            null, \/\/ protection domain\n+                            false, \/\/ initialize\n+                            0x00000002, \/\/ flags, HIDDEN\n+                            cd.classData()); \/\/ classData\n+                } catch (ClassFormatError e) {\n+                    \/*\n+                     * A ClassFormatError here means that (barring bugs in the\n+                     * proxy class generation code) there was some other\n+                     * invalid aspect of the arguments supplied to the proxy\n+                     * class creation (such as virtual machine limitations\n+                     * exceeded).\n+                     *\/\n+                    throw new IllegalArgumentException(e.toString());\n+                }\n@@ -559,0 +586,3 @@\n+\n+            reverseProxyCache.sub(pc).putIfAbsent(loader, Boolean.TRUE);\n+            return pc;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":47,"deletions":17,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.lang.classfile.*;\n-import java.lang.classfile.constantpool.*;\n-import java.lang.classfile.attribute.ExceptionsAttribute;\n@@ -34,1 +31,7 @@\n-import static java.lang.classfile.ClassFile.*;\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassHierarchyResolver;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.attribute.ExceptionsAttribute;\n@@ -37,0 +40,7 @@\n+import java.lang.classfile.constantpool.ClassEntry;\n+import java.lang.classfile.constantpool.ConstantDynamicEntry;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.constantpool.FieldRefEntry;\n+import java.lang.classfile.constantpool.InterfaceMethodRefEntry;\n+import java.lang.classfile.constantpool.MethodRefEntry;\n+import java.lang.classfile.constantpool.PoolEntry;\n@@ -38,1 +48,0 @@\n-import static java.lang.constant.ConstantDescs.*;\n@@ -49,1 +58,3 @@\n-import java.util.function.IntFunction;\n+\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -61,2 +72,0 @@\n-            CD_ClassLoader = ClassDesc.ofInternalName(\"java\/lang\/ClassLoader\"),\n-            CD_ClassNotFoundException = ClassDesc.ofInternalName(\"java\/lang\/ClassNotFoundException\"),\n@@ -66,3 +75,0 @@\n-            CD_NoClassDefFoundError = ClassDesc.ofInternalName(\"java\/lang\/NoClassDefFoundError\"),\n-            CD_NoSuchMethodError = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodError\"),\n-            CD_NoSuchMethodException = ClassDesc.ofInternalName(\"java\/lang\/NoSuchMethodException\"),\n@@ -78,2 +84,0 @@\n-            MTD_Class_String_boolean_ClassLoader = MethodTypeDesc.of(CD_Class, CD_String, CD_boolean, CD_ClassLoader),\n-            MTD_ClassLoader = MethodTypeDesc.of(CD_ClassLoader),\n@@ -82,1 +86,0 @@\n-            MTD_Method_String_ClassArray = MethodTypeDesc.of(CD_Method, CD_String, CD_Class.arrayType()),\n@@ -84,0 +87,1 @@\n+            MTD_Object_int = MethodTypeDesc.of(CD_Object, CD_int),\n@@ -111,5 +115,1 @@\n-    private static final ClassEntry CE_Class;\n-    private static final ClassEntry CE_ClassNotFoundException;\n-    private static final ClassEntry CE_NoClassDefFoundError;\n-    private static final ClassEntry CE_NoSuchMethodError;\n-    private static final ClassEntry CE_NoSuchMethodException;\n+    private static final ClassEntry CE_Method;\n@@ -123,0 +123,1 @@\n+    private static final InterfaceMethodRefEntry IMRE_List_get;\n@@ -124,6 +125,0 @@\n-    private static final MethodRefEntry MRE_Class_forName;\n-    private static final MethodRefEntry MRE_Class_getClassLoader;\n-    private static final MethodRefEntry MRE_Class_getMethod;\n-    private static final MethodRefEntry MRE_NoClassDefFoundError_init;\n-    private static final MethodRefEntry MRE_NoSuchMethodError_init;\n-    private static final MethodRefEntry MRE_Throwable_getMessage;\n@@ -132,1 +127,1 @@\n-    private static final Utf8Entry UE_Method;\n+    private static final ConstantDynamicEntry CDE_METHOD_LIST;\n@@ -146,1 +141,1 @@\n-        var ei = new int[21];\n+        var ei = new int[9];\n@@ -153,10 +148,5 @@\n-            ei[0] = cp.classEntry(CD_Class).index();\n-            ei[1] = cp.classEntry(CD_ClassNotFoundException).index();\n-            ei[2] = cp.classEntry(CD_NoClassDefFoundError).index();\n-            ei[3] = cp.classEntry(CD_NoSuchMethodError).index();\n-            ei[4] = cp.classEntry(CD_NoSuchMethodException).index();\n-            ei[5] = cp.classEntry(CD_Object).index();\n-            ei[6] = cp.classEntry(CD_Throwable).index();\n-            ei[7] = cp.classEntry(CD_UndeclaredThrowableException).index();\n-\n-            ei[8] = cp.fieldRefEntry(CD_Proxy, handlerFieldName, CD_InvocationHandler).index();\n+            int i = 0;\n+            ei[i++] = cp.classEntry(CD_Method).index();\n+            ei[i++] = cp.classEntry(CD_Object).index();\n+            ei[i++] = cp.classEntry(CD_Throwable).index();\n+            ei[i++] = cp.classEntry(CD_UndeclaredThrowableException).index();\n@@ -164,1 +154,1 @@\n-            ei[9] = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray).index();\n+            ei[i++] = cp.fieldRefEntry(CD_Proxy, handlerFieldName, CD_InvocationHandler).index();\n@@ -166,7 +156,2 @@\n-            ei[10] = cp.methodRefEntry(CD_Class, \"forName\", MTD_Class_String_boolean_ClassLoader).index();\n-            ei[11] = cp.methodRefEntry(CD_Class, \"getClassLoader\", MTD_ClassLoader).index();\n-            ei[12] = cp.methodRefEntry(CD_Class, \"getMethod\", MTD_Method_String_ClassArray).index();\n-            ei[13] = cp.methodRefEntry(CD_NoClassDefFoundError, INIT_NAME, MTD_void_String).index();\n-            ei[14] = cp.methodRefEntry(CD_NoSuchMethodError, INIT_NAME, MTD_void_String).index();\n-            ei[15] = cp.methodRefEntry(CD_Throwable, \"getMessage\", MTD_String).index();\n-            ei[16] = cp.methodRefEntry(CD_UndeclaredThrowableException, INIT_NAME, MTD_void_Throwable).index();\n+            ei[i++] = cp.interfaceMethodRefEntry(CD_InvocationHandler, \"invoke\", MTD_Object_Object_Method_ObjectArray).index();\n+            ei[i++] = cp.interfaceMethodRefEntry(CD_List, \"get\", MTD_Object_int).index();\n@@ -174,1 +159,1 @@\n-            ei[17] = cp.utf8Entry(CD_Method).index();\n+            ei[i++] = cp.methodRefEntry(CD_UndeclaredThrowableException, INIT_NAME, MTD_void_Throwable).index();\n@@ -176,3 +161,4 @@\n-            ei[18] = cp.utf8Entry(\"m0\").index();\n-            ei[19] = cp.utf8Entry(\"m1\").index();\n-            ei[20] = cp.utf8Entry(\"m2\").index();\n+            ei[i++] = cp.constantDynamicEntry(\n+                    cp.bsmEntry(BSM_CLASS_DATA, List.of()),\n+                    cp.nameAndTypeEntry(DEFAULT_NAME, CD_List)\n+            ).index();\n@@ -181,8 +167,5 @@\n-        CE_Class = entryByIndex(ei[0]);\n-        CE_ClassNotFoundException = entryByIndex(ei[1]);\n-        CE_NoClassDefFoundError = entryByIndex(ei[2]);\n-        CE_NoSuchMethodError = entryByIndex(ei[3]);\n-        CE_NoSuchMethodException = entryByIndex(ei[4]);\n-        CE_Object = entryByIndex(ei[5]);\n-        CE_Throwable = entryByIndex(ei[6]);\n-        CE_UndeclaredThrowableException = entryByIndex(ei[7]);\n+        int i = 0;\n+        CE_Method = entryByIndex(ei[i++]);\n+        CE_Object = entryByIndex(ei[i++]);\n+        CE_Throwable = entryByIndex(ei[i++]);\n+        CE_UndeclaredThrowableException = entryByIndex(ei[i++]);\n@@ -190,1 +173,1 @@\n-        FRE_Proxy_h = entryByIndex(ei[8]);\n+        FRE_Proxy_h = entryByIndex(ei[i++]);\n@@ -192,1 +175,2 @@\n-        IMRE_InvocationHandler_invoke = entryByIndex(ei[9]);\n+        IMRE_InvocationHandler_invoke = entryByIndex(ei[i++]);\n+        IMRE_List_get = entryByIndex(ei[i++]);\n@@ -194,7 +178,1 @@\n-        MRE_Class_forName = entryByIndex(ei[10]);\n-        MRE_Class_getClassLoader = entryByIndex(ei[11]);\n-        MRE_Class_getMethod = entryByIndex(ei[12]);\n-        MRE_NoClassDefFoundError_init = entryByIndex(ei[13]);\n-        MRE_NoSuchMethodError_init = entryByIndex(ei[14]);\n-        MRE_Throwable_getMessage = entryByIndex(ei[15]);\n-        MRE_UndeclaredThrowableException_init = entryByIndex(ei[16]);\n+        MRE_UndeclaredThrowableException_init = entryByIndex(ei[i++]);\n@@ -202,1 +180,1 @@\n-        UE_Method = entryByIndex(ei[17]);\n+        CDE_METHOD_LIST = entryByIndex(ei[i++]);\n@@ -205,3 +183,3 @@\n-            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"), entryByIndex(ei[18]));\n-            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class), entryByIndex(ei[19]));\n-            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"), entryByIndex(ei[20]));\n+            hashCodeMethod = new ProxyMethod(Object.class.getMethod(\"hashCode\"));\n+            equalsMethod = new ProxyMethod(Object.class.getMethod(\"equals\", Object.class));\n+            toStringMethod = new ProxyMethod(Object.class.getMethod(\"toString\"));\n@@ -224,1 +202,1 @@\n-    private ClassEntry classEntry;\n+    private final ClassEntry classEntry;\n@@ -243,6 +221,0 @@\n-    \/**\n-     * Ordinal of next ProxyMethod object added to proxyMethods.\n-     * Indexes are reserved for hashcode(0), equals(1), toString(2).\n-     *\/\n-    private int proxyMethodCount = 3;\n-\n@@ -259,2 +231,2 @@\n-                ClassFile.StackMapsOption.DROP_STACK_MAPS,\n-                ClassFile.ClassHierarchyResolverOption.of(\n+                StackMapsOption.DROP_STACK_MAPS,\n+                ClassHierarchyResolverOption.of(\n@@ -276,1 +248,1 @@\n-    static byte[] generateProxyClass(ClassLoader loader,\n+    static GeneratedClass generateProxyClass(ClassLoader loader,\n@@ -282,1 +254,1 @@\n-        final byte[] classFile = gen.generateClassFile();\n+        var classFile = gen.generateClassFile();\n@@ -298,1 +270,1 @@\n-                                Files.write(path, classFile);\n+                                Files.write(path, classFile.bytecode);\n@@ -416,1 +388,1 @@\n-            ProxyMethod pm = methods.get(0);\n+            ProxyMethod pm = methods.getFirst();\n@@ -520,0 +492,2 @@\n+    record GeneratedClass(byte[] bytecode, List<Method> classData) {}\n+\n@@ -524,1 +498,1 @@\n-    private byte[] generateClassFile() {\n+    private GeneratedClass generateClassFile() {\n@@ -542,1 +516,1 @@\n-                    addProxyMethod(m, intf, cp);\n+                    addProxyMethod(m, cp);\n@@ -555,1 +529,2 @@\n-        return classfileContext.build(classEntry, cp, clb -> {\n+        List<Method> methods = new ArrayList<>();\n+        var bytes = classfileContext.build(classEntry, cp, clb -> {\n@@ -560,0 +535,1 @@\n+            methods.clear();\n@@ -562,3 +538,0 @@\n-                    \/\/ add static field for the Method object\n-                    clb.withField(pm.methodFieldName, UE_Method, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n-\n@@ -566,1 +539,2 @@\n-                    pm.generateMethod(clb, classEntry);\n+                    pm.generateMethod(clb, methods.size());\n+                    methods.add(pm.method);\n@@ -569,2 +543,0 @@\n-\n-            generateStaticInitializer(clb);\n@@ -572,0 +544,1 @@\n+        return new GeneratedClass(bytes, List.copyOf(methods));\n@@ -587,1 +560,1 @@\n-    private void addProxyMethod(Method m, Class<?> fromClass, ConstantPoolBuilder cp) {\n+    private void addProxyMethod(Method m, ConstantPoolBuilder cp) {\n@@ -612,2 +585,1 @@\n-                exceptionTypes, fromClass,\n-                cp.utf8Entry(\"m\" + proxyMethodCount++)));\n+                exceptionTypes));\n@@ -639,39 +611,0 @@\n-    \/**\n-     * Generate the static initializer method for the proxy class.\n-     *\/\n-    private void generateStaticInitializer(ClassBuilder clb) {\n-        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, cob -> {\n-            \/\/ Put ClassLoader at local variable index 0, used by\n-            \/\/ Class.forName(String, boolean, ClassLoader) calls\n-            cob.ldc(classEntry)\n-               .invokevirtual(MRE_Class_getClassLoader)\n-               .astore(0);\n-            var ts = cob.newBoundLabel();\n-            for (List<ProxyMethod> sigmethods : proxyMethods.values()) {\n-                for (ProxyMethod pm : sigmethods) {\n-                    pm.codeFieldInitialization(cob, classEntry);\n-                }\n-            }\n-            cob.return_();\n-            var c1 = cob.newBoundLabel();\n-            cob.exceptionCatch(ts, c1, c1, CE_NoSuchMethodException)\n-               .new_(CE_NoSuchMethodError)\n-               .dup_x1()\n-               .swap()\n-               .invokevirtual(MRE_Throwable_getMessage)\n-               .invokespecial(MRE_NoSuchMethodError_init)\n-               .athrow();\n-            var c2 = cob.newBoundLabel();\n-            cob.exceptionCatch(ts, c1, c2, CE_ClassNotFoundException)\n-               .new_(CE_NoClassDefFoundError)\n-               .dup_x1()\n-               .swap()\n-               .invokevirtual(MRE_Throwable_getMessage)\n-               .invokespecial(MRE_NoClassDefFoundError_init)\n-               .athrow()\n-               .with(StackMapTableAttribute.of(List.of(\n-                     StackMapFrameInfo.of(c1, List.of(), THROWABLE_STACK),\n-                     StackMapFrameInfo.of(c2, List.of(), THROWABLE_STACK))));\n-        });\n-    }\n-\n@@ -716,1 +649,0 @@\n-        private final Class<?> fromClass;\n@@ -719,1 +651,0 @@\n-        private final Utf8Entry methodFieldName;\n@@ -723,2 +654,1 @@\n-                            Class<?> returnType, Class<?>[] exceptionTypes,\n-                            Class<?> fromClass, Utf8Entry methodFieldName) {\n+                            Class<?> returnType, Class<?>[] exceptionTypes) {\n@@ -730,2 +660,0 @@\n-            this.fromClass = fromClass;\n-            this.methodFieldName = methodFieldName;\n@@ -738,1 +666,0 @@\n-         * @param methodFieldName the fieldName to generate\n@@ -740,1 +667,1 @@\n-        private ProxyMethod(Method method, Utf8Entry methodFieldName) {\n+        private ProxyMethod(Method method) {\n@@ -743,1 +670,1 @@\n-                 method.getSharedExceptionTypes(), method.getDeclaringClass(), methodFieldName);\n+                 method.getSharedExceptionTypes());\n@@ -749,1 +676,1 @@\n-        private void generateMethod(ClassBuilder clb, ClassEntry className) {\n+        private void generateMethod(ClassBuilder clb, int index) {\n@@ -762,1 +689,4 @@\n-                           .getstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n+                           .ldc(CDE_METHOD_LIST)\n+                           .loadConstant(index)\n+                           .invokeinterface(IMRE_List_get)\n+                           .checkcast(CE_Method);\n@@ -840,48 +770,0 @@\n-        \/**\n-         * Generate code for initializing the static field that stores\n-         * the Method object for this proxy method. A class loader is\n-         * anticipated at local variable index 0.\n-         *\/\n-        private void codeFieldInitialization(CodeBuilder cob, ClassEntry className) {\n-            var cp = cob.constantPool();\n-            codeClassForName(cob, fromClass);\n-\n-            cob.ldc(method.getName())\n-               .loadConstant(parameterTypes.length)\n-               .anewarray(CE_Class);\n-\n-            \/\/ Construct an array with the parameter types mapping primitives to Wrapper types\n-            for (int i = 0; i < parameterTypes.length; i++) {\n-                cob.dup()\n-                   .loadConstant(i);\n-                if (parameterTypes[i].isPrimitive()) {\n-                    PrimitiveTypeInfo prim = PrimitiveTypeInfo.get(parameterTypes[i]);\n-                    cob.getstatic(prim.typeFieldRef);\n-                } else {\n-                    codeClassForName(cob, parameterTypes[i]);\n-                }\n-                cob.aastore();\n-            }\n-            \/\/ lookup the method\n-            cob.invokevirtual(MRE_Class_getMethod)\n-               .putstatic(cp.fieldRefEntry(className, cp.nameAndTypeEntry(methodFieldName, UE_Method)));\n-        }\n-\n-        \/*\n-         * =============== Code Generation Utility Methods ===============\n-         *\/\n-\n-        \/**\n-         * Generate code to invoke the Class.forName with the name of the given\n-         * class to get its Class object at runtime.  The code is written to\n-         * the supplied stream.  Note that the code generated by this method\n-         * may cause the checked ClassNotFoundException to be thrown. A class\n-         * loader is anticipated at local variable index 0.\n-         *\/\n-        private void codeClassForName(CodeBuilder cob, Class<?> cl) {\n-            cob.ldc(cl.getName())\n-               .iconst_0() \/\/ false\n-               .aload(0)\/\/ classLoader\n-               .invokestatic(MRE_Class_forName);\n-        }\n-\n@@ -922,4 +804,0 @@\n-        \/**\n-         * CP entry of wrapper class TYPE field\n-         *\/\n-        private final FieldRefEntry typeFieldRef;\n@@ -932,1 +810,0 @@\n-            this.typeFieldRef = CP.fieldRefEntry(wrapperClass, \"TYPE\", CD_Class);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":76,"deletions":199,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import java.util.function.IntFunction;\n@@ -58,1 +57,1 @@\n-final class ProxyGenerator {\n+final class ProxyGeneratorLegacy {\n@@ -256,2 +255,2 @@\n-    private ProxyGenerator(ClassLoader loader, String className, List<Class<?>> interfaces,\n-                           int accessFlags) {\n+    private ProxyGeneratorLegacy(ClassLoader loader, String className, List<Class<?>> interfaces,\n+                                 int accessFlags) {\n@@ -281,1 +280,1 @@\n-        ProxyGenerator gen = new ProxyGenerator(loader, name, interfaces, accessFlags);\n+        ProxyGeneratorLegacy gen = new ProxyGeneratorLegacy(loader, name, interfaces, accessFlags);\n@@ -752,1 +751,1 @@\n-                    Arrays.stream(parameterTypes).map(ProxyGenerator::toClassDesc).toArray(ClassDesc[]::new));\n+                    Arrays.stream(parameterTypes).map(ProxyGeneratorLegacy::toClassDesc).toArray(ClassDesc[]::new));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGeneratorLegacy.java","additions":5,"deletions":6,"binary":false,"changes":11,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","status":"copied"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -555,0 +555,5 @@\n+    public static boolean useLegacyProxyImpl() {\n+        var config = config();\n+        return config.useLegacyProxyImpl && !config.useOldSerializableConstructor;\n+    }\n+\n@@ -572,0 +577,1 @@\n+                                                            false,  \/\/ useLegacyProxyImpl\n@@ -587,0 +593,1 @@\n+                          boolean useLegacyProxyImpl,\n@@ -612,0 +619,2 @@\n+        boolean useLegacyProxyImpl =\n+            \"true\".equals(props.getProperty(\"jdk.reflect.useLegacyProxyImpl\"));\n@@ -615,1 +624,3 @@\n-        return new Config(useNativeAccessorOnly, useOldSerializableConstructor, disableSerialConstructorChecks);\n+        useLegacyProxyImpl &= !useOldSerializableConstructor;\n+\n+        return new Config(useNativeAccessorOnly, useOldSerializableConstructor, useLegacyProxyImpl, disableSerialConstructorChecks);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -275,1 +275,1 @@\n-    result = JVM_LookupDefineClass(env, lookup, utfName, body, length, pd, initialize, flags, classData);\n+    result = JVM_LookupDefineClass(env, loader, lookup, utfName, body, length, pd, initialize, flags, classData);\n","filename":"src\/java.base\/share\/native\/libjava\/ClassLoader.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,1 +230,0 @@\n-                        new StackTraceElement(\"jdk.proxy1.$Proxy0\", \"hashCode\", null, -1),\n","filename":"test\/langtools\/jdk\/jshell\/ExceptionsTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}