{"files":[{"patch":"@@ -105,2 +105,1 @@\n-                                          max_gc_pause_sec,\n-                                          GCTimeRatio);\n+                                          max_gc_pause_sec);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,4 +39,2 @@\n-                                           double gc_pause_goal_sec,\n-                                           uint gc_cost_ratio) :\n-     AdaptiveSizePolicy(gc_pause_goal_sec,\n-                        gc_cost_ratio),\n+                                           double gc_pause_goal_sec) :\n+     AdaptiveSizePolicy(gc_pause_goal_sec),\n@@ -76,0 +74,10 @@\n+\/\/ The throughput goal is implemented as\n+\/\/      _throughput_goal = 1 - (1 \/ (1 + gc_cost_ratio))\n+\/\/ gc_cost_ratio is the ratio\n+\/\/      application cost \/ gc cost\n+\/\/ For example a gc_cost_ratio of 4 translates into a\n+\/\/ throughput goal of .80\n+static double calculate_throughput_goal(double gc_cost_ratio) {\n+  return 1.0 - (1.0 \/ (1.0 + gc_cost_ratio));\n+}\n+\n@@ -81,1 +89,5 @@\n-  if (mutator_time_percent() < _throughput_goal) {\n+  \/\/ Get a local copy and use it inside gc-pause in case the global var gets updated externally.\n+  const uint local_GCTimeRatio = GCTimeRatio;\n+  const double throughput_goal = calculate_throughput_goal(local_GCTimeRatio);\n+\n+  if (mutator_time_percent() < throughput_goal) {\n@@ -83,1 +95,1 @@\n-    const double expected_gc_distance = _trimmed_minor_gc_time_seconds.last() * GCTimeRatio;\n+    const double expected_gc_distance = _trimmed_minor_gc_time_seconds.last() * local_GCTimeRatio;\n@@ -93,1 +105,1 @@\n-      mutator_time_percent(), _throughput_goal, (new_eden - cur_eden)\/K);\n+      mutator_time_percent(), throughput_goal, (new_eden - cur_eden)\/K);\n@@ -121,1 +133,1 @@\n-    const double gc_distance_target = MAX3(minor_gc_time_conservative_estimate() * GCTimeRatio,\n+    const double gc_distance_target = MAX3(minor_gc_time_conservative_estimate() * local_GCTimeRatio,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.cpp","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -64,2 +64,1 @@\n-                       double gc_pause_goal_sec,\n-                       uint gc_time_ratio);\n+                       double gc_pause_goal_sec);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psAdaptiveSizePolicy.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,10 +34,1 @@\n-\/\/ The throughput goal is implemented as\n-\/\/      _throughput_goal = 1 - ( 1 \/ (1 + gc_cost_ratio))\n-\/\/ gc_cost_ratio is the ratio\n-\/\/      application cost \/ gc cost\n-\/\/ For example a gc_cost_ratio of 4 translates into a\n-\/\/ throughput goal of .80\n-\n-AdaptiveSizePolicy::AdaptiveSizePolicy(double gc_pause_goal_sec,\n-                                       uint gc_cost_ratio) :\n-  _throughput_goal(1.0 - double(1.0 \/ (1.0 + (double) gc_cost_ratio))),\n+AdaptiveSizePolicy::AdaptiveSizePolicy(double gc_pause_goal_sec) :\n","filename":"src\/hotspot\/share\/gc\/shared\/adaptiveSizePolicy.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -50,4 +50,0 @@\n-  \/\/ Goal for the fraction of the total time during which application\n-  \/\/ threads run\n-  const double _throughput_goal;\n-\n@@ -173,2 +169,1 @@\n-  AdaptiveSizePolicy(double gc_pause_goal_sec,\n-                     uint gc_cost_ratio);\n+  AdaptiveSizePolicy(double gc_pause_goal_sec);\n","filename":"src\/hotspot\/share\/gc\/shared\/adaptiveSizePolicy.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"}]}