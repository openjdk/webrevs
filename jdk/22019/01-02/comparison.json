{"files":[{"patch":"@@ -128,0 +128,2 @@\n+      heap->forbid_uncommit();\n+\n@@ -250,0 +252,2 @@\n+\n+    heap->allow_uncommit();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -551,1 +551,0 @@\n-    ShenandoahHeapRegion* region = _regions.next();\n@@ -553,0 +552,2 @@\n+    assert(!heap->is_uncommit_in_progress(), \"Cannot uncommit bitmaps while resetting them.\");\n+    ShenandoahHeapRegion* region = _regions.next();\n@@ -555,5 +556,2 @@\n-      {\n-        ShenandoahHeapLocker locker(heap->lock());\n-        if (heap->is_bitmap_slice_committed(region)) {\n-          ctx->clear_bitmap(region);\n-        }\n+      if (heap->is_bitmap_slice_committed(region)) {\n+        ctx->clear_bitmap(region);\n@@ -2346,1 +2344,1 @@\n-    \/\/ slice is should stay committed, exit right away.\n+    \/\/ slice should stay committed, exit right away.\n@@ -2360,0 +2358,21 @@\n+void ShenandoahHeap::forbid_uncommit() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->forbid_uncommit();\n+  }\n+}\n+\n+void ShenandoahHeap::allow_uncommit() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->allow_uncommit();\n+  }\n+}\n+\n+#ifdef ASSERT\n+bool ShenandoahHeap::is_uncommit_in_progress() {\n+  if (_uncommit_thread != nullptr) {\n+    return _uncommit_thread->is_uncommit_in_progress();\n+  }\n+  return false;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -623,0 +623,6 @@\n+  void forbid_uncommit();\n+  void allow_uncommit();\n+#ifdef ASSERT\n+  bool is_uncommit_in_progress();\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,3 @@\n-  : _heap(heap), _lock(Mutex::safepoint - 2, \"ShenandoahUncommit_lock\", true) {\n+  : _heap(heap),\n+    _stop_lock(Mutex::safepoint - 2, \"ShenandoahUncommitStop_lock\", true),\n+    _uncommit_lock(Mutex::safepoint - 2, \"ShenandoahUncommitCancel_lock\", true) {\n@@ -63,1 +65,1 @@\n-      if (has_work(shrink_before, shrink_until)) {\n+      if (should_uncommit(shrink_before, shrink_until)) {\n@@ -69,1 +71,1 @@\n-      MonitorLocker locker(&_lock, Mutex::_no_safepoint_check_flag);\n+      MonitorLocker locker(&_stop_lock, Mutex::_no_safepoint_check_flag);\n@@ -77,0 +79,5 @@\n+bool ShenandoahUncommitThread::should_uncommit(double shrink_before, size_t shrink_until) const {\n+  \/\/ Only start uncommit if the GC is idle, is not trying to run and there is work to do.\n+  return _heap->is_idle() && _uncommit_allowed.is_set() && has_work(shrink_before, shrink_until);\n+}\n+\n@@ -98,1 +105,1 @@\n-    MonitorLocker locker(&_lock, Mutex::_no_safepoint_check_flag);\n+    MonitorLocker locker(&_stop_lock, Mutex::_no_safepoint_check_flag);\n@@ -105,1 +112,1 @@\n-    MonitorLocker locker(&_lock, Mutex::_no_safepoint_check_flag);\n+    MonitorLocker locker(&_stop_lock, Mutex::_no_safepoint_check_flag);\n@@ -110,0 +117,4 @@\n+bool ShenandoahUncommitThread::is_uncommit_allowed() {\n+  return _uncommit_allowed.is_set();\n+}\n+\n@@ -111,1 +122,2 @@\n-  assert (ShenandoahUncommit, \"should be enabled\");\n+  assert(ShenandoahUncommit, \"should be enabled\");\n+  assert(_uncommit_in_progress.is_unset(), \"Uncommit should not be in progress\");\n@@ -116,0 +128,6 @@\n+  if (!is_uncommit_allowed()) {\n+    return;\n+  }\n+\n+  _uncommit_in_progress.set();\n+\n@@ -121,1 +139,5 @@\n-  for (size_t i = _heap->num_regions(); i > 0; i--) { \/\/ care about size_t underflow\n+  for (size_t i = _heap->num_regions(); i > 0; i--) {\n+    if (!is_uncommit_allowed()) {\n+      break;\n+    }\n+\n@@ -138,0 +160,6 @@\n+  {\n+    MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+    _uncommit_in_progress.unset();\n+    locker.notify_all();\n+  }\n+\n@@ -146,1 +174,1 @@\n-  MonitorLocker locker(&_lock, Mutex::_safepoint_check_flag);\n+  MonitorLocker locker(&_stop_lock, Mutex::_safepoint_check_flag);\n@@ -150,0 +178,12 @@\n+\n+void ShenandoahUncommitThread::forbid_uncommit() {\n+  MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+  _uncommit_allowed.unset();\n+  while (_uncommit_in_progress.is_set()) {\n+    locker.wait();\n+  }\n+}\n+\n+void ShenandoahUncommitThread::allow_uncommit() {\n+  _uncommit_allowed.set();\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUncommitThread.cpp","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -37,1 +37,4 @@\n-  Monitor _lock;\n+  ShenandoahSharedFlag _uncommit_allowed;\n+  ShenandoahSharedFlag _uncommit_in_progress;\n+  Monitor _stop_lock;\n+  Monitor _uncommit_lock;\n@@ -39,0 +42,1 @@\n+  bool should_uncommit(double shrink_before, size_t shrink_until) const;\n@@ -41,0 +45,2 @@\n+\n+  bool is_uncommit_allowed();\n@@ -53,0 +59,10 @@\n+  \/\/ Wait for uncommit operations to stop, returns immediately if uncommit thread is idle\n+  void forbid_uncommit();\n+\n+  \/\/ Allows uncommit operations to happen, does not block.\n+  void allow_uncommit();\n+\n+  \/\/ True if uncommit is in progress.\n+  bool is_uncommit_in_progress() {\n+    return _uncommit_in_progress.is_set();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUncommitThread.hpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"}]}