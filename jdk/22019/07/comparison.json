{"files":[{"patch":"@@ -43,0 +43,14 @@\n+\/\/ Regions cannot be uncommitted when concurrent reset is zeroing out the bitmaps.\n+\/\/ This CADR class enforces this by forbidding region uncommits while it is in scope.\n+class ShenandoahNoUncommitMark : public StackObj {\n+  ShenandoahHeap* const _heap;\n+public:\n+  explicit ShenandoahNoUncommitMark(ShenandoahHeap* heap) : _heap(heap) {\n+    _heap->forbid_uncommit();\n+  }\n+\n+  ~ShenandoahNoUncommitMark() {\n+    _heap->allow_uncommit();\n+  }\n+};\n+\n@@ -58,1 +72,0 @@\n-  double last_shrink_time = os::elapsedTime();\n@@ -61,6 +74,0 @@\n-  \/\/ Shrink period avoids constantly polling regions for shrinking.\n-  \/\/ Having a period 10x lower than the delay would mean we hit the\n-  \/\/ shrinking with lag of less than 1\/10-th of true delay.\n-  \/\/ ShenandoahUncommitDelay is in msecs, but shrink_period is in seconds.\n-  const double shrink_period = (double)ShenandoahUncommitDelay \/ 1000 \/ 10;\n-\n@@ -78,3 +85,0 @@\n-    \/\/ Check if we have seen a new target for soft max heap size.\n-    const bool soft_max_changed = heap->check_soft_max_changed();\n-\n@@ -138,0 +142,3 @@\n+      \/\/ Cannot uncommit bitmap slices during concurrent reset\n+      ShenandoahNoUncommitMark forbid_region_uncommit(heap);\n+\n@@ -240,18 +247,8 @@\n-    const double current = os::elapsedTime();\n-\n-    if (ShenandoahUncommit && (is_gc_requested || soft_max_changed || (current - last_shrink_time > shrink_period))) {\n-      \/\/ Explicit GC tries to uncommit everything down to min capacity.\n-      \/\/ Soft max change tries to uncommit everything down to target capacity.\n-      \/\/ Periodic uncommit tries to uncommit suitable regions down to min capacity.\n-\n-      double shrink_before = (is_gc_requested || soft_max_changed) ?\n-                             current :\n-                             current - (ShenandoahUncommitDelay \/ 1000.0);\n-\n-      size_t shrink_until = soft_max_changed ?\n-                             heap->soft_max_capacity() :\n-                             heap->min_capacity();\n-\n-      heap->maybe_uncommit(shrink_before, shrink_until);\n-      heap->phase_timings()->flush_cycle_to_global();\n-      last_shrink_time = current;\n+    \/\/ Check if we have seen a new target for soft max heap size or if a gc was requested.\n+    \/\/ Either of these conditions will attempt to uncommit regions.\n+    if (ShenandoahUncommit) {\n+      if (heap->check_soft_max_changed()) {\n+        heap->notify_soft_max_changed();\n+      } else if (is_gc_requested) {\n+        heap->notify_explicit_gc_requested();\n+      }\n@@ -263,0 +260,1 @@\n+    const double current = os::elapsedTime();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":26,"deletions":28,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -27,2 +27,4 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/universe.hpp\"\n+\n+#include \"cds\/archiveHeapWriter.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"code\/codeCache.hpp\"\n@@ -41,1 +43,1 @@\n-#include \"gc\/shenandoah\/shenandoahClosures.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCodeRoots.hpp\"\n@@ -45,1 +47,0 @@\n-#include \"gc\/shenandoah\/shenandoahMarkingContext.inline.hpp\"\n@@ -47,0 +48,1 @@\n+#include \"gc\/shenandoah\/shenandoahClosures.inline.hpp\"\n@@ -48,1 +50,0 @@\n-#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n@@ -60,0 +61,1 @@\n+#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n@@ -63,0 +65,1 @@\n+#include \"gc\/shenandoah\/shenandoahUncommitThread.hpp\"\n@@ -65,1 +68,0 @@\n-#include \"gc\/shenandoah\/shenandoahCodeRoots.hpp\"\n@@ -75,3 +77,2 @@\n-#include \"cds\/archiveHeapWriter.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"code\/codeCache.hpp\"\n+\n+#include \"memory\/allocation.hpp\"\n@@ -80,0 +81,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -423,0 +425,4 @@\n+  if (ShenandoahUncommit) {\n+    _uncommit_thread = new ShenandoahUncommitThread(this);\n+  }\n+\n@@ -492,0 +498,1 @@\n+  _uncommit_thread(nullptr),\n@@ -547,1 +554,0 @@\n-    ShenandoahHeapRegion* region = _regions.next();\n@@ -549,0 +555,2 @@\n+    assert(!heap->is_uncommit_in_progress(), \"Cannot uncommit bitmaps while resetting them.\");\n+    ShenandoahHeapRegion* region = _regions.next();\n@@ -749,24 +757,3 @@\n-void ShenandoahHeap::maybe_uncommit(double shrink_before, size_t shrink_until) {\n-  assert (ShenandoahUncommit, \"should be enabled\");\n-\n-  \/\/ Determine if there is work to do. This avoids taking heap lock if there is\n-  \/\/ no work available, avoids spamming logs with superfluous logging messages,\n-  \/\/ and minimises the amount of work while locks are taken.\n-\n-  if (committed() <= shrink_until) return;\n-\n-  bool has_work = false;\n-  for (size_t i = 0; i < num_regions(); i++) {\n-    ShenandoahHeapRegion* r = get_region(i);\n-    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n-      has_work = true;\n-      break;\n-    }\n-  }\n-\n-  if (has_work) {\n-    static const char* msg = \"Concurrent uncommit\";\n-    ShenandoahConcurrentPhase gcPhase(msg, ShenandoahPhaseTimings::conc_uncommit, true \/* log_heap_usage *\/);\n-    EventMark em(\"%s\", msg);\n-\n-    op_uncommit(shrink_before, shrink_until);\n+void ShenandoahHeap::notify_soft_max_changed() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->notify_soft_max_changed();\n@@ -776,27 +763,3 @@\n-void ShenandoahHeap::op_uncommit(double shrink_before, size_t shrink_until) {\n-  assert (ShenandoahUncommit, \"should be enabled\");\n-\n-  \/\/ Application allocates from the beginning of the heap, and GC allocates at\n-  \/\/ the end of it. It is more efficient to uncommit from the end, so that applications\n-  \/\/ could enjoy the near committed regions. GC allocations are much less frequent,\n-  \/\/ and therefore can accept the committing costs.\n-\n-  size_t count = 0;\n-  for (size_t i = num_regions(); i > 0; i--) { \/\/ care about size_t underflow\n-    ShenandoahHeapRegion* r = get_region(i - 1);\n-    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n-      ShenandoahHeapLocker locker(lock());\n-      if (r->is_empty_committed()) {\n-        if (committed() < shrink_until + ShenandoahHeapRegion::region_size_bytes()) {\n-          break;\n-        }\n-\n-        r->make_uncommitted();\n-        count++;\n-      }\n-    }\n-    SpinPause(); \/\/ allow allocators to take the lock\n-  }\n-\n-  if (count > 0) {\n-    notify_heap_changed();\n+void ShenandoahHeap::notify_explicit_gc_requested() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->notify_explicit_gc_requested();\n@@ -1382,0 +1345,4 @@\n+  if (_uncommit_thread != nullptr) {\n+    tcl->do_thread(_uncommit_thread);\n+  }\n+\n@@ -1964,0 +1931,5 @@\n+\n+  \/\/ Stop 4. Shutdown uncommit thread.\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->stop();\n+  }\n@@ -2375,1 +2347,1 @@\n-    \/\/ slice is should stay committed, exit right away.\n+    \/\/ slice should stay committed, exit right away.\n@@ -2389,0 +2361,21 @@\n+void ShenandoahHeap::forbid_uncommit() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->forbid_uncommit();\n+  }\n+}\n+\n+void ShenandoahHeap::allow_uncommit() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->allow_uncommit();\n+  }\n+}\n+\n+#ifdef ASSERT\n+bool ShenandoahHeap::is_uncommit_in_progress() {\n+  if (_uncommit_thread != nullptr) {\n+    return _uncommit_thread->is_uncommit_in_progress();\n+  }\n+  return false;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":55,"deletions":62,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+class ShenandoahUncommitThread;\n@@ -212,1 +213,2 @@\n-private:\n+public:\n+  \/\/ Notify heuristics and region state change logger that the state of the heap has changed\n@@ -215,1 +217,1 @@\n-public:\n+  \/\/ Force counters to update\n@@ -217,0 +219,2 @@\n+\n+  \/\/ Update counters if forced flag is set\n@@ -376,5 +380,0 @@\n-  \/\/ These will uncommit empty regions if heap::committed > shrink_until\n-  \/\/ and there exists at least one region which was made empty before shrink_before.\n-  void maybe_uncommit(double shrink_before, size_t shrink_until);\n-  void op_uncommit(double shrink_before, size_t shrink_until);\n-\n@@ -410,0 +409,6 @@\n+  \/\/ The uncommit thread targets soft max heap, notify this thread when that value has changed.\n+  void notify_soft_max_changed();\n+\n+  \/\/ An explicit GC request may have freed regions, notify the uncommit thread.\n+  void notify_explicit_gc_requested();\n+\n@@ -413,0 +418,1 @@\n+  \/\/ The control thread presides over concurrent collection cycles\n@@ -414,0 +420,3 @@\n+\n+  \/\/ The uncommit thread periodically attempts to uncommit regions that have been empty for longer than ShenandoahUncommitDelay\n+  ShenandoahUncommitThread*  _uncommit_thread;\n@@ -625,0 +634,14 @@\n+  \/\/ During concurrent reset, the control thread will zero out the mark bitmaps for committed regions.\n+  \/\/ This cannot happen when the uncommit thread is simultaneously trying to uncommit regions and their bitmaps.\n+  \/\/ To prevent these threads from working at the same time, we provide these methods for the control thread to\n+  \/\/ prevent the uncommit thread from working while a collection cycle is in progress.\n+\n+  \/\/ Forbid uncommits (will stop and wait if regions are being uncommitted)\n+  void forbid_uncommit();\n+\n+  \/\/ Allow the uncommit thread to process regions\n+  void allow_uncommit();\n+#ifdef ASSERT\n+  bool is_uncommit_in_progress();\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -177,1 +177,0 @@\n-  f(conc_uncommit,                                  \"Concurrent Uncommit\")             \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUncommitThread.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"utilities\/events.hpp\"\n+\n+ShenandoahUncommitThread::ShenandoahUncommitThread(ShenandoahHeap* heap)\n+  : _heap(heap),\n+    _stop_lock(Mutex::safepoint - 2, \"ShenandoahUncommitStop_lock\", true),\n+    _uncommit_lock(Mutex::safepoint - 2, \"ShenandoahUncommitCancel_lock\", true) {\n+  set_name(\"Shenandoah Uncommit Thread\");\n+  create_and_start();\n+\n+  \/\/ Allow uncommits. This is managed by the control thread during a GC.\n+  _uncommit_allowed.set();\n+}\n+\n+void ShenandoahUncommitThread::run_service() {\n+  assert(ShenandoahUncommit, \"Thread should only run when uncommit is enabled\");\n+\n+  \/\/ Shrink period avoids constantly polling regions for shrinking.\n+  \/\/ Having a period 10x lower than the delay would mean we hit the\n+  \/\/ shrinking with lag of less than 1\/10-th of true delay.\n+  \/\/ ShenandoahUncommitDelay is in millis, but shrink_period is in seconds.\n+  double shrink_period = (double)ShenandoahUncommitDelay \/ 1000 \/ 10;\n+  double last_shrink_time = os::elapsedTime();\n+  while (!should_terminate()) {\n+    double current = os::elapsedTime();\n+    bool soft_max_changed = _soft_max_changed.try_unset();\n+    bool explicit_gc_requested = _explicit_gc_requested.try_unset();\n+\n+    if (soft_max_changed || explicit_gc_requested || current - last_shrink_time > shrink_period) {\n+      size_t shrink_until = soft_max_changed ? _heap->soft_max_capacity() : _heap->min_capacity();\n+      double shrink_before = (soft_max_changed || explicit_gc_requested) ?\n+              current :\n+              current - ((double) ShenandoahUncommitDelay \/ 1000.0);\n+\n+      \/\/ Explicit GC tries to uncommit everything down to min capacity.\n+      \/\/ Soft max change tries to uncommit everything down to target capacity.\n+      \/\/ Periodic uncommit tries to uncommit suitable regions down to min capacity.\n+      if (should_uncommit(shrink_before, shrink_until)) {\n+        uncommit(shrink_before, shrink_until);\n+        last_shrink_time = current;\n+      }\n+    }\n+    {\n+      MonitorLocker locker(&_stop_lock, Mutex::_no_safepoint_check_flag);\n+      if (!_stop_requested.is_set()) {\n+        locker.wait((int64_t)shrink_period);\n+      }\n+    }\n+  }\n+}\n+\n+bool ShenandoahUncommitThread::should_uncommit(double shrink_before, size_t shrink_until) const {\n+  \/\/ Only start uncommit if the GC is idle, is not trying to run and there is work to do.\n+  return _heap->is_idle() && is_uncommit_allowed() && has_work(shrink_before, shrink_until);\n+}\n+\n+bool ShenandoahUncommitThread::has_work(double shrink_before, size_t shrink_until) const {\n+  \/\/ Determine if there is work to do. This avoids locking the heap if there is\n+  \/\/ no work available, avoids spamming logs with superfluous logging messages,\n+  \/\/ and minimises the amount of work while locks are held.\n+\n+  if (_heap->committed() <= shrink_until) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < _heap->num_regions(); i++) {\n+    ShenandoahHeapRegion *r = _heap->get_region(i);\n+    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+void ShenandoahUncommitThread::notify_soft_max_changed() {\n+  assert(is_uncommit_allowed(), \"Only notify if uncommit is allowed\");\n+  if (_soft_max_changed.try_set()) {\n+    MonitorLocker locker(&_stop_lock, Mutex::_no_safepoint_check_flag);\n+    locker.notify_all();\n+  }\n+}\n+\n+void ShenandoahUncommitThread::notify_explicit_gc_requested() {\n+  assert(is_uncommit_allowed(), \"Only notify if uncommit is allowed\");\n+  if (_explicit_gc_requested.try_set()) {\n+    MonitorLocker locker(&_stop_lock, Mutex::_no_safepoint_check_flag);\n+    locker.notify_all();\n+  }\n+}\n+\n+bool ShenandoahUncommitThread::is_uncommit_allowed() const {\n+  return _uncommit_allowed.is_set();\n+}\n+\n+void ShenandoahUncommitThread::uncommit(double shrink_before, size_t shrink_until) {\n+  assert(ShenandoahUncommit, \"should be enabled\");\n+  assert(_uncommit_in_progress.is_unset(), \"Uncommit should not be in progress\");\n+\n+  if (!is_uncommit_allowed()) {\n+    return;\n+  }\n+\n+  const char* msg = \"Concurrent uncommit\";\n+  EventMark em(\"%s\", msg);\n+  double start = os::elapsedTime();\n+  size_t committed_start = _heap->committed();\n+  log_info(gc, start)(\"%s\", msg);\n+\n+  _uncommit_in_progress.set();\n+\n+  \/\/ Application allocates from the beginning of the heap, and GC allocates at\n+  \/\/ the end of it. It is more efficient to uncommit from the end, so that applications\n+  \/\/ could enjoy the near committed regions. GC allocations are much less frequent,\n+  \/\/ and therefore can accept the committing costs.\n+  size_t count = 0;\n+  for (size_t i = _heap->num_regions(); i > 0; i--) {\n+    if (!is_uncommit_allowed()) {\n+      break;\n+    }\n+\n+    ShenandoahHeapRegion* r = _heap->get_region(i - 1);\n+    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n+      SuspendibleThreadSetJoiner sts_joiner;\n+      ShenandoahHeapLocker locker(_heap->lock());\n+      if (r->is_empty_committed()) {\n+        if (_heap->committed() < shrink_until + ShenandoahHeapRegion::region_size_bytes()) {\n+          break;\n+        }\n+\n+        r->make_uncommitted();\n+        count++;\n+      }\n+    }\n+    SpinPause(); \/\/ allow allocators to take the lock\n+  }\n+\n+  {\n+    MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+    _uncommit_in_progress.unset();\n+    locker.notify_all();\n+  }\n+\n+  if (count > 0) {\n+    _heap->notify_heap_changed();\n+  }\n+\n+  size_t committed_end = _heap->committed();\n+  double elapsed = os::elapsedTime() - start;\n+  log_info(gc)(\"%s \" PROPERFMT \"(\" PROPERFMT \") %.3fms\",\n+               msg, PROPERFMTARGS(committed_start - committed_end), PROPERFMTARGS(_heap->capacity()),\n+               elapsed * MILLIUNITS);\n+}\n+\n+void ShenandoahUncommitThread::stop_service() {\n+  MonitorLocker locker(&_stop_lock, Mutex::_safepoint_check_flag);\n+  _stop_requested.set();\n+  locker.notify_all();\n+}\n+\n+void ShenandoahUncommitThread::forbid_uncommit() {\n+  MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+  _uncommit_allowed.unset();\n+  while (_uncommit_in_progress.is_set()) {\n+    locker.wait();\n+  }\n+}\n+\n+void ShenandoahUncommitThread::allow_uncommit() {\n+  _uncommit_allowed.set();\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUncommitThread.cpp","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHUNCOMMITTHREAD\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHUNCOMMITTHREAD\n+\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+\n+class ShenandoahHeap;\n+\n+class ShenandoahUncommitThread : public ConcurrentGCThread {\n+  ShenandoahHeap* const _heap;\n+\n+  \/\/ Indicates that `SoftMaxHeapSize` has changed\n+  ShenandoahSharedFlag _soft_max_changed;\n+\n+  \/\/ Indicates that an explicit gc has been requested\n+  ShenandoahSharedFlag _explicit_gc_requested;\n+\n+  \/\/ Indicates that the thread should stop and terminate\n+  ShenandoahSharedFlag _stop_requested;\n+\n+  \/\/ Indicates whether it is safe to uncommit regions\n+  ShenandoahSharedFlag _uncommit_allowed;\n+\n+  \/\/ Indicates that regions are being actively uncommitted\n+  ShenandoahSharedFlag _uncommit_in_progress;\n+\n+  \/\/ This lock is used to coordinate stopping and terminating this thread\n+  Monitor _stop_lock;\n+\n+  \/\/ This lock is used to coordinate allowing or forbidding regions to be uncommitted\n+  Monitor _uncommit_lock;\n+\n+  \/\/ True if there are regions to uncommit and uncommits are allowed\n+  bool should_uncommit(double shrink_before, size_t shrink_until) const;\n+\n+  \/\/ True if there are regions that have been empty for longer than ShenandoahUncommitDelay and the committed\n+  \/\/ memory is higher than soft max capacity or minimum capacity\n+  bool has_work(double shrink_before, size_t shrink_until) const;\n+\n+  \/\/ Perform the work of uncommitting empty regions\n+  void uncommit(double shrink_before, size_t shrink_until);\n+\n+  \/\/ True if the control thread has allowed this thread to uncommit regions\n+  bool is_uncommit_allowed() const;\n+\n+public:\n+  explicit ShenandoahUncommitThread(ShenandoahHeap* heap);\n+\n+  \/\/ Periodically check for regions to uncommit\n+  void run_service() override;\n+\n+  \/\/ Wake up this thread and try to uncommit for changed soft max size\n+  void notify_soft_max_changed();\n+\n+  \/\/ Wake up this thread and try to uncommit for min heap size\n+  void notify_explicit_gc_requested();\n+\n+  \/\/ Wait for uncommit operations to stop, returns immediately if uncommit thread is idle\n+  void forbid_uncommit();\n+\n+  \/\/ Allows uncommit operations to happen, does not block\n+  void allow_uncommit();\n+\n+  \/\/ True if uncommit is in progress\n+  bool is_uncommit_in_progress() {\n+    return _uncommit_in_progress.is_set();\n+  }\n+protected:\n+  \/\/ Interrupt and stop this thread\n+  void stop_service() override;\n+};\n+\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHUNCOMMITTHREAD\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUncommitThread.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"}]}