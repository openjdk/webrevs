{"files":[{"patch":"@@ -43,0 +43,13 @@\n+\/\/ Regions cannot be uncommitted when concurrent reset is zeroing out the bitmaps.\n+\/\/ This CADR class enforces this by forbidding region uncommits while it is in scope.\n+struct ShenandoahForbidRegionUncommit : public StackObj {\n+  ShenandoahHeap* const _heap;\n+  explicit ShenandoahForbidRegionUncommit(ShenandoahHeap* heap) : _heap(heap) {\n+    _heap->forbid_uncommit();\n+  }\n+\n+  ~ShenandoahForbidRegionUncommit() {\n+    _heap->allow_uncommit();\n+  }\n+};\n+\n@@ -128,1 +141,2 @@\n-      heap->forbid_uncommit();\n+      \/\/ Cannot uncommit bitmap slices during concurrent reset\n+      ShenandoahForbidRegionUncommit forbid_region_uncommit(heap);\n@@ -253,1 +267,0 @@\n-    heap->allow_uncommit();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -214,0 +214,1 @@\n+  \/\/ Notify heuristics and region state change logger that the state of the heap has changed\n@@ -215,0 +216,2 @@\n+\n+  \/\/ Force counters to update\n@@ -216,0 +219,2 @@\n+\n+  \/\/ Update counters if forced flag is set\n@@ -404,0 +409,1 @@\n+  \/\/ The uncommit thread targets soft max heap, notify this thread when that value has changed.\n@@ -405,0 +411,2 @@\n+\n+  \/\/ An explicit GC request may have freed regions, notify the uncommit thread.\n@@ -410,0 +418,1 @@\n+  \/\/ The control thread presides over concurrent collection cycles\n@@ -411,0 +420,2 @@\n+\n+  \/\/ The uncommit thread periodically attempts to uncommit regions that have been empty for longer than ShenandoahUncommitDelay\n@@ -623,0 +634,6 @@\n+  \/\/ During concurrent reset, the control thread will zero out the mark bitmaps for committed regions.\n+  \/\/ This cannot happen when the uncommit thread is simultaneously trying to uncommit regions and their bitmaps.\n+  \/\/ To prevent these threads from working at the same time, we provide these methods for the control thread to\n+  \/\/ prevent the uncommit thread from working while a collection cycle is in progress.\n+\n+  \/\/ Forbid uncommits (will stop and wait if regions are being uncommitted)\n@@ -624,0 +641,2 @@\n+\n+  \/\/ Allow the uncommit thread to process regions\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  return _heap->is_idle() && _uncommit_allowed.is_set() && has_work(shrink_before, shrink_until);\n+  return _heap->is_idle() && is_uncommit_allowed() && has_work(shrink_before, shrink_until);\n@@ -85,1 +85,1 @@\n-  \/\/ Determine if there is work to do. This avoids taking heap lock if there is\n+  \/\/ Determine if there is work to do. This avoids locking the heap if there is\n@@ -87,1 +87,1 @@\n-  \/\/ and minimises the amount of work while locks are taken.\n+  \/\/ and minimises the amount of work while locks are held.\n@@ -104,0 +104,1 @@\n+  assert(is_uncommit_allowed(), \"Only notify if uncommit is allowed\");\n@@ -111,0 +112,1 @@\n+  assert(is_uncommit_allowed(), \"Only notify if uncommit is allowed\");\n@@ -117,1 +119,1 @@\n-bool ShenandoahUncommitThread::is_uncommit_allowed() {\n+bool ShenandoahUncommitThread::is_uncommit_allowed() const {\n@@ -189,1 +191,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUncommitThread.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+\n+  \/\/ Indicates that `SoftMaxHeapSize` has changed\n@@ -35,0 +37,2 @@\n+\n+  \/\/ Indicates that an explicit gc has been requested\n@@ -36,0 +40,2 @@\n+\n+  \/\/ Indicates that the thread should stop and terminate\n@@ -37,0 +43,2 @@\n+\n+  \/\/ Indicates whether it is safe to uncommit regions\n@@ -38,0 +46,2 @@\n+\n+  \/\/ Indicates that regions are being actively uncommitted\n@@ -39,0 +49,2 @@\n+\n+  \/\/ This lock is used to coordinate stopping and terminating this thread\n@@ -40,0 +52,2 @@\n+\n+  \/\/ This lock is used to coordinate allowing or forbidding regions to be uncommitted\n@@ -42,0 +56,1 @@\n+  \/\/ True if there are regions to uncommit and uncommits are allowed\n@@ -43,0 +58,3 @@\n+\n+  \/\/ True if there are regions that have been empty for longer than ShenandoahUncommitDelay and the committed\n+  \/\/ memory is higher than soft max capacity or minimum capacity\n@@ -44,0 +62,2 @@\n+\n+  \/\/ Perform the work of uncommitting empty regions\n@@ -46,1 +66,3 @@\n-  bool is_uncommit_allowed();\n+  \/\/ True if the control thread has allowed this thread to uncommit regions\n+  bool is_uncommit_allowed() const;\n+\n@@ -50,1 +72,1 @@\n-  \/\/ Periodically check for regions to uncommit.\n+  \/\/ Periodically check for regions to uncommit\n@@ -62,1 +84,1 @@\n-  \/\/ Allows uncommit operations to happen, does not block.\n+  \/\/ Allows uncommit operations to happen, does not block\n@@ -65,1 +87,1 @@\n-  \/\/ True if uncommit is in progress.\n+  \/\/ True if uncommit is in progress\n@@ -70,0 +92,1 @@\n+  \/\/ Interrupt and stop this thread\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUncommitThread.hpp","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"}]}