{"files":[{"patch":"@@ -58,1 +58,0 @@\n-  double last_shrink_time = os::elapsedTime();\n@@ -61,6 +60,0 @@\n-  \/\/ Shrink period avoids constantly polling regions for shrinking.\n-  \/\/ Having a period 10x lower than the delay would mean we hit the\n-  \/\/ shrinking with lag of less than 1\/10-th of true delay.\n-  \/\/ ShenandoahUncommitDelay is in msecs, but shrink_period is in seconds.\n-  const double shrink_period = (double)ShenandoahUncommitDelay \/ 1000 \/ 10;\n-\n@@ -78,3 +71,0 @@\n-    \/\/ Check if we have seen a new target for soft max heap size.\n-    const bool soft_max_changed = heap->check_soft_max_changed();\n-\n@@ -138,0 +128,2 @@\n+      heap->forbid_uncommit();\n+\n@@ -240,18 +232,8 @@\n-    const double current = os::elapsedTime();\n-\n-    if (ShenandoahUncommit && (is_gc_requested || soft_max_changed || (current - last_shrink_time > shrink_period))) {\n-      \/\/ Explicit GC tries to uncommit everything down to min capacity.\n-      \/\/ Soft max change tries to uncommit everything down to target capacity.\n-      \/\/ Periodic uncommit tries to uncommit suitable regions down to min capacity.\n-\n-      double shrink_before = (is_gc_requested || soft_max_changed) ?\n-                             current :\n-                             current - (ShenandoahUncommitDelay \/ 1000.0);\n-\n-      size_t shrink_until = soft_max_changed ?\n-                             heap->soft_max_capacity() :\n-                             heap->min_capacity();\n-\n-      heap->maybe_uncommit(shrink_before, shrink_until);\n-      heap->phase_timings()->flush_cycle_to_global();\n-      last_shrink_time = current;\n+    \/\/ Check if we have seen a new target for soft max heap size or if a gc was requested.\n+    \/\/ Either of these conditions will attempt to uncommit regions.\n+    if (ShenandoahUncommit) {\n+      if (heap->check_soft_max_changed()) {\n+        heap->notify_soft_max_changed();\n+      } else if (is_gc_requested) {\n+        heap->notify_explicit_gc_requested();\n+      }\n@@ -263,0 +245,1 @@\n+    const double current = os::elapsedTime();\n@@ -269,0 +252,2 @@\n+\n+    heap->allow_uncommit();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":13,"deletions":28,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -27,2 +27,4 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/universe.hpp\"\n+\n+#include \"cds\/archiveHeapWriter.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"code\/codeCache.hpp\"\n@@ -40,1 +42,1 @@\n-#include \"gc\/shenandoah\/shenandoahClosures.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCodeRoots.hpp\"\n@@ -44,1 +46,0 @@\n-#include \"gc\/shenandoah\/shenandoahMarkingContext.inline.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"gc\/shenandoah\/shenandoahClosures.inline.hpp\"\n@@ -47,1 +49,0 @@\n-#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n@@ -59,0 +60,1 @@\n+#include \"gc\/shenandoah\/shenandoahPhaseTimings.hpp\"\n@@ -62,0 +64,1 @@\n+#include \"gc\/shenandoah\/shenandoahUncommitThread.hpp\"\n@@ -64,1 +67,0 @@\n-#include \"gc\/shenandoah\/shenandoahCodeRoots.hpp\"\n@@ -74,3 +76,2 @@\n-#include \"cds\/archiveHeapWriter.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"code\/codeCache.hpp\"\n+\n+#include \"memory\/allocation.hpp\"\n@@ -79,0 +80,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -422,0 +424,4 @@\n+  if (ShenandoahUncommit) {\n+    _uncommit_thread = new ShenandoahUncommitThread(this);\n+  }\n+\n@@ -489,0 +495,1 @@\n+  _uncommit_thread(nullptr),\n@@ -544,1 +551,0 @@\n-    ShenandoahHeapRegion* region = _regions.next();\n@@ -546,0 +552,2 @@\n+    assert(!heap->is_uncommit_in_progress(), \"Cannot uncommit bitmaps while resetting them.\");\n+    ShenandoahHeapRegion* region = _regions.next();\n@@ -746,24 +754,3 @@\n-void ShenandoahHeap::maybe_uncommit(double shrink_before, size_t shrink_until) {\n-  assert (ShenandoahUncommit, \"should be enabled\");\n-\n-  \/\/ Determine if there is work to do. This avoids taking heap lock if there is\n-  \/\/ no work available, avoids spamming logs with superfluous logging messages,\n-  \/\/ and minimises the amount of work while locks are taken.\n-\n-  if (committed() <= shrink_until) return;\n-\n-  bool has_work = false;\n-  for (size_t i = 0; i < num_regions(); i++) {\n-    ShenandoahHeapRegion* r = get_region(i);\n-    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n-      has_work = true;\n-      break;\n-    }\n-  }\n-\n-  if (has_work) {\n-    static const char* msg = \"Concurrent uncommit\";\n-    ShenandoahConcurrentPhase gcPhase(msg, ShenandoahPhaseTimings::conc_uncommit, true \/* log_heap_usage *\/);\n-    EventMark em(\"%s\", msg);\n-\n-    op_uncommit(shrink_before, shrink_until);\n+void ShenandoahHeap::notify_soft_max_changed() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->notify_soft_max_changed();\n@@ -773,27 +760,3 @@\n-void ShenandoahHeap::op_uncommit(double shrink_before, size_t shrink_until) {\n-  assert (ShenandoahUncommit, \"should be enabled\");\n-\n-  \/\/ Application allocates from the beginning of the heap, and GC allocates at\n-  \/\/ the end of it. It is more efficient to uncommit from the end, so that applications\n-  \/\/ could enjoy the near committed regions. GC allocations are much less frequent,\n-  \/\/ and therefore can accept the committing costs.\n-\n-  size_t count = 0;\n-  for (size_t i = num_regions(); i > 0; i--) { \/\/ care about size_t underflow\n-    ShenandoahHeapRegion* r = get_region(i - 1);\n-    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n-      ShenandoahHeapLocker locker(lock());\n-      if (r->is_empty_committed()) {\n-        if (committed() < shrink_until + ShenandoahHeapRegion::region_size_bytes()) {\n-          break;\n-        }\n-\n-        r->make_uncommitted();\n-        count++;\n-      }\n-    }\n-    SpinPause(); \/\/ allow allocators to take the lock\n-  }\n-\n-  if (count > 0) {\n-    notify_heap_changed();\n+void ShenandoahHeap::notify_explicit_gc_requested() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->notify_explicit_gc_requested();\n@@ -1379,0 +1342,4 @@\n+  if (_uncommit_thread != nullptr) {\n+    tcl->do_thread(_uncommit_thread);\n+  }\n+\n@@ -1961,0 +1928,5 @@\n+\n+  \/\/ Stop 4. Shutdown uncommit thread.\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->stop();\n+  }\n@@ -2372,1 +2344,1 @@\n-    \/\/ slice is should stay committed, exit right away.\n+    \/\/ slice should stay committed, exit right away.\n@@ -2386,0 +2358,21 @@\n+void ShenandoahHeap::forbid_uncommit() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->forbid_uncommit();\n+  }\n+}\n+\n+void ShenandoahHeap::allow_uncommit() {\n+  if (_uncommit_thread != nullptr) {\n+    _uncommit_thread->allow_uncommit();\n+  }\n+}\n+\n+#ifdef ASSERT\n+bool ShenandoahHeap::is_uncommit_in_progress() {\n+  if (_uncommit_thread != nullptr) {\n+    return _uncommit_thread->is_uncommit_in_progress();\n+  }\n+  return false;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":55,"deletions":62,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+class ShenandoahUncommitThread;\n@@ -212,3 +213,0 @@\n-private:\n-  void notify_heap_changed();\n-\n@@ -216,0 +214,1 @@\n+  void notify_heap_changed();\n@@ -376,5 +375,0 @@\n-  \/\/ These will uncommit empty regions if heap::committed > shrink_until\n-  \/\/ and there exists at least one region which was made empty before shrink_before.\n-  void maybe_uncommit(double shrink_before, size_t shrink_until);\n-  void op_uncommit(double shrink_before, size_t shrink_until);\n-\n@@ -410,0 +404,3 @@\n+  void notify_soft_max_changed();\n+  void notify_explicit_gc_requested();\n+\n@@ -414,0 +411,1 @@\n+  ShenandoahUncommitThread*  _uncommit_thread;\n@@ -625,0 +623,6 @@\n+  void forbid_uncommit();\n+  void allow_uncommit();\n+#ifdef ASSERT\n+  bool is_uncommit_in_progress();\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -177,1 +177,0 @@\n-  f(conc_uncommit,                                  \"Concurrent Uncommit\")             \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shenandoah\/shenandoahControlThread.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUncommitThread.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"utilities\/events.hpp\"\n+\n+ShenandoahUncommitThread::ShenandoahUncommitThread(ShenandoahHeap* heap)\n+  : _heap(heap),\n+    _stop_lock(Mutex::safepoint - 2, \"ShenandoahUncommitStop_lock\", true),\n+    _uncommit_lock(Mutex::safepoint - 2, \"ShenandoahUncommitCancel_lock\", true) {\n+  set_name(\"Shenandoah Uncommit Thread\");\n+  create_and_start();\n+}\n+\n+void ShenandoahUncommitThread::run_service() {\n+  assert(ShenandoahUncommit, \"Thread should only run when uncommit is enabled\");\n+\n+  \/\/ Shrink period avoids constantly polling regions for shrinking.\n+  \/\/ Having a period 10x lower than the delay would mean we hit the\n+  \/\/ shrinking with lag of less than 1\/10-th of true delay.\n+  \/\/ ShenandoahUncommitDelay is in millis, but shrink_period is in seconds.\n+  double shrink_period = (double)ShenandoahUncommitDelay \/ 1000 \/ 10;\n+  double last_shrink_time = os::elapsedTime();\n+  while (!should_terminate()) {\n+    double current = os::elapsedTime();\n+    bool soft_max_changed = _soft_max_changed.try_unset();\n+    bool explicit_gc_requested = _explicit_gc_requested.try_unset();\n+\n+    if (soft_max_changed || explicit_gc_requested || current - last_shrink_time > shrink_period) {\n+      size_t shrink_until = soft_max_changed ? _heap->soft_max_capacity() : _heap->min_capacity();\n+      double shrink_before = (soft_max_changed || explicit_gc_requested) ?\n+              current :\n+              current - ((double) ShenandoahUncommitDelay \/ 1000.0);\n+\n+      \/\/ Explicit GC tries to uncommit everything down to min capacity.\n+      \/\/ Soft max change tries to uncommit everything down to target capacity.\n+      \/\/ Periodic uncommit tries to uncommit suitable regions down to min capacity.\n+      if (should_uncommit(shrink_before, shrink_until)) {\n+        uncommit(shrink_before, shrink_until);\n+        last_shrink_time = current;\n+      }\n+    }\n+    {\n+      MonitorLocker locker(&_stop_lock, Mutex::_no_safepoint_check_flag);\n+      if (!_stop_requested.is_set()) {\n+        locker.wait((int64_t)shrink_period);\n+      }\n+    }\n+  }\n+}\n+\n+bool ShenandoahUncommitThread::should_uncommit(double shrink_before, size_t shrink_until) const {\n+  \/\/ Only start uncommit if the GC is idle, is not trying to run and there is work to do.\n+  return _heap->is_idle() && _uncommit_allowed.is_set() && has_work(shrink_before, shrink_until);\n+}\n+\n+bool ShenandoahUncommitThread::has_work(double shrink_before, size_t shrink_until) const {\n+  \/\/ Determine if there is work to do. This avoids taking heap lock if there is\n+  \/\/ no work available, avoids spamming logs with superfluous logging messages,\n+  \/\/ and minimises the amount of work while locks are taken.\n+\n+  if (_heap->committed() <= shrink_until) {\n+    return false;\n+  }\n+\n+  for (size_t i = 0; i < _heap->num_regions(); i++) {\n+    ShenandoahHeapRegion *r = _heap->get_region(i);\n+    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+void ShenandoahUncommitThread::notify_soft_max_changed() {\n+  if (_soft_max_changed.try_set()) {\n+    MonitorLocker locker(&_stop_lock, Mutex::_no_safepoint_check_flag);\n+    locker.notify_all();\n+  }\n+}\n+\n+void ShenandoahUncommitThread::notify_explicit_gc_requested() {\n+  if (_explicit_gc_requested.try_set()) {\n+    MonitorLocker locker(&_stop_lock, Mutex::_no_safepoint_check_flag);\n+    locker.notify_all();\n+  }\n+}\n+\n+bool ShenandoahUncommitThread::is_uncommit_allowed() {\n+  return _uncommit_allowed.is_set();\n+}\n+\n+void ShenandoahUncommitThread::uncommit(double shrink_before, size_t shrink_until) {\n+  assert(ShenandoahUncommit, \"should be enabled\");\n+  assert(_uncommit_in_progress.is_unset(), \"Uncommit should not be in progress\");\n+\n+  EventMark em(\"Concurrent uncommit\");\n+  double start = os::elapsedTime();\n+\n+  if (!is_uncommit_allowed()) {\n+    return;\n+  }\n+\n+  _uncommit_in_progress.set();\n+\n+  \/\/ Application allocates from the beginning of the heap, and GC allocates at\n+  \/\/ the end of it. It is more efficient to uncommit from the end, so that applications\n+  \/\/ could enjoy the near committed regions. GC allocations are much less frequent,\n+  \/\/ and therefore can accept the committing costs.\n+  size_t count = 0;\n+  for (size_t i = _heap->num_regions(); i > 0; i--) {\n+    if (!is_uncommit_allowed()) {\n+      break;\n+    }\n+\n+    ShenandoahHeapRegion* r = _heap->get_region(i - 1);\n+    if (r->is_empty_committed() && (r->empty_time() < shrink_before)) {\n+      SuspendibleThreadSetJoiner sts_joiner;\n+      ShenandoahHeapLocker locker(_heap->lock());\n+      if (r->is_empty_committed()) {\n+        if (_heap->committed() < shrink_until + ShenandoahHeapRegion::region_size_bytes()) {\n+          break;\n+        }\n+\n+        r->make_uncommitted();\n+        count++;\n+      }\n+    }\n+    SpinPause(); \/\/ allow allocators to take the lock\n+  }\n+\n+  {\n+    MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+    _uncommit_in_progress.unset();\n+    locker.notify_all();\n+  }\n+\n+  if (count > 0) {\n+    _heap->notify_heap_changed();\n+    double elapsed = os::elapsedTime() - start;\n+    log_info(gc)(\"Uncommitted \" SIZE_FORMAT \" regions, in %.3fs\", count, elapsed);\n+  }\n+}\n+\n+void ShenandoahUncommitThread::stop_service() {\n+  MonitorLocker locker(&_stop_lock, Mutex::_safepoint_check_flag);\n+  _stop_requested.set();\n+  locker.notify_all();\n+}\n+\n+void ShenandoahUncommitThread::forbid_uncommit() {\n+  MonitorLocker locker(&_uncommit_lock, Mutex::_no_safepoint_check_flag);\n+  _uncommit_allowed.unset();\n+  while (_uncommit_in_progress.is_set()) {\n+    locker.wait();\n+  }\n+}\n+\n+void ShenandoahUncommitThread::allow_uncommit() {\n+  _uncommit_allowed.set();\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUncommitThread.cpp","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHUNCOMMITTHREAD\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHUNCOMMITTHREAD\n+\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+\n+class ShenandoahHeap;\n+\n+class ShenandoahUncommitThread : public ConcurrentGCThread {\n+  ShenandoahHeap* const _heap;\n+  ShenandoahSharedFlag _soft_max_changed;\n+  ShenandoahSharedFlag _explicit_gc_requested;\n+  ShenandoahSharedFlag _stop_requested;\n+  ShenandoahSharedFlag _uncommit_allowed;\n+  ShenandoahSharedFlag _uncommit_in_progress;\n+  Monitor _stop_lock;\n+  Monitor _uncommit_lock;\n+\n+  bool should_uncommit(double shrink_before, size_t shrink_until) const;\n+  bool has_work(double shrink_before, size_t shrink_until) const;\n+  void uncommit(double shrink_before, size_t shrink_until);\n+\n+  bool is_uncommit_allowed();\n+public:\n+  explicit ShenandoahUncommitThread(ShenandoahHeap* heap);\n+\n+  \/\/ Periodically check for regions to uncommit.\n+  void run_service() override;\n+\n+  \/\/ Wake up this thread and try to uncommit for changed soft max size\n+  void notify_soft_max_changed();\n+\n+  \/\/ Wake up this thread and try to uncommit for min heap size\n+  void notify_explicit_gc_requested();\n+\n+  \/\/ Wait for uncommit operations to stop, returns immediately if uncommit thread is idle\n+  void forbid_uncommit();\n+\n+  \/\/ Allows uncommit operations to happen, does not block.\n+  void allow_uncommit();\n+\n+  \/\/ True if uncommit is in progress.\n+  bool is_uncommit_in_progress() {\n+    return _uncommit_in_progress.is_set();\n+  }\n+protected:\n+  void stop_service() override;\n+};\n+\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHUNCOMMITTHREAD\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUncommitThread.hpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}