{"files":[{"patch":"@@ -163,1 +163,1 @@\n-    tlab_allocate(noreg, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);\n+    tlab_allocate(obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,5 +52,1 @@\n-    Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);\n-#ifndef _LP64\n-    __ push(thread);\n-    __ get_thread(thread);\n-#endif\n+    Register thread = r15_thread;\n@@ -68,2 +64,0 @@\n-    NOT_LP64(__ pop(thread);)\n-\n@@ -73,1 +67,0 @@\n-#ifdef _LP64\n@@ -91,4 +84,0 @@\n-#else\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_array_pre_oop_entry),\n-                    addr, count);\n-#endif\n@@ -104,1 +93,0 @@\n-#ifdef _LP64\n@@ -115,4 +103,0 @@\n-#else\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, G1BarrierSetRuntime::write_ref_array_post_entry),\n-                  addr, count);\n-#endif\n@@ -120,0 +104,1 @@\n+\n@@ -123,1 +108,1 @@\n-                                    Register dst, Address src, Register tmp1, Register tmp_thread) {\n+                                    Register dst, Address src, Register tmp1) {\n@@ -128,1 +113,1 @@\n-  ModRefBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);\n+  ModRefBarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1);\n@@ -130,19 +115,0 @@\n-    Register thread = NOT_LP64(tmp_thread) LP64_ONLY(r15_thread);\n-\n-#ifndef _LP64\n-    \/\/ Work around the x86_32 bug that only manifests with Loom for some reason.\n-    \/\/ MacroAssembler::resolve_weak_handle calls this barrier with tmp_thread == noreg.\n-    if (thread == noreg) {\n-      if (dst != rcx && tmp1 != rcx) {\n-        thread = rcx;\n-      } else if (dst != rdx && tmp1 != rdx) {\n-        thread = rdx;\n-      } else if (dst != rdi && tmp1 != rdi) {\n-        thread = rdi;\n-      }\n-    }\n-    assert_different_registers(dst, tmp1, thread);\n-    __ push(thread);\n-    __ get_thread(thread);\n-#endif\n-\n@@ -154,1 +120,0 @@\n-                         thread \/* thread *\/,\n@@ -158,4 +123,0 @@\n-\n-#ifndef _LP64\n-    __ pop(thread);\n-#endif\n@@ -202,1 +163,1 @@\n-    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n+    __ load_heap_oop(pre_val, Address(obj, 0), noreg, AS_RAW);\n@@ -218,1 +179,0 @@\n-                                                 Register thread,\n@@ -226,3 +186,1 @@\n-#ifdef _LP64\n-  assert(thread == r15_thread, \"must be\");\n-#endif \/\/ _LP64\n+  const Register thread = r15_thread;\n@@ -263,2 +221,1 @@\n-    LP64_ONLY( assert(pre_val != c_rarg1, \"smashed arg\"); )\n-#ifdef _LP64\n+    assert(pre_val != c_rarg1, \"smashed arg\");\n@@ -271,4 +228,0 @@\n-#else\n-    __ push(thread);\n-    __ push(pre_val);\n-#endif\n@@ -336,1 +289,0 @@\n-                                                  Register thread,\n@@ -339,3 +291,1 @@\n-#ifdef _LP64\n-  assert(thread == r15_thread, \"must be\");\n-#endif \/\/ _LP64\n+  const Register thread = r15_thread;\n@@ -353,1 +303,1 @@\n-  RegSet saved = RegSet::of(store_addr NOT_LP64(COMMA thread));\n+  RegSet saved = RegSet::of(store_addr);\n@@ -364,1 +314,0 @@\n-#ifdef _LP64\n@@ -376,3 +325,0 @@\n-#else\n-  Unimplemented();\n-#endif \/\/ _LP64\n@@ -384,1 +330,0 @@\n-                                                    Register thread,\n@@ -387,3 +332,2 @@\n-#ifdef _LP64\n-  assert(thread == r15_thread, \"must be\");\n-#endif \/\/ _LP64\n+  const Register thread = r15_thread;\n+\n@@ -425,1 +369,0 @@\n-                                                     Register thread,\n@@ -429,4 +372,1 @@\n-#ifdef _LP64\n-  assert(thread == r15_thread, \"must be\");\n-#endif \/\/ _LP64\n-\n+  const Register thread = r15_thread;\n@@ -470,1 +410,0 @@\n-  Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n@@ -481,7 +420,0 @@\n-#ifndef _LP64\n-  InterpreterMacroAssembler *imasm = static_cast<InterpreterMacroAssembler*>(masm);\n-#endif\n-\n-  NOT_LP64(__ get_thread(rcx));\n-  NOT_LP64(imasm->save_bcp());\n-\n@@ -492,1 +424,0 @@\n-                         rthread \/* thread *\/,\n@@ -513,1 +444,0 @@\n-                            rthread \/* thread *\/,\n@@ -518,1 +448,0 @@\n-  NOT_LP64(imasm->restore_bcp());\n@@ -578,1 +507,1 @@\n-  const Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);\n+  const Register thread = r15_thread;\n@@ -581,2 +510,0 @@\n-  NOT_LP64(__ get_thread(thread);)\n-\n@@ -644,1 +571,1 @@\n-  const Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);\n+  const Register thread = r15_thread;\n@@ -662,2 +589,0 @@\n-  NOT_LP64(__ get_thread(thread);)\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":14,"deletions":89,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-                            Register thread,\n@@ -55,1 +54,0 @@\n-                             Register thread,\n@@ -70,1 +68,1 @@\n-                       Register dst, Address src, Register tmp1, Register tmp_thread);\n+                       Register dst, Address src, Register tmp1);\n@@ -76,1 +74,0 @@\n-                               Register thread,\n@@ -84,1 +81,0 @@\n-                                Register thread,\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  g1_asm->g1_write_barrier_pre_c2(masm, obj, pre_val, r15_thread, tmp, stub);\n+  g1_asm->g1_write_barrier_pre_c2(masm, obj, pre_val, tmp, stub);\n@@ -70,1 +70,1 @@\n-  g1_asm->g1_write_barrier_post_c2(masm, store_addr, new_val, r15_thread, tmp1, tmp2, stub);\n+  g1_asm->g1_write_barrier_post_c2(masm, store_addr, new_val, tmp1, tmp2, stub);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1_x86_64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-                                  Register dst, Address src, Register tmp1, Register tmp_thread) {\n+                                  Register dst, Address src, Register tmp1) {\n@@ -53,1 +53,0 @@\n-#ifdef _LP64\n@@ -61,3 +60,1 @@\n-      } else\n-#endif\n-      {\n+      } else {\n@@ -88,1 +85,0 @@\n-#ifdef _LP64\n@@ -90,12 +86,0 @@\n-#else\n-    if (atomic) {\n-      __ fild_d(src);               \/\/ Must load atomically\n-      __ subptr(rsp,2*wordSize);    \/\/ Make space for store\n-      __ fistp_d(Address(rsp,0));\n-      __ pop(rax);\n-      __ pop(rdx);\n-    } else {\n-      __ movl(rax, src);\n-      __ movl(rdx, src.plus_disp(wordSize));\n-    }\n-#endif\n@@ -120,1 +104,0 @@\n-#ifdef _LP64\n@@ -126,3 +109,0 @@\n-#else\n-        __ movl(dst, NULL_WORD);\n-#endif\n@@ -130,1 +110,0 @@\n-#ifdef _LP64\n@@ -139,3 +118,1 @@\n-        } else\n-#endif\n-        {\n+        } else {\n@@ -170,1 +147,0 @@\n-#ifdef _LP64\n@@ -172,12 +148,0 @@\n-#else\n-    if (atomic) {\n-      __ push(rdx);\n-      __ push(rax);                 \/\/ Must update atomically with FIST\n-      __ fild_d(Address(rsp,0));    \/\/ So load into FPU register\n-      __ fistp_d(dst);              \/\/ and put into memory atomically\n-      __ addptr(rsp, 2*wordSize);\n-    } else {\n-      __ movptr(dst, rax);\n-      __ movptr(dst.plus_disp(wordSize), rdx);\n-    }\n-#endif\n@@ -219,1 +183,0 @@\n-#ifdef _LP64\n@@ -221,3 +184,0 @@\n-#else\n-    fatal(\"No support for 8 bytes copy\");\n-#endif\n@@ -228,1 +188,0 @@\n-#ifdef _LP64\n@@ -232,1 +191,0 @@\n-#endif\n@@ -242,1 +200,0 @@\n-#ifdef _LP64\n@@ -246,1 +203,0 @@\n-#endif\n@@ -259,1 +215,0 @@\n-#ifdef _LP64\n@@ -261,3 +216,0 @@\n-#else\n-    fatal(\"No support for 8 bytes copy\");\n-#endif\n@@ -314,1 +266,1 @@\n-                                        Register thread, Register obj,\n+                                        Register obj,\n@@ -323,9 +275,2 @@\n-  if (!thread->is_valid()) {\n-#ifdef _LP64\n-    thread = r15_thread;\n-#else\n-    assert(t1->is_valid(), \"need temp reg\");\n-    thread = t1;\n-    __ get_thread(thread);\n-#endif\n-  }\n+\n+  const Register thread = r15_thread;\n@@ -354,1 +299,0 @@\n-#ifdef _LP64\n@@ -378,17 +322,0 @@\n-#else\n-void BarrierSetAssembler::nmethod_entry_barrier(MacroAssembler* masm, Label*, Label*) {\n-  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-  Label continuation;\n-\n-  Register tmp = rdi;\n-  __ push(tmp);\n-  __ movptr(tmp, (intptr_t)bs_nm->disarmed_guard_value_address());\n-  Address disarmed_addr(tmp, 0);\n-  __ align(4);\n-  __ cmpl_imm32(disarmed_addr, 0);\n-  __ pop(tmp);\n-  __ jcc(Assembler::equal, continuation);\n-  __ call(RuntimeAddress(StubRoutines::method_entry_barrier()));\n-  __ bind(continuation);\n-}\n-#endif\n@@ -401,6 +328,2 @@\n-  Register tmp1 = LP64_ONLY( rscratch1 ) NOT_LP64( rax );\n-  Register tmp2 = LP64_ONLY( rscratch2 ) NOT_LP64( rcx );\n-#ifndef _LP64\n-  __ push(tmp1);\n-  __ push(tmp2);\n-#endif \/\/ !_LP64\n+  Register tmp1 = rscratch1;\n+  Register tmp2 = rscratch2;\n@@ -422,5 +345,0 @@\n-#ifndef _LP64\n-  __ pop(tmp2);\n-  __ pop(tmp1);\n-#endif\n-\n@@ -430,5 +348,0 @@\n-\n-#ifndef _LP64\n-  __ pop(tmp2);\n-  __ pop(tmp1);\n-#endif\n@@ -454,2 +367,0 @@\n-#ifdef _LP64\n-\n@@ -731,8 +642,0 @@\n-#else \/\/ !_LP64\n-\n-OptoReg::Name BarrierSetAssembler::refine_register(const Node* node, OptoReg::Name opto_reg) {\n-  Unimplemented(); \/\/ This must be implemented to support late barrier expansion.\n-}\n-\n-#endif \/\/ _LP64\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":8,"deletions":105,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-                       Register dst, Address src, Register tmp1, Register tmp_thread);\n+                       Register dst, Address src, Register tmp1);\n@@ -96,1 +96,1 @@\n-                             Register thread, Register obj,\n+                             Register obj,\n@@ -117,2 +117,0 @@\n-#ifdef _LP64\n-\n@@ -163,2 +161,0 @@\n-#endif \/\/ _LP64\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#ifdef _LP64\n@@ -50,8 +49,0 @@\n-#else\n-  enum Intel_specific_constants {\n-    instruction_code        = 0x81,\n-    instruction_size        = 7,\n-    imm_offset              = 2,\n-    instruction_modrm       = 0x3f  \/\/ [rdi]\n-  };\n-#endif\n@@ -73,1 +64,0 @@\n-#ifdef _LP64\n@@ -100,23 +90,0 @@\n-#else\n-bool NativeNMethodCmpBarrier::check_barrier(err_msg& msg) const {\n-  if (((uintptr_t) instruction_address()) & 0x3) {\n-    msg.print(\"Addr: \" INTPTR_FORMAT \" not properly aligned\", p2i(instruction_address()));\n-    return false;\n-  }\n-\n-  int inst = ubyte_at(0);\n-  if (inst != instruction_code) {\n-    msg.print(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x\", p2i(instruction_address()),\n-        inst);\n-    return false;\n-  }\n-\n-  int modrm = ubyte_at(1);\n-  if (modrm != instruction_modrm) {\n-    msg.print(\"Addr: \" INTPTR_FORMAT \" mod\/rm: 0x%x\", p2i(instruction_address()),\n-        modrm);\n-    return false;\n-  }\n-  return true;\n-}\n-#endif \/\/ _LP64\n@@ -172,1 +139,0 @@\n-#ifdef _LP64\n@@ -178,3 +144,0 @@\n-#else\n-  return -18;\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-#ifdef _LP64\n@@ -73,11 +72,0 @@\n-#else\n-  __ lea(end,  Address(addr, count, Address::times_ptr, -wordSize));\n-  __ shrptr(addr, CardTable::card_shift());\n-  __ shrptr(end,   CardTable::card_shift());\n-  __ subptr(end, addr); \/\/ end --> count\n-__ BIND(L_loop);\n-  Address cardtable(addr, count, Address::times_1, disp);\n-  __ movb(cardtable, 0);\n-  __ decrement(count);\n-  __ jcc(Assembler::greaterEqual, L_loop);\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/cardTableBarrierSetAssembler_x86.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  bool obj_int = type == T_OBJECT LP64_ONLY(&& UseCompressedOops);\n+  bool obj_int = (type == T_OBJECT) && UseCompressedOops;\n@@ -37,1 +37,0 @@\n-#ifdef _LP64\n@@ -47,5 +46,0 @@\n-#else\n-    if (disjoint) {\n-      __ mov(rdx, dst);          \/\/ save 'to'\n-    }\n-#endif\n@@ -60,1 +54,1 @@\n-  bool obj_int = type == T_OBJECT LP64_ONLY(&& UseCompressedOops);\n+  bool obj_int = (type == T_OBJECT) && UseCompressedOops;\n@@ -64,1 +58,0 @@\n-#ifdef _LP64\n@@ -76,5 +69,0 @@\n-#else\n-    if (disjoint) {\n-      __ mov(dst, rdx); \/\/ restore 'to'\n-    }\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/modRefBarrierSetAssembler_x86.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-  NOT_LP64(assert(_addr->is_single_cpu(), \"must be single\");)\n@@ -49,1 +48,0 @@\n-#ifdef _LP64\n@@ -56,1 +54,0 @@\n-#endif\n@@ -108,1 +105,1 @@\n-  assert(type == T_INT || is_reference_type(type) LP64_ONLY( || type == T_LONG ), \"unexpected type\");\n+  assert(type == T_INT || is_reference_type(type) || type == T_LONG, \"unexpected type\");\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_x86.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    LP64_ONLY(assert(Argument::n_float_register_parameters_j == 8, \"8 fp registers to save at java call\"));\n+    assert(Argument::n_float_register_parameters_j == 8, \"8 fp registers to save at java call\");\n@@ -57,1 +57,1 @@\n-      const int xmm_size = wordSize * LP64_ONLY(2) NOT_LP64(4);\n+      const int xmm_size = wordSize * 2;\n@@ -68,1 +68,1 @@\n-      const int xmm_size = wordSize * LP64_ONLY(1) NOT_LP64(2);\n+      const int xmm_size = wordSize * 1;\n@@ -87,1 +87,1 @@\n-      const int xmm_size = wordSize * LP64_ONLY(2) NOT_LP64(4);\n+      const int xmm_size = wordSize * 2;\n@@ -98,1 +98,1 @@\n-      const int xmm_size = wordSize * LP64_ONLY(1) NOT_LP64(2);\n+      const int xmm_size = wordSize * 1;\n@@ -127,1 +127,1 @@\n-      bool obj_int = type == T_OBJECT LP64_ONLY(&& UseCompressedOops);\n+      bool obj_int = (type == T_OBJECT) && UseCompressedOops;\n@@ -131,1 +131,0 @@\n-#ifdef _LP64\n@@ -141,5 +140,0 @@\n-#else\n-      if (disjoint) {\n-        __ mov(rdx, dst);          \/\/ save 'to'\n-      }\n-#endif\n@@ -149,1 +143,0 @@\n-#ifdef _LP64\n@@ -151,14 +144,0 @@\n-#else\n-      Register thread = rax;\n-      if (thread == src || thread == dst || thread == count) {\n-        thread = rbx;\n-      }\n-      if (thread == src || thread == dst || thread == count) {\n-        thread = rcx;\n-      }\n-      if (thread == src || thread == dst || thread == count) {\n-        thread = rdx;\n-      }\n-      __ push(thread);\n-      __ get_thread(thread);\n-#endif\n@@ -185,1 +164,0 @@\n-#ifdef _LP64\n@@ -192,3 +170,1 @@\n-      } else\n-#endif\n-      {\n+      } else {\n@@ -202,1 +178,0 @@\n-      NOT_LP64(__ pop(thread);)\n@@ -214,1 +189,1 @@\n-    bool obj_int = type == T_OBJECT LP64_ONLY(&& UseCompressedOops);\n+    bool obj_int = (type == T_OBJECT) && UseCompressedOops;\n@@ -217,1 +192,0 @@\n-#ifdef _LP64\n@@ -229,5 +203,0 @@\n-#else\n-    if (disjoint) {\n-      __ mov(dst, rdx); \/\/ restore 'to'\n-    }\n-#endif\n@@ -241,1 +210,0 @@\n-                                                                 Register thread,\n@@ -247,1 +215,1 @@\n-    satb_write_barrier_pre(masm, obj, pre_val, thread, tmp, tosca_live, expand_call);\n+    satb_write_barrier_pre(masm, obj, pre_val, tmp, tosca_live, expand_call);\n@@ -254,1 +222,0 @@\n-                                                           Register thread,\n@@ -262,3 +229,1 @@\n-#ifdef _LP64\n-  assert(thread == r15_thread, \"must be\");\n-#endif \/\/ _LP64\n+  const Register thread = r15_thread;\n@@ -285,1 +250,1 @@\n-    __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);\n+    __ load_heap_oop(pre_val, Address(obj, 0), noreg, AS_RAW);\n@@ -330,3 +295,0 @@\n-  NOT_LP64( __ push(thread); )\n-\n-#ifdef _LP64\n@@ -340,1 +302,0 @@\n-#endif\n@@ -343,2 +304,1 @@\n-    LP64_ONLY( assert(pre_val != c_rarg1, \"smashed arg\"); )\n-#ifdef _LP64\n+    assert(pre_val != c_rarg1, \"smashed arg\");\n@@ -349,4 +309,0 @@\n-#else\n-    __ push(thread);\n-    __ push(pre_val);\n-#endif\n@@ -355,1 +311,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), LP64_ONLY(c_rarg0) NOT_LP64(pre_val), thread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre), c_rarg0, thread);\n@@ -358,2 +314,0 @@\n-  NOT_LP64( __ pop(thread); )\n-\n@@ -386,1 +340,0 @@\n-#ifdef _LP64\n@@ -388,8 +341,0 @@\n-#else\n-  Register thread = rcx;\n-  if (thread == dst) {\n-    thread = rbx;\n-  }\n-  __ push(thread);\n-  __ get_thread(thread);\n-#endif\n@@ -441,1 +386,1 @@\n-  uint num_saved_regs = 4 + (dst != rax ? 1 : 0) LP64_ONLY(+4);\n+  uint num_saved_regs = 4 + (dst != rax ? 1 : 0) + 4;\n@@ -451,1 +396,0 @@\n-#ifdef _LP64\n@@ -457,1 +401,0 @@\n-#endif\n@@ -461,1 +404,0 @@\n-#ifdef _LP64\n@@ -463,3 +405,0 @@\n-#else\n-  Register arg0 = rdi, arg1 = rsi;\n-#endif\n@@ -492,1 +431,0 @@\n-#ifdef _LP64\n@@ -497,1 +435,0 @@\n-#endif\n@@ -523,4 +460,0 @@\n-\n-#ifndef _LP64\n-    __ pop(thread);\n-#endif\n@@ -543,1 +476,1 @@\n-             Register dst, Address src, Register tmp1, Register tmp_thread) {\n+             Register dst, Address src, Register tmp1) {\n@@ -546,1 +479,1 @@\n-    BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);\n+    BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1);\n@@ -570,1 +503,1 @@\n-    BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);\n+    BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1);\n@@ -585,1 +518,1 @@\n-    BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);\n+    BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1);\n@@ -592,6 +525,1 @@\n-    Register thread = NOT_LP64(tmp_thread) LP64_ONLY(r15_thread);\n-    assert_different_registers(dst, tmp1, tmp_thread);\n-    if (!thread->is_valid()) {\n-      thread = rdx;\n-    }\n-    NOT_LP64(__ get_thread(thread));\n+    assert_different_registers(dst, tmp1, r15_thread);\n@@ -603,1 +531,0 @@\n-                                 thread \/* thread *\/,\n@@ -621,17 +548,2 @@\n-  Register thread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n-  Register tmp = LP64_ONLY(rscratch1) NOT_LP64(rdx);\n-\n-#ifndef _LP64\n-  \/\/ The next two ifs are just to get temporary registers to use for TLS and card table base.\n-  if (thread == obj) {\n-    thread = rdx;\n-    tmp = rsi;\n-  }\n-  if (tmp == obj) {\n-    tmp = rsi;\n-  }\n-\n-  __ push(thread);\n-  __ push(tmp);\n-  __ get_thread(thread);\n-#endif\n+  Register thread = r15_thread;\n+  Register tmp = rscratch1;\n@@ -653,5 +565,0 @@\n-\n-#ifndef _LP64\n-  __ pop(tmp);\n-  __ pop(thread);\n-#endif\n@@ -669,1 +576,0 @@\n-    Register rthread = LP64_ONLY(r15_thread) NOT_LP64(rcx);\n@@ -680,7 +586,1 @@\n-    assert_different_registers(val, tmp1, tmp2, tmp3, rthread);\n-\n-#ifndef _LP64\n-    __ get_thread(rthread);\n-    InterpreterMacroAssembler *imasm = static_cast<InterpreterMacroAssembler*>(masm);\n-    imasm->save_bcp();\n-#endif\n+    assert_different_registers(val, tmp1, tmp2, tmp3, r15_thread);\n@@ -692,1 +592,0 @@\n-                                   rthread \/* thread *\/,\n@@ -704,1 +603,0 @@\n-    NOT_LP64(imasm->restore_bcp());\n@@ -739,1 +637,0 @@\n-#ifdef _LP64\n@@ -742,3 +639,1 @@\n-  } else\n-#endif\n-  {\n+  } else {\n@@ -752,1 +647,0 @@\n-#ifdef _LP64\n@@ -756,3 +650,1 @@\n-  } else\n-#endif\n-  {\n+  } else {\n@@ -779,1 +671,0 @@\n-#ifdef _LP64\n@@ -781,4 +672,0 @@\n-#else\n-  const Register thread = tmp2;\n-  __ get_thread(thread);\n-#endif\n@@ -789,1 +676,0 @@\n-#ifdef _LP64\n@@ -793,3 +679,1 @@\n-  } else\n-#endif\n-  {\n+  } else {\n@@ -810,1 +694,0 @@\n-#ifdef _LP64\n@@ -814,1 +697,0 @@\n-#endif\n@@ -830,1 +712,0 @@\n-#ifdef _LP64\n@@ -834,1 +715,0 @@\n-#endif\n@@ -836,1 +716,0 @@\n-#ifdef _LP64\n@@ -840,3 +719,1 @@\n-  } else\n-#endif\n-  {\n+  } else {\n@@ -854,1 +731,0 @@\n-#ifdef _LP64\n@@ -857,3 +733,1 @@\n-  } else\n-#endif\n-  {\n+  } else {\n@@ -863,1 +737,0 @@\n-#ifdef _LP64\n@@ -867,3 +740,1 @@\n-  } else\n-#endif\n-  {\n+  } else {\n@@ -921,1 +792,0 @@\n-#ifdef _LP64\n@@ -938,20 +808,0 @@\n-#else\n-  const Register thread = tmp;\n-  __ get_thread(thread);\n-\n-  Address curr_ct_holder_addr(thread, in_bytes(ShenandoahThreadLocalData::byte_map_base_offset()));\n-  __ movptr(tmp, curr_ct_holder_addr);\n-\n-  __ lea(end, Address(addr, count, Address::times_ptr, -wordSize));\n-  __ shrptr(addr, CardTable::card_shift());\n-  __ shrptr(end,  CardTable::card_shift());\n-  __ subptr(end, addr); \/\/ end --> count\n-\n-  __ addptr(addr, tmp);\n-\n-  __ BIND(L_loop);\n-  Address cardtable(addr, count, Address::times_1, 0);\n-  __ movb(cardtable, 0);\n-  __ decrement(count);\n-  __ jccb(Assembler::greaterEqual, L_loop);\n-#endif\n@@ -1022,1 +872,0 @@\n-#ifdef _LP64\n@@ -1025,6 +874,0 @@\n-#else\n-    \/\/ On x86_32, C1 register allocator can give us the register without 8-bit support.\n-    \/\/ Do the full-register access and test to avoid compilation failures.\n-    __ movptr(tmp2, Address(tmp2, tmp1, Address::times_1));\n-    __ testptr(tmp2, 0xFF);\n-#endif\n@@ -1064,1 +907,1 @@\n-  const Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);\n+  const Register thread = r15_thread;\n@@ -1067,2 +910,0 @@\n-  NOT_LP64(__ get_thread(thread);)\n-\n@@ -1123,1 +964,0 @@\n-#ifdef _LP64\n@@ -1148,12 +988,0 @@\n-#else\n-  __ load_parameter(0, rax);\n-  __ load_parameter(1, rbx);\n-  if (is_strong) {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong), rax, rbx);\n-  } else if (is_weak) {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak), rax, rbx);\n-  } else {\n-    assert(is_phantom, \"only remaining strength\");\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom), rax, rbx);\n-  }\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":29,"deletions":201,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-                              Register thread,\n@@ -55,1 +54,0 @@\n-                                    Register thread,\n@@ -84,1 +82,1 @@\n-                       Register dst, Address src, Register tmp1, Register tmp_thread);\n+                       Register dst, Address src, Register tmp1);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -223,2 +223,1 @@\n-                                   Register tmp1,\n-                                   Register tmp_thread) {\n+                                   Register tmp1) {\n@@ -227,1 +226,1 @@\n-    BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1, tmp_thread);\n+    BarrierSetAssembler::load_at(masm, decorators, type, dst, src, tmp1);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -76,2 +76,1 @@\n-                       Register tmp1,\n-                       Register tmp_thread);\n+                       Register tmp1);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zBarrierSetAssembler_x86.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4047,1 +4047,1 @@\n-  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp, thread);\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp);\n@@ -4056,1 +4056,1 @@\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp, thread);\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp);\n@@ -4063,1 +4063,1 @@\n-                 value, Address(value, -JNIHandles::TypeTag::weak_global), tmp, thread);\n+                 value, Address(value, -JNIHandles::TypeTag::weak_global), tmp);\n@@ -4089,1 +4089,1 @@\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp, thread);\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp);\n@@ -4127,1 +4127,1 @@\n-void MacroAssembler::tlab_allocate(Register thread, Register obj,\n+void MacroAssembler::tlab_allocate(Register obj,\n@@ -4134,1 +4134,1 @@\n-  bs->tlab_allocate(this, thread, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);\n+  bs->tlab_allocate(this, obj, var_size_in_bytes, con_size_in_bytes, t1, t2, slow_case);\n@@ -5962,1 +5962,1 @@\n-                 result, Address(result, 0), tmp, \/*tmp_thread*\/noreg);\n+                 result, Address(result, 0), tmp);\n@@ -5978,1 +5978,1 @@\n-                 rresult, Address(rresult, 0), rtmp, \/*tmp_thread*\/noreg);\n+                 rresult, Address(rresult, 0), rtmp);\n@@ -6075,1 +6075,1 @@\n-                                    Register tmp1, Register thread_tmp) {\n+                                    Register tmp1) {\n@@ -6080,1 +6080,1 @@\n-    bs->BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1, thread_tmp);\n+    bs->BarrierSetAssembler::load_at(this, decorators, type, dst, src, tmp1);\n@@ -6082,1 +6082,1 @@\n-    bs->load_at(this, decorators, type, dst, src, tmp1, thread_tmp);\n+    bs->load_at(this, decorators, type, dst, src, tmp1);\n@@ -6098,3 +6098,2 @@\n-void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1,\n-                                   Register thread_tmp, DecoratorSet decorators) {\n-  access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, thread_tmp);\n+void MacroAssembler::load_heap_oop(Register dst, Address src, Register tmp1, DecoratorSet decorators) {\n+  access_load_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1);\n@@ -6104,3 +6103,2 @@\n-void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1,\n-                                            Register thread_tmp, DecoratorSet decorators) {\n-  access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1, thread_tmp);\n+void MacroAssembler::load_heap_oop_not_null(Register dst, Address src, Register tmp1, DecoratorSet decorators) {\n+  access_load_at(T_OBJECT, IN_HEAP | IS_NOT_NULL | decorators, dst, src, tmp1);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-                      Register tmp1, Register thread_tmp);\n+                      Register tmp1);\n@@ -393,4 +393,2 @@\n-  void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,\n-                     Register thread_tmp = noreg, DecoratorSet decorators = 0);\n-  void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,\n-                              Register thread_tmp = noreg, DecoratorSet decorators = 0);\n+  void load_heap_oop(Register dst, Address src, Register tmp1 = noreg, DecoratorSet decorators = 0);\n+  void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg, DecoratorSet decorators = 0);\n@@ -606,1 +604,0 @@\n-    Register thread,                   \/\/ Current thread\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-                    noreg, noreg);\n+                    noreg);\n@@ -215,1 +215,1 @@\n-                    noreg, noreg);\n+                    noreg);\n@@ -423,1 +423,1 @@\n-      __ access_load_at(T_ADDRESS, IN_HEAP, rbx_method, vmtarget_method, noreg, noreg);\n+      __ access_load_at(T_ADDRESS, IN_HEAP, rbx_method, vmtarget_method, noreg);\n@@ -431,1 +431,1 @@\n-      __ access_load_at(T_ADDRESS, IN_HEAP, rbx_method, vmtarget_method, noreg, noreg);\n+      __ access_load_at(T_ADDRESS, IN_HEAP, rbx_method, vmtarget_method, noreg);\n@@ -445,1 +445,1 @@\n-      __ access_load_at(T_ADDRESS, IN_HEAP, temp2_index, member_vmindex, noreg, noreg);\n+      __ access_load_at(T_ADDRESS, IN_HEAP, temp2_index, member_vmindex, noreg);\n@@ -477,1 +477,1 @@\n-      __ access_load_at(T_ADDRESS, IN_HEAP, rbx_index, member_vmindex, noreg, noreg);\n+      __ access_load_at(T_ADDRESS, IN_HEAP, rbx_index, member_vmindex, noreg);\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3984,1 +3984,1 @@\n-                    noreg, noreg);\n+                    noreg);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -647,1 +647,1 @@\n-  __ load_heap_oop(rax, field_address, \/*tmp1*\/ rbx, \/*tmp_thread*\/ rdx, ON_WEAK_OOP_REF);\n+  __ load_heap_oop(rax, field_address, \/*tmp1*\/ rbx, ON_WEAK_OOP_REF);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-  __ load_heap_oop(dst, src, rdx, rbx, decorators);\n+  __ load_heap_oop(dst, src, rdx, decorators);\n@@ -743,1 +743,1 @@\n-                    noreg, noreg);\n+                    noreg);\n@@ -755,1 +755,1 @@\n-                    noreg, noreg);\n+                    noreg);\n@@ -769,1 +769,1 @@\n-                    noreg, noreg);\n+                    noreg);\n@@ -781,1 +781,1 @@\n-                    noreg, noreg);\n+                    noreg);\n@@ -804,1 +804,1 @@\n-                    noreg, noreg);\n+                    noreg);\n@@ -814,1 +814,1 @@\n-                    noreg, noreg);\n+                    noreg);\n@@ -829,1 +829,1 @@\n-                    noreg, noreg);\n+                    noreg);\n@@ -840,1 +840,1 @@\n-                    noreg, noreg);\n+                    noreg);\n@@ -2571,1 +2571,1 @@\n-  __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);\n+  __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg);\n@@ -2584,1 +2584,1 @@\n-  __ access_load_at(T_BOOLEAN, IN_HEAP, rax, field, noreg, noreg);\n+  __ access_load_at(T_BOOLEAN, IN_HEAP, rax, field, noreg);\n@@ -2608,1 +2608,1 @@\n-  __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);\n+  __ access_load_at(T_INT, IN_HEAP, rax, field, noreg);\n@@ -2620,1 +2620,1 @@\n-  __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg, noreg);\n+  __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg);\n@@ -2632,1 +2632,1 @@\n-  __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg, noreg);\n+  __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg);\n@@ -2646,1 +2646,1 @@\n-  __ access_load_at(T_LONG, IN_HEAP | MO_RELAXED, noreg \/* ltos *\/, field, noreg, noreg);\n+  __ access_load_at(T_LONG, IN_HEAP | MO_RELAXED, noreg \/* ltos *\/, field, noreg);\n@@ -2657,1 +2657,1 @@\n-  __ access_load_at(T_FLOAT, IN_HEAP, noreg \/* ftos *\/, field, noreg, noreg);\n+  __ access_load_at(T_FLOAT, IN_HEAP, noreg \/* ftos *\/, field, noreg);\n@@ -2673,1 +2673,1 @@\n-  __ access_load_at(T_DOUBLE, IN_HEAP | MO_RELAXED, noreg \/* dtos *\/, field, noreg, noreg);\n+  __ access_load_at(T_DOUBLE, IN_HEAP | MO_RELAXED, noreg \/* dtos *\/, field, noreg);\n@@ -3136,1 +3136,1 @@\n-    __ access_load_at(T_LONG, IN_HEAP, noreg \/* ltos *\/, field, noreg, noreg);\n+    __ access_load_at(T_LONG, IN_HEAP, noreg \/* ltos *\/, field, noreg);\n@@ -3139,1 +3139,1 @@\n-    __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);\n+    __ access_load_at(T_INT, IN_HEAP, rax, field, noreg);\n@@ -3142,1 +3142,1 @@\n-    __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg, noreg);\n+    __ access_load_at(T_BYTE, IN_HEAP, rax, field, noreg);\n@@ -3145,1 +3145,1 @@\n-    __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg, noreg);\n+    __ access_load_at(T_SHORT, IN_HEAP, rax, field, noreg);\n@@ -3148,1 +3148,1 @@\n-    __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg, noreg);\n+    __ access_load_at(T_CHAR, IN_HEAP, rax, field, noreg);\n@@ -3151,1 +3151,1 @@\n-    __ access_load_at(T_FLOAT, IN_HEAP, noreg \/* ftos *\/, field, noreg, noreg);\n+    __ access_load_at(T_FLOAT, IN_HEAP, noreg \/* ftos *\/, field, noreg);\n@@ -3154,1 +3154,1 @@\n-    __ access_load_at(T_DOUBLE, IN_HEAP, noreg \/* dtos *\/, field, noreg, noreg);\n+    __ access_load_at(T_DOUBLE, IN_HEAP, noreg \/* dtos *\/, field, noreg);\n@@ -3183,1 +3183,1 @@\n-    __ access_load_at(T_INT, IN_HEAP, rax, field, noreg, noreg);\n+    __ access_load_at(T_INT, IN_HEAP, rax, field, noreg);\n@@ -3190,1 +3190,1 @@\n-    __ access_load_at(T_FLOAT, IN_HEAP, noreg \/* ftos *\/, field, noreg, noreg);\n+    __ access_load_at(T_FLOAT, IN_HEAP, noreg \/* ftos *\/, field, noreg);\n@@ -3593,1 +3593,1 @@\n-    __ tlab_allocate(r15_thread, rax, rdx, 0, rcx, rbx, slow_case);\n+    __ tlab_allocate(rax, rdx, 0, rcx, rbx, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"}]}