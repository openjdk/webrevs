{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.util.stream.*;\n@@ -33,0 +34,1 @@\n+import sun.jvm.hotspot.runtime.*;\n@@ -72,0 +74,2 @@\n+\n+      \/\/ rbp is not needed null check because it could be used as GPR by compiler (cl.exe) option.\n@@ -73,1 +77,3 @@\n-      if (rbp == null) return null;\n+\n+      Address rsp = context.getRegisterAsAddress(AMD64ThreadContext.RSP);\n+      if (rsp == null) return null;\n@@ -76,1 +82,9 @@\n-      return new WindowsAMD64CFrame(dbg, rbp, pc);\n+\n+      Threads threads = VM.getVM().getThreads();\n+      JavaThread ownerThread = IntStream.range(0, threads.getNumberOfThreads())\n+                                        .mapToObj(threads::getJavaThreadAt)\n+                                        .filter(jt -> thread.equals(jt.getThreadProxy()))\n+                                        .findFirst()\n+                                        .orElse(null);\n+\n+      return new WindowsAMD64CFrame(dbg, ownerThread, rsp, rbp, pc);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgCDebugger.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,4 @@\n+\n+  public static record SenderRegs(Address nextSP, Address nextFP, Address nextPC) {};\n+\n+  public SenderRegs getSenderRegs(Address sp, Address fp, Address pc);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgDebugger.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,0 +232,6 @@\n+  public synchronized SenderRegs getSenderRegs(Address sp, Address fp, Address pc) {\n+    \/\/ sp and pc should not be null, but fp might be null because it could be used as GPR.\n+    long[] rawSenderRegs = getSenderRegs0(sp.asLongValue(), fp == null ? 0L : fp.asLongValue(), pc.asLongValue());\n+    return rawSenderRegs == null ? null : new SenderRegs(newAddress(rawSenderRegs[0]), newAddress(rawSenderRegs[1]), newAddress(rawSenderRegs[2]));\n+  }\n+\n@@ -647,0 +653,2 @@\n+  private native long getFrameBase0(long sp, long pc);\n+  private native long[] getSenderRegs0(long sp, long fp, long pc);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgDebuggerLocal.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.runtime.amd64.*;\n@@ -34,0 +36,2 @@\n+  private JavaThread ownerThread;\n+  private Address rsp;\n@@ -37,2 +41,0 @@\n-  private static final int ADDRESS_SIZE = 8;\n-\n@@ -40,1 +42,1 @@\n-  public WindowsAMD64CFrame(WindbgDebugger dbg, Address rbp, Address pc) {\n+  public WindowsAMD64CFrame(WindbgDebugger dbg, JavaThread ownerThread, Address rsp, Address rbp, Address pc) {\n@@ -42,0 +44,2 @@\n+    this.ownerThread = ownerThread;\n+    this.rsp = rsp;\n@@ -47,0 +51,1 @@\n+  @Override\n@@ -48,2 +53,2 @@\n-    AMD64ThreadContext context = (AMD64ThreadContext) thread.getContext();\n-    Address rsp = context.getRegisterAsAddress(AMD64ThreadContext.RSP);\n+    return sender(thread, null, null, null);\n+  }\n@@ -51,3 +56,25 @@\n-    if ( (rbp == null) || rbp.lessThan(rsp) ) {\n-      return null;\n-    }\n+  @Override\n+  public CFrame sender(ThreadProxy th, Address nextSP, Address nextFP, Address nextPC) {\n+    if (nextSP == null && nextPC == null) {\n+      \/\/ GetStackTrace() by Windows Debug API would unwind frame with given SP, FP, and PC.\n+      \/\/ However it would not work for dynamic generated code like CodeBlob because\n+      \/\/ HotSpot would not register unwind info like RtlAddFunctionTable().\n+      \/\/ Thus SA should check whether current PC is in CodeCache at first when nextPC is null.\n+      var cb = VM.getVM().getCodeCache().findBlob(pc);\n+      if (cb != null) {\n+        if (cb.getFrameSize() > 0) {\n+          nextSP = rsp.addOffsetTo(cb.getFrameSize());\n+          nextPC = nextSP.getAddressAt(-1 * VM.getVM().getAddressSize());\n+\n+          \/\/ Set nextFP to null when PreserveFramePointer is disabled because We could not find out\n+          \/\/ frame pointer of sender frame - it might be omitted.\n+          nextFP = VM.getVM().getCommandLineBooleanFlag(\"PreserveFramePointer\") ? rsp.getAddressAt(0) : null;\n+        } else {\n+          \/\/ Use Frame (AMD64Frame) to access slots on stack.\n+          var frame = toFrame();\n+          nextSP = frame.getSenderSP();\n+          nextPC = frame.getSenderPC();\n+          nextFP = frame.getLink();\n+        }\n+        return new WindowsAMD64CFrame(dbg, ownerThread, nextSP, nextFP, nextPC);\n+      }\n@@ -55,2 +82,2 @@\n-    \/\/ Check alignment of rbp\n-    if ( dbg.getAddressValue(rbp) % ADDRESS_SIZE != 0) {\n+      WindbgDebugger.SenderRegs senderRegs = dbg.getSenderRegs(rsp, rbp, pc);\n+      if (senderRegs == null) {\n@@ -58,1 +85,1 @@\n-    }\n+      }\n@@ -60,7 +87,11 @@\n-    Address nextRBP = rbp.getAddressAt( 0 * ADDRESS_SIZE);\n-    if (nextRBP == null || nextRBP.lessThanOrEqual(rbp)) {\n-      return null;\n-    }\n-    Address nextPC  = rbp.getAddressAt( 1 * ADDRESS_SIZE);\n-    if (nextPC == null) {\n-      return null;\n+      if (senderRegs.nextSP() == null || senderRegs.nextSP().lessThanOrEqual(rsp)) {\n+        return null;\n+      }\n+      nextSP = senderRegs.nextSP();\n+\n+      if (senderRegs.nextPC() == null) {\n+        return null;\n+      }\n+      nextPC = senderRegs.nextPC();\n+\n+      nextFP = senderRegs.nextFP();\n@@ -68,1 +99,1 @@\n-    return new WindowsAMD64CFrame(dbg, nextRBP, nextPC);\n+    return new WindowsAMD64CFrame(dbg, ownerThread, nextSP, nextFP, nextPC);\n@@ -79,0 +110,16 @@\n+  @Override\n+  public Frame toFrame() {\n+    \/\/ Find the top of JavaVFrame related to this CFrame. The Windows  GetStackTrace DbgHelp API\n+    \/\/ cannot get FP for java frames.\n+    for (JavaVFrame vf = ownerThread.getLastJavaVFrameDbg(); vf != null; vf = vf.javaSender()) {\n+      Frame f = vf.getFrame();\n+      if (f.getSP().equals(rsp) && f.getPC().equals(pc)) {\n+        return f;\n+      } else if (f.getSP().greaterThanOrEqual(rsp)) {\n+        return f;\n+      }\n+    }\n+\n+    return new AMD64Frame(rsp, localVariableBase(), pc);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windows\/amd64\/WindowsAMD64CFrame.java","additions":67,"deletions":20,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -909,0 +909,34 @@\n+\n+\/*\n+ * Class:     sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal\n+ * Method:    getSenderRegs0\n+ * Signature: (JJJ)[J\n+ *\/\n+JNIEXPORT jlongArray JNICALL Java_sun_jvm_hotspot_debugger_windbg_WindbgDebuggerLocal_getSenderRegs0\n+    (JNIEnv *env, jobject obj, jlong sp, jlong fp, jlong pc) {\n+  IDebugControl* ptrIDebugControl = (IDebugControl*)env->GetLongField(obj, ptrIDebugControl_ID);\n+  CHECK_EXCEPTION_(nullptr);\n+\n+  DEBUG_STACK_FRAME frames[2];\n+  ULONG filled;\n+  HRESULT dbg_result = ptrIDebugControl->GetStackTrace(fp, sp, pc, frames, 2, &filled);\n+  if (dbg_result != S_OK || filled != 2) {\n+    return nullptr;\n+  }\n+\n+  jlongArray result = env->NewLongArray(3);\n+  CHECK_EXCEPTION_(nullptr);\n+  if (result == nullptr) {\n+    return nullptr;\n+  }\n+\n+  jlong regs[] = {\n+    static_cast<jlong>(frames[1].StackOffset),\n+    static_cast<jlong>(frames[1].FrameOffset),\n+    static_cast<jlong>(frames[1].InstructionOffset)\n+  };\n+  env->SetLongArrayRegion(result, 0, 3, regs);\n+  CHECK_EXCEPTION_(nullptr);\n+\n+  return result;\n+}\n","filename":"src\/jdk.hotspot.agent\/windows\/native\/libsaproc\/sawindbg.cpp","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,2 @@\n- * @bug 8208091\n- * @requires (os.family == \"linux\") & (vm.hasSA)\n+ * @bug 8208091 8374469\n+ * @requires (os.family == \"linux\" | os.family == \"windows\") & (vm.hasSA)\n@@ -53,1 +53,1 @@\n-    private static final String FIB_SPLIT_PATTERN = NATIVE_FUNCTION_NAME\n+    private static final String FIB_SPLIT_PATTERN = \"(NoFramePointer!)?\" + NATIVE_FUNCTION_NAME\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackMixed.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}