{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,0 +268,7 @@\n+\n+    \/\/ This method returns false - every exchange is considered as processed by the peer,\n+    \/\/ unless the peer explicitly states (through a GOAWAY frame) that the\n+    \/\/ corresponding stream wasn't processed\n+    boolean isUnprocessedByPeer() {\n+        return false;\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,2 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -361,0 +363,1 @@\n+    private final AtomicLong lastProcessedStreamInGoAway = new AtomicLong(-1);\n@@ -728,1 +731,3 @@\n-            if (connection.channel().isOpen()) {\n+            \/\/ we send a GOAWAY frame only if the remote side hasn't already indicated\n+            \/\/ the intention to close the connection by previously sending a GOAWAY of its own\n+            if (connection.channel().isOpen() && !isMarked(closedState, HALF_CLOSED_REMOTE)) {\n@@ -1208,7 +1213,39 @@\n-    private void handleGoAway(GoAwayFrame frame)\n-        throws IOException\n-    {\n-        if (markHalfClosedLRemote()) {\n-            shutdown(new IOException(\n-                    connection.channel().getLocalAddress()\n-                            + \": GOAWAY received\"));\n+    private void handleGoAway(final GoAwayFrame frame) {\n+        final long lastProcessedStream = frame.getLastStream();\n+        assert lastProcessedStream >= 0 : \"unexpected last stream id: \"\n+                + lastProcessedStream + \" in GOAWAY frame\";\n+        setFinalStream(); \/\/ don't allow any new streams on this connection\n+        markHalfClosedRemote();\n+        if (debug.on()) {\n+            debug.log(\"processing incoming GOAWAY with last processed stream id:%s in frame %s\",\n+                    lastProcessedStream, frame);\n+        }\n+        \/\/ see if this connection has previously received a GOAWAY from the peer and if yes\n+        \/\/ then check if this new last processed stream id is lesser than the previous\n+        \/\/ known last processed stream id. Only update the last processed stream id if the new\n+        \/\/ one is lesser than the previous one.\n+        long prevLastProcessed = lastProcessedStreamInGoAway.get();\n+        while (prevLastProcessed == -1 || lastProcessedStream < prevLastProcessed) {\n+            if (lastProcessedStreamInGoAway.compareAndSet(prevLastProcessed,\n+                    lastProcessedStream)) {\n+                break;\n+            }\n+            prevLastProcessed = lastProcessedStreamInGoAway.get();\n+        }\n+        handlePeerUnprocessedStreams(lastProcessedStreamInGoAway.get());\n+    }\n+\n+    private void handlePeerUnprocessedStreams(final long lastProcessedStream) {\n+        final AtomicInteger numClosed = new AtomicInteger(); \/\/ atomic merely to allow usage within lambda\n+        streams.forEach((id, exchange) -> {\n+            if (id > lastProcessedStream) {\n+                \/\/ any streams with an stream id higher than the last processed stream\n+                \/\/ can be retried (on a new connection). we close the exchange as unprocessed\n+                \/\/ to facilitate the retrying.\n+                client2.client().theExecutor().execute(exchange::closeAsUnprocessed);\n+                numClosed.incrementAndGet();\n+            }\n+        });\n+        if (debug.on()) {\n+            debug.log(numClosed.get() + \" stream(s), with id greater than \" + lastProcessedStream\n+                    + \", will be closed as unprocessed\");\n@@ -1748,1 +1785,1 @@\n-    private boolean markHalfClosedLRemote() {\n+    private boolean markHalfClosedRemote() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":47,"deletions":10,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-    volatile boolean expiredOnce;\n+    volatile boolean retriedOnce;\n@@ -472,1 +472,1 @@\n-                                expiredOnce = false;\n+                                retriedOnce = false;\n@@ -485,1 +485,1 @@\n-                        CompletableFuture<Response> errorCF = getExceptionalCF(ex);\n+                        CompletableFuture<Response> errorCF = getExceptionalCF(ex, exch.exchImpl);\n@@ -557,1 +557,1 @@\n-    private CompletableFuture<Response> getExceptionalCF(Throwable t) {\n+    private CompletableFuture<Response> getExceptionalCF(Throwable t, ExchangeImpl<?> exchImpl) {\n@@ -563,0 +563,1 @@\n+        final boolean retryAsUnprocessed = exchImpl != null && exchImpl.isUnprocessedByPeer();\n@@ -567,1 +568,1 @@\n-        } else if (retryOnFailure(t)) {\n+        } else if (retryAsUnprocessed || retryOnFailure(t)) {\n@@ -574,2 +575,4 @@\n-                if (!canRetryRequest(currentreq)) {\n-                    return failedFuture(cause); \/\/ fails with original cause\n+                if (!retryAsUnprocessed && !canRetryRequest(currentreq)) {\n+                    \/\/ a (peer) processed request which cannot be retried, fail with\n+                    \/\/ the original cause\n+                    return failedFuture(cause);\n@@ -581,1 +584,1 @@\n-            if (!expiredOnce) {\n+            if (!retriedOnce) {\n@@ -584,1 +587,1 @@\n-                            + \" (async): retrying due to: \", t);\n+                            + \" (async): retrying \" + currentreq + \" due to: \", t);\n@@ -586,1 +589,1 @@\n-                expiredOnce = true;\n+                retriedOnce = true;\n@@ -597,1 +600,1 @@\n-                            + \" (async): already retried once.\", t);\n+                            + \" (async): already retried once \" + currentreq, t);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -166,0 +166,3 @@\n+    \/\/ this will be set to true only when the peer explicitly states (through a GOAWAY frame)\n+    \/\/ that the corresponding stream (id) wasn't processed\n+    private volatile boolean unprocessedByPeer;\n@@ -1669,0 +1672,25 @@\n+    \/**\n+     * An unprocessed exchange is one that hasn't been processed by a peer. The local end of the\n+     * connection would be notified about such exchanges when it receives a GOAWAY frame with\n+     * a stream id that tells which exchanges have been unprocessed.\n+     * This method is called on such unprocessed exchanges and the implementation of this method\n+     * will arrange for the request, corresponding to this exchange, to be retried afresh on a\n+     * new connection.\n+     *\/\n+    void closeAsUnprocessed() {\n+        \/\/ We arrange for the request to be retried on a new connection as allowed by the RFC-9113\n+        this.unprocessedByPeer = true;\n+        this.errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n+        if (debug.on()) {\n+            debug.log(\"closing \" + this.request + \" as unprocessed by peer\");\n+        }\n+        \/\/ close the exchange and complete the response CF exceptionally\n+        close();\n+        completeResponseExceptionally(this.errorRef.get());\n+    }\n+\n+    @Override\n+    boolean isUnprocessedByPeer() {\n+        return this.unprocessedByPeer;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,373 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestServerConnection;\n+import jdk.internal.net.http.frame.ErrorFrame;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test\n+ * @bug 8335181\n+ * @summary verify that the HttpClient correctly handles incoming GOAWAY frames and\n+ *          retries any unprocessed requests on a new connection\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ * @run junit H2GoAwayTest\n+ *\/\n+public class H2GoAwayTest {\n+    private static final String REQ_PATH = \"\/test\";\n+    private static Http2TestServer server;\n+    private static String REQ_URI_BASE;\n+    private static SSLContext sslCtx;\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        sslCtx = new SimpleSSLContext().get();\n+        assertNotNull(sslCtx, \"SSLContext couldn't be created\");\n+        server = new Http2TestServer(\"localhost\", true, sslCtx);\n+        server.addHandler(new Handler(), REQ_PATH);\n+        server.start();\n+        System.out.println(\"Server started at \" + server.getAddress());\n+        REQ_URI_BASE = URIBuilder.newBuilder().scheme(\"https\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(REQ_PATH)\n+                .build().toString();\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        if (server != null) {\n+            System.out.println(\"Stopping server at \" + server.getAddress());\n+            server.stop();\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when several requests are sent using send() and the server\n+     * connection is configured to send a GOAWAY after processing only a few requests, then\n+     * the remaining requests are retried on a different connection\n+     *\/\n+    @Test\n+    public void testSequential() throws Exception {\n+        final RequestApprover reqApprover = new RequestApprover();\n+        server.setRequestApprover(reqApprover::allowNewRequest);\n+        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+                .sslContext(sslCtx).build()) {\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int numReqs = RequestApprover.MAX_REQS_PER_CONN + 3;\n+                final Set<String> connectionKeys = new LinkedHashSet<>();\n+                for (int i = 1; i <= numReqs; i++) {\n+                    final URI reqURI = new URI(REQ_URI_BASE + \"?seq&\" + reqMethod + \"=\" + i);\n+                    final HttpRequest req = HttpRequest.newBuilder()\n+                            .uri(reqURI)\n+                            .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                            .build();\n+                    System.out.println(\"initiating request \" + req);\n+                    final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                    final String respBody = resp.body();\n+                    System.out.println(\"received response: \" + respBody);\n+                    assertEquals(200, resp.statusCode(),\n+                            \"unexpected status code for request \" + resp.request());\n+                    \/\/ response body is the logical key of the connection on which the\n+                    \/\/ request was handled\n+                    connectionKeys.add(respBody);\n+                }\n+                System.out.println(\"connections involved in handling the requests: \"\n+                        + connectionKeys);\n+                \/\/ all requests have finished, we now just do a basic check that\n+                \/\/ more than one connection was involved in processing these requests\n+                assertEquals(2, connectionKeys.size(),\n+                        \"unexpected number of connections \" + connectionKeys);\n+            }\n+        } finally {\n+            server.setRequestApprover(null); \/\/ reset\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when a server responds with a GOAWAY and then never processes the new retried\n+     * requests on a new connection too, then the application code receives the request failure.\n+     * This tests the send() API of the HttpClient.\n+     *\/\n+    @Test\n+    public void testUnprocessedRaisesException() throws Exception {\n+        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+                .sslContext(sslCtx).build()) {\n+            final Random random = new Random();\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int maxAllowedReqs = 2;\n+                final int numReqs = maxAllowedReqs + 3; \/\/ 3 more requests than max allowed\n+                \/\/ create a random set of request paths that will be allowed to be processed\n+                \/\/ on the server\n+                final Set<String> allowedReqPaths = new HashSet<>();\n+                while (allowedReqPaths.size() < maxAllowedReqs) {\n+                    final int rnd = random.nextInt(1, numReqs + 1);\n+                    final String reqPath = REQ_PATH + \"?sync&\" + reqMethod + \"=\" + rnd;\n+                    allowedReqPaths.add(reqPath);\n+                }\n+                \/\/ configure the approver\n+                final OnlyAllowSpecificPaths reqApprover = new OnlyAllowSpecificPaths(allowedReqPaths);\n+                server.setRequestApprover(reqApprover::allowNewRequest);\n+                try {\n+                    int numSuccess = 0;\n+                    int numFailed = 0;\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final String reqQueryPart = \"?sync&\" + reqMethod + \"=\" + i;\n+                        final URI reqURI = new URI(REQ_URI_BASE + reqQueryPart);\n+                        final HttpRequest req = HttpRequest.newBuilder()\n+                                .uri(reqURI)\n+                                .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                                .build();\n+                        System.out.println(\"initiating request \" + req);\n+                        if (allowedReqPaths.contains(REQ_PATH + reqQueryPart)) {\n+                            \/\/ expected to successfully complete\n+                            numSuccess++;\n+                            final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                            final String respBody = resp.body();\n+                            System.out.println(\"received response: \" + respBody);\n+                            assertEquals(200, resp.statusCode(),\n+                                    \"unexpected status code for request \" + resp.request());\n+                        } else {\n+                            \/\/ expected to fail as unprocessed\n+                            try {\n+                                final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                                fail(\"Request was expected to fail as unprocessed,\"\n+                                        + \" but got response: \" + resp.body() + \", status code: \"\n+                                        + resp.statusCode());\n+                            } catch (IOException ioe) {\n+                                \/\/ verify it failed for the right reason\n+                                if (ioe.getMessage() == null\n+                                        || !ioe.getMessage().contains(\"request not processed by peer\")) {\n+                                    \/\/ propagate the original failure\n+                                    throw ioe;\n+                                }\n+                                numFailed++; \/\/ failed due to right reason\n+                                System.out.println(\"received expected failure: \" + ioe\n+                                        + \", for request \" + reqURI);\n+                            }\n+                        }\n+                    }\n+                    \/\/ verify the correct number of requests succeeded\/failed\n+                    assertEquals(maxAllowedReqs, numSuccess, \"unexpected number of requests succeeded\");\n+                    assertEquals((numReqs - maxAllowedReqs), numFailed, \"unexpected number of requests failed\");\n+                } finally {\n+                    server.setRequestApprover(null); \/\/ reset\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when a server responds with a GOAWAY and then never processes the new retried\n+     * requests on a new connection too, then the application code receives the request failure.\n+     * This tests the sendAsync() API of the HttpClient.\n+     *\/\n+    @Test\n+    public void testUnprocessedRaisesExceptionAsync() throws Throwable {\n+        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+                .sslContext(sslCtx).build()) {\n+            final Random random = new Random();\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int maxAllowedReqs = 2;\n+                final int numReqs = maxAllowedReqs + 3; \/\/ 3 more requests than max allowed\n+                \/\/ create a random set of request paths that will be allowed to be processed\n+                \/\/ on the server\n+                final Set<String> allowedReqPaths = new HashSet<>();\n+                while (allowedReqPaths.size() < maxAllowedReqs) {\n+                    final int rnd = random.nextInt(1, numReqs + 1);\n+                    final String reqPath = REQ_PATH + \"?async&\" + reqMethod + \"=\" + rnd;\n+                    allowedReqPaths.add(reqPath);\n+                }\n+                \/\/ configure the approver\n+                final OnlyAllowSpecificPaths reqApprover = new OnlyAllowSpecificPaths(allowedReqPaths);\n+                server.setRequestApprover(reqApprover::allowNewRequest);\n+                try {\n+                    final List<Future<HttpResponse<String>>> futures = new ArrayList<>();\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final URI reqURI = new URI(REQ_URI_BASE + \"?async&\" + reqMethod + \"=\" + i);\n+                        final HttpRequest req = HttpRequest.newBuilder()\n+                                .uri(reqURI)\n+                                .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                                .build();\n+                        System.out.println(\"initiating request \" + req);\n+                        final Future<HttpResponse<String>> f = client.sendAsync(req, BodyHandlers.ofString());\n+                        futures.add(f);\n+                    }\n+                    \/\/ wait for responses\n+                    int numFailed = 0;\n+                    int numSuccess = 0;\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        try {\n+                            final HttpResponse<String> resp = futures.get(i - 1).get();\n+                            numSuccess++;\n+                            final String respBody = resp.body();\n+                            System.out.println(\"request: \" + resp.request()\n+                                    + \", received response: \" + respBody);\n+                            assertEquals(200, resp.statusCode(),\n+                                    \"unexpected status code for request \" + resp.request());\n+                        } catch (ExecutionException ee) {\n+                            final Throwable cause = ee.getCause();\n+                            if (!(cause instanceof IOException ioe)) {\n+                                throw cause;\n+                            }\n+                            \/\/ verify it failed for the right reason\n+                            if (ioe.getMessage() == null\n+                                    || !ioe.getMessage().contains(\"request not processed by peer\")) {\n+                                \/\/ propagate the original failure\n+                                throw ioe;\n+                            }\n+                            numFailed++; \/\/ failed due to the right reason\n+                            System.out.println(\"received expected failure: \" + ioe\n+                                    + \", for request \"\n+                                    + REQ_URI_BASE + \"?async&\" + reqMethod + \"=\" + i);\n+                        }\n+                    }\n+                    \/\/ verify the correct number of requests succeeded\/failed\n+                    assertEquals(maxAllowedReqs, numSuccess, \"unexpected number of requests succeeded\");\n+                    assertEquals((numReqs - maxAllowedReqs), numFailed, \"unexpected number of requests failed\");\n+                } finally {\n+                    server.setRequestApprover(null); \/\/ reset\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ only allows requests with certain paths to be processed, irrespective of which\n+    \/\/ server connection is serving them. requests which don't match the allowed\n+    \/\/ paths will not be processed and a GOAWAY frame will be sent.\n+    private static final class OnlyAllowSpecificPaths {\n+        private final Set<String> allowedReqPaths;\n+\n+        private OnlyAllowSpecificPaths(final Set<String> allowedReqPaths) {\n+            this.allowedReqPaths = Set.copyOf(allowedReqPaths);\n+        }\n+\n+        public boolean allowNewRequest(final Http2TestServerConnection serverConn,\n+                                       final String reqPath) {\n+            if (allowedReqPaths.contains(reqPath)) {\n+                \/\/ allowed\n+                return true;\n+            }\n+            System.out.println(\"sending GOAWAY on server connection \" + serverConn\n+                    + \" for request: \" + reqPath);\n+            try {\n+                serverConn.sendGoAway(ErrorFrame.NO_ERROR);\n+            } catch (IOException e) {\n+                System.err.println(\"Failed to send GOAWAY on server connection: \"\n+                        + serverConn + \", request: \" + reqPath + \", due to: \" + e);\n+                e.printStackTrace();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    \/\/ allows a certain number of requests per server connection, before sending a GOAWAY\n+    \/\/ for any subsequent requests on that connection\n+    private static final class RequestApprover {\n+        private static final int MAX_REQS_PER_CONN = 6;\n+        private final Map<Http2TestServerConnection, AtomicInteger> numApproved =\n+                new ConcurrentHashMap<>();\n+        private final Map<Http2TestServerConnection, AtomicInteger> numDisapproved =\n+                new ConcurrentHashMap<>();\n+\n+        public boolean allowNewRequest(final Http2TestServerConnection serverConn,\n+                                       final String reqPath) {\n+            final AtomicInteger approved = numApproved.computeIfAbsent(serverConn,\n+                    (k) -> new AtomicInteger());\n+            int curr = approved.get();\n+            while (curr < MAX_REQS_PER_CONN) {\n+                if (approved.compareAndSet(curr, curr + 1)) {\n+                    return true; \/\/ new request allowed\n+                }\n+                curr = approved.get();\n+            }\n+            final AtomicInteger disapproved = numDisapproved.computeIfAbsent(serverConn,\n+                    (k) -> new AtomicInteger());\n+            final int numUnprocessed = disapproved.incrementAndGet();\n+            System.out.println(approved.get() + \" processed, \"\n+                    + numUnprocessed + \" unprocessed requests so far,\" +\n+                    \" sending GOAWAY on connection \" + serverConn);\n+            try {\n+                serverConn.sendGoAway(ErrorFrame.NO_ERROR);\n+            } catch (IOException e) {\n+                System.err.println(\"Failed to send GOAWAY on server connection: \"\n+                        + serverConn + \", due to: \" + e);\n+                e.printStackTrace();\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private static final class Handler implements Http2Handler {\n+\n+        @Override\n+        public void handle(final Http2TestExchange exchange) throws IOException {\n+            final String connectionKey = exchange.getConnectionKey();\n+            System.out.println(connectionKey + \" responding to request: \"\n+                    + exchange.getRequestURI());\n+            final byte[] response = connectionKey.getBytes(UTF_8);\n+            exchange.sendResponseHeaders(200, response.length);\n+            try (final OutputStream os = exchange.getResponseBody()) {\n+                os.write(response);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/H2GoAwayTest.java","additions":373,"deletions":0,"binary":false,"changes":373,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,10 @@\n+\n+    \/**\n+     * {@return a string that identifies the underlying connection for this exchange}\n+     * @apiNote\n+     * This connection key can be useful to figure out whether two exchanges\n+     * were performed on the same underlying connection.\n+     *\/\n+    default String getConnectionKey() {\n+        return \"{local=%s, remote=%s}\".formatted(getLocalAddress(), getRemoteAddress());\n+    }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchange.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,3 @@\n+import java.util.function.BiPredicate;\n+import java.util.function.Predicate;\n+\n@@ -62,0 +65,1 @@\n+    private volatile BiPredicate<Http2TestServerConnection, String> newRequestApprover;\n@@ -288,0 +292,14 @@\n+    public void setRequestApprover(final BiPredicate<Http2TestServerConnection, String> approver) {\n+        this.newRequestApprover = approver;\n+    }\n+\n+    public boolean shouldProcessNewHTTPRequest(final Http2TestServerConnection serverConn,\n+                                               final String reqPath) {\n+        final BiPredicate<Http2TestServerConnection, String> approver = this.newRequestApprover;\n+        if (approver == null) {\n+            \/\/ by the default the server will process new requests\n+            return true;\n+        }\n+        return approver.test(serverConn, reqPath);\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServer.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,1 @@\n+import java.util.Set;\n@@ -81,0 +82,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -113,0 +115,4 @@\n+    \/\/ the max stream id of a processed H2 request. -1 implies none were processed.\n+    private final AtomicInteger maxProcessedRequestStreamId = new AtomicInteger(-1);\n+    \/\/ the stream id that was sent in a GOAWAY frame. -1 implies no GOAWAY frame was sent.\n+    private final AtomicInteger goAwayRequestStreamId = new AtomicInteger(-1);\n@@ -237,5 +243,16 @@\n-    void goAway(int error) throws IOException {\n-        int laststream = nextstream >= 3 ? nextstream - 2 : 1;\n-\n-        GoAwayFrame go = new GoAwayFrame(laststream, error);\n-        outputQ.put(go);\n+    \/\/ public, to allow for usage in tests\n+    public void sendGoAway(final int error) throws IOException {\n+        int maxProcessedStreamId = maxProcessedRequestStreamId.get();\n+        if (maxProcessedStreamId == -1) {\n+            maxProcessedStreamId = 0;\n+        }\n+        int currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n+        while (currentGoAwayReqStrmId != -1 && maxProcessedStreamId < currentGoAwayReqStrmId) {\n+            if (goAwayRequestStreamId.compareAndSet(currentGoAwayReqStrmId, maxProcessedStreamId)) {\n+                break;\n+            }\n+            currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n+        }\n+        final GoAwayFrame frame = new GoAwayFrame(maxProcessedStreamId, error);\n+        outputQ.put(frame);\n+        System.err.println(\"Sending GOAWAY frame \" + frame + \" from server connection \" + this);\n@@ -334,2 +351,3 @@\n-            if (error != -1)\n-                goAway(error);\n+            if (error != -1) {\n+                sendGoAway(error);\n+            }\n@@ -615,0 +633,7 @@\n+        \/\/ skip processing the request if configured to do so\n+        if (!server.shouldProcessNewHTTPRequest(this, path)) {\n+            System.err.println(\"Rejecting HTTP request on primordial stream (==1) of connection \"\n+                    + this + \", request headers: \" + headersBuilder.toString());\n+            \/\/ just return back and consider the request unprocessed\n+            return;\n+        }\n@@ -623,0 +648,1 @@\n+        maxProcessedRequestStreamId.set(1);\n@@ -635,1 +661,1 @@\n-            throw new IOException(\"unexpected stream id\");\n+            throw new IOException(\"unexpected stream id: \" + streamid);\n@@ -666,1 +692,1 @@\n-        if (disallowedHeader.isPresent())\n+        if (disallowedHeader.isPresent()) {\n@@ -668,0 +694,1 @@\n+        }\n@@ -669,1 +696,8 @@\n-\n+        \/\/ skip processing the request if the server is configured to do so\n+        final String path = headers.firstValue(\":path\").orElse(\"\");\n+        if (!server.shouldProcessNewHTTPRequest(this, path)) {\n+            System.err.println(\"Rejecting HTTP request on stream \" + streamid\n+                    + \" of connection \" + this + \", request headers: \" + headers);\n+            \/\/ just return back and consider the request unprocessed\n+            return;\n+        }\n@@ -672,0 +706,8 @@\n+        \/\/ keep track of the largest request id that we have processed\n+        int currentLargest = maxProcessedRequestStreamId.get();\n+        while (streamid > currentLargest) {\n+            if (maxProcessedRequestStreamId.compareAndSet(currentLargest, streamid)) {\n+                break;\n+            }\n+            currentLargest = maxProcessedRequestStreamId.get();\n+        }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":53,"deletions":11,"binary":false,"changes":64,"status":"modified"}]}