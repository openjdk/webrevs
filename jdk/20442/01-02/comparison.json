{"files":[{"patch":"@@ -1245,1 +1245,1 @@\n-                client2.client().theExecutor().execute(exchange::closeAsUnprocessed);\n+                client2.client().theExecutor().ensureExecutedAsync(exchange::closeAsUnprocessed);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -647,6 +647,20 @@\n-                int error = frame.getErrorCode();\n-                IOException e = new IOException(\"Received RST_STREAM: \"\n-                        + ErrorFrame.stringForCode(error));\n-                if (errorRef.compareAndSet(null, e)) {\n-                    if (subscriber != null) {\n-                        subscriber.onError(e);\n+                final int error = frame.getErrorCode();\n+                if (error == ErrorFrame.REFUSED_STREAM) {\n+                    \/\/ A REFUSED_STREAM error code implies that the stream wasn't processed by the\n+                    \/\/ peer and the client is free to retry the request afresh.\n+                    \/\/ Here we arrange for the request to be retried.\n+                    this.unprocessedByPeer = true;\n+                    errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n+                    if (debug.on()) {\n+                        debug.log(\"request unprocessed by peer (REFUSED_STREAM) \" + this.request);\n+                    }\n+                } else {\n+                    final String reason = ErrorFrame.stringForCode(error);\n+                    final IOException failureCause = new IOException(\"Received RST_STREAM: \" + reason);\n+                    if (debug.on()) {\n+                        debug.log(streamid + \" received RST_STREAM with code: \" + reason);\n+                    }\n+                    if (errorRef.compareAndSet(null, failureCause)) {\n+                        if (subscriber != null) {\n+                            subscriber.onError(failureCause);\n+                        }\n@@ -655,1 +669,2 @@\n-                completeResponseExceptionally(e);\n+                final Throwable failureCause = errorRef.get();\n+                completeResponseExceptionally(failureCause);\n@@ -657,1 +672,1 @@\n-                    requestBodyCF.completeExceptionally(errorRef.get()); \/\/ we may be sending the body..\n+                    requestBodyCF.completeExceptionally(failureCause); \/\/ we may be sending the body..\n@@ -660,1 +675,1 @@\n-                    responseBodyCF.completeExceptionally(errorRef.get());\n+                    responseBodyCF.completeExceptionally(failureCause);\n@@ -1669,1 +1684,3 @@\n-        return connection.dbgString() + \"\/Stream(\"+streamid+\")\";\n+        final int id = streamid;\n+        final String sid = id == 0 ? \"?\" : String.valueOf(id);\n+        return connection.dbgString() + \"\/Stream(\" + sid + \")\";\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,6 @@\n-            \/\/ Odd stream numbers (client streams) should have been registered.\n+            \/\/ A client initiated stream might be closed (as unprocessed, due to a\n+            \/\/ GOAWAY received on the connection) even before the stream is\n+            \/\/ registered with this WindowController instance (when sending out request headers).\n+            \/\/ Thus, for client initiated streams, we don't enforce the presence of the\n+            \/\/ stream in the registered \"streams\" map.\n+\n@@ -107,3 +112,1 @@\n-            if (old == null && isClientStream) {\n-                throw new InternalError(\"Expected entry for streamid: \" + streamid);\n-            } else if (old != null && !isClientStream) {\n+            if (old != null && !isClientStream) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/WindowController.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,3 @@\n-        return super.toString() + \" Debugdata: \" + new String(debugData, UTF_8);\n+        return super.toString()\n+                + \" lastStreamId=\" + lastStream\n+                + \", Debugdata: \" + new String(debugData, UTF_8);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/frame\/GoAwayFrame.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.HashSet;\n@@ -45,5 +44,3 @@\n-import jdk.httpclient.test.lib.http2.Http2Handler;\n-import jdk.httpclient.test.lib.http2.Http2TestExchange;\n-import jdk.httpclient.test.lib.http2.Http2TestServer;\n-import jdk.httpclient.test.lib.http2.Http2TestServerConnection;\n-import jdk.internal.net.http.frame.ErrorFrame;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n@@ -67,1 +64,1 @@\n- * @build jdk.httpclient.test.lib.http2.Http2TestServer\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n@@ -73,1 +70,1 @@\n-    private static Http2TestServer server;\n+    private static HttpTestServer server;\n@@ -81,1 +78,1 @@\n-        server = new Http2TestServer(\"localhost\", true, sslCtx);\n+        server = HttpTestServer.create(HTTP_2, sslCtx);\n@@ -107,1 +104,1 @@\n-        final RequestApprover reqApprover = new RequestApprover();\n+        final LimitedPerConnRequestApprover reqApprover = new LimitedPerConnRequestApprover();\n@@ -113,1 +110,1 @@\n-                final int numReqs = RequestApprover.MAX_REQS_PER_CONN + 3;\n+                final int numReqs = LimitedPerConnRequestApprover.MAX_REQS_PER_CONN + 3;\n@@ -157,8 +154,0 @@\n-                \/\/ create a random set of request paths that will be allowed to be processed\n-                \/\/ on the server\n-                final Set<String> allowedReqPaths = new HashSet<>();\n-                while (allowedReqPaths.size() < maxAllowedReqs) {\n-                    final int rnd = random.nextInt(1, numReqs + 1);\n-                    final String reqPath = REQ_PATH + \"?sync&\" + reqMethod + \"=\" + rnd;\n-                    allowedReqPaths.add(reqPath);\n-                }\n@@ -166,1 +155,1 @@\n-                final OnlyAllowSpecificPaths reqApprover = new OnlyAllowSpecificPaths(allowedReqPaths);\n+                final LimitedRequestApprover reqApprover = new LimitedRequestApprover(maxAllowedReqs);\n@@ -179,1 +168,1 @@\n-                        if (allowedReqPaths.contains(REQ_PATH + reqQueryPart)) {\n+                        if (i <= maxAllowedReqs) {\n@@ -231,8 +220,0 @@\n-                \/\/ create a random set of request paths that will be allowed to be processed\n-                \/\/ on the server\n-                final Set<String> allowedReqPaths = new HashSet<>();\n-                while (allowedReqPaths.size() < maxAllowedReqs) {\n-                    final int rnd = random.nextInt(1, numReqs + 1);\n-                    final String reqPath = REQ_PATH + \"?async&\" + reqMethod + \"=\" + rnd;\n-                    allowedReqPaths.add(reqPath);\n-                }\n@@ -240,1 +221,1 @@\n-                final OnlyAllowSpecificPaths reqApprover = new OnlyAllowSpecificPaths(allowedReqPaths);\n+                final LimitedRequestApprover reqApprover = new LimitedRequestApprover(maxAllowedReqs);\n@@ -258,0 +239,1 @@\n+                        final String reqQueryPart = \"?async&\" + reqMethod + \"=\" + i;\n@@ -259,0 +241,2 @@\n+                            System.out.println(\"waiting response of request \"\n+                                    + REQ_URI_BASE + reqQueryPart);\n@@ -279,2 +263,1 @@\n-                                    + \", for request \"\n-                                    + REQ_URI_BASE + \"?async&\" + reqMethod + \"=\" + i);\n+                                    + \", for request \" + REQ_URI_BASE + reqQueryPart);\n@@ -293,5 +276,6 @@\n-    \/\/ only allows requests with certain paths to be processed, irrespective of which\n-    \/\/ server connection is serving them. requests which don't match the allowed\n-    \/\/ paths will not be processed and a GOAWAY frame will be sent.\n-    private static final class OnlyAllowSpecificPaths {\n-        private final Set<String> allowedReqPaths;\n+    \/\/ only allows fixed number of requests, irrespective of which server connection handles\n+    \/\/ it. requests that are rejected will either be sent a GOAWAY on the connection\n+    \/\/ or a RST_FRAME with a REFUSED_STREAM on the stream\n+    private static final class LimitedRequestApprover {\n+        private final int maxAllowedReqs;\n+        private final AtomicInteger numApproved = new AtomicInteger();\n@@ -299,2 +283,2 @@\n-        private OnlyAllowSpecificPaths(final Set<String> allowedReqPaths) {\n-            this.allowedReqPaths = Set.copyOf(allowedReqPaths);\n+        private LimitedRequestApprover(final int maxAllowedReqs) {\n+            this.maxAllowedReqs = maxAllowedReqs;\n@@ -303,1 +287,1 @@\n-        public boolean allowNewRequest(final Http2TestServerConnection serverConn,\n+        public boolean allowNewRequest(final String serverConnKey,\n@@ -305,14 +289,2 @@\n-            if (allowedReqPaths.contains(reqPath)) {\n-                \/\/ allowed\n-                return true;\n-            }\n-            System.out.println(\"sending GOAWAY on server connection \" + serverConn\n-                    + \" for request: \" + reqPath);\n-            try {\n-                serverConn.sendGoAway(ErrorFrame.NO_ERROR);\n-            } catch (IOException e) {\n-                System.err.println(\"Failed to send GOAWAY on server connection: \"\n-                        + serverConn + \", request: \" + reqPath + \", due to: \" + e);\n-                e.printStackTrace();\n-            }\n-            return false;\n+            final int approved = numApproved.incrementAndGet();\n+            return approved <= maxAllowedReqs;\n@@ -322,3 +294,4 @@\n-    \/\/ allows a certain number of requests per server connection, before sending a GOAWAY\n-    \/\/ for any subsequent requests on that connection\n-    private static final class RequestApprover {\n+    \/\/ allows a certain number of requests per server connection.\n+    \/\/ requests that are rejected will either be sent a GOAWAY on the connection\n+    \/\/ or a RST_FRAME with a REFUSED_STREAM on the stream\n+    private static final class LimitedPerConnRequestApprover {\n@@ -326,1 +299,1 @@\n-        private final Map<Http2TestServerConnection, AtomicInteger> numApproved =\n+        private final Map<String, AtomicInteger> numApproved =\n@@ -328,1 +301,1 @@\n-        private final Map<Http2TestServerConnection, AtomicInteger> numDisapproved =\n+        private final Map<String, AtomicInteger> numDisapproved =\n@@ -331,3 +304,2 @@\n-        public boolean allowNewRequest(final Http2TestServerConnection serverConn,\n-                                       final String reqPath) {\n-            final AtomicInteger approved = numApproved.computeIfAbsent(serverConn,\n+        public boolean allowNewRequest(final String serverConnKey, final String reqPath) {\n+            final AtomicInteger approved = numApproved.computeIfAbsent(serverConnKey,\n@@ -342,1 +314,1 @@\n-            final AtomicInteger disapproved = numDisapproved.computeIfAbsent(serverConn,\n+            final AtomicInteger disapproved = numDisapproved.computeIfAbsent(serverConnKey,\n@@ -346,9 +318,1 @@\n-                    + numUnprocessed + \" unprocessed requests so far,\" +\n-                    \" sending GOAWAY on connection \" + serverConn);\n-            try {\n-                serverConn.sendGoAway(ErrorFrame.NO_ERROR);\n-            } catch (IOException e) {\n-                System.err.println(\"Failed to send GOAWAY on server connection: \"\n-                        + serverConn + \", due to: \" + e);\n-                e.printStackTrace();\n-            }\n+                    + numUnprocessed + \" unprocessed requests on connection \" + serverConnKey);\n@@ -359,1 +323,1 @@\n-    private static final class Handler implements Http2Handler {\n+    private static final class Handler implements HttpTestHandler {\n@@ -362,1 +326,1 @@\n-        public void handle(final Http2TestExchange exchange) throws IOException {\n+        public void handle(final HttpTestExchange exchange) throws IOException {\n@@ -364,2 +328,2 @@\n-            System.out.println(connectionKey + \" responding to request: \"\n-                    + exchange.getRequestURI());\n+            System.out.println(\"responding to request: \" + exchange.getRequestURI()\n+                    + \" on connection \" + connectionKey);\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/H2GoAwayTest.java","additions":40,"deletions":76,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import java.util.function.BiPredicate;\n@@ -242,0 +243,1 @@\n+        public abstract String getConnectionKey();\n@@ -256,1 +258,1 @@\n-            return new Http2TestExchangeImpl(exchange);\n+            return new H2ExchangeImpl(exchange);\n@@ -309,0 +311,6 @@\n+\n+            @Override\n+            public String getConnectionKey() {\n+                return exchange.getLocalAddress() + \"->\" + exchange.getRemoteAddress();\n+            }\n+\n@@ -315,1 +323,1 @@\n-        private static final class Http2TestExchangeImpl extends HttpTestExchange {\n+        private static final class H2ExchangeImpl extends HttpTestExchange {\n@@ -317,1 +325,1 @@\n-            Http2TestExchangeImpl(Http2TestExchange exch) {\n+            H2ExchangeImpl(Http2TestExchange exch) {\n@@ -366,0 +374,5 @@\n+            @Override\n+            public String getConnectionKey() {\n+                return exchange.getConnectionKey();\n+            }\n+\n@@ -711,0 +724,1 @@\n+        public abstract void setRequestApprover(final BiPredicate<String, String> approver);\n@@ -859,0 +873,5 @@\n+\n+            @Override\n+            public void setRequestApprover(final BiPredicate<String, String> approver) {\n+                throw new UnsupportedOperationException(\"not supported\");\n+            }\n@@ -910,0 +929,5 @@\n+\n+            @Override\n+            public void setRequestApprover(final BiPredicate<String, String> approver) {\n+                this.impl.setRequestApprover(approver);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -76,4 +76,2 @@\n-     * {@return a string that identifies the underlying connection for this exchange}\n-     * @apiNote\n-     * This connection key can be useful to figure out whether two exchanges\n-     * were performed on the same underlying connection.\n+     * {@return the identification of the connection on which this exchange is being\n+     * processed}\n@@ -81,3 +79,1 @@\n-    default String getConnectionKey() {\n-        return \"{local=%s, remote=%s}\".formatted(getLocalAddress(), getRemoteAddress());\n-    }\n+    String getConnectionKey();\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchange.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -223,0 +223,5 @@\n+    @Override\n+    public String getConnectionKey() {\n+        return conn.connectionKey();\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchangeImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    \/\/ request approver which takes the server connection instance and the incoming request path\n+    \/\/ request approver which takes the server connection key and the incoming request path\n@@ -67,1 +67,1 @@\n-    private volatile BiPredicate<Http2TestServerConnection, String> newRequestApprover;\n+    private volatile BiPredicate<String, String> newRequestApprover;\n@@ -294,1 +294,1 @@\n-    public void setRequestApprover(final BiPredicate<Http2TestServerConnection, String> approver) {\n+    public void setRequestApprover(final BiPredicate<String, String> approver) {\n@@ -298,8 +298,2 @@\n-    public boolean shouldProcessNewHTTPRequest(final Http2TestServerConnection serverConn,\n-                                               final String reqPath) {\n-        final BiPredicate<Http2TestServerConnection, String> approver = this.newRequestApprover;\n-        if (approver == null) {\n-            \/\/ by the default the server will process new requests\n-            return true;\n-        }\n-        return approver.test(serverConn, reqPath);\n+    BiPredicate<String, String> getRequestApprover() {\n+        return this.newRequestApprover;\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServer.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+import java.util.function.BiPredicate;\n@@ -87,0 +88,1 @@\n+import static jdk.internal.net.http.frame.ErrorFrame.REFUSED_STREAM;\n@@ -243,2 +245,1 @@\n-    \/\/ public, to allow for usage in tests\n-    public void sendGoAway(final int error) throws IOException {\n+    private void sendGoAway(final int error) throws IOException {\n@@ -249,0 +250,1 @@\n+        boolean send = false;\n@@ -250,1 +252,4 @@\n-        while (currentGoAwayReqStrmId != -1 && maxProcessedStreamId < currentGoAwayReqStrmId) {\n+        \/\/ update the last processed stream id and send a goaway frame if the new last processed\n+        \/\/ stream id is lesser than the last processed stream id sent in\n+        \/\/ a previous goaway frame (if any)\n+        while (currentGoAwayReqStrmId == -1 || maxProcessedStreamId < currentGoAwayReqStrmId) {\n@@ -252,0 +257,1 @@\n+                send = true;\n@@ -256,0 +262,3 @@\n+        if (!send) {\n+            return;\n+        }\n@@ -634,4 +643,5 @@\n-        if (!server.shouldProcessNewHTTPRequest(this, path)) {\n-            System.err.println(\"Rejecting HTTP request on primordial stream (==1) of connection \"\n-                    + this + \", request headers: \" + headersBuilder.toString());\n-            \/\/ just return back and consider the request unprocessed\n+        final String connKey = connectionKey();\n+        if (!shouldProcessNewHTTPRequest(connKey, path)) {\n+            System.err.println(\"Rejecting primordial stream 1 and sending GOAWAY\" +\n+                    \" on server connection \" + connKey + \", for request: \" + path);\n+            sendGoAway(ErrorFrame.NO_ERROR);\n@@ -654,0 +664,12 @@\n+    private boolean shouldProcessNewHTTPRequest(final String serverConnKey, final String reqPath) {\n+        final BiPredicate<String, String> approver = this.server.getRequestApprover();\n+        if (approver == null) {\n+            return true; \/\/ process the request\n+        }\n+        return approver.test(serverConnKey, reqPath);\n+    }\n+\n+    final String connectionKey() {\n+        return this.server.getAddress() + \"->\" + this.socket.getRemoteSocketAddress();\n+    }\n+\n@@ -697,0 +719,1 @@\n+        final String connKey = connectionKey();\n@@ -698,4 +721,5 @@\n-        if (!server.shouldProcessNewHTTPRequest(this, path)) {\n-            System.err.println(\"Rejecting HTTP request on stream \" + streamid\n-                    + \" of connection \" + this + \", request headers: \" + headers);\n-            \/\/ just return back and consider the request unprocessed\n+        if (!shouldProcessNewHTTPRequest(connKey, path)) {\n+            System.err.println(\"Rejecting stream \" + streamid\n+                    + \" and sending GOAWAY on server connection \"\n+                    + connKey + \", for request: \" + path);\n+            sendGoAway(ErrorFrame.NO_ERROR);\n@@ -808,0 +832,2 @@\n+                    System.err.println(\"EOF reached on connection \" + connectionKey()\n+                            + \", will no longer accept incoming frames\");\n@@ -831,0 +857,11 @@\n+                            final int streamId = frame.streamid();\n+                            final int finalProcessedStreamId = goAwayRequestStreamId.get();\n+                            \/\/ if we already sent a goaway, then don't create new streams with\n+                            \/\/ higher stream ids.\n+                            if (finalProcessedStreamId != -1 && streamId > finalProcessedStreamId) {\n+                                System.err.println(connectionKey() + \" resetting stream \" + streamId\n+                                        + \" as REFUSED_STREAM\");\n+                                final ResetFrame rst = new ResetFrame(streamId, REFUSED_STREAM);\n+                                outputQ.put(rst);\n+                                continue;\n+                            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":48,"deletions":11,"binary":false,"changes":59,"status":"modified"}]}