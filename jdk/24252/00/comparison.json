{"files":[{"patch":"@@ -473,1 +473,1 @@\n-    assert(_callee == nullptr || _callee == m, \"repeated inline attempt with different callee\");\n+    assert(_callee == nullptr, \"repeated inlining attempt\");\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1094,9 +1094,0 @@\n-void CallJavaNode::register_for_late_inline() {\n-  if (generator() != nullptr) {\n-    Compile::current()->prepend_late_inline(generator());\n-    set_generator(nullptr);\n-  } else {\n-    assert(false, \"repeated inline attempt\");\n-  }\n-}\n-\n@@ -1113,20 +1104,11 @@\n-    if (cg->is_mh_late_inline()) {\n-      assert(IncrementalInlineMH, \"required\");\n-      assert(cg->call_node() == this, \"mismatch\");\n-      assert(cg->method()->is_method_handle_intrinsic(), \"required\");\n-\n-      \/\/ Check whether this MH handle call becomes a candidate for inlining.\n-      ciMethod* callee = cg->method();\n-      vmIntrinsics::ID iid = callee->intrinsic_id();\n-      if (iid == vmIntrinsics::_invokeBasic) {\n-        if (in(TypeFunc::Parms)->Opcode() == Op_ConP) {\n-          register_for_late_inline();\n-        }\n-      } else if (iid == vmIntrinsics::_linkToNative) {\n-        \/\/ never retry\n-      } else {\n-        assert(callee->has_member_arg(), \"wrong type of call?\");\n-        if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP) {\n-          register_for_late_inline();\n-          phase->C->inc_number_of_mh_late_inlines();\n-        }\n+    assert(IncrementalInlineMH, \"required\");\n+    assert(cg->call_node() == this, \"mismatch\");\n+    assert(cg->is_mh_late_inline(), \"not virtual\");\n+\n+    \/\/ Check whether this MH handle call becomes a candidate for inlining.\n+    ciMethod* callee = cg->method();\n+    vmIntrinsics::ID iid = callee->intrinsic_id();\n+    if (iid == vmIntrinsics::_invokeBasic) {\n+      if (in(TypeFunc::Parms)->Opcode() == Op_ConP) {\n+        phase->C->prepend_late_inline(cg);\n+        set_generator(nullptr);\n@@ -1134,0 +1116,2 @@\n+    } else if (iid == vmIntrinsics::_linkToNative) {\n+      \/\/ never retry\n@@ -1135,5 +1119,4 @@\n-      assert(IncrementalInline, \"required\");\n-      assert(!cg->method()->is_method_handle_intrinsic(), \"required\");\n-      if (phase->C->print_inlining()) {\n-        phase->C->inline_printer()->record(cg->method(), cg->call_node()->jvms(), InliningResult::FAILURE,\n-          \"static call node changed: trying again\");\n+      assert(callee->has_member_arg(), \"wrong type of call?\");\n+      if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP) {\n+        phase->C->prepend_late_inline(cg);\n+        set_generator(nullptr);\n@@ -1141,1 +1124,0 @@\n-      register_for_late_inline();\n@@ -1210,18 +1192,18 @@\n-    if (cg->is_virtual_late_inline()) {\n-      assert(IncrementalInlineVirtual, \"required\");\n-      assert(cg->call_node() == this, \"mismatch\");\n-\n-      \/\/ Recover symbolic info for method resolution.\n-      ciMethod* caller = jvms()->method();\n-      ciBytecodeStream iter(caller);\n-      iter.force_bci(jvms()->bci());\n-\n-      bool             not_used1;\n-      ciSignature*     not_used2;\n-      ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n-      ciKlass*         holder       = iter.get_declared_method_holder();\n-      if (orig_callee->is_method_handle_intrinsic()) {\n-        assert(_override_symbolic_info, \"required\");\n-        orig_callee = method();\n-        holder = method()->holder();\n-      }\n+    assert(IncrementalInlineVirtual, \"required\");\n+    assert(cg->call_node() == this, \"mismatch\");\n+    assert(cg->is_virtual_late_inline(), \"not virtual\");\n+\n+    \/\/ Recover symbolic info for method resolution.\n+    ciMethod* caller = jvms()->method();\n+    ciBytecodeStream iter(caller);\n+    iter.force_bci(jvms()->bci());\n+\n+    bool             not_used1;\n+    ciSignature*     not_used2;\n+    ciMethod*        orig_callee  = iter.get_method(not_used1, &not_used2);  \/\/ callee in the bytecode\n+    ciKlass*         holder       = iter.get_declared_method_holder();\n+    if (orig_callee->is_method_handle_intrinsic()) {\n+      assert(_override_symbolic_info, \"required\");\n+      orig_callee = method();\n+      holder = method()->holder();\n+    }\n@@ -1229,1 +1211,1 @@\n-      ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n+    ciInstanceKlass* klass = ciEnv::get_instance_klass_for_declared_method_holder(holder);\n@@ -1231,2 +1213,2 @@\n-      Node* receiver_node = in(TypeFunc::Parms);\n-      const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n+    Node* receiver_node = in(TypeFunc::Parms);\n+    const TypeOopPtr* receiver_type = phase->type(receiver_node)->isa_oopptr();\n@@ -1234,16 +1216,9 @@\n-      int  not_used3;\n-      bool call_does_dispatch;\n-      ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n-                                                         call_does_dispatch, not_used3);  \/\/ out-parameters\n-      if (!call_does_dispatch) {\n-        \/\/ Register for late inlining.\n-        cg->set_callee_method(callee);\n-        register_for_late_inline(); \/\/ MH late inlining prepends to the list, so do the same\n-      }\n-    } else {\n-      assert(IncrementalInline, \"required\");\n-      if (phase->C->print_inlining()) {\n-        phase->C->inline_printer()->record(cg->method(), cg->call_node()->jvms(), InliningResult::FAILURE,\n-          \"dynamic call node changed: trying again\");\n-      }\n-      register_for_late_inline();\n+    int  not_used3;\n+    bool call_does_dispatch;\n+    ciMethod* callee = phase->C->optimize_virtual_call(caller, klass, holder, orig_callee, receiver_type, true \/*is_virtual*\/,\n+                                                       call_does_dispatch, not_used3);  \/\/ out-parameters\n+    if (!call_does_dispatch) {\n+      \/\/ Register for late inlining.\n+      cg->set_callee_method(callee);\n+      phase->C->prepend_late_inline(cg); \/\/ MH late inlining prepends to the list, so do the same\n+      set_generator(nullptr);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":47,"deletions":72,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -793,1 +793,0 @@\n-  void register_for_late_inline();\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2088,1 +2088,0 @@\n-    bool is_scheduled_for_igvn_before = C->igvn_worklist()->member(cg->call_node());\n@@ -2099,10 +2098,0 @@\n-      } else {\n-        bool is_scheduled_for_igvn_after = C->igvn_worklist()->member(cg->call_node());\n-        if (!is_scheduled_for_igvn_before && is_scheduled_for_igvn_after) {\n-          \/\/ Avoid potential infinite loop if node already in the IGVN list\n-          assert(false, \"scheduled for IGVN during inlining attempt\");\n-        } else {\n-          \/\/ Ensure call node has not disappeared from IGVN worklist during a failed inlining attempt\n-          assert(!is_scheduled_for_igvn_before || is_scheduled_for_igvn_after, \"call node removed from IGVN list during inlining pass\");\n-          cg->call_node()->set_generator(cg);\n-        }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+compiler\/vectorapi\/VectorLogicalOpIdentityTest.java 8302459 linux-x64,windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * @bug 8325520 8302459\n+ * @bug 8325520\n@@ -1401,1 +1401,1 @@\n-                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+IncrementalInlineForceCleanup\")\n@@ -1403,5 +1403,0 @@\n-        testFramework = new TestFramework();\n-        testFramework.setDefaultWarmup(10000)\n-                     .addFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\")\n-                     .start();\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorGatherMaskFoldingTest.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @bug 8288294 8302459\n+ * @bug 8288294\n@@ -764,1 +764,0 @@\n-        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\", \"-XX:-TieredCompilation\");\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorLogicalOpIdentityTest.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}