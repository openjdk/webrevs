{"files":[{"patch":"@@ -3046,0 +3046,29 @@\n+\n+\/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n+int os::Aix::stat64x_via_LIBPATH(const char* path, struct stat64x* stat) {\n+  if (path[0] == '\/' ||\n+      (path[0] == '.' && (path[1] == '\/' ||\n+                          (path[1] == '.' && path[2] == '\/')))) {\n+    return stat64x(path, stat);\n+  }\n+\n+  const char* env = getenv(\"LIBPATH\");\n+  if (env == nullptr || *env == 0)\n+    return -1;\n+\n+  int ret = -1;\n+  size_t libpathlen = strlen(env);\n+  char* libpath = NEW_C_HEAP_ARRAY(char, libpathlen + 1, mtServiceability);\n+  char* combined = NEW_C_HEAP_ARRAY(char, libpathlen + strlen(path) + 1, mtServiceability);\n+  char *saveptr, *token;\n+  strcpy(libpath, env);\n+  for (token = strtok_r(libpath, \":\", &saveptr); token != nullptr; token = strtok_r(nullptr, \":\", &saveptr)) {\n+    sprintf(combined, \"%s\/%s\", token, path);\n+    if (0 == (ret = stat64x(combined, stat)))\n+      break;\n+  }\n+\n+  FREE_C_HEAP_ARRAY(char*, combined);\n+  FREE_C_HEAP_ARRAY(char*, libpath);\n+  return ret;\n+}\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2013, 2016 SAP SE. All rights reserved.\n+ * Copyright (c) 2013, 2023 SAP SE. All rights reserved.\n@@ -177,0 +177,3 @@\n+\n+  \/\/ Simulate the library search algorithm of dlopen() (in os::dll_load)\n+  static int stat64x_via_LIBPATH(const char* path, struct stat64x* stat);\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,0 +77,4 @@\n+#ifdef AIX\n+  _inode(0),\n+  _device(0),\n+#endif\n@@ -121,0 +125,18 @@\n+#ifdef AIX\n+void JvmtiAgent::set_inode(unsigned long inode) {\n+  _inode = inode;\n+}\n+\n+void JvmtiAgent::set_device(unsigned long device) {\n+  _device = device;\n+}\n+\n+unsigned long JvmtiAgent::inode() const {\n+  return _inode;\n+}\n+\n+unsigned long JvmtiAgent::device() const {\n+  return _device;\n+}\n+#endif\n+\n@@ -275,0 +297,14 @@\n+#ifdef AIX\n+\/\/ save the inode and device of the library's file as a signature. This signature can be used\n+\/\/ in the same way as the library handle as a signature on other platforms.\n+static void save_library_signature(JvmtiAgent* agent, const char* name) {\n+  struct stat64x libstat;\n+  if (0 == os::Aix::stat64x_via_LIBPATH(name, &libstat)) {\n+    agent->set_inode(libstat.st_ino);\n+    agent->set_device(libstat.st_dev);\n+  } else {\n+    assert(false, \"stat64x failed\");\n+  }\n+}\n+#endif\n+\n@@ -284,0 +320,1 @@\n+  AIX_ONLY(if (library != nullptr) save_library_signature(agent, agent->name());)\n@@ -296,0 +333,1 @@\n+    AIX_ONLY(if (library != nullptr) save_library_signature(agent, &buffer[0]);)\n@@ -301,0 +339,1 @@\n+      AIX_ONLY(save_library_signature(agent, &buffer[0]);)\n@@ -518,0 +557,3 @@\n+  #ifdef AIX\n+    previously_loaded = JvmtiAgentList::is_dynamic_lib_loaded(agent->device(), agent->inode());\n+  #else\n@@ -519,0 +561,1 @@\n+  #endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -46,0 +46,4 @@\n+#ifdef AIX\n+  unsigned long _inode;\n+  unsigned long _device;\n+#endif\n@@ -83,0 +87,6 @@\n+#ifdef AIX\n+  void set_inode(unsigned long inode);\n+  void set_device(unsigned long device);\n+  unsigned long inode() const;\n+  unsigned long device() const;\n+#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgent.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -246,0 +246,13 @@\n+#ifdef AIX\n+bool JvmtiAgentList::is_dynamic_lib_loaded(unsigned long device, unsigned long inode) {\n+  JvmtiAgentList::Iterator it = JvmtiAgentList::agents();\n+  while (it.has_next()) {\n+    JvmtiAgent* const agent = it.next();\n+    if (!agent->is_static_lib() && device != 0 && inode != 0 &&\n+        agent->device() == device && agent->inode() == inode) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+#ifdef AIX\n+  static bool is_dynamic_lib_loaded(unsigned long device, unsigned long inode);\n+#endif\n","filename":"src\/hotspot\/share\/prims\/jvmtiAgentList.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -126,12 +126,9 @@\n-        \/\/ test behavior on platforms that can detect if an agent library was previously loaded\n-        if (!Platform.isAix()) {\n-            \/\/ start loadJvmtiAgent1 via the command line, then dynamically load loadJvmtiAgent1\n-            test().withOpts(\"-agentpath:\" + jvmtiAgentPath1)\n-                    .whenRunning(loadJvmtiAgent1)\n-                    .stderrShouldNotContain(JVMTI_AGENT_WARNING);\n-\n-            \/\/ dynamically load loadJvmtiAgent1 twice, should be one warning\n-            test().whenRunning(loadJvmtiAgent1)\n-                    .whenRunning(loadJvmtiAgent1)\n-                    .stderrShouldContain(JVMTI_AGENT_WARNING, 1);\n-        }\n+        \/\/ start loadJvmtiAgent1 via the command line, then dynamically load loadJvmtiAgent1\n+        test().withOpts(\"-agentpath:\" + jvmtiAgentPath1)\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldNotContain(JVMTI_AGENT_WARNING);\n+\n+        \/\/ dynamically load loadJvmtiAgent1 twice, should be one warning\n+        test().whenRunning(loadJvmtiAgent1)\n+                .whenRunning(loadJvmtiAgent1)\n+                .stderrShouldContain(JVMTI_AGENT_WARNING, 1);\n","filename":"test\/jdk\/com\/sun\/tools\/attach\/warnings\/DynamicLoadWarningTest.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"}]}