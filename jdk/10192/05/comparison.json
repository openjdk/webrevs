{"files":[{"patch":"@@ -5090,0 +5090,42 @@\n+instruct vmaskcast_extend_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    __ neon_vector_extend($dst$$FloatRegister, dst_bt, length_in_bytes_dst,\n+                          $src$$FloatRegister, src_bt);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, dst_bt,\n+                          $src$$FloatRegister, src_bt, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -5100,1 +5142,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend_sve(pRegGov dst, pReg src) %{\n@@ -5104,1 +5146,1 @@\n-  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  format %{ \"vmaskcast_extend_sve $dst, $src\" %}\n@@ -5117,1 +5159,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow_sve(pRegGov dst, pReg src) %{\n@@ -5121,1 +5163,1 @@\n-  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  format %{ \"vmaskcast_narrow_sve $dst, $src\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":46,"deletions":4,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -3506,0 +3506,42 @@\n+instruct vmaskcast_extend_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) > Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_extend_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_dst = Matcher::vector_length_in_bytes(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    __ neon_vector_extend($dst$$FloatRegister, dst_bt, length_in_bytes_dst,\n+                          $src$$FloatRegister, src_bt);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow_neon(vReg dst, vReg src) %{\n+  predicate(UseSVE == 0 &&\n+            Matcher::vector_length_in_bytes(n) < Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vmaskcast_narrow_neon $dst, $src\" %}\n+  ins_encode %{\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    if (is_floating_point_type(dst_bt)) {\n+      dst_bt = (dst_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    if (is_floating_point_type(src_bt)) {\n+      src_bt = (src_bt == T_FLOAT) ? T_INT : T_LONG;\n+    }\n+    uint length_in_bytes_src = Matcher::vector_length_in_bytes(this, $src);\n+    __ neon_vector_narrow($dst$$FloatRegister, dst_bt,\n+                          $src$$FloatRegister, src_bt, length_in_bytes_src);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -3516,1 +3558,1 @@\n-instruct vmaskcast_extend(pRegGov dst, pReg src) %{\n+instruct vmaskcast_extend_sve(pRegGov dst, pReg src) %{\n@@ -3520,1 +3562,1 @@\n-  format %{ \"vmaskcast_extend $dst, $src\" %}\n+  format %{ \"vmaskcast_extend_sve $dst, $src\" %}\n@@ -3533,1 +3575,1 @@\n-instruct vmaskcast_narrow(pRegGov dst, pReg src) %{\n+instruct vmaskcast_narrow_sve(pRegGov dst, pReg src) %{\n@@ -3537,1 +3579,1 @@\n-  format %{ \"vmaskcast_narrow $dst, $src\" %}\n+  format %{ \"vmaskcast_narrow_sve $dst, $src\" %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":46,"deletions":4,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -4618,0 +4618,55 @@\n+void C2_MacroAssembler::vector_mask_cast(XMMRegister dst, XMMRegister src,\n+                                         BasicType dst_bt, BasicType src_bt, int vlen) {\n+  int vlen_enc = vector_length_encoding(MAX2(type2aelembytes(src_bt), type2aelembytes(dst_bt)) * vlen);\n+  assert(vlen_enc != AVX_512bit, \"\");\n+\n+  int dst_bt_size = type2aelembytes(dst_bt);\n+  int src_bt_size = type2aelembytes(src_bt);\n+  if (dst_bt_size > src_bt_size) {\n+    switch (dst_bt_size \/ src_bt_size) {\n+      case 2: vpmovsxbw(dst, src, vlen_enc); break;\n+      case 4: vpmovsxbd(dst, src, vlen_enc); break;\n+      case 8: vpmovsxbq(dst, src, vlen_enc); break;\n+      default: ShouldNotReachHere();\n+    }\n+  } else {\n+    assert(dst_bt_size < src_bt_size, \"\");\n+    switch (src_bt_size \/ dst_bt_size) {\n+      case 2: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpacksswb(dst, src, src, vlen_enc);\n+        } else {\n+          vpacksswb(dst, src, src, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+        }\n+        break;\n+      }\n+      case 4: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpackssdw(dst, src, src, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      case 8: {\n+        if (vlen_enc == AVX_128bit) {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, vlen_enc);\n+          vpacksswb(dst, dst, dst, vlen_enc);\n+        } else {\n+          vpshufd(dst, src, 0x08, vlen_enc);\n+          vpermq(dst, dst, 0x08, vlen_enc);\n+          vpackssdw(dst, dst, dst, AVX_128bit);\n+          vpacksswb(dst, dst, dst, AVX_128bit);\n+        }\n+        break;\n+      }\n+      default: ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -342,0 +342,2 @@\n+  void vector_mask_cast(XMMRegister dst, XMMRegister src, BasicType dst_bt, BasicType src_bt, int vlen);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1481,0 +1481,1 @@\n+    case Op_VectorMaskCast:\n@@ -1852,0 +1853,1 @@\n+    case Op_VectorMaskCast:\n@@ -8388,1 +8390,0 @@\n-  predicate(Matcher::vector_length(n) == Matcher::vector_length(n->in(1)));\n@@ -8399,2 +8400,1 @@\n-  predicate((Matcher::vector_length(n) == Matcher::vector_length(n->in(1))) &&\n-            (Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1))));\n+  predicate(Matcher::vector_length_in_bytes(n) == Matcher::vector_length_in_bytes(n->in(1)));\n@@ -8410,0 +8410,13 @@\n+instruct vmaskcast_avx(vec dst, vec src) %{\n+  predicate(Matcher::vector_length_in_bytes(n) != Matcher::vector_length_in_bytes(n->in(1)));\n+  match(Set dst (VectorMaskCast src));\n+  format %{ \"vector_mask_cast $dst, $src\" %}\n+  ins_encode %{\n+    int vlen = Matcher::vector_length(this);\n+    BasicType src_bt = Matcher::vector_element_basic_type(this, $src);\n+    BasicType dst_bt = Matcher::vector_element_basic_type(this);\n+    __ vector_mask_cast($dst$$XMMRegister, $src$$XMMRegister, dst_bt, src_bt, vlen);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2491,9 +2491,2 @@\n-    BasicType new_elem_bt_to = elem_bt_to;\n-    BasicType new_elem_bt_from = elem_bt_from;\n-    if (is_mask && is_floating_point_type(elem_bt_from)) {\n-      new_elem_bt_from = elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    if (is_mask && is_floating_point_type(elem_bt_to)) {\n-      new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    int cast_vopc = VectorCastNode::opcode(new_elem_bt_from, !is_ucast);\n+    assert(!is_mask || num_elem_from == num_elem_to, \"vector mask cast needs the same elem num\");\n+    int cast_vopc = VectorCastNode::opcode(elem_bt_from, !is_ucast);\n@@ -2501,5 +2494,3 @@\n-    \/\/ Make sure that vector cast is implemented to particular type\/size combination.\n-    bool no_vec_cast_check = is_mask &&\n-                             ((src_type->isa_vectmask() && dst_type->isa_vectmask()) ||\n-                              type2aelembytes(elem_bt_from) == type2aelembytes(elem_bt_to));\n-    if (!no_vec_cast_check && !arch_supports_vector(cast_vopc, num_elem_to, new_elem_bt_to, VecMaskNotUsed)) {\n+    \/\/ Make sure that vector cast is implemented to particular type\/size combination if it is\n+    \/\/ not a mask casting.\n+    if (!is_mask && !arch_supports_vector(cast_vopc, num_elem_to, elem_bt_to, VecMaskNotUsed)) {\n@@ -2508,1 +2499,1 @@\n-                      cast_vopc, num_elem_to, type2name(new_elem_bt_to), is_mask);\n+                      cast_vopc, num_elem_to, type2name(elem_bt_to), is_mask);\n@@ -2555,5 +2546,7 @@\n-        if ((dst_type->isa_vectmask() && src_type->isa_vectmask()) ||\n-            (type2aelembytes(elem_bt_from) == type2aelembytes(elem_bt_to))) {\n-          op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n-        } else {\n-          op = VectorMaskCastNode::makeCastNode(&gvn(), op, dst_type);\n+        \/\/ Make sure that cast for vector mask is implemented to particular type\/size combination.\n+        if (!arch_supports_vector(Op_VectorMaskCast, num_elem_to, elem_bt_to, VecMaskNotUsed)) {\n+          if (C->print_intrinsics()) {\n+            tty->print_cr(\"  ** not supported: arity=1 op=maskcast vlen2=%d etype2=%s ismask=%d\",\n+                          num_elem_to, type2name(elem_bt_to), is_mask);\n+          }\n+          return false;\n@@ -2561,0 +2554,1 @@\n+        op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1622,0 +1622,1 @@\n+          \/\/ VectorUnbox (VectorBox vmask) ==> VectorMaskCast vmask\n@@ -1623,10 +1624,1 @@\n-          if (in_vt->length_in_bytes() == out_vt->length_in_bytes() &&\n-              Matcher::match_rule_supported_vector(Op_VectorMaskCast, out_vt->length(), out_vt->element_basic_type())) {\n-            \/\/ Apply \"VectorUnbox (VectorBox vmask) ==> VectorMaskCast (vmask)\"\n-            \/\/ directly. This could avoid the transformation ordering issue from\n-            \/\/ \"VectorStoreMask (VectorLoadMask vmask) => vmask\".\n-            return new VectorMaskCastNode(value, vmask_type);\n-          }\n-          \/\/ VectorUnbox (VectorBox vmask) ==> VectorLoadMask (VectorStoreMask vmask)\n-          value = phase->transform(VectorStoreMaskNode::make(*phase, value, in_vt->element_basic_type(), in_vt->length()));\n-          return new VectorLoadMaskNode(value, vmask_type);\n+          return new VectorMaskCastNode(value, vmask_type);\n@@ -1723,42 +1715,0 @@\n-Node* VectorMaskCastNode::makeCastNode(PhaseGVN* phase, Node* src, const TypeVect* dst_type) {\n-  const TypeVect* src_type = src->bottom_type()->is_vect();\n-  assert(src_type->length() == dst_type->length(), \"\");\n-\n-  int num_elem = src_type->length();\n-  BasicType elem_bt_from = src_type->element_basic_type();\n-  BasicType elem_bt_to = dst_type->element_basic_type();\n-\n-  if (dst_type->isa_vectmask() == NULL && src_type->isa_vectmask() == NULL &&\n-      type2aelembytes(elem_bt_from) != type2aelembytes(elem_bt_to)) {\n-\n-    Node* op = src;\n-    BasicType new_elem_bt_from = elem_bt_from;\n-    BasicType new_elem_bt_to = elem_bt_to;\n-    if (is_floating_point_type(elem_bt_from)) {\n-      new_elem_bt_from =  elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n-    }\n-    if (is_floating_point_type(elem_bt_to)) {\n-      new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-    }\n-\n-    \/\/ Special handling for casting operation involving floating point types.\n-    \/\/ Case A) F -> X :=  F -> VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2X\n-    \/\/ Case B) X -> F :=  X -> VectorCastX2[I\/L] -> VectorMaskCast ([I\/L]->F [NOP])\n-    \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2[L\/I] -> VectotMaskCast (L\/I->F [NOP])\n-\n-    if (new_elem_bt_from != elem_bt_from) {\n-      const TypeVect* new_src_type = TypeVect::makemask(new_elem_bt_from, num_elem);\n-      op = phase->transform(new VectorMaskCastNode(op, new_src_type));\n-    }\n-\n-    op = phase->transform(VectorCastNode::make(VectorCastNode::opcode(new_elem_bt_from), op, new_elem_bt_to, num_elem));\n-\n-    if (new_elem_bt_to != elem_bt_to) {\n-      op = phase->transform(new VectorMaskCastNode(op, dst_type));\n-    }\n-    return op;\n-  } else {\n-    return new VectorMaskCastNode(src, dst_type);\n-  }\n-}\n-\n@@ -1785,1 +1735,1 @@\n-       return VectorMaskCastNode::makeCastNode(phase, src, dst_type);\n+       return new VectorMaskCastNode(src, dst_type);\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":3,"deletions":53,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -1508,1 +1508,0 @@\n-  static Node* makeCastNode(PhaseGVN* phase, Node* in1, const TypeVect * vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -202,0 +202,1 @@\n+    public static final String VECTOR_MASK_CAST = START + \"VectorMaskCast\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n@@ -26,0 +26,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -35,1 +37,0 @@\n-import jdk.test.lib.Utils;\n@@ -37,2 +38,2 @@\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n@@ -42,1 +43,1 @@\n- * @bug 8273264\n+ * @bug 8273264 8292898\n@@ -44,2 +45,2 @@\n- * @library \/test\/lib\n- * @summary AArch64: [vector] Add missing rules for VectorMaskCast\n+ * @library \/test\/lib \/\n+ * @summary Unify vector mask cast and add missing rules for VectorMaskCast\n@@ -48,1 +49,1 @@\n- * @run testng\/othervm -XX:-TieredCompilation -XX:CompileThreshold=100 compiler.vectorapi.VectorMaskCastTest\n+ * @run driver compiler.vectorapi.VectorMaskCastTest\n@@ -51,1 +52,0 @@\n-\n@@ -59,1 +59,1 @@\n-public class VectorMaskCastTest{\n+public class VectorMaskCastTest {\n@@ -61,1 +61,0 @@\n-    private static final int NUM_ITER = 5000;\n@@ -64,4 +63,6 @@\n-    public static boolean[] genMask() {\n-        boolean[] mask = new boolean[64];\n-        for (int i = 0; i < 64; i ++) {\n-            mask[i] = rd.nextBoolean();\n+    private static final boolean[] mask_arr;\n+\n+    static {\n+        mask_arr = new boolean[64];\n+        for (int i = 0; i < 64; i++) {\n+            mask_arr[i] = rd.nextBoolean();\n@@ -69,1 +70,0 @@\n-        return mask;\n@@ -73,1 +73,4 @@\n-    private static void testByte64ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testByte64ToShort128() {\n@@ -75,1 +78,1 @@\n-        Assert.assertEquals(mByte64.cast(ShortVector.SPECIES_128).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(ShortVector.SPECIES_128).toString(), mByte64.toString());\n@@ -78,1 +81,4 @@\n-    private static void testByte64ToInt256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testByte64ToInt256() {\n@@ -80,1 +86,1 @@\n-        Assert.assertEquals(mByte64.cast(IntVector.SPECIES_256).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(IntVector.SPECIES_256).toString(), mByte64.toString());\n@@ -83,1 +89,4 @@\n-    private static void testByte64ToFloat256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testByte64ToFloat256() {\n@@ -85,1 +94,1 @@\n-        Assert.assertEquals(mByte64.cast(FloatVector.SPECIES_256).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(FloatVector.SPECIES_256).toString(), mByte64.toString());\n@@ -88,1 +97,4 @@\n-    private static void testByte64ToLong512(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testByte64ToLong512() {\n@@ -90,1 +102,1 @@\n-        Assert.assertEquals(mByte64.cast(LongVector.SPECIES_512).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(LongVector.SPECIES_512).toString(), mByte64.toString());\n@@ -93,1 +105,4 @@\n-    private static void testByte64ToDouble512(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testByte64ToDouble512() {\n@@ -95,1 +110,1 @@\n-        Assert.assertEquals(mByte64.cast(DoubleVector.SPECIES_512).toString(), mByte64.toString());\n+        Asserts.assertEquals(mByte64.cast(DoubleVector.SPECIES_512).toString(), mByte64.toString());\n@@ -98,1 +113,4 @@\n-    private static void testByte128ToShort256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testByte128ToShort256() {\n@@ -100,1 +118,1 @@\n-        Assert.assertEquals(mByte128.cast(ShortVector.SPECIES_256).toString(), mByte128.toString());\n+        Asserts.assertEquals(mByte128.cast(ShortVector.SPECIES_256).toString(), mByte128.toString());\n@@ -103,1 +121,4 @@\n-    private static void testByte128ToInt512(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testByte128ToInt512() {\n@@ -105,1 +126,1 @@\n-        Assert.assertEquals(mByte128.cast(IntVector.SPECIES_512).toString(), mByte128.toString());\n+        Asserts.assertEquals(mByte128.cast(IntVector.SPECIES_512).toString(), mByte128.toString());\n@@ -108,1 +129,4 @@\n-    private static void testByte128ToFloat512(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testByte128ToFloat512() {\n@@ -110,1 +134,1 @@\n-        Assert.assertEquals(mByte128.cast(FloatVector.SPECIES_512).toString(), mByte128.toString());\n+        Asserts.assertEquals(mByte128.cast(FloatVector.SPECIES_512).toString(), mByte128.toString());\n@@ -113,1 +137,4 @@\n-    private static void testByte256ToShort512(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testByte256ToShort512() {\n@@ -115,1 +142,1 @@\n-        Assert.assertEquals(mByte256.cast(ShortVector.SPECIES_512).toString(), mByte256.toString());\n+        Asserts.assertEquals(mByte256.cast(ShortVector.SPECIES_512).toString(), mByte256.toString());\n@@ -119,1 +146,4 @@\n-    private static void testShort64ToInt128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testShort64ToInt128() {\n@@ -121,1 +151,1 @@\n-        Assert.assertEquals(mShort64.cast(IntVector.SPECIES_128).toString(), mShort64.toString());\n+        Asserts.assertEquals(mShort64.cast(IntVector.SPECIES_128).toString(), mShort64.toString());\n@@ -124,1 +154,4 @@\n-    private static void testShort64ToFloat128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testShort64ToFloat128() {\n@@ -126,1 +159,1 @@\n-        Assert.assertEquals(mShort64.cast(FloatVector.SPECIES_128).toString(), mShort64.toString());\n+        Asserts.assertEquals(mShort64.cast(FloatVector.SPECIES_128).toString(), mShort64.toString());\n@@ -129,1 +162,4 @@\n-    private static void testShort64ToLong256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort64ToLong256() {\n@@ -131,1 +167,1 @@\n-        Assert.assertEquals(mShort64.cast(LongVector.SPECIES_256).toString(), mShort64.toString());\n+        Asserts.assertEquals(mShort64.cast(LongVector.SPECIES_256).toString(), mShort64.toString());\n@@ -134,1 +170,4 @@\n-    private static void testShort64ToDouble256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort64ToDouble256() {\n@@ -136,1 +175,1 @@\n-        Assert.assertEquals(mShort64.cast(DoubleVector.SPECIES_256).toString(), mShort64.toString());\n+        Asserts.assertEquals(mShort64.cast(DoubleVector.SPECIES_256).toString(), mShort64.toString());\n@@ -139,1 +178,4 @@\n-    private static void testShort128ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testShort128ToByte64() {\n@@ -141,1 +183,1 @@\n-        Assert.assertEquals(mShort128.cast(ByteVector.SPECIES_64).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(ByteVector.SPECIES_64).toString(), mShort128.toString());\n@@ -144,1 +186,4 @@\n-    private static void testShort128ToInt256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort128ToInt256() {\n@@ -146,1 +191,1 @@\n-        Assert.assertEquals(mShort128.cast(IntVector.SPECIES_256).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(IntVector.SPECIES_256).toString(), mShort128.toString());\n@@ -149,1 +194,4 @@\n-    private static void testShort128ToFloat256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort128ToFloat256() {\n@@ -151,1 +199,1 @@\n-        Assert.assertEquals(mShort128.cast(FloatVector.SPECIES_256).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(FloatVector.SPECIES_256).toString(), mShort128.toString());\n@@ -154,1 +202,4 @@\n-    private static void testShort128ToLong512(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testShort128ToLong512() {\n@@ -156,1 +207,1 @@\n-        Assert.assertEquals(mShort128.cast(LongVector.SPECIES_512).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(LongVector.SPECIES_512).toString(), mShort128.toString());\n@@ -159,1 +210,4 @@\n-    private static void testShort128ToDouble512(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testShort128ToDouble512() {\n@@ -161,1 +215,1 @@\n-        Assert.assertEquals(mShort128.cast(DoubleVector.SPECIES_512).toString(), mShort128.toString());\n+        Asserts.assertEquals(mShort128.cast(DoubleVector.SPECIES_512).toString(), mShort128.toString());\n@@ -164,1 +218,4 @@\n-    private static void testShort256ToByte128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testShort256ToByte128() {\n@@ -166,1 +223,1 @@\n-        Assert.assertEquals(mShort256.cast(ByteVector.SPECIES_128).toString(), mShort256.toString());\n+        Asserts.assertEquals(mShort256.cast(ByteVector.SPECIES_128).toString(), mShort256.toString());\n@@ -169,1 +226,4 @@\n-    private static void testShort256ToInt512(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testShort256ToInt512() {\n@@ -171,1 +231,1 @@\n-        Assert.assertEquals(mShort256.cast(IntVector.SPECIES_512).toString(), mShort256.toString());\n+        Asserts.assertEquals(mShort256.cast(IntVector.SPECIES_512).toString(), mShort256.toString());\n@@ -174,1 +234,4 @@\n-    private static void testShort256ToFloat512(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testShort256ToFloat512() {\n@@ -176,1 +239,1 @@\n-        Assert.assertEquals(mShort256.cast(FloatVector.SPECIES_512).toString(), mShort256.toString());\n+        Asserts.assertEquals(mShort256.cast(FloatVector.SPECIES_512).toString(), mShort256.toString());\n@@ -179,1 +242,4 @@\n-    private static void testShort512ToByte256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testShort512ToByte256() {\n@@ -181,1 +247,1 @@\n-        Assert.assertEquals(mShort512.cast(ByteVector.SPECIES_256).toString(), mShort512.toString());\n+        Asserts.assertEquals(mShort512.cast(ByteVector.SPECIES_256).toString(), mShort512.toString());\n@@ -185,1 +251,4 @@\n-    private static void testInt64ToLong128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testInt64ToLong128() {\n@@ -187,1 +256,1 @@\n-        Assert.assertEquals(mInt64.cast(LongVector.SPECIES_128).toString(), mInt64.toString());\n+        Asserts.assertEquals(mInt64.cast(LongVector.SPECIES_128).toString(), mInt64.toString());\n@@ -190,1 +259,4 @@\n-    private static void testInt64ToDouble128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testInt64ToDouble128() {\n@@ -192,1 +264,1 @@\n-        Assert.assertEquals(mInt64.cast(DoubleVector.SPECIES_128).toString(), mInt64.toString());\n+        Asserts.assertEquals(mInt64.cast(DoubleVector.SPECIES_128).toString(), mInt64.toString());\n@@ -195,1 +267,4 @@\n-    private static void testInt128ToShort64(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testInt128ToShort64() {\n@@ -197,1 +272,1 @@\n-        Assert.assertEquals(mInt128.cast(ShortVector.SPECIES_64).toString(), mInt128.toString());\n+        Asserts.assertEquals(mInt128.cast(ShortVector.SPECIES_64).toString(), mInt128.toString());\n@@ -200,1 +275,4 @@\n-    private static void testInt128ToLong256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testInt128ToLong256() {\n@@ -202,1 +280,1 @@\n-        Assert.assertEquals(mInt128.cast(LongVector.SPECIES_256).toString(), mInt128.toString());\n+        Asserts.assertEquals(mInt128.cast(LongVector.SPECIES_256).toString(), mInt128.toString());\n@@ -205,1 +283,4 @@\n-    private static void testInt128ToDouble256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testInt128ToDouble256() {\n@@ -207,1 +288,1 @@\n-        Assert.assertEquals(mInt128.cast(DoubleVector.SPECIES_256).toString(), mInt128.toString());\n+        Asserts.assertEquals(mInt128.cast(DoubleVector.SPECIES_256).toString(), mInt128.toString());\n@@ -210,1 +291,4 @@\n-    private static void testInt256ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testInt256ToShort128() {\n@@ -212,1 +296,1 @@\n-        Assert.assertEquals(mInt256.cast(ShortVector.SPECIES_128).toString(), mInt256.toString());\n+        Asserts.assertEquals(mInt256.cast(ShortVector.SPECIES_128).toString(), mInt256.toString());\n@@ -215,1 +299,4 @@\n-    private static void testInt256ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testInt256ToByte64() {\n@@ -217,1 +304,1 @@\n-        Assert.assertEquals(mInt256.cast(ByteVector.SPECIES_64).toString(), mInt256.toString());\n+        Asserts.assertEquals(mInt256.cast(ByteVector.SPECIES_64).toString(), mInt256.toString());\n@@ -220,1 +307,4 @@\n-    private static void testInt256ToLong512(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testInt256ToLong512() {\n@@ -222,1 +312,1 @@\n-        Assert.assertEquals(mInt256.cast(LongVector.SPECIES_512).toString(), mInt256.toString());\n+        Asserts.assertEquals(mInt256.cast(LongVector.SPECIES_512).toString(), mInt256.toString());\n@@ -225,1 +315,4 @@\n-    private static void testInt256ToDouble512(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testInt256ToDouble512() {\n@@ -227,1 +320,1 @@\n-        Assert.assertEquals(mInt256.cast(DoubleVector.SPECIES_512).toString(), mInt256.toString());\n+        Asserts.assertEquals(mInt256.cast(DoubleVector.SPECIES_512).toString(), mInt256.toString());\n@@ -230,1 +323,4 @@\n-    private static void testInt512ToShort256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testInt512ToShort256() {\n@@ -232,1 +328,1 @@\n-        Assert.assertEquals(mInt512.cast(ShortVector.SPECIES_256).toString(), mInt512.toString());\n+        Asserts.assertEquals(mInt512.cast(ShortVector.SPECIES_256).toString(), mInt512.toString());\n@@ -235,1 +331,4 @@\n-    private static void testInt512ToByte128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testInt512ToByte128() {\n@@ -237,1 +336,1 @@\n-        Assert.assertEquals(mInt512.cast(ByteVector.SPECIES_128).toString(), mInt512.toString());\n+        Asserts.assertEquals(mInt512.cast(ByteVector.SPECIES_128).toString(), mInt512.toString());\n@@ -241,1 +340,4 @@\n-    private static void testFloat64ToLong128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloat64ToLong128() {\n@@ -243,1 +345,1 @@\n-        Assert.assertEquals(mFloat64.cast(LongVector.SPECIES_128).toString(), mFloat64.toString());\n+        Asserts.assertEquals(mFloat64.cast(LongVector.SPECIES_128).toString(), mFloat64.toString());\n@@ -246,1 +348,4 @@\n-    private static void testFloat64ToDouble128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testFloat64ToDouble128() {\n@@ -248,1 +353,1 @@\n-        Assert.assertEquals(mFloat64.cast(DoubleVector.SPECIES_128).toString(), mFloat64.toString());\n+        Asserts.assertEquals(mFloat64.cast(DoubleVector.SPECIES_128).toString(), mFloat64.toString());\n@@ -251,1 +356,4 @@\n-    private static void testFloat128ToShort64(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    public static void testFloat128ToShort64() {\n@@ -253,1 +361,1 @@\n-        Assert.assertEquals(mFloat128.cast(ShortVector.SPECIES_64).toString(), mFloat128.toString());\n+        Asserts.assertEquals(mFloat128.cast(ShortVector.SPECIES_64).toString(), mFloat128.toString());\n@@ -256,1 +364,4 @@\n-    private static void testFloat128ToLong256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testFloat128ToLong256() {\n@@ -258,1 +369,1 @@\n-        Assert.assertEquals(mFloat128.cast(LongVector.SPECIES_256).toString(), mFloat128.toString());\n+        Asserts.assertEquals(mFloat128.cast(LongVector.SPECIES_256).toString(), mFloat128.toString());\n@@ -261,1 +372,4 @@\n-    private static void testFloat128ToDouble256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testFloat128ToDouble256() {\n@@ -263,1 +377,1 @@\n-        Assert.assertEquals(mFloat128.cast(DoubleVector.SPECIES_256).toString(), mFloat128.toString());\n+        Asserts.assertEquals(mFloat128.cast(DoubleVector.SPECIES_256).toString(), mFloat128.toString());\n@@ -266,1 +380,4 @@\n-    private static void testFloat256ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testFloat256ToShort128() {\n@@ -268,1 +385,1 @@\n-        Assert.assertEquals(mFloat256.cast(ShortVector.SPECIES_128).toString(), mFloat256.toString());\n+        Asserts.assertEquals(mFloat256.cast(ShortVector.SPECIES_128).toString(), mFloat256.toString());\n@@ -271,1 +388,4 @@\n-    private static void testFloat256ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testFloat256ToByte64() {\n@@ -273,1 +393,1 @@\n-        Assert.assertEquals(mFloat256.cast(ByteVector.SPECIES_64).toString(), mFloat256.toString());\n+        Asserts.assertEquals(mFloat256.cast(ByteVector.SPECIES_64).toString(), mFloat256.toString());\n@@ -276,1 +396,4 @@\n-    private static void testFloat256ToLong512(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testFloat256ToLong512() {\n@@ -278,1 +401,1 @@\n-        Assert.assertEquals(mFloat256.cast(LongVector.SPECIES_512).toString(), mFloat256.toString());\n+        Asserts.assertEquals(mFloat256.cast(LongVector.SPECIES_512).toString(), mFloat256.toString());\n@@ -281,1 +404,4 @@\n-    private static void testFloat256ToDouble512(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testFloat256ToDouble512() {\n@@ -283,1 +409,1 @@\n-        Assert.assertEquals(mFloat256.cast(DoubleVector.SPECIES_512).toString(), mFloat256.toString());\n+        Asserts.assertEquals(mFloat256.cast(DoubleVector.SPECIES_512).toString(), mFloat256.toString());\n@@ -286,1 +412,4 @@\n-    private static void testFloat512ToShort256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testFloat512ToShort256() {\n@@ -288,1 +417,1 @@\n-        Assert.assertEquals(mFloat512.cast(ShortVector.SPECIES_256).toString(), mFloat512.toString());\n+        Asserts.assertEquals(mFloat512.cast(ShortVector.SPECIES_256).toString(), mFloat512.toString());\n@@ -291,1 +420,4 @@\n-    private static void testFloat512ToByte128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testFloat512ToByte128() {\n@@ -293,1 +425,1 @@\n-        Assert.assertEquals(mFloat512.cast(ByteVector.SPECIES_128).toString(), mFloat512.toString());\n+        Asserts.assertEquals(mFloat512.cast(ByteVector.SPECIES_128).toString(), mFloat512.toString());\n@@ -297,1 +429,4 @@\n-    private static void testLong128ToInt64(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLong128ToInt64() {\n@@ -299,1 +434,1 @@\n-        Assert.assertEquals(mLong128.cast(IntVector.SPECIES_64).toString(), mLong128.toString());\n+        Asserts.assertEquals(mLong128.cast(IntVector.SPECIES_64).toString(), mLong128.toString());\n@@ -302,1 +437,4 @@\n-    private static void testLong128ToFloat64(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testLong128ToFloat64() {\n@@ -304,1 +442,1 @@\n-        Assert.assertEquals(mLong128.cast(FloatVector.SPECIES_64).toString(), mLong128.toString());\n+        Asserts.assertEquals(mLong128.cast(FloatVector.SPECIES_64).toString(), mLong128.toString());\n@@ -307,1 +445,4 @@\n-    private static void testLong256ToInt128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testLong256ToInt128() {\n@@ -309,1 +450,1 @@\n-        Assert.assertEquals(mLong256.cast(IntVector.SPECIES_128).toString(), mLong256.toString());\n+        Asserts.assertEquals(mLong256.cast(IntVector.SPECIES_128).toString(), mLong256.toString());\n@@ -312,1 +453,4 @@\n-    private static void testLong256ToFloat128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testLong256ToFloat128() {\n@@ -314,1 +458,1 @@\n-        Assert.assertEquals(mLong256.cast(FloatVector.SPECIES_128).toString(), mLong256.toString());\n+        Asserts.assertEquals(mLong256.cast(FloatVector.SPECIES_128).toString(), mLong256.toString());\n@@ -317,1 +461,4 @@\n-    private static void testLong256ToShort64(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testLong256ToShort64() {\n@@ -319,1 +466,1 @@\n-        Assert.assertEquals(mLong256.cast(ShortVector.SPECIES_64).toString(), mLong256.toString());\n+        Asserts.assertEquals(mLong256.cast(ShortVector.SPECIES_64).toString(), mLong256.toString());\n@@ -322,1 +469,4 @@\n-    private static void testLong512ToInt256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testLong512ToInt256() {\n@@ -324,1 +474,1 @@\n-        Assert.assertEquals(mLong512.cast(IntVector.SPECIES_256).toString(), mLong512.toString());\n+        Asserts.assertEquals(mLong512.cast(IntVector.SPECIES_256).toString(), mLong512.toString());\n@@ -327,1 +477,4 @@\n-    private static void testLong512ToFloat256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testLong512ToFloat256() {\n@@ -329,1 +482,1 @@\n-        Assert.assertEquals(mLong512.cast(FloatVector.SPECIES_256).toString(), mLong512.toString());\n+        Asserts.assertEquals(mLong512.cast(FloatVector.SPECIES_256).toString(), mLong512.toString());\n@@ -332,1 +485,4 @@\n-    private static void testLong512ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testLong512ToShort128() {\n@@ -334,1 +490,1 @@\n-        Assert.assertEquals(mLong512.cast(ShortVector.SPECIES_128).toString(), mLong512.toString());\n+        Asserts.assertEquals(mLong512.cast(ShortVector.SPECIES_128).toString(), mLong512.toString());\n@@ -337,1 +493,4 @@\n-    private static void testLong512ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testLong512ToByte64() {\n@@ -339,1 +498,1 @@\n-        Assert.assertEquals(mLong512.cast(ByteVector.SPECIES_64).toString(), mLong512.toString());\n+        Asserts.assertEquals(mLong512.cast(ByteVector.SPECIES_64).toString(), mLong512.toString());\n@@ -343,1 +502,4 @@\n-    private static void testDouble128ToInt64(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDouble128ToInt64() {\n@@ -345,1 +507,1 @@\n-        Assert.assertEquals(mDouble128.cast(IntVector.SPECIES_64).toString(), mDouble128.toString());\n+        Asserts.assertEquals(mDouble128.cast(IntVector.SPECIES_64).toString(), mDouble128.toString());\n@@ -348,1 +510,4 @@\n-    private static void testDouble128ToFloat64(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"asimd\", \"true\"})\n+    public static void testDouble128ToFloat64() {\n@@ -350,1 +515,1 @@\n-        Assert.assertEquals(mDouble128.cast(FloatVector.SPECIES_64).toString(), mDouble128.toString());\n+        Asserts.assertEquals(mDouble128.cast(FloatVector.SPECIES_64).toString(), mDouble128.toString());\n@@ -353,1 +518,4 @@\n-    private static void testDouble256ToInt128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testDouble256ToInt128() {\n@@ -355,1 +523,1 @@\n-        Assert.assertEquals(mDouble256.cast(IntVector.SPECIES_128).toString(), mDouble256.toString());\n+        Asserts.assertEquals(mDouble256.cast(IntVector.SPECIES_128).toString(), mDouble256.toString());\n@@ -358,1 +526,4 @@\n-    private static void testDouble256ToFloat128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testDouble256ToFloat128() {\n@@ -360,1 +531,1 @@\n-        Assert.assertEquals(mDouble256.cast(FloatVector.SPECIES_128).toString(), mDouble256.toString());\n+        Asserts.assertEquals(mDouble256.cast(FloatVector.SPECIES_128).toString(), mDouble256.toString());\n@@ -363,1 +534,4 @@\n-    private static void testDouble256ToShort64(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx2\", \"true\"})\n+    public static void testDouble256ToShort64() {\n@@ -365,2 +539,2 @@\n-        Assert.assertEquals(mDouble256.cast(ShortVector.SPECIES_64).toString(), mDouble256.toString());\n-    };\n+        Asserts.assertEquals(mDouble256.cast(ShortVector.SPECIES_64).toString(), mDouble256.toString());\n+    }\n@@ -368,1 +542,4 @@\n-    private static void testDouble512ToInt256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testDouble512ToInt256() {\n@@ -370,1 +547,1 @@\n-        Assert.assertEquals(mDouble512.cast(IntVector.SPECIES_256).toString(), mDouble512.toString());\n+        Asserts.assertEquals(mDouble512.cast(IntVector.SPECIES_256).toString(), mDouble512.toString());\n@@ -373,1 +550,4 @@\n-    private static void testDouble512ToFloat256(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testDouble512ToFloat256() {\n@@ -375,1 +555,1 @@\n-        Assert.assertEquals(mDouble512.cast(FloatVector.SPECIES_256).toString(), mDouble512.toString());\n+        Asserts.assertEquals(mDouble512.cast(FloatVector.SPECIES_256).toString(), mDouble512.toString());\n@@ -378,1 +558,4 @@\n-    private static void testDouble512ToShort128(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testDouble512ToShort128() {\n@@ -380,1 +563,1 @@\n-        Assert.assertEquals(mDouble512.cast(ShortVector.SPECIES_128).toString(), mDouble512.toString());\n+        Asserts.assertEquals(mDouble512.cast(ShortVector.SPECIES_128).toString(), mDouble512.toString());\n@@ -383,1 +566,4 @@\n-    private static void testDouble512ToByte64(boolean[] mask_arr) {\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = { IRNode.VECTOR_MASK_CAST, \"> 0\" }, applyIfCPUFeature = {\"avx512\", \"true\"})\n+    public static void testDouble512ToByte64() {\n@@ -385,82 +571,5 @@\n-        Assert.assertEquals(mDouble512.cast(ByteVector.SPECIES_64).toString(), mDouble512.toString());\n-    }\n-\n-\n-    @Test\n-    public static void testMaskCast() {\n-        for (int i = 0; i < NUM_ITER; i++) {\n-            boolean[] mask = genMask();\n-            \/\/ Byte\n-            testByte64ToShort128(mask);\n-            testByte64ToInt256(mask);\n-            testByte64ToFloat256(mask);\n-            testByte64ToLong512(mask);\n-            testByte64ToDouble512(mask);\n-            testByte128ToShort256(mask);\n-            testByte128ToInt512(mask);\n-            testByte128ToFloat512(mask);\n-            testByte256ToShort512(mask);\n-\n-            \/\/ Short\n-            testShort64ToInt128(mask);\n-            testShort64ToFloat128(mask);\n-            testShort64ToLong256(mask);\n-            testShort64ToDouble256(mask);\n-            testShort128ToByte64(mask);\n-            testShort128ToInt256(mask);\n-            testShort128ToFloat256(mask);\n-            testShort128ToLong512(mask);\n-            testShort128ToDouble512(mask);\n-            testShort256ToByte128(mask);\n-            testShort256ToInt512(mask);\n-            testShort256ToFloat512(mask);\n-            testShort512ToByte256(mask);\n-\n-            \/\/ Int\n-            testInt64ToLong128(mask);\n-            testInt64ToDouble128(mask);\n-            testInt128ToShort64(mask);\n-            testInt128ToLong256(mask);\n-            testInt128ToDouble256(mask);\n-            testInt256ToShort128(mask);\n-            testInt256ToByte64(mask);\n-            testInt256ToLong512(mask);\n-            testInt256ToDouble512(mask);\n-            testInt512ToShort256(mask);\n-            testInt512ToByte128(mask);\n-\n-            \/\/ Float\n-            testFloat64ToLong128(mask);\n-            testFloat64ToDouble128(mask);\n-            testFloat128ToShort64(mask);\n-            testFloat128ToLong256(mask);\n-            testFloat128ToDouble256(mask);\n-            testFloat256ToShort128(mask);\n-            testFloat256ToByte64(mask);\n-            testFloat256ToLong512(mask);\n-            testFloat256ToDouble512(mask);\n-            testFloat512ToShort256(mask);\n-            testFloat512ToByte128(mask);\n-\n-            \/\/ Long\n-            testLong128ToInt64(mask);\n-            testLong128ToFloat64(mask);\n-            testLong256ToInt128(mask);\n-            testLong256ToFloat128(mask);\n-            testLong256ToShort64(mask);\n-            testLong512ToInt256(mask);\n-            testLong512ToFloat256(mask);\n-            testLong512ToShort128(mask);\n-            testLong512ToByte64(mask);\n-\n-            \/\/ Double\n-            testDouble128ToInt64(mask);\n-            testDouble128ToFloat64(mask);\n-            testDouble256ToInt128(mask);\n-            testDouble256ToFloat128(mask);\n-            testDouble256ToShort64(mask);\n-            testDouble512ToInt256(mask);\n-            testDouble512ToFloat256(mask);\n-            testDouble512ToShort128(mask);\n-            testDouble512ToByte64(mask);\n-        }\n+        Asserts.assertEquals(mDouble512.cast(ByteVector.SPECIES_64).toString(), mDouble512.toString());\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCastTest.java","additions":331,"deletions":222,"binary":false,"changes":553,"status":"modified"}]}