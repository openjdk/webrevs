{"files":[{"patch":"@@ -192,0 +192,2 @@\n+  do_intrinsic(_maxL,                     java_lang_Math,         max_name,           long2_long_signature,      F_S)   \\\n+  do_intrinsic(_minL,                     java_lang_Math,         min_name,           long2_long_signature,      F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -630,0 +630,2 @@\n+  case vmIntrinsics::_maxL:\n+  case vmIntrinsics::_minL:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -684,3 +684,2 @@\n-    return inline_min_max(intrinsic_id());\n-\n-  case vmIntrinsics::_maxF:\n+  case vmIntrinsics::_minL:\n+  case vmIntrinsics::_maxL:\n@@ -688,1 +687,1 @@\n-  case vmIntrinsics::_maxD:\n+  case vmIntrinsics::_maxF:\n@@ -690,1 +689,1 @@\n-  case vmIntrinsics::_maxF_strict:\n+  case vmIntrinsics::_maxD:\n@@ -692,1 +691,1 @@\n-  case vmIntrinsics::_maxD_strict:\n+  case vmIntrinsics::_maxF_strict:\n@@ -694,1 +693,2 @@\n-      return inline_fp_min_max(intrinsic_id());\n+  case vmIntrinsics::_maxD_strict:\n+    return inline_min_max(intrinsic_id());\n@@ -1935,1 +1935,72 @@\n-  set_result(generate_min_max(id, argument(0), argument(1)));\n+  Node* a = nullptr;\n+  Node* b = nullptr;\n+  Node* n = nullptr;\n+  switch (id) {\n+    case vmIntrinsics::_min:\n+    case vmIntrinsics::_max:\n+    case vmIntrinsics::_minF:\n+    case vmIntrinsics::_maxF:\n+    case vmIntrinsics::_minF_strict:\n+    case vmIntrinsics::_maxF_strict:\n+    case vmIntrinsics::_min_strict:\n+    case vmIntrinsics::_max_strict:\n+      assert(callee()->signature()->size() == 2, \"minF\/maxF has 2 parameters of size 1 each.\");\n+      a = argument(0);\n+      b = argument(1);\n+      break;\n+    case vmIntrinsics::_minD:\n+    case vmIntrinsics::_maxD:\n+    case vmIntrinsics::_minD_strict:\n+    case vmIntrinsics::_maxD_strict:\n+      assert(callee()->signature()->size() == 4, \"minD\/maxD has 2 parameters of size 2 each.\");\n+      a = round_double_node(argument(0));\n+      b = round_double_node(argument(2));\n+      break;\n+    case vmIntrinsics::_minL:\n+    case vmIntrinsics::_maxL:\n+      assert(callee()->signature()->size() == 4, \"minL\/maxL has 2 parameters of size 2 each.\");\n+      a = argument(0);\n+      b = argument(2);\n+      break;\n+    default:\n+      fatal_unexpected_iid(id);\n+      break;\n+  }\n+\n+  switch (id) {\n+    case vmIntrinsics::_min:\n+    case vmIntrinsics::_min_strict:\n+      n = new MinINode(a, b);\n+      break;\n+    case vmIntrinsics::_max:\n+    case vmIntrinsics::_max_strict:\n+      n = new MaxINode(a, b);\n+      break;\n+    case vmIntrinsics::_minF:\n+    case vmIntrinsics::_minF_strict:\n+      n = new MinFNode(a, b);\n+      break;\n+    case vmIntrinsics::_maxF:\n+    case vmIntrinsics::_maxF_strict:\n+      n = new MaxFNode(a, b);\n+      break;\n+    case vmIntrinsics::_minD:\n+    case vmIntrinsics::_minD_strict:\n+      n = new MinDNode(a, b);\n+      break;\n+    case vmIntrinsics::_maxD:\n+    case vmIntrinsics::_maxD_strict:\n+      n = new MaxDNode(a, b);\n+      break;\n+    case vmIntrinsics::_minL:\n+      n = new MinLNode(_gvn.C, a, b);\n+      break;\n+    case vmIntrinsics::_maxL:\n+      n = new MaxLNode(_gvn.C, a, b);\n+      break;\n+    default:\n+      fatal_unexpected_iid(id);\n+      break;\n+  }\n+\n+  set_result(_gvn.transform(n));\n@@ -2014,19 +2085,0 @@\n-Node*\n-LibraryCallKit::generate_min_max(vmIntrinsics::ID id, Node* x0, Node* y0) {\n-  Node* result_val = nullptr;\n-  switch (id) {\n-  case vmIntrinsics::_min:\n-  case vmIntrinsics::_min_strict:\n-    result_val = _gvn.transform(new MinINode(x0, y0));\n-    break;\n-  case vmIntrinsics::_max:\n-  case vmIntrinsics::_max_strict:\n-    result_val = _gvn.transform(new MaxINode(x0, y0));\n-    break;\n-  default:\n-    fatal_unexpected_iid(id);\n-    break;\n-  }\n-  return result_val;\n-}\n-\n@@ -4491,1 +4543,1 @@\n-      Node* moved = generate_min_max(vmIntrinsics::_min, orig_tail, length);\n+      Node* moved = _gvn.transform(new MinINode(orig_tail, length));\n@@ -8310,85 +8362,0 @@\n-\/\/------------------------------inline_fp_min_max------------------------------\n-bool LibraryCallKit::inline_fp_min_max(vmIntrinsics::ID id) {\n-\/* DISABLED BECAUSE METHOD DATA ISN'T COLLECTED PER CALL-SITE, SEE JDK-8015416.\n-\n-  \/\/ The intrinsic should be used only when the API branches aren't predictable,\n-  \/\/ the last one performing the most important comparison. The following heuristic\n-  \/\/ uses the branch statistics to eventually bail out if necessary.\n-\n-  ciMethodData *md = callee()->method_data();\n-\n-  if ( md != nullptr && md->is_mature() && md->invocation_count() > 0 ) {\n-    ciCallProfile cp = caller()->call_profile_at_bci(bci());\n-\n-    if ( ((double)cp.count()) \/ ((double)md->invocation_count()) < 0.8 ) {\n-      \/\/ Bail out if the call-site didn't contribute enough to the statistics.\n-      return false;\n-    }\n-\n-    uint taken = 0, not_taken = 0;\n-\n-    for (ciProfileData *p = md->first_data(); md->is_valid(p); p = md->next_data(p)) {\n-      if (p->is_BranchData()) {\n-        taken = ((ciBranchData*)p)->taken();\n-        not_taken = ((ciBranchData*)p)->not_taken();\n-      }\n-    }\n-\n-    double balance = (((double)taken) - ((double)not_taken)) \/ ((double)md->invocation_count());\n-    balance = balance < 0 ? -balance : balance;\n-    if ( balance > 0.2 ) {\n-      \/\/ Bail out if the most important branch is predictable enough.\n-      return false;\n-    }\n-  }\n-*\/\n-\n-  Node *a = nullptr;\n-  Node *b = nullptr;\n-  Node *n = nullptr;\n-  switch (id) {\n-  case vmIntrinsics::_maxF:\n-  case vmIntrinsics::_minF:\n-  case vmIntrinsics::_maxF_strict:\n-  case vmIntrinsics::_minF_strict:\n-    assert(callee()->signature()->size() == 2, \"minF\/maxF has 2 parameters of size 1 each.\");\n-    a = argument(0);\n-    b = argument(1);\n-    break;\n-  case vmIntrinsics::_maxD:\n-  case vmIntrinsics::_minD:\n-  case vmIntrinsics::_maxD_strict:\n-  case vmIntrinsics::_minD_strict:\n-    assert(callee()->signature()->size() == 4, \"minD\/maxD has 2 parameters of size 2 each.\");\n-    a = round_double_node(argument(0));\n-    b = round_double_node(argument(2));\n-    break;\n-  default:\n-    fatal_unexpected_iid(id);\n-    break;\n-  }\n-  switch (id) {\n-  case vmIntrinsics::_maxF:\n-  case vmIntrinsics::_maxF_strict:\n-    n = new MaxFNode(a, b);\n-    break;\n-  case vmIntrinsics::_minF:\n-  case vmIntrinsics::_minF_strict:\n-    n = new MinFNode(a, b);\n-    break;\n-  case vmIntrinsics::_maxD:\n-  case vmIntrinsics::_maxD_strict:\n-    n = new MaxDNode(a, b);\n-    break;\n-  case vmIntrinsics::_minD:\n-  case vmIntrinsics::_minD_strict:\n-    n = new MinDNode(a, b);\n-    break;\n-  default:\n-    fatal_unexpected_iid(id);\n-    break;\n-  }\n-  set_result(_gvn.transform(n));\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":80,"deletions":113,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -226,1 +226,0 @@\n-  Node* generate_min_max(vmIntrinsics::ID id, Node* x, Node* y);\n@@ -348,1 +347,0 @@\n-  bool inline_fp_min_max(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2036,0 +2036,1 @@\n+    @IntrinsicCandidate\n@@ -2131,0 +2132,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    \/\/ As Math.min\/max(LL) is not intrinsified, it first needs to be transformed into CMoveL and then MinL\/MaxL before\n+    \/\/ As Math.min\/max(LL) is not intrinsified in the backend, it first needs to be transformed into CMoveL and then MinL\/MaxL before\n@@ -117,1 +117,3 @@\n-    \/\/ As JDK-8307513 adds intrinsics for the methods, the tests will be updated then.\n+    \/\/ JDK-8307513 adds intrinsics for the methods such that MinL\/MaxL replace the ternary operations,\n+    \/\/ and this enables identities to be matched.\n+    \/\/ Note that before JDK-8307513 MinL\/MaxL nodes were already present before macro expansion.\n@@ -126,1 +128,1 @@\n-    @IR(applyIfPlatform = { \"riscv64\", \"false\" }, phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, counts = { IRNode.MIN_L, \"1\" })\n+    @IR(failOn = { IRNode.MIN_L, IRNode.MAX_L })\n@@ -132,1 +134,1 @@\n-    @IR(applyIfPlatform = { \"riscv64\", \"false\" }, phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, counts = { IRNode.MAX_L, \"1\" })\n+    @IR(failOn = { IRNode.MIN_L, IRNode.MAX_L })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestMinMaxIdentities.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8307513\n+ * @summary Test min and max IR inlining decisions\n+ * @library \/test\/lib \/\n+ * @run driver compiler.intrinsics.math.TestMinMaxInlining\n+ *\/\n+\n+package compiler.intrinsics.math;\n+\n+import compiler.lib.ir_framework.Argument;\n+import compiler.lib.ir_framework.Arguments;\n+import compiler.lib.ir_framework.Check;\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+public class TestMinMaxInlining {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(counts = { IRNode.MIN_I, \"1\" })\n+    private static int testIntMin(int a, int b) {\n+        return Math.min(a, b);\n+    }\n+\n+    @Check(test = \"testIntMin\")\n+    public static void checkTestIntMin(int result) {\n+        if (result != -42) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(counts = { IRNode.MAX_I, \"1\" })\n+    private static int testIntMax(int a, int b) {\n+        return Math.max(a, b);\n+    }\n+\n+    @Check(test = \"testIntMax\")\n+    public static void checkTestIntMax(int result) {\n+        if (result != 42) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    \/\/ JDK-8307513 does not change the way MinL\/MaxL nodes intrinsified in backend.\n+    \/\/ So they are still transformed into CmpL + CMoveL nodes after macro expansion.\n+    \/\/ This is the reason for the different before\/after macro expansion assertions below.\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, counts = { IRNode.MIN_L, \"1\" })\n+    @IR(phase = { CompilePhase.AFTER_MACRO_EXPANSION }, counts = { IRNode.MIN_L, \"0\" })\n+    private static long testLongMin(long a, long b) {\n+        return Math.min(a, b);\n+    }\n+\n+    @Check(test = \"testLongMin\")\n+    public static void checkTestLongMin(long result) {\n+        if (result != -42L) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, counts = { IRNode.MAX_L, \"1\" })\n+    @IR(phase = { CompilePhase.AFTER_MACRO_EXPANSION }, counts = { IRNode.MAX_L, \"0\" })\n+    private static long testLongMax(long a, long b) {\n+        return Math.max(a, b);\n+    }\n+\n+    @Check(test = \"testLongMax\")\n+    public static void checkTestLongMax(long result) {\n+        if (result != 42L) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(counts = { IRNode.MIN_F, \"1\" },\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static float testFloatMin(float a, float b) {\n+        return Math.min(a, b);\n+    }\n+\n+    @Check(test = \"testFloatMin\")\n+    public static void checkTestFloatMin(float result) {\n+        if (result != -42f) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(counts = { IRNode.MAX_F, \"1\" },\n+       applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static float testFloatMax(float a, float b) {\n+        return Math.max(a, b);\n+    }\n+\n+    @Check(test = \"testFloatMax\")\n+    public static void checkTestFloatMax(float result) {\n+        if (result != 42f) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(counts = { IRNode.MIN_D, \"1\" },\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static double testDoubleMin(double a, double b) {\n+        return Math.min(a, b);\n+    }\n+\n+    @Check(test = \"testDoubleMin\")\n+    public static void checkTestDoubleMin(double result) {\n+        if (result != -42D) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(counts = { IRNode.MAX_D, \"1\" },\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static double testDoubleMax(double a, double b) {\n+        return Math.max(a, b);\n+    }\n+\n+    @Check(test = \"testDoubleMax\")\n+    public static void checkTestDoubleMax(double result) {\n+        if (result != 42D) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestMinMaxInlining.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8307513\n+ * @summary [SuperWord] MaxReduction and MinReduction should vectorize for long\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.MinMaxRed_Long\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.stream.LongStream;\n+\n+public class MinMaxRed_Long {\n+\n+    private static final Random random = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) throws Exception {\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"maxReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public void runMaxTest() {\n+        runMaxTest(50);\n+        runMaxTest(80);\n+        runMaxTest(100);\n+    }\n+\n+    private static void runMaxTest(int probability) {\n+        long[] longs = reductionInit(probability);\n+        long res = 0;\n+        for (int j = 0; j < 2000; j++) {\n+            res = maxReductionImplement(longs, res);\n+        }\n+        if (res == 11 * Arrays.stream(longs).max().getAsLong()) {\n+            System.out.println(\"Success\");\n+        } else {\n+            throw new AssertionError(\"Failed\");\n+        }\n+    }\n+\n+    @Run(test = {\"minReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public void runMinTest() {\n+        runMinTest(50);\n+        runMinTest(80);\n+        runMinTest(100);\n+    }\n+\n+    private static void runMinTest(int probability) {\n+        long[] longs = reductionInit(probability);\n+        \/\/ Negating the values generated for controlling max branching\n+        \/\/ allows same logic to be used for min tests.\n+        longs = negate(longs);\n+        long res = 0;\n+        for (int j = 0; j < 2000; j++) {\n+            res = minReductionImplement(longs, res);\n+        }\n+        if (res == 11 * Arrays.stream(longs).min().getAsLong()) {\n+            System.out.println(\"Success\");\n+        } else {\n+            throw new AssertionError(\"Failed\");\n+        }\n+    }\n+\n+    static long[] negate(long[] nums) {\n+        return LongStream.of(nums).map(l -> -l).toArray();\n+    }\n+\n+    public static long[] reductionInit(int probability) {\n+        int aboveCount, abovePercent;\n+        long[] longs = new long[1024];\n+\n+        \/\/ Generates an array of numbers such that as the array is iterated\n+        \/\/ there is P probability of finding a new max value,\n+        \/\/ and 100-P probability of not finding a new max value.\n+        \/\/ The algorithm loops around if the distribution does not match the probability,\n+        \/\/ but it approximates the probability as the array sizes increase.\n+        \/\/ The worst case of this algorithm is when the desired array size is 100\n+        \/\/ and the aim is to get 50% of probability, which can only be satisfied\n+        \/\/ with 50 elements being a new max. This situation can take 15 rounds.\n+        \/\/ As sizes increase, say 10'000 elements,\n+        \/\/ the number of elements that have to satisfy 50% increases,\n+        \/\/ so the algorithm will stop as an example when 5027 elements are a new max values.\n+        \/\/ Also, probability values in the edges will achieve their objective quicker,\n+        \/\/ with 0% or 100% probability doing it in a single loop.\n+        \/\/ To support the same algorithm for min calculations,\n+        \/\/ negating the array elements achieves the same objective.\n+        do {\n+            long max = random.nextLong(10);\n+            longs[0] = max;\n+\n+            aboveCount = 0;\n+            for (int i = 1; i < longs.length; i++) {\n+                long value;\n+                if (random.nextLong(101) <= probability) {\n+                    long increment = random.nextLong(10);\n+                    value = max + increment;\n+                    aboveCount++;\n+                } else {\n+                    \/\/ Decrement by at least 1\n+                    long diffToMax = random.nextLong(10) + 1;\n+                    value = max - diffToMax;\n+                }\n+                longs[i] = value;\n+                max = Math.max(max, value);\n+            }\n+\n+            abovePercent = ((aboveCount + 1) * 100) \/ longs.length;\n+        } while (abovePercent != probability);\n+\n+        return longs;\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"SuperWordReductions\", \"true\", \"MaxVectorSize\", \">=32\"},\n+        applyIfCPUFeatureOr = {\"avx512\", \"true\", \"asimd\" , \"true\"},\n+        counts = {IRNode.MIN_REDUCTION_V, \" > 0\"})\n+    public static long minReductionImplement(long[] a, long res) {\n+        for (int i = 0; i < a.length; i++) {\n+            final long v = 11 * a[i];\n+            res = Math.min(res, v);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIfAnd = {\"SuperWordReductions\", \"true\", \"MaxVectorSize\", \">=32\"},\n+        applyIfCPUFeatureOr = {\"avx512\", \"true\", \"asimd\" , \"true\"},\n+        counts = {IRNode.MAX_REDUCTION_V, \" > 0\"})\n+    public static long maxReductionImplement(long[] a, long res) {\n+        for (int i = 0; i < a.length; i++) {\n+            final long v = 11 * a[i];\n+            res = Math.max(res, v);\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/MinMaxRed_Long.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,260 @@\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Arrays;\n+import java.util.IntSummaryStatistics;\n+import java.util.LongSummaryStatistics;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.LongStream;\n+\n+@Warmup(iterations = 3, time = 5)\n+@Measurement(iterations = 4, time = 5)\n+@Fork(2)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+public class MinMaxVector\n+{\n+    @State(Scope.Thread)\n+    public static class LoopState {\n+        @Param({\"2048\"})\n+        int size;\n+\n+        \/**\n+         * Probability of one of the min\/max branches being taken.\n+         * For max, this value represents the percentage of branches in which\n+         * the value will be bigger or equal than the current max.\n+         * For min, this value represents the percentage of branches in which\n+         * the value will be smaller or equal than the current min.\n+         *\/\n+        @Param({\"50\", \"80\", \"100\"})\n+        int probability;\n+\n+        int[] minIntA;\n+        int[] minIntB;\n+        long[] minLongA;\n+        long[] minLongB;\n+        int[] maxIntA;\n+        int[] maxIntB;\n+        long[] maxLongA;\n+        long[] maxLongB;\n+        int[] resultIntArray;\n+        long[] resultLongArray;\n+\n+        @Setup\n+        public void setup() {\n+            final long[][] longs = distributeLongRandomIncrement(size, probability);\n+            maxLongA = longs[0];\n+            maxLongB = longs[1];\n+            maxIntA = toInts(maxLongA);\n+            maxIntB = toInts(maxLongB);\n+            minLongA = negate(maxLongA);\n+            minLongB = negate(maxLongB);\n+            minIntA = toInts(minLongA);\n+            minIntB = toInts(minLongB);\n+            resultIntArray = new int[size];\n+            resultLongArray = new long[size];\n+        }\n+\n+        static long[] negate(long[] nums) {\n+            return LongStream.of(nums).map(l -> -l).toArray();\n+        }\n+\n+        static int[] toInts(long[] nums) {\n+            return Arrays.stream(nums).mapToInt(i -> (int) i).toArray();\n+        }\n+\n+        static long[][] distributeLongRandomIncrement(int size, int probability) {\n+            long[][] result;\n+            int aboveCount, abovePercent;\n+\n+            \/\/ This algorithm generates 2 arrays of numbers.\n+            \/\/ The first array is created such that as the array is iterated,\n+            \/\/ there is P probability of finding a new min\/max value,\n+            \/\/ and 100-P probability of not finding a new min\/max value.\n+            \/\/ This first array is used on its own for tests that iterate an array to reduce it to a single value,\n+            \/\/ e.g. the min or max value in the array.\n+            \/\/ The second array is loaded with values relative to the first array,\n+            \/\/ such that when the values in the same index are compared for min\/max,\n+            \/\/ the probability that a new min\/max value is found has the probability P.\n+            do {\n+                long max = ThreadLocalRandom.current().nextLong(10);\n+                result = new long[2][size];\n+                result[0][0] = max;\n+                result[1][0] = max - 1;\n+\n+                aboveCount = 0;\n+                for (int i = 1; i < result[0].length; i++) {\n+                    long value;\n+                    if (ThreadLocalRandom.current().nextLong(101) <= probability) {\n+                        long increment = ThreadLocalRandom.current().nextLong(10);\n+                        value = max + increment;\n+                        aboveCount++;\n+                    } else {\n+                        \/\/ Decrement by at least 1\n+                        long diffToMax = ThreadLocalRandom.current().nextLong(10) + 1;\n+                        value = max - diffToMax;\n+                    }\n+                    result[0][i] = value;\n+                    result[1][i] = max;\n+                    max = Math.max(max, value);\n+                }\n+\n+                abovePercent = ((aboveCount + 1) * 100) \/ size;\n+            } while (abovePercent != probability);\n+\n+            return result;\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class RangeState\n+    {\n+        @Param({\"1000\"})\n+        int size;\n+\n+        \/**\n+         * Define range of values to clip as a percentage.\n+         * For example, if value is 100, then all values are considered in the range,\n+         * and so the highest value would be the max value and the lowest value the min value in the array.\n+         * If the value is 90, then highest would be 10% lower than the max value,\n+         * and the min value would be 10% higher than the min value.\n+         *\/\n+        @Param({\"90\", \"100\"})\n+        int range;\n+\n+        @Param(\"0\")\n+        int seed;\n+\n+        int[] ints;\n+        int[] resultInts;\n+        long[] longs;\n+        long[] resultLongs;\n+        int highestInt;\n+        int lowestInt;\n+        long highestLong;\n+        long lowestLong;\n+        Random r = new Random(seed);\n+\n+        @Setup\n+        public void setup() {\n+            ints = new int[size];\n+            resultInts = new int[size];\n+            longs = new long[size];\n+            resultLongs = new long[size];\n+\n+            for (int i = 0; i < size; i++) {\n+                ints[i] = r.nextInt();\n+                longs[i] = r.nextLong();\n+            }\n+\n+            final IntSummaryStatistics intStats = Arrays.stream(ints).summaryStatistics();\n+            highestInt = (intStats.getMax() * range) \/ 100;\n+            lowestInt = intStats.getMin() + (intStats.getMax() - highestInt);\n+\n+            final LongSummaryStatistics longStats = Arrays.stream(longs).summaryStatistics();\n+            highestLong = (longStats.getMax() * range) \/ 100;\n+            lowestLong = longStats.getMin() + (longStats.getMax() - highestLong);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int[] intClippingRange(RangeState state) {\n+        for (int i = 0; i < state.size; i++) {\n+            state.resultInts[i] = Math.min(Math.max(state.ints[i], state.lowestInt), state.highestInt);\n+        }\n+        return state.resultInts;\n+    }\n+\n+    @Benchmark\n+    public int[] intLoopMin(LoopState state) {\n+        for (int i = 0; i < state.size; i++) {\n+            state.resultIntArray[i] = Math.min(state.minIntA[i], state.minIntB[i]);\n+        }\n+        return state.resultIntArray;\n+    }\n+\n+    @Benchmark\n+    public int[] intLoopMax(LoopState state) {\n+        for (int i = 0; i < state.size; i++) {\n+            state.resultIntArray[i] = Math.max(state.maxIntA[i], state.maxIntB[i]);\n+        }\n+        return state.resultIntArray;\n+    }\n+\n+    @Benchmark\n+    public int intReductionMin(LoopState state) {\n+        int result = 0;\n+        for (int i = 0; i < state.size; i++) {\n+            final int v = 11 * state.minIntA[i];\n+            result = Math.min(result, v);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public int intReductionMax(LoopState state) {\n+        int result = 0;\n+        for (int i = 0; i < state.size; i++) {\n+            final int v = 11 * state.maxIntA[i];\n+            result = Math.max(result, v);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public long[] longClippingRange(RangeState state) {\n+        for (int i = 0; i < state.size; i++) {\n+            state.resultLongs[i] = Math.min(Math.max(state.longs[i], state.lowestLong), state.highestLong);\n+        }\n+        return state.resultLongs;\n+    }\n+\n+    @Benchmark\n+    public long[] longLoopMin(LoopState state) {\n+        for (int i = 0; i < state.size; i++) {\n+            state.resultLongArray[i] = Math.min(state.minLongA[i], state.minLongB[i]);\n+        }\n+        return state.resultLongArray;\n+    }\n+\n+    @Benchmark\n+    public long[] longLoopMax(LoopState state) {\n+        for (int i = 0; i < state.size; i++) {\n+            state.resultLongArray[i] = Math.max(state.maxLongA[i], state.maxLongB[i]);\n+        }\n+        return state.resultLongArray;\n+    }\n+\n+    @Benchmark\n+    public long longReductionMin(LoopState state) {\n+        long result = 0;\n+        for (int i = 0; i < state.size; i++) {\n+            final long v = 11 * state.minLongA[i];\n+            result = Math.min(result, v);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public long longReductionMax(LoopState state) {\n+        long result = 0;\n+        for (int i = 0; i < state.size; i++) {\n+            final long v = 11 * state.maxLongA[i];\n+            result = Math.max(result, v);\n+        }\n+        return result;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/MinMaxVector.java","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"}]}