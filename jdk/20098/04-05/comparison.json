{"files":[{"patch":"@@ -1946,3 +1946,3 @@\n-  Node *a = nullptr;\n-  Node *b = nullptr;\n-  Node *n = nullptr;\n+  Node* a = nullptr;\n+  Node* b = nullptr;\n+  Node* n = nullptr;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    \/\/ As Math.min\/max(LL) is not intrinsified, it first needs to be transformed into CMoveL and then MinL\/MaxL before\n+    \/\/ As Math.min\/max(LL) is not intrinsified in the backend, it first needs to be transformed into CMoveL and then MinL\/MaxL before\n@@ -117,1 +117,3 @@\n-    \/\/ As JDK-8307513 adds intrinsics for the methods, the tests will be updated then.\n+    \/\/ JDK-8307513 adds intrinsics for the methods such that MinL\/MaxL replace the ternary operations,\n+    \/\/ and this enables identities to be matched.\n+    \/\/ Note that before JDK-8307513 MinL\/MaxL nodes were already present before macro expansion.\n@@ -126,1 +128,1 @@\n-    @IR(applyIfPlatform = { \"riscv64\", \"false\" }, phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, counts = { IRNode.MIN_L, \"1\" })\n+    @IR(failOn = { IRNode.MIN_L, IRNode.MAX_L })\n@@ -132,1 +134,1 @@\n-    @IR(applyIfPlatform = { \"riscv64\", \"false\" }, phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, counts = { IRNode.MAX_L, \"1\" })\n+    @IR(failOn = { IRNode.MIN_L, IRNode.MAX_L })\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestMinMaxIdentities.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -76,0 +76,4 @@\n+    \/\/ JDK-8307513 does not changes the way MinL\/MaxL nodes intrinsified in backend.\n+    \/\/ So they are still transformed into CmpL + CMoveL nodes after macro expansion.\n+    \/\/ This is the reason for the different before\/after macro expansion assertions below.\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestMinMaxInlining.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8307513\n+ * @summary [SuperWord] MaxReduction and MinReduction should vectorize for long\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.MinMaxRed_Long\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.stream.LongStream;\n+\n+public class MinMaxRed_Long {\n+\n+    private static final Random random = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) throws Exception {\n+        TestFramework framework = new TestFramework();\n+        framework.addFlags(\"-XX:+IgnoreUnrecognizedVMOptions\",\n+                           \"-XX:LoopUnrollLimit=250\",\n+                           \"-XX:CompileThresholdScaling=0.1\");\n+        framework.start();\n+    }\n+\n+    @Run(test = {\"maxReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public void runMaxTest() {\n+        runMaxTest(50);\n+        runMaxTest(80);\n+        runMaxTest(100);\n+    }\n+\n+    private static void runMaxTest(int probability) {\n+        long[] longs = new long[1024];\n+        ReductionInit(longs, probability);\n+        long res = 0;\n+        for (int j = 0; j < 2000; j++) {\n+            res = maxReductionImplement(longs, res);\n+        }\n+        if (res == 11 * Arrays.stream(longs).max().getAsLong()) {\n+            System.out.println(\"Success\");\n+        } else {\n+            throw new AssertionError(\"Failed\");\n+        }\n+    }\n+\n+    @Run(test = {\"minReductionImplement\"},\n+         mode = RunMode.STANDALONE)\n+    public void runMinTest() {\n+        runMinTest(50);\n+        runMinTest(80);\n+        runMinTest(100);\n+    }\n+\n+    private static void runMinTest(int probability) {\n+        long[] longs = new long[1024];\n+        ReductionInit(longs, probability);\n+        \/\/ Negating the values generated for controlling max branching\n+        \/\/ allows same logic to be used for min tests.\n+        longs = negate(longs);\n+        long res = 0;\n+        for (int j = 0; j < 2000; j++) {\n+            res = minReductionImplement(longs, res);\n+        }\n+        if (res == 11 * Arrays.stream(longs).min().getAsLong()) {\n+            System.out.println(\"Success\");\n+        } else {\n+            throw new AssertionError(\"Failed\");\n+        }\n+    }\n+\n+    static long[] negate(long[] nums) {\n+        return LongStream.of(nums).map(l -> -l).toArray();\n+    }\n+\n+    public static void ReductionInit(long[] longs, int probability) {\n+        int aboveCount, abovePercent;\n+\n+        \/\/ Iterate until you find a set that matches the requirement probability\n+        do {\n+            long max = random.nextLong(10);\n+            longs[0] = max;\n+\n+            aboveCount = 0;\n+            for (int i = 1; i < longs.length; i++) {\n+                long value;\n+                if (random.nextLong(101) <= probability) {\n+                    long increment = random.nextLong(10);\n+                    value = max + increment;\n+                    aboveCount++;\n+                } else {\n+                    \/\/ Decrement by at least 1\n+                    long decrement = random.nextLong(10) + 1;\n+                    value = max - decrement;\n+                }\n+                longs[i] = value;\n+                max = Math.max(max, value);\n+            }\n+\n+            abovePercent = ((aboveCount + 1) * 100) \/ longs.length;\n+        } while (abovePercent != probability);\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"true\"},\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\" },\n+        counts = {IRNode.MIN_REDUCTION_V, \" > 0\"})\n+    public static long minReductionImplement(long[] a, long res) {\n+        for (int i = 0; i < a.length; i++) {\n+            final long v = 11 * a[i];\n+            res = Math.min(res, v);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIf = {\"SuperWordReductions\", \"true\"},\n+        applyIfCPUFeatureOr = { \"avx512\", \"true\" },\n+        counts = {IRNode.MAX_REDUCTION_V, \" > 0\"})\n+    public static long maxReductionImplement(long[] a, long res) {\n+        for (int i = 0; i < a.length; i++) {\n+            final long v = 11 * a[i];\n+            res = Math.max(res, v);\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/MinMaxRed_Long.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -70,0 +70,1 @@\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/MinMaxVector.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}