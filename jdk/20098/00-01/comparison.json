{"files":[{"patch":"@@ -6410,1 +6410,3 @@\n-  format %{ \"cmovq$cop $dst, $src\\t# signed, long\" %}\n+  format %{ \"jn$cop     skip\\t# signed cmove long\\n\\t\"\n+            \"movq       $dst, $src\\n\"\n+    \"skip:\" %}\n@@ -6412,1 +6414,5 @@\n-    __ cmovq((Assembler::Condition)($cop$$cmpcode), $dst$$Register, $src$$Register);\n+    Label Lskip;\n+    \/\/ Invert sense of branch from sense of CMOV\n+    __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);\n+    __ movq($dst$$Register, $src$$Register);\n+    __ bind(Lskip);\n@@ -6414,1 +6420,1 @@\n-  ins_pipe(pipe_cmov_reg);  \/\/ XXX\n+  ins_pipe(pipe_slow);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -690,3 +690,2 @@\n-    return inline_min_max(intrinsic_id());\n-\n-  case vmIntrinsics::_maxF:\n+  case vmIntrinsics::_minL:\n+  case vmIntrinsics::_maxL:\n@@ -694,1 +693,1 @@\n-  case vmIntrinsics::_maxD:\n+  case vmIntrinsics::_maxF:\n@@ -696,1 +695,1 @@\n-  case vmIntrinsics::_maxF_strict:\n+  case vmIntrinsics::_maxD:\n@@ -698,1 +697,1 @@\n-  case vmIntrinsics::_maxD_strict:\n+  case vmIntrinsics::_maxF_strict:\n@@ -700,5 +699,2 @@\n-      return inline_fp_min_max(intrinsic_id());\n-\n-  case vmIntrinsicID::_maxL:\n-  case vmIntrinsicID::_minL:\n-    return inline_long_min_max(intrinsic_id());\n+  case vmIntrinsics::_maxD_strict:\n+    return inline_min_max(intrinsic_id());\n@@ -1943,1 +1939,72 @@\n-  set_result(generate_min_max(id, argument(0), argument(1)));\n+  Node *a = nullptr;\n+  Node *b = nullptr;\n+  Node *n = nullptr;\n+  switch (id) {\n+    case vmIntrinsics::_min:\n+    case vmIntrinsics::_max:\n+    case vmIntrinsics::_minF:\n+    case vmIntrinsics::_maxF:\n+    case vmIntrinsics::_minF_strict:\n+    case vmIntrinsics::_maxF_strict:\n+    case vmIntrinsics::_min_strict:\n+    case vmIntrinsics::_max_strict:\n+      assert(callee()->signature()->size() == 2, \"minF\/maxF has 2 parameters of size 1 each.\");\n+      a = argument(0);\n+      b = argument(1);\n+      break;\n+    case vmIntrinsics::_minD:\n+    case vmIntrinsics::_maxD:\n+    case vmIntrinsics::_minD_strict:\n+    case vmIntrinsics::_maxD_strict:\n+      assert(callee()->signature()->size() == 4, \"minD\/maxD has 2 parameters of size 2 each.\");\n+      a = round_double_node(argument(0));\n+      b = round_double_node(argument(2));\n+      break;\n+    case vmIntrinsics::_minL:\n+    case vmIntrinsics::_maxL:\n+      assert(callee()->signature()->size() == 4, \"minL\/maxL has 2 parameters of size 2 each.\");\n+      a = argument(0);\n+      b = argument(2);\n+      break;\n+    default:\n+      fatal_unexpected_iid(id);\n+      break;\n+  }\n+\n+  switch (id) {\n+    case vmIntrinsics::_min:\n+    case vmIntrinsics::_min_strict:\n+      n = new MinINode(a, b);\n+      break;\n+    case vmIntrinsics::_max:\n+    case vmIntrinsics::_max_strict:\n+      n = new MaxINode(a, b);\n+      break;\n+    case vmIntrinsics::_minF:\n+    case vmIntrinsics::_minF_strict:\n+      n = new MinFNode(a, b);\n+      break;\n+    case vmIntrinsics::_maxF:\n+    case vmIntrinsics::_maxF_strict:\n+      n = new MaxFNode(a, b);\n+      break;\n+    case vmIntrinsics::_minD:\n+    case vmIntrinsics::_minD_strict:\n+      n = new MinDNode(a, b);\n+      break;\n+    case vmIntrinsics::_maxD:\n+    case vmIntrinsics::_maxD_strict:\n+      n = new MaxDNode(a, b);\n+      break;\n+    case vmIntrinsics::_minL:\n+      n = new MinLNode(_gvn.C, a, b);\n+      break;\n+    case vmIntrinsics::_maxL:\n+      n = new MaxLNode(_gvn.C, a, b);\n+      break;\n+    default:\n+      fatal_unexpected_iid(id);\n+      break;\n+  }\n+\n+  set_result(_gvn.transform(n));\n@@ -2022,19 +2089,0 @@\n-Node*\n-LibraryCallKit::generate_min_max(vmIntrinsics::ID id, Node* x0, Node* y0) {\n-  Node* result_val = nullptr;\n-  switch (id) {\n-  case vmIntrinsics::_min:\n-  case vmIntrinsics::_min_strict:\n-    result_val = _gvn.transform(new MinINode(x0, y0));\n-    break;\n-  case vmIntrinsics::_max:\n-  case vmIntrinsics::_max_strict:\n-    result_val = _gvn.transform(new MaxINode(x0, y0));\n-    break;\n-  default:\n-    fatal_unexpected_iid(id);\n-    break;\n-  }\n-  return result_val;\n-}\n-\n@@ -4384,1 +4432,1 @@\n-      Node* moved = generate_min_max(vmIntrinsics::_min, orig_tail, length);\n+      Node* moved = _gvn.transform(new MinINode(orig_tail, length));\n@@ -8156,106 +8204,0 @@\n-\/\/------------------------------inline_fp_min_max------------------------------\n-bool LibraryCallKit::inline_fp_min_max(vmIntrinsics::ID id) {\n-\/* DISABLED BECAUSE METHOD DATA ISN'T COLLECTED PER CALL-SITE, SEE JDK-8015416.\n-\n-  \/\/ The intrinsic should be used only when the API branches aren't predictable,\n-  \/\/ the last one performing the most important comparison. The following heuristic\n-  \/\/ uses the branch statistics to eventually bail out if necessary.\n-\n-  ciMethodData *md = callee()->method_data();\n-\n-  if ( md != nullptr && md->is_mature() && md->invocation_count() > 0 ) {\n-    ciCallProfile cp = caller()->call_profile_at_bci(bci());\n-\n-    if ( ((double)cp.count()) \/ ((double)md->invocation_count()) < 0.8 ) {\n-      \/\/ Bail out if the call-site didn't contribute enough to the statistics.\n-      return false;\n-    }\n-\n-    uint taken = 0, not_taken = 0;\n-\n-    for (ciProfileData *p = md->first_data(); md->is_valid(p); p = md->next_data(p)) {\n-      if (p->is_BranchData()) {\n-        taken = ((ciBranchData*)p)->taken();\n-        not_taken = ((ciBranchData*)p)->not_taken();\n-      }\n-    }\n-\n-    double balance = (((double)taken) - ((double)not_taken)) \/ ((double)md->invocation_count());\n-    balance = balance < 0 ? -balance : balance;\n-    if ( balance > 0.2 ) {\n-      \/\/ Bail out if the most important branch is predictable enough.\n-      return false;\n-    }\n-  }\n-*\/\n-\n-  Node *a = nullptr;\n-  Node *b = nullptr;\n-  Node *n = nullptr;\n-  switch (id) {\n-  case vmIntrinsics::_maxF:\n-  case vmIntrinsics::_minF:\n-  case vmIntrinsics::_maxF_strict:\n-  case vmIntrinsics::_minF_strict:\n-    assert(callee()->signature()->size() == 2, \"minF\/maxF has 2 parameters of size 1 each.\");\n-    a = argument(0);\n-    b = argument(1);\n-    break;\n-  case vmIntrinsics::_maxD:\n-  case vmIntrinsics::_minD:\n-  case vmIntrinsics::_maxD_strict:\n-  case vmIntrinsics::_minD_strict:\n-    assert(callee()->signature()->size() == 4, \"minD\/maxD has 2 parameters of size 2 each.\");\n-    a = round_double_node(argument(0));\n-    b = round_double_node(argument(2));\n-    break;\n-  default:\n-    fatal_unexpected_iid(id);\n-    break;\n-  }\n-  switch (id) {\n-  case vmIntrinsics::_maxF:\n-  case vmIntrinsics::_maxF_strict:\n-    n = new MaxFNode(a, b);\n-    break;\n-  case vmIntrinsics::_minF:\n-  case vmIntrinsics::_minF_strict:\n-    n = new MinFNode(a, b);\n-    break;\n-  case vmIntrinsics::_maxD:\n-  case vmIntrinsics::_maxD_strict:\n-    n = new MaxDNode(a, b);\n-    break;\n-  case vmIntrinsics::_minD:\n-  case vmIntrinsics::_minD_strict:\n-    n = new MinDNode(a, b);\n-    break;\n-  default:\n-    fatal_unexpected_iid(id);\n-    break;\n-  }\n-  set_result(_gvn.transform(n));\n-  return true;\n-}\n-\n-\/\/------------------------------inline_long_min_max------------------------------\n-bool LibraryCallKit::inline_long_min_max(vmIntrinsics::ID id) {\n-  assert(callee()->signature()->size() == 4, \"minL\/maxL has 2 parameters of size 2 each.\");\n-  Node *a = argument(0);\n-  Node *b = argument(2);\n-  Node *n = nullptr;\n-  switch (id) {\n-    case vmIntrinsics::_minL:\n-      n = new MinLNode(_gvn.C, a, b);\n-      break;\n-    case vmIntrinsics::_maxL:\n-      n = new MaxLNode(_gvn.C, a, b);\n-      break;\n-    default:\n-      fatal_unexpected_iid(id);\n-      break;\n-  }\n-  set_result(_gvn.transform(n));\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":80,"deletions":138,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -220,1 +220,0 @@\n-  Node* generate_min_max(vmIntrinsics::ID id, Node* x, Node* y);\n@@ -340,2 +339,0 @@\n-  bool inline_fp_min_max(vmIntrinsics::ID id);\n-  bool inline_long_min_max(vmIntrinsics::ID id);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8307513\n+ * @summary Test min and max IR inlining decisions\n+ * @library \/test\/lib \/\n+ * @run driver compiler.intrinsics.math.TestMinMaxInlining\n+ *\/\n+\n+package compiler.intrinsics.math;\n+\n+import compiler.lib.ir_framework.Argument;\n+import compiler.lib.ir_framework.Arguments;\n+import compiler.lib.ir_framework.Check;\n+import compiler.lib.ir_framework.CompilePhase;\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.Test;\n+import compiler.lib.ir_framework.TestFramework;\n+\n+public class TestMinMaxInlining {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(counts = { IRNode.MIN_I, \"1\" })\n+    private static int testIntMin(int a, int b) {\n+        return Math.min(a, b);\n+    }\n+\n+    @Check(test = \"testIntMin\")\n+    public static void checkTestIntMin(int result) {\n+        if (result != -42) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(counts = { IRNode.MAX_I, \"1\" })\n+    private static int testIntMax(int a, int b) {\n+        return Math.max(a, b);\n+    }\n+\n+    @Check(test = \"testIntMax\")\n+    public static void checkTestIntMax(int result) {\n+        if (result != 42) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, counts = { IRNode.MIN_L, \"1\" })\n+    @IR(phase = { CompilePhase.AFTER_MACRO_EXPANSION }, counts = { IRNode.MIN_L, \"0\" })\n+    private static long testLongMin(long a, long b) {\n+        return Math.min(a, b);\n+    }\n+\n+    @Check(test = \"testLongMin\")\n+    public static void checkTestLongMin(long result) {\n+        if (result != -42L) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(phase = { CompilePhase.BEFORE_MACRO_EXPANSION }, counts = { IRNode.MAX_L, \"1\" })\n+    @IR(phase = { CompilePhase.AFTER_MACRO_EXPANSION }, counts = { IRNode.MAX_L, \"0\" })\n+    private static long testLongMax(long a, long b) {\n+        return Math.max(a, b);\n+    }\n+\n+    @Check(test = \"testLongMax\")\n+    public static void checkTestLongMax(long result) {\n+        if (result != 42L) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(counts = { IRNode.MIN_F, \"1\" })\n+    private static float testFloatMin(float a, float b) {\n+        return Math.min(a, b);\n+    }\n+\n+    @Check(test = \"testFloatMin\")\n+    public static void checkTestFloatMin(float result) {\n+        if (result != -42f) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(counts = { IRNode.MAX_F, \"1\" })\n+    private static float testFloatMax(float a, float b) {\n+        return Math.max(a, b);\n+    }\n+\n+    @Check(test = \"testFloatMax\")\n+    public static void checkTestFloatMax(float result) {\n+        if (result != 42f) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(counts = { IRNode.MIN_D, \"1\" })\n+    private static double testDoubleMin(double a, double b) {\n+        return Math.min(a, b);\n+    }\n+\n+    @Check(test = \"testDoubleMin\")\n+    public static void checkTestDoubleMin(double result) {\n+        if (result != -42D) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments(values = { Argument.NUMBER_MINUS_42, Argument.NUMBER_42 })\n+    @IR(counts = { IRNode.MAX_D, \"1\" })\n+    private static double testDoubleMax(double a, double b) {\n+        return Math.max(a, b);\n+    }\n+\n+    @Check(test = \"testDoubleMax\")\n+    public static void checkTestDoubleMax(double result) {\n+        if (result != 42D) {\n+            throw new RuntimeException(\"Incorrect result: \" + result);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestMinMaxInlining.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.LongStream;\n+\n+@Warmup(iterations = 3, time = 5)\n+@Measurement(iterations = 4, time = 5)\n+@Fork(2)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Thread)\n+public class MinMaxLoopBench\n+{\n+    @Param({\"100\", \"1000\", \"10000\"})\n+    int size;\n+\n+    \/**\n+     * Probability of one of the min\/max branches being taken.\n+     * For max, this value represents the percentage of branches in which\n+     * the value will be bigger or equal than the current max.\n+     * For min, this value represents the percentage of branches in which\n+     * the value will be smaller or equal than the current min.\n+     *\/\n+    @Param({\"50\", \"80\", \"100\"})\n+    int probability;\n+\n+    int[] minIntA;\n+    int[] minIntB;\n+    long[] minLongA;\n+    long[] minLongB;\n+    int[] maxIntA;\n+    int[] maxIntB;\n+    long[] maxLongA;\n+    long[] maxLongB;\n+\n+    @Setup\n+    public void setup() {\n+        final long[][] longs = distributeLongRandomIncrement(size, probability);\n+        maxLongA = longs[0];\n+        maxLongB = longs[1];\n+        maxIntA = toInts(maxLongA);\n+        maxIntB = toInts(maxLongB);\n+        minLongA = negate(maxLongA);\n+        minLongB = negate(maxLongB);\n+        minIntA = toInts(minLongA);\n+        minIntB = toInts(minLongB);\n+    }\n+\n+    static long[] negate(long[] nums) {\n+        return LongStream.of(nums).map(l -> -l).toArray();\n+    }\n+\n+    static int[] toInts(long[] nums) {\n+        return Arrays.stream(nums).mapToInt(i -> (int) i).toArray();\n+    }\n+\n+    static long[][] distributeLongRandomIncrement(int size, int probability) {\n+        long[][] result;\n+        int aboveCount, abovePercent;\n+\n+        \/\/ Iterate until you find a set that matches the requirement probability\n+        do {\n+            long max = ThreadLocalRandom.current().nextLong(10);\n+            result = new long[2][size];\n+            result[0][0] = max;\n+            result[1][0] = max - 1;\n+\n+            aboveCount = 0;\n+            for (int i = 1; i < result[0].length; i++) {\n+                long value;\n+                if (ThreadLocalRandom.current().nextLong(101) <= probability) {\n+                    long increment = ThreadLocalRandom.current().nextLong(10);\n+                    value = max + increment;\n+                    aboveCount++;\n+                } else {\n+                    \/\/ Decrement by at least 1\n+                    long decrement = ThreadLocalRandom.current().nextLong(10) + 1;\n+                    value = max - decrement;\n+                }\n+                result[0][i] = value;\n+                result[1][i] = max;\n+                max = Math.max(max, value);\n+            }\n+\n+            abovePercent = ((aboveCount + 1) * 100) \/ size;\n+        } while (abovePercent != probability);\n+\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public int[] intLoopMin() {\n+        final int[] result = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            result[i] = Math.min(minIntA[i], minIntB[i]);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public int[] intLoopMax() {\n+        final int[] result = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            result[i] = Math.max(maxIntA[i], maxIntB[i]);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public int intReductionMin() {\n+        int result = 0;\n+        for (int i = 0; i < size; i++) {\n+            final int v = 11 * minIntA[i];\n+            result = Math.min(result, v);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public int intReductionMax() {\n+        int result = 0;\n+        for (int i = 0; i < size; i++) {\n+            final int v = 11 * maxIntA[i];\n+            result = Math.max(result, v);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public long[] longLoopMin() {\n+        final long[] result = new long[size];\n+        for (int i = 0; i < size; i++) {\n+            result[i] = Math.min(minLongA[i], minLongB[i]);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public long[] longLoopMax() {\n+        final long[] result = new long[size];\n+        for (int i = 0; i < size; i++) {\n+            result[i] = Math.max(maxLongA[i], maxLongB[i]);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public long longReductionMin() {\n+        long result = 0;\n+        for (int i = 0; i < size; i++) {\n+            final long v = 11 * minLongA[i];\n+            result = Math.min(result, v);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public long longReductionMax() {\n+        long result = 0;\n+        for (int i = 0; i < size; i++) {\n+            final long v = 11 * maxLongA[i];\n+            result = Math.max(result, v);\n+        }\n+        return result;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/MinMaxLoopBench.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"}]}