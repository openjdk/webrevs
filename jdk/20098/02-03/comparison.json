{"files":[{"patch":"@@ -108,1 +108,1 @@\n-    @IR(counts = { IRNode.MIN_F, \"1\" })\n+    @IR(counts = { IRNode.MIN_F, \"1\" }, applyIfCPUFeatureOr = {\"avx\", \"true\"})\n@@ -122,1 +122,1 @@\n-    @IR(counts = { IRNode.MAX_F, \"1\" })\n+    @IR(counts = { IRNode.MAX_F, \"1\" }, applyIfCPUFeatureOr = {\"avx\", \"true\"})\n@@ -136,1 +136,1 @@\n-    @IR(counts = { IRNode.MIN_D, \"1\" })\n+    @IR(counts = { IRNode.MIN_D, \"1\" }, applyIfCPUFeatureOr = {\"avx\", \"true\"})\n@@ -150,1 +150,1 @@\n-    @IR(counts = { IRNode.MAX_D, \"1\" })\n+    @IR(counts = { IRNode.MAX_D, \"1\" }, applyIfCPUFeatureOr = {\"avx\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestMinMaxInlining.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,180 +0,0 @@\n-package org.openjdk.bench.java.lang;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.util.Arrays;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.LongStream;\n-\n-@Warmup(iterations = 3, time = 5)\n-@Measurement(iterations = 4, time = 5)\n-@Fork(2)\n-@OutputTimeUnit(TimeUnit.MILLISECONDS)\n-@BenchmarkMode(Mode.Throughput)\n-@State(Scope.Thread)\n-public class MinMaxLoopBench\n-{\n-    @Param({\"100\", \"1000\", \"10000\"})\n-    int size;\n-\n-    \/**\n-     * Probability of one of the min\/max branches being taken.\n-     * For max, this value represents the percentage of branches in which\n-     * the value will be bigger or equal than the current max.\n-     * For min, this value represents the percentage of branches in which\n-     * the value will be smaller or equal than the current min.\n-     *\/\n-    @Param({\"50\", \"80\", \"100\"})\n-    int probability;\n-\n-    int[] minIntA;\n-    int[] minIntB;\n-    long[] minLongA;\n-    long[] minLongB;\n-    int[] maxIntA;\n-    int[] maxIntB;\n-    long[] maxLongA;\n-    long[] maxLongB;\n-\n-    @Setup\n-    public void setup() {\n-        final long[][] longs = distributeLongRandomIncrement(size, probability);\n-        maxLongA = longs[0];\n-        maxLongB = longs[1];\n-        maxIntA = toInts(maxLongA);\n-        maxIntB = toInts(maxLongB);\n-        minLongA = negate(maxLongA);\n-        minLongB = negate(maxLongB);\n-        minIntA = toInts(minLongA);\n-        minIntB = toInts(minLongB);\n-    }\n-\n-    static long[] negate(long[] nums) {\n-        return LongStream.of(nums).map(l -> -l).toArray();\n-    }\n-\n-    static int[] toInts(long[] nums) {\n-        return Arrays.stream(nums).mapToInt(i -> (int) i).toArray();\n-    }\n-\n-    static long[][] distributeLongRandomIncrement(int size, int probability) {\n-        long[][] result;\n-        int aboveCount, abovePercent;\n-\n-        \/\/ Iterate until you find a set that matches the requirement probability\n-        do {\n-            long max = ThreadLocalRandom.current().nextLong(10);\n-            result = new long[2][size];\n-            result[0][0] = max;\n-            result[1][0] = max - 1;\n-\n-            aboveCount = 0;\n-            for (int i = 1; i < result[0].length; i++) {\n-                long value;\n-                if (ThreadLocalRandom.current().nextLong(101) <= probability) {\n-                    long increment = ThreadLocalRandom.current().nextLong(10);\n-                    value = max + increment;\n-                    aboveCount++;\n-                } else {\n-                    \/\/ Decrement by at least 1\n-                    long decrement = ThreadLocalRandom.current().nextLong(10) + 1;\n-                    value = max - decrement;\n-                }\n-                result[0][i] = value;\n-                result[1][i] = max;\n-                max = Math.max(max, value);\n-            }\n-\n-            abovePercent = ((aboveCount + 1) * 100) \/ size;\n-        } while (abovePercent != probability);\n-\n-        return result;\n-    }\n-\n-    @Benchmark\n-    public int[] intLoopMin() {\n-        final int[] result = new int[size];\n-        for (int i = 0; i < size; i++) {\n-            result[i] = Math.min(minIntA[i], minIntB[i]);\n-        }\n-        return result;\n-    }\n-\n-    @Benchmark\n-    public int[] intLoopMax() {\n-        final int[] result = new int[size];\n-        for (int i = 0; i < size; i++) {\n-            result[i] = Math.max(maxIntA[i], maxIntB[i]);\n-        }\n-        return result;\n-    }\n-\n-    @Benchmark\n-    public int intReductionMin() {\n-        int result = 0;\n-        for (int i = 0; i < size; i++) {\n-            final int v = 11 * minIntA[i];\n-            result = Math.min(result, v);\n-        }\n-        return result;\n-    }\n-\n-    @Benchmark\n-    public int intReductionMax() {\n-        int result = 0;\n-        for (int i = 0; i < size; i++) {\n-            final int v = 11 * maxIntA[i];\n-            result = Math.max(result, v);\n-        }\n-        return result;\n-    }\n-\n-    @Benchmark\n-    public long[] longLoopMin() {\n-        final long[] result = new long[size];\n-        for (int i = 0; i < size; i++) {\n-            result[i] = Math.min(minLongA[i], minLongB[i]);\n-        }\n-        return result;\n-    }\n-\n-    @Benchmark\n-    public long[] longLoopMax() {\n-        final long[] result = new long[size];\n-        for (int i = 0; i < size; i++) {\n-            result[i] = Math.max(maxLongA[i], maxLongB[i]);\n-        }\n-        return result;\n-    }\n-\n-    @Benchmark\n-    public long longReductionMin() {\n-        long result = 0;\n-        for (int i = 0; i < size; i++) {\n-            final long v = 11 * minLongA[i];\n-            result = Math.min(result, v);\n-        }\n-        return result;\n-    }\n-\n-    @Benchmark\n-    public long longReductionMax() {\n-        long result = 0;\n-        for (int i = 0; i < size; i++) {\n-            final long v = 11 * maxLongA[i];\n-            result = Math.max(result, v);\n-        }\n-        return result;\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/MinMaxLoopBench.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -0,0 +1,251 @@\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.Arrays;\n+import java.util.IntSummaryStatistics;\n+import java.util.LongSummaryStatistics;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.LongStream;\n+\n+@Warmup(iterations = 3, time = 5)\n+@Measurement(iterations = 4, time = 5)\n+@Fork(2)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+public class MinMaxVector\n+{\n+    @State(Scope.Thread)\n+    public static class LoopState {\n+        @Param({\"2048\"})\n+        int size;\n+\n+        \/**\n+         * Probability of one of the min\/max branches being taken.\n+         * For max, this value represents the percentage of branches in which\n+         * the value will be bigger or equal than the current max.\n+         * For min, this value represents the percentage of branches in which\n+         * the value will be smaller or equal than the current min.\n+         *\/\n+        @Param({\"50\", \"80\", \"100\"})\n+        int probability;\n+\n+        int[] minIntA;\n+        int[] minIntB;\n+        long[] minLongA;\n+        long[] minLongB;\n+        int[] maxIntA;\n+        int[] maxIntB;\n+        long[] maxLongA;\n+        long[] maxLongB;\n+        int[] resultIntArray;\n+        long[] resultLongArray;\n+\n+        @Setup\n+        public void setup() {\n+            final long[][] longs = distributeLongRandomIncrement(size, probability);\n+            maxLongA = longs[0];\n+            maxLongB = longs[1];\n+            maxIntA = toInts(maxLongA);\n+            maxIntB = toInts(maxLongB);\n+            minLongA = negate(maxLongA);\n+            minLongB = negate(maxLongB);\n+            minIntA = toInts(minLongA);\n+            minIntB = toInts(minLongB);\n+            resultIntArray = new int[size];\n+            resultLongArray = new long[size];\n+        }\n+        static long[] negate(long[] nums) {\n+            return LongStream.of(nums).map(l -> -l).toArray();\n+        }\n+\n+        static int[] toInts(long[] nums) {\n+            return Arrays.stream(nums).mapToInt(i -> (int) i).toArray();\n+        }\n+\n+        static long[][] distributeLongRandomIncrement(int size, int probability) {\n+            long[][] result;\n+            int aboveCount, abovePercent;\n+\n+            \/\/ Iterate until you find a set that matches the requirement probability\n+            do {\n+                long max = ThreadLocalRandom.current().nextLong(10);\n+                result = new long[2][size];\n+                result[0][0] = max;\n+                result[1][0] = max - 1;\n+\n+                aboveCount = 0;\n+                for (int i = 1; i < result[0].length; i++) {\n+                    long value;\n+                    if (ThreadLocalRandom.current().nextLong(101) <= probability) {\n+                        long increment = ThreadLocalRandom.current().nextLong(10);\n+                        value = max + increment;\n+                        aboveCount++;\n+                    } else {\n+                        \/\/ Decrement by at least 1\n+                        long decrement = ThreadLocalRandom.current().nextLong(10) + 1;\n+                        value = max - decrement;\n+                    }\n+                    result[0][i] = value;\n+                    result[1][i] = max;\n+                    max = Math.max(max, value);\n+                }\n+\n+                abovePercent = ((aboveCount + 1) * 100) \/ size;\n+            } while (abovePercent != probability);\n+\n+            return result;\n+        }\n+    }\n+\n+    @State(Scope.Thread)\n+    public static class RangeState\n+    {\n+        @Param({\"1000\"})\n+        int size;\n+\n+        \/**\n+         * Define range of values to clip as a percentage.\n+         * For example, if value is 100, then all values are considered in the range,\n+         * and so the highest value would be the max value and the lowest value the min value in the array.\n+         * If the value is 90, then highest would be 10% lower than the max value,\n+         * and the min value would be 10% higher than the min value.\n+         *\/\n+        @Param({\"90\", \"100\"})\n+        int range;\n+\n+        @Param(\"0\")\n+        int seed;\n+\n+        int[] ints;\n+        int[] resultInts;\n+        long[] longs;\n+        long[] resultLongs;\n+        int highestInt;\n+        int lowestInt;\n+        long highestLong;\n+        long lowestLong;\n+        Random r = new Random(seed);\n+\n+        @Setup\n+        public void setup() {\n+            ints = new int[size];\n+            resultInts = new int[size];\n+            longs = new long[size];\n+            resultLongs = new long[size];\n+\n+            for (int i = 0; i < size; i++) {\n+                ints[i] = r.nextInt();\n+                longs[i] = r.nextLong();\n+            }\n+\n+            final IntSummaryStatistics intStats = Arrays.stream(ints).summaryStatistics();\n+            highestInt = (intStats.getMax() * range) \/ 100;\n+            lowestInt = intStats.getMin() + (intStats.getMax() - highestInt);\n+\n+            final LongSummaryStatistics longStats = Arrays.stream(longs).summaryStatistics();\n+            highestLong = (longStats.getMax() * range) \/ 100;\n+            lowestLong = longStats.getMin() + (longStats.getMax() - highestLong);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int[] intClippingRange(RangeState state) {\n+        for (int i = 0; i < state.size; i++) {\n+            state.resultInts[i] = Math.min(Math.max(state.ints[i], state.lowestInt), state.highestInt);\n+        }\n+        return state.resultInts;\n+    }\n+\n+    @Benchmark\n+    public int[] intLoopMin(LoopState state) {\n+        for (int i = 0; i < state.size; i++) {\n+            state.resultIntArray[i] = Math.min(state.minIntA[i], state.minIntB[i]);\n+        }\n+        return state.resultIntArray;\n+    }\n+\n+    @Benchmark\n+    public int[] intLoopMax(LoopState state) {\n+        for (int i = 0; i < state.size; i++) {\n+            state.resultIntArray[i] = Math.max(state.maxIntA[i], state.maxIntB[i]);\n+        }\n+        return state.resultIntArray;\n+    }\n+\n+    @Benchmark\n+    public int intReductionMin(LoopState state) {\n+        int result = 0;\n+        for (int i = 0; i < state.size; i++) {\n+            final int v = 11 * state.minIntA[i];\n+            result = Math.min(result, v);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public int intReductionMax(LoopState state) {\n+        int result = 0;\n+        for (int i = 0; i < state.size; i++) {\n+            final int v = 11 * state.maxIntA[i];\n+            result = Math.max(result, v);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public long[] longClippingRange(RangeState state) {\n+        for (int i = 0; i < state.size; i++) {\n+            state.resultLongs[i] = Math.min(Math.max(state.longs[i], state.lowestLong), state.highestLong);\n+        }\n+        return state.resultLongs;\n+    }\n+\n+    @Benchmark\n+    public long[] longLoopMin(LoopState state) {\n+        for (int i = 0; i < state.size; i++) {\n+            state.resultLongArray[i] = Math.min(state.minLongA[i], state.minLongB[i]);\n+        }\n+        return state.resultLongArray;\n+    }\n+\n+    @Benchmark\n+    public long[] longLoopMax(LoopState state) {\n+        for (int i = 0; i < state.size; i++) {\n+            state.resultLongArray[i] = Math.max(state.maxLongA[i], state.maxLongB[i]);\n+        }\n+        return state.resultLongArray;\n+    }\n+\n+    @Benchmark\n+    public long longReductionMin(LoopState state) {\n+        long result = 0;\n+        for (int i = 0; i < state.size; i++) {\n+            final long v = 11 * state.minLongA[i];\n+            result = Math.min(result, v);\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public long longReductionMax(LoopState state) {\n+        long result = 0;\n+        for (int i = 0; i < state.size; i++) {\n+            final long v = 11 * state.maxLongA[i];\n+            result = Math.max(result, v);\n+        }\n+        return result;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/MinMaxVector.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"}]}