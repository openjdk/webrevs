{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestMinMaxInlining.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n@@ -62,2 +62,1 @@\n-        long[] longs = new long[1024];\n-        ReductionInit(longs, probability);\n+        long[] longs = reductionInit(probability);\n@@ -84,2 +83,1 @@\n-        long[] longs = new long[1024];\n-        ReductionInit(longs, probability);\n+        long[] longs = reductionInit(probability);\n@@ -104,1 +102,1 @@\n-    public static void ReductionInit(long[] longs, int probability) {\n+    public static long[] reductionInit(int probability) {\n@@ -106,0 +104,1 @@\n+        long[] longs = new long[1024];\n@@ -107,1 +106,15 @@\n-        \/\/ Iterate until you find a set that matches the requirement probability\n+        \/\/ Generates an array of numbers such that as the array is iterated\n+        \/\/ there is P probability of finding a new max value,\n+        \/\/ and 100-P probability of not finding a new max value.\n+        \/\/ The algorithm loops around if the distribution does not match the probability,\n+        \/\/ but it approximates the probability as the array sizes increase.\n+        \/\/ The worst case of this algorithm is when the desired array size is 100\n+        \/\/ and the aim is to get 50% of probability, which can only be satisfied\n+        \/\/ with 50 elements being a new max. This situation can take 15 rounds.\n+        \/\/ As sizes increase, say 10'000 elements,\n+        \/\/ the number of elements that have to satisfy 50% increases,\n+        \/\/ so the algorithm will stop as an example when 5027 elements are a new max values.\n+        \/\/ Also, probability values in the edges will achieve their objective quicker,\n+        \/\/ with 0% or 100% probability doing it in a single loop.\n+        \/\/ To support the same algorithm for min calculations,\n+        \/\/ negating the array elements achieves the same objective.\n@@ -121,2 +134,2 @@\n-                    long decrement = random.nextLong(10) + 1;\n-                    value = max - decrement;\n+                    long diffToMax = random.nextLong(10) + 1;\n+                    value = max - diffToMax;\n@@ -130,0 +143,2 @@\n+\n+        return longs;\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/MinMaxRed_Long.java","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -83,1 +83,9 @@\n-            \/\/ Iterate until you find a set that matches the requirement probability\n+            \/\/ This algorithm generates 2 arrays of numbers.\n+            \/\/ The first array is created such that as the array is iterated,\n+            \/\/ there is P probability of finding a new min\/max value,\n+            \/\/ and 100-P probability of not finding a new min\/max value.\n+            \/\/ This first array is used on its own for tests that iterate an array to reduce it to a single value,\n+            \/\/ e.g. the min or max value in the array.\n+            \/\/ The second array is loaded with values relative to the first array,\n+            \/\/ such that when the values in the same index are compared for min\/max,\n+            \/\/ the probability that a new min\/max value is found has the probability P.\n@@ -99,2 +107,2 @@\n-                        long decrement = ThreadLocalRandom.current().nextLong(10) + 1;\n-                        value = max - decrement;\n+                        long diffToMax = ThreadLocalRandom.current().nextLong(10) + 1;\n+                        value = max - diffToMax;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/MinMaxVector.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"}]}