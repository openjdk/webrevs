{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2023 SAP SE. All rights reserved.\n@@ -32,1 +33,1 @@\n-#include \"services\/memTracker.hpp\"\n+#include \"services\/memTracker.inline.hpp\"\n@@ -312,0 +313,4 @@\n+  if (MemTracker::check_exceeds_limit(x, _flags)) {\n+    return NULL;\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4263,75 +4263,0 @@\n-\n-bool Arguments::parse_malloc_limit_size(const char* s, size_t* out) {\n-  julong limit = 0;\n-  Arguments::ArgsRange range = parse_memory_size(s, &limit, 1, SIZE_MAX);\n-  switch (range) {\n-  case ArgsRange::arg_in_range:\n-    *out = (size_t)limit;\n-    return true;\n-  case ArgsRange::arg_too_big: \/\/ only possible on 32-bit\n-    vm_exit_during_initialization(\"MallocLimit: too large\", s);\n-    break;\n-  case ArgsRange::arg_too_small:\n-    vm_exit_during_initialization(\"MallocLimit: limit must be > 0\");\n-    break;\n-  default:\n-    break;\n-  }\n-  return false;\n-}\n-\n-\/\/ Helper for parse_malloc_limits\n-void Arguments::parse_single_category_limit(char* expression, size_t limits[mt_number_of_types]) {\n-  \/\/ <category>:<limit>\n-  char* colon = ::strchr(expression, ':');\n-  if (colon == nullptr) {\n-    vm_exit_during_initialization(\"MallocLimit: colon missing\", expression);\n-  }\n-  *colon = '\\0';\n-  MEMFLAGS f = NMTUtil::string_to_flag(expression);\n-  if (f == mtNone) {\n-    vm_exit_during_initialization(\"MallocLimit: invalid nmt category\", expression);\n-  }\n-  if (parse_malloc_limit_size(colon + 1, limits + (int)f) == false) {\n-    vm_exit_during_initialization(\"Invalid MallocLimit size\", colon + 1);\n-  }\n-}\n-\n-void Arguments::parse_malloc_limits(size_t* total_limit, size_t limits[mt_number_of_types]) {\n-\n-  \/\/ Reset output to 0\n-  *total_limit = 0;\n-  for (int i = 0; i < mt_number_of_types; i ++) {\n-    limits[i] = 0;\n-  }\n-\n-  \/\/ We are done if the option is not given.\n-  if (MallocLimit == nullptr) {\n-    return;\n-  }\n-\n-  \/\/ Global form?\n-  if (parse_malloc_limit_size(MallocLimit, total_limit)) {\n-    return;\n-  }\n-\n-  \/\/ No. So it must be in category-specific form: MallocLimit=<nmt category>:<size>[,<nmt category>:<size> ..]\n-  char* copy = os::strdup(MallocLimit);\n-  if (copy == nullptr) {\n-    vm_exit_out_of_memory(strlen(MallocLimit), OOM_MALLOC_ERROR, \"MallocLimit\");\n-  }\n-\n-  char* p = copy, *q;\n-  do {\n-    q = p;\n-    p = ::strchr(q, ',');\n-    if (p != nullptr) {\n-      *p = '\\0';\n-      p ++;\n-    }\n-    parse_single_category_limit(q, limits);\n-  } while (p != nullptr);\n-\n-  os::free(copy);\n-\n-}\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -480,4 +480,0 @@\n-  \/\/ Helpers for parse_malloc_limits\n-  static bool parse_malloc_limit_size(const char* s, size_t* out);\n-  static void parse_single_category_limit(char* expression, size_t limits[mt_number_of_types]);\n-\n@@ -654,10 +650,0 @@\n-  \/\/ Parse diagnostic NMT switch \"MallocLimit\" and return the found limits.\n-  \/\/ 1) If option is not given, it will set all limits to 0 (aka \"no limit\").\n-  \/\/ 2) If option is given in the global form (-XX:MallocLimit=<size>), it\n-  \/\/    will return the size in *total_limit.\n-  \/\/ 3) If option is given in its per-NMT-category form (-XX:MallocLimit=<category>:<size>[,<category>:<size>]),\n-  \/\/    it will return all found limits in the limits array.\n-  \/\/ 4) If option is malformed, it will exit the VM.\n-  \/\/ For (2) and (3), limits not affected by the switch will be set to 0.\n-  static void parse_malloc_limits(size_t* total_limit, size_t limits[mt_number_of_types]);\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1347,5 +1347,0 @@\n-  product(uintx, MallocMaxTestWords,     0, DIAGNOSTIC,                     \\\n-          \"If non-zero, maximum number of words that malloc\/realloc can \"   \\\n-          \"allocate (for testing only)\")                                    \\\n-          range(0, max_uintx)                                               \\\n-                                                                            \\\n@@ -1353,2 +1348,2 @@\n-          \"Limit malloc allocation size from VM. Reaching the limit will \"  \\\n-          \"trigger a fatal error. This feature requires \"                   \\\n+          \"Limit malloc allocation size from VM. Reaching a limit will \"    \\\n+          \"trigger an action (see flag). This feature requires \"            \\\n@@ -1357,4 +1352,11 @@\n-          \"- MallocLimit=<size> to set a total limit. \"                     \\\n-          \"- MallocLimit=<NMT category>:<size>[,<NMT category>:<size>...] \" \\\n-          \"  to set one or more category-specific limits.\"                  \\\n-          \"Example: -XX:MallocLimit=compiler:500m\")                         \\\n+          \"\\\"-XX:MallocLimit=<size>[:<flag>]\\\" sets a total limit.\"         \\\n+          \"\\\"-XX:MallocLimit=<category>:<size>[:<flag>][,<category>:<size>[:<flag>] ...]\\\"\" \\\n+          \"sets one or more category-specific limits.\"                      \\\n+          \"<flag> defines the action upon reaching the limit:\"              \\\n+          \"\\\"fatal\\\": end VM with a fatal error at the allocation site\"     \\\n+          \"\\\"oom\\\"  : will mimic a native OOM\"                              \\\n+          \"If <flag> is omitted, \\\"fatal\\\" is the default.\"                 \\\n+          \"Examples:\\n\"                                                     \\\n+          \"-XX:MallocLimit=2g\"                                              \\\n+          \"-XX:MallocLimit=2g:oom\"                                          \\\n+          \"-XX:MallocLimit=compiler:200m:oom,code:100m\")                    \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-#include \"services\/memTracker.hpp\"\n+#include \"services\/memTracker.inline.hpp\"\n@@ -90,2 +90,0 @@\n-static size_t cur_malloc_words = 0;  \/\/ current size for MallocMaxTestWords\n-\n@@ -610,17 +608,0 @@\n-\/\/\n-\/\/ This function supports testing of the malloc out of memory\n-\/\/ condition without really running the system out of memory.\n-\/\/\n-\n-static bool has_reached_max_malloc_test_peak(size_t alloc_size) {\n-  if (MallocMaxTestWords > 0) {\n-    size_t words = (alloc_size \/ BytesPerWord);\n-\n-    if ((cur_malloc_words + words) > MallocMaxTestWords) {\n-      return true;\n-    }\n-    Atomic::add(&cur_malloc_words, words);\n-  }\n-  return false;\n-}\n-\n@@ -661,2 +642,2 @@\n-  \/\/ For the test flag -XX:MallocMaxTestWords\n-  if (has_reached_max_malloc_test_peak(size)) {\n+  \/\/ Observe MallocLimit\n+  if (MemTracker::check_exceeds_limit(size, memflags)) {\n@@ -713,5 +694,0 @@\n-  \/\/ For the test flag -XX:MallocMaxTestWords\n-  if (has_reached_max_malloc_test_peak(size)) {\n-    return nullptr;\n-  }\n-\n@@ -728,0 +704,7 @@\n+    const size_t old_size = MallocTracker::malloc_header(memblock)->size();\n+\n+    \/\/ Observe MallocLimit\n+    if ((size > old_size) && MemTracker::check_exceeds_limit(size - old_size, memflags)) {\n+      return NULL;\n+    }\n+\n@@ -733,0 +716,1 @@\n+\n@@ -752,1 +736,1 @@\n-    size_t old_size = free_info.size;\n+    assert(old_size == free_info.size, \"Sanity\");\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":12,"deletions":28,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"services\/mallocLimit.hpp\"\n+#include \"services\/nmtCommon.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/parseInteger.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+MallocLimitSet MallocLimitHandler::_limits;\n+bool MallocLimitHandler::_have_limit = false;\n+\n+static const char* const MODE_OOM = \"oom\";\n+static const char* const MODE_FATAL = \"fatal\";\n+\n+static const char* mode_to_name(MallocLimitMode m) {\n+  switch (m) {\n+  case MallocLimitMode::trigger_fatal: return MODE_FATAL;\n+  case MallocLimitMode::trigger_oom: return MODE_OOM;\n+  default: ShouldNotReachHere();\n+  };\n+  return nullptr;\n+}\n+\n+class ParserHelper {\n+  \/\/ Start, end of parsed string.\n+  const char* const _s;\n+  const char* const _end;\n+  \/\/ Current parse position.\n+  const char* _p;\n+\n+public:\n+  ParserHelper(const char* s) : _s(s), _end(s + strlen(s)), _p(s) {}\n+\n+  bool eof() const { return _p >= _end; }\n+\n+  \/\/ Check if string at position matches a malloclimit_mode_t.\n+  \/\/ Advance position on match.\n+  bool match_mode_flag(MallocLimitMode* out) {\n+    if (eof()) {\n+      return false;\n+    }\n+    if (strncasecmp(_p, MODE_OOM, strlen(MODE_OOM)) == 0) {\n+      *out = MallocLimitMode::trigger_oom;\n+      _p += 3;\n+      return true;\n+    } else if (strncasecmp(_p, MODE_FATAL, strlen(MODE_FATAL)) == 0) {\n+      *out = MallocLimitMode::trigger_fatal;\n+      _p += 5;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Check if string at position matches a category name.\n+  \/\/ Advances position on match.\n+  bool match_category(MEMFLAGS* out) {\n+    if (eof()) {\n+      return false;\n+    }\n+    const char* end = strchr(_p, ':');\n+    if (end == nullptr) {\n+      end = _end;\n+    }\n+    stringStream ss;\n+    ss.print(\"%.*s\", (int)(end - _p), _p);\n+    MEMFLAGS f = NMTUtil::string_to_flag(ss.base());\n+    if (f != mtNone) {\n+      *out = f;\n+      _p = end;\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Check if string at position matches a memory size (e.g. \"100\", \"100g\" etc).\n+  \/\/ Advances position on match.\n+  bool match_size(size_t* out) {\n+    if (!eof()) {\n+      char* remainder = nullptr;\n+      if (parse_integer<size_t>(_p, &remainder, out)) {\n+        assert(remainder > _p && remainder <= _end, \"sanity\");\n+        _p = remainder;\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Check if char at pos matches c; return true and advance pos if so.\n+  bool match_char(char c) {\n+    if (!eof() && (*_p) == c) {\n+      _p ++;\n+      return true;\n+    }\n+    return false;\n+  }\n+};\n+\n+MallocLimitSet::MallocLimitSet() {\n+  reset();\n+}\n+\n+void MallocLimitSet::set_global_limit(size_t s, MallocLimitMode flag) {\n+  _glob.sz = s; _glob.mode = flag;\n+}\n+\n+void MallocLimitSet::set_category_limit(MEMFLAGS f, size_t s, MallocLimitMode flag) {\n+  const int i = NMTUtil::flag_to_index(f);\n+  _cat[i].sz = s; _cat[i].mode = flag;\n+}\n+\n+void MallocLimitSet::reset() {\n+  set_global_limit(0, MallocLimitMode::trigger_fatal);\n+  _glob.sz = 0; _glob.mode = MallocLimitMode::trigger_fatal;\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    set_category_limit(NMTUtil::index_to_flag(i), 0, MallocLimitMode::trigger_fatal);\n+  }\n+}\n+\n+void MallocLimitSet::print_on(outputStream* st) const {\n+  static const char* flagnames[] = { MODE_FATAL, MODE_OOM };\n+  if (_glob.sz > 0) {\n+    st->print_cr(\"MallocLimit: total limit: \" PROPERFMT \" (%s)\", PROPERFMTARGS(_glob.sz),\n+                 mode_to_name(_glob.mode));\n+  } else {\n+    for (int i = 0; i < mt_number_of_types; i++) {\n+      if (_cat[i].sz > 0) {\n+        st->print_cr(\"MallocLimit: category \\\"%s\\\" limit: \" PROPERFMT \" (%s)\",\n+                     NMTUtil::flag_to_enum_name(NMTUtil::index_to_flag(i)),\n+                     PROPERFMTARGS(_cat[i].sz), mode_to_name(_cat[i].mode));\n+      }\n+    }\n+  }\n+}\n+\n+bool MallocLimitSet::parse_malloclimit_option(const char* v, const char** err) {\n+\n+#define BAIL_UNLESS(condition, errormessage) if (!(condition)) { *err = errormessage; return false; }\n+\n+  \/\/ Global form:\n+  \/\/ MallocLimit=<size>[:flag]\n+\n+  \/\/ Category-specific form:\n+  \/\/ MallocLimit=<category>:<size>[:flag][,<category>:<size>[:flag]...]\n+\n+  reset();\n+\n+  ParserHelper sst(v);\n+\n+  BAIL_UNLESS(!sst.eof(), \"Empty string\");\n+\n+  \/\/ Global form?\n+  if (sst.match_size(&_glob.sz)) {\n+    \/\/ Match optional mode flag (e.g. 1g:oom)\n+    if (!sst.eof()) {\n+      BAIL_UNLESS(sst.match_char(':'), \"Expected colon\");\n+      BAIL_UNLESS(sst.match_mode_flag(&_glob.mode), \"Expected flag\");\n+    }\n+  }\n+  \/\/ Category-specific form?\n+  else {\n+    while (!sst.eof()) {\n+      MEMFLAGS f;\n+\n+      \/\/ Match category, followed by :\n+      BAIL_UNLESS(sst.match_category(&f), \"Expected category name\");\n+      BAIL_UNLESS(sst.match_char(':'), \"Expected colon following category\");\n+\n+      malloclimit* const modified_limit = &_cat[NMTUtil::flag_to_index(f)];\n+\n+      \/\/ Match size\n+      BAIL_UNLESS(sst.match_size(&modified_limit->sz), \"Expected size\");\n+\n+      \/\/ Match optional flag\n+      if (!sst.eof() && sst.match_char(':')) {\n+        BAIL_UNLESS(sst.match_mode_flag(&modified_limit->mode), \"Expected flag\");\n+      }\n+\n+      \/\/ More to come?\n+      if (!sst.eof()) {\n+        BAIL_UNLESS(sst.match_char(','), \"Expected comma\");\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+void MallocLimitHandler::initialize(const char* options) {\n+  _have_limit = false;\n+  if (options != nullptr && options[0] != '\\0') {\n+    const char* err = nullptr;\n+    if (!_limits.parse_malloclimit_option(options, &err)) {\n+      vm_exit_during_initialization(\"Failed to parse MallocLimit\", err);\n+    }\n+    _have_limit = true;\n+  }\n+}\n+\n+void MallocLimitHandler::print_on(outputStream* st) {\n+  if (have_limit()) {\n+    _limits.print_on(st);\n+  } else {\n+    st->print_cr(\"MallocLimit: unset\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/mallocLimit.cpp","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MALLOCLIMIT_HPP\n+#define SHARE_SERVICES_MALLOCLIMIT_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+enum class MallocLimitMode {\n+  trigger_fatal = 0,\n+  trigger_oom   = 1\n+};\n+\n+struct malloclimit {\n+  size_t sz;            \/\/ Limit size\n+  MallocLimitMode mode; \/\/ Behavior flags\n+};\n+\n+class MallocLimitSet {\n+  malloclimit _glob;                    \/\/ global limit\n+  malloclimit _cat[mt_number_of_types]; \/\/ per-category limit\n+public:\n+  MallocLimitSet();\n+\n+  void reset();\n+  bool parse_malloclimit_option(const char* optionstring, const char** err);\n+\n+  void set_global_limit(size_t s, MallocLimitMode flag);\n+  void set_category_limit(MEMFLAGS f, size_t s, MallocLimitMode flag);\n+\n+  const malloclimit* global_limit() const             { return &_glob; }\n+  const malloclimit* category_limit(MEMFLAGS f) const { return &_cat[(int)f]; }\n+\n+  void print_on(outputStream* st) const;\n+};\n+\n+class MallocLimitHandler : public AllStatic {\n+  static MallocLimitSet _limits;\n+  static bool _have_limit; \/\/ shortcut\n+\n+public:\n+\n+  static const malloclimit* global_limit()             { return _limits.global_limit(); }\n+  static const malloclimit* category_limit(MEMFLAGS f) { return _limits.category_limit(f); }\n+\n+  static void initialize(const char* options);\n+  static void print_on(outputStream* st);\n+\n+  \/\/ True if there is any limit established\n+  static bool have_limit() { return _have_limit; }\n+};\n+\n+#endif \/\/ SHARE_SERVICES_MALLOCLIMIT_HPP\n","filename":"src\/hotspot\/share\/services\/mallocLimit.hpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, 2023 SAP SE. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -34,0 +36,1 @@\n+#include \"services\/mallocLimit.hpp\"\n@@ -42,2 +45,0 @@\n-size_t MallocMemorySummary::_limits_per_category[mt_number_of_types] = { 0 };\n-size_t MallocMemorySummary::_total_limit = 0;\n@@ -83,1 +84,1 @@\n-  initialize_limit_handling();\n+  MallocLimitHandler::initialize(MallocLimit);\n@@ -86,3 +87,1 @@\n-void MallocMemorySummary::initialize_limit_handling() {\n-  \/\/ Initialize limit handling.\n-  Arguments::parse_malloc_limits(&_total_limit, _limits_per_category);\n+bool MallocMemorySummary::total_limit_reached(size_t s, size_t so_far, const malloclimit* limit) {\n@@ -90,14 +89,3 @@\n-  if (_total_limit > 0) {\n-    log_info(nmt)(\"MallocLimit: total limit: \" SIZE_FORMAT \"%s\",\n-                  byte_size_in_proper_unit(_total_limit),\n-                  proper_unit_for_byte_size(_total_limit));\n-  } else {\n-    for (int i = 0; i < mt_number_of_types; i ++) {\n-      size_t catlim = _limits_per_category[i];\n-      if (catlim > 0) {\n-        log_info(nmt)(\"MallocLimit: category \\\"%s\\\" limit: \" SIZE_FORMAT \"%s\",\n-                      NMTUtil::flag_to_name((MEMFLAGS)i),\n-                      byte_size_in_proper_unit(catlim),\n-                      proper_unit_for_byte_size(catlim));\n-      }\n-    }\n+  \/\/ Ignore the limit break during error reporting to prevent secondary errors.\n+  if (VMError::is_error_reported()) {\n+    return false;\n@@ -105,1 +93,0 @@\n-}\n@@ -107,5 +94,8 @@\n-void MallocMemorySummary::total_limit_reached(size_t size, size_t limit) {\n-  \/\/ Assert in both debug and release, but allow error reporting to malloc beyond limits.\n-  if (!VMError::is_error_reported()) {\n-    fatal(\"MallocLimit: reached limit (size: \" SIZE_FORMAT \", limit: \" SIZE_FORMAT \") \",\n-          size, limit);\n+#define FORMATTED \\\n+  \"MallocLimit: reached global limit (triggering allocation size: \" PROPERFMT \", allocated so far: \" PROPERFMT \", limit: \" PROPERFMT \") \", \\\n+  PROPERFMTARGS(s), PROPERFMTARGS(so_far), PROPERFMTARGS(limit->sz)\n+\n+  if (limit->mode == MallocLimitMode::trigger_fatal) {\n+    fatal(FORMATTED);\n+  } else {\n+    log_warning(nmt)(FORMATTED);\n@@ -113,0 +103,3 @@\n+#undef FORMATTED\n+\n+  return true;\n@@ -115,5 +108,5 @@\n-void MallocMemorySummary::category_limit_reached(size_t size, size_t limit, MEMFLAGS flag) {\n-  \/\/ Assert in both debug and release, but allow error reporting to malloc beyond limits.\n-  if (!VMError::is_error_reported()) {\n-    fatal(\"MallocLimit: category \\\"%s\\\" reached limit (size: \" SIZE_FORMAT \", limit: \" SIZE_FORMAT \") \",\n-          NMTUtil::flag_to_name(flag), size, limit);\n+bool MallocMemorySummary::category_limit_reached(MEMFLAGS f, size_t s, size_t so_far, const malloclimit* limit) {\n+\n+  \/\/ Ignore the limit break during error reporting to prevent secondary errors.\n+  if (VMError::is_error_reported()) {\n+    return false;\n@@ -121,1 +114,0 @@\n-}\n@@ -123,3 +115,6 @@\n-void MallocMemorySummary::print_limits(outputStream* st) {\n-  if (_total_limit != 0) {\n-    st->print(\"MallocLimit: \" SIZE_FORMAT, _total_limit);\n+#define FORMATTED \\\n+  \"MallocLimit: reached category \\\"%s\\\" limit (triggering allocation size: \" PROPERFMT \", allocated so far: \" PROPERFMT \", limit: \" PROPERFMT \") \", \\\n+  NMTUtil::flag_to_enum_name(f), PROPERFMTARGS(s), PROPERFMTARGS(so_far), PROPERFMTARGS(limit->sz)\n+\n+  if (limit->mode == MallocLimitMode::trigger_fatal) {\n+    fatal(FORMATTED);\n@@ -127,8 +122,1 @@\n-    bool first = true;\n-    for (int i = 0; i < mt_number_of_types; i ++) {\n-      if (_limits_per_category[i] > 0) {\n-        st->print(\"%s%s:\" SIZE_FORMAT, (first ? \"MallocLimit: \" : \", \"),\n-                  NMTUtil::flag_to_name((MEMFLAGS)i), _limits_per_category[i]);\n-        first = false;\n-      }\n-    }\n+    log_warning(nmt)(FORMATTED);\n@@ -136,0 +124,3 @@\n+#undef FORMATTED\n+\n+  return true;\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":35,"deletions":44,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -3,2 +3,1 @@\n- * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ * Copyright (c) 2021, 2023 SAP SE. All rights reserved.\n@@ -37,0 +36,1 @@\n+struct malloclimit;\n@@ -211,0 +211,1 @@\n+  static bool _have_limits;\n@@ -212,27 +213,7 @@\n-  \/\/ Malloc Limit handling (-XX:MallocLimit)\n-  static size_t _limits_per_category[mt_number_of_types];\n-  static size_t _total_limit;\n-\n-  static void initialize_limit_handling();\n-  static void total_limit_reached(size_t size, size_t limit);\n-  static void category_limit_reached(size_t size, size_t limit, MEMFLAGS flag);\n-\n-  static void check_limits_after_allocation(MEMFLAGS flag) {\n-    \/\/ We can only either have a total limit or category specific limits,\n-    \/\/ not both.\n-    if (_total_limit != 0) {\n-      size_t s = as_snapshot()->total();\n-      if (s > _total_limit) {\n-        total_limit_reached(s, _total_limit);\n-      }\n-    } else {\n-      size_t per_cat_limit = _limits_per_category[(int)flag];\n-      if (per_cat_limit > 0) {\n-        const MallocMemory* mm = as_snapshot()->by_type(flag);\n-        size_t s = mm->malloc_size() + mm->arena_size();\n-        if (s > per_cat_limit) {\n-          category_limit_reached(s, per_cat_limit, flag);\n-        }\n-      }\n-    }\n-  }\n+  \/\/ Called when a total limit break was detected.\n+  \/\/ Will return true if the limit was handled, false if it was ignored.\n+  static bool total_limit_reached(size_t s, size_t so_far, const malloclimit* limit);\n+\n+  \/\/ Called when a total limit break was detected.\n+  \/\/ Will return true if the limit was handled, false if it was ignored.\n+  static bool category_limit_reached(MEMFLAGS f, size_t s, size_t so_far, const malloclimit* limit);\n@@ -246,1 +227,0 @@\n-     check_limits_after_allocation(flag);\n@@ -264,1 +244,0 @@\n-     check_limits_after_allocation(flag);\n@@ -281,1 +260,4 @@\n-  static void print_limits(outputStream* st);\n+  \/\/ MallocLimit: returns true if allocating s bytes on f would trigger\n+  \/\/ either global or the category limit\n+  static inline bool check_exceeds_limit(size_t s, MEMFLAGS f);\n+\n@@ -324,0 +306,4 @@\n+  \/\/ MallocLimt: Given an allocation size s, check if mallocing this much\n+  \/\/ under category f would hit either the global limit or the limit for category f.\n+  static inline bool check_exceeds_limit(size_t s, MEMFLAGS f);\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":18,"deletions":32,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MALLOCTRACKER_INLINE_HPP\n+#define SHARE_SERVICES_MALLOCTRACKER_INLINE_HPP\n+\n+#include \"services\/mallocLimit.hpp\"\n+#include \"services\/mallocTracker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ Returns true if allocating s bytes on f would trigger either global or the category limit\n+inline bool MallocMemorySummary::check_exceeds_limit(size_t s, MEMFLAGS f) {\n+\n+  \/\/ Note: checks are ordered to have as little impact as possible on the standard code path,\n+  \/\/ when MallocLimit is unset, resp. it is set but we have reached no limit yet.\n+  \/\/ Somewhat expensive are:\n+  \/\/ - as_snapshot()->total(), total malloc load (requires iteration over arena types)\n+  \/\/ - VMError::is_error_reported() is a load from a volatile.\n+  if (MallocLimitHandler::have_limit()) {\n+\n+    \/\/ Global Limit ?\n+    const malloclimit* l = MallocLimitHandler::global_limit();\n+    if (l->sz > 0) {\n+      size_t so_far = as_snapshot()->total();\n+      if ((so_far + s) > l->sz) { \/\/ hit the limit\n+        return total_limit_reached(s, so_far, l);\n+      }\n+    } else {\n+      \/\/ Category Limit?\n+      l = MallocLimitHandler::category_limit(f);\n+      if (l->sz > 0) {\n+        const MallocMemory* mm = as_snapshot()->by_type(f);\n+        size_t so_far = mm->malloc_size() + mm->arena_size();\n+        if ((so_far + s) > l->sz) {\n+          return category_limit_reached(f, s, so_far, l);\n+        }\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+inline bool MallocTracker::check_exceeds_limit(size_t s, MEMFLAGS f) {\n+  return MallocMemorySummary::check_exceeds_limit(s, f);\n+}\n+\n+\n+#endif \/\/ SHARE_SERVICES_MALLOCTRACKER_INLINE_HPP\n","filename":"src\/hotspot\/share\/services\/mallocTracker.inline.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2028, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2020, 2023 SAP SE. All rights reserved.\n@@ -37,0 +37,1 @@\n+#include \"services\/mallocLimit.hpp\"\n@@ -93,1 +94,1 @@\n-    ls.cr();\n+    MallocLimitHandler::print_on(&ls);\n@@ -117,1 +118,1 @@\n-    MallocMemorySummary::print_limits(output);\n+    MallocLimitHandler::print_on(output);\n@@ -162,1 +163,1 @@\n-  MallocMemorySummary::print_limits(out);\n+  MallocLimitHandler::print_on(out);\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -233,0 +233,4 @@\n+  \/\/ MallocLimt: Given an allocation size s, check if mallocing this much\n+  \/\/ under category f would hit either the global limit or the limit for category f.\n+  static inline bool check_exceeds_limit(size_t s, MEMFLAGS f);\n+\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MEMTRACKER_INLINE_HPP\n+#define SHARE_SERVICES_MEMTRACKER_INLINE_HPP\n+\n+#include \"services\/mallocTracker.inline.hpp\"\n+#include \"services\/memTracker.hpp\"\n+\n+inline bool MemTracker::check_exceeds_limit(size_t s, MEMFLAGS f) {\n+  if (!enabled()) {\n+    return false;\n+  }\n+  return MallocTracker::check_exceeds_limit(s, f);\n+}\n+\n+#endif \/\/ SHARE_SERVICES_MEMTRACKER_INLINE_HPP\n","filename":"src\/hotspot\/share\/services\/memTracker.inline.hpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -2,1 +2,3 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023 SAP SE. All rights reserved.\n+\n@@ -99,0 +101,5 @@\n+  \/\/ Map memory type to literalized enum name (e.g. \"mtTest\")\n+  static const char* flag_to_enum_name(MEMFLAGS flag) {\n+    return _strings[flag_to_index(flag)].enum_s;\n+  }\n+\n","filename":"src\/hotspot\/share\/services\/nmtCommon.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/mallocLimit.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"services\/nmtCommon.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+#include \"testutils.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ Tests here just test the MallocLimit option parser. They are complemented\n+\/\/ by more extensive jtreg tests (runtime\/NMT\/TestMallocLimit.java)\n+static bool compare_limits(const malloclimit* a, const malloclimit* b) {\n+  return a->sz == b->sz && a->mode == b->mode;\n+}\n+\n+static bool compare_sets(const MallocLimitSet* a, const MallocLimitSet* b) {\n+  if (compare_limits(a->global_limit(), b->global_limit())) {\n+    for (int i = 0; i < mt_number_of_types; i++) {\n+      if (!compare_limits(a->category_limit(NMTUtil::index_to_flag(i)),\n+                          b->category_limit(NMTUtil::index_to_flag(i)))) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+static void test(const char* s, const MallocLimitSet& expected) {\n+  MallocLimitSet set;\n+  const char* err;\n+  EXPECT_TRUE(set.parse_malloclimit_option(s, &err)) << err;\n+  EXPECT_TRUE(compare_sets(&set, &expected));\n+}\n+\n+TEST(NMT, MallocLimitBasics) {\n+  MallocLimitSet expected;\n+\n+  expected.set_global_limit(1 * G, MallocLimitMode::trigger_fatal);\n+  test(\"1g\", expected);\n+  test(\"1024m\", expected);\n+  test(\"1048576k\", expected);\n+  test(\"1073741824\", expected);\n+\n+  \/\/ Fatal is default, but can be specified explicitely\n+  test(\"1g:fatal\", expected);\n+\n+  expected.set_global_limit(2 * M, MallocLimitMode::trigger_oom);\n+  test(\"2m:oom\", expected);\n+  test(\"2m:OOM\", expected);\n+  test(\"2048k:oom\", expected);\n+}\n+\n+TEST(NMT, MallocLimitPerCategory) {\n+  MallocLimitSet expected;\n+\n+  expected.set_category_limit(mtMetaspace, 1 * M, MallocLimitMode::trigger_fatal);\n+  test(\"metaspace:1m\", expected);\n+  test(\"metaspace:1m:fatal\", expected);\n+  test(\"METASPACE:1m\", expected);\n+\n+  expected.set_category_limit(mtCompiler, 2 * M, MallocLimitMode::trigger_oom);\n+  expected.set_category_limit(mtThread, 3 * M, MallocLimitMode::trigger_oom);\n+  expected.set_category_limit(mtThreadStack, 4 * M, MallocLimitMode::trigger_oom);\n+  expected.set_category_limit(mtClass, 5 * M, MallocLimitMode::trigger_fatal);\n+  expected.set_category_limit(mtClassShared, 6 * M, MallocLimitMode::trigger_fatal);\n+  test(\"metaspace:1m,compiler:2m:oom,thread:3m:oom,threadstack:4m:oom,class:5m,classshared:6m\", expected);\n+}\n+\n+TEST(NMT, MallocLimitCategoryEnumNames) {\n+  MallocLimitSet expected;\n+  stringStream option;\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS f = NMTUtil::index_to_flag(i);\n+    if (f != MEMFLAGS::mtNone) {\n+      expected.set_category_limit(f, (i + 1) * M, MallocLimitMode::trigger_fatal);\n+      option.print(\"%s%s:%dM\", (i > 0 ? \",\" : \"\"), NMTUtil::flag_to_enum_name(f), i + 1);\n+    }\n+  }\n+  test(option.base(), expected);\n+}\n+\n+TEST(NMT, MallocLimitAllCategoriesHaveHumanReadableNames) {\n+  MallocLimitSet expected;\n+  stringStream option;\n+  for (int i = 0; i < mt_number_of_types; i++) {\n+    MEMFLAGS f = NMTUtil::index_to_flag(i);\n+    if (f != MEMFLAGS::mtNone) {\n+      expected.set_category_limit(f, (i + 1) * M, MallocLimitMode::trigger_fatal);\n+      option.print(\"%s%s:%dM\", (i > 0 ? \",\" : \"\"), NMTUtil::flag_to_name(f), i + 1);\n+    }\n+  }\n+  test(option.base(), expected);\n+}\n+\n+static void test_failing(const char* s) {\n+  MallocLimitSet set;\n+  const char* err;\n+  ASSERT_FALSE(set.parse_malloclimit_option(s, &err));\n+}\n+\n+TEST(NMT, MallocLimitBadOptions) {\n+  test_failing(\"abcd\");\n+  test_failing(\"compiler:1g:\");\n+  test_failing(\"compiler:1g:oom:mtTest:asas:1m\");\n+}\n+\n+\/\/ Death tests.\n+\/\/ Majority of MallocLimit functional tests are done via jtreg test runtime\/NMT\/MallocLimitTest. Here, we just\n+\/\/ test that limits are triggered for specific APIs.\n+TEST_VM_FATAL_ERROR_MSG(NMT, MallocLimitDeathTestOnRealloc, \".*MallocLimit: reached category .mtTest. limit.*\") {\n+  \/\/ We fake the correct assert if NMT is off to make the test pass (there is no way to execute a death test conditionally)\n+  if (!MemTracker::enabled()) {\n+    fatal(\"Fake message please ignore: MallocLimit: reached category \\\"mtTest\\\" limit\");\n+  }\n+  \/\/ the real test\n+  MallocLimitHandler::initialize(\"test:100m:fatal\");\n+  char* p = (char*)os::malloc(2, mtTest);\n+  p = (char*)os::realloc(p, 120 * M, mtTest);\n+}\n+\n+TEST_VM_FATAL_ERROR_MSG(NMT, MallocLimitDeathTestOnStrDup, \".*MallocLimit: reached category .mtTest. limit.*\") {\n+  \/\/ We fake the correct assert if NMT is off to make the test pass (there is no way to execute a death test conditionally)\n+  if (!MemTracker::enabled()) {\n+    fatal(\"Fake message please ignore: MallocLimit: reached category \\\"mtTest\\\" limit\");\n+  }\n+  \/\/ the real test\n+  MallocLimitHandler::initialize(\"test:10m:fatal\");\n+  for (int i = 0; i < 100000; i++) {\n+    char* p = os::strdup(\"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef\", mtTest);\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_malloclimit.cpp","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,2 @@\n+        \/\/ We run the test with MallocLimit set to 768m in oom mode,\n+        \/\/ in order to trigger and observe a fake os::malloc oom. This needs NMT.\n@@ -74,1 +76,2 @@\n-            \"-XX:MallocMaxTestWords=\" + mallocMaxTestWords,\n+            \"-XX:NativeMemoryTracking=summary\",\n+            \"-XX:MallocLimit=768m:oom\",\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/JsrRewriting.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,5 +57,0 @@\n-        \/\/ limit is 768MB in native words\n-        int mallocMaxTestWords = (1024 * 1024 * 768 \/ 4);\n-        if (Platform.is64bit())\n-            mallocMaxTestWords = (mallocMaxTestWords \/ 2);\n-\n@@ -70,0 +65,2 @@\n+        \/\/ We run the test with MallocLimit set to 768m in oom mode,\n+        \/\/ in order to trigger and observe a fake os::malloc oom. This needs NMT.\n@@ -73,1 +70,2 @@\n-            \"-XX:MallocMaxTestWords=\" + mallocMaxTestWords,\n+            \"-XX:NativeMemoryTracking=summary\",\n+            \"-XX:MallocLimit=768m:oom\",\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassFile\/OomWhileParsingRepeatedJsr.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,5 +222,0 @@\n-        \/*\n-         * Exclude MallocMaxTestWords as it is expected to exit VM at small values (>=0)\n-         *\/\n-        excludeTestMinRange(\"MallocMaxTestWords\");\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @test id=global-limit\n+ * @test id=global-limit-fatal\n@@ -31,1 +31,1 @@\n- * @run driver MallocLimitTest global-limit\n+ * @run driver MallocLimitTest global-limit-fatal\n@@ -35,2 +35,2 @@\n- * @test id=compiler-limit\n- * @summary Verify -XX:MallocLimit with a compiler-specific limit (for \"mtCompiler\" category)\n+ * @test id=global-limit-oom\n+ * @summary Verify -XX:MallocLimit with a global limit\n@@ -39,1 +39,1 @@\n- * @run driver MallocLimitTest compiler-limit\n+ * @run driver MallocLimitTest global-limit-oom\n@@ -43,2 +43,2 @@\n- * @test id=multi-limit\n- * @summary Verify -XX:MallocLimit with multiple limits\n+ * @test id=compiler-limit-fatal\n+ * @summary Verify -XX:MallocLimit with a compiler-specific limit (for \"mtCompiler\" category)\n@@ -47,1 +47,1 @@\n- * @run driver MallocLimitTest multi-limit\n+ * @run driver MallocLimitTest compiler-limit-fatal\n@@ -51,2 +51,2 @@\n- * @test id=valid-settings\n- * @summary Verify -XX:MallocLimit rejects invalid settings\n+ * @test id=compiler-limit-oom\n+ * @summary Verify -XX:MallocLimit with a compiler-specific limit (for \"mtCompiler\" category)\n@@ -55,1 +55,1 @@\n- * @run driver MallocLimitTest valid-settings\n+ * @run driver MallocLimitTest compiler-limit-oom\n@@ -59,2 +59,2 @@\n- * @test id=invalid-settings\n- * @summary Verify -XX:MallocLimit rejects invalid settings\n+ * @test id=multi-limit\n+ * @summary Verify -XX:MallocLimit with multiple limits\n@@ -63,1 +63,1 @@\n- * @run driver MallocLimitTest invalid-settings\n+ * @run driver MallocLimitTest multi-limit\n@@ -99,3 +99,2 @@\n-    private static void testGlobalLimit() throws IOException {\n-        long smallMemorySize = 1024*1024; \/\/ 1m\n-        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=\" + smallMemorySize);\n+    private static void testGlobalLimitFatal() throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=1m\");\n@@ -104,5 +103,2 @@\n-        output.shouldContain(\"[nmt] MallocLimit: total limit: 1024K\"); \/\/ printed by byte_size_in_proper_unit()\n-        String s = output.firstMatch(\".*MallocLimit: reached limit \\\\(size: (\\\\d+), limit: \" + smallMemorySize + \"\\\\).*\", 1);\n-        Asserts.assertNotNull(s);\n-        long size = Long.parseLong(s);\n-        Asserts.assertGreaterThan(size, smallMemorySize);\n+        output.shouldContain(\"[nmt] MallocLimit: total limit: 1024K (fatal)\");\n+        output.shouldMatch(\"#  fatal error: MallocLimit: reached global limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1024K\\\\)\");\n@@ -111,10 +107,2 @@\n-    private static void testCompilerLimit() throws IOException {\n-        \/\/ Here, we count on the VM, running with -Xcomp and with 1m of arena space allowed, will start a compilation\n-        \/\/ and then trip over the limit.\n-        \/\/ If limit is too small, Compiler stops too early and we won't get a Retry file (see below, we check that).\n-        \/\/ If limit is too large, we may not trigger it for java -version.\n-        \/\/ 1m seems to work out fine.\n-        long smallMemorySize = 1024*1024; \/\/ 1m\n-        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=compiler:\" + smallMemorySize,\n-                \"-Xcomp\" \/\/ make sure we hit the compiler category limit\n-        );\n+    private static void testGlobalLimitOOM() throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=1m:oom\");\n@@ -123,6 +111,3 @@\n-        output.shouldContain(\"[nmt] MallocLimit: category \\\"Compiler\\\" limit: 1024K\"); \/\/ printed by byte_size_in_proper_unit\n-        String s = output.firstMatch(\".*MallocLimit: category \\\"Compiler\\\" reached limit \\\\(size: (\\\\d+), limit: \" + smallMemorySize + \"\\\\).*\", 1);\n-        Asserts.assertNotNull(s);\n-        long size = Long.parseLong(s);\n-        output.shouldContain(\"Compiler replay data is saved as\");\n-        Asserts.assertGreaterThan(size, smallMemorySize);\n+        output.shouldContain(\"[nmt] MallocLimit: total limit: 1024K (oom)\");\n+        output.shouldMatch(\".*\\\\[warning\\\\]\\\\[nmt\\\\] MallocLimit: reached global limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1024K\\\\)\");\n+        \/\/ The rest is fuzzy. We may get SIGSEGV or a native OOM message, depending on how the failing allocation was handled.\n@@ -131,3 +116,2 @@\n-    private static void testMultiLimit() throws IOException {\n-        long smallMemorySize = 1024; \/\/ 1k\n-        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=mtOther:2g,compiler:1g,internal:\" + smallMemorySize);\n+    private static void testCompilerLimitFatal() throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=compiler:1234k\", \"-Xcomp\");\n@@ -136,6 +120,2 @@\n-        output.shouldContain(\"[nmt] MallocLimit: category \\\"Compiler\\\" limit: 1024M\");\n-        output.shouldContain(\"[nmt] MallocLimit: category \\\"Internal\\\" limit: 1024B\");\n-        output.shouldContain(\"[nmt] MallocLimit: category \\\"Other\\\" limit: 2048M\");\n-        String s = output.firstMatch(\".*MallocLimit: category \\\"Internal\\\" reached limit \\\\(size: (\\\\d+), limit: \" + smallMemorySize + \"\\\\).*\", 1);\n-        long size = Long.parseLong(s);\n-        Asserts.assertGreaterThan(size, smallMemorySize);\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"mtCompiler\\\" limit: 1234K (fatal)\");\n+        output.shouldMatch(\"#  fatal error: MallocLimit: reached category \\\"mtCompiler\\\" limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1234K\\\\)\");\n@@ -144,2 +124,2 @@\n-    private static void testValidSetting(String setting, String... expected_output) throws IOException {\n-        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=\" + setting);\n+    private static void testCompilerLimitOOM() throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=compiler:1234k:oom\", \"-Xcomp\");\n@@ -147,54 +127,4 @@\n-        output.shouldHaveExitValue(0);\n-        for (String expected : expected_output) {\n-            output.shouldContain(expected);\n-        }\n-    }\n-\n-    private static void testValidSettings() throws IOException {\n-        \/\/ Test a number of valid settings.\n-        testValidSetting(\n-                \"2097152k\",\n-                \"[nmt] MallocLimit: total limit: 2048M\",\n-                \"[nmt] NMT initialized: summary\"\n-        );\n-        testValidSetting(\n-                \"gc:1234567891,mtInternal:987654321,Object Monitors:1g\",\n-                \"[nmt] MallocLimit: category \\\"GC\\\" limit: 1177M\",\n-                \"[nmt] MallocLimit: category \\\"Internal\\\" limit: 941M\",\n-                \"[nmt] MallocLimit: category \\\"Object Monitors\\\" limit: 1024M\",\n-                \"[nmt] NMT initialized: summary\"\n-        );\n-        \/\/ Set all categories individually:\n-        testValidSetting(\n-                \"JavaHeap:1024m,Class:1025m,Thread:1026m,ThreadStack:1027m,Code:1028m,GC:1029m,GCCardSet:1030m,Compiler:1031m,JVMCI:1032m,\" +\n-                        \"Internal:1033m,Other:1034m,Symbol:1035m,NMT:1036m,ClassShared:1037m,Chunk:1038m,Test:1039m,Tracing:1040m,Logging:1041m,\" +\n-                        \"Statistics:1042m,Arguments:1043m,Module:1044m,Safepoint:1045m,Synchronizer:1046m,Serviceability:1047m,Metaspace:1048m,StringDedup:1049m,ObjectMonitor:1050m\",\n-                \"[nmt] MallocLimit: category \\\"Java Heap\\\" limit: 1024M\",\n-                \"[nmt] MallocLimit: category \\\"Class\\\" limit: 1025M\",\n-                \"[nmt] MallocLimit: category \\\"Thread\\\" limit: 1026M\",\n-                \"[nmt] MallocLimit: category \\\"Thread Stack\\\" limit: 1027M\",\n-                \"[nmt] MallocLimit: category \\\"Code\\\" limit: 1028M\",\n-                \"[nmt] MallocLimit: category \\\"GC\\\" limit: 1029M\",\n-                \"[nmt] MallocLimit: category \\\"GCCardSet\\\" limit: 1030M\",\n-                \"[nmt] MallocLimit: category \\\"Compiler\\\" limit: 1031M\",\n-                \"[nmt] MallocLimit: category \\\"JVMCI\\\" limit: 1032M\",\n-                \"[nmt] MallocLimit: category \\\"Internal\\\" limit: 1033M\",\n-                \"[nmt] MallocLimit: category \\\"Other\\\" limit: 1034M\",\n-                \"[nmt] MallocLimit: category \\\"Symbol\\\" limit: 1035M\",\n-                \"[nmt] MallocLimit: category \\\"Native Memory Tracking\\\" limit: 1036M\",\n-                \"[nmt] MallocLimit: category \\\"Shared class space\\\" limit: 1037M\",\n-                \"[nmt] MallocLimit: category \\\"Arena Chunk\\\" limit: 1038M\",\n-                \"[nmt] MallocLimit: category \\\"Test\\\" limit: 1039M\",\n-                \"[nmt] MallocLimit: category \\\"Tracing\\\" limit: 1040M\",\n-                \"[nmt] MallocLimit: category \\\"Logging\\\" limit: 1041M\",\n-                \"[nmt] MallocLimit: category \\\"Statistics\\\" limit: 1042M\",\n-                \"[nmt] MallocLimit: category \\\"Arguments\\\" limit: 1043M\",\n-                \"[nmt] MallocLimit: category \\\"Module\\\" limit: 1044M\",\n-                \"[nmt] MallocLimit: category \\\"Safepoint\\\" limit: 1045M\",\n-                \"[nmt] MallocLimit: category \\\"Synchronization\\\" limit: 1046M\",\n-                \"[nmt] MallocLimit: category \\\"Serviceability\\\" limit: 1047M\",\n-                \"[nmt] MallocLimit: category \\\"Metaspace\\\" limit: 1048M\",\n-                \"[nmt] MallocLimit: category \\\"String Deduplication\\\" limit: 1049M\",\n-                \"[nmt] MallocLimit: category \\\"Object Monitors\\\" limit: 1050M\",\n-                \"[nmt] NMT initialized: summary\"\n-        );\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"mtCompiler\\\" limit: 1234K (oom)\");\n+        output.shouldMatch(\".*\\\\[warning\\\\]\\\\[nmt\\\\] MallocLimit: reached category \\\"mtCompiler\\\" limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1234K\\\\)\");\n+        \/\/ The rest is fuzzy. We may get SIGSEGV or a native OOM message, depending on how the failing allocation was handled.\n@@ -203,2 +133,2 @@\n-    private static void testInvalidSetting(String setting, String expected_error) throws IOException {\n-        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=\" + setting);\n+    private static void testMultiLimit() throws IOException {\n+        ProcessBuilder pb = processBuilderWithSetting(\"-XX:MallocLimit=other:2g,compiler:1g:oom,internal:1k\");\n@@ -206,1 +136,0 @@\n-        output.reportDiagnosticSummary();\n@@ -208,11 +137,4 @@\n-        output.shouldContain(expected_error);\n-    }\n-\n-    private static void testInvalidSettings() throws IOException {\n-        \/\/ Test a number of invalid settings the parser should catch. VM should abort in initialization.\n-        testInvalidSetting(\"gc\", \"MallocLimit: colon missing: gc\");\n-        testInvalidSetting(\"gc:abc\", \"Invalid MallocLimit size: abc\");\n-        testInvalidSetting(\"abcd:10m\", \"MallocLimit: invalid nmt category: abcd\");\n-        testInvalidSetting(\"nmt:100m,abcd:10m\", \"MallocLimit: invalid nmt category: abcd\");\n-        testInvalidSetting(\"0\", \"MallocLimit: limit must be > 0\");\n-        testInvalidSetting(\"GC:0\", \"MallocLimit: limit must be > 0\");\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"mtCompiler\\\" limit: 1024M (oom)\");\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"mtInternal\\\" limit: 1024B (fatal)\");\n+        output.shouldContain(\"[nmt] MallocLimit: category \\\"mtOther\\\" limit: 2048M (fatal)\");\n+        output.shouldMatch(\"#  fatal error: MallocLimit: reached category \\\"mtInternal\\\" limit \\\\(triggering allocation size: \\\\d+[BKM], allocated so far: \\\\d+[BKM], limit: 1024B\\\\)\");\n@@ -232,4 +154,8 @@\n-        if (args[0].equals(\"global-limit\")) {\n-            testGlobalLimit();\n-        } else if (args[0].equals(\"compiler-limit\")) {\n-            testCompilerLimit();\n+        if (args[0].equals(\"global-limit-fatal\")) {\n+            testGlobalLimitFatal();\n+        } else if (args[0].equals(\"global-limit-oom\")) {\n+            testGlobalLimitOOM();\n+        } else if (args[0].equals(\"compiler-limit-fatal\")) {\n+            testCompilerLimitFatal();\n+        } else if (args[0].equals(\"compiler-limit-oom\")) {\n+            testCompilerLimitOOM();\n@@ -238,4 +164,0 @@\n-        } else if (args[0].equals(\"valid-settings\")) {\n-            testValidSettings();\n-        } else if (args[0].equals(\"invalid-settings\")) {\n-            testInvalidSettings();\n","filename":"test\/hotspot\/jtreg\/runtime\/NMT\/MallocLimitTest.java","additions":47,"deletions":125,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+\/\/ Note: we run the test with MallocLimit for the \"other\" category set to 100m (oom mode),\n+\/\/ in order to trigger and observe a fake os::malloc oom. This needs NMT.\n+\n@@ -31,1 +34,1 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:MallocMaxTestWords=100m AllocateMemory\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary -XX:MallocLimit=other:100m:oom AllocateMemory\n@@ -59,1 +62,1 @@\n-        \/\/ we test this by limiting the malloc using -XX:MallocMaxTestWords\n+        \/\/ since we start with -XX:MallocLimit\n@@ -61,1 +64,1 @@\n-            address = unsafe.allocateMemory(100 * 1024 * 1024 * 8);\n+            address = unsafe.allocateMemory(100 * 1024 * 1024);\n","filename":"test\/hotspot\/jtreg\/runtime\/Unsafe\/AllocateMemory.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+\/\/ Note: we run the test with MallocLimit for the \"other\" category set to 100m (oom mode),\n+\/\/ in order to trigger and observe a fake os::malloc oom. This needs NMT.\n+\n@@ -31,1 +34,1 @@\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:MallocMaxTestWords=100m Reallocate\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:NativeMemoryTracking=summary -XX:MallocLimit=other:100m:oom Reallocate\n@@ -62,1 +65,1 @@\n-            unsafe.reallocateMemory(address, 100 * 1024 * 1024 * 8);\n+            unsafe.reallocateMemory(address, 100 * 1024 * 1024);\n","filename":"test\/hotspot\/jtreg\/runtime\/Unsafe\/Reallocate.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"}]}