{"files":[{"patch":"@@ -163,1 +163,1 @@\n-    private static long reduceLanes(long init, long[] arr, int vlen,binOpLong f) {\n+    private static long reduceLanes(long init, long[] arr, int vlen, binOpLong f) {\n@@ -219,34 +219,6 @@\n-    private static void verifyAddReductionFloat(float actual, float[] arr, int vlen) {\n-        float expected = 0.0f;\n-        for (int i = 0; i < vlen; i++) {\n-            expected += arr[i];\n-        }\n-        \/\/ Floating point addition reduction ops may introduce rounding errors.\n-        float ROUNDING_ERROR_FACTOR_ADD = 10.0f;\n-        float tolerance = Math.ulp(expected) * ROUNDING_ERROR_FACTOR_ADD;\n-        if (Math.abs(expected - actual) > tolerance) {\n-            throw new RuntimeException(\n-                \"assertEqualsWithTolerance\" +\n-                \": expected \" + expected + \" but was \" + actual +\n-                \" (tolerance: \" + tolerance + \", diff: \" + Math.abs(expected - actual) + \")\"\n-            );\n-        }\n-    }\n-\n-    private static void verifyAddReductionDouble(double actual, double[] arr, int vlen) {\n-        double expected = 0.0;\n-        for (int i = 0; i < vlen; i++) {\n-            expected += arr[i];\n-        }\n-        \/\/ Floating point addition reduction ops may introduce rounding errors.\n-        double ROUNDING_ERROR_FACTOR_ADD = 10.0;\n-        double tolerance = Math.ulp(expected) * ROUNDING_ERROR_FACTOR_ADD;\n-        if (Math.abs(expected - actual) > tolerance) {\n-            throw new RuntimeException(\n-                \"assertEqualsWithTolerance\" +\n-                \": expected \" + expected + \" but was \" + actual +\n-                \" (tolerance: \" + tolerance + \", diff: \" + Math.abs(expected - actual) + \")\"\n-            );\n-        }\n-    }\n-\n+    \/\/ Because the evaluation order of floating point reduction addition in the Vector\n+    \/\/ API is not guaranteed, it is difficult to choose a single tolerance that reliably\n+    \/\/ validates results for randomly generated floating‑point inputs. Given that there\n+    \/\/ are already extensive jtreg tests under \"test\/jdk\/jdk\/incubator\/vector\" that verify\n+    \/\/ the API’s numerical correctness, this test is instead focused solely on checking\n+    \/\/ the generated IRs, and deliberately does not assert on the computed result.\n@@ -259,3 +231,1 @@\n-        float result = v.reduceLanes(VectorOperators.ADD);\n-        verifyAddReductionFloat(result, fa, FSPEC_128.length());\n-        return result;\n+        return v.reduceLanes(VectorOperators.ADD);\n@@ -264,1 +234,2 @@\n-\n+    \/\/ Same with above test for float type, this test does not validate the numerical\n+    \/\/ result and focuses solely on checking the correctness of the generated IR.\n@@ -271,3 +242,1 @@\n-        double result = v.reduceLanes(VectorOperators.ADD);\n-        verifyAddReductionDouble(result, da, DSPEC_128.length());\n-        return result;\n+        return v.reduceLanes(VectorOperators.ADD);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorOperationsWithPartialSize.java","additions":11,"deletions":42,"binary":false,"changes":53,"status":"modified"}]}