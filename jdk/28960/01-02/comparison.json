{"files":[{"patch":"@@ -79,6 +79,2 @@\n-        \/\/ Use a range of 1~3000 for floating point values to keep the tests\n-        \/\/ effectiveness while avoiding the large precision differences introduced\n-        \/\/ by the add reduction APIs, especially since the Vector API does not\n-        \/\/ guarantee a specific calculation order for such operations.\n-        random.fill(random.uniformFloats(1.0f, 3000.0f), fa);\n-        random.fill(random.uniformDoubles(1.0, 3000.0), da);\n+        random.fill(random.floats(), fa);\n+        random.fill(random.doubles(), da);\n@@ -223,32 +219,6 @@\n-    private static void verifyAddReductionFloat(float actual, float[] arr, int vlen) {\n-        float expected = 0.0f;\n-        for (int i = 0; i < vlen; i++) {\n-            expected += arr[i];\n-        }\n-        \/\/ Floating point addition reduction ops may introduce rounding errors.\n-        float ROUNDING_ERROR_FACTOR_ADD = 10.0f;\n-        float tolerance = Math.ulp(expected) * ROUNDING_ERROR_FACTOR_ADD;\n-        if (Math.abs(expected - actual) > tolerance) {\n-            throw new RuntimeException(\n-                \": expected \" + expected + \" but was \" + actual +\n-                \" (tolerance: \" + tolerance + \", diff: \" + Math.abs(expected - actual) + \")\"\n-            );\n-        }\n-    }\n-\n-    private static void verifyAddReductionDouble(double actual, double[] arr, int vlen) {\n-        double expected = 0.0;\n-        for (int i = 0; i < vlen; i++) {\n-            expected += arr[i];\n-        }\n-        \/\/ Floating point addition reduction ops may introduce rounding errors.\n-        double ROUNDING_ERROR_FACTOR_ADD = 10.0;\n-        double tolerance = Math.ulp(expected) * ROUNDING_ERROR_FACTOR_ADD;\n-        if (Math.abs(expected - actual) > tolerance) {\n-            throw new RuntimeException(\n-                \": expected \" + expected + \" but was \" + actual +\n-                \" (tolerance: \" + tolerance + \", diff: \" + Math.abs(expected - actual) + \")\"\n-            );\n-        }\n-    }\n-\n+    \/\/ Because the evaluation order of floating point reduction addition in the Vector\n+    \/\/ API is not guaranteed, it is difficult to choose a single tolerance that reliably\n+    \/\/ validates results for randomly generated floating‑point inputs. Given that there\n+    \/\/ are already extensive jtreg tests under \"test\/jdk\/jdk\/incubator\/vector\" that verify\n+    \/\/ the API’s numerical correctness, this test is instead focused solely on checking\n+    \/\/ the generated IRs, and deliberately does not assert on the computed result.\n@@ -261,3 +231,1 @@\n-        float result = v.reduceLanes(VectorOperators.ADD);\n-        verifyAddReductionFloat(result, fa, FSPEC_128.length());\n-        return result;\n+        return v.reduceLanes(VectorOperators.ADD);\n@@ -266,1 +234,2 @@\n-\n+    \/\/ Same with above test for float type, this test does not validate the numerical\n+    \/\/ result and focuses solely on checking the correctness of the generated IR.\n@@ -273,3 +242,1 @@\n-        double result = v.reduceLanes(VectorOperators.ADD);\n-        verifyAddReductionDouble(result, da, DSPEC_128.length());\n-        return result;\n+        return v.reduceLanes(VectorOperators.ADD);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorOperationsWithPartialSize.java","additions":12,"deletions":45,"binary":false,"changes":57,"status":"modified"}]}