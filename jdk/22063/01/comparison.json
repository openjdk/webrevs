{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.module.ModuleReader;\n@@ -57,1 +56,0 @@\n-import java.security.AccessController;\n@@ -59,1 +57,0 @@\n-import java.security.PrivilegedAction;\n@@ -76,1 +73,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -79,1 +75,0 @@\n-import jdk.internal.misc.PreviewFeatures;\n@@ -87,1 +82,0 @@\n-import jdk.internal.vm.annotation.ForceInline;\n@@ -543,3 +537,1 @@\n-    @CallerSensitive\n-    public static Class<?> forName(String name, boolean initialize,\n-                                   ClassLoader loader)\n+    public static Class<?> forName(String name, boolean initialize, ClassLoader loader)\n@@ -548,30 +540,1 @@\n-        Class<?> caller = null;\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            \/\/ Reflective call to get caller class is only needed if a security manager\n-            \/\/ is present.  Avoid the overhead of making this call otherwise.\n-            caller = Reflection.getCallerClass();\n-        }\n-        return forName(name, initialize, loader, caller);\n-    }\n-\n-    \/\/ Caller-sensitive adapter method for reflective invocation\n-    @CallerSensitiveAdapter\n-    private static Class<?> forName(String name, boolean initialize, ClassLoader loader, Class<?> caller)\n-            throws ClassNotFoundException\n-    {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            \/\/ Reflective call to get caller class is only needed if a security manager\n-            \/\/ is present.  Avoid the overhead of making this call otherwise.\n-            if (loader == null) {\n-                ClassLoader ccl = ClassLoader.getClassLoader(caller);\n-                if (ccl != null) {\n-                    sm.checkPermission(\n-                            SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-                }\n-            }\n-        }\n-        return forName0(name, initialize, loader, caller);\n+        return forName0(name, initialize, loader, null);\n@@ -623,2 +586,0 @@\n-    @SuppressWarnings(\"removal\")\n-    @CallerSensitive\n@@ -626,12 +587,0 @@\n-        Class<?> caller = null;\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            caller = Reflection.getCallerClass();\n-        }\n-        return forName(module, name, caller);\n-    }\n-\n-    \/\/ Caller-sensitive adapter method for reflective invocation\n-    @SuppressWarnings(\"removal\")\n-    @CallerSensitiveAdapter\n-    private static Class<?> forName(Module module, String name, Class<?> caller) {\n@@ -641,14 +590,1 @@\n-        ClassLoader cl;\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            if (caller != null && caller.getModule() != module) {\n-                \/\/ if caller is null, Class.forName is the last java frame on the stack.\n-                \/\/ java.base has all permissions\n-                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-            }\n-            PrivilegedAction<ClassLoader> pa = module::getClassLoader;\n-            cl = AccessController.doPrivileged(pa);\n-        } else {\n-            cl = module.getClassLoader();\n-        }\n-\n+        ClassLoader cl = module.getClassLoader();\n@@ -743,1 +679,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -749,5 +684,0 @@\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);\n-        }\n-\n@@ -768,7 +698,1 @@\n-                java.security.AccessController.doPrivileged(\n-                    new java.security.PrivilegedAction<>() {\n-                        public Void run() {\n-                                c.setAccessible(true);\n-                                return null;\n-                            }\n-                        });\n+                c.setAccessible(true);\n@@ -1038,2 +962,0 @@\n-    @CallerSensitive\n-    @ForceInline \/\/ to ensure Reflection.getCallerClass optimization\n@@ -1041,9 +963,1 @@\n-        ClassLoader cl = classLoader;\n-        if (cl == null)\n-            return null;\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());\n-        }\n-        return cl;\n+        return classLoader;\n@@ -1514,1 +1428,0 @@\n-    @CallerSensitive\n@@ -1536,1 +1449,0 @@\n-            \/\/ Perform access check\n@@ -1538,6 +1450,0 @@\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,\n-                                                     Reflection.getCallerClass(), true);\n-            }\n@@ -1651,1 +1557,0 @@\n-    @CallerSensitive\n@@ -1669,1 +1574,1 @@\n-            for(int i = 0; i < parameterClasses.length; i++)\n+            for (int i = 0; i < parameterClasses.length; i++)\n@@ -1672,8 +1577,0 @@\n-            \/\/ Perform access check\n-            final Class<?> enclosingCandidate = enclosingInfo.getEnclosingClass();\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                enclosingCandidate.checkMemberAccess(sm, Member.DECLARED,\n-                                                     Reflection.getCallerClass(), true);\n-            }\n@@ -1681,0 +1578,1 @@\n+            final Class<?> enclosingCandidate = enclosingInfo.getEnclosingClass();\n@@ -1711,1 +1609,0 @@\n-    @CallerSensitive\n@@ -1713,11 +1610,1 @@\n-        final Class<?> candidate = getDeclaringClass0();\n-\n-        if (candidate != null) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                candidate.checkPackageAccess(sm,\n-                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);\n-            }\n-        }\n-        return candidate;\n+        return getDeclaringClass0();\n@@ -1736,1 +1623,0 @@\n-    @CallerSensitive\n@@ -1763,9 +1649,0 @@\n-\n-        if (enclosingCandidate != null) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                enclosingCandidate.checkPackageAccess(sm,\n-                    ClassLoader.getClassLoader(Reflection.getCallerClass()), true);\n-            }\n-        }\n@@ -1994,2 +1871,0 @@\n-    @SuppressWarnings(\"removal\")\n-    @CallerSensitive\n@@ -1997,25 +1872,6 @@\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), false);\n-        }\n-\n-        \/\/ Privileged so this implementation can look at DECLARED classes,\n-        \/\/ something the caller might not have privilege to do.  The code here\n-        \/\/ is allowed to look at DECLARED classes because (1) it does not hand\n-        \/\/ out anything other than public members and (2) public member access\n-        \/\/ has already been ok'd by the SecurityManager.\n-\n-        return java.security.AccessController.doPrivileged(\n-            new java.security.PrivilegedAction<>() {\n-                public Class<?>[] run() {\n-                    List<Class<?>> list = new ArrayList<>();\n-                    Class<?> currentClass = Class.this;\n-                    while (currentClass != null) {\n-                        for (Class<?> m : currentClass.getDeclaredClasses()) {\n-                            if (Modifier.isPublic(m.getModifiers())) {\n-                                list.add(m);\n-                            }\n-                        }\n-                        currentClass = currentClass.getSuperclass();\n-                    }\n-                    return list.toArray(new Class<?>[0]);\n+        List<Class<?>> list = new ArrayList<>();\n+        Class<?> currentClass = Class.this;\n+        while (currentClass != null) {\n+            for (Class<?> m : currentClass.getDeclaredClasses()) {\n+                if (Modifier.isPublic(m.getModifiers())) {\n+                    list.add(m);\n@@ -2023,1 +1879,4 @@\n-            });\n+            }\n+            currentClass = currentClass.getSuperclass();\n+        }\n+        return list.toArray(new Class<?>[0]);\n@@ -2057,1 +1916,0 @@\n-    @CallerSensitive\n@@ -2059,5 +1917,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);\n-        }\n@@ -2141,1 +1994,0 @@\n-    @CallerSensitive\n@@ -2143,5 +1995,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);\n-        }\n@@ -2176,1 +2023,0 @@\n-    @CallerSensitive\n@@ -2178,5 +2024,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);\n-        }\n@@ -2222,1 +2063,0 @@\n-    @CallerSensitive\n@@ -2225,5 +2065,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);\n-        }\n@@ -2325,1 +2160,0 @@\n-    @CallerSensitive\n@@ -2329,5 +2163,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);\n-        }\n@@ -2366,1 +2195,0 @@\n-    @CallerSensitive\n@@ -2369,5 +2197,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);\n-        }\n@@ -2395,1 +2218,0 @@\n-    @CallerSensitive\n@@ -2397,5 +2219,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), false);\n-        }\n@@ -2428,1 +2245,0 @@\n-    @CallerSensitive\n@@ -2430,5 +2246,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n@@ -2470,1 +2281,0 @@\n-    @CallerSensitive\n@@ -2472,5 +2282,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n@@ -2522,1 +2327,0 @@\n-    @CallerSensitive\n@@ -2524,5 +2328,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n@@ -2553,1 +2352,0 @@\n-    @CallerSensitive\n@@ -2555,5 +2353,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n@@ -2584,1 +2377,0 @@\n-    @CallerSensitive\n@@ -2587,5 +2379,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n@@ -2629,1 +2416,0 @@\n-    @CallerSensitive\n@@ -2633,5 +2419,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n@@ -2706,1 +2487,0 @@\n-    @CallerSensitive\n@@ -2709,6 +2489,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);\n-        }\n-\n@@ -2936,5 +2710,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(SecurityConstants.GET_PD_PERMISSION);\n-        }\n@@ -2975,85 +2744,0 @@\n-    \/*\n-     * Check if client is allowed to access members.  If access is denied,\n-     * throw a SecurityException.\n-     *\n-     * This method also enforces package access.\n-     *\n-     * <p> Default policy: allow all clients access with normal Java access\n-     * control.\n-     *\n-     * <p> NOTE: should only be called if a SecurityManager is installed\n-     *\/\n-    private void checkMemberAccess(@SuppressWarnings(\"removal\") SecurityManager sm, int which,\n-                                   Class<?> caller, boolean checkProxyInterfaces) {\n-        \/* Default policy allows access to all {@link Member#PUBLIC} members,\n-         * as well as access to classes that have the same class loader as the caller.\n-         * In all other cases, it requires RuntimePermission(\"accessDeclaredMembers\")\n-         * permission.\n-         *\/\n-        final ClassLoader ccl = ClassLoader.getClassLoader(caller);\n-        if (which != Member.PUBLIC) {\n-            final ClassLoader cl = classLoader;\n-            if (ccl != cl) {\n-                sm.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);\n-            }\n-        }\n-        this.checkPackageAccess(sm, ccl, checkProxyInterfaces);\n-    }\n-\n-    \/*\n-     * Checks if a client loaded in ClassLoader ccl is allowed to access this\n-     * class under the current package access policy. If access is denied,\n-     * throw a SecurityException.\n-     *\n-     * NOTE: this method should only be called if a SecurityManager is active\n-     *\/\n-    private void checkPackageAccess(@SuppressWarnings(\"removal\") SecurityManager sm, final ClassLoader ccl,\n-                                    boolean checkProxyInterfaces) {\n-        final ClassLoader cl = classLoader;\n-\n-        if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {\n-            String pkg = this.getPackageName();\n-            if (!pkg.isEmpty()) {\n-                \/\/ skip the package access check on a proxy class in default proxy package\n-                if (!Proxy.isProxyClass(this) || ReflectUtil.isNonPublicProxyClass(this)) {\n-                    sm.checkPackageAccess(pkg);\n-                }\n-            }\n-        }\n-        \/\/ check package access on the proxy interfaces\n-        if (checkProxyInterfaces && Proxy.isProxyClass(this)) {\n-            ReflectUtil.checkProxyPackageAccess(ccl, this.getInterfaces(\/* cloneArray *\/ false));\n-        }\n-    }\n-\n-    \/*\n-     * Checks if a client loaded in ClassLoader ccl is allowed to access the provided\n-     * classes under the current package access policy. If access is denied,\n-     * throw a SecurityException.\n-     *\n-     * NOTE: this method should only be called if a SecurityManager is active\n-     *       classes must be non-empty\n-     *       all classes provided must be loaded by the same ClassLoader\n-     * NOTE: this method does not support Proxy classes\n-     *\/\n-    private static void checkPackageAccessForPermittedSubclasses(@SuppressWarnings(\"removal\") SecurityManager sm,\n-                                    final ClassLoader ccl, Class<?>[] subClasses) {\n-        final ClassLoader cl = subClasses[0].classLoader;\n-\n-        if (ReflectUtil.needsPackageAccessCheck(ccl, cl)) {\n-            Set<String> packages = new HashSet<>();\n-\n-            for (Class<?> c : subClasses) {\n-                if (Proxy.isProxyClass(c))\n-                    throw new InternalError(\"a permitted subclass should not be a proxy class: \" + c);\n-                String pkg = c.getPackageName();\n-                if (!pkg.isEmpty()) {\n-                    packages.add(pkg);\n-                }\n-            }\n-            for (String pkg : packages) {\n-                sm.checkPackageAccess(pkg);\n-            }\n-        }\n-    }\n-\n@@ -3735,1 +3419,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -3741,3 +3424,1 @@\n-        return reflectionFactory =\n-                java.security.AccessController.doPrivileged\n-                        (new ReflectionFactory.GetReflectionFactoryAction());\n+        return reflectionFactory = ReflectionFactory.getReflectionFactory();\n@@ -3769,1 +3450,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -3776,7 +3456,1 @@\n-                java.security.AccessController.doPrivileged(\n-                    new java.security.PrivilegedAction<>() {\n-                        public Void run() {\n-                                values.setAccessible(true);\n-                                return null;\n-                            }\n-                        });\n+                values.setAccessible(true);\n@@ -4163,1 +3837,0 @@\n-    @CallerSensitive\n@@ -4168,13 +3841,1 @@\n-\n-        Class<?> host = getNestHost0();\n-        if (host == this) {\n-            return this;\n-        }\n-        \/\/ returning a different class requires a security check\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            checkPackageAccess(sm,\n-                               ClassLoader.getClassLoader(Reflection.getCallerClass()), true);\n-        }\n-        return host;\n+        return getNestHost0();\n@@ -4247,1 +3908,0 @@\n-    @CallerSensitive\n@@ -4255,11 +3915,0 @@\n-\n-        if (members.length > 1) {\n-            \/\/ If we return anything other than the current class we need\n-            \/\/ a security check\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                checkPackageAccess(sm,\n-                                   ClassLoader.getClassLoader(Reflection.getCallerClass()), true);\n-            }\n-        }\n@@ -4435,1 +4084,0 @@\n-    @CallerSensitive\n@@ -4448,10 +4096,0 @@\n-        if (subClasses.length > 0) {\n-            \/\/ If we return some classes we need a security check:\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                checkPackageAccessForPermittedSubclasses(sm,\n-                                             ClassLoader.getClassLoader(Reflection.getCallerClass()),\n-                                             subClasses);\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":21,"deletions":383,"binary":false,"changes":404,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -67,1 +65,0 @@\n-import jdk.internal.module.ModuleBootstrap.IllegalNativeAccess;\n@@ -74,1 +71,0 @@\n-import sun.security.util.SecurityConstants;\n@@ -201,5 +197,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-        }\n@@ -1559,1 +1550,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1569,2 +1559,1 @@\n-                    PrivilegedAction<Class<?>> pa = this::loadModuleInfoClass;\n-                    clazz = AccessController.doPrivileged(pa);\n+                    clazz = loadModuleInfoClass();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import jdk.internal.javac.PreviewFeature;\n@@ -57,1 +56,0 @@\n-import sun.security.util.SecurityConstants;\n@@ -508,3 +506,0 @@\n-        checkCreateClassLoaderPermission();\n-        checkGetClassLoaderPermission();\n-\n@@ -575,3 +570,0 @@\n-        checkCreateClassLoaderPermission();\n-        checkGetClassLoaderPermission();\n-\n@@ -657,2 +649,0 @@\n-        checkGetClassLoaderPermission();\n-\n@@ -696,14 +686,0 @@\n-    private static void checkCreateClassLoaderPermission() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null)\n-            sm.checkPermission(SecurityConstants.CREATE_CLASSLOADER_PERMISSION);\n-    }\n-\n-    private static void checkGetClassLoaderPermission() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null)\n-            sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -420,3 +418,1 @@\n-            PrivilegedAction<ClassLoader> pa = module::getClassLoader;\n-            @SuppressWarnings(\"removal\")\n-            ClassLoader loader = AccessController.doPrivileged(pa);\n+            ClassLoader loader = module.getClassLoader();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Package.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.security.AccessController;\n@@ -91,4 +90,1 @@\n-        @SuppressWarnings(\"removal\")\n-        private static final ReflectionFactory reflectionFactory =\n-            AccessController.doPrivileged(\n-                new ReflectionFactory.GetReflectionFactoryAction());\n+        private static final ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/PublicMethods.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -110,3 +110,0 @@\n-     * @throws SecurityException If a security manager is present, and it\n-     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n-     *         from {@code caller} to the package of {@code implementation}.\n@@ -141,1 +138,1 @@\n-            this.implInfo = caller.revealDirect(implementation); \/\/ may throw SecurityException\n+            this.implInfo = caller.revealDirect(implementation);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.security.*;\n@@ -88,10 +87,7 @@\n-        @SuppressWarnings(\"removal\")\n-        Member mem = AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public Member run() {\n-                    try {\n-                        return reflectUnchecked();\n-                    } catch (ReflectiveOperationException ex) {\n-                        throw new IllegalArgumentException(ex);\n-                    }\n-                }\n-            });\n+\n+        Member mem;\n+        try {\n+            mem = reflectUnchecked();\n+        } catch (ReflectiveOperationException ex) {\n+            throw new IllegalArgumentException(ex);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InfoFromMemberName.java","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -86,1 +85,1 @@\n-        disableEagerInitialization = GetBooleanAction.privilegedGetProperty(disableEagerInitializationKey);\n+        disableEagerInitialization = Boolean.getBoolean(disableEagerInitializationKey);\n@@ -137,3 +136,0 @@\n-     * @throws SecurityException If a security manager is present, and it\n-     *         <a href=\"MethodHandles.Lookup.html#secmgr\">denies access<\/a>\n-     *         from {@code caller} to the package of {@code implementation}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1211,5 +1211,1 @@\n-            try {\n-                assert (hostClass.getProtectionDomain() == invokerClass.getProtectionDomain()) : hostClass.getName()+\" (PD)\";\n-            } catch (SecurityException ex) {\n-                \/\/ Self-check was blocked by security manager. This is OK.\n-            }\n+            assert (hostClass.getProtectionDomain() == invokerClass.getProtectionDomain()) : hostClass.getName()+\" (PD)\";\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -59,2 +57,0 @@\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n@@ -62,1 +58,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -162,1 +157,0 @@\n-    @CallerSensitive\n@@ -171,11 +165,1 @@\n-        final MethodHandle mh;\n-        @SuppressWarnings(\"removal\")\n-        var sm = System.getSecurityManager();\n-        if (sm != null) {\n-            final Class<?> caller = Reflection.getCallerClass();\n-            final ClassLoader ccl = caller != null ? caller.getClassLoader() : null;\n-            ReflectUtil.checkProxyPackageAccess(ccl, intfc);\n-            mh = ccl != null ? bindCaller(target, caller) : target;\n-        } else {\n-            mh = target;\n-        }\n+        final MethodHandle mh = target;\n@@ -286,11 +270,1 @@\n-        @SuppressWarnings(\"removal\")\n-        var sm = System.getSecurityManager();\n-        Lookup lookup;\n-        if (sm != null) {\n-            @SuppressWarnings(\"removal\")\n-            var l = AccessController.doPrivileged((PrivilegedAction<Lookup>) () ->\n-                    definer.defineClassAsLookup(true));\n-            lookup = l;\n-        } else {\n-            lookup = definer.defineClassAsLookup(true);\n-        }\n+        Lookup lookup = definer.defineClassAsLookup(true);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":2,"deletions":28,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -69,1 +68,1 @@\n-        Properties props = GetPropertyAction.privilegedGetProperties();\n+        Properties props = System.getProperties();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleStatics.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-import sun.reflect.misc.ReflectUtil;\n-import sun.security.util.SecurityConstants;\n@@ -246,3 +244,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) sm.checkPermission(SecurityConstants.ACCESS_PERMISSION);\n@@ -466,3 +461,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager smgr = System.getSecurityManager();\n-        if (smgr != null)  smgr.checkPermission(SecurityConstants.ACCESS_PERMISSION);\n@@ -744,2 +736,0 @@\n-     * <li>avoid <a href=\"MethodHandles.Lookup.html#secmgr\">package access checks<\/a>\n-     *     for classes accessible to the lookup class\n@@ -1762,1 +1752,0 @@\n-            ensureDefineClassPermission();\n@@ -1768,11 +1757,0 @@\n-        private void ensureDefineClassPermission() {\n-            if (allowedModes == TRUSTED)  return;\n-\n-            if (!hasFullPrivilegeAccess()) {\n-                @SuppressWarnings(\"removal\")\n-                SecurityManager sm = System.getSecurityManager();\n-                if (sm != null)\n-                    sm.checkPermission(new RuntimePermission(\"defineClass\"));\n-            }\n-        }\n-\n@@ -2045,1 +2023,0 @@\n-            ensureDefineClassPermission();\n@@ -2131,1 +2108,0 @@\n-            ensureDefineClassPermission();\n@@ -2771,1 +2747,0 @@\n-            checkSecurityManager(targetClass);\n@@ -2875,1 +2850,0 @@\n-            checkSecurityManager(targetClass);\n@@ -3295,1 +3269,1 @@\n-            return lookup.getDirectMethodNoSecurityManager(refKind, method.getDeclaringClass(), method, findBoundCallerLookup(method));\n+            return lookup.getDirectMethod(refKind, method.getDeclaringClass(), method, findBoundCallerLookup(method));\n@@ -3346,1 +3320,1 @@\n-            return specialLookup.getDirectMethodNoSecurityManager(REF_invokeSpecial, method.getDeclaringClass(), method, findBoundCallerLookup(method));\n+            return specialLookup.getDirectMethod(REF_invokeSpecial, method.getDeclaringClass(), method, findBoundCallerLookup(method));\n@@ -3378,1 +3352,1 @@\n-            return lookup.getDirectConstructorNoSecurityManager(ctor.getDeclaringClass(), ctor);\n+            return lookup.getDirectConstructor(ctor.getDeclaringClass(), ctor);\n@@ -3383,1 +3357,1 @@\n-         * and instantiated by the given constructor.  No security manager check.\n+         * and instantiated by the given constructor.\n@@ -3476,1 +3450,1 @@\n-            return lookup.getDirectFieldNoSecurityManager(field.getReferenceKind(), f.getDeclaringClass(), field);\n+            return lookup.getDirectField(field.getReferenceKind(), f.getDeclaringClass(), field);\n@@ -3553,2 +3527,2 @@\n-            return getFieldVarHandleNoSecurityManager(getField.getReferenceKind(), putField.getReferenceKind(),\n-                                                      f.getDeclaringClass(), getField, putField);\n+            return getFieldVarHandle(getField.getReferenceKind(), putField.getReferenceKind(),\n+                                     f.getDeclaringClass(), getField, putField);\n@@ -3589,1 +3563,1 @@\n-            \/\/ Check SM permissions and member access before cracking.\n+            \/\/ Check member access before cracking.\n@@ -3592,1 +3566,0 @@\n-                checkSecurityManager(defc, member);\n@@ -3719,63 +3692,0 @@\n-        \/**\n-         * Perform steps 1 and 2b <a href=\"MethodHandles.Lookup.html#secmgr\">access checks<\/a>\n-         * for ensureInitialized, findClass or accessClass.\n-         *\/\n-        void checkSecurityManager(Class<?> refc) {\n-            if (allowedModes == TRUSTED)  return;\n-\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager smgr = System.getSecurityManager();\n-            if (smgr == null)  return;\n-\n-            \/\/ Step 1:\n-            boolean fullPrivilegeLookup = hasFullPrivilegeAccess();\n-            if (!fullPrivilegeLookup ||\n-                !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {\n-                ReflectUtil.checkPackageAccess(refc);\n-            }\n-\n-            \/\/ Step 2b:\n-            if (!fullPrivilegeLookup) {\n-                smgr.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-            }\n-        }\n-\n-        \/**\n-         * Perform steps 1, 2a and 3 <a href=\"MethodHandles.Lookup.html#secmgr\">access checks<\/a>.\n-         * Determines a trustable caller class to compare with refc, the symbolic reference class.\n-         * If this lookup object has full privilege access except original access,\n-         * then the caller class is the lookupClass.\n-         *\n-         * Lookup object created by {@link MethodHandles#privateLookupIn(Class, Lookup)}\n-         * from the same module skips the security permission check.\n-         *\/\n-        void checkSecurityManager(Class<?> refc, MemberName m) {\n-            Objects.requireNonNull(refc);\n-            Objects.requireNonNull(m);\n-\n-            if (allowedModes == TRUSTED)  return;\n-\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager smgr = System.getSecurityManager();\n-            if (smgr == null)  return;\n-\n-            \/\/ Step 1:\n-            boolean fullPrivilegeLookup = hasFullPrivilegeAccess();\n-            if (!fullPrivilegeLookup ||\n-                !VerifyAccess.classLoaderIsAncestor(lookupClass, refc)) {\n-                ReflectUtil.checkPackageAccess(refc);\n-            }\n-\n-            \/\/ Step 2a:\n-            if (m.isPublic()) return;\n-            if (!fullPrivilegeLookup) {\n-                smgr.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);\n-            }\n-\n-            \/\/ Step 3:\n-            Class<?> defc = m.getDeclaringClass();\n-            if (!fullPrivilegeLookup && defc != refc) {\n-                ReflectUtil.checkPackageAccess(defc);\n-            }\n-        }\n-\n@@ -3921,2 +3831,1 @@\n-            final boolean checkSecurity = true;\n-            return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, callerLookup);\n+            return getDirectMethodCommon(refKind, refc, method, doRestrict, callerLookup);\n@@ -3927,8 +3836,1 @@\n-            final boolean checkSecurity = true;\n-            return getDirectMethodCommon(REF_invokeSpecial, refc, method, checkSecurity, doRestrict, callerLookup);\n-        }\n-        \/** Check access and get the requested method, eliding security manager checks. *\/\n-        private MethodHandle getDirectMethodNoSecurityManager(byte refKind, Class<?> refc, MemberName method, Lookup callerLookup) throws IllegalAccessException {\n-            final boolean doRestrict    = true;\n-            final boolean checkSecurity = false;  \/\/ not needed for reflection or for linking CONSTANT_MH constants\n-            return getDirectMethodCommon(refKind, refc, method, checkSecurity, doRestrict, callerLookup);\n+            return getDirectMethodCommon(REF_invokeSpecial, refc, method, doRestrict, callerLookup);\n@@ -3938,1 +3840,0 @@\n-                                                   boolean checkSecurity,\n@@ -3942,3 +3843,0 @@\n-            \/\/ Optionally check with the security manager; this isn't needed for unreflect* calls.\n-            if (checkSecurity)\n-                checkSecurityManager(refc, method);\n@@ -4013,7 +3911,1 @@\n-            final boolean checkSecurity = true;\n-            return getDirectFieldCommon(refKind, refc, field, checkSecurity);\n-        }\n-        \/** Check access and get the requested field, eliding security manager checks. *\/\n-        private MethodHandle getDirectFieldNoSecurityManager(byte refKind, Class<?> refc, MemberName field) throws IllegalAccessException {\n-            final boolean checkSecurity = false;  \/\/ not needed for reflection or for linking CONSTANT_MH constants\n-            return getDirectFieldCommon(refKind, refc, field, checkSecurity);\n+            return getDirectFieldCommon(refKind, refc, field);\n@@ -4022,2 +3914,1 @@\n-        private MethodHandle getDirectFieldCommon(byte refKind, Class<?> refc, MemberName field,\n-                                                  boolean checkSecurity) throws IllegalAccessException {\n+        private MethodHandle getDirectFieldCommon(byte refKind, Class<?> refc, MemberName field) throws IllegalAccessException {\n@@ -4025,3 +3916,0 @@\n-            \/\/ Optionally check with the security manager; this isn't needed for unreflect* calls.\n-            if (checkSecurity)\n-                checkSecurityManager(refc, field);\n@@ -4038,8 +3926,1 @@\n-            final boolean checkSecurity = true;\n-            return getFieldVarHandleCommon(getRefKind, putRefKind, refc, getField, putField, checkSecurity);\n-        }\n-        private VarHandle getFieldVarHandleNoSecurityManager(byte getRefKind, byte putRefKind,\n-                                                             Class<?> refc, MemberName getField, MemberName putField)\n-                throws IllegalAccessException {\n-            final boolean checkSecurity = false;\n-            return getFieldVarHandleCommon(getRefKind, putRefKind, refc, getField, putField, checkSecurity);\n+            return getFieldVarHandleCommon(getRefKind, putRefKind, refc, getField, putField);\n@@ -4048,2 +3929,2 @@\n-                                                  Class<?> refc, MemberName getField, MemberName putField,\n-                                                  boolean checkSecurity) throws IllegalAccessException {\n+                                                  Class<?> refc, MemberName getField,\n+                                                  MemberName putField) throws IllegalAccessException {\n@@ -4056,2 +3937,0 @@\n-            if (checkSecurity)\n-                checkSecurityManager(refc, getField);\n@@ -4065,2 +3944,0 @@\n-                if (checkSecurity)\n-                    checkSecurityManager(refc, putField);\n@@ -4084,7 +3961,1 @@\n-            final boolean checkSecurity = true;\n-            return getDirectConstructorCommon(refc, ctor, checkSecurity);\n-        }\n-        \/** Check access and get the requested constructor, eliding security manager checks. *\/\n-        private MethodHandle getDirectConstructorNoSecurityManager(Class<?> refc, MemberName ctor) throws IllegalAccessException {\n-            final boolean checkSecurity = false;  \/\/ not needed for reflection or for linking CONSTANT_MH constants\n-            return getDirectConstructorCommon(refc, ctor, checkSecurity);\n+            return getDirectConstructorCommon(refc, ctor);\n@@ -4093,2 +3964,1 @@\n-        private MethodHandle getDirectConstructorCommon(Class<?> refc, MemberName ctor,\n-                                                  boolean checkSecurity) throws IllegalAccessException {\n+        private MethodHandle getDirectConstructorCommon(Class<?> refc, MemberName ctor) throws IllegalAccessException {\n@@ -4097,3 +3967,0 @@\n-            \/\/ Optionally check with the security manager; this isn't needed for unreflect* calls.\n-            if (checkSecurity)\n-                checkSecurityManager(refc, ctor);\n@@ -4166,2 +4033,1 @@\n-            try {\n-                MemberName resolved2 = publicLookup().resolveOrNull(refKind,\n+            MemberName resolved2 = publicLookup().resolveOrNull(refKind,\n@@ -4169,5 +4035,1 @@\n-                if (resolved2 == null) {\n-                    return false;\n-                }\n-                checkSecurityManager(defc, resolved2);\n-            } catch (SecurityException ex) {\n+            if (resolved2 == null) {\n@@ -4181,1 +4043,1 @@\n-                return getDirectFieldNoSecurityManager(refKind, defc, member);\n+                return getDirectField(refKind, defc, member);\n@@ -4183,1 +4045,1 @@\n-                return getDirectMethodNoSecurityManager(refKind, defc, member, findBoundCallerLookup(member));\n+                return getDirectMethod(refKind, defc, member, findBoundCallerLookup(member));\n@@ -4185,1 +4047,1 @@\n-                return getDirectConstructorNoSecurityManager(defc, member);\n+                return getDirectConstructor(defc, member);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":22,"deletions":160,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.WeakReference;\n@@ -39,1 +36,0 @@\n-import java.util.NoSuchElementException;\n@@ -44,2 +40,0 @@\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.stream.Stream;\n@@ -53,1 +47,0 @@\n-import sun.security.util.SecurityConstants;\n@@ -1186,7 +1179,0 @@\n-        if (loader == null) {\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-            }\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -268,10 +265,2 @@\n-            @SuppressWarnings(\"removal\")\n-            Method deserialize = AccessController.doPrivileged(new PrivilegedExceptionAction<>() {\n-                @Override\n-                public Method run() throws Exception {\n-                    Method m = capturingClass.getDeclaredMethod(\"$deserializeLambda$\", SerializedLambda.class);\n-                    m.setAccessible(true);\n-                    return m;\n-                }\n-            });\n-\n+            Method deserialize = capturingClass.getDeclaredMethod(\"$deserializeLambda$\", SerializedLambda.class);\n+            deserialize.setAccessible(true);\n@@ -281,6 +270,0 @@\n-        } catch (PrivilegedActionException e) {\n-            Exception cause = e.getException();\n-            if (cause instanceof RuntimeException re)\n-                throw re;\n-            else\n-                throw new RuntimeException(\"Exception in SerializedLambda.readResolve\", e);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/SerializedLambda.java","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.security.AccessController;\n@@ -38,2 +37,0 @@\n-import sun.security.action.GetPropertyAction;\n-import sun.security.util.SecurityConstants;\n@@ -84,11 +81,0 @@\n-    static void checkPermission() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            \/\/ SecurityConstants.ACCESS_PERMISSION is used to check\n-            \/\/ whether a client has sufficient privilege to defeat Java\n-            \/\/ language access control checks.\n-            sm.checkPermission(SecurityConstants.ACCESS_PERMISSION);\n-        }\n-    }\n-\n@@ -117,1 +103,0 @@\n-        checkPermission();\n@@ -199,1 +184,0 @@\n-        AccessibleObject.checkPermission();\n@@ -260,2 +244,0 @@\n-        AccessibleObject.checkPermission();\n-\n@@ -505,4 +487,1 @@\n-    @SuppressWarnings(\"removal\")\n-    static final ReflectionFactory reflectionFactory =\n-        AccessController.doPrivileged(\n-            new ReflectionFactory.GetReflectionFactoryAction());\n+    static final ReflectionFactory reflectionFactory = ReflectionFactory.getReflectionFactory();\n@@ -626,2 +605,1 @@\n-    \/\/ always succeed (it is not affected by the granting or revoking\n-    \/\/ of permissions); we speed up the check in the common case by\n+    \/\/ always succeed; we speed up the check in the common case by\n@@ -759,2 +737,1 @@\n-            String s = GetPropertyAction.privilegedGetProperty(\n-                    \"sun.reflect.debugModuleAccessChecks\");\n+            String s = System.getProperty(\"sun.reflect.debugModuleAccessChecks\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/AccessibleObject.java","additions":3,"deletions":26,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -184,1 +184,0 @@\n-        AccessibleObject.checkPermission();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -173,1 +173,0 @@\n-        AccessibleObject.checkPermission();\n@@ -1158,1 +1157,0 @@\n-    \/\/ security check is done before calling this method\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Field.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,1 +176,0 @@\n-        AccessibleObject.checkPermission();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -55,2 +53,0 @@\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n@@ -60,2 +56,0 @@\n-import sun.security.action.GetPropertyAction;\n-import sun.security.util.SecurityConstants;\n@@ -369,1 +363,0 @@\n-    @CallerSensitive\n@@ -374,6 +367,1 @@\n-        @SuppressWarnings(\"removal\")\n-        Class<?> caller = System.getSecurityManager() == null\n-                              ? null\n-                              : Reflection.getCallerClass();\n-\n-        return getProxyConstructor(caller, loader, interfaces)\n+        return getProxyConstructor(loader, interfaces)\n@@ -389,3 +377,0 @@\n-     * @param   caller passed from a public-facing @CallerSensitive method if\n-     *                 SecurityManager is set or {@code null} if there's no\n-     *                 SecurityManager\n@@ -398,2 +383,1 @@\n-    private static Constructor<?> getProxyConstructor(Class<?> caller,\n-                                                      ClassLoader loader,\n+    private static Constructor<?> getProxyConstructor(ClassLoader loader,\n@@ -405,3 +389,0 @@\n-            if (caller != null) {\n-                checkProxyAccess(caller, loader, intf);\n-            }\n@@ -415,3 +396,0 @@\n-            if (caller != null) {\n-                checkProxyAccess(caller, loader, intfsArray);\n-            }\n@@ -426,33 +404,0 @@\n-    \/*\n-     * Check permissions required to create a Proxy class.\n-     *\n-     * To define a proxy class, it performs the access checks as in\n-     * Class.forName (VM will invoke ClassLoader.checkPackageAccess):\n-     * 1. \"getClassLoader\" permission check if loader == null\n-     * 2. checkPackageAccess on the interfaces it implements\n-     *\n-     * To get a constructor and new instance of a proxy class, it performs\n-     * the package access check on the interfaces it implements\n-     * as in Class.getConstructor.\n-     *\n-     * If an interface is non-public, the proxy class must be defined by\n-     * the defining loader of the interface.  If the caller's class loader\n-     * is not the same as the defining loader of the interface, the VM\n-     * will throw IllegalAccessError when the generated proxy class is\n-     * being defined.\n-     *\/\n-    private static void checkProxyAccess(Class<?> caller,\n-                                         ClassLoader loader,\n-                                         Class<?> ... interfaces)\n-    {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            ClassLoader ccl = caller.getClassLoader();\n-            if (loader == null && ccl != null) {\n-                sm.checkPermission(SecurityConstants.GET_CLASSLOADER_PERMISSION);\n-            }\n-            ReflectUtil.checkProxyPackageAccess(ccl, interfaces);\n-        }\n-    }\n-\n@@ -519,1 +464,1 @@\n-            ClassLoader loader = getLoader(context.module());\n+            ClassLoader loader = context.module().getClassLoader();\n@@ -589,2 +534,1 @@\n-        private static final String DEBUG =\n-            GetPropertyAction.privilegedGetProperty(\"jdk.proxy.debug\", \"\");\n+        private static final String DEBUG = System.getProperty(\"jdk.proxy.debug\", \"\");\n@@ -621,1 +565,1 @@\n-            assert getLoader(context.module()) == loader;\n+            assert context.module().getClassLoader() == loader;\n@@ -633,3 +577,0 @@\n-         *\n-         * Must call the checkProxyAccess method to perform permission checks\n-         * before calling this.\n@@ -637,1 +578,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -647,6 +587,1 @@\n-            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                public Void run() {\n-                    cons.setAccessible(true);\n-                    return null;\n-                }\n-            });\n+            cons.setAccessible(true);\n@@ -791,1 +726,1 @@\n-                    if (getLoader(m) != loader) {\n+                    if (m.getClassLoader() != loader) {\n@@ -982,1 +917,0 @@\n-    @CallerSensitive\n@@ -988,5 +922,0 @@\n-        @SuppressWarnings(\"removal\")\n-        final Class<?> caller = System.getSecurityManager() == null\n-                                    ? null\n-                                    : Reflection.getCallerClass();\n-\n@@ -996,1 +925,1 @@\n-        Constructor<?> cons = getProxyConstructor(caller, loader, interfaces);\n+        Constructor<?> cons = getProxyConstructor(loader, interfaces);\n@@ -998,1 +927,1 @@\n-        return newProxyInstance(caller, cons, h);\n+        return newProxyInstance(cons, h);\n@@ -1001,3 +930,1 @@\n-    private static Object newProxyInstance(Class<?> caller, \/\/ null if no SecurityManager\n-                                           Constructor<?> cons,\n-                                           InvocationHandler h) {\n+    private static Object newProxyInstance(Constructor<?> cons, InvocationHandler h) {\n@@ -1008,4 +935,0 @@\n-            if (caller != null) {\n-                checkNewProxyPermission(caller, cons.getDeclaringClass());\n-            }\n-\n@@ -1025,29 +948,0 @@\n-    private static void checkNewProxyPermission(Class<?> caller, Class<?> proxyClass) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            if (ReflectUtil.isNonPublicProxyClass(proxyClass)) {\n-                ClassLoader ccl = caller.getClassLoader();\n-                ClassLoader pcl = proxyClass.getClassLoader();\n-\n-                \/\/ do permission check if the caller is in a different runtime package\n-                \/\/ of the proxy class\n-                String pkg = proxyClass.getPackageName();\n-                String callerPkg = caller.getPackageName();\n-\n-                if (pcl != ccl || !pkg.equals(callerPkg)) {\n-                    sm.checkPermission(new ReflectPermission(\"newProxyInPackage.\" + pkg));\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Returns the class loader for the given module.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    private static ClassLoader getLoader(Module m) {\n-        PrivilegedAction<ClassLoader> pa = m::getClassLoader;\n-        return AccessController.doPrivileged(pa);\n-    }\n-\n@@ -1078,2 +972,0 @@\n-    @SuppressWarnings(\"removal\")\n-    @CallerSensitive\n@@ -1092,10 +984,0 @@\n-        if (System.getSecurityManager() != null) {\n-            Class<?> ihClass = ih.getClass();\n-            Class<?> caller = Reflection.getCallerClass();\n-            if (ReflectUtil.needsPackageAccessCheck(caller.getClassLoader(),\n-                                                    ihClass.getClassLoader()))\n-            {\n-                ReflectUtil.checkPackageAccess(ihClass);\n-            }\n-        }\n-\n@@ -1252,1 +1134,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1254,12 +1135,7 @@\n-        return AccessController.doPrivileged(new PrivilegedAction<>() {\n-            @Override\n-            public MethodHandles.Lookup run() {\n-                try {\n-                    Method m = proxyClass.getDeclaredMethod(\"proxyClassLookup\", MethodHandles.Lookup.class);\n-                    m.setAccessible(true);\n-                    return (MethodHandles.Lookup) m.invoke(null, caller);\n-                } catch (ReflectiveOperationException e) {\n-                    throw new InternalError(e);\n-                }\n-            }\n-        });\n+        try {\n+            Method m = proxyClass.getDeclaredMethod(\"proxyClassLookup\", MethodHandles.Lookup.class);\n+            m.setAccessible(true);\n+            return (MethodHandles.Lookup) m.invoke(null, caller);\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":17,"deletions":141,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -109,3 +108,2 @@\n-            java.security.AccessController.doPrivileged(\n-                    new GetBooleanAction(\n-                            \"jdk.proxy.ProxyGenerator.saveGeneratedFiles\"));\n+            Boolean.getBoolean(\"jdk.proxy.ProxyGenerator.saveGeneratedFiles\");\n+\n@@ -218,21 +216,15 @@\n-            java.security.AccessController.doPrivileged(\n-                    new java.security.PrivilegedAction<Void>() {\n-                        public Void run() {\n-                            try {\n-                                int i = name.lastIndexOf('.');\n-                                Path path;\n-                                if (i > 0) {\n-                                    Path dir = Path.of(name.substring(0, i).replace('.', '\/'));\n-                                    Files.createDirectories(dir);\n-                                    path = dir.resolve(name.substring(i + 1) + \".class\");\n-                                } else {\n-                                    path = Path.of(name + \".class\");\n-                                }\n-                                Files.write(path, classFile);\n-                                return null;\n-                            } catch (IOException e) {\n-                                throw new InternalError(\n-                                        \"I\/O exception saving generated file: \" + e);\n-                            }\n-                        }\n-                    });\n+            try {\n+                int i = name.lastIndexOf('.');\n+                Path path;\n+                if (i > 0) {\n+                    Path dir = Path.of(name.substring(0, i).replace('.', '\/'));\n+                    Files.createDirectories(dir);\n+                    path = dir.resolve(name.substring(i + 1) + \".class\");\n+                } else {\n+                    path = Path.of(name + \".class\");\n+                }\n+                Files.write(path, classFile);\n+                return null;\n+            } catch (IOException e) {\n+                throw new InternalError(\"I\/O exception saving generated file: \" + e);\n+            }\n@@ -568,5 +560,0 @@\n-     * Discussion: Currently, for Proxy to work with SecurityManager,\n-     * we rely on the parameter classes of the methods to be computed\n-     * from Proxy instead of via user code paths like bootstrap method\n-     * lazy evaluation. That might change if we can pass in the live\n-     * Method objects directly..\n@@ -789,3 +776,0 @@\n-         * The generated code must be run in an AccessController.doPrivileged\n-         * block if a SecurityManager is present, as otherwise the code\n-         * cannot pass {@code null} ClassLoader to forName.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":17,"deletions":33,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -38,5 +38,0 @@\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n@@ -399,4 +394,0 @@\n-    \/\/ The access control context taken when the ServiceLoader is created\n-    @SuppressWarnings(\"removal\")\n-    private final AccessControlContext acc;\n-\n@@ -465,1 +456,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -476,3 +466,0 @@\n-        this.acc = (System.getSecurityManager() != null)\n-                ? AccessController.getContext()\n-                : null;\n@@ -489,1 +476,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -518,3 +504,0 @@\n-        this.acc = (System.getSecurityManager() != null)\n-                ? AccessController.getContext()\n-                : null;\n@@ -532,1 +515,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -542,3 +524,0 @@\n-        this.acc = (System.getSecurityManager() != null)\n-                ? AccessController.getContext()\n-                : null;\n@@ -604,1 +583,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -631,6 +609,1 @@\n-            Method m = result;\n-            PrivilegedAction<Void> pa = () -> {\n-                m.setAccessible(true);\n-                return null;\n-            };\n-            AccessController.doPrivileged(pa);\n+            result.setAccessible(true);\n@@ -647,1 +620,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -649,10 +621,0 @@\n-        PrivilegedExceptionAction<Constructor<?>> pa\n-            = new PrivilegedExceptionAction<>() {\n-                @Override\n-                public Constructor<?> run() throws Exception {\n-                    Constructor<?> ctor = clazz.getConstructor();\n-                    if (inExplicitModule(clazz))\n-                        ctor.setAccessible(true);\n-                    return ctor;\n-                }\n-            };\n@@ -661,4 +623,2 @@\n-            ctor = AccessController.doPrivileged(pa);\n-        } catch (Throwable x) {\n-            if (x instanceof PrivilegedActionException)\n-                x = x.getCause();\n+            ctor = clazz.getConstructor();\n+        } catch (NoSuchMethodException ex) {\n@@ -666,1 +626,1 @@\n-            fail(service, cn + \" Unable to get public no-arg constructor\", x);\n+            fail(service, cn + \" Unable to get public no-arg constructor\", ex);\n@@ -668,0 +628,2 @@\n+        if (inExplicitModule(clazz))\n+            ctor.setAccessible(true);\n@@ -681,2 +643,0 @@\n-        @SuppressWarnings(\"removal\")\n-        final AccessControlContext acc;\n@@ -686,2 +646,1 @@\n-                     Method factoryMethod,\n-                     @SuppressWarnings(\"removal\") AccessControlContext acc) {\n+                     Method factoryMethod) {\n@@ -692,1 +651,0 @@\n-            this.acc = acc;\n@@ -697,2 +655,1 @@\n-                     Constructor<? extends S> ctor,\n-                     @SuppressWarnings(\"removal\") AccessControlContext acc) {\n+                     Constructor<? extends S> ctor) {\n@@ -703,1 +660,0 @@\n-            this.acc = acc;\n@@ -726,1 +682,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -729,27 +684,6 @@\n-            Throwable exc = null;\n-            if (acc == null) {\n-                try {\n-                    result = factoryMethod.invoke(null);\n-                } catch (Throwable x) {\n-                    exc = x;\n-                }\n-            } else {\n-                PrivilegedExceptionAction<?> pa = new PrivilegedExceptionAction<>() {\n-                    @Override\n-                    public Object run() throws Exception {\n-                        return factoryMethod.invoke(null);\n-                    }\n-                };\n-                \/\/ invoke factory method with permissions restricted by acc\n-                try {\n-                    result = AccessController.doPrivileged(pa, acc);\n-                } catch (Throwable x) {\n-                    if (x instanceof PrivilegedActionException)\n-                        x = x.getCause();\n-                    exc = x;\n-                }\n-            }\n-            if (exc != null) {\n-                if (exc instanceof InvocationTargetException)\n-                    exc = exc.getCause();\n-                fail(service, factoryMethod + \" failed\", exc);\n+            try {\n+                result = factoryMethod.invoke(null);\n+            } catch (Throwable ex) {\n+                if (ex instanceof InvocationTargetException)\n+                    ex = ex.getCause();\n+                fail(service, factoryMethod + \" failed\", ex);\n@@ -770,1 +704,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -773,26 +706,5 @@\n-            Throwable exc = null;\n-            if (acc == null) {\n-                try {\n-                    p = ctor.newInstance();\n-                } catch (Throwable x) {\n-                    exc = x;\n-                }\n-            } else {\n-                PrivilegedExceptionAction<S> pa = new PrivilegedExceptionAction<>() {\n-                    @Override\n-                    public S run() throws Exception {\n-                        return ctor.newInstance();\n-                    }\n-                };\n-                \/\/ invoke constructor with permissions restricted by acc\n-                try {\n-                    p = AccessController.doPrivileged(pa, acc);\n-                } catch (Throwable x) {\n-                    if (x instanceof PrivilegedActionException)\n-                        x = x.getCause();\n-                    exc = x;\n-                }\n-            }\n-            if (exc != null) {\n-                if (exc instanceof InvocationTargetException)\n-                    exc = exc.getCause();\n+            try {\n+                p = ctor.newInstance();\n+            } catch (Throwable ex) {\n+                if (ex instanceof InvocationTargetException)\n+                    ex = ex.getCause();\n@@ -801,1 +713,1 @@\n-                     \"Provider \" + cn + \" could not be instantiated\", exc);\n+                     \"Provider \" + cn + \" could not be instantiated\", ex);\n@@ -812,1 +724,1 @@\n-            return Objects.hash(service, type, acc);\n+            return Objects.hash(service, type);\n@@ -819,2 +731,1 @@\n-                    && this.type == that.type\n-                    && Objects.equals(this.acc, that.acc);\n+                    && this.type == that.type;\n@@ -834,1 +745,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -844,16 +754,4 @@\n-        if (acc == null) {\n-            try {\n-                clazz = Class.forName(module, cn);\n-            } catch (LinkageError e) {\n-                fail(service, \"Unable to load \" + cn, e);\n-            }\n-        } else {\n-            PrivilegedExceptionAction<Class<?>> pa = () -> Class.forName(module, cn);\n-            try {\n-                clazz = AccessController.doPrivileged(pa);\n-            } catch (Throwable x) {\n-                if (x instanceof PrivilegedActionException)\n-                    x = x.getCause();\n-                fail(service, \"Unable to load \" + cn, x);\n-                return null;\n-            }\n+        try {\n+            clazz = Class.forName(module, cn);\n+        } catch (LinkageError e) {\n+            fail(service, \"Unable to load \" + cn, e);\n@@ -881,1 +779,1 @@\n-                return new ProviderImpl<S>(service, type, factoryMethod, acc);\n+                return new ProviderImpl<S>(service, type, factoryMethod);\n@@ -894,1 +792,1 @@\n-        return new ProviderImpl<S>(service, type, ctor, acc);\n+        return new ProviderImpl<S>(service, type, ctor);\n@@ -1000,14 +898,0 @@\n-        \/**\n-         * Returns the class loader that a module is defined to\n-         *\/\n-        @SuppressWarnings(\"removal\")\n-        private ClassLoader loaderFor(Module module) {\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm == null) {\n-                return module.getClassLoader();\n-            } else {\n-                PrivilegedAction<ClassLoader> pa = module::getClassLoader;\n-                return AccessController.doPrivileged(pa);\n-            }\n-        }\n-\n@@ -1044,1 +928,1 @@\n-                        ClassLoader l = loaderFor(sp.module());\n+                        ClassLoader l = sp.module().getClassLoader();\n@@ -1228,1 +1112,1 @@\n-                        ProviderImpl<S> p = new ProviderImpl<S>(service, type, ctor, acc);\n+                        ProviderImpl<S> p = new ProviderImpl<S>(service, type, ctor);\n@@ -1256,1 +1140,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -1259,8 +1142,1 @@\n-            if (acc == null) {\n-                return hasNextService();\n-            } else {\n-                PrivilegedAction<Boolean> action = new PrivilegedAction<>() {\n-                    public Boolean run() { return hasNextService(); }\n-                };\n-                return AccessController.doPrivileged(action, acc);\n-            }\n+            return hasNextService();\n@@ -1269,1 +1145,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -1272,8 +1147,1 @@\n-            if (acc == null) {\n-                return nextService();\n-            } else {\n-                PrivilegedAction<Provider<T>> action = new PrivilegedAction<>() {\n-                    public Provider<T> run() { return nextService(); }\n-                };\n-                return AccessController.doPrivileged(action, acc);\n-            }\n+            return nextService();\n","filename":"src\/java.base\/share\/classes\/java\/util\/ServiceLoader.java","additions":32,"deletions":164,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -323,9 +321,2 @@\n-            @SuppressWarnings(\"removal\")\n-            MethodType mt = AccessController.doPrivileged(new PrivilegedAction<>() {\n-                @Override\n-                public MethodType run() {\n-                    return MethodType.fromMethodDescriptorString(descriptorString(),\n-                        lookup.lookupClass().getClassLoader());\n-                }\n-            });\n-            mtype = mt;\n+            mtype = MethodType.fromMethodDescriptorString(descriptorString(),\n+                    lookup.lookupClass().getClassLoader());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import java.util.Properties;\n@@ -48,2 +47,0 @@\n-import sun.security.action.GetPropertyAction;\n-import sun.security.util.SecurityConstants;\n@@ -96,6 +93,0 @@\n-     * <p> First, if there is a security manager, its\n-     * <code>checkPermission<\/code> method is called with a {@link\n-     * java.lang.RuntimePermission} with target\n-     * <code>\"reflectionFactoryAccess\"<\/code>.  This may result in a\n-     * security exception.\n-     *\n@@ -106,4 +97,1 @@\n-     *\n-     * @exception SecurityException if a security manager exists and its\n-     *             <code>checkPermission<\/code> method doesn't allow\n-     *             access to the RuntimePermission \"reflectionFactoryAccess\".  *\/\n+     *\/\n@@ -111,6 +99,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(\n-                SecurityConstants.REFLECTION_FACTORY_ACCESS_PERMISSION);\n-        }\n@@ -552,1 +534,0 @@\n-        Properties props = GetPropertyAction.privilegedGetProperties();\n@@ -554,1 +535,1 @@\n-            \"true\".equals(props.getProperty(\"jdk.reflect.useNativeAccessorOnly\"));\n+            \"true\".equals(System.getProperty(\"jdk.reflect.useNativeAccessorOnly\"));\n@@ -556,1 +537,1 @@\n-            \"true\".equals(props.getProperty(\"jdk.disableSerialConstructorChecks\"));\n+            \"true\".equals(System.getProperty(\"jdk.disableSerialConstructorChecks\"));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -314,2 +314,0 @@\n-        \/\/ We use doPrivileged in order to allow an unprivileged caller to ask an arbitrary\n-        \/\/ class loader about the binding of the proposed name (type.getName()).\n@@ -323,11 +321,6 @@\n-        @SuppressWarnings(\"removal\")\n-        Class<?> res = java.security.AccessController.doPrivileged(\n-                new java.security.PrivilegedAction<>() {\n-                    public Class<?> run() {\n-                        try {\n-                            return Class.forName(name, false, refcLoader);\n-                        } catch (ClassNotFoundException | LinkageError e) {\n-                            return null; \/\/ Assume the class is not found\n-                        }\n-                    }\n-            });\n+        Class<?> res = null;\n+        try {\n+            res = Class.forName(name, false, refcLoader);\n+        } catch (ClassNotFoundException | LinkageError e) {\n+            \/\/ Assume the class is not found\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/VerifyAccess.java","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-\n@@ -34,1 +33,0 @@\n-import sun.security.util.SecurityConstants;\n@@ -41,3 +39,1 @@\n-    public static Class<?> forName(String name)\n-        throws ClassNotFoundException {\n-        checkPackageAccess(name);\n+    public static Class<?> forName(String name) throws ClassNotFoundException {\n@@ -76,7 +72,1 @@\n-     * Does a conservative approximation of member access check. Use this if\n-     * you don't have an actual 'userland' caller Class\/ClassLoader available.\n-     * This might be more restrictive than a precise member access check where\n-     * you have a caller, but should never allow a member access that is\n-     * forbidden.\n-     *\n-     * @param m the {@code Member} about to be accessed\n+     * Does nothing.\n@@ -84,24 +74,1 @@\n-    public static void conservativeCheckMemberAccess(Member m) throws SecurityException{\n-        @SuppressWarnings(\"removal\")\n-        final SecurityManager sm = System.getSecurityManager();\n-        if (sm == null)\n-            return;\n-\n-        \/\/ Check for package access on the declaring class.\n-        \/\/\n-        \/\/ In addition, unless the member and the declaring class are both\n-        \/\/ public check for access declared member permissions.\n-        \/\/\n-        \/\/ This is done regardless of ClassLoader relations between the {@code\n-        \/\/ Member m} and any potential caller.\n-\n-        final Class<?> declaringClass = m.getDeclaringClass();\n-\n-        privateCheckPackageAccess(sm, declaringClass);\n-\n-        if (Modifier.isPublic(m.getModifiers()) &&\n-                Modifier.isPublic(declaringClass.getModifiers()))\n-            return;\n-\n-        \/\/ Check for declared member access.\n-        sm.checkPermission(SecurityConstants.CHECK_MEMBER_ACCESS_PERMISSION);\n+    public static void conservativeCheckMemberAccess(Member m) {\n@@ -111,5 +78,1 @@\n-     * Checks package access on the given class.\n-     *\n-     * If it is a {@link Proxy#isProxyClass(java.lang.Class)} that implements\n-     * a non-public interface (i.e. may be in a non-restricted package),\n-     * also check the package access on the proxy interfaces.\n+     * Does nothing.\n@@ -118,5 +81,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager s = System.getSecurityManager();\n-        if (s != null) {\n-            privateCheckPackageAccess(s, clazz);\n-        }\n@@ -126,1 +84,1 @@\n-     * NOTE: should only be called if a SecurityManager is installed\n+     * Does nothing\n@@ -128,9 +86,1 @@\n-    private static void privateCheckPackageAccess(@SuppressWarnings(\"removal\") SecurityManager s, Class<?> clazz) {\n-        String pkg = clazz.getPackageName();\n-        if (!pkg.isEmpty()) {\n-            s.checkPackageAccess(pkg);\n-        }\n-\n-        if (isNonPublicProxyClass(clazz)) {\n-            privateCheckProxyPackageAccess(s, clazz);\n-        }\n+    public static void checkPackageAccess(String name) {\n@@ -140,4 +90,1 @@\n-     * Checks package access on the given classname.\n-     * This method is typically called when the Class instance is not\n-     * available and the caller attempts to load a class on behalf\n-     * the true caller (application).\n+     * Returns true.\n@@ -145,18 +92,0 @@\n-    public static void checkPackageAccess(String name) {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager s = System.getSecurityManager();\n-        if (s != null) {\n-            String cname = name.replace('\/', '.');\n-            if (cname.startsWith(\"[\")) {\n-                int b = cname.lastIndexOf('[') + 2;\n-                if (b > 1 && b < cname.length()) {\n-                    cname = cname.substring(b);\n-                }\n-            }\n-            int i = cname.lastIndexOf('.');\n-            if (i != -1) {\n-                s.checkPackageAccess(cname.substring(0, i));\n-            }\n-        }\n-    }\n-\n@@ -164,5 +93,0 @@\n-        try {\n-            checkPackageAccess(clazz);\n-        } catch (SecurityException e) {\n-            return false;\n-        }\n@@ -172,13 +96,0 @@\n-    \/\/ Returns true if p is an ancestor of cl i.e. class loader 'p' can\n-    \/\/ be found in the cl's delegation chain\n-    private static boolean isAncestor(ClassLoader p, ClassLoader cl) {\n-        ClassLoader acl = cl;\n-        do {\n-            acl = acl.getParent();\n-            if (p == acl) {\n-                return true;\n-            }\n-        } while (acl != null);\n-        return false;\n-    }\n-\n@@ -186,9 +97,1 @@\n-     * Returns true if package access check is needed for reflective\n-     * access from a class loader 'from' to classes or members in\n-     * a class defined by class loader 'to'.  This method returns true\n-     * if 'from' is not the same as or an ancestor of 'to'.  All code\n-     * in a system domain are granted with all permission and so this\n-     * method returns false if 'from' class loader is a class loader\n-     * loading system classes.  On the other hand, if a class loader\n-     * attempts to access system domain classes, it requires package\n-     * access check and this method will return true.\n+     * Returns false.\n@@ -197,7 +100,1 @@\n-        if (from == null || from == to)\n-            return false;\n-\n-        if (to == null)\n-            return true;\n-\n-        return !isAncestor(from, to);\n+        return false;\n@@ -207,4 +104,1 @@\n-     * Check package access on the proxy interfaces that the given proxy class\n-     * implements.\n-     *\n-     * @param clazz Proxy class object\n+     * Does nothing\n@@ -213,5 +107,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager s = System.getSecurityManager();\n-        if (s != null) {\n-            privateCheckProxyPackageAccess(s, clazz);\n-        }\n@@ -221,17 +110,1 @@\n-     * NOTE: should only be called if a SecurityManager is installed\n-     *\/\n-    private static void privateCheckProxyPackageAccess(@SuppressWarnings(\"removal\") SecurityManager s, Class<?> clazz) {\n-        \/\/ check proxy interfaces if the given class is a proxy class\n-        if (Proxy.isProxyClass(clazz)) {\n-            for (Class<?> intf : clazz.getInterfaces()) {\n-                privateCheckPackageAccess(s, intf);\n-            }\n-        }\n-    }\n-    \/**\n-     * Access check on the interfaces that a proxy class implements and throw\n-     * {@code SecurityException} if it accesses a restricted package from\n-     * the caller's class loader.\n-     *\n-     * @param ccl the caller's class loader\n-     * @param interfaces the list of interfaces that a proxy class implements\n+     * Does nothing.\n@@ -240,12 +113,1 @@\n-                                               Class<?>... interfaces)\n-    {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            for (Class<?> intf : interfaces) {\n-                ClassLoader cl = intf.getClassLoader();\n-                if (needsPackageAccessCheck(ccl, cl)) {\n-                    privateCheckPackageAccess(sm, intf);\n-                }\n-            }\n-        }\n+                                               Class<?>... interfaces) {\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/ReflectUtil.java","additions":13,"deletions":151,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-                    .shouldContain(\"Skipping java\/lang\/invoke\/BoundMethodHandle$Species_LLLL because it is dynamically generated\");\n+                .shouldHaveExitValue(0);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/StaticArchiveWithLambda.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}