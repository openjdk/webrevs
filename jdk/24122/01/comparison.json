{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,61 +25,1 @@\n-\/*\n- * @summary Simple jar builder\n- *   Input: jarName className1 className2 ...\n- *     do not specify extensions, just the names\n- *     E.g. prot_domain ProtDomainA ProtDomainB\n- *   Output: A jar containing compiled classes, placed in a test classes folder\n- * @library \/open\/test\/lib\n- *\/\n-\n-import jdk.test.lib.JDKToolFinder;\n-import jdk.test.lib.cds.CDSTestUtils;\n-import jdk.test.lib.compiler.CompilerUtils;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.helpers.ClassFileInstaller;\n-import java.io.File;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.spi.ToolProvider;\n-\n-public class JarBuilder {\n-    \/\/ to turn DEBUG on via command line: -DJarBuilder.DEBUG=[true, TRUE]\n-    private static final boolean DEBUG = Boolean.parseBoolean(System.getProperty(\"JarBuilder.DEBUG\", \"false\"));\n-    private static final String classDir = System.getProperty(\"test.classes\");\n-    private static final ToolProvider JAR = ToolProvider.findFirst(\"jar\")\n-        .orElseThrow(() -> new RuntimeException(\"ToolProvider for jar not found\"));\n-\n-    public static String getJarFilePath(String jarName) {\n-        return CDSTestUtils.getOutputDir() +  File.separator + jarName + \".jar\";\n-    }\n-\n-    \/\/ jar all files under dir, with manifest file man, with an optional versionArgs\n-    \/\/ for generating a multi-release jar.\n-    \/\/ The jar command is as follows:\n-    \/\/ jar cmf \\\n-    \/\/  <path to output jar> <path to the manifest file>\\\n-    \/\/   -C <path to the base classes> .\\\n-    \/\/    --release 9 -C <path to the versioned classes> .\n-    \/\/ the last line begins with \"--release\" corresponds to the optional versionArgs.\n-    public static String build(String jarName, File dir, String man, String ...versionArgs)\n-        throws Exception {\n-        ArrayList<String> args = new ArrayList<String>();\n-        if (man != null) {\n-            args.add(\"cfm\");\n-        } else {\n-            args.add(\"cf\");\n-        }\n-        String jarFile = getJarFilePath(jarName);\n-        args.add(jarFile);\n-        if (man != null) {\n-            args.add(man);\n-        }\n-        args.add(\"-C\");\n-        args.add(dir.getAbsolutePath());\n-        args.add(\".\");\n-        for (String verArg : versionArgs) {\n-            args.add(verArg);\n-        }\n-        createJar(args);\n-        return jarFile;\n-    }\n+import jdk.test.lib.cds.CDSJarUtils;\n@@ -87,67 +27,0 @@\n-    public static String build(String jarName, String ...classNames)\n-        throws Exception {\n-\n-        return createSimpleJar(classDir, getJarFilePath(jarName), classNames);\n-    }\n-\n-    public static String build(boolean classesInWorkDir, String jarName, String ...classNames)\n-        throws Exception {\n-        if (classesInWorkDir) {\n-            return createSimpleJar(\".\", getJarFilePath(jarName), classNames);\n-        } else {\n-            return build(jarName, classNames);\n-        }\n-    }\n-\n-\n-    public static String buildWithManifest(String jarName, String manifest,\n-        String jarClassesDir, String ...classNames) throws Exception {\n-        String jarPath = getJarFilePath(jarName);\n-        ArrayList<String> args = new ArrayList<String>();\n-        args.add(\"cvfm\");\n-        args.add(jarPath);\n-        args.add(System.getProperty(\"test.src\") + File.separator + \"test-classes\"\n-            + File.separator + manifest);\n-        addClassArgs(args, jarClassesDir, classNames);\n-        createJar(args);\n-\n-        return jarPath;\n-    }\n-\n-\n-    \/\/ Execute: jar uvf $jarFile -C $dir .\n-    static void update(String jarFile, String dir) throws Exception {\n-        String jarExe = JDKToolFinder.getJDKTool(\"jar\");\n-\n-        ArrayList<String> args = new ArrayList<>();\n-        args.add(jarExe);\n-        args.add(\"uvf\");\n-        args.add(jarFile);\n-        args.add(\"-C\");\n-        args.add(dir);\n-        args.add(\".\");\n-\n-        executeProcess(args.toArray(new String[1]));\n-    }\n-\n-    private static String createSimpleJar(String jarclassDir, String jarName,\n-        String[] classNames) throws Exception {\n-\n-        ArrayList<String> args = new ArrayList<String>();\n-        args.add(\"cf\");\n-        args.add(jarName);\n-        addClassArgs(args, jarclassDir, classNames);\n-        createJar(args);\n-\n-        return jarName;\n-    }\n-\n-    private static void addClassArgs(ArrayList<String> args, String jarclassDir,\n-        String[] classNames) {\n-\n-        for (String name : classNames) {\n-            args.add(\"-C\");\n-            args.add(jarclassDir);\n-            args.add(name + \".class\");\n-        }\n-    }\n@@ -155,0 +28,5 @@\n+\/*\n+ * This class is deprecated and should not be used by any new test cases. Use CDSJarUtils\n+ * and jdk.test.lib.cds.CDSModulePackager instead.\n+ *\/\n+public class JarBuilder extends CDSJarUtils {\n@@ -156,12 +34,3 @@\n-                                      String classesDir,\n-                                      String mainClass) throws Exception {\n-        ArrayList<String> argList = new ArrayList<String>();\n-        argList.add(\"--create\");\n-        argList.add(\"--file=\" + jarPath);\n-        if (mainClass != null) {\n-            argList.add(\"--main-class=\" + mainClass);\n-        }\n-        argList.add(\"-C\");\n-        argList.add(classesDir);\n-        argList.add(\".\");\n-        createJar(argList);\n+                                        String classesDir,\n+                                        String mainClass) throws Exception {\n+        createModularJarWithManifest(jarPath, classesDir, mainClass, null);\n@@ -174,128 +43,4 @@\n-        ArrayList<String> argList = new ArrayList<String>();\n-        argList.add(\"--create\");\n-        argList.add(\"--file=\" + jarPath);\n-        if (mainClass != null) {\n-            argList.add(\"--main-class=\" + mainClass);\n-        }\n-        argList.add(\"--manifest=\" + manifest);\n-        argList.add(\"-C\");\n-        argList.add(classesDir);\n-        argList.add(\".\");\n-        createJar(argList);\n-    }\n-\n-    private static void createJar(ArrayList<String> args) {\n-        if (DEBUG) printIterable(\"createJar args: \", args);\n-\n-        if (JAR.run(System.out, System.err, args.toArray(new String[1])) != 0) {\n-            throw new RuntimeException(\"jar operation failed\");\n-        }\n-    }\n-\n-    \/\/ Many AppCDS tests use the same simple \"hello.jar\" which contains\n-    \/\/ simple Hello.class and does not specify additional attributes.\n-    \/\/ For this common use case, use this method to get the jar path.\n-    \/\/ The method will check if the jar already exists\n-    \/\/ (created by another test or test run), and will create the jar\n-    \/\/ if it does not exist\n-    public static String getOrCreateHelloJar() throws Exception {\n-        String jarPath = getJarFilePath(\"hello\");\n-\n-        File jarFile = new File(jarPath);\n-        if (jarFile.exists()) {\n-            return jarPath;\n-        } else {\n-            return build(\"hello\", \"Hello\");\n-        }\n-    }\n-\n-    public static void compile(String dstPath, String source, String... extraArgs) throws Exception {\n-        ArrayList<String> args = new ArrayList<String>();\n-        args.add(JDKToolFinder.getCompileJDKTool(\"javac\"));\n-        args.add(\"-d\");\n-        args.add(dstPath);\n-        if (extraArgs != null) {\n-            for (String s : extraArgs) {\n-                args.add(s);\n-            }\n-        }\n-        args.add(source);\n-\n-        if (DEBUG) printIterable(\"compile args: \", args);\n-\n-        ProcessBuilder pb = new ProcessBuilder(args);\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    public static void compileModule(Path src,\n-                                     Path dest,\n-                                     String modulePathArg \/\/ arg to --module-path\n-                                     ) throws Exception {\n-        boolean compiled = false;\n-        if (modulePathArg == null) {\n-            compiled = CompilerUtils.compile(src, dest);\n-        } else {\n-            compiled = CompilerUtils.compile(src, dest,\n-                                           \"--module-path\", modulePathArg);\n-        }\n-        if (!compiled) {\n-            throw new RuntimeException(\"module did not compile\");\n-        }\n-    }\n-\n-    static final String keyTool = JDKToolFinder.getJDKTool(\"keytool\");\n-    static final String jarSigner = JDKToolFinder.getJDKTool(\"jarsigner\");\n-\n-    public static void signJarWithDisabledAlgorithm(String jarName) throws Exception {\n-        String keyName = \"key_with_disabled_alg\";\n-        executeProcess(keyTool,\n-            \"-genkey\", \"-keystore\", \".\/keystore\", \"-alias\", keyName,\n-            \"-storepass\", \"abc123\", \"-keypass\", \"abc123\", \"-keyalg\", \"dsa\",\n-            \"-sigalg\", \"SHA1withDSA\", \"-keysize\", \"512\", \"-dname\", \"CN=jvmtest2\")\n-            .shouldHaveExitValue(0);\n-\n-        doSigning(jarName, keyName);\n-    }\n-\n-    public static void signJar(String jarName) throws Exception {\n-        String keyName = \"mykey\";\n-        executeProcess(keyTool,\n-            \"-genkey\", \"-keystore\", \".\/keystore\", \"-alias\", keyName,\n-            \"-storepass\", \"abc123\", \"-keypass\", \"abc123\", \"-keyalg\", \"dsa\",\n-            \"-dname\", \"CN=jvmtest\")\n-            .shouldHaveExitValue(0);\n-\n-        doSigning(jarName, keyName);\n-    }\n-\n-    private static void doSigning(String jarName, String keyName) throws Exception {\n-        executeProcess(jarSigner,\n-           \"-keystore\", \".\/keystore\", \"-storepass\", \"abc123\", \"-keypass\",\n-           \"abc123\", \"-signedjar\", getJarFilePath(\"signed_\" + jarName),\n-           getJarFilePath(jarName), keyName)\n-           .shouldHaveExitValue(0);\n-    }\n-\n-    private static OutputAnalyzer executeProcess(String... cmds)\n-        throws Exception {\n-\n-        JarBuilder.printArray(\"executeProcess: \", cmds);\n-        return ProcessTools.executeProcess(new ProcessBuilder(cmds));\n-    }\n-\n-    \/\/ diagnostic\n-    public static void printIterable(String msg, Iterable<String> l) {\n-        StringBuilder sum = new StringBuilder();\n-        for (String s : l) {\n-            sum.append(s).append(' ');\n-        }\n-        System.out.println(msg + sum.toString());\n-    }\n-\n-    public static void printArray(String msg, String[] l) {\n-        StringBuilder sum = new StringBuilder();\n-        for (String s : l) {\n-            sum.append(s).append(' ');\n-        }\n-        System.out.println(msg + sum.toString());\n+        CDSJarUtils.buildFromDirectory(jarPath, classesDir,\n+                                       JarOptions.of()\n+                                           .setMainClass(mainClass)\n+                                           .setManifest(manifest));\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/JarBuilder.java","additions":14,"deletions":269,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.test.lib.cds.CDSModulePackager;\n@@ -104,1 +105,12 @@\n-        CDSModulePathUtils.init();\n+        String TEST_ROOT = System.getProperty(\"test.root\");\n+        Path SRC_DIR = Paths.get(TEST_ROOT, \"runtime\/cds\/appcds\/jigsaw\/modulepath\/src\");\n+\n+        String MAIN_MODULE = \"com.foos\";\n+        String MAIN_CLASS = \"com.foos.Test\";\n+\n+        String appClasses[] = {MAIN_CLASS};\n+\n+        CDSModulePackager modulePackager = new CDSModulePackager(SRC_DIR);\n+        modulePackager.createModularJarWithMainClass(MAIN_MODULE, MAIN_CLASS);\n+\n+        String modulePath = modulePackager.getOutputDir().toString();\n@@ -107,3 +119,2 @@\n-        String goodModulePath = CDSModulePathUtils.getModulesDir().toString();\n-        TestCommon.testDump(null, CDSModulePathUtils.getAppClasses(),\n-                            \"--module-path\", goodModulePath,\n+        TestCommon.testDump(null, appClasses,\n+                            \"--module-path\", modulePath,\n@@ -111,1 +122,1 @@\n-                            \"-m\", CDSModulePathUtils.MAIN_MODULE);\n+                            \"-m\", MAIN_MODULE);\n@@ -113,2 +124,2 @@\n-                       \"--module-path\", goodModulePath,\n-                       \"-m\", CDSModulePathUtils.MAIN_MODULE)\n+                       \"--module-path\", modulePath,\n+                       \"-m\", MAIN_MODULE)\n@@ -118,2 +129,2 @@\n-                       \"--module-path\", goodModulePath + \"\/bad\",\n-                       \"-m\", CDSModulePathUtils.MAIN_MODULE)\n+                       \"--module-path\", modulePath + \"\/bad\",\n+                       \"-m\", MAIN_MODULE)\n@@ -123,2 +134,2 @@\n-        TestCommon.testDump(null, CDSModulePathUtils.getAppClasses(),\n-                            \"--module-path\", goodModulePath,\n+        TestCommon.testDump(null, appClasses,\n+                            \"--module-path\", modulePath,\n@@ -126,1 +137,1 @@\n-                            \"--add-modules\", CDSModulePathUtils.MAIN_MODULE);\n+                            \"--add-modules\", MAIN_MODULE);\n@@ -128,3 +139,3 @@\n-                       \"--module-path\", goodModulePath,\n-                       \"--add-modules\", CDSModulePathUtils.MAIN_MODULE,\n-                       CDSModulePathUtils.MAIN_CLASS)\n+                       \"--module-path\", modulePath,\n+                       \"--add-modules\", MAIN_MODULE,\n+                       MAIN_CLASS)\n@@ -134,3 +145,3 @@\n-                       \"--module-path\", goodModulePath + \"\/bad\",\n-                       \"--add-modules\", CDSModulePathUtils.TEST_MODULE,\n-                       CDSModulePathUtils.MAIN_CLASS)\n+                       \"--module-path\", modulePath,\n+                       \"--add-modules\", \"java.base\",\n+                       MAIN_CLASS)\n@@ -141,52 +152,0 @@\n-\n-\/\/ TODO: enhance and move this class to jdk.test.lib.cds.CDSModulePathUtils\n-\n-class CDSModulePathUtils {\n-    private static String TEST_SRC = System.getProperty(\"test.root\");\n-    private static Path USER_DIR = Paths.get(CDSTestUtils.getOutputDir());\n-    private static Path SRC_DIR = Paths.get(TEST_SRC, \"runtime\/cds\/appcds\/jigsaw\/modulepath\/src\");\n-    private static Path MODS_DIR = Paths.get(\"mods\");\n-\n-    public static String MAIN_MODULE = \"com.bars\";\n-    public static String TEST_MODULE = \"com.foos\";\n-\n-    public static String MAIN_CLASS = \"com.bars.Main\";\n-    public static String TEST_CLASS = \"com.foos.Test\";\n-    private static String appClasses[] = {MAIN_CLASS, TEST_CLASS};\n-\n-    private static Path modulesDir;\n-\n-    \/\/ This directory contains all the modular jar files\n-    \/\/     $USER_DIR\/modules\/com.bars.jar\n-    \/\/     $USER_DIR\/modules\/com.foos.jar\n-    static Path getModulesDir() {\n-        return modulesDir;\n-    }\n-\n-    static String[] getAppClasses() {\n-        return appClasses;\n-    }\n-\n-    static void init() throws Exception  {\n-        JarBuilder.compileModule(SRC_DIR.resolve(TEST_MODULE),\n-                                 MODS_DIR.resolve(TEST_MODULE),\n-                                 null);\n-        JarBuilder.compileModule(SRC_DIR.resolve(MAIN_MODULE),\n-                                 MODS_DIR.resolve(MAIN_MODULE),\n-                                 MODS_DIR.toString());\n-\n-        String PATH_LIBS = \"modules\";\n-        modulesDir = Files.createTempDirectory(USER_DIR, PATH_LIBS);\n-        Path mainJar = modulesDir.resolve(MAIN_MODULE + \".jar\");\n-        Path testJar = modulesDir.resolve(TEST_MODULE + \".jar\");\n-\n-        \/\/ modylibs contains both modules com.foos.jar, com.bars.jar\n-        \/\/ build com.foos.jar\n-        String classes = MODS_DIR.resolve(TEST_MODULE).toString();\n-        JarBuilder.createModularJar(testJar.toString(), classes, TEST_CLASS);\n-\n-        \/\/ build com.bars.jar\n-        classes = MODS_DIR.resolve(MAIN_MODULE).toString();\n-        JarBuilder.createModularJar(mainJar.toString(), classes, MAIN_CLASS);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/AOTClassLinkingVMOptions.java","additions":29,"deletions":70,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,0 @@\n-import java.io.File;\n-import java.nio.file.Files;\n@@ -38,0 +36,2 @@\n+import jdk.test.lib.cds.CDSJarUtils;\n+import jdk.test.lib.cds.CDSModulePackager;\n@@ -39,1 +39,0 @@\n-import jdk.test.lib.compiler.CompilerUtils;\n@@ -41,1 +40,0 @@\n-import jdk.test.lib.Asserts;\n@@ -66,1 +64,1 @@\n-    private static Path moduleDir = null;\n+    private static Path moduleDir1 = null;\n@@ -68,1 +66,1 @@\n-    private static Path appJar = null;\n+    private static Path appJar1 = null;\n@@ -71,1 +69,4 @@\n-    public static void buildTestModule() throws Exception {\n+    private static void buildJars() throws Exception {\n+        moduleDir2 = Paths.get(\"module-path2\");\n+        CDSModulePackager modulePackager2 = new CDSModulePackager(SRC_DIR, moduleDir2);\n+        modulePackager2.createModularJar(TEST_MODULE2);\n@@ -73,19 +74,4 @@\n-        \/\/ javac -d mods\/$TESTMODULE src\/$TESTMODULE\/**\n-        JarBuilder.compileModule(SRC_DIR.resolve(TEST_MODULE2),\n-                                 MODS_DIR.resolve(TEST_MODULE2),\n-                                 null);\n-\n-        \/\/ javac -d mods\/$TESTMODULE --module-path MOD_DIR src\/$TESTMODULE\/**\n-        JarBuilder.compileModule(SRC_DIR.resolve(TEST_MODULE1),\n-                                 MODS_DIR.resolve(TEST_MODULE1),\n-                                 MODS_DIR.toString());\n-\n-        moduleDir = Files.createTempDirectory(USER_DIR, \"mlib\");\n-        Path jar = moduleDir.resolve(TEST_MODULE2 + \".jar\");\n-        String classes = MODS_DIR.resolve(TEST_MODULE2).toString();\n-        JarBuilder.createModularJar(jar.toString(), classes, null);\n-\n-        moduleDir2 = Files.createTempDirectory(USER_DIR, \"mlib2\");\n-        appJar = moduleDir2.resolve(TEST_MODULE1 + \".jar\");\n-        classes = MODS_DIR.resolve(TEST_MODULE1).toString();\n-        JarBuilder.createModularJar(appJar.toString(), classes, MAIN_CLASS);\n+        moduleDir1 = Paths.get(\"module-path1\");\n+        CDSModulePackager modulePackager1 = new CDSModulePackager(SRC_DIR, moduleDir1);\n+        modulePackager1.addExtraModulePath(\"module-path2\");\n+        appJar1 = modulePackager1.createModularJar(TEST_MODULE1);\n@@ -95,11 +81,6 @@\n-        boolean compiled\n-            = CompilerUtils.compile(SRC_DIR.resolve(PKG_NAME),\n-                                    MODS_DIR.resolve(PKG_NAME),\n-                                    \"--module-path\", MODS_DIR.toString(),\n-                                    \"--add-modules\", TEST_MODULE2,\n-                                    \"--add-exports\", \"org.astro\/org.astro=ALL-UNNAMED\");\n-        Asserts.assertTrue(compiled, \"test package did not compile\");\n-\n-        appJar2 = moduleDir2.resolve(PKG_NAME + \".jar\");\n-        classes = MODS_DIR.resolve(PKG_NAME).toString();\n-        JarBuilder.createModularJar(appJar2.toString(), classes, null);\n+        appJar2 = USER_DIR.resolve(\"non-modular.jar\");\n+\n+        CDSJarUtils.buildFromSourceDirectory(appJar2.toString(), SRC_DIR.resolve(PKG_NAME).toString(),\n+                                             \"--module-path\", moduleDir2.toString(),\n+                                             \"--add-modules\", TEST_MODULE2,\n+                                             \"--add-exports\", \"org.astro\/org.astro=ALL-UNNAMED\");\n@@ -109,2 +90,2 @@\n-        \/\/ compile the modules and create the modular jar files\n-        buildTestModule();\n+        buildJars();\n+\n@@ -115,1 +96,1 @@\n-        \/\/ the module in the --module-path\n+        \/\/ the dependent module, org.astro, in the --module-path\n@@ -117,2 +98,2 @@\n-                                        appJar.toString(), appClasses,\n-                                        \"--module-path\", moduleDir.toString(),\n+                                        appJar1.toString(), appClasses,\n+                                        \"--module-path\", moduleDir2.toString(),\n@@ -126,2 +107,2 @@\n-                              \"-cp\", appJar.toString(),\n-                              \"--module-path\", moduleDir.toString(),\n+                              \"-cp\", appJar1.toString(),\n+                              \"--module-path\", moduleDir2.toString(),\n@@ -141,1 +122,1 @@\n-                                        \"--module-path\", moduleDir.toString(),\n+                                        \"--module-path\", moduleDir2.toString(),\n@@ -151,1 +132,1 @@\n-                       \"--module-path\", moduleDir.toString(),\n+                       \"--module-path\", moduleDir2.toString(),\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/ExportModule.java","additions":28,"deletions":47,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -134,0 +134,5 @@\n+    \/\/ optional\n+    public String modulepath(RunMode runMode) {\n+        return null;\n+    }\n+\n@@ -197,0 +202,15 @@\n+    private String[] addClassOrModulePath(RunMode runMode, String[] cmdLine) {\n+        String cp = classpath(runMode);\n+        if (cp == null) {\n+            \/\/ Override the \"-cp ....\" added by Jtreg\n+            cmdLine = StringArrayUtils.concat(cmdLine, \"-Djava.class.path=\");\n+        } else {\n+            cmdLine = StringArrayUtils.concat(cmdLine, \"-cp\", cp);\n+        }\n+        String mp = modulepath(runMode);\n+        if (mp != null) {\n+            cmdLine = StringArrayUtils.concat(cmdLine, \"--module-path\", mp);\n+        }\n+        return cmdLine;\n+    }\n+\n@@ -202,1 +222,0 @@\n-                                                   \"-cp\", classpath(runMode),\n@@ -207,0 +226,1 @@\n+        cmdLine = addClassOrModulePath(runMode, cmdLine);\n@@ -216,1 +236,0 @@\n-                                                   \"-cp\", classpath(runMode),\n@@ -219,0 +238,1 @@\n+        cmdLine = addClassOrModulePath(runMode, cmdLine);\n@@ -231,1 +251,0 @@\n-                                                   \"-cp\", classpath(runMode),\n@@ -237,0 +256,2 @@\n+        cmdLine = addClassOrModulePath(runMode, cmdLine);\n+        cmdLine = StringArrayUtils.concat(cmdLine, appCommandLine(runMode));\n@@ -248,1 +269,0 @@\n-                                                   \"-cp\", classpath(runMode),\n@@ -254,0 +274,2 @@\n+        cmdLine = addClassOrModulePath(runMode, cmdLine);\n+        cmdLine = StringArrayUtils.concat(cmdLine, appCommandLine(runMode));\n@@ -293,1 +315,0 @@\n-                                            \"-cp\", classpath(runMode),\n@@ -299,0 +320,1 @@\n+          cmdLine = addClassOrModulePath(runMode, cmdLine);\n@@ -322,1 +344,0 @@\n-                                                   \"-cp\", classpath(runMode),\n@@ -324,0 +345,1 @@\n+        cmdLine = addClassOrModulePath(runMode, cmdLine);\n@@ -371,1 +393,1 @@\n-    private void runStaticWorkflow() throws Exception {\n+    public void runStaticWorkflow() throws Exception {\n@@ -378,1 +400,1 @@\n-    private void runDynamicWorkflow() throws Exception {\n+    public void runDynamicWorkflow() throws Exception {\n@@ -384,2 +406,2 @@\n-    \/\/ See JEP 485\n-    private void runAOTWorkflow() throws Exception {\n+    \/\/ See JEP 483\n+    public void runAOTWorkflow() throws Exception {\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":32,"deletions":10,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package jdk.test.lib.cds;\n+\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.StringArrayUtils;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.FileUtils;\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.spi.ToolProvider;\n+\n+public class CDSJarUtils {\n+    \/\/ to turn DEBUG on via command line: -DCDSJarUtils.DEBUG=[true, TRUE]\n+    private static final boolean DEBUG = Boolean.parseBoolean(System.getProperty(\"CDSJarUtils.DEBUG\", \"false\"));\n+    private static final String classDir = System.getProperty(\"test.classes\");\n+    private static final ToolProvider JAR = ToolProvider.findFirst(\"jar\")\n+        .orElseThrow(() -> new RuntimeException(\"ToolProvider for jar not found\"));\n+\n+    public static String getJarFilePath(String jarName) {\n+        return CDSTestUtils.getOutputDir() +  File.separator + jarName + \".jar\";\n+    }\n+\n+    \/\/ jar all files under dir, with manifest file man, with an optional versionArgs\n+    \/\/ for generating a multi-release jar.\n+    \/\/ The jar command is as follows:\n+    \/\/ jar cmf \\\n+    \/\/  <path to output jar> <path to the manifest file>\\\n+    \/\/   -C <path to the base classes> .\\\n+    \/\/    --release 9 -C <path to the versioned classes> .\n+    \/\/ the last line begins with \"--release\" corresponds to the optional versionArgs.\n+    public static String build(String jarName, File dir, String man, String ...versionArgs)\n+        throws Exception {\n+        ArrayList<String> args = new ArrayList<String>();\n+        if (man != null) {\n+            args.add(\"cfm\");\n+        } else {\n+            args.add(\"cf\");\n+        }\n+        String jarFile = getJarFilePath(jarName);\n+        args.add(jarFile);\n+        if (man != null) {\n+            args.add(man);\n+        }\n+        args.add(\"-C\");\n+        args.add(dir.getAbsolutePath());\n+        args.add(\".\");\n+        for (String verArg : versionArgs) {\n+            args.add(verArg);\n+        }\n+        createJar(args);\n+        return jarFile;\n+    }\n+\n+    public static String build(String jarName, String ...classNames)\n+        throws Exception {\n+\n+        return createSimpleJar(classDir, getJarFilePath(jarName), classNames);\n+    }\n+\n+    public static String build(boolean classesInWorkDir, String jarName, String ...classNames)\n+        throws Exception {\n+        if (classesInWorkDir) {\n+            return createSimpleJar(\".\", getJarFilePath(jarName), classNames);\n+        } else {\n+            return build(jarName, classNames);\n+        }\n+    }\n+\n+\n+    public static String buildWithManifest(String jarName, String manifest,\n+        String jarClassesDir, String ...classNames) throws Exception {\n+        String jarPath = getJarFilePath(jarName);\n+        ArrayList<String> args = new ArrayList<String>();\n+        args.add(\"cvfm\");\n+        args.add(jarPath);\n+        args.add(System.getProperty(\"test.src\") + File.separator + \"test-classes\"\n+            + File.separator + manifest);\n+        addClassArgs(args, jarClassesDir, classNames);\n+        createJar(args);\n+\n+        return jarPath;\n+    }\n+\n+\n+    \/\/ Execute: jar uvf $jarFile -C $dir .\n+    public static void update(String jarFile, String dir) throws Exception {\n+        String jarExe = JDKToolFinder.getJDKTool(\"jar\");\n+\n+        ArrayList<String> args = new ArrayList<>();\n+        args.add(jarExe);\n+        args.add(\"uvf\");\n+        args.add(jarFile);\n+        args.add(\"-C\");\n+        args.add(dir);\n+        args.add(\".\");\n+\n+        executeProcess(args.toArray(new String[1]));\n+    }\n+\n+    private static String createSimpleJar(String jarclassDir, String jarName,\n+        String[] classNames) throws Exception {\n+\n+        ArrayList<String> args = new ArrayList<String>();\n+        args.add(\"cf\");\n+        args.add(jarName);\n+        addClassArgs(args, jarclassDir, classNames);\n+        createJar(args);\n+\n+        return jarName;\n+    }\n+\n+    private static void addClassArgs(ArrayList<String> args, String jarclassDir,\n+        String[] classNames) {\n+\n+        for (String name : classNames) {\n+            args.add(\"-C\");\n+            args.add(jarclassDir);\n+            args.add(name + \".class\");\n+        }\n+    }\n+\n+    \/*\n+     * This class is for passing extra options to the \"jar\" command-line tool\n+     * for buildFromDirectory() and buildFromSourceDirectory().\n+     *\n+     * E.g.\n+     *\n+     * buildFromSourceDirectory(\"out.jar\", \"src\", JarOptions.of().setMainClass(\"MyMainClass\"),\n+     *                          \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+     *\/\n+    public static class JarOptions {\n+        private String [] options;\n+        private JarOptions() {}\n+\n+        public static JarOptions of(String... options) {\n+            JarOptions jo = new JarOptions();\n+            jo.options = options;\n+            return jo;\n+        }\n+\n+        public JarOptions setMainClass(String mainClass) {\n+            if (mainClass != null) {\n+                options = StringArrayUtils.concat(options, \"--main-class=\" + mainClass);\n+            }\n+            return this;\n+        }\n+        public JarOptions setManifest(String manifest) {\n+            if (manifest != null) {\n+                options = StringArrayUtils.concat(options, \"--manifest=\" + manifest);\n+            }\n+            return this;\n+        }\n+    }\n+\n+    public static void buildFromDirectory(String jarPath,\n+                                          String classesDir) throws Exception {\n+        buildFromDirectory(jarPath, classesDir, null);\n+    }\n+\n+    public static void buildFromDirectory(String jarPath,\n+                                          String classesDir,\n+                                          JarOptions jarOptions) throws Exception {\n+        ArrayList<String> argList = new ArrayList<String>();\n+        argList.add(\"--create\");\n+        argList.add(\"--file=\" + jarPath);\n+        if (jarOptions != null) {\n+            for (String s : jarOptions.options) {\n+                argList.add(s);\n+            }\n+        }\n+        argList.add(\"-C\");\n+        argList.add(classesDir);\n+        argList.add(\".\");\n+        createJar(argList);\n+    }\n+\n+    public static void buildFromSourceDirectory(String jarName, String srcDir, String... extraJavacArgs) throws Exception  {\n+        buildFromSourceDirectory(jarName, srcDir, null, extraJavacArgs);\n+    }\n+\n+    \/*\n+     * Compile all source files under srcDir using javac with extraJavacArgs. Package\n+     * all the classes into the specified JAR file\n+     *\/\n+    public static void buildFromSourceDirectory(String jarName, String srcDir, JarOptions jarOptions,\n+                                                String... extraJavacArgs) throws Exception\n+    {\n+        System.out.print(\"Compiling \" + srcDir + \" into \" + jarName);\n+        if (extraJavacArgs.length > 0) {\n+            System.out.print(\" with\");\n+            for (String s : extraJavacArgs) {\n+                System.out.print(\" \" + s);\n+            }\n+        }\n+        System.out.println();\n+\n+        Path dst = Files.createTempDirectory(Paths.get(\"\"), \"tmp-classes\");\n+\n+        if (!CompilerUtils.compile(Paths.get(srcDir), dst, extraJavacArgs)) {\n+            throw new RuntimeException(\"Compilation of \" + srcDir + \" failed\");\n+        }\n+\n+        CDSJarUtils.buildFromDirectory(jarName, dst.toString(), jarOptions);\n+\n+        try {\n+            \/\/ Remove temp files to avoid clutter\n+            FileUtils.deleteFileTreeWithRetry(dst);\n+        } catch (Exception e) {\n+            \/\/ Might fail on Windows due to anti-virus. Just ignore\n+        }\n+    }\n+\n+    private static void createJar(ArrayList<String> args) {\n+        if (DEBUG) printIterable(\"createJar args: \", args);\n+\n+        if (JAR.run(System.out, System.err, args.toArray(new String[1])) != 0) {\n+            throw new RuntimeException(\"jar operation failed\");\n+        }\n+    }\n+\n+    \/\/ Many AppCDS tests use the same simple \"hello.jar\" which contains\n+    \/\/ simple Hello.class and does not specify additional attributes.\n+    \/\/ For this common use case, use this method to get the jar path.\n+    \/\/ The method will check if the jar already exists\n+    \/\/ (created by another test or test run), and will create the jar\n+    \/\/ if it does not exist\n+    public static String getOrCreateHelloJar() throws Exception {\n+        String jarPath = getJarFilePath(\"hello\");\n+\n+        File jarFile = new File(jarPath);\n+        if (jarFile.exists()) {\n+            return jarPath;\n+        } else {\n+            return build(\"hello\", \"Hello\");\n+        }\n+    }\n+\n+    public static void compile(String dstPath, String source, String... extraArgs) throws Exception {\n+        ArrayList<String> args = new ArrayList<String>();\n+        args.add(JDKToolFinder.getCompileJDKTool(\"javac\"));\n+        args.add(\"-d\");\n+        args.add(dstPath);\n+        if (extraArgs != null) {\n+            for (String s : extraArgs) {\n+                args.add(s);\n+            }\n+        }\n+        args.add(source);\n+\n+        if (DEBUG) printIterable(\"compile args: \", args);\n+\n+        ProcessBuilder pb = new ProcessBuilder(args);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    public static void compileModule(Path src,\n+                                     Path dest,\n+                                     String modulePathArg \/\/ arg to --module-path\n+                                     ) throws Exception {\n+        boolean compiled = false;\n+        if (modulePathArg == null) {\n+            compiled = CompilerUtils.compile(src, dest);\n+        } else {\n+            compiled = CompilerUtils.compile(src, dest,\n+                                           \"--module-path\", modulePathArg);\n+        }\n+        if (!compiled) {\n+            throw new RuntimeException(\"module did not compile\");\n+        }\n+    }\n+\n+    static final String keyTool = JDKToolFinder.getJDKTool(\"keytool\");\n+    static final String jarSigner = JDKToolFinder.getJDKTool(\"jarsigner\");\n+\n+    public static void signJarWithDisabledAlgorithm(String jarName) throws Exception {\n+        String keyName = \"key_with_disabled_alg\";\n+        executeProcess(keyTool,\n+            \"-genkey\", \"-keystore\", \".\/keystore\", \"-alias\", keyName,\n+            \"-storepass\", \"abc123\", \"-keypass\", \"abc123\", \"-keyalg\", \"dsa\",\n+            \"-sigalg\", \"SHA1withDSA\", \"-keysize\", \"512\", \"-dname\", \"CN=jvmtest2\")\n+            .shouldHaveExitValue(0);\n+\n+        doSigning(jarName, keyName);\n+    }\n+\n+    public static void signJar(String jarName) throws Exception {\n+        String keyName = \"mykey\";\n+        executeProcess(keyTool,\n+            \"-genkey\", \"-keystore\", \".\/keystore\", \"-alias\", keyName,\n+            \"-storepass\", \"abc123\", \"-keypass\", \"abc123\", \"-keyalg\", \"dsa\",\n+            \"-dname\", \"CN=jvmtest\")\n+            .shouldHaveExitValue(0);\n+\n+        doSigning(jarName, keyName);\n+    }\n+\n+    private static void doSigning(String jarName, String keyName) throws Exception {\n+        executeProcess(jarSigner,\n+           \"-keystore\", \".\/keystore\", \"-storepass\", \"abc123\", \"-keypass\",\n+           \"abc123\", \"-signedjar\", getJarFilePath(\"signed_\" + jarName),\n+           getJarFilePath(jarName), keyName)\n+           .shouldHaveExitValue(0);\n+    }\n+\n+    private static OutputAnalyzer executeProcess(String... cmds)\n+        throws Exception {\n+\n+        printArray(\"executeProcess: \", cmds);\n+        return ProcessTools.executeProcess(new ProcessBuilder(cmds));\n+    }\n+\n+    \/\/ diagnostic\n+    public static void printIterable(String msg, Iterable<String> l) {\n+        StringBuilder sum = new StringBuilder();\n+        for (String s : l) {\n+            sum.append(s).append(' ');\n+        }\n+        System.out.println(msg + sum.toString());\n+    }\n+\n+    public static void printArray(String msg, String[] l) {\n+        StringBuilder sum = new StringBuilder();\n+        for (String s : l) {\n+            sum.append(s).append(' ');\n+        }\n+        System.out.println(msg + sum.toString());\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSJarUtils.java","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package jdk.test.lib.cds;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.test.lib.StringArrayUtils;\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.util.FileUtils;\n+import jdk.test.lib.cds.CDSJarUtils.JarOptions;\n+\n+\n+\/*\n+ * CDSModulePackager compiles Java sources into a directory that you can pass as the argument for\n+ * --module-path to the Java launcher.\n+ *\n+ * Here's an example for creating two modules from the directory ${test.src}\/src\n+ *\n+ *     CDSModulePackager modulePackager = new CDSModulePackager(\"src\");\n+ *     String modulePath = modulePackager.getOutputDir().toString();\n+ *\n+ *     modulePackager.createModularJar(\"com.foos\");\n+ *     modulePackager.createModularJar(\"com.needsfoosaddexport\",\n+ *                                     \"--add-exports\",\n+ *                                     \"com.foos\/com.foos.internal=com.needsfoosaddexport\");\n+ *\n+ * Note that when compiling the second module, it will can access the classes from all\n+ * modules that were previously compiled by the same CDSModulePackager.\n+ *\n+ * The source code should be arranged with the proper directory structure. E.g.\n+ *\n+ *     ${test.src}\/src\/com.foos\/com\/foos\/Test.java\n+ *     ${test.src}\/src\/com.foos\/com\/foos\/internal\/FoosInternal.java\n+ *     ${test.src}\/src\/com.foos\/module-info.java\n+ *     ${test.src}\/src\/com.needsfoosaddexport\/com\/needsfoosaddexport\/Main.java\n+ *     ${test.src}\/src\/com.needsfoosaddexport\/module-info.java\n+ *\n+ * By default, modulePath will be ${user.dir}\/test-modules (i.e., in the Jtreg \"scratch\" directory.\n+ * the output from the above would be\n+ *\n+ *     ${user.dir}\/test-modules\/com.foos.jar\n+ *     ${user.dir}\/test-modules\/com.needsfoosaddexport.jar\n+ *\n+ * You can then use these JAR files with:\n+ *\n+ *     java --module-path test-modules -m com.foos\/com.foos.Test\n+ *\/\n+public class CDSModulePackager {\n+    private Path srcRoot;\n+\n+    \/\/ By default: .\/test-modules in the scratch directory of the Jtreg test case.\n+    private Path outputDir;\n+\n+    private String extraModulePaths;\n+\n+    \/\/ Create modules where the source code is located in ${test.src}\/${srcRoot},\n+    \/\/ where test.src is the directory that contains the current Jtreg test case.\n+    \/\/\n+    \/\/ All modules will be packaged under ${outputDir}\n+    public CDSModulePackager(String srcRoot, String outputDir) {\n+        String testSrc = System.getProperty(\"test.src\");\n+        this.srcRoot = Paths.get(testSrc, srcRoot);\n+        this.outputDir = Paths.get(outputDir);\n+    }\n+\n+    public CDSModulePackager(String srcRoot) {\n+        this(srcRoot, \"test-modules\");\n+    }\n+\n+    public CDSModulePackager(Path srcRoot, Path outputDir) {\n+        this.srcRoot = srcRoot;\n+        this.outputDir = outputDir;\n+    }\n+\n+    public CDSModulePackager(Path srcRoot) {\n+        this(srcRoot, Paths.get(\"test-modules\"));\n+    }\n+\n+    public Path getOutputDir() {\n+        return outputDir;\n+    }\n+\n+    public void addExtraModulePath(String... extra) {\n+        for (String s : extra) {\n+            if (extraModulePaths == null) {\n+                extraModulePaths = s;\n+            } else {\n+                extraModulePaths += File.pathSeparator + s;\n+            }\n+        }\n+    }\n+\n+     public void addExtraModulePath(Path... extra) {\n+        for (Path p : extra) {\n+            if (extraModulePaths == null) {\n+                extraModulePaths = p.toString();\n+            } else {\n+                extraModulePaths += File.pathSeparator + p.toString();\n+            }\n+        }\n+    }\n+\n+    public Path createModularJar(String moduleName) throws Exception {\n+       return createModularJarWithMainClass(moduleName, null, (JarOptions)null);\n+    }\n+\n+    public Path createModularJar(String moduleName, String... javacOptions) throws Exception {\n+       return createModularJarWithMainClass(moduleName, null, (JarOptions)null, javacOptions);\n+    }\n+\n+    public Path createModularJarWithMainClass(String moduleName, String mainClass, String... javacOptions) throws Exception {\n+        return createModularJarWithMainClass(moduleName, mainClass, (JarOptions)null, javacOptions);\n+    }\n+\n+    \/\/ Compile all files under ${this.srcRoot}\/${moduleName}.\n+    public Path createModularJarWithMainClass(String moduleName, String mainClass, JarOptions jarOptions, String... javacOptions) throws Exception {\n+        Path src = srcRoot.resolve(moduleName);\n+\n+        \/\/ We always include the outputDir in the --module-path, so that you can compile new modules\n+        \/\/ that are dependent on modules already inside the outputDir.\n+        String modulePath = outputDir.toString();\n+        if (extraModulePaths != null) {\n+            modulePath += File.pathSeparator + extraModulePaths;\n+        }\n+        if (javacOptions == null) {\n+            javacOptions = new String[] {\"--module-path\", modulePath};\n+        } else {\n+            javacOptions = StringArrayUtils.concat(javacOptions, \"--module-path\", modulePath);\n+        }\n+\n+        if (mainClass != null) {\n+            if (jarOptions == null) {\n+                jarOptions = JarOptions.of();\n+            }\n+            jarOptions.setMainClass(mainClass);\n+        }\n+\n+        Path jarFile = outputDir.resolve(moduleName + \".jar\");\n+        CDSJarUtils.buildFromSourceDirectory(jarFile.toString(), src.toString(), jarOptions, javacOptions);\n+\n+        return jarFile;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSModulePackager.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.cds;\n+\n+import java.io.File;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.StringArrayUtils;\n+import jdk.test.whitebox.WhiteBox;\n+import jtreg.SkippedException;\n+\n+import java.util.function.Consumer;\n+\n+\/*\n+ * A simpler way to use CDSAppTester. Example:\n+ *\n+ * SimpleCDSAppTester.of(\"moduleNeedsJdkAddExport\")\n+ *    .classpath(dummyJar)\n+ *    .modulepath(modulePath)\n+ *    .addVmArgs(\"--add-modules\", \"com.needsjdkaddexport\",\n+ *               \"--add-exports\", \"java.base\/jdk.internal.misc=com.needsjdkaddexport\", \"-Xlog:cds\")\n+ *    .appCommandLine(\"-m\", \"com.needsjdkaddexport\/com.needsjdkaddexport.Main\")\n+ *    .setAssemblyChecker((OutputAnalyzer out) -> {\n+ *           out.shouldContain(\"Full module graph = enabled\");\n+ *        })\n+ *    .setProductionChecker((OutputAnalyzer out) -> {\n+ *            out.shouldContain(\"use_full_module_graph = true; java.base\");\n+ *        })\n+ *    .runStaticWorkflow()\n+ *    .runAOTWorkflow();\n+ *\/\n+public class SimpleCDSAppTester {\n+    private String name;\n+    private Consumer<OutputAnalyzer> assemblyChecker;\n+    private Consumer<OutputAnalyzer> productionChecker;\n+    private String classpath;\n+    private String modulepath;\n+    private String[] appCommandLine;\n+    private String[] vmArgs = new String[] {};\n+\n+    private SimpleCDSAppTester(String name) {\n+        this.name = name;\n+    }\n+\n+    public static SimpleCDSAppTester of(String name) {\n+        return new SimpleCDSAppTester(name);\n+    }\n+\n+    public SimpleCDSAppTester classpath(String... paths) {\n+        this.classpath = null;\n+        for (String p : paths) {\n+            if (this.classpath == null) {\n+                this.classpath = p;\n+            } else {\n+                this.classpath += File.pathSeparator + p;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    public SimpleCDSAppTester modulepath(String... paths) {\n+        this.modulepath = null;\n+        for (String p : paths) {\n+            if (this.modulepath == null) {\n+                this.modulepath = p;\n+            } else {\n+                this.modulepath += File.pathSeparator + p;\n+            }\n+        }\n+        return this;\n+    }\n+\n+    public SimpleCDSAppTester addVmArgs(String... args) {\n+        vmArgs = StringArrayUtils.concat(vmArgs, args);\n+        return this;\n+    }\n+\n+    public SimpleCDSAppTester appCommandLine(String... args) {\n+        this.appCommandLine = args;\n+        return this;\n+    }\n+\n+    public SimpleCDSAppTester setAssemblyChecker(Consumer<OutputAnalyzer> checker) {\n+        this.assemblyChecker = checker;\n+        return this;\n+    }\n+\n+    public SimpleCDSAppTester setProductionChecker(Consumer<OutputAnalyzer> checker) {\n+        this.productionChecker = checker;\n+        return this;\n+    }\n+\n+    class Tester extends CDSAppTester {\n+        public Tester(String name) {\n+            super(name);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return SimpleCDSAppTester.this.classpath;\n+        }\n+\n+        @Override\n+        public String modulepath(RunMode runMode) {\n+            return SimpleCDSAppTester.this.modulepath;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            return SimpleCDSAppTester.this.vmArgs;\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return SimpleCDSAppTester.this.appCommandLine;\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            if (isDumping(runMode) && runMode != RunMode.TRAINING) {\n+                if (assemblyChecker != null) {\n+                    assemblyChecker.accept(out);\n+                }\n+            } else if (runMode.isProductionRun()) {\n+                if (productionChecker != null) {\n+                    productionChecker.accept(out);\n+                }\n+            }\n+        }\n+    }\n+\n+    public SimpleCDSAppTester runStaticWorkflow() throws Exception {\n+        (new Tester(name)).runStaticWorkflow();\n+        return this;\n+    }\n+\n+    public SimpleCDSAppTester runAOTWorkflow() throws Exception {\n+        (new Tester(name)).runAOTWorkflow();\n+        return this;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/SimpleCDSAppTester.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"}]}