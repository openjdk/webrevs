{"files":[{"patch":"@@ -1147,0 +1147,5 @@\n+            if (shc.conContext.inputRecord.t13keyChangeHsExceedsRecordBoundary()) {\n+                throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,\n+                                    \"CLIENT_HELLO messages must align with a record boundary\");\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ClientHello.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -932,0 +932,5 @@\n+            if (chc.conContext.inputRecord.t13keyChangeHsExceedsRecordBoundary()) {\n+                throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,\n+                        \"FINISHED messages must align with a record boundary\");\n+            }\n+\n@@ -1075,0 +1080,5 @@\n+            if (shc.conContext.inputRecord.t13keyChangeHsExceedsRecordBoundary()) {\n+                throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,\n+                        \"FINISHED messages must align with a record boundary\");\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,4 @@\n+    \/\/ needed for TLS13 boundary check for handshake messages that immediately precede\n+    \/\/ a key change\n+    private boolean t13keyChangeHsExceedsRecordBoundary = false;\n+\n@@ -153,0 +157,8 @@\n+    public final boolean t13keyChangeHsExceedsRecordBoundary() {\n+        return t13keyChangeHsExceedsRecordBoundary;\n+    }\n+\n+    protected final void markT13keyChangeHsExceedsRecordBoundary() {\n+        t13keyChangeHsExceedsRecordBoundary = true;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/InputRecord.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -193,0 +193,7 @@\n+\n+            if (hc.negotiatedProtocol.useTLS13PlusSpec()\n+                    && hc.conContext.inputRecord.t13keyChangeHsExceedsRecordBoundary()) {\n+                throw hc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,\n+                        \"KEYUPDATE messages must align with a record boundary\");\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/KeyUpdate.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -341,0 +341,17 @@\n+                    \/\/ From RFC 8446:\n+                    \/\/ \"Implementations MUST verify that all messages immediately\n+                    \/\/ preceding a key change align with a record boundary; if\n+                    \/\/ not, then they MUST terminate the connection with an\n+                    \/\/ \"unexpected_message\" alert. Because the ClientHello,\n+                    \/\/ EndOfEarlyData, ServerHello, Finished, and KeyUpdate\n+                    \/\/ messages can immediately precede a key change, implementations\n+                    \/\/ MUST send these messages in alignment with a record boundary.\"\n+                    \/\/\n+                    \/\/ this check must be done here, as the handshakeBuffer is\n+                    \/\/ not accessible to the outer scope, therefore there is\n+                    \/\/ no way to check whether the handshake message\n+                    \/\/ was aligned with the boundary\n+                    if (nextPos < fragLim && SSLHandshake.t13PrecedesKeyChange(handshakeType)) {\n+                        markT13keyChangeHsExceedsRecordBoundary();\n+                    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineInputRecord.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -535,0 +535,12 @@\n+    \/**\n+     * Whether the handshake message with a given id precedes a key change\n+     * in (D)TLS1.3\n+     *\/\n+    static boolean t13PrecedesKeyChange(byte id) {\n+        return id == SSLHandshake.CLIENT_HELLO.id ||\n+                id == SSLHandshake.END_OF_EARLY_DATA.id ||\n+                id == SERVER_HELLO.id ||\n+                id == FINISHED.id ||\n+                id == KEY_UPDATE.id;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLHandshake.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,0 +368,17 @@\n+                    \/\/ From RFC 8446:\n+                    \/\/ \"Implementations MUST verify that all messages immediately\n+                    \/\/ preceding a key change align with a record boundary; if\n+                    \/\/ not, then they MUST terminate the connection with an\n+                    \/\/ \"unexpected_message\" alert. Because the ClientHello,\n+                    \/\/ EndOfEarlyData, ServerHello, Finished, and KeyUpdate\n+                    \/\/ messages can immediately precede a key change, implementations\n+                    \/\/ MUST send these messages in alignment with a record boundary.\"\n+                    \/\/\n+                    \/\/ this check must be done here, as the handshakeBuffer is\n+                    \/\/ not accessible to the outer scope, therefore there is\n+                    \/\/ no way to check whether the handshake message\n+                    \/\/ was aligned with the boundary\n+                    if (nextPos < fragLim && SSLHandshake.t13PrecedesKeyChange(handshakeType)) {\n+                        markT13keyChangeHsExceedsRecordBoundary();\n+                    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketInputRecord.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1242,0 +1242,5 @@\n+            if (chc.conContext.inputRecord.t13keyChangeHsExceedsRecordBoundary()) {\n+                throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,\n+                        \"SERVER_HELLO messages must align with a record boundary\");\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.nio.ByteBuffer;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLProtocolException;\n+\n+\/*\n+ * @test\n+ * @bug 8366453\n+ * @summary TLS 1.3 KeyUpdate record is not rejected if not on a record boundary\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm TLS13UnalignedKeyChangeHSMessage\n+ *\/\n+\n+public class TLS13UnalignedKeyChangeHSMessage extends SSLEngineTemplate {\n+\n+    private static final String exMsg = \"(unexpected_message) SERVER_HELLO messages must align with a record boundary\";\n+\n+    private static final int SERVER_HELLO_ID = 2;\n+    \/\/ HandShake type: encrypted_extension(8)\n+    \/\/ Body length:    0x000002\n+    \/\/ Body:           0x0000\n+    private static final byte[] SERVER_ENCRYPTED_EXTENSIONS = { 0x08, 0x00, 0x00, 0x02, 0x00, 0x00 };\n+\n+    protected TLS13UnalignedKeyChangeHSMessage()\n+            throws Exception {\n+        super();\n+    }\n+\n+    @Override\n+    protected ContextParameters getServerContextParameters() {\n+        return getContextParameters();\n+    }\n+\n+    @Override\n+    protected ContextParameters getClientContextParameters() {\n+        return getContextParameters();\n+    }\n+\n+    private ContextParameters getContextParameters() {\n+        return new ContextParameters(\"TLSv1.3\", \"PKIX\", \"SunX509\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 0) {\n+            throw new RuntimeException(\"Wrong number of arguments\");\n+        }\n+\n+        new TLS13UnalignedKeyChangeHSMessage().run();\n+    }\n+\n+    protected void run() throws Exception {\n+\n+        \/\/ Run handshake until the server sends a ServerHello\n+        ByteBuffer serverHelloMsg = null;\n+        do {\n+            clientEngine.wrap(clientOut, cTOs);\n+            runDelegatedTasks(clientEngine);\n+\n+            serverEngine.wrap(serverOut, sTOc);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.flip();\n+            sTOc.flip();\n+\n+            \/\/ check if server sent ServerHello\n+            if (sTOc.remaining() > 5\n+                    && (serverHelloMsg =\n+                            extractHandshakeMsg(sTOc, SERVER_HELLO_ID, false)\n+                        ) != null) {\n+                break;\n+            }\n+\n+            clientEngine.unwrap(sTOc, clientIn);\n+            runDelegatedTasks(clientEngine);\n+\n+            serverEngine.unwrap(cTOs, serverIn);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.compact();\n+            sTOc.compact();\n+        } while (serverEngine.getHandshakeStatus()\n+                != HandshakeStatus.NOT_HANDSHAKING);\n+\n+        if (serverHelloMsg == null) {\n+            throw new RuntimeException(\"ServerHello hs message not found!\");\n+        }\n+\n+        \/\/ Send unaligned ServerHello to client, by concatenating a valid\n+        \/\/ (empty) ServerEncryptedExtensions to the existing ServerHello\n+        ByteBuffer unalignedMessage = ByteBuffer.allocate(sTOc.limit()\n+                + 6);\n+        \/\/ grab record header from original message\n+        unalignedMessage.put(sTOc.get()); \/\/ Record type\n+        unalignedMessage.putShort(sTOc.getShort()); \/\/ TLS legacy version\n+\n+        \/\/ discard original body length\n+        int _originalBodyLen = sTOc.getShort();\n+\n+        \/\/ serverHello hs header + serverHello hs body length + encrypted extensions\n+        \/\/ hs message\n+        unalignedMessage.putShort((short)(4 + serverHelloMsg.remaining() +\n+                                SERVER_ENCRYPTED_EXTENSIONS.length));\n+\n+        unalignedMessage.putInt((SERVER_HELLO_ID << 24) | serverHelloMsg.remaining());\n+        unalignedMessage.put(serverHelloMsg);\n+\n+        unalignedMessage.put(SERVER_ENCRYPTED_EXTENSIONS);\n+\n+        unalignedMessage.flip();\n+\n+        runAndCheckException(\n+                () -> {\n+                    clientEngine.unwrap(unalignedMessage, clientIn);\n+                    runDelegatedTasks(clientEngine);\n+\n+                    cTOs.compact();\n+\n+                    \/\/ need to wrap again on the client to throw delegated exception\n+                    clientEngine.wrap(clientOut, cTOs);\n+                },\n+                ex -> {\n+                    assertTrue(ex instanceof SSLProtocolException);\n+                    assertEquals(exMsg, ex.getMessage());\n+                });\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLEngineImpl\/TLS13UnalignedKeyChangeHSMessage.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"}]}