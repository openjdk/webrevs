{"files":[{"patch":"@@ -40,0 +40,17 @@\n+\n+ifeq ($(call isTargetOs, linux)+$(call isTargetCpu, riscv64)+$(INCLUDE_COMPILER2), true+true+true)\n+  $(eval $(call SetupJdkLibrary, BUILD_LIBSLEEF, \\\n+      NAME := sleef, \\\n+      OPTIMIZATION := HIGH, \\\n+      SRC := libsleef\/lib, \\\n+      EXTRA_SRC := libsleef\/generated, \\\n+      DISABLED_WARNINGS_gcc := unused-function sign-compare tautological-compare ignored-qualifiers, \\\n+      DISABLED_WARNINGS_clang := unused-function sign-compare tautological-compare ignored-qualifiers, \\\n+      CFLAGS := $(CFLAGS_JDKLIB) -march=rv64gcv, \\\n+      LDFLAGS := $(LDFLAGS_JDKLIB) \\\n+          $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+      LIBS := $(JDKLIB_LIBS) \\\n+  ))\n+\n+  TARGETS += $(BUILD_LIBSLEEF)\n+endif\n","filename":"make\/modules\/jdk.incubator.vector\/Lib.gmk","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -49,2 +49,4 @@\n-    n_int_register_parameters_c   = 8, \/\/ x10, x11, ... x17 (c_rarg0, c_rarg1, ...)\n-    n_float_register_parameters_c = 8, \/\/ f10, f11, ... f17 (c_farg0, c_farg1, ... )\n+    \/\/ check more info at https:\/\/github.com\/riscv-non-isa\/riscv-elf-psabi-doc\/blob\/master\/riscv-cc.adoc\n+    n_int_register_parameters_c   = 8,   \/\/ x10, x11, ... x17 (c_rarg0, c_rarg1, ...)\n+    n_float_register_parameters_c = 8,   \/\/ f10, f11, ... f17 (c_farg0, c_farg1, ... )\n+    n_vector_register_parameters_c = 16,  \/\/ v8, v9, ... v23\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1975,1 +1975,1 @@\n-  return false;\n+  return EnableVectorSupport && UseVectorStubs;\n@@ -1979,2 +1979,6 @@\n-  Unimplemented();\n-  return OptoRegPair(0, 0);\n+  assert(EnableVectorSupport && UseVectorStubs, \"sanity\");\n+  assert(ideal_reg == Op_VecA, \"sanity\");\n+  \/\/ check more info at https:\/\/github.com\/riscv-non-isa\/riscv-elf-psabi-doc\/blob\/master\/riscv-cc.adoc\n+  int lo = V8_num;\n+  int hi = V8_K_num;\n+  return OptoRegPair(hi, lo);\n@@ -10069,0 +10073,17 @@\n+\/\/ Call Runtime Instruction without safepoint and with vector arguments\n+\n+instruct CallLeafDirectVector(method meth, rFlagsReg cr)\n+%{\n+  match(CallLeafVector);\n+\n+  effect(USE meth, KILL cr);\n+\n+  ins_cost(BRANCH_COST);\n+\n+  format %{ \"CALL, runtime leaf vector $meth\" %}\n+\n+  ins_encode(riscv_enc_java_to_runtime(meth));\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -669,1 +669,14 @@\n-  Unimplemented();\n+  assert(total_args_passed <= Argument::n_vector_register_parameters_c, \"unsupported\");\n+  assert(num_bits >= 64 && num_bits <= 2048 && is_power_of_2(num_bits), \"unsupported\");\n+\n+  \/\/ check more info at https:\/\/github.com\/riscv-non-isa\/riscv-elf-psabi-doc\/blob\/master\/riscv-cc.adoc\n+  static const VectorRegister VEC_ArgReg[Argument::n_vector_register_parameters_c] = {\n+    v8, v9, v10, v11, v12, v13, v14, v15,\n+    v16, v17, v18, v19, v20, v21, v22, v23\n+  };\n+\n+  const int next_reg_val = 3;\n+  for (uint i = 0; i < total_args_passed; i++) {\n+    VMReg vmreg = VEC_ArgReg[i]->as_VMReg();\n+    regs[i].set_pair(vmreg->next(next_reg_val), vmreg);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -6062,0 +6062,52 @@\n+  void generate_vector_math_stubs() {\n+    if (!UseRVV) {\n+      log_info(library)(\"vector is not supported, skip loading vector math (sleef) library!\");\n+      return;\n+    }\n+\n+    \/\/ Get native vector math stub routine addresses\n+    void* libsleef = nullptr;\n+    char ebuf[1024];\n+    char dll_name[JVM_MAXPATHLEN];\n+    if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"sleef\")) {\n+      libsleef = os::dll_load(dll_name, ebuf, sizeof ebuf);\n+    }\n+    if (libsleef == nullptr) {\n+      log_info(library)(\"Failed to load native vector math (sleef) library, %s!\", ebuf);\n+      return;\n+    }\n+\n+    \/\/ Method naming convention\n+    \/\/   All the methods are named as <OP><T>_<U><suffix>\n+    \/\/\n+    \/\/   Where:\n+    \/\/     <OP>     is the operation name, e.g. sin, cos\n+    \/\/     <T>      is to indicate float\/double\n+    \/\/              \"fx\/dx\" for vector float\/double operation\n+    \/\/     <U>      is the precision level\n+    \/\/              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n+    \/\/               We use \"u10\" for all operations by default\n+    \/\/               But for those functions do not have u10 support, we use \"u05\" instead\n+    \/\/     <suffix> rvv, indicates riscv vector extension\n+    \/\/\n+    \/\/   e.g. sinfx_u10rvv is the method for computing vector float sin using rvv instructions\n+    \/\/\n+    log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"sleef\" JNI_LIB_SUFFIX, p2i(libsleef));\n+\n+    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n+      if (vop == VectorSupport::VECTOR_OP_TANH) { \/\/ skip tanh because of performance regression\n+        continue;\n+      }\n+\n+      \/\/ The native library does not support u10 level of \"hypot\".\n+      const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n+\n+      snprintf(ebuf, sizeof(ebuf), \"%sfx_%srvv\", VectorSupport::mathname[op], ulf);\n+      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n+\n+      snprintf(ebuf, sizeof(ebuf), \"%sdx_%srvv\", VectorSupport::mathname[op], ulf);\n+      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n+    }\n+  }\n+\n@@ -6267,0 +6319,2 @@\n+    generate_vector_math_stubs();\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -4160,2 +4160,2 @@\n-      for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n-        int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+      for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+        int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n@@ -4166,1 +4166,1 @@\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::svmlname[op]);\n+        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf16_ha_z0\", VectorSupport::mathname[op]);\n@@ -4169,1 +4169,1 @@\n-        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::svmlname[op]);\n+        snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s8_ha_z0\", VectorSupport::mathname[op]);\n@@ -4174,2 +4174,2 @@\n-    for (int op = 0; op < VectorSupport::NUM_SVML_OP; op++) {\n-      int vop = VectorSupport::VECTOR_OP_SVML_START + op;\n+    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n@@ -4179,1 +4179,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4182,1 +4182,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4185,1 +4185,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%sf8_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4188,1 +4188,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s1_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4191,1 +4191,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s2_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n@@ -4194,1 +4194,1 @@\n-      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::svmlname[op], avx_sse_str);\n+      snprintf(ebuf, sizeof(ebuf), \"__jsvml_%s4_ha_%s\", VectorSupport::mathname[op], avx_sse_str);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -758,1 +758,1 @@\n-      if(ideal_reg >= Op_VecS && ideal_reg <= Op_VecZ) {\n+      if(ideal_reg >= Op_VecA && ideal_reg <= Op_VecZ) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-  Node* gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n+  Node* gen_call_to_vector_math(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -471,1 +471,1 @@\n-    operation = gen_call_to_svml(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n+    operation = gen_call_to_vector_math(opr->get_con(), elem_bt, num_elem, opd1, opd2);\n@@ -473,3 +473,3 @@\n-      log_if_needed(\"  ** svml call failed for %s_%s_%d\",\n-                         (elem_bt == T_FLOAT)?\"float\":\"double\",\n-                         VectorSupport::svmlname[opr->get_con() - VectorSupport::VECTOR_OP_SVML_START],\n+      log_if_needed(\"  ** Vector math call failed for %s_%s_%d\",\n+                         (elem_bt == T_FLOAT) ? \"float\" : \"double\",\n+                         VectorSupport::mathname[opr->get_con() - VectorSupport::VECTOR_OP_MATH_START],\n@@ -2016,1 +2016,1 @@\n-static address get_svml_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {\n+static address get_vector_math_address(int vop, int bits, BasicType bt, char* name_ptr, int name_len) {\n@@ -2020,2 +2020,2 @@\n-  assert((vop >= VectorSupport::VECTOR_OP_SVML_START) && (vop <= VectorSupport::VECTOR_OP_SVML_END), \"unexpected\");\n-  int op = vop - VectorSupport::VECTOR_OP_SVML_START;\n+  assert((vop >= VectorSupport::VECTOR_OP_MATH_START) && (vop <= VectorSupport::VECTOR_OP_MATH_END), \"unexpected\");\n+  int op = vop - VectorSupport::VECTOR_OP_MATH_START;\n@@ -2029,1 +2029,1 @@\n-        snprintf(name_ptr, name_len, \"vector_%s_float%d\", VectorSupport::svmlname[op], bits);\n+        snprintf(name_ptr, name_len, \"vector_%s_float_%dbits_fixed\", VectorSupport::mathname[op], bits);\n@@ -2033,1 +2033,1 @@\n-        snprintf(name_ptr, name_len, \"vector_%s_double%d\", VectorSupport::svmlname[op], bits);\n+        snprintf(name_ptr, name_len, \"vector_%s_double_%dbits_fixed\", VectorSupport::mathname[op], bits);\n@@ -2044,0 +2044,11 @@\n+  if (addr == nullptr && Matcher::supports_scalable_vector()) {\n+    if (bt == T_FLOAT) {\n+      snprintf(name_ptr, name_len, \"vector_%s_float_%dbits_scalable\", VectorSupport::mathname[op], bits);\n+      addr = StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n+    } else {\n+      assert(bt == T_DOUBLE, \"must be FP type only\");\n+      snprintf(name_ptr, name_len, \"vector_%s_double_%dbits_scalable\", VectorSupport::mathname[op], bits);\n+      addr = StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op];\n+    }\n+  }\n+\n@@ -2047,1 +2058,1 @@\n-Node* LibraryCallKit::gen_call_to_svml(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n+Node* LibraryCallKit::gen_call_to_vector_math(int vector_api_op_id, BasicType bt, int num_elem, Node* opd1, Node* opd2) {\n@@ -2049,1 +2060,1 @@\n-  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_SVML_START && vector_api_op_id <= VectorSupport::VECTOR_OP_SVML_END, \"need valid op id\");\n+  assert(vector_api_op_id >= VectorSupport::VECTOR_OP_MATH_START && vector_api_op_id <= VectorSupport::VECTOR_OP_MATH_END, \"need valid op id\");\n@@ -2055,2 +2066,2 @@\n-  \/\/ Get address for svml method.\n-  address addr = get_svml_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);\n+  \/\/ Get address for vector math method.\n+  address addr = get_vector_math_address(vector_api_op_id, vt->length_in_bytes() * BitsPerByte, bt, name, 100);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-const char* VectorSupport::svmlname[VectorSupport::NUM_SVML_OP] = {\n+const char* VectorSupport::mathname[VectorSupport::NUM_VECTOR_OP_MATH] = {\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,3 +124,3 @@\n-    VECTOR_OP_SVML_START = VECTOR_OP_TAN,\n-    VECTOR_OP_SVML_END   = VECTOR_OP_HYPOT,\n-    NUM_SVML_OP = VECTOR_OP_SVML_END - VECTOR_OP_SVML_START + 1\n+    VECTOR_OP_MATH_START = VECTOR_OP_TAN,\n+    VECTOR_OP_MATH_END   = VECTOR_OP_HYPOT,\n+    NUM_VECTOR_OP_MATH   = VECTOR_OP_MATH_END - VECTOR_OP_MATH_START + 1\n@@ -134,1 +134,2 @@\n-    NUM_VEC_SIZES = 4\n+    VEC_SIZE_SCALABLE = 4,\n+    NUM_VEC_SIZES = 5\n@@ -142,1 +143,1 @@\n-  static const char* svmlname[VectorSupport::NUM_SVML_OP];\n+  static const char* mathname[VectorSupport::NUM_VECTOR_OP_MATH];\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -178,2 +178,2 @@\n-address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n-address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n+address StubRoutines::_vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH] = {{nullptr}, {nullptr}};\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -296,2 +296,2 @@\n-  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n-  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_SVML_OP];\n+  static address _vector_f_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n+  static address _vector_d_math[VectorSupport::NUM_VEC_SIZES][VectorSupport::NUM_VECTOR_OP_MATH];\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2024, Rivos Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ On riscv, sleef vector apis depend on native vector intrinsic, which is supported on\n+\/\/ some compiler, e.g. gcc 14+.\n+\/\/ __riscv_v_intrinsic is used to tell if the compiler supports vector intrinsic.\n+\/\/\n+\/\/ At compile-time, if the current compiler does support vector intrinsics, bridge\n+\/\/ functions will be built in the library. In case the current compiler doesn't support\n+\/\/ vector intrinsics (gcc < 14), then the bridge functions won't be compiled.\n+\/\/ At run-time, if the library is found and the bridge functions are available in the\n+\/\/ library, then the java vector API will call into the bridge functions and sleef.\n+\n+#ifdef __riscv_v_intrinsic\n+\n+#include <stdint.h>\n+\n+#include <riscv_vector.h>\n+\n+#include \"..\/generated\/misc.h\"\n+#include \"..\/generated\/sleefinline_rvvm1.h\"\n+\n+#include <jni.h>\n+\n+\/\/ We maintain an invariant in java world that default dynamic rounding mode is RNE,\n+\/\/ please check JDK-8330094, JDK-8330266 for more details.\n+\/\/ Currently, sleef source on riscv does not change rounding mode to others except\n+\/\/ of RNE. But we still think it's safer to make sure that after calling into sleef\n+\/\/ the dynamic rounding mode is always RNE.\n+\n+#ifdef ASSERT\n+#define CHECK_FRM   __asm__ __volatile__ (     \\\n+    \"    frrm   t0              \\n\\t\"          \\\n+    \"    beqz   t0, 2f          \\n\\t\"          \\\n+    \"    csrrw  x0, cycle, x0   \\n\\t\"          \\\n+    \"2:                         \\n\\t\"          \\\n+    : : : \"memory\" );\n+#else\n+#define CHECK_FRM\n+#endif\n+\n+#define DEFINE_VECTOR_MATH_UNARY_RVV(op, type) \\\n+JNIEXPORT                                      \\\n+type op##rvv(type input) {                     \\\n+  type res = Sleef_##op##rvvm1(input);         \\\n+  CHECK_FRM                                    \\\n+  return res;                                  \\\n+}\n+\n+#define DEFINE_VECTOR_MATH_BINARY_RVV(op, type) \\\n+JNIEXPORT                                       \\\n+type op##rvv(type input1, type input2) {        \\\n+  type res = Sleef_##op##rvvm1(input1, input2); \\\n+  CHECK_FRM                                     \\\n+  return res;                                   \\\n+}\n+\n+DEFINE_VECTOR_MATH_UNARY_RVV(tanfx_u10,   vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(sinfx_u10,   vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(sinhfx_u10,  vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(cosfx_u10,   vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(coshfx_u10,  vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(asinfx_u10,  vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(acosfx_u10,  vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(atanfx_u10,  vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(cbrtfx_u10,  vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(logfx_u10,   vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(log10fx_u10, vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(log1pfx_u10, vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(expfx_u10,   vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(expm1fx_u10, vfloat_rvvm1_sleef)\n+\n+DEFINE_VECTOR_MATH_UNARY_RVV(tandx_u10,   vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(sindx_u10,   vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(sinhdx_u10,  vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(cosdx_u10,   vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(coshdx_u10,  vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(asindx_u10,  vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(acosdx_u10,  vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(atandx_u10,  vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(cbrtdx_u10,  vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(logdx_u10,   vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(log10dx_u10, vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(log1pdx_u10, vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(expdx_u10,   vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_UNARY_RVV(expm1dx_u10, vdouble_rvvm1_sleef)\n+\n+DEFINE_VECTOR_MATH_BINARY_RVV(atan2fx_u10, vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_BINARY_RVV(powfx_u10,   vfloat_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_BINARY_RVV(hypotfx_u05, vfloat_rvvm1_sleef)\n+\n+DEFINE_VECTOR_MATH_BINARY_RVV(atan2dx_u10, vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_BINARY_RVV(powdx_u10,   vdouble_rvvm1_sleef)\n+DEFINE_VECTOR_MATH_BINARY_RVV(hypotdx_u05, vdouble_rvvm1_sleef)\n+\n+#undef DEFINE_VECTOR_MATH_UNARY_RVV\n+\n+#undef DEFINE_VECTOR_MATH_BINARY_RVV\n+\n+#endif \/* __riscv_v_intrinsic *\/\n","filename":"src\/jdk.incubator.vector\/linux\/native\/libsleef\/lib\/vector_math_rvv.c","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"}]}