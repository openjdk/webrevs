{"files":[{"patch":"@@ -49,0 +49,1 @@\n+    \/\/ check more info at https:\/\/github.com\/riscv-non-isa\/riscv-elf-psabi-doc\/blob\/master\/riscv-cc.adoc\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1981,0 +1981,1 @@\n+  \/\/ check more info at https:\/\/github.com\/riscv-non-isa\/riscv-elf-psabi-doc\/blob\/master\/riscv-cc.adoc\n@@ -10074,1 +10075,1 @@\n-instruct CallLeafDirectVector(method meth)\n+instruct CallLeafDirectVector(method meth, rFlagsReg cr)\n@@ -10078,1 +10079,1 @@\n-  effect(USE meth);\n+  effect(USE meth, KILL cr);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -669,1 +669,1 @@\n-  \/\/ More than 8 argument inputs are not supported now.\n+  \/\/ More than 8 argument inputs are not supported for now.\n@@ -673,0 +673,1 @@\n+  \/\/ check more info at https:\/\/github.com\/riscv-non-isa\/riscv-elf-psabi-doc\/blob\/master\/riscv-cc.adoc\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6063,45 +6063,1 @@\n-    if (UseRVV) {\n-      \/\/ Get native vector math stub routine addresses\n-      void* libsleef = nullptr;\n-      char ebuf[1024];\n-      char dll_name[JVM_MAXPATHLEN];\n-      if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"sleef\")) {\n-        libsleef = os::dll_load(dll_name, ebuf, sizeof ebuf);\n-      }\n-      if (libsleef != nullptr) {\n-        \/\/ Method naming convention\n-        \/\/   All the methods are named as <OP><T>_<U><suffix>\n-        \/\/\n-        \/\/   Where:\n-        \/\/     <OP>     is the operation name, e.g. sin, cos\n-        \/\/     <T>      is to indicate float\/double\n-        \/\/              \"fx\/dx\" for vector float\/double operation\n-        \/\/     <U>      is the precision level\n-        \/\/              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n-        \/\/               We use \"u10\" for all operations by default\n-        \/\/               But for those functions do not have u10 support, we use \"u05\" instead\n-        \/\/     <suffix> rvv, indicates riscv vector extension\n-        \/\/\n-        \/\/   e.g. sinfx_u10rvv is the method for computing vector float sin using rvv instructions\n-        \/\/\n-        log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"sleef\" JNI_LIB_SUFFIX, p2i(libsleef));\n-\n-        for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n-          int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n-          if (vop == VectorSupport::VECTOR_OP_TANH) { \/\/ skip tanh because of performance regression\n-            continue;\n-          }\n-\n-          \/\/ The native library does not support u10 level of \"hypot\".\n-          const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n-\n-          snprintf(ebuf, sizeof(ebuf), \"%sfx_%srvv\", VectorSupport::mathname[op], ulf);\n-          StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n-\n-          snprintf(ebuf, sizeof(ebuf), \"%sdx_%srvv\", VectorSupport::mathname[op], ulf);\n-          StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n-        }\n-      } else {\n-        log_info(library)(\"Failed to load native vector math (sleef) library, %s!\", ebuf);\n-      }\n-    } else {\n+    if (!UseRVV) {\n@@ -6109,0 +6065,46 @@\n+      return;\n+    }\n+\n+    \/\/ Get native vector math stub routine addresses\n+    void* libsleef = nullptr;\n+    char ebuf[1024];\n+    char dll_name[JVM_MAXPATHLEN];\n+    if (os::dll_locate_lib(dll_name, sizeof(dll_name), Arguments::get_dll_dir(), \"sleef\")) {\n+      libsleef = os::dll_load(dll_name, ebuf, sizeof ebuf);\n+    }\n+    if (libsleef == nullptr) {\n+      log_info(library)(\"Failed to load native vector math (sleef) library, %s!\", ebuf);\n+      return;\n+    }\n+\n+    \/\/ Method naming convention\n+    \/\/   All the methods are named as <OP><T>_<U><suffix>\n+    \/\/\n+    \/\/   Where:\n+    \/\/     <OP>     is the operation name, e.g. sin, cos\n+    \/\/     <T>      is to indicate float\/double\n+    \/\/              \"fx\/dx\" for vector float\/double operation\n+    \/\/     <U>      is the precision level\n+    \/\/              \"u10\/u05\" represents 1.0\/0.5 ULP error bounds\n+    \/\/               We use \"u10\" for all operations by default\n+    \/\/               But for those functions do not have u10 support, we use \"u05\" instead\n+    \/\/     <suffix> rvv, indicates riscv vector extension\n+    \/\/\n+    \/\/   e.g. sinfx_u10rvv is the method for computing vector float sin using rvv instructions\n+    \/\/\n+    log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, JNI_LIB_PREFIX \"sleef\" JNI_LIB_SUFFIX, p2i(libsleef));\n+\n+    for (int op = 0; op < VectorSupport::NUM_VECTOR_OP_MATH; op++) {\n+      int vop = VectorSupport::VECTOR_OP_MATH_START + op;\n+      if (vop == VectorSupport::VECTOR_OP_TANH) { \/\/ skip tanh because of performance regression\n+        continue;\n+      }\n+\n+      \/\/ The native library does not support u10 level of \"hypot\".\n+      const char* ulf = (vop == VectorSupport::VECTOR_OP_HYPOT) ? \"u05\" : \"u10\";\n+\n+      snprintf(ebuf, sizeof(ebuf), \"%sfx_%srvv\", VectorSupport::mathname[op], ulf);\n+      StubRoutines::_vector_f_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n+\n+      snprintf(ebuf, sizeof(ebuf), \"%sdx_%srvv\", VectorSupport::mathname[op], ulf);\n+      StubRoutines::_vector_d_math[VectorSupport::VEC_SIZE_SCALABLE][op] = (address)os::dll_lookup(libsleef, ebuf);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":47,"deletions":45,"binary":false,"changes":92,"status":"modified"}]}