{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,33 @@\n+void BytecodeConstantPool::init() {\n+  for (int i = 1; i < _orig->length(); i++) {\n+    bool new_entry = false;\n+    BytecodeCPEntry entry;\n+    switch(_orig->tag_at(i).value()) {\n+    case JVM_CONSTANT_Class:\n+    case JVM_CONSTANT_UnresolvedClass:\n+      entry = BytecodeCPEntry::klass(_orig->klass_slot_at(i).name_index());\n+      break;\n+    case JVM_CONSTANT_Utf8:\n+      entry = BytecodeCPEntry::utf8(_orig->symbol_at(i));\n+      break;\n+    case JVM_CONSTANT_NameAndType:\n+      entry = BytecodeCPEntry::name_and_type(_orig->name_ref_index_at(i), _orig->signature_ref_index_at(i));\n+      break;\n+    case JVM_CONSTANT_Methodref:\n+      entry = BytecodeCPEntry::methodref(_orig->uncached_klass_ref_index_at(i), _orig->uncached_name_and_type_ref_index_at(i));\n+      break;\n+    case JVM_CONSTANT_String:\n+      entry = BytecodeCPEntry::string(_orig->unresolved_string_at(i));\n+      break;\n+    }\n+    if (entry._tag != BytecodeCPEntry::tag::ERROR_TAG) {\n+      bool created = false;\n+      _index_map.put_if_absent(entry, i, &created);\n+      if (created) {\n+        _orig_cp_added += 1;\n+        _added_entries.append(entry);\n+      }\n+    }\n+  }\n+}\n+\n@@ -39,1 +72,1 @@\n-  int new_size = _orig->length() + _entries.length();\n+  int new_size = _orig->length() + _added_entries.length() - _orig_cp_added;\n@@ -44,1 +77,1 @@\n-  u2 index = checked_cast<u2>(_entries.length());\n+  u2 index = checked_cast<u2>(new_size);\n@@ -46,1 +79,1 @@\n-  u2* probe = _indices.put_if_absent(bcpe, index, &created);\n+  u2* probe = _index_map.put_if_absent(bcpe, index, &created);\n@@ -48,1 +81,1 @@\n-    _entries.append(bcpe);\n+    _added_entries.append(bcpe);\n@@ -52,1 +85,1 @@\n-  return checked_cast<u2>(index + _orig->length());\n+  return index;\n@@ -56,1 +89,1 @@\n-  if (_entries.length() == 0) {\n+  if (_added_entries.length() == 0) {\n@@ -60,1 +93,1 @@\n-  int new_size = _orig->length() + _entries.length();\n+  int new_size = _orig->length() + _added_entries.length() - _orig_cp_added;\n@@ -72,3 +105,7 @@\n-  for (int i = 0; i < _entries.length(); ++i) {\n-    BytecodeCPEntry entry = _entries.at(i);\n-    int idx = i + _orig->length();\n+  for (int i = _orig_cp_added; i < _added_entries.length(); ++i) {\n+    \/\/ Add new entries that we added to the temporary constant pool, to the\n+    \/\/ newly creatd constant pool.\n+    BytecodeCPEntry entry = _added_entries.at(i);\n+    \/\/ Get the constant pool index saved in the hashtable for this new entry.\n+    u2* value = _index_map.get(entry);\n+    int idx = *value;\n@@ -86,1 +123,1 @@\n-            idx, cp->symbol_at(entry._u.string));\n+            idx, entry._u.utf8);\n","filename":"src\/hotspot\/share\/classfile\/bytecodeAssembler.cpp","additions":49,"deletions":12,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,0 @@\n-    u2 string;\n@@ -78,1 +77,1 @@\n-    uintptr_t hash;\n+    uintptr_t value;\n@@ -81,2 +80,2 @@\n-  BytecodeCPEntry() : _tag(ERROR_TAG) { _u.hash = 0; }\n-  BytecodeCPEntry(u1 tag) : _tag(tag) { _u.hash = 0; }\n+  BytecodeCPEntry() : _tag(ERROR_TAG) { _u.value = 0; }\n+  BytecodeCPEntry(u1 tag) : _tag(tag) { _u.value = 0; }\n@@ -96,1 +95,1 @@\n-  static BytecodeCPEntry string(u2 index) {\n+  static BytecodeCPEntry string(Symbol* symbol) {\n@@ -98,1 +97,1 @@\n-    bcpe._u.string = index;\n+    bcpe._u.utf8 = symbol;\n@@ -117,1 +116,1 @@\n-    return e0._tag == e1._tag && e0._u.hash == e1._u.hash;\n+    return e0._tag == e1._tag && e0._u.value == e1._u.value;\n@@ -121,1 +120,1 @@\n-    return (unsigned)(e0._tag ^ e0._u.hash);\n+    return (unsigned)(e0._tag ^ e0._u.value);\n@@ -125,1 +124,1 @@\n-class BytecodeConstantPool : ResourceObj {\n+class BytecodeConstantPool : public ResourceObj {\n@@ -132,2 +131,3 @@\n-  GrowableArray<BytecodeCPEntry> _entries;\n-  IndexHash _indices;\n+  GrowableArray<BytecodeCPEntry> _added_entries;\n+  IndexHash _index_map;\n+  int _orig_cp_added;\n@@ -137,0 +137,1 @@\n+  void init();\n@@ -139,1 +140,3 @@\n-  BytecodeConstantPool(ConstantPool* orig) : _orig(orig) {}\n+  BytecodeConstantPool(ConstantPool* orig) : _orig(orig), _orig_cp_added(0) {\n+    init();\n+  }\n@@ -141,1 +144,1 @@\n-  BytecodeCPEntry const& at(u2 index) const { return _entries.at(index); }\n+  BytecodeCPEntry const& at(u2 index) const { return _added_entries.at(index); }\n@@ -157,2 +160,3 @@\n-    u2 utf8_entry = utf8(str, CHECK_0);\n-    return find_or_add(BytecodeCPEntry::string(utf8_entry), THREAD);\n+    \/\/ Create the utf8_entry in the hashtable but use Symbol for matching.\n+    (void)utf8(str, CHECK_0);\n+    return find_or_add(BytecodeCPEntry::string(str), THREAD);\n","filename":"src\/hotspot\/share\/classfile\/bytecodeAssembler.hpp","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -942,1 +942,0 @@\n-  BytecodeConstantPool bpool(klass->constants());\n@@ -945,0 +944,2 @@\n+  BytecodeConstantPool* bpool = nullptr;\n+\n@@ -977,1 +978,5 @@\n-        int max_stack = BytecodeAssembler::assemble_method_error(&bpool, buffer,\n+        \/\/ Lazily allocate bytecode constant pool also.\n+        if (bpool == nullptr) {\n+          bpool = new BytecodeConstantPool(klass->constants());\n+        }\n+        int max_stack = BytecodeAssembler::assemble_method_error(bpool, buffer,\n@@ -981,1 +986,1 @@\n-        Method* m = new_method(&bpool, buffer, slot->name(), slot->signature(),\n+        Method* m = new_method(bpool, buffer, slot->name(), slot->signature(),\n@@ -998,1 +1003,1 @@\n-    switchover_constant_pool(&bpool, klass, &overpasses, CHECK);\n+    switchover_constant_pool(bpool, klass, &overpasses, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"}]}