{"files":[{"patch":"@@ -65,1 +65,1 @@\n-      exelauncher.c\n+      exelauncher.c libFDLeaker.c exeFDLeakTester.c\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,15 @@\n+int\n+markCloseOnExec(int fd)\n+{\n+    const int flags = fcntl(fd, F_GETFD);\n+    if (flags < 0) {\n+        return -1;\n+    }\n+    if ((flags & FD_CLOEXEC) == 0) {\n+        if (fcntl(fd, F_SETFD, flags | FD_CLOEXEC) < 0) {\n+            return -1;\n+        }\n+    }\n+    return 0;\n+}\n+\n@@ -71,1 +86,1 @@\n-closeDescriptors(void)\n+markDescriptorsCloseOnExec(void)\n@@ -75,11 +90,5 @@\n-    int from_fd = FAIL_FILENO + 1;\n-\n-    \/* We're trying to close all file descriptors, but opendir() might\n-     * itself be implemented using a file descriptor, and we certainly\n-     * don't want to close that while it's in use.  We assume that if\n-     * opendir() is implemented using a file descriptor, then it uses\n-     * the lowest numbered file descriptor, just like open().  So we\n-     * close a couple explicitly.  *\/\n-\n-    close(from_fd);          \/* for possible use by opendir() *\/\n-    close(from_fd + 1);      \/* another one for good luck *\/\n+    \/* This function marks all file descriptors beyond stderr as CLOEXEC.\n+     * That includes the file descriptor used for the fail pipe: we want that\n+     * one to stay open up until the execve, but it should be closed with the\n+     * execve. *\/\n+    const int fd_from = STDERR_FILENO + 1;\n@@ -94,1 +103,1 @@\n-        return 0;\n+        return -1;\n@@ -99,2 +108,6 @@\n-            (fd = strtol(dirp->d_name, NULL, 10)) >= from_fd + 2)\n-            close(fd);\n+            (fd = strtol(dirp->d_name, NULL, 10)) >= fd_from) {\n+            if (markCloseOnExec(fd) == -1) {\n+                closedir(dp);\n+                return -1;\n+            }\n+        }\n@@ -105,1 +118,1 @@\n-    return 1;\n+    return 0;\n@@ -397,1 +410,1 @@\n-    if (closeDescriptors() == 0) { \/* failed,  close the old way *\/\n+    if (markDescriptorsCloseOnExec() == -1) { \/* failed,  close the old way *\/\n@@ -400,2 +413,2 @@\n-        for (fd = FAIL_FILENO + 1; fd < max_fd; fd++)\n-            if (close(fd) == -1 && errno != EBADF)\n+        for (fd = STDERR_FILENO + 1; fd < max_fd; fd++)\n+            if (markCloseOnExec(fd) == -1 && errno != EBADF)\n@@ -416,3 +429,0 @@\n-    if (fcntl(FAIL_FILENO, F_SETFD, FD_CLOEXEC) == -1)\n-        goto WhyCantJohnnyExec;\n-\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.c","additions":32,"deletions":22,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/**\n+ * @test id=posix_spawn\n+ * @summary Check that we don't leak FDs\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -Djdk.lang.Process.launchMechanism=posix_spawn -agentlib:FDLeaker FDLeakTest\n+ *\/\n+\n+\/**\n+ * @test id=fork\n+ * @summary Check that we don't leak FDs\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -Djdk.lang.Process.launchMechanism=fork -agentlib:FDLeaker FDLeakTest\n+ *\/\n+\n+\/**\n+ * @test id=vfork\n+ * @summary Check that we don't leak FDs\n+ * @requires os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -Djdk.lang.Process.launchMechanism=vfork -agentlib:FDLeaker FDLeakTest\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+public class FDLeakTest {\n+    \/\/ This test has two native parts:\n+    \/\/ - a library invoked with -agentlib that ensures that, in the parent JVM, we open a native fd without setting\n+    \/\/   FD_CLOEXEC (libFDLeaker.c). This is necessary because there is no way to do this from Java: if Java functions\n+    \/\/   correctly, all files the user could open via its APIs should be marked with FD_CLOEXEC.\n+    \/\/ - a small native executable that tests - without using \/proc - whether any file descriptors other than\n+    \/\/   stdin\/out\/err are open.\n+    \/\/\n+    \/\/ What should happen: In the child process, between the initial fork and the exec of the target binary, we should\n+    \/\/ close all filedescriptors that are not stdin\/out\/err. If that works, the child process should not see any other\n+    \/\/ file descriptors save those three.\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createNativeTestProcessBuilder(\"FDLeakTester\");\n+        pb.inheritIO();\n+        Process p = pb.start();\n+        p.waitFor();\n+        if (p.exitValue() != 0) {\n+            throw new RuntimeException(\"Failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/FDLeakTest\/FDLeakTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <unistd.h>\n+\n+\/* Check if any fd past stderr is valid; if true, print warning on stderr and return -1\n+ *\n+ * Note: check without accessing \/proc since:\n+ * - non-portable\n+ * - may cause creation of temporary file descriptors\n+ *\/\n+int main(int argc, char** argv) {\n+    int errors = 0;\n+    int rc = 0;\n+    char buf[128];\n+    int max_fd = (int)sysconf(_SC_OPEN_MAX);\n+    if (max_fd == -1) {\n+        snprintf(buf, sizeof(buf), \"*** sysconf(_SC_OPEN_MAX) failed? (%d) ***\\n\", errno);\n+        rc = write(2, buf, strlen(buf));\n+        max_fd = 10000;\n+    }\n+    \/\/ We start after stderr fd\n+    for (int fd = 3; fd < max_fd; fd++) {\n+        if (fcntl(fd, F_GETFD, 0) >= 0) {\n+            \/\/ Error: found valid file descriptor\n+            errors++;\n+            snprintf(buf, sizeof(buf), \"*** Parent leaked file descriptor %d ***\\n\", fd);\n+            rc = write(2, buf, strlen(buf));\n+        }\n+    }\n+    return errors > 0 ? -1 : 0;\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/FDLeakTest\/exeFDLeakTester.c","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include \"jvmti.h\"\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  const char* filename = \".\/testfile_FDLeaker.txt\";\n+  FILE* f = fopen(filename, \"w\");\n+  if (f == NULL) {\n+    return JNI_ERR;\n+  }\n+  printf(\"Opened and leaked %s (%d)\", filename, fileno(f));\n+  return JNI_OK;\n+}\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/FDLeakTest\/libFDLeaker.c","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"}]}