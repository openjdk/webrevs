{"files":[{"patch":"@@ -1603,1 +1603,1 @@\n-                        NIO_ACCESS.acquireSession(dst);\n+                        int ticket = NIO_ACCESS.acquireSession(dst);\n@@ -1609,1 +1609,1 @@\n-                            NIO_ACCESS.releaseSession(dst);\n+                            NIO_ACCESS.releaseSession(dst, ticket);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1078,1 +1078,1 @@\n-        SharedSecrets.getJavaNioAccess().acquireSession(b);\n+        int ticket = SharedSecrets.getJavaNioAccess().acquireSession(b);\n@@ -1084,1 +1084,1 @@\n-            SharedSecrets.getJavaNioAccess().releaseSession(b);\n+            SharedSecrets.getJavaNioAccess().releaseSession(b, ticket);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -881,1 +881,1 @@\n-                public void acquireSession(Buffer buffer) {\n+                public int acquireSession(Buffer buffer) {\n@@ -884,1 +884,1 @@\n-                        scope.acquire0();\n+                        return scope.acquire0();\n@@ -886,0 +886,1 @@\n+                    return 0;\n@@ -889,1 +890,1 @@\n-                public void releaseSession(Buffer buffer) {\n+                public void releaseSession(Buffer buffer, int ticket) {\n@@ -893,1 +894,1 @@\n-                            scope.release0();\n+                            scope.release0(ticket);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-            NIO_ACCESS.acquireSession(buffer);\n+            int ticket = NIO_ACCESS.acquireSession(buffer);\n@@ -104,1 +104,1 @@\n-                NIO_ACCESS.releaseSession(buffer);\n+                NIO_ACCESS.releaseSession(buffer, ticket);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Adler32.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-            NIO_ACCESS.acquireSession(buffer);\n+            int ticket = NIO_ACCESS.acquireSession(buffer);\n@@ -103,1 +103,1 @@\n-                NIO_ACCESS.releaseSession(buffer);\n+                NIO_ACCESS.releaseSession(buffer, ticket);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-            NIO_ACCESS.acquireSession(buffer);\n+            int ticket = NIO_ACCESS.acquireSession(buffer);\n@@ -182,1 +182,1 @@\n-                NIO_ACCESS.releaseSession(buffer);\n+                NIO_ACCESS.releaseSession(buffer, ticket);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/CRC32C.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -322,1 +322,1 @@\n-                NIO_ACCESS.acquireSession(dictionary);\n+                int ticket = NIO_ACCESS.acquireSession(dictionary);\n@@ -327,1 +327,1 @@\n-                    NIO_ACCESS.releaseSession(dictionary);\n+                    NIO_ACCESS.releaseSession(dictionary, ticket);\n@@ -577,1 +577,1 @@\n-                    NIO_ACCESS.acquireSession(input);\n+                    int ticket = NIO_ACCESS.acquireSession(input);\n@@ -585,1 +585,1 @@\n-                        NIO_ACCESS.releaseSession(input);\n+                        NIO_ACCESS.releaseSession(input, ticket);\n@@ -701,1 +701,1 @@\n-                    NIO_ACCESS.acquireSession(output);\n+                    int ticket = NIO_ACCESS.acquireSession(output);\n@@ -709,1 +709,1 @@\n-                        NIO_ACCESS.releaseSession(output);\n+                        NIO_ACCESS.releaseSession(output, ticket);\n@@ -723,1 +723,1 @@\n-                    NIO_ACCESS.acquireSession(input);\n+                    int ticket = NIO_ACCESS.acquireSession(input);\n@@ -727,1 +727,1 @@\n-                            NIO_ACCESS.acquireSession(output);\n+                            int ticket2 = NIO_ACCESS.acquireSession(output);\n@@ -735,1 +735,1 @@\n-                                NIO_ACCESS.releaseSession(output);\n+                                NIO_ACCESS.releaseSession(output, ticket2);\n@@ -746,1 +746,1 @@\n-                        NIO_ACCESS.releaseSession(input);\n+                        NIO_ACCESS.releaseSession(input, ticket);\n@@ -752,1 +752,1 @@\n-                        NIO_ACCESS.acquireSession(output);\n+                        int ticket = NIO_ACCESS.acquireSession(output);\n@@ -760,1 +760,1 @@\n-                            NIO_ACCESS.releaseSession(output);\n+                            NIO_ACCESS.releaseSession(output, ticket);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Deflater.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-                NIO_ACCESS.acquireSession(dictionary);\n+                int ticket = NIO_ACCESS.acquireSession(dictionary);\n@@ -248,1 +248,1 @@\n-                    NIO_ACCESS.releaseSession(dictionary);\n+                    NIO_ACCESS.releaseSession(dictionary, ticket);\n@@ -366,1 +366,1 @@\n-                            NIO_ACCESS.acquireSession(input);\n+                            int ticket = NIO_ACCESS.acquireSession(input);\n@@ -373,1 +373,1 @@\n-                                NIO_ACCESS.releaseSession(input);\n+                                NIO_ACCESS.releaseSession(input, ticket);\n@@ -503,1 +503,1 @@\n-                            NIO_ACCESS.acquireSession(output);\n+                            int ticket = NIO_ACCESS.acquireSession(output);\n@@ -510,1 +510,1 @@\n-                                NIO_ACCESS.releaseSession(output);\n+                                NIO_ACCESS.releaseSession(output, ticket);\n@@ -528,1 +528,1 @@\n-                            NIO_ACCESS.acquireSession(input);\n+                            int ticket = NIO_ACCESS.acquireSession(input);\n@@ -532,1 +532,1 @@\n-                                    NIO_ACCESS.acquireSession(output);\n+                                    int ticket2 = NIO_ACCESS.acquireSession(output);\n@@ -539,1 +539,1 @@\n-                                        NIO_ACCESS.releaseSession(output);\n+                                        NIO_ACCESS.releaseSession(output, ticket2);\n@@ -549,1 +549,1 @@\n-                                NIO_ACCESS.releaseSession(input);\n+                                NIO_ACCESS.releaseSession(input, ticket);\n@@ -555,1 +555,1 @@\n-                                NIO_ACCESS.acquireSession(output);\n+                                int ticket = NIO_ACCESS.acquireSession(output);\n@@ -562,1 +562,1 @@\n-                                    NIO_ACCESS.releaseSession(output);\n+                                    NIO_ACCESS.releaseSession(output, ticket);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/Inflater.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-     * acquireSession(buffer);\n+     * int ticket = acquireSession(buffer);\n@@ -103,1 +103,1 @@\n-     *     releaseSession(buffer);\n+     *     releaseSession(buffer, ticket);\n@@ -107,1 +107,1 @@\n-     * @see #releaseSession(Buffer)\n+     * @see #releaseSession(Buffer, int)\n@@ -109,1 +109,1 @@\n-    void acquireSession(Buffer buffer);\n+    int acquireSession(Buffer buffer);\n@@ -111,1 +111,1 @@\n-    void releaseSession(Buffer buffer);\n+    void releaseSession(Buffer buffer, int ticket);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    public void acquire0() {\n+    public int acquire0() {\n@@ -58,0 +58,1 @@\n+        return 0;\n@@ -62,1 +63,1 @@\n-    public void release0() {\n+    public void release0(int ticket) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ConfinedSession.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    public void release0() {\n+    public void release0(int ticket) {\n@@ -52,1 +52,1 @@\n-    public void acquire0() {\n+    public int acquire0() {\n@@ -54,0 +54,1 @@\n+        return 0;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/GlobalSession.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-final class ImplicitSession extends SharedSession {\n+final class ImplicitSession extends MemorySessionImpl {\n@@ -44,1 +44,1 @@\n-        super();\n+        super(null, new SharedResourceList());\n@@ -50,1 +50,1 @@\n-    public void release0() {\n+    public void release0(int ticket) {\n@@ -55,1 +55,1 @@\n-    public void acquire0() {\n+    public int acquire0() {\n@@ -57,0 +57,1 @@\n+        return 0;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/ImplicitSession.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        permits ConfinedSession, GlobalSession, SharedSession {\n+        permits ConfinedSession, GlobalSession, SharedSession, ImplicitSession {\n@@ -159,1 +159,1 @@\n-    public abstract void release0();\n+    public abstract void release0(int ticket);\n@@ -161,1 +161,1 @@\n-    public abstract void acquire0();\n+    public abstract int acquire0();\n@@ -165,1 +165,1 @@\n-        acquire0();\n+        int ticket = acquire0();\n@@ -169,1 +169,1 @@\n-            release0();\n+            release0(ticket);\n@@ -230,1 +230,1 @@\n-    public final boolean isCloseable() {\n+    public boolean isCloseable() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+\n+import jdk.internal.foreign.MemorySessionImpl.ResourceList;\n+import jdk.internal.foreign.MemorySessionImpl.ResourceList.ResourceCleanup;\n+import jdk.internal.invoke.MhUtil;\n+\n+\n+\/**\n+ * A shared resource list; this implementation has to handle add vs. add races, as well as add vs. cleanup races.\n+ *\/\n+class SharedResourceList extends ResourceList {\n+\n+    static final VarHandle FST = MhUtil.findVarHandle(\n+            MethodHandles.lookup(), ResourceList.class, \"fst\", ResourceCleanup.class);\n+\n+    @Override\n+    void add(ResourceCleanup cleanup) {\n+        while (true) {\n+            ResourceCleanup prev = (ResourceCleanup) FST.getVolatile(this);\n+            if (prev == ResourceCleanup.CLOSED_LIST) {\n+                \/\/ too late\n+                throw MemorySessionImpl.alreadyClosed();\n+            }\n+            cleanup.next = prev;\n+            if (FST.compareAndSet(this, prev, cleanup)) {\n+                return; \/\/victory\n+            }\n+            \/\/ keep trying\n+        }\n+    }\n+\n+    void cleanup() {\n+        \/\/ At this point we are only interested about add vs. close races - not close vs. close\n+        \/\/ (because MemorySessionImpl::justClose ensured that this thread won the race to close the session).\n+        \/\/ So, the only \"bad\" thing that could happen is that some other thread adds to this list\n+        \/\/ while we're closing it.\n+        if (FST.getAcquire(this) != ResourceCleanup.CLOSED_LIST) {\n+            \/\/ok now we're really closing down\n+            ResourceCleanup prev = null;\n+            while (true) {\n+                prev = (ResourceCleanup) FST.getVolatile(this);\n+                \/\/ no need to check for DUMMY, since only one thread can get here!\n+                if (FST.compareAndSet(this, prev, ResourceCleanup.CLOSED_LIST)) {\n+                    break;\n+                }\n+            }\n+            cleanup(prev);\n+        } else {\n+            throw MemorySessionImpl.alreadyClosed();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedResourceList.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -28,1 +29,0 @@\n-import jdk.internal.invoke.MhUtil;\n@@ -32,2 +32,1 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n+import java.util.concurrent.atomic.AtomicIntegerArray;\n@@ -39,2 +38,3 @@\n- * closed. To ensure the former condition, a CAS is performed on the liveness bit. Ensuring the latter\n- * is trickier, and require a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n+ * closed. To ensure the former condition, the method {@link #justClose() justClose} is synchronized. Ensuring\n+ * the latter is trickier, using a number of counters to track how many threads are accessing the memory and\n+ * requires a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n@@ -44,1 +44,1 @@\n-sealed class SharedSession extends MemorySessionImpl permits ImplicitSession {\n+final class SharedSession extends MemorySessionImpl {\n@@ -48,1 +48,33 @@\n-    private static final int CLOSED_ACQUIRE_COUNT = -1;\n+    final private AtomicIntegerArray counters;\n+\n+    final static private int numCounters;\n+    final static private int mask;\n+\n+    \/\/ The number of ints per cacheline.\n+    final static private int multiplier;\n+    final static int CNT_CLOSING = -1;\n+    final static int CNT_CLOSED = -2;\n+\n+    private static final jdk.internal.misc.Unsafe UNSAFE = jdk.internal.misc.Unsafe.getUnsafe();\n+\n+    static {\n+        int cpus = Runtime.getRuntime().availableProcessors();\n+\n+        if (cpus < 2) {\n+            \/\/ Single CPU case.\n+            cpus = 1;\n+            mask = 0;\n+        } else {\n+            \/\/ Round up to next power of 2 CPUs.\n+            \/\/ Cap at 1024 to avoid excessive size.\n+            cpus = Integer.min(Integer.highestOneBit(cpus) << 1, 1024);\n+            mask = cpus - 1;\n+        }\n+        numCounters = cpus;\n+\n+        int cacheLineSize = UNSAFE.dataCacheLineFlushSize();\n+\n+        \/\/ Each counter is an integer on its own cacheline.\n+        multiplier = ((cacheLineSize < Integer.BYTES) ? 64 : cacheLineSize) \/ Integer.BYTES;\n+    }\n+\n@@ -52,0 +84,18 @@\n+        counters = new AtomicIntegerArray(numCounters * multiplier);\n+    }\n+\n+    @ForceInline\n+    private int getCounter() {\n+        return Thread.currentThread().hashCode() & mask;\n+    }\n+\n+    @ForceInline\n+    private int getAcquire(int index) {\n+        assert numCounters > index;\n+        return counters.getAcquire(index * multiplier);\n+    }\n+\n+    @ForceInline\n+    private int compareAndExchange(int index, int expected, int value) {\n+        assert numCounters > index;\n+        return counters.compareAndExchange(index * multiplier, expected, value);\n@@ -56,2 +106,4 @@\n-    public void acquire0() {\n-        int value;\n+    public int acquire0() {\n+        int ticket = getCounter();\n+        int value = 0;\n+        int old = getAcquire(ticket);\n@@ -59,3 +111,11 @@\n-            value = (int) ACQUIRE_COUNT.getVolatile(this);\n-            if (value < 0) {\n-                \/\/segment is not open!\n+            value = old;\n+\n+            if (value >= 0) {\n+                if (value == MAX_FORKS) {\n+                    throw tooManyAcquires();\n+                }\n+                old = compareAndExchange(ticket, value, value + 1);\n+            } else if (value == CNT_CLOSED) {\n+                \/\/ The following method will wait for the justClose() method to\n+                \/\/ set STATE variable to CLOSED, after all counters have been set\n+                \/\/ to CNT_CLOSED.\n@@ -63,3 +123,9 @@\n-            } else if (value == MAX_FORKS) {\n-                \/\/overflow\n-                throw tooManyAcquires();\n+            } else if (value == CNT_CLOSING) {\n+                \/\/ The closing thread will either succeed, changing this counter\n+                \/\/ to CNT_CLOSED or fail and backout the counter state to \"0\".\n+                do {\n+                    old = getAcquire(ticket);\n+                    Thread.onSpinWait();\n+                } while (old == CNT_CLOSING);\n+                \/\/ On exit value is CNT_CLOSING and old is >=0 or CNT_CLOSED.\n+                assert (old == CNT_CLOSED) || (old >= 0);\n@@ -67,1 +133,3 @@\n-        } while (!ACQUIRE_COUNT.compareAndSet(this, value, value + 1));\n+        } while (old != value);\n+\n+        return ticket;\n@@ -72,2 +140,5 @@\n-    public void release0() {\n-        int value;\n+    public void release0(int ticket) {\n+        assert (ticket >= 0 && ticket < numCounters) : \"Invalid ticket.\";\n+\n+        int value = 0;\n+        int old = getAcquire(ticket);\n@@ -75,4 +146,6 @@\n-            value = (int) ACQUIRE_COUNT.getVolatile(this);\n-            if (value <= 0) {\n-                \/\/cannot get here - we can't close segment twice\n-                throw sharedSessionAlreadyClosed();\n+            value = old;\n+\n+            if (value > 0) {\n+                old = compareAndExchange(ticket, value, value - 1);\n+            } else {\n+                throw alreadyClosed();\n@@ -80,1 +153,1 @@\n-        } while (!ACQUIRE_COUNT.compareAndSet(this, value, value - 1));\n+        } while (old != value);\n@@ -83,6 +156,54 @@\n-    void justClose() {\n-        int acquireCount = (int) ACQUIRE_COUNT.compareAndExchange(this, 0, CLOSED_ACQUIRE_COUNT);\n-        if (acquireCount < 0) {\n-            throw sharedSessionAlreadyClosed();\n-        } else if (acquireCount > 0) {\n-            throw alreadyAcquired(acquireCount);\n+    synchronized void justClose() {\n+        int value;\n+\n+        if (state == CLOSED) {\n+            throw alreadyClosed();\n+        }\n+\n+        \/\/ Attempt to transition all counters to CNT_CLOSING state.\n+        \/\/ Normally each counter should be 0. This method atomically changes them\n+        \/\/ to CNT_CLOSING (-1) and if that succeeds, then changes them all to\n+        \/\/ CNT_CLOSED (-2) then updates STATE and the SCOPED_MEMORY_ACCESS to\n+        \/\/ match.\n+        \/\/ Threads calling acquire0 will spin if CNT_CLOSING is acquired, and will\n+        \/\/ either fail if this method succeeds, or pass if this method fails to close.\n+        \/\/ If this method encounters a counter >0, counters that were set to\n+        \/\/ CNT_CLOSING are set to 0 and this method fails.\n+        for (int i = 0; i < numCounters; i++) {\n+            value = compareAndExchange(i, 0, CNT_CLOSING);\n+\n+            assert value != CNT_CLOSING;\n+\n+            if (value == CNT_CLOSED) {\n+                \/\/ It is already closed - throw an exception.\n+                throw alreadyClosed();\n+            }\n+\n+            if (value != 0) {\n+                \/\/ Total the counters we haven't set to CNT_CLOSING.\n+                \/\/ This might be inaccurate, but won't be zero.\n+                int total = value;\n+                for (int j = i + 1; j < numCounters; j++) {\n+                    int counter = counters.get(j * multiplier);\n+                    assert counter >= 0;\n+\n+                    total += counter;\n+                }\n+\n+                \/\/ Swapping from 0 to CNT_CLOSING failed, set back to 0.\n+                \/\/ We can't set the current one, that's the one that failed.\n+                for (int j = 0; j < i; j++) {\n+                    assert counters.getAcquire(j * multiplier) == CNT_CLOSING;\n+                    counters.setRelease(j * multiplier, 0);\n+                }\n+\n+                throw alreadyAcquired(total);\n+            }\n+        }\n+        \/\/ Success, any threads acquiring will spin on CNT_CLOSING now, for this counter.\n+\n+        \/\/ This causes threads that were spinning on CNT_CLOSING to throw alreadyClosed().\n+        for (int i = 0; i < numCounters; i++) {\n+            assert counters.getAcquire(i * multiplier) == CNT_CLOSING;\n+\n+            counters.setRelease(i * multiplier, CNT_CLOSED);\n@@ -91,0 +212,1 @@\n+        \/\/ Set MemorySessionImpl.state to match the counters closed status.\n@@ -95,5 +217,4 @@\n-    private IllegalStateException sharedSessionAlreadyClosed() {\n-        \/\/ To avoid the situation where a scope fails to be acquired or closed but still reports as\n-        \/\/ alive afterward, we wait for the state to change before throwing the exception\n-        while ((int) STATE.getVolatile(this) == OPEN) {\n-            Thread.onSpinWait();\n+    @Override\n+    public boolean isCloseable() {\n+        if (state == CLOSED) {\n+            return true;\n@@ -101,2 +222,0 @@\n-        return alreadyClosed();\n-    }\n@@ -104,19 +223,6 @@\n-    \/**\n-     * A shared resource list; this implementation has to handle add vs. add races, as well as add vs. cleanup races.\n-     *\/\n-    static class SharedResourceList extends ResourceList {\n-\n-        static final VarHandle FST = MhUtil.findVarHandle(\n-                MethodHandles.lookup(), ResourceList.class, \"fst\", ResourceCleanup.class);\n-\n-        @Override\n-        void add(ResourceCleanup cleanup) {\n-            while (true) {\n-                ResourceCleanup prev = (ResourceCleanup) FST.getVolatile(this);\n-                if (prev == ResourceCleanup.CLOSED_LIST) {\n-                    \/\/ too late\n-                    throw alreadyClosed();\n-                }\n-                cleanup.next = prev;\n-                if (FST.compareAndSet(this, prev, cleanup)) {\n-                    return; \/\/victory\n+        for (int i = 0; i < numCounters; i++) {\n+            int value = getAcquire(i);\n+\n+            if (value == CNT_CLOSING) {\n+                while ((value = getAcquire(i)) == CNT_CLOSING) {\n+                    Thread.onSpinWait();\n@@ -124,1 +230,4 @@\n-                \/\/ keep trying\n+\n+                \/\/ Restart from first counter.\n+                i = -1;\n+                continue;\n@@ -126,1 +235,0 @@\n-        }\n@@ -128,18 +236,4 @@\n-        void cleanup() {\n-            \/\/ At this point we are only interested about add vs. close races - not close vs. close\n-            \/\/ (because MemorySessionImpl::justClose ensured that this thread won the race to close the session).\n-            \/\/ So, the only \"bad\" thing that could happen is that some other thread adds to this list\n-            \/\/ while we're closing it.\n-            if (FST.getAcquire(this) != ResourceCleanup.CLOSED_LIST) {\n-                \/\/ok now we're really closing down\n-                ResourceCleanup prev = null;\n-                while (true) {\n-                    prev = (ResourceCleanup) FST.getVolatile(this);\n-                    \/\/ no need to check for DUMMY, since only one thread can get here!\n-                    if (FST.compareAndSet(this, prev, ResourceCleanup.CLOSED_LIST)) {\n-                        break;\n-                    }\n-                }\n-                cleanup(prev);\n-            } else {\n-                throw alreadyClosed();\n+            if (value == CNT_CLOSED) {\n+                return false;\n+            } else if (value > 0) {\n+                return false;\n@@ -148,0 +242,11 @@\n+\n+        return true;\n+    }\n+\n+    private IllegalStateException sharedSessionAlreadyClosed() {\n+        \/\/ To avoid the situation where a scope fails to be acquired or closed but still reports as\n+        \/\/ alive afterward, we wait for the state to change before throwing the exception\n+        while ((int) STATE.getVolatile(this) == OPEN) {\n+            Thread.onSpinWait();\n+        }\n+        return alreadyClosed();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SharedSession.java","additions":180,"deletions":75,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+import static java.lang.classfile.TypeKind.INT;\n@@ -126,2 +127,2 @@\n-    private static final MethodTypeDesc MTD_RELEASE0 = MTD_void;\n-    private static final MethodTypeDesc MTD_ACQUIRE0 = MTD_void;\n+    private static final MethodTypeDesc MTD_RELEASE0 = MethodTypeDesc.of(CD_void, CD_int);\n+    private static final MethodTypeDesc MTD_ACQUIRE0 = MethodTypeDesc.of(CD_int);\n@@ -148,0 +149,1 @@\n+    private int[] sessionTickets;\n@@ -293,0 +295,9 @@\n+\n+            sessionTickets = new int[numScopes];\n+            for (int i = 0; i < numScopes; i++) {\n+                int ticketLocal = cb.allocateLocal(INT);\n+                sessionTickets[i] = ticketLocal;\n+                cb.loadConstant(0)\n+                .istore(ticketLocal);\n+            }\n+\n@@ -533,1 +544,3 @@\n-        int nextScopeLocal = scopeSlots[curScopeLocalIdx++];\n+        int nextScopeLocal = scopeSlots[curScopeLocalIdx];\n+        int nextSessionTicketLocal = sessionTickets[curScopeLocalIdx];\n+        curScopeLocalIdx++;\n@@ -536,0 +549,1 @@\n+          .istore(nextSessionTicketLocal)\n@@ -548,1 +562,3 @@\n-        for (int scopeLocal : scopeSlots) {\n+        for (int i = 0; i < scopeSlots.length; i++) {\n+            int scopeLocal = scopeSlots[i];\n+            int ticketLocal = sessionTickets[i];\n@@ -550,1 +566,1 @@\n-              .ifThen(Opcode.IFNONNULL, ifCb -> {\n+            .ifThen(Opcode.IFNONNULL, ifCb -> {\n@@ -552,1 +568,2 @@\n-                    .invokevirtual(CD_MemorySessionImpl, \"release0\", MTD_RELEASE0);\n+                .iload(ticketLocal)\n+                .invokevirtual(CD_MemorySessionImpl, \"release0\", MTD_RELEASE0);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.Iterator;\n@@ -148,1 +149,3 @@\n-        List<MemorySessionImpl> acquiredScopes = new ArrayList<>();\n+        record ScopeAndTicket(MemorySessionImpl session, int ticket) {}\n+        List<ScopeAndTicket> acquiredScopes = new ArrayList<>();\n+\n@@ -175,1 +178,1 @@\n-                        sessionImpl.acquire0();\n+                        int ticket = sessionImpl.acquire0();\n@@ -178,1 +181,1 @@\n-                        acquiredScopes.add(sessionImpl);\n+                        acquiredScopes.add(new ScopeAndTicket(sessionImpl, ticket));\n@@ -208,2 +211,4 @@\n-            for (MemorySessionImpl sessionImpl : acquiredScopes) {\n-                sessionImpl.release0();\n+            for (ScopeAndTicket scope : acquiredScopes) {\n+                int ticket = scope.ticket;\n+                MemorySessionImpl sessionImpl = scope.session;\n+                sessionImpl.release0(ticket);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/DowncallLinker.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.Iterator;\n@@ -148,1 +149,2 @@\n-        List<MemorySessionImpl> acquiredSessions = new ArrayList<>();\n+        record ScopeAndTicket(MemorySessionImpl session, int ticket) {}\n+        List<ScopeAndTicket> acquiredSessions = new ArrayList<>();\n@@ -155,2 +157,1 @@\n-            targetImpl.acquire0();\n-            acquiredSessions.add(targetImpl);\n+            acquiredSessions.add(new ScopeAndTicket(targetImpl, targetImpl.acquire0()));\n@@ -168,2 +169,1 @@\n-                capturedStateImpl.acquire0();\n-                acquiredSessions.add(capturedStateImpl);\n+                acquiredSessions.add(new ScopeAndTicket(capturedStateImpl, capturedStateImpl.acquire0()));\n@@ -181,2 +181,1 @@\n-                    sessionImpl.acquire0();\n-                    acquiredSessions.add(sessionImpl);\n+                    acquiredSessions.add(new ScopeAndTicket(sessionImpl, sessionImpl.acquire0()));\n@@ -209,2 +208,2 @@\n-            for (MemorySessionImpl session : acquiredSessions) {\n-                session.release0();\n+            for (ScopeAndTicket scopeAndTicket : acquiredSessions) {\n+                scopeAndTicket.session.release0(scopeAndTicket.ticket);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/FallbackLinker.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -727,1 +727,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        int ticket = NIO_ACCESS.acquireSession(bb);\n@@ -739,1 +739,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseSession(bb, ticket);\n@@ -910,1 +910,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        int ticket = NIO_ACCESS.acquireSession(bb);\n@@ -924,1 +924,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseSession(bb, ticket);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-        acquireScope(bb, async);\n+        int ticket = acquireScope(bb, async);\n@@ -140,1 +140,1 @@\n-            releaseScope(bb);\n+            releaseScope(bb, ticket);\n@@ -185,1 +185,1 @@\n-                acquireScope(buf, async);\n+                int ticket = acquireScope(buf, async);\n@@ -187,1 +187,1 @@\n-                    handleReleasers = LinkedRunnable.of(Releaser.of(buf), handleReleasers);\n+                    handleReleasers = LinkedRunnable.of(Releaser.of(buf, ticket), handleReleasers);\n@@ -336,1 +336,1 @@\n-        acquireScope(bb, async);\n+        int ticket = acquireScope(bb, async);\n@@ -344,1 +344,1 @@\n-            releaseScope(bb);\n+            releaseScope(bb, ticket);\n@@ -398,1 +398,1 @@\n-                acquireScope(buf, async);\n+                int ticket = acquireScope(buf, async);\n@@ -400,1 +400,1 @@\n-                    handleReleasers = LinkedRunnable.of(Releaser.of(buf), handleReleasers);\n+                    handleReleasers = LinkedRunnable.of(Releaser.of(buf, ticket), handleReleasers);\n@@ -480,1 +480,1 @@\n-    static void acquireScope(ByteBuffer bb, boolean async) {\n+    static int acquireScope(ByteBuffer bb, boolean async) {\n@@ -484,1 +484,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        return NIO_ACCESS.acquireSession(bb);\n@@ -487,1 +487,1 @@\n-    static void releaseScope(ByteBuffer bb) {\n+    static void releaseScope(ByteBuffer bb, int ticket) {\n@@ -489,1 +489,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseSession(bb, ticket);\n@@ -502,2 +502,2 @@\n-            IOUtil.acquireScope(buf, true);\n-            return IOUtil.Releaser.of(buf);\n+            int ticket = IOUtil.acquireScope(buf, true);\n+            return IOUtil.Releaser.of(buf, ticket);\n@@ -508,2 +508,2 @@\n-                IOUtil.acquireScope(b, true);\n-                handleReleasers = IOUtil.LinkedRunnable.of(IOUtil.Releaser.of(b), handleReleasers);\n+                int ticket = IOUtil.acquireScope(b, true);\n+                handleReleasers = IOUtil.LinkedRunnable.of(IOUtil.Releaser.of(b, ticket), handleReleasers);\n@@ -540,1 +540,1 @@\n-    record Releaser(ByteBuffer bb) implements Runnable {\n+    record Releaser(ByteBuffer bb, int ticket) implements Runnable {\n@@ -547,1 +547,1 @@\n-            releaseScope(bb);\n+            releaseScope(bb, ticket);\n@@ -550,1 +550,1 @@\n-        static Runnable of(ByteBuffer bb) {\n+        static Runnable of(ByteBuffer bb, int ticket) {\n@@ -552,1 +552,1 @@\n-                    ? new Releaser(bb)\n+                    ? new Releaser(bb, ticket)\n@@ -555,1 +555,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":20,"deletions":21,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -330,1 +330,1 @@\n-        IOUtil.acquireScope(dst, true);\n+        int ticket = IOUtil.acquireScope(dst, true);\n@@ -354,1 +354,1 @@\n-                    IOUtil.releaseScope(dst);\n+                    IOUtil.releaseScope(dst, ticket);\n@@ -387,1 +387,1 @@\n-        IOUtil.acquireScope(src, true);\n+        int ticket = IOUtil.acquireScope(src, true);\n@@ -411,1 +411,1 @@\n-                    IOUtil.releaseScope(src);\n+                    IOUtil.releaseScope(src, ticket);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SimpleAsynchronousFileChannelImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-            NIO_ACCESS.acquireSession(dst);\n+            int ticket = NIO_ACCESS.acquireSession(dst);\n@@ -177,1 +177,1 @@\n-                NIO_ACCESS.releaseSession(dst);\n+                NIO_ACCESS.releaseSession(dst, ticket);\n@@ -229,1 +229,1 @@\n-            NIO_ACCESS.acquireSession(src);\n+            int ticket = NIO_ACCESS.acquireSession(src);\n@@ -236,1 +236,1 @@\n-                NIO_ACCESS.releaseSession(src);\n+                NIO_ACCESS.releaseSession(src, ticket);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -396,0 +396,1 @@\n+        private int ticket;             \/\/ to release buffer scope\n@@ -415,1 +416,1 @@\n-                IOUtil.releaseScope(dst);\n+                IOUtil.releaseScope(dst, ticket);\n@@ -451,1 +452,1 @@\n-                IOUtil.acquireScope(dst, true);\n+                ticket = IOUtil.acquireScope(dst, true);\n@@ -589,0 +590,1 @@\n+        private int ticket;             \/\/ to release buffer scope\n@@ -608,1 +610,1 @@\n-                IOUtil.releaseScope(src);\n+                IOUtil.releaseScope(src, ticket);\n@@ -634,1 +636,1 @@\n-                IOUtil.acquireScope(src, true);\n+                ticket = IOUtil.acquireScope(src, true);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsAsynchronousFileChannelImpl.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -727,1 +727,1 @@\n-        NIO_ACCESS.acquireSession(inBuffer);\n+        int ticket = NIO_ACCESS.acquireSession(inBuffer);\n@@ -729,1 +729,1 @@\n-            NIO_ACCESS.acquireSession(outBuffer);\n+            int ticket2 = NIO_ACCESS.acquireSession(outBuffer);\n@@ -811,1 +811,1 @@\n-                NIO_ACCESS.releaseSession(outBuffer);\n+                NIO_ACCESS.releaseSession(outBuffer, ticket2);\n@@ -814,1 +814,1 @@\n-            NIO_ACCESS.releaseSession(inBuffer);\n+            NIO_ACCESS.releaseSession(inBuffer, ticket);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -736,1 +736,1 @@\n-        NIO_ACCESS.acquireSession(inBuffer);\n+        int ticket = NIO_ACCESS.acquireSession(inBuffer);\n@@ -738,1 +738,1 @@\n-            NIO_ACCESS.acquireSession(outBuffer);\n+            int ticket2 = NIO_ACCESS.acquireSession(outBuffer);\n@@ -899,1 +899,1 @@\n-                NIO_ACCESS.releaseSession(outBuffer);\n+                NIO_ACCESS.releaseSession(outBuffer, ticket2);\n@@ -902,1 +902,1 @@\n-            NIO_ACCESS.releaseSession(inBuffer);\n+            NIO_ACCESS.releaseSession(inBuffer, ticket);\n@@ -1008,1 +1008,1 @@\n-        NIO_ACCESS.acquireSession(outBuffer);\n+        int ticket = NIO_ACCESS.acquireSession(outBuffer);\n@@ -1119,1 +1119,1 @@\n-            NIO_ACCESS.releaseSession(outBuffer);\n+            NIO_ACCESS.releaseSession(outBuffer, ticket);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Cipher.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -290,1 +290,1 @@\n-            NIO_ACCESS.acquireSession(byteBuffer);\n+            int ticket = NIO_ACCESS.acquireSession(byteBuffer);\n@@ -295,1 +295,1 @@\n-                NIO_ACCESS.releaseSession(byteBuffer);\n+                NIO_ACCESS.releaseSession(byteBuffer, ticket);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Digest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -559,1 +559,1 @@\n-        NIO_ACCESS.acquireSession(inBuffer);\n+        int ticket = NIO_ACCESS.acquireSession(inBuffer);\n@@ -561,1 +561,1 @@\n-            NIO_ACCESS.acquireSession(outBuffer);\n+            int ticket2 = NIO_ACCESS.acquireSession(outBuffer);\n@@ -637,1 +637,1 @@\n-                NIO_ACCESS.releaseSession(outBuffer);\n+                NIO_ACCESS.releaseSession(outBuffer, ticket2);\n@@ -640,1 +640,1 @@\n-            NIO_ACCESS.releaseSession(inBuffer);\n+            NIO_ACCESS.releaseSession(inBuffer, ticket);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyWrapCipher.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-            NIO_ACCESS.acquireSession(byteBuffer);\n+            int ticket = NIO_ACCESS.acquireSession(byteBuffer);\n@@ -292,1 +292,1 @@\n-                NIO_ACCESS.releaseSession(byteBuffer);\n+                NIO_ACCESS.releaseSession(byteBuffer, ticket);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Mac.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -623,1 +623,1 @@\n-                NIO_ACCESS.acquireSession(byteBuffer);\n+                int ticket = NIO_ACCESS.acquireSession(byteBuffer);\n@@ -641,1 +641,1 @@\n-                    NIO_ACCESS.releaseSession(byteBuffer);\n+                    NIO_ACCESS.releaseSession(byteBuffer, ticket);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11PSSSignature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -588,1 +588,1 @@\n-                NIO_ACCESS.acquireSession(byteBuffer);\n+                int ticket = NIO_ACCESS.acquireSession(byteBuffer);\n@@ -604,1 +604,1 @@\n-                    NIO_ACCESS.releaseSession(byteBuffer);\n+                    NIO_ACCESS.releaseSession(byteBuffer, ticket);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11Signature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -831,1 +831,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        int ticket = NIO_ACCESS.acquireSession(bb);\n@@ -839,1 +839,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseSession(bb, ticket);\n@@ -1014,1 +1014,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        int ticket = NIO_ACCESS.acquireSession(bb);\n@@ -1022,1 +1022,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseSession(bb, ticket);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -563,1 +563,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        int ticket = NIO_ACCESS.acquireSession(bb);\n@@ -570,1 +570,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseSession(bb, ticket);\n@@ -872,1 +872,1 @@\n-        NIO_ACCESS.acquireSession(bb);\n+        int ticket = NIO_ACCESS.acquireSession(bb);\n@@ -880,1 +880,1 @@\n-            NIO_ACCESS.releaseSession(bb);\n+            NIO_ACCESS.releaseSession(bb, ticket);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright 2025 Arm Limited and\/or its affiliates.\n@@ -321,3 +322,2 @@\n-    \/**\n-     * Test that a thread failing to acquire a scope will not observe it as alive afterwards.\n-     *\/\n+\n+    \/\/ Test that a thread failing to acquire a scope will not observe it as alive afterwards.\n@@ -365,0 +365,1 @@\n+                    int ticket = 0;\n@@ -366,1 +367,1 @@\n-                        scope.acquire0();\n+                        ticket = scope.acquire0();\n@@ -375,1 +376,1 @@\n-                    scope.release0();\n+                    scope.release0(ticket);\n@@ -389,0 +390,153 @@\n+    @Test\n+    public void testTickets() {\n+        Arena arena = Arena.ofShared();\n+        var sessionImpl = ((MemorySessionImpl) arena.scope());\n+        int ticket = sessionImpl.acquire0();\n+\n+        assertFalse(sessionImpl.isCloseable());\n+\n+        sessionImpl.release0(ticket);\n+        assertTrue(sessionImpl.isCloseable());\n+        assertThrows(IllegalStateException.class, () -> sessionImpl.release0(ticket));\n+\n+        sessionImpl.close();\n+        assertThrows(IllegalStateException.class, () -> sessionImpl.acquire0());\n+        assertTrue(sessionImpl.isCloseable());\n+    }\n+\n+    @Test\n+    public void testTicketsCrossThreads() throws InterruptedException {\n+        Arena arena = Arena.ofShared();\n+        var sessionImpl = ((MemorySessionImpl) arena.scope());\n+        int[] tickets = new int[N_THREADS];\n+        Thread[] threads = new Thread[N_THREADS];\n+\n+        for (int counter = 0; counter < N_THREADS; counter++) {\n+            threads[counter] = new Thread(new AcquireWork(counter, sessionImpl, tickets));\n+            threads[counter].start();\n+        }\n+\n+        for (int i = 0; i < N_THREADS; i++) {\n+            threads[i].join();\n+        }\n+\n+        assertFalse(sessionImpl.isCloseable());\n+\n+        try {\n+            for (int i = 0; i < N_THREADS; i++) {\n+                sessionImpl.release0(tickets[i]);\n+            }\n+        } catch (IllegalStateException e) {\n+            fail();\n+        }\n+\n+        assertTrue(sessionImpl.isCloseable());\n+\n+        try {\n+            sessionImpl.close();\n+        } catch (IllegalStateException e) {\n+            fail();\n+        }\n+    }\n+\n+    static class AcquireWork implements Runnable {\n+        int counter;\n+        MemorySessionImpl sessionImpl;\n+        int tickets[];\n+\n+        AcquireWork(int counter, MemorySessionImpl sessionImpl, int[] tickets) {\n+            this.counter = counter;\n+            this.sessionImpl = sessionImpl;\n+            this.tickets = tickets;\n+        }\n+\n+        public void run() {\n+            tickets[counter] = sessionImpl.acquire0();\n+            assertFalse(sessionImpl.isCloseable());\n+        }\n+    }\n+\n+    \/\/ Check that a scope is either closed and an acquire fails, or the\n+    \/\/ close fails and the acquire and release are successful.\n+    @Test\n+    public void testAcquireReleaseCloseRace() throws InterruptedException {\n+        boolean acquireLose = false;\n+        boolean closeLose = false;\n+\n+        while (true) {\n+            boolean closeLost = false;\n+\n+            Arena arena = Arena.ofShared();\n+            MemorySessionImpl sessionImpl = ((MemorySessionImpl) arena.scope());\n+\n+            int nthreads = 4;\n+            AcquireReleaseLoop[] arls = new AcquireReleaseLoop[nthreads];\n+            Thread[] threads = new Thread[nthreads];\n+\n+            for (int i = 0; i < nthreads; i++) {\n+                arls[i] = new AcquireReleaseLoop(sessionImpl);\n+                threads[i] = new Thread(arls[i]);\n+                threads[i].start();\n+            }\n+            Thread.sleep(100);\n+\n+            try {\n+                sessionImpl.close();\n+                assertFalse(sessionImpl.isAlive());\n+            } catch (IllegalStateException e) {\n+                assertTrue(sessionImpl.isAlive());\n+                closeLost = true;\n+            }\n+\n+            closeLose |= closeLost;\n+            for (int i = 0; i < nthreads; i++) {\n+                arls[i].loop = false;\n+                threads[i].join();\n+\n+                \/\/ Both cannot fail simultaneously.\n+                if (arls[i].acquireLose) {\n+                    assertFalse(closeLost);\n+                } else if (closeLost) {\n+                    assertFalse(arls[i].acquireLose);\n+                }\n+\n+                acquireLose |= arls[i].acquireLose;\n+            }\n+\n+            if (acquireLose && closeLose) {\n+                break;\n+            }\n+        }\n+    }\n+\n+    static class AcquireReleaseLoop implements Runnable {\n+        MemorySessionImpl sessionImpl;\n+        boolean acquireLose;\n+        volatile boolean loop = true;\n+        String message = null;\n+\n+        AcquireReleaseLoop(MemorySessionImpl sessionImpl) {\n+            this.sessionImpl = sessionImpl;\n+        }\n+\n+        public void run() {\n+            while (loop) {\n+                int ticket = 0;\n+                try {\n+                    ticket = sessionImpl.acquire0();\n+                } catch (IllegalStateException e) {\n+                    assertFalse(sessionImpl.isAlive());\n+                    acquireLose = true;\n+                    break;\n+                }\n+\n+                try {\n+                    sessionImpl.release0(ticket);\n+                } catch (IllegalStateException e) {\n+                    fail();\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -415,2 +569,2 @@\n-        parentImpl.acquire0();\n-        addCloseAction(child, parentImpl::release0);\n+        final int ticket = parentImpl.acquire0();\n+        addCloseAction(child, () -> {parentImpl.release0(ticket); });\n","filename":"test\/jdk\/java\/foreign\/TestMemorySession.java","additions":161,"deletions":7,"binary":false,"changes":168,"status":"modified"}]}