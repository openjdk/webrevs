{"files":[{"patch":"@@ -45,0 +45,2 @@\n+#include \"runtime\/serviceThread.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n@@ -56,0 +58,2 @@\n+\/\/\n+\/\/ Note: we can't link the classes yet because SharedRuntime is not yet ready to generate adapters.\n@@ -115,0 +119,38 @@\n+\/\/ Some cached heap objects may hold references to methods in aot-linked\n+\/\/ classes (via MemberName). We need to make sure all classes are\n+\/\/ linked before executing any bytecode.\n+void AOTLinkedClassBulkLoader::link_classes(JavaThread* current) {\n+  link_classes_impl(current);\n+  if (current->has_pending_exception()) {\n+    exit_on_exception(current);\n+  }\n+}\n+\n+void AOTLinkedClassBulkLoader::link_classes_impl(TRAPS) {\n+  precond(CDSConfig::is_using_aot_linked_classes());\n+\n+  AOTLinkedClassTable* table = AOTLinkedClassTable::get();\n+\n+  link_classes_in_table(table->boot1(), CHECK);\n+  link_classes_in_table(table->boot2(), CHECK);\n+  link_classes_in_table(table->platform(), CHECK);\n+  link_classes_in_table(table->app(), CHECK);\n+}\n+\n+void AOTLinkedClassBulkLoader::link_classes_in_table(Array<InstanceKlass*>* classes, TRAPS) {\n+  if (classes != nullptr) {\n+    for (int i = 0; i < classes->length(); i++) {\n+      \/\/ NOTE: CDSConfig::is_preserving_verification_constraints() is required\n+      \/\/ when storing ik in the AOT cache. This means we don't have to verify\n+      \/\/ ik at all.\n+      \/\/\n+      \/\/ Without is_preserving_verification_constraints(), ik->link_class() may cause\n+      \/\/ class loading, which may result in invocation of ClassLoader::loadClass() calls,\n+      \/\/ which CANNOT happen because we are not ready to execute any Java byecodes yet\n+      \/\/ at this point.\n+      InstanceKlass* ik = classes->at(i);\n+      ik->link_class(CHECK);\n+    }\n+  }\n+}\n+\n@@ -176,4 +218,2 @@\n-\/\/ Link all java.base classes in the AOTLinkedClassTable. Of those classes,\n-\/\/ move the ones that have been AOT-initialized to the \"initialized\" state.\n-void AOTLinkedClassBulkLoader::link_or_init_javabase_classes(JavaThread* current) {\n-  link_or_init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n+void AOTLinkedClassBulkLoader::init_javabase_classes(JavaThread* current) {\n+  init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n@@ -185,4 +225,2 @@\n-\/\/ Do the same thing as link_or_init_javabase_classes(), but for the classes that are not\n-\/\/ in the java.base module.\n-void AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes(JavaThread* current) {\n-  link_or_init_non_javabase_classes_impl(current);\n+void AOTLinkedClassBulkLoader::init_non_javabase_classes(JavaThread* current) {\n+  init_non_javabase_classes_impl(current);\n@@ -194,1 +232,1 @@\n-void AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes_impl(TRAPS) {\n+void AOTLinkedClassBulkLoader::init_non_javabase_classes_impl(TRAPS) {\n@@ -211,3 +249,3 @@\n-  link_or_init_classes_for_loader(Handle(), table->boot2(), CHECK);\n-  link_or_init_classes_for_loader(h_platform_loader, table->platform(), CHECK);\n-  link_or_init_classes_for_loader(h_system_loader, table->app(), CHECK);\n+  init_classes_for_loader(Handle(), table->boot2(), CHECK);\n+  init_classes_for_loader(h_platform_loader, table->platform(), CHECK);\n+  init_classes_for_loader(h_system_loader, table->app(), CHECK);\n@@ -245,0 +283,1 @@\n+    oop message = java_lang_Throwable::message(current->pending_exception());\n@@ -246,1 +285,1 @@\n-                   java_lang_String::as_utf8_string(java_lang_Throwable::message(current->pending_exception())));\n+                   message == nullptr ? \"(no message)\" : java_lang_String::as_utf8_string(message));\n@@ -292,1 +331,1 @@\n-void AOTLinkedClassBulkLoader::link_or_init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS) {\n+void AOTLinkedClassBulkLoader::init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS) {\n@@ -296,6 +335,1 @@\n-      if (ik->class_loader_data() == nullptr) {\n-        \/\/ This class is not yet loaded. We will initialize it in a later phase.\n-        \/\/ For example, we have loaded only AOTLinkedClassCategory::BOOT1 classes\n-        \/\/ but k is part of AOTLinkedClassCategory::BOOT2.\n-        continue;\n-      }\n+      assert(ik->class_loader_data() != nullptr, \"must be\");\n@@ -304,5 +338,0 @@\n-      } else {\n-        \/\/ Some cached heap objects may hold references to methods in aot-linked\n-        \/\/ classes (via MemberName). We need to make sure all classes are\n-        \/\/ linked to allow such MemberNames to be invoked.\n-        ik->link_class(CHECK);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":54,"deletions":25,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -55,4 +55,5 @@\n-  static void initiate_loading(JavaThread* current, const char* category, Handle initiating_loader,\n-                               Array<InstanceKlass*>* classes);\n-  static void link_or_init_non_javabase_classes_impl(TRAPS);\n-  static void link_or_init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS);\n+  static void initiate_loading(JavaThread* current, const char* category, Handle initiating_loader, Array<InstanceKlass*>* classes);\n+  static void link_classes_impl(TRAPS);\n+  static void link_classes_in_table(Array<InstanceKlass*>* classes, TRAPS);\n+  static void init_non_javabase_classes_impl(TRAPS);\n+  static void init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS);\n@@ -70,3 +71,4 @@\n-  static void preload_classes(JavaThread* current);\n-  static void link_or_init_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n-  static void link_or_init_non_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void preload_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void link_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void init_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void init_non_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -946,0 +946,2 @@\n+  } else if (is_dumping_classic_static_archive()) {\n+    return is_dumping_aot_linked_classes();\n@@ -947,1 +949,0 @@\n-    \/\/ For simplicity, we don't support this optimization with the old CDS workflow.\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  if (CDSConfig::is_preserving_verification_constraints() && CDSConfig::is_dumping_final_static_archive()) {\n+  if (CDSConfig::is_preserving_verification_constraints()) {\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -858,0 +858,22 @@\n+void SystemDictionaryShared::link_all_exclusion_check_candidates(InstanceKlass* ik) {\n+  bool need_to_link = false;\n+  {\n+    MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+    ExclusionCheckCandidates candidates(ik);\n+\n+    candidates.iterate_all([&] (InstanceKlass* k, DumpTimeClassInfo* info) {\n+      if (!k->is_linked()) {\n+        need_to_link = true;\n+      }\n+    });\n+  }\n+  if (need_to_link) {\n+    JavaThread* THREAD = JavaThread::current();\n+    if (log_is_enabled(Info, aot, link)) {\n+      ResourceMark rm(THREAD);\n+      log_info(aot, link)(\"Link all loaded classes for %s\", ik->external_name());\n+    }\n+    AOTMetaspace::link_all_loaded_classes(THREAD);\n+  }\n+}\n+\n@@ -881,9 +903,6 @@\n-      if (!ik->is_linked()) {\n-        \/\/ should_be_excluded_impl() below doesn't link unlinked classes. We come\n-        \/\/ here only when we are trying to aot-link constant pool entries, so\n-        \/\/ we'd better link the class.\n-        JavaThread* THREAD = JavaThread::current();\n-        ik->link_class(THREAD);\n-        if (HAS_PENDING_EXCEPTION) {\n-          CLEAR_PENDING_EXCEPTION;\n-          return true; \/\/ linking failed -- let's exclude it\n+      {\n+        \/\/ fast path\n+        MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+        DumpTimeClassInfo* p = get_info_locked(ik);\n+        if (p->has_checked_exclusion()) {\n+          return p->is_excluded();\n@@ -891,4 +910,0 @@\n-\n-        \/\/ Also link any classes that were loaded for the verification of ik or its supertypes.\n-        \/\/ Otherwise we might miss the verification constraints of those classes.\n-        AOTMetaspace::link_all_loaded_classes(THREAD);\n@@ -897,0 +912,2 @@\n+      link_all_exclusion_check_candidates(ik);\n+\n@@ -899,3 +916,0 @@\n-      if (p->is_excluded()) {\n-        return true;\n-      }\n@@ -915,1 +929,1 @@\n-      \/\/ Can't take the lock as we are in safepoint.\n+      \/\/ Don't take DumpTimeTable_lock as we are in safepoint.\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":31,"deletions":17,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+  static void link_all_exclusion_check_candidates(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -2503,0 +2504,27 @@\n+#if INCLUDE_CDS\n+static GrowableArrayCHeap<nmethod*, mtClassShared>* _delayed_compiled_method_load_events = nullptr;\n+\n+void nmethod::add_delayed_compiled_method_load_event(nmethod* nm) {\n+  precond(CDSConfig::is_using_aot_linked_classes());\n+  precond(!ServiceThread::has_started());\n+\n+  \/\/ We are still in single threaded stage of VM bootstrap. No need to lock.\n+  if (_delayed_compiled_method_load_events == nullptr) {\n+    _delayed_compiled_method_load_events = new GrowableArrayCHeap<nmethod*, mtClassShared>();\n+  }\n+  _delayed_compiled_method_load_events->append(nm);\n+}\n+\n+void nmethod::post_delayed_compiled_method_load_events() {\n+  precond(ServiceThread::has_started());\n+  if (_delayed_compiled_method_load_events != nullptr) {\n+    for (int i = 0; i < _delayed_compiled_method_load_events->length(); i++) {\n+      nmethod* nm = _delayed_compiled_method_load_events->at(i);\n+      nm->post_compiled_method_load_event();\n+    }\n+    delete _delayed_compiled_method_load_events;\n+    _delayed_compiled_method_load_events = nullptr;\n+  }\n+}\n+#endif\n+\n@@ -2508,0 +2536,10 @@\n+#if INCLUDE_CDS\n+  if (!ServiceThread::has_started()) {\n+    \/\/ With AOT-linked classes, we could compile wrappers for native methods before the\n+    \/\/ ServiceThread has been started, so we must delay the events to be posted later.\n+    assert(state == nullptr, \"must be\");\n+    add_delayed_compiled_method_load_event(this);\n+    return;\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -968,0 +968,6 @@\n+#if INCLUDE_CDS\n+  static void add_delayed_compiled_method_load_event(nmethod* nm);\n+public:\n+  static void post_delayed_compiled_method_load_events();\n+#endif\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-DEBUG_ONLY(JavaThread* ServiceThread::_instance = nullptr;)\n+JavaThread* ServiceThread::_instance = nullptr;\n@@ -65,1 +65,1 @@\n-  DEBUG_ONLY(_instance = thread;)\n+  _instance = thread;\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  DEBUG_ONLY(static JavaThread* _instance;)\n+  static JavaThread* _instance;\n@@ -47,0 +47,1 @@\n+  static bool has_started() { return  _instance != nullptr; }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -346,0 +346,5 @@\n+  \/\/ This is before the execution of the very first Java bytecode.\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    AOTLinkedClassBulkLoader::link_classes(THREAD);\n+  }\n+\n@@ -745,0 +750,4 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    nmethod::post_delayed_compiled_method_load_events();\n+  }\n+\n@@ -777,1 +786,1 @@\n-    AOTLinkedClassBulkLoader::link_or_init_javabase_classes(THREAD);\n+    AOTLinkedClassBulkLoader::init_javabase_classes(THREAD);\n@@ -796,1 +805,1 @@\n-    AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes(THREAD);\n+    AOTLinkedClassBulkLoader::init_non_javabase_classes(THREAD);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -573,0 +573,1 @@\n+ -runtime\/cds\/appcds\/VerifyObjArrayCloneTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -177,3 +177,0 @@\n-               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldConsumer is excluded\")\n-               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldProvider is excluded\")\n-               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldClass is excluded\")\n@@ -182,3 +179,1 @@\n-               .shouldNotMatch(\"klasses.* app *SubOfOldClass[$][$]Lambda\/\")\n-               .shouldMatch(\"archived indy *CP entry.*StringConcatTest .* => java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants\")\n-               .shouldNotMatch(\"archived indy *CP entry.*StringConcatTestOld .* => java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants\");\n+               .shouldMatch(\"archived indy *CP entry.*StringConcatTest .* => java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"}]}