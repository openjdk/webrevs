{"files":[{"patch":"@@ -37,1 +37,0 @@\n-#include \"code\/nmethod.hpp\"\n@@ -346,26 +345,0 @@\n-static GrowableArrayCHeap<nmethod*, mtClassShared>* _delayed_compiled_method_load_events = nullptr;\n-\n-\/\/ With AOT-linked classes, we could compile wrappers for native methods before the ServiceThread\n-\/\/ has been started, so we must delay the events to be posted later.\n-void AOTLinkedClassBulkLoader::add_delayed_compiled_method_load_event(nmethod* nm) {\n-  precond(CDSConfig::is_using_aot_linked_classes());\n-  precond(!ServiceThread::has_started());\n-\n-  \/\/ We are still in single threaded stage of VM bootstrap. No need to lock.\n-  if (_delayed_compiled_method_load_events == nullptr) {\n-    _delayed_compiled_method_load_events = new GrowableArrayCHeap<nmethod*, mtClassShared>();\n-  }\n-  _delayed_compiled_method_load_events->append(nm);\n-}\n-\n-void AOTLinkedClassBulkLoader::post_delayed_events() {\n-  if (_delayed_compiled_method_load_events != nullptr) {\n-    for (int i = 0; i < _delayed_compiled_method_load_events->length(); i++) {\n-      nmethod* nm = _delayed_compiled_method_load_events->at(i);\n-      nm->post_compiled_method_load_event();\n-    }\n-    delete _delayed_compiled_method_load_events;\n-    _delayed_compiled_method_load_events = nullptr;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-class nmethod;\n@@ -78,2 +77,0 @@\n-  static void add_delayed_compiled_method_load_event(nmethod* nm) NOT_CDS_RETURN;\n-  static void post_delayed_events() NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n@@ -2503,0 +2504,27 @@\n+#if INCLUDE_CDS\n+static GrowableArrayCHeap<nmethod*, mtClassShared>* _delayed_compiled_method_load_events = nullptr;\n+\n+void nmethod::add_delayed_compiled_method_load_event(nmethod* nm) {\n+  precond(CDSConfig::is_using_aot_linked_classes());\n+  precond(!ServiceThread::has_started());\n+\n+  \/\/ We are still in single threaded stage of VM bootstrap. No need to lock.\n+  if (_delayed_compiled_method_load_events == nullptr) {\n+    _delayed_compiled_method_load_events = new GrowableArrayCHeap<nmethod*, mtClassShared>();\n+  }\n+  _delayed_compiled_method_load_events->append(nm);\n+}\n+\n+void nmethod::post_delayed_compiled_method_load_events() {\n+  precond(ServiceThread::has_started());\n+  if (_delayed_compiled_method_load_events != nullptr) {\n+    for (int i = 0; i < _delayed_compiled_method_load_events->length(); i++) {\n+      nmethod* nm = _delayed_compiled_method_load_events->at(i);\n+      nm->post_compiled_method_load_event();\n+    }\n+    delete _delayed_compiled_method_load_events;\n+    _delayed_compiled_method_load_events = nullptr;\n+  }\n+}\n+#endif\n+\n@@ -2508,0 +2536,10 @@\n+#if INCLUDE_CDS\n+  if (!ServiceThread::has_started()) {\n+    \/\/ With AOT-linked classes, we could compile wrappers for native methods before the\n+    \/\/ ServiceThread has been started, so we must delay the events to be posted later.\n+    assert(state == nullptr, \"must be\");\n+    add_delayed_compiled_method_load_event(this);\n+    return;\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -968,0 +968,6 @@\n+#if INCLUDE_CDS\n+  static void add_delayed_compiled_method_load_event(nmethod* nm);\n+public:\n+  static void post_delayed_compiled_method_load_events();\n+#endif\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -73,1 +72,0 @@\n-#include \"runtime\/serviceThread.hpp\"\n@@ -3216,6 +3214,1 @@\n-    if (!ServiceThread::has_started()) {\n-      \/\/ Not ready to post JVMTI events yet.\n-      AOTLinkedClassBulkLoader::add_delayed_compiled_method_load_event(nm);\n-    } else {\n-      nm->post_compiled_method_load_event();\n-    }\n+    nm->post_compiled_method_load_event();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -751,1 +751,1 @@\n-    AOTLinkedClassBulkLoader::post_delayed_events();\n+    nmethod::post_delayed_compiled_method_load_events();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}