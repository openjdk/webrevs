{"files":[{"patch":"@@ -4617,1 +4617,1 @@\n-     * Then the length of the reordering array must be {@code #O    },\n+     * Then the length of the reordering array must be {@code #O},\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,134 +0,0 @@\n-package jdk.internal.foreign;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandleProxies;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Parameter;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.Objects;\n-\n-public final class MethodHandleMapper {\n-\n-    private MethodHandleMapper() {}\n-\n-    public static <T, R> R mapSystemCall(Class<T> type,\n-                                         Class<R> resultType,\n-                                         String stateName) {\n-\n-        Objects.requireNonNull(type);\n-        Objects.requireNonNull(resultType);\n-        Objects.requireNonNull(stateName);\n-\/*        final Method abstractMethod = checkTypeAndMethod(type, handle);\n-        final List<Class<?>> parameters = checkParameters(abstractMethod, handle, 0);\n-        final List<Class<?>> throwables = checkThrowables(abstractMethod);\n-        return generate(lookup, type, abstractMethod, parameters, throwables, handle, stateName);*\/\n-        return null;\n-    }\n-\n-    public static <T> T mapSystemCall(MethodHandles.Lookup lookup,\n-                                      Class<T> type,\n-                                      MethodHandle handle,\n-                                      String stateName) {\n-\n-        Objects.requireNonNull(lookup);\n-        Objects.requireNonNull(stateName);\n-        final Method abstractMethod = checkTypeAndMethod(type, handle);\n-        final List<Class<?>> parameters = checkParameters(abstractMethod, handle, 0);\n-        final List<Class<?>> throwables = checkThrowables(abstractMethod);\n-        return generate(lookup, type, abstractMethod, parameters, throwables, handle, stateName);\n-    }\n-\n-    public static <T> T map(MethodHandles.Lookup lookup,\n-                            Class<T> type,\n-                            MethodHandle handle) {\n-        Objects.requireNonNull(lookup);\n-        final Method abstractMethod = checkTypeAndMethod(type, handle);\n-        final List<Class<?>> parameters = checkParameters(abstractMethod, handle, 0);\n-        final List<Class<?>> throwables = checkThrowables(abstractMethod);\n-        return MethodHandleProxies.asInterfaceInstance(type, handle);\n-    }\n-\n-    private static <T> T generate(MethodHandles.Lookup lookup,\n-                                  Class<T> type,\n-                                  Method abstractMethod,\n-                                  List<Class<?>> parameters,\n-                                  List<Class<?>> throwables,\n-                                  MethodHandle handle,\n-                                  String stateName) {\n-        \/\/ generate\n-        \/\/ lookup.defineHiddenClass(...)\n-        return MethodHandleProxies.asInterfaceInstance(type, handle);\n-    }\n-\n-    private static Method checkTypeAndMethod(Class<?> type,\n-                                             MethodHandle handle) {\n-        Objects.requireNonNull(type);\n-        Objects.requireNonNull(handle);\n-        if (!type.isInterface()) {\n-            throw newIAE(type, \"is not an interface\");\n-        }\n-        if (type.isHidden()) {\n-            throw newIAE(type, \"is hidden\");\n-        }\n-        if (type.isSealed()) {\n-            throw newIAE(type, \"is sealed\");\n-        }\n-        if (type.getAnnotation(FunctionalInterface.class) == null) {\n-            throw newIAE(type, \"is not a @\" + FunctionalInterface.class.getSimpleName());\n-        }\n-        if (!(type.getTypeParameters().length == 0)) {\n-            throw newIAE(type, \"has type parameters\");\n-        }\n-\n-        Method abstractMethod = null;\n-        for (Method m : type.getMethods()) {\n-            if (Modifier.isAbstract(m.getModifiers())) {\n-                abstractMethod = m;\n-            }\n-        }\n-        if (abstractMethod == null) {\n-            throw new InternalError(\"Unable to find the abstract method in \" + type);\n-        }\n-\n-        final Class<?> returnType = abstractMethod.getReturnType();\n-        final Class<?> handleReturnType = handle.type().returnType();\n-        if (!returnType.equals(handleReturnType)) {\n-            throw newIAE(type, \" has a return type of '\" + returnType +\n-                    \"' but the provided handle has a return type of '\" + handleReturnType + \"'\");\n-        }\n-        return abstractMethod;\n-    }\n-\n-    private static List<Class<?>> checkParameters(Method method,\n-                                                  MethodHandle handle,\n-                                                  int handleOffset) {\n-        final List<Class<?>> parameters = new ArrayList<>();\n-        final MethodType handleType = handle.type();\n-        final Parameter[] methodParameters = method.getParameters();\n-        for (int i = 0; i < methodParameters.length; i++) {\n-            final Parameter parameter = methodParameters[i];\n-            if (!(parameter.getType().equals(handleType.parameterType(i + handleOffset)))) {\n-                throw new IllegalArgumentException(\"The abstract method \" + method + \" has a parameter list of \" +\n-                        Arrays.toString(methodParameters) + \" but the method handle has \" + handleType);\n-            }\n-            parameters.add(parameter.getType());\n-        }\n-        return List.copyOf(parameters);\n-    }\n-\n-    private static List<Class<?>> checkThrowables(Method method) {\n-        final Class<?>[] exceptionTypes = method.getExceptionTypes();\n-        final List<Class<?>> exceptions = new ArrayList<>(Arrays.asList(exceptionTypes));\n-        return List.copyOf(exceptions);\n-    }\n-\n-    private static IllegalArgumentException newIAE(Class<?> type, String msg) {\n-        return new IllegalArgumentException(type + \" \" + msg);\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MethodHandleMapper.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test TestMethodHandleMapper\n- * @modules java.base\/jdk.internal.foreign\n- * @run junit TestMethodHandleMapper\n- *\/\n-\n-import jdk.internal.foreign.MethodHandleMapper;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.foreign.Arena;\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.VarHandle;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-final class TestMethodHandleMapper {\n-\n-    private static final String ERRNO_NAME = \"errno\";\n-\n-    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n-                    .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n-\n-    private static final MethodHandle INT_DUMMY_HANDLE;\n-    private static final MethodHandle THROWING_INT_DUMMY_HANDLE;\n-    private static final MethodHandle LONG_DUMMY_HANDLE;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            INT_DUMMY_HANDLE = lookup\n-                    .findStatic(TestMethodHandleMapper.class, \"dummy\",\n-                            MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n-            THROWING_INT_DUMMY_HANDLE = lookup\n-                    .findStatic(TestMethodHandleMapper.class, \"throwingDummy\",\n-                            MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n-            LONG_DUMMY_HANDLE = lookup\n-                    .findStatic(TestMethodHandleMapper.class, \"dummy\",\n-                            MethodType.methodType(long.class, MemorySegment.class, long.class, int.class));\n-        } catch (ReflectiveOperationException e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    @FunctionalInterface\n-    public interface RawInt {\n-        int invoke(MemorySegment segment, int result, int errno);\n-    }\n-\n-    @FunctionalInterface\n-    public interface ThrowingRawInt {\n-        int invoke(MemorySegment segment, int result, int errno) throws IllegalArgumentException;\n-    }\n-\n-    @FunctionalInterface\n-    public interface RawLong {\n-        long invoke(MemorySegment segment, long result, int errno);\n-    }\n-\n-    @Test\n-    void rawInt() {\n-        RawInt rawInt = MethodHandleMapper.map(MethodHandles.lookup(), RawInt.class, INT_DUMMY_HANDLE);\n-        try (var arena = Arena.ofConfined()) {\n-            int r = rawInt.invoke(arena.allocate(Linker.Option.captureStateLayout()), 1, 0);\n-            assertEquals(1, r);\n-        }\n-    }\n-\n-    @Test\n-    void throwingRawInt() {\n-        ThrowingRawInt throwingRawInt = MethodHandleMapper.map(MethodHandles.lookup(), ThrowingRawInt.class, THROWING_INT_DUMMY_HANDLE);\n-        try (var arena = Arena.ofConfined()) {\n-            var segment = arena.allocate(Linker.Option.captureStateLayout());\n-            int r = throwingRawInt.invoke(segment, 1, 0);\n-            assertEquals(1, r);\n-            try {\n-                throwingRawInt.invoke(segment, -1, 1);\n-            } catch (IllegalArgumentException illegalArgumentException) {\n-                \/\/ All good\n-            } catch (Throwable throwable) {\n-                fail(throwable);\n-            }\n-            try {\n-                throwingRawInt.invoke(segment, -2, 1);\n-            } catch (IllegalArgumentException illegalArgumentException) {\n-                fail(illegalArgumentException);\n-            } catch (Throwable throwable) {\n-                assertInstanceOf(ArithmeticException.class, throwable);\n-                \/\/ All good\n-            }\n-        }\n-\n-    }\n-\n-    @Test\n-    void rawLong() {\n-        RawLong rawLong = MethodHandleMapper.map(MethodHandles.lookup(), RawLong.class, LONG_DUMMY_HANDLE);\n-        try (var arena = Arena.ofConfined()) {\n-            long r = rawLong.invoke(arena.allocate(Linker.Option.captureStateLayout()), 1, 0);\n-            assertEquals(1, r);\n-        }\n-    }\n-\n-    @Test\n-    void initialInvariants() {\n-        assertThrows(NullPointerException.class, () -> MethodHandleMapper.map(null, RawInt.class, INT_DUMMY_HANDLE));\n-        assertThrows(NullPointerException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), null, INT_DUMMY_HANDLE));\n-        assertThrows(NullPointerException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), RawInt.class, null));\n-    }\n-\n-    @Test\n-    void notFunctionalInterface() {\n-        interface NotFunctional {\n-            int a();\n-        }\n-        var e = assertThrows(IllegalArgumentException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), NotFunctional.class, INT_DUMMY_HANDLE));\n-        var message = e.getMessage();\n-        assertTrue(message.contains(\"is not a @FunctionalInterface\"), message);\n-    }\n-\n-    @Test\n-    void notInterface() {\n-        final class NotInterface {\n-            int a() {\n-                return 0;\n-            }\n-        }\n-        var e = assertThrows(IllegalArgumentException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), NotInterface.class, INT_DUMMY_HANDLE));\n-        var message = e.getMessage();\n-        assertTrue(message.contains(\"is not an interface\"), message);\n-    }\n-\n-    @Test\n-    void wrongParameter() {\n-        @FunctionalInterface\n-        interface WrongParameter {\n-            int a(int a, byte b);\n-        }\n-        var e = assertThrows(IllegalArgumentException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), WrongParameter.class, INT_DUMMY_HANDLE));\n-        var message = e.getMessage();\n-        assertTrue(message.contains(\"parameter list\"), message);\n-    }\n-\n-    @Test\n-    void wrongReturnType() {\n-        @FunctionalInterface\n-        interface WrongParameter {\n-            byte a(int a, int b);\n-        }\n-        var e = assertThrows(IllegalArgumentException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), WrongParameter.class, INT_DUMMY_HANDLE));\n-        var message = e.getMessage();\n-        assertTrue(message.contains(\"return type\"), message);\n-    }\n-\n-    @Test\n-    void hasTypeParameter() {\n-        @FunctionalInterface\n-        interface HasTypeParameter<T> {\n-            int a(int a, byte b);\n-        }\n-        var e = assertThrows(IllegalArgumentException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), HasTypeParameter.class, INT_DUMMY_HANDLE));\n-        var message = e.getMessage();\n-        assertTrue(message.contains(\"has type parameters\"), message);\n-    }\n-\n-    \/\/ Dummy method that is just returning the provided parameters\n-    private static int dummy(MemorySegment segment, int result, int errno) {\n-        ERRNO_HANDLE.set(segment, 0, errno);\n-        return result;\n-    }\n-\n-    \/\/ Dummy method that is just returning the provided parameters\n-    private static int throwingDummy(MemorySegment segment, int result, int errno) throws IllegalArgumentException {\n-        ERRNO_HANDLE.set(segment, 0, errno);\n-        if (result == -1) {\n-            throw new IllegalArgumentException();\n-        }\n-        if (result == -2) {\n-            throw new ArithmeticException();\n-        }\n-        return result;\n-    }\n-\n-    \/\/ Dummy method that is just returning the provided parameters\n-    private static long dummy(MemorySegment segment, long result, int errno) {\n-        ERRNO_HANDLE.set(segment, 0, errno);\n-        return result;\n-    }\n-\n-    private static long wrongType(long result, int errno) {\n-        return 0;\n-    }\n-\n-    private static short wrongType(MemorySegment segment, long result, int errno) {\n-        return 0;\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/TestMethodHandleMapper.java","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"}]}