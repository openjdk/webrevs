{"files":[{"patch":"@@ -4617,1 +4617,1 @@\n-     * Then the length of the reordering array must be {@code #O},\n+     * Then the length of the reordering array must be {@code #O    },\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,376 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.invoke.MhUtil;\n+import jdk.internal.misc.TerminatingThreadLocal;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public final class CaptureStateUtil {\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+    private static final long SIZE = Linker.Option.captureStateLayout().byteSize();\n+\n+    private static final TerminatingThreadLocal<SegmentCache> TL_CACHE = new TerminatingThreadLocal<>() {\n+        @Override\n+        protected void threadTerminated(SegmentCache stack) {\n+            stack.close();\n+        }\n+    };\n+\n+    private static final MethodHandle NON_NEGATIVE_INT_MH =\n+            MhUtil.findStatic(LOOKUP, \"nonNegative\",\n+                    MethodType.methodType(boolean.class, int.class));\n+\n+    private static final MethodHandle SUCCESS_INT_MH =\n+            MhUtil.findStatic(LOOKUP, \"success\",\n+                    MethodType.methodType(int.class, int.class, MemorySegment.class));\n+\n+    private static final MethodHandle ERROR_INT_MH =\n+            MhUtil.findStatic(LOOKUP, \"error\",\n+                    MethodType.methodType(int.class, MethodHandle.class, int.class, MemorySegment.class));\n+\n+    private static final MethodHandle NON_NEGATIVE_LONG_MH =\n+            MhUtil.findStatic(LOOKUP, \"nonNegative\",\n+                    MethodType.methodType(boolean.class, long.class));\n+\n+    private static final MethodHandle SUCCESS_LONG_MH =\n+            MhUtil.findStatic(LOOKUP, \"success\",\n+                    MethodType.methodType(long.class, long.class, MemorySegment.class));\n+\n+    private static final MethodHandle ERROR_LONG_MH =\n+            MhUtil.findStatic(LOOKUP, \"error\",\n+                    MethodType.methodType(long.class, MethodHandle.class, long.class, MemorySegment.class));\n+\n+    private static final MethodHandle ACQUIRE_CACHE_MH =\n+            MhUtil.findStatic(LOOKUP, \"acquireCache\",\n+                    MethodType.methodType(SegmentCache.class));\n+\n+    private static final MethodHandle ACQUIRE_SEGMENT_MH =\n+            MhUtil.findVirtual(LOOKUP, SegmentCache.class, \"acquire\",\n+                    MethodType.methodType(MemorySegment.class));\n+\n+    private static final MethodHandle RELEASE_SEGMENT_MH =\n+            MhUtil.findVirtual(LOOKUP, SegmentCache.class, \"release\",\n+                    MethodType.methodType(void.class, MemorySegment.class));\n+\n+\n+    \/\/ (int.class | long.class) ->\n+    \/\/   ({\"GetLastError\" | \"WSAGetLastError\"} | \"errno\") ->\n+    \/\/     MethodHandle\n+    private static final Map<Class<?>, Map<String, MethodHandle>> CAPTURE_STATE_EXTRACTORS;\n+\n+    static {\n+\n+        final StructLayout stateLayout = Linker.Option.captureStateLayout();\n+        final Map<Class<?>, Map<String, MethodHandle>> classMap = new HashMap<>();\n+        for (var clazz : new Class<?>[]{int.class, long.class}) {\n+            Map<String, MethodHandle> handles = stateLayout\n+                    .memberLayouts().stream()\n+                    .collect(Collectors.toUnmodifiableMap(\n+                            member -> member.name().orElseThrow(),\n+                            member -> {\n+                                VarHandle vh = stateLayout.varHandle(MemoryLayout.PathElement.groupElement(member.name().orElseThrow()));\n+                                \/\/ (MemorySegment, long)int\n+                                MethodHandle mh = vh.toMethodHandle(VarHandle.AccessMode.GET);\n+                                \/\/ (MemorySegment)int\n+                                return MethodHandles.insertArguments(mh, 1, 0L);\n+                            }\n+                    ));\n+            classMap.put(clazz, handles);\n+        }\n+        CAPTURE_STATE_EXTRACTORS = Map.copyOf(classMap);\n+    }\n+\n+    private CaptureStateUtil() {\n+    }\n+\n+    \/**\n+     * {@return a new MethodHandle that adapts the provided {@code target} so that it\n+     *          directly returns the same value as the {@code target} if it is\n+     *          non-negative, otherwise returns the negated errno}\n+     * <p>\n+     * This method is suitable for adapting system-call method handles(e.g.\n+     * {@code open()}, {@code read()}, and {@code close()}). Clients can check the return\n+     * value as shown in this example:\n+     * {@snippet lang = java:\n+     *       \/\/ (MemorySegment capture, MemorySegment pathname, int flags)int\n+     *       static final MethodHandle CAPTURING_OPEN = ...\n+     *\n+     *      \/\/ (MemorySegment pathname, int flags)int\n+     *      static final MethodHandle OPEN = CaptureStateUtil.adaptSystemCall(CAPTURING_OPEN, \"errno\");\n+     *\n+     *      try {\n+     *         int fh = (int)OPEN.invoke(pathName, flags);\n+     *         if (fh < 0) {\n+     *             throw new IOException(\"Error opening file: errno = \" + (-fh));\n+     *         }\n+     *         processFile(fh);\n+     *      } catch (Throwable t) {\n+     *           throw new RuntimeException(t);\n+     *      }\n+     *\n+     *}\n+     * For a method handle that takes a MemorySegment and two int parameters, the method\n+     * combinators are doing the equivalent of:\n+     *\n+     * {@snippet lang = java:\n+     *         public int invoke(int a, int b) {\n+     *             final SegmentCache segmentCache = acquireCache();\n+     *             final MemorySegment segment = segmentCache.acquire();\n+     *             try {\n+     *                 final int result = (int) handle.invoke(segment, a, b);\n+     *                 if (result >= 0) {\n+     *                     return result;\n+     *                 }\n+     *                 return -(int) errorHandle.get(segment);\n+     *             } finally {\n+     *                 segmentCache.release(segment);\n+     *             }\n+     *         }\n+     *}\n+     * Where {@code handle} is the original method handle with the coordinated\n+     * {@code (MemorySegment, int, int)int} and {@code errnoHandle} is a method handle\n+     * that retrieves the error code from the capturing segment.\n+     *\n+     *\n+     * @param target    method handle that returns an {@code int} or a {@code long} and has\n+     *                  a capturing state MemorySegment as its first parameter\n+     * @param stateName the name of the capturing state member layout\n+     *                  (i.e. \"errno\",\"GetLastError\", or \"WSAGetLastError\")\n+     * @throws IllegalArgumentException if the provided {@code target}'s return type is\n+     *                                  not {@code int} or {@code long}\n+     * @throws IllegalArgumentException if the provided {@code target}'s first parameter\n+     *                                  type is not {@linkplain MemorySegment}\n+     *\/\n+    public static MethodHandle adaptSystemCall(MethodHandle target, String stateName) {\n+        \/\/ Implicit null check\n+        final Class<?> returnType = target.type().returnType();\n+        Objects.requireNonNull(stateName);\n+\n+        if (!(returnType.equals(int.class) || returnType.equals(long.class))) {\n+            throw illegalArgDoesNot(target, \"return an int or a long\");\n+        }\n+        if (target.type().parameterType(0) != MemorySegment.class) {\n+            throw illegalArgDoesNot(target, \"have a MemorySegment as the first parameter\");\n+        }\n+\n+        \/\/ ((int | long), MemorySegment)(int | long)\n+        final MethodHandle captureStateExtractor = CAPTURE_STATE_EXTRACTORS\n+                .get(returnType)\n+                .get(stateName);\n+        if (captureStateExtractor == null) {\n+            throw new IllegalArgumentException(\"Unknown state name: \" + stateName);\n+        }\n+\n+        final boolean isInt = (returnType == int.class);\n+\n+        \/\/ Todo: Cache the error handles\n+        \/\/ ((int|long), MemorySegment)(int|long)\n+        MethodHandle inner = MethodHandles.guardWithTest(\n+                isInt ? NON_NEGATIVE_INT_MH : NON_NEGATIVE_LONG_MH,\n+                isInt ? SUCCESS_INT_MH : SUCCESS_LONG_MH,\n+                (isInt ? ERROR_INT_MH : ERROR_LONG_MH).bindTo(captureStateExtractor));\n+\n+        \/\/ (C0=MemorySegment, C1-Cn, MemorySegment)(int|long)\n+        inner = MethodHandles.collectArguments(inner, 0, target);\n+\n+        int[] perm = new int[target.type().parameterCount() + 1];\n+        for (int i = 0; i < target.type().parameterCount(); i++) {\n+            perm[i] = i;\n+        }\n+        perm[target.type().parameterCount()] = 0;\n+        \/\/ Deduplicate the first and last coordinate and only use the first\n+        \/\/ (C0=MemorySegment, C1-Cn)(int|long)\n+        inner = MethodHandles.permuteArguments(inner, target.type(), perm);\n+\n+        \/\/ (SegmentStack, C0=MemorySegment, C1-Cn)(int|long)\n+        inner = MethodHandles.dropArguments(inner, 0, SegmentCache.class);\n+\n+        \/\/ ((int|long))(int|long)\n+        MethodHandle cleanup = MethodHandles.identity(returnType);\n+        \/\/ (Throwable, (int|long))(int|long)\n+        cleanup = MethodHandles.dropArguments(cleanup, 0, Throwable.class);\n+        \/\/ (Throwable, (int|long), SegmentStack, C0=MemorySegment)(int|long)\n+        \/\/ Cleanup does not have to have all parameters. It can have zero or more.\n+        cleanup = MethodHandles.collectArguments(cleanup, 2, RELEASE_SEGMENT_MH);\n+\n+        \/\/ (SegmentStack, C0=MemorySegment, C1-Cn)(int|long)\n+        MethodHandle tryFinally = MethodHandles.tryFinally(inner, cleanup);\n+\n+        \/\/ (SegmentStack, SegmentStack, C1-Cn)(int|long)\n+        MethodHandle result = MethodHandles.filterArguments(tryFinally, 1, ACQUIRE_SEGMENT_MH);\n+\n+        final MethodType newType = result.type().dropParameterTypes(0, 1);\n+        perm = new int[result.type().parameterCount()];\n+        perm[0] = 0;\n+        for (int i = 1; i < result.type().parameterCount(); i++) {\n+            perm[i] = i - 1;\n+        }\n+        \/\/ Deduplicate the first and second coordinate and only use the first\n+        \/\/ (SegmentStack, C1-Cn)(int|long)\n+        result = MethodHandles.permuteArguments(result, newType, perm);\n+\n+        \/\/ Finally we arrive at (C1-Cn)(int|long)\n+        result = MethodHandles.collectArguments(result, 0, ACQUIRE_CACHE_MH);\n+\n+        return result;\n+    }\n+\n+    private static IllegalArgumentException illegalArgDoesNot(MethodHandle target, String info) {\n+        return new IllegalArgumentException(\"The provided target \" + target\n+                + \" does not \" + info);\n+    }\n+\n+    \/**\n+     * A cache of a memory segments to allow reuse. In many cases, only one segment will\n+     * ever be allocated per platform thread. However, if a virtual thread becomes\n+     * unmounted from its platform thread and another virtual thread acquires a new\n+     * segment. Having a secondary cache of these is slower than using malloc\/free directly.\n+     * <p>\n+     * The `cachedField` is about three times faster than a more general `deque`.\n+     * <p>\n+     * The class is using Unsafe rather than other supported APIs to allow early use\n+     * in the boostrap sequence.\n+     *\/\n+    private static final class SegmentCache {\n+\n+        private static final long CACHED_SEGMENT_OFFSET =\n+                UNSAFE.objectFieldOffset(SegmentCache.class, \"cachedSegment\");\n+        private MemorySegment cachedSegment;\n+\n+        \/\/ Used reflectively\n+        @ForceInline\n+        private MemorySegment acquire() {\n+            final MemorySegment segment = acquireFromCache();\n+            return segment == null ? malloc() : segment;\n+        }\n+\n+        \/\/ Used reflectively\n+        @ForceInline\n+        private void release(MemorySegment segment) {\n+            if (!releaseToCache(segment)) {\n+                free(segment);\n+            }\n+        }\n+\n+        \/\/ This method is called by a separate cleanup thread when the associated\n+        \/\/ platform thread is dead. So, there is no concurrent use here.\n+        \/\/ The method consumes the cached element in order for the method to be idempotent\n+        \/\/ which might be a bit paranoid.\n+        private void close() {\n+            final MemorySegment cSeg = acquireFromCache();\n+            if (cSeg != null) {\n+                free(cSeg);\n+            }\n+        }\n+\n+        @ForceInline\n+        private MemorySegment acquireFromCache() {\n+            return (MemorySegment) UNSAFE.getAndSetReference(this, CACHED_SEGMENT_OFFSET, null);\n+        }\n+\n+        @ForceInline\n+        private boolean releaseToCache(MemorySegment segment) {\n+            return UNSAFE.compareAndSetReference(this, CACHED_SEGMENT_OFFSET, null, segment);\n+        }\n+\n+        @SuppressWarnings(\"restricted\")\n+        @ForceInline\n+        private static MemorySegment malloc() {\n+            final long address = UNSAFE.allocateMemory(SIZE);\n+            return MemorySegment.ofAddress(address).reinterpret(SIZE);\n+        }\n+\n+        @ForceInline\n+        private static void free(MemorySegment segment) {\n+            UNSAFE.freeMemory(segment.address());\n+        }\n+\n+    }\n+\n+    \/\/ Support method used as method handles\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static SegmentCache acquireCache() {\n+        SegmentCache cache = TL_CACHE.get();\n+        if (cache == null) {\n+            TL_CACHE.set(cache = new SegmentCache());\n+        }\n+        return cache;\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static boolean nonNegative(int value) {\n+        return value >= 0;\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static int success(int value, MemorySegment segment) {\n+        return value;\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static int error(MethodHandle errorHandle, int value, MemorySegment segment) throws Throwable {\n+        return -(int) errorHandle.invokeExact(segment);\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static boolean nonNegative(long value) {\n+        return value >= 0L;\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static long success(long value, MemorySegment segment) {\n+        return value;\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static long error(MethodHandle errorHandle, long value, MemorySegment segment) throws Throwable {\n+        return -(int) errorHandle.invokeExact(segment);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil.java","additions":376,"deletions":0,"binary":false,"changes":376,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+package jdk.internal.foreign;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Parameter;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public final class MethodHandleMapper {\n+\n+    private MethodHandleMapper() {}\n+\n+    public static <T, R> R mapSystemCall(Class<T> type,\n+                                         Class<R> resultType,\n+                                         String stateName) {\n+\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(resultType);\n+        Objects.requireNonNull(stateName);\n+\/*        final Method abstractMethod = checkTypeAndMethod(type, handle);\n+        final List<Class<?>> parameters = checkParameters(abstractMethod, handle, 0);\n+        final List<Class<?>> throwables = checkThrowables(abstractMethod);\n+        return generate(lookup, type, abstractMethod, parameters, throwables, handle, stateName);*\/\n+        return null;\n+    }\n+\n+    public static <T> T mapSystemCall(MethodHandles.Lookup lookup,\n+                                      Class<T> type,\n+                                      MethodHandle handle,\n+                                      String stateName) {\n+\n+        Objects.requireNonNull(lookup);\n+        Objects.requireNonNull(stateName);\n+        final Method abstractMethod = checkTypeAndMethod(type, handle);\n+        final List<Class<?>> parameters = checkParameters(abstractMethod, handle, 0);\n+        final List<Class<?>> throwables = checkThrowables(abstractMethod);\n+        return generate(lookup, type, abstractMethod, parameters, throwables, handle, stateName);\n+    }\n+\n+    public static <T> T map(MethodHandles.Lookup lookup,\n+                            Class<T> type,\n+                            MethodHandle handle) {\n+        Objects.requireNonNull(lookup);\n+        final Method abstractMethod = checkTypeAndMethod(type, handle);\n+        final List<Class<?>> parameters = checkParameters(abstractMethod, handle, 0);\n+        final List<Class<?>> throwables = checkThrowables(abstractMethod);\n+        return MethodHandleProxies.asInterfaceInstance(type, handle);\n+    }\n+\n+    private static <T> T generate(MethodHandles.Lookup lookup,\n+                                  Class<T> type,\n+                                  Method abstractMethod,\n+                                  List<Class<?>> parameters,\n+                                  List<Class<?>> throwables,\n+                                  MethodHandle handle,\n+                                  String stateName) {\n+        \/\/ generate\n+        \/\/ lookup.defineHiddenClass(...)\n+        return MethodHandleProxies.asInterfaceInstance(type, handle);\n+    }\n+\n+    private static Method checkTypeAndMethod(Class<?> type,\n+                                             MethodHandle handle) {\n+        Objects.requireNonNull(type);\n+        Objects.requireNonNull(handle);\n+        if (!type.isInterface()) {\n+            throw newIAE(type, \"is not an interface\");\n+        }\n+        if (type.isHidden()) {\n+            throw newIAE(type, \"is hidden\");\n+        }\n+        if (type.isSealed()) {\n+            throw newIAE(type, \"is sealed\");\n+        }\n+        if (type.getAnnotation(FunctionalInterface.class) == null) {\n+            throw newIAE(type, \"is not a @\" + FunctionalInterface.class.getSimpleName());\n+        }\n+        if (!(type.getTypeParameters().length == 0)) {\n+            throw newIAE(type, \"has type parameters\");\n+        }\n+\n+        Method abstractMethod = null;\n+        for (Method m : type.getMethods()) {\n+            if (Modifier.isAbstract(m.getModifiers())) {\n+                abstractMethod = m;\n+            }\n+        }\n+        if (abstractMethod == null) {\n+            throw new InternalError(\"Unable to find the abstract method in \" + type);\n+        }\n+\n+        final Class<?> returnType = abstractMethod.getReturnType();\n+        final Class<?> handleReturnType = handle.type().returnType();\n+        if (!returnType.equals(handleReturnType)) {\n+            throw newIAE(type, \" has a return type of '\" + returnType +\n+                    \"' but the provided handle has a return type of '\" + handleReturnType + \"'\");\n+        }\n+        return abstractMethod;\n+    }\n+\n+    private static List<Class<?>> checkParameters(Method method,\n+                                                  MethodHandle handle,\n+                                                  int handleOffset) {\n+        final List<Class<?>> parameters = new ArrayList<>();\n+        final MethodType handleType = handle.type();\n+        final Parameter[] methodParameters = method.getParameters();\n+        for (int i = 0; i < methodParameters.length; i++) {\n+            final Parameter parameter = methodParameters[i];\n+            if (!(parameter.getType().equals(handleType.parameterType(i + handleOffset)))) {\n+                throw new IllegalArgumentException(\"The abstract method \" + method + \" has a parameter list of \" +\n+                        Arrays.toString(methodParameters) + \" but the method handle has \" + handleType);\n+            }\n+            parameters.add(parameter.getType());\n+        }\n+        return List.copyOf(parameters);\n+    }\n+\n+    private static List<Class<?>> checkThrowables(Method method) {\n+        final Class<?>[] exceptionTypes = method.getExceptionTypes();\n+        final List<Class<?>> exceptions = new ArrayList<>(Arrays.asList(exceptionTypes));\n+        return List.copyOf(exceptions);\n+    }\n+\n+    private static IllegalArgumentException newIAE(Class<?> type, String msg) {\n+        return new IllegalArgumentException(type + \" \" + msg);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MethodHandleMapper.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,9 @@\n+    public static MethodHandle findStatic(MethodHandles.Lookup lookup,\n+                                          String name,\n+                                          MethodType type) {\n+        try {\n+            return lookup.findStatic(lookup.lookupClass(), name, type);\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/MhUtil.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test CaptureStateUtil\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run junit TestCaptureStateUtil\n+ *\/\n+\n+import jdk.internal.foreign.CaptureStateUtil;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestCaptureStateUtil {\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n+                    .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n+\n+    private static final MethodHandle INT_DUMMY_HANDLE;\n+    private static final MethodHandle LONG_DUMMY_HANDLE;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            INT_DUMMY_HANDLE = lookup\n+                    .findStatic(TestCaptureStateUtil.class, \"dummy\",\n+                            MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+            LONG_DUMMY_HANDLE = lookup\n+                    .findStatic(TestCaptureStateUtil.class, \"dummy\",\n+                            MethodType.methodType(long.class, MemorySegment.class, long.class, int.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static final MethodHandle ADAPTED_INT = CaptureStateUtil.adaptSystemCall(INT_DUMMY_HANDLE, ERRNO_NAME);\n+    private static final MethodHandle ADAPTED_LONG = CaptureStateUtil.adaptSystemCall(LONG_DUMMY_HANDLE, ERRNO_NAME);\n+\n+    @Test\n+    void successfulInt() throws Throwable {\n+        int r = (int) ADAPTED_INT.invoke(1, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    private static final int EACCES = 13; \/* Permission denied *\/\n+\n+    @Test\n+    void errorInt() throws Throwable {\n+        int r = (int) ADAPTED_INT.invoke(-1, EACCES);\n+        assertEquals(-EACCES, r);\n+    }\n+\n+    @Test\n+    void successfulLong() throws Throwable {\n+        long r = (long) ADAPTED_LONG.invoke(1, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    @Test\n+    void errorLong() throws Throwable {\n+        long r = (long) ADAPTED_LONG.invoke(-1, EACCES);\n+        assertEquals(-EACCES, r);\n+    }\n+\n+    @Test\n+    void invariants() throws Throwable {\n+        MethodHandle noSegment = MethodHandles.lookup()\n+                .findStatic(TestCaptureStateUtil.class, \"wrongType\",\n+                        MethodType.methodType(long.class, long.class, int.class));\n+\n+        var noSegEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, ERRNO_NAME));\n+        assertTrue(noSegEx.getMessage().contains(\"does not have a MemorySegment as the first parameter\"));\n+\n+        MethodHandle wrongReturnType = MethodHandles.lookup()\n+                .findStatic(TestCaptureStateUtil.class, \"wrongType\",\n+                        MethodType.methodType(short.class, MemorySegment.class, long.class, int.class));\n+\n+        var wrongRetEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(wrongReturnType, ERRNO_NAME));\n+        assertTrue(wrongRetEx.getMessage().contains(\"does not return an int or a long\"));\n+\n+        var wrongCaptureName = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(LONG_DUMMY_HANDLE, \"foo\"));\n+        assertEquals(\"Unknown state name: foo\", wrongCaptureName.getMessage());\n+\n+        assertThrows(NullPointerException.class, () -> CaptureStateUtil.adaptSystemCall(null, ERRNO_NAME));\n+        assertThrows(NullPointerException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, null));\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int dummy(MemorySegment segment, int result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static long dummy(MemorySegment segment, long result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    private static long wrongType(long result, int errno) {\n+        return 0;\n+    }\n+\n+    private static short wrongType(MemorySegment segment, long result, int errno) {\n+        return 0;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestCaptureStateUtil.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test TestMethodHandleMapper\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run junit TestMethodHandleMapper\n+ *\/\n+\n+import jdk.internal.foreign.MethodHandleMapper;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestMethodHandleMapper {\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n+                    .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n+\n+    private static final MethodHandle INT_DUMMY_HANDLE;\n+    private static final MethodHandle THROWING_INT_DUMMY_HANDLE;\n+    private static final MethodHandle LONG_DUMMY_HANDLE;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            INT_DUMMY_HANDLE = lookup\n+                    .findStatic(TestMethodHandleMapper.class, \"dummy\",\n+                            MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+            THROWING_INT_DUMMY_HANDLE = lookup\n+                    .findStatic(TestMethodHandleMapper.class, \"throwingDummy\",\n+                            MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+            LONG_DUMMY_HANDLE = lookup\n+                    .findStatic(TestMethodHandleMapper.class, \"dummy\",\n+                            MethodType.methodType(long.class, MemorySegment.class, long.class, int.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    public interface RawInt {\n+        int invoke(MemorySegment segment, int result, int errno);\n+    }\n+\n+    @FunctionalInterface\n+    public interface ThrowingRawInt {\n+        int invoke(MemorySegment segment, int result, int errno) throws IllegalArgumentException;\n+    }\n+\n+    @FunctionalInterface\n+    public interface RawLong {\n+        long invoke(MemorySegment segment, long result, int errno);\n+    }\n+\n+    @Test\n+    void rawInt() {\n+        RawInt rawInt = MethodHandleMapper.map(MethodHandles.lookup(), RawInt.class, INT_DUMMY_HANDLE);\n+        try (var arena = Arena.ofConfined()) {\n+            int r = rawInt.invoke(arena.allocate(Linker.Option.captureStateLayout()), 1, 0);\n+            assertEquals(1, r);\n+        }\n+    }\n+\n+    @Test\n+    void throwingRawInt() {\n+        ThrowingRawInt throwingRawInt = MethodHandleMapper.map(MethodHandles.lookup(), ThrowingRawInt.class, THROWING_INT_DUMMY_HANDLE);\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(Linker.Option.captureStateLayout());\n+            int r = throwingRawInt.invoke(segment, 1, 0);\n+            assertEquals(1, r);\n+            try {\n+                throwingRawInt.invoke(segment, -1, 1);\n+            } catch (IllegalArgumentException illegalArgumentException) {\n+                \/\/ All good\n+            } catch (Throwable throwable) {\n+                fail(throwable);\n+            }\n+            try {\n+                throwingRawInt.invoke(segment, -2, 1);\n+            } catch (IllegalArgumentException illegalArgumentException) {\n+                fail(illegalArgumentException);\n+            } catch (Throwable throwable) {\n+                assertInstanceOf(ArithmeticException.class, throwable);\n+                \/\/ All good\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    void rawLong() {\n+        RawLong rawLong = MethodHandleMapper.map(MethodHandles.lookup(), RawLong.class, LONG_DUMMY_HANDLE);\n+        try (var arena = Arena.ofConfined()) {\n+            long r = rawLong.invoke(arena.allocate(Linker.Option.captureStateLayout()), 1, 0);\n+            assertEquals(1, r);\n+        }\n+    }\n+\n+    @Test\n+    void initialInvariants() {\n+        assertThrows(NullPointerException.class, () -> MethodHandleMapper.map(null, RawInt.class, INT_DUMMY_HANDLE));\n+        assertThrows(NullPointerException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), null, INT_DUMMY_HANDLE));\n+        assertThrows(NullPointerException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), RawInt.class, null));\n+    }\n+\n+    @Test\n+    void notFunctionalInterface() {\n+        interface NotFunctional {\n+            int a();\n+        }\n+        var e = assertThrows(IllegalArgumentException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), NotFunctional.class, INT_DUMMY_HANDLE));\n+        var message = e.getMessage();\n+        assertTrue(message.contains(\"is not a @FunctionalInterface\"), message);\n+    }\n+\n+    @Test\n+    void notInterface() {\n+        final class NotInterface {\n+            int a() {\n+                return 0;\n+            }\n+        }\n+        var e = assertThrows(IllegalArgumentException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), NotInterface.class, INT_DUMMY_HANDLE));\n+        var message = e.getMessage();\n+        assertTrue(message.contains(\"is not an interface\"), message);\n+    }\n+\n+    @Test\n+    void wrongParameter() {\n+        @FunctionalInterface\n+        interface WrongParameter {\n+            int a(int a, byte b);\n+        }\n+        var e = assertThrows(IllegalArgumentException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), WrongParameter.class, INT_DUMMY_HANDLE));\n+        var message = e.getMessage();\n+        assertTrue(message.contains(\"parameter list\"), message);\n+    }\n+\n+    @Test\n+    void wrongReturnType() {\n+        @FunctionalInterface\n+        interface WrongParameter {\n+            byte a(int a, int b);\n+        }\n+        var e = assertThrows(IllegalArgumentException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), WrongParameter.class, INT_DUMMY_HANDLE));\n+        var message = e.getMessage();\n+        assertTrue(message.contains(\"return type\"), message);\n+    }\n+\n+    @Test\n+    void hasTypeParameter() {\n+        @FunctionalInterface\n+        interface HasTypeParameter<T> {\n+            int a(int a, byte b);\n+        }\n+        var e = assertThrows(IllegalArgumentException.class, () -> MethodHandleMapper.map(MethodHandles.lookup(), HasTypeParameter.class, INT_DUMMY_HANDLE));\n+        var message = e.getMessage();\n+        assertTrue(message.contains(\"has type parameters\"), message);\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int dummy(MemorySegment segment, int result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int throwingDummy(MemorySegment segment, int result, int errno) throws IllegalArgumentException {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        if (result == -1) {\n+            throw new IllegalArgumentException();\n+        }\n+        if (result == -2) {\n+            throw new ArithmeticException();\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static long dummy(MemorySegment segment, long result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    private static long wrongType(long result, int errno) {\n+        return 0;\n+    }\n+\n+    private static short wrongType(MemorySegment segment, long result, int errno) {\n+        return 0;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMethodHandleMapper.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import jdk.internal.foreign.CaptureStateUtil;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\",\n+        \"--enable-native-access=ALL-UNNAMED\"})\n+public class CaptureStateUtilBench {\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n+            .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n+\n+    private static final long SIZE = Linker.Option.captureStateLayout().byteSize();\n+\n+    private static final MethodHandle DUMMY_EXPLICIT_ALLOC = dummyExplicitAlloc();\n+    private static final MethodHandle DUMMY_TL_ALLOC = dummyTlAlloc();\n+\n+    @Benchmark\n+    public int explicitAllocationSuccess() throws Throwable {\n+        try (var arena = Arena.ofConfined()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invoke(arena.allocate(SIZE), 0, 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int explicitAllocationFail() throws Throwable {\n+        try (var arena = Arena.ofConfined()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invoke(arena.allocate(SIZE), -1, 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int threadLocalReuseSuccess() throws Throwable {\n+        return (int) DUMMY_TL_ALLOC.invoke(0, 0);\n+    }\n+\n+    @Benchmark\n+    public int threadLocalFail() throws Throwable {\n+        return (int) DUMMY_TL_ALLOC.invoke( -1, 1);\n+    }\n+\n+    private static MethodHandle dummyExplicitAlloc() {\n+        try {\n+            return MethodHandles.lookup().findStatic(CaptureStateUtilBench.class,\n+                    \"dummy\", MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+        } catch (ReflectiveOperationException roe) {\n+            throw new RuntimeException(roe);\n+        }\n+    }\n+\n+    private static MethodHandle dummyTlAlloc() {\n+        final MethodHandle handle = dummyExplicitAlloc();\n+        return CaptureStateUtil.adaptSystemCall(handle, ERRNO_NAME);\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int dummy(MemorySegment segment, int result, int errno) {\n+        if (errno != 0) {\n+            \/\/ Assuming the capture state is only modified upon detecting an error.\n+            ERRNO_HANDLE.set(segment, 0, errno);\n+        }\n+        return result;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CaptureStateUtilBench.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"}]}