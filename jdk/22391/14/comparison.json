{"files":[{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.invoke.MhUtil;\n+import jdk.internal.misc.TerminatingThreadLocal;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.util.SingleElementPool;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+public final class CaptureStateUtil {\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+    private static final long SIZE = Linker.Option.captureStateLayout().byteSize();\n+\n+    private static final MethodHandle NON_NEGATIVE_INT_MH =\n+            MhUtil.findStatic(LOOKUP, \"nonNegative\",\n+                    MethodType.methodType(boolean.class, int.class));\n+\n+    private static final MethodHandle SUCCESS_INT_MH =\n+            MhUtil.findStatic(LOOKUP, \"success\",\n+                    MethodType.methodType(int.class, int.class, MemorySegment.class));\n+\n+    private static final MethodHandle ERROR_INT_MH =\n+            MhUtil.findStatic(LOOKUP, \"error\",\n+                    MethodType.methodType(int.class, MethodHandle.class, int.class, MemorySegment.class));\n+\n+    private static final MethodHandle NON_NEGATIVE_LONG_MH =\n+            MhUtil.findStatic(LOOKUP, \"nonNegative\",\n+                    MethodType.methodType(boolean.class, long.class));\n+\n+    private static final MethodHandle SUCCESS_LONG_MH =\n+            MhUtil.findStatic(LOOKUP, \"success\",\n+                    MethodType.methodType(long.class, long.class, MemorySegment.class));\n+\n+    private static final MethodHandle ERROR_LONG_MH =\n+            MhUtil.findStatic(LOOKUP, \"error\",\n+                    MethodType.methodType(long.class, MethodHandle.class, long.class, MemorySegment.class));\n+\n+    private static final MethodHandle TAKE_SEGMENT_MH =\n+            MhUtil.findVirtual(LOOKUP, SegmentPool.class, \"take\",\n+                    MethodType.methodType(MemorySegment.class));\n+\n+    private static final MethodHandle RELEASE_SEGMENT_MH =\n+            MhUtil.findVirtual(LOOKUP, SegmentPool.class, \"release\",\n+                    MethodType.methodType(void.class, MemorySegment.class));\n+\n+\n+    \/\/ (int.class | long.class) ->\n+    \/\/   ({\"GetLastError\" | \"WSAGetLastError\"} | \"errno\") ->\n+    \/\/     MethodHandle\n+    private static final Map<Class<?>, Map<String, MethodHandle>> INNER_HANDLES;\n+\n+    static {\n+\n+        final StructLayout stateLayout = Linker.Option.captureStateLayout();\n+        final Map<Class<?>, Map<String, MethodHandle>> classMap = new HashMap<>();\n+        for (var returnType : new Class<?>[]{int.class, long.class}) {\n+            Map<String, MethodHandle> handles = stateLayout\n+                    .memberLayouts().stream()\n+                    .collect(Collectors.toUnmodifiableMap(\n+                            member -> member.name().orElseThrow(),\n+                            member -> {\n+                                VarHandle vh = stateLayout.varHandle(MemoryLayout.PathElement.groupElement(member.name().orElseThrow()));\n+                                \/\/ (MemorySegment, long)int\n+                                MethodHandle intExtractor = vh.toMethodHandle(VarHandle.AccessMode.GET);\n+                                \/\/ (MemorySegment)int\n+                                intExtractor = MethodHandles.insertArguments(intExtractor, 1, 0L);\n+\n+                                if (returnType.equals(int.class)) {\n+                                    \/\/ (int, MemorySegment)int\n+                                    return MethodHandles.guardWithTest(\n+                                            NON_NEGATIVE_INT_MH,\n+                                            SUCCESS_INT_MH,\n+                                            ERROR_INT_MH.bindTo(intExtractor));\n+                                } else {\n+                                    \/\/ (long, MemorySegment)long\n+                                    return MethodHandles.guardWithTest(\n+                                            NON_NEGATIVE_LONG_MH,\n+                                            SUCCESS_LONG_MH,\n+                                            ERROR_LONG_MH.bindTo(intExtractor));\n+                                }\n+                            }\n+                    ));\n+            classMap.put(returnType, handles);\n+        }\n+        INNER_HANDLES = Map.copyOf(classMap);\n+    }\n+\n+    private CaptureStateUtil() {\n+    }\n+\n+    \/**\n+     * {@return a new MethodHandle that adapts the provided {@code target} so that it\n+     *          directly returns the same value as the {@code target} if it is\n+     *          non-negative, otherwise returns the negated errno}\n+     * <p>\n+     * This method is suitable for adapting system-call method handles(e.g.\n+     * {@code open()}, {@code read()}, and {@code close()}). Clients can check the return\n+     * value as shown in this example:\n+     * {@snippet lang = java:\n+     *       \/\/ (MemorySegment capture, MemorySegment pathname, int flags)int\n+     *       static final MethodHandle CAPTURING_OPEN = ...\n+     *\n+     *      \/\/ (MemorySegment pathname, int flags)int\n+     *      static final MethodHandle OPEN = CaptureStateUtil.adaptSystemCall(CAPTURING_OPEN, \"errno\");\n+     *\n+     *      try {\n+     *         int fh = (int)OPEN.invoke(pathName, flags);\n+     *         if (fh < 0) {\n+     *             throw new IOException(\"Error opening file: errno = \" + (-fh));\n+     *         }\n+     *         processFile(fh);\n+     *      } catch (Throwable t) {\n+     *           throw new RuntimeException(t);\n+     *      }\n+     *\n+     *}\n+     * For a method handle that takes a MemorySegment and two int parameters, the method\n+     * combinators are doing the equivalent of:\n+     *\n+     * {@snippet lang = java:\n+     *         public int invoke(int a, int b) {\n+     *             final SegmentPool segmentPool = acquirePool();\n+     *             final MemorySegment segment = segmentPool.acquire();\n+     *             try {\n+     *                 final int result = (int) handle.invoke(segment, a, b);\n+     *                 if (result >= 0) {\n+     *                     return result;\n+     *                 }\n+     *                 return -(int) errorHandle.get(segment);\n+     *             } finally {\n+     *                 segmentPool.release(segment);\n+     *             }\n+     *         }\n+     *}\n+     * Where {@code handle} is the original method handle with the coordinated\n+     * {@code (MemorySegment, int, int)int} and {@code errnoHandle} is a method handle\n+     * that retrieves the error code from the capturing segment.\n+     *\n+     *\n+     * @param target    method handle that returns an {@code int} or a {@code long} and has\n+     *                  a capturing state MemorySegment as its first parameter\n+     * @param stateName the name of the capturing state member layout\n+     *                  (i.e. \"errno\",\"GetLastError\", or \"WSAGetLastError\")\n+     * @throws IllegalArgumentException if the provided {@code target}'s return type is\n+     *                                  not {@code int} or {@code long}\n+     * @throws IllegalArgumentException if the provided {@code target}'s first parameter\n+     *                                  type is not {@linkplain MemorySegment}\n+     * @throws IllegalArgumentException if the provided {@code stateName} is unknown\n+     *                                  on the current platform\n+     *\/\n+    public static MethodHandle adaptSystemCall(MethodHandle target, String stateName) {\n+        \/\/ Implicit null check\n+        final Class<?> returnType = target.type().returnType();\n+        Objects.requireNonNull(stateName);\n+\n+        if (!(returnType.equals(int.class) || returnType.equals(long.class))) {\n+            throw illegalArgDoesNot(target, \"return an int or a long\");\n+        }\n+        if (target.type().parameterCount() == 0 || target.type().parameterType(0) != MemorySegment.class) {\n+            throw illegalArgDoesNot(target, \"have a MemorySegment as the first parameter\");\n+        }\n+\n+        \/\/ ((int | long), MemorySegment)(int | long)\n+        MethodHandle inner = INNER_HANDLES\n+                .get(returnType)\n+                .get(stateName);\n+        if (inner == null) {\n+            throw new IllegalArgumentException(\"Unknown state name: \" + stateName +\n+                    \". Known on this platform: \" + Linker.Option.captureStateLayout());\n+        }\n+\n+        \/\/ Make `target` specific adaptations\n+\n+        \/\/ (C0=MemorySegment, C1-Cn, MemorySegment)(int|long)\n+        inner = MethodHandles.collectArguments(inner, 0, target);\n+\n+        int[] perm = new int[target.type().parameterCount() + 1];\n+        for (int i = 0; i < target.type().parameterCount(); i++) {\n+            perm[i] = i;\n+        }\n+        perm[target.type().parameterCount()] = 0;\n+        \/\/ Deduplicate the first and last coordinate and only use the first\n+        \/\/ (C0=MemorySegment, C1-Cn)(int|long)\n+        inner = MethodHandles.permuteArguments(inner, target.type(), perm);\n+\n+        \/\/ (SegmentStack, C0=MemorySegment, C1-Cn)(int|long)\n+        inner = MethodHandles.dropArguments(inner, 0, SegmentPool.class);\n+\n+        \/\/ ((int|long))(int|long)\n+        MethodHandle cleanup = MethodHandles.identity(returnType);\n+        \/\/ (Throwable, (int|long))(int|long)\n+        cleanup = MethodHandles.dropArguments(cleanup, 0, Throwable.class);\n+        \/\/ (Throwable, (int|long), SegmentStack, C0=MemorySegment)(int|long)\n+        \/\/ Cleanup does not have to have all parameters. It can have zero or more.\n+        cleanup = MethodHandles.collectArguments(cleanup, 2, RELEASE_SEGMENT_MH);\n+\n+        \/\/ (SegmentStack, C0=MemorySegment, C1-Cn)(int|long)\n+        MethodHandle tryFinally = MethodHandles.tryFinally(inner, cleanup);\n+\n+        \/\/ (SegmentStack, SegmentStack, C1-Cn)(int|long)\n+        MethodHandle result = MethodHandles.filterArguments(tryFinally, 1, TAKE_SEGMENT_MH);\n+\n+        final MethodType newType = result.type().dropParameterTypes(0, 1);\n+        perm = new int[result.type().parameterCount()];\n+        perm[0] = 0;\n+        for (int i = 1; i < result.type().parameterCount(); i++) {\n+            perm[i] = i - 1;\n+        }\n+        \/\/ Deduplicate the first and second coordinate and only use the first\n+        \/\/ (SegmentStack, C1-Cn)(int|long)\n+        result = MethodHandles.permuteArguments(result, newType, perm);\n+\n+        \/\/ Finally we arrive at (C1-Cn)(int|long)\n+        return MethodHandles.collectArguments(result, 0, SegmentPool.ACQUIRE_POOL_MH);\n+    }\n+\n+    private static IllegalArgumentException illegalArgDoesNot(MethodHandle target, String info) {\n+        return new IllegalArgumentException(\"The provided target \" + target\n+                + \" does not \" + info);\n+    }\n+\n+    \/**\n+     * A cache of a memory segments to allow reuse. In many cases, only one segment will\n+     * ever be allocated per platform thread. However, if a virtual thread becomes\n+     * unmounted from its platform thread and another virtual thread acquires a new\n+     * segment, there will be no reuse. Having a secondary cache of these is slower than\n+     * using malloc\/free directly.\n+     * <p>\n+     * The cache is about three times faster than a more general `deque`.\n+     * <p>\n+     * The class is using j.i.m.Unsafe rather than other supported APIs to allow early\n+     * use in the boostrap sequence.\n+     *\/\n+    private static final class SegmentPool\n+            extends SingleElementPool.SingleElementPoolImpl<MemorySegment> {\n+\n+        private static final TerminatingThreadLocal<SegmentPool> TL_POOLS =\n+                new TerminatingThreadLocal<>() {\n+                    @Override\n+                    protected void threadTerminated(SegmentPool pool) {\n+                        pool.close();\n+                    }\n+                };\n+\n+        private static final MethodHandle ACQUIRE_POOL_MH =\n+                MhUtil.findStatic(MethodHandles.lookup(), \"acquirePool\",\n+                        MethodType.methodType(SegmentPool.class));\n+\n+\n+        private static final Supplier<MemorySegment> FACTORY = new Supplier<>() {\n+            @SuppressWarnings(\"restricted\")\n+            @ForceInline\n+            @Override\n+            public MemorySegment get() {\n+                \/\/ malloc\n+                final long address = UNSAFE.allocateMemory(SIZE);\n+                return MemorySegment.ofAddress(address).reinterpret(SIZE);\n+            }\n+        };\n+\n+        private static final Consumer<MemorySegment> RECYCLER = new Consumer<>() {\n+            @ForceInline\n+            @Override\n+            public void accept(MemorySegment segment) {\n+                \/\/ free\n+                UNSAFE.freeMemory(segment.address());\n+            }\n+        };\n+\n+        public SegmentPool() {\n+            super(FACTORY.get(), FACTORY, RECYCLER);\n+        }\n+\n+        \/\/ We need to override `take` and `release` to specify the low-level return and\n+        \/\/ parameter types.\n+\n+        @ForceInline\n+        @Override\n+        public MemorySegment take() {\n+            return super.take();\n+        }\n+\n+        @ForceInline\n+        @Override\n+        public void release(MemorySegment element) {\n+            super.release(element);\n+        }\n+\n+        \/\/ Used reflectively\n+        @ForceInline\n+        private static SegmentPool acquirePool() {\n+            SegmentPool cache = TL_POOLS.get();\n+            if (cache == null) {\n+                TL_POOLS.set(cache = new SegmentPool());\n+            }\n+            return cache;\n+        }\n+    }\n+\n+    \/\/ Support method used as method handles\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static boolean nonNegative(int value) {\n+        return value >= 0;\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static int success(int value, MemorySegment segment) {\n+        return value;\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static int error(MethodHandle errorHandle, int value, MemorySegment segment) throws Throwable {\n+        return -(int) errorHandle.invokeExact(segment);\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static boolean nonNegative(long value) {\n+        return value >= 0L;\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static long success(long value, MemorySegment segment) {\n+        return value;\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static long error(MethodHandle errorHandle, long value, MemorySegment segment) throws Throwable {\n+        return -(int) errorHandle.invokeExact(segment);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,9 @@\n+    public static MethodHandle findStatic(MethodHandles.Lookup lookup,\n+                                          String name,\n+                                          MethodType type) {\n+        try {\n+            return lookup.findStatic(lookup.lookupClass(), name, type);\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/MhUtil.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+package jdk.internal.util;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * A high-performance single element pool where the pooled element is eagerly created\n+ * upfront.\n+ * <p>\n+ * Elements are created using a {@code factory} and released elements not in the pool are\n+ * disposed of via a {@code recycler}. The single element in a pool can be created either\n+ * by the {@linkplain SingleElementPool#of(Supplier, Consumer) factory} or\n+ * {@linkplain SingleElementPool#of(Object, Supplier, Consumer) explicitly}.\n+ *\n+ * @param <T> the pool element type\n+ *\/\n+public sealed interface SingleElementPool<T> extends AutoCloseable {\n+\n+    \/**\n+     * {@return the single pooled element if not taken, otherwise invokes the pool's\n+     *          factory to create a new element}\n+     *\/\n+    T take();\n+\n+    \/**\n+     * Releases the provided {@code element}. If the element is <em>identical<\/em> to the\n+     * single pooled element, returns it to the pool; otherwise invokes the pool's\n+     * recycler to dispose of the provided {@code element}.\n+     *\/\n+    void release(T element);\n+\n+    \/**\n+     * Recycles the single pooled element if it is released. This method is idempotent.\n+     *\/\n+    @Override\n+    void close();\n+\n+    \/**\n+     * {@return a new SingleElementPool with the single pooled element created via the\n+     *          provided {@code factory}}.\n+     * @param factory  used to create new elements\n+     * @param recycler used to dispose of elements\n+     * @param <T> the pool element type\n+     * @throws NullPointerException if either of {@code factory} or {@code recycler}\n+     *         is {@code null}\n+     *\/\n+    static <T> SingleElementPool<T> of(Supplier<? extends T> factory,\n+                                       Consumer<? super T> recycler) {\n+        return new SingleElementPoolImpl<>(factory.get(), factory, recycler);\n+    }\n+\n+    \/**\n+     * {@return a new SingleElementPool with the given single {@code pooledElement}}\n+     * @param factory  used to create new elements\n+     * @param recycler used to dispose of elements\n+     * @param <T> the pool element type\n+     * @throws NullPointerException if either of {@code factory} or {@code recycler}\n+     *         is {@code null}\n+     *\/\n+    static <T> SingleElementPool<T> of(T pooledElement,\n+                                       Supplier<? extends T> factory,\n+                                       Consumer<? super T> recycler) {\n+        return new SingleElementPoolImpl<>(pooledElement, factory, recycler);\n+    }\n+\n+    \/\/ The class is not final to allow subclassing for low-level use.\n+    non-sealed class SingleElementPoolImpl<T> implements SingleElementPool<T> {\n+\n+        private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+        private static final long POOLED_ELEMENT_TAKEN_OFFSET =\n+                UNSAFE.objectFieldOffset(SingleElementPoolImpl.class, \"pooledElementTaken\");\n+        private static final long CLOSED_OFFSET =\n+                UNSAFE.objectFieldOffset(SingleElementPoolImpl.class, \"closed\");\n+\n+        private static final int FALSE = 0;\n+        private static final int TRUE = 1;\n+\n+        @Stable\n+        private final Supplier<? extends T> factory;\n+        @Stable\n+        private final Consumer<? super T> recycler;\n+        @Stable\n+        private final T pooledElement;\n+        \/\/ Using an int lock is faster than CASing a reference field\n+        private int pooledElementTaken;\n+        private int closed;\n+\n+        public SingleElementPoolImpl(T pooledElement,\n+                                     Supplier<? extends T> factory,\n+                                     Consumer<? super T> recycler) {\n+            Objects.requireNonNull(factory);\n+            Objects.requireNonNull(recycler);\n+            this.factory = factory;\n+            this.recycler = recycler;\n+            this.pooledElement = pooledElement;\n+        }\n+\n+        \/\/ Used reflectively\n+        @ForceInline\n+        public T take() {\n+            return takePooledElement() ? pooledElement : factory.get();\n+        }\n+\n+        \/\/ Used reflectively\n+        @ForceInline\n+        public void release(T element) {\n+            if (element == pooledElement) {\n+                releasePooledElement();\n+            } else {\n+                recycler.accept(element);\n+            }\n+        }\n+\n+        \/\/ This method is called by a separate cleanup thread when the associated\n+        \/\/ platform thread is dead.\n+        public void close() {\n+            if (UNSAFE.compareAndSetInt(this, CLOSED_OFFSET, FALSE, TRUE)) {\n+                if (UNSAFE.getIntVolatile(this, POOLED_ELEMENT_TAKEN_OFFSET) == FALSE) {\n+                    recycler.accept(pooledElement);\n+                }\n+            }\n+        }\n+\n+        @ForceInline\n+        private boolean takePooledElement() {\n+            return UNSAFE.getAndSetInt(this, POOLED_ELEMENT_TAKEN_OFFSET, TRUE) == FALSE;\n+        }\n+\n+        @ForceInline\n+        private void releasePooledElement() {\n+            UNSAFE.putIntVolatile(this, POOLED_ELEMENT_TAKEN_OFFSET, FALSE);\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SingleElementPool.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+package jdk.internal.util;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+final class SingleElementPoolImpl2<T> {\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    private static final long LOCKED_OFFSET =\n+            UNSAFE.objectFieldOffset(SingleElementPoolImpl2.class, \"locked\");\n+    private static final long CLOSED_OFFSET =\n+            UNSAFE.objectFieldOffset(SingleElementPoolImpl2.class, \"closed\");\n+\n+    @Stable\n+    private final Supplier<? extends T> factory;\n+    @Stable\n+    private final Consumer<? super T> recycler;\n+    @Stable\n+    private final T pooledElement;\n+    \/\/ Using an int lock is faster than CASing a reference field\n+    private int locked;\n+    private int closed;\n+\n+    public SingleElementPoolImpl2(T pooledElement,\n+                                 Supplier<? extends T> factory,\n+                                 Consumer<? super T> recycler) {\n+        this.factory = factory;\n+        this.recycler = recycler;\n+        this.pooledElement = pooledElement;\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    public T take() {\n+        return lock() ? pooledElement : factory.get();\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    public void release(T element) {\n+        if (element == pooledElement) {\n+            unlock();\n+        } else {\n+            recycler.accept(element);\n+        }\n+    }\n+\n+    \/\/ This method is called by a separate cleanup thread when the associated\n+    \/\/ platform thread is dead.\n+    public void close() {\n+        if (!UNSAFE.compareAndSetInt(this, CLOSED_OFFSET, 0, 1)) {\n+            recycler.accept(pooledElement);\n+        }\n+    }\n+\n+    @ForceInline\n+    private boolean lock() {\n+        return UNSAFE.getAndSetInt(this, LOCKED_OFFSET, 1) == 0;\n+    }\n+\n+    @ForceInline\n+    private void unlock() {\n+        UNSAFE.putIntVolatile(this, LOCKED_OFFSET, 0);\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SingleElementPoolImpl2.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test CaptureStateUtil\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run junit TestCaptureStateUtil\n+ *\/\n+\n+import jdk.internal.foreign.CaptureStateUtil;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestCaptureStateUtil {\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n+                    .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n+\n+    private static final MethodHandle INT_DUMMY_HANDLE;\n+    private static final MethodHandle LONG_DUMMY_HANDLE;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            INT_DUMMY_HANDLE = lookup\n+                    .findStatic(TestCaptureStateUtil.class, \"dummy\",\n+                            MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+            LONG_DUMMY_HANDLE = lookup\n+                    .findStatic(TestCaptureStateUtil.class, \"dummy\",\n+                            MethodType.methodType(long.class, MemorySegment.class, long.class, int.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static final MethodHandle ADAPTED_INT = CaptureStateUtil.adaptSystemCall(INT_DUMMY_HANDLE, ERRNO_NAME);\n+    private static final MethodHandle ADAPTED_LONG = CaptureStateUtil.adaptSystemCall(LONG_DUMMY_HANDLE, ERRNO_NAME);\n+\n+    @Test\n+    void successfulInt() throws Throwable {\n+        int r = (int) ADAPTED_INT.invokeExact(1, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    private static final int EACCES = 13; \/* Permission denied *\/\n+\n+    @Test\n+    void errorInt() throws Throwable {\n+        int r = (int) ADAPTED_INT.invokeExact(-1, EACCES);\n+        assertEquals(-EACCES, r);\n+    }\n+\n+    @Test\n+    void successfulLong() throws Throwable {\n+        long r = (long) ADAPTED_LONG.invokeExact(1L, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    @Test\n+    void errorLong() throws Throwable {\n+        long r = (long) ADAPTED_LONG.invokeExact(-1L, EACCES);\n+        assertEquals(-EACCES, r);\n+    }\n+\n+    @Test\n+    void invariants() throws Throwable {\n+        MethodHandle noSegment = MethodHandles.lookup()\n+                .findStatic(TestCaptureStateUtil.class, \"wrongType\",\n+                        MethodType.methodType(long.class, long.class, int.class));\n+\n+        var noSegEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, ERRNO_NAME));\n+        assertTrue(noSegEx.getMessage().contains(\"does not have a MemorySegment as the first parameter\"));\n+\n+        MethodHandle wrongReturnType = MethodHandles.lookup()\n+                .findStatic(TestCaptureStateUtil.class, \"wrongType\",\n+                        MethodType.methodType(short.class, MemorySegment.class, long.class, int.class));\n+\n+        var wrongRetEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(wrongReturnType, ERRNO_NAME));\n+        assertTrue(wrongRetEx.getMessage().contains(\"does not return an int or a long\"));\n+\n+        var wrongCaptureName = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(LONG_DUMMY_HANDLE, \"foo\"));\n+        assertTrue(wrongCaptureName.getMessage().startsWith(\"Unknown state name: foo\"), wrongCaptureName.getMessage());\n+\n+        assertThrows(NullPointerException.class, () -> CaptureStateUtil.adaptSystemCall(null, ERRNO_NAME));\n+        assertThrows(NullPointerException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, null));\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int dummy(MemorySegment segment, int result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static long dummy(MemorySegment segment, long result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    private static long wrongType(long result, int errno) {\n+        return 0;\n+    }\n+\n+    private static short wrongType(MemorySegment segment, long result, int errno) {\n+        return 0;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestCaptureStateUtil.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Basic tests of SingleElementPool\n+ * @modules java.base\/jdk.internal.util\n+ * @run junit SingleElementPoolTest\n+ *\/\n+\n+import jdk.internal.util.SingleElementPool;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class SingleElementPoolTest {\n+\n+    @Test\n+    public void basic() {\n+        final List<TestElement> recycledElements = new ArrayList<>();\n+        TestElement element = new TestElement();\n+        SingleElementPool.SingleElementPoolImpl<TestElement> pool =\n+                new SingleElementPool.SingleElementPoolImpl<>(element, TestElement::new, recycledElements::add);\n+\n+        TestElement first = pool.take();\n+        assertSame(element, first);\n+        TestElement second = pool.take();\n+        assertNotSame(first, second);\n+        pool.release(second);\n+        pool.release(first);\n+        TestElement reused = pool.take();\n+        assertSame(element, reused);\n+        pool.release(reused);\n+        pool.close();\n+        assertEquals(List.of(second, first), recycledElements);\n+    }\n+\n+    @Test\n+    public void closeReleased() {\n+        final List<TestElement> recycledElements = new ArrayList<>();\n+        TestElement element = new TestElement();\n+        SingleElementPool.SingleElementPoolImpl<TestElement> pool =\n+                new SingleElementPool.SingleElementPoolImpl<>(element, TestElement::new, recycledElements::add);\n+        TestElement first = pool.take();\n+        pool.release(first);\n+\n+        pool.close();\n+\n+        assertEquals(List.of(first), recycledElements);\n+\n+        \/\/ Check idempotency\n+        pool.close();\n+        assertEquals(List.of(first), recycledElements);\n+    }\n+\n+    @Test\n+    public void closeNotReleased() {\n+        final List<TestElement> recycledElements = new ArrayList<>();\n+        TestElement element = new TestElement();\n+        SingleElementPool.SingleElementPoolImpl<TestElement> pool =\n+                new SingleElementPool.SingleElementPoolImpl<>(element, TestElement::new, recycledElements::add);\n+        TestElement first = pool.take();\n+        pool.close();\n+\n+        assertTrue(recycledElements.isEmpty());\n+\n+        \/\/ Check idempotency\n+        pool.close();\n+        assertTrue(recycledElements.isEmpty());\n+    }\n+\n+    @Test\n+    public void invariants() {\n+        assertThrows(NullPointerException.class, () -> SingleElementPool.of(null, _ -> {}));\n+        assertThrows(NullPointerException.class, () -> SingleElementPool.of(Object::new, null));\n+        assertDoesNotThrow(() -> SingleElementPool.of(null, Object::new, _ -> {}));\n+    }\n+\n+    static final class TestElement{}\n+\n+}\n","filename":"test\/jdk\/java\/util\/SingleElementPool\/SingleElementPoolTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import jdk.internal.foreign.CaptureStateUtil;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\",\n+        \"--enable-native-access=ALL-UNNAMED\"})\n+public class CaptureStateUtilBench {\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n+            .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n+\n+    private static final long SIZE = Linker.Option.captureStateLayout().byteSize();\n+\n+    private static final MethodHandle DUMMY_EXPLICIT_ALLOC = dummyExplicitAlloc();\n+    private static final MethodHandle DUMMY_TL_ALLOC = dummyTlAlloc();\n+\n+    @Benchmark\n+    public int explicitAllocationSuccess() throws Throwable {\n+        try (var arena = Arena.ofConfined()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), 0, 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int explicitAllocationFail() throws Throwable {\n+        try (var arena = Arena.ofConfined()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), -1, 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int threadLocalReuseSuccess() throws Throwable {\n+        return (int) DUMMY_TL_ALLOC.invokeExact(0, 0);\n+    }\n+\n+    @Benchmark\n+    public int threadLocalFail() throws Throwable {\n+        return (int) DUMMY_TL_ALLOC.invokeExact( -1, 1);\n+    }\n+\n+    private static MethodHandle dummyExplicitAlloc() {\n+        try {\n+            return MethodHandles.lookup().findStatic(CaptureStateUtilBench.class,\n+                    \"dummy\", MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+        } catch (ReflectiveOperationException roe) {\n+            throw new RuntimeException(roe);\n+        }\n+    }\n+\n+    private static MethodHandle dummyTlAlloc() {\n+        final MethodHandle handle = dummyExplicitAlloc();\n+        return CaptureStateUtil.adaptSystemCall(handle, ERRNO_NAME);\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int dummy(MemorySegment segment, int result, int errno) {\n+        if (errno != 0) {\n+            \/\/ Assuming the capture state is only modified upon detecting an error.\n+            ERRNO_HANDLE.set(segment, 0, errno);\n+        }\n+        return result;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CaptureStateUtilBench.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"}]}