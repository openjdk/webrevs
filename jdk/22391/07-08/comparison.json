{"files":[{"patch":"@@ -29,2 +29,0 @@\n-import jdk.internal.vm.Continuation;\n-import jdk.internal.vm.ContinuationSupport;\n@@ -52,1 +50,1 @@\n-    private static final TerminatingThreadLocal<MemorySegment> TL = new TerminatingThreadLocal<>() {\n+    private static final TerminatingThreadLocal<SegmentCache> TL_CACHE = new TerminatingThreadLocal<>() {\n@@ -54,2 +52,2 @@\n-        protected void threadTerminated(MemorySegment value) {\n-            free(value);\n+        protected void threadTerminated(SegmentCache stack) {\n+            stack.close();\n@@ -59,2 +57,30 @@\n-    private static final MethodHandle ACQUIRE_MH =\n-            MhUtil.findStatic(LOOKUP, \"acquireCaptureStateSegment\",\n+    private static final MethodHandle NON_NEGATIVE_INT_MH =\n+            MhUtil.findStatic(LOOKUP, \"nonNegative\",\n+                    MethodType.methodType(boolean.class, int.class));\n+\n+    private static final MethodHandle SUCCESS_INT_MH =\n+            MhUtil.findStatic(LOOKUP, \"success\",\n+                    MethodType.methodType(int.class, int.class, MemorySegment.class));\n+\n+    private static final MethodHandle ERROR_INT_MH =\n+            MhUtil.findStatic(LOOKUP, \"error\",\n+                    MethodType.methodType(int.class, MethodHandle.class, int.class, MemorySegment.class));\n+\n+    private static final MethodHandle NON_NEGATIVE_LONG_MH =\n+            MhUtil.findStatic(LOOKUP, \"nonNegative\",\n+                    MethodType.methodType(boolean.class, long.class));\n+\n+    private static final MethodHandle SUCCESS_LONG_MH =\n+            MhUtil.findStatic(LOOKUP, \"success\",\n+                    MethodType.methodType(long.class, long.class, MemorySegment.class));\n+\n+    private static final MethodHandle ERROR_LONG_MH =\n+            MhUtil.findStatic(LOOKUP, \"error\",\n+                    MethodType.methodType(long.class, MethodHandle.class, long.class, MemorySegment.class));\n+\n+    private static final MethodHandle ACQUIRE_CACHE_MH =\n+            MhUtil.findStatic(LOOKUP, \"acquireCache\",\n+                    MethodType.methodType(SegmentCache.class));\n+\n+    private static final MethodHandle ACQUIRE_SEGMENT_MH =\n+            MhUtil.findVirtual(LOOKUP, SegmentCache.class, \"acquire\",\n@@ -63,3 +89,3 @@\n-    private static final MethodHandle INT_RETURN_FILTER_MH =\n-            MhUtil.findStatic(LOOKUP, \"returnFilter\",\n-                    MethodType.methodType(int.class, MethodHandle.class, int.class));\n+    private static final MethodHandle RELEASE_SEGMENT_MH =\n+            MhUtil.findVirtual(LOOKUP, SegmentCache.class, \"release\",\n+                    MethodType.methodType(void.class, MemorySegment.class));\n@@ -67,3 +93,0 @@\n-    private static final MethodHandle LONG_RETURN_FILTER_MH =\n-            MhUtil.findStatic(LOOKUP, \"returnFilter\",\n-                    MethodType.methodType(long.class, MethodHandle.class, long.class));\n@@ -74,1 +97,1 @@\n-    private static final Map<Class<?>, Map<String, MethodHandle>> RETURN_FILTERS;\n+    private static final Map<Class<?>, Map<String, MethodHandle>> CAPTURE_STATE_EXTRACTORS;\n@@ -86,6 +109,5 @@\n-                                MethodHandle mh = getAsIntHandle(stateLayout, member);\n-                                MethodHandle returnFilter = clazz.equals(int.class)\n-                                        ? INT_RETURN_FILTER_MH\n-                                        : LONG_RETURN_FILTER_MH;\n-                                \/\/ (int)int\n-                                return returnFilter.bindTo(mh);\n+                                VarHandle vh = stateLayout.varHandle(MemoryLayout.PathElement.groupElement(member.name().orElseThrow()));\n+                                \/\/ (MemorySegment, long)int\n+                                MethodHandle mh = vh.toMethodHandle(VarHandle.AccessMode.GET);\n+                                \/\/ (MemorySegment)int\n+                                return MethodHandles.insertArguments(mh, 1, 0L);\n@@ -96,1 +118,1 @@\n-        RETURN_FILTERS = Map.copyOf(classMap);\n+        CAPTURE_STATE_EXTRACTORS = Map.copyOf(classMap);\n@@ -128,0 +150,22 @@\n+     * For a method handle that takes a MemorySegment and two int parameters, the method\n+     * combinators are doing the equivalent of:\n+     *\n+     * {@snippet lang = java:\n+     *         public int invoke(int a, int b) {\n+     *             final SegmentCache segmentCache = acquireCache();\n+     *             final MemorySegment segment = segmentCache.acquire();\n+     *             try {\n+     *                 final int result = (int) handle.invoke(segment, a, b);\n+     *                 if (result >= 0) {\n+     *                     return result;\n+     *                 }\n+     *                 return -(int) errorHandle.get(segment);\n+     *             } finally {\n+     *                 segmentCache.release(segment);\n+     *             }\n+     *         }\n+     *}\n+     * Where {@code handle} is the original method handle with the coordinated\n+     * {@code (MemorySegment, int, int)int} and {@code errnoHandle} is a method handle\n+     * that retrieves the error code from the capturing segment.\n+     *\n@@ -150,2 +194,2 @@\n-        \/\/ (int | long)(int | long)\n-        final MethodHandle returnFilter = RETURN_FILTERS\n+        \/\/ ((int | long), MemorySegment)(int | long)\n+        final MethodHandle captureStateExtractor = CAPTURE_STATE_EXTRACTORS\n@@ -154,1 +198,1 @@\n-        if (returnFilter == null) {\n+        if (captureStateExtractor == null) {\n@@ -158,2 +202,1 @@\n-        \/\/ (MemorySegment, C*)(int | long) -> (C*)(int | long)\n-        target = MethodHandles.collectArguments(target, 0, ACQUIRE_MH);\n+        final boolean isInt = (returnType == int.class);\n@@ -161,3 +204,9 @@\n-        \/\/ (C*)(int | long) -> (C*)(int | long)\n-        return MethodHandles.filterReturnValue(target, returnFilter);\n-    }\n+        \/\/ Todo: Cache the error handles\n+        \/\/ ((int|long), MemorySegment)(int|long)\n+        MethodHandle inner = MethodHandles.guardWithTest(\n+                isInt ? NON_NEGATIVE_INT_MH : NON_NEGATIVE_LONG_MH,\n+                isInt ? SUCCESS_INT_MH : SUCCESS_LONG_MH,\n+                (isInt ? ERROR_INT_MH : ERROR_LONG_MH).bindTo(captureStateExtractor));\n+\n+        \/\/ (C0=MemorySegment, C1-Cn, MemorySegment)(int|long)\n+        inner = MethodHandles.collectArguments(inner, 0, target);\n@@ -165,5 +214,3 @@\n-    \/\/ Used reflectively via ACQUIRE_MH\n-    private static MemorySegment acquireCaptureStateSegment() {\n-        MemorySegment segment = TL.get();\n-        if (segment == null) {\n-            TL.set(segment = malloc());\n+        int[] perm = new int[target.type().parameterCount() + 1];\n+        for (int i = 0; i < target.type().parameterCount(); i++) {\n+            perm[i] = i;\n@@ -171,1 +218,36 @@\n-        return segment;\n+        perm[target.type().parameterCount()] = 0;\n+        \/\/ Deduplicate the first and last coordinate and only use the first\n+        \/\/ (C0=MemorySegment, C1-Cn)(int|long)\n+        inner = MethodHandles.permuteArguments(inner, target.type(), perm);\n+\n+        \/\/ (SegmentStack, C0=MemorySegment, C1-Cn)(int|long)\n+        inner = MethodHandles.dropArguments(inner, 0, SegmentCache.class);\n+\n+        \/\/ ((int|long))(int|long)\n+        MethodHandle cleanup = MethodHandles.identity(returnType);\n+        \/\/ (Throwable, (int|long))(int|long)\n+        cleanup = MethodHandles.dropArguments(cleanup, 0, Throwable.class);\n+        \/\/ (Throwable, (int|long), SegmentStack, C0=MemorySegment)(int|long)\n+        \/\/ Cleanup does not have to have all parameters. It can have zero or more.\n+        cleanup = MethodHandles.collectArguments(cleanup, 2, RELEASE_SEGMENT_MH);\n+\n+        \/\/ (SegmentStack, C0=MemorySegment, C1-Cn)(int|long)\n+        MethodHandle tryFinally = MethodHandles.tryFinally(inner, cleanup);\n+\n+        \/\/ (SegmentStack, SegmentStack, C1-Cn)(int|long)\n+        MethodHandle result = MethodHandles.filterArguments(tryFinally, 1, ACQUIRE_SEGMENT_MH);\n+\n+        final MethodType newType = result.type().dropParameterTypes(0, 1);\n+        perm = new int[result.type().parameterCount()];\n+        perm[0] = 0;\n+        for (int i = 1; i < result.type().parameterCount(); i++) {\n+            perm[i] = i - 1;\n+        }\n+        \/\/ Deduplicate the first and second coordinate and only use the first\n+        \/\/ (SegmentStack, C1-Cn)(int|long)\n+        result = MethodHandles.permuteArguments(result, newType, perm);\n+\n+        \/\/ Finally we arrive at (C1-Cn)(int|long)\n+        result = MethodHandles.collectArguments(result, 0, ACQUIRE_CACHE_MH);\n+\n+        return result;\n@@ -174,5 +256,63 @@\n-    \/\/ Used reflectively via INT_RETURN_FILTER_MH\n-    @ForceInline\n-    private static int returnFilter(MethodHandle errorHandle, int result) throws Throwable {\n-        if (result >= 0) {\n-            return result;\n+    private static IllegalArgumentException illegalArgDoesNot(MethodHandle target, String info) {\n+        return new IllegalArgumentException(\"The provided target \" + target\n+                + \" does not \" + info);\n+    }\n+\n+    \/**\n+     * A cache of a memory segments to allow reuse. In many cases, only one segment will\n+     * ever be allocated per platform thread. However, if a virtual thread becomes\n+     * unmounted from its platform thread and another virtual thread acquires a new\n+     * segment. Having a secondary cache of these is slower than using malloc\/free directly.\n+     * <p>\n+     * The `cachedField` is about three times faster than a more general `deque`.\n+     * <p>\n+     * The class is using Unsafe rather than other supported APIs to allow early use\n+     * in the boostrap sequence.\n+     *\/\n+    private static final class SegmentCache {\n+\n+        private static final long CACHED_SEGMENT_OFFSET =\n+                UNSAFE.objectFieldOffset(SegmentCache.class, \"cachedSegment\");\n+        private MemorySegment cachedSegment;\n+\n+        \/\/ Used reflectively\n+        @ForceInline\n+        private MemorySegment acquire() {\n+            final MemorySegment segment = acquireFromCache();\n+            return segment == null ? malloc() : segment;\n+        }\n+\n+        \/\/ Used reflectively\n+        @ForceInline\n+        private void release(MemorySegment segment) {\n+            if (!releaseToCache(segment)) {\n+                free(segment);\n+            }\n+        }\n+\n+        \/\/ This method is called by a separate cleanup thread when the associated\n+        \/\/ platform thread is dead. So, there is no concurrent use here.\n+        \/\/ The method consumes the cached element in order for the method to be idempotent\n+        \/\/ which might be a bit paranoid.\n+        private void close() {\n+            final MemorySegment cSeg = acquireFromCache();\n+            if (cSeg != null) {\n+                free(cSeg);\n+            }\n+        }\n+\n+        @ForceInline\n+        private MemorySegment acquireFromCache() {\n+            return (MemorySegment) UNSAFE.getAndSetReference(this, CACHED_SEGMENT_OFFSET, null);\n+        }\n+\n+        @ForceInline\n+        private boolean releaseToCache(MemorySegment segment) {\n+            return UNSAFE.compareAndSetReference(this, CACHED_SEGMENT_OFFSET, null, segment);\n+        }\n+\n+        @SuppressWarnings(\"restricted\")\n+        @ForceInline\n+        private static MemorySegment malloc() {\n+            final long address = UNSAFE.allocateMemory(SIZE);\n+            return MemorySegment.ofAddress(address).reinterpret(SIZE);\n@@ -180,1 +320,6 @@\n-        return -(int) errorHandle.invoke();\n+\n+        @ForceInline\n+        private static void free(MemorySegment segment) {\n+            UNSAFE.freeMemory(segment.address());\n+        }\n+\n@@ -183,1 +328,3 @@\n-    \/\/ Used reflectively via LONG_RETURN_FILTER_MH\n+    \/\/ Support method used as method handles\n+\n+    \/\/ Used reflectively\n@@ -185,3 +332,4 @@\n-    private static long returnFilter(MethodHandle errorHandle, long result) throws Throwable {\n-        if (result >= 0) {\n-            return result;\n+    private static SegmentCache acquireCache() {\n+        SegmentCache cache = TL_CACHE.get();\n+        if (cache == null) {\n+            TL_CACHE.set(cache = new SegmentCache());\n@@ -189,1 +337,1 @@\n-        return -(int) errorHandle.invoke();\n+        return cache;\n@@ -192,4 +340,4 @@\n-    @SuppressWarnings(\"restricted\")\n-    private static MemorySegment malloc() {\n-        final long address = UNSAFE.allocateMemory(SIZE);\n-        return MemorySegment.ofAddress(address).reinterpret(SIZE);\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static boolean nonNegative(int value) {\n+        return value >= 0;\n@@ -198,2 +346,4 @@\n-    private static void free(MemorySegment segment) {\n-        UNSAFE.freeMemory(segment.address());\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static int success(int value, MemorySegment segment) {\n+        return value;\n@@ -202,3 +352,4 @@\n-    private static IllegalArgumentException illegalArgDoesNot(MethodHandle target, String info) {\n-        return new IllegalArgumentException(\"The provided target \" + target\n-                + \" does not \" + info);\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static int error(MethodHandle errorHandle, int value, MemorySegment segment) throws Throwable {\n+        return -(int) errorHandle.invokeExact(segment);\n@@ -207,3 +358,4 @@\n-    private static MethodHandle getAsIntHandle(StructLayout parent, MemoryLayout layout) {\n-        final MethodHandle handle = MhUtil.findStatic(LOOKUP, \"getStateAsInt\", MethodType.methodType(int.class, VarHandle.class));\n-        return handle.bindTo(parent.varHandle(MemoryLayout.PathElement.groupElement(layout.name().orElseThrow())));\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static boolean nonNegative(long value) {\n+        return value >= 0L;\n@@ -212,15 +364,4 @@\n-    \/\/ Used reflectively by `getAsIntHandle(MemoryLayout layout)`\n-    private static int getStateAsInt(VarHandle handle) {\n-        if (ContinuationSupport.isSupported() && Thread.currentThread().isVirtual()) {\n-            \/\/ Make sure we are not unmounted\/remounted from\/on another platform thread\n-            \/\/ during the critical read region. This prevents access across platform threads.\n-            Continuation.pin();\n-            try {\n-                return getStateAsIntCriticalRegion(handle);\n-            } finally {\n-                Continuation.unpin();\n-            }\n-        } else {\n-            \/\/ On platform threads, we always remain on the PT itself\n-            return getStateAsIntCriticalRegion(handle);\n-        }\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static long success(long value, MemorySegment segment) {\n+        return value;\n@@ -229,3 +370,4 @@\n-    \/\/ Critical read region for VTs.\n-    private static int getStateAsIntCriticalRegion(VarHandle handle) {\n-        return (int) handle.get(acquireCaptureStateSegment(), 0);\n+    \/\/ Used reflectively\n+    @ForceInline\n+    private static long error(MethodHandle errorHandle, long value, MemorySegment segment) throws Throwable {\n+        return -(int) errorHandle.invokeExact(segment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil.java","additions":218,"deletions":76,"binary":false,"changes":294,"status":"modified"},{"patch":"@@ -1,343 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.foreign;\n-\n-import jdk.internal.invoke.MhUtil;\n-import jdk.internal.misc.TerminatingThreadLocal;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Stable;\n-\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.foreign.StructLayout;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.VarHandle;\n-import java.util.Deque;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.concurrent.ConcurrentLinkedDeque;\n-import java.util.stream.Collectors;\n-\n-public final class CaptureStateUtil2 {\n-\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n-    private static final long SIZE = Linker.Option.captureStateLayout().byteSize();\n-\n-    private static final TerminatingThreadLocal<SegmentStack> TL_STACK = new TerminatingThreadLocal<>() {\n-        @Override\n-        protected void threadTerminated(SegmentStack stack) {\n-            stack.close();\n-        }\n-    };\n-\n-    private static final MethodHandle NON_NEGATIVE_INT_MH =\n-            MhUtil.findStatic(LOOKUP, \"nonNegative\",\n-                    MethodType.methodType(boolean.class, int.class));\n-\n-    private static final MethodHandle SUCCESS_INT_MH =\n-            MhUtil.findStatic(LOOKUP, \"success\",\n-                    MethodType.methodType(int.class, int.class, MemorySegment.class));\n-\n-    private static final MethodHandle ERROR_INT_MH =\n-            MhUtil.findStatic(LOOKUP, \"error\",\n-                    MethodType.methodType(int.class, MethodHandle.class, int.class, MemorySegment.class));\n-\n-    private static final MethodHandle NON_NEGATIVE_LONG_MH =\n-            MhUtil.findStatic(LOOKUP, \"nonNegative\",\n-                    MethodType.methodType(boolean.class, long.class));\n-\n-    private static final MethodHandle SUCCESS_LONG_MH =\n-            MhUtil.findStatic(LOOKUP, \"success\",\n-                    MethodType.methodType(long.class, long.class, MemorySegment.class));\n-\n-    private static final MethodHandle ERROR_LONG_MH =\n-            MhUtil.findStatic(LOOKUP, \"error\",\n-                    MethodType.methodType(long.class, MethodHandle.class, long.class, MemorySegment.class));\n-\n-    private static final MethodHandle ACQUIRE_STACK_MH =\n-            MhUtil.findStatic(LOOKUP, \"acquireStack\",\n-                    MethodType.methodType(SegmentStack.class));\n-\n-    private static final MethodHandle ACQUIRE_SEGMENT_MH =\n-            MhUtil.findVirtual(LOOKUP, SegmentStack.class, \"acquire\",\n-                    MethodType.methodType(MemorySegment.class));\n-\n-    private static final MethodHandle RELEASE_SEGMENT_MH =\n-            MhUtil.findVirtual(LOOKUP, SegmentStack.class, \"release\",\n-                    MethodType.methodType(void.class, MemorySegment.class));\n-\n-\n-    \/\/ (int.class | long.class) ->\n-    \/\/   ({\"GetLastError\" | \"WSAGetLastError\"} | \"errno\") ->\n-    \/\/     MethodHandle\n-    private static final Map<Class<?>, Map<String, MethodHandle>> CAPTURE_STATE_EXTRACTORS;\n-\n-    static {\n-\n-        final StructLayout stateLayout = Linker.Option.captureStateLayout();\n-        final Map<Class<?>, Map<String, MethodHandle>> classMap = new HashMap<>();\n-        for (var clazz : new Class<?>[]{int.class, long.class}) {\n-            Map<String, MethodHandle> handles = stateLayout\n-                    .memberLayouts().stream()\n-                    .collect(Collectors.toUnmodifiableMap(\n-                            member -> member.name().orElseThrow(),\n-                            member -> {\n-                                VarHandle vh = stateLayout.varHandle(MemoryLayout.PathElement.groupElement(member.name().orElseThrow()));\n-                                \/\/ (MemorySegment, long)int\n-                                MethodHandle mh = vh.toMethodHandle(VarHandle.AccessMode.GET);\n-                                \/\/ (MemorySegment)int\n-                                return MethodHandles.insertArguments(mh, 1, 0L);\n-                            }\n-                    ));\n-            classMap.put(clazz, handles);\n-        }\n-        CAPTURE_STATE_EXTRACTORS = Map.copyOf(classMap);\n-    }\n-\n-    private CaptureStateUtil2() {\n-    }\n-\n-    \/**\n-     * {@return a new MethodHandle that adapts the provided {@code target} so that it\n-     *          directly returns the same value as the {@code target} if it is\n-     *          non-negative, otherwise returns the negated errno}\n-     * <p>\n-     * This method is suitable for adapting system-call method handles(e.g.\n-     * {@code open()}, {@code read()}, and {@code close()}). Clients can check the return\n-     * value as shown in this example:\n-     * {@snippet lang = java:\n-     *       \/\/ (MemorySegment capture, MemorySegment pathname, int flags)int\n-     *       static final MethodHandle CAPTURING_OPEN = ...\n-     *\n-     *      \/\/ (MemorySegment pathname, int flags)int\n-     *      static final MethodHandle OPEN = CaptureStateUtil.adaptSystemCall(CAPTURING_OPEN, \"errno\");\n-     *\n-     *      try {\n-     *         int fh = (int)OPEN.invoke(pathName, flags);\n-     *         if (fh < 0) {\n-     *             throw new IOException(\"Error opening file: errno = \" + (-fh));\n-     *         }\n-     *         processFile(fh);\n-     *      } catch (Throwable t) {\n-     *           throw new RuntimeException(t);\n-     *      }\n-     *\n-     *}\n-     * For a method handle that takes a MemorySegment and two int parameters, the method\n-     * combinators are doing the equivalent of:\n-     *\n-     * {@snippet lang=java:\n-     *         public int invoke(int a, int b) {\n-     *             final SegmentStack segmentStack = acquireStack();\n-     *             final MemorySegment segment = segmentStack.acquire();\n-     *             try {\n-     *                 final int result = (int) handle.invoke(segment, a, b);\n-     *                 if (result >= 0) {\n-     *                     return result;\n-     *                 }\n-     *                 return -(int) errorHandle.get(segment);\n-     *             } finally {\n-     *                 segmentStack.release(segment);\n-     *             }\n-     *         }\n-     * }\n-     *\n-     *\n-     *\n-     * @param target    method handle that returns an {@code int} or a {@code long} and has\n-     *                  a capturing state MemorySegment as its first parameter\n-     * @param stateName the name of the capturing state member layout\n-     *                  (i.e. \"errno\",\"GetLastError\", or \"WSAGetLastError\")\n-     * @throws IllegalArgumentException if the provided {@code target}'s return type is\n-     *                                  not {@code int} or {@code long}\n-     * @throws IllegalArgumentException if the provided {@code target}'s first parameter\n-     *                                  type is not {@linkplain MemorySegment}\n-     *\/\n-    public static MethodHandle adaptSystemCall(MethodHandle target, String stateName) {\n-        \/\/ Implicit null check\n-        final Class<?> returnType = target.type().returnType();\n-        Objects.requireNonNull(stateName);\n-\n-        if (!(returnType.equals(int.class) || returnType.equals(long.class))) {\n-            throw illegalArgDoesNot(target, \"return an int or a long\");\n-        }\n-        if (target.type().parameterType(0) != MemorySegment.class) {\n-            throw illegalArgDoesNot(target, \"have a MemorySegment as the first parameter\");\n-        }\n-\n-        \/\/ ((int | long), MemorySegment)(int | long)\n-        final MethodHandle captureStateExtractor = CAPTURE_STATE_EXTRACTORS\n-                .get(returnType)\n-                .get(stateName);\n-        if (captureStateExtractor == null) {\n-            throw new IllegalArgumentException(\"Unknown state name: \" + stateName);\n-        }\n-\n-        final boolean isInt = (returnType == int.class);\n-\n-        \/\/ Todo: Cache the error handles\n-        \/\/ ((int|long), MemorySegment)(int|long)\n-        MethodHandle inner = MethodHandles.guardWithTest(\n-                isInt ? NON_NEGATIVE_INT_MH : NON_NEGATIVE_LONG_MH,\n-                isInt ? SUCCESS_INT_MH : SUCCESS_LONG_MH,\n-                (isInt ? ERROR_INT_MH : ERROR_LONG_MH).bindTo(captureStateExtractor));\n-\n-        \/\/ (C0=MemorySegment, C1-Cn, MemorySegment)(int|long)\n-        inner = MethodHandles.collectArguments(inner, 0, target);\n-\n-        int[] perm = new int[target.type().parameterCount() + 1];\n-        for (int i = 0; i < target.type().parameterCount(); i++) {\n-            perm[i] = i;\n-        }\n-        perm[target.type().parameterCount()] = 0;\n-        \/\/ Deduplicate the first and last coordinate and only use the first\n-        \/\/ (C0=MemorySegment, C1-Cn)(int|long)\n-        inner = MethodHandles.permuteArguments(inner, target.type(), perm);\n-\n-        \/\/ (SegmentStack, C0=MemorySegment, C1-Cn)(int|long)\n-        inner = MethodHandles.dropArguments(inner, 0, SegmentStack.class);\n-\n-        \/\/ ((int|long))(int|long)\n-        MethodHandle cleanup = MethodHandles.identity(returnType);\n-        \/\/ (Throwable, (int|long))(int|long)\n-        cleanup = MethodHandles.dropArguments(cleanup, 0, Throwable.class);\n-        \/\/ (Throwable, (int|long), SegmentStack, C0=MemorySegment)(int|long)\n-        cleanup = MethodHandles.collectArguments(cleanup, 2, RELEASE_SEGMENT_MH);\n-        \/\/ (Throwable, (int|long), SegmentStack, C0=MemorySegment, C1-Cn)(int|long)\n-        cleanup = MethodHandles.dropArguments(cleanup, 4, inner.type().parameterList().subList(2, inner.type().parameterCount()));\n-        \/\/cleanup = MethodHandles.filterArguments()\n-\n-        \/\/ (SegmentStack, C0=MemorySegment, C1-Cn)(int|long)\n-        MethodHandle tryFinally = MethodHandles.tryFinally(inner, cleanup);\n-\n-        \/\/ (SegmentStack, SegmentStack, C1-Cn)(int|long)\n-        MethodHandle result = MethodHandles.filterArguments(tryFinally, 1, ACQUIRE_SEGMENT_MH);\n-\n-        final MethodType newType = result.type().dropParameterTypes(0, 1);\n-        perm = new int[result.type().parameterCount()];\n-        perm[0] = 0;\n-        for (int i = 1; i < result.type().parameterCount(); i++) {\n-            perm[i] = i - 1;\n-        }\n-        \/\/ Deduplicate the first and second coordinate and only use the first\n-        \/\/ (SegmentStack, C1-Cn)(int|long)\n-        result = MethodHandles.permuteArguments(result, newType, perm);\n-\n-        \/\/ Finally we arrive at (C1-Cn)(int|long)\n-        result = MethodHandles.collectArguments(result, 0, ACQUIRE_STACK_MH);\n-\n-        return result;\n-    }\n-\n-    \/\/ Used reflectively via ACQUIRE_MH\n-    @ForceInline\n-    private static SegmentStack acquireStack() {\n-        SegmentStack stack = TL_STACK.get();\n-        if (stack == null) {\n-            TL_STACK.set(stack = new SegmentStack());\n-        }\n-        return stack;\n-    }\n-\n-    @SuppressWarnings(\"restricted\")\n-    @ForceInline\n-    private static MemorySegment malloc() {\n-        final long address = UNSAFE.allocateMemory(SIZE);\n-        return MemorySegment.ofAddress(address).reinterpret(SIZE);\n-    }\n-\n-    private static void free(MemorySegment segment) {\n-        UNSAFE.freeMemory(segment.address());\n-    }\n-\n-    private static IllegalArgumentException illegalArgDoesNot(MethodHandle target, String info) {\n-        return new IllegalArgumentException(\"The provided target \" + target\n-                + \" does not \" + info);\n-    }\n-\n-    private static final class SegmentStack {\n-\n-        @Stable\n-        private final Deque<MemorySegment> deque = new ConcurrentLinkedDeque<>();\n-\n-        @ForceInline\n-        MemorySegment acquire() {\n-            final MemorySegment segment = deque.poll();\n-            return segment == null ? malloc() : segment;\n-        }\n-\n-        void release(MemorySegment segment) {\n-            deque.push(segment);\n-        }\n-\n-        void close(){\n-            for (MemorySegment segment:deque) {\n-                free(segment);\n-            }\n-        }\n-    }\n-\n-    \/\/ Used reflectively\n-    @ForceInline\n-    private static boolean nonNegative(int value) {\n-        return value >= 0;\n-    }\n-\n-    \/\/ Used reflectively\n-    @ForceInline\n-    private static int success(int value, MemorySegment segment) {\n-        return value;\n-    }\n-\n-    \/\/ Used reflectively\n-    @ForceInline\n-    private static int error(MethodHandle errorHandle, int value, MemorySegment segment) throws Throwable {\n-        return -(int) errorHandle.invokeExact(segment);\n-    }\n-\n-    \/\/ Used reflectively\n-    @ForceInline\n-    private static boolean nonNegative(long value) {\n-        return value >= 0L;\n-    }\n-\n-    \/\/ Used reflectively\n-    @ForceInline\n-    private static long success(long value, MemorySegment segment) {\n-        return value;\n-    }\n-\n-    \/\/ Used reflectively\n-    @ForceInline\n-    private static long error(MethodHandle errorHandle, long value, MemorySegment segment) throws Throwable {\n-        return -(int) errorHandle.invokeExact(segment);\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil2.java","additions":0,"deletions":343,"binary":false,"changes":343,"status":"deleted"},{"patch":"@@ -1,140 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test TestCaptureStateUtil2\n- * @modules java.base\/jdk.internal.foreign\n- * @run junit TestCaptureStateUtil2\n- *\/\n-\n-import jdk.internal.foreign.CaptureStateUtil2;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.foreign.Linker;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.MemorySegment;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.lang.invoke.VarHandle;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-final class TestCaptureStateUtil2 {\n-\n-    private static final String ERRNO_NAME = \"errno\";\n-\n-    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n-                    .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n-\n-    private static final MethodHandle INT_DUMMY_HANDLE;\n-    private static final MethodHandle LONG_DUMMY_HANDLE;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            INT_DUMMY_HANDLE = lookup\n-                    .findStatic(TestCaptureStateUtil2.class, \"dummy\",\n-                            MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n-            LONG_DUMMY_HANDLE = lookup\n-                    .findStatic(TestCaptureStateUtil2.class, \"dummy\",\n-                            MethodType.methodType(long.class, MemorySegment.class, long.class, int.class));\n-        } catch (ReflectiveOperationException e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    private static final MethodHandle ADAPTED_INT = CaptureStateUtil2.adaptSystemCall(INT_DUMMY_HANDLE, ERRNO_NAME);\n-    private static final MethodHandle ADAPTED_LONG = CaptureStateUtil2.adaptSystemCall(LONG_DUMMY_HANDLE, ERRNO_NAME);\n-\n-    @Test\n-    void successfulInt() throws Throwable {\n-        int r = (int) ADAPTED_INT.invoke(1, 0);\n-        assertEquals(1, r);\n-    }\n-\n-    private static final int EACCES = 13; \/* Permission denied *\/\n-\n-    @Test\n-    void errorInt() throws Throwable {\n-        int r = (int) ADAPTED_INT.invoke(-1, EACCES);\n-        assertEquals(-EACCES, r);\n-    }\n-\n-    @Test\n-    void successfulLong() throws Throwable {\n-        long r = (long) ADAPTED_LONG.invoke(1, 0);\n-        assertEquals(1, r);\n-    }\n-\n-    @Test\n-    void errorLong() throws Throwable {\n-        long r = (long) ADAPTED_LONG.invoke(-1, EACCES);\n-        assertEquals(-EACCES, r);\n-    }\n-\n-    @Test\n-    void invariants() throws Throwable {\n-        MethodHandle noSegment = MethodHandles.lookup()\n-                .findStatic(TestCaptureStateUtil2.class, \"wrongType\",\n-                        MethodType.methodType(long.class, long.class, int.class));\n-\n-        var noSegEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil2.adaptSystemCall(noSegment, ERRNO_NAME));\n-        assertTrue(noSegEx.getMessage().contains(\"does not have a MemorySegment as the first parameter\"));\n-\n-        MethodHandle wrongReturnType = MethodHandles.lookup()\n-                .findStatic(TestCaptureStateUtil2.class, \"wrongType\",\n-                        MethodType.methodType(short.class, MemorySegment.class, long.class, int.class));\n-\n-        var wrongRetEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil2.adaptSystemCall(wrongReturnType, ERRNO_NAME));\n-        assertTrue(wrongRetEx.getMessage().contains(\"does not return an int or a long\"));\n-\n-        var wrongCaptureName = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil2.adaptSystemCall(LONG_DUMMY_HANDLE, \"foo\"));\n-        assertEquals(\"Unknown state name: foo\", wrongCaptureName.getMessage());\n-\n-        assertThrows(NullPointerException.class, () -> CaptureStateUtil2.adaptSystemCall(null, ERRNO_NAME));\n-        assertThrows(NullPointerException.class, () -> CaptureStateUtil2.adaptSystemCall(noSegment, null));\n-    }\n-\n-    \/\/ Dummy method that is just returning the provided parameters\n-    private static int dummy(MemorySegment segment, int result, int errno) {\n-        ERRNO_HANDLE.set(segment, 0, errno);\n-        return result;\n-    }\n-\n-    \/\/ Dummy method that is just returning the provided parameters\n-    private static long dummy(MemorySegment segment, long result, int errno) {\n-        ERRNO_HANDLE.set(segment, 0, errno);\n-        return result;\n-    }\n-\n-    private static long wrongType(long result, int errno) {\n-        return 0;\n-    }\n-\n-    private static short wrongType(MemorySegment segment, long result, int errno) {\n-        return 0;\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/TestCaptureStateUtil2.java","additions":0,"deletions":140,"binary":false,"changes":140,"status":"deleted"},{"patch":"@@ -26,1 +26,1 @@\n-import jdk.internal.foreign.CaptureStateUtil2;\n+import jdk.internal.foreign.CaptureStateUtil;\n@@ -67,1 +67,1 @@\n-    public int explicitSuccess() throws Throwable {\n+    public int explicitAllocationSuccess() throws Throwable {\n@@ -74,1 +74,1 @@\n-    public int explicitFail() throws Throwable {\n+    public int explicitAllocationFail() throws Throwable {\n@@ -81,1 +81,1 @@\n-    public int tlSuccess() throws Throwable {\n+    public int threadLocalReuseSuccess() throws Throwable {\n@@ -83,1 +83,0 @@\n-\n@@ -87,1 +86,1 @@\n-    public int tlFail() throws Throwable {\n+    public int threadLocalFail() throws Throwable {\n@@ -93,1 +92,2 @@\n-            return MethodHandles.lookup().findStatic(CaptureStateUtilBench.class, \"dummy\", MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+            return MethodHandles.lookup().findStatic(CaptureStateUtilBench.class,\n+                    \"dummy\", MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n@@ -101,1 +101,1 @@\n-        return CaptureStateUtil2.adaptSystemCall(handle, ERRNO_NAME);\n+        return CaptureStateUtil.adaptSystemCall(handle, ERRNO_NAME);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CaptureStateUtilBench.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}