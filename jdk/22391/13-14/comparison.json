{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.util.SingleElementPool;\n@@ -30,1 +31,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -43,0 +43,2 @@\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n@@ -51,7 +53,0 @@\n-    private static final TerminatingThreadLocal<SegmentCache> TL_CACHE = new TerminatingThreadLocal<>() {\n-        @Override\n-        protected void threadTerminated(SegmentCache stack) {\n-            stack.close();\n-        }\n-    };\n-\n@@ -82,6 +77,2 @@\n-    private static final MethodHandle ACQUIRE_CACHE_MH =\n-            MhUtil.findStatic(LOOKUP, \"acquireCache\",\n-                    MethodType.methodType(SegmentCache.class));\n-\n-    private static final MethodHandle ACQUIRE_SEGMENT_MH =\n-            MhUtil.findVirtual(LOOKUP, SegmentCache.class, \"acquire\",\n+    private static final MethodHandle TAKE_SEGMENT_MH =\n+            MhUtil.findVirtual(LOOKUP, SegmentPool.class, \"take\",\n@@ -91,1 +82,1 @@\n-            MhUtil.findVirtual(LOOKUP, SegmentCache.class, \"release\",\n+            MhUtil.findVirtual(LOOKUP, SegmentPool.class, \"release\",\n@@ -170,2 +161,2 @@\n-     *             final SegmentCache segmentCache = acquireCache();\n-     *             final MemorySegment segment = segmentCache.acquire();\n+     *             final SegmentPool segmentPool = acquirePool();\n+     *             final MemorySegment segment = segmentPool.acquire();\n@@ -179,1 +170,1 @@\n-     *                 segmentCache.release(segment);\n+     *                 segmentPool.release(segment);\n@@ -235,1 +226,1 @@\n-        inner = MethodHandles.dropArguments(inner, 0, SegmentCache.class);\n+        inner = MethodHandles.dropArguments(inner, 0, SegmentPool.class);\n@@ -249,1 +240,1 @@\n-        MethodHandle result = MethodHandles.filterArguments(tryFinally, 1, ACQUIRE_SEGMENT_MH);\n+        MethodHandle result = MethodHandles.filterArguments(tryFinally, 1, TAKE_SEGMENT_MH);\n@@ -262,1 +253,1 @@\n-        return MethodHandles.collectArguments(result, 0, ACQUIRE_CACHE_MH);\n+        return MethodHandles.collectArguments(result, 0, SegmentPool.ACQUIRE_POOL_MH);\n@@ -282,23 +273,24 @@\n-    private static final class SegmentCache {\n-\n-        private static final long ALLOCATED_OFFSET =\n-                UNSAFE.objectFieldOffset(SegmentCache.class, \"lock\");\n-\n-        \/\/ Using an int lock is faster than CASing a reference field\n-        private int lock;\n-        @Stable\n-        private final MemorySegment cachedSegment = malloc();\n-\n-        \/\/ Used reflectively\n-        @ForceInline\n-        private MemorySegment acquire() {\n-            return lock() ? cachedSegment : malloc();\n-        }\n-\n-        \/\/ Used reflectively\n-        @ForceInline\n-        private void release(MemorySegment segment) {\n-            if (segment == cachedSegment) {\n-                unlock();\n-            } else {\n-                free(segment);\n+    private static final class SegmentPool\n+            extends SingleElementPool.SingleElementPoolImpl<MemorySegment> {\n+\n+        private static final TerminatingThreadLocal<SegmentPool> TL_POOLS =\n+                new TerminatingThreadLocal<>() {\n+                    @Override\n+                    protected void threadTerminated(SegmentPool pool) {\n+                        pool.close();\n+                    }\n+                };\n+\n+        private static final MethodHandle ACQUIRE_POOL_MH =\n+                MhUtil.findStatic(MethodHandles.lookup(), \"acquirePool\",\n+                        MethodType.methodType(SegmentPool.class));\n+\n+\n+        private static final Supplier<MemorySegment> FACTORY = new Supplier<>() {\n+            @SuppressWarnings(\"restricted\")\n+            @ForceInline\n+            @Override\n+            public MemorySegment get() {\n+                \/\/ malloc\n+                final long address = UNSAFE.allocateMemory(SIZE);\n+                return MemorySegment.ofAddress(address).reinterpret(SIZE);\n@@ -306,1 +298,10 @@\n-        }\n+        };\n+\n+        private static final Consumer<MemorySegment> RECYCLER = new Consumer<>() {\n+            @ForceInline\n+            @Override\n+            public void accept(MemorySegment segment) {\n+                \/\/ free\n+                UNSAFE.freeMemory(segment.address());\n+            }\n+        };\n@@ -308,4 +309,2 @@\n-        \/\/ This method is called by a separate cleanup thread when the associated\n-        \/\/ platform thread is dead.\n-        private void close() {\n-            free(cachedSegment);\n+        public SegmentPool() {\n+            super(FACTORY.get(), FACTORY, RECYCLER);\n@@ -314,4 +313,2 @@\n-        @ForceInline\n-        private boolean lock() {\n-            return UNSAFE.getAndSetInt(this, ALLOCATED_OFFSET, 1) == 0;\n-        }\n+        \/\/ We need to override `take` and `release` to specify the low-level return and\n+        \/\/ parameter types.\n@@ -320,2 +317,3 @@\n-        private void unlock() {\n-            UNSAFE.putIntVolatile(this, ALLOCATED_OFFSET, 0);\n+        @Override\n+        public MemorySegment take() {\n+            return super.take();\n@@ -324,1 +322,0 @@\n-        @SuppressWarnings(\"restricted\")\n@@ -326,3 +323,3 @@\n-        private static MemorySegment malloc() {\n-            final long address = UNSAFE.allocateMemory(SIZE);\n-            return MemorySegment.ofAddress(address).reinterpret(SIZE);\n+        @Override\n+        public void release(MemorySegment element) {\n+            super.release(element);\n@@ -331,0 +328,1 @@\n+        \/\/ Used reflectively\n@@ -332,2 +330,6 @@\n-        private static void free(MemorySegment segment) {\n-            UNSAFE.freeMemory(segment.address());\n+        private static SegmentPool acquirePool() {\n+            SegmentPool cache = TL_POOLS.get();\n+            if (cache == null) {\n+                TL_POOLS.set(cache = new SegmentPool());\n+            }\n+            return cache;\n@@ -335,1 +337,0 @@\n-\n@@ -340,10 +341,0 @@\n-    \/\/ Used reflectively\n-    @ForceInline\n-    private static SegmentCache acquireCache() {\n-        SegmentCache cache = TL_CACHE.get();\n-        if (cache == null) {\n-            TL_CACHE.set(cache = new SegmentCache());\n-        }\n-        return cache;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil.java","additions":63,"deletions":72,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+package jdk.internal.util;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * A high-performance single element pool where the pooled element is eagerly created\n+ * upfront.\n+ * <p>\n+ * Elements are created using a {@code factory} and released elements not in the pool are\n+ * disposed of via a {@code recycler}. The single element in a pool can be created either\n+ * by the {@linkplain SingleElementPool#of(Supplier, Consumer) factory} or\n+ * {@linkplain SingleElementPool#of(Object, Supplier, Consumer) explicitly}.\n+ *\n+ * @param <T> the pool element type\n+ *\/\n+public sealed interface SingleElementPool<T> extends AutoCloseable {\n+\n+    \/**\n+     * {@return the single pooled element if not taken, otherwise invokes the pool's\n+     *          factory to create a new element}\n+     *\/\n+    T take();\n+\n+    \/**\n+     * Releases the provided {@code element}. If the element is <em>identical<\/em> to the\n+     * single pooled element, returns it to the pool; otherwise invokes the pool's\n+     * recycler to dispose of the provided {@code element}.\n+     *\/\n+    void release(T element);\n+\n+    \/**\n+     * Recycles the single pooled element if it is released. This method is idempotent.\n+     *\/\n+    @Override\n+    void close();\n+\n+    \/**\n+     * {@return a new SingleElementPool with the single pooled element created via the\n+     *          provided {@code factory}}.\n+     * @param factory  used to create new elements\n+     * @param recycler used to dispose of elements\n+     * @param <T> the pool element type\n+     * @throws NullPointerException if either of {@code factory} or {@code recycler}\n+     *         is {@code null}\n+     *\/\n+    static <T> SingleElementPool<T> of(Supplier<? extends T> factory,\n+                                       Consumer<? super T> recycler) {\n+        return new SingleElementPoolImpl<>(factory.get(), factory, recycler);\n+    }\n+\n+    \/**\n+     * {@return a new SingleElementPool with the given single {@code pooledElement}}\n+     * @param factory  used to create new elements\n+     * @param recycler used to dispose of elements\n+     * @param <T> the pool element type\n+     * @throws NullPointerException if either of {@code factory} or {@code recycler}\n+     *         is {@code null}\n+     *\/\n+    static <T> SingleElementPool<T> of(T pooledElement,\n+                                       Supplier<? extends T> factory,\n+                                       Consumer<? super T> recycler) {\n+        return new SingleElementPoolImpl<>(pooledElement, factory, recycler);\n+    }\n+\n+    \/\/ The class is not final to allow subclassing for low-level use.\n+    non-sealed class SingleElementPoolImpl<T> implements SingleElementPool<T> {\n+\n+        private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+        private static final long POOLED_ELEMENT_TAKEN_OFFSET =\n+                UNSAFE.objectFieldOffset(SingleElementPoolImpl.class, \"pooledElementTaken\");\n+        private static final long CLOSED_OFFSET =\n+                UNSAFE.objectFieldOffset(SingleElementPoolImpl.class, \"closed\");\n+\n+        private static final int FALSE = 0;\n+        private static final int TRUE = 1;\n+\n+        @Stable\n+        private final Supplier<? extends T> factory;\n+        @Stable\n+        private final Consumer<? super T> recycler;\n+        @Stable\n+        private final T pooledElement;\n+        \/\/ Using an int lock is faster than CASing a reference field\n+        private int pooledElementTaken;\n+        private int closed;\n+\n+        public SingleElementPoolImpl(T pooledElement,\n+                                     Supplier<? extends T> factory,\n+                                     Consumer<? super T> recycler) {\n+            Objects.requireNonNull(factory);\n+            Objects.requireNonNull(recycler);\n+            this.factory = factory;\n+            this.recycler = recycler;\n+            this.pooledElement = pooledElement;\n+        }\n+\n+        \/\/ Used reflectively\n+        @ForceInline\n+        public T take() {\n+            return takePooledElement() ? pooledElement : factory.get();\n+        }\n+\n+        \/\/ Used reflectively\n+        @ForceInline\n+        public void release(T element) {\n+            if (element == pooledElement) {\n+                releasePooledElement();\n+            } else {\n+                recycler.accept(element);\n+            }\n+        }\n+\n+        \/\/ This method is called by a separate cleanup thread when the associated\n+        \/\/ platform thread is dead.\n+        public void close() {\n+            if (UNSAFE.compareAndSetInt(this, CLOSED_OFFSET, FALSE, TRUE)) {\n+                if (UNSAFE.getIntVolatile(this, POOLED_ELEMENT_TAKEN_OFFSET) == FALSE) {\n+                    recycler.accept(pooledElement);\n+                }\n+            }\n+        }\n+\n+        @ForceInline\n+        private boolean takePooledElement() {\n+            return UNSAFE.getAndSetInt(this, POOLED_ELEMENT_TAKEN_OFFSET, TRUE) == FALSE;\n+        }\n+\n+        @ForceInline\n+        private void releasePooledElement() {\n+            UNSAFE.putIntVolatile(this, POOLED_ELEMENT_TAKEN_OFFSET, FALSE);\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SingleElementPool.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+package jdk.internal.util;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+final class SingleElementPoolImpl2<T> {\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    private static final long LOCKED_OFFSET =\n+            UNSAFE.objectFieldOffset(SingleElementPoolImpl2.class, \"locked\");\n+    private static final long CLOSED_OFFSET =\n+            UNSAFE.objectFieldOffset(SingleElementPoolImpl2.class, \"closed\");\n+\n+    @Stable\n+    private final Supplier<? extends T> factory;\n+    @Stable\n+    private final Consumer<? super T> recycler;\n+    @Stable\n+    private final T pooledElement;\n+    \/\/ Using an int lock is faster than CASing a reference field\n+    private int locked;\n+    private int closed;\n+\n+    public SingleElementPoolImpl2(T pooledElement,\n+                                 Supplier<? extends T> factory,\n+                                 Consumer<? super T> recycler) {\n+        this.factory = factory;\n+        this.recycler = recycler;\n+        this.pooledElement = pooledElement;\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    public T take() {\n+        return lock() ? pooledElement : factory.get();\n+    }\n+\n+    \/\/ Used reflectively\n+    @ForceInline\n+    public void release(T element) {\n+        if (element == pooledElement) {\n+            unlock();\n+        } else {\n+            recycler.accept(element);\n+        }\n+    }\n+\n+    \/\/ This method is called by a separate cleanup thread when the associated\n+    \/\/ platform thread is dead.\n+    public void close() {\n+        if (!UNSAFE.compareAndSetInt(this, CLOSED_OFFSET, 0, 1)) {\n+            recycler.accept(pooledElement);\n+        }\n+    }\n+\n+    @ForceInline\n+    private boolean lock() {\n+        return UNSAFE.getAndSetInt(this, LOCKED_OFFSET, 1) == 0;\n+    }\n+\n+    @ForceInline\n+    private void unlock() {\n+        UNSAFE.putIntVolatile(this, LOCKED_OFFSET, 0);\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SingleElementPoolImpl2.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Basic tests of SingleElementPool\n+ * @modules java.base\/jdk.internal.util\n+ * @run junit SingleElementPoolTest\n+ *\/\n+\n+import jdk.internal.util.SingleElementPool;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class SingleElementPoolTest {\n+\n+    @Test\n+    public void basic() {\n+        final List<TestElement> recycledElements = new ArrayList<>();\n+        TestElement element = new TestElement();\n+        SingleElementPool.SingleElementPoolImpl<TestElement> pool =\n+                new SingleElementPool.SingleElementPoolImpl<>(element, TestElement::new, recycledElements::add);\n+\n+        TestElement first = pool.take();\n+        assertSame(element, first);\n+        TestElement second = pool.take();\n+        assertNotSame(first, second);\n+        pool.release(second);\n+        pool.release(first);\n+        TestElement reused = pool.take();\n+        assertSame(element, reused);\n+        pool.release(reused);\n+        pool.close();\n+        assertEquals(List.of(second, first), recycledElements);\n+    }\n+\n+    @Test\n+    public void closeReleased() {\n+        final List<TestElement> recycledElements = new ArrayList<>();\n+        TestElement element = new TestElement();\n+        SingleElementPool.SingleElementPoolImpl<TestElement> pool =\n+                new SingleElementPool.SingleElementPoolImpl<>(element, TestElement::new, recycledElements::add);\n+        TestElement first = pool.take();\n+        pool.release(first);\n+\n+        pool.close();\n+\n+        assertEquals(List.of(first), recycledElements);\n+\n+        \/\/ Check idempotency\n+        pool.close();\n+        assertEquals(List.of(first), recycledElements);\n+    }\n+\n+    @Test\n+    public void closeNotReleased() {\n+        final List<TestElement> recycledElements = new ArrayList<>();\n+        TestElement element = new TestElement();\n+        SingleElementPool.SingleElementPoolImpl<TestElement> pool =\n+                new SingleElementPool.SingleElementPoolImpl<>(element, TestElement::new, recycledElements::add);\n+        TestElement first = pool.take();\n+        pool.close();\n+\n+        assertTrue(recycledElements.isEmpty());\n+\n+        \/\/ Check idempotency\n+        pool.close();\n+        assertTrue(recycledElements.isEmpty());\n+    }\n+\n+    @Test\n+    public void invariants() {\n+        assertThrows(NullPointerException.class, () -> SingleElementPool.of(null, _ -> {}));\n+        assertThrows(NullPointerException.class, () -> SingleElementPool.of(Object::new, null));\n+        assertDoesNotThrow(() -> SingleElementPool.of(null, Object::new, _ -> {}));\n+    }\n+\n+    static final class TestElement{}\n+\n+}\n","filename":"test\/jdk\/java\/util\/SingleElementPool\/SingleElementPoolTest.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"}]}