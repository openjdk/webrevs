{"files":[{"patch":"@@ -196,0 +196,2 @@\n+     * @throws IllegalArgumentException if the provided {@code stateName} is unknown\n+     *                                  on the current platform\n@@ -205,1 +207,1 @@\n-        if (target.type().parameterType(0) != MemorySegment.class) {\n+        if (target.type().parameterCount() == 0 || target.type().parameterType(0) != MemorySegment.class) {\n@@ -214,1 +216,2 @@\n-            throw new IllegalArgumentException(\"Unknown state name: \" + stateName);\n+            throw new IllegalArgumentException(\"Unknown state name: \" + stateName +\n+                    \". Known on this platform: \" + Linker.Option.captureStateLayout());\n@@ -259,3 +262,1 @@\n-        result = MethodHandles.collectArguments(result, 0, ACQUIRE_CACHE_MH);\n-\n-        return result;\n+        return MethodHandles.collectArguments(result, 0, ACQUIRE_CACHE_MH);\n@@ -273,1 +274,2 @@\n-     * segment. Having a secondary cache of these is slower than using malloc\/free directly.\n+     * segment, there will be no reuse. Having a secondary cache of these is slower than\n+     * using malloc\/free directly.\n@@ -275,1 +277,1 @@\n-     * The `cachedField` is about three times faster than a more general `deque`.\n+     * The cache is about three times faster than a more general `deque`.\n@@ -277,2 +279,2 @@\n-     * The class is using Unsafe rather than other supported APIs to allow early use\n-     * in the boostrap sequence.\n+     * The class is using j.i.m.Unsafe rather than other supported APIs to allow early\n+     * use in the boostrap sequence.\n@@ -307,3 +309,1 @@\n-        \/\/ platform thread is dead. So, there is no concurrent use here.\n-        \/\/ The method consumes the cached element in order for the method to be idempotent\n-        \/\/ which might be a bit paranoid.\n+        \/\/ platform thread is dead.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        int r = (int) ADAPTED_INT.invoke(1, 0);\n+        int r = (int) ADAPTED_INT.invokeExact(1, 0);\n@@ -81,1 +81,1 @@\n-        int r = (int) ADAPTED_INT.invoke(-1, EACCES);\n+        int r = (int) ADAPTED_INT.invokeExact(-1, EACCES);\n@@ -87,1 +87,1 @@\n-        long r = (long) ADAPTED_LONG.invoke(1, 0);\n+        long r = (long) ADAPTED_LONG.invokeExact(1L, 0);\n@@ -93,1 +93,1 @@\n-        long r = (long) ADAPTED_LONG.invoke(-1, EACCES);\n+        long r = (long) ADAPTED_LONG.invokeExact(-1L, EACCES);\n@@ -114,1 +114,1 @@\n-        assertEquals(\"Unknown state name: foo\", wrongCaptureName.getMessage());\n+        assertTrue(wrongCaptureName.getMessage().startsWith(\"Unknown state name: foo\"), wrongCaptureName.getMessage());\n","filename":"test\/jdk\/java\/foreign\/TestCaptureStateUtil.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}