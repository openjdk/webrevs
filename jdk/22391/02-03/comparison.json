{"files":[{"patch":"@@ -41,4 +41,0 @@\n-import java.util.List;\n-import java.util.Random;\n-import java.util.concurrent.locks.LockSupport;\n-import java.util.stream.IntStream;\n@@ -124,101 +120,0 @@\n-    private static final int THREAD_COUNT = 1 << 14;\n-    private static final int LOOP_COUNT = 1 << 16;\n-\n-    \/\/ As TerminatingThreadLocal is carrier-local, this test tries to make sure that\n-    \/\/ a VT can not see another VT's thread local memory segment despite extensive\n-    \/\/ unmounting taking place.\n-    @Test\n-    void threadBarrage() {\n-\n-        \/\/ Create the work units\n-        var works = IntStream.range(0, THREAD_COUNT)\n-                .mapToObj(_ -> new Work())\n-                .toList();\n-\n-        \/\/ Pre-create the VTs before starting them\n-        var virtualThreads = works.stream()\n-                .map(Thread.ofVirtual()::unstarted)\n-                .toList();\n-\n-        \/\/ Kick off the VTs once all of them are create\n-        virtualThreads.forEach(Thread::start);\n-\n-        \/\/ Rely on the scheduler to interrupt VTs with lower prio\n-        var spawner = new HiPrioSpawner();\n-        var spawnerThread = Thread.ofPlatform().start(spawner);\n-\n-        \/\/ Wait for all VTs to complete\n-        virtualThreads.forEach(TestCaptureStateUtil::join);\n-        spawner.shutdown();\n-        join(spawnerThread);\n-\n-        \/\/ Count how many work items were ok\n-        long ok = works.stream()\n-                .filter(Work::isOk)\n-                .count();\n-\n-        assertEquals(works.size(), ok, \"Only \" + ok + \" of \" + works.size() + \" virtual threads made it!\");\n-    }\n-\n-    private static final class HiPrioSpawner implements Runnable {\n-\n-        private volatile boolean running = true;\n-\n-        private static final long INTERVAL_NS = 100_000; \/\/ Max 1_000_000_000\/100_000 = 10_000 new threads per second\n-\n-        @Override\n-        public void run() {\n-            long next = System.nanoTime() + INTERVAL_NS;\n-\n-            while (running) {\n-                \/\/Thread t = Thread.ofVirtual().unstarted((() -> {}));\n-                Thread t = Thread.ofPlatform().unstarted((() -> {}));\n-                t.setPriority(Thread.MAX_PRIORITY);\n-                t.start();\n-                join(t);\n-\n-                \/\/ Throttle the number of new threads per second\n-                while (System.nanoTime() < next) {\n-                    LockSupport.parkNanos(INTERVAL_NS \/ 100);\n-                }\n-                next += INTERVAL_NS;\n-            }\n-        }\n-\n-        void shutdown() {\n-            running = false;\n-        }\n-\n-    }\n-\n-    private static final class Work implements Runnable {\n-\n-        private volatile boolean ok = true;\n-\n-        public void run() {\n-            final int threadId = (int) Thread.currentThread().threadId() & Integer.MAX_VALUE;\n-            for (int i = 0; i < LOOP_COUNT && ok; i++) {\n-                try {\n-                    long r = (long) ADAPTED_LONG.invoke(-1L, threadId);\n-                    if (-threadId != r) {\n-                        ok = false;\n-                    }\n-                } catch (Throwable t) {\n-                    ok = false;\n-                }\n-            }\n-        }\n-\n-        public boolean isOk() {\n-            return ok;\n-        }\n-    }\n-\n-    static void join(Thread t) {\n-        try {\n-            t.join();\n-        } catch (InterruptedException ie) {\n-            throw new RuntimeException(ie);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestCaptureStateUtil.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"modified"}]}