{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -97,1 +98,1 @@\n-    private static final Map<Class<?>, Map<String, MethodHandle>> CAPTURE_STATE_EXTRACTORS;\n+    private static final Map<Class<?>, Map<String, MethodHandle>> INNER_HANDLES;\n@@ -103,1 +104,1 @@\n-        for (var clazz : new Class<?>[]{int.class, long.class}) {\n+        for (var returnType : new Class<?>[]{int.class, long.class}) {\n@@ -111,1 +112,1 @@\n-                                MethodHandle mh = vh.toMethodHandle(VarHandle.AccessMode.GET);\n+                                MethodHandle intExtractor = vh.toMethodHandle(VarHandle.AccessMode.GET);\n@@ -113,1 +114,15 @@\n-                                return MethodHandles.insertArguments(mh, 1, 0L);\n+                                intExtractor = MethodHandles.insertArguments(intExtractor, 1, 0L);\n+\n+                                if (returnType.equals(int.class)) {\n+                                    \/\/ (int, MemorySegment)int\n+                                    return MethodHandles.guardWithTest(\n+                                            NON_NEGATIVE_INT_MH,\n+                                            SUCCESS_INT_MH,\n+                                            ERROR_INT_MH.bindTo(intExtractor));\n+                                } else {\n+                                    \/\/ (long, MemorySegment)long\n+                                    return MethodHandles.guardWithTest(\n+                                            NON_NEGATIVE_LONG_MH,\n+                                            SUCCESS_LONG_MH,\n+                                            ERROR_LONG_MH.bindTo(intExtractor));\n+                                }\n@@ -116,1 +131,1 @@\n-            classMap.put(clazz, handles);\n+            classMap.put(returnType, handles);\n@@ -118,1 +133,1 @@\n-        CAPTURE_STATE_EXTRACTORS = Map.copyOf(classMap);\n+        INNER_HANDLES = Map.copyOf(classMap);\n@@ -195,1 +210,1 @@\n-        final MethodHandle captureStateExtractor = CAPTURE_STATE_EXTRACTORS\n+        MethodHandle inner = INNER_HANDLES\n@@ -198,1 +213,1 @@\n-        if (captureStateExtractor == null) {\n+        if (inner == null) {\n@@ -202,8 +217,1 @@\n-        final boolean isInt = (returnType == int.class);\n-\n-        \/\/ Todo: Cache the error handles\n-        \/\/ ((int|long), MemorySegment)(int|long)\n-        MethodHandle inner = MethodHandles.guardWithTest(\n-                isInt ? NON_NEGATIVE_INT_MH : NON_NEGATIVE_LONG_MH,\n-                isInt ? SUCCESS_INT_MH : SUCCESS_LONG_MH,\n-                (isInt ? ERROR_INT_MH : ERROR_LONG_MH).bindTo(captureStateExtractor));\n+        \/\/ Make `target` specific adaptations\n@@ -274,3 +282,7 @@\n-        private static final long CACHED_SEGMENT_OFFSET =\n-                UNSAFE.objectFieldOffset(SegmentCache.class, \"cachedSegment\");\n-        private MemorySegment cachedSegment;\n+        private static final long ALLOCATED_OFFSET =\n+                UNSAFE.objectFieldOffset(SegmentCache.class, \"lock\");\n+\n+        \/\/ Using an int lock is faster than CASing a reference field\n+        private int lock;\n+        @Stable\n+        private final MemorySegment cachedSegment = malloc();\n@@ -281,2 +293,1 @@\n-            final MemorySegment segment = acquireFromCache();\n-            return segment == null ? malloc() : segment;\n+            return lock() ? cachedSegment : malloc();\n@@ -288,1 +299,3 @@\n-            if (!releaseToCache(segment)) {\n+            if (segment == cachedSegment) {\n+                unlock();\n+            } else {\n@@ -298,4 +311,1 @@\n-            final MemorySegment cSeg = acquireFromCache();\n-            if (cSeg != null) {\n-                free(cSeg);\n-            }\n+            free(cachedSegment);\n@@ -305,2 +315,2 @@\n-        private MemorySegment acquireFromCache() {\n-            return (MemorySegment) UNSAFE.getAndSetReference(this, CACHED_SEGMENT_OFFSET, null);\n+        private boolean lock() {\n+            return UNSAFE.getAndSetInt(this, ALLOCATED_OFFSET, 1) == 0;\n@@ -310,2 +320,2 @@\n-        private boolean releaseToCache(MemorySegment segment) {\n-            return UNSAFE.compareAndSetReference(this, CACHED_SEGMENT_OFFSET, null, segment);\n+        private void unlock() {\n+            UNSAFE.putIntVolatile(this, ALLOCATED_OFFSET, 0);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil.java","additions":40,"deletions":30,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-            return (int) DUMMY_EXPLICIT_ALLOC.invoke(arena.allocate(SIZE), 0, 0);\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), 0, 0);\n@@ -76,1 +76,1 @@\n-            return (int) DUMMY_EXPLICIT_ALLOC.invoke(arena.allocate(SIZE), -1, 1);\n+            return (int) DUMMY_EXPLICIT_ALLOC.invokeExact(arena.allocate(SIZE), -1, 1);\n@@ -82,1 +82,1 @@\n-        return (int) DUMMY_TL_ALLOC.invoke(0, 0);\n+        return (int) DUMMY_TL_ALLOC.invokeExact(0, 0);\n@@ -87,1 +87,1 @@\n-        return (int) DUMMY_TL_ALLOC.invoke( -1, 1);\n+        return (int) DUMMY_TL_ALLOC.invokeExact( -1, 1);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CaptureStateUtilBench.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}