{"files":[{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.vm.Continuation;\n+import jdk.internal.vm.ContinuationSupport;\n@@ -212,0 +214,17 @@\n+        if (Thread.currentThread().isVirtual() && ContinuationSupport.isSupported()) {\n+            \/\/ Make sure we are not unmounted\/remounted from\/on another platform thread\n+            \/\/ during the critical read region. This prevents access across platform threads.\n+            Continuation.pin();\n+            try {\n+                return getStateAsIntCriticalRegion(handle);\n+            } finally {\n+                Continuation.unpin();\n+            }\n+        } else {\n+            \/\/ On platform threads, we always remain on the PT itself\n+            return getStateAsIntCriticalRegion(handle);\n+        }\n+    }\n+\n+    \/\/ Critical read region for VTs.\n+    private static int getStateAsIntCriticalRegion(VarHandle handle) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+import java.util.Random;\n+import java.util.concurrent.locks.LockSupport;\n@@ -122,0 +124,6 @@\n+    private static final int THREAD_COUNT = 1 << 14;\n+    private static final int LOOP_COUNT = 1 << 16;\n+\n+    \/\/ As TerminatingThreadLocal is carrier-local, this test tries to make sure that\n+    \/\/ a VT can not see another VT's thread local memory segment despite extensive\n+    \/\/ unmounting taking place.\n@@ -124,2 +132,9 @@\n-        var virtualThreads = IntStream.range(0, 1 << 14)\n-                .mapToObj(_ -> Thread.ofVirtual().unstarted(TestCaptureStateUtil::work))\n+\n+        \/\/ Create the work units\n+        var works = IntStream.range(0, THREAD_COUNT)\n+                .mapToObj(_ -> new Work())\n+                .toList();\n+\n+        \/\/ Pre-create the VTs before starting them\n+        var virtualThreads = works.stream()\n+                .map(Thread.ofVirtual()::unstarted)\n@@ -128,0 +143,1 @@\n+        \/\/ Kick off the VTs once all of them are create\n@@ -130,5 +146,39 @@\n-        virtualThreads.forEach(t -> {\n-            try {\n-                t.join();\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n+        \/\/ Rely on the scheduler to interrupt VTs with lower prio\n+        var spawner = new HiPrioSpawner();\n+        var spawnerThread = Thread.ofPlatform().start(spawner);\n+\n+        \/\/ Wait for all VTs to complete\n+        virtualThreads.forEach(TestCaptureStateUtil::join);\n+        spawner.shutdown();\n+        join(spawnerThread);\n+\n+        \/\/ Count how many work items were ok\n+        long ok = works.stream()\n+                .filter(Work::isOk)\n+                .count();\n+\n+        assertEquals(works.size(), ok, \"Only \" + ok + \" of \" + works.size() + \" virtual threads made it!\");\n+    }\n+\n+    private static final class HiPrioSpawner implements Runnable {\n+\n+        private volatile boolean running = true;\n+\n+        private static final long INTERVAL_NS = 100_000; \/\/ Max 1_000_000_000\/100_000 = 10_000 new threads per second\n+\n+        @Override\n+        public void run() {\n+            long next = System.nanoTime() + INTERVAL_NS;\n+\n+            while (running) {\n+                \/\/Thread t = Thread.ofVirtual().unstarted((() -> {}));\n+                Thread t = Thread.ofPlatform().unstarted((() -> {}));\n+                t.setPriority(Thread.MAX_PRIORITY);\n+                t.start();\n+                join(t);\n+\n+                \/\/ Throttle the number of new threads per second\n+                while (System.nanoTime() < next) {\n+                    LockSupport.parkNanos(INTERVAL_NS \/ 100);\n+                }\n+                next += INTERVAL_NS;\n@@ -136,1 +186,6 @@\n-        });\n+        }\n+\n+        void shutdown() {\n+            running = false;\n+        }\n+\n@@ -139,8 +194,15 @@\n-    private static void work() {\n-        final int threadId = (int) Thread.currentThread().threadId() & Integer.MAX_VALUE;\n-        for (int i = 0; i < (1 << 14); i++) {\n-            long r = 0;\n-            try {\n-                r = (long) ADAPTED_LONG.invoke(-1L, threadId);\n-            } catch (Throwable t) {\n-                fail(t);\n+    private static final class Work implements Runnable {\n+\n+        private volatile boolean ok = true;\n+\n+        public void run() {\n+            final int threadId = (int) Thread.currentThread().threadId() & Integer.MAX_VALUE;\n+            for (int i = 0; i < LOOP_COUNT && ok; i++) {\n+                try {\n+                    long r = (long) ADAPTED_LONG.invoke(-1L, threadId);\n+                    if (-threadId != r) {\n+                        ok = false;\n+                    }\n+                } catch (Throwable t) {\n+                    ok = false;\n+                }\n@@ -148,1 +210,12 @@\n-            assertEquals(-threadId, r);\n+        }\n+\n+        public boolean isOk() {\n+            return ok;\n+        }\n+    }\n+\n+    static void join(Thread t) {\n+        try {\n+            t.join();\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n","filename":"test\/jdk\/java\/foreign\/TestCaptureStateUtil.java","additions":90,"deletions":17,"binary":false,"changes":107,"status":"modified"}]}