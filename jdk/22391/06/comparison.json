{"files":[{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.internal.invoke.MhUtil;\n+import jdk.internal.misc.TerminatingThreadLocal;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.Continuation;\n+import jdk.internal.vm.ContinuationSupport;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.StructLayout;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public final class CaptureStateUtil {\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+    private static final long SIZE = Linker.Option.captureStateLayout().byteSize();\n+\n+    private static final TerminatingThreadLocal<MemorySegment> TL = new TerminatingThreadLocal<>() {\n+        @Override\n+        protected void threadTerminated(MemorySegment value) {\n+            free(value);\n+        }\n+    };\n+\n+    private static final MethodHandle ACQUIRE_MH =\n+            MhUtil.findStatic(LOOKUP, \"acquireCaptureStateSegment\",\n+                    MethodType.methodType(MemorySegment.class));\n+\n+    private static final MethodHandle INT_RETURN_FILTER_MH =\n+            MhUtil.findStatic(LOOKUP, \"returnFilter\",\n+                    MethodType.methodType(int.class, MethodHandle.class, int.class));\n+\n+    private static final MethodHandle LONG_RETURN_FILTER_MH =\n+            MhUtil.findStatic(LOOKUP, \"returnFilter\",\n+                    MethodType.methodType(long.class, MethodHandle.class, long.class));\n+\n+    \/\/ (int.class | long.class) ->\n+    \/\/   ({\"GetLastError\" | \"WSAGetLastError\"} | \"errno\") ->\n+    \/\/     MethodHandle\n+    private static final Map<Class<?>, Map<String, MethodHandle>> RETURN_FILTERS;\n+\n+    static {\n+\n+        final StructLayout stateLayout = Linker.Option.captureStateLayout();\n+        final Map<Class<?>, Map<String, MethodHandle>> classMap = new HashMap<>();\n+        for (var clazz : new Class<?>[]{int.class, long.class}) {\n+            Map<String, MethodHandle> handles = stateLayout\n+                    .memberLayouts().stream()\n+                    .collect(Collectors.toUnmodifiableMap(\n+                            member -> member.name().orElseThrow(),\n+                            member -> {\n+                                MethodHandle mh = getAsIntHandle(stateLayout, member);\n+                                MethodHandle returnFilter = clazz.equals(int.class)\n+                                        ? INT_RETURN_FILTER_MH\n+                                        : LONG_RETURN_FILTER_MH;\n+                                \/\/ (int)int\n+                                return returnFilter.bindTo(mh);\n+                            }\n+                    ));\n+            classMap.put(clazz, handles);\n+        }\n+        RETURN_FILTERS = Map.copyOf(classMap);\n+    }\n+\n+    private CaptureStateUtil() {\n+    }\n+\n+    \/**\n+     * {@return a new MethodHandle that adapts the provided {@code target} so that it\n+     *          directly returns the same value as the {@code target} if it is\n+     *          non-negative, otherwise returns the negated errno}\n+     * <p>\n+     * This method is suitable for adapting system-call method handles(e.g.\n+     * {@code open()}, {@code read()}, and {@code close()}). Clients can check the return\n+     * value as shown in this example:\n+     * {@snippet lang = java:\n+     *       \/\/ (MemorySegment capture, MemorySegment pathname, int flags)int\n+     *       static final MethodHandle CAPTURING_OPEN = ...\n+     *\n+     *      \/\/ (MemorySegment pathname, int flags)int\n+     *      static final MethodHandle OPEN = CaptureStateUtil.adaptSystemCall(CAPTURING_OPEN, \"errno\");\n+     *\n+     *      try {\n+     *         int fh = (int)OPEN.invoke(pathName, flags);\n+     *         if (fh < 0) {\n+     *             throw new IOException(\"Error opening file: errno = \" + (-fh));\n+     *         }\n+     *         processFile(fh);\n+     *      } catch (Throwable t) {\n+     *           throw new RuntimeException(t);\n+     *      }\n+     *\n+     *}\n+     *\n+     * @param target    method handle that returns an {@code int} or a {@code long} and has\n+     *                  a capturing state MemorySegment as its first parameter\n+     * @param stateName the name of the capturing state member layout\n+     *                  (i.e. \"errno\",\"GetLastError\", or \"WSAGetLastError\")\n+     * @throws IllegalArgumentException if the provided {@code target}'s return type is\n+     *                                  not {@code int} or {@code long}\n+     * @throws IllegalArgumentException if the provided {@code target}'s first parameter\n+     *                                  type is not {@linkplain MemorySegment}\n+     *\/\n+    public static MethodHandle adaptSystemCall(MethodHandle target, String stateName) {\n+        \/\/ Implicit null check\n+        final Class<?> returnType = target.type().returnType();\n+        Objects.requireNonNull(stateName);\n+\n+        if (!(returnType.equals(int.class) || returnType.equals(long.class))) {\n+            throw illegalArgDoesNot(target, \"return an int or a long\");\n+        }\n+        if (target.type().parameterType(0) != MemorySegment.class) {\n+            throw illegalArgDoesNot(target, \"have a MemorySegment as the first parameter\");\n+        }\n+\n+        \/\/ (int | long)(int | long)\n+        final MethodHandle returnFilter = RETURN_FILTERS\n+                .get(returnType)\n+                .get(stateName);\n+        if (returnFilter == null) {\n+            throw new IllegalArgumentException(\"Unknown state name: \" + stateName);\n+        }\n+\n+        \/\/ (MemorySegment, C*)(int | long) -> (C*)(int | long)\n+        target = MethodHandles.collectArguments(target, 0, ACQUIRE_MH);\n+\n+        \/\/ (C*)(int | long) -> (C*)(int | long)\n+        return MethodHandles.filterReturnValue(target, returnFilter);\n+    }\n+\n+    \/\/ Used reflectively via ACQUIRE_MH\n+    private static MemorySegment acquireCaptureStateSegment() {\n+        MemorySegment segment = TL.get();\n+        if (segment == null) {\n+            TL.set(segment = malloc());\n+        }\n+        return segment;\n+    }\n+\n+    \/\/ Used reflectively via INT_RETURN_FILTER_MH\n+    @ForceInline\n+    private static int returnFilter(MethodHandle errorHandle, int result) throws Throwable {\n+        if (result >= 0) {\n+            return result;\n+        }\n+        return -(int) errorHandle.invoke();\n+    }\n+\n+    \/\/ Used reflectively via LONG_RETURN_FILTER_MH\n+    @ForceInline\n+    private static long returnFilter(MethodHandle errorHandle, long result) throws Throwable {\n+        if (result >= 0) {\n+            return result;\n+        }\n+        return -(int) errorHandle.invoke();\n+    }\n+\n+    @SuppressWarnings(\"restricted\")\n+    private static MemorySegment malloc() {\n+        final long address = UNSAFE.allocateMemory(SIZE);\n+        return MemorySegment.ofAddress(address).reinterpret(SIZE);\n+    }\n+\n+    private static void free(MemorySegment segment) {\n+        UNSAFE.freeMemory(segment.address());\n+    }\n+\n+    private static IllegalArgumentException illegalArgDoesNot(MethodHandle target, String info) {\n+        return new IllegalArgumentException(\"The provided target \" + target\n+                + \" does not \" + info);\n+    }\n+\n+    private static MethodHandle getAsIntHandle(StructLayout parent, MemoryLayout layout) {\n+        final MethodHandle handle = MhUtil.findStatic(LOOKUP, \"getStateAsInt\", MethodType.methodType(int.class, VarHandle.class));\n+        return handle.bindTo(parent.varHandle(MemoryLayout.PathElement.groupElement(layout.name().orElseThrow())));\n+    }\n+\n+    \/\/ Used reflectively by `getAsIntHandle(MemoryLayout layout)`\n+    private static int getStateAsInt(VarHandle handle) {\n+        if (ContinuationSupport.isSupported() && Thread.currentThread().isVirtual()) {\n+            \/\/ Make sure we are not unmounted\/remounted from\/on another platform thread\n+            \/\/ during the critical read region. This prevents access across platform threads.\n+            Continuation.pin();\n+            try {\n+                return getStateAsIntCriticalRegion(handle);\n+            } finally {\n+                Continuation.unpin();\n+            }\n+        } else {\n+            \/\/ On platform threads, we always remain on the PT itself\n+            return getStateAsIntCriticalRegion(handle);\n+        }\n+    }\n+\n+    \/\/ Critical read region for VTs.\n+    private static int getStateAsIntCriticalRegion(VarHandle handle) {\n+        return (int) handle.get(acquireCaptureStateSegment(), 0);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CaptureStateUtil.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,9 @@\n+    public static MethodHandle findStatic(MethodHandles.Lookup lookup,\n+                                          String name,\n+                                          MethodType type) {\n+        try {\n+            return lookup.findStatic(lookup.lookupClass(), name, type);\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/MhUtil.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test CaptureStateUtil\n+ * @modules java.base\/jdk.internal.foreign\n+ * @run junit TestCaptureStateUtil\n+ *\/\n+\n+import jdk.internal.foreign.CaptureStateUtil;\n+import org.junit.jupiter.api.Test;\n+\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestCaptureStateUtil {\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n+                    .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n+\n+    private static final MethodHandle INT_DUMMY_HANDLE;\n+    private static final MethodHandle LONG_DUMMY_HANDLE;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            INT_DUMMY_HANDLE = lookup\n+                    .findStatic(TestCaptureStateUtil.class, \"dummy\",\n+                            MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+            LONG_DUMMY_HANDLE = lookup\n+                    .findStatic(TestCaptureStateUtil.class, \"dummy\",\n+                            MethodType.methodType(long.class, MemorySegment.class, long.class, int.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static final MethodHandle ADAPTED_INT = CaptureStateUtil.adaptSystemCall(INT_DUMMY_HANDLE, ERRNO_NAME);\n+    private static final MethodHandle ADAPTED_LONG = CaptureStateUtil.adaptSystemCall(LONG_DUMMY_HANDLE, ERRNO_NAME);\n+\n+    @Test\n+    void successfulInt() throws Throwable {\n+        int r = (int) ADAPTED_INT.invoke(1, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    private static final int EACCES = 13; \/* Permission denied *\/\n+\n+    @Test\n+    void errorInt() throws Throwable {\n+        int r = (int) ADAPTED_INT.invoke(-1, EACCES);\n+        assertEquals(-EACCES, r);\n+    }\n+\n+    @Test\n+    void successfulLong() throws Throwable {\n+        long r = (long) ADAPTED_LONG.invoke(1, 0);\n+        assertEquals(1, r);\n+    }\n+\n+    @Test\n+    void errorLong() throws Throwable {\n+        long r = (long) ADAPTED_LONG.invoke(-1, EACCES);\n+        assertEquals(-EACCES, r);\n+    }\n+\n+    @Test\n+    void invariants() throws Throwable {\n+        MethodHandle noSegment = MethodHandles.lookup()\n+                .findStatic(TestCaptureStateUtil.class, \"wrongType\",\n+                        MethodType.methodType(long.class, long.class, int.class));\n+\n+        var noSegEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, ERRNO_NAME));\n+        assertTrue(noSegEx.getMessage().contains(\"does not have a MemorySegment as the first parameter\"));\n+\n+        MethodHandle wrongReturnType = MethodHandles.lookup()\n+                .findStatic(TestCaptureStateUtil.class, \"wrongType\",\n+                        MethodType.methodType(short.class, MemorySegment.class, long.class, int.class));\n+\n+        var wrongRetEx = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(wrongReturnType, ERRNO_NAME));\n+        assertTrue(wrongRetEx.getMessage().contains(\"does not return an int or a long\"));\n+\n+        var wrongCaptureName = assertThrows(IllegalArgumentException.class, () -> CaptureStateUtil.adaptSystemCall(LONG_DUMMY_HANDLE, \"foo\"));\n+        assertEquals(\"Unknown state name: foo\", wrongCaptureName.getMessage());\n+\n+        assertThrows(NullPointerException.class, () -> CaptureStateUtil.adaptSystemCall(null, ERRNO_NAME));\n+        assertThrows(NullPointerException.class, () -> CaptureStateUtil.adaptSystemCall(noSegment, null));\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int dummy(MemorySegment segment, int result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static long dummy(MemorySegment segment, long result, int errno) {\n+        ERRNO_HANDLE.set(segment, 0, errno);\n+        return result;\n+    }\n+\n+    private static long wrongType(long result, int errno) {\n+        return 0;\n+    }\n+\n+    private static short wrongType(MemorySegment segment, long result, int errno) {\n+        return 0;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestCaptureStateUtil.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import jdk.internal.foreign.CaptureStateUtil;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgs = {\"--add-exports=java.base\/jdk.internal.foreign=ALL-UNNAMED\",\n+        \"--enable-native-access=ALL-UNNAMED\"})\n+public class CaptureStateUtilBench {\n+\n+    private static final String ERRNO_NAME = \"errno\";\n+\n+    private static final VarHandle ERRNO_HANDLE = Linker.Option.captureStateLayout()\n+            .varHandle(MemoryLayout.PathElement.groupElement(ERRNO_NAME));\n+\n+    private static final long SIZE = Linker.Option.captureStateLayout().byteSize();\n+\n+    private static final MethodHandle DUMMY_EXPLICIT_ALLOC = dummyExplicitAlloc();\n+    private static final MethodHandle DUMMY_TL_ALLOC = dummyTlAlloc();\n+\n+    @Benchmark\n+    public int explicitSuccess() throws Throwable {\n+        try (var arena = Arena.ofConfined()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invoke(arena.allocate(SIZE), 0, 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int explicitFail() throws Throwable {\n+        try (var arena = Arena.ofConfined()) {\n+            return (int) DUMMY_EXPLICIT_ALLOC.invoke(arena.allocate(SIZE), -1, 1);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int tlSuccess() throws Throwable {\n+        return (int) DUMMY_TL_ALLOC.invoke(0, 0);\n+\n+    }\n+\n+    @Benchmark\n+    public int tlFail() throws Throwable {\n+        return (int) DUMMY_TL_ALLOC.invoke( -1, 1);\n+    }\n+\n+    private static MethodHandle dummyExplicitAlloc() {\n+        try {\n+            return MethodHandles.lookup().findStatic(CaptureStateUtilBench.class, \"dummy\", MethodType.methodType(int.class, MemorySegment.class, int.class, int.class));\n+        } catch (ReflectiveOperationException roe) {\n+            throw new RuntimeException(roe);\n+        }\n+    }\n+\n+    private static MethodHandle dummyTlAlloc() {\n+        final MethodHandle handle = dummyExplicitAlloc();\n+        return CaptureStateUtil.adaptSystemCall(handle, ERRNO_NAME);\n+    }\n+\n+    \/\/ Dummy method that is just returning the provided parameters\n+    private static int dummy(MemorySegment segment, int result, int errno) {\n+        if (errno != 0) {\n+            \/\/ Assuming the capture state is only modified upon detecting an error.\n+            ERRNO_HANDLE.set(segment, 0, errno);\n+        }\n+        return result;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/CaptureStateUtilBench.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"}]}