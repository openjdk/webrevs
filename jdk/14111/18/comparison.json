{"files":[{"patch":"@@ -1146,11 +1146,9 @@\n-        if (TieredCompilation) {\n-          \/\/ If there is an old version we're done with it\n-          CompiledMethod* old = method->code();\n-          if (TraceMethodReplacement && old != nullptr) {\n-            ResourceMark rm;\n-            char *method_name = method->name_and_sig_as_C_string();\n-            tty->print_cr(\"Replacing method %s\", method_name);\n-          }\n-          if (old != nullptr) {\n-            old->make_not_used();\n-          }\n+        \/\/ If there is an old version we're done with it\n+        CompiledMethod* old = method->code();\n+        if (TraceMethodReplacement && old != nullptr) {\n+          ResourceMark rm;\n+          char *method_name = method->name_and_sig_as_C_string();\n+          tty->print_cr(\"Replacing method %s\", method_name);\n+        }\n+        if (old != nullptr) {\n+          old->make_not_used();\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"compiler\/compilerDirectives.hpp\"\n@@ -1384,0 +1385,61 @@\n+void CodeCache::mark_directives_matches(bool top_only) {\n+  MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+  Thread *thread = Thread::current();\n+  HandleMark hm(thread);\n+\n+  CompiledMethodIterator iter(CompiledMethodIterator::only_not_unloading);\n+  while(iter.next()) {\n+    CompiledMethod* nm = iter.method();\n+    methodHandle mh(thread, nm->method());\n+    if (DirectivesStack::hasMatchingDirectives(mh, top_only)) {\n+      ResourceMark rm;\n+      log_trace(codecache)(\"Mark because of matching directives %s\", mh->external_name());\n+      mh->set_has_matching_directives();\n+    }\n+  }\n+}\n+\n+void CodeCache::recompile_marked_directives_matches() {\n+  Thread *thread = Thread::current();\n+  HandleMark hm(thread);\n+\n+  \/\/ Try the max level and let the directives be applied during the compilation.\n+  int comp_level = CompilationPolicy::highest_compile_level();\n+  RelaxedCompiledMethodIterator iter(RelaxedCompiledMethodIterator::only_not_unloading);\n+  while(iter.next()) {\n+    CompiledMethod* nm = iter.method();\n+    methodHandle mh(thread, nm->method());\n+    if (mh->has_matching_directives()) {\n+      ResourceMark rm;\n+      mh->clear_directive_flags();\n+      bool deopt = false;\n+\n+      if (!nm->is_osr_method()) {\n+        log_trace(codecache)(\"Recompile to level %d because of matching directives %s\",\n+                             comp_level, mh->external_name());\n+        nmethod * comp_nm = CompileBroker::compile_method(mh, InvocationEntryBci, comp_level,\n+                                                          methodHandle(), 0,\n+                                                          CompileTask::Reason_DirectivesChanged,\n+                                                          (JavaThread*)thread);\n+        if (comp_nm == nullptr) {\n+          log_trace(codecache)(\"Recompilation to level %d failed, deoptimize %s\",\n+                               comp_level, mh->external_name());\n+          deopt = true;\n+        }\n+      } else {\n+        log_trace(codecache)(\"Deoptimize OSR %s\", mh->external_name());\n+        deopt = true;\n+      }\n+      \/\/ For some reason the method cannot be compiled by C2, e.g. the new directives forbid it.\n+      \/\/ Deoptimize the method and let the usual hotspot logic do the rest.\n+      if (deopt) {\n+        if (!nm->has_been_deoptimized() && nm->can_be_deoptimized()) {\n+          nm->make_not_entrant();\n+          nm->make_deoptimized();\n+        }\n+      }\n+      gc_on_allocation(); \/\/ Flush unused methods from CodeCache if required.\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -308,0 +308,3 @@\n+  static void mark_directives_matches(bool top_only = false);\n+  static void recompile_marked_directives_matches();\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1168,5 +1168,7 @@\n-  \/\/ A request has been made for compilation.  Before we do any\n-  \/\/ real work, check to see if the method has been compiled\n-  \/\/ in the meantime with a definitive result.\n-  if (compilation_is_complete(method, osr_bci, comp_level)) {\n-    return;\n+  if (compile_reason != CompileTask::Reason_DirectivesChanged) {\n+    \/\/ A request has been made for compilation.  Before we do any\n+    \/\/ real work, check to see if the method has been compiled\n+    \/\/ in the meantime with a definitive result.\n+    if (compilation_is_complete(method, osr_bci, comp_level)) {\n+      return;\n+    }\n@@ -1217,5 +1219,7 @@\n-    \/\/ We need to check again to see if the compilation has\n-    \/\/ completed.  A previous compilation may have registered\n-    \/\/ some result.\n-    if (compilation_is_complete(method, osr_bci, comp_level)) {\n-      return;\n+    if (compile_reason != CompileTask::Reason_DirectivesChanged) {\n+      \/\/ We need to check again to see if the compilation has\n+      \/\/ completed.  A previous compilation may have registered\n+      \/\/ some result.\n+      if (compilation_is_complete(method, osr_bci, comp_level)) {\n+        return;\n+      }\n@@ -1370,1 +1374,2 @@\n-    if (method_code != nullptr && method_code->is_nmethod()) {\n+    if (method_code != nullptr && method_code->is_nmethod()\n+                      && (compile_reason != CompileTask::Reason_DirectivesChanged)) {\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+      Reason_DirectivesChanged, \/\/ Changed CompilerDirectivesStack\n@@ -77,1 +78,2 @@\n-      \"bootstrap\"\n+      \"bootstrap\",\n+      \"directives_changed\"\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -738,0 +738,19 @@\n+bool DirectivesStack::hasMatchingDirectives(const methodHandle& method, bool top_only) {\n+  assert(_depth > 0, \"Must never be empty\");\n+  MutexLocker locker(DirectivesStack_lock, Mutex::_no_safepoint_check_flag);\n+\n+  CompilerDirectives* dir = _top;\n+  assert(dir != nullptr, \"Must be initialized\");\n+\n+  while (dir != nullptr) {\n+    if (!dir->is_default_directive() && dir->match(method)) {\n+      return true;\n+    }\n+    if (top_only) {\n+      break;\n+    }\n+    dir = dir->next();\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+  static bool hasMatchingDirectives(const methodHandle& method, bool top_only = false);\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -818,0 +818,8 @@\n+  \/\/ Clear the flags related to compiler directives that were set by the compilerBroker,\n+  \/\/ because the directives can be updated.\n+  void clear_directive_flags() {\n+    set_has_matching_directives(false);\n+    clear_is_not_c1_compilable();\n+    clear_is_not_c2_compilable();\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+   status(has_matching_directives     , 1 << 16) \/* Temporary mark, used only when methods are to be refreshed to reflect a compiler directives update *\/ \\\n","filename":"src\/hotspot\/share\/oops\/methodFlags.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -271,1 +271,0 @@\n-  MUTEX_DEFN(DirectivesStack_lock            , PaddedMutex  , nosafepoint);\n@@ -329,0 +328,1 @@\n+  MUTEX_DEFL(DirectivesStack_lock           , PaddedMutex  , CodeCache_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,0 +147,1 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CompilerDirectivesReplaceDCmd>(full_export, true, false));\n@@ -921,1 +922,3 @@\n-  _filename(\"filename\",\"Name of the directives file\", \"STRING\",true) {\n+  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n+  _refresh(\"-r\", \"Refresh affected methods.\", \"BOOLEAN\", false, \"false\") {\n+\n@@ -923,0 +926,1 @@\n+  _dcmdparser.add_dcmd_option(&_refresh);\n@@ -927,0 +931,37 @@\n+  if (_refresh.value()) {\n+    CodeCache::mark_directives_matches(true);\n+    CodeCache::recompile_marked_directives_matches();\n+  }\n+}\n+\n+CompilerDirectivesReplaceDCmd::CompilerDirectivesReplaceDCmd(outputStream* output, bool heap) :\n+                           DCmdWithParser(output, heap),\n+  _filename(\"filename\", \"Name of the directives file\", \"STRING\", true),\n+  _refresh(\"-r\", \"Refresh affected methods.\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_argument(&_filename);\n+  _dcmdparser.add_dcmd_option(&_refresh);\n+}\n+\n+void CompilerDirectivesReplaceDCmd::execute(DCmdSource source, TRAPS) {\n+  \/\/ Need to mark the methods twice, to account for the method that doesn't match\n+  \/\/ the directives anymore\n+  if (_refresh.value()) {\n+    CodeCache::mark_directives_matches();\n+\n+    DirectivesStack::clear();\n+    DirectivesParser::parse_from_file(_filename.value(), output(), true);\n+\n+    CodeCache::mark_directives_matches();\n+    CodeCache::recompile_marked_directives_matches();\n+  } else {\n+    DirectivesStack::clear();\n+    DirectivesParser::parse_from_file(_filename.value(), output(), true);\n+  }\n+}\n+\n+CompilerDirectivesRemoveDCmd::CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) :\n+                           DCmdWithParser(output, heap),\n+  _refresh(\"-r\", \"Refresh affected methods.\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_option(&_refresh);\n@@ -930,1 +971,14 @@\n-  DirectivesStack::pop(1);\n+  if (_refresh.value()) {\n+    CodeCache::mark_directives_matches(true);\n+    DirectivesStack::pop(1);\n+    CodeCache::recompile_marked_directives_matches();\n+  } else {\n+    DirectivesStack::pop(1);\n+  }\n+}\n+\n+CompilerDirectivesClearDCmd::CompilerDirectivesClearDCmd(outputStream* output, bool heap) :\n+                           DCmdWithParser(output, heap),\n+  _refresh(\"-r\", \"Refresh affected methods.\", \"BOOLEAN\", false, \"false\") {\n+\n+  _dcmdparser.add_dcmd_option(&_refresh);\n@@ -934,1 +988,7 @@\n-  DirectivesStack::clear();\n+  if (_refresh.value()) {\n+    CodeCache::mark_directives_matches();\n+    DirectivesStack::clear();\n+    CodeCache::recompile_marked_directives_matches();\n+  } else {\n+    DirectivesStack::clear();\n+  }\n@@ -936,0 +996,1 @@\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":64,"deletions":3,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -691,1 +691,3 @@\n-class CompilerDirectivesRemoveDCmd : public DCmd {\n+class CompilerDirectivesRemoveDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n@@ -693,1 +695,2 @@\n-  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static int num_arguments() { return 1; }\n+  CompilerDirectivesRemoveDCmd(outputStream* output, bool heap);\n@@ -714,0 +717,1 @@\n+  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n@@ -715,1 +719,1 @@\n-  static int num_arguments() { return 1; }\n+  static int num_arguments() { return 2; }\n@@ -734,1 +738,27 @@\n-class CompilerDirectivesClearDCmd : public DCmd {\n+class CompilerDirectivesReplaceDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<char*> _filename;\n+  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n+public:\n+  static int num_arguments() { return 2; }\n+  CompilerDirectivesReplaceDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"Compiler.directives_replace\";\n+  }\n+  static const char* description() {\n+    return \"Clear directives stack, and load new compiler directives from file.\";\n+  }\n+  static const char* impact() {\n+    return \"Low\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+class CompilerDirectivesClearDCmd : public DCmdWithParser {\n+protected:\n+  DCmdArgument<bool> _refresh; \/\/ true if update should be forced after directives changes.\n@@ -736,1 +766,2 @@\n-  CompilerDirectivesClearDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static int num_arguments() { return 1; }\n+  CompilerDirectivesClearDCmd(outputStream* output, bool heap);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,0 +95,8 @@\n+        if (count != 3) {\n+            Assert.fail(\"Expected three directives - found \" + count);\n+        }\n+\n+        \/\/ Test replacement with some directives from file\n+        output = executor.execute(\"Compiler.directives_replace \" + filename);\n+        output = executor.execute(\"Compiler.directives_print\");\n+        count = find(output, \"Directive:\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/CompilerDirectivesDCMDTest.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2023, BELLSOFT. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test DirectivesRefreshTest\n+ * @summary Test of forced recompile after compiler directives changes by diagnostic command\n+ * @requires vm.compiler1.enabled & vm.compiler2.enabled\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-BackgroundCompilation\n+ *                   serviceability.dcmd.compiler.DirectivesRefreshTest\n+ *\/\n+\n+package serviceability.dcmd.compiler;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.dcmd.CommandExecutor;\n+import jdk.test.lib.dcmd.JMXExecutor;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.lang.reflect.Method;\n+import java.util.Random;\n+\n+import static jdk.test.lib.Asserts.assertEQ;\n+\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_NONE;\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_SIMPLE;\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n+\n+public class DirectivesRefreshTest {\n+\n+    static Path cmdPath = Paths.get(System.getProperty(\"test.src\", \".\"), \"refresh_control.txt\");\n+    static WhiteBox wb = WhiteBox.getWhiteBox();\n+    static Random random = new Random();\n+\n+    static Method method;\n+    static CommandExecutor executor;\n+\n+    static int callable() {\n+        int result = 0;\n+        for (int i = 0; i < 100; i++) {\n+            result += random.nextInt(100);\n+        }\n+        return result;\n+    }\n+\n+    static void checkCompilationLevel(Method method, int level) {\n+        assertEQ(wb.getMethodCompilationLevel(method), level, \"Compilation level\");\n+    }\n+\n+    static void setup() throws Exception {\n+        method = DirectivesRefreshTest.class.getDeclaredMethod(\"callable\");\n+        executor = new JMXExecutor();\n+\n+        System.out.println(\"Compilation with C2\");\n+\n+        \/\/ Happens with fairly hot methods.\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+        checkCompilationLevel(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+    }\n+\n+    static void testDirectivesAddRefresh() {\n+        System.out.println(\"Force forbid C2 via directive, method deoptimized\");\n+\n+        var output = executor.execute(\"Compiler.directives_add -r \" + cmdPath.toString());\n+        output.stderrShouldBeEmpty().shouldContain(\"1 compiler directives added\");\n+        \/\/ Current handling of 'Exclude' for '-r' clears flags.\n+        checkCompilationLevel(method, COMP_LEVEL_NONE);\n+\n+        System.out.println(\"C2 is excluded, re-compilation with C1\");\n+\n+        \/\/ Sanity check for the directive.\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+        checkCompilationLevel(method, COMP_LEVEL_NONE);\n+\n+        \/\/ Happens with fairly hot methods.\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_SIMPLE);\n+        checkCompilationLevel(method, COMP_LEVEL_SIMPLE);\n+    }\n+\n+    static void testDirectivesClearRefresh() {\n+        System.out.println(\"Re-compilation with C2 due to removed restriction\");\n+\n+        var output = executor.execute(\"Compiler.directives_clear -r\");\n+        output.stderrShouldBeEmpty().stdoutShouldBeEmpty();\n+\n+        \/\/ No need to enqueue the method, \"immediate\" effect of '-r' without deoptimization.\n+        checkCompilationLevel(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+    }\n+\n+    static void testDirectivesAddRegular() {\n+        System.out.println(\"No changes if the restriction is not forced\");\n+\n+        \/\/ According to original JEP 165, the directive will be handled\n+        \/\/ \"when a method is submitted for a compilation\".\n+        var output = executor.execute(\"Compiler.directives_add \" + cmdPath.toString());\n+        output.stderrShouldBeEmpty().shouldContain(\"1 compiler directives added\");\n+\n+        \/\/ In this program the method is not called, and here it is not enqueued.\n+        checkCompilationLevel(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        setup();\n+        testDirectivesAddRefresh();\n+        testDirectivesClearRefresh();\n+        testDirectivesAddRegular();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/DirectivesRefreshTest.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,8 @@\n+[\n+  {\n+    match: \"serviceability.dcmd.compiler.DirectivesRefreshTest::callable\",\n+    c2: {\n+      Exclude: true\n+    }\n+  }\n+]\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/compiler\/refresh_control.txt","additions":8,"deletions":0,"binary":false,"changes":8,"status":"added"}]}