{"files":[{"patch":"@@ -816,0 +816,18 @@\n+    \/**\n+     * Appends the 2 width string representation of the {@code int}\n+     * argument to this sequence.\n+     *\n+     * @param   i   an {@code int}.\n+     * @return  a reference to this object.\n+     *\/\n+    void appendPair(int i) {\n+        int count = this.count;\n+        ensureCapacityInternal(count + 2);\n+        if (isLatin1()) {\n+            DecimalDigits.putPairLatin1(value, count, i);\n+        } else {\n+            DecimalDigits.putPairUTF16(value, count, i);\n+        }\n+        this.count = count + 2;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2114,0 +2114,3 @@\n+            public void appendPair(StringBuilder buf, int v) {\n+                buf.appendPair(v);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -2007,9 +2007,1 @@\n-        Objects.requireNonNull(text, \"text\");\n-        Objects.requireNonNull(query, \"query\");\n-        try {\n-            return parseResolved0(text, null).query(query);\n-        } catch (DateTimeParseException ex) {\n-            throw ex;\n-        } catch (RuntimeException ex) {\n-            throw createError(text, ex);\n-        }\n+        return printerParser.parse(text, this, query);\n@@ -2072,1 +2064,1 @@\n-    private DateTimeParseException createError(CharSequence text, RuntimeException ex) {\n+    DateTimeParseException createError(CharSequence text, RuntimeException ex) {\n@@ -2096,1 +2088,1 @@\n-    private TemporalAccessor parseResolved0(final CharSequence text, final ParsePosition position) {\n+    TemporalAccessor parseResolved0(final CharSequence text, final ParsePosition position) {\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatter.java","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+import static java.lang.classfile.ClassFile.*;\n@@ -74,1 +75,17 @@\n-\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption;\n+import static java.lang.invoke.MethodType.methodType;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.classfile.ClassBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.Label;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.Opcode;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -79,0 +96,2 @@\n+import java.nio.charset.CharacterCodingException;\n+import java.nio.charset.StandardCharsets;\n@@ -85,0 +104,2 @@\n+import java.time.OffsetDateTime;\n+import java.time.OffsetTime;\n@@ -87,0 +108,1 @@\n+import java.time.ZonedDateTime;\n@@ -121,0 +143,1 @@\n+import java.util.function.Consumer;\n@@ -124,0 +147,5 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.constant.ConstantUtils;\n+import jdk.internal.misc.VM;\n+import jdk.internal.util.ClassFileDumper;\n@@ -125,0 +153,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -164,0 +193,7 @@\n+    private static final boolean COMPILE;\n+    static {\n+        String property = VM.getSavedProperty(\"java.time.format.DateTimeFormatter.compile\");\n+        COMPILE = property == null || property.isEmpty() || \"true\".equalsIgnoreCase(property);\n+    }\n+\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -2341,1 +2377,1 @@\n-            CompositePrinterParser cpp = new CompositePrinterParser(active.printerParsers, active.optional);\n+            CompositePrinterParser cpp = CompositePrinterParser.of(active.printerParsers, active.optional);\n@@ -2434,1 +2470,1 @@\n-        CompositePrinterParser pp = new CompositePrinterParser(printerParsers, false);\n+        CompositePrinterParser pp = CompositePrinterParser.of(printerParsers, false);\n@@ -2504,1 +2540,2 @@\n-    static final class CompositePrinterParser implements DateTimePrinterParser {\n+    static class CompositePrinterParser implements DateTimePrinterParser {\n+        @Stable\n@@ -2508,5 +2545,1 @@\n-        private CompositePrinterParser(List<DateTimePrinterParser> printerParsers, boolean optional) {\n-            this(printerParsers.toArray(new DateTimePrinterParser[0]), optional);\n-        }\n-\n-        private CompositePrinterParser(DateTimePrinterParser[] printerParsers, boolean optional) {\n+        protected CompositePrinterParser(DateTimePrinterParser[] printerParsers, boolean optional) {\n@@ -2517,0 +2550,12 @@\n+        static CompositePrinterParser of(List<DateTimePrinterParser> printerParsers, boolean optional) {\n+            return of(printerParsers.toArray(new DateTimePrinterParser[0]), optional);\n+        }\n+\n+        static CompositePrinterParser of(DateTimePrinterParser[] printerParsers, boolean optional) {\n+            if (COMPILE) {\n+                return PrinterParserFactory.generate(printerParsers, optional);\n+            } else {\n+                return new CompositePrinterParser(printerParsers, optional);\n+            }\n+        }\n+\n@@ -2527,1 +2572,1 @@\n-            return new CompositePrinterParser(printerParsers, optional);\n+            return CompositePrinterParser.of(printerParsers, optional);\n@@ -2551,0 +2596,12 @@\n+        protected <T> T parse(CharSequence text, DateTimeFormatter formatter, TemporalQuery<T> query) {\n+            Objects.requireNonNull(text, \"text\");\n+            Objects.requireNonNull(query, \"query\");\n+            try {\n+                return formatter.parseResolved0(text, null).query(query);\n+            } catch (DateTimeParseException ex) {\n+                throw ex;\n+            } catch (RuntimeException ex) {\n+                throw formatter.createError(text, ex);\n+            }\n+        }\n+\n@@ -2552,1 +2609,1 @@\n-        public int parse(DateTimeParseContext context, CharSequence text, int position) {\n+        public final int parse(DateTimeParseContext context, CharSequence text, int position) {\n@@ -2555,7 +2612,6 @@\n-                int pos = position;\n-                for (DateTimePrinterParser pp : printerParsers) {\n-                    pos = pp.parse(context, text, pos);\n-                    if (pos < 0) {\n-                        context.endOptional(false);\n-                        return position;  \/\/ return original position\n-                    }\n+            }\n+            int pos = parse0(context, text, position);\n+            if (pos < 0) {\n+                if (optional) {\n+                    context.endOptional(false);\n+                    return position;  \/\/ return original position\n@@ -2563,0 +2619,2 @@\n+            }\n+            if (optional) {\n@@ -2564,0 +2622,26 @@\n+            }\n+            return pos;\n+        }\n+\n+        protected int parse0(DateTimeParseContext context, CharSequence text, int position) {\n+            int pos = position;\n+            for (DateTimePrinterParser pp : printerParsers) {\n+                pos = pp.parse(context, text, pos);\n+                if (pos < 0) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        static int litteral(CharSequence text, int pos, char literal) {\n+            char ch;\n+            if (pos == text.length() || text.charAt(pos) != literal) {\n+                throw error(text, pos);\n+            }\n+            return pos + 1;\n+        }\n+\n+        static int position(CharSequence text, long valuePos) {\n+            int pos = (int) valuePos;\n+            if (pos >= 0) {\n@@ -2565,0 +2649,17 @@\n+            }\n+\n+            throw error(text, ~pos);\n+        }\n+\n+        static int value(long valuePos) {\n+            return (int) (valuePos >> 32);\n+        }\n+\n+        static long valuePos(int value, int pos) {\n+            return (((long) value) << 32) | pos;\n+        }\n+\n+        static DateTimeParseException error(CharSequence text, int pos) {\n+            String abbr;\n+            if (text.length() > 64) {\n+                abbr = text.subSequence(0, 64).toString() + \"...\";\n@@ -2566,7 +2667,1 @@\n-                for (DateTimePrinterParser pp : printerParsers) {\n-                    position = pp.parse(context, text, position);\n-                    if (position < 0) {\n-                        break;\n-                    }\n-                }\n-                return position;\n+                abbr = text.toString();\n@@ -2574,0 +2669,3 @@\n+            int errorIndex = ~pos;\n+            return new DateTimeParseException(\"Text '\" + abbr + \"' could not be parsed at index \" +\n+                    errorIndex, text, errorIndex);\n@@ -2918,2 +3016,17 @@\n-            long value = getValue(context, valueLong);\n-            DecimalStyle decimalStyle = context.getDecimalStyle();\n+            format(buf, context.getDecimalStyle(), getValue(context, valueLong));\n+            return true;\n+        }\n+\n+        public void format(StringBuilder buf, int value) {\n+            format(buf, DecimalStyle.STANDARD, value);\n+        }\n+\n+        public void format(StringBuilder buf, long value) {\n+            format(buf, DecimalStyle.STANDARD, value);\n+        }\n+\n+        public void format(StringBuilder buf, DecimalStyle decimalStyle, int value) {\n+            format(buf, decimalStyle, (long) value);\n+        }\n+\n+        public void format(StringBuilder buf, DecimalStyle decimalStyle, long value) {\n@@ -2926,3 +3039,27 @@\n-                throw new DateTimeException(\"Field \" + field +\n-                    \" cannot be printed as the value \" + value +\n-                    \" exceeds the maximum print width of \" + maxWidth);\n+                maxWidthError(value);\n+            }\n+\n+            switch (signStyle) {\n+                case EXCEEDS_PAD  -> printSignExceedsPad(buf, decimalStyle, minWidth, size, value);\n+                case ALWAYS       -> printSignAlways(buf, decimalStyle, value);\n+                case NORMAL       -> printSignNormal(buf, decimalStyle, value);\n+                case NOT_NEGATIVE -> notNegative(value);\n+            }\n+            printValue(buf, decimalStyle, size, value);\n+        }\n+\n+        protected void printValueWidth1NotNegative(StringBuilder buf, int value) {\n+            buf.append((char) ('0' + value));\n+        }\n+\n+        protected final void printValueWidth2NotNegative(StringBuilder buf, int value) {\n+            buf.append(value);\n+        }\n+\n+        protected void printValueFixedWidth2NotNegative(StringBuilder buf, int value) {\n+            JLA.appendPair(buf, value);\n+        }\n+\n+        protected void printValueFixWidth3NotNegative(StringBuilder buf, int value) {\n+            if (value >= 1000) {\n+                maxWidthError(value);\n@@ -2930,0 +3067,13 @@\n+            if (value < 100) {\n+                buf.repeat('0', value < 10 ? 2 : 1);\n+            }\n+            buf.append(value);\n+        }\n+\n+        protected void printValueFixWidth4NotNegative(StringBuilder buf, int value) {\n+            if (Math.abs(value) >= 10000) {\n+                maxWidthError(value);\n+            }\n+            JLA.appendPair(buf, value \/ 100);\n+            JLA.appendPair(buf, value % 100);\n+        }\n@@ -2931,0 +3081,1 @@\n+        protected final void printValueWidth4ExceedsPad(StringBuilder buf, int value) {\n@@ -2932,9 +3083,2 @@\n-                switch (signStyle) {\n-                    case EXCEEDS_PAD:\n-                        if (minWidth < 19 && size > minWidth) {\n-                            buf.append(decimalStyle.getPositiveSign());\n-                        }\n-                        break;\n-                    case ALWAYS:\n-                        buf.append(decimalStyle.getPositiveSign());\n-                        break;\n+                if (value > 9999) {\n+                    buf.append('+');\n@@ -2943,6 +3087,2 @@\n-                switch (signStyle) {\n-                    case NORMAL, EXCEEDS_PAD, ALWAYS -> buf.append(decimalStyle.getNegativeSign());\n-                    case NOT_NEGATIVE -> throw new DateTimeException(\"Field \" + field +\n-                                             \" cannot be printed as the value \" + value +\n-                                             \" cannot be negative according to the SignStyle\");\n-                }\n+                value = -value;\n+                buf.append('-');\n@@ -2950,0 +3090,9 @@\n+            if (value < 10000) {\n+                JLA.appendPair(buf, value \/ 100);\n+                JLA.appendPair(buf, value % 100);\n+            } else {\n+                buf.append(value);\n+            }\n+        }\n+\n+        protected final void printValue(StringBuilder buf, DecimalStyle decimalStyle, int size, long value) {\n@@ -2961,1 +3110,44 @@\n-            return true;\n+        }\n+\n+        final void printSignExceedsPad(StringBuilder buf, DecimalStyle decimalStyle, int minWidth, int size, long value) {\n+            if (value >= 0) {\n+                if (minWidth < 19 && size > minWidth) {\n+                    buf.append(decimalStyle.getPositiveSign());\n+                }\n+            } else {\n+                buf.append(decimalStyle.getNegativeSign());\n+            }\n+        }\n+\n+        final void printSignNormal(StringBuilder buf, DecimalStyle decimalStyle, long value) {\n+            if (value < 0) {\n+                buf.append(decimalStyle.getNegativeSign());\n+            }\n+        }\n+\n+        final void printSignAlways(StringBuilder buf, DecimalStyle decimalStyle, long value) {\n+            buf.append(\n+                    value >= 0 ? decimalStyle.getPositiveSign() : decimalStyle.getNegativeSign()\n+            );\n+        }\n+\n+        final void notNegative(long value) {\n+            if (value < 0) {\n+                negateFieldError(value);\n+            }\n+        }\n+\n+        final void maxWidthError(long value) {\n+            throw new DateTimeException(\"Field \" + field +\n+                    \" cannot be printed as the value \" + value +\n+                    \" exceeds the maximum print width of \" + maxWidth);\n+        }\n+\n+        final void negateFieldError(long value) {\n+            throw new DateTimeException(\"Field \" + field +\n+                    \" cannot be printed as the value \" + value +\n+                    \" cannot be negative according to the SignStyle\");\n+        }\n+\n+        static int yearOfEra(int year) {\n+            return year = (year >= 1 ? year : 1 - year);\n@@ -2987,0 +3179,25 @@\n+        public final int parseFixedWidth2NotNegative(DateTimeParseContext context, CharSequence text, int position) {\n+            int d0, d1;\n+            var decimalStyle = context.getDecimalStyle();\n+            if (((text.length() - position - 2)\n+                    | (d0 = decimalStyle.convertToDigit(text.charAt(position    )))\n+                    | (d1 = decimalStyle.convertToDigit(text.charAt(position + 1)))) < 0\n+            ) {\n+                return ~position;\n+            }\n+            return setValue(context, digit2(d0, d1), position, position + 2);\n+        }\n+\n+        protected final int parseFixedWidth3NotNegative(DateTimeParseContext context, CharSequence text, int position) {\n+            int d0, d1, d2;\n+            var decimalStyle = context.getDecimalStyle();\n+            if (((text.length() - position - 3)\n+                    | (d0 = decimalStyle.convertToDigit(text.charAt(position    )))\n+                    | (d1 = decimalStyle.convertToDigit(text.charAt(position + 1)))\n+                    | (d2 = decimalStyle.convertToDigit(text.charAt(position + 2)))) < 0\n+            ) {\n+                return ~position;\n+            }\n+            return setValue(context, digit3(d0, d1, d2), position, position + 3);\n+        }\n+\n@@ -2994,3 +3211,3 @@\n-            boolean negative = false;\n-            boolean positive = false;\n-            if (sign == context.getDecimalStyle().getPositiveSign()) {\n+            boolean negative = false, positive = false;\n+            var decimalStyle = context.getDecimalStyle();\n+            if (sign == decimalStyle.getPositiveSign()) {\n@@ -3002,1 +3219,1 @@\n-            } else if (sign == context.getDecimalStyle().getNegativeSign()) {\n+            } else if (sign == decimalStyle.getNegativeSign()) {\n@@ -3026,1 +3243,1 @@\n-                    int digit = context.getDecimalStyle().convertToDigit(ch);\n+                    int digit = decimalStyle.convertToDigit(ch);\n@@ -3089,0 +3306,94 @@\n+        \/**\n+         * A variant of the parse method that returns a combination of value and position.\n+         *\/\n+        protected long parse(CharSequence text, int position) {\n+            int length = text.length();\n+            if (position == length) {\n+                return ~position;\n+            }\n+            char sign = text.charAt(position);  \/\/ IOOBE if invalid position\n+            boolean negative = false;\n+            boolean positive = false;\n+            if (sign == '+') {\n+                positive = true;\n+                position++;\n+            } else if (sign == '-') {\n+                negative = true;\n+                position++;\n+            }\n+            int minEndPos = position + minWidth;\n+            if (minEndPos > length) {\n+                return ~position;\n+            }\n+            int total = 0;\n+            int pos = position;\n+            int maxEndPos = Math.min(pos + maxWidth, length);\n+            while (pos < maxEndPos) {\n+                char ch = text.charAt(pos++);\n+                int digit = digit(ch);\n+                if (digit < 0) {\n+                    pos--;\n+                    if (pos < minEndPos) {\n+                        return ~position;  \/\/ need at least min width digits\n+                    }\n+                    break;\n+                }\n+                total = total * 10 + digit;\n+            }\n+\n+            if (negative) {\n+                if (total == 0) {\n+                    return ~(position - 1);  \/\/ minus zero not allowed\n+                }\n+                total = -total;\n+            } else {\n+                int parseLen = pos - position;\n+                if (positive) {\n+                    if (parseLen <= minWidth) {\n+                        return ~(position - 1);  \/\/ '+' only parsed if minWidth exceeded\n+                    }\n+                } else {\n+                    if (parseLen > minWidth) {\n+                        return ~position;  \/\/ '+' must be parsed if minWidth exceeded\n+                    }\n+                }\n+            }\n+\n+            return CompositePrinterParser.valuePos(total, pos);\n+        }\n+\n+        protected final long parseFixedWidth2NotNegative(CharSequence text, int position) {\n+            int d0, d1;\n+            if (((text.length() - position - 2)\n+                    | (d0 = digit(text.charAt(position    )))\n+                    | (d1 = digit(text.charAt(position + 1)))) < 0\n+            ) {\n+                return ~position;\n+            }\n+            return CompositePrinterParser.valuePos(digit2(d0, d1), position + 2);\n+        }\n+\n+        protected final long parseFixedWidth3NotNegative(CharSequence text, int position) {\n+            int d0, d1, d2;\n+            if (((text.length() - position - 3)\n+                    | (d0 = digit(text.charAt(position    )))\n+                    | (d1 = digit(text.charAt(position + 1)))\n+                    | (d2 = digit(text.charAt(position + 2)))) < 0\n+            ) {\n+                return ~position;\n+            }\n+            return CompositePrinterParser.valuePos(digit3(d0, d1, d2), position + 3);\n+        }\n+\n+        protected int digit2(int d0, int d1) {\n+            return d0 * 10 + d1;\n+        }\n+\n+        protected int digit3(int d0, int d1, int d2) {\n+            return d0 * 100 + d1 * 10 + d2;\n+        }\n+\n+        static int digit(char ch) {\n+            return ch >= '0' && ch <= '9' ?  ch - '0' : -1;\n+        }\n+\n@@ -3369,4 +3680,6 @@\n-            Long value = context.getValue(field);\n-            if (value == null) {\n-                return false;\n-            }\n+            format(buf, context.getDecimalStyle(), context.getTemporal().get(ChronoField.NANO_OF_SECOND));\n+            return true;\n+        }\n+\n+        @Override\n+        public void format(StringBuilder buf, DecimalStyle decimalStyle, long value) {\n@@ -3374,1 +3687,5 @@\n-            DecimalStyle decimalStyle = context.getDecimalStyle();\n+            format(buf, decimalStyle, val);\n+        }\n+\n+        @Override\n+        public void format(StringBuilder buf, DecimalStyle decimalStyle, int val) {\n@@ -3414,1 +3731,22 @@\n-            return true;\n+        }\n+\n+        protected void printValueWidth1NotNegative(StringBuilder buf, int value) {\n+            buf.append(value \/ 100_000_000);\n+        }\n+\n+        protected void printValueFixedWidth2NotNegative(StringBuilder buf, int value) {\n+            JLA.appendPair(buf, value \/ 10_000_000);\n+        }\n+\n+        protected void printValueFixWidth3NotNegative(StringBuilder buf, int value) {\n+            value \/= 1000_000;\n+            if (value < 100) {\n+                buf.repeat('0', value < 10 ? 2 : 1);\n+            }\n+            buf.append(value);\n+        }\n+\n+        protected void printValueFixWidth4NotNegative(StringBuilder buf, int value) {\n+            value \/= 100_000;\n+            JLA.appendPair(buf, value \/ 100);\n+            JLA.appendPair(buf, value % 100);\n@@ -3458,0 +3796,39 @@\n+        protected final long parse(CharSequence text, int position) {\n+            int length = text.length();\n+            if (position == length) {\n+                \/\/ valid if whole field is optional, invalid if minimum width\n+                return (minWidth > 0 ? ~position : position);\n+            }\n+            int minEndPos = position + minWidth;\n+            if (minEndPos > length) {\n+                return ~position;  \/\/ need at least min width digits\n+            }\n+            int maxEndPos = Math.min(position + maxWidth, length);\n+            int total = 0;  \/\/ can use int because we are only parsing up to 9 digits\n+            int pos = position;\n+            while (pos < maxEndPos) {\n+                char ch = text.charAt(pos);\n+                int digit = digit(ch);\n+                if (digit < 0) {\n+                    if (pos < minEndPos) {\n+                        return ~position;  \/\/ need at least min width digits\n+                    }\n+                    break;\n+                }\n+                pos++;\n+                total = total * 10 + digit;\n+            }\n+            for (int i = 9 - (pos - position); i > 0; i--) {\n+                total *= 10;\n+            }\n+            return CompositePrinterParser.valuePos(total, pos);\n+        }\n+\n+        protected final int digit2(int d0, int d1, int d2) {\n+            return d0 * 100_000_000 + d1 * 10_000_000;\n+        }\n+\n+        protected final int digit3(int d0, int d1, int d2) {\n+            return d0 * 100_000_000 + d1 * 10_000_000 + d2 * 1_000_000;\n+        }\n+\n@@ -3794,0 +4171,1 @@\n+        private volatile CompositePrinterParser parser;\n@@ -3869,8 +4247,11 @@\n-            CompositePrinterParser parser = new DateTimeFormatterBuilder()\n-                    .append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T')\n-                    .appendValue(HOUR_OF_DAY, 2).appendLiteral(':')\n-                    .appendValue(MINUTE_OF_HOUR, 2).appendLiteral(':')\n-                    .appendValue(SECOND_OF_MINUTE, 2)\n-                    .appendFraction(NANO_OF_SECOND, minDigits, maxDigits, true)\n-                    .appendOffsetId()\n-                    .toFormatter().toPrinterParser(false);\n+            CompositePrinterParser parser = this.parser;\n+            if (parser == null) {\n+                this.parser = parser = new DateTimeFormatterBuilder()\n+                        .append(DateTimeFormatter.ISO_LOCAL_DATE).appendLiteral('T')\n+                        .appendValue(HOUR_OF_DAY, 2).appendLiteral(':')\n+                        .appendValue(MINUTE_OF_HOUR, 2).appendLiteral(':')\n+                        .appendValue(SECOND_OF_MINUTE, 2)\n+                        .appendFraction(NANO_OF_SECOND, minDigits, maxDigits, true)\n+                        .appendOffsetId()\n+                        .toFormatter().toPrinterParser(false);\n+            }\n@@ -4033,1 +4414,0 @@\n-                int negative = (sign == '-' ? -1 : 1);\n@@ -4058,53 +4438,1 @@\n-                switch (parseType) {\n-                    case 0: \/\/ +HH\n-                    case 11: \/\/ +H\n-                        parseHour(text, paddedHour, array);\n-                        break;\n-                    case 1: \/\/ +HHmm\n-                    case 2: \/\/ +HH:mm\n-                    case 13: \/\/ +H:mm\n-                        parseHour(text, paddedHour, array);\n-                        parseMinute(text, isColon, false, array);\n-                        break;\n-                    case 3: \/\/ +HHMM\n-                    case 4: \/\/ +HH:MM\n-                    case 15: \/\/ +H:MM\n-                        parseHour(text, paddedHour, array);\n-                        parseMinute(text, isColon, true, array);\n-                        break;\n-                    case 5: \/\/ +HHMMss\n-                    case 6: \/\/ +HH:MM:ss\n-                    case 17: \/\/ +H:MM:ss\n-                        parseHour(text, paddedHour, array);\n-                        parseMinute(text, isColon, true, array);\n-                        parseSecond(text, isColon, false, array);\n-                        break;\n-                    case 7: \/\/ +HHMMSS\n-                    case 8: \/\/ +HH:MM:SS\n-                    case 19: \/\/ +H:MM:SS\n-                        parseHour(text, paddedHour, array);\n-                        parseMinute(text, isColon, true, array);\n-                        parseSecond(text, isColon, true, array);\n-                        break;\n-                    case 9: \/\/ +HHmmss\n-                    case 10: \/\/ +HH:mm:ss\n-                    case 21: \/\/ +H:mm:ss\n-                        parseHour(text, paddedHour, array);\n-                        parseOptionalMinuteSecond(text, isColon, array);\n-                        break;\n-                    case 12: \/\/ +Hmm\n-                        parseVariableWidthDigits(text, 1, 4, array);\n-                        break;\n-                    case 14: \/\/ +HMM\n-                        parseVariableWidthDigits(text, 3, 4, array);\n-                        break;\n-                    case 16: \/\/ +HMMss\n-                        parseVariableWidthDigits(text, 3, 6, array);\n-                        break;\n-                    case 18: \/\/ +HMMSS\n-                        parseVariableWidthDigits(text, 5, 6, array);\n-                        break;\n-                    case 20: \/\/ +Hmmss\n-                        parseVariableWidthDigits(text, 1, 6, array);\n-                        break;\n-                }\n+                parse(text, parseType, paddedHour, array, isColon);\n@@ -4112,1 +4440,1 @@\n-                    if (array[1] > 23 || array[2] > 59 || array[3] > 59) {\n+                    if (array[1] > 23 | array[2] > 59 | array[3] > 59) {\n@@ -4115,1 +4443,4 @@\n-                    long offsetSecs = negative * (array[1] * 3600L + array[2] * 60L + array[3]);\n+                    long offsetSecs = array[1] * 3600L + array[2] * 60L + array[3];\n+                    if (sign == '-') {\n+                        offsetSecs = -offsetSecs;\n+                    }\n@@ -4126,0 +4457,92 @@\n+        \/**\n+         * A variant of the parse method that returns a combination of value and position.\n+         *\/\n+        final long parse(CharSequence text, int position) {\n+            int length = text.length();\n+            int noOffsetLen = noOffsetText.length();\n+            if (position == length) {\n+                return noOffsetLen == 0 ? position : ~position;\n+            }\n+\n+            \/\/ parse normal plus\/minus offset\n+            char sign = text.charAt(position);  \/\/ IOOBE if invalid position\n+            if (sign == '+' || sign == '-') {\n+                \/\/ starts\n+                int[] array = new int[4];\n+                array[0] = position + 1;\n+                \/\/ parse according to the selected pattern\n+                parse(text, type, isPaddedHour(), array, isColon());\n+                if (array[0] > 0) {\n+                    if (array[1] > 23 | array[2] > 59 | array[3] > 59) {\n+                        throw new DateTimeException(\"Value out of range: Hour[0-23], Minute[0-59], Second[0-59]\");\n+                    }\n+                    int offsetSecs = (array[1] * 3600 + array[2] * 60 + array[3]);\n+                    if (sign == '-') {\n+                        offsetSecs = -offsetSecs;\n+                    }\n+                    return CompositePrinterParser.valuePos(offsetSecs, array[0]);\n+                }\n+            }\n+            \/\/ handle special case of empty no offset text\n+            if (noOffsetLen == 0) {\n+                return position;\n+            }\n+            return ~position;\n+        }\n+\n+        private void parse(CharSequence text, int parseType, boolean paddedHour, int[] array, boolean isColon) {\n+            switch (parseType) {\n+                case 0: \/\/ +HH\n+                case 11: \/\/ +H\n+                    parseHour(text, paddedHour, array);\n+                    break;\n+                case 1: \/\/ +HHmm\n+                case 2: \/\/ +HH:mm\n+                case 13: \/\/ +H:mm\n+                    parseHour(text, paddedHour, array);\n+                    parseMinute(text, isColon, false, array);\n+                    break;\n+                case 3: \/\/ +HHMM\n+                case 4: \/\/ +HH:MM\n+                case 15: \/\/ +H:MM\n+                    parseHour(text, paddedHour, array);\n+                    parseMinute(text, isColon, true, array);\n+                    break;\n+                case 5: \/\/ +HHMMss\n+                case 6: \/\/ +HH:MM:ss\n+                case 17: \/\/ +H:MM:ss\n+                    parseHour(text, paddedHour, array);\n+                    parseMinute(text, isColon, true, array);\n+                    parseSecond(text, isColon, false, array);\n+                    break;\n+                case 7: \/\/ +HHMMSS\n+                case 8: \/\/ +HH:MM:SS\n+                case 19: \/\/ +H:MM:SS\n+                    parseHour(text, paddedHour, array);\n+                    parseMinute(text, isColon, true, array);\n+                    parseSecond(text, isColon, true, array);\n+                    break;\n+                case 9: \/\/ +HHmmss\n+                case 10: \/\/ +HH:mm:ss\n+                case 21: \/\/ +H:mm:ss\n+                    parseHour(text, paddedHour, array);\n+                    parseOptionalMinuteSecond(text, isColon, array);\n+                    break;\n+                case 12: \/\/ +Hmm\n+                    parseVariableWidthDigits(text, 1, 4, array);\n+                    break;\n+                case 14: \/\/ +HMM\n+                    parseVariableWidthDigits(text, 3, 4, array);\n+                    break;\n+                case 16: \/\/ +HMMss\n+                    parseVariableWidthDigits(text, 3, 6, array);\n+                    break;\n+                case 18: \/\/ +HMMSS\n+                    parseVariableWidthDigits(text, 5, 6, array);\n+                    break;\n+                case 20: \/\/ +Hmmss\n+                    parseVariableWidthDigits(text, 1, 6, array);\n+                    break;\n+            }\n+        }\n+\n@@ -5614,0 +6037,878 @@\n+\n+    \/**\n+     * Bytecode PrinterParserFactory.\n+     *\n+     *\/\n+    static final class PrinterParserFactory {\n+        static final ClassDesc\n+                CD_CharSequence                = ClassDesc.ofDescriptor(\"Ljava\/lang\/CharSequence;\"),\n+                CD_StringBuilder               = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringBuilder;\"),\n+                CD_TemporalField               = ClassDesc.ofDescriptor(\"Ljava\/time\/temporal\/TemporalField;\"),\n+                CD_LocalDate                   = ClassDesc.ofDescriptor(\"Ljava\/time\/LocalDate;\"),\n+                CD_LocalDateTime               = ClassDesc.ofDescriptor(\"Ljava\/time\/LocalDateTime;\"),\n+                CD_ZoneOffset                  = ClassDesc.ofDescriptor(\"Ljava\/time\/ZoneOffset;\"),\n+                CD_OffsetTime                  = ClassDesc.ofDescriptor(\"Ljava\/time\/OffsetTime;\"),\n+                CD_OffsetDateTime              = ClassDesc.ofDescriptor(\"Ljava\/time\/OffsetDateTime;\"),\n+                CD_LocalTime                   = ClassDesc.ofDescriptor(\"Ljava\/time\/LocalTime;\"),\n+                CD_CharLiteralPrinterParser    = ClassDesc.ofDescriptor(\"Ljava\/time\/format\/DateTimeFormatterBuilder$CharLiteralPrinterParser;\"),\n+                CD_ChronoField                 = ClassDesc.ofDescriptor(\"Ljava\/time\/temporal\/ChronoField;\"),\n+                CD_CompositePrinterParser      = ClassDesc.ofDescriptor(\"Ljava\/time\/format\/DateTimeFormatterBuilder$CompositePrinterParser;\"),\n+                CD_DateTimeFormatter           = ClassDesc.ofDescriptor(\"Ljava\/time\/format\/DateTimeFormatter;\"),\n+                CD_DateTimeParseContext        = ClassDesc.ofDescriptor(\"Ljava\/time\/format\/DateTimeParseContext;\"),\n+                CD_DateTimePrintContext        = ClassDesc.ofDescriptor(\"Ljava\/time\/format\/DateTimePrintContext;\"),\n+                CD_DateTimePrinterParser       = ClassDesc.ofDescriptor(\"Ljava\/time\/format\/DateTimeFormatterBuilder$DateTimePrinterParser;\"),\n+                CD_DateTimePrinterParser_array = ClassDesc.ofDescriptor(\"[Ljava\/time\/format\/DateTimeFormatterBuilder$DateTimePrinterParser;\"),\n+                CD_DecimalStyle                = ClassDesc.ofDescriptor(\"Ljava\/time\/format\/DecimalStyle;\"),\n+                CD_NanosPrinterParser          = ClassDesc.ofDescriptor(\"Ljava\/time\/format\/DateTimeFormatterBuilder$NanosPrinterParser;\"),\n+                CD_NumberPrinterParser         = ClassDesc.ofDescriptor(\"Ljava\/time\/format\/DateTimeFormatterBuilder$NumberPrinterParser;\"),\n+                CD_OffsetIdPrinterParser       = ClassDesc.ofDescriptor(\"Ljava\/time\/format\/DateTimeFormatterBuilder$OffsetIdPrinterParser;\"),\n+                CD_TemporalAccessor            = ClassDesc.ofDescriptor(\"Ljava\/time\/temporal\/TemporalAccessor;\"),\n+                CD_TemporalQuery               = ClassDesc.ofDescriptor(\"Ljava\/time\/temporal\/TemporalQuery;\"),\n+                CD_TemporalAccessorWrapper     = ClassDesc.ofDescriptor(\"Ljava\/time\/format\/DateTimeFormatterBuilder$PrinterParserFactory$TemporalAccessorWrapper;\");\n+        static final MethodTypeDesc\n+                MTD_StringBuilder_char         = MethodTypeDesc.of(CD_StringBuilder, CD_char),\n+                MTD_void_int                   = MethodTypeDesc.of(CD_void, CD_int),\n+                MTD_boolean                    = MethodTypeDesc.of(CD_boolean),\n+                MTD_char                       = MethodTypeDesc.of(CD_char),\n+                MTD_int                        = MethodTypeDesc.of(CD_int),\n+                MTD_int_int                    = MethodTypeDesc.of(CD_int, CD_int),\n+                MTD_int_long                   = MethodTypeDesc.of(CD_int, CD_long),\n+                MTD_long                       = MethodTypeDesc.of(CD_long),\n+                MTD_DecimalStyle               = MethodTypeDesc.of(CD_DecimalStyle),\n+                MTD_int_TemporalField          = MethodTypeDesc.of(CD_int, CD_TemporalField),\n+                MTD_Long_TemporalField         = MethodTypeDesc.of(CD_Long, CD_TemporalField),\n+                MTD_long_TemporalField         = MethodTypeDesc.of(CD_long, CD_TemporalField),\n+                MTD_boolean_TemporalField      = MethodTypeDesc.of(CD_boolean, CD_TemporalField),\n+                MTD_TemporalAccessor           = MethodTypeDesc.of(CD_TemporalAccessor),\n+                MTD_OBJECT_TemporalAccessor    = MethodTypeDesc.of(CD_Object, CD_TemporalAccessor),\n+                MTD_long_CharSequence_int      = MethodTypeDesc.of(CD_long, CD_CharSequence, CD_int),\n+                MTD_int_CharSequence_long      = MethodTypeDesc.of(CD_int, CD_CharSequence, CD_long),\n+                MTD_int_CharSequence_int_char  = MethodTypeDesc.of(CD_int, CD_CharSequence, CD_int, CD_char),\n+                MTD_constructor                = MethodTypeDesc.of(CD_void, CD_DateTimePrinterParser_array, CD_boolean),\n+                MTD_format                     = MethodTypeDesc.of(CD_boolean, CD_DateTimePrintContext, CD_StringBuilder),\n+                MTD_formatValue_int            = MethodTypeDesc.of(CD_void, CD_StringBuilder, CD_int),\n+                MTD_formatValue_long           = MethodTypeDesc.of(CD_void, CD_StringBuilder, CD_long),\n+                MTD_parse                      = MethodTypeDesc.of(CD_Object, CD_CharSequence, CD_DateTimeFormatter, CD_TemporalQuery),\n+                MTD_parseValue                 = MethodTypeDesc.of(CD_int, CD_DateTimeParseContext, CD_CharSequence, CD_int),\n+                MTD_LocalDateTime_Of           = MethodTypeDesc.of(CD_LocalDateTime, CD_int, CD_int, CD_int, CD_int, CD_int, CD_int, CD_int),\n+                MTD_OffsetDateTime_Of          = MethodTypeDesc.of(CD_OffsetDateTime, CD_int, CD_int, CD_int, CD_int, CD_int, CD_int, CD_int, CD_ZoneOffset),\n+                MTD_ZoneOffset_ofTotalSeconds  = MethodTypeDesc.of(CD_ZoneOffset, CD_int),\n+                MTD_LocalDate_Of               = MethodTypeDesc.of(CD_LocalDate, CD_int, CD_int, CD_int),\n+                MTD_LocalTime_Of               = MethodTypeDesc.of(CD_LocalTime, CD_int, CD_int, CD_int, CD_int),\n+                MTD_OffsetTime_Of              = MethodTypeDesc.of(CD_OffsetTime, CD_int, CD_int, CD_int, CD_int, CD_ZoneOffset),\n+                MTD_TemporalAccessorWrapper_Of = MethodTypeDesc.of(CD_TemporalAccessorWrapper, CD_TemporalAccessor);\n+\n+        PrinterParserFactory() {\n+            \/\/ no instantiation\n+        }\n+\n+        static CompositePrinterParser generate(DateTimePrinterParser[] printerParsers, boolean optional) {\n+            var className = \"java.time.format.DateTimeFormatterBuilder$$PrinterParser\";\n+            var classDesc = ConstantUtils.binaryNameToDesc(className);\n+\n+            byte[] classBytes = ClassFile.of().build(classDesc,\n+                    new Consumer<ClassBuilder>() {\n+                        @Override\n+                        public void accept(ClassBuilder clb) {\n+                            clb.withFlags(ACC_FINAL | ACC_SUPER | ACC_SYNTHETIC)\n+                               .withSuperclass(CD_CompositePrinterParser)\n+                               .withMethodBody(\"format\",\n+                                       MTD_format,\n+                                       ACC_PUBLIC | ACC_FINAL,\n+                                       generateFormat(classDesc, printerParsers, optional))\n+                               .withMethodBody(\"parse0\",\n+                                       MTD_parseValue,\n+                                       ACC_FINAL | ACC_PROTECTED,\n+                                       generateParse0(classDesc, printerParsers))\n+                               .withMethodBody(INIT_NAME,\n+                                       MTD_constructor,\n+                                       ACC_PUBLIC,\n+                                       generateConstructor(classDesc, printerParsers));\n+\n+                            for (int i = 0; i < printerParsers.length; ++i) {\n+                                clb.withField(\"printerParser\" + i, paramType(printerParsers[i]), ACC_FINAL | ACC_PRIVATE);\n+                            }\n+\n+                            Set<ChronoField> fields = new HashSet<>();\n+                            boolean allOfLiteralOrNumber = true;\n+                            int offsetPrinterParserCount = 0;\n+                            for (var pp : printerParsers) {\n+                                if (pp instanceof CharLiteralPrinterParser) {\n+                                    continue;\n+                                }\n+                                if (pp instanceof OffsetIdPrinterParser) {\n+                                    offsetPrinterParserCount++;\n+                                    continue;\n+                                }\n+                                if (pp instanceof NumberPrinterParser npp && npp.field instanceof ChronoField chronoField) {\n+                                    fields.add(chronoField);\n+                                    continue;\n+                                }\n+                                allOfLiteralOrNumber = false;\n+                                break;\n+                            }\n+\n+                            if (allOfLiteralOrNumber && offsetPrinterParserCount <= 1) {\n+                                boolean localDateTime = false, localDate = false, localTime = false;\n+                                if (fields.size() == 7) {\n+                                    localDateTime = containsLocalDate(fields) && containsLocalTime(fields, true);\n+                                } else if (fields.size() == 6) {\n+                                    localDateTime = containsLocalDate(fields) && containsLocalTime(fields, false);\n+                                } else if (fields.size() == 4) {\n+                                    localTime = containsLocalTime(fields, true);\n+                                } else if (fields.size() == 3) {\n+                                    localDate = containsLocalDate(fields);\n+                                    localTime = containsLocalTime(fields, false);\n+                                }\n+\n+                                if (localDateTime || localDate || localTime) {\n+                                    clb.withMethodBody(\"parse\",\n+                                            MTD_parse,\n+                                            ACC_PUBLIC | ACC_FINAL,\n+                                            generateParseDirect(\n+                                                    classDesc,\n+                                                    printerParsers,\n+                                                    fields,\n+                                                    offsetPrinterParserCount == 1));\n+                                }\n+                            }\n+                        }});\n+            try {\n+                var lookup      = MethodHandles.lookup();\n+                var lookupClass = lookup.lookupClass();\n+                var loader      = lookupClass.getClassLoader();\n+                var pd          = (loader != null) ? JLA.protectionDomain(lookupClass) : null;\n+                int classFlags  = ACC_FINAL | ACC_PRIVATE | ACC_STATIC;\n+                var hiddenClass = JLA.defineClass(loader, lookupClass, className, classBytes, pd, true, classFlags, null);\n+                var constructor = hiddenClass.getConstructor(DateTimePrinterParser[].class, boolean.class);\n+                return (CompositePrinterParser) constructor.newInstance(printerParsers, optional);\n+            } catch (Exception e) {\n+                throw new DateTimeException(\"Exception while spinning the class\", e);\n+            }\n+        }\n+\n+        static boolean containsLocalDate(Set<ChronoField> fields) {\n+            return (fields.contains(ChronoField.YEAR) || fields.contains(ChronoField.YEAR_OF_ERA))\n+                 && fields.contains(ChronoField.MONTH_OF_YEAR)\n+                 && fields.contains(ChronoField.DAY_OF_MONTH);\n+        }\n+\n+        static boolean containsLocalTime(Set<ChronoField> fields, boolean withNano) {\n+            return fields.contains(ChronoField.HOUR_OF_DAY)\n+                && fields.contains(ChronoField.MINUTE_OF_HOUR)\n+                && fields.contains(ChronoField.SECOND_OF_MINUTE)\n+                && (!withNano || fields.contains(ChronoField.NANO_OF_SECOND));\n+        }\n+\n+        static Consumer<CodeBuilder> generateConstructor(ClassDesc classDesc, DateTimePrinterParser[] printerParsers) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    int thisSlot     = cb.receiverSlot(),\n+                        parsersSlot  = cb.parameterSlot(0),\n+                        optionalSlot = cb.parameterSlot(1);\n+                    \/*\n+                     * super(printerParsers, optional)\n+                     *\/\n+                    cb.aload(thisSlot)\n+                      .aload(parsersSlot)\n+                      .iload(optionalSlot)\n+                      .invokespecial(CD_CompositePrinterParser, INIT_NAME, MTD_constructor);\n+\n+                    \/*\n+                     * this.printerParser0 = printerParsers[0];\n+                     * this.printerParser1 = printerParsers[1];\n+                     * ...\n+                     *\/\n+                    for (int i = 0; i < printerParsers.length; ++i) {\n+                        var paramDesc = paramType(printerParsers[i]);\n+                        cb.aload(thisSlot)\n+                          .aload(parsersSlot)\n+                          .loadConstant(i)\n+                          .arrayLoad(TypeKind.REFERENCE)\n+                          .checkcast(paramDesc)\n+                          .putfield(classDesc, \"printerParser\" + i, paramDesc);\n+                    }\n+                    cb.return_();\n+                }\n+            };\n+        }\n+\n+        static ClassDesc paramType(DateTimePrinterParser pp) {\n+            if (pp instanceof NanosPrinterParser) {\n+                return CD_NanosPrinterParser;\n+            } else if (pp instanceof NumberPrinterParser) {\n+                return CD_NumberPrinterParser;\n+            } else if (pp instanceof CharLiteralPrinterParser) {\n+                return CD_CharLiteralPrinterParser;\n+            } else if (pp instanceof CompositePrinterParser) {\n+                return CD_CompositePrinterParser;\n+            } else {\n+                return CD_DateTimePrinterParser;\n+            }\n+        }\n+\n+        \/**\n+         * Generate format method\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         *  public final boolean format(DateTimePrintContext context, StringBuilder buf) {\n+         *      if (context.getDecimalStyle() != DecimalStyle.STANDARD) {\n+         *          return super.parse(text, formatter, query);\n+         *      }\n+         *\n+         *      if (optional) {\n+         *          context.startOptional();\n+         *      }\n+         *\n+         *      TemporalAccessor temporal = context.temporal;\n+         *      int length = buf.length();\n+         *\n+         *      if (printerParser0.format(context, buf) == false) {\n+         *          buf.setLength(length);\n+         *          return true;\n+         *      }\n+         *\n+         *      if (printerParser1.format(context, buf) == false) {\n+         *          buf.setLength(length);\n+         *          return true;\n+         *      }\n+         *\n+         *      if (printerParserN.format(context, buf) == false) {\n+         *          buf.setLength(length);\n+         *          return true;\n+         *      }\n+         *\n+         *      if (optional) {\n+         *          context.endOptional();\n+         *      }\n+         *\n+         *      return true;\n+         *  }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        static Consumer<CodeBuilder> generateFormat(ClassDesc classDesc, DateTimePrinterParser[] printerParsers, boolean optional) {\n+            return new Consumer<CodeBuilder>() {\n+                int thisSlot,\n+                    contextSlot,\n+                    bufSlot,\n+                    lengthSlot,\n+                    temporalSlot,\n+                    wrapperSlot;\n+\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    thisSlot     = cb.receiverSlot();\n+                    contextSlot  = cb.parameterSlot(0);\n+                    bufSlot      = cb.parameterSlot(1);\n+                    lengthSlot   = cb.allocateLocal(TypeKind.INT);\n+                    temporalSlot = cb.allocateLocal(TypeKind.REFERENCE);\n+                    wrapperSlot  = cb.allocateLocal(TypeKind.REFERENCE);\n+\n+                    \/*\n+                     *  if (context.getDecimalStyle() != DecimalStyle.STANDARD) {\n+                     *      return super.parse(text, formatter, query);\n+                     *  }\n+                     *\/\n+                    var L0 = cb.newLabel();\n+                    cb.aload(contextSlot)\n+                      .invokevirtual(CD_DateTimePrintContext, \"getDecimalStyle\", MTD_DecimalStyle)\n+                      .getstatic(CD_DecimalStyle, \"STANDARD\", CD_DecimalStyle)\n+                      .if_acmpeq(L0)\n+                      .aload(thisSlot)\n+                      .aload(contextSlot)\n+                      .aload(bufSlot)\n+                      .invokespecial(CD_CompositePrinterParser, \"format\", MTD_format)\n+                      .ireturn()\n+                      .labelBinding(L0);\n+\n+                    if (optional) {\n+                        \/*\n+                         * context.startOptional();\n+                         *\/\n+                        cb.aload(contextSlot)\n+                          .invokevirtual(CD_DateTimePrintContext, \"startOptional\", MTD_void);\n+                    }\n+\n+                    \/*\n+                     * TemporalAccessor temporal = context.temporal;\n+                     *\/\n+                    cb.aload(contextSlot)\n+                      .invokevirtual(CD_DateTimePrintContext, \"getTemporal\", MTD_TemporalAccessor)\n+                      .astore(temporalSlot);\n+\n+                    \/*\n+                     * TemporalAccessorWrapper wrapper = TemporalAccessorWrapper.wrapper(temporal);\n+                     *\/\n+                    cb.aload(temporalSlot)\n+                      .invokestatic(CD_TemporalAccessorWrapper, \"wrapper\", MTD_TemporalAccessorWrapper_Of)\n+                      .astore(wrapperSlot);\n+\n+                    \/*\n+                     * int length = buf.length();\n+                     *\/\n+                    cb.aload(bufSlot)\n+                      .invokevirtual(CD_StringBuilder, \"length\", MTD_int)\n+                      .istore(lengthSlot);\n+\n+                    var LReturn = cb.newLabel();\n+                    for (int i = 0; i < printerParsers.length; ++i) {\n+                        var pp = printerParsers[i];\n+\n+                        if (pp instanceof CharLiteralPrinterParser literal) {\n+                            appendLiteral(cb, literal);\n+                            continue;\n+                        }\n+\n+                        if (pp instanceof NumberPrinterParser npp) {\n+                            appendNumber(cb, npp, i, LReturn);\n+                            continue;\n+                        }\n+\n+                        \/*\n+                         * if (printerParserN.format(context, buf) == false) {\n+                         *     buf.setLength(length);\n+                         *     return true;\n+                         * }\n+                         *\/\n+                        var paramType = paramType(pp);\n+                        boolean isInterface = paramType == CD_DateTimePrinterParser;\n+                        var invokeType = isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL;\n+                        var L1 = cb.newLabel();\n+                        cb.aload(thisSlot)\n+                          .getfield(classDesc, \"printerParser\" + i, paramType(pp))\n+                          .aload(contextSlot)\n+                          .aload(bufSlot)\n+                          .invoke(invokeType, paramType, \"format\", MTD_format, isInterface)\n+                          .ifne(L1)\n+                          .aload(bufSlot)\n+                          .iload(lengthSlot)\n+                          .invokevirtual(CD_StringBuilder, \"setLength\", MTD_void_int)\n+                          .goto_(LReturn)\n+                          .labelBinding(L1);\n+                    }\n+\n+                    cb.labelBinding(LReturn);\n+                    if (optional) {\n+                        \/*\n+                         * context.endOptional();\n+                         *\/\n+                        cb.aload(contextSlot)\n+                          .invokevirtual(CD_DateTimePrintContext, \"endOptional\", MTD_void);\n+                    }\n+\n+                    \/*\n+                     * return true;\n+                     *\/\n+                    cb.iconst_1()\n+                      .ireturn();\n+                }\n+\n+                \/**\n+                 * Generate format method\n+                 *\n+                 * The following is an example of the generated target code:\n+                 *\n+                 * <blockquote><pre>\n+                 *  if (context.isSupported(field)) {\n+                 *      goto LReturn;\n+                 *  }\n+                 *\n+                 *  switch (field instanceof ChronoField chronoField) {\n+                 *      case YEAR             -> printValueFixWidth4NotNegative(buf, temporal.getYear());\n+                 *      case YEAR_OF_ERA      -> printValueFixWidth4NotNegative(buf, yearOfEra(temporal.getYear()));\n+                 *      case MONTH_OF_YEAR    -> printValueFixedWidth2NotNegative(buf, temporal.getMonthValue());\n+                 *      case DAY_OF_YEAR      -> printValueFixWidth3NotNegative(buf, temporal.getDayOfYear());\n+                 *      case DAY_OF_MONTH     -> printValueFixedWidth2NotNegative(buf, temporal.getDayOfMonth());\n+                 *      case HOUR_OF_DAY      -> printValueFixedWidth2NotNegative(buf, temporal.getHourOfDay());\n+                 *      case MINUTE_OF_HOUR   -> printValueFixedWidth2NotNegative(buf, temporal.getMinuteOfHour());\n+                 *      case SECOND_OF_MINUTE -> printValueFixedWidth2NotNegative(buf, decimalStyle, temporal.getSecondOfMinute());\n+                 *      case NANO_OF_SECOND   -> printValueFixWidth3NotNegative(buf, temporal.getNanoOfSecond());\n+                 *      default               -> printerParserN.format(buf, temporal.getLong(field));\n+                 *  };\n+                 *\n+                 * <\/pre><\/blockquote>\n+                 *\/\n+                void appendNumber(CodeBuilder cb, NumberPrinterParser pp, int index, Label LReturn) {\n+                    \/*\n+                     * if (context.isSupported(field)) {\n+                     *     break;\n+                     * }\n+                     *\/\n+                    cb.aload(contextSlot);\n+                    getfield(cb, pp, index);\n+                    cb.invokevirtual(CD_DateTimePrintContext, \"isSupported\", MTD_boolean_TemporalField)\n+                      .ifeq(LReturn);\n+\n+                    \/*\n+                     * printerParserN.format(buf, decimalStyle, temporal.getLong(field));\n+                     *\/\n+                    cb.aload(thisSlot)\n+                      .getfield(classDesc, \"printerParser\" + index, paramType(pp))\n+                      .aload(bufSlot)\n+                      .aload(wrapperSlot);\n+                    if (pp.field instanceof ChronoField chronoField) {\n+                        String methodName = switch (chronoField) {\n+                            case YEAR,YEAR_OF_ERA -> \"getYear\";\n+                            case MONTH_OF_YEAR    -> \"getMonthValue\";\n+                            case DAY_OF_YEAR      -> \"getDayOfYear\";\n+                            case DAY_OF_MONTH     -> \"getDayOfMonth\";\n+                            case HOUR_OF_DAY      -> \"getHour\";\n+                            case MINUTE_OF_HOUR   -> \"getMinute\";\n+                            case SECOND_OF_MINUTE -> \"getSecond\";\n+                            case NANO_OF_SECOND   -> \"getNano\";\n+                            default               -> null;\n+                        };\n+                        if (methodName != null) {\n+                            cb.invokevirtual(CD_TemporalAccessorWrapper, methodName, MTD_int);\n+                            if (chronoField == ChronoField.YEAR_OF_ERA) {\n+                                \/\/ year = yearOfEra(year)\n+                                cb.invokestatic(CD_NumberPrinterParser, \"yearOfEra\", MTD_int_int);\n+                            }\n+                            cb.invokevirtual(CD_NumberPrinterParser, formatMethod(pp), MTD_formatValue_int);\n+                            return;\n+                        }\n+                    }\n+\n+                    getfield(cb, pp, index);\n+                    cb.invokevirtual(CD_TemporalAccessorWrapper, \"getLong\", MTD_long_TemporalField)\n+                      .invokevirtual(CD_NumberPrinterParser, \"format\", MTD_formatValue_long);\n+                }\n+\n+                static String formatMethod(NumberPrinterParser pp) {\n+                    var range = pp.field.range();\n+                    long minimum = range.getMinimum(),\n+                         maximum = range.getMaximum();\n+                    int maximumSize = DecimalDigits.stringSize(maximum),\n+                        minimumSize = DecimalDigits.stringSize(Math.abs(minimum));\n+\n+                    String method = \"format\";\n+                    if (pp.signStyle == SignStyle.NOT_NEGATIVE) {\n+                        if (pp.minWidth == 1 && pp.maxWidth == 1 && minimum >= 0 && maximumSize == 1) {\n+                            method = \"printValueWidth1NotNegative\";\n+                        } else if (pp.maxWidth == 2 && minimum >= 0) {\n+                            if (pp.minWidth == 1) {\n+                                method = \"printValueWidth2NotNegative\";\n+                            } else if (pp.minWidth == 2) {\n+                                method = \"printValueFixedWidth2NotNegative\";\n+                            }\n+                        } else if (pp.minWidth == 3 && pp.maxWidth == 3) {\n+                            if (minimum >= 0 && maximumSize <= 3) {\n+                                method = \"printValueFixWidth3NotNegative\";\n+                            }\n+                        } else if (pp.minWidth == 4 && pp.maxWidth == 4) {\n+                            method = \"printValueFixWidth4NotNegative\";\n+                        }\n+                    } else if (pp.signStyle == SignStyle.EXCEEDS_PAD && pp.minWidth == 4\n+                            && maximum <= 1_000_000_000 && minimum >= -1_000_000_000\n+                            && minimumSize <= pp.maxWidth && maximumSize <= pp.maxWidth\n+                    ) {\n+                        method = \"printValueWidth4ExceedsPad\";\n+                    }\n+                    return method;\n+                }\n+\n+                void getfield(CodeBuilder cb, NumberPrinterParser pp, int index) {\n+                    if (pp.field instanceof ChronoField chronoField) {\n+                        cb.getstatic(CD_ChronoField, chronoField.name(), CD_ChronoField);\n+                    } else {\n+                        cb.aload(thisSlot)\n+                          .getfield(classDesc, \"printerParser\" + index, paramType(pp))\n+                          .getfield(CD_NumberPrinterParser, \"field\", CD_TemporalField);\n+                    }\n+                }\n+\n+                void appendLiteral(CodeBuilder cb, CharLiteralPrinterParser parser) {\n+                    \/*\n+                     * buf.append(literal);\n+                     *\/\n+                    cb.aload(bufSlot)\n+                      .loadConstant((int) parser.literal)\n+                      .invokevirtual(CD_StringBuilder, \"append\", MTD_StringBuilder_char)\n+                      .pop();\n+                }\n+            };\n+        }\n+\n+        \/**\n+         * Generate parse0 method\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         *  protected final boolean format(DateTimePrintContext context, StringBuilder buf) {\n+         *      int pos = positioin;\n+         *\n+         *      pos = this.printerParser0.parse(context, text, pos);\n+         *      if (pos < 0) goto LReturn;\n+         *\n+         *      pos = this.printerParser1.parse(context, text, pos);\n+         *      if (pos < 0) goto LReturn;\n+         *       ...\n+         *\n+         *      LReturn:\n+         *      return this.printerParserN.parse(context, text, pos);\n+         *  }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        static Consumer<CodeBuilder> generateParse0(ClassDesc classDesc, DateTimePrinterParser[] printerParsers) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    int thisSlot     = cb.receiverSlot(),\n+                        contextSlot  = cb.parameterSlot(0),\n+                        textSlot     = cb.parameterSlot(1),\n+                        positionSlot = cb.parameterSlot(2),\n+                        posSlot      = cb.allocateLocal(TypeKind.INT);\n+\n+                    var LReturn = cb.newLabel();\n+\n+                    \/*\n+                     * int pos = positioin;\n+                     *\/\n+                    cb.iload(positionSlot)\n+                      .istore(posSlot);\n+\n+                    \/*\n+                     * pos = this.printerParser0.parse(context, text, pos);\n+                     * if (pos < 0) goto LReturn;\n+                     * pos = this.printerParser1.parse(context, text, pos);\n+                     * if (pos < 0) goto LReturn;\n+                     *  ...\n+                     * return this.printerParserN.parse(context, text, pos);\n+                     *\/\n+                    for (int i = 0; i < printerParsers.length; ++i) {\n+                        var pp = printerParsers[i];\n+                        var paramType = paramType(pp);\n+                        boolean isInterface = paramType == CD_DateTimePrinterParser;\n+                        Opcode invokeType = isInterface ? Opcode.INVOKEINTERFACE : Opcode.INVOKEVIRTUAL;\n+                        cb.aload(thisSlot)\n+                          .getfield(classDesc, \"printerParser\" + i, paramType)\n+                          .aload(contextSlot)\n+                          .aload(textSlot)\n+                          .iload(posSlot)\n+                          .invoke(invokeType, paramType, parseMethod(pp), MTD_parseValue, isInterface);\n+                        if (i != printerParsers.length - 1) {\n+                            cb.dup()\n+                              .istore(posSlot)\n+                              .iflt(LReturn);\n+                        } else {\n+                            cb.ireturn();\n+                        }\n+                    }\n+\n+                    \/*\n+                     * return pos;\n+                     *\/\n+                    cb.labelBinding(LReturn)\n+                      .iload(posSlot)\n+                      .ireturn();\n+                }\n+            };\n+        }\n+\n+        \/**\n+         * Generate parse method, Optimizes parsing performance by leveraging built-in temporal queries\n+         *  (LocalDate\/LocalDateTime\/LocalTime\/OffsetDateTime\/OffsetTime), eliminating the overhead\n+         *  of constructing new DateTimeParseContext instances.\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         *  public final <T> T parse(CharSequence text, DateTimeFormatter formatter, TemporalQuery<T> query) {\n+         *      if (formatter.getDecimalStyle() != DecimalStyle.STANDARD) {\n+         *          return super.parse(text, formatter, query);\n+         *      }\n+         *\n+         *      long valuePos = printerParserYear.parse(text, 0);\n+         *      int pos = position(text, valuePos);\n+         *      int year = value(valuePos);\n+         *\n+         *      pos = litteral(text, pos, literal);\n+         *\n+         *      valuePos = printerParserMonth.parse(text, pos);\n+         *      pos = position(text, valuePos);\n+         *      int month = value(valuePos);\n+         *\n+         *      pos = litteral(text, pos, literal);\n+         *\n+         *      valuePos = printerParserDayOfMonth.parse(text, pos);\n+         *      pos = position(text, valuePos);\n+         *      int dayOfMonth = value(valuePos);\n+         *\n+         *      return query.queryFrom(\n+         *              LocalDateTime.of(year, month, dayOfMonth));\n+         *  }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        static Consumer<CodeBuilder> generateParseDirect(\n+                ClassDesc classDesc,\n+                DateTimePrinterParser[] printerParsers,\n+                Set<ChronoField> fields,\n+                boolean includeOffset\n+        ) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    int thisSlot      = cb.receiverSlot(),\n+                        textSlot      = cb.parameterSlot(0),\n+                        formatterSlot = cb.parameterSlot(1),\n+                        querySlot     = cb.parameterSlot(2);\n+\n+                    int valuePosSlot  = cb.allocateLocal(TypeKind.LONG),\n+                        posSlot       = cb.allocateLocal(TypeKind.INT);\n+\n+                    int yearSlot          = -1,\n+                        monthSlot         = -1,\n+                        dayOfMonthSlot    = -1,\n+                        hourSlot          = -1,\n+                        minuteSlot        = -1,\n+                        secondSlot        = -1,\n+                        nanoSlot          = -1,\n+                        offsetSecondsSlot = -1;\n+\n+                    for (var field : fields) {\n+                        int slot = cb.allocateLocal(TypeKind.INT);\n+                        switch (field) {\n+                            case YEAR,YEAR_OF_ERA -> yearSlot          = slot;\n+                            case MONTH_OF_YEAR    -> monthSlot         = slot;\n+                            case DAY_OF_MONTH     -> dayOfMonthSlot    = slot;\n+                            case HOUR_OF_DAY      -> hourSlot          = slot;\n+                            case MINUTE_OF_HOUR   -> minuteSlot        = slot;\n+                            case SECOND_OF_MINUTE -> secondSlot        = slot;\n+                            case NANO_OF_SECOND   -> nanoSlot          = slot;\n+                            default               -> throw new AssertionError();\n+                        }\n+                    }\n+                    if (includeOffset) {\n+                        offsetSecondsSlot = cb.allocateLocal(TypeKind.INT);\n+                    }\n+\n+                    \/*\n+                     *  if (formatter.getDecimalStyle() != DecimalStyle.STANDARD) {\n+                     *      return super.parse(text, formatter, query);\n+                     *  }\n+                     *\/\n+                    var L0 = cb.newLabel();\n+                    cb.aload(formatterSlot)\n+                      .invokevirtual(CD_DateTimeFormatter, \"getDecimalStyle\", MTD_DecimalStyle)\n+                      .getstatic(CD_DecimalStyle, \"STANDARD\", CD_DecimalStyle)\n+                      .if_acmpeq(L0)\n+                      .aload(thisSlot)\n+                      .aload(textSlot)\n+                      .aload(formatterSlot)\n+                      .aload(querySlot)\n+                      .invokespecial(CD_CompositePrinterParser, \"parse\", MTD_parse)\n+                      .areturn()\n+                      .labelBinding(L0);\n+\n+                    \/*\n+                     * int pos = 0;\n+                     *\/\n+                    cb.iconst_0()\n+                      .istore(posSlot);\n+                    for (int i = 0; i < printerParsers.length; i++) {\n+                        var pp = printerParsers[i];\n+                        var paramType = paramType(pp);\n+                        if (pp instanceof OffsetIdPrinterParser opp) {\n+                            \/*\n+                             * valuePos = offsetPrinterParserN.parse(text, pos)\n+                             *\/\n+                            cb.aload(thisSlot)\n+                              .getfield(classDesc, \"printerParser\" + i, paramType)\n+                              .aload(textSlot)\n+                              .iload(posSlot)\n+                              .invokevirtual(CD_OffsetIdPrinterParser, \"parse\", MTD_long_CharSequence_int)\n+                              .lstore(valuePosSlot);\n+\n+                            posValue(cb, textSlot, valuePosSlot, posSlot, offsetSecondsSlot);\n+                        } else if (pp instanceof NumberPrinterParser npp) {\n+                            \/*\n+                             * valuePos = printerParserN.parse(text, pos)\n+                             *\/\n+                            cb.aload(thisSlot)\n+                              .getfield(classDesc, \"printerParser\" + i, paramType)\n+                              .aload(textSlot)\n+                              .iload(posSlot)\n+                              .invokevirtual(CD_NumberPrinterParser, parseMethod(pp), MTD_long_CharSequence_int)\n+                              .lstore(valuePosSlot);\n+\n+                            int slot = switch ((ChronoField) npp.field) {\n+                                case YEAR,YEAR_OF_ERA -> yearSlot;\n+                                case MONTH_OF_YEAR    -> monthSlot;\n+                                case DAY_OF_MONTH     -> dayOfMonthSlot;\n+                                case HOUR_OF_DAY      -> hourSlot;\n+                                case MINUTE_OF_HOUR   -> minuteSlot;\n+                                case SECOND_OF_MINUTE -> secondSlot;\n+                                case NANO_OF_SECOND   -> nanoSlot;\n+                                default               -> throw new AssertionError();\n+                            };\n+                            posValue(cb, textSlot, valuePosSlot, posSlot, slot);\n+                        } else if (pp instanceof CharLiteralPrinterParser cpp) {\n+                            \/*\n+                             * pos = litteral(text, pos, literal1);\n+                             *\/\n+                            cb.aload(textSlot)\n+                              .iload(posSlot)\n+                              .ldc((int) cpp.literal)\n+                              .invokestatic(CD_CompositePrinterParser, \"litteral\", MTD_int_CharSequence_int_char)\n+                              .istore(posSlot);\n+                        } else {\n+                            throw new AssertionError();\n+                        }\n+                    }\n+\n+                    \/*\n+                     *  return query.queryFrom(\n+                     *          LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nano));\n+                     *\/\n+                    cb.aload(querySlot);\n+\n+                    boolean containsLocalDate            = containsLocalDate(fields),\n+                            containsLocalTimeWithoutNano = containsLocalTime(fields, false),\n+                            containsLocalTimeWithNano    = containsLocalTime(fields, true);\n+                    if (containsLocalDate && (containsLocalTimeWithNano || containsLocalTimeWithoutNano)) {\n+                        \/*\n+                         * LocalDateTime.of(year, month, dayOfMonth, hour, minute, second, nano));\n+                         *\/\n+                        cb.iload(yearSlot)\n+                          .iload(monthSlot)\n+                          .iload(dayOfMonthSlot)\n+                          .iload(hourSlot)\n+                          .iload(minuteSlot)\n+                          .iload(secondSlot);\n+\n+                        if (containsLocalTimeWithNano) {\n+                            cb.iload(nanoSlot);\n+                        } else {\n+                            cb.iconst_0();\n+                        }\n+                        if (includeOffset) {\n+                            cb.iload(offsetSecondsSlot)\n+                              .invokestatic(CD_ZoneOffset, \"ofTotalSeconds\", MTD_ZoneOffset_ofTotalSeconds)\n+                              .invokestatic(CD_OffsetDateTime, \"of\", MTD_OffsetDateTime_Of);\n+                        } else {\n+                            cb.invokestatic(CD_LocalDateTime, \"of\", MTD_LocalDateTime_Of);\n+                        }\n+                    } else if (containsLocalDate) {\n+                        \/*\n+                         * LocalDate.of(year, month, dayOfMonth));\n+                         *\/\n+                        cb.iload(yearSlot)\n+                          .iload(monthSlot)\n+                          .iload(dayOfMonthSlot)\n+                          .invokestatic(CD_LocalDate, \"of\", MTD_LocalDate_Of);\n+                    } else if (containsLocalTimeWithNano || containsLocalTimeWithoutNano) {\n+                        \/*\n+                         * LocalTime.of(hour, minute, second, nano));\n+                         *\/\n+                        cb.iload(hourSlot)\n+                          .iload(minuteSlot)\n+                          .iload(secondSlot);\n+                        if (containsLocalTimeWithNano) {\n+                            cb.iload(nanoSlot);\n+                        } else {\n+                            cb.iconst_0();\n+                        }\n+                        if (includeOffset) {\n+                            cb.iload(offsetSecondsSlot)\n+                              .invokestatic(CD_ZoneOffset, \"ofTotalSeconds\", MTD_ZoneOffset_ofTotalSeconds)\n+                              .invokestatic(CD_OffsetTime, \"of\", MTD_OffsetTime_Of);\n+                        } else {\n+                            cb.invokestatic(CD_LocalTime, \"of\", MTD_LocalTime_Of);\n+                        }\n+                    } else {\n+                        throw new AssertionError();\n+                    }\n+\n+                    cb.invokeinterface(CD_TemporalQuery, \"queryFrom\", MTD_OBJECT_TemporalAccessor)\n+                      .areturn();\n+                }\n+\n+                void posValue(CodeBuilder cb, int textSlot, int valuePosSlot, int posSlot, int valueSlot) {\n+                    \/*\n+                     * pos = position(text, valuePos);\n+                     *\/\n+                    cb.aload(textSlot)\n+                      .lload(valuePosSlot)\n+                      .invokestatic(CD_CompositePrinterParser, \"position\", MTD_int_CharSequence_long)\n+                      .istore(posSlot);\n+\n+                    \/*\n+                     * fieldValue = (int) (valuePosSlot >> 32);\n+                     *\/\n+                    cb.lload(valuePosSlot)\n+                      .invokestatic(CD_CompositePrinterParser, \"value\", MTD_int_long)\n+                      .istore(valueSlot);\n+                }\n+            };\n+        }\n+\n+        static String parseMethod(DateTimePrinterParser pp) {\n+            String method = \"parse\";\n+            if (pp instanceof NumberPrinterParser npp && npp.signStyle == SignStyle.NOT_NEGATIVE) {\n+                if (npp.minWidth == 2 && npp.maxWidth == 2) {\n+                    method = \"parseFixedWidth2NotNegative\";\n+                } else if (npp.minWidth == 3 && npp.maxWidth == 3) {\n+                    method = \"parseFixedWidth3NotNegative\";\n+                }\n+            }\n+            return method;\n+        }\n+\n+        \/\/-----------------------------------------------------------------------\n+        \/\/ Wrapper for speeding up access to TemporalField\n+        \/\/-----------------------------------------------------------------------\n+        static record TemporalAccessorWrapper(TemporalAccessor ta, LocalDate localDate, LocalTime localTime) {\n+            public long getLong(TemporalField field) {\n+                return ta.getLong(field);\n+            }\n+            public int getYear() {\n+                return localDate != null ? localDate.getYear() : ta.get(ChronoField.YEAR);\n+            }\n+            public int getMonthValue() {\n+                return localDate != null ? localDate.getMonthValue() : ta.get(ChronoField.MONTH_OF_YEAR);\n+            }\n+            public int getDayOfYear() {\n+                return localDate != null ? localDate.getDayOfYear() : ta.get(ChronoField.DAY_OF_YEAR);\n+            }\n+            public int getDayOfMonth() {\n+                return localDate != null ? localDate.getDayOfMonth() : ta.get(ChronoField.DAY_OF_MONTH);\n+            }\n+            public int getHour() {\n+                return localTime != null ? localTime.getHour() : ta.get(ChronoField.HOUR_OF_DAY);\n+            }\n+            public int getMinute() {\n+                return localTime != null ? localTime.getMinute() : ta.get(ChronoField.MINUTE_OF_HOUR);\n+            }\n+            public int getSecond() {\n+                return localTime != null ? localTime.getSecond() : ta.get(ChronoField.SECOND_OF_MINUTE);\n+            }\n+            public int getNano() {\n+                return localTime != null ? localTime.getNano() : ta.get(ChronoField.NANO_OF_SECOND);\n+            }\n+            static TemporalAccessorWrapper wrapper(TemporalAccessor ta) {\n+                LocalDate localDate = null;\n+                LocalTime localTime = null;\n+                if (ta instanceof LocalDate) {\n+                    localDate = (LocalDate) ta;\n+                } else if (ta instanceof LocalTime) {\n+                    localTime = (LocalTime) ta;\n+                } else if (ta instanceof LocalDateTime localDateTime) {\n+                    localDate = localDateTime.toLocalDate();\n+                    localTime = localDateTime.toLocalTime();\n+                } else if (ta instanceof OffsetDateTime odt) {\n+                    localDate = odt.toLocalDate();\n+                    localTime = odt.toLocalTime();\n+                } else if (ta instanceof OffsetTime) {\n+                    localTime = ((OffsetTime) ta).toLocalTime();\n+                } else if (ta instanceof ZonedDateTime zdt) {\n+                    localDate = zdt.toLocalDate();\n+                    localTime = zdt.toLocalTime();\n+                }\n+                return new TemporalAccessorWrapper(ta, localDate, localTime);\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":1423,"deletions":122,"binary":false,"changes":1545,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,3 +155,1 @@\n-                throw new DateTimeException(\"Unable to apply override zone '\" + overrideZone +\n-                        \"' because the temporal object being formatted has a different offset but\" +\n-                        \" does not represent an instant: \" + temporal);\n+                throw unableApplyOverrideZone(temporal, overrideZone);\n@@ -170,3 +168,1 @@\n-                            throw new DateTimeException(\"Unable to apply override chronology '\" + overrideChrono +\n-                                    \"' because the temporal object being formatted contains date fields but\" +\n-                                    \" does not represent a whole date: \" + temporal);\n+                            throw unableApplyOverrideChronology(temporal, overrideChrono);\n@@ -231,0 +227,12 @@\n+    private static DateTimeException unableApplyOverrideChronology(TemporalAccessor temporal, Chronology overrideChrono) {\n+        return new DateTimeException(\"Unable to apply override chronology '\" + overrideChrono +\n+                \"' because the temporal object being formatted contains date fields but\" +\n+                \" does not represent a whole date: \" + temporal);\n+    }\n+\n+    private static DateTimeException unableApplyOverrideZone(TemporalAccessor temporal, ZoneId overrideZone) {\n+        return new DateTimeException(\"Unable to apply override zone '\" + overrideZone +\n+                \"' because the temporal object being formatted has a different offset but\" +\n+                \" does not represent an instant: \" + temporal);\n+    }\n+\n@@ -279,0 +287,7 @@\n+    \/**\n+     * isOption segment of the input.\n+     *\/\n+    boolean isSupported(TemporalField field) {\n+        return optional == 0 || temporal.isSupported(field);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimePrintContext.java","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -316,1 +316,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/time\/temporal\/TemporalAccessor.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -372,0 +372,6 @@\n+    \/**\n+     * Appends the 2 width string representation of the {@code int}\n+     * argument to StringBuilder.\n+     *\/\n+    void appendPair(StringBuilder buf, int v);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -909,0 +909,108 @@\n+    @Test\n+    public void test_out_twice_1() {\n+        int[] powers = new int[] {\n+                1000000000,\n+                100000000,\n+                10000000,\n+                1000000,\n+                100000,\n+                10000,\n+                1000,\n+                100,\n+                10,\n+                1,\n+        };\n+        int patternCount = 10;\n+        String[] dateTimePatterns = new String[patternCount];\n+        String[] timePatterns = new String[patternCount];\n+        for (int i = 0; i < patternCount; i++) {\n+            String nano = i == 0 ? \"\" : \".\" + \"S\".repeat(i);\n+            String dateTimePattern = \"yyyy-MM-dd HH:mm:ss\" + nano;\n+            dateTimePatterns[i] = dateTimePattern + \" \" + dateTimePattern;\n+\n+            String timePattern = \"HH:mm:ss\" + nano;\n+            timePatterns[i] = timePattern + \" \" + timePattern;\n+        }\n+        DateTimeFormatter[] dateTimeFormatters = new DateTimeFormatter[patternCount];\n+        DateTimeFormatter[] timeFormatters = new DateTimeFormatter[patternCount];\n+        for (int i = 0; i < patternCount; i++) {\n+            dateTimeFormatters[i] = DateTimeFormatter.ofPattern(dateTimePatterns[i], Locale.US);\n+            timeFormatters[i] = DateTimeFormatter.ofPattern(timePatterns[i], Locale.US);\n+        }\n+        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd yyyy-MM-dd\", Locale.US);\n+        LocalDateTime dateTime = LocalDateTime.now();\n+\n+        String dateStr = new StringBuilder().append(dateTime.getYear())\n+                .append(dateTime.getMonthValue() < 10 ? \"-0\" : \"-\").append(dateTime.getMonthValue())\n+                .append(dateTime.getDayOfMonth() < 10 ? \"-0\" : \"-\").append(dateTime.getDayOfMonth()).toString();\n+\n+        String dateExpected = dateStr + \" \" + dateStr;\n+        assertEquals(dateExpected, dateFormatter.format(dateTime));\n+        assertEquals(dateExpected, dateFormatter.format(OffsetDateTime.of(dateTime, ZoneOffset.UTC)));\n+        assertEquals(dateExpected, dateFormatter.format(ZonedDateTime.of(dateTime, ZoneOffset.UTC)));\n+\n+        for (int i = 0; i < patternCount; i++) {\n+            StringBuilder buf = new StringBuilder()\n+                    .append(dateTime.getHour() < 10 ? \"0\" : \"\").append(dateTime.getHour())\n+                    .append(dateTime.getMinute() < 10 ? \":0\" : \":\").append(dateTime.getMinute())\n+                    .append(dateTime.getSecond() < 10 ? \":0\" : \":\").append(dateTime.getSecond());\n+            if (i > 0) {\n+                buf.append('.');\n+                int power = powers[i];\n+                int value = dateTime.getNano() \/ power;\n+                buf.append((\"%0\" + i + \"d\").formatted(value));\n+            }\n+            String timeStr = buf.toString();\n+            String dateTimeExpected = dateStr + \" \" + timeStr + \" \" + dateStr + \" \" + timeStr;\n+            DateTimeFormatter dateTimeFormatter = dateTimeFormatters[i];\n+            assertEquals(dateTimeExpected, dateTimeFormatter.format(dateTime));\n+            assertEquals(dateTimeExpected, dateTimeFormatter.format(OffsetDateTime.of(dateTime, ZoneOffset.UTC)));\n+            assertEquals(dateTimeExpected, dateTimeFormatter.format(ZonedDateTime.of(dateTime, ZoneOffset.UTC)));\n+            assertEquals(dateTimeExpected, dateTimeFormatter.withZone(ZoneOffset.UTC).format(dateTime.toInstant(ZoneOffset.UTC)));\n+\n+            String timeExpected = timeStr + \" \" + timeStr;\n+            DateTimeFormatter timeFormatter = timeFormatters[i];\n+            assertEquals(timeExpected, timeFormatter.format(dateTime));\n+            assertEquals(timeExpected, timeFormatter.format(dateTime.toLocalTime()));\n+            assertEquals(timeExpected, timeFormatter.format(OffsetDateTime.of(dateTime, ZoneOffset.UTC)));\n+            assertEquals(timeExpected, timeFormatter.format(OffsetDateTime.of(dateTime, ZoneOffset.UTC).toOffsetTime()));\n+            assertEquals(timeExpected, timeFormatter.format(ZonedDateTime.of(dateTime, ZoneOffset.UTC)));\n+            assertEquals(timeExpected, timeFormatter.withZone(ZoneOffset.UTC).format(dateTime.toInstant(ZoneOffset.UTC)));\n+        }\n+    }\n+\n+    @Test\n+    public void test_out_twice_2() {\n+        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern(\"yyyy-M-d yyyy-M-d\", Locale.US);\n+        DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern(\"H:m:s H:m:s\", Locale.US);\n+        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(\"yyyy-M-d H:m:s yyyy-M-d H:m:s\", Locale.US);\n+\n+        LocalDateTime dateTime = LocalDateTime.now();\n+\n+        String dateStr = new StringBuilder().append(dateTime.getYear())\n+                .append('-').append(dateTime.getMonthValue())\n+                .append('-').append(dateTime.getDayOfMonth())\n+                .toString();\n+\n+        String dateExpected = dateStr + \" \" + dateStr;\n+        assertEquals(dateExpected, dateFormatter.format(dateTime));\n+        assertEquals(dateExpected, dateFormatter.format(OffsetDateTime.of(dateTime, ZoneOffset.UTC)));\n+        assertEquals(dateExpected, dateFormatter.format(ZonedDateTime.of(dateTime, ZoneOffset.UTC)));\n+\n+        StringBuilder buf = new StringBuilder().append(dateTime.getHour())\n+                .append(':').append(dateTime.getMinute())\n+                .append(':').append(dateTime.getSecond());\n+        String timeStr = buf.toString();\n+\n+        String dateTimeExpected = dateStr + \" \" + timeStr + \" \" + dateStr + \" \" + timeStr;\n+        assertEquals(dateTimeExpected, dateTimeFormatter.format(dateTime));\n+        assertEquals(dateTimeExpected, dateTimeFormatter.format(OffsetDateTime.of(dateTime, ZoneOffset.UTC)));\n+        assertEquals(dateTimeExpected, dateTimeFormatter.format(ZonedDateTime.of(dateTime, ZoneOffset.UTC)));\n+\n+        String timeExpected = timeStr + \" \" + timeStr;\n+        assertEquals(timeExpected, timeFormatter.format(dateTime));\n+        assertEquals(timeExpected, timeFormatter.format(dateTime.toLocalTime()));\n+        assertEquals(timeExpected, timeFormatter.format(OffsetDateTime.of(dateTime, ZoneOffset.UTC)));\n+        assertEquals(timeExpected, timeFormatter.format(OffsetDateTime.of(dateTime, ZoneOffset.UTC).toOffsetTime()));\n+        assertEquals(timeExpected, timeFormatter.format(ZonedDateTime.of(dateTime, ZoneOffset.UTC)));\n+    }\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/format\/TCKDateTimeFormatter.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.time.format;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.LocalTime;\n+import java.time.OffsetDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+\n+import java.util.Locale;\n+import java.util.Random;\n+import java.util.TimeZone;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(3)\n+@State(Scope.Thread)\n+public class DateTimeFormatterParse {\n+    static final DateTimeFormatter formatterLocalTime = DateTimeFormatter.ofPattern(\"HH:mm:ss\");\n+    static final DateTimeFormatter formatterLocalTimeWithNano = DateTimeFormatter.ofPattern(\"HH:mm:ss.SSS\");\n+    static final DateTimeFormatter formatterLocalDate = DateTimeFormatter.ofPattern(\"yyyy-MM-dd\");\n+    static final DateTimeFormatter formatterLocalDateTime = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss\");\n+    static final DateTimeFormatter formatterLocalDateTimeWithNano = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\");\n+    static final DateTimeFormatter formatterOffsetDateTime = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSSSSZZZZZ\");\n+    static final DateTimeFormatter formatterZonedDateTime = DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSSSSZZZZZ'['VV']'\");\n+\n+    static final String STR_LOCALTIME = \"21:11:48\";\n+    static final String STR_LOCALTIME_WITH_NANO = \"21:11:48.456\";\n+    static final String STR_LOCALDATE = \"2024-08-01\";\n+    static final String STR_LOCALDATETIME = \"2024-08-01T21:11:48\";\n+    static final String STR_LOCALDATETIME_WITH_NANO = \"2024-08-01T21:11:48.456\";\n+    static final String STR_INSTANT = \"2024-08-12T03:25:54.980339Z\";\n+    static final String STR_OFFSETDATETIME = \"2024-08-12T11:50:46.731509+08:00\";\n+    static final String STR_ZONEDDATETIME = \"2024-08-12T11:50:46.731509+08:00[Asia\/Shanghai]\";\n+\n+    @Benchmark\n+    public LocalTime parseLocalTime() {\n+        return LocalTime.parse(STR_LOCALTIME, formatterLocalTime);\n+    }\n+\n+    @Benchmark\n+    public LocalTime parseLocalTimeWithNano() {\n+        return LocalTime.parse(STR_LOCALTIME_WITH_NANO, formatterLocalTimeWithNano);\n+    }\n+\n+    @Benchmark\n+    public LocalDate parseLocalDate() {\n+        return LocalDate.parse(STR_LOCALDATE, formatterLocalDate);\n+    }\n+\n+    @Benchmark\n+    public LocalDateTime parseLocalDateTime() {\n+        return LocalDateTime.parse(STR_LOCALDATETIME, formatterLocalDateTime);\n+    }\n+\n+    @Benchmark\n+    public LocalDateTime parseLocalDateTimeWithNano() {\n+        return LocalDateTime.parse(STR_LOCALDATETIME_WITH_NANO, formatterLocalDateTimeWithNano);\n+    }\n+\n+    @Benchmark\n+    public OffsetDateTime parseOffsetDateTime() {\n+        return OffsetDateTime.parse(STR_OFFSETDATETIME, formatterOffsetDateTime);\n+    }\n+\n+    @Benchmark\n+    public ZonedDateTime parseZonedDateTime() {\n+        return ZonedDateTime.parse(STR_ZONEDDATETIME, formatterZonedDateTime);\n+    }\n+\n+    @Benchmark\n+    public Instant parseInstant() {\n+        return Instant.parse(STR_INSTANT);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/time\/format\/DateTimeFormatterParse.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"}]}