{"files":[{"patch":"@@ -3051,2 +3051,18 @@\n-        protected void printValueWidth1NotNegative(StringBuilder buf, int value) {\n-            buf.append((char) ('0' + value));\n+        protected int value1(int value) {\n+            return value;\n+        }\n+\n+        protected int value2(int value) {\n+            return value;\n+        }\n+\n+        protected int value3(int value) {\n+            return value;\n+        }\n+\n+        protected int value4(int value) {\n+            return value;\n+        }\n+\n+        protected final void printValueWidth1NotNegative(StringBuilder buf, int value) {\n+            buf.append((char) ('0' + value1(value)));\n@@ -3056,1 +3072,1 @@\n-            buf.append(value);\n+            buf.append(value2(value));\n@@ -3059,2 +3075,2 @@\n-        protected void printValueFixedWidth2NotNegative(StringBuilder buf, int value) {\n-            JLA.appendPair(buf, value);\n+        protected final void printValueFixedWidth2NotNegative(StringBuilder buf, int value) {\n+            JLA.appendPair(buf, value2(value));\n@@ -3063,1 +3079,2 @@\n-        protected void printValueFixWidth3NotNegative(StringBuilder buf, int value) {\n+        protected final void printValueFixWidth3NotNegative(StringBuilder buf, int value) {\n+            value = value3(value);\n@@ -3073,1 +3090,2 @@\n-        protected void printValueFixWidth4NotNegative(StringBuilder buf, int value) {\n+        protected final void printValueFixWidth4NotNegative(StringBuilder buf, int value) {\n+            value = value4(value);\n@@ -3077,0 +3095,1 @@\n+            int value2 = value \/ 100;\n@@ -3078,1 +3097,1 @@\n-            JLA.appendPair(buf, value % 100);\n+            JLA.appendPair(buf, value - value2 * 100);\n@@ -3082,0 +3101,1 @@\n+            value = value4(value);\n@@ -3733,2 +3753,2 @@\n-        protected void printValueWidth1NotNegative(StringBuilder buf, int value) {\n-            buf.append(value \/ 100_000_000);\n+        protected int value1(int value) {\n+            return value \/ 100_000_000;\n@@ -3737,2 +3757,2 @@\n-        protected void printValueFixedWidth2NotNegative(StringBuilder buf, int value) {\n-            JLA.appendPair(buf, value \/ 10_000_000);\n+        protected int value2(int value) {\n+            return value \/ 10_000_000;\n@@ -3741,6 +3761,2 @@\n-        protected void printValueFixWidth3NotNegative(StringBuilder buf, int value) {\n-            value \/= 1000_000;\n-            if (value < 100) {\n-                buf.repeat('0', value < 10 ? 2 : 1);\n-            }\n-            buf.append(value);\n+        protected int value3(int value) {\n+            return value \/ 1_000_000;\n@@ -3749,4 +3765,2 @@\n-        protected void printValueFixWidth4NotNegative(StringBuilder buf, int value) {\n-            value \/= 100_000;\n-            JLA.appendPair(buf, value \/ 100);\n-            JLA.appendPair(buf, value % 100);\n+        protected int value4(int value) {\n+            return value \/ 100_000;\n@@ -6472,0 +6486,7 @@\n+                        } else if (chronoField.range().getMinimum() >= Integer.MIN_VALUE\n+                                && chronoField.range().getMaximum() <= Integer.MAX_VALUE\n+                        ) {\n+                            getfield(cb, pp, index);\n+                            cb.invokevirtual(CD_TemporalAccessorWrapper, \"get\", MTD_int_TemporalField)\n+                              .invokevirtual(CD_NumberPrinterParser, formatMethod(pp), MTD_formatValue_int);\n+                            return;\n@@ -6489,1 +6510,1 @@\n-                        if (pp.minWidth == 1 && pp.maxWidth == 1 && minimum >= 0 && maximumSize == 1) {\n+                        if (pp.minWidth == 1 && pp.maxWidth == 1) {\n@@ -6497,4 +6518,2 @@\n-                        } else if (pp.minWidth == 3 && pp.maxWidth == 3) {\n-                            if (minimum >= 0 && maximumSize <= 3) {\n-                                method = \"printValueFixWidth3NotNegative\";\n-                            }\n+                        } else if (pp.minWidth == 3 && pp.maxWidth == 3 && minimum >= 0) {\n+                            method = \"printValueFixWidth3NotNegative\";\n@@ -6865,0 +6884,3 @@\n+            public int get(TemporalField field) {\n+                return ta.get(field);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/time\/format\/DateTimeFormatterBuilder.java","additions":49,"deletions":27,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+import java.time.temporal.ChronoUnit;\n@@ -1027,0 +1028,211 @@\n+    @Test\n+    public void test_output_second_fields() {\n+        List<ChronoField> fields = new ArrayList<>();\n+        for (ChronoField value : ChronoField.values()) {\n+            if (value.getRangeUnit() == ChronoUnit.SECONDS) {\n+                fields.add(value);\n+            }\n+        }\n+        DateTimeFormatter[] formatters = new DateTimeFormatter[fields.size()];\n+        for (int i = 0; i < fields.size(); i++) {\n+            ChronoField chronoField = fields.get(i);\n+            formatters[i] = new DateTimeFormatterBuilder().appendValue(chronoField).toFormatter();\n+        }\n+\n+        int[] nanos = {\n+                0, 9,\n+                10, 99,\n+                100, 999,\n+                1000, 9999,\n+                10000, 99999,\n+                100000, 999999,\n+                1000000, 9999999,\n+                10000000, 99999999,\n+                10000000, 999999999\n+        };\n+        for (int nano : nanos) {\n+            Instant instant = Instant.ofEpochSecond(0, nano);\n+            for (int i = 0; i < fields.size(); i++) {\n+                assertEquals(String.valueOf(instant.getLong(fields.get(i))), formatters[i].format(instant));\n+            }\n+            LocalTime localTime = LocalTime.of(0, 0, 0, nano);\n+            for (int i = 0; i < fields.size(); i++) {\n+                assertEquals(String.valueOf(localTime.get(fields.get(i))), formatters[i].format(localTime));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test_output_days_fields() {\n+        List<ChronoField> fields = new ArrayList<>();\n+        for (ChronoField value : ChronoField.values()) {\n+            if (value.getRangeUnit() == ChronoUnit.DAYS) {\n+                fields.add(value);\n+            }\n+        }\n+        DateTimeFormatter[] formatters = new DateTimeFormatter[fields.size()];\n+        for (int i = 0; i < fields.size(); i++) {\n+            ChronoField chronoField = fields.get(i);\n+            formatters[i] = new DateTimeFormatterBuilder().appendValue(chronoField)\n+                    .toFormatter();\n+        }\n+\n+        List<LocalDateTime> dateTimes = dateTimes(false);\n+        for (LocalDateTime dateTime : dateTimes) {\n+            for (int i = 0; i < fields.size(); i++) {\n+                assertEquals(String.valueOf(dateTime.getLong(fields.get(i))), formatters[i].format(dateTime));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test_output_long_fields() {\n+        ChronoField[] fields = {\n+                ChronoField.MICRO_OF_DAY,\n+                ChronoField.NANO_OF_DAY,\n+                ChronoField.MILLI_OF_DAY,\n+                ChronoField.EPOCH_DAY\n+        };\n+        DateTimeFormatter[] formatters = new DateTimeFormatter[fields.length];\n+        for (int i = 0; i < fields.length; i++) {\n+            ChronoField chronoField = fields[i];\n+            formatters[i] = new DateTimeFormatterBuilder().appendValue(chronoField)\n+                    .toFormatter().withZone(ZoneOffset.UTC);\n+        }\n+\n+        List<LocalDateTime> dateTimes = dateTimes(false);\n+        for (LocalDateTime dateTime : dateTimes) {\n+            for (int i = 0; i < fields.length; i++) {\n+                Instant instant = dateTime.toInstant(ZoneOffset.UTC);\n+                assertEquals(String.valueOf(dateTime.getLong(fields[i])), formatters[i].format(instant));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test_output_width_1() {\n+        List<LocalDateTime> dateTimes = dateTimes(true);\n+        ChronoField[] fields = {ChronoField.DAY_OF_WEEK, ChronoField.AMPM_OF_DAY, ChronoField.ALIGNED_WEEK_OF_MONTH};\n+        DateTimeFormatter[] formatters = new DateTimeFormatter[fields.length];\n+        for (int i = 0; i < fields.length; i++) {\n+            formatters[i] = new DateTimeFormatterBuilder()\n+                    .appendValue(fields[i], 1, 1, SignStyle.NOT_NEGATIVE)\n+                    .toFormatter();\n+        }\n+        for (LocalDateTime dateTime : dateTimes) {\n+            for (int i = 0; i < fields.length; i++) {\n+                assertEquals(\n+                        String.valueOf(dateTime.get(fields[i])),\n+                        formatters[i].format(dateTime));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test_output_width_2() {\n+        List<LocalDateTime> dateTimes = dateTimes(true);\n+        ChronoField[] fields = {\n+                ChronoField.DAY_OF_MONTH,\n+                ChronoField.HOUR_OF_DAY,\n+                ChronoField.SECOND_OF_MINUTE,\n+                ChronoField.CLOCK_HOUR_OF_DAY,\n+                ChronoField.ALIGNED_WEEK_OF_YEAR\n+        };\n+        DateTimeFormatter[] formatters_1_2 = new DateTimeFormatter[fields.length];\n+        DateTimeFormatter[] formatters_2_2 = new DateTimeFormatter[fields.length];\n+        for (int i = 0; i < fields.length; i++) {\n+            formatters_1_2[i] = new DateTimeFormatterBuilder()\n+                    .appendValue(fields[i], 1, 2, SignStyle.NOT_NEGATIVE)\n+                    .toFormatter();\n+            formatters_2_2[i] = new DateTimeFormatterBuilder()\n+                    .appendValue(fields[i], 2, 2, SignStyle.NOT_NEGATIVE)\n+                    .toFormatter();\n+        }\n+        for (LocalDateTime dateTime : dateTimes) {\n+            for (int i = 0; i < fields.length; i++) {\n+                assertEquals(\n+                        String.valueOf(dateTime.get(fields[i])),\n+                        formatters_1_2[i].format(dateTime));\n+                assertEquals(\n+                        \"%02d\".formatted(dateTime.get(fields[i])),\n+                        formatters_2_2[i].format(dateTime));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test_output_width_3() {\n+        List<LocalDateTime> dateTimes = dateTimes(true);\n+        ChronoField[] fields = {ChronoField.ALIGNED_WEEK_OF_YEAR, ChronoField.DAY_OF_YEAR, ChronoField.MILLI_OF_SECOND};\n+        DateTimeFormatter[] formatters_3_3 = new DateTimeFormatter[fields.length];\n+        DateTimeFormatter[] formatters_1_3 = new DateTimeFormatter[fields.length];\n+        for (int i = 0; i < fields.length; i++) {\n+            formatters_3_3[i] = new DateTimeFormatterBuilder()\n+                    .appendValue(fields[i], 3, 3, SignStyle.NOT_NEGATIVE)\n+                    .toFormatter();\n+            formatters_1_3[i] = new DateTimeFormatterBuilder()\n+                    .appendValue(fields[i], 1, 3, SignStyle.NOT_NEGATIVE)\n+                    .toFormatter();\n+        }\n+        for (LocalDateTime dateTime : dateTimes) {\n+            for (int i = 0; i < fields.length; i++) {\n+                assertEquals(\n+                        \"%03d\".formatted(dateTime.get(fields[i])),\n+                        formatters_3_3[i].format(dateTime));\n+                assertEquals(\n+                        Integer.toString(dateTime.get(fields[i])),\n+                        formatters_1_3[i].format(dateTime));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void test_output_width_4() {\n+        ChronoField[] fields = {ChronoField.YEAR, ChronoField.YEAR_OF_ERA};\n+        DateTimeFormatter[] formatters_4_4 = new DateTimeFormatter[fields.length];\n+        DateTimeFormatter[] formatters_4_EXCEEDS_PAD = new DateTimeFormatter[fields.length];\n+        for (int i = 0; i < fields.length; i++) {\n+            formatters_4_4[i] = new DateTimeFormatterBuilder()\n+                    .appendValue(fields[i], 4, 9, SignStyle.NOT_NEGATIVE)\n+                    .toFormatter();\n+            formatters_4_EXCEEDS_PAD[i] = new DateTimeFormatterBuilder()\n+                    .appendValue(fields[i], 4, 9, SignStyle.EXCEEDS_PAD)\n+                    .toFormatter();\n+        }\n+        LocalDate date = LocalDate.of(1972, 1, 1);\n+        for (int i = 0; i < fields.length; i++) {\n+            assertEquals(\n+                    \"%04d\".formatted(date.get(fields[i])),\n+                    formatters_4_4[i].format(date));\n+            assertEquals(\n+                    \"%04d\".formatted(date.get(fields[i])),\n+                    formatters_4_EXCEEDS_PAD[i].format(date));\n+        }\n+    }\n+\n+    @Test\n+    public void test_output_nano_second() {\n+        DateTimeFormatter[] formatters = new DateTimeFormatter[9];\n+        DateTimeFormatter[] formatters_fixed_width = new DateTimeFormatter[9];\n+        for (int i = 0; i < 9; i++) {\n+            int width = i + 1;\n+            formatters[i] = new DateTimeFormatterBuilder()\n+                    .appendFraction(ChronoField.NANO_OF_SECOND, 1, width, false)\n+                    .toFormatter();\n+            formatters_fixed_width[i] = new DateTimeFormatterBuilder()\n+                    .appendFraction(ChronoField.NANO_OF_SECOND, width, width, false)\n+                    .toFormatter();\n+        }\n+        int nanoOfSecond = 123456789;\n+        String nanoOfSecondStr = Integer.toString(nanoOfSecond);\n+        LocalTime date = LocalTime.of(12, 13,14, nanoOfSecond);\n+        for (int i = 0; i < formatters.length; i++) {\n+            assertEquals(\n+                    nanoOfSecondStr.substring(0, i + 1),\n+                    formatters[i].format(date));\n+            assertEquals(\n+                    nanoOfSecondStr.substring(0, i + 1),\n+                    formatters_fixed_width[i].format(date));\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/time\/tck\/java\/time\/format\/TCKDateTimeFormatter.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"modified"}]}