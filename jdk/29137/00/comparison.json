{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,6 +165,10 @@\n-void G1Analytics::update_gc_time_ratios(double end_time_sec, double pause_time_ms) {\n-  \/\/ This estimates the wall-clock time \"lost\" by application mutator threads due to concurrent GC\n-  \/\/ activity. We do not account for contention on other shared resources such as memory bandwidth and\n-  \/\/ caches, therefore underestimate the impact of the concurrent GC activity on mutator threads.\n-  uint num_cpus = (uint)os::active_processor_count();\n-  double concurrent_gc_impact_time = _concurrent_gc_cpu_time_ms \/ num_cpus;\n+void G1Analytics::update_gc_time_ratios(double end_time_sec, double pause_time_ms, bool is_user_requested_gc) {\n+  \/\/ Exclude pause times from user-requested GCs when updating sizing heuristics.\n+  \/\/ User-triggered GCs may occur independently of normal GC pressure, so including\n+  \/\/ their pause times would skew the GC Time Ratios used for heap sizing decisions.\n+  if (!is_user_requested_gc) {\n+    \/\/ This estimates the wall-clock time \"lost\" by application mutator threads due to concurrent GC\n+    \/\/ activity. We do not account for contention on other shared resources such as memory bandwidth and\n+    \/\/ caches, therefore underestimate the impact of the concurrent GC activity on mutator threads.\n+    uint num_cpus = (uint)os::active_processor_count();\n+    double concurrent_gc_impact_time = _concurrent_gc_cpu_time_ms \/ num_cpus;\n@@ -172,1 +176,1 @@\n-  double gc_time_ms = pause_time_ms + concurrent_gc_impact_time;\n+    double gc_time_ms = pause_time_ms + concurrent_gc_impact_time;\n@@ -174,2 +178,2 @@\n-  double long_interval_ms = (end_time_sec - oldest_known_gc_end_time_sec()) * 1000.0;\n-  double long_term_gc_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + gc_time_ms;\n+    double long_interval_ms = (end_time_sec - oldest_known_gc_end_time_sec()) * 1000.0;\n+    double long_term_gc_time_ms = _recent_gc_times_ms.sum() - _recent_gc_times_ms.oldest() + gc_time_ms;\n@@ -177,2 +181,2 @@\n-  _long_term_gc_time_ratio = long_term_gc_time_ms \/ long_interval_ms;\n-  _long_term_gc_time_ratio = clamp(_long_term_gc_time_ratio, 0.0, 1.0);\n+    _long_term_gc_time_ratio = long_term_gc_time_ms \/ long_interval_ms;\n+    _long_term_gc_time_ratio = clamp(_long_term_gc_time_ratio, 0.0, 1.0);\n@@ -180,1 +184,1 @@\n-  double short_interval_ms = (end_time_sec - most_recent_gc_end_time_sec()) * 1000.0;\n+    double short_interval_ms = (end_time_sec - most_recent_gc_end_time_sec()) * 1000.0;\n@@ -182,3 +186,3 @@\n-  assert(short_interval_ms != 0.0, \"short_interval_ms should not be zero, calculated from %f and %f\", end_time_sec,  most_recent_gc_end_time_sec());\n-  _short_term_gc_time_ratio = gc_time_ms \/ short_interval_ms;\n-  _short_term_gc_time_ratio = clamp(_short_term_gc_time_ratio, 0.0, 1.0);\n+    assert(short_interval_ms != 0.0, \"short_interval_ms should not be zero, calculated from %f and %f\", end_time_sec,  most_recent_gc_end_time_sec());\n+    _short_term_gc_time_ratio = gc_time_ms \/ short_interval_ms;\n+    _short_term_gc_time_ratio = clamp(_short_term_gc_time_ratio, 0.0, 1.0);\n@@ -186,1 +190,3 @@\n-  update_recent_gc_times(end_time_sec, gc_time_ms);\n+    _recent_gc_times_ms.add(gc_time_ms);\n+  }\n+  _recent_prev_end_times_for_all_gcs_sec.add(end_time_sec);\n@@ -325,6 +331,0 @@\n-void G1Analytics::update_recent_gc_times(double end_time_sec,\n-                                         double gc_time_ms) {\n-  _recent_gc_times_ms.add(gc_time_ms);\n-  _recent_prev_end_times_for_all_gcs_sec.add(end_time_sec);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n-  \/\/ These exclude marking times.\n+  \/\/ These exclude marking times and System.gc() pause times.\n@@ -199,2 +199,1 @@\n-  void update_recent_gc_times(double end_time_sec, double gc_time_ms);\n-  void update_gc_time_ratios(double end_time_sec, double pause_time_ms);\n+  void update_gc_time_ratios(double end_time_sec, double pause_time_ms, bool is_user_requested_gc);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Analytics.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,0 +210,11 @@\n+  \/\/ Do not interfere with GC-Pressure driven heap resizing unless the user\n+  \/\/ explicitly sets otherwise. G1 heap sizing should be free to grow or shrink\n+  \/\/ the heap based on GC pressure, rather than being forced to satisfy\n+  \/\/ MinHeapFreeRatio or MaxHeapFreeRatio defaults that the user did not set.\n+  if (FLAG_IS_DEFAULT(MinHeapFreeRatio)) {\n+    FLAG_SET_DEFAULT(MinHeapFreeRatio, 0);\n+  }\n+  if (FLAG_IS_DEFAULT(MaxHeapFreeRatio)) {\n+    FLAG_SET_DEFAULT(MaxHeapFreeRatio, 100);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1381,1 +1381,1 @@\n-  _analytics->update_gc_time_ratios(end_time_sec, pause_time_ms);\n+  _analytics->update_gc_time_ratios(end_time_sec, pause_time_ms, GCCause::is_user_requested_gc(_g1h->gc_cause()));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}