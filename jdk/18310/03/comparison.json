{"files":[{"patch":"@@ -4861,1 +4861,1 @@\n-  vblendvps(dst, dst, xtmp4, xtmp3, vec_enc);\n+  vblendvps(dst, dst, xtmp4, xtmp3, vec_enc, false, xtmp4);\n@@ -4871,1 +4871,1 @@\n-  vblendvps(dst, dst, xtmp1, xtmp3, vec_enc);\n+  vblendvps(dst, dst, xtmp1, xtmp3, vec_enc, true, xtmp4);\n@@ -5007,1 +5007,1 @@\n-  vblendvps(dst, dst, xtmp4, xtmp3, Assembler::AVX_128bit);\n+  vblendvps(dst, dst, xtmp4, xtmp3, Assembler::AVX_128bit, false, xtmp5);\n@@ -5020,1 +5020,1 @@\n-  vblendvps(dst, dst, xtmp1, xtmp3, Assembler::AVX_128bit);\n+  vblendvps(dst, dst, xtmp1, xtmp3, Assembler::AVX_128bit, false, xtmp5);\n@@ -6074,1 +6074,1 @@\n-  vblendvps(dst, dst, xtmp2, dst, vec_enc);\n+  vblendvps(dst, dst, xtmp2, dst, vec_enc, true, xtmp1);\n@@ -6089,1 +6089,1 @@\n-  vblendvps(dst, dst, xtmp2, src, vec_enc);\n+  vblendvps(dst, dst, xtmp2, src, vec_enc, true, xtmp1);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3521,5 +3521,12 @@\n-  \/\/ WARN: Allow dst == (src1|src2), mask == scratch\n-  bool blend_emulation = EnableX86ECoreOpts && UseAVX > 1;\n-  bool scratch_available = scratch != xnoreg && scratch != src1 && scratch != src2 && scratch != dst;\n-  bool dst_available = dst != mask && (dst != src1 || dst != src2);\n-  if (blend_emulation && scratch_available && dst_available) {\n+  bool blend_emulation_needed = EnableX86ECoreOpts && UseAVX > 1;\n+  bool scratch_available;\n+  bool dst_available;\n+  if (compute_mask) {\n+    scratch_available = scratch != xnoreg && scratch != dst && scratch != src1 && scratch != src2;\n+    dst_available = dst != src1 || dst != src2;\n+  } else {\n+    scratch_available = scratch != xnoreg && scratch != dst;\n+    dst_available = dst != mask && (dst != src1 || dst != src2);\n+  }\n+\n+  if (blend_emulation_needed && scratch_available && dst_available) {\n@@ -3545,5 +3552,12 @@\n-  \/\/ WARN: Allow dst == (src1|src2), mask == scratch\n-  bool blend_emulation = EnableX86ECoreOpts && UseAVX > 1;\n-  bool scratch_available = scratch != xnoreg && scratch != src1 && scratch != src2 && scratch != dst && (!compute_mask || scratch != mask);\n-  bool dst_available = dst != mask && (dst != src1 || dst != src2);\n-  if (blend_emulation && scratch_available && dst_available) {\n+  bool blend_emulation_needed = EnableX86ECoreOpts && UseAVX > 1;\n+  bool scratch_available;\n+  bool dst_available;\n+  if (compute_mask) {\n+    scratch_available = scratch != xnoreg && scratch != dst && scratch != mask && scratch != src1 && scratch != src2;\n+    dst_available = dst != src1 || dst != src2;\n+  } else {\n+    scratch_available = scratch != xnoreg && scratch != dst;\n+    dst_available = dst != mask && (dst != src1 || dst != src2);\n+  }\n+\n+  if (blend_emulation_needed && scratch_available && dst_available) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":24,"deletions":10,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1127,0 +1127,10 @@\n+    public static final String COUNTTRAILINGZEROS_VI = VECTOR_PREFIX + \"COUNTTRAILINGZEROS_VI\" + POSTFIX;\n+    static {\n+        vectorNode(COUNTTRAILINGZEROS_VI, \"CountTrailingZerosV\", TYPE_INT);\n+    }\n+\n+    public static final String COUNTLEADINGZEROS_VI = VECTOR_PREFIX + \"COUNTLEADINGZEROS_VI\" + POSTFIX;\n+    static {\n+        vectorNode(COUNTLEADINGZEROS_VI, \"CountLeadingZerosV\", TYPE_INT);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.test.lib.Asserts;\n@@ -60,1 +61,1 @@\n-            b[i] = 333 * i + 9999;\n+            b[i] = 333 * i - 9999;\n@@ -154,0 +155,18 @@\n+    @Test\n+    @IR(counts = {IRNode.COUNTLEADINGZEROS_VI, \">0\"})\n+    public int[] vectorizeNumberOfLeadingZeros() {\n+        int[] res = new int[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Integer.numberOfLeadingZeros(b[i]);\n+        }\n+        return res;\n+    }\n+\n+    @Run(test = {\"vectorizeNumberOfLeadingZeros\"})\n+    public void checkResult() {\n+        int[] res = vectorizeNumberOfLeadingZeros();\n+        for (int i = 0; i < SIZE; ++i) {\n+            Asserts.assertEquals(res[i], Integer.numberOfLeadingZeros(b[i]));\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicIntOpTest.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -66,0 +66,10 @@\n+    @Benchmark\n+    @BenchmarkMode(Mode.Throughput)\n+    @OutputTimeUnit(TimeUnit.MICROSECONDS)\n+    public int[] intLeadingZeroCount() {\n+        for (int i = 0; i < SIZE; i++) {\n+            bitCounts[i] = Integer.numberOfLeadingZeros(bufferRandInts[i]);\n+        }\n+        return bitCounts;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorBitCount.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}