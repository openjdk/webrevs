{"files":[{"patch":"@@ -3623,2 +3623,0 @@\n-      fileStream fs(defaultStream::output_stream());\n-      os::print_memory_mappings((char*)start, bytes, &fs);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -286,2 +286,15 @@\n-  \/\/ Same as MutexLocker but can be used during VM init while single threaded and before mutexes are ready or current thread has been assigned.\n-  \/\/ Performs no action during VM init.\n+  \/*\n+   * NmtVirtualMemoryLocker is similar to MutexLocker but can be used during VM init before mutexes are ready or\n+   * current thread has been assigned. Performs no action during VM init.\n+   *\n+   * Unlike malloc, NMT requires locking for virtual memory operations. This is because it must synchronize the usage\n+   * of global data structures used for modelling the effect of virtual memory operations.\n+   * It is important that locking is used such that the actual OS memory operations (mmap) are done atomically with the\n+   * corresponding NMT accounting (updating the internal model). Currently, this is not the case in all situations\n+   * (see JDK-8341491), but this should be changed in the future.\n+   *\n+   * An issue with using Mutex is that NMT is used early during VM initialization before mutexes are initialized\n+   * and current thread is attached. Mutexes do not work under those conditions, so we must use a flag to avoid\n+   * attempting to lock until initialization is finished. Lack of synchronization here should not be a problem since it\n+   * is single threaded at that point in time anyway.\n+   *\/\n","filename":"src\/hotspot\/share\/nmt\/memTracker.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"}]}