{"files":[{"patch":"@@ -155,1 +155,4 @@\n-  DecoratorSet decorators = C2_READ_ACCESS | C2_CONTROL_DEPENDENT_LOAD | IN_HEAP | C2_ARRAY_COPY;\n+  \/\/ Pin the load: if this is an array load, it's going to be dependent on a condition that's not a range check for that\n+  \/\/ access. If that condition is replaced by an identical dominating one, then an unpinned load would risk floating\n+  \/\/ above runtime checks that guarantee it is within bounds.\n+  DecoratorSet decorators = C2_READ_ACCESS | C2_CONTROL_DEPENDENT_LOAD | IN_HEAP | C2_ARRAY_COPY | C2_UNKNOWN_CONTROL_LOAD;\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1742,0 +1742,2 @@\n+\n+  void pin_array_access_nodes(Node* ctrl);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1492,1 +1492,8 @@\n-          dominated_by(prevdom->as_IfProj(), n->as_If());\n+          \/\/ Split if: pin array accesses that are control dependent on a range check and moved to a regular if,\n+          \/\/ to prevent an array load from floating above its range check. There are three cases:\n+          \/\/ 1. Move from RangeCheck \"a\" to RangeCheck \"b\": don't need to pin. If we ever remove b, then we pin all its array accesses at that point.\n+          \/\/ 2. We move from RangeCheck \"a\" to regular if \"b\": need to pin. If we ever remove b, then its array accesses would start to float, since we don't pin at that point.\n+          \/\/ 3. If we move from regular if: don't pin. All array accesses are already assumed to be pinned.\n+          bool pin_array_access_nodes =  n->Opcode() == Op_RangeCheck &&\n+                                         prevdom->in(0)->Opcode() != Op_RangeCheck\n+          dominated_by(prevdom->as_IfProj(), n->as_If(), false, pin_array_access_nodes);\n@@ -1666,1 +1673,13 @@\n-        _igvn.replace_input_of(n, 0, place_outside_loop(n_ctrl, loop_ctrl));\n+        Node* maybe_pinned_n = n;\n+        Node* outside_ctrl = place_outside_loop(n_ctrl, loop_ctrl);\n+        if (n->depends_only_on_test()) {\n+          Node* pinned_clone = n->pin_array_access_node();\n+          if (pinned_clone != nullptr) {\n+            \/\/ Pin array access nodes: if this is an array load, it's going to be dependent on a condition that's not a\n+            \/\/ range check for that access. If that condition is replaced by an identical dominating one, then an\n+            \/\/ unpinned load would risk floating above its range check.\n+            register_new_node(pinned_clone, outside_ctrl);\n+            maybe_pinned_n = pinned_clone;\n+          }\n+        }\n+        _igvn.replace_input_of(maybe_pinned_n, 0, outside_ctrl);\n@@ -1680,1 +1699,10 @@\n-          Node* x = n->clone(); \/\/ Clone computation\n+          Node* x = nullptr;\n+          if (n->depends_only_on_test()) {\n+            \/\/ Pin array access nodes: if this is an array load, it's going to be dependent on a condition that's not a\n+            \/\/ range check for that access. If that condition is replaced by an identical dominating one, then an\n+            \/\/ unpinned load would risk floating above its range check.\n+            x = n->pin_array_access_node();\n+          }\n+          if (x == nullptr) {\n+            x = n->clone();\n+          }\n@@ -2230,0 +2258,14 @@\n+      if (idx == 0 &&\n+          use->depends_only_on_test()) {\n+        Node* pinned_clone = use->pin_array_access_node();\n+        if (pinned_clone != nullptr) {\n+          \/\/ Pin array access nodes: control is updated here to a region. If, after some transformations, only one path\n+          \/\/ into the region is left, an array load could become dependent on a condition that's not a range check for\n+          \/\/ that access. If that condition is replaced by an identical dominating one, then an unpinned load would risk\n+          \/\/ floating above its range check.\n+          pinned_clone->set_req(0, phi);\n+          register_new_node(pinned_clone, get_ctrl(use));\n+          _igvn.replace_node(use, pinned_clone);\n+          continue;\n+        }\n+      }\n@@ -3865,0 +3907,13 @@\n+      if (n_clone->depends_only_on_test()) {\n+        \/\/ Pin array access nodes: control is updated here to the loop head. If, after some transformations, the\n+        \/\/ backedge is removed, an array load could become dependent on a condition that's not a range check for that\n+        \/\/ access. If that condition is replaced by an identical dominating one, then an unpinned load would risk\n+        \/\/ floating above its range check.\n+        Node* pinned_clone = n_clone->pin_array_access_node();\n+        if (pinned_clone != nullptr) {\n+          register_new_node(pinned_clone, get_ctrl(n_clone));\n+          old_new.map(n->_idx, pinned_clone);\n+          _igvn.replace_node(n_clone, pinned_clone);\n+          n_clone = pinned_clone;\n+        }\n+      }\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":58,"deletions":3,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -730,0 +730,8 @@\n+  if (iff->Opcode() == Op_RangeCheck) {\n+    \/\/ Pin array access nodes: control is updated here to a region. If, after some transformations, only one path\n+    \/\/ into the region is left, an array load could become dependent on a condition that's not a range check for\n+    \/\/ that access. If that condition is replaced by an identical dominating one, then an unpinned load would risk\n+    \/\/ floating above its range check.\n+    pin_array_access_nodes_dependent_on(new_true);\n+    pin_array_access_nodes_dependent_on(new_false);\n+  }\n@@ -740,0 +748,15 @@\n+\n+void PhaseIdealLoop::pin_array_access_nodes_dependent_on(Node* ctrl) {\n+  for (DUIterator i = ctrl->outs(); ctrl->has_out(i); i++) {\n+    Node* use = ctrl->out(i);\n+    if (!use->depends_only_on_test()) {\n+      continue;\n+    }\n+    Node* pinned_clone = use->pin_array_access_node();\n+    if (pinned_clone != nullptr) {\n+      register_new_node(pinned_clone, get_ctrl(use));\n+      _igvn.replace_node(use, pinned_clone);\n+      --i;\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8323274\n+ * @summary partial peeling loop can cause an array load to become dependent on a test other than its range check\n+ * @run main\/othervm -XX:-UseOnStackReplacement -XX:-TieredCompilation -XX:-BackgroundCompilation TestArrayAccessAboveRCAfterPartialPeeling\n+ *\/\n+\n+public class TestArrayAccessAboveRCAfterPartialPeeling {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            test(array, 2, true, 1);\n+            test(array, 2, false, 1);\n+            inlined(array, 2, 42, true, 42, 1, 1);\n+            inlined(array, 2, 42, false, 42, 1, 1);\n+        }\n+        try {\n+            test(array, 2, true, -1);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+    }\n+\n+    private static int test(int[] array, int k, boolean flag, int j) {\n+        int l;\n+        for (l = 1; l < 2; l *= 2) {\n+\n+        }\n+        int m;\n+        for (m = 0; m < 42; m += l) {\n+\n+        }\n+        int n;\n+        for (n = 0; n < 10; n += m\/42) {\n+\n+        }\n+        return inlined(array, k, l, flag, m, n\/10, j);\n+    }\n+\n+    private static int inlined(int[] array, int k, int l, boolean flag, int m, int n, int j) {\n+        if (array == null) {\n+        }\n+        int[] otherArray = new int[100];\n+        int i = 0;\n+        int v = 0;\n+        if (k == m) {\n+        }\n+\n+        if (flag) {\n+            v += array[j];\n+            v += otherArray[i];\n+\n+            for (; ; ) {\n+                synchronized (new Object()) {\n+                }\n+                if (j >= 100) {\n+                    break;\n+                }\n+                if (k == 42) {\n+                }\n+                v += array[j];\n+                v += otherArray[i];\n+                if (i >= n) {\n+                    otherArray[i] = v;\n+                }\n+                v += array[j];\n+                if (l == 2) {\n+                    break;\n+                }\n+                i++;\n+                j *= 2;\n+                volatileField = 42;\n+                k = 2;\n+                l = 42;\n+            }\n+        } else {\n+            v += array[j];\n+            v += otherArray[i];\n+\n+            for (; ; ) {\n+                synchronized (new Object()) {\n+                }\n+                if (j >= 100) {\n+                    break;\n+                }\n+                if (k == 42) {\n+                }\n+                v += array[j];\n+                v += otherArray[i];\n+                if (i >= n) {\n+                    otherArray[i] = v;\n+                }\n+                v += array[j];\n+                if (l == 2) {\n+                    break;\n+                }\n+                i++;\n+                j *= 2;\n+                volatileField = 42;\n+                k = 2;\n+                l = 42;\n+            }\n+        }\n+        return v;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterPartialPeeling.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8323274\n+ * @summary sinking an array load out of loop can cause it to become dependent on a test other than its range check\n+ * @run main\/othervm -XX:-UseOnStackReplacement -XX:-TieredCompilation -XX:-BackgroundCompilation TestArrayAccessAboveRCAfterSinking\n+ *\/\n+\n+\n+import java.util.Arrays;\n+\n+public class TestArrayAccessAboveRCAfterSinking {\n+    public static void main(String[] args) {\n+        boolean[] allFalse = new boolean[100];\n+        boolean[] allTrue = new boolean[100];\n+        Arrays.fill(allTrue, true);\n+        int[] array = new int[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(allTrue, array, 0, true, 0);\n+            test1(allTrue, array, 0, false, 0);\n+            inlined1(allFalse, array, 2, 0);\n+            inlined1(allFalse, array, 42, 0);\n+            inlined1(allTrue, array, 2, 0);\n+            test2(allTrue, array, 0, true, 0);\n+            test2(allTrue, array, 0, false, 0);\n+            inlined2(allFalse, array, 2, 0);\n+            inlined2(allFalse, array, 42, 0);\n+            inlined2(allTrue, array, 2, 0);\n+        }\n+        try {\n+            test1(allTrue, array, -1, true, 0);\n+            test2(allTrue, array, -1, true, 0);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+    }\n+\n+    private static int test1(boolean[] flags, int[] array, int k, boolean flag, int v) {\n+        if (flags == null) {\n+        }\n+        if (array == null) {\n+        }\n+        int j = 1;\n+        for (; j < 2; j *= 2) {\n+        }\n+        int i;\n+        for (i = 0; i < 10; i += j) {\n+\n+        }\n+        if (flags[i - 10]) {\n+            if (flag) {\n+                return inlined1(flags, array, j, k);\n+            } else {\n+                return inlined1(flags, array, j, k) + v;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static int inlined1(boolean[] flags, int[] array, int j, int k) {\n+        for (int i = 0; i < 100; i++) {\n+            final boolean flag = flags[i & (j - 3)];\n+            int v = array[i + k];\n+            if (flag) {\n+                return v;\n+            }\n+            if (j + (i & (j - 2)) == 2) {\n+                break;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static int test2(boolean[] flags, int[] array, int k, boolean flag, int v) {\n+        if (flags == null) {\n+        }\n+        if (array == null) {\n+        }\n+        int j = 1;\n+        for (; j < 2; j *= 2) {\n+        }\n+        int i;\n+        for (i = 0; i < 10; i += j) {\n+\n+        }\n+        if (flags[i - 10]) {\n+            if (flag) {\n+                return inlined2(flags, array, j, k);\n+            } else {\n+                return inlined2(flags, array, j, k) + v;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    private static int inlined2(boolean[] flags, int[] array, int j, int k) {\n+        for (int i = 0; i < 100; i++) {\n+            int v = array[i + k];\n+            if (flags[i & (j - 3)]) {\n+                return v;\n+            }\n+            if (j + (i & (j - 2)) == 2) {\n+                break;\n+            }\n+        }\n+        return 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterSinking.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8323274\n+ * @summary split if can cause an array load to become dependent on a test other than its range check\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation TestArrayAccessAboveRCAfterSplitIf\n+ *\/\n+\n+public class TestArrayAccessAboveRCAfterSplitIf {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[1000];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(array, array, 0, 2, true);\n+            inlined1(42, array, array, 0, 2, 10, true);\n+            inlined1(2, array, array, 0, 2, 10, true);\n+            inlined1(42, array, array, 0, 2, 10, false);\n+            inlined1(2, array, array, 0, 2, 10, false);\n+            test2(array, array, 0, 2, true);\n+            inlined2(42, array, array, 0, 2, 10, true);\n+            inlined2(2, array, array, 0, 2, 10, true);\n+            inlined2(42, array, array, 0, 2, 10, false);\n+            inlined2(2, array, array, 0, 2, 10, false);\n+        }\n+        try {\n+            test1(array, array, -1, 2, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test2(array, array, -1, 2, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+    }\n+\n+    private static int test1(int[] array1, int[] array2, int i, int l, boolean flag) {\n+        for (int j = 0; j < 10; j++) {\n+        }\n+        int k;\n+        for (k = 1; k < 2; k *= 2) {\n+\n+        }\n+        int m;\n+        for (m = 0; m < 10; m+=k) {\n+\n+        }\n+        return inlined1(k, array1, array2, i, l, m, flag);\n+    }\n+\n+    private static int inlined1(int k, int[] array1, int[] array2, int i, int l, int m, boolean flag) {\n+        int v;\n+        int[] array;\n+        if (array1 == null) {\n+        }\n+        if (l == 10) {\n+\n+        }\n+        if (flag) {\n+            if (k == 2) {\n+                v = array1[i];\n+                array = array1;\n+                if (l == m) {\n+                }\n+            } else {\n+                v = array2[i];\n+                array = array2;\n+            }\n+            v += array[i];\n+            v += array2[i];\n+        } else {\n+            if (k == 2) {\n+                v = array1[i];\n+                array = array1;\n+                if (l == m) {\n+                }\n+            } else {\n+                v = array2[i];\n+                array = array2;\n+            }\n+            v += array[i];\n+            v += array2[i];\n+        }\n+        return v;\n+    }\n+\n+    private static int test2(int[] array1, int[] array2, int i, int l, boolean flag) {\n+        for (int j = 0; j < 10; j++) {\n+        }\n+        int k;\n+        for (k = 1; k < 2; k *= 2) {\n+\n+        }\n+        int m;\n+        for (m = 0; m < 10; m+=k) {\n+\n+        }\n+        return inlined2(k, array1, array2, i, l, m, flag);\n+    }\n+\n+    private static int inlined2(int k, int[] array1, int[] array2, int i, int l, int m, boolean flag) {\n+        int v;\n+        int[] array;\n+        if (array1 == null) {\n+        }\n+        if (l == 10) {\n+\n+        }\n+        if (flag) {\n+            if (k == 2) {\n+                v = array1[i];\n+                array = array1;\n+                if (l == m) {\n+                }\n+            } else {\n+                v = array2[i];\n+                array = array2;\n+            }\n+            if (Integer.compareUnsigned(i, array.length) >= 0) {\n+            }\n+            v += array[i];\n+            v += array2[i];\n+        } else {\n+            if (k == 2) {\n+                v = array1[i];\n+                array = array1;\n+                if (l == m) {\n+                }\n+            } else {\n+                v = array2[i];\n+                array = array2;\n+            }\n+            if (Integer.compareUnsigned(i, array.length) >= 0) {\n+            }\n+            v += array[i];\n+            v += array2[i];\n+        }\n+        return v;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterSplitIf.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8323274\n+ * @summary loop unswitching can cause an array load to become dependent on a test other than its range check\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:CompileOnly=TestArrayAccessAboveRCAfterUnswitching::test\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:StressSeed=148059521 TestArrayAccessAboveRCAfterUnswitching\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation -XX:CompileOnly=TestArrayAccessAboveRCAfterUnswitching::test\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestArrayAccessAboveRCAfterUnswitching\n+ *\/\n+\n+import java.util.Arrays;\n+\n+public class TestArrayAccessAboveRCAfterUnswitching {\n+    private static int field;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[1000];\n+        boolean[] allFalse = new boolean[1000];\n+        boolean[] allTrue = new boolean[1000];\n+        Arrays.fill(allTrue, true);\n+        for (int i = 0; i < 20_000; i++) {\n+            inlined(array, allFalse, 42, 2, 2, 0);\n+            inlined(array, allFalse, 2, 42, 2, 0);\n+            inlined(array, allFalse, 2, 2, 2, 0);\n+            inlined(array, allFalse, 2, 2, 42, 0);\n+            inlined(array, allTrue, 2, 2, 2, 0);\n+            test(array, allTrue, 0);\n+        }\n+        try {\n+            test(array, allTrue, -1);\n+        } catch (ArrayIndexOutOfBoundsException aioobe) {\n+        }\n+    }\n+\n+    private static int test(int[] array, boolean[] flags, int start) {\n+        if (flags == null) {\n+        }\n+        if (array == null) {\n+        }\n+        int j = 1;\n+        for (; j < 2; j *= 2) {\n+        }\n+        int k = 1;\n+        for (; k < 2; k *= 2) {\n+        }\n+        int l = 1;\n+        for (; l < 2; l *= 2) {\n+        }\n+        int i;\n+        for (i = 0; i < 10; i += l) {\n+\n+        }\n+        if (flags[i - 10]) {\n+            return inlined(array, flags, j, k, l, start);\n+        }\n+        return 0;\n+    }\n+\n+    private static int inlined(int[] array, boolean[] flags, int j, int k, int l, int start) {\n+        for (int i = 0; i < 100; i++) {\n+            final boolean flag = flags[i & (j - 3)];\n+            int v = array[(i + start) & (j - 3)];\n+            if (flag) {\n+                return v;\n+            }\n+            if (j != 2) {\n+                field = v;\n+            } else {\n+                if (k != 2) {\n+                    field = 42;\n+                } else {\n+                    if (l == 2) {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        return 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterUnswitching.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8323274\n+ * @summary converting an array copy to a series of loads\/stores add loads that can float\n+ * @run main\/othervm -XX:-UseOnStackReplacement -XX:-TieredCompilation -XX:-BackgroundCompilation TestArrayAccessAboveRCForArrayCopyLoad\n+ *\/\n+\n+public class TestArrayAccessAboveRCForArrayCopyLoad {\n+    public static void main(String[] args) {\n+        int[] array = new int[10];\n+        for (int i = 0; i < 20_000; i++) {\n+            test(array, 0, array, 1, false);\n+            test(array, 0, array, 1, true);\n+        }\n+        try {\n+            test(array, -1, array, 0, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+\n+        }\n+    }\n+\n+    private static void test(int[] src, int srcPos, int[] dst, int dstPos, boolean flag) {\n+        if (src == null) {\n+        }\n+        if (srcPos < dstPos) {\n+            if (flag) {\n+                System.arraycopy(src, srcPos, dst, dstPos, 2);\n+            } else {\n+                System.arraycopy(src, srcPos, dst, dstPos, 2);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCForArrayCopyLoad.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"}]}