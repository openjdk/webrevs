{"files":[{"patch":"@@ -175,304 +175,0 @@\n-#if INCLUDE_RTM_OPT\n-\n-\/\/ Update rtm_counters based on abort status\n-\/\/ input: abort_status\n-\/\/        rtm_counters (RTMLockingCounters*)\n-\/\/ flags are killed\n-void C2_MacroAssembler::rtm_counters_update(Register abort_status, Register rtm_counters) {\n-\n-  atomic_incptr(Address(rtm_counters, RTMLockingCounters::abort_count_offset()));\n-  if (PrintPreciseRTMLockingStatistics) {\n-    for (int i = 0; i < RTMLockingCounters::ABORT_STATUS_LIMIT; i++) {\n-      Label check_abort;\n-      testl(abort_status, (1<<i));\n-      jccb(Assembler::equal, check_abort);\n-      atomic_incptr(Address(rtm_counters, RTMLockingCounters::abortX_count_offset() + (i * sizeof(uintx))));\n-      bind(check_abort);\n-    }\n-  }\n-}\n-\n-\/\/ Branch if (random & (count-1) != 0), count is 2^n\n-\/\/ tmp, scr and flags are killed\n-void C2_MacroAssembler::branch_on_random_using_rdtsc(Register tmp, Register scr, int count, Label& brLabel) {\n-  assert(tmp == rax, \"\");\n-  assert(scr == rdx, \"\");\n-  rdtsc(); \/\/ modifies EDX:EAX\n-  andptr(tmp, count-1);\n-  jccb(Assembler::notZero, brLabel);\n-}\n-\n-\/\/ Perform abort ratio calculation, set no_rtm bit if high ratio\n-\/\/ input:  rtm_counters_Reg (RTMLockingCounters* address)\n-\/\/ tmpReg, rtm_counters_Reg and flags are killed\n-void C2_MacroAssembler::rtm_abort_ratio_calculation(Register tmpReg,\n-                                                    Register rtm_counters_Reg,\n-                                                    RTMLockingCounters* rtm_counters,\n-                                                    Metadata* method_data) {\n-  Label L_done, L_check_always_rtm1, L_check_always_rtm2;\n-\n-  if (RTMLockingCalculationDelay > 0) {\n-    \/\/ Delay calculation\n-    movptr(tmpReg, ExternalAddress((address) RTMLockingCounters::rtm_calculation_flag_addr()));\n-    testptr(tmpReg, tmpReg);\n-    jccb(Assembler::equal, L_done);\n-  }\n-  \/\/ Abort ratio calculation only if abort_count > RTMAbortThreshold\n-  \/\/   Aborted transactions = abort_count * 100\n-  \/\/   All transactions = total_count *  RTMTotalCountIncrRate\n-  \/\/   Set no_rtm bit if (Aborted transactions >= All transactions * RTMAbortRatio)\n-\n-  movptr(tmpReg, Address(rtm_counters_Reg, RTMLockingCounters::abort_count_offset()));\n-  cmpptr(tmpReg, RTMAbortThreshold);\n-  jccb(Assembler::below, L_check_always_rtm2);\n-  imulptr(tmpReg, tmpReg, 100);\n-\n-  Register scrReg = rtm_counters_Reg;\n-  movptr(scrReg, Address(rtm_counters_Reg, RTMLockingCounters::total_count_offset()));\n-  imulptr(scrReg, scrReg, RTMTotalCountIncrRate);\n-  imulptr(scrReg, scrReg, RTMAbortRatio);\n-  cmpptr(tmpReg, scrReg);\n-  jccb(Assembler::below, L_check_always_rtm1);\n-  if (method_data != nullptr) {\n-    \/\/ set rtm_state to \"no rtm\" in MDO\n-    mov_metadata(tmpReg, method_data);\n-    lock();\n-    orl(Address(tmpReg, MethodData::rtm_state_offset()), NoRTM);\n-  }\n-  jmpb(L_done);\n-  bind(L_check_always_rtm1);\n-  \/\/ Reload RTMLockingCounters* address\n-  lea(rtm_counters_Reg, ExternalAddress((address)rtm_counters));\n-  bind(L_check_always_rtm2);\n-  movptr(tmpReg, Address(rtm_counters_Reg, RTMLockingCounters::total_count_offset()));\n-  cmpptr(tmpReg, RTMLockingThreshold \/ RTMTotalCountIncrRate);\n-  jccb(Assembler::below, L_done);\n-  if (method_data != nullptr) {\n-    \/\/ set rtm_state to \"always rtm\" in MDO\n-    mov_metadata(tmpReg, method_data);\n-    lock();\n-    orl(Address(tmpReg, MethodData::rtm_state_offset()), UseRTM);\n-  }\n-  bind(L_done);\n-}\n-\n-\/\/ Update counters and perform abort ratio calculation\n-\/\/ input:  abort_status_Reg\n-\/\/ rtm_counters_Reg, flags are killed\n-void C2_MacroAssembler::rtm_profiling(Register abort_status_Reg,\n-                                      Register rtm_counters_Reg,\n-                                      RTMLockingCounters* rtm_counters,\n-                                      Metadata* method_data,\n-                                      bool profile_rtm) {\n-\n-  assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n-  \/\/ update rtm counters based on rax value at abort\n-  \/\/ reads abort_status_Reg, updates flags\n-  lea(rtm_counters_Reg, ExternalAddress((address)rtm_counters));\n-  rtm_counters_update(abort_status_Reg, rtm_counters_Reg);\n-  if (profile_rtm) {\n-    \/\/ Save abort status because abort_status_Reg is used by following code.\n-    if (RTMRetryCount > 0) {\n-      push(abort_status_Reg);\n-    }\n-    assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n-    rtm_abort_ratio_calculation(abort_status_Reg, rtm_counters_Reg, rtm_counters, method_data);\n-    \/\/ restore abort status\n-    if (RTMRetryCount > 0) {\n-      pop(abort_status_Reg);\n-    }\n-  }\n-}\n-\n-\/\/ Retry on abort if abort's status is 0x6: can retry (0x2) | memory conflict (0x4)\n-\/\/ inputs: retry_count_Reg\n-\/\/       : abort_status_Reg\n-\/\/ output: retry_count_Reg decremented by 1\n-\/\/ flags are killed\n-void C2_MacroAssembler::rtm_retry_lock_on_abort(Register retry_count_Reg, Register abort_status_Reg, Label& retryLabel) {\n-  Label doneRetry;\n-  assert(abort_status_Reg == rax, \"\");\n-  \/\/ The abort reason bits are in eax (see all states in rtmLocking.hpp)\n-  \/\/ 0x6 = conflict on which we can retry (0x2) | memory conflict (0x4)\n-  \/\/ if reason is in 0x6 and retry count != 0 then retry\n-  andptr(abort_status_Reg, 0x6);\n-  jccb(Assembler::zero, doneRetry);\n-  testl(retry_count_Reg, retry_count_Reg);\n-  jccb(Assembler::zero, doneRetry);\n-  pause();\n-  decrementl(retry_count_Reg);\n-  jmp(retryLabel);\n-  bind(doneRetry);\n-}\n-\n-\/\/ Spin and retry if lock is busy,\n-\/\/ inputs: box_Reg (monitor address)\n-\/\/       : retry_count_Reg\n-\/\/ output: retry_count_Reg decremented by 1\n-\/\/       : clear z flag if retry count exceeded\n-\/\/ tmp_Reg, scr_Reg, flags are killed\n-void C2_MacroAssembler::rtm_retry_lock_on_busy(Register retry_count_Reg, Register box_Reg,\n-                                               Register tmp_Reg, Register scr_Reg, Label& retryLabel) {\n-  Label SpinLoop, SpinExit, doneRetry;\n-  int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);\n-\n-  testl(retry_count_Reg, retry_count_Reg);\n-  jccb(Assembler::zero, doneRetry);\n-  decrementl(retry_count_Reg);\n-  movptr(scr_Reg, RTMSpinLoopCount);\n-\n-  bind(SpinLoop);\n-  pause();\n-  decrementl(scr_Reg);\n-  jccb(Assembler::lessEqual, SpinExit);\n-  movptr(tmp_Reg, Address(box_Reg, owner_offset));\n-  testptr(tmp_Reg, tmp_Reg);\n-  jccb(Assembler::notZero, SpinLoop);\n-\n-  bind(SpinExit);\n-  jmp(retryLabel);\n-  bind(doneRetry);\n-  incrementl(retry_count_Reg); \/\/ clear z flag\n-}\n-\n-\/\/ Use RTM for normal stack locks\n-\/\/ Input: objReg (object to lock)\n-void C2_MacroAssembler::rtm_stack_locking(Register objReg, Register tmpReg, Register scrReg,\n-                                         Register retry_on_abort_count_Reg,\n-                                         RTMLockingCounters* stack_rtm_counters,\n-                                         Metadata* method_data, bool profile_rtm,\n-                                         Label& DONE_LABEL, Label& IsInflated) {\n-  assert(UseRTMForStackLocks, \"why call this otherwise?\");\n-  assert(tmpReg == rax, \"\");\n-  assert(scrReg == rdx, \"\");\n-  Label L_rtm_retry, L_decrement_retry, L_on_abort;\n-\n-  if (RTMRetryCount > 0) {\n-    movl(retry_on_abort_count_Reg, RTMRetryCount); \/\/ Retry on abort\n-    bind(L_rtm_retry);\n-  }\n-  movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));\n-  testptr(tmpReg, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral\n-  jcc(Assembler::notZero, IsInflated);\n-\n-  if (PrintPreciseRTMLockingStatistics || profile_rtm) {\n-    Label L_noincrement;\n-    if (RTMTotalCountIncrRate > 1) {\n-      \/\/ tmpReg, scrReg and flags are killed\n-      branch_on_random_using_rdtsc(tmpReg, scrReg, RTMTotalCountIncrRate, L_noincrement);\n-    }\n-    assert(stack_rtm_counters != nullptr, \"should not be null when profiling RTM\");\n-    atomic_incptr(ExternalAddress((address)stack_rtm_counters->total_count_addr()), scrReg);\n-    bind(L_noincrement);\n-  }\n-  xbegin(L_on_abort);\n-  movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));       \/\/ fetch markword\n-  andptr(tmpReg, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n-  cmpptr(tmpReg, markWord::unlocked_value);         \/\/ bits = 01 unlocked\n-  jcc(Assembler::equal, DONE_LABEL);        \/\/ all done if unlocked\n-\n-  Register abort_status_Reg = tmpReg; \/\/ status of abort is stored in RAX\n-  if (UseRTMXendForLockBusy) {\n-    xend();\n-    movptr(abort_status_Reg, 0x2);   \/\/ Set the abort status to 2 (so we can retry)\n-    jmp(L_decrement_retry);\n-  }\n-  else {\n-    xabort(0);\n-  }\n-  bind(L_on_abort);\n-  if (PrintPreciseRTMLockingStatistics || profile_rtm) {\n-    rtm_profiling(abort_status_Reg, scrReg, stack_rtm_counters, method_data, profile_rtm);\n-  }\n-  bind(L_decrement_retry);\n-  if (RTMRetryCount > 0) {\n-    \/\/ retry on lock abort if abort status is 'can retry' (0x2) or 'memory conflict' (0x4)\n-    rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry);\n-  }\n-}\n-\n-\/\/ Use RTM for inflating locks\n-\/\/ inputs: objReg (object to lock)\n-\/\/         boxReg (on-stack box address (displaced header location) - KILLED)\n-\/\/         tmpReg (ObjectMonitor address + markWord::monitor_value)\n-void C2_MacroAssembler::rtm_inflated_locking(Register objReg, Register boxReg, Register tmpReg,\n-                                            Register scrReg, Register retry_on_busy_count_Reg,\n-                                            Register retry_on_abort_count_Reg,\n-                                            RTMLockingCounters* rtm_counters,\n-                                            Metadata* method_data, bool profile_rtm,\n-                                            Label& DONE_LABEL) {\n-  assert(UseRTMLocking, \"why call this otherwise?\");\n-  assert(tmpReg == rax, \"\");\n-  assert(scrReg == rdx, \"\");\n-  Label L_rtm_retry, L_decrement_retry, L_on_abort;\n-  int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);\n-\n-  movptr(Address(boxReg, 0), checked_cast<int32_t>(markWord::unused_mark().value()));\n-  movptr(boxReg, tmpReg); \/\/ Save ObjectMonitor address\n-\n-  if (RTMRetryCount > 0) {\n-    movl(retry_on_busy_count_Reg, RTMRetryCount);  \/\/ Retry on lock busy\n-    movl(retry_on_abort_count_Reg, RTMRetryCount); \/\/ Retry on abort\n-    bind(L_rtm_retry);\n-  }\n-  if (PrintPreciseRTMLockingStatistics || profile_rtm) {\n-    Label L_noincrement;\n-    if (RTMTotalCountIncrRate > 1) {\n-      \/\/ tmpReg, scrReg and flags are killed\n-      branch_on_random_using_rdtsc(tmpReg, scrReg, RTMTotalCountIncrRate, L_noincrement);\n-    }\n-    assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n-    atomic_incptr(ExternalAddress((address)rtm_counters->total_count_addr()), scrReg);\n-    bind(L_noincrement);\n-  }\n-  xbegin(L_on_abort);\n-  movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes()));\n-  movptr(tmpReg, Address(tmpReg, owner_offset));\n-  testptr(tmpReg, tmpReg);\n-  jcc(Assembler::zero, DONE_LABEL);\n-  if (UseRTMXendForLockBusy) {\n-    xend();\n-    jmp(L_decrement_retry);\n-  }\n-  else {\n-    xabort(0);\n-  }\n-  bind(L_on_abort);\n-  Register abort_status_Reg = tmpReg; \/\/ status of abort is stored in RAX\n-  if (PrintPreciseRTMLockingStatistics || profile_rtm) {\n-    rtm_profiling(abort_status_Reg, scrReg, rtm_counters, method_data, profile_rtm);\n-  }\n-  if (RTMRetryCount > 0) {\n-    \/\/ retry on lock abort if abort status is 'can retry' (0x2) or 'memory conflict' (0x4)\n-    rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry);\n-  }\n-\n-  movptr(tmpReg, Address(boxReg, owner_offset)) ;\n-  testptr(tmpReg, tmpReg) ;\n-  jccb(Assembler::notZero, L_decrement_retry) ;\n-\n-  \/\/ Appears unlocked - try to swing _owner from null to non-null.\n-  \/\/ Invariant: tmpReg == 0.  tmpReg is EAX which is the implicit cmpxchg comparand.\n-#ifdef _LP64\n-  Register threadReg = r15_thread;\n-#else\n-  get_thread(scrReg);\n-  Register threadReg = scrReg;\n-#endif\n-  lock();\n-  cmpxchgptr(threadReg, Address(boxReg, owner_offset)); \/\/ Updates tmpReg\n-\n-  if (RTMRetryCount > 0) {\n-    \/\/ success done else retry\n-    jccb(Assembler::equal, DONE_LABEL) ;\n-    bind(L_decrement_retry);\n-    \/\/ Spin and retry if lock is busy.\n-    rtm_retry_lock_on_busy(retry_on_busy_count_Reg, boxReg, tmpReg, scrReg, L_rtm_retry);\n-  }\n-  else {\n-    bind(L_decrement_retry);\n-  }\n-}\n-\n-#endif \/\/  INCLUDE_RTM_OPT\n-\n@@ -557,4 +253,1 @@\n-                                 RTMLockingCounters* rtm_counters,\n-                                 RTMLockingCounters* stack_rtm_counters,\n-                                 Metadata* method_data,\n-                                 bool use_rtm, bool profile_rtm) {\n+                                 Metadata* method_data) {\n@@ -564,8 +257,3 @@\n-\n-  if (use_rtm) {\n-    assert_different_registers(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg);\n-  } else {\n-    assert(cx1Reg == noreg, \"\");\n-    assert(cx2Reg == noreg, \"\");\n-    assert_different_registers(objReg, boxReg, tmpReg, scrReg);\n-  }\n+  assert(cx1Reg == noreg, \"\");\n+  assert(cx2Reg == noreg, \"\");\n+  assert_different_registers(objReg, boxReg, tmpReg, scrReg);\n@@ -597,9 +285,0 @@\n-#if INCLUDE_RTM_OPT\n-  if (UseRTMForStackLocks && use_rtm) {\n-    assert(LockingMode != LM_MONITOR, \"LockingMode == 0 (LM_MONITOR) and +UseRTMForStackLocks are mutually exclusive\");\n-    rtm_stack_locking(objReg, tmpReg, scrReg, cx2Reg,\n-                      stack_rtm_counters, method_data, profile_rtm,\n-                      DONE_LABEL, IsInflated);\n-  }\n-#endif \/\/ INCLUDE_RTM_OPT\n-\n@@ -635,8 +314,0 @@\n-#if INCLUDE_RTM_OPT\n-  \/\/ Use the same RTM locking code in 32- and 64-bit VM.\n-  if (use_rtm) {\n-    rtm_inflated_locking(objReg, boxReg, tmpReg, scrReg, cx1Reg, cx2Reg,\n-                         rtm_counters, method_data, profile_rtm, DONE_LABEL);\n-  } else {\n-#endif \/\/ INCLUDE_RTM_OPT\n-\n@@ -703,3 +374,0 @@\n-#if INCLUDE_RTM_OPT\n-  } \/\/ use_rtm()\n-#endif\n@@ -758,1 +426,1 @@\n-void C2_MacroAssembler::fast_unlock(Register objReg, Register boxReg, Register tmpReg, bool use_rtm) {\n+void C2_MacroAssembler::fast_unlock(Register objReg, Register boxReg, Register tmpReg) {\n@@ -765,14 +433,0 @@\n-#if INCLUDE_RTM_OPT\n-  if (UseRTMForStackLocks && use_rtm) {\n-    assert(LockingMode != LM_MONITOR, \"LockingMode == 0 (LM_MONITOR) and +UseRTMForStackLocks are mutually exclusive\");\n-    Label L_regular_unlock;\n-    movptr(tmpReg, Address(objReg, oopDesc::mark_offset_in_bytes())); \/\/ fetch markword\n-    andptr(tmpReg, markWord::lock_mask_in_place);                     \/\/ look at 2 lock bits\n-    cmpptr(tmpReg, markWord::unlocked_value);                         \/\/ bits = 01 unlocked\n-    jccb(Assembler::notEqual, L_regular_unlock);                      \/\/ if !HLE RegularLock\n-    xend();                                                           \/\/ otherwise end...\n-    jmp(DONE_LABEL);                                                  \/\/ ... and we're done\n-    bind(L_regular_unlock);\n-  }\n-#endif\n-\n@@ -791,13 +445,0 @@\n-#if INCLUDE_RTM_OPT\n-  if (use_rtm) {\n-    Label L_regular_inflated_unlock;\n-    int owner_offset = OM_OFFSET_NO_MONITOR_VALUE_TAG(owner);\n-    movptr(boxReg, Address(tmpReg, owner_offset));\n-    testptr(boxReg, boxReg);\n-    jccb(Assembler::notZero, L_regular_inflated_unlock);\n-    xend();\n-    jmp(DONE_LABEL);\n-    bind(L_regular_inflated_unlock);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":5,"deletions":364,"binary":false,"changes":369,"status":"modified"},{"patch":"@@ -40,5 +40,2 @@\n-                 RTMLockingCounters* rtm_counters,\n-                 RTMLockingCounters* stack_rtm_counters,\n-                 Metadata* method_data,\n-                 bool use_rtm, bool profile_rtm);\n-  void fast_unlock(Register obj, Register box, Register tmp, bool use_rtm);\n+                 Metadata* method_data);\n+  void fast_unlock(Register obj, Register box, Register tmp);\n@@ -50,23 +47,0 @@\n-#if INCLUDE_RTM_OPT\n-  void rtm_counters_update(Register abort_status, Register rtm_counters);\n-  void branch_on_random_using_rdtsc(Register tmp, Register scr, int count, Label& brLabel);\n-  void rtm_abort_ratio_calculation(Register tmp, Register rtm_counters_reg,\n-                                   RTMLockingCounters* rtm_counters,\n-                                   Metadata* method_data);\n-  void rtm_profiling(Register abort_status_Reg, Register rtm_counters_Reg,\n-                     RTMLockingCounters* rtm_counters, Metadata* method_data, bool profile_rtm);\n-  void rtm_retry_lock_on_abort(Register retry_count, Register abort_status, Label& retryLabel);\n-  void rtm_retry_lock_on_busy(Register retry_count, Register box, Register tmp, Register scr, Label& retryLabel);\n-  void rtm_stack_locking(Register obj, Register tmp, Register scr,\n-                         Register retry_on_abort_count,\n-                         RTMLockingCounters* stack_rtm_counters,\n-                         Metadata* method_data, bool profile_rtm,\n-                         Label& DONE_LABEL, Label& IsInflated);\n-  void rtm_inflated_locking(Register obj, Register box, Register tmp,\n-                            Register scr, Register retry_on_busy_count,\n-                            Register retry_on_abort_count,\n-                            RTMLockingCounters* rtm_counters,\n-                            Metadata* method_data, bool profile_rtm,\n-                            Label& DONE_LABEL);\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":28,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,5 +55,0 @@\n-#if defined(COMPILER2)\n-\/\/ Include Restricted Transactional Memory lock eliding optimization\n-#define INCLUDE_RTM_OPT 1\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/globalDefinitions_x86.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -154,45 +154,0 @@\n-  \/* Use Restricted Transactional Memory for lock eliding *\/                \\\n-  product(bool, UseRTMLocking, false,                                       \\\n-          \"(Deprecated) Enable RTM lock eliding for inflated locks \"        \\\n-          \"in compiled code\")                                               \\\n-                                                                            \\\n-  product(bool, UseRTMForStackLocks, false, EXPERIMENTAL,                   \\\n-          \"Enable RTM lock eliding for stack locks in compiled code\")       \\\n-                                                                            \\\n-  product(bool, UseRTMDeopt, false,                                         \\\n-          \"(Deprecated) Perform deopt and recompilation based on \"          \\\n-          \"RTM abort ratio\")                                                \\\n-                                                                            \\\n-  product(int, RTMRetryCount, 5,                                            \\\n-          \"(Deprecated) Number of RTM retries on lock abort or busy\")       \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(int, RTMSpinLoopCount, 100, EXPERIMENTAL,                         \\\n-          \"Spin count for lock to become free before RTM retry\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(int, RTMAbortThreshold, 1000, EXPERIMENTAL,                       \\\n-          \"Calculate abort ratio after this number of aborts\")              \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(int, RTMLockingThreshold, 10000, EXPERIMENTAL,                    \\\n-          \"Lock count at which to do RTM lock eliding without \"             \\\n-          \"abort ratio calculation\")                                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(int, RTMAbortRatio, 50, EXPERIMENTAL,                             \\\n-          \"Lock abort ratio at which to stop use RTM lock eliding\")         \\\n-          range(0, 100) \/* natural range *\/                                 \\\n-                                                                            \\\n-  product(int, RTMTotalCountIncrRate, 64, EXPERIMENTAL,                     \\\n-          \"Increment total RTM attempted lock count once every n times\")    \\\n-          range(1, max_jint)                                                \\\n-          constraint(RTMTotalCountIncrRateConstraintFunc,AfterErgo)         \\\n-                                                                            \\\n-  product(intx, RTMLockingCalculationDelay, 0, EXPERIMENTAL,                \\\n-          \"Number of milliseconds to wait before start calculating aborts \" \\\n-          \"for RTM locking\")                                                \\\n-                                                                            \\\n-  product(bool, UseRTMXendForLockBusy, true, EXPERIMENTAL,                  \\\n-          \"Use RTM Xend instead of Xabort when lock busy\")                  \\\n-                                                                            \\\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"runtime\/rtmLocking.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1479,7 +1479,0 @@\n-  if (UseRTMLocking) {\n-    \/\/ Abort RTM transaction before calling JNI\n-    \/\/ because critical section will be large and will be\n-    \/\/ aborted anyway. Also nmethod could be deoptimized.\n-    __ xabort(0);\n-  }\n-\n@@ -2425,5 +2418,0 @@\n-  if (UseRTMLocking) {\n-    \/\/ Abort RTM transaction before possible nmethod deoptimization.\n-    __ xabort(0);\n-  }\n-\n@@ -2612,7 +2600,0 @@\n-  if (UseRTMLocking) {\n-    \/\/ Abort RTM transaction before calling runtime\n-    \/\/ because critical section will be large and will be\n-    \/\/ aborted anyway. Also nmethod could be deoptimized.\n-    __ xabort(0);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1962,7 +1962,0 @@\n-    if (UseRTMLocking) {\n-      \/\/ Abort RTM transaction before calling JNI\n-      \/\/ because critical section will be large and will be\n-      \/\/ aborted anyway. Also nmethod could be deoptimized.\n-      __ xabort(0);\n-    }\n-\n@@ -2924,5 +2917,0 @@\n-  if (UseRTMLocking) {\n-    \/\/ Abort RTM transaction before possible nmethod deoptimization.\n-    __ xabort(0);\n-  }\n-\n@@ -3115,7 +3103,0 @@\n-  if (UseRTMLocking) {\n-    \/\/ Abort RTM transaction before calling runtime\n-    \/\/ because critical section will be large and will be\n-    \/\/ aborted anyway. Also nmethod could be deoptimized.\n-    __ xabort(0);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1249,49 +1249,0 @@\n-  if (!supports_rtm() && UseRTMLocking) {\n-    vm_exit_during_initialization(\"RTM instructions are not available on this CPU\");\n-  }\n-\n-#if INCLUDE_RTM_OPT\n-  if (UseRTMLocking) {\n-    if (!CompilerConfig::is_c2_enabled()) {\n-      \/\/ Only C2 does RTM locking optimization.\n-      vm_exit_during_initialization(\"RTM locking optimization is not supported in this VM\");\n-    }\n-    if (is_intel_family_core()) {\n-      if ((_model == CPU_MODEL_HASWELL_E3) ||\n-          (_model == CPU_MODEL_HASWELL_E7 && _stepping < 3) ||\n-          (_model == CPU_MODEL_BROADWELL  && _stepping < 4)) {\n-        \/\/ currently a collision between SKL and HSW_E3\n-        if (!UnlockExperimentalVMOptions && UseAVX < 3) {\n-          vm_exit_during_initialization(\"UseRTMLocking is only available as experimental option on this \"\n-                                        \"platform. It must be enabled via -XX:+UnlockExperimentalVMOptions flag.\");\n-        } else {\n-          warning(\"UseRTMLocking is only available as experimental option on this platform.\");\n-        }\n-      }\n-    }\n-    if (!FLAG_IS_CMDLINE(UseRTMLocking)) {\n-      \/\/ RTM locking should be used only for applications with\n-      \/\/ high lock contention. For now we do not use it by default.\n-      vm_exit_during_initialization(\"UseRTMLocking flag should be only set on command line\");\n-    }\n-  } else { \/\/ !UseRTMLocking\n-    if (UseRTMForStackLocks) {\n-      if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {\n-        warning(\"UseRTMForStackLocks flag should be off when UseRTMLocking flag is off\");\n-      }\n-      FLAG_SET_DEFAULT(UseRTMForStackLocks, false);\n-    }\n-    if (UseRTMDeopt) {\n-      FLAG_SET_DEFAULT(UseRTMDeopt, false);\n-    }\n-    if (PrintPreciseRTMLockingStatistics) {\n-      FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);\n-    }\n-  }\n-#else\n-  if (UseRTMLocking) {\n-    \/\/ Only C2 does RTM locking optimization.\n-    vm_exit_during_initialization(\"RTM locking optimization is not supported in this VM\");\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":0,"deletions":49,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -13616,17 +13616,0 @@\n-instruct cmpFastLockRTM(eFlagsReg cr, eRegP object, eBXRegP box, eAXRegI tmp, eDXRegI scr, rRegI cx1, rRegI cx2, eRegP thread) %{\n-  predicate(Compile::current()->use_rtm());\n-  match(Set cr (FastLock object box));\n-  effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box, TEMP thread);\n-  ins_cost(300);\n-  format %{ \"FASTLOCK $object,$box\\t! kills $box,$tmp,$scr,$cx1,$cx2\" %}\n-  ins_encode %{\n-    __ get_thread($thread$$Register);\n-    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,\n-                 $scr$$Register, $cx1$$Register, $cx2$$Register, $thread$$Register,\n-                 _rtm_counters, _stack_rtm_counters,\n-                 ((Method*)(ra_->C->method()->constant_encoding()))->method_data(),\n-                 true, ra_->C->profile_rtm());\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -13634,1 +13617,1 @@\n-  predicate(LockingMode != LM_LIGHTWEIGHT && !Compile::current()->use_rtm());\n+  predicate(LockingMode != LM_LIGHTWEIGHT);\n@@ -13642,1 +13625,1 @@\n-                 $scr$$Register, noreg, noreg, $thread$$Register, nullptr, nullptr, nullptr, false, false);\n+                 $scr$$Register, noreg, noreg, $thread$$Register, nullptr);\n@@ -13654,1 +13637,1 @@\n-    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_->C->use_rtm());\n+    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -12263,16 +12263,0 @@\n-instruct cmpFastLockRTM(rFlagsReg cr, rRegP object, rbx_RegP box, rax_RegI tmp, rdx_RegI scr, rRegI cx1, rRegI cx2) %{\n-  predicate(Compile::current()->use_rtm());\n-  match(Set cr (FastLock object box));\n-  effect(TEMP tmp, TEMP scr, TEMP cx1, TEMP cx2, USE_KILL box);\n-  ins_cost(300);\n-  format %{ \"fastlock $object,$box\\t! kills $box,$tmp,$scr,$cx1,$cx2\" %}\n-  ins_encode %{\n-    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register,\n-                 $scr$$Register, $cx1$$Register, $cx2$$Register, r15_thread,\n-                 _rtm_counters, _stack_rtm_counters,\n-                 ((Method*)(ra_->C->method()->constant_encoding()))->method_data(),\n-                 true, ra_->C->profile_rtm());\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -12280,1 +12264,1 @@\n-  predicate(LockingMode != LM_LIGHTWEIGHT && !Compile::current()->use_rtm());\n+  predicate(LockingMode != LM_LIGHTWEIGHT);\n@@ -12287,1 +12271,1 @@\n-                 $scr$$Register, noreg, noreg, r15_thread, nullptr, nullptr, nullptr, false, false);\n+                 $scr$$Register, noreg, noreg, r15_thread, nullptr);\n@@ -12299,1 +12283,1 @@\n-    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, ra_->C->use_rtm());\n+    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":3,"deletions":19,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1617,5 +1617,0 @@\n-      if (node->is_ideal_fastlock() && new_inst->is_ideal_fastlock()) {\n-        fprintf(fp, \"  ((MachFastLockNode*)n%d)->_rtm_counters = _rtm_counters;\\n\", cnt);\n-        fprintf(fp, \"  ((MachFastLockNode*)n%d)->_stack_rtm_counters = _stack_rtm_counters;\\n\", cnt);\n-      }\n-\n@@ -4011,4 +4006,0 @@\n-  if( inst->is_ideal_fastlock() ) {\n-    fprintf(fp_cpp, \"%s node->_rtm_counters = _leaf->as_FastLock()->rtm_counters();\\n\", indent);\n-    fprintf(fp_cpp, \"%s node->_stack_rtm_counters = _leaf->as_FastLock()->stack_rtm_counters();\\n\", indent);\n-  }\n","filename":"src\/hotspot\/share\/adlc\/output_c.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1035,2 +1035,1 @@\n-                            int immediate_oops_patched,\n-                            RTMState  rtm_state) {\n+                            int immediate_oops_patched) {\n@@ -1093,8 +1092,0 @@\n-#if INCLUDE_RTM_OPT\n-    if (!failing() && (rtm_state != NoRTM) &&\n-        (method()->method_data() != nullptr) &&\n-        (method()->method_data()->rtm_state() != rtm_state)) {\n-      \/\/ Preemptive decompile if rtm state was changed.\n-      record_failure(\"RTM state change invalidated rtm code\");\n-    }\n-#endif\n@@ -1137,3 +1128,0 @@\n-#if INCLUDE_RTM_OPT\n-      nm->set_rtm_state(rtm_state);\n-#endif\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -386,2 +386,1 @@\n-                       int                       immediate_oops_patched,\n-                       RTMState                  rtm_state = NoRTM);\n+                       int                       immediate_oops_patched);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -482,11 +482,0 @@\n-#if INCLUDE_RTM_OPT\n-  \/\/ return cached value\n-  int rtm_state() {\n-    if (is_empty()) {\n-      return NoRTM;\n-    } else {\n-      return get_MethodData()->rtm_state();\n-    }\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1232,3 +1232,0 @@\n-#if INCLUDE_RTM_OPT\n-  _rtm_state                  = NoRTM;\n-#endif\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -263,6 +263,0 @@\n-#if INCLUDE_RTM_OPT\n-  \/\/ RTM state at compile time. Used during deoptimization to decide\n-  \/\/ whether to restart collecting RTM locking abort statistic again.\n-  RTMState _rtm_state;\n-#endif\n-\n@@ -632,6 +626,0 @@\n-#if INCLUDE_RTM_OPT\n-  \/\/ rtm state accessing and manipulating\n-  RTMState  rtm_state() const          { return _rtm_state; }\n-  void set_rtm_state(RTMState state)   { _rtm_state = state; }\n-#endif\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -101,17 +101,0 @@\n-\n-\/\/ States of Restricted Transactional Memory usage.\n-enum RTMState: u1 {\n-  NoRTM      = 0x2, \/\/ Don't use RTM\n-  UseRTM     = 0x1, \/\/ Use RTM\n-  ProfileRTM = 0x0  \/\/ Use RTM with abort ratio calculation\n-};\n-\n-#ifndef INCLUDE_RTM_OPT\n-#define INCLUDE_RTM_OPT 0\n-#endif\n-#if INCLUDE_RTM_OPT\n-#define RTM_OPT_ONLY(code) code\n-#else\n-#define RTM_OPT_ONLY(code)\n-#endif\n-\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -80,2 +80,0 @@\n-  option(NoRTMLockEliding,  \"NoRTMLockEliding\",  Bool) \\\n-  option(UseRTMLockEliding, \"UseRTMLockEliding\", Bool) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1336,15 +1336,0 @@\n-#if INCLUDE_RTM_OPT\n-  _rtm_state = NoRTM; \/\/ No RTM lock eliding by default\n-  if (UseRTMLocking &&\n-      !CompilerOracle::has_option(mh, CompileCommandEnum::NoRTMLockEliding)) {\n-    if (CompilerOracle::has_option(mh, CompileCommandEnum::UseRTMLockEliding) || !UseRTMDeopt) {\n-      \/\/ Generate RTM lock eliding code without abort ratio calculation code.\n-      _rtm_state = UseRTM;\n-    } else if (UseRTMDeopt) {\n-      \/\/ Generate RTM lock eliding code and include abort ratio calculation\n-      \/\/ code if UseRTMDeopt is on.\n-      _rtm_state = ProfileRTM;\n-    }\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2073,5 +2073,0 @@\n-#if INCLUDE_RTM_OPT\n-  \/\/ State of RTM code generation during compilation of the method\n-  int               _rtm_state;\n-#endif\n-\n@@ -2273,16 +2268,0 @@\n-#if INCLUDE_RTM_OPT\n-  int rtm_state() const {\n-    return _rtm_state;\n-  }\n-  void set_rtm_state(RTMState rstate) {\n-    _rtm_state = (int)rstate;\n-  }\n-  void atomic_set_rtm_state(RTMState rstate) {\n-    Atomic::store(&_rtm_state, (int)rstate);\n-  }\n-\n-  static ByteSize rtm_state_offset() {\n-    return byte_offset_of(MethodData, _rtm_state);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -460,3 +460,0 @@\n-  product(bool, PrintPreciseRTMLockingStatistics, false, DIAGNOSTIC,        \\\n-          \"Print per-lock-site statistics of rtm locking in JVM\")           \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -272,1 +272,0 @@\n-macro(Opaque3)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -716,1 +716,1 @@\n-  if (ProfileTraps RTM_OPT_ONLY( || UseRTMLocking )) {\n+  if (ProfileTraps) {\n@@ -719,1 +719,0 @@\n-    \/\/ Need MDO to record RTM code generation state.\n@@ -1078,1 +1077,0 @@\n-  set_rtm_state(NoRTM); \/\/ No RTM lock eliding by default\n@@ -1081,16 +1079,0 @@\n-#if INCLUDE_RTM_OPT\n-  if (UseRTMLocking && has_method() && (method()->method_data_or_null() != nullptr)) {\n-    int rtm_state = method()->method_data()->rtm_state();\n-    if (method_has_option(CompileCommandEnum::NoRTMLockEliding) || ((rtm_state & NoRTM) != 0)) {\n-      \/\/ Don't generate RTM lock eliding code.\n-      set_rtm_state(NoRTM);\n-    } else if (method_has_option(CompileCommandEnum::UseRTMLockEliding) || ((rtm_state & UseRTM) != 0) || !UseRTMDeopt) {\n-      \/\/ Generate RTM lock eliding code without abort ratio calculation code.\n-      set_rtm_state(UseRTM);\n-    } else if (UseRTMDeopt) {\n-      \/\/ Generate RTM lock eliding code and include abort ratio calculation\n-      \/\/ code if UseRTMDeopt is on.\n-      set_rtm_state(ProfileRTM);\n-    }\n-  }\n-#endif\n@@ -3225,1 +3207,0 @@\n-  case Op_Opaque3:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -358,1 +358,0 @@\n-  RTMState              _rtm_state;             \/\/ State of Restricted Transactional Memory usage\n@@ -670,4 +669,0 @@\n-  RTMState          rtm_state()  const           { return _rtm_state; }\n-  void          set_rtm_state(RTMState s)        { _rtm_state = s; }\n-  bool              use_rtm() const              { return (_rtm_state & NoRTM) == 0; }\n-  bool          profile_rtm() const              { return _rtm_state == ProfileRTM; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3494,3 +3494,0 @@\n-  \/\/ Create the rtm counters for this fast lock if needed.\n-  flock->create_rtm_lock_counter(sync_jvms()); \/\/ sync_jvms used to get current bci\n-\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -197,16 +197,0 @@\n-void FastLockNode::create_rtm_lock_counter(JVMState* state) {\n-#if INCLUDE_RTM_OPT\n-  Compile* C = Compile::current();\n-  if (C->profile_rtm() || (PrintPreciseRTMLockingStatistics && C->use_rtm())) {\n-    RTMLockingNamedCounter* rlnc = (RTMLockingNamedCounter*)\n-           OptoRuntime::new_named_counter(state, NamedCounter::RTMLockingCounter);\n-    _rtm_counters = rlnc->counters();\n-    if (UseRTMForStackLocks) {\n-      rlnc = (RTMLockingNamedCounter*)\n-           OptoRuntime::new_named_counter(state, NamedCounter::RTMLockingCounter);\n-      _stack_rtm_counters = rlnc->counters();\n-    }\n-  }\n-#endif\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-class RTMLockingCounters;\n-\n@@ -133,4 +131,0 @@\n-private:\n-  RTMLockingCounters*       _rtm_counters; \/\/ RTM lock counters for inflated locks\n-  RTMLockingCounters* _stack_rtm_counters; \/\/ RTM lock counters for stack locks\n-\n@@ -141,2 +135,0 @@\n-    _rtm_counters = nullptr;\n-    _stack_rtm_counters = nullptr;\n@@ -156,4 +148,0 @@\n-\n-  void create_rtm_lock_counter(JVMState* state);\n-  RTMLockingCounters*       rtm_counters() const { return _rtm_counters; }\n-  RTMLockingCounters* stack_rtm_counters() const { return _stack_rtm_counters; }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -904,9 +904,0 @@\n-#if INCLUDE_RTM_OPT\n-      case Op_FastLock:\n-      case Op_FastUnlock: {\n-        \/\/ Don't unroll RTM locking code because it is large.\n-        if (UseRTMLocking) {\n-          return false;\n-        }\n-      }\n-#endif\n@@ -1077,9 +1068,0 @@\n-#if INCLUDE_RTM_OPT\n-      case Op_FastLock:\n-      case Op_FastUnlock: {\n-        \/\/ Don't unroll RTM locking code because it is large.\n-        if (UseRTMLocking) {\n-          return false;\n-        }\n-      }\n-#endif\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-class RTMLockingCounters;\n@@ -805,2 +804,0 @@\n-  RTMLockingCounters*       _rtm_counters; \/\/ RTM lock counters for inflated locks\n-  RTMLockingCounters* _stack_rtm_counters; \/\/ RTM lock counters for stack locks\n","filename":"src\/hotspot\/share\/opto\/machnode.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2431,1 +2431,0 @@\n-               n->Opcode() == Op_Opaque3   ||\n@@ -2484,24 +2483,0 @@\n-#if INCLUDE_RTM_OPT\n-      } else if ((n->Opcode() == Op_Opaque3) && ((Opaque3Node*)n)->rtm_opt()) {\n-        assert(C->profile_rtm(), \"should be used only in rtm deoptimization code\");\n-        assert((n->outcnt() == 1) && n->unique_out()->is_Cmp(), \"\");\n-        Node* cmp = n->unique_out();\n-#ifdef ASSERT\n-        \/\/ Validate graph.\n-        assert((cmp->outcnt() == 1) && cmp->unique_out()->is_Bool(), \"\");\n-        BoolNode* bol = cmp->unique_out()->as_Bool();\n-        assert((bol->outcnt() == 1) && bol->unique_out()->is_If() &&\n-               (bol->_test._test == BoolTest::ne), \"\");\n-        IfNode* ifn = bol->unique_out()->as_If();\n-        assert((ifn->outcnt() == 2) &&\n-               ifn->proj_out(1)->is_uncommon_trap_proj(Deoptimization::Reason_rtm_state_change) != nullptr, \"\");\n-#endif\n-        Node* repl = n->in(1);\n-        if (!_has_locks) {\n-          \/\/ Remove RTM state check if there are no locks in the code.\n-          \/\/ Replace input to compare the same value.\n-          repl = (cmp->in(1) == n) ? cmp->in(2) : cmp->in(1);\n-        }\n-        _igvn.replace_node(n, repl);\n-        success = true;\n-#endif\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,10 +48,0 @@\n-\/\/ Do NOT remove the opaque node until no more loop opts can happen.\n-Node* Opaque3Node::Identity(PhaseGVN* phase) {\n-  if (phase->C->post_loop_opts_phase()) {\n-    return in(1);\n-  } else {\n-    phase->C->record_for_post_loop_opts_igvn(this);\n-  }\n-  return this;\n-}\n-\n@@ -95,6 +85,0 @@\n-\/\/ Do not allow value-numbering\n-uint Opaque3Node::hash() const { return NO_HASH; }\n-bool Opaque3Node::cmp(const Node &n) const {\n-  return (&n == this);          \/\/ Always fail except on self\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,20 +94,0 @@\n-\/\/------------------------------Opaque3Node------------------------------------\n-\/\/ A node to prevent unwanted optimizations. Will be optimized only during\n-\/\/ macro nodes expansion.\n-class Opaque3Node : public Node {\n-  int _opt; \/\/ what optimization it was used for\n-  virtual uint hash() const;\n-  virtual bool cmp(const Node &n) const;\n-  public:\n-  enum { RTM_OPT };\n-  Opaque3Node(Compile* C, Node* n, int opt) : Node(0, n), _opt(opt) {\n-    \/\/ Put it on the Macro nodes list to removed during macro nodes expansion.\n-    init_flags(Flag_is_macro);\n-    C->add_macro_node(this);\n-  }\n-  virtual int Opcode() const;\n-  virtual const Type* bottom_type() const { return TypeInt::INT; }\n-  virtual Node* Identity(PhaseGVN* phase);\n-  bool rtm_opt() const { return (_opt == RTM_OPT); }\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -3391,2 +3391,1 @@\n-                 SharedRuntime::is_wide_vector(C->max_vector_size()),\n-                 C->rtm_state());\n+                 SharedRuntime::is_wide_vector(C->max_vector_size()));\n@@ -3400,2 +3399,1 @@\n-                               bool              has_wide_vectors,\n-                               RTMState          rtm_state) {\n+                               bool              has_wide_vectors) {\n@@ -3439,2 +3437,1 @@\n-                                     0,\n-                                     C->rtm_state());\n+                                     0);\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,2 +124,1 @@\n-                    bool              has_wide_vectors,\n-                    RTMState          rtm_state);\n+                    bool              has_wide_vectors);\n","filename":"src\/hotspot\/share\/opto\/output.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -504,2 +504,0 @@\n-  void rtm_deopt();\n-\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -600,3 +600,0 @@\n-\n-    \/\/ Add check to deoptimize the nmethod if RTM state was changed\n-    rtm_deopt();\n@@ -605,1 +602,1 @@\n-  \/\/ Check for bailouts during method entry or RTM state check setup.\n+  \/\/ Check for bailouts during method entry.\n@@ -2204,36 +2201,0 @@\n-\/\/ Add check to deoptimize if RTM state is not ProfileRTM\n-void Parse::rtm_deopt() {\n-#if INCLUDE_RTM_OPT\n-  if (C->profile_rtm()) {\n-    assert(C->has_method(), \"only for normal compilations\");\n-    assert(!C->method()->method_data()->is_empty(), \"MDO is needed to record RTM state\");\n-    assert(depth() == 1, \"generate check only for main compiled method\");\n-\n-    \/\/ Set starting bci for uncommon trap.\n-    set_parse_bci(is_osr_parse() ? osr_bci() : 0);\n-\n-    \/\/ Load the rtm_state from the MethodData.\n-    const TypePtr* adr_type = TypeMetadataPtr::make(C->method()->method_data());\n-    Node* mdo = makecon(adr_type);\n-    int offset = in_bytes(MethodData::rtm_state_offset());\n-    Node* adr_node = basic_plus_adr(mdo, mdo, offset);\n-    Node* rtm_state = make_load(control(), adr_node, TypeInt::INT, T_INT, adr_type, MemNode::unordered);\n-\n-    \/\/ Separate Load from Cmp by Opaque.\n-    \/\/ In expand_macro_nodes() it will be replaced either\n-    \/\/ with this load when there are locks in the code\n-    \/\/ or with ProfileRTM (cmp->in(2)) otherwise so that\n-    \/\/ the check will fold.\n-    Node* profile_state = makecon(TypeInt::make(ProfileRTM));\n-    Node* opq   = _gvn.transform( new Opaque3Node(C, rtm_state, Opaque3Node::RTM_OPT) );\n-    Node* chk   = _gvn.transform( new CmpINode(opq, profile_state) );\n-    Node* tst   = _gvn.transform( new BoolNode(chk, BoolTest::eq) );\n-    \/\/ Branch to failure if state was changed\n-    { BuildCutout unless(this, tst, PROB_ALWAYS);\n-      uncommon_trap(Deoptimization::Reason_rtm_state_change,\n-                    Deoptimization::Action_make_not_entrant);\n-    }\n-  }\n-#endif\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":1,"deletions":40,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1838,8 +1838,0 @@\n-#if INCLUDE_RTM_OPT\n-    } else if (c->tag() == NamedCounter::RTMLockingCounter) {\n-      RTMLockingCounters* rlc = ((RTMLockingNamedCounter*)c)->counters();\n-      if (rlc->nonzero()) {\n-        tty->print_cr(\"%s\", c->name());\n-        rlc->print_on(tty);\n-      }\n-#endif\n@@ -1887,6 +1879,1 @@\n-  NamedCounter* c;\n-  if (tag == NamedCounter::RTMLockingCounter) {\n-    c = new RTMLockingNamedCounter(st.freeze());\n-  } else {\n-    c = new NamedCounter(st.freeze(), tag);\n-  }\n+  NamedCounter* c = new NamedCounter(st.freeze(), tag);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"runtime\/rtmLocking.hpp\"\n@@ -64,2 +63,1 @@\n-    EliminatedLockCounter,\n-    RTMLockingCounter\n+    EliminatedLockCounter\n@@ -101,11 +99,0 @@\n-class RTMLockingNamedCounter : public NamedCounter {\n- private:\n- RTMLockingCounters _counters;\n-\n- public:\n-  RTMLockingNamedCounter(const char *n) :\n-    NamedCounter(n, RTMLockingCounter), _counters() {}\n-\n-  RTMLockingCounters* counters() { return &_counters; }\n-};\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -510,5 +510,0 @@\n-#if defined(X86)\n-  { \"UseRTMLocking\",                JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n-  { \"UseRTMDeopt\",                  JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n-  { \"RTMRetryCount\",                JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n-#endif \/\/ X86\n@@ -548,0 +543,5 @@\n+#if defined(X86)\n+  { \"UseRTMLocking\",                JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n+  { \"UseRTMDeopt\",                  JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n+  { \"RTMRetryCount\",                JDK_Version::jdk(23), JDK_Version::jdk(24), JDK_Version::jdk(25) },\n+#endif \/\/ X86\n@@ -1850,8 +1850,0 @@\n-#endif\n-#if defined(X86) && !defined(ZERO)\n-  if (LockingMode == LM_MONITOR && UseRTMForStackLocks) {\n-    jio_fprintf(defaultStream::error_stream(),\n-                \"LockingMode == 0 (LM_MONITOR) and -XX:+UseRTMForStackLocks are mutually exclusive\\n\");\n-\n-    return false;\n-  }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2079,2 +2079,1 @@\n-    \/\/ Need MDO to record RTM code generation state.\n-    bool create_if_missing = ProfileTraps RTM_OPT_ONLY( || UseRTMLocking );\n+    bool create_if_missing = ProfileTraps;\n@@ -2428,10 +2427,0 @@\n-#if INCLUDE_RTM_OPT\n-      \/\/ Restart collecting RTM locking abort statistic if the method\n-      \/\/ is recompiled for a reason other than RTM state change.\n-      \/\/ Assume that in new recompiled code the statistic could be different,\n-      \/\/ for example, due to different inlining.\n-      if ((reason != Reason_rtm_state_change) && (trap_mdo != nullptr) &&\n-          UseRTMDeopt && (nm->rtm_state() != ProfileRTM)) {\n-        trap_mdo->atomic_set_rtm_state(ProfileRTM);\n-      }\n-#endif\n@@ -2727,1 +2716,0 @@\n-  \"rtm_state_change\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -116,1 +116,0 @@\n-    Reason_rtm_state_change,      \/\/ rtm state change detected\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -381,14 +381,0 @@\n-JVMFlag::Error RTMTotalCountIncrRateConstraintFunc(int value, bool verbose) {\n-#if INCLUDE_RTM_OPT\n-  if (UseRTMLocking && !is_power_of_2(RTMTotalCountIncrRate)) {\n-    JVMFlag::printError(verbose,\n-                        \"RTMTotalCountIncrRate (%d) must be \"\n-                        \"a power of 2, resetting it to 64\\n\",\n-                        RTMTotalCountIncrRate);\n-    FLAG_SET_DEFAULT(RTMTotalCountIncrRate, 64);\n-  }\n-#endif\n-\n-  return JVMFlag::SUCCESS;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-  f(int ,  RTMTotalCountIncrRateConstraintFunc)         \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-  if (PrintLockStatistics || PrintPreciseRTMLockingStatistics) {\n+  if (PrintLockStatistics) {\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"compiler\/compilerDefinitions.hpp\"\n-\n-#if INCLUDE_RTM_OPT\n-\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/task.hpp\"\n-#include \"runtime\/rtmLocking.hpp\"\n-\n-\n-\/\/ One-shot PeriodicTask subclass for enabling RTM locking\n-uintx RTMLockingCounters::_calculation_flag = 0;\n-\n-class RTMLockingCalculationTask : public PeriodicTask {\n- public:\n-  RTMLockingCalculationTask(size_t interval_time) : PeriodicTask(interval_time){  }\n-\n-  virtual void task() {\n-    RTMLockingCounters::_calculation_flag = 1;\n-    \/\/ Reclaim our storage and disenroll ourself\n-    delete this;\n-  }\n-};\n-\n-void RTMLockingCounters::init() {\n-  if (UseRTMLocking && RTMLockingCalculationDelay > 0) {\n-    RTMLockingCalculationTask* task = new RTMLockingCalculationTask(RTMLockingCalculationDelay);\n-    task->enroll();\n-  } else {\n-    _calculation_flag = 1;\n-  }\n-}\n-\n-const char* RTMLockingCounters::_abortX_desc[ABORT_STATUS_LIMIT] = {\n-  \"abort instruction   \",\n-  \"may succeed on retry\",\n-  \"thread conflict     \",\n-  \"buffer overflow     \",\n-  \"debug or trap hit   \",\n-  \"maximum nested depth\"\n-};\n-\n-\/\/------------------------------print_on-------------------------------\n-void RTMLockingCounters::print_on(outputStream* st) const {\n-  tty->print_cr(\"# rtm locks total (estimated): \" UINTX_FORMAT, _total_count * RTMTotalCountIncrRate);\n-  tty->print_cr(\"# rtm lock aborts (total): \" UINTX_FORMAT, _abort_count);\n-  for (int i = 0; i < ABORT_STATUS_LIMIT; i++) {\n-    tty->print_cr(\"# rtm lock aborts %d (%s): \" UINTX_FORMAT, i, _abortX_desc[i], _abortX_count[i]);\n-  }\n-}\n-void RTMLockingCounters::print() const { print_on(tty); }\n-\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/rtmLocking.cpp","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_RUNTIME_RTMLOCKING_HPP\n-#define SHARE_RUNTIME_RTMLOCKING_HPP\n-\n-\/\/ Generate RTM (Restricted Transactional Memory) locking code for all inflated\n-\/\/ locks when \"UseRTMLocking\" option is on with normal locking mechanism as fall back\n-\/\/ handler.\n-\/\/\n-\/\/ On abort\/lock busy the lock will be retried a fixed number of times under RTM\n-\/\/ as specified by \"RTMRetryCount\" option. The locks which abort too often\n-\/\/ can be auto tuned or manually tuned.\n-\/\/\n-\/\/ Auto-tuning can be done on an option like UseRTMDeopt and it will need abort\n-\/\/ ratio calculation for each lock. The abort ratio will be calculated after\n-\/\/ \"RTMAbortThreshold\" number of aborts is reached. The formulas are:\n-\/\/\n-\/\/     Aborted transactions = abort_count * 100\n-\/\/     All transactions = total_count *  RTMTotalCountIncrRate\n-\/\/\n-\/\/     Aborted transactions >= All transactions * RTMAbortRatio\n-\/\/\n-\/\/ If \"UseRTMDeopt\" is on and the aborts ratio reaches \"RTMAbortRatio\"\n-\/\/ the method containing the lock will be deoptimized and recompiled with\n-\/\/ all locks as normal locks. If the abort ratio continues to remain low after\n-\/\/ \"RTMLockingThreshold\" locks are attempted, then the method will be deoptimized\n-\/\/ and recompiled with all locks as RTM locks without abort ratio calculation code.\n-\/\/ The abort ratio calculation can be delayed by specifying flag\n-\/\/ -XX:RTMLockingCalculationDelay in millisecond.\n-\/\/\n-\/\/ For manual tuning the abort statistics for each lock needs to be provided\n-\/\/ to the user on some JVM option like \"PrintPreciseRTMLockingStatistics\".\n-\/\/ Based on the abort statistics users can create a .hotspot_compiler file\n-\/\/ or use -XX:CompileCommand=option,class::method,NoRTMLockEliding\n-\/\/ to specify for which methods to disable RTM locking.\n-\/\/\n-\/\/ When UseRTMForStackLocks option is enabled along with UseRTMLocking option,\n-\/\/ the RTM locking code is generated for stack locks too.\n-\/\/ The retries, auto-tuning support and rtm locking statistics are all\n-\/\/ supported for stack locks just like inflated locks.\n-\n-\/\/ RTM locking counters\n-class RTMLockingCounters {\n- private:\n-  uintx _total_count; \/\/ Total RTM locks count\n-  uintx _abort_count; \/\/ Total aborts count\n-\n- public:\n-  enum { ABORT_STATUS_LIMIT = 6 };\n-  \/\/ Counters per RTM Abort Status. Incremented with +PrintPreciseRTMLockingStatistics\n-  \/\/ RTM uses the EAX register to communicate abort status to software.\n-  \/\/ Following an RTM abort the EAX register has the following definition.\n-  \/\/\n-  \/\/   EAX register bit position   Meaning\n-  \/\/     0     Set if abort caused by XABORT instruction.\n-  \/\/     1     If set, the transaction may succeed on a retry. This bit is always clear if bit 0 is set.\n-  \/\/     2     Set if another logical processor conflicted with a memory address that was part of the transaction that aborted.\n-  \/\/     3     Set if an internal buffer overflowed.\n-  \/\/     4     Set if a debug breakpoint was hit.\n-  \/\/     5     Set if an abort occurred during execution of a nested transaction.\n- private:\n-  uintx _abortX_count[ABORT_STATUS_LIMIT];\n-  static const char* _abortX_desc[ABORT_STATUS_LIMIT];\n-\n- public:\n-  static uintx _calculation_flag;\n-  static uintx* rtm_calculation_flag_addr() { return &_calculation_flag; }\n-\n-  static void init();\n-\n-  RTMLockingCounters() : _total_count(0), _abort_count(0) {\n-    for (int i = 0; i < ABORT_STATUS_LIMIT; i++) {\n-      _abortX_count[i] = 0;\n-    }\n-  }\n-\n-  uintx* total_count_addr()               { return &_total_count; }\n-\n-  static int total_count_offset()         { return (int)offset_of(RTMLockingCounters, _total_count); }\n-  static int abort_count_offset()         { return (int)offset_of(RTMLockingCounters, _abort_count); }\n-  static int abortX_count_offset()        { return (int)offset_of(RTMLockingCounters, _abortX_count[0]); }\n-\n-\n-  bool nonzero() {  return (_abort_count + _total_count) > 0; }\n-\n-  void print_on(outputStream* st) const;\n-  void print() const;\n-};\n-\n-#endif \/\/ SHARE_RUNTIME_RTMLOCKING_HPP\n","filename":"src\/hotspot\/share\/runtime\/rtmLocking.hpp","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -112,3 +112,0 @@\n-#if INCLUDE_RTM_OPT\n-#include \"runtime\/rtmLocking.hpp\"\n-#endif\n@@ -805,4 +802,0 @@\n-#if INCLUDE_RTM_OPT\n-  RTMLockingCounters::init();\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2262,1 +2262,0 @@\n-  declare_constant(Deoptimization::Reason_rtm_state_change)               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-.TH \"JAVA\" \"1\" \"2024\" \"JDK 23-ea\" \"JDK Commands\"\n+.TH \"JAVA\" \"1\" \"2024\" \"JDK 24\" \"JDK Commands\"\n@@ -189,1 +189,1 @@\n-(\\f[V]23\\f[R]) and a limited number of previous releases, detailed in\n+(\\f[V]24\\f[R]) and a limited number of previous releases, detailed in\n@@ -1198,1 +1198,1 @@\n-\\f[V]--sun-misc-unsafe-memory-acces=\\f[R] \\f[I]value\\f[R]\n+\\f[V]--sun-misc-unsafe-memory-access=\\f[R] \\f[I]value\\f[R]\n@@ -3487,10 +3487,0 @@\n-\\f[V]-XX:+ScavengeBeforeFullGC\\f[R]\n-Enables GC of the young generation before each full GC.\n-This option is enabled by default.\n-It is recommended that you \\f[I]don\\[aq]t\\f[R] disable it, because\n-scavenging the young generation before a full GC can reduce the number\n-of objects reachable from the old generation space into the young\n-generation space.\n-To disable GC of the young generation before each full GC, specify the\n-option \\f[V]-XX:-ScavengeBeforeFullGC\\f[R].\n-.TP\n@@ -3789,0 +3779,22 @@\n+.SH OBSOLETE JAVA OPTIONS\n+.PP\n+These \\f[V]java\\f[R] options are still accepted but ignored, and a\n+warning is issued when they\\[aq]re used.\n+.TP\n+\\f[V]--illegal-access=\\f[R]\\f[I]parameter\\f[R]\n+Controlled \\f[I]relaxed strong encapsulation\\f[R], as defined in\n+\\f[B]JEP 261\\f[R]\n+[https:\/\/openjdk.org\/jeps\/261#Relaxed-strong-encapsulation].\n+This option was deprecated in JDK 16 by \\f[B]JEP 396\\f[R]\n+[https:\/\/openjdk.org\/jeps\/396] and made obsolete in JDK 17 by \\f[B]JEP\n+403\\f[R] [https:\/\/openjdk.org\/jeps\/403].\n+.TP\n+\\f[V]-XX:+ScavengeBeforeFullGC\\f[R]\n+Enables GC of the young generation before each full GC.\n+This option is enabled by default.\n+It is recommended that you \\f[I]don\\[aq]t\\f[R] disable it, because\n+scavenging the young generation before a full GC can reduce the number\n+of objects reachable from the old generation space into the young\n+generation space.\n+To disable GC of the young generation before each full GC, specify the\n+option \\f[V]-XX:-ScavengeBeforeFullGC\\f[R].\n@@ -3866,12 +3878,0 @@\n-.SH OBSOLETE JAVA OPTIONS\n-.PP\n-These \\f[V]java\\f[R] options are still accepted but ignored, and a\n-warning is issued when they\\[aq]re used.\n-.TP\n-\\f[V]--illegal-access=\\f[R]\\f[I]parameter\\f[R]\n-Controlled \\f[I]relaxed strong encapsulation\\f[R], as defined in\n-\\f[B]JEP 261\\f[R]\n-[https:\/\/openjdk.org\/jeps\/261#Relaxed-strong-encapsulation].\n-This option was deprecated in JDK 16 by \\f[B]JEP 396\\f[R]\n-[https:\/\/openjdk.org\/jeps\/396] and made obsolete in JDK 17 by \\f[B]JEP\n-403\\f[R] [https:\/\/openjdk.org\/jeps\/403].\n@@ -3880,1 +3880,1 @@\n-These \\f[V]java\\f[R] options have been removed in JDK 23 and using them\n+These \\f[V]java\\f[R] options have been removed in JDK 24 and using them\n","filename":"src\/java.base\/share\/man\/java.1","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -54,12 +54,0 @@\n-compiler\/rtm\/locking\/TestRTMAbortRatio.java 8183263 generic-x64,generic-i586\n-compiler\/rtm\/locking\/TestRTMAbortThreshold.java 8183263 generic-x64,generic-i586\n-compiler\/rtm\/locking\/TestRTMAfterNonRTMDeopt.java 8183263 generic-x64,generic-i586\n-compiler\/rtm\/locking\/TestRTMDeoptOnHighAbortRatio.java 8183263 generic-x64,generic-i586\n-compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java 8183263 generic-x64,generic-i586\n-compiler\/rtm\/locking\/TestRTMLockingCalculationDelay.java 8183263 generic-x64,generic-i586\n-compiler\/rtm\/locking\/TestRTMLockingThreshold.java 8183263 generic-x64,generic-i586\n-compiler\/rtm\/locking\/TestRTMSpinLoopCount.java 8183263 generic-x64,generic-i586\n-compiler\/rtm\/locking\/TestUseRTMDeopt.java 8183263 generic-x64,generic-i586\n-compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java 8183263 generic-x64,generic-i586\n-compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java 8183263 generic-x64,generic-i586\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-  compiler\/rtm\/ \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,214 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.function.BooleanSupplier;\n-\n-\/**\n- * Base for all RTM-related CLI tests.\n- *\/\n-public abstract class RTMGenericCommandLineOptionTest {\n-\n-    protected static final String RTM_INSTR_ERROR\n-            = \"RTM instructions are not available on this CPU\";\n-    protected static final String RTM_UNSUPPORTED_VM_ERROR\n-            = \"RTM locking optimization is not supported in this VM\";\n-    protected static final String RTM_FOR_STACK_LOCKS_WARNING\n-            = \"UseRTMForStackLocks flag should be off when UseRTMLocking \"\n-            + \"flag is off\";\n-    protected static final String RTM_COUNT_INCR_WARNING\n-            = \"must be a power of 2, resetting it to 64\";\n-\n-    protected final String optionName;\n-    protected final String errorMessage;\n-    protected final String experimentalOptionError;\n-    protected final boolean isExperimental;\n-    protected final boolean isBoolean;\n-    protected final String defaultValue;\n-    protected final String[] optionValues;\n-\n-    \/**\n-     * Constructs new genetic RTM CLI test, for option {@code optionName} which\n-     * has default value {@code defaultValue}. Test cases will use option's\n-     * values passed via {@code optionValues} for verification of correct\n-     * option processing.\n-     *\n-     * Test constructed using this ctor will be started on any cpu regardless\n-     * it's architecture and supported\/unsupported features.\n-     *\n-     * @param optionName name of option to be tested\n-     * @param isBoolean {@code true} if option is binary\n-     * @param isExperimental {@code true} if option is experimental\n-     * @param defaultValue default value of tested option\n-     * @param optionValues different option values\n-     *\/\n-    public RTMGenericCommandLineOptionTest(\n-            String optionName, boolean isBoolean, boolean isExperimental,\n-            String defaultValue, String... optionValues) {\n-        this.optionName = optionName;\n-        this.isExperimental = isExperimental;\n-        this.isBoolean = isBoolean;\n-        this.defaultValue = defaultValue;\n-        this.optionValues = optionValues;\n-        this.errorMessage = CommandLineOptionTest.\n-                getUnrecognizedOptionErrorMessage(optionName);\n-        this.experimentalOptionError = CommandLineOptionTest.\n-                getExperimentalOptionErrorMessage(optionName);\n-    }\n-\n-    public void runTestCases() throws Throwable {\n-        if (Platform.isX86() || Platform.isX64()) {\n-            if (Platform.isServer()) {\n-                runX86SupportedVMTestCases();\n-            } else {\n-                runX86UnsupportedVMTestCases();\n-            }\n-        } else {\n-            runNonX86TestCases();\n-        }\n-    }\n-\n-    \/**\n-     * Runs test cases on X86 CPU if VM supports RTM locking.\n-     * @throws Throwable\n-     *\/\n-    protected void runX86SupportedVMTestCases() throws Throwable {\n-        runGenericX86TestCases();\n-    }\n-\n-    \/**\n-     * Runs test cases on X86 CPU if VM does not support RTM locking.\n-     * @throws Throwable\n-     *\/\n-    protected void runX86UnsupportedVMTestCases() throws Throwable {\n-        runGenericX86TestCases();\n-    }\n-\n-    \/**\n-     * Runs test cases on non-X86 CPU.\n-     * @throws Throwable\n-     *\/\n-    protected void runNonX86TestCases() throws Throwable {\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                new String[] { errorMessage }, null,\n-                String.format(\"Option '%s' should be unknown on non-X86CPUs.%n\"\n-                + \"JVM startup should fail\", optionName), \"\", ExitCode.FAIL,\n-                prepareOptionValue(defaultValue));\n-    }\n-\n-    \/**\n-     * Runs generic X86 test cases.\n-     * @throws Throwable\n-     *\/\n-    protected void runGenericX86TestCases() throws Throwable {\n-        verifyJVMStartup();\n-        verifyOptionValues();\n-    }\n-\n-    protected void verifyJVMStartup() throws Throwable {\n-        String optionValue = prepareOptionValue(defaultValue);\n-        String shouldFailMessage = String.format(\"VM option '%s' is \"\n-                + \"experimental.%nVM startup expected to fail without \"\n-                + \"-XX:+UnlockExperimentalVMOptions option\", optionName);\n-        String shouldPassMessage = String.format(\"VM option '%s' is \"\n-                + \"experimental%nVM startup should pass with \"\n-                + \"-XX:+UnlockExperimentalVMOptions option\", optionName);\n-        if (isExperimental) {\n-            \/\/ verify that option is experimental\n-            CommandLineOptionTest.verifySameJVMStartup(\n-                    new String[] { experimentalOptionError },\n-                    new String[] { errorMessage }, shouldFailMessage,\n-                    shouldFailMessage, ExitCode.FAIL, optionValue);\n-            \/\/ verify that it could be passed if experimental options\n-            \/\/ are unlocked\n-            CommandLineOptionTest.verifySameJVMStartup(null,\n-                    new String[] {\n-                            experimentalOptionError,\n-                            errorMessage\n-                    },\n-                    shouldPassMessage,\n-                    \"JVM should start without any warnings or errors\",\n-                    ExitCode.OK,\n-                    CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                    optionValue);\n-        } else {\n-            \/\/ verify that option could be passed\n-            CommandLineOptionTest.verifySameJVMStartup(null,\n-                    new String[]{errorMessage},\n-                    String.format(\"VM startup shuld pass with '%s' option\",\n-                            optionName),\n-                    \"JVM should start without any warnings or errors\",\n-                    ExitCode.OK, optionValue);\n-        }\n-    }\n-\n-    protected void verifyOptionValues() throws Throwable {\n-        \/\/ verify default value\n-        if (isExperimental) {\n-            CommandLineOptionTest.verifyOptionValueForSameVM(optionName,\n-                    defaultValue,\n-                    String.format(\"Option '%s' is expected to have '%s' \"\n-                            + \"default value\", optionName, defaultValue),\n-                    CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS);\n-        } else {\n-            CommandLineOptionTest.verifyOptionValueForSameVM(optionName,\n-                    defaultValue,\n-                    String.format(\"Option '%s' is expected to have '%s' \"\n-                            + \"default value\", optionName, defaultValue));\n-        }\n-        \/\/ verify other specified option values\n-        if (optionValues == null) {\n-            return;\n-        }\n-\n-        for (String value : optionValues) {\n-            if (isExperimental) {\n-                CommandLineOptionTest.verifyOptionValueForSameVM(optionName,\n-                        value,\n-                        String.format(\"Option '%s' is set to have '%s' value\",\n-                                optionName, value),\n-                        CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                        prepareOptionValue(value));\n-            } else {\n-                CommandLineOptionTest.verifyOptionValueForSameVM(optionName,\n-                        value,\n-                        String.format(\"Option '%s' is set to have '%s' value\",\n-                                optionName, value), prepareOptionValue(value));\n-            }\n-        }\n-    }\n-\n-    protected String prepareOptionValue(String value) {\n-        if (isBoolean) {\n-            return CommandLineOptionTest.prepareBooleanFlag(optionName,\n-                    Boolean.valueOf(value));\n-        } else {\n-            return String.format(\"-XX:%s=%s\", optionName, value);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/RTMGenericCommandLineOptionTest.java","additions":0,"deletions":214,"binary":false,"changes":214,"status":"deleted"},{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-\/**\n- * Base for all RTM-related CLI tests on options whose processing depends\n- * on UseRTMLocking value.\n- *\n- * Since UseRTMLocking option could be used when both CPU and VM supports RTM\n- * locking, this test will be skipped on all unsupported configurations.\n- *\/\n-public abstract class RTMLockingAwareTest\n-        extends RTMGenericCommandLineOptionTest {\n-    protected final String warningMessage;\n-    protected final String[] correctValues;\n-    protected final String[] incorrectValues;\n-    \/**\n-     * Constructs new test for option {@code optionName} that should be executed\n-     * only on CPU with RTM support.\n-     * Test will be executed using set of correct values from\n-     * {@code correctValues} and set of incorrect values from\n-     * {@code incorrectValues}.\n-     *\n-     * @param optionName name of option to be tested\n-     * @param isBoolean {@code true} if tested option is binary\n-     * @param isExperimental {@code true} if tested option is experimental\n-     * @param defaultValue default value of tested option\n-     * @param correctValues array with correct values, that should not emit\n-     *                      {@code warningMessage} to VM output\n-     * @param incorrectValues array with incorrect values, that should emit\n-     *                        {@code waningMessage} to VM output\n-     * @param warningMessage warning message associated with tested option\n-     *\/\n-    protected RTMLockingAwareTest(String optionName, boolean isBoolean,\n-            boolean isExperimental, String defaultValue,\n-            String[] correctValues, String[] incorrectValues,\n-            String warningMessage) {\n-        super(optionName, isBoolean, isExperimental, defaultValue);\n-        this.correctValues = correctValues;\n-        this.incorrectValues = incorrectValues;\n-        this.warningMessage = warningMessage;\n-    }\n-\n-    @Override\n-    protected void verifyJVMStartup() throws Throwable {\n-        \/\/ Run generic sanity checks\n-        super.verifyJVMStartup();\n-        \/\/ Verify how option values will be processed depending on\n-        \/\/ UseRTMLocking value.\n-        if (correctValues != null) {\n-            for (String correctValue : correctValues) {\n-                \/\/ For correct values it is expected to see no warnings\n-                \/\/ regardless to UseRTMLocking\n-                verifyStartupWarning(correctValue, true, false);\n-                verifyStartupWarning(correctValue, false, false);\n-            }\n-        }\n-\n-        if (incorrectValues != null) {\n-            for (String incorrectValue : incorrectValues) {\n-                \/\/ For incorrect values it is expected to see warning\n-                \/\/ only with -XX:+UseRTMLocking\n-                verifyStartupWarning(incorrectValue, true, true);\n-                verifyStartupWarning(incorrectValue, false, false);\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected void verifyOptionValues() throws Throwable {\n-        super.verifyOptionValues();\n-        \/\/ Verify how option values will be setup after processing\n-        \/\/ depending on UseRTMLocking value\n-        if (correctValues != null) {\n-            for (String correctValue : correctValues) {\n-                \/\/ Correct value could be set up regardless to UseRTMLocking\n-                verifyOptionValues(correctValue, false, correctValue);\n-                verifyOptionValues(correctValue, true, correctValue);\n-            }\n-        }\n-\n-        if (incorrectValues != null) {\n-            for (String incorrectValue : incorrectValues) {\n-                \/\/ With -XX:+UseRTMLocking, incorrect value will be changed to\n-                \/\/ default value.\n-                verifyOptionValues(incorrectValue, false, incorrectValue);\n-                verifyOptionValues(incorrectValue, true, defaultValue);\n-            }\n-        }\n-    }\n-\n-    private void verifyStartupWarning(String value, boolean useRTMLocking,\n-            boolean isWarningExpected) throws Throwable {\n-        String warnings[] = new String[] { warningMessage };\n-        List<String> options = new LinkedList<>();\n-        options.add(CommandLineOptionTest.prepareBooleanFlag(\"UseRTMLocking\",\n-                useRTMLocking));\n-\n-        if (isExperimental) {\n-            options.add(CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS);\n-        }\n-        options.add(prepareOptionValue(value));\n-\n-        String errorString =  String.format(\"JVM should start with option '%s'\"\n-                + \"'%nWarnings should be shown: %s\", optionName,\n-                isWarningExpected);\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                (isWarningExpected ? warnings : null),\n-                (isWarningExpected ? null : warnings),\n-                errorString, errorString, ExitCode.OK,\n-                options.toArray(new String[options.size()]));\n-    }\n-\n-    private void verifyOptionValues(String value, boolean useRTMLocking,\n-            String expectedValue) throws Throwable {\n-        List<String> options = new LinkedList<>();\n-        options.add(CommandLineOptionTest.prepareBooleanFlag(\"UseRTMLocking\",\n-                useRTMLocking));\n-\n-        if (isExperimental) {\n-            options.add(CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS);\n-        }\n-        options.add(prepareOptionValue(value));\n-\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName,\n-                expectedValue, String.format(\"Option '%s' should have '%s' \"\n-                        + \"value if '%s' flag set\",\n-                        optionName, expectedValue, prepareOptionValue(value)),\n-                options.toArray(new String[options.size()]));\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/RTMLockingAwareTest.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public abstract class TestPrintPreciseRTMLockingStatisticsBase\n-        extends RTMGenericCommandLineOptionTest {\n-    protected static final String DEFAULT_VALUE = \"false\";\n-\n-    protected TestPrintPreciseRTMLockingStatisticsBase() {\n-        super(\"PrintPreciseRTMLockingStatistics\", true, false,\n-                TestPrintPreciseRTMLockingStatisticsBase.DEFAULT_VALUE);\n-    }\n-\n-    @Override\n-    protected void runNonX86TestCases() throws Throwable {\n-        verifyJVMStartup();\n-        verifyOptionValues();\n-    }\n-\n-    @Override\n-    protected void verifyJVMStartup() throws Throwable {\n-        if (Platform.isServer()) {\n-            if (!Platform.isDebugBuild()) {\n-                String shouldFailMessage = String.format(\"VM option '%s' is \"\n-                        + \"diagnostic%nJVM startup should fail without \"\n-                        + \"-XX:\\\\+UnlockDiagnosticVMOptions flag\", optionName);\n-                String shouldPassMessage = String.format(\"VM option '%s' is \"\n-                        + \"diagnostic%nJVM startup should pass with \"\n-                        + \"-XX:\\\\+UnlockDiagnosticVMOptions in debug build\",\n-                        optionName);\n-                String errorMessage = CommandLineOptionTest.\n-                        getDiagnosticOptionErrorMessage(optionName);\n-                \/\/ verify that option is actually diagnostic\n-                CommandLineOptionTest.verifySameJVMStartup(\n-                        new String[] { errorMessage }, null, shouldFailMessage,\n-                        shouldFailMessage, ExitCode.FAIL,\n-                        prepareOptionValue(\"true\"));\n-\n-                CommandLineOptionTest.verifySameJVMStartup(null,\n-                        new String[] { errorMessage }, shouldPassMessage,\n-                        shouldPassMessage + \"without any warnings\", ExitCode.OK,\n-                        CommandLineOptionTest.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                        prepareOptionValue(\"true\"));\n-            } else {\n-                String shouldPassMessage = String.format(\"JVM startup should \"\n-                                + \"pass with '%s' option in debug build\",\n-                                optionName);\n-                CommandLineOptionTest.verifySameJVMStartup(null, null,\n-                        shouldPassMessage, shouldPassMessage,\n-                        ExitCode.OK, prepareOptionValue(\"true\"));\n-            }\n-        } else {\n-            String errorMessage = CommandLineOptionTest.\n-                    getUnrecognizedOptionErrorMessage(optionName);\n-            String shouldFailMessage =  String.format(\"JVM startup should fail\"\n-                    + \" with '%s' option in not debug build\", optionName);\n-            CommandLineOptionTest.verifySameJVMStartup(\n-                    new String[]{errorMessage}, null, shouldFailMessage,\n-                    shouldFailMessage, ExitCode.FAIL,\n-                    CommandLineOptionTest.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                    prepareOptionValue(\"true\"));\n-        }\n-    }\n-\n-    @Override\n-    protected void verifyOptionValues() throws Throwable {\n-        if (Platform.isServer()) {\n-            \/\/ Verify default value\n-            CommandLineOptionTest.verifyOptionValueForSameVM(optionName,\n-                    TestPrintPreciseRTMLockingStatisticsBase.DEFAULT_VALUE,\n-                    String.format(\"Option '%s' should have '%s' default value\",\n-                            optionName,\n-                       TestPrintPreciseRTMLockingStatisticsBase.DEFAULT_VALUE),\n-                    CommandLineOptionTest.UNLOCK_DIAGNOSTIC_VM_OPTIONS);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestPrintPreciseRTMLockingStatisticsBase.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify PrintPreciseRTMLockingStatistics on CPUs and OSs with\n- *          rtm support and on VM with rtm locking support,\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestPrintPreciseRTMLockingStatisticsOptionOnSupportedConfig\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class TestPrintPreciseRTMLockingStatisticsOptionOnSupportedConfig\n-        extends TestPrintPreciseRTMLockingStatisticsBase {\n-\n-    @Override\n-    protected void verifyOptionValues() throws Throwable {\n-        super.verifyOptionValues();\n-        \/\/ verify default value\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName,\n-                TestPrintPreciseRTMLockingStatisticsBase.DEFAULT_VALUE,\n-                String.format(\"Option '%s' should have '%s' default value on\"\n-                        + \" supported CPU\", optionName,\n-                TestPrintPreciseRTMLockingStatisticsBase.DEFAULT_VALUE),\n-                CommandLineOptionTest.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\");\n-\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName,\n-                TestPrintPreciseRTMLockingStatisticsBase.DEFAULT_VALUE,\n-                String.format(\"Option '%s' should have '%s' default value on\"\n-                        + \" supported CPU when -XX:-UseRTMLocking flag set\",\n-                        optionName,\n-                       TestPrintPreciseRTMLockingStatisticsBase.DEFAULT_VALUE),\n-                CommandLineOptionTest.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:-UseRTMLocking\", prepareOptionValue(\"true\"));\n-\n-        \/\/ verify that option could be turned on\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName, \"true\",\n-                String.format(\"Option '%s' should have 'true' value when set \"\n-                        + \"on supported CPU and -XX:+UseRTMLocking flag set\",\n-                        optionName),\n-                CommandLineOptionTest.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\", prepareOptionValue(\"true\"));\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestPrintPreciseRTMLockingStatisticsOptionOnSupportedConfig()\n-                .runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestPrintPreciseRTMLockingStatisticsOptionOnSupportedConfig.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify PrintPreciseRTMLockingStatistics on CPUs or OSs without\n- *          rtm support and\/or unsupported VM.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires !vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestPrintPreciseRTMLockingStatisticsOptionOnUnsupportedConfig\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-public class TestPrintPreciseRTMLockingStatisticsOptionOnUnsupportedConfig\n-        extends TestPrintPreciseRTMLockingStatisticsBase {\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestPrintPreciseRTMLockingStatisticsOptionOnUnsupportedConfig()\n-                .runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestPrintPreciseRTMLockingStatisticsOptionOnUnsupportedConfig.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify processing of RTMAbortThreshold option.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestRTMAbortThresholdOption\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-public class TestRTMAbortThresholdOption\n-        extends RTMGenericCommandLineOptionTest {\n-    private static final String DEFAULT_VALUE = \"1000\";\n-\n-    private TestRTMAbortThresholdOption() {\n-        super(\"RTMAbortThreshold\", false, true,\n-                TestRTMAbortThresholdOption.DEFAULT_VALUE,\n-                \"0\", \"42\", \"100\", \"10000\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMAbortThresholdOption().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestRTMAbortThresholdOption.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify processing of RTMLockingCalculationDelay option.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestRTMLockingCalculationDelayOption\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-public class TestRTMLockingCalculationDelayOption\n-        extends RTMGenericCommandLineOptionTest {\n-    private static final String DEFAULT_VALUE = \"0\";\n-\n-    private TestRTMLockingCalculationDelayOption() {\n-        super(\"RTMLockingCalculationDelay\", false,\n-                true, TestRTMLockingCalculationDelayOption.DEFAULT_VALUE);\n-    }\n-\n-    public static void main(String agrs[]) throws Throwable {\n-        new TestRTMLockingCalculationDelayOption().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestRTMLockingCalculationDelayOption.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify processing of RTMLockingThreshold option.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestRTMLockingThresholdOption\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-public class TestRTMLockingThresholdOption\n-        extends RTMGenericCommandLineOptionTest {\n-    private static final String DEFAULT_VALUE = \"10000\";\n-\n-    private TestRTMLockingThresholdOption() {\n-        super(\"RTMLockingThreshold\", false, true,\n-                TestRTMLockingThresholdOption.DEFAULT_VALUE);\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMLockingThresholdOption().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestRTMLockingThresholdOption.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify processing of RTMRetryCount option.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestRTMRetryCountOption\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-public class TestRTMRetryCountOption extends RTMGenericCommandLineOptionTest {\n-    private static final String DEFAULT_VALUE = \"5\";\n-\n-    private TestRTMRetryCountOption() {\n-        super(\"RTMRetryCount\", false, false,\n-                TestRTMRetryCountOption.DEFAULT_VALUE,\n-                \"0\", \"10\", \"100\", \"1000\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMRetryCountOption().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestRTMRetryCountOption.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify processing of RTMSpinLoopCount option.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestRTMSpinLoopCountOption\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-public class TestRTMSpinLoopCountOption\n-        extends RTMGenericCommandLineOptionTest {\n-    private static final String DEFAULT_VALUE = \"100\";\n-\n-    private TestRTMSpinLoopCountOption() {\n-        super(\"RTMSpinLoopCount\", false, true,\n-                TestRTMSpinLoopCountOption.DEFAULT_VALUE,\n-                \"0\", \"10\", \"42\", \"1000\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMSpinLoopCountOption().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestRTMSpinLoopCountOption.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify RTMTotalCountIncrRate option processing on CPU and OS with\n- *          rtm support and on VM with rtm locking support.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestRTMTotalCountIncrRateOptionOnSupportedConfig\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-public class TestRTMTotalCountIncrRateOptionOnSupportedConfig\n-        extends RTMLockingAwareTest {\n-    private static final String DEFAULT_VALUE = \"64\";\n-\n-    private TestRTMTotalCountIncrRateOptionOnSupportedConfig() {\n-        super(\"RTMTotalCountIncrRate\", false, true,\n-                TestRTMTotalCountIncrRateOptionOnSupportedConfig.DEFAULT_VALUE,\n-                \/* correct values *\/\n-                new String[] { \"1\", \"2\", \"128\", \"1024\" },\n-                \/* incorrect values *\/\n-                new String[] { \"3\", \"5\", \"7\", \"42\" },\n-                RTMGenericCommandLineOptionTest.RTM_COUNT_INCR_WARNING);\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMTotalCountIncrRateOptionOnSupportedConfig().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestRTMTotalCountIncrRateOptionOnSupportedConfig.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify UseRTMDeopt option processing on CPUs with rtm support\n- *          when rtm locking is supported by VM.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestUseRTMDeoptOptionOnSupportedConfig\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class TestUseRTMDeoptOptionOnSupportedConfig {\n-    private static final String DEFAULT_VALUE = \"false\";\n-\n-    public void runTestCases() throws Throwable {\n-        String shouldPassMessage = \" JVM should startup with option '\"\n-                + \"-XX:+UseRTMDeopt' without any warnings\";\n-        \/\/ verify that option could be turned on\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                null, null, shouldPassMessage, shouldPassMessage, ExitCode.OK,\n-                \"-XX:+UseRTMDeopt\");\n-        shouldPassMessage = \" JVM should startup with option '\"\n-                + \"-XX:-UseRTMDeopt' without any warnings\";\n-        \/\/ verify that option could be turned off\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                null, null, shouldPassMessage, shouldPassMessage, ExitCode.OK,\n-                \"-XX:-UseRTMDeopt\");\n-        String defValMessage = String.format(\"UseRTMDeopt should have '%s'\"\n-                                    + \"default value\",\n-                        TestUseRTMDeoptOptionOnSupportedConfig.DEFAULT_VALUE);\n-        \/\/ verify default value\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseRTMDeopt\",\n-                TestUseRTMDeoptOptionOnSupportedConfig.DEFAULT_VALUE,\n-                defValMessage);\n-        \/\/ verify default value\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseRTMDeopt\",\n-                TestUseRTMDeoptOptionOnSupportedConfig.DEFAULT_VALUE,\n-                defValMessage,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\");\n-        \/\/ verify that option is off when UseRTMLocking is off\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseRTMDeopt\",\n-                \"false\", \"UseRTMDeopt should be off when UseRTMLocking is off\",\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:-UseRTMLocking\", \"-XX:+UseRTMDeopt\");\n-        \/\/ verify that option could be turned on\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseRTMDeopt\", \"true\",\n-                \"UseRTMDeopt should be on when UseRTMLocking is on and \"\n-                        + \"'-XX:+UseRTMDeopt' flag set\",\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\", \"-XX:+UseRTMDeopt\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMDeoptOptionOnSupportedConfig().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMDeoptOptionOnSupportedConfig.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify UseRTMDeopt option processing on CPUs or OSs without rtm support\n- *          or on VMs without rtm locking support.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires !vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestUseRTMDeoptOptionOnUnsupportedConfig\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class TestUseRTMDeoptOptionOnUnsupportedConfig\n-        extends RTMGenericCommandLineOptionTest {\n-    private static final String DEFAULT_VALUE = \"false\";\n-\n-    private TestUseRTMDeoptOptionOnUnsupportedConfig() {\n-        super(\"UseRTMDeopt\", true, false,\n-                TestUseRTMDeoptOptionOnUnsupportedConfig.DEFAULT_VALUE,\n-                \"true\");\n-    }\n-\n-    @Override\n-    protected void runX86SupportedVMTestCases() throws Throwable {\n-        super.verifyJVMStartup();\n-        \/\/ verify default value\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName,\n-                defaultValue, String.format(\"'%s' should have '%s' \"\n-                        + \"default value on unsupported configs.\",\n-                        optionName, DEFAULT_VALUE));\n-        \/\/ verify that until RTMLocking is not used, value\n-        \/\/ will be set to default false.\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName,\n-                defaultValue, String.format(\"'%s' should be off on unsupported\"\n-                        + \" configs even if '-XX:+%s' flag set\", optionName,\n-                        optionName),\n-                \"-XX:+UseRTMDeopt\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMDeoptOptionOnUnsupportedConfig().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMDeoptOptionOnUnsupportedConfig.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify UseRTMForStackLocks option processing on CPU and OS with\n- *          rtm support when VM supports rtm locking.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestUseRTMForStackLocksOptionOnSupportedConfig\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class TestUseRTMForStackLocksOptionOnSupportedConfig {\n-    private static final String DEFAULT_VALUE = \"false\";\n-\n-    public void runTestCases() throws Throwable {\n-        String errorMessage\n-                = CommandLineOptionTest.getExperimentalOptionErrorMessage(\n-                \"UseRTMForStackLocks\");\n-        String warningMessage\n-                = RTMGenericCommandLineOptionTest.RTM_FOR_STACK_LOCKS_WARNING;\n-\n-        String shouldFailMessage = \" VM option 'UseRTMForStackLocks' is \"\n-                + \"experimental%nJVM startup should fail without \"\n-                + \"-XX:+UnlockExperimentalVMOptions flag\";\n-\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                new String[] { errorMessage }, null, shouldFailMessage,\n-                shouldFailMessage + \"%nError message expected\", ExitCode.FAIL,\n-                \"-XX:+UseRTMForStackLocks\");\n-        String shouldPassMessage = \" VM option 'UseRTMForStackLocks'\"\n-                + \" is experimental%nJVM startup should pass with \"\n-                + \"-XX:+UnlockExperimentalVMOptions flag\";\n-        \/\/ verify that we get a warning when trying to use rtm for stack\n-        \/\/ lock, but not using rtm locking.\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                new String[] { warningMessage }, null, shouldPassMessage,\n-                \"There should be warning when trying to use rtm for stack \"\n-                        + \"lock, but not using rtm locking\", ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMForStackLocks\",\n-                \"-XX:-UseRTMLocking\");\n-        \/\/ verify that we don't get a warning when no using rtm for stack\n-        \/\/ lock and not using rtm locking.\n-        CommandLineOptionTest.verifySameJVMStartup(null,\n-                new String[] { warningMessage }, shouldPassMessage,\n-                \"There should not be any warning when use both \"\n-                        + \"-XX:-UseRTMForStackLocks and -XX:-UseRTMLocking \"\n-                        + \"flags\",\n-                ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:-UseRTMForStackLocks\",\n-                \"-XX:-UseRTMLocking\");\n-        \/\/ verify that we don't get a warning when using rtm for stack\n-        \/\/ lock and using rtm locking.\n-        CommandLineOptionTest.verifySameJVMStartup(null,\n-                new String[] { warningMessage }, shouldPassMessage,\n-                \"There should not be any warning when use both \"\n-                        + \"-XX:+UseRTMForStackLocks and -XX:+UseRTMLocking\"\n-                        + \" flags\",\n-                ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMForStackLocks\",\n-                \"-XX:+UseRTMLocking\");\n-        \/\/ verify that default value if false\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseRTMForStackLocks\",\n-                TestUseRTMForStackLocksOptionOnSupportedConfig.DEFAULT_VALUE,\n-                \"Default value of option 'UseRTMForStackLocks' should be false\",\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS);\n-        \/\/ verify that default value is false even with +UseRTMLocking\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseRTMForStackLocks\",\n-                TestUseRTMForStackLocksOptionOnSupportedConfig.DEFAULT_VALUE,\n-                \"Default value of option 'UseRTMForStackLocks' should be false\",\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\");\n-        \/\/ verify that we can turn the option on\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseRTMForStackLocks\",\n-                        \"true\", \"Value of option 'UseRTMForStackLocks' should \"\n-                                + \"be able to be set as 'true' when both \"\n-                                + \"-XX:+UseRTMForStackLocks and \"\n-                                + \"-XX:+UseRTMLocking flags used\",\n-                        CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                        \"-XX:+UseRTMLocking\", \"-XX:+UseRTMForStackLocks\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMForStackLocksOptionOnSupportedConfig().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMForStackLocksOptionOnSupportedConfig.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify UseRTMForStackLocks option processing on CPUs or OSs without\n- *          rtm support and\/or on VMs without rtm locking support.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires !vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestUseRTMForStackLocksOptionOnUnsupportedConfig\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class TestUseRTMForStackLocksOptionOnUnsupportedConfig\n-        extends RTMGenericCommandLineOptionTest {\n-    private static final String DEFAULT_VALUE = \"false\";\n-\n-    private TestUseRTMForStackLocksOptionOnUnsupportedConfig() {\n-        super(\"UseRTMForStackLocks\", true, true,\n-                TestUseRTMForStackLocksOptionOnUnsupportedConfig.DEFAULT_VALUE,\n-                \"true\");\n-    }\n-\n-    @Override\n-    protected void runX86SupportedVMTestCases() throws Throwable {\n-        String shouldFailMessage = String.format(\"VM option '%s' is \"\n-                + \"experimental%nJVM startup should fail without \"\n-                + \"-XX:+UnlockExperimentalVMOptions flag\", optionName);\n-\n-        \/\/ verify that option is experimental\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                new String[] { experimentalOptionError }, null,\n-                shouldFailMessage, shouldFailMessage + \"%nError message \"\n-                        + \"should be shown\", ExitCode.FAIL,\n-                prepareOptionValue(\"true\"));\n-\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                new String[]{ experimentalOptionError }, null,\n-                shouldFailMessage, shouldFailMessage + \"%nError message \"\n-                        + \"should be shown\", ExitCode.FAIL,\n-                prepareOptionValue(\"false\"));\n-\n-        String shouldPassMessage = String.format(\"VM option '%s' is \"\n-                + \" experimental%nJVM startup should pass with \"\n-                + \"-XX:+UnlockExperimentalVMOptions flag\", optionName);\n-        \/\/ verify that if we turn it on, then VM output will contain\n-        \/\/ warning saying that this option could be turned on only\n-        \/\/ when we use rtm locking\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                new String[]{\n-                    RTMGenericCommandLineOptionTest.RTM_FOR_STACK_LOCKS_WARNING\n-                }, null, shouldPassMessage, \"There should be warning when try \"\n-                    + \"to use rtm for stack lock, but not using rtm locking\",\n-                ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                prepareOptionValue(\"true\")\n-        );\n-        \/\/ verify that options is turned off by default\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName,\n-                TestUseRTMForStackLocksOptionOnUnsupportedConfig.DEFAULT_VALUE,\n-                String.format(\"Default value of option '%s' should be '%s'\",\n-                        optionName, DEFAULT_VALUE),\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS);\n-        \/\/ verify that it could not be turned on without rtm locking\n-        CommandLineOptionTest.verifyOptionValueForSameVM(optionName,\n-                TestUseRTMForStackLocksOptionOnUnsupportedConfig.DEFAULT_VALUE,\n-                String.format(\"Value of '%s' shouldn't able to be set to \"\n-                        + \"'true' without setting -XX:+UseRTMLocking flag\",\n-                        optionName),\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                prepareOptionValue(\"true\"));\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMForStackLocksOptionOnUnsupportedConfig().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMForStackLocksOptionOnUnsupportedConfig.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify UseRTMLocking option processing on CPU and OS with rtm support and\n- *          on VM with rtm locking support.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestUseRTMLockingOptionOnSupportedConfig\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class TestUseRTMLockingOptionOnSupportedConfig {\n-    private static final String DEFAULT_VALUE = \"false\";\n-\n-    public void runTestCases() throws Throwable {\n-        String unrecongnizedOption\n-                =  CommandLineOptionTest.getUnrecognizedOptionErrorMessage(\n-                \"UseRTMLocking\");\n-        String shouldPassMessage = \"VM option 'UseRTMLocking' is experimental\"\n-                + \"%nJVM startup should pass with \"\n-                + \"-XX:+UnlockExperimentalVMOptions flag\";\n-        \/\/ verify that there are no warning or error in VM output\n-        CommandLineOptionTest.verifySameJVMStartup(null,\n-                new String[]{\n-                        RTMGenericCommandLineOptionTest.RTM_INSTR_ERROR,\n-                        unrecongnizedOption\n-                }, shouldPassMessage, \"There should not be any warning when use\"\n-                        + \"with -XX:+UnlockExperimentalVMOptions\", ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\"\n-        );\n-\n-        CommandLineOptionTest.verifySameJVMStartup(null,\n-                new String[]{\n-                        RTMGenericCommandLineOptionTest.RTM_INSTR_ERROR,\n-                        unrecongnizedOption\n-                }, shouldPassMessage, \"There should not be any warning when use\"\n-                        + \"with -XX:+UnlockExperimentalVMOptions\", ExitCode.OK,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:-UseRTMLocking\"\n-        );\n-        \/\/ verify that UseRTMLocking is of by default\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseRTMLocking\",\n-                TestUseRTMLockingOptionOnSupportedConfig.DEFAULT_VALUE,\n-                String.format(\"Default value of option 'UseRTMLocking' should \"\n-                    + \"be '%s'\", DEFAULT_VALUE),\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS);\n-        \/\/ verify that we can change UseRTMLocking value\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseRTMLocking\",\n-                TestUseRTMLockingOptionOnSupportedConfig.DEFAULT_VALUE,\n-                String.format(\"Default value of option 'UseRTMLocking' should \"\n-                    + \"be '%s'\", DEFAULT_VALUE),\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:-UseRTMLocking\");\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseRTMLocking\",\n-                \"true\", \"Value of 'UseRTMLocking' should be set \"\n-                        + \"to 'true' if -XX:+UseRTMLocking flag set\",\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-XX:+UseRTMLocking\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMLockingOptionOnSupportedConfig().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMLockingOptionOnSupportedConfig.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify UseRTMLocking option processing on CPUs without\n- *          rtm support.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires !vm.rtm.cpu & vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestUseRTMLockingOptionOnUnsupportedCPU\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class TestUseRTMLockingOptionOnUnsupportedCPU {\n-    private static final String DEFAULT_VALUE = \"false\";\n-\n-    public void runTestCases() throws Throwable {\n-        String unrecognizedOption\n-                = CommandLineOptionTest.getUnrecognizedOptionErrorMessage(\n-                \"UseRTMLocking\");\n-        String errorMessage = RTMGenericCommandLineOptionTest.RTM_INSTR_ERROR;\n-\n-        if (Platform.isX86() || Platform.isX64()) {\n-            String shouldFailMessage = \"JVM startup should fail with option \" +\n-                                       \"-XX:+UseRTMLocking on unsupported CPU\";\n-\n-            \/\/ verify that we get an error when use +UseRTMLocking\n-            \/\/ on unsupported CPU\n-            CommandLineOptionTest.verifySameJVMStartup(\n-                    new String[] { errorMessage },\n-                    new String[] { unrecognizedOption }, shouldFailMessage,\n-                    shouldFailMessage + \". Error message should be shown.\",\n-                    ExitCode.FAIL, \"-XX:+UseRTMLocking\");\n-\n-            String shouldPassMessage = \"JVM startup should pass with option \"\n-                    + \"-XX:-UseRTMLocking even on unsupported CPU\";\n-            \/\/ verify that we can pass -UseRTMLocking without\n-            \/\/ getting any error messages\n-            CommandLineOptionTest.verifySameJVMStartup(null, new String[] {\n-                    errorMessage, unrecognizedOption }, shouldPassMessage,\n-                    shouldPassMessage + \" without any warnings\", ExitCode.OK,\n-                    \"-XX:-UseRTMLocking\");\n-\n-            \/\/ verify that UseRTMLocking is false by default\n-            CommandLineOptionTest.verifyOptionValueForSameVM(\"UseRTMLocking\",\n-                    TestUseRTMLockingOptionOnUnsupportedCPU.DEFAULT_VALUE,\n-                    String.format(\"Default value of option 'UseRTMLocking' \"\n-                        +\"should be '%s'\", DEFAULT_VALUE));\n-        } else {\n-            String shouldFailMessage = \"RTMLocking should be unrecognized\"\n-                    + \" on non-x86 CPUs. JVM startup should fail.\"\n-                    + \"Error message should be shown\";\n-            \/\/ verify that on non-x86 CPUs RTMLocking could not be used\n-            CommandLineOptionTest.verifySameJVMStartup(\n-                    new String[] { unrecognizedOption },\n-                    null, shouldFailMessage, shouldFailMessage,\n-                    ExitCode.FAIL, \"-XX:+UseRTMLocking\");\n-\n-            CommandLineOptionTest.verifySameJVMStartup(\n-                    new String[] { unrecognizedOption },\n-                    null, shouldFailMessage, shouldFailMessage,\n-                    ExitCode.FAIL, \"-XX:-UseRTMLocking\");\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMLockingOptionOnUnsupportedCPU().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMLockingOptionOnUnsupportedCPU.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify UseRTMLocking option processing on CPU with rtm support\n- *          in case when VM should not support this option.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.cpu & !(vm.flavor == \"server\" & !vm.emulatedClient)\n- * @run driver compiler.rtm.cli.TestUseRTMLockingOptionOnUnsupportedVM\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-import jdk.test.lib.process.ExitCode;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-public class TestUseRTMLockingOptionOnUnsupportedVM {\n-    private static final String DEFAULT_VALUE = \"false\";\n-\n-    public void runTestCases() throws Throwable {\n-        String errorMessage\n-                = RTMGenericCommandLineOptionTest.RTM_UNSUPPORTED_VM_ERROR;\n-        String shouldFailMessage = \"JVM startup should fail with option \"\n-                + \"-XX:+UseRTMLocking even on unsupported VM. Error message\"\n-                + \" should be shown\";\n-        String shouldPassMessage = \"JVM startup should pass with option \"\n-                + \"-XX:-UseRTMLocking even on unsupported VM\";\n-        \/\/ verify that we can't use +UseRTMLocking\n-        CommandLineOptionTest.verifySameJVMStartup(\n-                new String[] { errorMessage }, null, shouldFailMessage,\n-                shouldFailMessage, ExitCode.FAIL,\n-                 \"-XX:+UseRTMLocking\");\n-        \/\/ verify that we can turn it off\n-        CommandLineOptionTest.verifySameJVMStartup(null,\n-                new String[] { errorMessage }, shouldPassMessage,\n-                shouldPassMessage + \" without any warnings\", ExitCode.OK,\n-                \"-XX:-UseRTMLocking\");\n-        \/\/ verify that it is off by default\n-        CommandLineOptionTest.verifyOptionValueForSameVM(\"UseRTMLocking\",\n-                TestUseRTMLockingOptionOnUnsupportedVM.DEFAULT_VALUE,\n-                String.format(\"Default value of option 'UseRTMLocking' should\"\n-                    + \" be '%s'\", DEFAULT_VALUE));\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMLockingOptionOnUnsupportedVM().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMLockingOptionOnUnsupportedVM.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify processing of UseRTMXendForLockBusy option.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.flagless\n- * @requires vm.rtm.compiler\n- * @run driver compiler.rtm.cli.TestUseRTMXendForLockBusyOption\n- *\/\n-\n-package compiler.rtm.cli;\n-\n-public class TestUseRTMXendForLockBusyOption\n-        extends RTMGenericCommandLineOptionTest {\n-    private static final String DEFAULT_VALUE = \"true\";\n-\n-    public TestUseRTMXendForLockBusyOption() {\n-        super(\"UseRTMXendForLockBusy\", true, true,\n-                TestUseRTMXendForLockBusyOption.DEFAULT_VALUE, \"true\");\n-    }\n-\n-    public static void main(String agrs[]) throws Throwable {\n-        new TestUseRTMXendForLockBusyOption().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMXendForLockBusyOption.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,165 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that RTMAbortRatio affects amount of aborts before\n- *          deoptimization.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.locking.TestRTMAbortRatio\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.XAbortProvoker;\n-import compiler.testlibrary.rtm.CompilableTest;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that method will be deoptimized on high abort ratio\n- * as soon as abort ratio reaches RTMAbortRatio's value.\n- *\/\n-public class TestRTMAbortRatio {\n-\n-    protected void runTestCases() throws Throwable {\n-        verifyAbortRatio(0, false);\n-        verifyAbortRatio(10, false);\n-        verifyAbortRatio(50, false);\n-        verifyAbortRatio(100, false);\n-\n-        verifyAbortRatio(0, true);\n-        verifyAbortRatio(10, true);\n-        verifyAbortRatio(50, true);\n-        verifyAbortRatio(100, true);\n-    }\n-\n-    private void verifyAbortRatio(int abortRatio, boolean useStackLock)\n-            throws Throwable {\n-        CompilableTest test = new Test();\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                test,\n-                CommandLineOptionTest.prepareBooleanFlag(\"UseRTMForStackLocks\",\n-                        useStackLock),\n-                \"-XX:+UseRTMDeopt\",\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:RTMAbortThreshold=0\",\n-                CommandLineOptionTest.prepareNumericFlag(\"RTMLockingThreshold\",\n-                        10 * Test.TOTAL_ITERATIONS),\n-                CommandLineOptionTest.prepareNumericFlag(\"RTMAbortRatio\",\n-                        abortRatio),\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                test.getClass().getName(),\n-                Boolean.toString(!useStackLock));\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                test.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 1, \"VM output should contain \"\n-                + \"exactly one RTM locking statistics entry.\");\n-\n-        RTMLockingStatistics lock = statistics.get(0);\n-        int actualRatio;\n-\n-        if (lock.getTotalAborts() == 1L) {\n-            actualRatio = 0;\n-        } else {\n-            actualRatio = (int) (lock.getTotalLocks()\n-                    \/ (lock.getTotalAborts() - 1L));\n-        }\n-\n-        Asserts.assertLTE(actualRatio, abortRatio, String.format(\n-                \"Actual abort ratio (%d) should lower or equal to \"\n-                + \"specified (%d).\", actualRatio, abortRatio));\n-    }\n-\n-    \/**\n-     * Force abort after {@code Test.WARMUP_ITERATIONS} is done.\n-     *\/\n-    public static class Test implements CompilableTest {\n-        private static final int TOTAL_ITERATIONS = 10000;\n-        private static final int WARMUP_ITERATIONS = 1000;\n-        private final XAbortProvoker xabort = new XAbortProvoker();\n-        private final Object monitor = new Object();\n-        \/\/ Following field have to be static in order to avoid escape analysis.\n-        @SuppressWarnings(\"UnsuedDeclaration\")\n-        private static int field = 0;\n-\n-        @Override\n-        public String getMethodWithLockName() {\n-             return this.getClass().getName() + \"::lock\";\n-         }\n-\n-        @Override\n-        public String[] getMethodsToCompileNames() {\n-            return new String[] { getMethodWithLockName(), \"*.doAbort\" };\n-        }\n-\n-        public void lock(boolean abort) {\n-            synchronized(monitor) {\n-                if (abort) {\n-                    xabort.doAbort();\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Usage:\n-         * Test &lt;inflate monitor&gt;\n-         *\/\n-        public static void main(String args[]) throws Throwable {\n-            Asserts.assertGTE(args.length, 1, \"One argument required.\");\n-            Test t = new Test();\n-            boolean shouldBeInflated = Boolean.valueOf(args[0]);\n-            if (shouldBeInflated) {\n-                AbortProvoker.inflateMonitor(t.monitor);\n-            }\n-            for (int i = 0; i < Test.TOTAL_ITERATIONS; i++) {\n-                AbortProvoker.verifyMonitorState(t.monitor, shouldBeInflated);\n-                t.lock(i >= Test.WARMUP_ITERATIONS);\n-            }\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMAbortRatio().runTestCases();\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestRTMAbortRatio.java","additions":0,"deletions":165,"binary":false,"changes":165,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that RTMAbortThreshold option affects\n- *          amount of aborts after which abort ratio is calculated.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.locking.TestRTMAbortThreshold\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.AbortType;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that on RTMAbortThreshold option actually affects how soon\n- * method will be deoptimized on high abort ratio.\n- *\/\n-public class TestRTMAbortThreshold {\n-\n-    protected void runTestCases() throws Throwable {\n-        verifyAbortThreshold(false, 1);\n-        verifyAbortThreshold(false, 10);\n-        verifyAbortThreshold(false, 1000);\n-\n-        verifyAbortThreshold(true, 1);\n-        verifyAbortThreshold(true, 10);\n-        verifyAbortThreshold(true, 1000);\n-    }\n-\n-    private void verifyAbortThreshold(boolean useStackLock,\n-            long abortThreshold) throws Throwable {\n-        AbortProvoker provoker = AbortType.XABORT.provoker();\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                provoker,\n-                \"-XX:+UseRTMDeopt\",\n-                \"-XX:RTMAbortRatio=0\",\n-                CommandLineOptionTest.prepareNumericFlag(\"RTMAbortThreshold\",\n-                        abortThreshold),\n-                CommandLineOptionTest.prepareBooleanFlag(\"UseRTMForStackLocks\",\n-                        useStackLock),\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                AbortProvoker.class.getName(),\n-                AbortType.XABORT.toString(),\n-                Boolean.toString(!useStackLock));\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                provoker.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 1, \"VM output should contain \"\n-                + \"exactly one RTM locking statistics entry for method \"\n-                + provoker.getMethodWithLockName());\n-\n-        Asserts.assertEQ(statistics.get(0).getTotalLocks(), abortThreshold,\n-                String.format(\"Expected that method with rtm lock elision was\"\n-                        + \" deoptimized after %d lock attempts\",\n-                        abortThreshold));\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-         new TestRTMAbortThreshold().runTestCases();\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestRTMAbortThreshold.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,212 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that if we use RTMDeopt, then deoptimization\n- *          caused by reason other then rtm_state_change will reset\n- *          method's RTM state. And if we don't use RTMDeopt, then\n- *          RTM state remain the same after such deoptimization.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.locking.TestRTMAfterNonRTMDeopt\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.XAbortProvoker;\n-import compiler.testlibrary.rtm.CompilableTest;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.List;\n-\n-\/**\n- * To verify that with +UseRTMDeopt method's RTM state will be\n- * changed to ProfileRTM on deoptimization unrelated to\n- * rtm_state_change following sequence of events is used:\n- * <pre>\n- *\n- *     rtm state ^\n- *               |\n- *       UseRTM  |      ******|     ******\n- *               |            |\n- *   ProfileRTM  |******|     |*****|\n- *               |      |     |     |\n- *              0-------|-----|-----|---------------------&gt; time\n- *                      |     |     \\ force abort\n- *                      |     |\n- *                      |     \\ force deoptimization\n- *                      |\n- *                      \\ force xabort\n- * <\/pre>\n- * When xabort is forced by native method call method should\n- * change it's state to UseRTM, because we use RTMAbortRatio=100\n- * and low RTMLockingThreshold, so at this point actual abort\n- * ratio will be below 100% and there should be enough lock\n- * attempts to recompile method without RTM profiling.\n- *\/\n-public class TestRTMAfterNonRTMDeopt {\n-    private static final int ABORT_THRESHOLD = 1000;\n-    private static final String RANGE_CHECK = \"range_check\";\n-\n-    protected void runTestCases() throws Throwable {\n-        verifyRTMAfterDeopt(false, false);\n-        verifyRTMAfterDeopt(true, false);\n-\n-        verifyRTMAfterDeopt(false, true);\n-        verifyRTMAfterDeopt(true, true);\n-    }\n-\n-    private void verifyRTMAfterDeopt(boolean useStackLock,\n-            boolean useRTMDeopt) throws Throwable {\n-        CompilableTest test = new Test();\n-        String logFile = String.format(\"rtm_%s_stack_lock_%s_deopt.xml\",\n-                (useStackLock ? \"use\" : \"no\"), (useRTMDeopt ? \"use\" : \"no\"));\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                logFile,\n-                test,\n-                \"-XX:CompileThreshold=1\",\n-                CommandLineOptionTest.prepareBooleanFlag(\"UseRTMForStackLocks\",\n-                        useStackLock),\n-                CommandLineOptionTest.prepareBooleanFlag(\"UseRTMDeopt\",\n-                        useRTMDeopt),\n-                \"-XX:RTMAbortRatio=100\",\n-                CommandLineOptionTest.prepareNumericFlag(\"RTMAbortThreshold\",\n-                        TestRTMAfterNonRTMDeopt.ABORT_THRESHOLD),\n-                CommandLineOptionTest.prepareNumericFlag(\"RTMLockingThreshold\",\n-                        TestRTMAfterNonRTMDeopt.ABORT_THRESHOLD \/ 2L),\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                Test.class.getName(),\n-                Boolean.toString(!useStackLock)\n-        );\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        int traps = RTMTestBase.firedRTMStateChangeTraps(logFile);\n-\n-        if (useRTMDeopt) {\n-            Asserts.assertEQ(traps, 2, \"Two uncommon traps with \"\n-                    + \"reason rtm_state_change should be fired.\");\n-        } else {\n-            Asserts.assertEQ(traps, 0, \"No uncommon traps with \"\n-                    + \"reason rtm_state_change should be fired.\");\n-        }\n-\n-        int rangeCheckTraps = RTMTestBase.firedUncommonTraps(logFile,\n-                TestRTMAfterNonRTMDeopt.RANGE_CHECK);\n-\n-        Asserts.assertEQ(rangeCheckTraps, 1,\n-                \"One range_check uncommon trap should be fired.\");\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                test.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        int expectedStatEntries = (useRTMDeopt ? 4 : 2);\n-\n-        Asserts.assertEQ(statistics.size(), expectedStatEntries,\n-                String.format(\"VM output should contain %d RTM locking \"\n-                        + \"statistics entries.\", expectedStatEntries));\n-    }\n-\n-    public static class Test implements CompilableTest {\n-        \/\/ Following field have to be static in order to avoid escape analysis.\n-        @SuppressWarnings(\"UnsuedDeclaration\")\n-        private static int field = 0;\n-        private static final int ITERATIONS = 10000;\n-        private static final int RANGE_CHECK_AT = ITERATIONS \/ 2;\n-        private final XAbortProvoker xabort = new XAbortProvoker();\n-        private final Object monitor = new Object();\n-\n-        @Override\n-        public String getMethodWithLockName() {\n-            return this.getClass().getName() + \"::forceAbort\";\n-        }\n-\n-        @Override\n-        public String[] getMethodsToCompileNames() {\n-            return new String[] { getMethodWithLockName(),\n-                                  XAbortProvoker.class.getName() + \"::doAbort()\" };\n-        }\n-\n-        public void forceAbort(int a[], boolean abort) {\n-            try {\n-                synchronized(monitor) {\n-                    a[0]++;\n-                    if (abort) {\n-                        Test.field = xabort.doAbort();\n-                    }\n-                }\n-            } catch (Throwable t) {\n-                \/\/ suppress any throwables\n-            }\n-        }\n-\n-        \/**\n-         * Usage:\n-         * Test &lt;inflate monitor&gt;\n-         *\/\n-        public static void main(String args[]) throws Throwable {\n-            Test t = new Test();\n-\n-            boolean shouldBeInflated = Boolean.valueOf(args[0]);\n-            if (shouldBeInflated) {\n-                AbortProvoker.inflateMonitor(t.monitor);\n-            }\n-\n-            int tmp[] = new int[1];\n-\n-            for (int i = 0; i < Test.ITERATIONS; i++ ) {\n-                AbortProvoker.verifyMonitorState(t.monitor, shouldBeInflated);\n-                if (i == Test.RANGE_CHECK_AT) {\n-                    t.forceAbort(new int[0], false);\n-                } else {\n-                    boolean isThreshold\n-                            = (i == TestRTMAfterNonRTMDeopt.ABORT_THRESHOLD);\n-                    boolean isThresholdPlusRange\n-                            = (i == TestRTMAfterNonRTMDeopt.ABORT_THRESHOLD\n-                            + Test.RANGE_CHECK_AT);\n-                    t.forceAbort(tmp, isThreshold || isThresholdPlusRange);\n-                }\n-            }\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMAfterNonRTMDeopt().runTestCases();\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestRTMAfterNonRTMDeopt.java","additions":0,"deletions":212,"binary":false,"changes":212,"status":"deleted"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that on high abort ratio method will be recompiled\n- *          without rtm locking.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.locking.TestRTMDeoptOnHighAbortRatio\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.AbortType;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that on high abort ratio method wil be deoptimized with\n- * <i>rtm_state_change<\/i> reason and after that RTM-based lock elision will not\n- * be used for that method.\n- * This test make asserts on total locks count done by compiled method,\n- * so in order to avoid issue with retriable locks -XX:RTMRetryCount=0 is used.\n- * For more details on that issue see {@link TestUseRTMAfterLockInflation}.\n- *\/\n-public class TestRTMDeoptOnHighAbortRatio {\n-    private static final long ABORT_THRESHOLD\n-            = AbortProvoker.DEFAULT_ITERATIONS \/ 2L;\n-\n-    protected void runTestCases() throws Throwable {\n-        verifyDeopt(false);\n-        verifyDeopt(true);\n-    }\n-\n-    private void verifyDeopt(boolean useStackLock) throws Throwable {\n-        AbortProvoker provoker = AbortType.XABORT.provoker();\n-        String logFileName = String.format(\"rtm_deopt_%s_stack_lock.xml\",\n-                (useStackLock ? \"use\" : \"no\"));\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                logFileName,\n-                provoker,\n-                \"-XX:+UseRTMDeopt\",\n-                CommandLineOptionTest.prepareBooleanFlag(\"UseRTMForStackLocks\",\n-                        useStackLock),\n-                \"-XX:RTMRetryCount=0\",\n-                CommandLineOptionTest.prepareNumericFlag(\"RTMAbortThreshold\",\n-                        TestRTMDeoptOnHighAbortRatio.ABORT_THRESHOLD),\n-                \"-XX:RTMAbortRatio=100\",\n-                \"-XX:CompileThreshold=1\",\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                AbortProvoker.class.getName(),\n-                AbortType.XABORT.toString(),\n-                Boolean.toString(!useStackLock)\n-        );\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        int firedTraps = RTMTestBase.firedRTMStateChangeTraps(logFileName);\n-\n-        Asserts.assertEQ(firedTraps, 1, \"Expected to get only one \"\n-                + \"deoptimization due to rtm state change\");\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                provoker.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 1, \"VM output should contain \"\n-                + \"exactly one RTM locking statistics entry for method \"\n-                + provoker.getMethodWithLockName());\n-\n-        Asserts.assertEQ(statistics.get(0).getTotalLocks(),\n-                TestRTMDeoptOnHighAbortRatio.ABORT_THRESHOLD,\n-                \"After AbortThreshold was reached, method should be\"\n-                + \" recompiled without rtm lock eliding.\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMDeoptOnHighAbortRatio().runTestCases();\n-    }\n-}\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestRTMDeoptOnHighAbortRatio.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -1,169 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that on low abort ratio method will be recompiled.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.locking.TestRTMDeoptOnLowAbortRatio\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.XAbortProvoker;\n-import compiler.testlibrary.rtm.CompilableTest;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that low abort ratio method will be deoptimized with\n- * <i>rtm_state_change<\/i> reason and will continue to use RTM-based lock\n- * elision after that.\n- * This test make asserts on total locks count done by compiled method,\n- * so in order to avoid issue with retriable locks -XX:RTMRetryCount=0 is used.\n- * For more details on that issue see {@link TestUseRTMAfterLockInflation}.\n- *\/\n-public class TestRTMDeoptOnLowAbortRatio {\n-    private static final long LOCKING_THRESHOLD = 100L;\n-    private static final long ABORT_THRESHOLD = LOCKING_THRESHOLD \/ 2L;\n-\n-    protected void runTestCases() throws Throwable {\n-        verifyRTMDeopt(false);\n-        verifyRTMDeopt(true);\n-    }\n-\n-    private void verifyRTMDeopt(boolean useStackLock) throws Throwable {\n-        CompilableTest test = new Test();\n-        String logFileName = String.format(\"rtm_deopt_%s_stack_lock.xml\",\n-                                           useStackLock ? \"use\" : \"no\");\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                logFileName,\n-                test,\n-                \"-XX:+UseRTMDeopt\",\n-                CommandLineOptionTest.prepareBooleanFlag(\"UseRTMForStackLocks\",\n-                        useStackLock),\n-                CommandLineOptionTest.prepareNumericFlag(\"RTMLockingThreshold\",\n-                        TestRTMDeoptOnLowAbortRatio.LOCKING_THRESHOLD),\n-                CommandLineOptionTest.prepareNumericFlag(\"RTMAbortThreshold\",\n-                        TestRTMDeoptOnLowAbortRatio.ABORT_THRESHOLD),\n-                \"-XX:RTMAbortRatio=100\",\n-                \"-XX:CompileThreshold=1\",\n-                \"-XX:RTMRetryCount=0\",\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                Test.class.getName(),\n-                Boolean.toString(!useStackLock)\n-        );\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        int firedTraps = RTMTestBase.firedRTMStateChangeTraps(logFileName);\n-\n-        Asserts.assertEQ(firedTraps, 1,\n-                        \"Expected to get only one deoptimization due to rtm\"\n-                        + \" state change\");\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                test.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 2,\n-                         \"VM output should contain two RTM locking \"\n-                         + \"statistics entries for method \"\n-                         + test.getMethodWithLockName());\n-\n-        RTMLockingStatistics statisticsBeforeDeopt = null;\n-\n-        for (RTMLockingStatistics s : statistics) {\n-            if (s.getTotalLocks()\n-                    == TestRTMDeoptOnLowAbortRatio.LOCKING_THRESHOLD) {\n-                Asserts.assertNull(statisticsBeforeDeopt,\n-                        \"Only one abort was expected during test run\");\n-                statisticsBeforeDeopt = s;\n-            }\n-        }\n-\n-        Asserts.assertNotNull(statisticsBeforeDeopt,\n-                \"After LockThreshold was reached, method should be recompiled \"\n-                + \"with rtm lock eliding.\");\n-    }\n-\n-    public static class Test implements CompilableTest {\n-        private final XAbortProvoker xabort = new XAbortProvoker();\n-        private final Object monitor = new Object();\n-\n-        @Override\n-        public String getMethodWithLockName() {\n-            return this.getClass().getName() + \"::forceAbort\";\n-        }\n-\n-        @Override\n-        public String[] getMethodsToCompileNames() {\n-            return new String[] { getMethodWithLockName(),\n-                                  XAbortProvoker.class.getName() + \"::doAbort\" };\n-        }\n-\n-        public void forceAbort(boolean abort) {\n-            synchronized(monitor) {\n-                if (abort) {\n-                    xabort.doAbort();\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Usage:\n-         * Test &lt;inflate monitor&gt;\n-         *\/\n-        public static void main(String args[]) throws Throwable {\n-            Asserts.assertGTE(args.length, 1, \"One argument required.\");\n-            Test t = new Test();\n-            boolean shouldBeInflated = Boolean.valueOf(args[0]);\n-            if (shouldBeInflated) {\n-                AbortProvoker.inflateMonitor(t.monitor);\n-            }\n-            for (int i = 0; i < AbortProvoker.DEFAULT_ITERATIONS; i++) {\n-                AbortProvoker.verifyMonitorState(t.monitor, shouldBeInflated);\n-                t.forceAbort(i >= TestRTMDeoptOnLowAbortRatio.ABORT_THRESHOLD);\n-            }\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMDeoptOnLowAbortRatio().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java","additions":0,"deletions":169,"binary":false,"changes":169,"status":"deleted"},{"patch":"@@ -1,106 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that RTMLockingCalculationDelay affect when\n- *          abort ratio calculation is started.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.locking.TestRTMLockingCalculationDelay\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.AbortType;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-\/**\n- * Test verifies that abort ratio calculation could be delayed using\n- * RTMLockingCalculationDelay option.\n- *\/\n-public class TestRTMLockingCalculationDelay {\n-    private static final boolean INFLATE_MONITOR = true;\n-\n-    protected void runTestCases() throws Throwable {\n-        \/\/ verify that calculation will be started immediately\n-        verifyLockingCalculationDelay(0, 0, true);\n-\n-        \/\/ verify that calculation will not be started during\n-        \/\/ first 10 minutes, while test will be started immediately\n-        verifyLockingCalculationDelay(600000, 0, false);\n-\n-        \/\/ verify that calculation will be started after a second\n-        verifyLockingCalculationDelay(1000, 1000, true);\n-    }\n-\n-    private void verifyLockingCalculationDelay(long delay, long testDelay,\n-            boolean deoptExpected) throws Throwable {\n-        AbortProvoker provoker = AbortType.XABORT.provoker();\n-        String logFileName = String.format(\"rtm_delay_%d_%d.xml\", delay,\n-                testDelay);\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                logFileName,\n-                provoker,\n-                \"-XX:+UseRTMDeopt\",\n-                CommandLineOptionTest.prepareNumericFlag(\n-                        \"RTMLockingCalculationDelay\", delay),\n-                \"-XX:RTMAbortRatio=0\",\n-                \"-XX:RTMAbortThreshold=0\",\n-                AbortProvoker.class.getName(),\n-                AbortType.XABORT.toString(),\n-                Boolean.toString(\n-                        TestRTMLockingCalculationDelay.INFLATE_MONITOR),\n-                Long.toString(AbortProvoker.DEFAULT_ITERATIONS),\n-                Long.toString(testDelay)\n-        );\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        int deopts = RTMTestBase.firedRTMStateChangeTraps(logFileName);\n-\n-        if (deoptExpected) {\n-            Asserts.assertGT(deopts, 0, \"At least one deoptimization due to \"\n-                    + \"rtm_state_chage is expected\");\n-        } else {\n-            Asserts.assertEQ(deopts, 0, \"No deoptimizations due to \"\n-                    + \"rtm_state_chage are expected\");\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMLockingCalculationDelay().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestRTMLockingCalculationDelay.java","additions":0,"deletions":106,"binary":false,"changes":106,"status":"deleted"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that RTMLockingThreshold affects rtm state transition\n- *          ProfileRTM => UseRTM.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.locking.TestRTMLockingThreshold\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.XAbortProvoker;\n-import compiler.testlibrary.rtm.CompilableTest;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that RTMLockingThreshold option actually affects how soon\n- * method will be deoptimized on low abort ratio.\n- *\/\n-public class TestRTMLockingThreshold {\n-\n-    \/**\n-     * We use non-zero abort threshold to avoid abort related to\n-     * interrupts, VMM calls, etc. during first lock attempt.\n-     *\n-     *\/\n-    private static final int MIN_ABORT_THRESHOLD = 10;\n-\n-    protected void runTestCases() throws Throwable {\n-        verifyLockingThreshold(0, false);\n-        verifyLockingThreshold(100, false);\n-        verifyLockingThreshold(1000, false);\n-\n-        verifyLockingThreshold(0, true);\n-        verifyLockingThreshold(100, true);\n-        verifyLockingThreshold(1000, true);\n-    }\n-\n-    private void verifyLockingThreshold(int lockingThreshold,\n-            boolean useStackLock) throws Throwable {\n-        CompilableTest test = new Test();\n-\n-        int abortThreshold = Math.max(lockingThreshold \/ 2,\n-                TestRTMLockingThreshold.MIN_ABORT_THRESHOLD);\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                test,\n-                \"-XX:CompileThreshold=1\",\n-                CommandLineOptionTest.prepareBooleanFlag(\"UseRTMForStackLocks\",\n-                        useStackLock),\n-                \"-XX:+UseRTMDeopt\",\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:RTMRetryCount=0\",\n-                CommandLineOptionTest.prepareNumericFlag(\"RTMAbortThreshold\",\n-                        abortThreshold),\n-                CommandLineOptionTest.prepareNumericFlag(\"RTMLockingThreshold\",\n-                        lockingThreshold),\n-                \"-XX:RTMAbortRatio=100\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                Test.class.getName(),\n-                Boolean.toString(!useStackLock),\n-                Integer.toString(lockingThreshold)\n-        );\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                test.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 2, \"VM output should contain two \"\n-                + \"RTM locking statistics entries.\");\n-\n-        \/**\n-         * If RTMLockingThreshold==0, then we have to make at least 1 call.\n-         *\/\n-        long expectedValue = lockingThreshold;\n-        if (expectedValue == 0) {\n-            expectedValue++;\n-        }\n-\n-        RTMLockingStatistics statBeforeDeopt = null;\n-        for (RTMLockingStatistics s : statistics) {\n-            if (s.getTotalLocks() == expectedValue) {\n-                Asserts.assertNull(statBeforeDeopt,\n-                        \"Only one statistics entry should contain aborts\");\n-                statBeforeDeopt = s;\n-            }\n-        }\n-\n-        Asserts.assertNotNull(statBeforeDeopt, \"There should be exactly one \"\n-                + \"statistics entry corresponding to ProfileRTM state.\");\n-    }\n-\n-    public static class Test implements CompilableTest {\n-        \/\/ Following field have to be static in order to avoid escape analysis.\n-        @SuppressWarnings(\"UnsuedDeclaration\")\n-        private static int field = 0;\n-        private static final int TOTAL_ITERATIONS = 10000;\n-        private final XAbortProvoker xabort = new XAbortProvoker();\n-        private final Object monitor = new Object();\n-\n-        @Override\n-        public String getMethodWithLockName() {\n-            return this.getClass().getName() + \"::lock\";\n-        }\n-\n-        @Override\n-        public String[] getMethodsToCompileNames() {\n-            return new String[] { getMethodWithLockName(),\n-                                  XAbortProvoker.class.getName() + \"::doAbort\" };\n-        }\n-\n-        public void lock(boolean abort) {\n-            synchronized(monitor) {\n-                if (abort) {\n-                    Test.field += xabort.doAbort();\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Usage:\n-         * Test &lt;inflate monitor&gt;\n-         *\/\n-        public static void main(String args[]) throws Throwable {\n-            Asserts.assertGTE(args.length, 2, \"Two arguments required.\");\n-            Test t = new Test();\n-            boolean shouldBeInflated = Boolean.valueOf(args[0]);\n-            int lockingThreshold = Integer.valueOf(args[1]);\n-            if (shouldBeInflated) {\n-                AbortProvoker.inflateMonitor(t.monitor);\n-            }\n-            for (int i = 0; i < Test.TOTAL_ITERATIONS; i++) {\n-                AbortProvoker.verifyMonitorState(t.monitor, shouldBeInflated);\n-                t.lock(i >= lockingThreshold \/ 2);\n-            }\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMLockingThreshold().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestRTMLockingThreshold.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that RTMRetryCount affects actual amount of retries.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI\n- *                   compiler.rtm.locking.TestRTMRetryCount\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.BusyLock;\n-import compiler.testlibrary.rtm.CompilableTest;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that RTMRetryCount option actually affects amount of\n- * retries on lock busy.\n- *\/\n-public class TestRTMRetryCount {\n-    \/**\n-     * Time in ms, during which busy lock will be locked.\n-     *\/\n-    private static final int LOCKING_TIME = 5000;\n-    private static final boolean INFLATE_MONITOR = true;\n-\n-    protected void runTestCases() throws Throwable {\n-        verifyRTMRetryCount(0);\n-        verifyRTMRetryCount(1);\n-        verifyRTMRetryCount(5);\n-        verifyRTMRetryCount(10);\n-    }\n-\n-    private void verifyRTMRetryCount(int retryCount) throws Throwable {\n-        CompilableTest busyLock = new BusyLock();\n-        long expectedAborts = retryCount + 1L;\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                busyLock,\n-                \"-XX:-UseRTMXendForLockBusy\",\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                CommandLineOptionTest.prepareNumericFlag(\"RTMRetryCount\",\n-                        retryCount),\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                BusyLock.class.getName(),\n-                Boolean.toString(TestRTMRetryCount.INFLATE_MONITOR),\n-                Integer.toString(TestRTMRetryCount.LOCKING_TIME)\n-        );\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                busyLock.getMethodWithLockName(), outputAnalyzer.getStdout());\n-\n-        Asserts.assertEQ(statistics.size(), 1, \"VM output should contain \"\n-                + \"exactly one rtm locking statistics entry for method \"\n-                + busyLock.getMethodWithLockName());\n-\n-        Asserts.assertEQ(statistics.get(0).getTotalAborts(), expectedAborts,\n-                String.format(\"It is expected to get %d aborts\",\n-                        expectedAborts));\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMRetryCount().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestRTMRetryCount.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that RTMSpinLoopCount affects time spent\n- *          between locking attempts.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI\n- *                   compiler.rtm.locking.TestRTMSpinLoopCount\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.BusyLock;\n-import compiler.testlibrary.rtm.CompilableTest;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-import jdk.test.lib.Platform;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that RTMSpinLoopCount increase time spent between retries\n- * by comparing amount of retries done with different RTMSpinLoopCount's values.\n- *\/\n-public class TestRTMSpinLoopCount {\n-    private static final int LOCKING_TIME = 1000;\n-    private static final int RTM_RETRY_COUNT = 1000;\n-    private static final boolean INFLATE_MONITOR = true;\n-    private static final long MAX_ABORTS = RTM_RETRY_COUNT + 1L;\n-    private static int[] SPIN_LOOP_COUNTS;\n-\n-    protected void runTestCases() throws Throwable {\n-\n-        SPIN_LOOP_COUNTS = new int[] { 0, 100, 1_000, 10_000, 100_000 };\n-\n-        long[] aborts = new long[TestRTMSpinLoopCount.SPIN_LOOP_COUNTS.length];\n-\n-        for (int i = 0; i < TestRTMSpinLoopCount.SPIN_LOOP_COUNTS.length; i++) {\n-            aborts[i] = getAbortsCountOnLockBusy(\n-                    TestRTMSpinLoopCount.SPIN_LOOP_COUNTS[i]);\n-        }\n-\n-        for (int i = 1; i < aborts.length; i++) {\n-            Asserts.assertLTE(aborts[i], aborts[i - 1], \"Increased spin loop \"\n-                    + \"count should not increase retries count.\");\n-        }\n-    }\n-\n-    private long getAbortsCountOnLockBusy(int spinLoopCount) throws Throwable {\n-        CompilableTest test = new BusyLock();\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                test,\n-                CommandLineOptionTest.prepareNumericFlag(\"RTMRetryCount\",\n-                        TestRTMSpinLoopCount.RTM_RETRY_COUNT),\n-                CommandLineOptionTest.prepareNumericFlag(\"RTMSpinLoopCount\",\n-                        spinLoopCount),\n-                \"-XX:-UseRTMXendForLockBusy\",\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                BusyLock.class.getName(),\n-                Boolean.toString(TestRTMSpinLoopCount.INFLATE_MONITOR),\n-                Integer.toString(TestRTMSpinLoopCount.LOCKING_TIME)\n-        );\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                test.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 1,\n-                \"VM output should contain exactly one entry for method \"\n-                 + test.getMethodWithLockName());\n-\n-        RTMLockingStatistics lock = statistics.get(0);\n-\n-        Asserts.assertLTE(lock.getTotalAborts(),\n-                TestRTMSpinLoopCount.MAX_ABORTS, String.format(\"Total aborts \"\n-                        + \"count (%d) should be less or equal to %d\",\n-                        lock.getTotalAborts(),\n-                        TestRTMSpinLoopCount.MAX_ABORTS));\n-\n-        return lock.getTotalAborts();\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMSpinLoopCount().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestRTMSpinLoopCount.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -1,163 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that RTMTotalCountIncrRate option affects\n- *          RTM locking statistics.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.locking.TestRTMTotalCountIncrRate\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.XAbortProvoker;\n-import compiler.testlibrary.rtm.CompilableTest;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that with RTMTotalCountIncrRate=1 RTM locking statistics\n- * contains precise information abort attempted locks and that with other values\n- * statistics contains information abort non-zero locking attempts.\n- * Since assert done for RTMTotalCountIncrRate=1 is pretty strict, test uses\n- * -XX:RTMRetryCount=0 to avoid issue with retriable aborts. For more details on\n- * that issue see {@link TestUseRTMAfterLockInflation}.\n- *\/\n-public class TestRTMTotalCountIncrRate {\n-    protected void runTestCases() throws Throwable {\n-        verifyLocksCount(1, false);\n-        verifyLocksCount(64, false);\n-        verifyLocksCount(128, false);\n-        verifyLocksCount(1, true);\n-        verifyLocksCount(64, true);\n-        verifyLocksCount(128, true);\n-    }\n-\n-    private void verifyLocksCount(int incrRate, boolean useStackLock)\n-            throws Throwable{\n-        CompilableTest test = new Test();\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                test,\n-                CommandLineOptionTest.prepareBooleanFlag(\"UseRTMForStackLocks\",\n-                        useStackLock),\n-                CommandLineOptionTest.prepareNumericFlag(\n-                        \"RTMTotalCountIncrRate\", incrRate),\n-                \"-XX:RTMRetryCount=0\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                Test.class.getName(),\n-                Boolean.toString(!useStackLock)\n-        );\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                test.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 1, \"VM output should contain \"\n-                + \"exactly one RTM locking statistics entry for method \"\n-                + test.getMethodWithLockName());\n-\n-        RTMLockingStatistics lock = statistics.get(0);\n-        if (incrRate == 1) {\n-            Asserts.assertEQ(lock.getTotalLocks(), Test.TOTAL_ITERATIONS,\n-                    \"Total locks should be exactly the same as amount of \"\n-                    + \"iterations.\");\n-        }\n-    }\n-\n-    public static class Test implements CompilableTest {\n-        private static final long TOTAL_ITERATIONS = 10000L;\n-        private final XAbortProvoker xabort = new XAbortProvoker();\n-        private final Object monitor = new Object();\n-        \/\/ Following field have to be static in order to avoid escape analysis.\n-        @SuppressWarnings(\"UnsuedDeclaration\")\n-        private static int field = 0;\n-\n-        @Override\n-        public String getMethodWithLockName() {\n-            return this.getClass().getName() + \"::lock\";\n-        }\n-\n-        @Override\n-        public String[] getMethodsToCompileNames() {\n-            return new String[] { getMethodWithLockName(), \"*.doAbort\" };\n-        }\n-\n-        public void lock(boolean forceAbort) {\n-            synchronized(monitor) {\n-                if (forceAbort) {\n-                    \/\/ We're calling native method in order to force\n-                    \/\/ abort. It's done by explicit xabort call emitted\n-                    \/\/ in SharedRuntime::generate_native_wrapper.\n-                    \/\/ If an actual JNI call will be replaced by\n-                    \/\/ intrinsic - we'll be in trouble, since xabort\n-                    \/\/ will be no longer called and test may fail.\n-                    xabort.doAbort();\n-                }\n-                Test.field++;\n-            }\n-        }\n-\n-        \/**\n-         * Usage:\n-         * Test &lt;inflate monitor&gt;\n-         *\/\n-        public static void main(String args[]) throws Throwable {\n-            Asserts.assertGTE(args.length, 1, \"One argument required.\");\n-            Test test = new Test();\n-            boolean shouldBeInflated = Boolean.valueOf(args[0]);\n-            if (shouldBeInflated) {\n-                AbortProvoker.inflateMonitor(test.monitor);\n-            }\n-            for (long i = 0L; i < Test.TOTAL_ITERATIONS; i++) {\n-                AbortProvoker.verifyMonitorState(test.monitor,\n-                        shouldBeInflated);\n-                \/\/ Force abort on first iteration to avoid rare case when\n-                \/\/ there were no aborts and locks count was not incremented\n-                \/\/ with RTMTotalCountIncrRate > 1 (in such case JVM won't\n-                \/\/ print JVM locking statistics).\n-                test.lock(i == 0);\n-            }\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestRTMTotalCountIncrRate().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestRTMTotalCountIncrRate.java","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"},{"patch":"@@ -1,128 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that rtm locking is used for stack locks before\n- *          inflation and after it used for inflated locks.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.locking.TestUseRTMAfterLockInflation\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.AbortType;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that RTM is used after lock inflation by executing compiled\n- * method with RTM-based lock elision using stack lock first, then that lock\n- * is inflated and the same compiled method invoked again.\n- *\n- * Compiled method invoked {@code AbortProvoker.DEFAULT_ITERATIONS} times before\n- * lock inflation and the same amount of times after inflation.\n- * As a result total locks count should be equal to\n- * {@code 2 * AbortProvoker.DEFAULT_ITERATIONS}.\n- * It is a pretty strict assertion which could fail if some retriable abort\n- * happened: it could be {@code AbortType.RETRIABLE} or\n- * {@code AbortType.MEM_CONFLICT}, but unfortunately abort can has both these\n- * reasons simultaneously. In order to avoid false negative failures related\n- * to incorrect aborts counting, -XX:RTMRetryCount=0 is used.\n- *\/\n-public class TestUseRTMAfterLockInflation {\n-    private static final long EXPECTED_LOCKS\n-            = 2L * AbortProvoker.DEFAULT_ITERATIONS;\n-\n-    protected void runTestCases() throws Throwable {\n-        AbortProvoker provoker = AbortType.XABORT.provoker();\n-        long totalLocksCount = 0;\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                provoker,\n-                \"-XX:+UseRTMForStackLocks\",\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:RTMRetryCount=0\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                Test.class.getName(),\n-                AbortType.XABORT.toString());\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                provoker.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 2,\n-                \"VM output should contain two rtm locking statistics entries \"\n-                + \"for method \" + provoker.getMethodWithLockName());\n-\n-        for (RTMLockingStatistics s : statistics) {\n-            totalLocksCount += s.getTotalLocks();\n-        }\n-\n-        Asserts.assertEQ(totalLocksCount,\n-                TestUseRTMAfterLockInflation.EXPECTED_LOCKS,\n-                \"Total lock count should be greater or equal to \"\n-                + TestUseRTMAfterLockInflation.EXPECTED_LOCKS);\n-    }\n-\n-    public static class Test {\n-        \/**\n-         * Usage:\n-         * Test &lt;provoker type&gt;\n-         *\/\n-        public static void main(String args[]) throws Throwable {\n-            Asserts.assertGT(args.length, 0,\n-                    \"AbortType name is expected as first argument.\");\n-\n-            AbortProvoker provoker\n-                    = AbortType.lookup(Integer.valueOf(args[0])).provoker();\n-            for (int i = 0; i < AbortProvoker.DEFAULT_ITERATIONS; i++) {\n-                AbortProvoker.verifyMonitorState(provoker, false \/*deflated*\/);\n-                provoker.forceAbort();\n-            }\n-            provoker.inflateMonitor();\n-            for (int i = 0; i < AbortProvoker.DEFAULT_ITERATIONS; i++) {\n-                AbortProvoker.verifyMonitorState(provoker, true \/*inflated*\/);\n-                provoker.forceAbort();\n-            }\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMAfterLockInflation().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestUseRTMAfterLockInflation.java","additions":0,"deletions":128,"binary":false,"changes":128,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that UseRTMDeopt affects uncommon trap installation in\n- *          compiled methods with synchronized block.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.locking.TestUseRTMDeopt\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.AbortType;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-\/**\n- * Test verifies that usage of UseRTMDeopt option affects uncommon traps usage\n- * for methods that use locking.\n- *\/\n-public class TestUseRTMDeopt {\n-\n-    protected void runTestCases() throws Throwable {\n-        verifyUseRTMDeopt(false);\n-        verifyUseRTMDeopt(true);\n-    }\n-\n-    private void verifyUseRTMDeopt(boolean useRTMDeopt) throws Throwable {\n-        AbortProvoker provoker = AbortType.XABORT.provoker();\n-        String logFileName = String.format(\"rtm_%s_deopt.xml\",\n-                useRTMDeopt ? \"use\" : \"no\");\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                logFileName,\n-                provoker,\n-                CommandLineOptionTest.prepareBooleanFlag(\"UseRTMDeopt\",\n-                        useRTMDeopt),\n-                AbortProvoker.class.getName(),\n-                AbortType.XABORT.toString()\n-        );\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        int expectedUncommonTraps = useRTMDeopt ? 1 : 0;\n-        int installedUncommonTraps\n-                = RTMTestBase.installedRTMStateChangeTraps(logFileName);\n-\n-        Asserts.assertEQ(expectedUncommonTraps, installedUncommonTraps,\n-                String.format(\"Expected to find %d uncommon traps \"\n-                              + \"installed with reason rtm_state_change.\",\n-                        expectedUncommonTraps));\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMDeopt().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestUseRTMDeopt.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that rtm locking is used for inflated locks.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.locking.TestUseRTMForInflatedLocks\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.AbortType;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that RTM-based lock elision could be used for inflated locks\n- * by calling compiled method that use RTM-based lock elision and using\n- * manually inflated lock.\n- * Compiled method invoked {@code AbortProvoker.DEFAULT_ITERATIONS} times,\n- * so total locks count should be the same.\n- * This test could also be affected by retriable aborts, so -XX:RTMRetryCount=0\n- * is used. For more information abort that issue see\n- * {@link TestUseRTMAfterLockInflation}.\n- *\/\n-public class TestUseRTMForInflatedLocks {\n-\n-    protected void runTestCases() throws Throwable {\n-        AbortProvoker provoker = AbortType.XABORT.provoker();\n-        RTMLockingStatistics lock;\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                provoker,\n-                \"-XX:-UseRTMForStackLocks\",\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:RTMRetryCount=0\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                AbortProvoker.class.getName(),\n-                AbortType.XABORT.toString());\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                provoker.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 1,\n-                \"VM output should contain exactly one rtm locking statistics \"\n-                + \"entry for method \" + provoker.getMethodWithLockName());\n-\n-        lock = statistics.get(0);\n-        Asserts.assertEQ(lock.getTotalLocks(), AbortProvoker.DEFAULT_ITERATIONS,\n-                \"Total lock count should be greater or equal to \"\n-                + AbortProvoker.DEFAULT_ITERATIONS);\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMForInflatedLocks().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestUseRTMForInflatedLocks.java","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that rtm locking is used for stack locks.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.locking.TestUseRTMForStackLocks\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.AbortType;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that RTM-based lock elision could be used for stack locks\n- * by calling compiled method that use RTM-based lock elision and using\n- * stack lock.\n- * Compiled method invoked {@code AbortProvoker.DEFAULT_ITERATIONS} times,\n- * so total locks count should be the same.\n- * This test could also be affected by retriable aborts, so -XX:RTMRetryCount=0\n- * is used. For more information abort that issue see\n- * {@link TestUseRTMAfterLockInflation}.\n- *\/\n-public class TestUseRTMForStackLocks {\n-    private static final boolean INFLATE_MONITOR = false;\n-\n-    protected void runTestCases() throws Throwable {\n-        AbortProvoker provoker = AbortType.XABORT.provoker();\n-        RTMLockingStatistics lock;\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                provoker,\n-                \"-XX:+UseRTMForStackLocks\",\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:RTMRetryCount=0\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                AbortProvoker.class.getName(),\n-                AbortType.XABORT.toString(),\n-                Boolean.toString(TestUseRTMForStackLocks.INFLATE_MONITOR));\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                provoker.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 1,\n-                \"VM output should contain exactly one rtm locking statistics \"\n-                + \"entry for method \" + provoker.getMethodWithLockName());\n-\n-        lock = statistics.get(0);\n-        Asserts.assertEQ(lock.getTotalLocks(), AbortProvoker.DEFAULT_ITERATIONS,\n-                \"Total locks count should be greater or equal to \"\n-                + AbortProvoker.DEFAULT_ITERATIONS);\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMForStackLocks().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestUseRTMForStackLocks.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that UseRTMXendForLockBusy option affects\n- *          method behaviour if lock is busy.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                   -XX:+WhiteBoxAPI\n- *                   compiler.rtm.locking.TestUseRTMXendForLockBusy\n- *\/\n-\n-package compiler.rtm.locking;\n-\n-import compiler.testlibrary.rtm.AbortType;\n-import compiler.testlibrary.rtm.BusyLock;\n-import compiler.testlibrary.rtm.CompilableTest;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that with +UseRTMXendForLockBusy there will be no aborts\n- * forced by the test.\n- *\/\n-public class TestUseRTMXendForLockBusy {\n-    private final static int LOCKING_TIME = 5000;\n-\n-    protected void runTestCases() throws Throwable {\n-        \/\/ inflated lock, xabort on lock busy\n-        verifyXendForLockBusy(true, false);\n-        \/\/ inflated lock, xend on lock busy\n-        verifyXendForLockBusy(true, true);\n-        \/\/ stack lock, xabort on lock busy\n-        verifyXendForLockBusy(false, false);\n-        \/\/ stack lock, xend on lock busy\n-        verifyXendForLockBusy(false, true);\n-    }\n-\n-    private void verifyXendForLockBusy(boolean inflateMonitor,\n-            boolean useXend) throws Throwable {\n-        CompilableTest test = new BusyLock();\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                test,\n-                CommandLineOptionTest.prepareBooleanFlag(\"UseRTMForStackLocks\",\n-                        !inflateMonitor),\n-                CommandLineOptionTest.prepareBooleanFlag(\n-                        \"UseRTMXendForLockBusy\",\n-                        useXend),\n-                \"-XX:RTMRetryCount=0\",\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                BusyLock.class.getName(),\n-                Boolean.toString(inflateMonitor),\n-                Integer.toString(TestUseRTMXendForLockBusy.LOCKING_TIME)\n-        );\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                test.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 1, \"VM output should contain \"\n-                + \"exactly one rtm locking statistics entry for method \"\n-                + test.getMethodWithLockName());\n-\n-        long aborts = statistics.get(0).getAborts(AbortType.XABORT);\n-\n-        if (useXend) {\n-            Asserts.assertEQ(aborts, 0L,\n-                    \"Expected to get no aborts on busy lock\");\n-        } else {\n-            Asserts.assertGT(aborts, 0L,\n-                    \"Expected to get at least one abort on busy lock\");\n-        }\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMXendForLockBusy().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that NoRTMLockEliding option could be applied to\n- *          specified method and that such method will not use rtm.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.method_options.TestNoRTMLockElidingOption\n- *\/\n-\n-package compiler.rtm.method_options;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.AbortType;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that method tagged with option <i>NoRTMLockElidingOption<\/i>\n- * will not use RTM-based lock elision.\n- * Test invokes compiled method and checks that no deoptimization with\n- * <i>rtm_state_change<\/i> reason had happened and that that VM output\n- * does not contain RTM locking statistics for compiled method.\n- *\/\n-public class TestNoRTMLockElidingOption {\n-\n-    public void runTestCases() throws Throwable {\n-        verifyOption(false);\n-        verifyOption(true);\n-    }\n-\n-    public void verifyOption(boolean useStackLock) throws Throwable {\n-        AbortProvoker provoker = AbortType.XABORT.provoker();\n-        String logFileName = String.format(\"rtm_deopt_%s_stack_lock.xml\",\n-                (useStackLock ? \"use\" : \"no\"));\n-        String methodOption = String.format(\"-XX:CompileCommand=option,\" +\n-                \"%s,NoRTMLockEliding\", provoker.getMethodWithLockName());\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                logFileName,\n-                provoker,\n-                CommandLineOptionTest.prepareBooleanFlag(\"UseRTMForStackLocks\",\n-                        useStackLock),\n-                methodOption,\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:+UseRTMDeopt\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                AbortProvoker.class.getName(),\n-                AbortType.XABORT.toString(),\n-                Boolean.toString(!useStackLock)\n-        );\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        int firedTraps = RTMTestBase.firedRTMStateChangeTraps(logFileName);\n-\n-        Asserts.assertEQ(firedTraps, 0,\n-                \"No deoptimizations with rtm_state_change reason are expected\");\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                provoker.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 0,\n-                \"VM output should not contain RTM locking statistics entries \"\n-                + \"for method \" + provoker.getMethodWithLockName());\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestNoRTMLockElidingOption().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/method_options\/TestNoRTMLockElidingOption.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that UseRTMLockEliding option could be applied to\n- *          specified method and that such method will not be deoptimized\n- *          on high abort ratio.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.method_options.TestUseRTMLockElidingOption\n- *\/\n-\n-package compiler.rtm.method_options;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.AbortType;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.util.List;\n-\n-\/**\n- * Test verifies that method tagged with option <i>UseRTMLockElidingOption<\/i>\n- * will use RTM-based lock elision, but will be never deoptimized with\n- * <i>rtm_state_change reason<\/i>.\n- * Test invokes compiled method and checks that no deoptimization with\n- * <i>rtm_state_change<\/i> reason had happened and that that VM output\n- * contains RTM locking statistics for compiled method and that total locks\n- * count equals to method's invocations.\n- * Since last assert is pretty strict, test uses -XX:RTMRetryCount=0 in order\n- * to avoid issue with retriable aborts described in\n- * {@link TestUseRTMAfterLockInflation}.\n- *\/\n-public class TestUseRTMLockElidingOption {\n-\n-    public void runTestCases() throws Throwable {\n-        verifyOption(false);\n-        verifyOption(true);\n-    }\n-\n-    public void verifyOption(boolean useStackLock) throws Throwable {\n-        AbortProvoker provoker = AbortType.XABORT.provoker();\n-        String logFileName = String.format(\"rtm_deopt_%s_stack_lock.xml\",\n-                (useStackLock ? \"use\" : \"no\"));\n-        String methodOption = String.format(\"-XX:CompileCommand=option,\" +\n-                \"%s,UseRTMLockEliding\", provoker.getMethodWithLockName());\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                logFileName,\n-                provoker,\n-                CommandLineOptionTest.prepareBooleanFlag(\"UseRTMForStackLocks\",\n-                        useStackLock),\n-                methodOption,\n-                \"-XX:RTMTotalCountIncrRate=1\",\n-                \"-XX:RTMRetryCount=0\",\n-                \"-XX:+UseRTMDeopt\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                provoker.getClass().getName(),\n-                AbortType.XABORT.toString(),\n-                Boolean.toString(!useStackLock)\n-        );\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        int firedTraps = RTMTestBase.firedRTMStateChangeTraps(logFileName);\n-\n-        Asserts.assertEQ(firedTraps, 0,\n-                \"Method deoptimization with rtm_state_change is unexpected\");\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                provoker.getMethodWithLockName(), outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 1,\n-                \"VM output should contain exactly one RTM locking \"\n-                + \"statistics entry for method \"\n-                + provoker.getMethodWithLockName());\n-\n-        RTMLockingStatistics lock = statistics.get(0);\n-\n-        Asserts.assertEQ(lock.getTotalLocks(), AbortProvoker.DEFAULT_ITERATIONS,\n-                \"Expected to get total locks count equal to total amount of \"\n-                + \"lock attempts.\");\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestUseRTMLockElidingOption().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/method_options\/TestUseRTMLockElidingOption.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,142 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8031320\n- * @summary Verify that rtm locking statistics contain proper information\n- *          on overall aborts and locks count and count of aborts of\n- *          different types. Test also verify that VM output does not\n- *          contain rtm locking statistics when it should not.\n- * @library \/test\/lib \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @requires vm.rtm.cpu & vm.rtm.compiler\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm\/native -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n- *                          -XX:+WhiteBoxAPI\n- *                          compiler.rtm.print.TestPrintPreciseRTMLockingStatistics\n- *\/\n-\n-\n-package compiler.rtm.print;\n-\n-import compiler.testlibrary.rtm.AbortProvoker;\n-import compiler.testlibrary.rtm.AbortType;\n-import compiler.testlibrary.rtm.RTMLockingStatistics;\n-import compiler.testlibrary.rtm.RTMTestBase;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-\n-\/**\n- * Test verifies that VM output does not contain RTM locking statistics when it\n- * should not (when PrintPreciseRTMLockingStatistics is off) and that with\n- * -XX:+PrintPreciseRTMLockingStatistics locking statistics contains sane\n- * total locks and aborts count as well as for specific abort types.\n- *\/\n-public class TestPrintPreciseRTMLockingStatistics {\n-\n-    public void runTestCases() throws Throwable {\n-        verifyNoStatistics();\n-        verifyStatistics();\n-    }\n-\n-    \/\/ verify that VM output does not contain\n-    \/\/ rtm locking statistics\n-    private void verifyNoStatistics() throws Throwable {\n-        verifyNoStatistics(AbortType.XABORT);\n-\n-        verifyNoStatistics(AbortType.XABORT,\n-                \"-XX:-PrintPreciseRTMLockingStatistics\");\n-\n-        verifyNoStatistics(AbortType.XABORT, \"-XX:-UseRTMLocking\",\n-                \"-XX:+PrintPreciseRTMLockingStatistics\");\n-    }\n-\n-    \/\/ verify that rtm locking statistics contain information\n-    \/\/ about each type of aborts\n-    private void verifyStatistics() throws Throwable {\n-        verifyAbortsCount(AbortType.XABORT);\n-        verifyAbortsCount(AbortType.MEM_CONFLICT);\n-        verifyAbortsCount(AbortType.BUF_OVERFLOW);\n-        verifyAbortsCount(AbortType.NESTED_ABORT);\n-    }\n-\n-    private void verifyNoStatistics(AbortType abortProvokerType,\n-            String... vmOpts) throws Throwable {\n-        AbortProvoker provoker = abortProvokerType.provoker();\n-        List<String> finalVMOpts = new LinkedList<>();\n-        Collections.addAll(finalVMOpts, vmOpts);\n-        Collections.addAll(finalVMOpts, AbortProvoker.class.getName(),\n-                abortProvokerType.toString());\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(provoker,\n-                finalVMOpts.toArray(new String[finalVMOpts.size()]));\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                outputAnalyzer.getOutput());\n-\n-        Asserts.assertEQ(statistics.size(), 0, \"VM output should not contain \"\n-                + \"any RTM locking statistics\");\n-    }\n-\n-    private void verifyAbortsCount(AbortType abortType) throws Throwable {\n-        AbortProvoker provoker = abortType.provoker();\n-\n-        OutputAnalyzer outputAnalyzer = RTMTestBase.executeRTMTest(\n-                provoker,\n-                \"-XX:+PrintPreciseRTMLockingStatistics\",\n-                AbortProvoker.class.getName(),\n-                abortType.toString());\n-\n-        outputAnalyzer.shouldHaveExitValue(0);\n-\n-        List<RTMLockingStatistics> statistics = RTMLockingStatistics.fromString(\n-                provoker.getMethodWithLockName(),outputAnalyzer.getOutput());\n-\n-        Asserts.assertGT(statistics.size(), 0, \"VM output should contain one \"\n-                + \"rtm locking statistics entry for method \"\n-                + provoker.getMethodWithLockName());\n-\n-        RTMLockingStatistics lock = statistics.get(0);\n-\n-        Asserts.assertGT(lock.getTotalAborts(), 0L,\n-                \"RTM locking statistics should contain non zero total aborts \"\n-                + \"count\");\n-\n-        Asserts.assertGT(lock.getAborts(abortType), 0L, String.format(\n-                \"RTM locking statistics should contain non zero aborts count \"\n-                + \"for abort reason %s\", abortType));\n-    }\n-\n-    public static void main(String args[]) throws Throwable {\n-        new TestPrintPreciseRTMLockingStatistics().runTestCases();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java","additions":0,"deletions":142,"binary":false,"changes":142,"status":"deleted"},{"patch":"@@ -1,216 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.testlibrary.rtm;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.whitebox.WhiteBox;\n-\n-import java.util.Objects;\n-import java.util.concurrent.BrokenBarrierException;\n-import java.util.concurrent.CyclicBarrier;\n-\n-\/**\n- * Base class for different transactional execution abortion\n- * provokers aimed to force abort due to specified reason.\n- *\/\n-public abstract class AbortProvoker implements CompilableTest {\n-    public static final long DEFAULT_ITERATIONS = 10000L;\n-    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n-    @SuppressWarnings(\"unused\")\n-    private static int sharedState = 0;\n-    \/**\n-     * Inflates monitor associated with object {@code monitor}.\n-     * Inflation is forced by entering the same monitor from\n-     * two different threads.\n-     *\n-     * @param monitor monitor to be inflated.\n-     * @return inflated monitor.\n-     * @throws Exception if something went wrong.\n-     *\/\n-    public static Object inflateMonitor(Object monitor) throws Exception {\n-        CyclicBarrier barrier = new CyclicBarrier(2);\n-\n-        Runnable inflatingRunnable = () -> {\n-            synchronized (monitor) {\n-                try {\n-                    barrier.await();\n-                } catch (BrokenBarrierException  | InterruptedException e) {\n-                    throw new RuntimeException(\n-                            \"Synchronization issue occurred.\", e);\n-                }\n-                try {\n-                    monitor.wait();\n-                } catch (InterruptedException e) {\n-                    throw new AssertionError(\"The thread waiting on an\"\n-                            + \" inflated monitor was interrupted, thus test\"\n-                            + \" results may be incorrect.\", e);\n-                }\n-            }\n-        };\n-\n-        Thread t = new Thread(inflatingRunnable);\n-        t.setDaemon(true);\n-        t.start();\n-        \/\/ Wait until thread t enters the monitor.\n-        barrier.await();\n-        synchronized (monitor) {\n-            \/\/ At this point thread t is already waiting on the monitor.\n-            \/\/ Modifying static field just to avoid lock's elimination.\n-            sharedState++;\n-        }\n-        verifyMonitorState(monitor, true \/* inflated *\/);\n-        return monitor;\n-    }\n-\n-    \/**\n-     * Verifies that {@code monitor} is a stack-lock or inflated lock depending\n-     * on {@code shouldBeInflated} value. If {@code monitor} is inflated while\n-     * it is expected that it should be a stack-lock, then this method attempts\n-     * to deflate it by forcing a safepoint and then verifies the state once\n-     * again.\n-     *\n-     * @param monitor monitor to be verified.\n-     * @param shouldBeInflated flag indicating whether or not monitor is\n-     *                         expected to be inflated.\n-     * @throws RuntimeException if the {@code monitor} in a wrong state.\n-     *\/\n-    public static void verifyMonitorState(Object monitor,\n-            boolean shouldBeInflated) {\n-        if (!shouldBeInflated && WHITE_BOX.isMonitorInflated(monitor)) {\n-            boolean did_deflation = WHITE_BOX.deflateIdleMonitors();\n-            Asserts.assertEQ(did_deflation, true,\n-                             \"deflateIdleMonitors() should have worked.\");\n-        }\n-        Asserts.assertEQ(WHITE_BOX.isMonitorInflated(monitor), shouldBeInflated,\n-                \"Monitor in a wrong state.\");\n-    }\n-    \/**\n-     * Verifies that monitor used by the {@code provoker} is a stack-lock or\n-     * inflated lock depending on {@code shouldBeInflated} value. If such\n-     * monitor is inflated while it is expected that it should be a stack-lock,\n-     * then this method attempts to deflate it by forcing a safepoint and then\n-     * verifies the state once again.\n-     *\n-     * @param provoker AbortProvoker whose monitor's state should be verified.\n-     * @param shouldBeInflated flag indicating whether or not monitor is\n-     *                         expected to be inflated.\n-     * @throws RuntimeException if the {@code monitor} in a wrong state.\n-     *\/\n-    public static void verifyMonitorState(AbortProvoker provoker,\n-            boolean shouldBeInflated) {\n-        verifyMonitorState(provoker.monitor, shouldBeInflated);\n-    }\n-\n-    \/**\n-     * Get instance of specified AbortProvoker, inflate associated monitor\n-     * if needed and then invoke forceAbort method in a loop.\n-     *\n-     * Usage:\n-     * AbortProvoker &lt;AbortType name&gt; [&lt;inflate monitor&gt\n-     * [&lt;iterations&gt; [ &lt;delay&gt;]]]\n-     *\n-     *  Default parameters are:\n-     *  <ul>\n-     *  <li>inflate monitor = <b>true<\/b><\/li>\n-     *  <li>iterations = {@code AbortProvoker.DEFAULT_ITERATIONS}<\/li>\n-     *  <li>delay = <b>0<\/b><\/li>\n-     *  <\/ul>\n-     *\/\n-    public static void main(String args[]) throws Throwable {\n-        Asserts.assertGT(args.length, 0, \"At least one argument is required.\");\n-\n-        AbortType abortType = AbortType.lookup(Integer.valueOf(args[0]));\n-        boolean monitorShouldBeInflated = true;\n-        long iterations = AbortProvoker.DEFAULT_ITERATIONS;\n-\n-        if (args.length > 1) {\n-            monitorShouldBeInflated = Boolean.valueOf(args[1]);\n-\n-            if (args.length > 2) {\n-                iterations = Long.valueOf(args[2]);\n-\n-                if (args.length > 3) {\n-                    Thread.sleep(Integer.valueOf(args[3]));\n-                }\n-            }\n-        }\n-\n-        AbortProvoker provoker = abortType.provoker();\n-\n-        if (monitorShouldBeInflated) {\n-            provoker.inflateMonitor();\n-        }\n-\n-        for (long i = 0; i < iterations; i++) {\n-            AbortProvoker.verifyMonitorState(provoker, monitorShouldBeInflated);\n-            provoker.forceAbort();\n-        }\n-    }\n-\n-    protected final Object monitor;\n-\n-    protected AbortProvoker() {\n-        this(new Object());\n-    }\n-\n-    protected AbortProvoker(Object monitor) {\n-        this.monitor = Objects.requireNonNull(monitor);\n-    }\n-\n-    \/**\n-     * Inflates monitor used by this AbortProvoker instance.\n-     * @throws Exception\n-     *\/\n-    public void inflateMonitor() throws Exception {\n-        AbortProvoker.inflateMonitor(monitor);\n-    }\n-\n-    \/**\n-     * Forces transactional execution abortion.\n-     *\/\n-    public abstract void forceAbort();\n-\n-    \/**\n-     * Returns names of all methods that have to be compiled\n-     * in order to successfully force transactional execution\n-     * abortion.\n-     *\n-     * @return array with methods' names that have to be compiled.\n-     *\/\n-    @Override\n-    public String[] getMethodsToCompileNames() {\n-        return new String[] { getMethodWithLockName() };\n-    }\n-\n-    \/**\n-     * Returns name of the method that will contain monitor whose locking\n-     * will be elided using transactional execution.\n-     *\n-     * @return name of the method that will contain elided lock.\n-     *\/\n-    @Override\n-    public String getMethodWithLockName() {\n-        return this.getClass().getName() + \"::forceAbort\";\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/testlibrary\/rtm\/AbortProvoker.java","additions":0,"deletions":216,"binary":false,"changes":216,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.testlibrary.rtm;\n-\n-import jdk.test.lib.Asserts;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-\/**\n- * Type of transactional execution abort.\n- * For more details on different abort types please see\n- * shared\/vm\/runtime\/rtmLocking.hpp\n- *\/\n-public enum AbortType {\n-    XABORT(0),\n-    RETRIABLE(1),\n-    MEM_CONFLICT(2),\n-    BUF_OVERFLOW(3),\n-    DEBUG_BREAKPOINT(4),\n-    NESTED_ABORT(5);\n-\n-    private final int type;\n-    private static final Map<Integer, AbortType> LOOKUP_MAP = new HashMap<>();\n-\n-    static {\n-        for (AbortType abortType : AbortType.values()) {\n-            Asserts.assertFalse(LOOKUP_MAP.containsKey(abortType.type),\n-                    \"Abort type values should be unique.\");\n-            LOOKUP_MAP.put(abortType.type, abortType);\n-        }\n-    }\n-\n-    private AbortType(int type) {\n-        this.type = type;\n-    }\n-\n-    \/**\n-     * Returns AbortProvoker for aborts represented by this abort type.\n-     *\n-     * @return an AbortProvoker instance\n-     *\/\n-    public AbortProvoker provoker() {\n-        return AbortType.createNewProvoker(this);\n-    }\n-\n-    public static AbortType lookup(int type) {\n-        Asserts.assertLT(type, AbortType.values().length,\n-                \"Unknown abort type.\");\n-        return LOOKUP_MAP.get(type);\n-    }\n-\n-    \/**\n-     * Returns transaction execution abort provoker for specified abortion type.\n-     *\n-     * @param type a type of abort which will be forced by returned\n-     *             AbortProvoker instance.\n-     * @return AbortProvoker instance that will force abort of specified type\n-     * @throws RuntimeException if there is no provoker for specified type\n-     *\/\n-    private static AbortProvoker createNewProvoker(AbortType type) {\n-        switch (type) {\n-            case XABORT:\n-                return new XAbortProvoker();\n-            case MEM_CONFLICT:\n-                return new MemoryConflictProvoker();\n-            case BUF_OVERFLOW:\n-                return new BufferOverflowProvoker();\n-            case NESTED_ABORT:\n-                return new NestedAbortProvoker();\n-            default:\n-                throw new RuntimeException(\"No provoker exists for type \"\n-                        + type.name());\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return Integer.toString(type);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/testlibrary\/rtm\/AbortType.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.testlibrary.rtm;\n-\n-\/**\n- * In order to provoke transactional execution abort due to\n- * internal's buffer overflow BufferOverflowProvoker modifies\n- * 1MB of BYTES during single transaction.\n- *\/\n-class BufferOverflowProvoker extends AbortProvoker {\n-    \/**\n-     * To force buffer overflow abort we modify memory region with\n-     * size more then L1d cache size.\n-     *\/\n-    private static final int MORE_THAN_L1D_SIZE = 1024 * 1024;\n-    private static final byte[] DATA = new byte[MORE_THAN_L1D_SIZE];\n-\n-    @Override\n-    public void forceAbort() {\n-        synchronized(monitor) {\n-            for (int i = 0; i < BufferOverflowProvoker.DATA.length; i++) {\n-                BufferOverflowProvoker.DATA[i]++;\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/testlibrary\/rtm\/BufferOverflowProvoker.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -1,125 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.testlibrary.rtm;\n-\n-import java.util.concurrent.BrokenBarrierException;\n-import java.util.concurrent.CyclicBarrier;\n-\n-\/**\n- * Test case for busy lock scenario.\n- * One thread enters the monitor and sleep for a while.\n- * Another thread is blocked on the same monitor.\n- *\/\n-public class BusyLock implements CompilableTest, Runnable {\n-    private static final int DEFAULT_TIMEOUT = 1000;\n-    private final CyclicBarrier barrier;\n-\n-    \/\/ Following field have to be static in order to avoid escape analysis.\n-    @SuppressWarnings(\"UnsuedDeclaration\")\n-    private static int field = 0;\n-    protected final Object monitor;\n-    protected final int timeout;\n-\n-    public BusyLock() {\n-        this(BusyLock.DEFAULT_TIMEOUT);\n-    }\n-\n-    public BusyLock(int timeout) {\n-        this.timeout = timeout;\n-        this.monitor = new Object();\n-        this.barrier = new CyclicBarrier(2);\n-    }\n-\n-    @Override\n-    public void run() {\n-        try {\n-            synchronized (monitor) {\n-                barrier.await();\n-                Thread.sleep(timeout);\n-            }\n-        } catch (InterruptedException | BrokenBarrierException e) {\n-            throw new RuntimeException(\"Synchronization error happened.\", e);\n-        }\n-    }\n-\n-    public void syncAndTest() {\n-        try {\n-            \/\/ wait until monitor is locked by a ::run method\n-            barrier.await();\n-        } catch (InterruptedException | BrokenBarrierException e) {\n-            throw new RuntimeException(\"Synchronization error happened.\", e);\n-        }\n-        test();\n-    }\n-\n-    public void test() {\n-        synchronized(monitor) {\n-            BusyLock.field++;\n-        }\n-    }\n-\n-    @Override\n-    public String getMethodWithLockName() {\n-        return this.getClass().getName() + \"::test\";\n-    }\n-\n-    @Override\n-    public String[] getMethodsToCompileNames() {\n-        return new String[] { getMethodWithLockName() };\n-    }\n-\n-    \/**\n-     * Usage:\n-     * BusyLock [ &lt;inflate monitor&gt; [ &lt;timeout&gt; ] ]\n-     *\n-     * Default values are:\n-     * <ul>\n-     *     <li>inflate monitor = {@code true}<\/li>\n-     *     <li>timeout = {@code BusyLock.DEFAULT_TIMEOUT}<\/li>\n-     * <\/ul>\n-     *\/\n-    public static void main(String args[]) throws Exception {\n-        int timeoutValue = BusyLock.DEFAULT_TIMEOUT;\n-        boolean inflateMonitor = true;\n-\n-        if (args.length > 0 ) {\n-            inflateMonitor = Boolean.valueOf(args[0]);\n-\n-            if (args.length > 1) {\n-                timeoutValue = Integer.valueOf(args[1]);\n-            }\n-        }\n-\n-        BusyLock busyLock = new BusyLock(timeoutValue);\n-\n-        if (inflateMonitor) {\n-            AbortProvoker.inflateMonitor(busyLock.monitor);\n-        }\n-\n-        Thread t = new Thread(busyLock);\n-        t.start();\n-        busyLock.syncAndTest();\n-        t.join();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/testlibrary\/rtm\/BusyLock.java","additions":0,"deletions":125,"binary":false,"changes":125,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.testlibrary.rtm;\n-\n-\/**\n- * Interface for test scenarios that contain methods\n- * that should be compiled.\n- *\/\n-public interface CompilableTest {\n-    \/**\n-     * @return array with methods' names that should be compiled.\n-     *\/\n-    String[] getMethodsToCompileNames();\n-\n-    \/**\n-     * @return name of method with RTM-elided lock.\n-     *\/\n-    String getMethodWithLockName();\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/testlibrary\/rtm\/CompilableTest.java","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.testlibrary.rtm;\n-\n-import java.util.concurrent.BrokenBarrierException;\n-import java.util.concurrent.CyclicBarrier;\n-\n-\/**\n- * To force transactional execution abort due to memory conflict\n- * one thread should access memory region from transactional region\n- * while another thread should modify the same memory region.\n- * Since this scenario is based on the race condition between threads\n- * you should not expect some particular amount of aborts.\n- *\/\n-class MemoryConflictProvoker extends AbortProvoker {\n-    \/\/ Following field have to be static in order to avoid escape analysis.\n-    @SuppressWarnings(\"UnsuedDeclaration\")\n-    private static int field = 0;\n-    private static final int INNER_ITERATIONS = 10000;\n-    private final CyclicBarrier barrier;\n-    \/**\n-     * This thread will access and modify memory region\n-     * from outside of the transaction.\n-     *\/\n-    private final Runnable conflictingThread;\n-\n-    public MemoryConflictProvoker() {\n-        this(new Object());\n-    }\n-\n-    public MemoryConflictProvoker(Object monitor) {\n-        super(monitor);\n-        barrier = new CyclicBarrier(2);\n-        conflictingThread = () -> {\n-            try {\n-                barrier.await();\n-            } catch (Exception e) {\n-                throw new RuntimeException(e);\n-            }\n-            for (int i = 0; i < MemoryConflictProvoker.INNER_ITERATIONS; i++) {\n-                MemoryConflictProvoker.field++;\n-            }\n-        };\n-    }\n-\n-    \/**\n-     * Accesses and modifies memory region from within the transaction.\n-     *\/\n-    public void transactionalRegion() {\n-        for (int i = 0; i < MemoryConflictProvoker.INNER_ITERATIONS; i++) {\n-            synchronized(monitor) {\n-                MemoryConflictProvoker.field--;\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void forceAbort() {\n-        try {\n-            Thread t = new Thread(conflictingThread);\n-            t.start();\n-            try {\n-                barrier.await();\n-            } catch (InterruptedException | BrokenBarrierException e) {\n-                throw new RuntimeException(e);\n-            }\n-            transactionalRegion();\n-            t.join();\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    @Override\n-    public String getMethodWithLockName() {\n-        return this.getClass().getName() + \"::transactionalRegion\";\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/testlibrary\/rtm\/MemoryConflictProvoker.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.testlibrary.rtm;\n-\n-import java.util.Arrays;\n-\n-\/**\n- * In order to force nested transaction abort NestedAbortProvoker\n- * invoke BufferOverflowProvoker from transactional region.\n- *\/\n-class NestedAbortProvoker extends AbortProvoker {\n-    \/\/ Following field have to be static in order to avoid escape analysis.\n-    @SuppressWarnings(\"UnsuedDeclaration\")\n-    private static int field = 0;\n-    private final AbortProvoker nestedAbortProvoker;\n-\n-    public NestedAbortProvoker() {\n-        this.nestedAbortProvoker = new XAbortProvoker(monitor);\n-    }\n-\n-    @Override\n-    public void forceAbort() {\n-        synchronized(monitor) {\n-            NestedAbortProvoker.field++;\n-            nestedAbortProvoker.forceAbort();\n-            NestedAbortProvoker.field--;\n-        }\n-    }\n-\n-    @Override\n-    public String[] getMethodsToCompileNames() {\n-        String nestedProvokerMethods[]\n-                = nestedAbortProvoker.getMethodsToCompileNames();\n-        String methods[] = Arrays.copyOf(nestedProvokerMethods,\n-                nestedProvokerMethods.length + 1);\n-        methods[methods.length - 1] = getMethodWithLockName();\n-        return methods;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/testlibrary\/rtm\/NestedAbortProvoker.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.testlibrary.rtm;\n-\n-import java.util.EnumMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Wrapper for +UsePreciseRTMLockingStatistics output.\n- *\n- * Example of locking statistics:\n- *\n- * java\/lang\/ClassLoader.loadClass@7\n- * # rtm locks total (estimated): 6656\n- * # rtm lock aborts (total): 10000\n- * # rtm lock aborts 0 (abort instruction   ): 9999\n- * # rtm lock aborts 1 (may succeed on retry): 9999\n- * # rtm lock aborts 2 (thread conflict     ): 0\n- * # rtm lock aborts 3 (buffer overflow     ): 1\n- * # rtm lock aborts 4 (debug or trap hit   ): 0\n- * # rtm lock aborts 5 (maximum nested depth): 0\n- *\/\n-public class RTMLockingStatistics {\n-    \/**\n-     * Pattern for aborts per abort type entries.\n-     *\/\n-    private static final Pattern ABORT_PATTERN;\n-\n-    \/**\n-     * Pattern for whole statistics.\n-     *\/\n-    private static final Pattern RTM_LOCKING_STATISTICS_PATTERN;\n-\n-    static {\n-        String abortRe\n-                = \"# rtm lock aborts\\\\s+(?<type>[0-9]+)\\\\s+\\\\([a-z\\\\s]+\\\\):\\\\s(?<count>[0-9]+)\";\n-\n-        ABORT_PATTERN = Pattern.compile(abortRe);\n-        RTM_LOCKING_STATISTICS_PATTERN = Pattern.compile(\n-                \"(?<className>[^.\\n]+)\\\\.\" +\n-                \"(?<methodName>[^@\\n]+)@(?<bci>[0-9]+)\\n\" +\n-                \"# rtm locks total \\\\(estimated\\\\):\\\\s*\" +\n-                \"(?<totalLocks>[0-9]+)\\n\" +\n-                \"# rtm lock aborts\\\\s+\\\\(total\\\\):\\\\s*(?<totalAborts>[0-9]+)\\n\" +\n-                \"(?<abortStats>(\" + abortRe + \"\\n)+)\");\n-    }\n-\n-    private final long totalLocks;\n-    private final long totalAborts;\n-    private final String className;\n-    private final String methodName;\n-    private final int bci;\n-    private final Map<AbortType, Long> aborts = new EnumMap<>(AbortType.class);\n-\n-    \/**\n-     * Constructs RTMLockingStatistics from matcher captured statistics entry.\n-     * @param matcher Matcher captured statistics entry.\n-     *\/\n-    private RTMLockingStatistics(Matcher matcher) {\n-        className = matcher.group(\"className\");\n-        methodName = matcher.group(\"methodName\");\n-        bci = Integer.valueOf(matcher.group(\"bci\"));\n-        totalLocks = Long.valueOf(matcher.group(\"totalLocks\"));\n-        totalAborts = Long.valueOf(matcher.group(\"totalAborts\"));\n-\n-        Matcher abortMatcher = ABORT_PATTERN.matcher(matcher.\n-                group(\"abortStats\"));\n-\n-        while (abortMatcher.find()) {\n-            int type = Integer.valueOf(abortMatcher.group(\"type\"));\n-            long count = Long.valueOf(abortMatcher.group(\"count\"));\n-            setAborts(AbortType.lookup(type), count);\n-        }\n-    }\n-\n-\n-    \/**\n-     * Parses string and return all founded RTM locking statistics entries.\n-     *\n-     * @param str the string to be parsed.\n-     * @return list with all founded RTM locking statistics entries or\n-     *         empty list if nothing was found.\n-     *\/\n-    public static List<RTMLockingStatistics> fromString(String str) {\n-        List<RTMLockingStatistics> statistics = new LinkedList<>();\n-        Matcher matcher = RTM_LOCKING_STATISTICS_PATTERN.matcher(str);\n-\n-        while (matcher.find()) {\n-            RTMLockingStatistics lock = new RTMLockingStatistics(matcher);\n-            statistics.add(lock);\n-        }\n-\n-        return statistics;\n-    }\n-\n-    \/**\n-     * Parses string and return all founded RTM locking statistics entries\n-     * for locks in method {@code methodName}.\n-     *\n-     * @param methodName a name of the method for locks from which statistics\n-     *                   should be gathered.\n-     * @param str the string to be parsed.\n-     * @return list with all founded RTM locking statistics entries or\n-     *         empty list if nothing was found.\n-     *\/\n-    public static List<RTMLockingStatistics> fromString(String methodName,\n-            String str) {\n-        String formattedMethodName = formatMethodName(methodName);\n-\n-        List<RTMLockingStatistics> statisticsForMethod = new LinkedList<>();\n-        for (RTMLockingStatistics statistics : fromString(str)) {\n-            if (statistics.getLockName().startsWith(formattedMethodName)) {\n-                statisticsForMethod.add(statistics);\n-            }\n-        }\n-        return statisticsForMethod;\n-    }\n-\n-    \/**\n-     * Formats method's name so it will have the same format as\n-     * in rtm locking statistics.\n-     *\n-     * <pre>\n-     * Example:\n-     * com\/example\/Klass::method =&gt; com\/example\/Klass.method\n-     * com\/example\/Klass.method  =&gt; com\/example\/Klass.method\n-     * com.example.Klass::method =&gt; com\/example\/Klass.method\n-     * com.example.Klass.method  =&gt; com\/example\/Klass.method\n-     * <\/pre>\n-     *\n-     * @param methodName method's name that should be formatted.\n-     * @return formatted method's name.\n-     *\/\n-    private static String formatMethodName(String methodName) {\n-        String m[];\n-        if (methodName.contains(\"::\")) {\n-            m = methodName.split(\"::\");\n-        } else {\n-            int splitAt = methodName.lastIndexOf('.');\n-            m = new String[2];\n-            m[0] = methodName.substring(0, splitAt);\n-            m[1] = methodName.substring(splitAt + 1);\n-        }\n-        return String.format(\"%s.%s\", m[0].replaceAll(\"\\\\.\", \"\/\"), m[1]);\n-    }\n-\n-    \/**\n-     * Returns name of lock for which this statistics was collected.\n-     * Lock name has following format:\n-     * &lt;class name&gt;.&lt;method name&gt;@&lt;bci&gt;\n-     *\n-     * @return name of lock.\n-     *\/\n-    public String getLockName() {\n-        return String.format(\"%s.%s@%d\", className, methodName, bci);\n-    }\n-\n-    \/**\n-     * Returns aborts count for specified abort type.\n-     *\n-     * @param type an abort type.\n-     * @return count of aborts.\n-     *\/\n-    public long getAborts(AbortType type) {\n-        return aborts.getOrDefault(type, 0L);\n-    }\n-\n-    \/**\n-     * Sets aborts count for specified abort type.\n-     *\n-     * @param type an abort type.\n-     * @param count count of aborts.\n-     *\/\n-    public void setAborts(AbortType type, long count) {\n-        aborts.put(type, count);\n-    }\n-\n-    public long getTotalLocks() {\n-        return totalLocks;\n-    }\n-\n-    public long getTotalAborts() {\n-        return totalAborts;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder builder = new StringBuilder();\n-        builder.append(getLockName()).append('\\n');\n-        builder.append(String.format(\"# rtm locks total (estimated): %d\\n\",\n-                getTotalLocks()));\n-        builder.append(String.format(\"# rtm lock aborts: %d\\n\",\n-                getTotalLocks()));\n-\n-        for (AbortType type : AbortType.values()) {\n-            builder.append(String.format(\"# rtm lock aborts %s %d\\n\",\n-                    type.toString(), getAborts(type)));\n-        }\n-        return builder.toString();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/testlibrary\/rtm\/RTMLockingStatistics.java","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"},{"patch":"@@ -1,280 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.testlibrary.rtm;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.cli.CommandLineOptionTest;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Auxiliary methods used for RTM testing.\n- *\/\n-public class RTMTestBase {\n-    private static final String RTM_STATE_CHANGE_REASON = \"rtm_state_change\";\n-    \/**\n-     * We don't parse compilation log as XML-document and use regular\n-     * expressions instead, because in some cases it could be\n-     * malformed.\n-     *\/\n-    private static final String FIRED_UNCOMMON_TRAP_PATTERN_TEMPLATE\n-            = \"<uncommon_trap thread='[0-9]+' reason='%s'\";\n-    private static final String INSTALLED_UNCOMMON_TRAP_PATTERN_TEMPLATE\n-            = \"<uncommon_trap bci='[0-9]+' reason='%s'\";\n-\n-    \/**\n-     * Executes RTM test in a new JVM started with {@code options} cli options.\n-     *\n-     * @param test test case to execute.\n-     * @param options additional options for VM\n-     * @throws Exception when something went wrong.\n-     *\/\n-    public static OutputAnalyzer executeRTMTest(CompilableTest test,\n-            String... options) throws Exception {\n-        ProcessBuilder processBuilder\n-                = ProcessTools.createLimitedTestJavaProcessBuilder(\n-                RTMTestBase.prepareTestOptions(test, options));\n-        OutputAnalyzer outputAnalyzer\n-                = new OutputAnalyzer(processBuilder.start());\n-        System.out.println(outputAnalyzer.getOutput());\n-        return outputAnalyzer;\n-    }\n-\n-    \/**\n-     * Executes test case and save compilation log to {@code logFileName}.\n-     *\n-     * @param logFileName a name of compilation log file\n-     * @param test a test case to execute case to execute\n-     * @param options additional options to VM\n-     * @return OutputAnalyzer for started test case\n-     * @throws Exception when something went wrong\n-     *\/\n-    public static OutputAnalyzer executeRTMTest(String logFileName,\n-            CompilableTest test, String... options) throws Exception {\n-        ProcessBuilder processBuilder\n-                = ProcessTools.createLimitedTestJavaProcessBuilder(\n-                RTMTestBase.prepareTestOptions(logFileName, test, options));\n-        OutputAnalyzer outputAnalyzer\n-                = new OutputAnalyzer(processBuilder.start());\n-\n-        System.out.println(outputAnalyzer.getOutput());\n-\n-        return outputAnalyzer;\n-    }\n-\n-    \/**\n-     * Finds count of uncommon traps with reason {@code reason} installed\n-     * during compilation.\n-     *\n-     * @param compilationLogFile a path to file with LogCompilation output.\n-     * @param reason reason of installed uncommon traps.\n-     * @return count of installed uncommon traps with reason {@code reason}.\n-     * @throws IOException\n-     *\/\n-    public static int installedUncommonTraps(String compilationLogFile,\n-            String reason)throws IOException {\n-        String pattern = String.format(\n-                RTMTestBase.INSTALLED_UNCOMMON_TRAP_PATTERN_TEMPLATE,\n-                reason);\n-        return RTMTestBase.findTraps(compilationLogFile, pattern);\n-    }\n-\n-    \/**\n-     * Finds count of uncommon traps with reason <i>rtm_state_change<\/i>\n-     * installed during compilation.\n-     *\n-     * @param compilationLogFile a path to file with LogCompilation output.\n-     * @return count of installed uncommon traps with reason\n-     *         <i>rtm_state_change<\/i>.\n-     * @throws IOException\n-     *\/\n-    public static int installedRTMStateChangeTraps(String compilationLogFile)\n-            throws IOException {\n-        return RTMTestBase.installedUncommonTraps(compilationLogFile,\n-                RTMTestBase.RTM_STATE_CHANGE_REASON);\n-    }\n-\n-    \/**\n-     * Finds count of fired uncommon traps with reason {@code reason}.\n-     *\n-     * @param compilationLogFile a path to file with LogCompilation output.\n-     * @param reason a reason of fired uncommon traps.\n-     * @return count of fired uncommon traps with reason {@code reason}.\n-     * @throws IOException\n-     *\/\n-    public static int firedUncommonTraps(String compilationLogFile,\n-            String reason) throws IOException {\n-        String pattern = String.format(\n-                RTMTestBase.FIRED_UNCOMMON_TRAP_PATTERN_TEMPLATE,\n-                reason);\n-        return RTMTestBase.findTraps(compilationLogFile, pattern);\n-    }\n-\n-    \/**\n-     * Finds count of fired uncommon traps with reason <i>rtm_state_change<\/i>.\n-     *\n-     * @param compilationLogFile a path to file with LogCompilation output.\n-     * @return count of fired uncommon traps with reason\n-     *         <i>rtm_state_change<\/i>.\n-     * @throws IOException\n-     *\/\n-    public static int firedRTMStateChangeTraps(String compilationLogFile)\n-            throws IOException {\n-        return RTMTestBase.firedUncommonTraps(compilationLogFile,\n-                RTMTestBase.RTM_STATE_CHANGE_REASON);\n-    }\n-\n-    \/**\n-     * Finds count of uncommon traps that matches regular\n-     * expression in {@code re}.\n-     *\n-     * @param compilationLogFile a path to file with LogCompilation output.\n-     * @param re regular expression to match uncommon traps.\n-     * @throws IOException\n-     *\/\n-    private static int findTraps(String compilationLogFile, String re)\n-            throws IOException {\n-        String compilationLog = RTMTestBase.fileAsString(compilationLogFile);\n-        Pattern pattern = Pattern.compile(re);\n-        Matcher matcher = pattern.matcher(compilationLog);\n-        int traps = 0;\n-        while (matcher.find()) {\n-            traps++;\n-        }\n-        return traps;\n-    }\n-\n-    \/**\n-     * Returns file's content as a string.\n-     *\n-     * @param path a path to file to operate on.\n-     * @return string with content of file.\n-     * @throws IOException\n-     *\/\n-    private static String fileAsString(String path) throws IOException {\n-        byte[] fileAsBytes = Files.readAllBytes(Paths.get(path));\n-        return new String(fileAsBytes);\n-    }\n-\n-    \/**\n-     * Prepares VM options for test execution.\n-     * This method get test java options, filter out all RTM-related options,\n-     * adds CompileCommand=compileonly,method_name options for each method\n-     * from {@code methodToCompile} and finally appends all {@code vmOpts}.\n-     *\n-     * @param test test case whose methods that should be compiled.\n-     *             If {@code null} then no additional <i>compileonly<\/i>\n-     *             commands will be added to VM options.\n-     * @param vmOpts additional options to pass to VM.\n-     * @return Array with VM options.\n-     *\/\n-    private static String[] prepareTestOptions(CompilableTest test,\n-            String... vmOpts) {\n-        return RTMTestBase.prepareFilteredTestOptions(test, null, vmOpts);\n-    }\n-\n-    \/**\n-     * Prepares VM options for test execution.\n-     * This method get test java options, filter out all RTM-related options\n-     * and all options that matches regexps in {@code additionalFilters},\n-     * adds CompileCommand=compileonly,method_name options for each method\n-     * from {@code methodToCompile} and finally appends all {@code vmOpts}.\n-     *\n-     * @param test test case whose methods that should be compiled.\n-     *             If {@code null} then no additional <i>compileonly<\/i>\n-     *             commands will be added to VM options.\n-     * @param additionalFilters array with regular expression that will be\n-     *                          used to filter out test java options.\n-     *                          If {@code null} then no additional filters\n-     *                          will be used.\n-     * @param vmOpts additional options to pass to VM.\n-     * @return array with VM options.\n-     *\/\n-    private static String[] prepareFilteredTestOptions(CompilableTest test,\n-            String[] additionalFilters, String... vmOpts) {\n-        List<String> finalVMOpts = new LinkedList<>();\n-        String[] filters;\n-\n-        if (additionalFilters != null) {\n-            filters = Arrays.copyOf(additionalFilters,\n-                    additionalFilters.length + 1);\n-        } else {\n-            filters = new String[1];\n-        }\n-\n-        filters[filters.length - 1] = \"RTM\";\n-        String[] filteredVMOpts = Utils.getFilteredTestJavaOpts(filters);\n-        Collections.addAll(finalVMOpts, filteredVMOpts);\n-        Collections.addAll(finalVMOpts, \"-Xcomp\", \"-server\",\n-                \"-XX:-TieredCompilation\", \"-XX:+UseRTMLocking\",\n-                CommandLineOptionTest.UNLOCK_DIAGNOSTIC_VM_OPTIONS,\n-                CommandLineOptionTest.UNLOCK_EXPERIMENTAL_VM_OPTIONS,\n-                \"-Xbootclasspath\/a:.\", \"-XX:+WhiteBoxAPI\",\n-                \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n-\n-        if (test != null) {\n-            for (String method : test.getMethodsToCompileNames()) {\n-                finalVMOpts.add(\"-XX:CompileCommand=compileonly,\" + method);\n-            }\n-        }\n-        Collections.addAll(finalVMOpts, vmOpts);\n-        return finalVMOpts.toArray(new String[finalVMOpts.size()]);\n-    }\n-\n-    \/**\n-     * Adds additional options for VM required for successful execution of test.\n-     *\n-     * @param logFileName a name of compilation log file\n-     * @param test a test case to execute\n-     * @param options additional options to VM\n-     * @return an array with VM options\n-     *\/\n-    private static String[] prepareTestOptions(String logFileName,\n-            CompilableTest test, String... options) {\n-        String[] preparedOptions = RTMTestBase.prepareFilteredTestOptions(\n-                test,\n-                new String[] {\n-                        \"LogCompilation\",\n-                        \"LogFile\"\n-                });\n-        List<String> updatedOptions = new LinkedList<>();\n-        Collections.addAll(updatedOptions, preparedOptions);\n-        Collections.addAll(updatedOptions,\n-                \"-XX:+LogCompilation\",\n-                \"-XX:LogFile=\" + logFileName);\n-        Collections.addAll(updatedOptions, options);\n-\n-        return updatedOptions.toArray(new String[updatedOptions.size()]);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/testlibrary\/rtm\/RTMTestBase.java","additions":0,"deletions":280,"binary":false,"changes":280,"status":"deleted"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.testlibrary.rtm;\n-\n-\/**\n- * Current RTM locking implementation force transaction abort\n- * before native method call by explicit xabort(0) call.\n- *\/\n-public class XAbortProvoker extends AbortProvoker {\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"XAbortProvoker\");\n-        } catch (UnsatisfiedLinkError e) {\n-            System.out.println(\"Could not load native library: \" + e);\n-        }\n-    }\n-\n-    public native int doAbort();\n-\n-    \/\/ Following field have to be static in order to avoid escape analysis.\n-    @SuppressWarnings(\"UnsuedDeclaration\")\n-    private static int field = 0;\n-\n-    public XAbortProvoker() {\n-        this(new Object());\n-    }\n-\n-    public XAbortProvoker(Object monitor) {\n-        super(monitor);\n-    }\n-\n-    @Override\n-    public void forceAbort() {\n-        synchronized(monitor) {\n-            XAbortProvoker.field = doAbort();\n-        }\n-    }\n-\n-    @Override\n-    public String[] getMethodsToCompileNames() {\n-        return new String[] {\n-                getMethodWithLockName(),\n-                XAbortProvoker.class.getName() + \"::doAbort\"\n-        };\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/testlibrary\/rtm\/XAbortProvoker.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-\n-\/**\n- * Simply calling a JNI method from the JVM will abort any active transaction,\n- * so doAbort() does nothing special and only returns after being called.\n- * The transaction abortion happens right before the JNI method is called.\n- *\/\n-JNIEXPORT int JNICALL\n-Java_compiler_testlibrary_rtm_XAbortProvoker_doAbort(JNIEnv *env, jobject o) {\n-  return 0;\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/testlibrary\/rtm\/libXAbortProvoker.c","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"}]}