{"files":[{"patch":"@@ -831,1 +831,2 @@\n-  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n+  \/\/ two threads can walk this stack concurrently\n+  \/\/ so _last_java_pc might already be set\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -673,1 +673,2 @@\n-  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n+  \/\/ two threads can walk this stack concurrently\n+  \/\/ so _last_java_pc might already be set\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -704,1 +704,2 @@\n-  vmassert(last_Java_pc() == nullptr, \"already walkable\");\n+  \/\/ two threads can walk this stack concurrently\n+  \/\/ so _last_java_pc might already be set\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,8 +28,0 @@\n-Thread* ThreadCrashProtection::_protected_thread = nullptr;\n-ThreadCrashProtection* ThreadCrashProtection::_crash_protection = nullptr;\n-\n-ThreadCrashProtection::ThreadCrashProtection() {\n-  _protected_thread = Thread::current();\n-  assert(_protected_thread->is_JfrSampler_thread(), \"should be JFRSampler\");\n-}\n-\n@@ -49,0 +41,5 @@\n+\n+  Thread* current_thread = Thread::current();\n+  assert(current_thread->is_JfrSampler_thread(), \"should be JFRSampler\");\n+  assert(current_thread->crash_protection() == nullptr, \"not reentrant\");\n+\n@@ -50,3 +47,1 @@\n-    \/\/ make sure we can see in the signal handler that we have crash protection\n-    \/\/ installed\n-    _crash_protection = this;\n+    current_thread->set_crash_protection(this);\n@@ -54,3 +49,1 @@\n-    \/\/ and clear the crash protection\n-    _crash_protection = nullptr;\n-    _protected_thread = nullptr;\n+    current_thread->set_crash_protection(nullptr);\n@@ -60,0 +53,1 @@\n+  current_thread->set_crash_protection(nullptr);\n@@ -61,2 +55,0 @@\n-  _crash_protection = nullptr;\n-  _protected_thread = nullptr;\n@@ -67,1 +59,0 @@\n-  assert(_crash_protection != nullptr, \"must have crash protection\");\n@@ -71,7 +62,2 @@\n-void ThreadCrashProtection::check_crash_protection(int sig,\n-    Thread* thread) {\n-\n-  if (thread != nullptr &&\n-      thread == _protected_thread &&\n-      _crash_protection != nullptr) {\n-\n+void ThreadCrashProtection::check_crash_protection(int sig, Thread* thread) {\n+  if (thread != nullptr && thread->crash_protection() != nullptr) {\n@@ -79,1 +65,1 @@\n-      _crash_protection->restore();\n+      thread->crash_protection()->restore();\n","filename":"src\/hotspot\/os\/posix\/threadCrashProtection_posix.cpp","additions":11,"deletions":25,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    return _crash_protection != nullptr && _protected_thread == thr;\n+    return thr != nullptr && thr->crash_protection() != nullptr;\n@@ -50,1 +50,0 @@\n-  ThreadCrashProtection();\n@@ -55,2 +54,0 @@\n-  static Thread* _protected_thread;\n-  static ThreadCrashProtection* _crash_protection;\n","filename":"src\/hotspot\/os\/posix\/threadCrashProtection_posix.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,8 +28,0 @@\n-Thread* ThreadCrashProtection::_protected_thread = nullptr;\n-ThreadCrashProtection* ThreadCrashProtection::_crash_protection = nullptr;\n-\n-ThreadCrashProtection::ThreadCrashProtection() {\n-  _protected_thread = Thread::current();\n-  assert(_protected_thread->is_JfrSampler_thread(), \"should be JFRSampler\");\n-}\n-\n@@ -43,0 +35,4 @@\n+  Thread* current_thread = Thread::current();\n+  assert(current_thread->is_JfrSampler_thread(), \"should be JFRSampler\");\n+  assert(current_thread->crash_protection() == nullptr, \"not reentrant\");\n+\n@@ -45,1 +41,1 @@\n-    _crash_protection = this;\n+    current_thread->set_crash_protection(this);\n@@ -51,2 +47,1 @@\n-  _crash_protection = nullptr;\n-  _protected_thread = nullptr;\n+  current_thread->set_crash_protection(nullptr);\n","filename":"src\/hotspot\/os\/windows\/threadCrashProtection_windows.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    return _crash_protection != nullptr && _protected_thread == thr;\n+    return thr != nullptr && thr->crash_protection() != nullptr;\n@@ -47,1 +47,0 @@\n-  ThreadCrashProtection();\n@@ -49,3 +48,0 @@\n-private:\n-  static Thread* _protected_thread;\n-  static ThreadCrashProtection* _crash_protection;\n","filename":"src\/hotspot\/os\/windows\/threadCrashProtection_windows.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -47,1 +50,0 @@\n-\n@@ -62,0 +64,5 @@\n+#if INCLUDE_JFR\n+  MetadataOnStackClosure closure;\n+  Jfr::metadata_do(&closure);\n+#endif\n+\n@@ -65,0 +72,1 @@\n+\n","filename":"src\/hotspot\/share\/classfile\/metadataOnStackMark.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"memory\/iterator.hpp\"\n@@ -151,0 +152,4 @@\n+\n+void Jfr::metadata_do(MetadataClosure* f) {\n+  JfrRecorder::metadata_do(f);\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+class MetadataClosure;\n@@ -75,0 +76,1 @@\n+  static void metadata_do(MetadataClosure* f);\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp\"\n@@ -171,0 +172,6 @@\n+JVM_ENTRY_NO_ENV(jboolean, jfr_set_cpu_throttle(JNIEnv* env, jclass jvm, jdouble rate, jboolean autoadapt))\n+  JfrEventSetting::set_enabled(JfrCPUTimeSampleEvent, rate > 0);\n+  JfrCPUTimeThreadSampling::set_rate(rate, autoadapt == JNI_TRUE);\n+  return JNI_TRUE;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -132,0 +132,2 @@\n+jboolean JNICALL jfr_set_cpu_throttle(JNIEnv* env, jclass jvm, jdouble rate, jboolean autoadapt);\n+\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+      (char*)\"setCPUThrottle\", (char*)\"(DZ)Z\", (void*)jfr_set_cpu_throttle,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -945,0 +945,14 @@\n+  <Event name=\"CPUTimeSample\" category=\"Java Virtual Machine, Profiling\" label=\"CPU Time Method Sample\"\n+    description=\"Snapshot of a threads state from the CPU time sampler. The throttle can be either an upper bound for the event emission rate, e.g. 100\/s, or the cpu-time period, e.g. 10ms, with s, ms, us and ns supported as time units.\"\n+    throttle=\"true\" thread=\"false\" experimental=\"true\">\n+    <Field type=\"StackTrace\" name=\"stackTrace\" label=\"Stack Trace\" \/>\n+    <Field type=\"Thread\" name=\"eventThread\" label=\"Thread\" \/>\n+    <Field type=\"boolean\" name=\"failed\" label=\"Failed\" description=\"Failed to obtain the stack trace\" \/>\n+    <Field type=\"Tickspan\" name=\"samplingPeriod\" label=\"CPU Time Sampling Period\"\/>\n+  <\/Event>\n+\n+  <Event name=\"CPUTimeSampleLoss\" category=\"Java Virtual Machine, Profiling\" label=\"CPU Time Method Profiling Lost Samples\" description=\"Records that the CPU time sampler lost samples because of internal throttling\"\n+    thread=\"false\" stackTrace=\"false\" startTime=\"false\" experimental=\"true\">\n+    <Field type=\"int\" name=\"lostSamples\" label=\"Lost Samples\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  <\/xs:simpleType> \n+  <\/xs:simpleType>\n@@ -126,1 +126,1 @@\n-<\/xs:schema>\n\\ No newline at end of file\n+<\/xs:schema>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xsd","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,1088 @@\n+\/*\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/orderAccess.hpp\"\n+#include \"jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp\"\n+\n+#if defined(LINUX)\n+\n+#include \"jfr\/recorder\/service\/jfrOptionSet.hpp\"\n+#include \"jfr\/recorder\/service\/jfrEvent.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrAsyncStackTrace.hpp\"\n+#include \"jfr\/utilities\/jfrThreadIterator.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"jfr\/recorder\/jfrRecorder.hpp\"\n+#include \"jfr\/periodic\/sampling\/jfrCallTrace.hpp\"\n+#include \"jfr\/recorder\/storage\/jfrBuffer.hpp\"\n+#include \"jfr\/recorder\/service\/jfrRecorderService.hpp\"\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n+#include \"jfrfiles\/jfrEventClasses.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/threadCrashProtection.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+\n+#include \"signals_posix.hpp\"\n+\n+static const int64_t AUTOADAPT_INTERVAL_MS = 100;\n+\n+enum JfrSampleType {\n+  \/\/ no sample, because thread not in walkable state\n+  NO_SAMPLE = 0,\n+  \/\/ sample from thread while in Java\n+  JAVA_SAMPLE = 1,\n+  \/\/ sample from thread while in native\n+  NATIVE_SAMPLE = 2\n+};\n+\n+static bool thread_state_in_java(JavaThread* thread) {\n+  assert(thread != nullptr, \"invariant\");\n+  JavaThreadState state = thread->thread_state();\n+  return state == _thread_in_Java || state == _thread_in_Java_trans;\n+}\n+\n+static bool thread_state_in_non_java(JavaThread* thread) {\n+  assert(thread != nullptr, \"invariant\");\n+  switch(thread->thread_state()) {\n+    case _thread_new:\n+    case _thread_uninitialized:\n+    case _thread_new_trans:\n+    case _thread_in_Java_trans:\n+    case _thread_in_Java:\n+          break;\n+    case _thread_blocked_trans:\n+    case _thread_in_vm_trans:\n+    case _thread_in_native_trans:\n+    case _thread_blocked:\n+    case _thread_in_native:\n+    case _thread_in_vm:\n+      return true;\n+    default:\n+      ShouldNotReachHere();\n+      break;\n+  }\n+  return false;\n+}\n+\n+static bool is_excluded(JavaThread* thread) {\n+  return thread->is_hidden_from_external_view() || thread->jfr_thread_local()->is_excluded();\n+}\n+\n+static JavaThread* get_java_thread_if_valid() {\n+  Thread* raw_thread = Thread::current_or_null_safe();\n+  JavaThread* jt;\n+\n+  if (raw_thread == nullptr || !raw_thread->is_Java_thread() ||\n+      (jt = JavaThread::cast(raw_thread))->is_exiting()) {\n+    return nullptr;\n+  }\n+\n+  if (is_excluded(jt)) {\n+    return nullptr;\n+  }\n+  return jt;\n+}\n+\n+\n+volatile uint32_t active_recordings = 0;\n+\n+\/\/ A trace of stack frames, contains all information\n+\/\/ collected in the signal handler, required to create\n+\/\/ a JFR event with a stack trace\n+class JfrCPUTimeTrace {\n+  friend class JfrTraceQueue;\n+  u4 _index;\n+  JfrAsyncStackFrame* _frames;\n+  JfrAsyncStackTrace _stacktrace;\n+  u4 _max_frames;\n+  \/\/ error code for the trace, 0 if no error\n+  u4 _error;\n+  int64_t _sampling_period;\n+\n+  JfrSampleType _type;\n+  JfrTicks _start_time;\n+  JfrTicks _end_time;\n+  JavaThread* _sampled_thread;\n+\n+public:\n+  JfrCPUTimeTrace(u4 index, JfrAsyncStackFrame* frames, u4 max_frames):\n+    _index(index), _frames(frames), _stacktrace(_frames, max_frames),\n+    _max_frames(max_frames) {\n+\n+    }\n+\n+  JfrAsyncStackFrame* frames() { return _frames; }\n+  u4 max_frames() const { return _max_frames; }\n+\n+  bool successful() const { return _error == NO_ERROR; }\n+\n+  JfrSampleType type() const { return _type; }\n+\n+  JfrTicks start_time() const { return _start_time; }\n+  void set_end_time(JfrTicks end_time) { _end_time = end_time; }\n+  JfrTicks end_time() const { return _end_time; }\n+  void set_sampled_thread(JavaThread* thread) { _sampled_thread = thread; }\n+  JavaThread* sampled_thread() const { return _sampled_thread; }\n+\n+  JfrAsyncStackTrace& stacktrace() { return _stacktrace; }\n+\n+  int64_t sampling_period() const { return _sampling_period; }\n+\n+  enum SampleError {\n+    NO_ERROR = 0,\n+    ERROR_NO_TRACE = 1,\n+    ERROR_NO_TOPFRAME = 2,\n+    ERROR_JAVA_WALK_FAILED = 3,\n+    ERROR_NATIVE_WALK_FAILED = 4,\n+    ERROR_NO_TOP_METHOD = 5,\n+    ERROR_NO_LAST_JAVA_FRAME = 6\n+  };\n+\n+  \/\/ Record a trace of the current thread\n+  void record_trace(JavaThread* jt, void* ucontext, int64_t sampling_period, bool should_pause) {\n+    _stacktrace = JfrAsyncStackTrace(_frames, _max_frames);\n+    set_sampled_thread(jt);\n+    _type = NO_SAMPLE;\n+    _error = ERROR_NO_TRACE;\n+    _start_time = _end_time = JfrTicks::now();\n+    _sampling_period = sampling_period;\n+    if (!should_pause && !jt->in_deopt_handler() && !Universe::heap()->is_stw_gc_active())  {\n+      ThreadInAsgct tia(jt);\n+      Atomic::inc(&active_recordings);\n+      if (thread_state_in_java(jt)) {\n+        record_java_trace(jt, ucontext);\n+      } else if (thread_state_in_non_java(jt)) {\n+        record_native_trace(jt, ucontext);\n+      }\n+      Atomic::dec(&active_recordings);\n+    }\n+    _end_time = JfrTicks::now();\n+  }\n+\n+  void metadata_do(MetadataClosure* f) const {\n+    _stacktrace.metadata_do(f);\n+  }\n+\n+private:\n+\n+  void record_java_trace(JavaThread* jt, void* ucontext) {\n+    _type = JAVA_SAMPLE;\n+    JfrGetCallTrace trace(true, jt);\n+    frame topframe;\n+    if (trace.get_topframe(ucontext, topframe)) {\n+      _error = _stacktrace.record_async(jt, topframe) ? NO_ERROR : ERROR_JAVA_WALK_FAILED;\n+    }\n+  }\n+\n+  void record_native_trace(JavaThread* jt, void* ucontext) {\n+    _type = NATIVE_SAMPLE;\n+    _error = ERROR_NO_TRACE;\n+    if (!jt->has_last_Java_frame()) {\n+      _error = ERROR_NO_LAST_JAVA_FRAME;\n+      return;\n+    }\n+    frame topframe = jt->last_frame();\n+    frame first_java_frame;\n+    Method* method = nullptr;\n+    JfrGetCallTrace gct(false, jt);\n+    if (!gct.find_top_frame(topframe, &method, first_java_frame)) {\n+      _error = ERROR_NO_TOPFRAME;\n+      return;\n+    }\n+    if (method == nullptr) {\n+      _error = ERROR_NO_TOP_METHOD;\n+      return;\n+    }\n+    topframe = first_java_frame;\n+    _error = _stacktrace.record_async(jt, topframe) ? NO_ERROR: ERROR_NATIVE_WALK_FAILED;\n+  }\n+};\n+\n+\/\/ Fixed size async-signal-safe MPMC queue backed by an array.\n+\/\/ Serves for passing traces from a thread being sampled (producer)\n+\/\/ to a thread emitting JFR events (consumer).\n+\/\/ Does not own any frames.\n+\/\/\n+\/\/ _head and _tail of the queue are virtual (always increasing) positions modulo 2^32.\n+\/\/ Actual index into the backing array is computed as (position % _capacity).\n+\/\/ Generation G of an element at position P is the number of full wraps around the array:\n+\/\/   G = P \/ _capacity\n+\/\/ Generation allows to disambiguate situations when _head and _tail point to the same element.\n+\/\/\n+\/\/ Each element of the array is assigned a state, which encodes full\/empty flag in bit 31\n+\/\/ and the generation G of the element in bits 0..30:\n+\/\/   state (0,G): the element is empty and avaialble for enqueue() in generation G,\n+\/\/   state (1,G): the element is full and available for dequeue() in generation G.\n+\/\/ Possible transitions are:\n+\/\/   (0,G) --enqueue--> (1,G) --dequeue--> (0,G+1)\n+class JfrTraceQueue {\n+\n+  struct Element {\n+    \/\/ Encodes full\/empty flag along with generation of the element.\n+    \/\/ Also, establishes happens-before relationship between producer and consumer.\n+    \/\/ Update of this field \"commits\" enqueue\/dequeue transaction.\n+    u4 _state;\n+    JfrCPUTimeTrace* _trace;\n+  };\n+\n+  Element* _data;\n+  u4 _capacity;\n+\n+  \/\/ Pad _head and _tail to avoid false sharing\n+  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_PADDING_SIZE, sizeof(Element*) + sizeof(u4));\n+\n+  volatile u4 _head;\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_PADDING_SIZE, sizeof(u4));\n+\n+  volatile u4 _tail;\n+  DEFINE_PAD_MINUS_SIZE(2, DEFAULT_PADDING_SIZE, sizeof(u4));\n+\n+  inline Element* element(u4 position) {\n+    return &_data[position % _capacity];\n+  }\n+\n+  inline u4 state_empty(u4 position) {\n+    return (position \/ _capacity) & 0x7fffffff;\n+  }\n+\n+  inline u4 state_full(u4 position) {\n+    return (position \/ _capacity) | 0x80000000;\n+  }\n+\n+public:\n+  JfrTraceQueue(u4 capacity) : _capacity(capacity), _head(0), _tail(0) {\n+    _data = JfrCHeapObj::new_array<Element>(capacity);\n+    memset(_data, 0, _capacity * sizeof(Element));\n+  }\n+\n+  ~JfrTraceQueue() {\n+    JfrCHeapObj::free(_data, _capacity * sizeof(Element));\n+  }\n+\n+  bool enqueue(JfrCPUTimeTrace* trace) {\n+    int count = 10000;\n+    while (count -- > 0) {\n+      u4 tail = Atomic::load_acquire(&_tail);\n+      Element* e = element(tail);\n+      u4 state = Atomic::load_acquire(&e->_state);\n+      if (state == state_empty(tail)) {\n+        if (Atomic::cmpxchg(&_tail, tail, tail + 1, memory_order_seq_cst) == tail) {\n+            e->_trace = trace;\n+            \/\/ Mark element as full in current generation\n+            Atomic::release_store(&e->_state, state_full(tail));\n+            return true;\n+        }\n+      } else if (state == state_full(tail)) {\n+        \/\/ Another thread has just filled the same position; retry operation\n+      } else {\n+        return false;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  u4 _mark_count = 0;\n+\n+  JfrCPUTimeTrace* dequeue() {\n+    int count = 1000;\n+    while (count-- > 0) {\n+      u4 head = Atomic::load_acquire(&_head);\n+      Element* e = element(head);\n+      u4 state = Atomic::load_acquire(&e->_state);\n+      if (state == state_full(head)) {\n+        if (Atomic::cmpxchg(&_head, head, head + 1, memory_order_seq_cst) == head) {\n+            JfrCPUTimeTrace* trace = e->_trace;\n+            \/\/ After taking an element, mark it as empty in the next generation,\n+            \/\/ so we can reuse it again after completing the full circle\n+            Atomic::release_store(&e->_state, state_empty(head + _capacity));\n+            return trace;\n+        }\n+      } else if (state == state_empty(head)) {\n+        return nullptr; \/\/ Queue is empty\n+      } else {\n+        \/\/ Producer has not yet completed transaction\n+        \/\/ mark it as empty to prevent stalling\n+        if (count < 500) {\n+          Atomic::inc(&_mark_count);\n+          printf(\"mark count: %d\\n\", Atomic::load(&_mark_count));\n+          Atomic::release_store(&e->_state, state_empty(head));\n+        }\n+      }\n+    }\n+    return nullptr; \/\/ prevent hanging\n+  }\n+\n+  void reset() {\n+    memset(_data, 0, _capacity * sizeof(Element));\n+    _head = 0;\n+    _tail = 0;\n+    OrderAccess::release();\n+  }\n+\n+  void metadata_do(MetadataClosure* f) {\n+    if (Atomic::load(&_head) == Atomic::load(&_tail)) {\n+      return;\n+    }\n+    \/\/ iterate over all elements between head and tail\n+    uint32_t head = Atomic::load(&_head);\n+    uint32_t tail = Atomic::load(&_tail);\n+    printf(\"head: %d, tail: %d\\n\", head, tail);\n+    if (tail > head) {\n+      for (u4 i = head; i < tail; i++) {\n+        Element* e = element(i);\n+        if (e->_state == state_full(i)) {\n+          e->_trace->metadata_do(f);\n+        }\n+      }\n+    } else {\n+      for (u4 i = _head; i < _capacity; i++) {\n+        Element* e = element(i);\n+        if (e->_state == state_full(i)) {\n+          e->_trace->metadata_do(f);\n+        }\n+      }\n+      for (u4 i = 0; i < _tail; i++) {\n+        Element* e = element(i);\n+        if (e->_state == state_full(i)) {\n+          e->_trace->metadata_do(f);\n+        }\n+      }\n+    }\n+  }\n+\n+};\n+\n+\n+\/\/ Two queues for sampling, fresh and filled\n+\/\/ at the start, all traces are in the fresh queue\n+class JfrTraceQueues {\n+  JfrAsyncStackFrame* _frames;\n+  JfrCPUTimeTrace* _traces;\n+  JfrTraceQueue _fresh;\n+  JfrTraceQueue _filled;\n+  u4 _max_traces;\n+  u4 _max_frames_per_trace;\n+\n+public:\n+  JfrTraceQueues(u4 max_traces, u4 max_frames_per_trace):\n+    _frames(JfrCHeapObj::new_array<JfrAsyncStackFrame>(max_traces * max_frames_per_trace)),\n+    _traces(JfrCHeapObj::new_array<JfrCPUTimeTrace>(max_traces)), _fresh(max_traces), _filled(max_traces),\n+    _max_traces(max_traces), _max_frames_per_trace(max_frames_per_trace) {\n+    \/\/ create traces\n+    for (u4 i = 0; i < max_traces; i++) {\n+      _traces[i] = JfrCPUTimeTrace(i, &_frames[i * max_frames_per_trace], max_frames_per_trace);\n+    }\n+    \/\/ initialize fresh queue\n+    for (u4 i = 0; i < max_traces; i++) {\n+      _fresh.enqueue(&_traces[i]);\n+    }\n+  }\n+\n+  ~JfrTraceQueues() {\n+    JfrCHeapObj::free(_frames, sizeof(JfrAsyncStackFrame) * _max_traces * _max_frames_per_trace);\n+    JfrCHeapObj::free(_traces, sizeof(JfrCPUTimeTrace) * _max_traces);\n+  }\n+\n+  JfrTraceQueue& fresh() { return _fresh; }\n+  JfrTraceQueue& filled() { return _filled; }\n+\n+  u4 max_traces() const { return _max_traces; }\n+\n+  void reset() {\n+    _fresh.reset();\n+    for (u4 i = 0; i < _max_traces; i++) {\n+      _fresh.enqueue(&_traces[i]);\n+    }\n+    _filled.reset();\n+  }\n+\n+  void metadata_do(MetadataClosure* f) {\n+    _filled.metadata_do(f);\n+  }\n+};\n+\n+static int64_t compute_sampling_period(double rate);\n+\n+class JfrCPUTimeThreadSampler : public NonJavaThread {\n+  friend class JfrCPUTimeThreadSampling;\n+ private:\n+  Semaphore _sample;\n+  NonJavaThread* _sampler_thread;\n+  JfrTraceQueues _queues;\n+  double _rate;\n+  bool _autoadapt;\n+  volatile int64_t _current_sampling_period_ns = -1;\n+  const size_t _max_frames_per_trace;\n+  volatile bool _disenrolled;\n+  volatile bool _stop_signals = false;\n+  volatile int _active_signal_handlers;\n+  volatile bool _enqueue_loop_active = false;\n+  volatile bool _should_pause = false;\n+  JfrStackFrame *_jfrFrames;\n+  volatile int _ignore_because_queue_full = 0;\n+  volatile int _ignore_because_queue_full_sum = 0;\n+\n+#ifdef ASSERT\n+  volatile bool _process_queue = true;\n+#endif\n+\n+  const JfrBuffer* get_enqueue_buffer();\n+  const JfrBuffer* renew_if_full(const JfrBuffer* enqueue_buffer);\n+\n+\n+  void task_stacktrace(JfrSampleType type, JavaThread** last_thread);\n+  JfrCPUTimeThreadSampler(double rate, bool autoadapt, u4 max_traces, u4 max_frames_per_trace);\n+  ~JfrCPUTimeThreadSampler();\n+\n+  void start_thread();\n+\n+  void enroll();\n+  void disenroll();\n+  void update_all_thread_timers();\n+\n+  void autoadapt_period_if_needed();\n+\n+  bool should_process_trace_queue();\n+  \/\/ returns whether it returned normally and not because of lock contention\n+  bool process_trace_queue();\n+\n+  void set_rate(double rate, bool autoadapt);\n+  int64_t get_sampling_period() const { return Atomic::load(&_current_sampling_period_ns); };\n+\n+  void metadata_do(MetadataClosure* f);\n+\n+protected:\n+  virtual void post_run();\n+public:\n+  virtual const char* name() const { return \"JFR CPU Time Thread Sampler\"; }\n+  virtual const char* type_name() const { return \"JfrCPUTimeThreadSampler\"; }\n+  bool is_JfrSampler_thread() const { return true; }\n+  void run();\n+  void on_javathread_create(JavaThread* thread);\n+  bool create_timer_for_thread(JavaThread* thread, timer_t &timerid);\n+  void on_javathread_terminate(JavaThread* thread);\n+\n+  void handle_timer_signal(siginfo_t* info, void* context);\n+  void init_timers();\n+  void stop_timer();\n+};\n+\n+\n+JfrCPUTimeThreadSampler::JfrCPUTimeThreadSampler(double rate, bool autoadapt, u4 max_traces, u4 max_frames_per_trace) :\n+  _sample(),\n+  _sampler_thread(nullptr),\n+  _queues(max_traces, max_frames_per_trace),\n+  _rate(rate),\n+  _autoadapt(autoadapt),\n+  _current_sampling_period_ns(compute_sampling_period(rate)),\n+  _max_frames_per_trace(max_frames_per_trace),\n+  _disenrolled(true),\n+  _jfrFrames(JfrCHeapObj::new_array<JfrStackFrame>(_max_frames_per_trace)) {\n+  assert(rate >= 0, \"invariant\");\n+}\n+\n+JfrCPUTimeThreadSampler::~JfrCPUTimeThreadSampler() {\n+  JfrCHeapObj::free(_jfrFrames, sizeof(JfrStackFrame) * _max_frames_per_trace);\n+}\n+\n+void JfrCPUTimeThreadSampler::on_javathread_create(JavaThread* thread) {\n+  if (thread->is_Compiler_thread()) {\n+    return;\n+  }\n+  if (thread->jfr_thread_local() != nullptr) {\n+    timer_t timerid;\n+    if (create_timer_for_thread(thread, timerid)) {\n+      thread->jfr_thread_local()->set_timerid(timerid);\n+    }\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampler::on_javathread_terminate(JavaThread* thread) {\n+  if (thread->jfr_thread_local() != nullptr && thread->jfr_thread_local()->has_timerid()) {\n+    timer_delete(thread->jfr_thread_local()->timerid());\n+    thread->jfr_thread_local()->unset_timerid();\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampler::start_thread() {\n+  if (os::create_thread(this, os::os_thread)) {\n+    os::start_thread(this);\n+  } else {\n+    log_error(jfr)(\"Failed to create thread for thread sampling\");\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampler::enroll() {\n+  if (Atomic::cmpxchg(&_disenrolled, true, false)) {\n+    log_info(jfr)(\"Enrolling CPU thread sampler\");\n+    _sample.signal();\n+    init_timers();\n+    log_trace(jfr)(\"Enrolled CPU thread sampler\");\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampler::disenroll() {\n+  if (!Atomic::cmpxchg(&_disenrolled, false, true)) {\n+    log_info(jfr)(\"Disenrolling CPU thread sampler\");\n+    stop_timer();\n+    Atomic::store(&_stop_signals, true);\n+    while (_active_signal_handlers > 0) {\n+      \/\/ wait for all signal handlers to finish\n+      os::naked_short_nanosleep(1000);\n+    }\n+    _sample.wait();\n+    _queues.reset();\n+    Atomic::store(&_stop_signals, false);\n+    log_trace(jfr)(\"Disenrolled CPU thread sampler\");\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampler::run() {\n+  assert(_sampler_thread == nullptr, \"invariant\");\n+  _sampler_thread = this;\n+  int64_t last_autoadapt_check = os::javaTimeNanos();\n+  while (true) {\n+    if (!_sample.trywait()) {\n+      \/\/ disenrolled\n+      _sample.wait();\n+    }\n+    _sample.signal();\n+\n+    if (os::javaTimeNanos() - last_autoadapt_check > AUTOADAPT_INTERVAL_MS * 1000000) {\n+      autoadapt_period_if_needed();\n+      last_autoadapt_check = os::javaTimeNanos();\n+    }\n+\n+    int64_t period_nanos = get_sampling_period();\n+    period_nanos = period_nanos == 0 ? max_jlong : period_nanos;\n+    \/\/ If both periods are max_jlong, it implies the sampler is in the process of\n+    \/\/ disenrolling. Loop back for graceful disenroll by means of the semaphore.\n+    if (period_nanos == max_jlong) {\n+      continue;\n+    }\n+    int ignored = Atomic::xchg(&_ignore_because_queue_full, 0);\n+    if (ignored != 0) {\n+      log_trace(jfr)(\"CPU thread sampler ignored %d elements because of full queue (sum %d)\\n\", ignored, _ignore_because_queue_full_sum);\n+      if (EventCPUTimeSampleLoss::is_enabled()) {\n+        EventCPUTimeSampleLoss event;\n+        event.set_starttime(JfrTicks::now());\n+        event.set_lostSamples(ignored);\n+        event.commit();\n+      }\n+    }\n+\n+    \/\/ process all filled traces\n+    if (process_trace_queue()) {\n+      int64_t sleep_to_next = period_nanos \/ os::processor_count() \/ 2;\n+      if (sleep_to_next >= NANOSECS_PER_SEC) {\n+        sleep_to_next = NANOSECS_PER_SEC - 1;\n+      }\n+      os::naked_short_nanosleep(sleep_to_next);\n+    } else {\n+      \/\/ lock contention, so make sure to sleep to allow other\n+      \/\/ threads to finish\n+      os::naked_sleep(10);\n+    }\n+  }\n+}\n+\n+\/\/ crash protection for JfrThreadLocal::thread_id(trace->sampled_thread())\n+\/\/ because the thread could be deallocated between the time of recording\n+\/\/ and the time of processing\n+class JFRRecordSampledThreadCallback : public CrashProtectionCallback {\n+  friend class JfrCPUTimeThreadSampler;\n+ public:\n+  JFRRecordSampledThreadCallback(JavaThread* thread) :\n+    _thread(thread) {\n+  }\n+  virtual void call() {\n+    if (_thread->is_exiting()) {\n+      return;\n+    }\n+    _thread_id = JfrThreadLocal::thread_id(_thread);\n+    _valid = true;\n+  }\n+ private:\n+  JavaThread* _thread;\n+  traceid _thread_id;\n+  bool _valid = false;\n+};\n+\n+\n+static size_t count = 0;\n+static size_t lock_contention_loss_count = 0;\n+\n+\n+bool JfrCPUTimeThreadSampler::should_process_trace_queue() {\n+#ifdef ASSERT\n+  bool could_potentially_run = Atomic::load_acquire(&_process_queue);\n+#else\n+  bool could_potentially_run = true;\n+#endif\n+  return could_potentially_run && !Atomic::load_acquire(&_should_pause);\n+}\n+\n+bool JfrCPUTimeThreadSampler::process_trace_queue() {\n+  JfrCPUTimeTrace* trace;\n+  const JfrBuffer* enqueue_buffer = get_enqueue_buffer();\n+  assert(enqueue_buffer != nullptr, \"invariant\");\n+  enqueue_buffer = renew_if_full(enqueue_buffer);\n+\n+  if (!should_process_trace_queue()) {\n+    return true;\n+  }\n+\n+  Atomic::release_store(&_enqueue_loop_active, true);\n+\n+  bool stop = false;\n+\n+  while (!stop && should_process_trace_queue() && (trace = _queues.filled().dequeue()) != nullptr) {\n+    {\n+      JfrRotationLock lock(false, 1); \/\/ don't lock automatically\n+      if (lock.lock(1)) {\n+        \/\/ we aquired the lock, all good\n+\n+        \/\/ make sure we have enough space in the JFR enqueue buffer\n+        \/\/ create event, convert frames (resolve method ids)\n+        \/\/ we can't do the conversion in the signal handler,\n+        \/\/ as this causes segmentation faults related to the\n+        \/\/ enqueue buffers\n+        EventCPUTimeSample event;\n+        event.set_failed(true);\n+        if (trace->successful() && trace->stacktrace().nr_of_frames() > 0) {\n+          JfrStackTrace jfrTrace(_jfrFrames, _max_frames_per_trace);\n+          if (trace->stacktrace().store(&jfrTrace) && jfrTrace.nr_of_frames() > 0) {\n+            traceid id = JfrStackTraceRepository::add(jfrTrace);\n+            event.set_stackTrace(id);\n+            event.set_failed(false);\n+          } else {\n+            event.set_stackTrace(0);\n+          }\n+        } else {\n+          event.set_stackTrace(0);\n+        }\n+        event.set_starttime(trace->start_time());\n+        event.set_endtime(trace->end_time());\n+        event.set_samplingPeriod(Ticks(trace->sampling_period() \/ 1000000000.0 * JfrTime::frequency()) - Ticks(0));\n+\n+        if (EventCPUTimeSample::is_enabled()) {\n+          JFRRecordSampledThreadCallback cb(trace->sampled_thread());\n+          ThreadCrashProtection crash_protection;\n+          if (crash_protection.call(cb) && cb._valid) {\n+            event.set_eventThread(cb._thread_id);\n+            event.commit();\n+            count++;\n+            if (count % 10000 == 0) {\n+              log_info(jfr)(\"CPU thread sampler count %d; lock contention loss %d; queue loss (includes lock contention) %d\\n\", (int) count, (int) lock_contention_loss_count, (int) Atomic::load(&_ignore_because_queue_full_sum));\n+            }\n+          } else {\n+            log_trace(jfr)(\"Couldn't obtain thread id\\n\");\n+          }\n+        }\n+      } else {\n+        \/\/ we didn't get the lock\n+        \/\/ note this down as a loss and break out of the loop\n+        \/\/ this doesn't happen often, but it can happen\n+        \/\/\n+        \/\/ without this weak locking, we can cause a deadlock\n+        \/\/ this might happen because running this loop prevents the GC from progressing in the metadata_do method.\n+        \/\/ when the GC runs at the safepoint induced by the JFR recorder (which obtains the lock we're waiting for)\n+        Atomic::inc(&_ignore_because_queue_full);\n+        stop = true;\n+        lock_contention_loss_count++;\n+      }\n+    }\n+    if (!stop) {\n+      \/\/ only renew the buffer if we did enqueue or commit anything\n+      enqueue_buffer = renew_if_full(enqueue_buffer);\n+    }\n+    _queues.fresh().enqueue(trace);\n+  }\n+  Atomic::release_store(&_enqueue_loop_active, false);\n+  return !stop;\n+}\n+\n+void JfrCPUTimeThreadSampler::post_run() {\n+  this->NonJavaThread::post_run();\n+  delete this;\n+}\n+\n+const JfrBuffer* JfrCPUTimeThreadSampler::get_enqueue_buffer() {\n+  const JfrBuffer* buffer = JfrTraceIdLoadBarrier::get_sampler_enqueue_buffer(this);\n+  return buffer != nullptr ? renew_if_full(buffer) : JfrTraceIdLoadBarrier::renew_sampler_enqueue_buffer(this);\n+}\n+\n+const JfrBuffer* JfrCPUTimeThreadSampler::renew_if_full(const JfrBuffer* enqueue_buffer) {\n+  assert(enqueue_buffer != nullptr, \"invariant\");\n+  return enqueue_buffer->free_size() < _max_frames_per_trace * 2 * wordSize ? JfrTraceIdLoadBarrier::renew_sampler_enqueue_buffer(this) : enqueue_buffer;\n+}\n+\n+static JfrCPUTimeThreadSampling* _instance = nullptr;\n+\n+JfrCPUTimeThreadSampling& JfrCPUTimeThreadSampling::instance() {\n+  return *_instance;\n+}\n+\n+JfrCPUTimeThreadSampling* JfrCPUTimeThreadSampling::create() {\n+  assert(_instance == nullptr, \"invariant\");\n+  _instance = new JfrCPUTimeThreadSampling();\n+  return _instance;\n+}\n+\n+void JfrCPUTimeThreadSampling::destroy() {\n+  if (_instance != nullptr) {\n+    delete _instance;\n+    _instance = nullptr;\n+  }\n+}\n+\n+JfrCPUTimeThreadSampling::JfrCPUTimeThreadSampling() : _sampler(nullptr) {}\n+\n+JfrCPUTimeThreadSampling::~JfrCPUTimeThreadSampling() {\n+  if (_sampler != nullptr) {\n+    _sampler->disenroll();\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampling::create_sampler(double rate, bool autoadapt) {\n+  assert(_sampler == nullptr, \"invariant\");\n+  \/\/ factor of 20 seems to be a sweet spot between memory consumption\n+  \/\/ and lost samples for 1ms interval, we additionally keep in a\n+  \/\/ predetermined range to avoid adverse effects with too many\n+  \/\/ or too little elements in the queue, as we only have\n+  \/\/ one thread that processes the queue\n+  int64_t period_millis = compute_sampling_period(rate) \/ 1000000;\n+  int queue_size = 20 * os::processor_count() \/ (period_millis > 9 ? 2 : 1);\n+  \/\/ the queue should not be larger a factor of 4 of the max chunk size\n+  \/\/ so that it usually can be processed in one go without\n+  \/\/ allocating a new chunk\n+  long max_chunk_size = JfrOptionSet::max_chunk_size() == 0 ? 12 * 1024 * 1024 : JfrOptionSet::max_chunk_size() \/ 2;\n+  int max_size = max_chunk_size \/ 2 \/ wordSize \/ JfrOptionSet::stackdepth();\n+  if (queue_size < 20 * 4) {\n+    queue_size = 20 * 4;\n+  } else if (queue_size > max_size) {\n+    queue_size = max_size;\n+  }\n+  _sampler = new JfrCPUTimeThreadSampler(rate, autoadapt, queue_size, JfrOptionSet::stackdepth());\n+  _sampler->start_thread();\n+  _sampler->enroll();\n+}\n+\n+void JfrCPUTimeThreadSampling::update_run_state(double rate, bool autoadapt) {\n+  if (rate != 0) {\n+    if (_sampler == nullptr) {\n+      create_sampler(rate, autoadapt);\n+    } else {\n+      _sampler->set_rate(rate, autoadapt);\n+      _sampler->enroll();\n+    }\n+    return;\n+  }\n+  if (_sampler != nullptr) {\n+    _sampler->set_rate(rate \/* 0 *\/, autoadapt);\n+    _sampler->disenroll();\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampling::set_rate(double rate, bool autoadapt) {\n+  assert(rate >= 0, \"invariant\");\n+  if (_instance == nullptr) {\n+    return;\n+  }\n+  instance().set_rate_value(rate, autoadapt);\n+}\n+\n+void JfrCPUTimeThreadSampling::set_rate_value(double rate, bool autoadapt) {\n+  if (_sampler != nullptr) {\n+    _sampler->set_rate(rate, autoadapt);\n+  }\n+  update_run_state(rate, autoadapt);\n+}\n+\n+void JfrCPUTimeThreadSampling::on_javathread_create(JavaThread *thread) {\n+  if (_instance != nullptr && _instance->_sampler != nullptr) {\n+    _instance->_sampler->on_javathread_create(thread);\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampling::on_javathread_terminate(JavaThread *thread) {\n+  if (_instance != nullptr && _instance->_sampler != nullptr) {\n+    _instance->_sampler->on_javathread_terminate(thread);\n+  }\n+}\n+\n+void handle_timer_signal(int signo, siginfo_t* info, void* context) {\n+  assert(_instance != nullptr, \"invariant\");\n+  _instance->handle_timer_signal(info, context);\n+}\n+\n+\n+void JfrCPUTimeThreadSampling::handle_timer_signal(siginfo_t* info, void* context) {\n+  assert(_sampler != nullptr, \"invariant\");\n+  if (Atomic::load(&_sampler->_stop_signals)) {\n+    return;\n+  }\n+  Atomic::inc(&_sampler->_active_signal_handlers);\n+  _sampler->handle_timer_signal(info, context);\n+  Atomic::dec(&_sampler->_active_signal_handlers);\n+}\n+\n+void JfrCPUTimeThreadSampler::handle_timer_signal(siginfo_t* info, void* context) {\n+  JavaThread* jt = get_java_thread_if_valid();\n+  if (jt == nullptr) {\n+    return;\n+  }\n+  if (Atomic::load_acquire(&_should_pause)) {\n+    \/\/ TODO: needed?\n+    return;\n+  }\n+  NoResourceMark rm;\n+  JfrCPUTimeTrace* trace = this->_queues.fresh().dequeue();\n+  if (trace != nullptr) {\n+    \/\/ the sampling period might be too low for the current Linux configuration\n+    \/\/ so samples might be skipped and we have to compute the actual period\n+    int64_t period = get_sampling_period() * (info->si_overrun + 1);\n+    trace->record_trace(jt, context, period, Atomic::load_acquire(&_should_pause));\n+    this->_queues.filled().enqueue(trace);\n+  } else {\n+    Atomic::inc(&_ignore_because_queue_full);\n+    Atomic::inc(&_ignore_because_queue_full_sum);\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampling::metadata_do(MetadataClosure* f) {\n+  if (_sampler != nullptr) {\n+    _sampler->metadata_do(f);\n+  }\n+}\n+\n+static const int SIG = SIGPROF;\n+\n+static void set_timer_time(timer_t timerid, int64_t period_nanos) {\n+  struct itimerspec its;\n+  if (period_nanos == 0) {\n+    its.it_interval.tv_sec = 0;\n+    its.it_interval.tv_nsec = 0;\n+  } else {\n+    its.it_interval.tv_sec = period_nanos \/ NANOSECS_PER_SEC;\n+    its.it_interval.tv_nsec = period_nanos % NANOSECS_PER_SEC;\n+  }\n+  its.it_value = its.it_interval;\n+  if (timer_settime(timerid, 0, &its, NULL) == -1) {\n+    warning(\"Failed to set timer for thread sampling: %s\", os::strerror(os::get_last_error()));\n+  }\n+}\n+\n+bool JfrCPUTimeThreadSampler::create_timer_for_thread(JavaThread* thread, timer_t& timerid) {\n+  if (thread->osthread() == nullptr || thread->osthread()->thread_id() == 0){\n+    return false;\n+  }\n+  timer_t t;\n+  struct sigevent sev;\n+  sev.sigev_notify = SIGEV_THREAD_ID;\n+  sev.sigev_signo = SIG;\n+  sev.sigev_value.sival_ptr = &t;\n+  ((int*)&sev.sigev_notify)[1] = thread->osthread()->thread_id();\n+  clockid_t clock;\n+  int err = pthread_getcpuclockid(thread->osthread()->pthread_id(), &clock);\n+  if (err != 0) {\n+    log_error(jfr)(\"Failed to get clock for thread sampling: %s\", os::strerror(err));\n+    return false;\n+  }\n+  if (timer_create(clock, &sev, &t) < 0) {\n+    return false;\n+  }\n+  int64_t period = get_sampling_period();\n+  if (period != 0) {\n+    set_timer_time(t, period);\n+  }\n+  timerid = t;\n+  return true;\n+}\n+\n+class VM_CPUTimeSamplerThreadInitializer : public VM_Operation {\n+ private:\n+  JfrCPUTimeThreadSampler *_sampler;\n+ public:\n+\n+  VM_CPUTimeSamplerThreadInitializer(JfrCPUTimeThreadSampler* sampler) : _sampler(sampler) {\n+  }\n+\n+  VMOp_Type type() const { return VMOp_CPUTimeSamplerThreadInitializer; }\n+  void doit() {\n+    JfrJavaThreadIterator iter;\n+    while (iter.has_next()) {\n+      _sampler->on_javathread_create(iter.next());\n+    }\n+  };\n+};\n+\n+void JfrCPUTimeThreadSampler::init_timers() {\n+  \/\/ install sig handler for sig\n+  PosixSignals::install_generic_signal_handler(SIG, (void*)::handle_timer_signal);\n+\n+  VM_CPUTimeSamplerThreadInitializer op(this);\n+  VMThread::execute(&op);\n+}\n+\n+class VM_CPUTimeSamplerThreadTerminator : public VM_Operation {\n+ private:\n+  JfrCPUTimeThreadSampler *_sampler;\n+ public:\n+\n+  VM_CPUTimeSamplerThreadTerminator(JfrCPUTimeThreadSampler* sampler) : _sampler(sampler) {\n+  }\n+\n+  VMOp_Type type() const { return VMOp_CPUTimeSamplerThreadTerminator; }\n+  void doit() {\n+    JfrJavaThreadIterator iter;\n+    while (iter.has_next()) {\n+      JavaThread *thread = iter.next();\n+      JfrThreadLocal* jfr_thread_local = thread->jfr_thread_local();\n+      if (jfr_thread_local != nullptr && jfr_thread_local->has_timerid()) {\n+        timer_delete(jfr_thread_local->timerid());\n+        thread->jfr_thread_local()->unset_timerid();\n+      }\n+    }\n+  };\n+};\n+\n+void JfrCPUTimeThreadSampler::stop_timer() {\n+  VM_CPUTimeSamplerThreadTerminator op(this);\n+  VMThread::execute(&op);\n+}\n+\n+int64_t compute_sampling_period(double rate) {\n+  if (rate == 0) {\n+    return 0;\n+  }\n+  return os::active_processor_count() * 1000000000.0 \/ rate;\n+}\n+\n+void JfrCPUTimeThreadSampler::autoadapt_period_if_needed() {\n+  int64_t current_period = get_sampling_period();\n+  if (_autoadapt || current_period == -1) {\n+    int64_t period = compute_sampling_period(_rate);\n+    if (period != current_period) {\n+      Atomic::store(&_current_sampling_period_ns, period);\n+      update_all_thread_timers();\n+    }\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampler::set_rate(double rate, bool autoadapt) {\n+  _rate = rate;\n+  _autoadapt = autoadapt;\n+  if (_rate > 0 && Atomic::load(&_disenrolled) == false) {\n+    autoadapt_period_if_needed();\n+  } else {\n+    Atomic::store(&_current_sampling_period_ns, compute_sampling_period(rate));\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampler::metadata_do(MetadataClosure* f) {\n+  Atomic::release_store(&_should_pause, true);\n+  while (Atomic::load_acquire(&active_recordings) > 0) {\n+  }\n+  while (Atomic::load_acquire(&_enqueue_loop_active)) {\n+  }\n+  OrderAccess::loadload();\n+  _queues.metadata_do(f);\n+  Atomic::release_store(&_should_pause, false);\n+}\n+\n+void JfrCPUTimeThreadSampler::update_all_thread_timers() {\n+  int64_t period_millis = get_sampling_period();\n+  MutexLocker tlock(Threads_lock);\n+  ThreadsListHandle tlh;\n+  for (size_t i = 0; i < tlh.length(); i++) {\n+    JavaThread* thread = tlh.thread_at(i);\n+    JfrThreadLocal* jfr_thread_local = thread->jfr_thread_local();\n+    if (jfr_thread_local != nullptr && jfr_thread_local->has_timerid()) {\n+      set_timer_time(jfr_thread_local->timerid(), period_millis);\n+    }\n+  }\n+}\n+\n+#ifdef ASSERT\n+void JfrCPUTimeThreadSampling::set_process_queue(bool process_queue) {\n+  if (_instance != nullptr && _instance->_sampler != nullptr) {\n+    Atomic::store(&_instance->_sampler->_process_queue, process_queue);\n+  }\n+}\n+#endif\n+\n+#else\n+\n+static bool _showed_warning = false;\n+\n+static void warn() {\n+  if (!_showed_warning) {\n+    warning(\"CPU time method sampling not supported in JFR on your platform\");\n+    _showed_warning = true;\n+  }\n+}\n+\n+static JfrCPUTimeThreadSampling* _instance = nullptr;\n+\n+JfrCPUTimeThreadSampling& JfrCPUTimeThreadSampling::instance() {\n+  return *_instance;\n+}\n+\n+JfrCPUTimeThreadSampling* JfrCPUTimeThreadSampling::create() {\n+  _instance = new JfrCPUTimeThreadSampling();\n+  return _instance;\n+}\n+\n+void JfrCPUTimeThreadSampling::destroy() {\n+  delete _instance;\n+  _instance = nullptr;\n+}\n+\n+void JfrCPUTimeThreadSampling::set_rate(double rate, bool autoadapt) {\n+  if (rate != 0) {\n+    warn();\n+  }\n+}\n+\n+void JfrCPUTimeThreadSampling::on_javathread_create(JavaThread* thread) {\n+}\n+\n+void JfrCPUTimeThreadSampling::on_javathread_terminate(JavaThread* thread) {\n+}\n+\n+void JfrCPUTimeThreadSampling::metadata_do(MetadataClosure* f) {\n+}\n+\n+#ifdef ASSERT\n+void JfrCPUTimeThreadSampling::set_process_queue(bool process_queue) {}\n+#endif\n+\n+#endif \/\/ defined(LINUX) && defined(INCLUDE_JFR)\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":1088,"deletions":0,"binary":false,"changes":1088,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_PERIODIC_SAMPLING_JFRCPUTIMETHREADSAMPLER_HPP\n+#define SHARE_JFR_PERIODIC_SAMPLING_JFRCPUTIMETHREADSAMPLER_HPP\n+\n+#include \"jfr\/utilities\/jfrAllocation.hpp\"\n+\n+class JavaThread;\n+class NonJavaThread;\n+class MetadataClosure;\n+\n+#if defined(LINUX)\n+\n+\n+class JfrCPUTimeThreadSampler;\n+\n+class JfrCPUTimeThreadSampling : public JfrCHeapObj {\n+  friend class JfrRecorder;\n+ private:\n+\n+  JfrCPUTimeThreadSampler* _sampler;\n+\n+  void create_sampler(double rate, bool autoadapt);\n+  void set_rate_value(double rate, bool autoadapt);\n+\n+  JfrCPUTimeThreadSampling();\n+  ~JfrCPUTimeThreadSampling();\n+\n+  static JfrCPUTimeThreadSampling& instance();\n+  static JfrCPUTimeThreadSampling* create();\n+  static void destroy();\n+\n+  void update_run_state(double rate, bool autoadapt);\n+\n+ public:\n+  static void set_rate(double rate, bool autoadapt);\n+\n+  static void on_javathread_create(JavaThread* thread);\n+  static void on_javathread_terminate(JavaThread* thread);\n+  void handle_timer_signal(siginfo_t* info, void* context);\n+  void metadata_do(MetadataClosure* f);\n+\n+#ifdef ASSERT\n+  static void set_process_queue(bool process_queue);\n+#endif\n+};\n+\n+#else\n+\n+\/\/ a basic implementation on other platforms that\n+\/\/ emits warnings\n+\n+class JfrCPUTimeThreadSampling : public JfrCHeapObj {\n+  friend class JfrRecorder;\n+private:\n+  static JfrCPUTimeThreadSampling& instance();\n+  static JfrCPUTimeThreadSampling* create();\n+  static void destroy();\n+\n+ public:\n+  static void set_rate(double rate, bool autoadapt);\n+\n+  static void on_javathread_create(JavaThread* thread);\n+  static void on_javathread_terminate(JavaThread* thread);\n+  void metadata_do(MetadataClosure* f);\n+\n+#ifdef ASSERT\n+  static void set_process_queue(bool process_queue);\n+#endif\n+};\n+\n+#endif \/\/ defined(LINUX)\n+\n+\n+#endif \/\/ SHARE_JFR_PERIODIC_SAMPLING_JFRCPUTIMETHREADSAMPLER_HPP\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -185,0 +185,1 @@\n+  NoResourceMark rm;\n@@ -237,0 +238,1 @@\n+  NoResourceMark rm;\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+  friend class JfrCPUTimeThreadSampler;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp\"\n@@ -50,0 +51,1 @@\n+#include \"memory\/iterator.hpp\"\n@@ -307,0 +309,3 @@\n+  if (!create_cpu_time_thread_sampling()) {\n+    return false;\n+  }\n@@ -321,0 +326,1 @@\n+static JfrCPUTimeThreadSampling* _cpu_time_thread_sampling = nullptr;\n@@ -393,0 +399,6 @@\n+bool JfrRecorder::create_cpu_time_thread_sampling() {\n+  assert(_cpu_time_thread_sampling == nullptr, \"invariant\");\n+  _cpu_time_thread_sampling = JfrCPUTimeThreadSampling::create();\n+  return _cpu_time_thread_sampling != nullptr;\n+}\n+\n@@ -431,0 +443,4 @@\n+  if (_cpu_time_thread_sampling != nullptr) {\n+    JfrCPUTimeThreadSampling::destroy();\n+    _cpu_time_thread_sampling = nullptr;\n+  }\n@@ -465,0 +481,6 @@\n+\n+void JfrRecorder::metadata_do(MetadataClosure* f) {\n+  if (_cpu_time_thread_sampling != nullptr) {\n+    _cpu_time_thread_sampling->metadata_do(f);\n+  }\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/iterator.hpp\"\n@@ -32,0 +33,1 @@\n+class MetadataClosure;\n@@ -57,0 +59,1 @@\n+  static bool create_cpu_time_thread_sampling();\n@@ -61,0 +64,1 @@\n+  static void metadata_do(MetadataClosure* f);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,0 +64,3 @@\n+  if (event_id == JfrCPUTimeSampleEvent) {\n+    return nullptr;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrEventThrottler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,15 +61,5 @@\n-class JfrRotationLock : public StackObj {\n- private:\n-  static const Thread* _owner_thread;\n-  static const int retry_wait_millis;\n-  static volatile int _lock;\n-  Thread* _thread;\n-  bool _recursive;\n-\n-  static bool acquire(Thread* thread) {\n-    if (Atomic::cmpxchg(&_lock, 0, 1) == 0) {\n-      assert(_owner_thread == nullptr, \"invariant\");\n-      _owner_thread = thread;\n-      return true;\n-    }\n-    return false;\n+bool JfrRotationLock::acquire(Thread* thread) {\n+  if (Atomic::cmpxchg(&_lock, 0, 1) == 0) {\n+    assert(_owner_thread == nullptr, \"invariant\");\n+    _owner_thread = thread;\n+    return true;\n@@ -77,0 +67,2 @@\n+  return false;\n+}\n@@ -78,8 +70,6 @@\n-  \/\/ The system can proceed to a safepoint\n-  \/\/ because even if the thread is a JavaThread,\n-  \/\/ it is running as _thread_in_native here.\n-  void lock() {\n-    while (!acquire(_thread)) {\n-      os::naked_short_sleep(retry_wait_millis);\n-    }\n-    assert(is_owner(), \"invariant\");\n+\/\/ The system can proceed to a safepoint\n+\/\/ because even if the thread is a JavaThread,\n+\/\/ it is running as _thread_in_native here.\n+bool JfrRotationLock::lock(int retries) {\n+  if (_obtained_lock) {\n+      return true;\n@@ -87,11 +77,5 @@\n-\n- public:\n-  JfrRotationLock() : _thread(Thread::current()), _recursive(false) {\n-    assert(_thread != nullptr, \"invariant\");\n-    if (_thread == _owner_thread) {\n-      \/\/ Recursive case is not supported.\n-      _recursive = true;\n-      assert(_lock == 1, \"invariant\");\n-      \/\/ For user, should not be \"jfr, system\".\n-      log_info(jfr)(\"Unable to issue rotation due to recursive calls.\");\n-      return;\n+  assert(!is_owner(), \"invariant\");\n+  int retry_count = 0;\n+  while (!acquire(_thread)) {\n+    if (++retry_count > retries && retries > 0) {\n+      return false;\n@@ -99,1 +83,1 @@\n-    lock();\n+    os::naked_short_sleep(_retry_wait_millis);\n@@ -101,0 +85,4 @@\n+  assert(is_owner(), \"invariant\");\n+  _obtained_lock = true;\n+  return true;\n+}\n@@ -102,8 +90,9 @@\n-  ~JfrRotationLock() {\n-    assert(is_owner(), \"invariant\");\n-    if (_recursive) {\n-      return;\n-    }\n-    _owner_thread = nullptr;\n-    OrderAccess::storestore();\n-    _lock = 0;\n+JfrRotationLock::JfrRotationLock(bool lock_directly, int retry_wait_millis) : _retry_wait_millis(retry_wait_millis), _thread(Thread::current()), _recursive(false), _obtained_lock(false) {\n+  assert(_thread != nullptr, \"invariant\");\n+  if (_thread == _owner_thread) {\n+    \/\/ Recursive case is not supported.\n+    _recursive = true;\n+    assert(_lock == 1, \"invariant\");\n+    \/\/ For user, should not be \"jfr, system\".\n+    log_info(jfr)(\"Unable to issue rotation due to recursive calls.\");\n+    return;\n@@ -111,3 +100,2 @@\n-\n-  static bool is_owner() {\n-    return _owner_thread == Thread::current();\n+  if (lock_directly) {\n+    lock(-1);\n@@ -115,0 +103,1 @@\n+}\n@@ -116,2 +105,3 @@\n-  bool is_acquired_recursively() const {\n-    return _recursive;\n+JfrRotationLock::~JfrRotationLock() {\n+  if (!_obtained_lock || _recursive) {\n+    return;\n@@ -119,1 +109,9 @@\n-};\n+  assert(is_owner(), \"invariant\");\n+  _owner_thread = nullptr;\n+  OrderAccess::storestore();\n+  _lock = 0;\n+}\n+\n+bool JfrRotationLock::is_owner() {\n+  return _owner_thread == Thread::current();\n+}\n@@ -122,1 +120,1 @@\n-const int JfrRotationLock::retry_wait_millis = 10;\n+const int JfrRotationLock::default_retry_wait_millis = 10;\n@@ -709,1 +707,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":49,"deletions":51,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -37,0 +37,31 @@\n+class JfrRotationLock : public StackObj {\n+ private:\n+  int _retry_wait_millis;\n+  static const Thread* _owner_thread;\n+  static const int default_retry_wait_millis;\n+  static volatile int _lock;\n+  Thread* _thread;\n+  bool _recursive;\n+  bool _obtained_lock;\n+\n+  static bool acquire(Thread* thread);\n+\n+ public:\n+  JfrRotationLock() : JfrRotationLock(true, default_retry_wait_millis) {}\n+  JfrRotationLock(bool lock_directly, int retry_wait_millis = default_retry_wait_millis);\n+\n+  \/\/ The system can proceed to a safepoint\n+  \/\/ because even if the thread is a JavaThread,\n+  \/\/ it is running as _thread_in_native here.\n+  \/\/ Only call this method directly if you haven't locked before\n+  bool lock(int retries);\n+\n+  ~JfrRotationLock();\n+\n+  static bool is_owner();\n+\n+  bool is_acquired_recursively() const {\n+    return _recursive;\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jfr\/recorder\/stacktrace\/jfrAsyncStackTrace.hpp\"\n+#include \"jfr\/recorder\/stacktrace\/jfrStackTrace.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"jfr\/recorder\/repository\/jfrChunkWriter.hpp\"\n+#include \"jfr\/recorder\/storage\/jfrBuffer.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.hpp\"\n+#include \"runtime\/threadCrashProtection.hpp\"\n+#include \"runtime\/vframe.inline.hpp\"\n+\n+JfrAsyncStackFrame::JfrAsyncStackFrame(u2 methodId, int bci, u1 type, int lineno, InstanceKlass* klass) :\n+  _methodId(methodId), _type(type), _bci(bci), _line(lineno), _klass(klass) {\n+}\n+\n+int JfrAsyncStackFrame::lineno() const {\n+  return _line;\n+}\n+\n+int JfrAsyncStackFrame::bci() const {\n+  return _bci;\n+}\n+\n+u1 JfrAsyncStackFrame::type() const {\n+  return _type;\n+}\n+\n+JfrAsyncStackTrace::JfrAsyncStackTrace(JfrAsyncStackFrame* frames, u4 max_frames) :\n+  _frames(frames),\n+  _nr_of_frames(0),\n+  _max_frames(max_frames),\n+  _reached_root(false)\n+  {}\n+\n+void JfrAsyncStackTrace::metadata_do(MetadataClosure* f) const {\n+  if (_nr_of_frames == 0) {\n+    return;\n+  }\n+  for (u4 i = 0; i < _nr_of_frames; i++) {\n+    f->do_metadata(_frames[i].klass());\n+  }\n+}\n+\n+bool JfrAsyncStackTrace::record_async(JavaThread* jt, const frame& frame) {\n+  NoHandleMark nhm;\n+\n+  assert(jt != nullptr, \"invariant\");\n+  Thread* current_thread = Thread::current_or_null_safe();\n+  if (current_thread == nullptr) {\n+    return false;\n+  }\n+  assert(current_thread->in_asgct(), \"invariant\");\n+\n+  u4 count = 0;\n+  _reached_root = true;\n+\n+  JfrVframeStream vfs(jt, frame, false, true, false);\n+\n+  while (!vfs.at_end()) {\n+    if (count >= _max_frames) {\n+      _reached_root = false;\n+      break;\n+    }\n+    const Method* method = vfs.method();\n+    if (method == nullptr || !Method::is_valid_method(method)) {\n+      \/\/ we throw away everything we've gathered in this sample since\n+      \/\/ none of it is safe\n+      return false;\n+    }\n+    u1 type = vfs.is_interpreted_frame() ? JfrStackFrame::FRAME_INTERPRETER : JfrStackFrame::FRAME_JIT;\n+    int bci = 0;\n+    if (method->is_native()) {\n+      type = JfrStackFrame::FRAME_NATIVE;\n+    } else {\n+      bci = vfs.bci();\n+    }\n+\n+    intptr_t* frame_id = vfs.frame_id();\n+    vfs.next_vframe();\n+    if (type == JfrStackFrame::FRAME_JIT && !vfs.at_end() && frame_id == vfs.frame_id()) {\n+      \/\/ This frame and the caller frame are both the same physical\n+      \/\/ frame, so this frame is inlined into the caller.\n+      type = JfrStackFrame::FRAME_INLINE;\n+    }\n+\n+    _frames[count] = JfrAsyncStackFrame(method->orig_method_idnum(), bci, type, method->line_number_from_bci(bci), method->method_holder());\n+    count++;\n+  }\n+  _nr_of_frames = count;\n+  return count > 0;\n+}\n+\n+bool JfrAsyncStackTrace::store(JfrStackTrace* trace) const {\n+  assert(trace != nullptr, \"invariant\");\n+  Thread* current_thread = Thread::current();\n+  assert(current_thread->is_JfrSampler_thread() || current_thread->in_asgct(), \"invariant\");\n+  trace->set_nr_of_frames(_nr_of_frames);\n+  trace->set_reached_root(_reached_root);\n+  traceid hash = 1;\n+  for (u4 i = 0; i < _nr_of_frames; i++) {\n+    const JfrAsyncStackFrame& frame = _frames[i];\n+    Method* method = frame.klass()->method_with_orig_idnum(frame.methodId());\n+    if (!Method::is_valid_method(method)) {\n+      \/\/ we throw away everything we've gathered in this sample since\n+      \/\/ none of it is safe\n+      return false;\n+    }\n+    const traceid mid = JfrTraceId::load(method);\n+    hash = (hash * 31) + mid;\n+    hash = (hash * 31) + frame.bci();\n+    hash = (hash * 31) + frame.type();\n+    trace->_frames[i] = JfrStackFrame(mid, frame.bci(), frame.type(), frame.lineno(), method->method_holder());\n+  }\n+  trace->set_hash(hash);\n+  trace->_lineno = true;\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrAsyncStackTrace.cpp","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_RECORDER_STACKTRACE_JFRASYNCSTACKTRACE_HPP\n+#define SHARE_JFR_RECORDER_STACKTRACE_JFRASYNCSTACKTRACE_HPP\n+\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"oops\/method.hpp\"\n+\n+\/\/ This is based on JfrStackTrace, with the major difference that methods\n+\/\/ are not resolved\n+\n+class frame;\n+class InstanceKlass;\n+class JavaThread;\n+class JfrStackTrace;\n+class MetadataClosure;\n+\n+class JfrAsyncStackFrame {\n+ private:\n+  \/\/ this could be optimized, by restricting the line to 2**24\n+  \/\/ and storing the bci in 17 bits, reducing the type to 4 bits\n+  u2 _methodId;\n+  u1 _type;\n+  int _bci;\n+  int _line;\n+  InstanceKlass* _klass;\n+\n+ public:\n+  JfrAsyncStackFrame(u2 methodId, int bci, u1 type, int lineno, InstanceKlass* klass);\n+\n+  enum : u1 {\n+    FRAME_INTERPRETER = 0,\n+    FRAME_JIT,\n+    FRAME_INLINE,\n+    FRAME_NATIVE,\n+    NUM_FRAME_TYPES\n+  };\n+\n+  u2 methodId() const { return _methodId; }\n+  int bci() const;\n+  u1 type() const;\n+  int lineno() const;\n+  InstanceKlass* klass() const { return _klass; }\n+};\n+\n+class JfrAsyncStackTraceStoreCallback;\n+\n+\/\/ A trace without methods resolved to ids\n+class JfrAsyncStackTrace {\n+  friend class JfrCPUTimeTrace;\n+  friend class JfrAsyncStackTraceStoreCallback;\n+ private:\n+  JfrAsyncStackFrame* _frames;\n+  u4 _nr_of_frames;\n+  u4 _max_frames;\n+  bool _reached_root;\n+\n+  void set_nr_of_frames(u4 nr_of_frames) { _nr_of_frames = nr_of_frames; }\n+  void set_reached_root(bool reached_root) { _reached_root = reached_root; }\n+  void resolve_linenos() const;\n+\n+  bool record_async(JavaThread* other_thread, const frame& frame);\n+\n+  bool full_stacktrace() const { return _reached_root; }\n+\n+  JfrAsyncStackTrace(JfrAsyncStackFrame* frames, u4 max_frames);\n+\n+  void metadata_do(MetadataClosure* f) const;\n+\n+ public:\n+\n+  \/\/ store the trace in a JfrStackTrace object, resolving methods and line numbers\n+  bool store(JfrStackTrace* trace) const;\n+\n+  u4 nr_of_frames() const { return _nr_of_frames; }\n+};\n+\n+#endif \/\/ SHARE_JFR_RECORDER_STACKTRACE_JFRASYNCSTACKTRACE_HPP\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrAsyncStackTrace.hpp","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -140,12 +140,0 @@\n-class JfrVframeStream : public vframeStreamCommon {\n- private:\n-  bool _vthread;\n-  const ContinuationEntry* _cont_entry;\n-  bool _async_mode;\n-  bool step_to_sender();\n-  void next_frame();\n- public:\n-  JfrVframeStream(JavaThread* jt, const frame& fr, bool stop_at_java_call_stub, bool async_mode);\n-  void next_vframe();\n-};\n-\n@@ -164,1 +152,1 @@\n-JfrVframeStream::JfrVframeStream(JavaThread* jt, const frame& fr, bool stop_at_java_call_stub, bool async_mode) :\n+JfrVframeStream::JfrVframeStream(JavaThread* jt, const frame& fr, bool stop_at_java_call_stub, bool async_mode, bool allow_continuation_walk) :\n@@ -168,1 +156,1 @@\n-                     walk_continuation(jt)),\n+                     allow_continuation_walk ? walk_continuation(jt) : RegisterMap::WalkContinuation::skip),\n@@ -246,1 +234,1 @@\n-  JfrVframeStream vfs(jt, frame, false, true);\n+  JfrVframeStream vfs(jt, frame, false, true, true);\n@@ -297,1 +285,1 @@\n-  JfrVframeStream vfs(jt, frame, false, false);\n+  JfrVframeStream vfs(jt, frame, false, false, true);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":4,"deletions":16,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/vframe.hpp\"\n@@ -37,0 +38,12 @@\n+class JfrVframeStream : public vframeStreamCommon {\n+ private:\n+  bool _vthread;\n+  const ContinuationEntry* _cont_entry;\n+  bool _async_mode;\n+  bool step_to_sender();\n+  void next_frame();\n+ public:\n+  JfrVframeStream(JavaThread* jt, const frame& fr, bool stop_at_java_call_stub, bool async_mode, bool allow_continuation_walk);\n+  void next_vframe();\n+};\n+\n@@ -71,0 +84,3 @@\n+  friend class JfrCPUTimeTrace;\n+  friend class JfrAsyncStackTrace;\n+  friend class JfrCPUTimeThreadSampler;\n@@ -110,0 +126,1 @@\n+  u4 nr_of_frames() const { return _nr_of_frames; }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  friend class JfrCPUTimeThreadSampler;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTraceRepository.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#ifdef ASSERT\n@@ -41,1 +40,1 @@\n-static void assert_epoch_identity(JavaThread* jt, u2 current_epoch) {\n+static bool check_and_assert_epoch_identity(JavaThread* jt, u2 current_epoch) {\n@@ -49,1 +48,1 @@\n-  assert(vthread_epoch == current_epoch, \"invariant\");\n+  return vthread_epoch == current_epoch; \/\/ might be false for the CPU-time sampler\n@@ -51,1 +50,0 @@\n-#endif \/\/ ASSERT\n@@ -63,3 +61,6 @@\n-    DEBUG_ONLY(assert_epoch_identity(jt, current_epoch);)\n-    ThreadInVMfromJava transition(jt);\n-    return JfrJavaEventWriter::event_writer(jt);\n+    if (check_and_assert_epoch_identity(jt, current_epoch)) {\n+      \/\/ the CPU-time sampler can cause the invariant to fail,\n+      \/\/ so we have to check it\n+      ThreadInVMfromJava transition(jt);\n+      return JfrJavaEventWriter::event_writer(jt);\n+    }\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp\"\n@@ -129,1 +130,3 @@\n-      send_java_thread_start_event(JavaThread::cast(t));\n+      JavaThread *const jt = JavaThread::cast(t);\n+      send_java_thread_start_event(jt);\n+      JfrCPUTimeThreadSampling::on_javathread_create(jt);\n@@ -225,0 +228,1 @@\n+    JfrCPUTimeThreadSampling::on_javathread_terminate(jt);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,5 @@\n+#ifdef LINUX\n+\/\/ required for timer_t type\n+#include <signal.h>\n+#endif\n+\n@@ -73,0 +78,2 @@\n+  LINUX_ONLY(bool _has_cpu_timer = false);\n+  LINUX_ONLY(timer_t _cpu_timer);\n@@ -280,0 +287,20 @@\n+  \/\/ CPU time sampling\n+#ifdef LINUX\n+  void set_timerid(timer_t timer) {\n+    _has_cpu_timer = true;\n+    _cpu_timer = timer;\n+  }\n+\n+  void unset_timerid() {\n+    _has_cpu_timer = false;\n+  }\n+\n+  timer_t timerid() const {\n+    return _cpu_timer;\n+  }\n+\n+  bool has_timerid() const {\n+    return _has_cpu_timer;\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -126,0 +126,7 @@\n+  #ifdef ASSERT\n+  Thread* t = Thread::current_or_null_safe();\n+  if (t != nullptr && t->resource_area() != nullptr) {\n+    \/\/ Just to make sure that we're allowed to allocate\n+    t->resource_area()->verify_no_NoResourceMark();\n+  }\n+  #endif\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+    area->verify_no_NoResourceMark();\n@@ -47,1 +48,1 @@\n-  if (_nesting <= 0 && !VMError::is_error_reported()) {\n+  if ((_nesting <= 0 || _no_resource_mark_nesting > 0) && !VMError::is_error_reported()) {\n@@ -54,1 +55,5 @@\n-        fatal(\"memory leak: allocating without ResourceMark\");\n+        if (_nesting <= 0) {\n+          fatal(\"memory leak: allocating without ResourceMark\");\n+        } else {\n+          fatal(\"memory leak: allocating with NoResourceMark\");\n+        }\n@@ -80,0 +85,17 @@\n+\n+#ifdef ASSERT\n+\n+NoResourceMark::NoResourceMark() {\n+  ResourceArea* area = Thread::current()->resource_area();\n+  area->_no_resource_mark_nesting++;\n+  assert(area->_no_resource_mark_nesting > 0, \"must stack allocate NoResourceMark\" );\n+}\n+\n+\n+NoResourceMark::~NoResourceMark() {\n+  ResourceArea* area = Thread::current()->resource_area();\n+  assert(area->_no_resource_mark_nesting > 0, \"must stack allocate NoResourceMark\" );\n+  area->_no_resource_mark_nesting--;\n+}\n+\n+#endif \/\/ ASSERT\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/memory\/resourceArea.cpp","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  friend class NoResourceMark;\n@@ -49,1 +50,2 @@\n-  int _nesting;                 \/\/ current # of nested ResourceMarks\n+  int _nesting;                  \/\/ current # of nested ResourceMarks\n+  int _no_resource_mark_nesting; \/\/ current # of nested NoResourceMarks\n@@ -55,1 +57,1 @@\n-    Arena(mem_tag, Arena::Tag::tag_ra) DEBUG_ONLY(COMMA _nesting(0)) {}\n+    Arena(mem_tag, Arena::Tag::tag_ra) DEBUG_ONLY(COMMA _nesting(0) COMMA _no_resource_mark_nesting(0)) {}\n@@ -58,1 +60,1 @@\n-    Arena(mem_tag, Arena::Tag::tag_ra, init_size) DEBUG_ONLY(COMMA _nesting(0)) {\n+    Arena(mem_tag, Arena::Tag::tag_ra, init_size) DEBUG_ONLY(COMMA _nesting(0) COMMA _no_resource_mark_nesting(0)) {\n@@ -63,0 +65,1 @@\n+  DEBUG_ONLY(void verify_no_NoResourceMark() const { assert(_no_resource_mark_nesting == 0, \"Allocating inside NoResourceMark\"); })\n@@ -179,0 +182,2 @@\n+\/\/ ResourceMark to mark that new resource area allocations are allowed\n+\/\/ Voided by the NoResourceMark stack object\n@@ -216,0 +221,15 @@\n+\/\/------------------------------------------------------------------------------------------------------------------------\n+\/\/ A NoResourceMark stack object will verify that no resource areas or new chunks are allocated\n+\/\/ in its scope. Enabled in debug mode only.\n+\n+class NoResourceMark: public StackObj {\n+ public:\n+#ifdef ASSERT\n+  NoResourceMark();\n+  ~NoResourceMark();\n+#else\n+  NoResourceMark()  {}\n+  ~NoResourceMark() {}\n+#endif\n+};\n+\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -576,1 +576,0 @@\n-\n@@ -589,0 +588,2 @@\n+  NoResourceMark rm;\n+\n","filename":"src\/hotspot\/share\/prims\/forte.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -130,0 +130,3 @@\n+#if INCLUDE_JFR && defined(ASSERT)\n+#include \"jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp\"\n+#endif\n@@ -188,0 +191,8 @@\n+WB_ENTRY(void, WB_SetCPUTimeSamplerProcessQueue(JNIEnv* env, jobject o, bool process_queue))\n+#if INCLUDE_JFR != 0 && defined(ASSERT)\n+  JfrCPUTimeThreadSampling::set_process_queue(process_queue);\n+#else\n+  warning(\"Stopping the CPU time sampler is only supported in debug builds with JFR\");\n+#endif\n+WB_END\n+\n@@ -3006,1 +3017,2 @@\n-  {CC\"rootChunkWordSize\", CC\"()J\",                    (void*)&WB_RootChunkWordSize}\n+  {CC\"rootChunkWordSize\", CC\"()J\",                    (void*)&WB_RootChunkWordSize},\n+  {CC\"setCPUTimeSamplerProcessQueue\", CC\"(Z)V\",       (void*)&WB_SetCPUTimeSamplerProcessQueue},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+class ThreadCrashProtection;\n@@ -81,0 +82,1 @@\n+\/\/     - JfrCPUTimeThreadSampler\n@@ -625,0 +627,1 @@\n+  ThreadCrashProtection* _crash_protection = nullptr;\n@@ -626,0 +629,1 @@\n+\n@@ -627,0 +631,4 @@\n+  ThreadCrashProtection* crash_protection() const { return _crash_protection; }\n+  void set_crash_protection(ThreadCrashProtection* cp) { _crash_protection = cp; }\n+\n+  \/\/ in ASGCT or the signal handler of the JfrCPUTimeSampler\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -118,0 +118,2 @@\n+  template(CPUTimeSamplerThreadInitializer)       \\\n+  template(CPUTimeSamplerThreadTerminator)        \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -239,0 +239,1 @@\n+  friend class JfrCPUTimeThreadSampler;\n","filename":"src\/hotspot\/share\/utilities\/ticks.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+import jdk.jfr.internal.settings.CPUThrottleSetting;\n@@ -322,0 +323,3 @@\n+        if (type.getName().equals(\"jdk.CPUTimeSample\")) {\n+            return new Control(new CPUThrottleSetting(type), def);\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -273,0 +273,10 @@\n+    \/**\n+     * Set the maximum event emission rate for the CPU time sampler\n+     *\n+     * Setting rate to 0 turns off the CPU time method sampler.\n+     *\n+     * @param rate the new rate in events per second\n+     * @param autoadapt true if the rate should be adapted automatically\n+     *\/\n+    public static native boolean setCPUThrottle(double rate, boolean autoadapt);\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.jfr.events.ActiveSettingEvent;\n@@ -35,0 +36,1 @@\n+import jdk.jfr.internal.util.TimespanRate;\n@@ -46,0 +48,1 @@\n+    private final boolean isCPUTimeMethodSampling;\n@@ -57,0 +60,1 @@\n+    private TimespanRate cpuRate;\n@@ -76,0 +80,1 @@\n+        this.isCPUTimeMethodSampling = isJVM && name.equals(Type.EVENT_NAME_PREFIX + \"CPUTimeSample\");\n@@ -166,0 +171,7 @@\n+    public void setCPUThrottle(TimespanRate rate) {\n+        if (isCPUTimeMethodSampling) {\n+            this.cpuRate = rate;\n+            JVM.setCPUThrottle(rate.rate(), rate.autoadapt());\n+        }\n+    }\n+\n@@ -183,2 +195,2 @@\n-        if (hasCutoff) {\n-            \/\/ Event has a duration, but not a threshold. Used by OldObjectSample\n+        if (hasCutoff || isCPUTimeMethodSampling) {\n+            \/\/ Event has a duration, but not a threshold. Used by OldObjectSample and CPUTimeSample\n@@ -226,0 +238,3 @@\n+            } else if (isCPUTimeMethodSampling) {\n+                TimespanRate r = enabled ? cpuRate : new TimespanRate(0, false);\n+                JVM.setCPUThrottle(r.rate(), r.autoadapt());\n@@ -363,0 +378,4 @@\n+    public boolean isCPUTimeMethodSampling() {\n+        return isCPUTimeMethodSampling;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformEventType.java","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -42,1 +42,2 @@\n-                missing:whitespace, missing:whitespace, missing:whitespace\n+                missing:whitespace, missing:whitespace, missing:whitespace,\n+                missing:whitespace\n@@ -403,0 +404,22 @@\n+[application.cpu-time-hot-methods]\n+label = \"Java Methods that Execute the Most from CPU Time Sampler (Experimental)\"\n+table = \"COLUMN 'Method', 'Samples', 'Percent'\n+         FORMAT none, none, normalized\n+         SELECT stackTrace.topFrame AS T, COUNT(*), COUNT(*)\n+         FROM CPUTimeSample GROUP BY T LIMIT 25\"\n+\n+[application.cpu-time-failed-samples]\n+label = \"Failed CPU Time Samples (Experimental)\"\n+table = \"COLUMN 'Failed?', 'Samples', 'Percent'\n+         FORMAT none, none, normalized\n+         SELECT failed, COUNT(*), COUNT(*)\n+         FROM CPUTimeSample\n+         GROUP BY failed\"\n+\n+[application.cpu-time-lossed-samples]\n+label = \"CPU Time Samples lossed because of internal throttling (Experimental)\"\n+table = \"COLUMN 'Lost samples'\n+         FORMAT none\n+         SELECT SUM(O.lostSamples)\n+         FROM CPUTimeSampleLoss as O\"\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/view.ini","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.settings;\n+\n+import static jdk.jfr.internal.util.TimespanUnit.SECONDS;\n+import static jdk.jfr.internal.util.TimespanUnit.MILLISECONDS;\n+\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import jdk.jfr.Description;\n+import jdk.jfr.SettingControl;\n+import jdk.jfr.Label;\n+import jdk.jfr.MetadataDefinition;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.PlatformEventType;\n+import jdk.jfr.internal.Type;\n+import jdk.jfr.internal.util.TimespanRate;\n+import jdk.jfr.internal.util.Utils;\n+\n+@MetadataDefinition\n+@Label(\"CPUThrottleSetting\")\n+@Description(\"Upper bounds the emission rate for CPU time samples\")\n+@Name(Type.SETTINGS_PREFIX + \"Rate\")\n+public final class CPUThrottleSetting extends SettingControl {\n+    public static final String DEFAULT_VALUE = \"0\/s\";\n+    private final PlatformEventType eventType;\n+    private String value = DEFAULT_VALUE;\n+\n+    public CPUThrottleSetting(PlatformEventType eventType) {\n+       this.eventType = Objects.requireNonNull(eventType);\n+    }\n+\n+    @Override\n+    public String combine(Set<String> values) {\n+        TimespanRate max = null;\n+        for (String value : values) {\n+            TimespanRate rate = TimespanRate.of(value);\n+            if (rate != null) {\n+                if (max == null || rate.isHigher(max)) {\n+                    max = rate;\n+                }\n+                max = new TimespanRate(max.rate(), max.autoadapt() || rate.autoadapt());\n+            }\n+        }\n+        \/\/ \"off\" is not supported\n+        return Objects.requireNonNullElse(max.toString(), DEFAULT_VALUE);\n+    }\n+\n+    @Override\n+    public void setValue(String value) {\n+        TimespanRate rate = TimespanRate.of(value);\n+        if (rate != null) {\n+            eventType.setCPUThrottle(rate);\n+            this.value = value;\n+        }\n+    }\n+\n+    @Override\n+    public String getValue() {\n+        return value;\n+    }\n+}\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/CPUThrottleSetting.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -58,0 +58,4 @@\n+\n+    public double perSecond() {\n+        return inNanos() * 1_000_000_000.0;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Rate.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+import jdk.jfr.internal.settings.CPUThrottleSetting;\n+\n+\/**\n+ * A rate or fixed period, see {@link jdk.jfr.internal.Rate}\n+ *\/\n+public record TimespanRate(double rate, boolean autoadapt) {\n+\n+    public static TimespanRate of(String text) {\n+        if (text.equals(\"off\")) {\n+            text = CPUThrottleSetting.DEFAULT_VALUE;\n+        }\n+        boolean isPeriod = !text.contains(\"\/\");\n+        if (isPeriod) {\n+            var period = ValueParser.parseTimespanWithInfinity(text, Long.MAX_VALUE);\n+            if (period == Long.MAX_VALUE) {\n+                return null;\n+            }\n+            if (period == 0) {\n+                return new TimespanRate(0, false);\n+            }\n+            return new TimespanRate(Runtime.getRuntime().availableProcessors() \/ (period \/ 1_000_000_000.0), false);\n+        }\n+        Rate r = Rate.of(text);\n+        if (r == null) {\n+            return null;\n+        }\n+        return new TimespanRate(r.perSecond(), true);\n+    }\n+\n+    public boolean isHigher(TimespanRate that) {\n+        return rate() > that.rate();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        if (autoadapt) {\n+            return String.format(\"%d\/ns\", (long)(rate * 1_000_000_000L));\n+        }\n+        return String.format(\"%dns\", (long)(Runtime.getRuntime().availableProcessors() \/ rate * 1_000_000_000L));\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/TimespanRate.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -193,0 +193,10 @@\n+    <event name=\"jdk.CPUTimeSample\">\n+      <setting name=\"enabled\" control=\"method-sampling-enabled\">false<\/setting>\n+      <setting name=\"throttle\">500\/s<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.CPUTimeSampleLoss\">\n+      <setting name=\"enabled\" control=\"method-sampling-enabled\">true<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -193,0 +193,10 @@\n+    <event name=\"jdk.CPUTimeSample\">\n+      <setting name=\"enabled\">false<\/setting>\n+      <setting name=\"throttle\">10ms<\/setting>\n+      <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n+    <event name=\"jdk.CPUTimeSampleLoss\">\n+      <setting name=\"enabled\">true<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -92,1 +92,4 @@\n-        \"Flush\", \"SyncOnValueBasedClass\");\n+        \"Flush\", \"SyncOnValueBasedClass\", \"CPUTimeSample\", \"CPUTimeSampleLoss\");\n+\n+    \/\/ Subset of the experimental events that should have tests\n+    private static final Set<String> experimentalButTestedEvents = Set.of(\"CPUTimeSample\");\n@@ -113,1 +116,3 @@\n-        for (String event : jfrEventTypes) {\n+        Set<String> checkedEvents = new HashSet<>(jfrEventTypes);\n+        checkedEvents.addAll(experimentalButTestedEvents);\n+        for (String event : checkedEvents) {\n","filename":"test\/jdk\/jdk\/jfr\/event\/metadata\/TestLookForUntestedEvents.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedFrame;\n+import jdk.jfr.consumer.RecordedStackTrace;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.RecurseThread;\n+\n+public class BaseTestFullStackTrace {\n+    private final static int MAX_DEPTH = 64; \/\/ currently hardcoded in jvm\n+\n+    private final String eventName;\n+    private final String threadFieldName;\n+\n+    public BaseTestFullStackTrace(String eventName, String threadFieldName) {\n+        this.eventName = eventName;\n+        this.threadFieldName = threadFieldName;\n+    }\n+\n+    public void run() throws Throwable {\n+        RecurseThread[] threads = new RecurseThread[3];\n+        for (int i = 0; i < threads.length; ++i) {\n+            int depth = MAX_DEPTH - 1 + i;\n+            threads[i] = new RecurseThread(depth);\n+            threads[i].setName(\"recursethread-\" + depth);\n+            threads[i].start();\n+        }\n+\n+        for (RecurseThread thread : threads) {\n+            while (!thread.isInRunLoop()) {\n+                Thread.sleep(20);\n+            }\n+        }\n+\n+        assertStackTraces(threads);\n+\n+        for (RecurseThread thread : threads) {\n+            thread.quit();\n+            thread.join();\n+        }\n+    }\n+\n+    private void assertStackTraces(RecurseThread[] threads) throws Throwable {\n+        while (true) {\n+            try (Recording recording = new Recording()) {\n+                if (eventName.equals(EventNames.CPUTimeSample)) {\n+                    recording.enable(eventName).with(\"throttle\", \"50ms\");\n+                } else {\n+                    recording.enable(eventName).withPeriod(Duration.ofMillis(50));\n+                }\n+                recording.start();\n+                Thread.sleep(500);\n+                recording.stop();\n+                if (hasValidStackTraces(recording, threads)) {\n+                    break;\n+                }\n+            }\n+        };\n+    }\n+\n+    private boolean hasValidStackTraces(Recording recording, RecurseThread[] threads) throws Throwable {\n+        boolean[] isEventFound = new boolean[threads.length];\n+\n+        for (RecordedEvent event : Events.fromRecording(recording)) {\n+            System.out.println(\"Event: \" + event);\n+            String threadName = Events.assertField(event, threadFieldName + \".javaName\").getValue();\n+            long threadId = Events.assertField(event, threadFieldName + \".javaThreadId\").getValue();\n+\n+            for (int threadIndex = 0; threadIndex < threads.length; ++threadIndex) {\n+                RecurseThread currThread = threads[threadIndex];\n+                if (threadId == currThread.getId()) {\n+                    System.out.println(\"ThreadName=\" + currThread.getName() + \", depth=\" + currThread.totalDepth);\n+                    Asserts.assertEquals(threadName, currThread.getName(), \"Wrong thread name\");\n+                    if (\"recurseEnd\".equals(getTopMethodName(event))) {\n+                        isEventFound[threadIndex] = true;\n+                        checkEvent(event, currThread.totalDepth);\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        for (int i = 0; i < threads.length; ++i) {\n+            String msg = \"threadIndex=%d, recurseDepth=%d, isEventFound=%b%n\";\n+            System.out.printf(msg, i, threads[i].totalDepth, isEventFound[i]);\n+        }\n+        for (int i = 0; i < threads.length; ++i) {\n+            if(!isEventFound[i]) {\n+               \/\/ no assertion, let's retry.\n+               \/\/ Could be race condition, i.e safe point during Thread.sleep\n+               System.out.println(\"Failed to validate all threads, will retry.\");\n+               return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public String getTopMethodName(RecordedEvent event) {\n+        List<RecordedFrame> frames = event.getStackTrace().getFrames();\n+        Asserts.assertFalse(frames.isEmpty(), \"JavaFrames was empty\");\n+        return frames.getFirst().getMethod().getName();\n+    }\n+\n+    private void checkEvent(RecordedEvent event, int expectedDepth) throws Throwable {\n+        RecordedStackTrace stacktrace = null;\n+        try {\n+            stacktrace = event.getStackTrace();\n+            List<RecordedFrame> frames = stacktrace.getFrames();\n+            Asserts.assertEquals(Math.min(MAX_DEPTH, expectedDepth), frames.size(), \"Wrong stacktrace depth. Expected:\" + expectedDepth);\n+            List<String> expectedMethods = getExpectedMethods(expectedDepth);\n+            Asserts.assertEquals(expectedMethods.size(), frames.size(), \"Wrong expectedMethods depth. Test error.\");\n+\n+            for (int i = 0; i < frames.size(); ++i) {\n+                String name = frames.get(i).getMethod().getName();\n+                String expectedName = expectedMethods.get(i);\n+                System.out.printf(\"method[%d]=%s, expected=%s%n\", i, name, expectedName);\n+                Asserts.assertEquals(name, expectedName, \"Wrong method name\");\n+            }\n+\n+            boolean isTruncated = stacktrace.isTruncated();\n+            boolean isTruncateExpected = expectedDepth > MAX_DEPTH;\n+            Asserts.assertEquals(isTruncated, isTruncateExpected, \"Wrong value for isTruncated. Expected:\" + isTruncateExpected);\n+\n+            String firstMethod = frames.getLast().getMethod().getName();\n+            boolean isFullTrace = \"run\".equals(firstMethod);\n+            String msg = String.format(\"Wrong values for isTruncated=%b, isFullTrace=%b\", isTruncated, isFullTrace);\n+            Asserts.assertTrue(isTruncated != isFullTrace, msg);\n+        } catch (Throwable t) {\n+            System.out.println(String.format(\"stacktrace:%n%s\", stacktrace));\n+            throw t;\n+        }\n+    }\n+\n+    private List<String> getExpectedMethods(int depth) {\n+        List<String> methods = new ArrayList<>();\n+        methods.add(\"recurseEnd\");\n+        for (int i = 0; i < depth - 2; ++i) {\n+            methods.add((i % 2) == 0 ? \"recurseA\" : \"recurseB\");\n+        }\n+        methods.add(\"run\");\n+        if (depth > MAX_DEPTH) {\n+            methods = methods.subList(0, MAX_DEPTH);\n+        }\n+        return methods;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/BaseTestFullStackTrace.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.RecurseThread;\n+\n+\/*\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @run main\/timeout=30 jdk.jfr.event.profiling.TestCPUTimeAndExecutionSample\n+ *\/\n+public class TestCPUTimeAndExecutionSample {\n+\n+    static String sampleEvent = EventNames.CPUTimeSample;\n+\n+    \/\/ The period is set to 1100 ms to provoke the 1000 ms\n+    \/\/ threshold in the JVM for os::naked_short_sleep().\n+    public static void main(String[] args) throws Exception {\n+        run(EventNames.ExecutionSample);\n+        run(EventNames.CPUTimeSample);\n+        run(EventNames.ExecutionSample);\n+        run(EventNames.CPUTimeSample);\n+    }\n+\n+    private static void run(String eventType) {\n+        RecurseThread t = new RecurseThread(50);\n+        t.setDaemon(true);\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(sampleEvent).with(\"throttle\", \"1000\/s\");\n+            rs.onEvent(sampleEvent, e -> {\n+                t.quit();\n+                rs.close();\n+            });\n+            t.start();\n+            rs.start();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeAndExecutionSample.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+import java.util.List;\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.MethodHandle;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.classloader.ClassUnloadCommon;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.RecurseThread;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\" & vm.debug\n+ * @library \/test\/lib\n+ * @library classes\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @build test.RecursiveMethods\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -XX:ErrorFile=\/tmp\/bla.log -Xbootclasspath\/a:.\n+ *    --enable-native-access=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *    jdk.jfr.event.profiling.TestCPUTimeClassUnloading\n+ *\/\n+public class TestCPUTimeClassUnloading {\n+\n+    private static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    \/\/ The period is set to 1100 ms to provoke the 1000 ms\n+    \/\/ threshold in the JVM for os::naked_short_sleep().\n+    public static void main(String[] args) throws Exception {\n+\n+        try(Recording recording = new Recording()) {\n+            recording.enable(EventNames.CPUTimeSample)\n+                    .with(\"throttle\", \"1us\");\n+            recording.start();\n+\n+            Thread.sleep(100);\n+\n+            loadAndUnload();\n+            \/\/ stop processing the queue\n+            wb.setCPUTimeSamplerProcessQueue(false);\n+            \/\/ load a class, then call a method on it for a second\n+            \/\/ then unload the class, this should create methods and\n+            \/\/ classes in the queue that are not present any more\n+            loadAndUnload();\n+            \/\/ resume processing the queue\n+            wb.setCPUTimeSamplerProcessQueue(true);\n+            Thread.sleep(1000);\n+\n+            recording.stop();\n+\n+            long count = Events.fromRecording(recording).stream()\n+                    .filter(e -> e.getEventType().getName().equals(EventNames.CPUTimeSample))\n+                    .count();\n+            if (count < 10) {\n+                throw new AssertionError(\"Not enough events\");\n+            }\n+        }\n+    }\n+\n+    private static void loadAndUnload() throws Exception {\n+        ClassLoader cl = ClassUnloadCommon.newClassLoader();\n+        Class<?> c = cl.loadClass(\"test.RecursiveMethods\");\n+        var entryMethod = c.getMethod(\"entry\", int.class);\n+        \/\/ call entry method for 1s\n+        long start = System.currentTimeMillis();\n+        while (start + 1000 < System.currentTimeMillis()) {\n+            entryMethod.invoke(null, 100);\n+        }\n+        ClassUnloadCommon.triggerUnloading(List.of(\"test.RecursiveMethods\"));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeClassUnloading.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/**\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @build jdk.jfr.event.profiling.BaseTestFullStackTrace\n+ * @run main\/othervm jdk.jfr.event.profiling.TestCPUTimeSampleFullStackTrace\n+ *\/\n+public class TestCPUTimeSampleFullStackTrace {\n+\n+    public static void main(String[] args) throws Throwable {\n+        new BaseTestFullStackTrace(EventNames.CPUTimeSample, \"eventThread\").run();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleFullStackTrace.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.internal.JVM;\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/*\n+ * Tests that creating multiple recordings after another is possible.\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @run main jdk.jfr.event.profiling.TestCPUTimeSampleMultipleRecordings\n+ *\/\n+public class TestCPUTimeSampleMultipleRecordings {\n+\n+    static String nativeEvent = EventNames.CPUTimeSample;\n+\n+    static volatile boolean alive = true;\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread t = new Thread(TestCPUTimeSampleMultipleRecordings::nativeMethod);\n+        t.setDaemon(true);\n+        t.start();\n+        for (int i = 0; i < 2; i++) {\n+            try (RecordingStream rs = new RecordingStream()) {\n+                rs.enable(nativeEvent).with(\"throttle\", \"1ms\");\n+                rs.onEvent(nativeEvent, e -> {\n+                    alive = false;\n+                    rs.close();\n+                });\n+\n+                rs.start();\n+            }\n+        }\n+        alive = false;\n+    }\n+\n+    public static void nativeMethod() {\n+        while (alive) {\n+            JVM.getPid();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleMultipleRecordings.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.internal.JVM;\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/*\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @run main jdk.jfr.event.profiling.TestCPUTimeSampleNative\n+ *\/\n+public class TestCPUTimeSampleNative {\n+\n+    static String nativeEvent = EventNames.CPUTimeSample;\n+\n+    static volatile boolean alive = true;\n+\n+    public static void main(String[] args) throws Exception {\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(nativeEvent).with(\"throttle\", \"1ms\");\n+            rs.onEvent(nativeEvent, e -> {\n+                alive = false;\n+                rs.close();\n+            });\n+            Thread t = new Thread(TestCPUTimeSampleNative::nativeMethod);\n+            t.setDaemon(true);\n+            t.start();\n+            rs.start();\n+        }\n+\n+    }\n+\n+    public static void nativeMethod() {\n+        while (alive) {\n+            JVM.getPid();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleNative.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+import java.lang.management.ManagementFactory;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Comparator;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.event.profiling.TestCPUTimeSampleThrottling\n+ *\/\n+public class TestCPUTimeSampleThrottling {\n+\n+    public static void main(String[] args) throws Exception {\n+        testZeroPerSecond();\n+        testThrottleSettings();\n+        testThrottleSettingsPeriod();\n+    }\n+\n+    private static void testZeroPerSecond() throws Exception {\n+        Asserts.assertTrue(0L == countEvents(1000, \"0\/s\").count());\n+    }\n+\n+    private static void testThrottleSettings() throws Exception {\n+        long count = countEvents(1000,\n+            Runtime.getRuntime().availableProcessors() * 2 + \"\/s\").count();\n+        Asserts.assertTrue(count > 0 && count < 3,\n+            \"Expected between 0 and 3 events, got \" + count);\n+    }\n+\n+    private static void testThrottleSettingsPeriod() throws Exception {\n+        float rate = countEvents(1000, \"10ms\").rate();\n+        Asserts.assertTrue(rate > 90 && rate < 110, \"Expected around 100 events per second, got \" + rate);\n+    }\n+\n+    private record EventCount(long count, float time) {\n+        float rate() {\n+            return count \/ time;\n+        }\n+    }\n+\n+    private static EventCount countEvents(int timeMs, String rate) throws Exception {\n+        try(Recording recording = new Recording()) {\n+            recording.enable(EventNames.CPUTimeSample)\n+                    .with(\"throttle\", rate);\n+\n+            var bean = ManagementFactory.getThreadMXBean();\n+\n+            recording.start();\n+\n+            long startThreadCpuTime = bean.getCurrentThreadCpuTime();\n+\n+            wasteCPU(timeMs);\n+\n+            long spendCPUTime = bean.getCurrentThreadCpuTime() - startThreadCpuTime;\n+\n+            recording.stop();\n+\n+            long eventCount = Events.fromRecording(recording).stream()\n+                    .filter(e -> e.getThread().getJavaName()\n+                                .equals(Thread.currentThread().getName()))\n+                    .count();\n+\n+            System.out.println(\"Event count: \" + eventCount + \", CPU time: \" + spendCPUTime \/ 1_000_000_000f + \"s\");\n+\n+            return new EventCount(eventCount, spendCPUTime \/ 1_000_000_000f);\n+        }\n+    }\n+\n+    private static void wasteCPU(int durationMs) {\n+        long start = System.currentTimeMillis();\n+        double i = 0;\n+        while (System.currentTimeMillis() - start < durationMs) {\n+            for (int j = 0; j < 100000; j++) {\n+                i = Math.sqrt(i * Math.pow(Math.sqrt(Math.random()), Math.random()));\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSampleThrottling.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.RecurseThread;\n+\n+\/*\n+ * @test\n+ * @requires vm.hasJFR & os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @run main jdk.jfr.event.profiling.TestCPUTimeSamplingLongPeriod\n+ *\/\n+public class TestCPUTimeSamplingLongPeriod {\n+\n+    static String sampleEvent = EventNames.CPUTimeSample;\n+\n+    \/\/ The period is set to 1100 ms to provoke the 1000 ms\n+    \/\/ threshold in the JVM for os::naked_short_sleep().\n+    public static void main(String[] args) throws Exception {\n+        RecurseThread t = new RecurseThread(50);\n+        t.setDaemon(true);\n+        try (RecordingStream rs = new RecordingStream()) {\n+            rs.enable(sampleEvent).with(\"throttle\", \"1100ms\");\n+            rs.onEvent(sampleEvent, e -> {\n+                t.quit();\n+                rs.close();\n+            });\n+            t.start();\n+            rs.start();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeSamplingLongPeriod.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -26,9 +26,0 @@\n-import java.time.Duration;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.RecordedEvent;\n-import jdk.jfr.consumer.RecordedFrame;\n-import jdk.jfr.consumer.RecordedStackTrace;\n-import jdk.test.lib.Asserts;\n@@ -36,2 +27,0 @@\n-import jdk.test.lib.jfr.Events;\n-import jdk.test.lib.jfr.RecurseThread;\n@@ -43,0 +32,1 @@\n+ * @build jdk.jfr.event.profiling.BaseTestFullStackTrace\n@@ -46,2 +36,0 @@\n-    private final static String EVENT_NAME = EventNames.ExecutionSample;\n-    private final static int MAX_DEPTH = 64; \/\/ currently hardcoded in jvm\n@@ -50,31 +38,1 @@\n-        RecurseThread[] threads = new RecurseThread[3];\n-        for (int i = 0; i < threads.length; ++i) {\n-            int depth = MAX_DEPTH - 1 + i;\n-            threads[i] = new RecurseThread(depth);\n-            threads[i].setName(\"recursethread-\" + depth);\n-            threads[i].start();\n-        }\n-\n-        for (RecurseThread thread : threads) {\n-            while (!thread.isInRunLoop()) {\n-                Thread.sleep(20);\n-            }\n-        }\n-\n-        assertStackTraces(threads);\n-\n-        for (RecurseThread thread : threads) {\n-            thread.quit();\n-            thread.join();\n-        }\n-    }\n-\n-    private static void assertStackTraces( RecurseThread[] threads) throws Throwable {\n-        Recording recording= null;\n-        do {\n-            recording = new Recording();\n-            recording.enable(EVENT_NAME).withPeriod(Duration.ofMillis(50));\n-            recording.start();\n-            Thread.sleep(500);\n-            recording.stop();\n-        } while (!hasValidStackTraces(recording, threads));\n+        new BaseTestFullStackTrace(EventNames.ExecutionSample, \"sampledThread\").run();\n@@ -83,85 +41,0 @@\n-    private static boolean hasValidStackTraces(Recording recording, RecurseThread[] threads) throws Throwable {\n-        boolean[] isEventFound = new boolean[threads.length];\n-\n-        for (RecordedEvent event : Events.fromRecording(recording)) {\n-            \/\/System.out.println(\"Event: \" + event);\n-            String threadName = Events.assertField(event, \"sampledThread.javaName\").getValue();\n-            long threadId = Events.assertField(event, \"sampledThread.javaThreadId\").getValue();\n-\n-            for (int threadIndex = 0; threadIndex < threads.length; ++threadIndex) {\n-                RecurseThread currThread = threads[threadIndex];\n-                if (threadId == currThread.getId()) {\n-                    System.out.println(\"ThreadName=\" + currThread.getName() + \", depth=\" + currThread.totalDepth);\n-                    Asserts.assertEquals(threadName, currThread.getName(), \"Wrong thread name\");\n-                    if (\"recurseEnd\".equals(getTopMethodName(event))) {\n-                        isEventFound[threadIndex] = true;\n-                        checkEvent(event, currThread.totalDepth);\n-                        break;\n-                    }\n-                }\n-            }\n-        }\n-\n-        for (int i = 0; i < threads.length; ++i) {\n-            String msg = \"threadIndex=%d, recurseDepth=%d, isEventFound=%b%n\";\n-            System.out.printf(msg, i, threads[i].totalDepth, isEventFound[i]);\n-        }\n-        for (int i = 0; i < threads.length; ++i) {\n-            if(!isEventFound[i]) {\n-               \/\/ no assertion, let's retry.\n-               \/\/ Could be race condition, i.e safe point during Thread.sleep\n-               System.out.println(\"Failed to validate all threads, will retry.\");\n-               return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    public static String getTopMethodName(RecordedEvent event) {\n-        List<RecordedFrame> frames = event.getStackTrace().getFrames();\n-        Asserts.assertFalse(frames.isEmpty(), \"JavaFrames was empty\");\n-        return frames.getFirst().getMethod().getName();\n-    }\n-\n-    private static void checkEvent(RecordedEvent event, int expectedDepth) throws Throwable {\n-        RecordedStackTrace stacktrace = null;\n-        try {\n-            stacktrace = event.getStackTrace();\n-            List<RecordedFrame> frames = stacktrace.getFrames();\n-            Asserts.assertEquals(Math.min(MAX_DEPTH, expectedDepth), frames.size(), \"Wrong stacktrace depth. Expected:\" + expectedDepth);\n-            List<String> expectedMethods = getExpectedMethods(expectedDepth);\n-            Asserts.assertEquals(expectedMethods.size(), frames.size(), \"Wrong expectedMethods depth. Test error.\");\n-\n-            for (int i = 0; i < frames.size(); ++i) {\n-                String name = frames.get(i).getMethod().getName();\n-                String expectedName = expectedMethods.get(i);\n-                System.out.printf(\"method[%d]=%s, expected=%s%n\", i, name, expectedName);\n-                Asserts.assertEquals(name, expectedName, \"Wrong method name\");\n-            }\n-\n-            boolean isTruncated = stacktrace.isTruncated();\n-            boolean isTruncateExpected = expectedDepth > MAX_DEPTH;\n-            Asserts.assertEquals(isTruncated, isTruncateExpected, \"Wrong value for isTruncated. Expected:\" + isTruncateExpected);\n-\n-            String firstMethod = frames.getLast().getMethod().getName();\n-            boolean isFullTrace = \"run\".equals(firstMethod);\n-            String msg = String.format(\"Wrong values for isTruncated=%b, isFullTrace=%b\", isTruncated, isFullTrace);\n-            Asserts.assertTrue(isTruncated != isFullTrace, msg);\n-        } catch (Throwable t) {\n-            System.out.println(String.format(\"stacktrace:%n%s\", stacktrace));\n-            throw t;\n-        }\n-    }\n-\n-    private static List<String> getExpectedMethods(int depth) {\n-        List<String> methods = new ArrayList<>();\n-        methods.add(\"recurseEnd\");\n-        for (int i = 0; i < depth - 2; ++i) {\n-            methods.add((i % 2) == 0 ? \"recurseA\" : \"recurseB\");\n-        }\n-        methods.add(\"run\");\n-        if (depth > MAX_DEPTH) {\n-            methods = methods.subList(0, MAX_DEPTH);\n-        }\n-        return methods;\n-    }\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestFullStackTrace.java","additions":2,"deletions":129,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    final static String SAMPLE_EVENT = EventNames.ExecutionSample;\n+    static String sampleEvent = EventNames.ExecutionSample;\n@@ -50,2 +50,2 @@\n-            rs.enable(SAMPLE_EVENT).withPeriod(Duration.ofMillis(1100));\n-            rs.onEvent(SAMPLE_EVENT, e -> {\n+            rs.enable(sampleEvent).withPeriod(Duration.ofMillis(1100));\n+            rs.onEvent(sampleEvent, e -> {\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestSamplingLongPeriod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ package test;\n+\n+ import java.time.Duration;\n+\n+ \/*\n+  * A class used to create a simple deep call stack for testing purposes\n+  *\/\n+ public class RecursiveMethods {\n+\n+    \/** Method that uses recursion to produce a call stack of at least {@code depth} depth *\/\n+    public static int entry(int depth) {\n+        return method2(--depth);\n+    }\n+\n+    private static int method2(int depth) {\n+        return method3(--depth);\n+    }\n+\n+    private static int method3(int depth) {\n+        return method4(--depth);\n+    }\n+\n+    private static int method4(int depth) {\n+        return method5(--depth);\n+    }\n+\n+    private static int method5(int depth) {\n+        return method6(--depth);\n+    }\n+\n+    private static int method6(int depth) {\n+        return method7(--depth);\n+    }\n+\n+    private static int method7(int depth) {\n+        return method8(--depth);\n+    }\n+\n+    private static int method8(int depth) {\n+        return method9(--depth);\n+    }\n+\n+    private static int method9(int depth) {\n+        return method10(--depth);\n+    }\n+\n+    private static int method10(int depth) {\n+        if (depth > 0) {\n+            return entry(--depth);\n+        }\n+        return depth;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/classes\/test\/RecursiveMethods.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -77,0 +77,2 @@\n+    public static final String CPUTimeSample = PREFIX + \"CPUTimeSample\";\n+    public static final String CPUTimeSampleLoss = PREFIX + \"CPUTimeSampleLoss\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -801,0 +801,4 @@\n+\n+  \/\/ enable and disable CPU time sampler queue processing\n+  \/\/ only works with debug builds\n+  public native void setCPUTimeSamplerProcessQueue(boolean processQueue);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}