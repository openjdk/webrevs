{"files":[{"patch":"@@ -214,2 +214,17 @@\n-\/\/ Fixed size array-based MPMC queue for storing traces.\n-\/\/ Does not own any frames\n+\/\/ Fixed size async-signal-safe MPMC queue backed by an array.\n+\/\/ Serves for passing traces from a thread being sampled (producer)\n+\/\/ to a thread emitting JFR events (consumer).\n+\/\/ Does not own any frames.\n+\/\/\n+\/\/ _head and _tail of the queue are virtual (always increasing) positions modulo 2^32.\n+\/\/ Actual index into the backing array is computed as (position % _capacity).\n+\/\/ Generation G of an element at position P is the number of full wraps around the array:\n+\/\/   G = P \/ _capacity\n+\/\/ Generation allows to disambiguate situations when _head and _tail point to the same element.\n+\/\/\n+\/\/ Each element of the array is assigned a state, which encodes full\/empty flag in bit 31\n+\/\/ and the generation G of the element in bits 0..30:\n+\/\/   state (0,G): the element is empty and avaialble for enqueue() in generation G,\n+\/\/   state (1,G): the element is full and available for dequeue() in generation G.\n+\/\/ Possible transitions are:\n+\/\/   (0,G) --enqueue--> (1,G) --dequeue--> (0,G+1)\n@@ -219,2 +234,3 @@\n-    \/\/ Encodes generation of the element (to solve ABA problem)\n-    \/\/ along with full\/empty flag in the highest bit\n+    \/\/ Encodes full\/empty flag along with generation of the element.\n+    \/\/ Also, establishes happens-before relationship between producer and consumer.\n+    \/\/ Update of this field \"commits\" enqueue\/dequeue transaction.\n@@ -237,2 +253,2 @@\n-  inline Element* element(u4 index) {\n-    return &_data[index % _capacity];\n+  inline Element* element(u4 position) {\n+    return &_data[position % _capacity];\n@@ -241,2 +257,2 @@\n-  inline u4 state_empty(u4 index) {\n-    return (index \/ _capacity) & 0x7fffffff;\n+  inline u4 state_empty(u4 position) {\n+    return (position \/ _capacity) & 0x7fffffff;\n@@ -245,2 +261,2 @@\n-  inline u4 state_full(u4 index) {\n-    return (index \/ _capacity) | 0x80000000;\n+  inline u4 state_full(u4 position) {\n+    return (position \/ _capacity) | 0x80000000;\n@@ -267,0 +283,1 @@\n+            \/\/ Mark element as full in current generation\n@@ -270,1 +287,3 @@\n-      } else if (state != state_full(tail)) {\n+      } else if (state == state_full(tail)) {\n+        \/\/ Another thread has just filled the same position; retry operation\n+      } else {\n@@ -284,0 +303,2 @@\n+            \/\/ After taking an element, mark it as empty in the next generation,\n+            \/\/ so we can reuse it again after completing the full circle\n@@ -288,1 +309,3 @@\n-        return nullptr;\n+        return nullptr; \/\/ Queue is empty\n+      } else {\n+        \/\/ Producer has not yet completed transaction\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"}]}