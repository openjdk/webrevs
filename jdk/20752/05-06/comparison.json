{"files":[{"patch":"@@ -57,19 +57,2 @@\n-  switch(thread->thread_state()) {\n-    case _thread_new:\n-    case _thread_uninitialized:\n-    case _thread_new_trans:\n-    case _thread_in_vm_trans:\n-    case _thread_blocked_trans:\n-    case _thread_in_native_trans:\n-    case _thread_blocked:\n-    case _thread_in_vm:\n-    case _thread_in_native:\n-      break;\n-    case _thread_in_Java_trans:\n-    case _thread_in_Java:\n-      return true;\n-    default:\n-      ShouldNotReachHere();\n-      break;\n-  }\n-  return false;\n+  JavaThreadState state = thread->thread_state();\n+  return state == _thread_in_Java || state == _thread_in_Java_trans;\n@@ -78,1 +61,1 @@\n-static bool thread_state_in_native(JavaThread* thread) {\n+static bool thread_state_in_non_java(JavaThread* thread) {\n@@ -184,1 +167,1 @@\n-      } else if (thread_state_in_native(jt)) {\n+      } else if (thread_state_in_non_java(jt)) {\n@@ -384,0 +367,5 @@\n+  \/\/ This is required for testing purposes\n+  \/\/ To ensure that the sampler works even when the worker\n+  \/\/ thread is stopped for a while, with unloaded methods\n+  \/\/ in the queue\n+  volatile bool _process_queue = true;\n@@ -558,1 +546,1 @@\n-  while ((trace = _queues.filled().dequeue()) != nullptr) {\n+  while (Atomic::load(&_process_queue) && (trace = _queues.filled().dequeue()) != nullptr) {\n@@ -850,3 +838,3 @@\n-NonJavaThread* JfrCPUTimeThreadSampling::get_worker_thread_or_null() {\n-  if (_instance != nullptr) {\n-    return _instance->_sampler->_sampler_thread;\n+void JfrCPUTimeThreadSampling::set_process_queue(bool process_queue) {\n+  if (_instance != nullptr && _instance->_sampler != nullptr) {\n+    Atomic::store(&_instance->_sampler->_process_queue, process_queue);\n@@ -854,1 +842,0 @@\n-  return nullptr;\n@@ -896,3 +883,1 @@\n-NonJavaThread* JfrCPUTimeThreadSampling::get_worker_thread_or_null() {\n-  return nullptr;\n-}\n+void JfrCPUTimeThreadSampling::set_process_queue(bool process_queue) {}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":14,"deletions":29,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  static NonJavaThread* get_worker_thread_or_null();\n+  static void set_process_queue(bool process_queue);\n@@ -84,1 +84,1 @@\n-  static NonJavaThread* get_worker_thread_or_null();\n+  static void set_process_queue(bool process_queue);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-WB_ENTRY(jint, WB_GetCPUTimeSampleWorkerThreadId(JNIEnv* env, jobject o))\n+WB_ENTRY(void, WB_SetCPUTimeSamplerProcessQueue(JNIEnv* env, jobject o, bool process_queue))\n@@ -195,4 +195,1 @@\n-  NonJavaThread *worker = JfrCPUTimeThreadSampling::get_worker_thread_or_null();\n-  if (worker != nullptr) {\n-    return worker->osthread()->thread_id();\n-  }\n+  JfrCPUTimeThreadSampling::set_process_queue(process_queue);\n@@ -200,1 +197,0 @@\n-  return 0;\n@@ -2985,1 +2981,1 @@\n-  {CC\"getCPUTimeSampleWorkerThreadId\", CC\"()I\",       (void*)&WB_GetCPUTimeSampleWorkerThreadId},\n+  {CC\"setCPUTimeSamplerProcessQueue\", CC\"(Z)V\",       (void*)&WB_SetCPUTimeSamplerProcessQueue},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.profiling;\n+\n+import java.time.Duration;\n+import java.util.List;\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.MethodHandle;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.classloader.ClassUnloadCommon;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.RecurseThread;\n+import jdk.test.whitebox.WhiteBox;\n+\n+\/*\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR & os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @library classes\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @build test.RecursiveMethods\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -XX:ErrorFile=\/tmp\/bla.log -Xbootclasspath\/a:.\n+ *    --enable-native-access=ALL-UNNAMED -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *    jdk.jfr.event.profiling.TestCPUTimeClassUnloading\n+ *\/\n+public class TestCPUTimeClassUnloading {\n+\n+    private static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    \/\/ The period is set to 1100 ms to provoke the 1000 ms\n+    \/\/ threshold in the JVM for os::naked_short_sleep().\n+    public static void main(String[] args) throws Exception {\n+\n+        try(Recording recording = new Recording()) {\n+            recording.enable(EventNames.CPUTimeSample)\n+                    .with(\"throttle\", \"1us\");\n+            recording.start();\n+\n+            Thread.sleep(100);\n+\n+            loadAndUnload();\n+            \/\/ stop processing the queue\n+            wb.setCPUTimeSamplerProcessQueue(false);\n+            \/\/ load a class, then call a method on it for a second\n+            \/\/ then unload the class, this should create methods and\n+            \/\/ classes in the queue that are not present any more\n+            loadAndUnload();\n+            \/\/ resume processing the queue\n+            wb.setCPUTimeSamplerProcessQueue(true);\n+            Thread.sleep(1000);\n+\n+            recording.stop();\n+\n+            long count = Events.fromRecording(recording).stream()\n+                    .filter(e -> e.getEventType().getName().equals(EventNames.CPUTimeSample))\n+                    .count();\n+            if (count < 10) {\n+                throw new AssertionError(\"Not enough events\");\n+            }\n+        }\n+    }\n+\n+    private static void loadAndUnload() throws Exception {\n+        ClassLoader cl = ClassUnloadCommon.newClassLoader();\n+        Class<?> c = cl.loadClass(\"test.RecursiveMethods\");\n+        var entryMethod = c.getMethod(\"entry\", int.class);\n+        \/\/ call entry method for 1s\n+        long start = System.currentTimeMillis();\n+        while (start + 1000 < System.currentTimeMillis()) {\n+            entryMethod.invoke(null, 100);\n+        }\n+        ClassUnloadCommon.triggerUnloading(List.of(\"test.RecursiveMethods\"));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/TestCPUTimeClassUnloading.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2024, SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ package test;\n+\n+ import java.time.Duration;\n+\n+ \/*\n+  * A class used to create a simple deep call stack for testing purposes\n+  *\/\n+ public class RecursiveMethods {\n+\n+    \/** Method that uses recursion to produce a call stack of at least {@code depth} depth *\/\n+    public static int entry(int depth) {\n+        return method2(--depth);\n+    }\n+\n+    private static int method2(int depth) {\n+        return method3(--depth);\n+    }\n+\n+    private static int method3(int depth) {\n+        return method4(--depth);\n+    }\n+\n+    private static int method4(int depth) {\n+        return method5(--depth);\n+    }\n+\n+    private static int method5(int depth) {\n+        return method6(--depth);\n+    }\n+\n+    private static int method6(int depth) {\n+        return method7(--depth);\n+    }\n+\n+    private static int method7(int depth) {\n+        return method8(--depth);\n+    }\n+\n+    private static int method8(int depth) {\n+        return method9(--depth);\n+    }\n+\n+    private static int method9(int depth) {\n+        return method10(--depth);\n+    }\n+\n+    private static int method10(int depth) {\n+        if (depth > 0) {\n+            return entry(--depth);\n+        }\n+        return depth;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/event\/profiling\/classes\/test\/RecursiveMethods.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -810,2 +810,2 @@\n-  \/\/ OS id of the CPU time sampler working thread\n-  public native int getCPUTimeSampleWorkerThreadId();\n+  \/\/ enable and disable CPU time sampler queue processing\n+  public native void setCPUTimeSamplerProcessQueue(boolean processQueue);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}