{"files":[{"patch":"@@ -48,1 +48,0 @@\n-#include <sys\/utsname.h>\n@@ -370,6 +369,0 @@\n-static const int64_t MINIMAL_PERIOD_NOT_FOUND = -1;\n-static const int64_t MINIMAL_PERIOD_NOT_SET = -2;\n-\n-static int64_t _minimal_period = MINIMAL_PERIOD_NOT_SET;\n-\n-static int64_t get_minimal_period();\n@@ -430,1 +423,1 @@\n-  void handle_timer_signal(void* context);\n+  void handle_timer_signal(siginfo_t* info, void* context);\n@@ -732,1 +725,1 @@\n-  _instance->handle_timer_signal(context);\n+  _instance->handle_timer_signal(info, context);\n@@ -736,1 +729,1 @@\n-void JfrCPUTimeThreadSampling::handle_timer_signal(void* context) {\n+void JfrCPUTimeThreadSampling::handle_timer_signal(siginfo_t* info, void* context) {\n@@ -742,1 +735,1 @@\n-  _sampler->handle_timer_signal(context);\n+  _sampler->handle_timer_signal(info, context);\n@@ -746,1 +739,1 @@\n-void JfrCPUTimeThreadSampler::handle_timer_signal(void* context) {\n+void JfrCPUTimeThreadSampler::handle_timer_signal(siginfo_t* info, void* context) {\n@@ -753,1 +746,4 @@\n-    trace->record_trace(jt, context, get_sampling_period());\n+    \/\/ the sampling period might be too low for the current Linux configuration\n+    \/\/ so samples might be skipped and we have to compute the actual period\n+    int64_t period = get_sampling_period() * (info->si_overrun + 1);\n+    trace->record_trace(jt, context, period);\n@@ -857,49 +853,0 @@\n-\/\/ obtain the maximum frequency of CPU time events\n-static int64_t obtain_kernel_frequency() {\n-  const int BUFFER_SIZE = 256;\n-  struct utsname uname_data;\n-  char filename[BUFFER_SIZE];\n-  char buffer[BUFFER_SIZE];\n-  char config_hz_prefix[] = \"CONFIG_HZ=\";\n-  FILE *file;\n-\n-  \/\/ Get kernel version using uname\n-  if (uname(&uname_data) != 0) {\n-    return -1;\n-  }\n-\n-  \/\/ Construct the filename: \/boot\/config-<kernel_version>\n-  snprintf(filename, sizeof(filename), \"\/boot\/config-%s\", uname_data.release);\n-\n-  \/\/ Open the file\n-  file = fopen(filename, \"r\");\n-  if (!file) {\n-    return -1;\n-  }\n-\n-  \/\/ Read each line and look for the CONFIG_HZ setting\n-  while (fgets(buffer, sizeof(buffer), file)) {\n-    if (strncmp(buffer, config_hz_prefix, strlen(config_hz_prefix)) == 0) {\n-      \/\/ Extract the value after \"CONFIG_HZ=\"\n-      char *value = buffer + strlen(config_hz_prefix);\n-      int64_t hz_value = strtoll(value, NULL, 10);\n-      fclose(file);\n-      return hz_value;\n-    }\n-  }\n-  fclose(file);\n-  return -1;\n-}\n-\n-int64_t get_minimal_period() {\n-  if (_minimal_period == MINIMAL_PERIOD_NOT_SET) {\n-    int64_t hz = obtain_kernel_frequency();\n-    if (hz == 0) {\n-      _minimal_period = -1;\n-    } else if (hz != -1) {\n-      _minimal_period = 1000000000 \/ hz;\n-    }\n-  }\n-  return _minimal_period;\n-}\n-\n@@ -910,5 +857,1 @@\n-  int64_t period = os::active_processor_count() * 1000000000.0 \/ rate;\n-  if (get_minimal_period() > 0 && period < get_minimal_period()) {\n-    return get_minimal_period();\n-  }\n-  return period;\n+  return os::active_processor_count() * 1000000000.0 \/ rate;\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.cpp","additions":10,"deletions":67,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  void handle_timer_signal(void* context);\n+  void handle_timer_signal(siginfo_t* info, void* context);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrCPUTimeThreadSampler.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}