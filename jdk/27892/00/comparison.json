{"files":[{"patch":"@@ -130,1 +130,1 @@\n-    lazy_replace(uncommon_proj_orig, uncommon_trap);\n+    replace_ctrl_node_and_forward_ctrl_and_idom(uncommon_proj_orig, uncommon_trap);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4074,1 +4074,1 @@\n-    lazy_replace(outer_out, in);\n+    replace_ctrl_node_and_forward_ctrl_and_idom(outer_out, in);\n@@ -4083,1 +4083,1 @@\n-  lazy_replace(exit, result_ctrl);\n+  replace_ctrl_node_and_forward_ctrl_and_idom(exit, result_ctrl);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1712,2 +1712,2 @@\n-  lazy_replace(head, new_inner_head);\n-  lazy_replace(exit_test, new_inner_exit);\n+  replace_ctrl_node_and_forward_ctrl_and_idom(head, new_inner_head);\n+  replace_ctrl_node_and_forward_ctrl_and_idom(exit_test, new_inner_exit);\n@@ -2385,1 +2385,1 @@\n-      lazy_replace(backedge_sfpt, iftrue);\n+      replace_ctrl_node_and_forward_ctrl_and_idom(backedge_sfpt, iftrue);\n@@ -2486,2 +2486,2 @@\n-    lazy_replace(iffalse, iff2);\n-    lazy_replace(iftrue,  ift2);\n+    replace_ctrl_node_and_forward_ctrl_and_idom(iffalse, iff2);\n+    replace_ctrl_node_and_forward_ctrl_and_idom(iftrue,  ift2);\n@@ -2502,1 +2502,1 @@\n-  lazy_replace( iff, le ); \/\/ fix 'get_ctrl'\n+  replace_ctrl_node_and_forward_ctrl_and_idom(iff, le); \/\/ fix 'get_ctrl'\n@@ -2528,1 +2528,1 @@\n-  lazy_replace( x, l );\n+  replace_ctrl_node_and_forward_ctrl_and_idom(x, l);\n@@ -2554,1 +2554,1 @@\n-      lazy_replace(sfpt, sfpt->in(TypeFunc::Control));\n+      replace_ctrl_node_and_forward_ctrl_and_idom(sfpt, sfpt->in(TypeFunc::Control));\n@@ -3519,1 +3519,1 @@\n-    iloop->lazy_replace(outer_le, new_end);\n+    iloop->replace_ctrl_node_and_forward_ctrl_and_idom(outer_le, new_end);\n@@ -4490,1 +4490,1 @@\n-        phase->lazy_replace(n, n->in(TypeFunc::Control));\n+        phase->replace_ctrl_node_and_forward_ctrl_and_idom(n, n->in(TypeFunc::Control));\n@@ -6159,1 +6159,1 @@\n-            lazy_replace(n,in);       \/\/ Pull safepoint now\n+            replace_ctrl_node_and_forward_ctrl_and_idom(n, in); \/\/ Pull safepoint now\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -960,0 +960,6 @@\n+  \/\/\n+  \/\/ Exception:\n+  \/\/ control nodes that are dead because of \"replace_ctrl_node_and_forward_ctrl_and_idom\"\n+  \/\/ or have otherwise modified their ctrl state by \"install_lazy_ctrl_and_idom_forwarding\".\n+  \/\/ They return \"true\", because they have a ctrl \"forwarding\" to the other ctrl node they\n+  \/\/ were replaced with.\n@@ -1073,5 +1079,2 @@\n-  \/\/ Control nodes can be replaced or subsumed.  During this pass they\n-  \/\/ get their replacement Node in slot 1.  Instead of updating the block\n-  \/\/ location of all Nodes in the subsumed block, we lazily do it.  As we\n-  \/\/ pull such a subsumed block out of the array, we write back the final\n-  \/\/ correct block.\n+\n+  \/\/ Retreives the ctrl for a data node i.\n@@ -1079,2 +1082,6 @@\n-    assert(has_node(i), \"\");\n-    Node *n = get_ctrl_no_update(i);\n+    assert(has_node(i) && has_ctrl(i), \"must be data node with ctrl\");\n+    Node* n = get_ctrl_no_update(i);\n+    \/\/ We store the found ctrl in the side-table again. In most cases,\n+    \/\/ this is a no-op, since we just read from _loop_or_ctrl. But in cases\n+    \/\/ where there was a ctrl forwarding via dead ctrl nodes, this shortens the path.\n+    \/\/ See: install_lazy_ctrl_and_idom_forwarding\n@@ -1082,2 +1089,2 @@\n-    assert(has_node(i) && has_ctrl(i), \"\");\n-    assert(n == find_non_split_ctrl(n), \"must return legal ctrl\" );\n+    assert(has_node(i) && has_ctrl(i), \"must still be data node with ctrl\");\n+    assert(n == find_non_split_ctrl(n), \"must return legal ctrl\");\n@@ -1100,0 +1107,1 @@\n+private:\n@@ -1101,1 +1109,4 @@\n-    assert(has_ctrl(i), \"should be control, not loop\");\n+    \/\/ We expect only data nodes (which must have a ctrl set), or\n+    \/\/ dead ctrl nodes that have a ctrl \"forwarding\".\n+    \/\/ See: install_lazy_ctrl_and_idom_forwarding.\n+    assert(has_ctrl(i), \"only data nodes or ctrl nodes with ctrl forwarding expected\");\n@@ -1105,0 +1116,1 @@\n+  \/\/ Compute the ctrl of node i, jumping over ctrl forwardings.\n@@ -1106,4 +1118,8 @@\n-    assert( has_ctrl(i), \"\" );\n-    Node *n = get_ctrl_no_update_helper(i);\n-    if (!n->in(0)) {\n-      \/\/ Skip dead CFG nodes\n+    assert(has_ctrl(i), \"only data nodes expected\");\n+    Node* n = get_ctrl_no_update_helper(i);\n+    if (n->in(0) == nullptr) {\n+      \/\/ We encountered a dead CFG node.\n+      \/\/ If everything went right, this dead CFG node should have had a ctrl\n+      \/\/ forwarding installed, using \"install_lazy_ctrl_and_idom_forwarding\".\n+      \/\/ We now have to jump from the old (dead) ctrl node to the new (live)\n+      \/\/ ctrl node, in possibly multiple ctrl\/idom forwarding steps.\n@@ -1112,1 +1128,1 @@\n-      } while (!n->in(0));\n+      } while (n->in(0) == nullptr);\n@@ -1118,0 +1134,1 @@\n+public:\n@@ -1128,5 +1145,21 @@\n-  \/\/ Lazy-dazy update of 'get_ctrl' and 'idom_at' mechanisms.  Replace\n-  \/\/ the 'old_node' with 'new_node'.  Kill old-node.  Add a reference\n-  \/\/ from old_node to new_node to support the lazy update.  Reference\n-  \/\/ replaces loop reference, since that is not needed for dead node.\n-  void lazy_update(Node *old_node, Node *new_node) {\n+\n+  \/\/ Install a ctrl \"forwarding\" from an old (dead) control node.\n+  \/\/ This is a \"lazy\" update of the \"get_ctrl\" and \"idom\" mechanism:\n+  \/\/ - Install a forwarding from old_node (dead ctrl) to new_node.\n+  \/\/ - When querying \"get_ctrl\": jump from data node over possibly\n+  \/\/   multiple dead ctrl nodes with ctrl forwarding to eventually\n+  \/\/   reach a live ctrl node. Shorten the path to avoid chasing the\n+  \/\/   forwarding in the future.\n+  \/\/ - When querying \"idom\": from some node get its old idom, which\n+  \/\/   may be dead but has a ctrl forwarding to the new and live\n+  \/\/   idom. Shorten the path to avoid chasing the forwarding in the\n+  \/\/   future.\n+  \/\/ Using \"install_lazy_ctrl_and_idom_forwarding\" allows us to only edit\n+  \/\/ the entry for the old dead node now, and we do not have to update all\n+  \/\/ the nodes that had the old_node as their \"get_ctrl\" or \"idom\". We\n+  \/\/ clean up the forwarding links when we query \"get_ctrl\" or \"idom\".\n+  void install_lazy_ctrl_and_idom_forwarding(Node* old_node, Node* new_node) {\n+    assert(!has_ctrl(old_node), \"must be ctrl node\");\n+    assert(!has_ctrl(new_node), \"must be ctrl node\");\n+    assert(old_node->in(0) == nullptr, \"old node must be dead\");\n+    assert(new_node->in(0) != nullptr, \"new node must be live\");\n@@ -1137,0 +1170,1 @@\n+    assert(has_ctrl(old_node), \"must have installed ctrl forwarding\");\n@@ -1138,1 +1172,5 @@\n-  void lazy_replace(Node *old_node, Node *new_node) {\n+\n+  \/\/ Replace the old ctrl node with a new ctrl node.\n+  \/\/ - Update the node inputs of all uses.\n+  \/\/ - Lazily update the ctrl and idom info of all uses, via a ctrl\/idom forwarding.\n+  void replace_ctrl_node_and_forward_ctrl_and_idom(Node *old_node, Node *new_node) {\n@@ -1140,1 +1178,1 @@\n-    lazy_update(old_node, new_node);\n+    install_lazy_ctrl_and_idom_forwarding(old_node, new_node);\n@@ -1211,1 +1249,0 @@\n-public:\n@@ -1221,0 +1258,5 @@\n+      \/\/ We encountered a dead CFG node.\n+      \/\/ If everything went right, this dead CFG node should have had a idom\/ctrl\n+      \/\/ forwarding installed, using \"install_lazy_ctrl_and_idom_forwarding\".\n+      \/\/ We now have to jump from the old (dead) ctrl node to the new (live)\n+      \/\/ ctrl\/idom node, in possibly multiple ctrl\/idom forwarding steps.\n@@ -1227,1 +1269,2 @@\n-  Node *idom(Node* d) const {\n+public:\n+  Node* idom(Node* d) const {\n@@ -1231,3 +1274,7 @@\n-  Node *idom(uint didx) const {\n-    Node *n = idom_no_update(didx);\n-    _idom[didx] = n; \/\/ Lazily remove dead CFG nodes from table.\n+  Node* idom(uint didx) const {\n+    Node* n = idom_no_update(didx);\n+    \/\/ We store the found idom in the side-table again. In most cases,\n+    \/\/ this is a no-op, since we just read from _idom. But in cases where\n+    \/\/ there was a ctrl forwarding via dead ctrl nodes, this shortens the path.\n+    \/\/ See: install_lazy_ctrl_and_idom_forwarding\n+    _idom[didx] = n;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":74,"deletions":27,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2745,1 +2745,1 @@\n-        \/\/ lazy_replace() below moves all nodes that are:\n+        \/\/ replace_ctrl_node_and_forward_ctrl_and_idom() below moves all nodes that are:\n@@ -2748,3 +2748,4 @@\n-        \/\/ below the post-loop merge point. lazy_replace() takes a dead control as first input. To make it\n-        \/\/ possible to use it, the loop exit projection is cloned and becomes the new exit projection. The initial one\n-        \/\/ becomes dead and is \"replaced\" by the region.\n+        \/\/ below the post-loop merge point.\n+        \/\/ replace_ctrl_node_and_forward_ctrl_and_idom() takes a dead control as first input.\n+        \/\/ To make it possible to use it, the loop exit projection is cloned and becomes the\n+        \/\/ new exit projection. The initial one becomes dead and is \"replaced\" by the region.\n@@ -2759,1 +2760,1 @@\n-        lazy_replace(use, r);\n+        replace_ctrl_node_and_forward_ctrl_and_idom(use, r);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -658,1 +658,1 @@\n-    lazy_replace(ifp, ifpx);\n+    replace_ctrl_node_and_forward_ctrl_and_idom(ifp, ifpx);\n@@ -672,3 +672,4 @@\n-  lazy_replace(iff, region_dom);\n-  lazy_update(region, region_dom); \/\/ idom must be update before handle_uses\n-  region->set_req(0, nullptr);        \/\/ Break the self-cycle. Required for lazy_update to work on region\n+  replace_ctrl_node_and_forward_ctrl_and_idom(iff, region_dom);\n+  \/\/ Break the self-cycle. Required for install_lazy_ctrl_and_idom_forwarding to work on region.\n+  region->set_req(0, nullptr);\n+  install_lazy_ctrl_and_idom_forwarding(region, region_dom); \/\/ idom must be updated before handle_use\n","filename":"src\/hotspot\/share\/opto\/split_if.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}