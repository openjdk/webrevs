{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,1 +220,1 @@\n-    protected ML_KEM_KeyPair generateKemKeyPair(byte[] kem_d, byte[] kem_z) {\n+    protected ML_KEM_KeyPair generateKemKeyPair(byte[] kem_d_z) {\n@@ -230,1 +230,1 @@\n-        var kPkeKeyPair = generateK_PkeKeyPair(kem_d);\n+        var kPkeKeyPair = generateK_PkeKeyPair(kem_d_z);\n@@ -249,1 +249,1 @@\n-        System.arraycopy(kem_z, 0, decapsKey,\n+        System.arraycopy(kem_d_z, 32, decapsKey,\n@@ -370,1 +370,1 @@\n-        mlKemG.update(seed);\n+        mlKemG.update(seed, 0, 32);\n@@ -374,0 +374,1 @@\n+        mlKemG.reset();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,6 @@\n+    public static byte[] seedToExpandedPrivate(String pname, byte[] seed) {\n+        return new ML_KEM(pname).generateKemKeyPair(seed)\n+                .decapsulationKey()\n+                .keyBytes();\n+    }\n+\n@@ -54,1 +60,1 @@\n-            byte[] seed = new byte[32];\n+            byte[] seedAndZ = new byte[64];\n@@ -56,3 +62,1 @@\n-            r.nextBytes(seed);\n-            byte[] z = new byte[32];\n-            r.nextBytes(z);\n+            r.nextBytes(seedAndZ);\n@@ -62,7 +66,2 @@\n-            try {\n-                kp = mlKem.generateKemKeyPair(seed, z);\n-            } finally {\n-                Arrays.fill(seed, (byte)0);\n-                Arrays.fill(z, (byte)0);\n-            }\n-            return new byte[][] {\n+            kp = mlKem.generateKemKeyPair(seedAndZ);\n+            return new byte[][]{\n@@ -70,0 +69,1 @@\n+                    seedAndZ,\n@@ -100,0 +100,9 @@\n+\n+        @Override\n+        protected byte[] implGenAlt(String name, byte[] key) {\n+            if (key.length == 64) {\n+                return seedToExpandedPrivate(name, key);\n+            } else {\n+                return null;\n+            }\n+        }\n@@ -186,1 +195,1 @@\n-            super(\"ML-KEM\", \"ML-KEM-512\", \"ML-KEM-768\", \"ML-KEM-1024\");\n+            super(\"ML-KEM\", new KF(), \"ML-KEM-512\", \"ML-KEM-768\", \"ML-KEM-1024\");\n@@ -190,1 +199,1 @@\n-            super(\"ML-KEM\", name);\n+            super(\"ML-KEM\", new KF(name), name);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM_Impls.java","additions":23,"deletions":14,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import sun.security.util.DerInputStream;\n@@ -42,0 +41,1 @@\n+import java.util.function.BiFunction;\n@@ -53,0 +53,15 @@\n+\/\/\/ Besides the [PKCS8Key#key] field, this class might contain an optional\n+\/\/\/ alternative key stored in [#alt].\n+\/\/\/\n+\/\/\/ 1. If there is only `key`, there is only one private key encoding.\n+\/\/\/ 2. If both `key` and `alt` exist. `key` is used in encoding,\n+\/\/\/    and `alt` is used in calculation.\n+\/\/\/\n+\/\/\/ This allows ML-KEM or ML-DSA to encode the seed used in key pair\n+\/\/\/ generation as the private key. In this case, `alt` will be the\n+\/\/\/ expanded key as described in the FIPS documents. If the seed is\n+\/\/\/ lost, `key` will be the expanded key and `alt` will be null.\n+\/\/\/\n+\/\/\/ For algorithms that do not have this \"alternative\" key format,\n+\/\/\/ only `key` will be included and `alt` must be `null`.\n+\/\/\/\n@@ -60,1 +75,1 @@\n-    private final byte[] rawBytes;\n+    private final byte[] alt;\n@@ -64,3 +79,10 @@\n-    \/\/\/ Ctor from family name, parameter set name, raw key bytes.\n-    \/\/\/ Key bytes won't be cloned, caller must relinquish ownership\n-    public NamedPKCS8Key(String fname, String pname, byte[] rawBytes) {\n+    \/\/\/ Ctor from raw key bytes.\n+    \/\/\/\n+    \/\/\/ `rawBytes` and `alt` won't be cloned, caller\n+    \/\/\/ must relinquish ownership.\n+    \/\/\/\n+    \/\/\/ @param fname family name\n+    \/\/\/ @param pname parameter set name\n+    \/\/\/ @param rawBytes raw key bytes\n+    \/\/\/ @param alt alternative key format, can be `null`.\n+    public NamedPKCS8Key(String fname, String pname, byte[] rawBytes, byte[] alt) {\n@@ -69,0 +91,1 @@\n+        this.alt = alt;\n@@ -74,8 +97,1 @@\n-        this.rawBytes = rawBytes;\n-\n-        DerValue val = new DerValue(DerValue.tag_OctetString, rawBytes);\n-        try {\n-            this.key = val.toByteArray();\n-        } finally {\n-            val.clear();\n-        }\n+        this.key = rawBytes;\n@@ -84,2 +100,12 @@\n-    \/\/\/ Ctor from family name, and PKCS #8 bytes\n-    public NamedPKCS8Key(String fname, byte[] encoded) throws InvalidKeyException {\n+    \/\/\/ Ctor from family name and PKCS #8 encoding\n+    \/\/\/\n+    \/\/\/ @param fname family name\n+    \/\/\/ @param encoded PKCS #8 encoding. It is copied so caller can modify\n+    \/\/\/     it after the method call.\n+    \/\/\/ @param genAlt a function that is able to calculate the alternative\n+    \/\/\/     key from raw key inside `encoded`. In the case of seed\/expanded,\n+    \/\/\/     the function will calculate expanded from seed. If it recognizes\n+    \/\/\/     the input being already the expanded key, it must return `null`.\n+    \/\/\/     If there is no alternative key format, `getAlt` must be `null`.\n+    public NamedPKCS8Key(String fname, byte[] encoded,\n+            BiFunction<String, byte[], byte[]> genAlt) throws InvalidKeyException {\n@@ -88,8 +114,4 @@\n-        try {\n-            paramSpec = new NamedParameterSpec(algid.getName());\n-            if (algid.getEncodedParams() != null) {\n-                throw new InvalidKeyException(\"algorithm identifier has params\");\n-            }\n-            rawBytes = new DerInputStream(key).getOctetString();\n-        } catch (IOException e) {\n-            throw new InvalidKeyException(\"Cannot parse input\", e);\n+        this.alt = genAlt == null ? null : genAlt.apply(algid.getName(), this.key);\n+        paramSpec = new NamedParameterSpec(algid.getName());\n+        if (algid.getEncodedParams() != null) {\n+            throw new InvalidKeyException(\"algorithm identifier has params\");\n@@ -109,1 +131,17 @@\n-        return rawBytes;\n+        return key;\n+    }\n+\n+    \/\/\/ Returns the reference to the key that will be used in computations\n+    \/\/\/ inside `NamedKEM` or `NamedSignature` between `alt` (if exists)\n+    \/\/\/ and `key`.\n+    \/\/\/\n+    \/\/\/ This method currently simply chooses the longer one, where it is the\n+    \/\/\/ expanded format. If the key used in computations is not the longer\n+    \/\/\/ one for an algorithm, consider adding overridable methods to\n+    \/\/\/ `NamedKEM` and `NamedSignature` to extract it.\n+    public byte[] getExpanded() {\n+        if (alt == null) {\n+            return key;\n+        } else {\n+            return alt.length > key.length ? alt : key;\n+        }\n@@ -131,1 +169,0 @@\n-        Arrays.fill(rawBytes, (byte)0);\n@@ -133,0 +170,3 @@\n+        if (alt != null) {\n+            Arrays.fill(alt, (byte)0);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/NamedPKCS8Key.java","additions":66,"deletions":26,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+\n@@ -31,1 +32,0 @@\n-import java.util.Arrays;\n@@ -35,0 +35,5 @@\n+    public static byte[] seedToExpandedPrivate(String pname, byte[] seed) {\n+        var impl = new ML_DSA(name2int(pname));\n+        return impl.skEncode(impl.generateKeyPairInternal(seed).privateKey());\n+    }\n+\n@@ -81,0 +86,1 @@\n+                        seed,\n@@ -85,1 +91,0 @@\n-                Arrays.fill(seed, (byte)0);\n@@ -115,0 +120,9 @@\n+\n+        @Override\n+        protected byte[] implGenAlt(String name, byte[] key) {\n+            if (key.length == 32) {\n+                return seedToExpandedPrivate(name, key);\n+            } else {\n+                return null;\n+            }\n+        }\n@@ -137,1 +151,1 @@\n-            super(\"ML-DSA\", \"ML-DSA-44\", \"ML-DSA-65\", \"ML-DSA-87\");\n+            super(\"ML-DSA\", new KF(), \"ML-DSA-44\", \"ML-DSA-65\", \"ML-DSA-87\");\n@@ -140,1 +154,1 @@\n-            super(\"ML-DSA\", name);\n+            super(\"ML-DSA\", new KF(name), name);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA_Impls.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-import java.util.Objects;\n@@ -54,0 +53,1 @@\n+    private final NamedKeyFactory fac;\n@@ -58,0 +58,2 @@\n+    \/\/\/ @param fac the `KeyFactory` used to translate foreign keys and\n+    \/\/\/         perform key validation\n@@ -59,1 +61,1 @@\n-    protected NamedKEM(String fname, String... pnames) {\n+    protected NamedKEM(String fname, NamedKeyFactory fac, String... pnames) {\n@@ -68,0 +70,1 @@\n+        this.fac = fac;\n@@ -79,2 +82,1 @@\n-        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n-                .engineTranslateKey(publicKey);\n+        var nk = (NamedX509Key) fac.engineTranslateKey(publicKey);\n@@ -95,3 +97,2 @@\n-        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n-                .engineTranslateKey(privateKey);\n-        var sk = nk.getRawBytes();\n+        var nk = (NamedPKCS8Key) fac.engineTranslateKey(privateKey);\n+        var sk = nk.getExpanded();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKEM.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-import java.util.Objects;\n@@ -61,1 +60,1 @@\n-public class NamedKeyFactory extends KeyFactorySpi {\n+public abstract class NamedKeyFactory extends KeyFactorySpi {\n@@ -132,6 +131,2 @@\n-                var bytes = rks.getKeyArr();\n-                try {\n-                    return new NamedPKCS8Key(fname, pnames[0], bytes);\n-                } finally {\n-                    Arrays.fill(bytes, (byte) 0);\n-                }\n+                var raw = rks.getKeyArr();\n+                return new NamedPKCS8Key(fname, pnames[0], raw, implGenAlt(pnames[0], raw));\n@@ -144,6 +139,2 @@\n-                var bytes = espec.getEncoded();\n-                try {\n-                    return new NamedPKCS8Key(fname, pnames[0], bytes);\n-                } finally {\n-                    Arrays.fill(bytes, (byte) 0);\n-                }\n+                var raw = espec.getEncoded();\n+                return new NamedPKCS8Key(fname, pnames[0], raw, implGenAlt(pnames[0], raw));\n@@ -160,1 +151,1 @@\n-        var k = new NamedPKCS8Key(fname, bytes);\n+        var k = new NamedPKCS8Key(fname, bytes, this::implGenAlt);\n@@ -263,0 +254,1 @@\n+                var raw = key.getEncoded();\n@@ -264,2 +256,2 @@\n-                        ? new NamedPKCS8Key(fname, name, key.getEncoded())\n-                        : new NamedX509Key(fname, name, key.getEncoded());\n+                        ? new NamedPKCS8Key(fname, name, raw, implGenAlt(name, raw))\n+                        : new NamedX509Key(fname, name, raw);\n@@ -288,0 +280,8 @@\n+\n+    \/\/\/ User-defined function to generate the alternative key inside\n+    \/\/\/ a [NamedPKCS8Key].\n+    \/\/\/\n+    \/\/\/ This method will be called when the key factory is constructing\n+    \/\/\/ a private key. If the input `key` is a seed, the expanded key must\n+    \/\/\/ be returned. If `key` is in expanded format, `null` must be returned.\n+    protected abstract byte[] implGenAlt(String name, byte[] key);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyFactory.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.util.Objects;\n@@ -98,0 +97,7 @@\n+\/\/\/ If the private key of an algorithm can be encoded in two formats, the\n+\/\/\/ encoded format will be the `key` of the `NamedPKCS8Key`, and the other\n+\/\/\/ format will be the `alt` field. When there are two formats (for example,\n+\/\/\/ \"seed\" and \"expanded\"), the [#implGenerateKeyPair] must return the encoding\n+\/\/\/ format as the 2nd element and the other format as the 3rd element. All\n+\/\/\/ calculations inside `NamedKEM` or `NamedSignature` use the \"other\" format.\n+\/\/\/\n@@ -167,1 +173,2 @@\n-                new NamedPKCS8Key(fname, pname, keys[1]));\n+                new NamedPKCS8Key(fname, pname, keys[1],\n+                        keys.length == 2 ? null : keys[2]));\n@@ -174,1 +181,4 @@\n-    \/\/\/ @return public key and private key (in this order) in raw bytes\n+    \/\/\/ @return the public key, the private key, and the alternative\n+    \/\/\/         format of the private key (in this order) in raw bytes.\n+    \/\/\/         If there is no alternative format, the 3rd element\n+    \/\/\/         must be `null` or simply omitted.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyPairGenerator.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import java.util.Objects;\n@@ -54,0 +53,1 @@\n+    private final NamedKeyFactory fac;\n@@ -68,0 +68,2 @@\n+    \/\/\/ @param fac the `KeyFactory` used to translate foreign keys and\n+    \/\/\/         perform key validation\n@@ -69,1 +71,1 @@\n-    protected NamedSignature(String fname, String... pnames) {\n+    protected NamedSignature(String fname, NamedKeyFactory fac, String... pnames) {\n@@ -78,0 +80,1 @@\n+        this.fac = fac;\n@@ -83,2 +86,1 @@\n-        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n-                .engineTranslateKey(publicKey);\n+        var nk = (NamedX509Key) fac.engineTranslateKey(publicKey);\n@@ -95,2 +97,1 @@\n-        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n-                .engineTranslateKey(privateKey);\n+        var nk = (NamedPKCS8Key) fac.engineTranslateKey(privateKey);\n@@ -98,1 +99,1 @@\n-        secKey = nk.getRawBytes();\n+        secKey = nk.getExpanded();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedSignature.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,2 @@\n-    \/\/\/ Ctor from family name, and X.509 bytes\n+    \/\/\/ Ctor from family name, and X.509 bytes. Input byte array\n+    \/\/\/ is copied. Caller can modify it after the method call.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/NamedX509Key.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,261 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8340327\n- * @modules java.base\/sun.security.x509\n- *          java.base\/sun.security.pkcs\n- *          java.base\/sun.security.provider\n- *          java.base\/sun.security.util\n- * @library \/test\/lib\n- *\/\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.security.SeededSecureRandom;\n-import sun.security.pkcs.NamedPKCS8Key;\n-import sun.security.provider.NamedKeyFactory;\n-import sun.security.provider.NamedKeyPairGenerator;\n-import sun.security.util.RawKeySpec;\n-import sun.security.x509.NamedX509Key;\n-\n-import java.security.*;\n-import java.security.spec.*;\n-\n-public class NamedKeyFactoryTest {\n-\n-    private static final SeededSecureRandom RAND = SeededSecureRandom.one();\n-\n-    public static void main(String[] args) throws Exception {\n-        Security.addProvider(new ProviderImpl());\n-\n-        var g = KeyPairGenerator.getInstance(\"sHA\");\n-        var g2 = KeyPairGenerator.getInstance(\"ShA-256\");\n-        var g5 = KeyPairGenerator.getInstance(\"SHa-512\");\n-        var kf = KeyFactory.getInstance(\"ShA\");\n-        var kf2 = KeyFactory.getInstance(\"Sha-256\");\n-        var kf5 = KeyFactory.getInstance(\"Sha-512\");\n-\n-        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n-        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n-        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n-\n-        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n-        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n-        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n-\n-        Utils.runAndCheckException(() -> g.initialize(NamedParameterSpec.ED448),\n-                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n-        Utils.runAndCheckException(() -> g.initialize(new NamedParameterSpec(\"SHA-384\")),\n-                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n-\n-        Utils.runAndCheckException(() -> g5.initialize(new NamedParameterSpec(\"SHA-256\")),\n-                InvalidAlgorithmParameterException.class); \/\/ diff pname\n-        g5.initialize(new NamedParameterSpec(\"SHA-512\"));\n-\n-        g.initialize(new NamedParameterSpec(\"sHA-512\"));\n-        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-512\");\n-        g.initialize(new NamedParameterSpec(\"ShA-256\"));\n-        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n-\n-        var pk = new NamedX509Key(\"sHa\", \"ShA-256\", RAND.nBytes(2));\n-        var sk = new NamedPKCS8Key(\"sHa\", \"SHa-256\", RAND.nBytes(2));\n-        checkKey(pk, \"sHa\", \"ShA-256\");\n-        checkKey(sk, \"sHa\", \"SHa-256\");\n-\n-        Asserts.assertEquals(\"X.509\", pk.getFormat());\n-        Asserts.assertEquals(\"PKCS#8\", sk.getFormat());\n-\n-        var pkSpec = kf.getKeySpec(pk, X509EncodedKeySpec.class);\n-        var skSpec = kf.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n-\n-        kf2.getKeySpec(pk, X509EncodedKeySpec.class);\n-        kf2.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n-        Utils.runAndCheckException(() -> kf5.getKeySpec(pk, X509EncodedKeySpec.class),\n-                InvalidKeySpecException.class); \/\/ wrong KF\n-        Utils.runAndCheckException(() -> kf5.getKeySpec(sk, PKCS8EncodedKeySpec.class),\n-                InvalidKeySpecException.class);\n-        Utils.runAndCheckException(() -> kf.getKeySpec(pk, PKCS8EncodedKeySpec.class),\n-                InvalidKeySpecException.class); \/\/ wrong KeySpec\n-        Utils.runAndCheckException(() -> kf.getKeySpec(sk, X509EncodedKeySpec.class),\n-                InvalidKeySpecException.class);\n-\n-        checkKey(kf.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n-        Utils.runAndCheckException(() -> kf.generatePrivate(pkSpec),\n-                InvalidKeySpecException.class);\n-\n-        checkKey(kf.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n-        Utils.runAndCheckException(() -> kf.generatePublic(skSpec),\n-                InvalidKeySpecException.class);\n-\n-        checkKey(kf2.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n-        checkKey(kf2.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n-\n-        Utils.runAndCheckException(() -> kf5.generatePublic(pkSpec),\n-                InvalidKeySpecException.class); \/\/ wrong KF\n-        Utils.runAndCheckException(() -> kf5.generatePublic(skSpec),\n-                InvalidKeySpecException.class);\n-\n-        \/\/ The private RawKeySpec and unnamed RAW EncodedKeySpec\n-        var prk = kf.getKeySpec(pk, RawKeySpec.class);\n-        Asserts.assertEqualsByteArray(prk.getKeyArr(), pk.getRawBytes());\n-        var prk2 = kf.getKeySpec(pk, EncodedKeySpec.class);\n-        Asserts.assertEquals(\"RAW\", prk2.getFormat());\n-        Asserts.assertEqualsByteArray(prk.getKeyArr(), prk2.getEncoded());\n-\n-        Asserts.assertEqualsByteArray(kf2.generatePublic(prk).getEncoded(), pk.getEncoded());\n-        Utils.runAndCheckException(() -> kf.generatePublic(prk), InvalidKeySpecException.class); \/\/ no pname\n-        Asserts.assertEqualsByteArray(kf2.generatePublic(prk2).getEncoded(), pk.getEncoded());\n-        Utils.runAndCheckException(() -> kf.generatePublic(prk2), InvalidKeySpecException.class); \/\/ no pname\n-\n-        var srk = kf.getKeySpec(sk, RawKeySpec.class);\n-        Asserts.assertEqualsByteArray(srk.getKeyArr(), sk.getRawBytes());\n-        var srk2 = kf.getKeySpec(sk, EncodedKeySpec.class);\n-        Asserts.assertEquals(\"RAW\", srk2.getFormat());\n-        Asserts.assertEqualsByteArray(srk2.getEncoded(), sk.getRawBytes());\n-\n-        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk).getEncoded(), sk.getEncoded());\n-        Utils.runAndCheckException(() -> kf.generatePrivate(srk), InvalidKeySpecException.class); \/\/ no pname\n-        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk2).getEncoded(), sk.getEncoded());\n-        Utils.runAndCheckException(() -> kf.generatePrivate(srk2), InvalidKeySpecException.class); \/\/ no pname\n-\n-        var pk1 = new PublicKey() {\n-            public String getAlgorithm() { return \"SHA\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-        };\n-        var pk2 = new PublicKey() {\n-            public String getAlgorithm() { return \"sHA-256\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-        };\n-        var pk3 = new PublicKey() {\n-            public String getAlgorithm() { return \"SHA\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n-        };\n-\n-        checkKey(kf2.translateKey(pk1), \"SHA\", \"SHA-256\");\n-        checkKey(kf.translateKey(pk2), \"SHA\", \"SHA-256\");\n-        checkKey(kf.translateKey(pk3), \"SHA\", \"SHA-256\");\n-\n-        Utils.runAndCheckException(() -> kf.translateKey(pk1), InvalidKeyException.class);\n-        Utils.runAndCheckException(() -> kf5.translateKey(pk2), InvalidKeyException.class);\n-        Utils.runAndCheckException(() -> kf5.translateKey(pk3), InvalidKeyException.class);\n-\n-        var sk1 = new PrivateKey() {\n-            public String getAlgorithm() { return \"SHA\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-        };\n-        var sk2 = new PrivateKey() {\n-            public String getAlgorithm() { return \"sHA-256\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-        };\n-        var sk3 = new PrivateKey() {\n-            public String getAlgorithm() { return \"SHA\"; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return RAND.nBytes(2); }\n-            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n-        };\n-\n-        checkKey(kf2.translateKey(sk1), \"SHA\", \"SHA-256\");\n-        checkKey(kf.translateKey(sk2), \"SHA\", \"SHA-256\");\n-        checkKey(kf.translateKey(sk3), \"SHA\", \"SHA-256\");\n-\n-        Utils.runAndCheckException(() -> kf.translateKey(sk1), InvalidKeyException.class);\n-        Utils.runAndCheckException(() -> kf5.translateKey(sk2), InvalidKeyException.class);\n-        Utils.runAndCheckException(() -> kf5.translateKey(sk3), InvalidKeyException.class);\n-    }\n-\n-    static void checkKeyPair(KeyPair kp, String algName, String toString) {\n-        checkKey(kp.getPrivate(), algName, toString);\n-        checkKey(kp.getPublic(), algName, toString);\n-    }\n-\n-    static void checkKey(Key k, String algName, String pname) {\n-        Asserts.assertEquals(algName, k.getAlgorithm());\n-        Asserts.assertTrue(k.toString().contains(pname));\n-        if (k instanceof AsymmetricKey ak && ak.getParams() instanceof NamedParameterSpec nps) {\n-            Asserts.assertEquals(pname, nps.getName());\n-        }\n-    }\n-\n-    \/\/ Provider\n-\n-    public static class ProviderImpl extends Provider {\n-        public ProviderImpl() {\n-            super(\"P\", \"1\", \"...\");\n-            put(\"KeyFactory.SHA\", KF.class.getName());\n-            put(\"KeyFactory.SHA-256\", KF1.class.getName());\n-            put(\"KeyFactory.SHA-512\", KF2.class.getName());\n-            put(\"KeyPairGenerator.SHA\", KPG.class.getName());\n-            put(\"KeyPairGenerator.SHA-256\", KPG1.class.getName());\n-            put(\"KeyPairGenerator.SHA-512\", KPG2.class.getName());\n-        }\n-    }\n-    public static class KF extends NamedKeyFactory {\n-        public KF() {\n-            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n-        }\n-    }\n-    public static class KF1 extends NamedKeyFactory {\n-        public KF1() {\n-            super(\"SHA\", \"SHA-256\");\n-        }\n-    }\n-    public static class KF2 extends NamedKeyFactory {\n-        public KF2() {\n-            super(\"SHA\", \"SHA-512\");\n-        }\n-    }\n-    public static class KPG extends NamedKeyPairGenerator {\n-        public KPG() {\n-            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n-        }\n-\n-        public KPG(String pname) {\n-            super(\"SHA\", pname);\n-        }\n-\n-        @Override\n-        public byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n-            var out = new byte[2][];\n-            out[0] = RAND.nBytes(name.endsWith(\"256\") ? 2 : 4);\n-            out[1] = RAND.nBytes(name.endsWith(\"256\") ? 2 : 4);\n-            return out;\n-        }\n-    }\n-    public static class KPG1 extends KPG {\n-        public KPG1() {\n-            super(\"SHA-256\");\n-        }\n-    }\n-    public static class KPG2 extends KPG {\n-        public KPG2() {\n-            super(\"SHA-512\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/provider\/NamedKeyFactoryTest.java","additions":0,"deletions":261,"binary":false,"changes":261,"status":"deleted"},{"patch":"@@ -42,0 +42,2 @@\n+ *          java.base\/com.sun.crypto.provider\n+ * @run main\/othervm Launcher\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/Launcher.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,2 @@\n-                Asserts.assertEqualsByteArray(toByteArray(c.get(\"sk\").asString()), sk);\n+                Asserts.assertEqualsByteArray(toByteArray(c.get(\"sk\").asString()),\n+                        ML_DSA_Impls.seedToExpandedPrivate(pname, sk));\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_DSA_Test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+import com.sun.crypto.provider.ML_KEM_Impls;\n@@ -74,1 +75,3 @@\n-                Asserts.assertEqualsByteArray(toByteArray(c.get(\"dk\").asString()), sk);\n+                Asserts.assertEqualsByteArray(\n+                        toByteArray(c.get(\"dk\").asString()),\n+                        ML_KEM_Impls.seedToExpandedPrivate(pname, sk));\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_KEM_Test.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8340327\n+ * @bug 8340327 8347938 8347941\n@@ -31,0 +31,1 @@\n+ *          java.base\/sun.security.util\n@@ -43,0 +44,2 @@\n+import sun.security.util.DerOutputStream;\n+import sun.security.util.DerValue;\n@@ -44,0 +47,1 @@\n+import java.io.IOException;\n@@ -69,1 +73,1 @@\n-            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+            super(\"EdDSA\", new EdDSAKeyFactory(), \"Ed25519\", \"Ed448\");\n@@ -73,1 +77,1 @@\n-            super(\"EdDSA\", pname);\n+            super(\"EdDSA\", new EdDSAKeyFactory(pname), pname);\n@@ -90,1 +94,5 @@\n-            return getOps(name).sign(plain, sk, msg);\n+            try {\n+                return getOps(name).sign(plain, new DerValue(sk).getOctetString(), msg);\n+            } catch (IOException e) {\n+                throw new SignatureException(e);\n+            }\n@@ -124,0 +132,5 @@\n+\n+        @Override\n+        protected byte[] implGenAlt(String name, byte[] key) {\n+            return null;\n+        }\n@@ -160,1 +173,3 @@\n-            return new byte[][] { encodedPoint, sk };\n+            return new byte[][] {\n+                    encodedPoint,\n+                    new DerOutputStream().putOctetString(sk).toByteArray()};\n","filename":"test\/jdk\/sun\/security\/provider\/named\/NamedEdDSA.java","additions":21,"deletions":6,"binary":false,"changes":27,"previous_filename":"test\/jdk\/sun\/security\/provider\/NamedEdDSA.java","status":"renamed"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340327 8347938 8347941\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.provider\n+ *          java.base\/sun.security.util\n+ * @library \/test\/lib\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+import sun.security.util.RawKeySpec;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.*;\n+import java.security.spec.*;\n+import java.util.Arrays;\n+\n+public class NamedKeyFactoryTest {\n+\n+    private static final SeededSecureRandom RAND = SeededSecureRandom.one();\n+    private static final byte[] RAW_SK = RAND.nBytes(16);\n+    private static final byte[] RAW_PK = RAND.nBytes(16);\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.addProvider(new ProviderImpl());\n+\n+        var g = KeyPairGenerator.getInstance(\"sHA\");\n+        var g2 = KeyPairGenerator.getInstance(\"ShA-256\");\n+        var g5 = KeyPairGenerator.getInstance(\"SHa-512\");\n+        var kf = KeyFactory.getInstance(\"ShA\");\n+        var kf2 = KeyFactory.getInstance(\"Sha-256\");\n+        var kf5 = KeyFactory.getInstance(\"Sha-512\");\n+\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n+\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g2.generateKeyPair(), \"SHA\", \"SHA-256\");\n+        checkKeyPair(g5.generateKeyPair(), \"SHA\", \"SHA-512\");\n+\n+        Utils.runAndCheckException(() -> g.initialize(NamedParameterSpec.ED448),\n+                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n+        Utils.runAndCheckException(() -> g.initialize(new NamedParameterSpec(\"SHA-384\")),\n+                InvalidAlgorithmParameterException.class); \/\/ wrong pname\n+\n+        Utils.runAndCheckException(() -> g5.initialize(new NamedParameterSpec(\"SHA-256\")),\n+                InvalidAlgorithmParameterException.class); \/\/ diff pname\n+        g5.initialize(new NamedParameterSpec(\"SHA-512\"));\n+\n+        g.initialize(new NamedParameterSpec(\"sHA-512\"));\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-512\");\n+        g.initialize(new NamedParameterSpec(\"ShA-256\"));\n+        checkKeyPair(g.generateKeyPair(), \"SHA\", \"SHA-256\");\n+\n+        var pk = new NamedX509Key(\"sHa\", \"ShA-256\", RAW_PK);\n+        var sk = new NamedPKCS8Key(\"sHa\", \"SHa-256\", RAW_SK, null);\n+        checkKey(pk, \"sHa\", \"ShA-256\");\n+        checkKey(sk, \"sHa\", \"SHa-256\");\n+\n+        Asserts.assertEquals(\"X.509\", pk.getFormat());\n+        Asserts.assertEquals(\"PKCS#8\", sk.getFormat());\n+\n+        var pkSpec = kf.getKeySpec(pk, X509EncodedKeySpec.class);\n+        var skSpec = kf.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n+\n+        kf2.getKeySpec(pk, X509EncodedKeySpec.class);\n+        kf2.getKeySpec(sk, PKCS8EncodedKeySpec.class);\n+        Utils.runAndCheckException(() -> kf5.getKeySpec(pk, X509EncodedKeySpec.class),\n+                InvalidKeySpecException.class); \/\/ wrong KF\n+        Utils.runAndCheckException(() -> kf5.getKeySpec(sk, PKCS8EncodedKeySpec.class),\n+                InvalidKeySpecException.class);\n+        Utils.runAndCheckException(() -> kf.getKeySpec(pk, PKCS8EncodedKeySpec.class),\n+                InvalidKeySpecException.class); \/\/ wrong KeySpec\n+        Utils.runAndCheckException(() -> kf.getKeySpec(sk, X509EncodedKeySpec.class),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n+        Utils.runAndCheckException(() -> kf.generatePrivate(pkSpec),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n+        Utils.runAndCheckException(() -> kf.generatePublic(skSpec),\n+                InvalidKeySpecException.class);\n+\n+        checkKey(kf2.generatePrivate(skSpec), \"SHA\", \"SHA-256\");\n+        checkKey(kf2.generatePublic(pkSpec), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf5.generatePublic(pkSpec),\n+                InvalidKeySpecException.class); \/\/ wrong KF\n+        Utils.runAndCheckException(() -> kf5.generatePublic(skSpec),\n+                InvalidKeySpecException.class);\n+\n+        \/\/ The private RawKeySpec and unnamed RAW EncodedKeySpec\n+        var prk = kf.getKeySpec(pk, RawKeySpec.class);\n+        Asserts.assertEqualsByteArray(prk.getKeyArr(), pk.getRawBytes());\n+        var prk2 = kf.getKeySpec(pk, EncodedKeySpec.class);\n+        Asserts.assertEquals(\"RAW\", prk2.getFormat());\n+        Asserts.assertEqualsByteArray(prk.getKeyArr(), prk2.getEncoded());\n+\n+        Asserts.assertEqualsByteArray(kf2.generatePublic(prk).getEncoded(), pk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePublic(prk), InvalidKeySpecException.class); \/\/ no pname\n+        Asserts.assertEqualsByteArray(kf2.generatePublic(prk2).getEncoded(), pk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePublic(prk2), InvalidKeySpecException.class); \/\/ no pname\n+\n+        var srk = kf.getKeySpec(sk, RawKeySpec.class);\n+        Asserts.assertEqualsByteArray(srk.getKeyArr(), sk.getRawBytes());\n+        var srk2 = kf.getKeySpec(sk, EncodedKeySpec.class);\n+        Asserts.assertEquals(\"RAW\", srk2.getFormat());\n+        Asserts.assertEqualsByteArray(srk2.getEncoded(), sk.getRawBytes());\n+\n+        checkKey(kf2.generatePrivate(srk), \"SHA\", \"SHA-256\");\n+        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk).getEncoded(), sk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePrivate(srk), InvalidKeySpecException.class); \/\/ no pname\n+        checkKey(kf2.generatePrivate(srk), \"SHA\", \"SHA-256\");\n+        Asserts.assertEqualsByteArray(kf2.generatePrivate(srk2).getEncoded(), sk.getEncoded());\n+        Utils.runAndCheckException(() -> kf.generatePrivate(srk2), InvalidKeySpecException.class); \/\/ no pname\n+\n+        var pk1 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_PK; }\n+        };\n+        var pk2 = new PublicKey() {\n+            public String getAlgorithm() { return \"sHA-256\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_PK; }\n+        };\n+        var pk3 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_PK; }\n+            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n+        };\n+\n+        checkKey(kf2.translateKey(pk1), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(pk2), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(pk3), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf.translateKey(pk1), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk2), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk3), InvalidKeyException.class);\n+\n+        var sk1 = new PrivateKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_SK; }\n+        };\n+        var sk2 = new PrivateKey() {\n+            public String getAlgorithm() { return \"sHA-256\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_SK; }\n+        };\n+        var sk3 = new PrivateKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return RAW_SK; }\n+            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n+        };\n+\n+        checkKey(kf2.translateKey(sk1), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(sk2), \"SHA\", \"SHA-256\");\n+        checkKey(kf.translateKey(sk3), \"SHA\", \"SHA-256\");\n+\n+        Utils.runAndCheckException(() -> kf.translateKey(sk1), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(sk2), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(sk3), InvalidKeyException.class);\n+    }\n+\n+    static void checkKeyPair(KeyPair kp, String algName, String toString) {\n+        checkKey(kp.getPrivate(), algName, toString);\n+        checkKey(kp.getPublic(), algName, toString);\n+    }\n+\n+    static void checkKey(Key k, String algName, String pname) {\n+        Asserts.assertEquals(algName, k.getAlgorithm());\n+        Asserts.assertTrue(k.toString().contains(pname));\n+        if (k instanceof AsymmetricKey ak && ak.getParams() instanceof NamedParameterSpec nps) {\n+            Asserts.assertEquals(pname, nps.getName());\n+        }\n+        if (k instanceof NamedPKCS8Key nsk) {\n+            var raw = nsk.getRawBytes();\n+            Asserts.assertEqualsByteArray(Arrays.copyOf(RAW_SK, raw.length), raw);\n+        }\n+        if (k instanceof NamedX509Key npk) {\n+            var raw = npk.getRawBytes();\n+            Asserts.assertEqualsByteArray(Arrays.copyOf(RAW_PK, raw.length), raw);\n+        }\n+    }\n+\n+    \/\/ Provider\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"P\", \"1\", \"...\");\n+            put(\"KeyFactory.SHA\", KF.class.getName());\n+            put(\"KeyFactory.SHA-256\", KF1.class.getName());\n+            put(\"KeyFactory.SHA-512\", KF2.class.getName());\n+            put(\"KeyPairGenerator.SHA\", KPG.class.getName());\n+            put(\"KeyPairGenerator.SHA-256\", KPG1.class.getName());\n+            put(\"KeyPairGenerator.SHA-512\", KPG2.class.getName());\n+        }\n+    }\n+    public static class KF extends NamedKeyFactory {\n+        public KF() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+\n+        public KF(String name) {\n+            super(\"SHA\", name);\n+        }\n+\n+        @Override\n+        protected byte[] implGenAlt(String name, byte[] key) {\n+            return null;\n+        }\n+    }\n+    public static class KF1 extends KF {\n+        public KF1() {\n+            super(\"SHA-256\");\n+        }\n+    }\n+    public static class KF2 extends KF {\n+        public KF2() {\n+            super(\"SHA-512\");\n+        }\n+    }\n+    public static class KPG extends NamedKeyPairGenerator {\n+        public KPG() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+\n+        public KPG(String pname) {\n+            super(\"SHA\", pname);\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n+            var out = new byte[2][];\n+            out[0] = name.endsWith(\"256\") ? Arrays.copyOf(RAW_PK, 8) : RAW_PK;\n+            out[1] = name.endsWith(\"256\") ? Arrays.copyOf(RAW_SK, 8) : RAW_SK;\n+            return out;\n+        }\n+    }\n+    public static class KPG1 extends KPG {\n+        public KPG1() {\n+            super(\"SHA-256\");\n+        }\n+    }\n+    public static class KPG2 extends KPG {\n+        public KPG2() {\n+            super(\"SHA-512\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/named\/NamedKeyFactoryTest.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8347938 8347941\n+ * @modules java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.x509\n+ * @library \/test\/lib\n+ * @summary check the Named***Key behavior\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.util.Arrays;\n+\n+public class NamedKeys {\n+    public static void main(String[] args) throws Exception {\n+\n+        var r = SeededSecureRandom.one();\n+        var raw = r.nBytes(32);\n+\n+        \/\/ Create a key using raw bytes\n+        var sk = new NamedPKCS8Key(\"ML-DSA\", \"ML-DSA-44\", raw, null);\n+        var enc = sk.getEncoded().clone();\n+\n+        \/\/ The raw bytes array is re-used\n+        Asserts.assertTrue(sk.getRawBytes() == sk.getRawBytes());\n+        \/\/ but the encoding is different\n+        Asserts.assertTrue(sk.getEncoded() != sk.getEncoded());\n+\n+        \/\/ When source change\n+        Arrays.fill(raw, (byte)0);\n+        \/\/ Internal raw bytes also changes\n+        Asserts.assertEqualsByteArray(sk.getRawBytes(), new byte[32]);\n+        \/\/ No guarantee on getEncoded() output, could be cached\n+\n+        \/\/ Create a key using encoding\n+        var sk1 = new NamedPKCS8Key(\"ML-DSA\", enc, null);\n+        var sk2 = new NamedPKCS8Key(\"ML-DSA\", enc, null);\n+        var raw1 = sk1.getRawBytes();\n+        Asserts.assertTrue(raw1 != sk2.getRawBytes());\n+        Asserts.assertTrue(sk1.getEncoded() != sk2.getEncoded());\n+\n+        var encCopy = enc.clone(); \/\/ store a copy\n+        Arrays.fill(enc, (byte)0); \/\/ clean the source and the key unchanged\n+        Asserts.assertEqualsByteArray(encCopy, sk1.getEncoded());\n+\n+        \/\/ Same with public key\n+        \/\/ Create a key using raw bytes\n+        raw = r.nBytes(32);\n+        var pk = new NamedX509Key(\"ML-DSA\", \"ML-DSA-44\", raw);\n+        enc = pk.getEncoded().clone();\n+\n+        \/\/ The raw bytes array is re-used\n+        Asserts.assertTrue(pk.getRawBytes() == pk.getRawBytes());\n+        \/\/ but the encoding is different\n+        Asserts.assertTrue(pk.getEncoded() != pk.getEncoded());\n+\n+        \/\/ When source change\n+        Arrays.fill(raw, (byte)0);\n+        \/\/ Internal raw bytes also changes\n+        Asserts.assertEqualsByteArray(pk.getRawBytes(), new byte[32]);\n+        \/\/ No guarantee on getEncoded() output, could be cached\n+\n+        \/\/ Create a key using encoding\n+        var pk1 = new NamedX509Key(\"ML-DSA\", enc);\n+        var pk2 = new NamedX509Key(\"ML-DSA\", enc);\n+        raw1 = pk1.getRawBytes();\n+        Asserts.assertTrue(raw1 != pk2.getRawBytes());\n+        Asserts.assertTrue(pk1.getEncoded() != pk2.getEncoded());\n+\n+        encCopy = enc.clone(); \/\/ store a copy\n+        Arrays.fill(enc, (byte)0); \/\/ clean the source and the key unchanged\n+        Asserts.assertEqualsByteArray(encCopy, pk1.getEncoded());\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/named\/NamedKeys.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8347938 8347941\n+ * @library \/test\/lib\n+ * @modules java.base\/com.sun.crypto.provider\n+ *          java.base\/sun.security.provider\n+ *          java.base\/sun.security.util\n+ * @summary check key reading compatibility\n+ * @run main\/othervm SeedOrExpanded\n+ *\/\n+\n+import com.sun.crypto.provider.ML_KEM_Impls;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.FixedSecureRandom;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.provider.ML_DSA_Impls;\n+import sun.security.util.DerOutputStream;\n+import sun.security.util.DerValue;\n+import sun.security.util.KnownOIDs;\n+import sun.security.util.ObjectIdentifier;\n+\n+import javax.crypto.KEM;\n+import java.security.KeyFactory;\n+import java.security.KeyPairGenerator;\n+import java.security.PrivateKey;\n+import java.security.Signature;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Arrays;\n+\n+public class SeedOrExpanded {\n+\n+    static final SeededSecureRandom RAND = SeededSecureRandom.one();\n+\n+    public static void main(String[] args) throws Exception {\n+        test(\"ML-KEM-768\");\n+        test(\"ML-DSA-65\");\n+    }\n+\n+    static void test(String alg) throws Exception {\n+\n+        var seed = RAND.nBytes(alg.contains(\"ML-KEM\") ? 64 : 32);\n+        var g = KeyPairGenerator.getInstance(alg);\n+\n+        \/\/ Generation\n+\n+        g.initialize(-1, new FixedSecureRandom(seed));\n+        var kp = g.generateKeyPair();\n+        var kseed = kp.getPrivate().getEncoded();\n+\n+        var ex = alg.contains(\"ML-KEM\")\n+                ? ML_KEM_Impls.seedToExpandedPrivate(alg, seed)\n+                : ML_DSA_Impls.seedToExpandedPrivate(alg, seed);\n+        var kexpanded = new DerOutputStream().write(DerValue.tag_Sequence,\n+                new DerOutputStream().putInteger(0)\n+                        .write(DerValue.tag_Sequence, new DerOutputStream()\n+                                .putOID(ObjectIdentifier.of(KnownOIDs.findMatch(alg))))\n+                        .putOctetString(ex)).toByteArray();\n+\n+        \/\/ Seed encoding is usually shorter than expanded\n+        Asserts.assertTrue(kseed.length < kexpanded.length);\n+        Asserts.assertEqualsByteArray( \/\/ ... and encoding ends with seed\n+                Arrays.copyOfRange(kseed, kseed.length - seed.length, kseed.length),\n+                seed);\n+\n+        \/\/ Key loading\n+\n+        var f = KeyFactory.getInstance(alg);\n+        var sk1 = f.generatePrivate(new PKCS8EncodedKeySpec(kseed));\n+        var sk2 = f.generatePrivate(new PKCS8EncodedKeySpec(kexpanded));\n+        var sk3 = f.translateKey(new PrivateKey() {\n+            public String getAlgorithm() { return alg; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return seed.clone(); }\n+        });\n+        var sk4 = f.translateKey(new PrivateKey() {\n+            public String getAlgorithm() { return alg; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return ex.clone(); }\n+        });\n+        \/\/ Key factory never tries to reformat keys\n+        Asserts.assertEqualsByteArray(sk1.getEncoded(), kseed);\n+        Asserts.assertEqualsByteArray(sk2.getEncoded(), kexpanded);\n+        Asserts.assertEqualsByteArray(sk3.getEncoded(), kseed);\n+        Asserts.assertEqualsByteArray(sk4.getEncoded(), kexpanded);\n+\n+        \/\/ Key using\n+\n+        if (alg.contains(\"ML-KEM\")) {\n+            var kem = KEM.getInstance(\"ML-KEM\");\n+            var e = kem.newEncapsulator(kp.getPublic(), RAND);\n+            var enc = e.encapsulate();\n+            var k1 = kem.newDecapsulator(sk1).decapsulate(enc.encapsulation());\n+            var k2 = kem.newDecapsulator(sk2).decapsulate(enc.encapsulation());\n+            Asserts.assertEqualsByteArray(k1.getEncoded(), k2.getEncoded());\n+            Asserts.assertEqualsByteArray(k1.getEncoded(), enc.key().getEncoded());\n+        } else {\n+            var s = Signature.getInstance(\"ML-DSA\");\n+            var rnd = RAND.nBytes(32); \/\/ randomness for signature generation\n+            var msg = RAND.nBytes(20);\n+            s.initSign(sk1, new FixedSecureRandom(rnd));\n+            s.update(msg);\n+            var sig1 = s.sign();\n+            s.initSign(sk2, new FixedSecureRandom(rnd));\n+            s.update(msg);\n+            var sig2 = s.sign();\n+            Asserts.assertEqualsByteArray(sig1, sig2);\n+            s.initVerify(kp.getPublic());\n+            s.update(msg);\n+            Asserts.assertTrue(s.verify(sig1));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/pqc\/SeedOrExpanded.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,0 +259,9 @@\n+        String patchPath = System.getProperty(\"test.patch.path\");\n+        if (patchPath != null) {\n+            try (var subs = Files.newDirectoryStream(Path.of(patchPath))) {\n+                for (var sub : subs) {\n+                    var name = sub.getFileName();\n+                    cmd.add(\"--patch-module=\" + name + \"=\" + sub);\n+                }\n+            }\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/process\/Proc.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}