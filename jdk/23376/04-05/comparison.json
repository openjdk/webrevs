{"files":[{"patch":"@@ -230,0 +230,1 @@\n+        \/\/The 1st 32-byte `d` is used in K-PKE key pair generation\n@@ -249,0 +250,1 @@\n+        \/\/ The 2nd 32-byte `z` is copied into decapsKey\n@@ -370,0 +372,1 @@\n+        \/\/ Note: only the 1st 32-byte in the seed is used\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import sun.security.util.DerValue;\n@@ -33,0 +34,1 @@\n+import java.io.IOException;\n@@ -40,1 +42,1 @@\n-    public static byte[] seedToExpandedPrivate(String pname, byte[] seed) {\n+    public static byte[] seedToTransformed(String pname, byte[] seed) {\n@@ -102,3 +104,9 @@\n-        protected byte[] implGenAlt(String name, byte[] key) {\n-            if (key.length == 64) {\n-                return seedToExpandedPrivate(name, key);\n+        protected byte[] implTransform(String name, byte[] input) {\n+            if (input.length == 64) { \/\/ seed\n+                return seedToTransformed(name, input);\n+            } else if (input.length > 1 && input[0] == 4) { \/\/ jdk24\n+                try {\n+                    return new DerValue(input).getOctetString();\n+                } catch (IOException e) {\n+                    return null;\n+                }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ML_KEM_Impls.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import sun.security.util.DerValue;\n@@ -53,2 +52,6 @@\n-\/\/\/ Besides the [PKCS8Key#key] field, this class might contain an optional\n-\/\/\/ alternative key stored in [#alt].\n+\/\/\/ Besides the existing [PKCS8Key#key] field, this class optionally supports a\n+\/\/\/ transformed format stored in [#transformed]. While `key` always represents\n+\/\/\/ the base format used for encoding, an algorithm may perform pre-computation\n+\/\/\/ to derive a transformed format, which may accelerate future operations.\n+\/\/\/ The transformed format must be self-sufficient for cryptographic\n+\/\/\/ computations without requiring the base format.\n@@ -56,3 +59,3 @@\n-\/\/\/ 1. If there is only `key`, there is only one private key encoding.\n-\/\/\/ 2. If both `key` and `alt` exist. `key` is used in encoding,\n-\/\/\/    and `alt` is used in calculation.\n+\/\/\/ 1. If only `key` is present, it is used for both encoding and computations.\n+\/\/\/ 2. If both `key` and `transformed` are available, `key` is used for encoding,\n+\/\/\/    and `transformed` is used for computations.\n@@ -60,4 +63,2 @@\n-\/\/\/ This allows ML-KEM or ML-DSA to encode the seed used in key pair\n-\/\/\/ generation as the private key. In this case, `alt` will be the\n-\/\/\/ expanded key as described in the FIPS documents. If the seed is\n-\/\/\/ lost, `key` will be the expanded key and `alt` will be null.\n+\/\/\/ For algorithms that do not define a transformed key format, only `key` is\n+\/\/\/ included, and `transformed` must be `null`.\n@@ -65,2 +66,9 @@\n-\/\/\/ For algorithms that do not have this \"alternative\" key format,\n-\/\/\/ only `key` will be included and `alt` must be `null`.\n+\/\/\/ Note: When a transformed format is not defined, `key` and `transformed`\n+\/\/\/ may hold the same value. However, subtle differences can arise depending\n+\/\/\/ on if they are the same object. To avoid ambiguity, always set `transformed`\n+\/\/\/ to `null`.\n+\/\/\/\n+\/\/\/ The encoding in `NamedPKCS8Key` differs from that of XDH and EdDSA keys.\n+\/\/\/ While `key` is always placed inside an `OneAsymmetricKey` structure as an\n+\/\/\/ OCTET STRING , for XDH and EdDSA, the `key` field itself is an OCTET STRING.\n+\/\/\/ `NamedPKCS8Key` treats `key` as a generic opaque byte array.\n@@ -75,1 +83,1 @@\n-    private final byte[] alt;\n+    private final transient byte[] transformed;\n@@ -79,1 +87,1 @@\n-    \/\/\/ Ctor from raw key bytes.\n+    \/\/\/ Creates a `NamedPKCS8Key` from raw key bytes.\n@@ -81,1 +89,1 @@\n-    \/\/\/ `rawBytes` and `alt` won't be cloned, caller\n+    \/\/\/ `rawBytes` and `transformed` won't be cloned, caller\n@@ -87,2 +95,2 @@\n-    \/\/\/ @param alt alternative key format, can be `null`.\n-    public NamedPKCS8Key(String fname, String pname, byte[] rawBytes, byte[] alt) {\n+    \/\/\/ @param transformed transformed key format, can be `null`.\n+    public NamedPKCS8Key(String fname, String pname, byte[] rawBytes, byte[] transformed) {\n@@ -91,1 +99,1 @@\n-        this.alt = alt;\n+        this.transformed = transformed;\n@@ -100,1 +108,1 @@\n-    \/\/\/ Ctor from family name and PKCS #8 encoding\n+    \/\/\/ Creates a `NamedPKCS8Key` from family name and PKCS #8 encoding.\n@@ -105,5 +113,6 @@\n-    \/\/\/ @param genAlt a function that is able to calculate the alternative\n-    \/\/\/     key from raw key inside `encoded`. In the case of seed\/expanded,\n-    \/\/\/     the function will calculate expanded from seed. If it recognizes\n-    \/\/\/     the input being already the expanded key, it must return `null`.\n-    \/\/\/     If there is no alternative key format, `getAlt` must be `null`.\n+    \/\/\/ @param transform a function that is able to calculate the transformed\n+    \/\/\/     format from the base format inside `encoded`. If it recognizes\n+    \/\/\/     the input already in transformed format, it must return `null`.\n+    \/\/\/     If there is no transformed key format, `transform` must be `null`.\n+    \/\/\/     Whatever the case, the ownership of the result is fully granted\n+    \/\/\/     to this `NamedPKCS8Key` object.\n@@ -111,1 +120,1 @@\n-            BiFunction<String, byte[], byte[]> genAlt) throws InvalidKeyException {\n+            BiFunction<String, byte[], byte[]> transform) throws InvalidKeyException {\n@@ -114,1 +123,1 @@\n-        this.alt = genAlt == null ? null : genAlt.apply(algid.getName(), this.key);\n+        this.transformed = transform == null ? null : transform.apply(algid.getName(), this.key);\n@@ -129,1 +138,1 @@\n-    \/\/\/ the content or keep a reference.\n+    \/\/\/ the content or pass the reference to untrusted application code.\n@@ -134,14 +143,5 @@\n-    \/\/\/ Returns the reference to the key that will be used in computations\n-    \/\/\/ inside `NamedKEM` or `NamedSignature` between `alt` (if exists)\n-    \/\/\/ and `key`.\n-    \/\/\/\n-    \/\/\/ This method currently simply chooses the longer one, where it is the\n-    \/\/\/ expanded format. If the key used in computations is not the longer\n-    \/\/\/ one for an algorithm, consider adding overridable methods to\n-    \/\/\/ `NamedKEM` and `NamedSignature` to extract it.\n-    public byte[] getExpanded() {\n-        if (alt == null) {\n-            return key;\n-        } else {\n-            return alt.length > key.length ? alt : key;\n-        }\n+    \/\/\/ Returns the reference to the key that will be used in computations.\n+    \/\/\/ Caller must not modify the content or pass the reference to untrusted\n+    \/\/\/ application code.\n+    public byte[] getTransformed() {\n+        return transformed == null ? key : transformed;\n@@ -170,2 +170,2 @@\n-        if (alt != null) {\n-            Arrays.fill(alt, (byte)0);\n+        if (transformed != null) {\n+            Arrays.fill(transformed, (byte)0);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/NamedPKCS8Key.java","additions":43,"deletions":43,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.security.util.DerValue;\n@@ -30,0 +31,1 @@\n+import java.io.IOException;\n@@ -35,1 +37,1 @@\n-    public static byte[] seedToExpandedPrivate(String pname, byte[] seed) {\n+    public static byte[] seedToTransformed(String pname, byte[] seed) {\n@@ -37,1 +39,6 @@\n-        return impl.skEncode(impl.generateKeyPairInternal(seed).privateKey());\n+        var sk = impl.generateKeyPairInternal(seed).privateKey();\n+        try {\n+            return impl.skEncode(sk);\n+        } finally {\n+            sk.destroy();\n+        }\n@@ -122,3 +129,9 @@\n-        protected byte[] implGenAlt(String name, byte[] key) {\n-            if (key.length == 32) {\n-                return seedToExpandedPrivate(name, key);\n+        protected byte[] implTransform(String name, byte[] input) {\n+            if (input.length == 32) { \/\/ seed\n+                return seedToTransformed(name, input);\n+            } else if (input.length > 1 && input[0] == 4) { \/\/ jdk24\n+                try {\n+                    return new DerValue(input).getOctetString();\n+                } catch (IOException e) {\n+                    return null;\n+                }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/ML_DSA_Impls.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-        var sk = nk.getExpanded();\n+        var sk = nk.getTransformed();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKEM.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-public abstract class NamedKeyFactory extends KeyFactorySpi {\n+public class NamedKeyFactory extends KeyFactorySpi {\n@@ -132,1 +132,1 @@\n-                return new NamedPKCS8Key(fname, pnames[0], raw, implGenAlt(pnames[0], raw));\n+                return new NamedPKCS8Key(fname, pnames[0], raw, implTransform(pnames[0], raw));\n@@ -140,1 +140,1 @@\n-                return new NamedPKCS8Key(fname, pnames[0], raw, implGenAlt(pnames[0], raw));\n+                return new NamedPKCS8Key(fname, pnames[0], raw, implTransform(pnames[0], raw));\n@@ -151,1 +151,1 @@\n-        var k = new NamedPKCS8Key(fname, bytes, this::implGenAlt);\n+        var k = new NamedPKCS8Key(fname, bytes, this::implTransform);\n@@ -256,1 +256,1 @@\n-                        ? new NamedPKCS8Key(fname, name, raw, implGenAlt(name, raw))\n+                        ? new NamedPKCS8Key(fname, name, raw, implTransform(name, raw))\n@@ -281,1 +281,1 @@\n-    \/\/\/ User-defined function to generate the alternative key inside\n+    \/\/\/ User-defined function to generate the transformed format of\n@@ -284,4 +284,9 @@\n-    \/\/\/ This method will be called when the key factory is constructing\n-    \/\/\/ a private key. If the input `key` is a seed, the expanded key must\n-    \/\/\/ be returned. If `key` is in expanded format, `null` must be returned.\n-    protected abstract byte[] implGenAlt(String name, byte[] key);\n+    \/\/\/ This method is called when the key factory is constructing a private\n+    \/\/\/ key. If `input` is in base format, the transformed key must be returned.\n+    \/\/\/ If `input` is in transformed format, `null` must be returned. Whatever\n+    \/\/\/ the case, the ownership of the result is fully granted to the caller.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    protected byte[] implTransform(String name, byte[] input) {\n+        return null;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyFactory.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -97,6 +97,12 @@\n-\/\/\/ If the private key of an algorithm can be encoded in two formats, the\n-\/\/\/ encoded format will be the `key` of the `NamedPKCS8Key`, and the other\n-\/\/\/ format will be the `alt` field. When there are two formats (for example,\n-\/\/\/ \"seed\" and \"expanded\"), the [#implGenerateKeyPair] must return the encoding\n-\/\/\/ format as the 2nd element and the other format as the 3rd element. All\n-\/\/\/ calculations inside `NamedKEM` or `NamedSignature` use the \"other\" format.\n+\/\/\/ For some algorithms, the private key is encoded in a base format, but the\n+\/\/\/ computations use a transformed format. The [#implGenerateKeyPair] would\n+\/\/\/ return the base format as the 2nd element and the transformed format as the\n+\/\/\/ 3rd element. All computations inside `NamedKEM` or `NamedSignature` use the\n+\/\/\/ transformed format. The `NamedKeyFactory` must override the `implTransform`\n+\/\/\/ method to compute the transformed format from the base format.\n+\/\/\/\n+\/\/\/ If `implTransform` detects that the input is already in the transformed\n+\/\/\/ format, it indicates that the base format may have been lost, and it must\n+\/\/\/ return `null`. For maximum interoperability, it may also convert other\n+\/\/\/ formats into the transformed format. Note that `key` remains unchanged,\n+\/\/\/ so when re-encoded, it uses its original encoding format.\n@@ -181,1 +187,1 @@\n-    \/\/\/ @return the public key, the private key, and the alternative\n+    \/\/\/ @return the public key, the private key, and the transformed\n@@ -183,2 +189,2 @@\n-    \/\/\/         If there is no alternative format, the 3rd element\n-    \/\/\/         must be `null` or simply omitted.\n+    \/\/\/         If there is no transformed format, the 3rd element\n+    \/\/\/         must be omitted.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyPairGenerator.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-        secKey = nk.getExpanded();\n+        secKey = nk.getTransformed();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedSignature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-                        ML_DSA_Impls.seedToExpandedPrivate(pname, sk));\n+                        ML_DSA_Impls.seedToTransformed(pname, sk));\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_DSA_Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-                        ML_KEM_Impls.seedToExpandedPrivate(pname, sk));\n+                        ML_KEM_Impls.seedToTransformed(pname, sk));\n","filename":"test\/jdk\/sun\/security\/provider\/acvp\/ML_KEM_Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -132,5 +132,0 @@\n-\n-        @Override\n-        protected byte[] implGenAlt(String name, byte[] key) {\n-            return null;\n-        }\n","filename":"test\/jdk\/sun\/security\/provider\/named\/NamedEdDSA.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -240,5 +240,0 @@\n-\n-        @Override\n-        protected byte[] implGenAlt(String name, byte[] key) {\n-            return null;\n-        }\n","filename":"test\/jdk\/sun\/security\/provider\/named\/NamedKeyFactoryTest.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,135 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8347938 8347941\n- * @library \/test\/lib\n- * @modules java.base\/com.sun.crypto.provider\n- *          java.base\/sun.security.provider\n- *          java.base\/sun.security.util\n- * @summary check key reading compatibility\n- * @run main\/othervm SeedOrExpanded\n- *\/\n-\n-import com.sun.crypto.provider.ML_KEM_Impls;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.security.FixedSecureRandom;\n-import jdk.test.lib.security.SeededSecureRandom;\n-import sun.security.provider.ML_DSA_Impls;\n-import sun.security.util.DerOutputStream;\n-import sun.security.util.DerValue;\n-import sun.security.util.KnownOIDs;\n-import sun.security.util.ObjectIdentifier;\n-\n-import javax.crypto.KEM;\n-import java.security.KeyFactory;\n-import java.security.KeyPairGenerator;\n-import java.security.PrivateKey;\n-import java.security.Signature;\n-import java.security.spec.PKCS8EncodedKeySpec;\n-import java.util.Arrays;\n-\n-public class SeedOrExpanded {\n-\n-    static final SeededSecureRandom RAND = SeededSecureRandom.one();\n-\n-    public static void main(String[] args) throws Exception {\n-        test(\"ML-KEM-768\");\n-        test(\"ML-DSA-65\");\n-    }\n-\n-    static void test(String alg) throws Exception {\n-\n-        var seed = RAND.nBytes(alg.contains(\"ML-KEM\") ? 64 : 32);\n-        var g = KeyPairGenerator.getInstance(alg);\n-\n-        \/\/ Generation\n-\n-        g.initialize(-1, new FixedSecureRandom(seed));\n-        var kp = g.generateKeyPair();\n-        var kseed = kp.getPrivate().getEncoded();\n-\n-        var ex = alg.contains(\"ML-KEM\")\n-                ? ML_KEM_Impls.seedToExpandedPrivate(alg, seed)\n-                : ML_DSA_Impls.seedToExpandedPrivate(alg, seed);\n-        var kexpanded = new DerOutputStream().write(DerValue.tag_Sequence,\n-                new DerOutputStream().putInteger(0)\n-                        .write(DerValue.tag_Sequence, new DerOutputStream()\n-                                .putOID(ObjectIdentifier.of(KnownOIDs.findMatch(alg))))\n-                        .putOctetString(ex)).toByteArray();\n-\n-        \/\/ Seed encoding is usually shorter than expanded\n-        Asserts.assertTrue(kseed.length < kexpanded.length);\n-        Asserts.assertEqualsByteArray( \/\/ ... and encoding ends with seed\n-                Arrays.copyOfRange(kseed, kseed.length - seed.length, kseed.length),\n-                seed);\n-\n-        \/\/ Key loading\n-\n-        var f = KeyFactory.getInstance(alg);\n-        var sk1 = f.generatePrivate(new PKCS8EncodedKeySpec(kseed));\n-        var sk2 = f.generatePrivate(new PKCS8EncodedKeySpec(kexpanded));\n-        var sk3 = f.translateKey(new PrivateKey() {\n-            public String getAlgorithm() { return alg; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return seed.clone(); }\n-        });\n-        var sk4 = f.translateKey(new PrivateKey() {\n-            public String getAlgorithm() { return alg; }\n-            public String getFormat() { return \"RAW\"; }\n-            public byte[] getEncoded() { return ex.clone(); }\n-        });\n-        \/\/ Key factory never tries to reformat keys\n-        Asserts.assertEqualsByteArray(sk1.getEncoded(), kseed);\n-        Asserts.assertEqualsByteArray(sk2.getEncoded(), kexpanded);\n-        Asserts.assertEqualsByteArray(sk3.getEncoded(), kseed);\n-        Asserts.assertEqualsByteArray(sk4.getEncoded(), kexpanded);\n-\n-        \/\/ Key using\n-\n-        if (alg.contains(\"ML-KEM\")) {\n-            var kem = KEM.getInstance(\"ML-KEM\");\n-            var e = kem.newEncapsulator(kp.getPublic(), RAND);\n-            var enc = e.encapsulate();\n-            var k1 = kem.newDecapsulator(sk1).decapsulate(enc.encapsulation());\n-            var k2 = kem.newDecapsulator(sk2).decapsulate(enc.encapsulation());\n-            Asserts.assertEqualsByteArray(k1.getEncoded(), k2.getEncoded());\n-            Asserts.assertEqualsByteArray(k1.getEncoded(), enc.key().getEncoded());\n-        } else {\n-            var s = Signature.getInstance(\"ML-DSA\");\n-            var rnd = RAND.nBytes(32); \/\/ randomness for signature generation\n-            var msg = RAND.nBytes(20);\n-            s.initSign(sk1, new FixedSecureRandom(rnd));\n-            s.update(msg);\n-            var sig1 = s.sign();\n-            s.initSign(sk2, new FixedSecureRandom(rnd));\n-            s.update(msg);\n-            var sig2 = s.sign();\n-            Asserts.assertEqualsByteArray(sig1, sig2);\n-            s.initVerify(kp.getPublic());\n-            s.update(msg);\n-            Asserts.assertTrue(s.verify(sig1));\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/provider\/pqc\/SeedOrExpanded.java","additions":0,"deletions":135,"binary":false,"changes":135,"status":"deleted"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8347938 8347941\n+ * @library \/test\/lib\n+ * @modules java.base\/com.sun.crypto.provider\n+ *          java.base\/sun.security.provider\n+ *          java.base\/sun.security.util\n+ * @summary check key reading compatibility\n+ * @run main\/othervm SeedOrTransformed\n+ *\/\n+\n+import com.sun.crypto.provider.ML_KEM_Impls;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.FixedSecureRandom;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.provider.ML_DSA_Impls;\n+import sun.security.util.DerOutputStream;\n+import sun.security.util.DerValue;\n+import sun.security.util.KnownOIDs;\n+import sun.security.util.ObjectIdentifier;\n+\n+import javax.crypto.KEM;\n+import java.security.KeyFactory;\n+import java.security.KeyPairGenerator;\n+import java.security.PrivateKey;\n+import java.security.Signature;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.Arrays;\n+\n+public class SeedOrTransformed {\n+\n+    static final SeededSecureRandom RAND = SeededSecureRandom.one();\n+\n+    public static void main(String[] args) throws Exception {\n+        test(\"ML-KEM-768\");\n+        test(\"ML-DSA-65\");\n+    }\n+\n+    static void test(String alg) throws Exception {\n+\n+        var seed = RAND.nBytes(alg.contains(\"ML-KEM\") ? 64 : 32);\n+        var g = KeyPairGenerator.getInstance(alg);\n+\n+        \/\/ Generation\n+\n+        g.initialize(-1, new FixedSecureRandom(seed));\n+        var kp = g.generateKeyPair();\n+        var encSeed = kp.getPrivate().getEncoded();\n+\n+        var ex = alg.contains(\"ML-KEM\")\n+                ? ML_KEM_Impls.seedToTransformed(alg, seed)\n+                : ML_DSA_Impls.seedToTransformed(alg, seed);\n+        var encTransformed = new DerOutputStream().write(DerValue.tag_Sequence,\n+                new DerOutputStream().putInteger(0)\n+                        .write(DerValue.tag_Sequence, new DerOutputStream()\n+                                .putOID(ObjectIdentifier.of(KnownOIDs.findMatch(alg))))\n+                        .putOctetString(ex))\n+                .toByteArray();\n+        var enc24 = new DerOutputStream().write(DerValue.tag_Sequence,\n+                new DerOutputStream().putInteger(0)\n+                        .write(DerValue.tag_Sequence, new DerOutputStream()\n+                                .putOID(ObjectIdentifier.of(KnownOIDs.findMatch(alg))))\n+                        .putOctetString(\n+                                new DerOutputStream().putOctetString(ex).toByteArray()))\n+                .toByteArray();\n+\n+        \/\/ Seed encoding is usually shorter than transformed\n+        Asserts.assertTrue(encSeed.length < encTransformed.length);\n+        Asserts.assertEqualsByteArray( \/\/ ... and encoding ends with seed\n+                Arrays.copyOfRange(encSeed, encSeed.length - seed.length, encSeed.length),\n+                seed);\n+\n+        \/\/ Key loading\n+\n+        var f = KeyFactory.getInstance(alg);\n+        var sk1 = f.generatePrivate(new PKCS8EncodedKeySpec(encSeed));\n+        var sk2 = f.generatePrivate(new PKCS8EncodedKeySpec(encTransformed));\n+        var sk24 = f.generatePrivate(new PKCS8EncodedKeySpec(enc24));\n+        var sk3 = f.translateKey(new PrivateKey() {\n+            public String getAlgorithm() { return alg; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return seed.clone(); }\n+        });\n+        var sk4 = f.translateKey(new PrivateKey() {\n+            public String getAlgorithm() { return alg; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return ex.clone(); }\n+        });\n+        \/\/ Key factory never tries to reformat keys\n+        Asserts.assertEqualsByteArray(sk1.getEncoded(), encSeed);\n+        Asserts.assertEqualsByteArray(sk2.getEncoded(), encTransformed);\n+        Asserts.assertEqualsByteArray(sk24.getEncoded(), enc24);\n+        Asserts.assertEqualsByteArray(sk3.getEncoded(), encSeed);\n+        Asserts.assertEqualsByteArray(sk4.getEncoded(), encTransformed);\n+\n+        \/\/ Key using\n+\n+        if (alg.contains(\"ML-KEM\")) {\n+            var kem = KEM.getInstance(\"ML-KEM\");\n+            var e = kem.newEncapsulator(kp.getPublic(), RAND);\n+            var enc = e.encapsulate();\n+            var k1 = kem.newDecapsulator(sk1).decapsulate(enc.encapsulation());\n+            var k2 = kem.newDecapsulator(sk2).decapsulate(enc.encapsulation());\n+            var k24 = kem.newDecapsulator(sk24).decapsulate(enc.encapsulation());\n+            Asserts.assertEqualsByteArray(k1.getEncoded(), k2.getEncoded());\n+            Asserts.assertEqualsByteArray(k1.getEncoded(), k24.getEncoded());\n+            Asserts.assertEqualsByteArray(k1.getEncoded(), enc.key().getEncoded());\n+        } else {\n+            var s = Signature.getInstance(\"ML-DSA\");\n+            var rnd = RAND.nBytes(32); \/\/ randomness for signature generation\n+            var msg = RAND.nBytes(20);\n+            s.initSign(sk1, new FixedSecureRandom(rnd));\n+            s.update(msg);\n+            var sig1 = s.sign();\n+            s.initSign(sk2, new FixedSecureRandom(rnd));\n+            s.update(msg);\n+            var sig2 = s.sign();\n+            s.initSign(sk24, new FixedSecureRandom(rnd));\n+            s.update(msg);\n+            var sig24 = s.sign();\n+            Asserts.assertEqualsByteArray(sig1, sig2);\n+            Asserts.assertEqualsByteArray(sig1, sig24);\n+            s.initVerify(kp.getPublic());\n+            s.update(msg);\n+            Asserts.assertTrue(s.verify(sig1));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/pqc\/SeedOrTransformed.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"}]}