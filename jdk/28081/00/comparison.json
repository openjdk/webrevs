{"files":[{"patch":"@@ -0,0 +1,699 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.invoke;\n+\n+\/**\n+ * Methods corresponding to operators on primitive types in the Java\n+ * programming language or instructions operating on primitive types in\n+ * the Java virtual machine.\n+ *\n+ * @see java.lang.runtime.ExactConversionsSupport\n+ * @see java.util.Objects#isNull(Object)\n+ * @see java.util.Objects#nonNull(Object)\n+ *\n+ * @jls 4.2.2 Integer Operations\n+ * @jls 4.2.4 Floating-Point Operations\n+ *\/\n+public class Operators {\n+    private  Operators(){throw new AssertionError(\"No Operators instances for you\");}\n+\n+    \/*\n+     * Quoting from JLS:\n+     *\n+     * 4.2.2. Integer Operations\n+     *\n+     * The Java programming language provides a number of operators that act on integral values:\n+     *\n+     * * The comparison operators, which result in a value of type boolean:\n+     *   * The numerical comparison operators <, <=, >, and >= (&sect;15.20.1)\n+     *   * The numerical equality operators == and != (&sect;15.21.1)\n+     * * The numerical operators, which result in a value of type int or long:\n+     *   * The unary plus and minus operators + and - (&sect;15.15.3, &sect;15.15.4)\n+     *   * The multiplicative operators *, \/, and % (&sect;15.17)\n+     *   * The additive operators + and - (&sect;15.18)\n+     *   * The increment operator ++, both prefix (&sect;15.15.1) and postfix (&sect;15.14.2)\n+     *   * The decrement operator --, both prefix (&sect;15.15.2) and postfix (&sect;15.14.3)\n+     *   * The signed and unsigned shift operators <<, >>, and >>> (&sect;15.19)\n+     *   * The bitwise complement operator ~ (&sect;15.15.5)\n+     *   * The integer bitwise operators &, ^, and | (&sect;15.22.1)\n+     *   * The conditional operator ? : (&sect;15.25)\n+     *   * The cast operator (&sect;15.16), which can convert from an\n+     *     integral value to a value of any specified numeric type\n+     *\/\n+\n+    \/\/ Comparison operators\n+\n+    \/**\n+     * {@return whether or not the first argument is less than the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code <} operator on {@code int} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static boolean lessThan(int a, int b) {return a < b;}\n+\n+    \/**\n+     * {@return whether or not the first argument is less than or\n+     * equal to the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code <=} operator on {@code int} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static boolean lessThanEqual(int a, int b) {return a <= b;}\n+\n+    \/**\n+     * {@return whether or not the first argument is greater than the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code >} operator on {@code int} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static boolean greaterThan(int a, int b) {return a > b;}\n+\n+    \/**\n+     * {@return whether or not the first argument is greater than or\n+     * equal to the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code <=} operator on {@code int} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static boolean greaterThanEqual(int a, int b) {return a >= b;}\n+\n+    \/\/ icomp\n+\n+    \/**\n+     * {@return whether or not the first argument is equal to the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code ==} operator on {@code int} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static boolean equal(int a, int b) {return a == b;}\n+\n+    \/**\n+     * {@return whether or not the first argument is not equal to the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code !=} operator on {@code int} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static boolean notEqual(int a, int b) {return a != b;}\n+\n+    \/\/ Numerical operators\n+\n+    \/**\n+     * {@return the unary plus of the argument}\n+     *\n+     * @implSpec\n+     * This method wraps the unary {@code +} operator on {@code int} augment.\n+     *\n+     * @param a the argument\n+     *\/\n+    public static int plus(int a) {return +a;} \/\/ Just for completeness; don't need this.\n+\n+    \/**\n+     * {@return the unary negation of the argument}\n+     *\n+     * @implSpec\n+     * This method wraps the unary {@code -} operator on {@code int} augment.\n+     *\n+     * @param a the argument\n+     *\/\n+    public static int negate(int a) {return -a;}\n+\n+    \/\/ Multiplicative operators\n+\n+    \/**\n+     * {@return the product of the two operands}\n+     *\n+     * @implSpec\n+     * This method wraps the binary {@code *} operator on {@code int} augments.\n+     *\n+     * @param multiplier the first operand\n+     * @param multiplicand the second operand\n+     *\/\n+    public static int multiply(int multiplier, int multiplicand) {return multiplier * multiplicand;}\n+\n+    \/**\n+     * {@return the quotient of the two operands}\n+     *\n+     * @implSpec\n+     * This method wraps the binary {@code \/} operator on {@code int} augments.\n+     *\n+     * @param dividend the first operand\n+     * @param divisor the second operand\n+     *\/\n+    public static int divide(int dividend, int divisor) {return dividend \/ divisor;}\n+\n+    \/**\n+     * {@return the remainder of the two operands}\n+     *\n+     * @implSpec\n+     * This method wraps the binary {@code %} operator on {@code int} augments.\n+     *\n+     * @param dividend the first operand\n+     * @param divisor the second operand\n+     *\/\n+    public static int remainder(int dividend, int divisor) {return dividend % divisor;}\n+\n+\n+    \/\/ Additive operators\n+\n+    \/**\n+     * {@return the sum of the two operands}\n+     *\n+     * @implSpec\n+     * This method wraps the binary {@code +} operator on {@code int} augments.\n+     *\n+     * @param addend the first operand\n+     * @param augend the second operand\n+     *\/\n+    public static int add(int addend, int augend) {return addend + augend;}\n+\n+    \/**\n+     * {@return the difference of the two operands}\n+     *\n+     * @implSpec\n+     * This method wraps the binary {@code -} operator on {@code int} augments.\n+     *\n+     * @param minuend the first operand\n+     * @param subtrahend the second operand\n+     *\/\n+    public static int substract(int minuend, int subtrahend) {return minuend - subtrahend;}\n+\n+    \/\/ Increment\/decrement operators\n+\n+    \/**\n+     * {@return the operand incremented by 1}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code ++} operator on an {@code int} augment.\n+     *\n+     * @param a the operand\n+     *\/\n+    public static int increment(int a) {return a++;}\n+\n+    \/**\n+     * {@return the operand incremented by 1}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code --} operator on an {@code int} augment.\n+     *\n+     * @param a the operand\n+     *\/\n+    public static int decrement(int a) {return a--;}\n+\n+    \/\/ Shift operators\n+\n+    \/**\n+     * {@return the first argument left shifted by the shift distance of the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code >>} operator on {@code int} augments.\n+     *\n+     * @param a the first argument\n+     * @param shiftDistance shift distance in bits\n+     *\/\n+    public static int shiftLeft(int a, int shiftDistance) {return a << shiftDistance;}\n+\n+    \/**\n+     * {@return the first argument right shifted by the shift distance of the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code >>} operator on {@code int} augments.\n+     *\n+     * @param a the first argument\n+     * @param shiftDistance shift distance in bits\n+     *\/\n+    public static int shiftRight(int a, int shiftDistance) {return a >> shiftDistance;}\n+\n+    \/**\n+     * {@return the first argument unsigned right shifted by the shift distance of the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code >>>} operator on {@code int} augments.\n+     *\n+     * @param a the first argument\n+     * @param shiftDistance shift distance in bits\n+     *\/\n+    public static int shiftRightUnsigned(int a, int shiftDistance) {return a >>> shiftDistance;}\n+\n+\n+    \/\/ Bitwise operators\n+\n+    \/**\n+     * {@return the complement of the argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code ~} operator applied to the {@code int} augment.\n+     *\n+     * @param a the argument\n+     *\/\n+    public static int complement(int a) {return ~a;}\n+\n+    \/**\n+     * {@return the arguments AND'ed together}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code &} operator on {@code int} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static int and(int a, int b) {return a & b;}\n+\n+    \/**\n+     * {@return the arguments OR'ed together}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code |} operator on {@code int} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static int or(int a, int b) {return a | b;}\n+\n+    \/**\n+     * {@return the arguments XOR'ed together}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code ^} operator on {@code int} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static int xor(int a, int b) {return a ^ b;}\n+\n+\n+    \/\/ casting -- i2b, i2c, i2d, i2f, i2l, i2s\n+\n+    \/**\n+     * {@return the result of casting the argument to {@code byte}}\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code i2b} JVM instruction.\n+     *\n+     * @param a the argument to convert to {@code byte}\n+     *\/\n+    public static byte i2b(int a)   {return (byte)  a;}\n+\n+    \/**\n+     * {@return the result of casting the argument to {@code char}}\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code i2c} JVM instruction.\n+     *\n+     * @param a the argument to convert to {@code char}\n+     *\/\n+    public static char i2c(int a)   {return (char)  a;}\n+\n+    \/**\n+     * {@return the result of casting the argument to {@code double}}\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code i2d} JVM instruction.\n+     *\n+     * @param a the argument to convert to {@code double}\n+     *\/\n+    public static double i2d(int a) {return (double)a;}\n+\n+    \/**\n+     * {@return the result of casting the argument to {@code float}}\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code i2f} JVM instruction.\n+     *\n+     * @param a the argument to convert to {@code float}\n+     *\/\n+    public static float i2f(int a)  {return (float) a;}\n+\n+    \/**\n+     * {@return the result of casting the argument to {@code long}}\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code i2l} JVM instruction.\n+     *\n+     * @param a the argument to convert to {@code long}\n+     *\/\n+    public static long i2l(int a)   {return (long)  a;}\n+\n+    \/**\n+     * {@return the result of indexing into the argument array}\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code iaload} JVM instruction.\n+     *\n+     * @param array the argument to convert to index into\n+     * @param index the index\n+     *\/\n+    public static int iaload(int[] array, int index) {return array[index];}\n+\n+    \/**\n+     * Store a value into the specified index of the argument array.\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code iastore} JVM instruction.\n+     *\n+     * @param array the argument to convert to index into\n+     * @param index the index\n+     * @param value the value to store into the aray\n+     *\/\n+    public static void iastore(int[] array, int index, int value) {array[index] = value; }\n+\n+    \/\/ TODO add methods for long\n+    \/\/ casting -- l2d, l2f, l2i\n+\n+    \/\/ Floating-point\n+\n+    \/*\n+     * Quoting from JLS:\n+     *\n+     * The Java programming language provides a number of operators that act on floating-point values:\n+     *\n+     * * The comparison operators, which result in a value of type boolean:\n+     *   * The numerical comparison operators <, <=, >, and >= (&sect;15.20.1)\n+     *   * The numerical equality operators == and != (&sect;15.21.1)\n+     * * The numerical operators, which result in a value of type float or double:\n+     *   * The unary plus and minus operators + and - (&sect;15.15.3, &sect;15.15.4)\n+     *   * The multiplicative operators *, \/, and % (&sect;15.17)\n+     *   * The additive operators + and - (&sect;15.18.2)\n+     *   * The increment operator ++, both prefix (&sect;15.15.1) and postfix (&sect;15.14.2)\n+     *   * The decrement operator --, both prefix (&sect;15.15.2) and postfix (&sect;15.14.3)\n+     * * The conditional operator ? : (&sect;15.25)\n+     * * The cast operator (&sect;15.16), which can convert from a\n+     *   floating-point value to a value of any specified numeric type\n+     * * The string concatenation operator + (&sect;15.18.1), which, when\n+     *   given a String operand and a floating-point operand, will\n+     *   convert the floating-point operand to a String representing\n+     *   its value in decimal form (without information loss), and\n+     *   then produce a newly created String by concatenating the two\n+     *   strings\n+     *\/\n+\n+    \/\/ Comparison operators\n+\n+    \/**\n+     * {@return whether or not the first argument is less than the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code <} operator on {@code float} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static boolean lessThan(float a, float b) {return a < b;}\n+\n+    \/**\n+     * {@return whether or not the first argument is less than or\n+     * equal to the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code <=} operator on {@code float} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static boolean lessThanEqual(float a, float b) {return a <= b;}\n+\n+    \/**\n+     * {@return whether or not the first argument is greater than the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code >} operator on {@code float} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static boolean greaterThan(float a, float b) {return a > b;}\n+\n+    \/**\n+     * {@return whether or not the first argument is greater than or\n+     * equal to the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code <=} operator on {@code float} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static boolean greaterThanEqual(float a, float b) {return a >= b;}\n+\n+    \/**\n+     * {@return whether or not the first argument is equal to the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code ==} operator on {@code float} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static boolean equal(float a, float b) {return a == b;}\n+\n+    \/**\n+     * {@return whether or not the first argument is not equal to the second argument}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code !=} operator on {@code float} augments.\n+     *\n+     * @param a the first argument\n+     * @param b the second argument\n+     *\/\n+    public static boolean notEqual(float a, float b) {return a != b;}\n+\n+    \/\/ Include fcompg, fcompl?\n+\n+    \/\/ Numerical operators\n+\n+    \/**\n+     * {@return the unary plus of the argument}\n+     *\n+     * @implSpec\n+     * This method wraps the unary {@code +} operator on {@code float} augment.\n+     *\n+     * @param a the argument\n+     *\/\n+    public static float plus(float a) {return +a;} \/\/ Just for completeness; don't need this.\n+\n+    \/**\n+     * {@return the unary negation of the argument}\n+     *\n+     * @implSpec\n+     * This method wraps the unary {@code -} operator on {@code float} augment.\n+     *\n+     * @param a the argument\n+     *\/\n+    public static float negate(float a) {return -a;}\n+\n+    \/\/ Multiplicative operators\n+\n+    \/**\n+     * {@return the product of the two operands}\n+     *\n+     * @implSpec\n+     * This method wraps the binary {@code *} operator on {@code float} augments.\n+     *\n+     * @param multiplier the first operand\n+     * @param multiplicand the second operand\n+     *\/\n+    public static float multiply(float multiplier, float multiplicand) {return multiplier * multiplicand;}\n+\n+    \/**\n+     * {@return the quotient of the two operands}\n+     *\n+     * @implSpec\n+     * This method wraps the binary {@code \/} operator on {@code float} augments.\n+     *\n+     * @param dividend the first operand\n+     * @param divisor the second operand\n+     *\/\n+    public static float divide(float dividend, float divisor) {return dividend \/ divisor;}\n+\n+    \/**\n+     * {@return the remainder of the two operands}\n+     *\n+     * @implSpec\n+     * This method wraps the binary {@code %} operator on {@code float} augments.\n+     *\n+     * @param dividend the first operand\n+     * @param divisor the second operand\n+     *\/\n+    public static float remainder(float dividend, float divisor) {return dividend % divisor;}\n+\n+\n+    \/\/ Additive operators\n+\n+    \/**\n+     * {@return the sum of the two operands}\n+     *\n+     * @implSpec\n+     * This method wraps the binary {@code +} operator on {@code float} augments.\n+     *\n+     * @param addend the first operand\n+     * @param augend the second operand\n+     *\/\n+    public static float add(float addend, float augend) {return addend + augend;}\n+\n+    \/**\n+     * {@return the difference of the two operands}\n+     *\n+     * @implSpec\n+     * This method wraps the binary {@code -} operator on {@code float} augments.\n+     *\n+     * @param minuend the first operand\n+     * @param subtrahend the second operand\n+     *\/\n+    public static float substract(float minuend, float subtrahend) {return minuend - subtrahend;}\n+\n+    \/\/ Increment\/decrement operators\n+\n+    \/**\n+     * {@return the operand incremented by 1}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code ++} operator on an {@code float} augment.\n+     *\n+     * @param a the operand\n+     *\/\n+    public static float increment(float a) {return a++;}\n+\n+    \/**\n+     * {@return the operand incremented by 1}\n+     *\n+     * @implSpec\n+     * This method wraps the {@code --} operator on an {@code float} augment.\n+     *\n+     * @param a the operand\n+     *\/\n+    public static float decrement(float a) {return a--;}\n+\n+    \/\/ casting -- f2d, f2i, f2l\n+\n+    \/**\n+     * {@return the result of casting the argument to {@code double}}\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code f2d} JVM instruction.\n+     *\n+     * @param a the argument to convert to {@code double}\n+     *\/\n+    public static double f2d(float a) {return (double)a;}\n+\n+    \/**\n+     * {@return the result of casting the argument to {@code int}}\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code f2i} JVM instruction.\n+     *\n+     * @param a the argument to convert to {@code int}\n+     *\/\n+    public static int f2i(float a)   {return (int)    a;}\n+\n+    \/**\n+     * {@return the result of casting the argument to {@code long}}\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code f2l} JVM instruction.\n+     *\n+     * @param a the argument to convert to {@code long}\n+     *\/\n+    public static long f2l(float a)   {return (long)  a;}\n+\n+    \/**\n+     * {@return the result of indexing into the argument array}\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code faload} JVM instruction.\n+     *\n+     * @param array the argument to convert to index into\n+     * @param index the index\n+     *\/\n+    public static float faload(float[] array, int index) {return array[index];}\n+\n+    \/**\n+     * Store a value into the specified index of the argument array.\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code fastore} JVM instruction.\n+     *\n+     * @param array the argument to convert to index into\n+     * @param index the index\n+     * @param value the value to store into the aray\n+     *\/\n+    public static void fastore(float[] array, int index, float value) {array[index] = value; }\n+\n+\n+    \/\/ TODO add methods for double\n+    \/\/ casting -- d2f, d2i, d2l\n+\n+    \/\/ Instructions\n+\n+    \/**\n+     * Throw the argument; does not return normally.\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code athrow} JVM instruction.\n+     *\n+     * @param t the throwable to throw\n+     * @throws Throwable unconditionally\n+     *\/\n+    public static void athrow(Throwable t) throws Throwable {\n+        throw t;\n+    }\n+\n+    \/\/ Instructions that don't have primitive operators\n+\n+    \/\/ arraylength  -- add all the overloads? int[], ..., Object[]\n+\n+    \/\/ checkcast\n+\n+    \/\/ ifnonnnull -- see Objects::nonNull\n+\n+    \/\/ ifnull -- see Objects::isNull\n+\n+    \/\/ instanceof\n+\n+    \/**\n+     * No-operation.\n+     *\n+     * @apiNote\n+     * This method corresponds to the {@code nop} JVM instruction.\n+     *\/\n+    public void nop() {return;}\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Operators.java","additions":699,"deletions":0,"binary":false,"changes":699,"status":"added"}]}