{"files":[{"patch":"@@ -187,0 +187,1 @@\n+  NoJvmtiEventsMark njem;\n","filename":"src\/hotspot\/share\/cds\/aotStreamedHeapLoader.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  thread->toggle_is_disable_suspend();\n+  thread->disable_jvmti_events();\n","filename":"src\/hotspot\/share\/cds\/aotThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3162,6 +3162,1 @@\n-\/\/ Disable collection of VMObjectAlloc events\n-NoJvmtiVMObjectAllocMark::NoJvmtiVMObjectAllocMark() : _collector(nullptr) {\n-  \/\/ a no-op if VMObjectAlloc event is not enabled\n-  if (!JvmtiExport::should_post_vm_object_alloc()) {\n-    return;\n-  }\n+NoJvmtiEventsMark::NoJvmtiEventsMark() {\n@@ -3171,9 +3166,1 @@\n-    JvmtiThreadState *state = current_thread->jvmti_thread_state();\n-    if (state != nullptr) {\n-      JvmtiVMObjectAllocEventCollector *collector;\n-      collector = state->get_vm_object_alloc_event_collector();\n-      if (collector != nullptr && collector->is_enabled()) {\n-        _collector = collector;\n-        _collector->set_enabled(false);\n-      }\n-    }\n+    current_thread->disable_jvmti_events();\n@@ -3183,4 +3170,5 @@\n-\/\/ Re-Enable collection of VMObjectAlloc events (if previously enabled)\n-NoJvmtiVMObjectAllocMark::~NoJvmtiVMObjectAllocMark() {\n-  if (was_enabled()) {\n-    _collector->set_enabled(true);\n+NoJvmtiEventsMark::~NoJvmtiEventsMark() {\n+  Thread* thread = Thread::current_or_null();\n+  if (thread != nullptr && thread->is_Java_thread())  {\n+    JavaThread* current_thread = JavaThread::cast(thread);\n+    current_thread->enable_jvmti_events();\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -588,19 +588,2 @@\n-\/\/ Marker class to disable the posting of VMObjectAlloc events\n-\/\/ within its scope.\n-\/\/\n-\/\/ Usage :-\n-\/\/\n-\/\/ {\n-\/\/   NoJvmtiVMObjectAllocMark njm;\n-\/\/   :\n-\/\/   \/\/ VMObjAlloc event will not be posted\n-\/\/   JvmtiExport::vm_object_alloc_event_collector(obj);\n-\/\/   :\n-\/\/ }\n-\n-class NoJvmtiVMObjectAllocMark : public StackObj {\n- private:\n-  \/\/ enclosing collector if enabled, null otherwise\n-  JvmtiVMObjectAllocEventCollector *_collector;\n-\n-  bool was_enabled()    { return _collector != nullptr; }\n+\/\/ Marker class to temporary disable posting of jvmti events.\n+class NoJvmtiEventsMark : public StackObj {\n@@ -609,2 +592,2 @@\n-  NoJvmtiVMObjectAllocMark() NOT_JVMTI_RETURN;\n-  ~NoJvmtiVMObjectAllocMark() NOT_JVMTI_RETURN;\n+  NoJvmtiEventsMark() NOT_JVMTI_RETURN;\n+  ~NoJvmtiEventsMark() NOT_JVMTI_RETURN;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -454,0 +454,1 @@\n+  _jvmti_events_disabled(0),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -328,0 +328,1 @@\n+  int                   _jvmti_events_disabled;          \/\/ JVMTI events disabled manually\n@@ -751,1 +752,1 @@\n-  void toggle_is_disable_suspend()               { _is_disable_suspend = !_is_disable_suspend; };\n+  void toggle_is_disable_suspend()               { _is_disable_suspend = !_is_disable_suspend; }\n@@ -754,1 +755,4 @@\n-  void toggle_is_in_java_upcall()                { _is_in_java_upcall = !_is_in_java_upcall; };\n+  void toggle_is_in_java_upcall()                { _is_in_java_upcall = !_is_in_java_upcall; }\n+\n+  void disable_jvmti_events()                    { _jvmti_events_disabled++; }\n+  void enable_jvmti_events()                     { _jvmti_events_disabled--; }\n@@ -763,1 +767,3 @@\n-  bool should_hide_jvmti_events() const          { return _is_in_VTMS_transition || _is_disable_suspend || _is_in_java_upcall; }\n+  bool should_hide_jvmti_events() const {\n+    return _is_in_VTMS_transition || _is_disable_suspend || _is_in_java_upcall || _jvmti_events_disabled != 0;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8372039\n+ * @summary The test verifies that object allocation sampling is disabled during AOT.\n+ *\n+ * Don't remove 'modules' line, it triggers the crash.\n+ * @modules java.management\n+ *\n+ * @run main\/othervm\/native -agentlib:SamplingDuringInit SamplingDuringInit\n+ * @run main\/othervm\/native -agentlib:SamplingDuringInit -XX:-UseCompressedOops SamplingDuringInit\n+ *\/\n+\n+public class SamplingDuringInit {\n+\n+    public static Object[] tmp = new Object[1000];\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Allocate some objects to trigger Sampling even if\n+        \/\/ all JDK classes are preloaded.\n+        for (int i = 0; i < tmp.length; i++) {\n+            tmp[i] = new String(\"tmp\" + i);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SampledObjectAlloc\/SamplingDuringInit\/SamplingDuringInit.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jvmti.h\"\n+#include \"jvmti_common.hpp\"\n+\n+#include <atomic>\n+\n+extern \"C\" {\n+\n+\/\/ SampledObjectAlloc event might be triggered on any thread\n+static std::atomic<int> events_counter(0);\n+\n+JNIEXPORT void JNICALL\n+SampledObjectAlloc(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jobject object, jclass object_klass, jlong size) {\n+  events_counter++;\n+  LOG(\"Sampled object, events_counter = %d\\n\", events_counter.load());\n+}\n+\n+void JNICALL\n+VMDeath(jvmtiEnv *jvmti, JNIEnv* jni) {\n+  if (events_counter == 0) {\n+    fatal(jni, \"SampledObjectAlloc events counter shouldn't be zero\");\n+  }\n+}\n+\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiEnv* jvmti = nullptr;\n+  jvmtiCapabilities caps;\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+  jint res;\n+\n+  LOG(\"AGENT INIT\");\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n+  if (res != JNI_OK || jvmti == nullptr) {\n+    LOG(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_generate_sampled_object_alloc_events = 1;\n+  if (jvmti->AddCapabilities(&caps) != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.SampledObjectAlloc = &SampledObjectAlloc;\n+  callbacks.VMDeath = &VMDeath;\n+\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  check_jvmti_error(err, \"SetEventCallbacks\");\n+  \/*\n+   * Interval should be small enough to triggger sampling event while objects are init by VM.\n+   *\/\n+  err = jvmti->SetHeapSamplingInterval(10);\n+  check_jvmti_error(err, \"SetHeapSamplingInterval\");\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, nullptr);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SAMPLED_OBJECT_ALLOC, nullptr);\n+  check_jvmti_error(err, \"SetEventNotificationMode\");\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SampledObjectAlloc\/SamplingDuringInit\/libSamplingDuringInit.cpp","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}