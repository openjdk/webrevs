{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,2 +99,0 @@\n-        --add-exports java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED \\\n-        --add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,0 @@\n-        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n-        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AbstractCorpusBenchmark.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,4 +38,0 @@\n-            \"ASM_1\",\n-            \"ASM_3\",\n-            \"ASM_UNSHARED_3\",\n-\/\/            \"ASM_TREE\",\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/AdaptNull.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,6 +32,0 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.tree.ClassNode;\n-import jdk.internal.org.objectweb.asm.tree.MethodNode;\n@@ -48,49 +42,0 @@\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public void asmStreamCountLoads(Blackhole bh) {\n-        for (byte[] bytes : classes) {\n-            ClassReader cr = new ClassReader(bytes);\n-\n-            var mv = new MethodVisitor(Opcodes.ASM9) {\n-                int count = 0;\n-\n-                @Override\n-                public void visitVarInsn(int opcode, int var) {\n-                    ++count;\n-                }\n-            };\n-\n-            var visitor = new ClassVisitor(Opcodes.ASM9) {\n-                @Override\n-                public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n-                    return mv;\n-                }\n-            };\n-            cr.accept(visitor, 0);\n-            bh.consume(mv.count);\n-        }\n-    }\n-\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public void asmTreeCountLoads(Blackhole bh) {\n-        for (byte[] bytes : classes) {\n-            var mv = new MethodVisitor(Opcodes.ASM9) {\n-                int count = 0;\n-\n-                @Override\n-                public void visitVarInsn(int opcode, int var) {\n-                    ++count;\n-                }\n-            };\n-\n-            ClassNode node = new ClassNode();\n-            ClassReader cr = new ClassReader(bytes);\n-            cr.accept(node, 0);\n-            for (MethodNode mn : node.methods) {\n-                mn.accept(mv);\n-            }\n-            bh.consume(mv.count);\n-        }\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ReadDeep.java","additions":1,"deletions":56,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n-import jdk.internal.org.objectweb.asm.tree.*;\n@@ -37,29 +35,0 @@\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public void asmStreamReadName(Blackhole bh) {\n-        for (byte[] bytes : classes) {\n-            ClassReader cr = new ClassReader(bytes);\n-            var  visitor = new ClassVisitor(Opcodes.ASM9) {\n-                String theName;\n-\n-                @Override\n-                public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-                    theName = name;\n-                }\n-            };\n-            cr.accept(visitor, 0);\n-            bh.consume(visitor.theName);\n-        }\n-    }\n-\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public void asmTreeReadName(Blackhole bh) {\n-        for (byte[] bytes : classes) {\n-            ClassNode node = new ClassNode();\n-            ClassReader cr = new ClassReader(bytes);\n-            cr.accept(node, 0);\n-            bh.consume(node.name);\n-        }\n-    }\n-\n@@ -93,37 +62,0 @@\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public void asmStreamCountFields(Blackhole bh) {\n-        for (byte[] bytes : classes) {\n-            ClassReader cr = new ClassReader(bytes);\n-            var visitor = new ClassVisitor(Opcodes.ASM9) {\n-                int count;\n-\n-                @Override\n-                public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n-                    if ((access & Opcodes.ACC_PUBLIC) != 1) {\n-                        ++count;\n-                    }\n-                    return null;\n-                }\n-            };\n-            cr.accept(visitor, 0);\n-            bh.consume(visitor.count);\n-        }\n-    }\n-\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public void asmTreeCountFields(Blackhole bh) {\n-        for (byte[] bytes : classes) {\n-            int count = 0;\n-            ClassNode node = new ClassNode();\n-            ClassReader cr = new ClassReader(bytes);\n-            cr.accept(node, 0);\n-            for (FieldNode fn : node.fields)\n-                if ((fn.access & Opcodes.ACC_PUBLIC) != 1) {\n-                    ++count;\n-                }\n-            bh.consume(count);\n-        }\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/ReadMetadata.java","additions":1,"deletions":69,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,13 +44,0 @@\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-import jdk.internal.org.objectweb.asm.Attribute;\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.FieldVisitor;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.ModuleVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.RecordComponentVisitor;\n-import jdk.internal.org.objectweb.asm.TypePath;\n-import jdk.internal.org.objectweb.asm.tree.ClassNode;\n@@ -63,2 +50,0 @@\n-    static int ASM9 = 9 << 16 | 0 << 8;\n-\n@@ -126,32 +111,0 @@\n-        ASM_1(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(cw, 0);\n-            return cw.toByteArray();\n-        }),\n-        ASM_UNSHARED_1(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(cw, 0);\n-            return cw.toByteArray();\n-        }),\n-        ASM_3(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(new CustomClassVisitor(cw), 0);\n-            return cw.toByteArray();\n-        }),\n-        ASM_UNSHARED_3(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(new CustomClassVisitor(cw), 0);\n-            return cw.toByteArray();\n-        }),\n-        ASM_TREE(bytes -> {\n-            ClassNode node = new ClassNode();\n-            ClassReader cr = new ClassReader(bytes);\n-            cr.accept(node, 0);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            node.accept(cw);\n-            return cw.toByteArray();\n-        }),\n@@ -189,6 +142,0 @@\n-        ASM_NOP_SHARED(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(new NopClassVisitor(cw), 0);\n-            return cw.toByteArray();\n-        }),\n@@ -229,7 +176,0 @@\n-        ASM_ADD_FIELD(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            cr.accept(cw, 0);\n-            cw.visitField(0, \"argleBargleWoogaWooga\", \"I\", null, null);\n-            return cw.toByteArray();\n-        }),\n@@ -260,14 +200,0 @@\n-        ASM_DEL_METHOD(bytes -> {\n-            ClassReader cr = new ClassReader(bytes);\n-            jdk.internal.org.objectweb.asm.ClassWriter cw = new jdk.internal.org.objectweb.asm.ClassWriter(cr, jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES);\n-            ClassVisitor v = new ClassVisitor(ASM9, cw) {\n-                @Override\n-                public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n-                    return (name.equals(\"hashCode\") && descriptor.equals(\"()Z\"))\n-                           ? null\n-                           : super.visitMethod(access, name, descriptor, signature, exceptions);\n-                }\n-            };\n-            cr.accept(cw, 0);\n-            return cw.toByteArray();\n-        }),\n@@ -306,273 +232,0 @@\n-    static class CustomClassVisitor extends ClassVisitor {\n-\n-        public CustomClassVisitor(ClassVisitor writer) {\n-            super(ASM9, writer);\n-        }\n-\n-        @Override\n-        public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-            super.visit(version, access, name, signature, superName, interfaces);\n-        }\n-\n-        @Override\n-        public void visitSource(String source, String debug) {\n-            super.visitSource(source, debug);\n-        }\n-\n-        @Override\n-        public ModuleVisitor visitModule(String name, int access, String version) {\n-            return super.visitModule(name, access, version);\n-        }\n-\n-        @Override\n-        public void visitNestHost(String nestHost) {\n-            super.visitNestHost(nestHost);\n-        }\n-\n-        @Override\n-        public void visitOuterClass(String owner, String name, String descriptor) {\n-            super.visitOuterClass(owner, name, descriptor);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n-            return super.visitAnnotation(descriptor, visible);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n-            return super.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitAttribute(Attribute attribute) {\n-            super.visitAttribute(attribute);\n-        }\n-\n-        @Override\n-        public void visitNestMember(String nestMember) {\n-            super.visitNestMember(nestMember);\n-        }\n-\n-        @Override\n-        public void visitInnerClass(String name, String outerName, String innerName, int access) {\n-            super.visitInnerClass(name, outerName, innerName, access);\n-        }\n-\n-        @Override\n-        public RecordComponentVisitor visitRecordComponent(String name, String descriptor, String signature) {\n-            return super.visitRecordComponent(name, descriptor, signature);\n-        }\n-\n-        @Override\n-        public FieldVisitor visitField(int access, String name, String descriptor, String signature, Object value) {\n-            return super.visitField(access, name, descriptor, signature, value);\n-        }\n-\n-        @Override\n-        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n-            MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n-            return new CustomMethodVisitor(mv);\n-        }\n-\n-        @Override\n-        public void visitEnd() {\n-            super.visitEnd();\n-        }\n-    };\n-\n-\n-    static class CustomMethodVisitor extends MethodVisitor {\n-\n-        public CustomMethodVisitor(MethodVisitor methodVisitor) {\n-            super(ASM9, methodVisitor);\n-        }\n-\n-        @Override\n-        public void visitParameter(String name, int access) {\n-            super.visitParameter(name, access);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotationDefault() {\n-            return super.visitAnnotationDefault();\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {\n-            return super.visitAnnotation(descriptor, visible);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitTypeAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n-            return super.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitAnnotableParameterCount(int parameterCount, boolean visible) {\n-            super.visitAnnotableParameterCount(parameterCount, visible);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitParameterAnnotation(int parameter, String descriptor, boolean visible) {\n-            return super.visitParameterAnnotation(parameter, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitAttribute(Attribute attribute) {\n-            super.visitAttribute(attribute);\n-        }\n-\n-        @Override\n-        public void visitCode() {\n-            super.visitCode();\n-        }\n-\n-        @Override\n-        public void visitFrame(int type, int numLocal, Object[] local, int numStack, Object[] stack) {\n-            super.visitFrame(type, numLocal, local, numStack, stack);\n-        }\n-\n-        @Override\n-        public void visitInsn(int opcode) {\n-            super.visitInsn(opcode);\n-        }\n-\n-        @Override\n-        public void visitIntInsn(int opcode, int operand) {\n-            super.visitIntInsn(opcode, operand);\n-        }\n-\n-        @Override\n-        public void visitVarInsn(int opcode, int var) {\n-            super.visitVarInsn(opcode, var);\n-        }\n-\n-        @Override\n-        public void visitTypeInsn(int opcode, String type) {\n-            super.visitTypeInsn(opcode, type);\n-        }\n-\n-        @Override\n-        public void visitFieldInsn(int opcode, String owner, String name, String descriptor) {\n-            super.visitFieldInsn(opcode, owner, name, descriptor);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"deprecation\")\n-        public void visitMethodInsn(int opcode, String owner, String name, String descriptor) {\n-            super.visitMethodInsn(opcode, owner, name, descriptor);\n-        }\n-\n-        @Override\n-        public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {\n-            super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n-        }\n-\n-        @Override\n-        public void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethodHandle, Object... bootstrapMethodArguments) {\n-            super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\n-        }\n-\n-        @Override\n-        public void visitJumpInsn(int opcode, Label label) {\n-            super.visitJumpInsn(opcode, label);\n-        }\n-\n-        @Override\n-        public void visitLabel(Label label) {\n-            super.visitLabel(label);\n-        }\n-\n-        @Override\n-        public void visitLdcInsn(Object value) {\n-            super.visitLdcInsn(value);\n-        }\n-\n-        @Override\n-        public void visitIincInsn(int var, int increment) {\n-            super.visitIincInsn(var, increment);\n-        }\n-\n-        @Override\n-        public void visitTableSwitchInsn(int min, int max, Label dflt, Label... labels) {\n-            super.visitTableSwitchInsn(min, max, dflt, labels);\n-        }\n-\n-        @Override\n-        public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {\n-            super.visitLookupSwitchInsn(dflt, keys, labels);\n-        }\n-\n-        @Override\n-        public void visitMultiANewArrayInsn(String descriptor, int numDimensions) {\n-            super.visitMultiANewArrayInsn(descriptor, numDimensions);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitInsnAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n-            return super.visitInsnAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {\n-            super.visitTryCatchBlock(start, end, handler, type);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitTryCatchAnnotation(int typeRef, TypePath typePath, String descriptor, boolean visible) {\n-            return super.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int index) {\n-            super.visitLocalVariable(name, descriptor, signature, start, end, index);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitLocalVariableAnnotation(int typeRef, TypePath typePath, Label[] start, Label[] end, int[] index, String descriptor, boolean visible) {\n-            return super.visitLocalVariableAnnotation(typeRef, typePath, start, end, index, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitLineNumber(int line, Label start) {\n-            super.visitLineNumber(line, start);\n-        }\n-\n-        @Override\n-        public void visitMaxs(int maxStack, int maxLocals) {\n-            super.visitMaxs(maxStack, maxLocals);\n-        }\n-\n-        @Override\n-        public void visitEnd() {\n-            super.visitEnd();\n-        }\n-    };\n-\n-    static class NopClassVisitor extends CustomClassVisitor {\n-\n-        public NopClassVisitor(ClassVisitor writer) {\n-            super(writer);\n-        }\n-\n-        @Override\n-        public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {\n-            MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n-            return new NopMethodVisitor(mv);\n-        }\n-    }\n-\n-    static class NopMethodVisitor extends CustomMethodVisitor {\n-\n-        public NopMethodVisitor(MethodVisitor methodVisitor) {\n-            super(methodVisitor);\n-        }\n-\n-        @Override\n-        public void visitCode() {\n-            super.visitCode();\n-            visitInsn(Opcodes.NOP);\n-        }\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Transforms.java","additions":1,"deletions":348,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n@@ -60,2 +59,0 @@\n-        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED\",\n-        \"--add-exports\", \"java.base\/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED\",\n@@ -73,1 +70,0 @@\n-    static String checkFileAsm = \"\/tmp\/asw\/MyClass.class\";\n@@ -75,1 +71,0 @@\n-    static boolean writeClassAsm = Files.exists(Paths.get(checkFileAsm).getParent());\n@@ -78,65 +73,0 @@\n-\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public byte[] asmStream() {\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(Opcodes.V12, Opcodes.ACC_PUBLIC, \"MyClass\", null, \"java\/lang\/Object\", null);\n-        cw.visitSource(\"MyClass.java\", null);\n-\n-        {\n-            MethodVisitor mv = cw.visitMethod(0, INIT_NAME, \"()V\", null, null);\n-            mv.visitCode();\n-            Label startLabel = new Label();\n-            Label endLabel = new Label();\n-            mv.visitLabel(startLabel);\n-            mv.visitVarInsn(Opcodes.ALOAD, 0);\n-            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, \"java\/lang\/Object\", INIT_NAME, \"()V\", false);\n-            mv.visitInsn(Opcodes.RETURN);\n-            mv.visitLabel(endLabel);\n-            mv.visitLocalVariable(\"this\", \"LMyClass;\", null, startLabel, endLabel, 1);\n-            mv.visitMaxs(-1, -1);\n-            mv.visitEnd();\n-        }\n-\n-        for (int xi = 0; xi < REPEATS; ++xi) {\n-            MethodVisitor mv = cw.visitMethod(Opcodes.ACC_PUBLIC+Opcodes.ACC_STATIC, METHOD_NAMES[xi], \"([Ljava\/lang\/String;)V\", null, null);\n-            mv.visitCode();\n-            Label loopTop = new Label();\n-            Label loopEnd = new Label();\n-            Label startLabel = new Label();\n-            Label endLabel = new Label();\n-            Label iStart = new Label();\n-            mv.visitLabel(startLabel);\n-            mv.visitInsn(Opcodes.ICONST_1);\n-            mv.visitVarInsn(Opcodes.ISTORE, 1);\n-            mv.visitLabel(iStart);\n-            mv.visitInsn(Opcodes.ICONST_1);\n-            mv.visitVarInsn(Opcodes.ISTORE, 2);\n-            mv.visitLabel(loopTop);\n-            mv.visitVarInsn(Opcodes.ILOAD, 2);\n-            mv.visitIntInsn(Opcodes.BIPUSH, 10);\n-            mv.visitJumpInsn(Opcodes.IF_ICMPGE, loopEnd);\n-            mv.visitVarInsn(Opcodes.ILOAD, 1);\n-            mv.visitVarInsn(Opcodes.ILOAD, 2);\n-            mv.visitInsn(Opcodes.IMUL);\n-            mv.visitVarInsn(Opcodes.ISTORE, 1);\n-            mv.visitIincInsn(2, 1);\n-            mv.visitJumpInsn(Opcodes.GOTO, loopTop);\n-            mv.visitLabel(loopEnd);\n-            mv.visitFieldInsn(Opcodes.GETSTATIC,\"java\/lang\/System\", \"out\", \"Ljava\/io\/PrintStream;\");\n-            mv.visitVarInsn(Opcodes.ILOAD, 1);\n-            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, \"java\/io\/PrintStream\", \"println\", \"(I)V\", false);\n-            mv.visitLabel(endLabel);\n-            mv.visitInsn(Opcodes.RETURN);\n-            mv.visitLocalVariable(\"fac\", \"I\", null, startLabel, endLabel, 1);\n-            mv.visitLocalVariable(\"i\",   \"I\", null, iStart, loopEnd, 2);\n-            mv.visitMaxs(-1, -1);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n-\n-        byte[] bytes = cw.toByteArray();\n-        if (writeClassAsm) writeClass(bytes, checkFileAsm);\n-        return bytes;\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":1,"deletions":71,"binary":false,"changes":72,"status":"modified"}]}