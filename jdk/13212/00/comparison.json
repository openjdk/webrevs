{"files":[{"patch":"@@ -310,0 +310,9 @@\n+    \/**\n+     * Test if the current character is a line terminator.\n+     *\n+     * @return true if current character is a line terminator.\n+     *\/\n+    private boolean isEOLN() {\n+        return isOneOf('\\n', '\\r');\n+    }\n+\n@@ -1088,1 +1097,1 @@\n-                                       getRawString(pos, endPos)\n+                                       new String(getRawCharacters(pos, endPos))\n@@ -1140,1 +1149,1 @@\n-                                + getRawString(pos, endPos)\n+                                + new String(getRawCharacters(pos, endPos))\n@@ -1144,1 +1153,3 @@\n-        return new BasicComment(style,this, pos, endPos);\n+        char[] buf = getRawCharacters(pos, endPos);\n+\n+        return new BasicComment(style, fac, buf, pos);\n@@ -1159,2 +1170,2 @@\n-                                + \",\" + endPos + \")=|\"\n-                                + getRawString(pos, endPos)\n+                                + \",\" + endPos + \")=|\" +\n+                                new String(getRawCharacters(pos, endPos))\n@@ -1174,2 +1185,2 @@\n-                                + \",\" + endPos + \")=|\"\n-                                + getRawString(pos, endPos)\n+                                + \",\" + endPos + \")=|\" +\n+                                new String(getRawCharacters(pos, endPos))\n@@ -1198,0 +1209,3 @@\n+         *   LINE starting with \/\/\n+         *   BLOCK starting with \/*\n+         *   JAVADOC starting with \/**\n@@ -1214,4 +1228,4 @@\n-         * @param cs     comment style\n-         * @param reader existing reader\n-         * @param pos    start of meaningful content in buffer.\n-         * @param endPos end of meaningful content in buffer.\n+         * @param cs      comment style\n+         * @param sf      Scan factory.\n+         * @param array   Array containing contents of source.\n+         * @param offset  Position offset in original source buffer.\n@@ -1219,2 +1233,2 @@\n-        protected BasicComment(CommentStyle cs, UnicodeReader reader, int pos, int endPos) {\n-            super(reader, pos, endPos);\n+        protected BasicComment(CommentStyle cs, ScannerFactory sf, char[] array, int offset) {\n+            super(sf, array, offset);\n@@ -1236,1 +1250,2 @@\n-         * @param pos buffer position in comment.\n+         * @param pos  buffer position in comment.\n+         *\n@@ -1245,0 +1260,3 @@\n+         *   LINE starting with \/\/\n+         *   BLOCK starting with \/*\n+         *   JAVADOC starting with \/**\n@@ -1246,1 +1264,1 @@\n-         * @return style of comment.\n+         * @return\n@@ -1258,1 +1276,1 @@\n-            if (!scanned) {\n+            if (!scanned && cs == CommentStyle.JAVADOC) {\n@@ -1261,0 +1279,1 @@\n+\n@@ -1265,5 +1284,1 @@\n-         * Detect the deprecated tag.\n-         *\n-         * @param line line reader\n-         *\n-         * @return true if deprecated tag is present.\n+         * Scan JAVADOC comment for details.\n@@ -1271,14 +1286,4 @@\n-        protected boolean hasDeprecated(UnicodeReader line) {\n-            return line.accept(\"@deprecated\") &&\n-                    (line.isWhitespace() || line.is('*') || line.isEOLN());\n-        }\n-\n-        \/**\n-         * Remove closing star(s) slash from comment.\n-         *\n-         * @param line line reader\n-         *\n-         * @return new line reader if detected otherwise original line reader.\n-         *\/\n-        UnicodeReader trimEndOfComment(UnicodeReader line) {\n-            int pos = line.position();\n+        protected void scanDocComment() {\n+            try {\n+                boolean deprecatedPrefix = false;\n+                accept(\"\/**\");\n@@ -1286,4 +1291,4 @@\n-            while (line.isAvailable()) {\n-                if (line.is('*')) {\n-                    int endPos = line.position();\n-                    line.skip('*');\n+                forEachLine:\n+                while (isAvailable()) {\n+                    \/\/ Skip optional WhiteSpace at beginning of line\n+                    skipWhitespace();\n@@ -1291,2 +1296,5 @@\n-                    if (line.is('\/')) {\n-                        return line.lineReader(pos, endPos);\n+                    \/\/ Skip optional consecutive Stars\n+                    while (accept('*')) {\n+                        if (is('\/')) {\n+                            return;\n+                        }\n@@ -1294,4 +1302,0 @@\n-                } else {\n-                    line.next();\n-                }\n-            }\n@@ -1299,1 +1303,2 @@\n-            line.reset(pos);\n+                    \/\/ Skip optional WhiteSpace after Stars\n+                    skipWhitespace();\n@@ -1301,2 +1306,2 @@\n-            return line;\n-        }\n+                    \/\/ At beginning of line in the JavaDoc sense.\n+                    deprecatedPrefix = deprecatedFlag || accept(\"@deprecated\");\n@@ -1304,10 +1309,10 @@\n-        \/**\n-         * Trim the first part of the JavaDoc comment.\n-         *\n-         * @param line line reader\n-         *\n-         * @return modified line reader\n-         *\/\n-        UnicodeReader trimJavadocComment(UnicodeReader line) {\n-            int pos = line.position();\n-            line.skipWhitespace();\n+                    if (deprecatedPrefix && isAvailable()) {\n+                        if (Character.isWhitespace(get())) {\n+                            deprecatedFlag = true;\n+                        } else if (accept('*')) {\n+                            if (is('\/')) {\n+                                deprecatedFlag = true;\n+                                return;\n+                            }\n+                        }\n+                    }\n@@ -1315,3 +1320,5 @@\n-            if (line.skip('*') == 0) {\n-                line.reset(pos);\n-            }\n+                    \/\/ Skip rest of line\n+                    while (isAvailable()) {\n+                        switch (get()) {\n+                            case '*':\n+                                next();\n@@ -1319,2 +1326,3 @@\n-            return trimEndOfComment(line);\n-        }\n+                                if (is('\/')) {\n+                                    return;\n+                                }\n@@ -1322,8 +1330,6 @@\n-        \/**\n-         * Put the line into the buffer.\n-         *\n-         * @param line line reader\n-         *\/\n-        protected void putLine(UnicodeReader line) {\n-            \/\/ ignore overridden in subclass\n-        }\n+                                break;\n+                            case '\\r': \/\/ (Spec 3.4)\n+                            case '\\n': \/\/ (Spec 3.4)\n+                                accept('\\r');\n+                                accept('\\n');\n+                                continue forEachLine;\n@@ -1331,6 +1337,8 @@\n-        \/**\n-         * Scan document comment for content.\n-         *\/\n-        protected void scanDocComment() {\n-            if (!scanned) {\n-                deprecatedFlag = false;\n+                            default:\n+                                next();\n+                                break;\n+                        }\n+                    } \/\/ rest of line\n+                } \/\/ forEachLine\n+                return;\n+            } finally {\n@@ -1338,18 +1346,0 @@\n-\n-                if (!accept(\"\/**\")) {\n-                    return;\n-                }\n-\n-                while (isAvailable()) {\n-                    UnicodeReader line = lineReader();\n-                    line = trimJavadocComment(line);\n-\n-                    \/\/ If standalone @deprecated tag\n-                    int pos = line.position();\n-                    if (hasDeprecated(line)) {\n-                        deprecatedFlag = true;\n-                    }\n-\n-                    line.reset(pos);\n-                    putLine(line);\n-                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":85,"deletions":95,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -82,1 +82,2 @@\n-        return new JavadocComment(style, this, pos, endPos);\n+        char[] buf = getRawCharacters(pos, endPos);\n+        return new JavadocComment(style, fac, buf, pos);\n@@ -90,0 +91,7 @@\n+        \/**\n+         * Pattern used to detect a well formed @deprecated tag in a Javadoc\n+         * comment.\n+         *\/\n+        private static final Pattern DEPRECATED_PATTERN =\n+            Pattern.compile(\"(?sm).*^\\\\s*@deprecated( |$).*\");\n+\n@@ -107,2 +115,2 @@\n-        JavadocComment(CommentStyle cs, UnicodeReader reader, int pos, int endPos) {\n-            super(cs, reader, pos, endPos);\n+        JavadocComment(CommentStyle cs, ScannerFactory sf, char[] array, int offset) {\n+            super( cs, sf, array, offset);\n@@ -113,1 +121,1 @@\n-         * Add current character or code point from line to the extraction buffer.\n+         * Add a character to the extraction buffer.\n@@ -115,1 +123,1 @@\n-         * @param line line reader\n+         * @param ch  character to add.\n@@ -117,9 +125,4 @@\n-        protected void putLine(UnicodeReader line) {\n-            while (line.isAvailable()) {\n-                offsetMap.add(sb.length(), line.position());\n-\n-                if (line.isSurrogate()) {\n-                    sb.appendCodePoint(line.getCodepoint());\n-                } else {\n-                    sb.append(line.get());\n-                }\n+        protected void put(char ch) {\n+            offsetMap.add(sb.length(), offsetPosition());\n+            sb.append(ch);\n+        }\n@@ -127,1 +130,18 @@\n-                line.next();\n+        \/**\n+         * Add a code point to the extraction buffer.\n+         *\n+         * @param codePoint  code point to add.\n+         *\/\n+        protected void putCodePoint(int codePoint) {\n+            offsetMap.add(sb.length(), offsetPosition());\n+            sb.appendCodePoint(codePoint);\n+        }\n+\n+        \/**\n+         * Add current character or code point to the extraction buffer.\n+         *\/\n+        protected void put() {\n+            if (isSurrogate()) {\n+                putCodePoint(getCodepoint());\n+            } else {\n+                put(get());\n@@ -129,2 +149,0 @@\n-            offsetMap.add(sb.length(), line.position());\n-            sb.append('\\n');\n@@ -135,1 +153,1 @@\n-            if (!scanned) {\n+            if (!scanned && cs == CommentStyle.JAVADOC) {\n@@ -156,2 +174,91 @@\n-            try {\n-                super.scanDocComment();\n+             try {\n+                 boolean firstLine = true;\n+\n+                 \/\/ Skip over \/*\n+                 accept(\"\/*\");\n+\n+                 \/\/ Consume any number of stars\n+                 skip('*');\n+\n+                 \/\/ Is the comment in the form \/**\/, \/***\/, \/****\/, etc. ?\n+                 if (is('\/')) {\n+                     docComment = \"\";\n+                     return;\n+                 }\n+\n+                 \/\/ Skip line terminator on the first line of the comment.\n+                 if (isOneOf('\\n', '\\r')) {\n+                     accept('\\r');\n+                     accept('\\n');\n+                     firstLine = false;\n+                 }\n+\n+             outerLoop:\n+                 \/\/ The outerLoop processes the doc comment, looping once\n+                 \/\/ for each line.  For each line, it first strips off\n+                 \/\/ whitespace, then it consumes any stars, then it\n+                 \/\/ puts the rest of the line into the extraction buffer.\n+                 while (isAvailable()) {\n+                     int begin_pos = position();\n+                     \/\/ Consume  whitespace from the beginning of each line.\n+                     skipWhitespace();\n+                     \/\/ Are there stars here?  If so, consume them all\n+                     \/\/ and check for the end of comment.\n+                     if (is('*')) {\n+                         \/\/ skip all of the stars\n+                         skip('*');\n+\n+                         \/\/ check for the closing slash.\n+                         if (accept('\/')) {\n+                             \/\/ We're done with the Javadoc comment\n+                             break outerLoop;\n+                         }\n+                     } else if (!firstLine) {\n+                         \/\/ The current line does not begin with a '*' so we will\n+                         \/\/ treat it as comment\n+                         reset(begin_pos);\n+                     }\n+\n+                 textLoop:\n+                     \/\/ The textLoop processes the rest of the characters\n+                     \/\/ on the line, adding them to the extraction buffer.\n+                     while (isAvailable()) {\n+                         if (accept(\"*\/\")) {\n+                             \/\/ This is the end of the comment, return\n+                             \/\/ the contents of the extraction buffer.\n+                             break outerLoop;\n+                         } else if (isOneOf('\\n', '\\r')) {\n+                             \/\/ We've seen a newline.  Add it to our\n+                             \/\/ buffer and break out of this loop,\n+                             \/\/ starting fresh on a new line.\n+                             put('\\n');\n+                             accept('\\r');\n+                             accept('\\n');\n+                             break textLoop;\n+                         } else if (is('\\f')){\n+                             next();\n+                             break textLoop; \/\/ treat as end of line\n+\n+                         } else {\n+                             \/\/ Add the character to our buffer.\n+                             put();\n+                             next();\n+                         }\n+                     } \/\/ end textLoop\n+                     firstLine = false;\n+                 } \/\/ end outerLoop\n+\n+                 \/\/ If extraction buffer is not empty.\n+                 if (sb.length() > 0) {\n+                     \/\/ Remove trailing asterisks.\n+                     int i = sb.length() - 1;\n+                     while (i > -1 && sb.charAt(i) == '*') {\n+                         i--;\n+                     }\n+                     sb.setLength(i + 1) ;\n+\n+                     \/\/ Store the text of the doc comment\n+                    docComment = sb.toString();\n+                 } else {\n+                    docComment = \"\";\n+                }\n@@ -159,1 +266,6 @@\n-                docComment = sb.toString();\n+                scanned = true;\n+\n+                \/\/ Check if comment contains @deprecated comment.\n+                if (docComment != null && DEPRECATED_PATTERN.matcher(docComment).matches()) {\n+                    deprecatedFlag = true;\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavadocTokenizer.java","additions":133,"deletions":21,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -276,3 +276,3 @@\n-            LINE,       \/\/ Starting with \/\/\n-            BLOCK,      \/\/ starting with \/*\n-            JAVADOC,    \/\/ starting with \/**\n+            LINE,\n+            BLOCK,\n+            JAVADOC,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Tokens.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -107,24 +107,0 @@\n-        this(sf.log, array, length);\n-    }\n-\n-    \/**\n-     * Constructor.\n-     *\n-     * @param log     Log for error reporting.\n-     * @param array   array containing contents of source.\n-     * @param length  length of meaningful content in buffer.\n-     *\/\n-    protected UnicodeReader(Log log, char[] array, int length) {\n-        this(log, array, 0, length);\n-    }\n-\n-    \/**\n-      * Constructor.\n-      *\n-      * @param log     Log for error reporting.\n-      * @param array   array containing contents of source.\n-      * @param pos     start of meaningful content in buffer.\n-      * @param endPos  end of meaningful content in buffer.\n-      *\/\n-    @SuppressWarnings(\"this-escape\")\n-    protected UnicodeReader(Log log, char[] array, int pos, int endPos) {\n@@ -132,2 +108,2 @@\n-        this.length = endPos;\n-        this.position = pos;\n+        this.length = length;\n+        this.position = 0;\n@@ -139,1 +115,1 @@\n-        this.log = log;\n+        this.log = sf.log;\n@@ -453,3 +429,0 @@\n-    \/**\n-     * Match one of the arguments and advance if a match. Returns true if a match.\n-     *\/\n@@ -462,17 +435,0 @@\n-        return false;\n-    }\n-\n-    \/**\n-     * Return a reader which is bracketed by the currect position\n-     * and the next line terminator.\n-     *\n-     * @return a new reader\n-     *\/\n-    protected UnicodeReader lineReader() {\n-        int pos = position;\n-        skipToEOLN();\n-        int endPos = position;\n-        accept('\\r');\n-        accept('\\n');\n-        return lineReader(pos, endPos);\n-    }\n@@ -480,11 +436,1 @@\n-    \/**\n-     * Return a reader which is bracketed by the {@code pos}\n-     * and {@code endPos}.\n-     *\n-     * @param pos     initial position\n-     * @param endPos  end position\n-     *\n-     * @return a new reader\n-     *\/\n-    protected UnicodeReader lineReader(int pos, int endPos) {\n-        return new UnicodeReader(log, buffer, pos, endPos);\n+        return false;\n@@ -497,2 +443,0 @@\n-     *\n-     * @return number of characters skipped\n@@ -500,2 +444,1 @@\n-    protected int skip(char ch) {\n-        int count = 0;\n+    protected void skip(char ch) {\n@@ -503,1 +446,1 @@\n-            count++;\n+            \/\/ next\n@@ -505,10 +448,0 @@\n-        return count;\n-    }\n-\n-    \/**\n-     * Is ASCII white space character.\n-     *\n-     * @return true if is ASCII white space character\n-     *\/\n-    protected boolean isWhitespace() {\n-        return isOneOf(' ', '\\t', '\\f');\n@@ -526,9 +459,0 @@\n-    \/**\n-     * Is ASCII line terminator.\n-     *\n-     * @return true if is ASCII white space character\n-     *\/\n-    protected boolean isEOLN() {\n-        return isOneOf('\\r', '\\n');\n-    }\n-\n@@ -540,1 +464,1 @@\n-            if (isEOLN()) {\n+            if (isOneOf('\\r', '\\n')) {\n@@ -546,0 +470,1 @@\n+\n@@ -643,19 +568,0 @@\n-    \/**\n-     * Returns a string subset of the input buffer.\n-     * The returned string begins at the {@code beginIndex} and\n-     * extends to the character at index {@code endIndex - 1}.\n-     * Thus the length of the substring is {@code endIndex-beginIndex}.\n-     * This behavior is like\n-     * {@code String.substring(beginIndex, endIndex)}.\n-     * Unicode escape sequences are not translated.\n-     *\n-     * @param  beginIndex the beginning index, inclusive.\n-     * @param  endIndex the ending index, exclusive.\n-     *\n-     * @throws ArrayIndexOutOfBoundsException if either offset is outside of the\n-     *         array bounds\n-     *\/\n-    public String getRawString(int beginIndex, int endIndex) {\n-        return new String(buffer, beginIndex, endIndex - beginIndex);\n-    }\n-\n@@ -669,0 +575,5 @@\n+        \/**\n+         * Offset from the beginning of the original reader buffer.\n+         *\/\n+        private final int offset;\n+\n@@ -677,3 +588,3 @@\n-         * @param reader  existing reader\n-         * @param pos     start of meaningful content in buffer.\n-         * @param endPos  end of meaningful content in buffer.\n+         * @param sf      Scan factory.\n+         * @param array   Array containing contents of source.\n+         * @param offset  Position offset in original source buffer.\n@@ -681,2 +592,3 @@\n-        protected PositionTrackingReader(UnicodeReader reader, int pos, int endPos) {\n-            super(reader.log, reader.buffer, pos, endPos);\n+        protected PositionTrackingReader(ScannerFactory sf, char[] array, int offset) {\n+            super(sf, array, array.length);\n+            this.offset = offset;\n@@ -714,0 +626,9 @@\n+\n+        \/**\n+         * Returns position relative to the original source buffer.\n+         *\n+         * @return\n+         *\/\n+        protected int offsetPosition() {\n+            return position() + offset;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/UnicodeReader.java","additions":28,"deletions":107,"binary":false,"changes":135,"status":"modified"}]}