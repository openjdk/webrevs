{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.util.ArrayList;\n@@ -1306,1 +1307,1 @@\n-        public List<Symbol> permitted;\n+        private java.util.List<PermittedClassWithPos> permitted;\n@@ -1310,0 +1311,2 @@\n+        private record PermittedClassWithPos(Symbol permittedClass, int pos) {}\n+\n@@ -1318,1 +1321,1 @@\n-            this.permitted = List.nil();\n+            this.permitted = new ArrayList<>();\n@@ -1330,0 +1333,35 @@\n+        public void addPermittedSubclass(ClassSymbol csym, int pos) {\n+            if (isPermittedExplicit) {\n+                \/\/ in this case just add the permitted subclasses clause is explicit\n+                permitted.add(new PermittedClassWithPos(csym, pos));\n+            } else {\n+                \/\/ in this case we need to insert at the right pos\n+                PermittedClassWithPos element = new PermittedClassWithPos(csym, pos);\n+                int index = Collections.binarySearch(permitted, element, java.util.Comparator.comparing(PermittedClassWithPos::pos));\n+                if (index < 0) {\n+                    index = -index - 1;\n+                }\n+                permitted.add(index, element);\n+            }\n+        }\n+\n+        public boolean isPermittedSubclass(Symbol csym) {\n+            for (PermittedClassWithPos permittedClassWithPos : permitted) {\n+                if (permittedClassWithPos.permittedClass.equals(csym)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public void clearPermittedSubclasses() {\n+            permitted.clear();\n+        }\n+\n+        public void setPermittedSubclasses(List<Symbol> permittedSubs) {\n+            permitted.clear();\n+            for (Symbol csym : permittedSubs) {\n+                permitted.add(new PermittedClassWithPos(csym, 0));\n+            }\n+        }\n+\n@@ -1646,1 +1684,1 @@\n-            return permitted.map(s -> s.type);\n+            return permitted.stream().map(s -> s.permittedClass().type).collect(List.collector());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -1704,1 +1704,1 @@\n-                    return sealedOne.permitted.stream().allMatch(sym -> areDisjoint((ClassSymbol)sym, other));\n+                    return sealedOne.getPermittedSubclasses().stream().allMatch(type -> areDisjoint((ClassSymbol)type.tsym, other));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5386,1 +5386,1 @@\n-                        c.permitted.isEmpty()) {\n+                        c.getPermittedSubclasses().isEmpty()) {\n@@ -5393,1 +5393,1 @@\n-                    for (Symbol subTypeSym : c.permitted) {\n+                    for (Type subType : c.getPermittedSubclasses()) {\n@@ -5395,1 +5395,1 @@\n-                        if (subTypeSym.type.getTag() == TYPEVAR) {\n+                        if (subType.getTag() == TYPEVAR) {\n@@ -5397,2 +5397,2 @@\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                    Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));\n+                            log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n+                                    Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subType)));\n@@ -5400,2 +5400,2 @@\n-                        if (subTypeSym.isAnonymous() && !c.isEnum()) {\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n+                        if (subType.tsym.isAnonymous() && !c.isEnum()) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n@@ -5403,1 +5403,1 @@\n-                        if (permittedTypes.contains(subTypeSym)) {\n+                        if (permittedTypes.contains(subType.tsym)) {\n@@ -5406,1 +5406,1 @@\n-                                            .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)\n+                                            .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subType.tsym, permittedExpr, true) != null)\n@@ -5408,1 +5408,1 @@\n-                            log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));\n+                            log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subType)));\n@@ -5410,1 +5410,1 @@\n-                            permittedTypes.add(subTypeSym);\n+                            permittedTypes.add(subType.tsym);\n@@ -5413,2 +5413,2 @@\n-                            if (subTypeSym.packge() != c.packge()) {\n-                                log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                            if (subType.tsym.packge() != c.packge()) {\n+                                log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n@@ -5418,2 +5418,2 @@\n-                        } else if (subTypeSym.packge().modle != c.packge().modle) {\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                        } else if (subType.tsym.packge().modle != c.packge().modle) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n@@ -5423,2 +5423,2 @@\n-                        if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),\n+                        if (subType.tsym == c.type.tsym || types.isSuperType(subType, c.type)) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subType.tsym, ((JCClassDecl)env.tree).permitting),\n@@ -5426,1 +5426,1 @@\n-                                            subTypeSym == c.type.tsym ?\n+                                            subType.tsym == c.type.tsym ?\n@@ -5428,1 +5428,1 @@\n-                                                    Fragments.MustNotBeSupertype(subTypeSym.type)\n+                                                    Fragments.MustNotBeSupertype(subType)\n@@ -5432,1 +5432,1 @@\n-                            boolean thisIsASuper = types.directSupertypes(subTypeSym.type)\n+                            boolean thisIsASuper = types.directSupertypes(subType)\n@@ -5436,2 +5436,2 @@\n-                                log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                        Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));\n+                                log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n+                                        Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subType)));\n@@ -5472,1 +5472,1 @@\n-                            if (!supertypeSym.permitted.contains(c.type.tsym)) {\n+                            if (!supertypeSym.isPermittedSubclass(c.type.tsym)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -948,2 +948,2 @@\n-                    for (Symbol sym : current.permitted) {\n-                        ClassSymbol csym = (ClassSymbol) sym;\n+                    for (Type t : current.getPermittedSubclasses()) {\n+                        ClassSymbol csym = (ClassSymbol) t.tsym;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -922,1 +922,1 @@\n-                            supClass.permitted = supClass.permitted.append(sym);\n+                            supClass.addPermittedSubclass(sym, tree.pos);\n@@ -935,1 +935,1 @@\n-                sym.permitted = permittedSubtypeSymbols.toList();\n+                sym.setPermittedSubclasses(permittedSubtypeSymbols.toList());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1301,1 +1301,1 @@\n-                        ((ClassSymbol)sym).permitted = subtypes.toList();\n+                        ((ClassSymbol)sym).setPermittedSubclasses(subtypes.toList());\n@@ -2933,1 +2933,1 @@\n-        if (c.permitted != null && !c.permitted.isEmpty()) {\n+        if (!c.getPermittedSubclasses().isEmpty()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -925,1 +925,1 @@\n-        if (csym.permitted.nonEmpty()) {\n+        if (csym.getPermittedSubclasses().nonEmpty()) {\n@@ -927,3 +927,3 @@\n-            databuf.appendChar(csym.permitted.size());\n-            for (Symbol c : csym.permitted) {\n-                databuf.appendChar(poolWriter.putClass((ClassSymbol) c));\n+            databuf.appendChar(csym.getPermittedSubclasses().size());\n+            for (Type t : csym.getPermittedSubclasses()) {\n+                databuf.appendChar(poolWriter.putClass((ClassSymbol) t.tsym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1646,1 +1646,1 @@\n-                    node.sym.permitted = List.nil();\n+                    node.sym.clearPermittedSubclasses();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,1 +145,0 @@\n-        subtypeNames.sort((s1, s2) -> s1.compareTo(s2));\n@@ -698,0 +697,34 @@\n+\n+    @Test\n+    public void testClientSwapsPermittedSubclassesOrder(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path foo = src.resolve(\"Foo.java\");\n+        Path fooUser = src.resolve(\"FooUser.java\");\n+\n+        tb.writeFile(foo,\n+                \"\"\"\n+                public sealed interface Foo {\n+                    record R1() implements Foo {}\n+                    record R2() implements Foo {}\n+                }\n+                \"\"\");\n+\n+        tb.writeFile(fooUser,\n+                \"\"\"\n+                public class FooUser {\n+                    \/\/ see that the order of arguments differ from the order of subclasses of Foo in the source above\n+                    \/\/ we need to check that the order of permitted subclasses of Foo in the class file corresponds to the\n+                    \/\/ original order in the source code\n+                    public void blah(Foo.R2 a, Foo.R1 b) {}\n+                }\n+                \"\"\");\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(fooUser, foo)\n+                .run();\n+        checkSealedClassFile(out, \"Foo.class\", List.of(\"Foo$R1\", \"Foo$R2\"));\n+    }\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedDiffConfigurationsTest.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"}]}