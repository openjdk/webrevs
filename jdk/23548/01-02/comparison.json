{"files":[{"patch":"@@ -40,0 +40,1 @@\n+import java.util.function.Consumer;\n@@ -49,1 +50,0 @@\n-import org.junit.jupiter.api.function.ThrowingConsumer;\n@@ -94,1 +94,2 @@\n-        record CondyBoot(MethodHandles.Lookup lookup, String name, Class<?> type) {}\n+        record CondyBoot(MethodHandles.Lookup lookup, String name, Class<?> type) {\n+        }\n@@ -172,0 +173,59 @@\n+    @ParameterizedTest\n+    @MethodSource(\"equalityCases\")\n+    <T, P extends PoolEntry> void testAsSymbolEquality(ValidSymbolCase<T, P> validSymbolCase, String entryState, P p) {\n+        var asSymbol = validSymbolCase.translator.extractor.apply(p);\n+        assertEquals(validSymbolCase.sym, asSymbol, \"asSym vs sym\");\n+        assertEquals(validSymbolCase.other, asSymbol, \"asSym vs other sym\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalityCases\")\n+    <T, P extends PoolEntry> void testMatchesOriginalEquality(ValidSymbolCase<T, P> validSymbolCase, String entryState, P p) {\n+        assertTrue(validSymbolCase.translator.tester.test(p, validSymbolCase.sym));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalityCases\")\n+    <T, P extends PoolEntry> void testMatchesEquivalentEquality(ValidSymbolCase<T, P> validSymbolCase, String entryState, P p) {\n+        assertTrue(validSymbolCase.translator.tester.test(p, validSymbolCase.other));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inequalityCases\")\n+    <T, P extends PoolEntry> void testAsSymbolInequality(ValidSymbolCase<T, P> validSymbolCase, String stateName, P p) {\n+        var asSymbol = validSymbolCase.translator.extractor.apply(p);\n+        assertEquals(validSymbolCase.sym, asSymbol, \"asSymbol vs original\");\n+        assertNotEquals(validSymbolCase.other, asSymbol, \"asSymbol vs inequal\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inequalityCases\")\n+    <T, P extends PoolEntry> void testMatchesOriginalInequality(ValidSymbolCase<T, P> validSymbolCase, String stateName, P p) {\n+        assertTrue(validSymbolCase.translator.tester.test(p, validSymbolCase.sym));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inequalityCases\")\n+    <T, P extends PoolEntry> void testMatchesNonEquivalentInequality(ValidSymbolCase<T, P> validSymbolCase, String stateName, P p) {\n+        assertFalse(validSymbolCase.translator.tester.test(p, validSymbolCase.other));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"malformedCases\")\n+    <T, P extends PoolEntry> void testAsSymbolMalformed(InvalidSymbolCase<T, P> baseCase, String entryState, P p) {\n+        assertThrows(IllegalArgumentException.class, () -> baseCase.translator.extractor.apply(p));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"malformedCases\")\n+    <T, P extends PoolEntry> void testMatchesMalformed(InvalidSymbolCase<T, P> baseCase, String entryState, P p) {\n+        assertFalse(baseCase.translator.tester.test(p, baseCase.target));\n+    }\n+\n+    \/\/ Support for complex pool entry creation with different inflation states.\n+    \/\/ Inflation states include:\n+    \/\/   - bound\/unbound,\n+    \/\/   - asSymbol()\n+    \/\/   - matches() resulting in match\n+    \/\/   - matches() resulting in mismatch\n+\n@@ -173,8 +233,1 @@\n-    record PoolEntryCase<P>(String desc, Supplier<P> poolEntry) {\n-        void test(ThrowingConsumer<P> job) {\n-            try {\n-                job.accept(poolEntry.get());\n-            } catch (Throwable e) {\n-                Assertions.fail(\"Tested entry: \" + desc, e);\n-            }\n-        }\n+    record StatefulPoolEntry<P>(String desc, Supplier<P> factory) {\n@@ -184,1 +237,2 @@\n-    record SymbolicTranslator<T, P extends PoolEntry>(String name, BiFunction<ConstantPoolBuilder, T, P> writer, BiPredicate<P, T> tester, Function<P, T> extractor) {\n+    record SymbolicTranslator<T, P extends PoolEntry>(String name, BiFunction<ConstantPoolBuilder, T, P> writer,\n+                                                      BiPredicate<P, T> tester, Function<P, T> extractor) {\n@@ -194,1 +248,2 @@\n-            var bytes = ClassFile.of().build(cpb.classEntry(ClassDesc.of(\"Test\")), cpb, _ -> {});\n+            var bytes = ClassFile.of().build(cpb.classEntry(ClassDesc.of(\"Test\")), cpb, _ -> {\n+            });\n@@ -199,2 +254,2 @@\n-        public Stream<PoolEntryCase<P>> entriesSpawner(T original) {\n-            return entriesSpawner(() -> this.createUnboundEntry(original));\n+        public Stream<StatefulPoolEntry<P>> entriesSpawner(T original) {\n+            return spawnBounded(() -> this.createUnboundEntry(original));\n@@ -204,2 +259,2 @@\n-        public Stream<PoolEntryCase<P>> entriesSpawner(Supplier<P> original) {\n-            return Stream.of(new PoolEntryCase<>(original.get().toString(), original))\n+        public Stream<StatefulPoolEntry<P>> spawnBounded(Supplier<P> original) {\n+            return Stream.of(new StatefulPoolEntry<>(original.get().toString(), original))\n@@ -207,3 +262,3 @@\n-                sink.accept(s); \/\/ unbound\n-                sink.accept(new PoolEntryCase<>(s.desc + \"+lazy\", () -> toBoundEntry(s.poolEntry.get()))); \/\/ bound\n-            });\n+                        sink.accept(s); \/\/ unbound\n+                        sink.accept(new StatefulPoolEntry<>(s.desc + \"+lazy\", () -> toBoundEntry(s.factory.get()))); \/\/ bound\n+                    });\n@@ -213,3 +268,3 @@\n-        public PoolEntryCase<P> inflateByTest(PoolEntryCase<P> last, T arg, String msg) {\n-            return new PoolEntryCase<>(\"+matches(\" + msg + \")\", () -> {\n-                var ret = last.poolEntry.get();\n+        public StatefulPoolEntry<P> inflateByMatching(StatefulPoolEntry<P> last, T arg, String msg) {\n+            return new StatefulPoolEntry<>(\"+matches(\" + msg + \")\", () -> {\n+                var ret = last.factory.get();\n@@ -223,3 +278,3 @@\n-        public PoolEntryCase<P> inflateByComputeSymbol(PoolEntryCase<P> last) {\n-            return new PoolEntryCase<>(last.desc + \"+asSymbol()\", () -> {\n-                var ret = last.poolEntry.get();\n+        public StatefulPoolEntry<P> inflateByComputeSymbol(StatefulPoolEntry<P> last) {\n+            return new StatefulPoolEntry<>(last.desc + \"+asSymbol()\", () -> {\n+                var ret = last.factory.get();\n@@ -237,0 +292,4 @@\n+    \/\/ A case testing valid symbol sym; other is another symbol that may match or mismatch.\n+    record ValidSymbolCase<T, P extends PoolEntry>(SymbolicTranslator<T, P> translator, T sym, T other) {\n+    }\n+\n@@ -239,2 +298,2 @@\n-    static final SymbolicTranslator<ClassDesc, Utf8Entry> UTF8_CLASS_TRANSLATOR = new SymbolicTranslator<>(\"FieldDescriptorUtf8\", ConstantPoolBuilder::utf8Entry, Utf8Entry::isFieldType, Util::fieldTypeSymbol);\n-    static final SymbolicTranslator<MethodTypeDesc, Utf8Entry> UTF8_METHOD_TYPE_TRANSLATOR = new SymbolicTranslator<>(\"MethodDescriptorUtf8\", ConstantPoolBuilder::utf8Entry, Utf8Entry::isMethodType, Util::methodTypeSymbol);\n+    static final SymbolicTranslator<ClassDesc, Utf8Entry> UTF8_CLASS_TRANSLATOR = new SymbolicTranslator<>(\"FieldTypeUtf8\", ConstantPoolBuilder::utf8Entry, Utf8Entry::isFieldType, Util::fieldTypeSymbol);\n+    static final SymbolicTranslator<MethodTypeDesc, Utf8Entry> UTF8_METHOD_TYPE_TRANSLATOR = new SymbolicTranslator<>(\"MethodTypeUtf8\", ConstantPoolBuilder::utf8Entry, Utf8Entry::isMethodType, Util::methodTypeSymbol);\n@@ -247,23 +306,5 @@\n-    static Stream<Arguments> equalityCases() {\n-        return Stream.of(\n-                Arguments.of(CLASS_ENTRY_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/Object\")), \/\/ class or interface\n-                Arguments.of(CLASS_ENTRY_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/Object;\")), \/\/ array\n-                Arguments.of(UTF8_CLASS_TRANSLATOR, CD_int, ClassDesc.ofDescriptor(\"I\")), \/\/ primitive\n-                Arguments.of(UTF8_CLASS_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/Object\")), \/\/ class or interface\n-                Arguments.of(UTF8_CLASS_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/Object;\")), \/\/ array\n-                Arguments.of(UTF8_STRING_TRANSLATOR, \"Ab\\u0000c\", \"Ab\\u0000c\"),\n-                Arguments.of(UTF8_METHOD_TYPE_TRANSLATOR, MTD_void, MethodTypeDesc.ofDescriptor(\"()V\")),\n-                Arguments.of(UTF8_METHOD_TYPE_TRANSLATOR, MethodTypeDesc.of(CD_int, CD_Long), MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Long;)I\")),\n-                Arguments.of(METHOD_TYPE_ENTRY_TRANSLATOR, MethodTypeDesc.of(CD_Object), MethodTypeDesc.ofDescriptor(\"()Ljava\/lang\/Object;\")),\n-                Arguments.of(STRING_ENTRY_TRANSLATOR, \"Ape\", new String(\"Ape\".getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8)),\n-                Arguments.of(PACKAGE_ENTRY_TRANSLATOR, PackageDesc.of(\"java.lang\"), PackageDesc.ofInternalName(\"java\/lang\")),\n-                Arguments.of(MODULE_ENTRY_TRANSLATOR, ModuleDesc.of(\"java.base\"), ModuleDesc.of(new String(\"java.base\".getBytes(StandardCharsets.US_ASCII), StandardCharsets.US_ASCII)))\n-        );\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"equalityCases\")\n-    <T, P extends PoolEntry> void testEquality(SymbolicTranslator<T, P> translator, T first, T alt) {\n-        assertEquals(first, alt, \"Bad test data\");\n-        translator.entriesSpawner(first)\n-                .<PoolEntryCase<P>>mapMulti((src, sink) -> {\n+    \/\/ Create arguments of tuple (ValidSymbolCase, entryState, PoolEntry) to verify symbolic behavior of pool entries\n+    \/\/ with particular inflation states\n+    static <T, P extends PoolEntry> void specializeInflation(ValidSymbolCase<T, P> validSymbolCase, Consumer<Arguments> callArgs) {\n+        validSymbolCase.translator.entriesSpawner(validSymbolCase.sym)\n+                .<StatefulPoolEntry<P>>mapMulti((src, sink) -> {\n@@ -271,3 +312,3 @@\n-                    sink.accept(translator.inflateByTest(src, first, \"first\"));\n-                    sink.accept(translator.inflateByTest(src, alt, \"alt\"));\n-                    sink.accept(translator.inflateByComputeSymbol(src));\n+                    sink.accept(validSymbolCase.translator.inflateByMatching(src, validSymbolCase.sym, \"same symbol\"));\n+                    sink.accept(validSymbolCase.translator.inflateByMatching(src, validSymbolCase.other, \"another symbol\"));\n+                    sink.accept(validSymbolCase.translator.inflateByComputeSymbol(src));\n@@ -275,9 +316,18 @@\n-                .forEach(scenario -> {\n-                    scenario.test(p -> {\n-                        var asSymbol = translator.extractor.apply(p);\n-                        assertEquals(first, asSymbol, \"asSym vs first\");\n-                        assertEquals(alt, asSymbol, \"asSym vs alt\");\n-                    });\n-                    scenario.test(p -> assertTrue(translator.tester.test(p, first), \"eqSym first\"));\n-                    scenario.test(p -> assertTrue(translator.tester.test(p, alt), \"eqSym alt\"));\n-                });\n+                .forEach(stateful -> callArgs.accept(Arguments.of(validSymbolCase, stateful.desc, stateful.factory.get())));\n+    }\n+\n+    static Stream<Arguments> equalityCases() {\n+        return Stream.of(\n+                new ValidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/Object\")), \/\/ class or interface\n+                new ValidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/Object;\")), \/\/ array\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_int, ClassDesc.ofDescriptor(\"I\")), \/\/ primitive\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/Object\")), \/\/ class or interface\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/Object;\")), \/\/ array\n+                new ValidSymbolCase<>(UTF8_STRING_TRANSLATOR, \"Ab\\u0000c\", \"Ab\\u0000c\"),\n+                new ValidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, MTD_void, MethodTypeDesc.ofDescriptor(\"()V\")),\n+                new ValidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, MethodTypeDesc.of(CD_int, CD_Long), MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Long;)I\")),\n+                new ValidSymbolCase<>(METHOD_TYPE_ENTRY_TRANSLATOR, MethodTypeDesc.of(CD_Object), MethodTypeDesc.ofDescriptor(\"()Ljava\/lang\/Object;\")),\n+                new ValidSymbolCase<>(STRING_ENTRY_TRANSLATOR, \"Ape\", new String(\"Ape\".getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8)),\n+                new ValidSymbolCase<>(PACKAGE_ENTRY_TRANSLATOR, PackageDesc.of(\"java.lang\"), PackageDesc.ofInternalName(\"java\/lang\")),\n+                new ValidSymbolCase<>(MODULE_ENTRY_TRANSLATOR, ModuleDesc.of(\"java.base\"), ModuleDesc.of(new String(\"java.base\".getBytes(StandardCharsets.US_ASCII), StandardCharsets.US_ASCII)))\n+        ).mapMulti(ConstantDescSymbolsTest::specializeInflation);\n@@ -288,13 +338,13 @@\n-                Arguments.of(CLASS_ENTRY_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/io\/Object\")), \/\/ class or interface\n-                Arguments.of(CLASS_ENTRY_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/String;\")), \/\/ array\n-                Arguments.of(UTF8_CLASS_TRANSLATOR, CD_int, ClassDesc.ofDescriptor(\"S\")), \/\/ primitive\n-                Arguments.of(UTF8_CLASS_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/String\")), \/\/ class or interface\n-                Arguments.of(UTF8_CLASS_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/System;\")), \/\/ array\n-                Arguments.of(UTF8_STRING_TRANSLATOR, \"Ab\\u0000c\", \"Abdc\"),\n-                Arguments.of(UTF8_METHOD_TYPE_TRANSLATOR, MTD_void, MethodTypeDesc.ofDescriptor(\"()I\")),\n-                Arguments.of(UTF8_METHOD_TYPE_TRANSLATOR, MethodTypeDesc.of(CD_int, CD_Short), MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Long;)I\")),\n-                Arguments.of(METHOD_TYPE_ENTRY_TRANSLATOR, MethodTypeDesc.of(CD_String), MethodTypeDesc.ofDescriptor(\"()Ljava\/lang\/Object;\")),\n-                Arguments.of(STRING_ENTRY_TRANSLATOR, \"Cat\", new String(\"Ape\".getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8)),\n-                Arguments.of(PACKAGE_ENTRY_TRANSLATOR, PackageDesc.of(\"java.lang\"), PackageDesc.ofInternalName(\"java\/util\")),\n-                Arguments.of(MODULE_ENTRY_TRANSLATOR, ModuleDesc.of(\"java.base\"), ModuleDesc.of(new String(\"java.desktop\".getBytes(StandardCharsets.US_ASCII), StandardCharsets.US_ASCII)))\n-        );\n+                new ValidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/io\/Object\")), \/\/ class or interface\n+                new ValidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/String;\")), \/\/ array\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_int, ClassDesc.ofDescriptor(\"S\")), \/\/ primitive\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/String\")), \/\/ class or interface\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/System;\")), \/\/ array\n+                new ValidSymbolCase<>(UTF8_STRING_TRANSLATOR, \"Ab\\u0000c\", \"Abdc\"),\n+                new ValidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, MTD_void, MethodTypeDesc.ofDescriptor(\"()I\")),\n+                new ValidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, MethodTypeDesc.of(CD_int, CD_Short), MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Long;)I\")),\n+                new ValidSymbolCase<>(METHOD_TYPE_ENTRY_TRANSLATOR, MethodTypeDesc.of(CD_String), MethodTypeDesc.ofDescriptor(\"()Ljava\/lang\/Object;\")),\n+                new ValidSymbolCase<>(STRING_ENTRY_TRANSLATOR, \"Cat\", new String(\"Ape\".getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8)),\n+                new ValidSymbolCase<>(PACKAGE_ENTRY_TRANSLATOR, PackageDesc.of(\"java.lang\"), PackageDesc.ofInternalName(\"java\/util\")),\n+                new ValidSymbolCase<>(MODULE_ENTRY_TRANSLATOR, ModuleDesc.of(\"java.base\"), ModuleDesc.of(new String(\"java.desktop\".getBytes(StandardCharsets.US_ASCII), StandardCharsets.US_ASCII)))\n+        ).mapMulti(ConstantDescSymbolsTest::specializeInflation);\n@@ -303,20 +353,1 @@\n-    @ParameterizedTest\n-    @MethodSource(\"inequalityCases\")\n-    <T, P extends PoolEntry> void testInequality(SymbolicTranslator<T, P> translator, T obj, T bad) {\n-        assertNotEquals(obj, bad, \"Bad test data\");\n-        translator.entriesSpawner(obj)\n-                .<PoolEntryCase<P>>mapMulti((src, sink) -> {\n-                    sink.accept(src);\n-                    sink.accept(translator.inflateByTest(src, obj, \"obj\"));\n-                    sink.accept(translator.inflateByTest(src, bad, \"bad\"));\n-                    sink.accept(translator.inflateByComputeSymbol(src));\n-                })\n-                .forEach(scenario -> {\n-                    scenario.test(p -> {\n-                        var asSymbol = translator.extractor.apply(p);\n-                        assertEquals(obj, asSymbol, \"asSym vs obj\");\n-                        assertNotEquals(bad, asSymbol, \"asSym vs bad\");\n-                    });\n-                    scenario.test(p -> assertTrue(translator.tester.test(p, obj), \"eqSym obj\"));\n-                    scenario.test(p -> assertFalse(translator.tester.test(p, bad), \"eqSym bad\"));\n-                });\n+    record InvalidSymbolCase<T, P extends PoolEntry>(SymbolicTranslator<T, P> translator, Supplier<P> factory, T target) {\n@@ -330,20 +361,3 @@\n-    static Stream<Arguments> malformedCases() {\n-        return Stream.of(\n-                Arguments.of(CLASS_ENTRY_TRANSLATOR, badFactory(b -> b.classEntry(b.utf8Entry(\"java.lang.Object\"))), CD_Object), \/\/ class or interface\n-                Arguments.of(CLASS_ENTRY_TRANSLATOR, badFactory(b -> b.classEntry(b.utf8Entry(\"[Ljava\/lang\/String\"))), CD_String.arrayType()), \/\/ array\n-                Arguments.of(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"int\")), ClassDesc.ofDescriptor(\"I\")), \/\/ primitive\n-                Arguments.of(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"Ljava\/lang\/String\")), CD_String), \/\/ class or interface\n-                Arguments.of(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"[Ljava\/lang\/String\")), CD_String.arrayType()), \/\/ array\n-                Arguments.of(METHOD_TYPE_ENTRY_TRANSLATOR, badFactory(b -> b.methodTypeEntry(b.utf8Entry(\"()\"))), MTD_void),\n-                Arguments.of(METHOD_TYPE_ENTRY_TRANSLATOR, badFactory(b -> b.methodTypeEntry(b.utf8Entry(\"(V)\"))), MTD_void),\n-                Arguments.of(UTF8_METHOD_TYPE_TRANSLATOR, badFactory(b -> b.utf8Entry(\"()Ljava\/lang\/String\")), MethodTypeDesc.of(CD_String)),\n-                Arguments.of(PACKAGE_ENTRY_TRANSLATOR, badFactory(b -> b.packageEntry(b.utf8Entry(\"java.lang\"))), PackageDesc.of(\"java.lang\")),\n-                Arguments.of(MODULE_ENTRY_TRANSLATOR, badFactory(b -> b.moduleEntry(b.utf8Entry(\"java@base\"))), ModuleDesc.of(\"java.base\"))\n-        );\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"malformedCases\")\n-    <T, P extends PoolEntry> void testMalformed(SymbolicTranslator<T, P> translator, Supplier<P> factory, T target) {\n-        translator.entriesSpawner(factory)\n-                .<PoolEntryCase<P>>mapMulti((src, sink) -> {\n+    static <T, P extends PoolEntry> void specializeInflation(InvalidSymbolCase<T, P> invalidSymbolCase, Consumer<Arguments> callArgs) {\n+        invalidSymbolCase.translator.spawnBounded(invalidSymbolCase.factory)\n+                .<StatefulPoolEntry<P>>mapMulti((src, sink) -> {\n@@ -351,1 +365,1 @@\n-                    sink.accept(translator.inflateByTest(src, target, \"target\"));\n+                    sink.accept(invalidSymbolCase.translator.inflateByMatching(src, invalidSymbolCase.target, \"target\"));\n@@ -353,4 +367,16 @@\n-                .forEach(scenario -> {\n-                    scenario.test(p -> assertThrows(IllegalArgumentException.class, () -> translator.extractor.apply(p), \"asSym\"));\n-                    scenario.test(p -> assertFalse(translator.tester.test(p, target), \"eqSym\"));\n-                });\n+                .forEach(stateful -> callArgs.accept(Arguments.of(invalidSymbolCase, stateful.desc, stateful.factory.get())));\n+    }\n+\n+    static Stream<Arguments> malformedCases() {\n+        return Stream.of(\n+                new InvalidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, badFactory(b -> b.classEntry(b.utf8Entry(\"java.lang.Object\"))), CD_Object), \/\/ class or interface\n+                new InvalidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, badFactory(b -> b.classEntry(b.utf8Entry(\"[Ljava\/lang\/String\"))), CD_String.arrayType()), \/\/ array\n+                new InvalidSymbolCase<>(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"int\")), ClassDesc.ofDescriptor(\"I\")), \/\/ primitive\n+                new InvalidSymbolCase<>(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"Ljava\/lang\/String\")), CD_String), \/\/ class or interface\n+                new InvalidSymbolCase<>(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"[Ljava\/lang\/String\")), CD_String.arrayType()), \/\/ array\n+                new InvalidSymbolCase<>(METHOD_TYPE_ENTRY_TRANSLATOR, badFactory(b -> b.methodTypeEntry(b.utf8Entry(\"()\"))), MTD_void),\n+                new InvalidSymbolCase<>(METHOD_TYPE_ENTRY_TRANSLATOR, badFactory(b -> b.methodTypeEntry(b.utf8Entry(\"(V)\"))), MTD_void),\n+                new InvalidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, badFactory(b -> b.utf8Entry(\"()Ljava\/lang\/String\")), MethodTypeDesc.of(CD_String)),\n+                new InvalidSymbolCase<>(PACKAGE_ENTRY_TRANSLATOR, badFactory(b -> b.packageEntry(b.utf8Entry(\"java.lang\"))), PackageDesc.of(\"java.lang\")),\n+                new InvalidSymbolCase<>(MODULE_ENTRY_TRANSLATOR, badFactory(b -> b.moduleEntry(b.utf8Entry(\"java@base\"))), ModuleDesc.of(\"java.base\"))\n+        ).mapMulti(ConstantDescSymbolsTest::specializeInflation);\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":146,"deletions":120,"binary":false,"changes":266,"status":"modified"}]}