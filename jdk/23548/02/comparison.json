{"files":[{"patch":"@@ -107,0 +107,5 @@\n+     * @apiNote\n+     * If only symbol equivalence is desired, {@link #matches(ClassDesc)\n+     * matches} should be used.  It requires reduced parsing and can\n+     * improve {@code class} file reading performance.\n+     *\n@@ -111,0 +116,9 @@\n+\n+    \/**\n+     * {@return whether this entry describes the given reference type}  Returns\n+     * {@code false} if {@code desc} is primitive.\n+     *\n+     * @param desc the reference type\n+     * @since 25\n+     *\/\n+    boolean matches(ClassDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ClassEntry.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -73,0 +73,5 @@\n+     *\n+     * @apiNote\n+     * If only symbol equivalence is desired, {@link #matches(MethodTypeDesc)\n+     * matches} should be used.  It requires reduced parsing and can\n+     * improve {@code class} file reading performance.\n@@ -75,0 +80,8 @@\n+\n+    \/**\n+     * {@return whether this entry describes the given method type}\n+     *\n+     * @param desc the method type descriptor\n+     * @since 25\n+     *\/\n+    boolean matches(MethodTypeDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MethodTypeEntry.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -58,0 +58,5 @@\n+     *\n+     * @apiNote\n+     * If only symbol equivalence is desired, {@link #matches(ModuleDesc)\n+     * matches} should be used.  It requires reduced parsing and can\n+     * improve {@code class} file reading performance.\n@@ -60,0 +65,8 @@\n+\n+    \/**\n+     * {@return whether this entry describes the given module}\n+     *\n+     * @param desc the module descriptor\n+     * @since 25\n+     *\/\n+    boolean matches(ModuleDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ModuleEntry.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -61,0 +61,5 @@\n+     *\n+     * @apiNote\n+     * If only symbol equivalence is desired, {@link #matches(PackageDesc)\n+     * matches} should be used.  It requires reduced parsing and can\n+     * improve {@code class} file reading performance.\n@@ -63,0 +68,8 @@\n+\n+    \/**\n+     * {@return whether this entry describes the given package}\n+     *\n+     * @param desc the package descriptor\n+     * @since 25\n+     *\/\n+    boolean matches(PackageDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/PackageEntry.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -59,0 +59,7 @@\n+     * @apiNote\n+     * A {@code Utf8Entry} can be used directly as a {@link CharSequence} if\n+     * {@code String} functionalities are not strictly desired.  If only string\n+     * equivalence is desired, {@link #equalsString(String) equalsString} should\n+     * be used.  Reduction of string processing can significantly improve {@code\n+     * class} file reading performance.\n+     *\n@@ -62,0 +69,8 @@\n+\n+    \/**\n+     * {@return whether this entry describes the same string as the provided string}\n+     *\n+     * @param value the string to compare to\n+     * @since 25\n+     *\/\n+    boolean equalsString(String value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/StringEntry.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -87,0 +87,18 @@\n+\n+    \/**\n+     * {@return whether this entry describes the descriptor string of this\n+     * field type}\n+     *\n+     * @param desc the field type\n+     * @since 25\n+     *\/\n+    boolean isFieldType(ClassDesc desc);\n+\n+    \/**\n+     * {@return whether this entry describes the descriptor string of this\n+     * method type}\n+     *\n+     * @param desc the method type\n+     * @since 25\n+     *\/\n+    boolean isMethodType(MethodTypeDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/Utf8Entry.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n+import jdk.internal.constant.PrimitiveClassDescImpl;\n@@ -76,5 +78,0 @@\n-    static boolean isArrayDescriptor(Utf8EntryImpl cs) {\n-        \/\/ Do not throw out-of-bounds for empty strings\n-        return !cs.isEmpty() && cs.charAt(0) == '[';\n-    }\n-\n@@ -441,0 +438,73 @@\n+\n+        @Override\n+        public boolean isFieldType(ClassDesc desc) {\n+            var sym = typeSym;\n+            if (sym != null) {\n+                return sym instanceof ClassDesc cd && cd.equals(desc);\n+            }\n+\n+            \/\/ In parsing, Utf8Entry is not even inflated by this point\n+            \/\/ We can operate on the raw byte arrays, as all ascii are compatible\n+            var ret = state == State.RAW\n+                    ? rawEqualsSym(desc)\n+                    : equalsString(desc.descriptorString());\n+            if (ret)\n+                this.typeSym = desc;\n+            return ret;\n+        }\n+\n+        private boolean rawEqualsSym(ClassDesc desc) {\n+            int len = rawLen;\n+            if (len < 1) {\n+                return false;\n+            }\n+            int c = rawBytes[offset];\n+            if (len == 1) {\n+                return desc instanceof PrimitiveClassDescImpl pd && pd.wrapper().basicTypeChar() == c;\n+            } else if (c == 'L') {\n+                return desc.isClassOrInterface() && equalsString(desc.descriptorString());\n+            } else if (c == '[') {\n+                return desc.isArray() && equalsString(desc.descriptorString());\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        boolean mayBeArrayDescriptor() {\n+            if (state == State.RAW) {\n+                return rawLen > 0 && rawBytes[offset] == '[';\n+            } else {\n+                return charLen > 0 && charAt(0) == '[';\n+            }\n+        }\n+\n+        @Override\n+        public boolean isMethodType(MethodTypeDesc desc) {\n+            var sym = typeSym;\n+            if (sym != null) {\n+                return sym instanceof MethodTypeDesc mtd && mtd.equals(desc);\n+            }\n+\n+            \/\/ In parsing, Utf8Entry is not even inflated by this point\n+            \/\/ We can operate on the raw byte arrays, as all ascii are compatible\n+            var ret = state == State.RAW\n+                    ? rawEqualsSym(desc)\n+                    : equalsString(desc.descriptorString());\n+            if (ret)\n+                this.typeSym = desc;\n+            return ret;\n+        }\n+\n+        private boolean rawEqualsSym(MethodTypeDesc desc) {\n+            if (rawLen < 3) {\n+                return false;\n+            }\n+            var bytes = rawBytes;\n+            int index = offset;\n+            int c = bytes[index] | (bytes[index + 1] << Byte.SIZE);\n+            if ((desc.parameterCount() == 0) != (c == ('(' | (')' << Byte.SIZE)))) {\n+                \/\/ heuristic - avoid inflation for no-arg status mismatch\n+                return false;\n+            }\n+            return (c & 0xFF) == '(' && equalsString(desc.descriptorString());\n+        }\n@@ -541,1 +611,1 @@\n-            if (isArrayDescriptor(ref1)) {\n+            if (ref1.mayBeArrayDescriptor()) {\n@@ -549,0 +619,22 @@\n+        @Override\n+        public boolean matches(ClassDesc desc) {\n+            var sym = this.sym;\n+            if (sym != null) {\n+                return sym.equals(desc);\n+            }\n+\n+            var ret = rawEqualsSymbol(desc);\n+            if (ret)\n+                this.sym = desc;\n+            return ret;\n+        }\n+\n+        private boolean rawEqualsSymbol(ClassDesc desc) {\n+            if (ref1.mayBeArrayDescriptor()) {\n+                return desc.isArray() && ref1.isFieldType(desc);\n+            } else {\n+                return desc instanceof ClassOrInterfaceDescImpl coid\n+                        && ref1.equalsString(coid.internalName());\n+            }\n+        }\n+\n@@ -574,1 +666,1 @@\n-            return this.hash = hashClassFromUtf8(isArrayDescriptor(ref1), ref1);\n+            return this.hash = hashClassFromUtf8(ref1.mayBeArrayDescriptor(), ref1);\n@@ -599,0 +691,5 @@\n+        @Override\n+        public boolean matches(PackageDesc desc) {\n+            return ref1.equalsString(desc.internalName());\n+        }\n+\n@@ -630,0 +727,5 @@\n+        @Override\n+        public boolean matches(ModuleDesc desc) {\n+            return ref1.equalsString(desc.name());\n+        }\n+\n@@ -986,0 +1088,5 @@\n+        @Override\n+        public boolean matches(MethodTypeDesc desc) {\n+            return ref1.isMethodType(desc);\n+        }\n+\n@@ -1019,0 +1126,5 @@\n+        @Override\n+        public boolean equalsString(String value) {\n+            return ref1.equalsString(value);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":120,"deletions":8,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -500,1 +500,1 @@\n-        return classEntry(ne, AbstractPoolEntry.isArrayDescriptor(ne));\n+        return classEntry(ne, ne.mayBeArrayDescriptor());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,5 +33,2 @@\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodHandleDesc;\n-import java.lang.constant.MethodTypeDesc;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.constant.*;\n@@ -40,0 +37,5 @@\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n@@ -44,1 +46,1 @@\n-import jdk.internal.classfile.impl.AbstractPoolEntry;\n+import jdk.internal.classfile.impl.Util;\n@@ -49,0 +51,1 @@\n+import org.junit.jupiter.params.provider.Arguments;\n@@ -91,1 +94,2 @@\n-        record CondyBoot(MethodHandles.Lookup lookup, String name, Class<?> type) {}\n+        record CondyBoot(MethodHandles.Lookup lookup, String name, Class<?> type) {\n+        }\n@@ -168,0 +172,212 @@\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalityCases\")\n+    <T, P extends PoolEntry> void testAsSymbolEquality(ValidSymbolCase<T, P> validSymbolCase, String entryState, P p) {\n+        var asSymbol = validSymbolCase.translator.extractor.apply(p);\n+        assertEquals(validSymbolCase.sym, asSymbol, \"asSym vs sym\");\n+        assertEquals(validSymbolCase.other, asSymbol, \"asSym vs other sym\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalityCases\")\n+    <T, P extends PoolEntry> void testMatchesOriginalEquality(ValidSymbolCase<T, P> validSymbolCase, String entryState, P p) {\n+        assertTrue(validSymbolCase.translator.tester.test(p, validSymbolCase.sym));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalityCases\")\n+    <T, P extends PoolEntry> void testMatchesEquivalentEquality(ValidSymbolCase<T, P> validSymbolCase, String entryState, P p) {\n+        assertTrue(validSymbolCase.translator.tester.test(p, validSymbolCase.other));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inequalityCases\")\n+    <T, P extends PoolEntry> void testAsSymbolInequality(ValidSymbolCase<T, P> validSymbolCase, String stateName, P p) {\n+        var asSymbol = validSymbolCase.translator.extractor.apply(p);\n+        assertEquals(validSymbolCase.sym, asSymbol, \"asSymbol vs original\");\n+        assertNotEquals(validSymbolCase.other, asSymbol, \"asSymbol vs inequal\");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inequalityCases\")\n+    <T, P extends PoolEntry> void testMatchesOriginalInequality(ValidSymbolCase<T, P> validSymbolCase, String stateName, P p) {\n+        assertTrue(validSymbolCase.translator.tester.test(p, validSymbolCase.sym));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inequalityCases\")\n+    <T, P extends PoolEntry> void testMatchesNonEquivalentInequality(ValidSymbolCase<T, P> validSymbolCase, String stateName, P p) {\n+        assertFalse(validSymbolCase.translator.tester.test(p, validSymbolCase.other));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"malformedCases\")\n+    <T, P extends PoolEntry> void testAsSymbolMalformed(InvalidSymbolCase<T, P> baseCase, String entryState, P p) {\n+        assertThrows(IllegalArgumentException.class, () -> baseCase.translator.extractor.apply(p));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"malformedCases\")\n+    <T, P extends PoolEntry> void testMatchesMalformed(InvalidSymbolCase<T, P> baseCase, String entryState, P p) {\n+        assertFalse(baseCase.translator.tester.test(p, baseCase.target));\n+    }\n+\n+    \/\/ Support for complex pool entry creation with different inflation states.\n+    \/\/ Inflation states include:\n+    \/\/   - bound\/unbound,\n+    \/\/   - asSymbol()\n+    \/\/   - matches() resulting in match\n+    \/\/   - matches() resulting in mismatch\n+\n+    \/\/ a pool entry, suitable for testing lazy behaviors and has descriptive name\n+    record StatefulPoolEntry<P>(String desc, Supplier<P> factory) {\n+    }\n+\n+    \/\/ Test pool entry <-> nominal descriptor, also the equals methods\n+    record SymbolicTranslator<T, P extends PoolEntry>(String name, BiFunction<ConstantPoolBuilder, T, P> writer,\n+                                                      BiPredicate<P, T> tester, Function<P, T> extractor) {\n+        private P createUnboundEntry(T symbol) {\n+            ConstantPoolBuilder cpb = ConstantPoolBuilder.of(); \/\/ Temp pool does not support some entries\n+            return writer.apply(cpb, symbol);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private P toBoundEntry(P unboundEntry) {\n+            ConstantPoolBuilder cpb = (ConstantPoolBuilder) unboundEntry.constantPool();\n+            int index = unboundEntry.index();\n+            var bytes = ClassFile.of().build(cpb.classEntry(ClassDesc.of(\"Test\")), cpb, _ -> {\n+            });\n+            return (P) ClassFile.of().parse(bytes).constantPool().entryByIndex(index);\n+        }\n+\n+        \/\/ Spawn entries to test from a nominal descriptor\n+        public Stream<StatefulPoolEntry<P>> entriesSpawner(T original) {\n+            return spawnBounded(() -> this.createUnboundEntry(original));\n+        }\n+\n+        \/\/ Spawn additional bound entries to test from an initial unbound entry\n+        public Stream<StatefulPoolEntry<P>> spawnBounded(Supplier<P> original) {\n+            return Stream.of(new StatefulPoolEntry<>(original.get().toString(), original))\n+                    .mapMulti((s, sink) -> {\n+                        sink.accept(s); \/\/ unbound\n+                        sink.accept(new StatefulPoolEntry<>(s.desc + \"+lazy\", () -> toBoundEntry(s.factory.get()))); \/\/ bound\n+                    });\n+        }\n+\n+        \/\/ Add extra stage of entry spawn to \"inflate\" entries via positive\/negative tests\n+        public StatefulPoolEntry<P> inflateByMatching(StatefulPoolEntry<P> last, T arg, String msg) {\n+            return new StatefulPoolEntry<>(\"+matches(\" + msg + \")\", () -> {\n+                var ret = last.factory.get();\n+                tester.test(ret, arg);\n+                return ret;\n+            });\n+        }\n+\n+        \/\/ Add extra stage of entry spawn to \"inflate\" entries via descriptor computation\n+        \/\/ This should not be used if the pool entry may be invalid (i.e. throws IAE)\n+        public StatefulPoolEntry<P> inflateByComputeSymbol(StatefulPoolEntry<P> last) {\n+            return new StatefulPoolEntry<>(last.desc + \"+asSymbol()\", () -> {\n+                var ret = last.factory.get();\n+                extractor.apply(ret);\n+                return ret;\n+            });\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name; \/\/ don't include lambda garbage in failure reports\n+        }\n+    }\n+\n+    \/\/ A case testing valid symbol sym; other is another symbol that may match or mismatch.\n+    record ValidSymbolCase<T, P extends PoolEntry>(SymbolicTranslator<T, P> translator, T sym, T other) {\n+    }\n+\n+    \/\/ Current supported conversions\n+    static final SymbolicTranslator<String, Utf8Entry> UTF8_STRING_TRANSLATOR = new SymbolicTranslator<>(\"Utf8\", ConstantPoolBuilder::utf8Entry, Utf8Entry::equalsString, Utf8Entry::stringValue);\n+    static final SymbolicTranslator<ClassDesc, Utf8Entry> UTF8_CLASS_TRANSLATOR = new SymbolicTranslator<>(\"FieldTypeUtf8\", ConstantPoolBuilder::utf8Entry, Utf8Entry::isFieldType, Util::fieldTypeSymbol);\n+    static final SymbolicTranslator<MethodTypeDesc, Utf8Entry> UTF8_METHOD_TYPE_TRANSLATOR = new SymbolicTranslator<>(\"MethodTypeUtf8\", ConstantPoolBuilder::utf8Entry, Utf8Entry::isMethodType, Util::methodTypeSymbol);\n+    static final SymbolicTranslator<ClassDesc, ClassEntry> CLASS_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"ClassEntry\", ConstantPoolBuilder::classEntry, ClassEntry::matches, ClassEntry::asSymbol);\n+    static final SymbolicTranslator<MethodTypeDesc, MethodTypeEntry> METHOD_TYPE_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"MethodTypeEntry\", ConstantPoolBuilder::methodTypeEntry, MethodTypeEntry::matches, MethodTypeEntry::asSymbol);\n+    static final SymbolicTranslator<String, StringEntry> STRING_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"StringEntry\", ConstantPoolBuilder::stringEntry, StringEntry::equalsString, StringEntry::stringValue);\n+    static final SymbolicTranslator<PackageDesc, PackageEntry> PACKAGE_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"PackageEntry\", ConstantPoolBuilder::packageEntry, PackageEntry::matches, PackageEntry::asSymbol);\n+    static final SymbolicTranslator<ModuleDesc, ModuleEntry> MODULE_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"ModuleEntry\", ConstantPoolBuilder::moduleEntry, ModuleEntry::matches, ModuleEntry::asSymbol);\n+\n+    \/\/ Create arguments of tuple (ValidSymbolCase, entryState, PoolEntry) to verify symbolic behavior of pool entries\n+    \/\/ with particular inflation states\n+    static <T, P extends PoolEntry> void specializeInflation(ValidSymbolCase<T, P> validSymbolCase, Consumer<Arguments> callArgs) {\n+        validSymbolCase.translator.entriesSpawner(validSymbolCase.sym)\n+                .<StatefulPoolEntry<P>>mapMulti((src, sink) -> {\n+                    sink.accept(src);\n+                    sink.accept(validSymbolCase.translator.inflateByMatching(src, validSymbolCase.sym, \"same symbol\"));\n+                    sink.accept(validSymbolCase.translator.inflateByMatching(src, validSymbolCase.other, \"another symbol\"));\n+                    sink.accept(validSymbolCase.translator.inflateByComputeSymbol(src));\n+                })\n+                .forEach(stateful -> callArgs.accept(Arguments.of(validSymbolCase, stateful.desc, stateful.factory.get())));\n+    }\n+\n+    static Stream<Arguments> equalityCases() {\n+        return Stream.of(\n+                new ValidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/Object\")), \/\/ class or interface\n+                new ValidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/Object;\")), \/\/ array\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_int, ClassDesc.ofDescriptor(\"I\")), \/\/ primitive\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/Object\")), \/\/ class or interface\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/Object;\")), \/\/ array\n+                new ValidSymbolCase<>(UTF8_STRING_TRANSLATOR, \"Ab\\u0000c\", \"Ab\\u0000c\"),\n+                new ValidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, MTD_void, MethodTypeDesc.ofDescriptor(\"()V\")),\n+                new ValidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, MethodTypeDesc.of(CD_int, CD_Long), MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Long;)I\")),\n+                new ValidSymbolCase<>(METHOD_TYPE_ENTRY_TRANSLATOR, MethodTypeDesc.of(CD_Object), MethodTypeDesc.ofDescriptor(\"()Ljava\/lang\/Object;\")),\n+                new ValidSymbolCase<>(STRING_ENTRY_TRANSLATOR, \"Ape\", new String(\"Ape\".getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8)),\n+                new ValidSymbolCase<>(PACKAGE_ENTRY_TRANSLATOR, PackageDesc.of(\"java.lang\"), PackageDesc.ofInternalName(\"java\/lang\")),\n+                new ValidSymbolCase<>(MODULE_ENTRY_TRANSLATOR, ModuleDesc.of(\"java.base\"), ModuleDesc.of(new String(\"java.base\".getBytes(StandardCharsets.US_ASCII), StandardCharsets.US_ASCII)))\n+        ).mapMulti(ConstantDescSymbolsTest::specializeInflation);\n+    }\n+\n+    static Stream<Arguments> inequalityCases() {\n+        return Stream.of(\n+                new ValidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/io\/Object\")), \/\/ class or interface\n+                new ValidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/String;\")), \/\/ array\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_int, ClassDesc.ofDescriptor(\"S\")), \/\/ primitive\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/String\")), \/\/ class or interface\n+                new ValidSymbolCase<>(UTF8_CLASS_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/System;\")), \/\/ array\n+                new ValidSymbolCase<>(UTF8_STRING_TRANSLATOR, \"Ab\\u0000c\", \"Abdc\"),\n+                new ValidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, MTD_void, MethodTypeDesc.ofDescriptor(\"()I\")),\n+                new ValidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, MethodTypeDesc.of(CD_int, CD_Short), MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Long;)I\")),\n+                new ValidSymbolCase<>(METHOD_TYPE_ENTRY_TRANSLATOR, MethodTypeDesc.of(CD_String), MethodTypeDesc.ofDescriptor(\"()Ljava\/lang\/Object;\")),\n+                new ValidSymbolCase<>(STRING_ENTRY_TRANSLATOR, \"Cat\", new String(\"Ape\".getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8)),\n+                new ValidSymbolCase<>(PACKAGE_ENTRY_TRANSLATOR, PackageDesc.of(\"java.lang\"), PackageDesc.ofInternalName(\"java\/util\")),\n+                new ValidSymbolCase<>(MODULE_ENTRY_TRANSLATOR, ModuleDesc.of(\"java.base\"), ModuleDesc.of(new String(\"java.desktop\".getBytes(StandardCharsets.US_ASCII), StandardCharsets.US_ASCII)))\n+        ).mapMulti(ConstantDescSymbolsTest::specializeInflation);\n+    }\n+\n+    record InvalidSymbolCase<T, P extends PoolEntry>(SymbolicTranslator<T, P> translator, Supplier<P> factory, T target) {\n+    }\n+\n+    \/\/ Type hint function\n+    private static <P extends PoolEntry> Supplier<P> badFactory(Function<ConstantPoolBuilder, P> func) {\n+        return () -> func.apply(ConstantPoolBuilder.of());\n+    }\n+\n+    static <T, P extends PoolEntry> void specializeInflation(InvalidSymbolCase<T, P> invalidSymbolCase, Consumer<Arguments> callArgs) {\n+        invalidSymbolCase.translator.spawnBounded(invalidSymbolCase.factory)\n+                .<StatefulPoolEntry<P>>mapMulti((src, sink) -> {\n+                    sink.accept(src);\n+                    sink.accept(invalidSymbolCase.translator.inflateByMatching(src, invalidSymbolCase.target, \"target\"));\n+                })\n+                .forEach(stateful -> callArgs.accept(Arguments.of(invalidSymbolCase, stateful.desc, stateful.factory.get())));\n+    }\n+\n+    static Stream<Arguments> malformedCases() {\n+        return Stream.of(\n+                new InvalidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, badFactory(b -> b.classEntry(b.utf8Entry(\"java.lang.Object\"))), CD_Object), \/\/ class or interface\n+                new InvalidSymbolCase<>(CLASS_ENTRY_TRANSLATOR, badFactory(b -> b.classEntry(b.utf8Entry(\"[Ljava\/lang\/String\"))), CD_String.arrayType()), \/\/ array\n+                new InvalidSymbolCase<>(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"int\")), ClassDesc.ofDescriptor(\"I\")), \/\/ primitive\n+                new InvalidSymbolCase<>(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"Ljava\/lang\/String\")), CD_String), \/\/ class or interface\n+                new InvalidSymbolCase<>(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"[Ljava\/lang\/String\")), CD_String.arrayType()), \/\/ array\n+                new InvalidSymbolCase<>(METHOD_TYPE_ENTRY_TRANSLATOR, badFactory(b -> b.methodTypeEntry(b.utf8Entry(\"()\"))), MTD_void),\n+                new InvalidSymbolCase<>(METHOD_TYPE_ENTRY_TRANSLATOR, badFactory(b -> b.methodTypeEntry(b.utf8Entry(\"(V)\"))), MTD_void),\n+                new InvalidSymbolCase<>(UTF8_METHOD_TYPE_TRANSLATOR, badFactory(b -> b.utf8Entry(\"()Ljava\/lang\/String\")), MethodTypeDesc.of(CD_String)),\n+                new InvalidSymbolCase<>(PACKAGE_ENTRY_TRANSLATOR, badFactory(b -> b.packageEntry(b.utf8Entry(\"java.lang\"))), PackageDesc.of(\"java.lang\")),\n+                new InvalidSymbolCase<>(MODULE_ENTRY_TRANSLATOR, badFactory(b -> b.moduleEntry(b.utf8Entry(\"java@base\"))), ModuleDesc.of(\"java.base\"))\n+        ).mapMulti(ConstantDescSymbolsTest::specializeInflation);\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":224,"deletions":8,"binary":false,"changes":232,"status":"modified"}]}