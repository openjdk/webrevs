{"files":[{"patch":"@@ -107,0 +107,5 @@\n+     * @apiNote\n+     * If only symbol equivalence is desired, {@link #equalsSymbol(ClassDesc)\n+     * equalsSymbol} should be used.  It requires reduced parsing and can\n+     * improve {@code class} file reading performance.\n+     *\n@@ -111,0 +116,9 @@\n+\n+    \/**\n+     * {@return whether this entry describes the given reference type}  Returns\n+     * {@code false} if {@code desc} is primitive.\n+     *\n+     * @param desc the reference type\n+     * @since 25\n+     *\/\n+    boolean equalsSymbol(ClassDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ClassEntry.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -73,0 +73,5 @@\n+     *\n+     * @apiNote\n+     * If only symbol equivalence is desired, {@link #equalsSymbol(MethodTypeDesc)\n+     * equalsSymbol} should be used.  It requires reduced parsing and can\n+     * improve {@code class} file reading performance.\n@@ -75,0 +80,8 @@\n+\n+    \/**\n+     * {@return whether this entry describes the given method type}\n+     *\n+     * @param desc the method type descriptor\n+     * @since 25\n+     *\/\n+    boolean equalsSymbol(MethodTypeDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MethodTypeEntry.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -58,0 +58,5 @@\n+     *\n+     * @apiNote\n+     * If only symbol equivalence is desired, {@link #equalsSymbol(ModuleDesc)\n+     * equalsSymbol} should be used.  It requires reduced parsing and can\n+     * improve {@code class} file reading performance.\n@@ -60,0 +65,8 @@\n+\n+    \/**\n+     * {@return whether this entry describes the given module}\n+     *\n+     * @param desc the module descriptor\n+     * @since 25\n+     *\/\n+    boolean equalsSymbol(ModuleDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ModuleEntry.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -61,0 +61,5 @@\n+     *\n+     * @apiNote\n+     * If only symbol equivalence is desired, {@link #equalsSymbol(PackageDesc)\n+     * equalsSymbol} should be used.  It requires reduced parsing and can\n+     * improve {@code class} file reading performance.\n@@ -63,0 +68,8 @@\n+\n+    \/**\n+     * {@return whether this entry describes the given package}\n+     *\n+     * @param desc the package descriptor\n+     * @since 25\n+     *\/\n+    boolean equalsSymbol(PackageDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/PackageEntry.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -59,0 +59,7 @@\n+     * @apiNote\n+     * A {@code Utf8Entry} can be used directly as a {@link CharSequence} if\n+     * {@code String} functionalities are not strictly desired.  If only string\n+     * equivalence is desired, {@link #equalsString(String) equalsString} should\n+     * be used.  Reduction of string processing can significantly improve {@code\n+     * class} file reading performance.\n+     *\n@@ -62,0 +69,8 @@\n+\n+    \/**\n+     * {@return whether this entry describes the same string as the provided string}\n+     *\n+     * @param value the string to compare to\n+     * @since 25\n+     *\/\n+    boolean equalsString(String value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/StringEntry.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -87,0 +87,18 @@\n+\n+    \/**\n+     * {@return whether this entry describes the descriptor string of this\n+     * field type}\n+     *\n+     * @param desc the field type\n+     * @since 25\n+     *\/\n+    boolean equalsSymbol(ClassDesc desc);\n+\n+    \/**\n+     * {@return whether this entry describes the descriptor string of this\n+     * method type}\n+     *\n+     * @param desc the method type\n+     * @since 25\n+     *\/\n+    boolean equalsSymbol(MethodTypeDesc desc);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/Utf8Entry.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jdk.internal.constant.ClassOrInterfaceDescImpl;\n+import jdk.internal.constant.PrimitiveClassDescImpl;\n@@ -76,5 +78,0 @@\n-    static boolean isArrayDescriptor(Utf8EntryImpl cs) {\n-        \/\/ Do not throw out-of-bounds for empty strings\n-        return !cs.isEmpty() && cs.charAt(0) == '[';\n-    }\n-\n@@ -441,0 +438,73 @@\n+\n+        @Override\n+        public boolean equalsSymbol(ClassDesc desc) {\n+            var sym = typeSym;\n+            if (sym != null) {\n+                return sym instanceof ClassDesc cd && cd.equals(desc);\n+            }\n+\n+            \/\/ In parsing, Utf8Entry is not even inflated by this point\n+            \/\/ We can operate on the raw byte arrays, as all ascii are compatible\n+            var ret = state == State.RAW\n+                    ? rawEqualsSym(desc)\n+                    : equalsString(desc.descriptorString());\n+            if (ret)\n+                this.typeSym = desc;\n+            return ret;\n+        }\n+\n+        private boolean rawEqualsSym(ClassDesc desc) {\n+            int len = rawLen;\n+            if (len < 1) {\n+                return false;\n+            }\n+            int c = rawBytes[offset];\n+            if (len == 1) {\n+                return desc instanceof PrimitiveClassDescImpl pd && pd.wrapper().basicTypeChar() == c;\n+            } else if (c == 'L') {\n+                return desc.isClassOrInterface() && equalsString(desc.descriptorString());\n+            } else if (c == '[') {\n+                return desc.isArray() && equalsString(desc.descriptorString());\n+            } else {\n+                return false;\n+            }\n+        }\n+\n+        boolean mayBeArrayDescriptor() {\n+            if (state == State.RAW) {\n+                return rawLen > 0 && rawBytes[offset] == '[';\n+            } else {\n+                return charLen > 0 && charAt(0) == '[';\n+            }\n+        }\n+\n+        @Override\n+        public boolean equalsSymbol(MethodTypeDesc desc) {\n+            var sym = typeSym;\n+            if (sym != null) {\n+                return sym instanceof MethodTypeDesc mtd && mtd.equals(desc);\n+            }\n+\n+            \/\/ In parsing, Utf8Entry is not even inflated by this point\n+            \/\/ We can operate on the raw byte arrays, as all ascii are compatible\n+            var ret = state == State.RAW\n+                    ? rawEqualsSym(desc)\n+                    : equalsString(desc.descriptorString());\n+            if (ret)\n+                this.typeSym = desc;\n+            return ret;\n+        }\n+\n+        private boolean rawEqualsSym(MethodTypeDesc desc) {\n+            if (rawLen < 3) {\n+                return false;\n+            }\n+            var bytes = rawBytes;\n+            int index = offset;\n+            int c = bytes[index] | (bytes[index + 1] << Byte.SIZE);\n+            if ((desc.parameterCount() == 0) != (c == ('(' | (')' << Byte.SIZE)))) {\n+                \/\/ heuristic - avoid inflation for no-arg status mismatch\n+                return false;\n+            }\n+            return (c & 0xFF) == '(' && equalsString(desc.descriptorString());\n+        }\n@@ -541,1 +611,1 @@\n-            if (isArrayDescriptor(ref1)) {\n+            if (ref1.mayBeArrayDescriptor()) {\n@@ -549,0 +619,22 @@\n+        @Override\n+        public boolean equalsSymbol(ClassDesc desc) {\n+            var sym = this.sym;\n+            if (sym != null) {\n+                return sym.equals(desc);\n+            }\n+\n+            var ret = rawEqualsSymbol(desc);\n+            if (ret)\n+                this.sym = desc;\n+            return ret;\n+        }\n+\n+        private boolean rawEqualsSymbol(ClassDesc desc) {\n+            if (ref1.mayBeArrayDescriptor()) {\n+                return desc.isArray() && ref1.equalsSymbol(desc);\n+            } else {\n+                return desc instanceof ClassOrInterfaceDescImpl coid\n+                        && ref1.equalsString(coid.internalName());\n+            }\n+        }\n+\n@@ -574,1 +666,1 @@\n-            return this.hash = hashClassFromUtf8(isArrayDescriptor(ref1), ref1);\n+            return this.hash = hashClassFromUtf8(ref1.mayBeArrayDescriptor(), ref1);\n@@ -599,0 +691,5 @@\n+        @Override\n+        public boolean equalsSymbol(PackageDesc desc) {\n+            return ref1.equalsString(desc.internalName());\n+        }\n+\n@@ -630,0 +727,5 @@\n+        @Override\n+        public boolean equalsSymbol(ModuleDesc desc) {\n+            return ref1.equalsString(desc.name());\n+        }\n+\n@@ -986,0 +1088,5 @@\n+        @Override\n+        public boolean equalsSymbol(MethodTypeDesc desc) {\n+            return ref1.equalsSymbol(desc);\n+        }\n+\n@@ -1019,0 +1126,5 @@\n+        @Override\n+        public boolean equalsString(String value) {\n+            return ref1.equalsString(value);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":120,"deletions":8,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -500,1 +500,1 @@\n-        return classEntry(ne, AbstractPoolEntry.isArrayDescriptor(ne));\n+        return classEntry(ne, ne.mayBeArrayDescriptor());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,5 +33,2 @@\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.DynamicConstantDesc;\n-import java.lang.constant.MethodHandleDesc;\n-import java.lang.constant.MethodTypeDesc;\n+import java.lang.classfile.constantpool.*;\n+import java.lang.constant.*;\n@@ -40,0 +37,4 @@\n+import java.nio.charset.StandardCharsets;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n@@ -44,1 +45,1 @@\n-import jdk.internal.classfile.impl.AbstractPoolEntry;\n+import jdk.internal.classfile.impl.Util;\n@@ -48,0 +49,1 @@\n+import org.junit.jupiter.api.function.ThrowingConsumer;\n@@ -49,0 +51,1 @@\n+import org.junit.jupiter.params.provider.Arguments;\n@@ -168,0 +171,187 @@\n+\n+    \/\/ a pool entry, suitable for testing lazy behaviors and has descriptive name\n+    record PoolEntryCase<P>(String desc, Supplier<P> poolEntry) {\n+        void test(ThrowingConsumer<P> job) {\n+            try {\n+                job.accept(poolEntry.get());\n+            } catch (Throwable e) {\n+                Assertions.fail(\"Tested entry: \" + desc, e);\n+            }\n+        }\n+    }\n+\n+    \/\/ Test pool entry <-> nominal descriptor, also the equals methods\n+    record SymbolicTranslator<T, P extends PoolEntry>(String name, BiFunction<ConstantPoolBuilder, T, P> writer, BiPredicate<P, T> tester, Function<P, T> extractor) {\n+        private P createUnboundEntry(T symbol) {\n+            ConstantPoolBuilder cpb = ConstantPoolBuilder.of(); \/\/ Temp pool does not support some entries\n+            return writer.apply(cpb, symbol);\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private P toBoundEntry(P unboundEntry) {\n+            ConstantPoolBuilder cpb = (ConstantPoolBuilder) unboundEntry.constantPool();\n+            int index = unboundEntry.index();\n+            var bytes = ClassFile.of().build(cpb.classEntry(ClassDesc.of(\"Test\")), cpb, _ -> {});\n+            return (P) ClassFile.of().parse(bytes).constantPool().entryByIndex(index);\n+        }\n+\n+        \/\/ Spawn entries to test from a nominal descriptor\n+        public Stream<PoolEntryCase<P>> entriesSpawner(T original) {\n+            return entriesSpawner(() -> this.createUnboundEntry(original));\n+        }\n+\n+        \/\/ Spawn additional bound entries to test from an initial unbound entry\n+        public Stream<PoolEntryCase<P>> entriesSpawner(Supplier<P> original) {\n+            return Stream.of(new PoolEntryCase<>(original.get().toString(), original))\n+                    .mapMulti((s, sink) -> {\n+                sink.accept(s); \/\/ unbound\n+                sink.accept(new PoolEntryCase<>(s.desc + \"+lazy\", () -> toBoundEntry(s.poolEntry.get()))); \/\/ bound\n+            });\n+        }\n+\n+        \/\/ Add extra stage of entry spawn to \"inflate\" entries via positive\/negative tests\n+        public PoolEntryCase<P> inflateByTest(PoolEntryCase<P> last, T arg, String msg) {\n+            return new PoolEntryCase<>(\"+equalsSymbol(\" + msg + \")\", () -> {\n+                var ret = last.poolEntry.get();\n+                tester.test(ret, arg);\n+                return ret;\n+            });\n+        }\n+\n+        \/\/ Add extra stage of entry spawn to \"inflate\" entries via descriptor computation\n+        \/\/ This should not be used if the pool entry may be invalid (i.e. throws IAE)\n+        public PoolEntryCase<P> inflateByComputeSymbol(PoolEntryCase<P> last) {\n+            return new PoolEntryCase<>(last.desc + \"+asSymbol()\", () -> {\n+                var ret = last.poolEntry.get();\n+                extractor.apply(ret);\n+                return ret;\n+            });\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return name; \/\/ don't include lambda garbage in failure reports\n+        }\n+    }\n+\n+    \/\/ Current supported conversions\n+    static final SymbolicTranslator<String, Utf8Entry> UTF8_STRING_TRANSLATOR = new SymbolicTranslator<>(\"Utf8\", ConstantPoolBuilder::utf8Entry, Utf8Entry::equalsString, Utf8Entry::stringValue);\n+    static final SymbolicTranslator<ClassDesc, Utf8Entry> UTF8_CLASS_TRANSLATOR = new SymbolicTranslator<>(\"FieldDescriptorUtf8\", ConstantPoolBuilder::utf8Entry, Utf8Entry::equalsSymbol, Util::fieldTypeSymbol);\n+    static final SymbolicTranslator<MethodTypeDesc, Utf8Entry> UTF8_METHOD_TYPE_TRANSLATOR = new SymbolicTranslator<>(\"MethodDescriptorUtf8\", ConstantPoolBuilder::utf8Entry, Utf8Entry::equalsSymbol, Util::methodTypeSymbol);\n+    static final SymbolicTranslator<ClassDesc, ClassEntry> CLASS_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"ClassEntry\", ConstantPoolBuilder::classEntry, ClassEntry::equalsSymbol, ClassEntry::asSymbol);\n+    static final SymbolicTranslator<MethodTypeDesc, MethodTypeEntry> METHOD_TYPE_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"MethodTypeEntry\", ConstantPoolBuilder::methodTypeEntry, MethodTypeEntry::equalsSymbol, MethodTypeEntry::asSymbol);\n+    static final SymbolicTranslator<String, StringEntry> STRING_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"StringEntry\", ConstantPoolBuilder::stringEntry, StringEntry::equalsString, StringEntry::stringValue);\n+    static final SymbolicTranslator<PackageDesc, PackageEntry> PACKAGE_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"PackageEntry\", ConstantPoolBuilder::packageEntry, PackageEntry::equalsSymbol, PackageEntry::asSymbol);\n+    static final SymbolicTranslator<ModuleDesc, ModuleEntry> MODULE_ENTRY_TRANSLATOR = new SymbolicTranslator<>(\"ModuleEntry\", ConstantPoolBuilder::moduleEntry, ModuleEntry::equalsSymbol, ModuleEntry::asSymbol);\n+\n+    static Stream<Arguments> equalityCases() {\n+        return Stream.of(\n+                Arguments.of(CLASS_ENTRY_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/Object\")), \/\/ class or interface\n+                Arguments.of(CLASS_ENTRY_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/Object;\")), \/\/ array\n+                Arguments.of(UTF8_CLASS_TRANSLATOR, CD_int, ClassDesc.ofDescriptor(\"I\")), \/\/ primitive\n+                Arguments.of(UTF8_CLASS_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/Object\")), \/\/ class or interface\n+                Arguments.of(UTF8_CLASS_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/Object;\")), \/\/ array\n+                Arguments.of(UTF8_STRING_TRANSLATOR, \"Ab\\u0000c\", \"Ab\\u0000c\"),\n+                Arguments.of(UTF8_METHOD_TYPE_TRANSLATOR, MTD_void, MethodTypeDesc.ofDescriptor(\"()V\")),\n+                Arguments.of(UTF8_METHOD_TYPE_TRANSLATOR, MethodTypeDesc.of(CD_int, CD_Long), MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Long;)I\")),\n+                Arguments.of(METHOD_TYPE_ENTRY_TRANSLATOR, MethodTypeDesc.of(CD_Object), MethodTypeDesc.ofDescriptor(\"()Ljava\/lang\/Object;\")),\n+                Arguments.of(STRING_ENTRY_TRANSLATOR, \"Ape\", new String(\"Ape\".getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8)),\n+                Arguments.of(PACKAGE_ENTRY_TRANSLATOR, PackageDesc.of(\"java.lang\"), PackageDesc.ofInternalName(\"java\/lang\")),\n+                Arguments.of(MODULE_ENTRY_TRANSLATOR, ModuleDesc.of(\"java.base\"), ModuleDesc.of(new String(\"java.base\".getBytes(StandardCharsets.US_ASCII), StandardCharsets.US_ASCII)))\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"equalityCases\")\n+    <T, P extends PoolEntry> void testEquality(SymbolicTranslator<T, P> translator, T first, T alt) {\n+        assertEquals(first, alt, \"Bad test data\");\n+        translator.entriesSpawner(first)\n+                .<PoolEntryCase<P>>mapMulti((src, sink) -> {\n+                    sink.accept(src);\n+                    sink.accept(translator.inflateByTest(src, first, \"first\"));\n+                    sink.accept(translator.inflateByTest(src, alt, \"alt\"));\n+                    sink.accept(translator.inflateByComputeSymbol(src));\n+                })\n+                .forEach(scenario -> {\n+                    scenario.test(p -> {\n+                        var asSymbol = translator.extractor.apply(p);\n+                        assertEquals(first, asSymbol, \"asSym vs first\");\n+                        assertEquals(alt, asSymbol, \"asSym vs alt\");\n+                    });\n+                    scenario.test(p -> assertTrue(translator.tester.test(p, first), \"eqSym first\"));\n+                    scenario.test(p -> assertTrue(translator.tester.test(p, alt), \"eqSym alt\"));\n+                });\n+    }\n+\n+    static Stream<Arguments> inequalityCases() {\n+        return Stream.of(\n+                Arguments.of(CLASS_ENTRY_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/io\/Object\")), \/\/ class or interface\n+                Arguments.of(CLASS_ENTRY_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/String;\")), \/\/ array\n+                Arguments.of(UTF8_CLASS_TRANSLATOR, CD_int, ClassDesc.ofDescriptor(\"S\")), \/\/ primitive\n+                Arguments.of(UTF8_CLASS_TRANSLATOR, CD_Object, ClassDesc.ofInternalName(\"java\/lang\/String\")), \/\/ class or interface\n+                Arguments.of(UTF8_CLASS_TRANSLATOR, CD_Object.arrayType(), ClassDesc.ofDescriptor(\"[Ljava\/lang\/System;\")), \/\/ array\n+                Arguments.of(UTF8_STRING_TRANSLATOR, \"Ab\\u0000c\", \"Abdc\"),\n+                Arguments.of(UTF8_METHOD_TYPE_TRANSLATOR, MTD_void, MethodTypeDesc.ofDescriptor(\"()I\")),\n+                Arguments.of(UTF8_METHOD_TYPE_TRANSLATOR, MethodTypeDesc.of(CD_int, CD_Short), MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Long;)I\")),\n+                Arguments.of(METHOD_TYPE_ENTRY_TRANSLATOR, MethodTypeDesc.of(CD_String), MethodTypeDesc.ofDescriptor(\"()Ljava\/lang\/Object;\")),\n+                Arguments.of(STRING_ENTRY_TRANSLATOR, \"Cat\", new String(\"Ape\".getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8)),\n+                Arguments.of(PACKAGE_ENTRY_TRANSLATOR, PackageDesc.of(\"java.lang\"), PackageDesc.ofInternalName(\"java\/util\")),\n+                Arguments.of(MODULE_ENTRY_TRANSLATOR, ModuleDesc.of(\"java.base\"), ModuleDesc.of(new String(\"java.desktop\".getBytes(StandardCharsets.US_ASCII), StandardCharsets.US_ASCII)))\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"inequalityCases\")\n+    <T, P extends PoolEntry> void testInequality(SymbolicTranslator<T, P> translator, T obj, T bad) {\n+        assertNotEquals(obj, bad, \"Bad test data\");\n+        translator.entriesSpawner(obj)\n+                .<PoolEntryCase<P>>mapMulti((src, sink) -> {\n+                    sink.accept(src);\n+                    sink.accept(translator.inflateByTest(src, obj, \"obj\"));\n+                    sink.accept(translator.inflateByTest(src, bad, \"bad\"));\n+                    sink.accept(translator.inflateByComputeSymbol(src));\n+                })\n+                .forEach(scenario -> {\n+                    scenario.test(p -> {\n+                        var asSymbol = translator.extractor.apply(p);\n+                        assertEquals(obj, asSymbol, \"asSym vs obj\");\n+                        assertNotEquals(bad, asSymbol, \"asSym vs bad\");\n+                    });\n+                    scenario.test(p -> assertTrue(translator.tester.test(p, obj), \"eqSym obj\"));\n+                    scenario.test(p -> assertFalse(translator.tester.test(p, bad), \"eqSym bad\"));\n+                });\n+    }\n+\n+    \/\/ Type hint function\n+    private static <P extends PoolEntry> Supplier<P> badFactory(Function<ConstantPoolBuilder, P> func) {\n+        return () -> func.apply(ConstantPoolBuilder.of());\n+    }\n+\n+    static Stream<Arguments> malformedCases() {\n+        return Stream.of(\n+                Arguments.of(CLASS_ENTRY_TRANSLATOR, badFactory(b -> b.classEntry(b.utf8Entry(\"java.lang.Object\"))), CD_Object), \/\/ class or interface\n+                Arguments.of(CLASS_ENTRY_TRANSLATOR, badFactory(b -> b.classEntry(b.utf8Entry(\"[Ljava\/lang\/String\"))), CD_String.arrayType()), \/\/ array\n+                Arguments.of(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"int\")), ClassDesc.ofDescriptor(\"I\")), \/\/ primitive\n+                Arguments.of(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"Ljava\/lang\/String\")), CD_String), \/\/ class or interface\n+                Arguments.of(UTF8_CLASS_TRANSLATOR, badFactory(b -> b.utf8Entry(\"[Ljava\/lang\/String\")), CD_String.arrayType()), \/\/ array\n+                Arguments.of(METHOD_TYPE_ENTRY_TRANSLATOR, badFactory(b -> b.methodTypeEntry(b.utf8Entry(\"()\"))), MTD_void),\n+                Arguments.of(METHOD_TYPE_ENTRY_TRANSLATOR, badFactory(b -> b.methodTypeEntry(b.utf8Entry(\"(V)\"))), MTD_void),\n+                Arguments.of(UTF8_METHOD_TYPE_TRANSLATOR, badFactory(b -> b.utf8Entry(\"()Ljava\/lang\/String\")), MethodTypeDesc.of(CD_String)),\n+                Arguments.of(PACKAGE_ENTRY_TRANSLATOR, badFactory(b -> b.packageEntry(b.utf8Entry(\"java.lang\"))), PackageDesc.of(\"java.lang\")),\n+                Arguments.of(MODULE_ENTRY_TRANSLATOR, badFactory(b -> b.moduleEntry(b.utf8Entry(\"java@base\"))), ModuleDesc.of(\"java.base\"))\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"malformedCases\")\n+    <T, P extends PoolEntry> void testMalformed(SymbolicTranslator<T, P> translator, Supplier<P> factory, T target) {\n+        translator.entriesSpawner(factory)\n+                .<PoolEntryCase<P>>mapMulti((src, sink) -> {\n+                    sink.accept(src);\n+                    sink.accept(translator.inflateByTest(src, target, \"target\"));\n+                })\n+                .forEach(scenario -> {\n+                    scenario.test(p -> assertThrows(IllegalArgumentException.class, () -> translator.extractor.apply(p), \"asSym\"));\n+                    scenario.test(p -> assertFalse(translator.tester.test(p, target), \"eqSym\"));\n+                });\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":197,"deletions":7,"binary":false,"changes":204,"status":"modified"}]}