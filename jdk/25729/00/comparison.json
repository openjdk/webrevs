{"files":[{"patch":"@@ -628,0 +628,28 @@\n+bool ShenandoahBarrierC2Support::is_anti_dependent_load_at_control(PhaseIdealLoop* phase, Node* maybe_load, Node* store,\n+                                                                   Node* control) {\n+  return maybe_load->is_Load() && phase->C->can_alias(store->adr_type(), phase->C->get_alias_index(maybe_load->adr_type())) &&\n+         phase->ctrl_or_self(maybe_load) == control;\n+}\n+\n+void ShenandoahBarrierC2Support::maybe_push_anti_dependent_loads(PhaseIdealLoop* phase, Node* maybe_store, Node* control, Unique_Node_List &wq) {\n+  if (!maybe_store->is_Store() && !maybe_store->is_LoadStore()) {\n+    return;\n+  }\n+  Node* mem = maybe_store->in(MemNode::Memory);\n+  for (DUIterator_Fast imax, i = mem->fast_outs(imax); i < imax; i++) {\n+    Node* u = mem->fast_out(i);\n+    if (is_anti_dependent_load_at_control(phase, u, maybe_store, control)) {\n+      wq.push(u);\n+    }\n+  }\n+}\n+\n+void ShenandoahBarrierC2Support::push_data_inputs_at_control(PhaseIdealLoop* phase, Node* n, Node* ctrl, Unique_Node_List &wq) {\n+  for (uint i = 0; i < n->req(); i++) {\n+    Node* in = n->in(i);\n+    if (in != nullptr && phase->has_ctrl(in) && phase->get_ctrl(in) == ctrl) {\n+      wq.push(in);\n+    }\n+  }\n+}\n+\n@@ -642,16 +670,3 @@\n-      if (m->is_Store() || m->is_LoadStore()) {\n-        \/\/ Take anti-dependencies into account\n-        Node* mem = m->in(MemNode::Memory);\n-        for (DUIterator_Fast imax, i = mem->fast_outs(imax); i < imax; i++) {\n-          Node* u = mem->fast_out(i);\n-          if (u->is_Load() && phase->C->can_alias(m->adr_type(), phase->C->get_alias_index(u->adr_type())) &&\n-              phase->ctrl_or_self(u) == c) {\n-            wq.push(u);\n-          }\n-        }\n-      }\n-      for (uint i = 0; i < m->req(); i++) {\n-        if (m->in(i) != nullptr && phase->ctrl_or_self(m->in(i)) == c) {\n-          wq.push(m->in(i));\n-        }\n-      }\n+      \/\/ Take anti-dependencies into account\n+      maybe_push_anti_dependent_loads(phase, m, c, wq);\n+      push_data_inputs_at_control(phase, m, c, wq);\n@@ -1009,1 +1024,14 @@\n-void ShenandoahBarrierC2Support::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer& fixer, Unique_Node_List& uses, Unique_Node_List& uses_to_ignore, uint last, PhaseIdealLoop* phase) {\n+void ShenandoahBarrierC2Support::collect_nodes_above_barrier(Unique_Node_List &nodes_above_barrier, PhaseIdealLoop* phase, Node* ctrl, Node* init_raw_mem) {\n+  nodes_above_barrier.clear();\n+  if (phase->has_ctrl(init_raw_mem) && phase->get_ctrl(init_raw_mem) == ctrl && !init_raw_mem->is_Phi()) {\n+    nodes_above_barrier.push(init_raw_mem);\n+  }\n+  for (uint next = 0; next < nodes_above_barrier.size(); next++) {\n+    Node* n = nodes_above_barrier.at(next);\n+    \/\/ Take anti-dependencies into account\n+    maybe_push_anti_dependent_loads(phase, n, ctrl, nodes_above_barrier);\n+    push_data_inputs_at_control(phase, n, ctrl, nodes_above_barrier);\n+  }\n+}\n+\n+void ShenandoahBarrierC2Support::fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer& fixer, Unique_Node_List& uses, Unique_Node_List& nodes_above_barrier, uint last, PhaseIdealLoop* phase) {\n@@ -1020,13 +1048,1 @@\n-  uses_to_ignore.clear();\n-  if (phase->has_ctrl(init_raw_mem) && phase->get_ctrl(init_raw_mem) == ctrl && !init_raw_mem->is_Phi()) {\n-    uses_to_ignore.push(init_raw_mem);\n-  }\n-  for (uint next = 0; next < uses_to_ignore.size(); next++) {\n-    Node *n = uses_to_ignore.at(next);\n-    for (uint i = 0; i < n->req(); i++) {\n-      Node* in = n->in(i);\n-      if (in != nullptr && phase->has_ctrl(in) && phase->get_ctrl(in) == ctrl) {\n-        uses_to_ignore.push(in);\n-      }\n-    }\n-  }\n+  collect_nodes_above_barrier(nodes_above_barrier, phase, ctrl, init_raw_mem);\n@@ -1038,1 +1054,1 @@\n-        !uses_to_ignore.member(u) &&\n+        !nodes_above_barrier.member(u) &&\n@@ -1042,2 +1058,1 @@\n-      Node* c = old_c;\n-      if (c != ctrl ||\n+      if (old_c != ctrl ||\n@@ -1318,1 +1333,1 @@\n-  Unique_Node_List uses_to_ignore;\n+  Unique_Node_List nodes_above_barriers;\n@@ -1413,1 +1428,1 @@\n-    fix_ctrl(lrb, region, fixer, uses, uses_to_ignore, last, phase);\n+    fix_ctrl(lrb, region, fixer, uses, nodes_above_barriers, last, phase);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":50,"deletions":35,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -65,0 +65,4 @@\n+\n+  static void collect_nodes_above_barrier(Unique_Node_List &nodes_above_barrier, PhaseIdealLoop* phase, Node* ctrl,\n+                                          Node* init_raw_mem);\n+\n@@ -66,1 +70,1 @@\n-  static void fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer& fixer, Unique_Node_List& uses, Unique_Node_List& uses_to_ignore, uint last, PhaseIdealLoop* phase);\n+  static void fix_ctrl(Node* barrier, Node* region, const MemoryGraphFixer& fixer, Unique_Node_List& uses, Unique_Node_List& nodes_above_barrier, uint last, PhaseIdealLoop* phase);\n@@ -79,0 +83,5 @@\n+  static void push_data_inputs_at_control(PhaseIdealLoop* phase, Node* n, Node* ctrl,\n+                                          Unique_Node_List &wq);\n+  static bool is_anti_dependent_load_at_control(PhaseIdealLoop* phase, Node* maybe_load, Node* store, Node* control);\n+\n+  static void maybe_push_anti_dependent_loads(PhaseIdealLoop* phase, Node* maybe_store, Node* control, Unique_Node_List &wq);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8358334\n+ * @summary C2\/Shenandoah: incorrect execution with Unsafe\n+ * @requires vm.gc.Shenandoah\n+ * @modules java.base\/jdk.internal.misc:+open\n+ *\n+ * @run main\/othervm -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:-TieredCompilation -XX:+UseShenandoahGC\n+ *                   TestLostAntiDependencyAtExpansion\n+ *\n+ *\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestLostAntiDependencyAtExpansion {\n+    static final jdk.internal.misc.Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    public static void main(String[] args) {\n+        long addr = UNSAFE.allocateMemory(8);\n+        for (int i = 0; i < 20_000; i++) {\n+            UNSAFE.putLong(addr, 42L);\n+            long res = test1(addr);\n+            if (res != 42L) {\n+                throw new RuntimeException(\"Incorrect result: \" + res);\n+            }\n+        }\n+    }\n+\n+    static class A {\n+        long field;\n+    }\n+\n+    static A a = new A();\n+\n+    private static long test1(long addr) {\n+        long tmp = UNSAFE.getLong(addr);\n+\n+        UNSAFE.putLong(addr, 0L);\n+\n+        return tmp + a.field;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLostAntiDependencyAtExpansion.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"}]}