{"files":[{"patch":"@@ -1703,2 +1703,3 @@\n-void C2_MacroAssembler::load_vector(XMMRegister dst, Address src, int vlen_in_bytes) {\n-  switch (vlen_in_bytes) {\n+void C2_MacroAssembler::load_vector(BasicType bt, XMMRegister dst, Address src, int vlen_in_bytes) {\n+  if (is_integral_type(bt)) {\n+    switch (vlen_in_bytes) {\n@@ -1711,0 +1712,10 @@\n+    }\n+  } else {\n+    switch (vlen_in_bytes) {\n+    case 4:  movflt(dst, src); break;\n+    case 8:  movdbl(dst, src); break;\n+    case 16: movups(dst, src); break;\n+    case 32: vmovups(dst, src, Assembler::AVX_256bit); break;\n+    case 64: vmovups(dst, src, Assembler::AVX_512bit); break;\n+    default: ShouldNotReachHere();\n+    }\n@@ -1714,1 +1725,1 @@\n-void C2_MacroAssembler::load_vector(XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch) {\n+void C2_MacroAssembler::load_vector(BasicType bt, XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch) {\n@@ -1718,1 +1729,1 @@\n-    load_vector(dst, as_Address(src), vlen_in_bytes);\n+    load_vector(bt, dst, as_Address(src), vlen_in_bytes);\n@@ -1721,1 +1732,1 @@\n-    load_vector(dst, Address(rscratch, 0), vlen_in_bytes);\n+    load_vector(bt, dst, Address(rscratch, 0), vlen_in_bytes);\n@@ -1750,4 +1761,1 @@\n-    movq(dst, src);\n-    if (vlen == 16) {\n-      punpcklqdq(dst, dst);\n-    }\n+    load_vector(bt, dst, src, vlen);\n@@ -1764,1 +1772,1 @@\n-  load_vector(dst, addr, vlen_in_bytes);\n+  load_vector(T_BYTE, dst, addr, vlen_in_bytes);\n@@ -3454,1 +3462,1 @@\n-  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+  load_vector(eltype, dst, src, arrays_hashcode_elsize(eltype) * 8);\n@@ -3458,1 +3466,1 @@\n-  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+  load_vector(eltype, dst, src, arrays_hashcode_elsize(eltype) * 8);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -130,2 +130,2 @@\n-  void load_vector(XMMRegister dst, Address        src, int vlen_in_bytes);\n-  void load_vector(XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch = noreg);\n+  void load_vector(BasicType bt, XMMRegister dst, Address        src, int vlen_in_bytes);\n+  void load_vector(BasicType bt, XMMRegister dst, AddressLiteral src, int vlen_in_bytes, Register rscratch = noreg);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2721,12 +2721,3 @@\n-static inline GrowableArray<jvalue>* vreplicate_imm(BasicType bt, T con, int len) {\n-  GrowableArray<jvalue>* val = new GrowableArray<jvalue>(len);\n-  jvalue ele;\n-  switch (bt) {\n-    case T_BYTE:   ele.b = con; break;\n-    case T_SHORT:  ele.s = con; break;\n-    case T_INT:    ele.i = con; break;\n-    case T_LONG:   ele.j = con; break;\n-    case T_FLOAT:  ele.f = con; break;\n-    case T_DOUBLE: ele.d = con; break;\n-    default: ShouldNotReachHere();\n-  }\n+static inline GrowableArray<jbyte>* vreplicate_imm(BasicType bt, T con, int len) {\n+  int size = type2aelembytes(bt) * len;\n+  GrowableArray<jbyte>* val = new GrowableArray<jbyte>(size, size, 0);\n@@ -2734,1 +2725,30 @@\n-    val->append(ele);\n+    int offset = i * type2aelembytes(bt);\n+    switch (bt) {\n+    case T_BYTE: val->at(i) = con; break;\n+    case T_SHORT: {\n+      jshort c = con;\n+      memcpy(val->adr_at(offset), &c, sizeof(jshort));\n+      break;\n+    }\n+    case T_INT: {\n+      jint c = con;\n+      memcpy(val->adr_at(offset), &c, sizeof(jint));\n+      break;\n+    }\n+    case T_LONG: {\n+      jlong c = con;\n+      memcpy(val->adr_at(offset), &c, sizeof(jlong));\n+      break;\n+    }\n+    case T_FLOAT: {\n+      jfloat c = con;\n+      memcpy(val->adr_at(offset), &c, sizeof(jfloat));\n+      break;\n+    }\n+    case T_DOUBLE: {\n+      jdouble c = con;\n+      memcpy(val->adr_at(offset), &c, sizeof(jdouble));\n+      break;\n+    }\n+    default: assert(false, \"%s\", type2name(bt));\n+    }\n@@ -4018,1 +4038,2 @@\n-    __ load_vector($dst$$XMMRegister, $mem$$Address, Matcher::vector_length_in_bytes(this));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ load_vector(bt, $dst$$XMMRegister, $mem$$Address, Matcher::vector_length_in_bytes(this));\n@@ -4501,4 +4522,3 @@\n-    InternalAddress addr = $constantaddress(Matcher::vector_element_basic_type(this),\n-        vreplicate_imm(Matcher::vector_element_basic_type(this), $con$$constant,\n-            (VM_Version::supports_sse3() ? (VM_Version::supports_avx() ? 4 : 8) : 8) \/\n-                type2aelembytes(Matcher::vector_element_basic_type(this))));\n+    InternalAddress addr = $constantaddress(vreplicate_imm(Matcher::vector_element_basic_type(this), $con$$constant,\n+                                                           (VM_Version::supports_sse3() ? (VM_Version::supports_avx() ? 4 : 8) : 16) \/\n+                                                                   type2aelembytes(Matcher::vector_element_basic_type(this))));\n@@ -4642,1 +4662,1 @@\n-    InternalAddress addr = $constantaddress(T_LONG, vreplicate_imm(T_LONG, $con$$constant, 1));\n+    InternalAddress addr = $constantaddress(vreplicate_imm(T_LONG, $con$$constant, VM_Version::supports_sse3() ? 1 : 2));\n@@ -4724,2 +4744,2 @@\n-    InternalAddress addr = $constantaddress(T_FLOAT, vreplicate_imm(T_FLOAT, $con$$constant,\n-        VM_Version::supports_sse3() ? (VM_Version::supports_avx() ? 1 : 2) : 2));\n+    InternalAddress addr = $constantaddress(vreplicate_imm(T_FLOAT, $con$$constant,\n+                                                           VM_Version::supports_sse3() ? (VM_Version::supports_avx() ? 1 : 2) : 4));\n@@ -4801,1 +4821,1 @@\n-    InternalAddress addr = $constantaddress(T_DOUBLE, vreplicate_imm(T_DOUBLE, $con$$constant, 1));\n+    InternalAddress addr = $constantaddress(vreplicate_imm(T_DOUBLE, $con$$constant, VM_Version::supports_sse3() ? 1 : 2));\n@@ -9611,1 +9631,1 @@\n-    InternalAddress addr = $constantaddress(T_LONG, vreplicate_imm(T_LONG, 0x8040201008040201L, 1));\n+    InternalAddress addr = $constantaddress(jlong(0x8040201008040201));\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":43,"deletions":23,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -483,1 +483,1 @@\n-  address array_constant(BasicType bt, GrowableArray<jvalue>* c, int alignment) {\n+  address array_constant(const GrowableArray<jbyte>* c, int alignment) {\n@@ -485,3 +485,1 @@\n-    int len = c->length();\n-    int size = type2aelembytes(bt) * len;\n-    address ptr = start_a_const(size, alignment);\n+    address ptr = start_a_const(c->length(), alignment);\n@@ -489,14 +487,2 @@\n-      for (int i = 0; i < len; i++) {\n-        jvalue e = c->at(i);\n-        switch(bt) {\n-          case T_BOOLEAN: emit_int8(e.z);   break;\n-          case T_BYTE:    emit_int8(e.b);   break;\n-          case T_CHAR:    emit_int16(e.c);  break;\n-          case T_SHORT:   emit_int16(e.s);  break;\n-          case T_INT:     emit_int32(e.i);  break;\n-          case T_LONG:    emit_int64(e.j);  break;\n-          case T_FLOAT:   emit_float(e.f);  break;\n-          case T_DOUBLE:  emit_double(e.d); break;\n-          default:\n-            ShouldNotReachHere();\n-        }\n+      for (int i = 0; i < c->length(); i++) {\n+        emit_int8(c->at(i));\n","filename":"src\/hotspot\/share\/asm\/assembler.hpp","additions":5,"deletions":19,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -892,0 +892,1 @@\n+  cb.set_const_section_alignment(_const_section_alignment);\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,15 +44,1 @@\n-      jvalue ele1 = get_array()->at(i);\n-      jvalue ele2 = other.get_array()->at(i);\n-      bool is_eq;\n-      switch (type()) {\n-        case T_BOOLEAN: is_eq = ele1.z == ele2.z; break;\n-        case T_BYTE:    is_eq = ele1.b == ele2.b; break;\n-        case T_CHAR:    is_eq = ele1.c == ele2.c; break;\n-        case T_SHORT:   is_eq = ele1.s == ele2.s; break;\n-        case T_INT:     is_eq = ele1.i == ele2.i; break;\n-        case T_LONG:    is_eq = ele1.j == ele2.j; break;\n-        case T_FLOAT:   is_eq = jint_cast(ele1.f)  == jint_cast(ele2.f);  break;\n-        case T_DOUBLE:  is_eq = jlong_cast(ele1.d) == jlong_cast(ele2.d); break;\n-        default: ShouldNotReachHere(); is_eq = false;\n-      }\n-      if (!is_eq) {\n+      if (get_array()->at(i) != other.get_array()->at(i)) {\n@@ -64,0 +50,1 @@\n+\n@@ -78,0 +65,9 @@\n+int ConstantTable::alignment() const {\n+  int res = 1;\n+  for (int i = 0; i < _constants.length(); i++) {\n+    const Constant& c = _constants.at(i);\n+    res = MAX2(res, c.alignment());\n+  }\n+  return res;\n+}\n+\n@@ -79,4 +75,24 @@\n-  \/\/ sort descending\n-  if (a->freq() > b->freq())  return -1;\n-  if (a->freq() < b->freq())  return  1;\n-  return 0;\n+  \/\/ put the ones with large alignments first\n+  if (a->alignment() > 8 && b->alignment() > 8) {\n+    \/\/ sort them by alignment\n+    if (a->alignment() > b->alignment()) {\n+      return -1;\n+    } else if (a->alignment() < b->alignment()) {\n+      return 1;\n+    } else {\n+      return 0;\n+    }\n+  } else if (a->alignment() > 8) {\n+    return -1;\n+  } else if (b->alignment() > 8) {\n+    return 1;\n+  } else {\n+    \/\/ for constants with small alignments, sort them by frequency\n+    if (a->freq() > b->freq()) {\n+      return -1;\n+    } else if (a->freq() < b->freq()) {\n+      return 1;\n+    } else {\n+      return 0;\n+    }\n+  }\n@@ -87,1 +103,1 @@\n-    return type2aelembytes(con->type()) * con->get_array()->length();\n+    return con->get_array()->length();\n@@ -152,1 +168,1 @@\n-      constant_addr = masm->array_constant(con.type(), con.get_array(), con.alignment());\n+      constant_addr = masm->array_constant(con.get_array(), con.alignment());\n@@ -254,3 +270,2 @@\n-ConstantTable::Constant ConstantTable::add(MachConstantNode* n, BasicType bt,\n-                                           GrowableArray<jvalue>* array, int alignment) {\n-  Constant con(bt, array, alignment);\n+ConstantTable::Constant ConstantTable::add(MachConstantNode* n, GrowableArray<jbyte>* array, int alignment) {\n+  Constant con(array, alignment);\n@@ -261,3 +276,2 @@\n-ConstantTable::Constant ConstantTable::add(MachConstantNode* n, BasicType bt,\n-                                           GrowableArray<jvalue>* array) {\n-  return add(n, bt, array, array->length() * type2aelembytes(bt));\n+ConstantTable::Constant ConstantTable::add(MachConstantNode* n, GrowableArray<jbyte>* array) {\n+  return add(n, array, array->length());\n","filename":"src\/hotspot\/share\/opto\/constantTable.cpp","additions":42,"deletions":28,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-      GrowableArray<jvalue>* _array;\n+      GrowableArray<jbyte>* _array;\n@@ -75,2 +75,2 @@\n-    Constant(BasicType type, GrowableArray<jvalue>* array, int alignment, bool can_be_reused = true) :\n-      _type(type),\n+    Constant(GrowableArray<jbyte>* array, int alignment) :\n+      _type(T_BYTE),\n@@ -81,1 +81,1 @@\n-      _can_be_reused(can_be_reused)\n+      _can_be_reused(true)\n@@ -83,1 +83,0 @@\n-      assert(is_java_primitive(type), \"not applicable for %s\", type2name(type));\n@@ -85,2 +84,2 @@\n-      _v._array = new GrowableArray<jvalue>(array->length());\n-      for (jvalue ele : *array) {\n+      _v._array = new GrowableArray<jbyte>(array->length());\n+      for (jbyte ele : *array) {\n@@ -105,1 +104,1 @@\n-    GrowableArray<jvalue>* get_array() const { return _v._array; }\n+    const GrowableArray<jbyte>* get_array() const { return _v._array; }\n@@ -137,0 +136,1 @@\n+  int alignment() const;\n@@ -153,2 +153,2 @@\n-  Constant add(MachConstantNode* n, BasicType bt, GrowableArray<jvalue>* array);\n-  Constant add(MachConstantNode* n, BasicType bt, GrowableArray<jvalue>* array, int alignment);\n+  Constant add(MachConstantNode* n, GrowableArray<jbyte>* array);\n+  Constant add(MachConstantNode* n, GrowableArray<jbyte>* array, int alignment);\n","filename":"src\/hotspot\/share\/opto\/constantTable.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1335,1 +1335,1 @@\n-    const_req = constant_table().size() + add_size;\n+    const_req = constant_table().alignment() + constant_table().size() + add_size;\n@@ -1375,0 +1375,1 @@\n+  cb->set_const_section_alignment(constant_table().alignment());\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}