{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-import jdk.internal.module.Resources;\n+import jdk.internal.module.Checks;\n@@ -70,1 +70,1 @@\n-     * Returns true if a resource has an effective package.\n+     * Returns true if a resource is located in a named package.\n@@ -72,3 +72,8 @@\n-    public static boolean isNamedPackageResource(String path) {\n-        return (path.endsWith(\".class\") && !path.endsWith(\"module-info.class\")) ||\n-                Resources.canEncapsulate(path);\n+    public static boolean isNamedPackageResource(String name) {\n+        int index = name.lastIndexOf(\"\/\");\n+        if (index == -1) {\n+            return false;\n+        } else {\n+            String pn = name.substring(0, index).replace('\/', '.');\n+            return Checks.isPackageName(pn);\n+        }\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ResourcePoolManager.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-import jdk.internal.module.Resources;\n+import jdk.internal.module.Checks;\n@@ -692,1 +692,0 @@\n-                        .filter(path -> isResource(path.toString()))\n@@ -706,1 +705,1 @@\n-                     .filter(e -> !e.isDirectory() && isResource(e.getName()))\n+                     .filter(e -> !e.isDirectory())\n@@ -713,2 +712,2 @@\n-         * Returns true if it's a .class or a resource with an effective\n-         * package name.\n+         * Maps the given relative file path to a package name.\n+         * @throws UncheckedIOException for a class file in a top-level directory\n@@ -716,15 +715,12 @@\n-        boolean isResource(String name) {\n-            name = name.replace(File.separatorChar, '\/');\n-            return name.endsWith(\".class\") || Resources.canEncapsulate(name);\n-        }\n-\n-\n-        String toPackageName(Path path) {\n-            String name = path.toString();\n-            int index = name.lastIndexOf(File.separatorChar);\n-            if (index != -1)\n-                return name.substring(0, index).replace(File.separatorChar, '.');\n-\n-            if (name.endsWith(\".class\") && !name.equals(MODULE_INFO)) {\n-                IOException e = new IOException(name  + \" in the unnamed package\");\n-                throw new UncheckedIOException(e);\n+        private String toPackageName(Path path) {\n+            assert path.getRoot() == null;\n+\n+            Path parent = path.getParent();\n+            if (parent != null) {\n+                String sep = path.getFileSystem().getSeparator();\n+                String pn = parent.toString().replace(sep, \".\");\n+                return Checks.isPackageName(pn) ? pn : \"\";\n+            } else {\n+                \/\/ file in top-level directory\n+                ensureNotClassFile(path.toString());\n+                return \"\";\n@@ -732,1 +728,0 @@\n-            return \"\";\n@@ -735,1 +730,5 @@\n-        String toPackageName(ZipEntry entry) {\n+        \/**\n+         * Maps the name of a JAR file entry to a package name.\n+         * @throws UncheckedIOException for a class file in a top-level directory\n+         *\/\n+        private String toPackageName(ZipEntry entry) {\n@@ -737,0 +736,2 @@\n+            assert !name.endsWith(\"\/\");\n+\n@@ -738,2 +739,9 @@\n-            if (index != -1)\n-                return name.substring(0, index).replace('\/', '.');\n+            if (index != -1) {\n+                String pn = name.substring(0, index).replace('\/', '.');\n+                return Checks.isPackageName(pn) ? pn : \"\";\n+            } else {\n+                \/\/ entry in top-level directory\n+                ensureNotClassFile(name);\n+                return \"\";\n+            }\n+        }\n@@ -741,0 +749,4 @@\n+        \/**\n+         * Throws IOException for a .class file that is not module-info.class.\n+         *\/\n+        private void ensureNotClassFile(String name) {\n@@ -745,1 +757,0 @@\n-            return \"\";\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/JmodTask.java","additions":36,"deletions":25,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8353267\n+ * @summary Test jlink with a module containing a class file in its META-INF directory\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.module\n+ *          jdk.jlink\n+ *          jdk.jartool\n+ * @run junit ClassFileInMetaInfo\n+ *\/\n+\n+import java.lang.module.ModuleDescriptor;\n+import java.io.PrintStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.ModuleInfoWriter;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ClassFileInMetaInfo {\n+    private static PrintStream out;\n+    private static String moduleName;\n+    private static String classesDir;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        out = System.err; \/\/ inline with Junit\n+\n+        \/\/ Create module foo containing\n+        \/\/     module-info.class\n+        \/\/     p\/C.class\n+        \/\/     META-INF\/extra\/q\/C.class\n+        moduleName = \"foo\";\n+        ModuleDescriptor descriptor = ModuleDescriptor.newModule(moduleName).build();\n+        byte[] moduleInfo = ModuleInfoWriter.toBytes(descriptor);\n+        Path dir = Files.createTempDirectory(Path.of(\".\"), moduleName);\n+        Files.write(dir.resolve(\"module-info.class\"), moduleInfo);\n+        Files.createFile(Files.createDirectory(dir.resolve(\"p\")).resolve(\"C.class\"));\n+        Path extraClasses = dir.resolve(\"META-INF\/extra\/\");\n+        Files.createFile(Files.createDirectories(extraClasses.resolve(\"q\")).resolve(\"C.class\"));\n+        classesDir = dir.toString();\n+    }\n+\n+    @Test\n+    void testExplodedModule() throws Exception {\n+        test(classesDir);\n+    }\n+\n+    @Test\n+    void testModularJar() throws Exception {\n+        String jarFile = \"foo.jar\";\n+        ToolProvider jarTool = ToolProvider.findFirst(\"jar\").orElseThrow();\n+        int res = jarTool.run(out, out, \"cf\", jarFile, \"-C\", classesDir, \".\");\n+        assertEquals(0, res);\n+        test(jarFile);\n+    }\n+\n+    @Test\n+    void testJmod() throws Exception {\n+        String jmodFile = \"foo.jmod\";\n+        ToolProvider jmodTool = ToolProvider.findFirst(\"jmod\").orElseThrow();\n+        int res = jmodTool.run(out, out, \"create\", \"--class-path\", classesDir, jmodFile);\n+        assertEquals(0, res);\n+        test(jmodFile);\n+    }\n+\n+    \/**\n+     * jlink --module-path .. --add-modules foo --ouptut image\n+     * image\/bin\/java --describe-module foo\n+     *\/\n+    private void test(String modulePath) throws Exception {\n+        Path dir = Files.createTempDirectory(Path.of(\".\"), \"image\");\n+        Files.delete(dir);\n+        String image = dir.toString();\n+\n+        ToolProvider jlinkTool = ToolProvider.findFirst(\"jlink\").orElseThrow();\n+        int res = jlinkTool.run(out, out,\n+                \"--module-path\", modulePath,\n+                \"--add-modules\", moduleName,\n+                \"--output\", image);\n+        assertEquals(0, res);\n+\n+        var pb = new ProcessBuilder(image + \"\/bin\/java\", \"--describe-module\", moduleName);\n+        ProcessTools.executeProcess(pb)\n+                .outputTo(out)\n+                .errorTo(out)\n+                .shouldHaveExitValue(0)\n+                .shouldContain(moduleName)\n+                .shouldContain(\"contains p\")\n+                .shouldNotContain(\"META-INF\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jlink\/ClassFileInMetaInfo.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8142968 8166568 8166286 8170618 8168149 8240910 8276764 8276766\n+ * @bug 8142968 8166568 8166286 8170618 8168149 8240910 8276764 8276766 8353267\n@@ -31,0 +31,1 @@\n+ *          java.base\/jdk.internal.module\n@@ -48,0 +49,1 @@\n+import jdk.test.lib.util.ModuleInfoWriter;\n@@ -685,1 +687,37 @@\n-        }\n+    }\n+\n+    \/**\n+     * Test class files is the META-INF directory.\n+     *\/\n+    @Test\n+    public void testClassInMetaInf() throws IOException {\n+        Path jmod = MODS_DIR.resolve(\"baz.jmod\");\n+        FileUtils.deleteFileIfExistsWithRetry(jmod);\n+\n+        ModuleDescriptor descriptor = ModuleDescriptor.newModule(\"baz\").build();\n+        byte[] moduleInfo = ModuleInfoWriter.toBytes(descriptor);\n+\n+        Path dir = Files.createTempDirectory(Path.of(\".\"), \"baz\");\n+        Files.write(dir.resolve(\"module-info.class\"), moduleInfo);\n+        Files.createFile(Files.createDirectory(dir.resolve(\"p\")).resolve(\"C.class\"));\n+\n+        \/\/ META-INF\/extra\/q\/C.class\n+        Path extraClasses = dir.resolve(\"META-INF\/extra\/\");\n+        Files.createFile(Files.createDirectories(extraClasses.resolve(\"q\")).resolve(\"C.class\"));\n+\n+        Set<String> expectedPackages = Set.of(\"p\");\n+        Set<String> expectedContent = Set.of(\n+                CLASSES_PREFIX + \"module-info.class\",\n+                CLASSES_PREFIX + \"p\/C.class\",\n+                CLASSES_PREFIX + \"META-INF\/extra\/q\/C.class\");\n+\n+        jmod(\"create\",\n+                \"--class-path\", dir.toString(),\n+                jmod.toString())\n+                .assertSuccess()\n+                .resultChecker(r -> {\n+                    Set<String> pkgs = getModuleDescriptor(jmod).packages();\n+                    assertEquals(pkgs, expectedPackages);\n+                    assertJmodContent(jmod, expectedContent);\n+                });\n+    }\n","filename":"test\/jdk\/tools\/jmod\/JmodTest.java","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"}]}