{"files":[{"patch":"@@ -353,0 +353,8 @@\n+size_t G1CollectedHeap::allocation_used_bytes(size_t allocation_word_size) {\n+  if (is_humongous(allocation_word_size)) {\n+    return humongous_obj_size_in_regions(allocation_word_size) * G1HeapRegion::GrainBytes;\n+  } else {\n+    return allocation_word_size * HeapWordSize;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1232,0 +1232,4 @@\n+  \/\/ Returns how much space in bytes an allocation of word_size will use up in the\n+  \/\/ heap.\n+  static size_t allocation_used_bytes(size_t word_size);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -369,11 +369,0 @@\n-  \/\/ If the full collection was triggered by an allocation failure, we should account\n-  \/\/ for the bytes required for this allocation under used_after_gc. This prevents\n-  \/\/ unnecessary shrinking that would be followed by an expand call to satisfy the\n-  \/\/ allocation.\n-  size_t allocation_bytes = allocation_word_size * HeapWordSize;\n-  if (_g1h->is_humongous(allocation_word_size)) {\n-    \/\/ Humongous objects are allocated in entire regions, we must calculate\n-    \/\/ required space in terms of full regions, not just the object size.\n-    allocation_bytes = G1HeapRegion::align_up_to_region_byte_size(allocation_bytes);\n-  }\n-\n@@ -383,1 +372,5 @@\n-  const size_t used_after_gc = capacity_after_gc + allocation_bytes -\n+  const size_t used_after_gc = capacity_after_gc +\n+                               \/\/ If the full collection was triggered by an allocation failure,\n+                               \/\/ account that allocation too. Otherwise we could shrink and then\n+                               \/\/ expand immediately to satisfy the allocation.\n+                               _g1h->allocation_used_bytes(allocation_word_size) -\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -47,0 +47,5 @@\n+void G1IHOPControl::report_statistics(G1NewTracer* new_tracer, size_t occupancy) {\n+  print_log(occupancy);\n+  send_jfr_event(new_tracer, occupancy);\n+}\n+\n@@ -53,1 +58,1 @@\n-void G1IHOPControl::print() {\n+void G1IHOPControl::print_log(size_t occupancy) {\n@@ -61,1 +66,1 @@\n-                      G1CollectedHeap::heap()->used(),\n+                      occupancy,\n@@ -68,1 +73,1 @@\n-void G1IHOPControl::send_trace_event(G1NewTracer* tracer) {\n+void G1IHOPControl::send_jfr_event(G1NewTracer* tracer, size_t occupancy) {\n@@ -72,1 +77,1 @@\n-                                       G1CollectedHeap::heap()->used(),\n+                                       occupancy,\n@@ -168,2 +173,2 @@\n-void G1AdaptiveIHOPControl::print() {\n-  G1IHOPControl::print();\n+void G1AdaptiveIHOPControl::print_log(size_t occupancy) {\n+  G1IHOPControl::print_log(occupancy);\n@@ -177,1 +182,1 @@\n-                      G1CollectedHeap::heap()->used(),\n+                      occupancy,\n@@ -184,2 +189,2 @@\n-void G1AdaptiveIHOPControl::send_trace_event(G1NewTracer* tracer) {\n-  G1IHOPControl::send_trace_event(tracer);\n+void G1AdaptiveIHOPControl::send_jfr_event(G1NewTracer* tracer, size_t occupancy) {\n+  G1IHOPControl::send_jfr_event(tracer, occupancy);\n@@ -188,1 +193,1 @@\n-                                          G1CollectedHeap::heap()->used(),\n+                                          occupancy,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1IHOPControl.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -58,1 +58,5 @@\n- public:\n+\n+  virtual void print_log(size_t occupancy);\n+  virtual void send_jfr_event(G1NewTracer* tracer, size_t occupancy);\n+\n+public:\n@@ -79,2 +83,1 @@\n-  virtual void print();\n-  virtual void send_trace_event(G1NewTracer* tracer);\n+  void report_statistics(G1NewTracer* tracer, size_t occupancy);\n@@ -142,0 +145,4 @@\n+\n+  virtual void print_log(size_t occupancy);\n+  virtual void send_jfr_event(G1NewTracer* tracer, size_t occupancy);\n+\n@@ -153,3 +160,0 @@\n-\n-  virtual void print();\n-  virtual void send_trace_event(G1NewTracer* tracer);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1IHOPControl.hpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -746,0 +746,7 @@\n+size_t G1Policy::conc_mark_occupancy(size_t allocation_word_size) const {\n+  size_t cur_used_bytes = _g1h->non_young_capacity_bytes();\n+  \/\/ For humongous allocations, we need to consider that we actually use full regions\n+  \/\/ for allocations. So the value to compare the threshold to needs to consider that.\n+  return cur_used_bytes + _g1h->allocation_used_bytes(allocation_word_size);\n+}\n+\n@@ -752,9 +759,1 @@\n-\n-  size_t cur_used_bytes = _g1h->non_young_capacity_bytes();\n-  size_t allocation_byte_size = allocation_word_size * HeapWordSize;\n-  \/\/ For humongous allocations, we need to consider that we actually use full regions\n-  \/\/ for allocations. So compare the threshold to this size.\n-  if (_g1h->is_humongous(allocation_word_size)) {\n-    allocation_byte_size = G1HeapRegion::align_up_to_region_byte_size(allocation_byte_size);\n-  }\n-  size_t marking_request_bytes = cur_used_bytes + allocation_byte_size;\n+  size_t marking_request_bytes = conc_mark_occupancy(allocation_word_size);\n@@ -767,1 +766,1 @@\n-                              cur_used_bytes, allocation_byte_size, marking_initiating_used_threshold, (double) marking_initiating_used_threshold \/ _g1h->capacity() * 100, source);\n+                              marking_request_bytes, allocation_word_size * HeapWordSize, marking_initiating_used_threshold, (double) marking_initiating_used_threshold \/ _g1h->capacity() * 100, source);\n@@ -998,4 +997,4 @@\n-    update_ihop_prediction(app_time_ms \/ 1000.0,\n-                           G1GCPauseTypeHelper::is_young_only_pause(this_pause));\n-\n-    _ihop_control->send_trace_event(_g1h->gc_tracer_stw());\n+    if (update_ihop_prediction(app_time_ms \/ 1000.0,\n+                               G1GCPauseTypeHelper::is_young_only_pause(this_pause))) {\n+      _ihop_control->report_statistics(_g1h->gc_tracer_stw(), conc_mark_occupancy(allocation_word_size));\n+    }\n@@ -1048,1 +1047,1 @@\n-void G1Policy::update_ihop_prediction(double mutator_time_s,\n+bool G1Policy::update_ihop_prediction(double mutator_time_s,\n@@ -1085,7 +1084,1 @@\n-  if (report) {\n-    report_ihop_statistics();\n-  }\n-}\n-\n-void G1Policy::report_ihop_statistics() {\n-  _ihop_control->print();\n+  return report;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -63,2 +63,3 @@\n-  \/\/ Update the IHOP control with necessary statistics.\n-  void update_ihop_prediction(double mutator_time_s,\n+  \/\/ Update the IHOP control with necessary statistics. Returns true if there\n+  \/\/ has been a significant update to the prediction.\n+  bool update_ihop_prediction(double mutator_time_s,\n@@ -66,1 +67,0 @@\n-  void report_ihop_statistics();\n@@ -310,0 +310,5 @@\n+private:\n+  \/\/ The current occupancy relevant to concurrent marking, that is compared to\n+  \/\/ the threshold.\n+  size_t conc_mark_occupancy(size_t allocation_word_size) const;\n+public:\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"}]}