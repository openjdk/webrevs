{"files":[{"patch":"@@ -2963,0 +2963,8 @@\n+size_t G1CollectedHeap::non_young_occupancy_after_allocation(size_t allocation_word_size) {\n+  const size_t cur_occupancy =  (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes;\n+  \/\/ For humongous allocations, consider that allocation in the result as well -\n+  \/\/ it will be allocated as such. Otherwise G1 will allocate the object in young\n+  \/\/ gen. In that case, do not account here.\n+  return cur_occupancy + is_humongous(allocation_word_size) ? allocation_used_bytes(allocation_word_size) : 0;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1035,3 +1035,1 @@\n-  size_t non_young_capacity_bytes() {\n-    return (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes;\n-  }\n+  size_t non_young_occupancy_after_allocation(size_t allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -369,0 +369,1 @@\n+  const size_t capacity_after_gc = _g1h->capacity();\n@@ -371,2 +372,11 @@\n-  const size_t capacity_after_gc = _g1h->capacity();\n-  const size_t used_after_gc = capacity_after_gc +\n+  const size_t current_used_after_gc = capacity_after_gc -\n+                                       _g1h->unused_committed_regions_in_bytes() -\n+                                       \/\/ Discount space used by current Eden to establish a\n+                                       \/\/ situation during Remark similar to at the end of full\n+                                       \/\/ GC where eden is empty. During Remark there can be an\n+                                       \/\/ arbitrary number of eden regions which would skew the\n+                                       \/\/ results.\n+                                       _g1h->eden_regions_count() * G1HeapRegion::GrainBytes;\n+\n+  \/\/ Add pending allocation;\n+  const size_t used_after_gc = current_used_after_gc +\n@@ -376,8 +386,1 @@\n-                               _g1h->allocation_used_bytes(allocation_word_size) -\n-                               _g1h->unused_committed_regions_in_bytes() -\n-                               \/\/ Discount space used by current Eden to establish a\n-                               \/\/ situation during Remark similar to at the end of full\n-                               \/\/ GC where eden is empty. During Remark there can be an\n-                               \/\/ arbitrary number of eden regions which would skew the\n-                               \/\/ results.\n-                               _g1h->eden_regions_count() * G1HeapRegion::GrainBytes;\n+                               _g1h->allocation_used_bytes(allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -746,7 +746,0 @@\n-size_t G1Policy::conc_mark_occupancy(size_t allocation_word_size) const {\n-  size_t cur_used_bytes = _g1h->non_young_capacity_bytes();\n-  \/\/ For humongous allocations, we need to consider that we actually use full regions\n-  \/\/ for allocations. So the value to compare the threshold to needs to consider that.\n-  return cur_used_bytes + _g1h->allocation_used_bytes(allocation_word_size);\n-}\n-\n@@ -759,1 +752,1 @@\n-  size_t marking_request_bytes = conc_mark_occupancy(allocation_word_size);\n+  size_t occupancy_after_allocation = _g1h->non_young_occupancy_after_allocation(allocation_word_size);\n@@ -762,1 +755,1 @@\n-  if (marking_request_bytes > marking_initiating_used_threshold) {\n+  if (occupancy_after_allocation > marking_initiating_used_threshold) {\n@@ -766,1 +759,1 @@\n-                              marking_request_bytes, allocation_word_size * HeapWordSize, marking_initiating_used_threshold, (double) marking_initiating_used_threshold \/ _g1h->capacity() * 100, source);\n+                              occupancy_after_allocation, allocation_word_size * HeapWordSize, marking_initiating_used_threshold, (double) marking_initiating_used_threshold \/ _g1h->capacity() * 100, source);\n@@ -999,1 +992,1 @@\n-      _ihop_control->report_statistics(_g1h->gc_tracer_stw(), conc_mark_occupancy(allocation_word_size));\n+      _ihop_control->report_statistics(_g1h->gc_tracer_stw(), _g1h->non_young_occupancy_after_allocation(allocation_word_size));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  \/\/ Update the IHOP control with necessary statistics. Returns true if there\n+  \/\/ Update the IHOP control with the necessary statistics. Returns true if there\n@@ -310,5 +310,0 @@\n-private:\n-  \/\/ The current occupancy relevant to concurrent marking, that is compared to\n-  \/\/ the threshold.\n-  size_t conc_mark_occupancy(size_t allocation_word_size) const;\n-public:\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"}]}