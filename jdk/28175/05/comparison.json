{"files":[{"patch":"@@ -353,0 +353,8 @@\n+size_t G1CollectedHeap::allocation_used_bytes(size_t allocation_word_size) {\n+  if (is_humongous(allocation_word_size)) {\n+    return humongous_obj_size_in_regions(allocation_word_size) * G1HeapRegion::GrainBytes;\n+  } else {\n+    return allocation_word_size * HeapWordSize;\n+  }\n+}\n+\n@@ -2955,0 +2963,9 @@\n+size_t G1CollectedHeap::non_young_occupancy_after_allocation(size_t allocation_word_size) {\n+  \/\/ For simplicity, just count whole regions.\n+  const size_t cur_occupancy = (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes;\n+  \/\/ Humongous allocations will always be assigned to non-young heap, so consider\n+  \/\/ that allocation in the result as well. Otherwise the allocation will always\n+  \/\/ be in young gen, so there is no need to account it here.\n+  return cur_occupancy + (is_humongous(allocation_word_size) ? allocation_used_bytes(allocation_word_size) : 0);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1035,3 +1035,4 @@\n-  size_t non_young_capacity_bytes() {\n-    return (old_regions_count() + humongous_regions_count()) * G1HeapRegion::GrainBytes;\n-  }\n+  \/\/ Returns how much memory there is assigned to non-young heap that can not be\n+  \/\/ allocated into any more without garbage collection after a hypothetical\n+  \/\/ allocation of allocation_word_size.\n+  size_t non_young_occupancy_after_allocation(size_t allocation_word_size);\n@@ -1232,0 +1233,4 @@\n+  \/\/ Returns how much space in bytes an allocation of word_size will use up in the\n+  \/\/ heap.\n+  static size_t allocation_used_bytes(size_t word_size);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -369,11 +369,1 @@\n-  \/\/ If the full collection was triggered by an allocation failure, we should account\n-  \/\/ for the bytes required for this allocation under used_after_gc. This prevents\n-  \/\/ unnecessary shrinking that would be followed by an expand call to satisfy the\n-  \/\/ allocation.\n-  size_t allocation_bytes = allocation_word_size * HeapWordSize;\n-  if (_g1h->is_humongous(allocation_word_size)) {\n-    \/\/ Humongous objects are allocated in entire regions, we must calculate\n-    \/\/ required space in terms of full regions, not just the object size.\n-    allocation_bytes = G1HeapRegion::align_up_to_region_byte_size(allocation_bytes);\n-  }\n-\n+  const size_t capacity_after_gc = _g1h->capacity();\n@@ -382,9 +372,15 @@\n-  const size_t capacity_after_gc = _g1h->capacity();\n-  const size_t used_after_gc = capacity_after_gc + allocation_bytes -\n-                               _g1h->unused_committed_regions_in_bytes() -\n-                               \/\/ Discount space used by current Eden to establish a\n-                               \/\/ situation during Remark similar to at the end of full\n-                               \/\/ GC where eden is empty. During Remark there can be an\n-                               \/\/ arbitrary number of eden regions which would skew the\n-                               \/\/ results.\n-                               _g1h->eden_regions_count() * G1HeapRegion::GrainBytes;\n+  const size_t current_used_after_gc = capacity_after_gc -\n+                                       _g1h->unused_committed_regions_in_bytes() -\n+                                       \/\/ Discount space used by current Eden to establish a\n+                                       \/\/ situation during Remark similar to at the end of full\n+                                       \/\/ GC where eden is empty. During Remark there can be an\n+                                       \/\/ arbitrary number of eden regions which would skew the\n+                                       \/\/ results.\n+                                       _g1h->eden_regions_count() * G1HeapRegion::GrainBytes;\n+\n+  \/\/ Add pending allocation;\n+  const size_t used_after_gc = current_used_after_gc +\n+                               \/\/ If the full collection was triggered by an allocation failure,\n+                               \/\/ account that allocation too. Otherwise we could shrink and then\n+                               \/\/ expand immediately to satisfy the allocation.\n+                               _g1h->allocation_used_bytes(allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -47,0 +47,5 @@\n+void G1IHOPControl::report_statistics(G1NewTracer* new_tracer, size_t non_young_occupancy) {\n+  print_log(non_young_occupancy);\n+  send_trace_event(new_tracer, non_young_occupancy);\n+}\n+\n@@ -53,1 +58,1 @@\n-void G1IHOPControl::print() {\n+void G1IHOPControl::print_log(size_t non_young_occupancy) {\n@@ -56,1 +61,1 @@\n-  log_debug(gc, ihop)(\"Basic information (value update), threshold: %zuB (%1.2f), target occupancy: %zuB, current occupancy: %zuB, \"\n+  log_debug(gc, ihop)(\"Basic information (value update), threshold: %zuB (%1.2f), target occupancy: %zuB, non-young occupancy: %zuB, \"\n@@ -61,1 +66,1 @@\n-                      G1CollectedHeap::heap()->used(),\n+                      non_young_occupancy,\n@@ -68,1 +73,1 @@\n-void G1IHOPControl::send_trace_event(G1NewTracer* tracer) {\n+void G1IHOPControl::send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy) {\n@@ -72,1 +77,1 @@\n-                                       G1CollectedHeap::heap()->used(),\n+                                       non_young_occupancy,\n@@ -168,5 +173,5 @@\n-void G1AdaptiveIHOPControl::print() {\n-  G1IHOPControl::print();\n-  size_t actual_target = actual_target_threshold();\n-  log_debug(gc, ihop)(\"Adaptive IHOP information (value update), threshold: %zuB (%1.2f), internal target occupancy: %zuB, \"\n-                      \"occupancy: %zuB, additional buffer size: %zuB, predicted old gen allocation rate: %1.2fB\/s, \"\n+void G1AdaptiveIHOPControl::print_log(size_t non_young_occupancy) {\n+  G1IHOPControl::print_log(non_young_occupancy);\n+  size_t actual_threshold = actual_target_threshold();\n+  log_debug(gc, ihop)(\"Adaptive IHOP information (value update), threshold: %zuB (%1.2f), internal target threshold: %zuB, \"\n+                      \"non-young occupancy: %zuB, additional buffer size: %zuB, predicted old gen allocation rate: %1.2fB\/s, \"\n@@ -175,3 +180,3 @@\n-                      percent_of(get_conc_mark_start_threshold(), actual_target),\n-                      actual_target,\n-                      G1CollectedHeap::heap()->used(),\n+                      percent_of(get_conc_mark_start_threshold(), actual_threshold),\n+                      actual_threshold,\n+                      non_young_occupancy,\n@@ -184,2 +189,2 @@\n-void G1AdaptiveIHOPControl::send_trace_event(G1NewTracer* tracer) {\n-  G1IHOPControl::send_trace_event(tracer);\n+void G1AdaptiveIHOPControl::send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy) {\n+  G1IHOPControl::send_trace_event(tracer, non_young_occupancy);\n@@ -188,1 +193,1 @@\n-                                          G1CollectedHeap::heap()->used(),\n+                                          non_young_occupancy,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1IHOPControl.cpp","additions":21,"deletions":16,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -58,1 +58,5 @@\n- public:\n+\n+  virtual void print_log(size_t non_young_occupancy);\n+  virtual void send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy);\n+\n+public:\n@@ -79,2 +83,1 @@\n-  virtual void print();\n-  virtual void send_trace_event(G1NewTracer* tracer);\n+  void report_statistics(G1NewTracer* tracer, size_t non_young_occupancy);\n@@ -142,0 +145,4 @@\n+\n+  virtual void print_log(size_t non_young_occupancy);\n+  virtual void send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy);\n+\n@@ -153,3 +160,0 @@\n-\n-  virtual void print();\n-  virtual void send_trace_event(G1NewTracer* tracer);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1IHOPControl.hpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -752,9 +752,1 @@\n-\n-  size_t cur_used_bytes = _g1h->non_young_capacity_bytes();\n-  size_t allocation_byte_size = allocation_word_size * HeapWordSize;\n-  \/\/ For humongous allocations, we need to consider that we actually use full regions\n-  \/\/ for allocations. So compare the threshold to this size.\n-  if (_g1h->is_humongous(allocation_word_size)) {\n-    allocation_byte_size = G1HeapRegion::align_up_to_region_byte_size(allocation_byte_size);\n-  }\n-  size_t marking_request_bytes = cur_used_bytes + allocation_byte_size;\n+  size_t occupancy_after_allocation = _g1h->non_young_occupancy_after_allocation(allocation_word_size);\n@@ -763,1 +755,1 @@\n-  if (marking_request_bytes > marking_initiating_used_threshold) {\n+  if (occupancy_after_allocation > marking_initiating_used_threshold) {\n@@ -767,1 +759,1 @@\n-                              cur_used_bytes, allocation_byte_size, marking_initiating_used_threshold, (double) marking_initiating_used_threshold \/ _g1h->capacity() * 100, source);\n+                              occupancy_after_allocation, allocation_word_size * HeapWordSize, marking_initiating_used_threshold, (double) marking_initiating_used_threshold \/ _g1h->capacity() * 100, source);\n@@ -998,4 +990,4 @@\n-    update_ihop_prediction(app_time_ms \/ 1000.0,\n-                           G1GCPauseTypeHelper::is_young_only_pause(this_pause));\n-\n-    _ihop_control->send_trace_event(_g1h->gc_tracer_stw());\n+    if (update_ihop_prediction(app_time_ms \/ 1000.0,\n+                               G1GCPauseTypeHelper::is_young_only_pause(this_pause))) {\n+      _ihop_control->report_statistics(_g1h->gc_tracer_stw(), _g1h->non_young_occupancy_after_allocation(allocation_word_size));\n+    }\n@@ -1048,1 +1040,1 @@\n-void G1Policy::update_ihop_prediction(double mutator_time_s,\n+bool G1Policy::update_ihop_prediction(double mutator_time_s,\n@@ -1085,7 +1077,1 @@\n-  if (report) {\n-    report_ihop_statistics();\n-  }\n-}\n-\n-void G1Policy::report_ihop_statistics() {\n-  _ihop_control->print();\n+  return report;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":9,"deletions":23,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -63,2 +63,3 @@\n-  \/\/ Update the IHOP control with necessary statistics.\n-  void update_ihop_prediction(double mutator_time_s,\n+  \/\/ Update the IHOP control with the necessary statistics. Returns true if there\n+  \/\/ has been a significant update to the prediction.\n+  bool update_ihop_prediction(double mutator_time_s,\n@@ -66,1 +67,0 @@\n-  void report_ihop_statistics();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                                               size_t current_occupancy,\n+                                               size_t non_young_occupancy,\n@@ -107,1 +107,1 @@\n-                             current_occupancy,\n+                             non_young_occupancy,\n@@ -209,1 +209,1 @@\n-                                             size_t current_occupancy,\n+                                             size_t non_young_occupancy,\n@@ -219,1 +219,1 @@\n-    evt.set_currentOccupancy(current_occupancy);\n+    evt.set_currentOccupancy(non_young_occupancy);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Trace.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-                                  size_t current_occupancy,\n+                                  size_t non_young_occupancy,\n@@ -82,1 +82,1 @@\n-                                     size_t current_occupancy,\n+                                     size_t non_young_occupancy,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Trace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}