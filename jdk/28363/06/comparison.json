{"files":[{"patch":"@@ -3530,0 +3530,2 @@\n+  __ cmpl(len, 16 * 16);\n+  __ jcc(Assembler::lessEqual, ENC_DEC_DONE);\n@@ -4019,1 +4021,1 @@\n-  Label encrypt_done, encrypt_by_8_new, encrypt_by_8;\n+  Label encrypt_done, encrypt_by_8_new, encrypt_by_8, exit;\n@@ -4026,0 +4028,2 @@\n+  __ cmpl(len, 128);\n+  __ jcc(Assembler::less, exit);\n@@ -4093,0 +4097,1 @@\n+  __ bind(exit);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_aes.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2025, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8371864\n+ * @run main\/othervm\/timeout=600 TestGCMSplitBound\n+ * @summary Test GaloisCounterMode.implGCMCrypt0 AVX512\/AVX2 intrinsics.\n+ *\/\n+\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class TestGCMSplitBound {\n+\n+    static final SecureRandom SECURE_RANDOM = newDefaultSecureRandom();\n+\n+    private static SecureRandom newDefaultSecureRandom() {\n+        SecureRandom retval = new SecureRandom();\n+        retval.nextLong(); \/\/ force seeding\n+        return retval;\n+    }\n+\n+    private static byte[] randBytes(int size) {\n+        byte[] rand = new byte[size];\n+        SECURE_RANDOM.nextBytes(rand);\n+        return rand;\n+    }\n+\n+    private static final int IV_SIZE_IN_BYTES = 12;\n+    private static final int TAG_SIZE_IN_BYTES = 16;\n+\n+    private Cipher getCipher(final byte[] key, final byte[] aad, final byte[] nonce, int mode)\n+        throws Exception {\n+        SecretKey keySpec = new SecretKeySpec(key, \"AES\");\n+        AlgorithmParameterSpec params =\n+            new GCMParameterSpec(8 * TAG_SIZE_IN_BYTES, nonce, 0, nonce.length);\n+        Cipher cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+        cipher.init(mode, keySpec, params);\n+        if (aad != null && aad.length != 0) {\n+            cipher.updateAAD(aad);\n+        }\n+        return cipher;\n+    }\n+\n+    private byte[] gcmEncrypt(final byte[] key, final byte[] plaintext, final byte[] aad)\n+        throws Exception {\n+        byte[] nonce = randBytes(IV_SIZE_IN_BYTES);\n+        Cipher cipher = getCipher(key, aad, nonce, Cipher.ENCRYPT_MODE);\n+        int outputSize = cipher.getOutputSize(plaintext.length);\n+        int len = IV_SIZE_IN_BYTES + outputSize;\n+        byte[] output = new byte[len];\n+        System.arraycopy(nonce, 0, output, 0, IV_SIZE_IN_BYTES);\n+        cipher.doFinal(plaintext, 0, plaintext.length, output, IV_SIZE_IN_BYTES);\n+        return output;\n+    }\n+\n+    private byte[] gcmDecrypt(final byte[] key, final byte[] ciphertext, final byte[] aad)\n+        throws Exception {\n+        byte[] nonce = new byte[IV_SIZE_IN_BYTES];\n+        System.arraycopy(ciphertext, 0, nonce, 0, IV_SIZE_IN_BYTES);\n+        Cipher cipher = getCipher(key, aad, nonce, Cipher.DECRYPT_MODE);\n+        return cipher.doFinal(ciphertext, IV_SIZE_IN_BYTES, ciphertext.length - IV_SIZE_IN_BYTES);\n+    }\n+\n+    \/\/ x86-64 parallel intrinsic data size\n+    private static final int PARALLEL_LEN = 512;\n+    \/\/ max data size for x86-64 intrinsic\n+    private static final int SPLIT_LEN = 1048576; \/\/ 1MB\n+\n+    private void encryptAndDecrypt(byte[] key, byte[] aad, byte[] message, int messageSize)\n+        throws Exception {\n+        byte[] ciphertext = gcmEncrypt(key, message, aad);\n+        byte[] decrypted = gcmDecrypt(key, ciphertext, aad);\n+        if (ciphertext == null) {\n+            throw new RuntimeException(\"ciphertext is null\");\n+        }\n+        if (Arrays.compare(decrypted, 0, messageSize, message, 0, messageSize) != 0) {\n+            throw new RuntimeException(\n+                 \"Decrypted message is different from the original message\");\n+        }\n+    }\n+\n+    private void run() throws Exception {\n+        byte[] aad = randBytes(20);\n+        byte[] key = randBytes(16);\n+        \/\/ Force JIT.\n+        for (int i = 0; i < 100000; i++) {\n+            byte[] message = randBytes(PARALLEL_LEN);\n+            encryptAndDecrypt(key, aad, message, PARALLEL_LEN);\n+        }\n+        for (int messageSize = SPLIT_LEN - 300; messageSize <= SPLIT_LEN + 300; messageSize++) {\n+            byte[] message = randBytes(messageSize);\n+            try {\n+                encryptAndDecrypt(key, aad, message, messageSize);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\n+                    \"Failed for messageSize \" + Integer.toHexString(messageSize), e);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        TestGCMSplitBound test = new TestGCMSplitBound();\n+        for (int i = 0; i < 3; i++) {\n+            test.run();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AES\/TestGCMSplitBound.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"}]}