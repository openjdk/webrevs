{"files":[{"patch":"@@ -3530,0 +3530,2 @@\n+  __ cmpl(len, 256);\n+  __ jcc(Assembler::lessEqual, ENC_DEC_DONE);\n@@ -4019,1 +4021,1 @@\n-  Label encrypt_done, encrypt_by_8_new, encrypt_by_8;\n+  Label encrypt_done, encrypt_by_8_new, encrypt_by_8, exit;\n@@ -4026,0 +4028,2 @@\n+  __ cmpl(len, 128);\n+  __ jcc(Assembler::less, exit);\n@@ -4093,0 +4097,1 @@\n+  __ bind(exit);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_aes.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8371864\n+ * @run main\/othervm TestAesGcmIntrinsic\n+ * @summary Test GaloisCounterMode.implGCMCrypt0 AVX512\/AVX2 intrinsics.\n+ *\/\n+\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.time.Duration;\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class TestAesGcmIntrinsic {\n+\n+  static final SecureRandom SECURE_RANDOM = newDefaultSecureRandom();\n+\n+  private static SecureRandom newDefaultSecureRandom() {\n+    SecureRandom retval = new SecureRandom();\n+    retval.nextLong(); \/\/ force seeding\n+    return retval;\n+  }\n+\n+  private static byte[] randBytes(int size) {\n+    byte[] rand = new byte[size];\n+    SECURE_RANDOM.nextBytes(rand);\n+    return rand;\n+  }\n+\n+  private static final int IV_SIZE_IN_BYTES = 12;\n+  private static final int TAG_SIZE_IN_BYTES = 16;\n+\n+  private byte[] gcmEncrypt(final byte[] key, final byte[] plaintext, final byte[] aad)\n+      throws Exception {\n+    byte[] nonce = randBytes(IV_SIZE_IN_BYTES);\n+    SecretKey keySpec = new SecretKeySpec(key, \"AES\");\n+    AlgorithmParameterSpec params =\n+        new GCMParameterSpec(8 * TAG_SIZE_IN_BYTES, nonce, 0, nonce.length);\n+    Cipher cipher = Cipher.getInstance(\"AES\/GCM\/NoPadding\");\n+    cipher.init(Cipher.ENCRYPT_MODE, keySpec, params);\n+    if (aad != null && aad.length != 0) {\n+      cipher.updateAAD(aad);\n+    }\n+    int outputSize = cipher.getOutputSize(plaintext.length);\n+    int len = IV_SIZE_IN_BYTES + outputSize;\n+    byte[] output = new byte[len];\n+    System.arraycopy(nonce, 0, output, 0, IV_SIZE_IN_BYTES);\n+    cipher.doFinal(plaintext, 0, plaintext.length, output, IV_SIZE_IN_BYTES);\n+    return output;\n+  }\n+\n+  \/\/ x86-64 parallel intrinsic data size\n+  private static final int PARALLEL_LEN = 512;\n+  \/\/ max data size for x86-64 intrinsic\n+  private static final int SPLIT_LEN = 1048576; \/\/ 1MB\n+\n+  private void jitFunc() throws Exception {\n+    byte[] aad = randBytes(20);\n+    byte[] key = randBytes(16);\n+    \/\/ Force JIT.\n+    for (int i = 0; i < 100000; i++) {\n+      byte[] message = randBytes(PARALLEL_LEN);\n+      byte[] ciphertext = gcmEncrypt(key, message, aad);\n+      if (ciphertext == null) {\n+        throw new RuntimeException(\"ciphertext is null\");\n+      }\n+    }\n+    for (int messageSize = SPLIT_LEN; messageSize < SPLIT_LEN + 300; messageSize++) {\n+      byte[] message = randBytes(messageSize);\n+      try {\n+        byte[] ciphertext = gcmEncrypt(key, message, aad);\n+        if (ciphertext == null) {\n+          throw new RuntimeException(\"ciphertext is null\");\n+        }\n+      } catch (Exception e) {\n+        throw new Exception(\"Failed for messageSize \" + Integer.toHexString(messageSize), e);\n+      }\n+    }\n+  }\n+\n+  public static void main(String[] args) throws Exception {\n+    TestAesGcmIntrinsic test = new TestAesGcmIntrinsic();\n+    long startTime = System.currentTimeMillis();\n+    while (System.currentTimeMillis() - startTime < 60 * 1000) {\n+      test.jitFunc();\n+    }\n+  }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AES\/TestAesGcmIntrinsic.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"}]}