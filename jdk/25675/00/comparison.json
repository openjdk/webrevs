{"files":[{"patch":"@@ -1264,63 +1264,0 @@\n-static char saved_jvm_path[MAXPATHLEN] = {0};\n-\n-\/\/ Find the full path to the current module, libjvm.so.\n-void os::jvm_path(char *buf, jint buflen) {\n-  \/\/ Error checking.\n-  if (buflen < MAXPATHLEN) {\n-    assert(false, \"must use a large-enough buffer\");\n-    buf[0] = '\\0';\n-    return;\n-  }\n-  \/\/ Lazy resolve the path to current module.\n-  if (saved_jvm_path[0] != 0) {\n-    strcpy(buf, saved_jvm_path);\n-    return;\n-  }\n-\n-  Dl_info dlinfo;\n-  int ret = dladdr(CAST_FROM_FN_PTR(void *, os::jvm_path), &dlinfo);\n-  assert(ret != 0, \"cannot locate libjvm\");\n-  char* rp = os::realpath((char *)dlinfo.dli_fname, buf, buflen);\n-  assert(rp != nullptr, \"error in realpath(): maybe the 'path' argument is too long?\");\n-\n-  \/\/ If executing unit tests we require JAVA_HOME to point to the real JDK.\n-  if (Arguments::executing_unit_tests()) {\n-    \/\/ Look for JAVA_HOME in the environment.\n-    char* java_home_var = ::getenv(\"JAVA_HOME\");\n-    if (java_home_var != nullptr && java_home_var[0] != 0) {\n-\n-      \/\/ Check the current module name \"libjvm.so\".\n-      const char* p = strrchr(buf, '\/');\n-      if (p == nullptr) {\n-        return;\n-      }\n-      assert(strstr(p, \"\/libjvm\") == p, \"invalid library name\");\n-\n-      stringStream ss(buf, buflen);\n-      rp = os::realpath(java_home_var, buf, buflen);\n-      if (rp == nullptr) {\n-        return;\n-      }\n-\n-      assert((int)strlen(buf) < buflen, \"Ran out of buffer room\");\n-      ss.print(\"%s\/lib\", buf);\n-\n-      if (0 == access(buf, F_OK)) {\n-        \/\/ Use current module name \"libjvm.so\"\n-        ss.print(\"\/%s\/libjvm%s\", Abstract_VM_Version::vm_variant(), JNI_LIB_SUFFIX);\n-        assert(strcmp(buf + strlen(buf) - strlen(JNI_LIB_SUFFIX), JNI_LIB_SUFFIX) == 0,\n-               \"buf has been truncated\");\n-      } else {\n-        \/\/ Go back to path of .so\n-        rp = os::realpath((char *)dlinfo.dli_fname, buf, buflen);\n-        if (rp == nullptr) {\n-          return;\n-        }\n-      }\n-    }\n-  }\n-\n-  strncpy(saved_jvm_path, buf, sizeof(saved_jvm_path));\n-  saved_jvm_path[sizeof(saved_jvm_path) - 1] = '\\0';\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":63,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1485,77 +1485,0 @@\n-static char saved_jvm_path[MAXPATHLEN] = {0};\n-\n-\/\/ Find the full path to the current module, libjvm\n-void os::jvm_path(char *buf, jint buflen) {\n-  \/\/ Error checking.\n-  if (buflen < MAXPATHLEN) {\n-    assert(false, \"must use a large-enough buffer\");\n-    buf[0] = '\\0';\n-    return;\n-  }\n-  \/\/ Lazy resolve the path to current module.\n-  if (saved_jvm_path[0] != 0) {\n-    strcpy(buf, saved_jvm_path);\n-    return;\n-  }\n-\n-  char dli_fname[MAXPATHLEN];\n-  dli_fname[0] = '\\0';\n-  bool ret = dll_address_to_library_name(\n-                                         CAST_FROM_FN_PTR(address, os::jvm_path),\n-                                         dli_fname, sizeof(dli_fname), nullptr);\n-  assert(ret, \"cannot locate libjvm\");\n-  char *rp = nullptr;\n-  if (ret && dli_fname[0] != '\\0') {\n-    rp = os::realpath(dli_fname, buf, buflen);\n-  }\n-  if (rp == nullptr) {\n-    return;\n-  }\n-\n-  \/\/ If executing unit tests we require JAVA_HOME to point to the real JDK.\n-  if (Arguments::executing_unit_tests()) {\n-    \/\/ Look for JAVA_HOME in the environment.\n-    char* java_home_var = ::getenv(\"JAVA_HOME\");\n-    if (java_home_var != nullptr && java_home_var[0] != 0) {\n-\n-      \/\/ Check the current module name \"libjvm\"\n-      const char* p = strrchr(buf, '\/');\n-      assert(strstr(p, \"\/libjvm\") == p, \"invalid library name\");\n-\n-      stringStream ss(buf, buflen);\n-      rp = os::realpath(java_home_var, buf, buflen);\n-      if (rp == nullptr) {\n-        return;\n-      }\n-\n-      assert((int)strlen(buf) < buflen, \"Ran out of buffer space\");\n-      \/\/ Add the appropriate library and JVM variant subdirs\n-      ss.print(\"%s\/lib\/%s\", buf, Abstract_VM_Version::vm_variant());\n-\n-      if (0 != access(buf, F_OK)) {\n-        ss.reset();\n-        ss.print(\"%s\/lib\", buf);\n-      }\n-\n-      \/\/ If the path exists within JAVA_HOME, add the JVM library name\n-      \/\/ to complete the path to JVM being overridden.  Otherwise fallback\n-      \/\/ to the path to the current library.\n-      if (0 == access(buf, F_OK)) {\n-        \/\/ Use current module name \"libjvm\"\n-        ss.print(\"\/libjvm%s\", JNI_LIB_SUFFIX);\n-        assert(strcmp(buf + strlen(buf) - strlen(JNI_LIB_SUFFIX), JNI_LIB_SUFFIX) == 0,\n-               \"buf has been truncated\");\n-      } else {\n-        \/\/ Fall back to path of current library\n-        rp = os::realpath(dli_fname, buf, buflen);\n-        if (rp == nullptr) {\n-          return;\n-        }\n-      }\n-    }\n-  }\n-\n-  strncpy(saved_jvm_path, buf, MAXPATHLEN);\n-  saved_jvm_path[MAXPATHLEN - 1] = '\\0';\n-}\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":77,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2749,71 +2749,0 @@\n-static char saved_jvm_path[MAXPATHLEN] = {0};\n-\n-\/\/ Find the full path to the current module, libjvm.so\n-void os::jvm_path(char *buf, jint buflen) {\n-  \/\/ Error checking.\n-  if (buflen < MAXPATHLEN) {\n-    assert(false, \"must use a large-enough buffer\");\n-    buf[0] = '\\0';\n-    return;\n-  }\n-  \/\/ Lazy resolve the path to current module.\n-  if (saved_jvm_path[0] != 0) {\n-    strcpy(buf, saved_jvm_path);\n-    return;\n-  }\n-\n-  char dli_fname[MAXPATHLEN];\n-  dli_fname[0] = '\\0';\n-  bool ret = dll_address_to_library_name(\n-                                         CAST_FROM_FN_PTR(address, os::jvm_path),\n-                                         dli_fname, sizeof(dli_fname), nullptr);\n-  assert(ret, \"cannot locate libjvm\");\n-  char *rp = nullptr;\n-  if (ret && dli_fname[0] != '\\0') {\n-    rp = os::realpath(dli_fname, buf, buflen);\n-  }\n-  if (rp == nullptr) {\n-    return;\n-  }\n-\n-  \/\/ If executing unit tests we require JAVA_HOME to point to the real JDK.\n-  if (Arguments::executing_unit_tests()) {\n-    \/\/ Look for JAVA_HOME in the environment.\n-    char* java_home_var = ::getenv(\"JAVA_HOME\");\n-    if (java_home_var != nullptr && java_home_var[0] != 0) {\n-\n-      \/\/ Check the current module name \"libjvm.so\".\n-      const char* p = strrchr(buf, '\/');\n-      if (p == nullptr) {\n-        return;\n-      }\n-      assert(strstr(p, \"\/libjvm\") == p, \"invalid library name\");\n-\n-      stringStream ss(buf, buflen);\n-      rp = os::realpath(java_home_var, buf, buflen);\n-      if (rp == nullptr) {\n-        return;\n-      }\n-\n-      assert((int)strlen(buf) < buflen, \"Ran out of buffer room\");\n-      ss.print(\"%s\/lib\", buf);\n-\n-      if (0 == access(buf, F_OK)) {\n-        \/\/ Use current module name \"libjvm.so\"\n-        ss.print(\"\/%s\/libjvm%s\", Abstract_VM_Version::vm_variant(), JNI_LIB_SUFFIX);\n-        assert(strcmp(buf + strlen(buf) - strlen(JNI_LIB_SUFFIX), JNI_LIB_SUFFIX) == 0,\n-               \"buf has been truncated\");\n-      } else {\n-        \/\/ Go back to path of .so\n-        rp = os::realpath(dli_fname, buf, buflen);\n-        if (rp == nullptr) {\n-          return;\n-        }\n-      }\n-    }\n-  }\n-\n-  strncpy(saved_jvm_path, buf, MAXPATHLEN);\n-  saved_jvm_path[MAXPATHLEN - 1] = '\\0';\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":71,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1063,0 +1063,82 @@\n+static char saved_jvm_path[MAXPATHLEN] = {0};\n+\n+\/\/ Find the full path to the current module, libjvm.so\n+void os::jvm_path(char *buf, jint buflen) {\n+  \/\/ Error checking.\n+  if (buflen < MAXPATHLEN) {\n+    assert(false, \"must use a large-enough buffer\");\n+    buf[0] = '\\0';\n+    return;\n+  }\n+  \/\/ Lazy resolve the path to current module.\n+  if (saved_jvm_path[0] != 0) {\n+    strcpy(buf, saved_jvm_path);\n+    return;\n+  }\n+\n+#ifdef AIX\n+  Dl_info dlinfo;\n+  int ret = dladdr(CAST_FROM_FN_PTR(void *, os::jvm_path), &dlinfo);\n+  assert(ret != 0, \"cannot locate libjvm\");\n+  char* rp = os::realpath((char *)dlinfo.dli_fname, buf, buflen);\n+  assert(rp != nullptr, \"error in realpath(): maybe the 'path' argument is too long?\");\n+#else\n+  char dli_fname[MAXPATHLEN];\n+  dli_fname[0] = '\\0';\n+  bool ret = dll_address_to_library_name(\n+                                         CAST_FROM_FN_PTR(address, os::jvm_path),\n+                                         dli_fname, sizeof(dli_fname), nullptr);\n+  assert(ret, \"cannot locate libjvm\");\n+  char *rp = nullptr;\n+  if (ret && dli_fname[0] != '\\0') {\n+    rp = os::realpath(dli_fname, buf, buflen);\n+  }\n+  if (rp == nullptr) {\n+    return;\n+  }\n+#endif \/\/ AIX\n+\n+  \/\/ If executing unit tests we require JAVA_HOME to point to the real JDK.\n+  if (Arguments::executing_unit_tests()) {\n+    \/\/ Look for JAVA_HOME in the environment.\n+    char* java_home_var = ::getenv(\"JAVA_HOME\");\n+    if (java_home_var != nullptr && java_home_var[0] != 0) {\n+\n+      \/\/ Check the current module name \"libjvm.so\".\n+      const char* p = strrchr(buf, '\/');\n+      if (p == nullptr) {\n+        return;\n+      }\n+      assert(strstr(p, \"\/libjvm\") == p, \"invalid library name\");\n+\n+      stringStream ss(buf, buflen);\n+      rp = os::realpath(java_home_var, buf, buflen);\n+      if (rp == nullptr) {\n+        return;\n+      }\n+\n+      assert((int)strlen(buf) < buflen, \"Ran out of buffer room\");\n+      ss.print(\"%s\/lib\", buf);\n+\n+      \/\/ If the path exists within JAVA_HOME, add the VM variant directory and JVM\n+      \/\/ library name to complete the path to JVM being overridden.  Otherwise fallback\n+      \/\/ to the path to the current library.\n+      if (0 == access(buf, F_OK)) {\n+        \/\/ Use current module name \"libjvm.so\"\n+        ss.print(\"\/%s\/libjvm%s\", Abstract_VM_Version::vm_variant(), JNI_LIB_SUFFIX);\n+        assert(strcmp(buf + strlen(buf) - strlen(JNI_LIB_SUFFIX), JNI_LIB_SUFFIX) == 0,\n+               \"buf has been truncated\");\n+      } else {\n+        \/\/ Go back to path of .so\n+        rp = os::realpath(dli_fname, buf, buflen);\n+        if (rp == nullptr) {\n+          return;\n+        }\n+      }\n+    }\n+  }\n+\n+  strncpy(saved_jvm_path, buf, MAXPATHLEN);\n+  saved_jvm_path[MAXPATHLEN - 1] = '\\0';\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"}]}