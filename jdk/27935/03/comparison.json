{"files":[{"patch":"@@ -849,4 +849,0 @@\n-  if (UseNUMA) {\n-    thread->update_lgrp_id();\n-  }\n-\n@@ -1178,4 +1174,0 @@\n-  if (UseNUMA) {\n-    thread->update_lgrp_id();\n-  }\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -98,2 +99,2 @@\n-  for (int i = 0; i < lgrp_spaces()->length(); i++) {\n-    s += lgrp_spaces()->at(i)->space()->used_in_words();\n+  for (LGRPSpace* ls : *lgrp_spaces()) {\n+    s += ls->space()->used_in_words();\n@@ -106,2 +107,2 @@\n-  for (int i = 0; i < lgrp_spaces()->length(); i++) {\n-    s += lgrp_spaces()->at(i)->space()->free_in_words();\n+  for (LGRPSpace* ls : *lgrp_spaces()) {\n+    s += ls->space()->free_in_words();\n@@ -112,13 +113,4 @@\n-MutableNUMASpace::LGRPSpace *MutableNUMASpace::lgrp_space_for_thread(Thread* thr) const {\n-  guarantee(thr != nullptr, \"No thread\");\n-\n-  int lgrp_id = thr->lgrp_id();\n-  assert(lgrp_id != -1, \"lgrp_id must be set during thread creation\");\n-\n-  int lgrp_spaces_index = lgrp_spaces()->find_if([&](LGRPSpace* space) {\n-    return space->lgrp_id() == (uint)lgrp_id;\n-  });\n-\n-  if (lgrp_spaces_index == -1) {\n-    \/\/ Running on a CPU with no memory; pick another CPU based on %.\n-    lgrp_spaces_index = lgrp_id % lgrp_spaces()->length();\n+size_t MutableNUMASpace::tlab_capacity(Thread *ignored) const {\n+  size_t s = 0;\n+  for (LGRPSpace* ls : *lgrp_spaces()) {\n+    s += ls->space()->capacity_in_bytes();\n@@ -126,1 +118,1 @@\n-  return lgrp_spaces()->at(lgrp_spaces_index);\n+  return s \/ (size_t)lgrp_spaces()->length();\n@@ -129,2 +121,6 @@\n-size_t MutableNUMASpace::tlab_capacity(Thread *thr) const {\n-  return lgrp_space_for_thread(thr)->space()->capacity_in_bytes();\n+size_t MutableNUMASpace::tlab_used(Thread *ignored) const {\n+  size_t s = 0;\n+  for (LGRPSpace* ls : *lgrp_spaces()) {\n+    s += ls->space()->used_in_bytes();\n+  }\n+  return s \/ (size_t)lgrp_spaces()->length();\n@@ -133,3 +129,13 @@\n-size_t MutableNUMASpace::tlab_used(Thread *thr) const {\n-  return lgrp_space_for_thread(thr)->space()->used_in_bytes();\n-}\n+size_t MutableNUMASpace::unsafe_max_tlab_alloc(Thread *ignored) const {\n+  size_t s = 0;\n+  for (LGRPSpace* ls : *lgrp_spaces()) {\n+    s += ls->space()->free_in_bytes();\n+  }\n+\n+  size_t average_free_in_bytes = s \/ (size_t)lgrp_spaces()->length();\n+\n+  \/\/ free_in_bytes() is aligned to MinObjAlignmentInBytes, but averaging across\n+  \/\/ all LGRPs can produce a non-aligned result. We align the value here because\n+  \/\/ it may be used directly for TLAB allocation, which requires the allocation\n+  \/\/ size to be properly aligned.\n+  size_t aligned_average = align_down(average_free_in_bytes, MinObjAlignmentInBytes);\n@@ -137,2 +143,1 @@\n-size_t MutableNUMASpace::unsafe_max_tlab_alloc(Thread *thr) const {\n-  return lgrp_space_for_thread(thr)->space()->free_in_bytes();\n+  return aligned_average;\n@@ -454,2 +459,5 @@\n-HeapWord* MutableNUMASpace::cas_allocate(size_t size) {\n-  Thread *thr = Thread::current();\n+MutableNUMASpace::LGRPSpace *MutableNUMASpace::lgrp_space_for_current_thread() const {\n+  const int lgrp_id = os::numa_get_group_id();\n+  int lgrp_spaces_index = lgrp_spaces()->find_if([&](LGRPSpace* space) {\n+    return space->lgrp_id() == (uint)lgrp_id;\n+  });\n@@ -457,2 +465,4 @@\n-  \/\/ Update the locality group to match where the thread actually is.\n-  thr->update_lgrp_id();\n+  if (lgrp_spaces_index == -1) {\n+    \/\/ Running on a CPU with no memory; pick another CPU based on %.\n+    lgrp_spaces_index = lgrp_id % lgrp_spaces()->length();\n+  }\n@@ -460,1 +470,5 @@\n-  LGRPSpace *ls = lgrp_space_for_thread(thr);\n+  return lgrp_spaces()->at(lgrp_spaces_index);\n+}\n+\n+HeapWord* MutableNUMASpace::cas_allocate(size_t size) {\n+  LGRPSpace *ls = lgrp_space_for_current_thread();\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":44,"deletions":30,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  LGRPSpace *lgrp_space_for_thread(Thread *thr) const;\n+  LGRPSpace *lgrp_space_for_current_thread() const;\n@@ -169,3 +169,3 @@\n-  virtual size_t tlab_capacity(Thread* thr) const;\n-  virtual size_t tlab_used(Thread* thr) const;\n-  virtual size_t unsafe_max_tlab_alloc(Thread* thr) const;\n+  virtual size_t tlab_capacity(Thread* ignored) const;\n+  virtual size_t tlab_used(Thread* ignored) const;\n+  virtual size_t unsafe_max_tlab_alloc(Thread* ignored) const;\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-  _lgrp_id = -1;\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -525,1 +525,0 @@\n-  int              _lgrp_id;\n@@ -540,3 +539,0 @@\n-  int     lgrp_id() const  { return _lgrp_id; }\n-  void    update_lgrp_id() { _lgrp_id = os::numa_get_group_id(); }\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}