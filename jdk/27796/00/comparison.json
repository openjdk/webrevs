{"files":[{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package jdk.internal.ffi.generated.errno;\n-\n-import java.lang.foreign.*;\n-import java.lang.invoke.*;\n-import java.util.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-\n-@SuppressWarnings(\"restricted\")\n-public class errno_h$shared {\n-\n-    errno_h$shared() {\n-        \/\/ Should not be called directly\n-    }\n-\n-    public static final OfBoolean C_BOOL = (OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n-    public static final OfByte C_CHAR =(OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n-    public static final OfShort C_SHORT = (OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n-    public static final OfInt C_INT = (OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n-    public static final OfLong C_LONG_LONG = (OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n-    public static final OfFloat C_FLOAT = (OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n-    public static final OfDouble C_DOUBLE = (OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n-    public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n-            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n-    public static final OfLong C_LONG = (OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long\");\n-\n-    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n-\n-    static void traceDowncall(String name, Object... args) {\n-         String traceArgs = Arrays.stream(args)\n-                       .map(Object::toString)\n-                       .collect(Collectors.joining(\", \"));\n-         System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n-    }\n-\n-    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n-        try {\n-            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static MemoryLayout align(MemoryLayout layout, long align) {\n-        return switch (layout) {\n-            case PaddingLayout p -> p;\n-            case ValueLayout v -> v.withByteAlignment(align);\n-            case GroupLayout g -> {\n-                MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n-                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n-                yield g instanceof StructLayout ?\n-                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n-            }\n-            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n-        };\n-    }\n-}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/errno\/errno_h$shared.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.ffi.util.FFMUtils;\n+\n@@ -34,1 +36,1 @@\n-public class errno_h extends errno_h$shared {\n+public class errno_h {\n@@ -40,5 +42,0 @@\n-    static final Arena LIBRARY_ARENA = Arena.ofAuto();\n-\n-    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n-            .or(Linker.nativeLinker().defaultLookup());\n-\n@@ -57,4 +54,4 @@\n-                C_INT,\n-                C_INT,\n-                C_POINTER,\n-                C_LONG\n+            FFMUtils.C_INT,\n+            FFMUtils.C_INT,\n+            FFMUtils.C_POINTER,\n+            FFMUtils.C_LONG\n@@ -63,1 +60,1 @@\n-        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow(\"strerror_r\");\n+        public static final MemorySegment ADDR = FFMUtils.findOrThrow(\"strerror_r\");\n@@ -106,2 +103,2 @@\n-            if (TRACE_DOWNCALLS) {\n-                traceDowncall(\"strerror_r\", __errnum, __strerrbuf, __buflen);\n+            if (FFMUtils.TRACE_DOWNCALLS) {\n+                FFMUtils.traceDowncall(\"strerror_r\", __errnum, __strerrbuf, __buflen);\n@@ -110,2 +107,0 @@\n-        } catch (Error | RuntimeException ex) {\n-           throw ex;\n@@ -113,1 +108,1 @@\n-           throw new AssertionError(\"should not reach here\", ex$);\n+            throw new AssertionError(\"should not reach here\", ex$);\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/errno\/errno_h.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -41,0 +41,4 @@\n+ * After generation of native bindings, the layouts for the C builtin layouts and other\n+ * variables\/methods not specific to a component area are moved to the {@code FFMUtils} class\n+ * for future reusability.\n+ *\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/errno\/package-info.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-import java.lang.foreign.*;\n-import java.util.function.*;\n+import jdk.internal.ffi.util.FFMUtils;\n@@ -33,2 +32,12 @@\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-import static java.lang.foreign.ValueLayout.*;\n+import java.lang.foreign.GroupLayout;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.AddressLayout;\n+import java.lang.foreign.SegmentAllocator;\n+import java.lang.foreign.Arena;\n+import java.util.function.Consumer;\n+\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n+import static java.lang.foreign.ValueLayout.OfLong;\n+import static java.lang.foreign.ValueLayout.OfShort;\n+import static java.lang.foreign.ValueLayout.OfInt;\n@@ -56,6 +65,6 @@\n-        kqueue_h.align(kqueue_h.C_LONG, 4).withName(\"ident\"),\n-        kqueue_h.C_SHORT.withName(\"filter\"),\n-        kqueue_h.C_SHORT.withName(\"flags\"),\n-        kqueue_h.C_INT.withName(\"fflags\"),\n-        kqueue_h.align(kqueue_h.C_LONG, 4).withName(\"data\"),\n-        kqueue_h.align(kqueue_h.C_POINTER, 4).withName(\"udata\")\n+        FFMUtils.align(FFMUtils.C_LONG, 4).withName(\"ident\"),\n+        FFMUtils.C_SHORT.withName(\"filter\"),\n+        FFMUtils.C_SHORT.withName(\"flags\"),\n+        FFMUtils.C_INT.withName(\"fflags\"),\n+        FFMUtils.align(FFMUtils.C_LONG, 4).withName(\"data\"),\n+        FFMUtils.align(FFMUtils.C_POINTER, 4).withName(\"udata\")\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/kqueue\/kevent.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package jdk.internal.ffi.generated.kqueue;\n-\n-import java.lang.foreign.*;\n-import java.lang.invoke.*;\n-import java.util.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-\n-@SuppressWarnings(\"restricted\")\n-public class kqueue_h$shared {\n-\n-    kqueue_h$shared() {\n-        \/\/ Should not be called directly\n-    }\n-\n-    public static final OfBoolean C_BOOL = (OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n-    public static final OfByte C_CHAR =(OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n-    public static final OfShort C_SHORT = (OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n-    public static final OfInt C_INT = (OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n-    public static final OfLong C_LONG_LONG = (OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n-    public static final OfFloat C_FLOAT = (OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n-    public static final OfDouble C_DOUBLE = (OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n-    public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n-            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n-    public static final OfLong C_LONG = (OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long\");\n-\n-    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n-\n-    static void traceDowncall(String name, Object... args) {\n-         String traceArgs = Arrays.stream(args)\n-                       .map(Object::toString)\n-                       .collect(Collectors.joining(\", \"));\n-         System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n-    }\n-\n-    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n-        try {\n-            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static MemoryLayout align(MemoryLayout layout, long align) {\n-        return switch (layout) {\n-            case PaddingLayout p -> p;\n-            case ValueLayout v -> v.withByteAlignment(align);\n-            case GroupLayout g -> {\n-                MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n-                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n-                yield g instanceof StructLayout ?\n-                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n-            }\n-            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n-        };\n-    }\n-}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/kqueue\/kqueue_h$shared.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -30,0 +30,3 @@\n+import jdk.internal.ffi.util.FFMUtils;\n+import jdk.internal.foreign.*;\n+\n@@ -31,1 +34,1 @@\n-import java.lang.invoke.*;\n+import java.lang.invoke.MethodHandle;\n@@ -34,1 +37,3 @@\n-public class kqueue_h extends kqueue_h$shared {\n+public class kqueue_h {\n+\n+    private static final String ERRNO_NAME = \"errno\";\n@@ -40,2 +45,0 @@\n-    static final Arena LIBRARY_ARENA = Arena.ofAuto();\n-\n@@ -72,0 +75,1 @@\n+\n@@ -83,2 +87,1 @@\n-        public static final FunctionDescriptor DESC = FunctionDescriptor.of(\n-            kqueue_h.C_INT    );\n+        public static final FunctionDescriptor DESC = FunctionDescriptor.of(FFMUtils.C_INT);\n@@ -86,1 +89,1 @@\n-        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow(\"kqueue\");\n+        public static final MemorySegment ADDR = FFMUtils.findOrThrow(\"kqueue\");\n@@ -88,1 +91,4 @@\n-        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC,\n+                Linker.Option.captureCallState(ERRNO_NAME));\n+\n+        public static final MethodHandle ADAPTED = CaptureStateUtil.adaptSystemCall(HANDLE, ERRNO_NAME);\n@@ -127,1 +133,0 @@\n-        var mh$ = kqueue.HANDLE;\n@@ -129,6 +134,1 @@\n-            if (TRACE_DOWNCALLS) {\n-                traceDowncall(\"kqueue\");\n-            }\n-            return (int)mh$.invokeExact();\n-        } catch (Error | RuntimeException ex) {\n-           throw ex;\n+            return (int) kqueue.ADAPTED.invokeExact();\n@@ -136,1 +136,1 @@\n-           throw new AssertionError(\"should not reach here\", ex$);\n+            throw new AssertionError(\"should not reach here\", ex$);\n@@ -142,7 +142,7 @@\n-            kqueue_h.C_INT,\n-            kqueue_h.C_INT,\n-            kqueue_h.C_POINTER,\n-            kqueue_h.C_INT,\n-            kqueue_h.C_POINTER,\n-            kqueue_h.C_INT,\n-            kqueue_h.C_POINTER\n+            FFMUtils.C_INT,\n+            FFMUtils.C_INT,\n+            FFMUtils.C_POINTER,\n+            FFMUtils.C_INT,\n+            FFMUtils.C_POINTER,\n+            FFMUtils.C_INT,\n+            FFMUtils.C_POINTER\n@@ -151,3 +151,4 @@\n-        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow(\"kevent\");\n-\n-        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);\n+        public static final MemorySegment ADDR = FFMUtils.findOrThrow(\"kevent\");\n+        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC,\n+                Linker.Option.captureCallState(ERRNO_NAME));\n+        public static final MethodHandle ADAPTED =  CaptureStateUtil.adaptSystemCall(HANDLE, ERRNO_NAME);\n@@ -192,1 +193,0 @@\n-        var mh$ = kevent.HANDLE;\n@@ -194,2 +194,2 @@\n-            if (TRACE_DOWNCALLS) {\n-                traceDowncall(\"kevent\", kq, changelist, nchanges, eventlist, nevents, timeout);\n+            if (FFMUtils.TRACE_DOWNCALLS) {\n+                FFMUtils.traceDowncall(\"kevent\", kq, changelist, nchanges, eventlist, nevents, timeout);\n@@ -197,3 +197,1 @@\n-            return (int)mh$.invokeExact(kq, changelist, nchanges, eventlist, nevents, timeout);\n-        } catch (Error | RuntimeException ex) {\n-           throw ex;\n+            return (int) kevent.ADAPTED.invokeExact(kq, changelist, nchanges, eventlist, nevents, timeout);\n@@ -201,1 +199,1 @@\n-           throw new AssertionError(\"should not reach here\", ex$);\n+            throw new AssertionError(\"should not reach here\", ex$);\n@@ -204,0 +202,1 @@\n+\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/kqueue\/kqueue_h.java","additions":32,"deletions":33,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -49,0 +49,4 @@\n+ * After generation of native bindings, the layouts for the C builtin layouts and other\n+ * variables\/methods not specific to a component area are moved to the {@code FFMUtils} class\n+ * for future reusability.\n+ *\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/kqueue\/package-info.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,4 @@\n+ * After generation of native bindings, the layouts for the C builtin layouts and other\n+ * variables\/methods not specific to a component area are moved to the {@code FFMUtils} class\n+ * for future reusability.\n+ *\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/timespec\/package-info.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.ffi.util.*;\n+\n@@ -31,1 +33,1 @@\n-import java.util.function.*;\n+import java.util.function.Consumer;\n@@ -33,2 +35,2 @@\n-import static java.lang.foreign.MemoryLayout.PathElement.*;\n-import static java.lang.foreign.ValueLayout.*;\n+import static java.lang.foreign.MemoryLayout.PathElement.groupElement;\n+import static java.lang.foreign.ValueLayout.OfLong;\n@@ -52,2 +54,2 @@\n-        timespec_h.C_LONG.withName(\"tv_sec\"),\n-        timespec_h.C_LONG.withName(\"tv_nsec\")\n+        FFMUtils.C_LONG.withName(\"tv_sec\"),\n+        FFMUtils.C_LONG.withName(\"tv_nsec\")\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/timespec\/timespec.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package jdk.internal.ffi.generated.timespec;\n-\n-import java.lang.foreign.*;\n-import java.lang.invoke.*;\n-import java.util.*;\n-import java.util.stream.*;\n-\n-import static java.lang.foreign.ValueLayout.*;\n-\n-@SuppressWarnings(\"restricted\")\n-public class timespec_h$shared {\n-\n-    timespec_h$shared() {\n-        \/\/ Should not be called directly\n-    }\n-\n-    public static final OfBoolean C_BOOL = (OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n-    public static final OfByte C_CHAR =(OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n-    public static final OfShort C_SHORT = (OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n-    public static final OfInt C_INT = (OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n-    public static final OfLong C_LONG_LONG = (OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n-    public static final OfFloat C_FLOAT = (OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n-    public static final OfDouble C_DOUBLE = (OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n-    public static final AddressLayout C_POINTER = ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n-            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n-    public static final OfLong C_LONG = (OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long\");\n-\n-    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean(\"jextract.trace.downcalls\");\n-\n-    static void traceDowncall(String name, Object... args) {\n-         String traceArgs = Arrays.stream(args)\n-                       .map(Object::toString)\n-                       .collect(Collectors.joining(\", \"));\n-         System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n-    }\n-\n-    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n-        try {\n-            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n-        } catch (ReflectiveOperationException ex) {\n-            throw new AssertionError(ex);\n-        }\n-    }\n-\n-    static MemoryLayout align(MemoryLayout layout, long align) {\n-        return switch (layout) {\n-            case PaddingLayout p -> p;\n-            case ValueLayout v -> v.withByteAlignment(align);\n-            case GroupLayout g -> {\n-                MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n-                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n-                yield g instanceof StructLayout ?\n-                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n-            }\n-            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n-        };\n-    }\n-}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/timespec\/timespec_h$shared.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Generated by jextract\n-\n-package jdk.internal.ffi.generated.timespec;\n-\n-import java.lang.foreign.*;\n-\n-public class timespec_h extends timespec_h$shared {\n-\n-    timespec_h() {\n-        \/\/ Should not be called directly\n-    }\n-\n-    static final Arena LIBRARY_ARENA = Arena.ofAuto();\n-\n-    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n-            .or(Linker.nativeLinker().defaultLookup());\n-\n-}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/generated\/timespec\/timespec_h.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.ffi.util;\n+\n+import jdk.internal.ffi.generated.errno.errno_h;\n+\n+import java.io.IOException;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.charset.StandardCharsets;\n+\n+\/\/ Errno utility for macosx platform\n+public final class ErrnoUtils {\n+    private ErrnoUtils() {\n+    }\n+\n+    private static final long ERRNO_STRING_HOLDER_ARRAY_SIZE = 256L;\n+\n+    \/**\n+     * Returns an IOException whose detail message combines the provided context with the\n+     * strerror_r description for the given errno.\n+     * On success, the message includes both the context and the errno string.\n+     * If strerror_r fails, the message only includes the context and errno value.\n+     * @param errno a non-negative POSIX errno value\n+     * @param context additional context to prefix the error message; must not be null\n+     * @return an IOException describing the errno\n+     *\/\n+    public static IOException ioExceptionFromErrno(int errno, String context) {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment buf = arena.allocate(ERRNO_STRING_HOLDER_ARRAY_SIZE);\n+            if (errno_h.strerror_r(errno, buf, ERRNO_STRING_HOLDER_ARRAY_SIZE) == 0) {\n+                String errnoMsg = buf.getString(0, StandardCharsets.UTF_8);\n+                return new IOException(context + \" \" + errnoMsg);\n+            } else {\n+                \/\/ failed to convert errno to string - output errno value\n+                return new IOException(context + \" Errno: \" + errno);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/util\/ErrnoUtils.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.ffi.util;\n+\n+import java.lang.foreign.*;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+@SuppressWarnings(\"restricted\")\n+public final class FFMUtils {\n+\n+    public static final ValueLayout.OfBoolean C_BOOL =\n+            (ValueLayout.OfBoolean) Linker.nativeLinker().canonicalLayouts().get(\"bool\");\n+\n+    public static final ValueLayout.OfByte C_CHAR =\n+            (ValueLayout.OfByte)Linker.nativeLinker().canonicalLayouts().get(\"char\");\n+\n+    public static final ValueLayout.OfShort C_SHORT =\n+            (ValueLayout.OfShort) Linker.nativeLinker().canonicalLayouts().get(\"short\");\n+\n+    public static final ValueLayout.OfInt C_INT =\n+            (ValueLayout.OfInt) Linker.nativeLinker().canonicalLayouts().get(\"int\");\n+\n+    public static final ValueLayout.OfLong C_LONG_LONG =\n+            (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long long\");\n+\n+    public static final ValueLayout.OfFloat C_FLOAT =\n+            (ValueLayout.OfFloat) Linker.nativeLinker().canonicalLayouts().get(\"float\");\n+\n+    public static final ValueLayout.OfDouble C_DOUBLE =\n+            (ValueLayout.OfDouble) Linker.nativeLinker().canonicalLayouts().get(\"double\");\n+\n+    public static final AddressLayout C_POINTER =\n+            ((AddressLayout) Linker.nativeLinker().canonicalLayouts().get(\"void*\"))\n+                    .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));\n+\n+    public static final ValueLayout.OfLong C_LONG =\n+            (ValueLayout.OfLong) Linker.nativeLinker().canonicalLayouts().get(\"long\");\n+\n+    private FFMUtils() {\n+    }\n+\n+    \/**\n+     * Returns a {@code MemorySegment} set to the size of byteSize\n+     *\n+     * @param byteSize the size in bytes to be allocated\n+     * @param byteAlignment the size in bytes for the memory alignment\n+     *\n+     * @throws IllegalArgumentException if the maxByteAlignment of the created\n+     * MemorySegment is less than the provided byteAlignment\n+     *\n+     * @return the newly created {@code MemorySegment}\n+     *\/\n+    public static MemorySegment malloc(long byteSize, long byteAlignment) {\n+        long allocatedMemory = UNSAFE.allocateMemory(byteSize);\n+        MemorySegment result = MemorySegment.ofAddress(allocatedMemory).reinterpret(byteSize);\n+        if (result.maxByteAlignment() < byteAlignment) {\n+            throw new IllegalArgumentException();\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Takes a {@code MemorySegment} and deallocates the memory at that address\n+     * @param memorySegment the {@code MemorySegment} that will be deallocated\n+     *\/\n+    public static void free(MemorySegment memorySegment) {\n+        UNSAFE.freeMemory(memorySegment.address());\n+    }\n+\n+    \/\/ SegmentAllocator that delegates to Unsafe for memory allocation\n+    public static final SegmentAllocator SEGMENT_ALLOCATOR = new SegmentAllocator() {\n+        @Override\n+        public MemorySegment allocate(long byteSize, long byteAlignment) {\n+            return malloc(byteSize, byteAlignment);\n+        }\n+    };\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    \/\/ Variables and methods below are extracted from jextract generated\n+    \/\/ code and used by native bindings on all platforms\n+    public static final boolean TRACE_DOWNCALLS = false;\n+    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()\n+            .or(Linker.nativeLinker().defaultLookup());\n+\n+    public static void traceDowncall(String name, Object... args) {\n+        String traceArgs = Arrays.stream(args)\n+                .map(Object::toString)\n+                .collect(Collectors.joining(\", \"));\n+        System.out.printf(\"%s(%s)\\n\", name, traceArgs);\n+    }\n+\n+    public static MemorySegment findOrThrow(String symbol) {\n+        return SYMBOL_LOOKUP.findOrThrow(symbol);\n+    }\n+\n+    public static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {\n+        try {\n+            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    public static MemoryLayout align(MemoryLayout layout, long align) {\n+        return switch (layout) {\n+            case PaddingLayout p -> p;\n+            case ValueLayout v -> v.withByteAlignment(align);\n+            case GroupLayout g -> {\n+                MemoryLayout[] alignedMembers = g.memberLayouts().stream()\n+                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);\n+                yield g instanceof StructLayout ?\n+                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);\n+            }\n+            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));\n+        };\n+    }\n+}\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/ffi\/util\/FFMUtils.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+import jdk.internal.ffi.generated.kqueue.kevent;\n+import jdk.internal.ffi.generated.kqueue.kqueue_h;\n+import jdk.internal.ffi.generated.timespec.timespec;\n+import jdk.internal.ffi.util.ErrnoUtils;\n+import jdk.internal.ffi.util.FFMUtils;\n+import jdk.internal.foreign.BufferStack;\n+\n@@ -29,1 +36,5 @@\n-import jdk.internal.misc.Unsafe;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import static java.lang.foreign.MemorySegment.NULL;\n+import static jdk.internal.ffi.generated.errno.errno_h.EINTR;\n@@ -35,2 +46,1 @@\n-class KQueue {\n-    private KQueue() { }\n+final class KQueue {\n@@ -38,1 +48,4 @@\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n+    private static final BufferStack TIMESPEC_BUFFER_STACK = BufferStack.of(timespec.layout());\n+    private static final BufferStack KEVENT_BUFFER_STACK = BufferStack.of(kevent.layout());\n+\n+    private KQueue() { }\n@@ -50,7 +63,0 @@\n-    static {\n-        IOUtil.load();\n-    }\n-    private static final int SIZEOF_KQUEUEEVENT    = keventSize();\n-    private static final int OFFSET_IDENT          = identOffset();\n-    private static final int OFFSET_FILTER         = filterOffset();\n-    private static final int OFFSET_FLAGS          = flagsOffset();\n@@ -59,2 +65,2 @@\n-    static final int EVFILT_READ  = -1;\n-    static final int EVFILT_WRITE = -2;\n+    static final int EVFILT_READ  = kqueue_h.EVFILT_READ();\n+    static final int EVFILT_WRITE = kqueue_h.EVFILT_WRITE();\n@@ -63,4 +69,4 @@\n-    static final int EV_ADD     = 0x0001;\n-    static final int EV_DELETE  = 0x0002;\n-    static final int EV_ONESHOT = 0x0010;\n-    static final int EV_CLEAR   = 0x0020;\n+    static final int EV_ADD     = kqueue_h.EV_ADD();\n+    static final int EV_DELETE  = kqueue_h.EV_DELETE();\n+    static final int EV_ONESHOT = kqueue_h.EV_ONESHOT();\n+    static final int EV_CLEAR   = kqueue_h.EV_CLEAR();\n@@ -71,2 +77,2 @@\n-    static long allocatePollArray(int count) {\n-        return unsafe.allocateMemory(count * SIZEOF_KQUEUEEVENT);\n+    static MemorySegment allocatePollArray(int count) {\n+        return kevent.allocateArray(count, FFMUtils.SEGMENT_ALLOCATOR);\n@@ -78,2 +84,2 @@\n-    static void freePollArray(long address) {\n-        unsafe.freeMemory(address);\n+    static void freePollArray(MemorySegment memorySegment){\n+        FFMUtils.free(memorySegment);\n@@ -85,2 +91,2 @@\n-    static long getEvent(long address, int i) {\n-        return address + (SIZEOF_KQUEUEEVENT*i);\n+    static MemorySegment getEvent(MemorySegment memoryHandle, int i) {\n+        return kevent.asSlice(memoryHandle, i);\n@@ -92,2 +98,2 @@\n-    static int getDescriptor(long address) {\n-        return unsafe.getInt(address + OFFSET_IDENT);\n+    static long getDescriptor(MemorySegment memoryHandle) {\n+        return kevent.ident(memoryHandle);\n@@ -96,2 +102,2 @@\n-    static short getFilter(long address) {\n-        return unsafe.getShort(address + OFFSET_FILTER);\n+    static short getFilter(MemorySegment memoryHandle) {\n+        return kevent.filter(memoryHandle);\n@@ -100,2 +106,2 @@\n-    static short getFlags(long address) {\n-        return unsafe.getShort(address + OFFSET_FLAGS);\n+    static short getFlags(MemorySegment memoryHandle) {\n+        return kevent.flags(memoryHandle);\n@@ -106,9 +112,21 @@\n-    private static native int keventSize();\n-\n-    private static native int identOffset();\n-\n-    private static native int filterOffset();\n-\n-    private static native int flagsOffset();\n-\n-    static native int create() throws IOException;\n+    static int register(int kqfd, int fd, int filter, int flags) {\n+        int result;\n+        try (Arena arena = KEVENT_BUFFER_STACK.pushFrame(kevent.layout())) {\n+            MemorySegment keventMS = arena.allocate(kevent.layout());\n+            kevent.ident(keventMS, fd);\n+            kevent.filter(keventMS, (short) filter);\n+            kevent.flags(keventMS, (short) flags);\n+            \/\/ rest default to zero\n+\n+            \/\/ call kqueue and retry if the call returns the\n+            \/\/ interrupted errno value EINTR\n+            do {\n+                result = kqueue_h.kevent(\n+                        kqfd, keventMS, 1, NULL,\n+                        0, NULL);\n+            } while (result == -EINTR());\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+        return result;\n+    }\n@@ -116,1 +134,30 @@\n-    static native int register(int kqfd, int fd, int filter, int flags);\n+    static public int poll(int kqfd, MemorySegment pollAddress, int nevents, long timeout) {\n+        int result;\n+        try (Arena arena = TIMESPEC_BUFFER_STACK.pushFrame(timespec.layout())) {\n+            MemorySegment tsMS = arena.allocate(timespec.layout());\n+            MemorySegment tsp;\n+\n+            if (timeout >= 0) {\n+                timespec.tv_sec(tsMS, timeout \/ 1000);\n+                timespec.tv_nsec(tsMS, (timeout % 1000) * 1000000);\n+                tsp = tsMS;\n+            } else {\n+                tsp = NULL;\n+            }\n+\n+            result = kqueue_h.kevent(\n+                    kqfd, NULL, 0, pollAddress,\n+                    nevents, tsp);\n+            if (result < 0) {\n+                if (result == -EINTR()) {\n+                    return IOStatus.INTERRUPTED;\n+                } else {\n+                    throw ErrnoUtils.ioExceptionFromErrno(-result,\n+                            \"kqueue failed.\");\n+                }\n+            }\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+        return result;\n+    }\n@@ -118,2 +165,7 @@\n-    static native int poll(int kqfd, long pollAddress, int nevents, long timeout)\n-        throws IOException;\n+    static int create() throws IOException {\n+        int res = kqueue_h.kqueue();\n+        if (res < 0) {\n+            throw ErrnoUtils.ioExceptionFromErrno(-res, \"kqueue failed\");\n+        }\n+        return res;\n+    }\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/KQueue.java","additions":94,"deletions":42,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.foreign.MemorySegment;\n+\n@@ -37,1 +39,1 @@\n-    private final long address;\n+    private final MemorySegment pollArray;\n@@ -43,1 +45,1 @@\n-        this.address = KQueue.allocatePollArray(maxEvents);\n+        this.pollArray = KQueue.allocatePollArray(maxEvents);\n@@ -68,1 +70,1 @@\n-        int n = KQueue.poll(kqfd, address, maxEvents, timeout);\n+        int n = KQueue.poll(kqfd, pollArray, maxEvents, timeout);\n@@ -71,2 +73,2 @@\n-            long keventAddress = KQueue.getEvent(address, i);\n-            int fdVal = KQueue.getDescriptor(keventAddress);\n+            MemorySegment eventMS = KQueue.getEvent(pollArray, i);\n+            int fdVal = (int) KQueue.getDescriptor(eventMS);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/KQueuePoller.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -43,3 +44,1 @@\n-final class KQueuePort\n-    extends Port\n-{\n+final class KQueuePort extends Port {\n@@ -53,1 +52,1 @@\n-    private final long address;\n+    private final MemorySegment pollArrayRegions;\n@@ -84,3 +83,1 @@\n-    KQueuePort(AsynchronousChannelProvider provider, ThreadPool pool)\n-        throws IOException\n-    {\n+    KQueuePort(AsynchronousChannelProvider provider, ThreadPool pool) throws IOException {\n@@ -90,1 +87,1 @@\n-        this.address = KQueue.allocatePollArray(MAX_KEVENTS_TO_POLL);\n+        this.pollArrayRegions = KQueue.allocatePollArray(MAX_KEVENTS_TO_POLL);\n@@ -97,1 +94,1 @@\n-            KQueue.freePollArray(address);\n+            KQueue.freePollArray(pollArrayRegions);\n@@ -129,1 +126,1 @@\n-        KQueue.freePollArray(address);\n+        KQueue.freePollArray(pollArrayRegions);\n@@ -200,1 +197,1 @@\n-                        n = KQueue.poll(kqfd, address, MAX_KEVENTS_TO_POLL, -1L);\n+                        n = KQueue.poll(kqfd, pollArrayRegions, MAX_KEVENTS_TO_POLL, -1L);\n@@ -212,2 +209,2 @@\n-                            long keventAddress = KQueue.getEvent(address, n);\n-                            int fd = KQueue.getDescriptor(keventAddress);\n+                            MemorySegment eventMS = KQueue.getEvent(pollArrayRegions, n);\n+                            int fd = (int) KQueue.getDescriptor(eventMS);\n@@ -238,1 +235,1 @@\n-                                int filter = KQueue.getFilter(keventAddress);\n+                                int filter = KQueue.getFilter(eventMS);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/KQueuePort.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.ffi.generated.kqueue.kqueue_h;\n+\n@@ -29,0 +31,1 @@\n+import java.lang.foreign.MemorySegment;\n@@ -57,1 +60,1 @@\n-    private final long pollArrayAddress;\n+    private final MemorySegment pollArrayAddress;\n@@ -81,1 +84,1 @@\n-        this.kqfd = KQueue.create();\n+        this.kqfd = kqueue_h.kqueue();\n@@ -248,2 +251,2 @@\n-            long kevent = KQueue.getEvent(pollArrayAddress, i);\n-            int fd = KQueue.getDescriptor(kevent);\n+            MemorySegment eventMS = KQueue.getEvent(pollArrayAddress, i);\n+            int fd = (int) KQueue.getDescriptor(eventMS);\n@@ -256,1 +259,1 @@\n-                    short filter = KQueue.getFilter(kevent);\n+                    short filter = KQueue.getFilter(eventMS);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/KQueueSelectorImpl.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <strings.h>\n-#include <sys\/types.h>\n-#include <sys\/event.h>\n-#include <sys\/time.h>\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jlong.h\"\n-#include \"nio.h\"\n-#include \"nio_util.h\"\n-\n-#include \"sun_nio_ch_KQueue.h\"\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_keventSize(JNIEnv* env, jclass clazz)\n-{\n-    return sizeof(struct kevent);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_identOffset(JNIEnv* env, jclass clazz)\n-{\n-    return offsetof(struct kevent, ident);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_filterOffset(JNIEnv* env, jclass clazz)\n-{\n-    return offsetof(struct kevent, filter);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_flagsOffset(JNIEnv* env, jclass clazz)\n-{\n-    return offsetof(struct kevent, flags);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_create(JNIEnv *env, jclass clazz) {\n-    int kqfd = kqueue();\n-    if (kqfd < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"kqueue failed\");\n-        return IOS_THROWN;\n-    }\n-    return kqfd;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_register(JNIEnv *env, jclass clazz, jint kqfd,\n-                                jint fd, jint filter, jint flags)\n-\n-{\n-    struct kevent changes[1];\n-    int res;\n-\n-    EV_SET(&changes[0], fd, filter, flags, 0, 0, 0);\n-    RESTARTABLE(kevent(kqfd, &changes[0], 1, NULL, 0, NULL), res);\n-    return (res == -1) ? errno : 0;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_KQueue_poll(JNIEnv *env, jclass clazz, jint kqfd, jlong address,\n-                            jint nevents, jlong timeout)\n-{\n-    struct kevent *events = jlong_to_ptr(address);\n-    int res;\n-    struct timespec ts;\n-    struct timespec *tsp;\n-\n-    if (timeout >= 0) {\n-        ts.tv_sec = timeout \/ 1000;\n-        ts.tv_nsec = (timeout % 1000) * 1000000;\n-        tsp = &ts;\n-    } else {\n-        tsp = NULL;\n-    }\n-\n-    res = kevent(kqfd, NULL, 0, events, nevents, tsp);\n-    if (res < 0) {\n-        if (errno == EINTR) {\n-            return IOS_INTERRUPTED;\n-        } else {\n-            JNU_ThrowIOExceptionWithLastError(env, \"kqueue failed\");\n-            return IOS_THROWN;\n-        }\n-    }\n-    return res;\n-}\n","filename":"src\/java.base\/macosx\/native\/libnio\/ch\/KQueue.c","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"}]}