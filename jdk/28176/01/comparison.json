{"files":[{"patch":"@@ -89,4 +89,0 @@\n-    if (ptr == zpointer::null) {\n-      assert(!ZVerifyOops || !ZHeap::heap()->is_in(uintptr_t(p)) || !ZHeap::heap()->is_old(p), \"No raw null in old\");\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -226,1 +226,0 @@\n-    return;\n@@ -228,19 +227,0 @@\n-\n-  if (!ZGeneration::young()->is_phase_mark_complete()) {\n-    return;\n-  }\n-\n-  if (!page->is_relocatable()) {\n-    return;\n-  }\n-\n-  if (ZRelocate::compute_to_age(age) != ZPageAge::old) {\n-    return;\n-  }\n-\n-  \/\/ If the object is young, we have to still be careful that it isn't racingly\n-  \/\/ about to get promoted to the old generation. That causes issues when null\n-  \/\/ pointers are supposed to be coloured, but the JIT is a bit sloppy and\n-  \/\/ reinitializes memory with raw nulls. We detect this situation and detune\n-  \/\/ rather than relying on the JIT to never be sloppy with redundant initialization.\n-  deoptimize_allocation(thread);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -114,0 +114,10 @@\n+class ZRendezvousHandshakeClosure : public HandshakeClosure {\n+public:\n+  ZRendezvousHandshakeClosure()\n+    : HandshakeClosure(\"ZRendezvous\") {}\n+\n+  void do_thread(Thread* thread) {\n+    \/\/ Does nothing\n+  }\n+};\n+\n@@ -171,5 +181,13 @@\n-  if (is_young()) {\n-    _relocate.flip_age_pages(selector->not_selected_small());\n-    _relocate.flip_age_pages(selector->not_selected_medium());\n-    _relocate.flip_age_pages(selector->not_selected_large());\n-  }\n+  _relocate.flip_age_pages(selector->not_selected_small());\n+  _relocate.flip_age_pages(selector->not_selected_medium());\n+  _relocate.flip_age_pages(selector->not_selected_large());\n+\n+  \/\/ Perform a handshake between flip promotion and running the promotion barrier. This ensures\n+  \/\/ that ZBarrierSet::on_slowpath_allocation_exit() observing a young page that was then racingly\n+  \/\/ flip promoted, will run any stores without barriers to completion before responding to the\n+  \/\/ handshake at the subsequent safepoint poll. This ensures that the flip promotion barriers always\n+  \/\/ run after compiled code missing barriers, but before relocate start.\n+  ZRendezvousHandshakeClosure cl;\n+  Handshake::execute(&cl);\n+\n+  _relocate.barrier_flip_promoted_pages(_relocation_set.flip_promoted_pages());\n@@ -238,1 +256,3 @@\n-  flip_age_pages(&selector);\n+  if (is_young()) {\n+    flip_age_pages(&selector);\n+  }\n@@ -1283,10 +1303,0 @@\n-class ZRendezvousHandshakeClosure : public HandshakeClosure {\n-public:\n-  ZRendezvousHandshakeClosure()\n-    : HandshakeClosure(\"ZRendezvous\") {}\n-\n-  void do_thread(Thread* thread) {\n-    \/\/ Does nothing\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":26,"deletions":16,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1325,1 +1325,1 @@\n-    : ZTask(\"ZPromotePagesTask\"),\n+    : ZTask(\"ZFlipAgePagesTask\"),\n@@ -1340,10 +1340,0 @@\n-      if (promotion) {\n-        \/\/ Before promoting an object (and before relocate start), we must ensure that all\n-        \/\/ contained zpointers are store good. The marking code ensures that for non-null\n-        \/\/ pointers, but null pointers are ignored. This code ensures that even null pointers\n-        \/\/ are made store good, for the promoted objects.\n-        prev_page->object_iterate([&](oop obj) {\n-          ZIterator::basic_oop_iterate_safe(obj, ZBarrier::promote_barrier_on_young_oop_field);\n-        });\n-      }\n-\n@@ -1363,1 +1353,1 @@\n-        \/\/ Defer promoted page registration times the lock is taken\n+        \/\/ Defer promoted page registration\n@@ -1374,0 +1364,26 @@\n+class ZPromoteBarrierTask : public ZTask {\n+private:\n+  ZArrayParallelIterator<ZPage*> _iter;\n+\n+public:\n+  ZPromoteBarrierTask(const ZArray<ZPage*>* pages)\n+    : ZTask(\"ZPromoteBarrierTask\"),\n+      _iter(pages) {}\n+\n+  virtual void work() {\n+    SuspendibleThreadSetJoiner sts_joiner;\n+\n+    for (ZPage* page; _iter.next(&page);) {\n+      \/\/ When promoting an object (and before relocate start), we must ensure that all\n+      \/\/ contained zpointers are store good. The marking code ensures that for non-null\n+      \/\/ pointers, but null pointers are ignored. This code ensures that even null pointers\n+      \/\/ are made store good, for the promoted objects.\n+      page->object_iterate([&](oop obj) {\n+        ZIterator::basic_oop_iterate_safe(obj, ZBarrier::promote_barrier_on_young_oop_field);\n+      });\n+\n+      SuspendibleThreadSet::yield();\n+    }\n+  }\n+};\n+\n@@ -1379,0 +1395,5 @@\n+void ZRelocate::barrier_flip_promoted_pages(const ZArray<ZPage*>* pages) {\n+  ZPromoteBarrierTask promote_barrier_task(pages);\n+  workers()->run(&promote_barrier_task);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+  void barrier_flip_promoted_pages(const ZArray<ZPage*>* pages);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}