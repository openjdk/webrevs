{"files":[{"patch":"@@ -5548,11 +5548,9 @@\n-  \/\/ When the base is not aligned to 8 bytes, then we let\n-  \/\/ the compare loop include the array length, and skip\n-  \/\/ the explicit comparison of length.\n-  bool length_is_8aligned = is_aligned(length_offset, BytesPerWord);\n-  assert(is_aligned(base_offset, BytesPerWord) || is_aligned(length_offset, BytesPerWord),\n-         \"base_offset or length_offset must be 8-byte aligned\");\n-  assert(is_aligned(base_offset, BytesPerWord) || base_offset == length_offset + BytesPerInt,\n-         \"base_offset must be 8-byte aligned or no padding between base and length\");\n-  int start_offset = length_is_8aligned ? length_offset : klass_offset;\n-  assert(is_aligned(start_offset, BytesPerWord), \"start offset must be 8-byte-aligned\");\n-  int extra_length = length_is_8aligned ? base_offset - length_offset : base_offset - klass_offset;\n+  \/\/ When the length offset is not aligned to 8 bytes,\n+  \/\/ then we align it down, this is valid as the new\n+  \/\/ offset will always be the klass which is the same\n+  \/\/ for type arrays.\n+  int start_offset = align_down(length_offset, BytesPerWord);\n+  int extra_length = base_offset - start_offset;\n+  assert(start_offset == length_offset || start_offset == klass_offset, \n+         \"start offset must be 8-byte-aligned or be the klass offset\");\n+  assert(base_offset != start_offset, \"must include the length field\");\n@@ -5593,1 +5591,0 @@\n-    assert(extra_length != 0, \"expect extra length\");\n@@ -5660,1 +5657,0 @@\n-    assert(extra_length != 0, \"expect extra length\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"}]}