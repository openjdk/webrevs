{"files":[{"patch":"@@ -5542,1 +5542,0 @@\n-  Register cnt2 = tmp2;  \/\/ cnt2 only used in array length compare\n@@ -5545,0 +5544,1 @@\n+  int klass_offset  = arrayOopDesc::klass_offset_in_bytes();\n@@ -5551,1 +5551,1 @@\n-  bool is_8aligned = is_aligned(base_offset, BytesPerWord);\n+  bool length_is_8aligned = is_aligned(length_offset, BytesPerWord);\n@@ -5556,1 +5556,1 @@\n-  int start_offset = is_8aligned ? base_offset : length_offset;\n+  int start_offset = length_is_8aligned ? length_offset : klass_offset;\n@@ -5558,1 +5558,2 @@\n-  int extra_length = is_8aligned ? 0 : BytesPerInt \/ elem_size;\n+  int extra_length = length_is_8aligned ? base_offset - length_offset : base_offset - klass_offset;\n+  extra_length = extra_length \/ elem_size; \/\/ We count in elements, not bytes.\n@@ -5592,14 +5593,3 @@\n-    if (is_8aligned) {\n-      \/\/ Check if lenghts are equal. When bases are\n-      \/\/ not aligned, we compare the lengths in the\n-      \/\/ main loop and don't need to compare it\n-      \/\/ explicitely ahead of the loop.\n-      ldrw(cnt2, Address(a2, length_offset));\n-      eorw(tmp5, cnt1, cnt2);\n-      cbnzw(tmp5, DONE);\n-    } else {\n-      assert(extra_length != 0, \"expect extra length\");\n-      \/\/ Increase loop counter by size of length field.\n-      addw(cnt1, cnt1, extra_length);\n-      \/\/ We don't need cnt2 on that path.\n-    }\n+    assert(extra_length != 0, \"expect extra length\");\n+    \/\/ Increase loop counter by size of length field.\n+    addw(cnt1, cnt1, extra_length);\n@@ -5670,9 +5660,4 @@\n-    if (is_8aligned) {\n-      \/\/ cnt2 only needed when doing explicit length-compares.\n-      ldrw(cnt2, Address(a2, length_offset));\n-    } else {\n-      assert(extra_length != 0, \"expect extra length\");\n-      \/\/ Increase loop counter by size of length field.\n-      addw(cnt1, cnt1, extra_length);\n-      \/\/ We don't need cnt2 on that path.\n-    }\n+    assert(extra_length != 0, \"expect extra length\");\n+    \/\/ Increase loop counter by size of length field.\n+    addw(cnt1, cnt1, extra_length);\n+\n@@ -5688,8 +5673,0 @@\n-    if (is_8aligned) {\n-      \/\/ Check if lenghts are equal. When bases are\n-      \/\/ not aligned, we compare the lengths in the\n-      \/\/ main loop and don't need to compare it\n-      \/\/ explicitely ahead of the loop.\n-      cmp(cnt2, cnt1);\n-      br(NE, DONE);\n-    }\n@@ -5728,8 +5705,0 @@\n-    if (is_8aligned) {\n-      \/\/ Check if lenghts are equal. When bases are\n-      \/\/ not aligned, we compare the lengths in the\n-      \/\/ main loop and don't need to compare it\n-      \/\/ explicitely ahead of the loop.\n-      cmp(cnt2, cnt1);\n-      br(NE, DONE);\n-    }\n@@ -5756,13 +5725,0 @@\n-    if (is_8aligned) {\n-      \/\/ Check if lenghts are equal. When bases are\n-      \/\/ not aligned, we compare the lengths in the\n-      \/\/ main loop and don't need to compare it\n-      \/\/ explicitely ahead of the loop.\n-      cmp(cnt2, cnt1);\n-      br(NE, DONE);\n-      \/\/ We only need to check if length == 0 when\n-      \/\/ bases are aligned, because otherwise we'll\n-      \/\/ compare array lengths in 'the loops', and\n-      \/\/ cnt1 can not be 0.\n-      cbz(cnt1, SAME);\n-    }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":56,"binary":false,"changes":68,"status":"modified"}]}