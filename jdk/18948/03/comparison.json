{"files":[{"patch":"@@ -5548,0 +5548,10 @@\n+  \/\/ When the base is not aligned to 8 bytes, then we let\n+  \/\/ the compare loop include the array length, and skip\n+  \/\/ the explicit comparison of length.\n+  bool is_8aligned = is_aligned(base_offset, BytesPerWord);\n+  assert(is_aligned(base_offset, BytesPerWord) || is_aligned(length_offset, BytesPerWord),\n+         \"base_offset or length_offset must be 8-byte aligned\");\n+  assert(is_aligned(base_offset, BytesPerWord) || base_offset == length_offset + BytesPerInt,\n+         \"base_offset must be 8-byte aligned or no padding between base and length\");\n+  int start_offset = is_8aligned ? base_offset : length_offset;\n+  int extra_length = is_8aligned ? 0 : BytesPerInt \/ elem_size;\n@@ -5581,5 +5591,16 @@\n-    ldrw(cnt2, Address(a2, length_offset));\n-    eorw(tmp5, cnt1, cnt2);\n-    cbnzw(tmp5, DONE);\n-    lea(a1, Address(a1, base_offset));\n-    lea(a2, Address(a2, base_offset));\n+    if (extra_length != 0) {\n+      \/\/ Increase loop counter by size of length field.\n+      addw(cnt1, cnt1, extra_length);\n+      \/\/ We don't need cnt2 on that path.\n+    }\n+    if (is_8aligned) {\n+      \/\/ Check if lenghts are equal. When bases are\n+      \/\/ not aligned, we compare the lengths in the\n+      \/\/ main loop and don't need to compare it\n+      \/\/ explicitely ahead of the loop.\n+      ldrw(cnt2, Address(a2, length_offset));\n+      eorw(tmp5, cnt1, cnt2);\n+      cbnzw(tmp5, DONE);\n+    }\n+    lea(a1, Address(a1, start_offset));\n+    lea(a2, Address(a2, start_offset));\n@@ -5648,1 +5669,9 @@\n-    ldrw(cnt2, Address(a2, length_offset));\n+    if (is_8aligned) {\n+      \/\/ cnt2 only needed when doing explicit length-compares.\n+      ldrw(cnt2, Address(a2, length_offset));\n+    }\n+    if (extra_length != 0) {\n+      \/\/ Increase loop counter by size of length field.\n+      addw(cnt1, cnt1, extra_length);\n+      \/\/ We don't need cnt2 on that path.\n+    }\n@@ -5653,1 +5682,1 @@\n-    ldr(tmp3, Address(pre(a1, base_offset)));\n+    ldr(tmp3, Address(pre(a1, start_offset)));\n@@ -5656,1 +5685,1 @@\n-    ldr(tmp4, Address(pre(a2, base_offset)));\n+    ldr(tmp4, Address(pre(a2, start_offset)));\n@@ -5658,2 +5687,8 @@\n-    cmp(cnt2, cnt1);\n-    br(NE, DONE);\n+    if (is_8aligned) {\n+      \/\/ Check if lenghts are equal. When bases are\n+      \/\/ not aligned, we compare the lengths in the\n+      \/\/ main loop and don't need to compare it\n+      \/\/ explicitely ahead of the loop.\n+      cmp(cnt2, cnt1);\n+      br(NE, DONE);\n+    }\n@@ -5691,3 +5726,9 @@\n-    ldr(tmp4, Address(pre(a2, base_offset)));\n-    cmp(cnt2, cnt1);\n-    br(NE, DONE);\n+    ldr(tmp4, Address(pre(a2, start_offset)));\n+    if (is_8aligned) {\n+      \/\/ Check if lenghts are equal. When bases are\n+      \/\/ not aligned, we compare the lengths in the\n+      \/\/ main loop and don't need to compare it\n+      \/\/ explicitely ahead of the loop.\n+      cmp(cnt2, cnt1);\n+      br(NE, DONE);\n+    }\n@@ -5714,3 +5755,13 @@\n-    cmp(cnt2, cnt1);\n-    br(NE, DONE);\n-    cbz(cnt1, SAME);\n+    if (is_8aligned) {\n+      \/\/ Check if lenghts are equal. When bases are\n+      \/\/ not aligned, we compare the lengths in the\n+      \/\/ main loop and don't need to compare it\n+      \/\/ explicitely ahead of the loop.\n+      cmp(cnt2, cnt1);\n+      br(NE, DONE);\n+      \/\/ We only need to check if length == 0 when\n+      \/\/ bases are aligned, because otherwise we'll\n+      \/\/ compare array lengths in 'the loops', and\n+      \/\/ cnt1 can not be 0.\n+      cbz(cnt1, SAME);\n+    }\n@@ -5718,2 +5769,2 @@\n-    ldr(tmp3, Address(a1, base_offset));\n-    ldr(tmp4, Address(a2, base_offset));\n+    ldr(tmp3, Address(pre(a1, start_offset)));\n+    ldr(tmp4, Address(pre(a2, start_offset)));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":69,"deletions":18,"binary":false,"changes":87,"status":"modified"}]}