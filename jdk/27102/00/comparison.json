{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -631,0 +631,1 @@\n+            result.appendLine(\"@SuppressWarnings(\\\"lossy-conversions\\\")\");\n","filename":"make\/jdk\/src\/classes\/build\/tools\/intpoly\/FieldGen.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+        LONG(\"long\", \"long\", null),\n","filename":"make\/langtools\/tools\/propertiesparser\/parser\/MessageType.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4000,0 +4000,1 @@\n+            chk.checkOutOfRangeShift(tree.rhs.pos(), operator, operand);\n@@ -4090,0 +4091,1 @@\n+            chk.checkOutOfRangeShift(tree.rhs.pos(), operator, right);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4044,0 +4044,40 @@\n+    \/**\n+     *  Check for bit shifts using an out-of-range bit count.\n+     *  @param pos           Position for error reporting.\n+     *  @param operator      The operator for the expression\n+     *  @param operand       The right hand operand for the expression\n+     *\/\n+    void checkOutOfRangeShift(final DiagnosticPosition pos, Symbol operator, Type operand) {\n+        if (operand.constValue() instanceof Number shiftAmount) {\n+            Type targetType;\n+            int maximumShift;\n+            switch (((OperatorSymbol)operator).opcode) {\n+            case ByteCodes.ishl:\n+            case ByteCodes.ishr:\n+            case ByteCodes.iushr:\n+            case ByteCodes.ishll:\n+            case ByteCodes.ishrl:\n+            case ByteCodes.iushrl:\n+                targetType = syms.intType;\n+                maximumShift = 32;\n+                break;\n+            case ByteCodes.lshl:\n+            case ByteCodes.lshr:\n+            case ByteCodes.lushr:\n+            case ByteCodes.lshll:\n+            case ByteCodes.lshrl:\n+            case ByteCodes.lushrl:\n+                targetType = syms.longType;\n+                maximumShift = 64;\n+                break;\n+            default:\n+                return;\n+            }\n+            long specifiedShift = shiftAmount.longValue();\n+            int actualShift = (int)specifiedShift & (maximumShift - 1);\n+            if (specifiedShift != actualShift) {\n+                log.warning(pos, LintWarnings.BitShiftOutOfRange(targetType, specifiedShift, actualShift));\n+            }\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2453,0 +2453,5 @@\n+# 0: type, 1: long, 2: number\n+# lint: lossy-conversions\n+compiler.warn.bit.shift.out.of.range=\\\n+    shifting {0} by {1} bits is equivalent to shifting by {2} bit(s)\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-    Warn about possible lossy conversions in compound assignment.\n+    Warn about possible lossy conversions in compound assignment and bit shift operations.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n- * <tr><th scope=\"row\">{@code lossy-conversions}    <td>possible lossy conversions in compound assignment\n+ * <tr><th scope=\"row\">{@code lossy-conversions}    <td>possible lossy conversions in compound assignment or bit shift\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -605,1 +605,1 @@\n-        in compound assignment.\n+        in compound assignment and bit shift operations.\n","filename":"src\/jdk.compiler\/share\/man\/javac.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -510,1 +510,1 @@\n-        int sign = (diff >> -1);\n+        int sign = (diff >> 31);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractSpecies.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -487,1 +487,1 @@\n-        int sign = (diff >> -1);\n+        int sign = (diff >> 31);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractVector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.bit.shift.out.of.range\n+\/\/ options: -Xlint:lossy-conversions\n+\n+class BitShiftOutOfRange {\n+    int m(int a) {\n+        return a << 32;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/BitShiftOutOfRange.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 5038439\n+ * @summary Verify warnings about bit shifts using out-of-range shift amounts\n+ * @compile\/ref=ShiftOutOfRange.out -XDrawDiagnostics -Xlint:lossy-conversions ShiftOutOfRange.java\n+ *\/\n+\n+public class ShiftOutOfRange {\n+\n+    public void shiftInt() {\n+        int a = 123;\n+\n+        \/\/ These should generate warnings\n+        a = a << (byte)-1;\n+        a = a >> (char)-1;\n+        a = a >>> (short)-1;\n+        a <<= -1;\n+        a >>= -1L;          \/\/ also generates \"implicit cast from long to int in compound assignment is possibly lossy\"\n+        a >>>= (byte)-1;\n+\n+        \/\/ These should not generate warnings\n+        a = a << (byte)0;\n+        a = a >> (char)7;\n+        a = a >>> (short)13;\n+        a <<= 17;\n+        a >>= (long)23;     \/\/ also generates \"implicit cast from long to int in compound assignment is possibly lossy\"\n+        a >>>= (byte)31;\n+        a <<= hashCode();\n+        a >>= hashCode();\n+        a >>>= hashCode();\n+\n+        \/\/ These should generate warnings\n+        a = a << (byte)32;\n+        a = a >> (char)32;\n+        a = a >>> (short)32;\n+        a <<= 32;\n+        a >>= (long)32;     \/\/ also generates \"implicit cast from long to int in compound assignment is possibly lossy\"\n+        a >>>= (byte)32;\n+    }\n+\n+    public void shiftLong() {\n+        long a = 123;\n+\n+        \/\/ These should generate warnings\n+        a = a << (byte)-1;\n+        a = a >> (char)-1;\n+        a = a >>> (short)-1;\n+        a <<= -1;\n+        a >>= -1L;\n+        a >>>= (byte)-1;\n+\n+        \/\/ These should not generate warnings\n+        a = a << (byte)0;\n+        a = a >> (char)15;\n+        a = a >>> (short)25;\n+        a <<= 34;\n+        a >>= (long)47;\n+        a >>>= (byte)63;\n+        a <<= hashCode();\n+        a >>= hashCode();\n+        a >>>= hashCode();\n+\n+        \/\/ These should generate warnings\n+        a = a << (byte)64;\n+        a = a >> (char)64;\n+        a = a >>> (short)64;\n+        a <<= 64;\n+        a >>= (long)64;\n+        a >>>= (byte)64;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/ShiftOutOfRange.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+ShiftOutOfRange.java:14:18: compiler.warn.bit.shift.out.of.range: int, -1, 31\n+ShiftOutOfRange.java:15:18: compiler.warn.bit.shift.out.of.range: int, 65535, 31\n+ShiftOutOfRange.java:16:19: compiler.warn.bit.shift.out.of.range: int, -1, 31\n+ShiftOutOfRange.java:17:15: compiler.warn.bit.shift.out.of.range: int, -1, 31\n+ShiftOutOfRange.java:18:15: compiler.warn.possible.loss.of.precision: long, int\n+ShiftOutOfRange.java:18:15: compiler.warn.bit.shift.out.of.range: int, -1, 31\n+ShiftOutOfRange.java:19:16: compiler.warn.bit.shift.out.of.range: int, -1, 31\n+ShiftOutOfRange.java:26:15: compiler.warn.possible.loss.of.precision: long, int\n+ShiftOutOfRange.java:33:18: compiler.warn.bit.shift.out.of.range: int, 32, 0\n+ShiftOutOfRange.java:34:18: compiler.warn.bit.shift.out.of.range: int, 32, 0\n+ShiftOutOfRange.java:35:19: compiler.warn.bit.shift.out.of.range: int, 32, 0\n+ShiftOutOfRange.java:36:15: compiler.warn.bit.shift.out.of.range: int, 32, 0\n+ShiftOutOfRange.java:37:15: compiler.warn.possible.loss.of.precision: long, int\n+ShiftOutOfRange.java:37:15: compiler.warn.bit.shift.out.of.range: int, 32, 0\n+ShiftOutOfRange.java:38:16: compiler.warn.bit.shift.out.of.range: int, 32, 0\n+ShiftOutOfRange.java:45:18: compiler.warn.bit.shift.out.of.range: long, -1, 63\n+ShiftOutOfRange.java:46:18: compiler.warn.bit.shift.out.of.range: long, 65535, 63\n+ShiftOutOfRange.java:47:19: compiler.warn.bit.shift.out.of.range: long, -1, 63\n+ShiftOutOfRange.java:48:15: compiler.warn.bit.shift.out.of.range: long, -1, 63\n+ShiftOutOfRange.java:49:15: compiler.warn.bit.shift.out.of.range: long, -1, 63\n+ShiftOutOfRange.java:50:16: compiler.warn.bit.shift.out.of.range: long, -1, 63\n+ShiftOutOfRange.java:64:18: compiler.warn.bit.shift.out.of.range: long, 64, 0\n+ShiftOutOfRange.java:65:18: compiler.warn.bit.shift.out.of.range: long, 64, 0\n+ShiftOutOfRange.java:66:19: compiler.warn.bit.shift.out.of.range: long, 64, 0\n+ShiftOutOfRange.java:67:15: compiler.warn.bit.shift.out.of.range: long, 64, 0\n+ShiftOutOfRange.java:68:15: compiler.warn.bit.shift.out.of.range: long, 64, 0\n+ShiftOutOfRange.java:69:16: compiler.warn.bit.shift.out.of.range: long, 64, 0\n+27 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/ShiftOutOfRange.out","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,1 @@\n+    @SuppressWarnings(\"lossy-conversions\")\n@@ -70,0 +71,1 @@\n+    @SuppressWarnings(\"lossy-conversions\")\n@@ -80,0 +82,1 @@\n+    @SuppressWarnings(\"lossy-conversions\")\n@@ -90,0 +93,1 @@\n+    @SuppressWarnings(\"lossy-conversions\")\n@@ -100,0 +104,1 @@\n+    @SuppressWarnings(\"lossy-conversions\")\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/Rotation.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}