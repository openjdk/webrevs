{"files":[{"patch":"@@ -231,1 +231,1 @@\n-      forwardee = cast_to_oop(m.decode_pointer());\n+      forwardee = obj->forwardee();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-    obj = cast_to_oop(m.decode_pointer());\n+    obj = obj->forwardee();\n@@ -630,1 +630,1 @@\n-  oop forward_ptr = old->forward_to_atomic(old, m, memory_order_relaxed);\n+  oop forward_ptr = old->forward_to_self_atomic(m, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -328,1 +328,1 @@\n-  if (obj->forward_to_atomic(obj, obj_mark) == nullptr) {\n+  if (obj->forward_to_self_atomic(obj_mark) == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    return cast_to_oop(m.decode_pointer());\n+    return o->forwardee(m);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -903,1 +903,1 @@\n-  old->forward_to(old);\n+  old->forward_to_self();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-\/\/             hash:25 ------------>| age:4  unused_gap:1  lock:2 (normal object)\n+\/\/             hash:25 ------------>| age:4  self-fwd:1  lock:2 (normal object)\n@@ -44,1 +44,1 @@\n-\/\/  unused:25 hash:31 -->| unused_gap:1  age:4  unused_gap:1  lock:2 (normal object)\n+\/\/  unused:25 hash:31 -->| unused_gap:1  age:4  self-fwd:1  lock:2 (normal object)\n@@ -106,2 +106,2 @@\n-  static const int first_unused_gap_bits          = 1;\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - first_unused_gap_bits;\n+  static const int self_fwd_bits                  = 1;\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - self_fwd_bits;\n@@ -109,1 +109,1 @@\n-  static const int second_unused_gap_bits         = LP64_ONLY(1) NOT_LP64(0);\n+  static const int unused_gap_bits                = LP64_ONLY(1) NOT_LP64(0);\n@@ -112,2 +112,3 @@\n-  static const int age_shift                      = lock_bits + first_unused_gap_bits;\n-  static const int hash_shift                     = age_shift + age_bits + second_unused_gap_bits;\n+  static const int self_fwd_shift                 = lock_shift + lock_bits;\n+  static const int age_shift                      = self_fwd_shift + self_fwd_bits;\n+  static const int hash_shift                     = age_shift + age_bits + unused_gap_bits;\n@@ -117,0 +118,2 @@\n+  static const uintptr_t self_fwd_mask            = right_n_bits(self_fwd_bits);\n+  static const uintptr_t self_fwd_mask_in_place   = self_fwd_mask << self_fwd_shift;\n@@ -146,0 +149,3 @@\n+  bool is_forwarded() const {\n+    return is_marked();\n+  }\n@@ -263,0 +269,8 @@\n+\n+  inline bool self_forwarded() const {\n+    return mask_bits(value(), self_fwd_mask_in_place) != 0;\n+  }\n+\n+  inline markWord set_self_forwarded() const {\n+    return markWord(value() | self_fwd_mask_in_place | marked_value);\n+  }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -67,1 +67,3 @@\n- public:\n+  inline oop cas_set_forwardee(markWord new_mark, markWord old_mark, atomic_memory_order order);\n+\n+public:\n@@ -263,0 +265,1 @@\n+  inline void forward_to_self();\n@@ -269,0 +272,1 @@\n+  inline oop forward_to_self_atomic(markWord compare, atomic_memory_order order = memory_order_conservative);\n@@ -271,0 +275,1 @@\n+  inline oop forwardee(markWord header) const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -266,3 +266,1 @@\n-  \/\/ The extra heap check is needed since the obj might be locked, in which case the\n-  \/\/ mark would point to a stack location and have the sentinel bit cleared\n-  return mark().is_marked();\n+  return mark().is_forwarded();\n@@ -278,4 +276,6 @@\n-oop oopDesc::forward_to_atomic(oop p, markWord compare, atomic_memory_order order) {\n-  markWord m = markWord::encode_pointer_as_mark(p);\n-  assert(m.decode_pointer() == p, \"encoding must be reversible\");\n-  markWord old_mark = cas_set_mark(m, compare, order);\n+void oopDesc::forward_to_self() {\n+  set_mark(markWord::prototype().set_self_forwarded());\n+}\n+\n+oop oopDesc::cas_set_forwardee(markWord new_mark, markWord compare, atomic_memory_order order) {\n+  markWord old_mark = cas_set_mark(new_mark, compare, order);\n@@ -285,1 +285,23 @@\n-    return cast_to_oop(old_mark.decode_pointer());\n+    assert(old_mark.is_forwarded(), \"must be forwarded here\");\n+    return forwardee(old_mark);\n+  }\n+}\n+\n+oop oopDesc::forward_to_atomic(oop p, markWord compare, atomic_memory_order order) {\n+  markWord m = markWord::encode_pointer_as_mark(p);\n+  assert(forwardee(m) == p, \"encoding must be reversible\");\n+  return cas_set_forwardee(m, compare, order);\n+}\n+\n+oop oopDesc::forward_to_self_atomic(markWord compare, atomic_memory_order order) {\n+  markWord new_mark = markWord::prototype().set_self_forwarded();\n+  assert(forwardee(new_mark) == cast_to_oop(this), \"encoding must be reversible\");\n+  return cas_set_forwardee(new_mark, compare, order);\n+}\n+\n+oop oopDesc::forwardee(markWord mark) const {\n+  assert(mark.is_forwarded(), \"only decode when actually forwarded\");\n+  if (mark.self_forwarded()) {\n+    return cast_to_oop(this);\n+  } else {\n+    return cast_to_oop(mark.decode_pointer());\n@@ -294,1 +316,1 @@\n-  return cast_to_oop(mark().decode_pointer());\n+  return forwardee(mark());\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":31,"deletions":9,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -32,1 +32,4 @@\n-  oopDesc _oop;\n+  \/\/ Align at least to 8 bytes, otherwise the lowest address bit\n+  \/\/ could be interpreted as 'self-forwarded' when encoded as\n+  \/\/ forwardee in the mark-word.\n+  alignas(BytesPerLong) oopDesc _oop;\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}