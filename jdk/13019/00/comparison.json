{"files":[{"patch":"@@ -133,0 +133,10 @@\n+ * @apiNote\n+ * Resources allocated by the {@code HttpClient} may be reclaimed early\n+ * by {@linkplain #close() closing} the client.\n+ * An {@code HttpClient} instance typically manages its own pools of\n+ * connections, which it can typically reuse when another request is made to\n+ * the same origin server using the same protocol version and security,\n+ * through the same client. In the JDK implementation, connection pools\n+ * are not shared between {@code HttpClient} instances. Creating a new client\n+ * for each operation, though possible, will prevent reusing such connections.\n+ *\n@@ -135,1 +145,1 @@\n-public abstract class HttpClient {\n+public abstract class HttpClient implements AutoCloseable {\n@@ -733,0 +743,116 @@\n+\n+    \/**\n+     * Initiates an orderly shutdown in which previously submitted\n+     * operations are completed, but no new request will be accepted.\n+     * Invocation has no additional effect if already shut down.\n+     *\n+     * <p>This method does not wait for previously submitted request\n+     * to complete execution.  Use {@link #awaitTermination awaitTermination}\n+     * to do that.\n+     *\n+     * @implSpec\n+     * The default implementation of this method does nothing. Subclasses should\n+     * override this method to implement the appropriate behavior.\n+     *\n+     * @since 21\n+     *\/\n+    public void shutdown() { }\n+\n+    \/**\n+     * Blocks until all operations have completed execution after a shutdown\n+     * request, or the timeout occurs, or the current thread is\n+     * interrupted, whichever happens first.\n+     *\n+     * @implSpec\n+     * The default implementation of this method does nothing and returns true.\n+     * Subclasses should override this method to implement the proper behavior.\n+     *\n+     * @param duration the maximum time to wait\n+     * @return {@code true} if this client terminated and\n+     *         {@code false} if the timeout elapsed before termination\n+     * @throws InterruptedException if interrupted while waiting\n+     *\n+     * @since 21\n+     *\/\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if all operations have completed following shut down.\n+     * Note that {@code isTerminated} is never {@code true} unless\n+     * either {@code shutdown} or {@code shutdownNow} was called first.\n+     *\n+     * @implSpec\n+     * The default implementation of this method does nothing and returns false.\n+     * Subclasses should override this method to implement the proper behavior.\n+     *\n+     * @return {@code true} if all tasks have completed following shut down\n+     *\n+     * @since 21\n+     *\/\n+    public boolean isTerminated() {\n+        return false;\n+    }\n+\n+    \/**\n+     * This method is called if the thread waiting on {@link #close()} is\n+     * interrupted. An implementation of this method may attempt to\n+     * interrupt operations that are actively running.\n+     * The behavior of actively running operations when interrupted\n+     * is undefined. In particular, there is no guarantee that\n+     * interrupted operations will terminate, or that code waiting\n+     * on these operations will ever be notified.\n+     *\n+     * @implSpec\n+     * The default implementation of this simply calls {@link #shutdown()}.\n+     * Subclasses should override this method to implement the appropriate\n+     * behavior.\n+     *\n+     * @since 21\n+     *\/\n+    public void shutdownNow() {\n+        shutdown();\n+    }\n+\n+    \/**\n+     * Initiates an orderly shutdown in which previously submitted operation are\n+     * executed, but no new request will be accepted. This method waits until all\n+     * operations have completed execution and the client has terminated.\n+     *\n+     * <p> If interrupted while waiting, this method may attempt to stop all\n+     * operations by calling {@link #shutdownNow()}. It then continues to wait\n+     * until all actively executing operations have completed.\n+     * The interrupt status will be re-asserted before this method returns.\n+     *\n+     * <p> If already terminated, invoking this method has no effect.\n+     *\n+     * @implSpec\n+     * The default implementation invokes {@code shutdown()} and waits for tasks\n+     * to complete execution with {@code awaitTermination}.\n+     *\n+     * @since 21\n+     *\/\n+    @Override\n+    public void close() {\n+        boolean terminated = isTerminated();\n+        if (!terminated) {\n+            shutdown();\n+            boolean interrupted = false;\n+            while (!terminated) {\n+                try {\n+                    terminated = awaitTermination(Duration.ofDays(1L));\n+                } catch (InterruptedException e) {\n+                    if (!interrupted) {\n+                        interrupted = true;\n+                        shutdownNow();\n+                        if (isTerminated()) break;\n+                    }\n+                }\n+            }\n+            if (interrupted) {\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpClient.java","additions":127,"deletions":1,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,0 +170,25 @@\n+    @Override\n+    public boolean isTerminated() {\n+        return impl.isTerminated();\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        impl.shutdown();\n+    }\n+\n+    @Override\n+    public void shutdownNow() {\n+        impl.shutdownNow();\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        return impl.awaitTermination(duration);\n+    }\n+\n+    @Override\n+    public void close() {\n+        impl.close();\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientFacade.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n-import java.nio.channels.SocketChannel;\n@@ -407,0 +406,1 @@\n+    private volatile boolean shutdownRequested;\n@@ -609,0 +609,22 @@\n+    @Override\n+    public void shutdown() {\n+        shutdownRequested = true;\n+        selmgr.wakeupSelector();\n+    }\n+\n+    @Override\n+    public void shutdownNow() {\n+        shutdown();\n+        selmgr.abort(new IOException(\"shutdownNow\"));\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        return selmgr.join(duration);\n+    }\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return isStarted.get() && !isAlive.get();\n+    }\n+\n@@ -632,3 +654,5 @@\n-        if (openedConnections.add(plainHttpConnection)) {\n-            pendingTCPConnectionCount.incrementAndGet();\n-        }\n+        if (!finished()) {\n+            if (openedConnections.add(plainHttpConnection)) {\n+                pendingTCPConnectionCount.incrementAndGet();\n+            }\n+        } else closeConnection(plainHttpConnection);\n@@ -668,1 +692,1 @@\n-        if (count == 0 && facadeRef.refersTo(null)) {\n+        if (count == 0 && (facadeRef.refersTo(null) || shutdownRequested)) {\n@@ -690,1 +714,1 @@\n-        if (count == 0 && facadeRef.refersTo(null)) {\n+        if (count == 0 && (facadeRef.refersTo(null) || shutdownRequested)) {\n@@ -712,1 +736,1 @@\n-        if (count == 0 && facadeRef.refersTo(null)) {\n+        if (count == 0 && (facadeRef.refersTo(null) || shutdownRequested)) {\n@@ -827,1 +851,12 @@\n-    boolean isReferenced() {\n+    boolean finished() {\n+        if (referenceCount() > 0) return false;\n+        if (shutdownRequested) {\n+            synchronized (this) {\n+                \/\/ avoid race with sendAsync\n+                if (referenceCount() == 0) return true;\n+            }\n+        }\n+        return !isReferenced();\n+    }\n+\n+    private boolean isReferenced() {\n@@ -958,0 +993,4 @@\n+        if (shutdownRequested) {\n+            return MinimalFuture.failedFuture(new IOException(\"closed\"));\n+        }\n+\n@@ -975,1 +1014,6 @@\n-        requestReference();\n+        synchronized (this) {\n+            if (shutdownRequested) {\n+                return MinimalFuture.failedFuture(new IOException(\"closed\"));\n+            }\n+            requestReference();\n+        }\n@@ -1264,1 +1308,1 @@\n-                    if (!owner.isReferenced()) {\n+                    if (owner.finished()) {\n@@ -1267,1 +1311,1 @@\n-                                \"HttpClient no longer referenced. Exiting...\");\n+                                \"HttpClient finished. Exiting...\");\n@@ -1308,1 +1352,1 @@\n-                        if (!owner.isReferenced()) {\n+                        if (owner.finished()) {\n@@ -1311,1 +1355,1 @@\n-                                    \"HttpClient no longer referenced. Exiting...\");\n+                                    \"HttpClient finished. Exiting...\");\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":58,"deletions":14,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -143,3 +143,4 @@\n-                client().connectionOpened(PlainHttpConnection.this);\n-                \/\/ complete async since the event runs on the SelectorManager thread\n-                cf.completeAsync(() -> ConnectState.SUCCESS, client().theExecutor());\n+                if (connectionOpened()) {\n+                    \/\/ complete async since the event runs on the SelectorManager thread\n+                    cf.completeAsync(() -> ConnectState.SUCCESS, client().theExecutor());\n+                } else throw new ConnectException(\"Connection closed\");\n@@ -216,2 +217,3 @@\n-                client().connectionOpened(this);\n-                cf.complete(ConnectState.SUCCESS);\n+                if (connectionOpened()) {\n+                    cf.complete(ConnectState.SUCCESS);\n+                } else throw new ConnectException(\"connection closed\");\n@@ -239,0 +241,12 @@\n+    boolean connectionOpened() {\n+        boolean closed = this.closed;\n+        if (closed) return false;\n+        synchronized (this) {\n+            closed = this.closed;\n+            if (!closed) {\n+                client().connectionOpened(this);\n+            }\n+        }\n+        return !closed;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,452 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267140\n+ * @summary Test HttpClient::shutdownNow. Any running operation will\n+ *          be aborted and the client should eventually exit.\n+ *          This test tests shutdownNow, awaitTermination, and\n+ *          isTerminated.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       AsyncShutdownNow\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.err;\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class AsyncShutdownNow implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"AsyncShutdownNow message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    static Throwable getCause(Throwable t) {\n+        while (t instanceof CompletionException || t instanceof ExecutionException) {\n+            t = t.getCause();\n+        }\n+        return t;\n+    }\n+\n+    static String readBody(InputStream in) {\n+        try {\n+            return new String(in.readAllBytes(), StandardCharsets.UTF_8);\n+        } catch (IOException io) {\n+            throw new UncheckedIOException(io);\n+        }\n+    }\n+\n+    static boolean hasExpectedMessage(IOException io) {\n+        String message = io.getMessage();\n+        if (message == null) return false;\n+        \/\/ exception from sendAsync()\n+        if (message.equals(\"closed\")) return true;\n+        \/\/ exception from selmgr.abort\n+        if (message.equals(\"shutdownNow\")) return true;\n+        return false;\n+    }\n+\n+    static void checkCause(String what, Throwable cause) {\n+        Throwable t = cause;\n+        Throwable accepted = null;\n+        while (t != null) {\n+            out.println(what + \": checking \" + t);\n+            if (t instanceof  IOException io && hasExpectedMessage(io)) {\n+                out.println(what + \": Got expected message in cause: \" + io);\n+                return;\n+            } else if (t instanceof ClosedChannelException) {\n+                out.println(what + \": Accepting ClosedChannelException as a valid cause: \" + t);\n+                accepted = t;\n+            }\n+            t = t.getCause();\n+        }\n+        if (accepted != null) {\n+            out.println(what + \": Didn't find expected shutdownNow\/closed, \" +\n+                    \"but accepting \" + accepted.getClass().getSimpleName()\n+                    + \" as a valid cause: \" + accepted);\n+            return;\n+        }\n+        throw new AssertionError(what + \": Unexpected exception: \" + cause, cause);\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        Throwable failed = null;\n+        try {\n+            List<CompletableFuture<String>> bodies = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                final int si = i;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(AsyncShutdownNow::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down client now%n\", i, sleep);\n+                    client.shutdownNow();\n+                }\n+                var cf = bodyCF.exceptionally((t) -> {\n+                    Throwable cause = getCause(t);\n+                    out.println(si + \": Got expected exception: \" + cause);\n+                    if (UncheckedIOException.class.isAssignableFrom(cause.getClass())) {\n+                        if (cause.getCause() != null) {\n+                            out.println(si + \": Got expected exception: \" + cause);\n+                            cause = cause.getCause();\n+                        }\n+                    }\n+                    checkCause(String.valueOf(si), cause);\n+                    return null;\n+                });\n+                bodies.add(cf);\n+            }\n+            CompletableFuture.allOf(bodies.toArray(new CompletableFuture<?>[0])).get();\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(client, readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(client.isTerminated());\n+    }\n+\n+    static Throwable cleanup(HttpClient client, ExecutorService readerService, Throwable failed) {\n+        try {\n+            try {\n+                if (client.awaitTermination(Duration.ofMillis(2000))) {\n+                    out.println(\"Client terminated within expected delay\");\n+                } else {\n+                    AssertionError error = new AssertionError(\"client still running\");\n+                    if (failed != null) {\n+                        failed.addSuppressed(error);\n+                    } else failed = error;\n+                }\n+            } finally {\n+                readerService.shutdown();\n+                readerService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (InterruptedException ie) {\n+            if (failed != null) {\n+                failed.addSuppressed(ie);\n+            } else failed = ie;\n+        }\n+        return failed;\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        out.printf(\"will shutdown client in step %d%n\", step);\n+        Throwable failed = null;\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                final int si = i;\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(AsyncShutdownNow::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        })\n+                        .thenApply((s) -> {\n+                            out.println(si + \":  Got body: \" + s);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down client now%n\", i, sleep);\n+                    client.shutdownNow();\n+                }\n+                bodyCF.handle((r, t) -> {\n+                    if (t != null) {\n+                        try {\n+                            Throwable cause = getCause(t);\n+                            out.println(si + \": Got expected exception: \" + cause);\n+                            if (UncheckedIOException.class.isAssignableFrom(cause.getClass())) {\n+                                if (cause.getCause() != null) {\n+                                    out.println(si + \": Got expected exception: \" + cause);\n+                                    cause = cause.getCause();\n+                                }\n+                            }\n+                            checkCause(String.valueOf(si), cause);\n+                        } catch (Throwable ase) {\n+                            return CompletableFuture.failedFuture(ase);\n+                        }\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return CompletableFuture.completedFuture(r);\n+                    }\n+                }).thenCompose((c) -> c).get();\n+            }\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(client, readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(client.isTerminated());\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.checkShutdown(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(\"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(\"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                for (int i=0; i<bytes.length; i++) {\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/AsyncShutdownNow.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"added"},{"patch":"@@ -0,0 +1,345 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267140\n+ * @summary Test for HttpClient::close. Any running operation should\n+ *          succeed and the client should eventually exit.\n+ *          This test tests close, awaitTermination, and\n+ *          isTerminated.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       HttpClientClose\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.err;\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class HttpClientClose implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"HttpClientClose message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    static String readBody(InputStream in) {\n+        try {\n+            return new String(in.readAllBytes(), StandardCharsets.UTF_8);\n+        } catch (IOException io) {\n+            throw new UncheckedIOException(io);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        Throwable failed = null;\n+        try (HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build()) {\n+            TRACKER.track(client);\n+\n+            List<CompletableFuture<String>> bodies = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                final int si = i;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(HttpClientClose::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                var cf = bodyCF;\n+                bodies.add(cf);\n+            }\n+            CompletableFuture.allOf(bodies.toArray(new CompletableFuture<?>[0])).get();\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+    }\n+\n+    static Throwable cleanup(ExecutorService readerService, Throwable failed) {\n+        try {\n+            readerService.shutdown();\n+            readerService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException ie) {\n+            if (failed != null) {\n+                failed.addSuppressed(ie);\n+            } else failed = ie;\n+        }\n+        return failed;\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        Throwable failed = null;\n+        HttpClient toCheck = null;\n+        try (HttpClient client = toCheck = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build()) {\n+            TRACKER.track(client);\n+\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                final int si = i;\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(HttpClientClose::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        })\n+                        .thenApply((s) -> {\n+                            out.println(si + \":  Got body: \" + s);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                bodyCF.get();\n+            }\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(toCheck.isTerminated());\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.checkShutdown(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(\"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(\"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                for (int i=0; i<bytes.length; i++) {\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientClose.java","additions":345,"deletions":0,"binary":false,"changes":345,"status":"added"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267140\n+ * @summary Test for HttpClient::shutdown. Any running operation should\n+ *          succeed but new operations will be rejected. The client\n+ *          should eventually exit.\n+ *          This test tests shutdown, awaitTermination, and\n+ *          isTerminated.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       HttpClientShutdown\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.err;\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class HttpClientShutdown implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"HttpClientShutdown message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+    static volatile long start = System.nanoTime();\n+\n+    static final String now() {\n+        var duration = Duration.ofNanos(System.nanoTime() - start);\n+        var secs = duration.toSeconds();\n+        var ms = duration.toMillisPart();\n+        if (secs > 0) {\n+            return String.format(\"[%ss %sms] \", secs, ms);\n+        } else {\n+            return String.format(\"[%sms] \", ms);\n+        }\n+    }\n+\n+    static Throwable getCause(Throwable t) {\n+        while (t instanceof CompletionException || t instanceof ExecutionException) {\n+            t = t.getCause();\n+        }\n+        return t;\n+    }\n+\n+    static String readBody(InputStream in) {\n+        try {\n+            return new String(in.readAllBytes(), StandardCharsets.UTF_8);\n+        } catch (IOException io) {\n+            throw new UncheckedIOException(io);\n+        }\n+    }\n+\n+    static boolean hasExpectedMessage(IOException io) {\n+        String message = io.getMessage();\n+        if (message == null) return false;\n+        \/\/ exception from sendAsync()\n+        if (message.equals(\"closed\")) return true;\n+        return false;\n+    }\n+\n+    static void checkCause(String what, Throwable cause) {\n+        Throwable t = cause;\n+        Throwable accepted = null;\n+        while (t != null) {\n+            out.println(now() + what + \": checking \" + t);\n+            if (t instanceof  IOException io && hasExpectedMessage(io)) {\n+                out.println(now() + what + \": Got expected message in cause: \" + io);\n+                return;\n+            } else if (t instanceof ClosedChannelException) {\n+                out.println(now() + what + \": Accepting ClosedChannelException as a valid cause: \" + t);\n+                accepted = t;\n+            }\n+            t = t.getCause();\n+        }\n+        if (accepted != null) {\n+            out.println(now() + what + \": Didn't find expected closed, \" +\n+                    \"but accepting \" + accepted.getClass().getSimpleName()\n+                    + \" as a valid cause: \" + accepted);\n+            return;\n+        }\n+        throw new AssertionError(what + \": Unexpected exception: \" + cause, cause);\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- %sstarting (%s) ----%n\", now(), uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        Throwable failed = null;\n+        try {\n+            List<CompletableFuture<String>> bodies = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(now() + \"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                final int si = i;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(now() + si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(HttpClientShutdown::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            out.println(now() + si +\": Got expected message: \" + s);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(now() + \"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i < step) {\n+                    bodies.add(bodyCF);\n+                    continue;\n+                }\n+                if (i == step) {\n+                    out.printf(now() + \"%d: shutting down client%n\", i, sleep);\n+                    client.shutdown();\n+                }\n+                var cf = bodyCF.exceptionally((t) -> {\n+                    Throwable cause = getCause(t);\n+                    if (UncheckedIOException.class.isInstance(cause)) {\n+                        if (cause.getCause() != null) {\n+                            cause = cause.getCause();\n+                        }\n+                    }\n+                    out.println(now() + si + \": Got expected exception: \" + cause);\n+                    checkCause(String.valueOf(si), cause);\n+                    return null;\n+                });\n+                bodies.add(cf);\n+            }\n+            CompletableFuture.allOf(bodies.toArray(new CompletableFuture<?>[0])).get();\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(client, readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(client.isTerminated());\n+    }\n+\n+    static Throwable cleanup(HttpClient client, ExecutorService readerService, Throwable failed) {\n+        try {\n+            try {\n+                out.println(now() + \"awaiting termination...\");\n+                if (client.awaitTermination(Duration.ofMillis(2000))) {\n+                    out.println(now() + \"Client terminated within expected delay\");\n+                } else {\n+                    out.println(now() + \"Client still running!\");\n+                    AssertionError error = new AssertionError(\"client still running\");\n+                    if (failed != null) {\n+                        failed.addSuppressed(error);\n+                    } else failed = error;\n+                }\n+            } finally {\n+                readerService.shutdown();\n+                readerService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (InterruptedException ie) {\n+            if (failed != null) {\n+                failed.addSuppressed(ie);\n+            } else failed = ie;\n+        }\n+        return failed;\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- %sstarting (%s) ----%n\", now(), uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        out.printf(now() + \"will shutdown client in step %d%n\", step);\n+        Throwable failed = null;\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(now() + \"Iteration %d request: %s%n\", i, request.uri());\n+                final int si = i;\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(now() + si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(HttpClientShutdown::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        })\n+                        .thenApply((s) -> {\n+                            out.println(now() + si + \":  Got body: \" + s);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(now() + \"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i < step) {\n+                    bodyCF.get();\n+                    continue;\n+                }\n+                if (i == step) {\n+                    out.printf(now() + \"%d: shutting down client%n\", i, sleep);\n+                    client.shutdown();\n+                }\n+                bodyCF.handle((r, t) -> {\n+                    if (t != null) {\n+                        try {\n+                            Throwable cause = getCause(t);\n+                            if (UncheckedIOException.class.isInstance(cause)) {\n+                                if (cause.getCause() != null) {\n+                                    cause = cause.getCause();\n+                                }\n+                            }\n+                            out.println(now() + si + \": Got expected exception: \" + cause);\n+                            checkCause(String.valueOf(si), cause);\n+                        } catch (Throwable ase) {\n+                            return CompletableFuture.failedFuture(ase);\n+                        }\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return CompletableFuture.completedFuture(r);\n+                    }\n+                }).thenCompose((c) -> c).get();\n+            }\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(client, readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(client.isTerminated());\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+        start = System.nanoTime();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.checkShutdown(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(now() + \"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(now() + \"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            long previous;\n+            long begin = previous = System.nanoTime();\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                out.println(now() + \"Start sending body for: \" + t.getRequestURI());\n+                for (int i=0; i<bytes.length; i++) {\n+                    long now = System.nanoTime();\n+                    long sincePrevious =  Duration.ofNanos(now - previous).toMillis();\n+                    long sinceBegin = Duration.ofNanos(now - begin).toMillis();\n+                    if (i > 0 && (sincePrevious > 25)) {\n+                        previous = now;\n+                        out.printf(\"%s%s\/%s bytes sent in %sms for: %s%n\", now(),\n+                                i, bytes.length, sinceBegin, t.getRequestURI());\n+                    }\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+                out.println(now() + \"Body sent (\" + bytes.length + \" bytes) for: \" + t.getRequestURI());\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientShutdown.java","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"},{"patch":"@@ -0,0 +1,385 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267140\n+ * @summary Test HttpClient::shutdownNow. Any running operation will\n+ *          be aborted and the client should eventually exit.\n+ *          This test tests shutdownNow, awaitTermination, and\n+ *          isTerminated.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       ShutdownNow\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.channels.ClosedChannelException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class ShutdownNow implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"ShutdownNow message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    static Throwable getCause(Throwable t) {\n+        while (t instanceof CompletionException || t instanceof ExecutionException) {\n+            t = t.getCause();\n+        }\n+        return t;\n+    }\n+\n+    static boolean hasExpectedMessage(IOException io) {\n+        String message = io.getMessage();\n+        if (message == null) return false;\n+        \/\/ exception from sendAsync()\n+        if (message.equals(\"closed\")) return true;\n+        \/\/ exception from selmgr.abort\n+        if (message.equals(\"shutdownNow\")) return true;\n+        return false;\n+    }\n+\n+    static void checkCause(String what, Throwable cause) {\n+        Throwable t = cause;\n+        Throwable accepted = null;\n+        while (t != null) {\n+            out.println(what + \": checking \" + t);\n+            if (t instanceof  IOException io && hasExpectedMessage(io)) {\n+                out.println(what + \": Got expected message in cause: \" + io);\n+                return;\n+            } else if (t instanceof ClosedChannelException) {\n+                out.println(what + \": Accepting ClosedChannelException as a valid cause: \" + t);\n+                accepted = t;\n+            }\n+            t = t.getCause();\n+        }\n+        if (accepted != null) {\n+            out.println(what + \": Didn't find expected shutdownNow\/closed, \" +\n+                    \"but accepting \" + accepted.getClass().getSimpleName()\n+                    + \" as a valid cause: \" + accepted);\n+            return;\n+        }\n+        throw new AssertionError(what + \": Unexpected exception: \" + cause, cause);\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        try {\n+            List<CompletableFuture<HttpResponse<String>>> responses = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<String>> responseCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofString());\n+\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down client now%n\", i, sleep);\n+                    client.shutdownNow();\n+                }\n+                final int si = i;\n+                var cf = responseCF.thenApply((response) -> {\n+                    out.println(si + \":  Got response: \" + response);\n+                    out.println(si + \":  Got body Path: \" + response.body());\n+                    assertEquals(response.statusCode(), 200);\n+                    assertEquals(response.body(), MESSAGE);\n+                    return response;\n+                }).exceptionally((t) -> {\n+                    Throwable cause = getCause(t);\n+                    out.println(si + \": Got expected exception: \" + cause);\n+                    checkCause(String.valueOf(si), cause);\n+                    return null;\n+                });\n+                responses.add(cf);\n+            }\n+            CompletableFuture.allOf(responses.toArray(new CompletableFuture<?>[0])).get();\n+        } finally {\n+            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+                out.println(\"Client terminated within expected delay\");\n+            } else {\n+                throw new AssertionError(\"client still running\");\n+            }\n+            assertTrue(client.isTerminated());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        out.printf(\"will shutdown client in step %d%n\", step);\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                            .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                            .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<String>> responseCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofString());\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down client now%n\", i, sleep);\n+                    client.shutdownNow();\n+                }\n+                final int si = i;\n+                responseCF.thenApply((response) -> {\n+                    out.println(si + \":  Got response: \" + response);\n+                    out.println(si + \":  Got body Path: \" + response.body());\n+                    assertEquals(response.statusCode(), 200);\n+                    assertEquals(response.body(), MESSAGE);\n+                    return response;\n+                }).handle((r,t) -> {\n+                    if (t != null) {\n+                        try {\n+                            Throwable cause = getCause(t);\n+                            out.println(si + \": Got expected exception: \" + cause);\n+                            checkCause(String.valueOf(si), cause);\n+                         } catch (Throwable ase) {\n+                            return CompletableFuture.failedFuture(ase);\n+                        }\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return CompletableFuture.completedFuture(r);\n+                    }\n+                }).thenCompose((c) -> c).get();\n+            }\n+       } finally {\n+            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+                out.println(\"Client terminated within expected delay\");\n+            } else {\n+                throw new AssertionError(\"client still running\");\n+            }\n+            assertTrue(client.isTerminated());\n+        }\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.check(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(\"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(\"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                for (int i=0; i<bytes.length; i++) {\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/ShutdownNow.java","additions":385,"deletions":0,"binary":false,"changes":385,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,26 @@\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return client.isTerminated();\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        client.shutdown();\n+    }\n+\n+    @Override\n+    public void shutdownNow() {\n+        client.shutdownNow();\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        return client.awaitTermination(duration);\n+    }\n+\n+    @Override\n+    public void close() {\n+        client.close();\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/offline\/DelegatingHttpClient.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.time.Duration;\n@@ -34,0 +35,2 @@\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n@@ -43,0 +46,3 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n@@ -56,0 +62,2 @@\n+    private final ConcurrentLinkedQueue<CompletableFuture<?>> responses = new ConcurrentLinkedQueue();\n+    volatile boolean shutdownRequested;\n@@ -184,0 +192,7 @@\n+        CompletableFuture<HttpResponse<T>> cf = new CompletableFuture<>();\n+        synchronized (this) {\n+            if (shutdownRequested) {\n+                return CompletableFuture.failedFuture(new IOException(\"closed\"));\n+            }\n+            responses.add(cf);\n+        }\n@@ -204,1 +219,0 @@\n-        CompletableFuture<HttpResponse<T>> cf = new CompletableFuture<>();\n@@ -206,0 +220,1 @@\n+                try {\n@@ -217,0 +232,2 @@\n+                } finally {\n+                    responses.remove(cf);\n@@ -218,0 +235,1 @@\n+            }\n@@ -243,0 +261,49 @@\n+\n+    @Override\n+    public boolean isTerminated() {\n+        synchronized (this) {\n+            if (!shutdownRequested) return false;\n+            return responses.isEmpty();\n+        }\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        shutdownRequested = true;\n+    }\n+\n+    @Override\n+    public void shutdownNow() {\n+        shutdown();\n+        CompletableFuture[] futures;\n+        synchronized (this) {\n+            if (responses.isEmpty()) return ;\n+            futures = responses.toArray(CompletableFuture[]::new);\n+            responses.clear();\n+        }\n+        for (var op : futures) {\n+            op.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        CompletableFuture[] futures;\n+        synchronized (this) {\n+            if (responses.isEmpty()) return true;\n+            futures = responses.toArray(CompletableFuture[]::new);\n+        }\n+        var all = CompletableFuture.allOf(futures);\n+        Duration max = Duration.ofMillis(Long.MAX_VALUE);\n+        long timeout = duration.compareTo(max) > 0 ? Long.MAX_VALUE : duration.toMillis();\n+        try {\n+            all.exceptionally((t) -> null).get(timeout, TimeUnit.MILLISECONDS);\n+        } catch (TimeoutException te) {\n+            return false;\n+        } catch (InterruptedException ie) {\n+            throw ie;\n+        } catch (ExecutionException failed) {\n+            return true;\n+        }\n+        return true;\n+    }\n","filename":"test\/jdk\/java\/net\/httpclient\/offline\/FixedResponseHttpClient.java","additions":69,"deletions":2,"binary":false,"changes":71,"status":"modified"}]}