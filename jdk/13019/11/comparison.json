{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.net.http.HttpResponse.BodyHandlers;\n@@ -41,0 +42,1 @@\n+import java.util.Objects;\n@@ -48,0 +50,2 @@\n+import java.util.concurrent.Flow.Subscription;\n+\n@@ -64,1 +68,5 @@\n- * sharing, for all requests sent through it.\n+ * sharing, for all requests sent through it. An {@code HttpClient} instance\n+ * typically manages its own pools of connections, which it may then reuse\n+ * as and when necessary. Connection pools are  typically not shared between\n+ * {@code HttpClient} instances. Creating a new client for each operation,\n+ * though possible, will usually prevent reusing such connections.\n@@ -133,0 +141,18 @@\n+ * @apiNote\n+ * <p id=\"closing\"> Resources allocated by the {@code HttpClient} may be\n+ * reclaimed early by {@linkplain #close() closing} the client.\n+ * The JDK built-in implementation of the {@code HttpClient} overrides\n+ * {@link #close()}, {@link #shutdown()}, {@link #shutdownNow()},\n+ * {@link #awaitTermination(Duration)}, and {@link #isTerminated()} to\n+ * provide a best effort implementation. Failing to close, cancel, or\n+ * read returned streams to exhaustion, such as streams provided when using\n+ * {@link BodyHandlers#ofInputStream()}, {@link BodyHandlers#ofLines()}, or\n+ * {@link BodyHandlers#ofPublisher()}, may prevent requests submitted\n+ * before an {@linkplain #shutdown() orderly shutdown}\n+ * to run to completion. Likewise, failing to\n+ * {@linkplain Subscription#request(long) request data} or {@linkplain\n+ * Subscription#cancel() cancel subscriptions} from a custom {@linkplain\n+ * java.net.http.HttpResponse.BodySubscriber BodySubscriber} may stop\n+ * delivery of data and {@linkplain #awaitTermination(Duration) stall an\n+ * orderly shutdown}.\n+ *\n@@ -135,1 +161,1 @@\n-public abstract class HttpClient {\n+public abstract class HttpClient implements AutoCloseable {\n@@ -602,1 +628,2 @@\n-     * @throws IOException if an I\/O error occurs when sending or receiving\n+     * @throws IOException if an I\/O error occurs when sending or receiving, or\n+     *         the client has {@linkplain ##closing shut down}\n@@ -649,1 +676,2 @@\n-     * <li>{@link IOException} - if an I\/O error occurs when sending or receiving<\/li>\n+     * <li>{@link IOException} - if an I\/O error occurs when sending or receiving,\n+     *      or the client has {@linkplain ##closing shut down}.<\/li>\n@@ -733,0 +761,143 @@\n+\n+    \/**\n+     * Initiates an orderly shutdown in which  requests previously\n+     * submitted with {@code send} or {@code sendAsync}\n+     * are run to completion, but no new request will be accepted.\n+     * Running a request to completion may involve running several\n+     * operations in the background, including {@linkplain ##closing\n+     * waiting for responses to be delivered}, which will all have to\n+     * run to completion until the request is considered completed.\n+     *\n+     * Invocation has no additional effect if already shut down.\n+     *\n+     * <p>This method does not wait for previously submitted request\n+     * to complete execution.  Use {@link #awaitTermination(Duration)\n+     * awaitTermination} or {@link #close() close} to do that.\n+     *\n+     * @implSpec\n+     * The default implementation of this method does nothing. Subclasses should\n+     * override this method to implement the appropriate behavior.\n+     * See the API Note on {@linkplain ##closing closing}.\n+     *\n+     * @since 21\n+     *\/\n+    public void shutdown() { }\n+\n+    \/**\n+     * Blocks until all operations have completed execution after a shutdown\n+     * request, or the {@code duration} elapses, or the current thread is\n+     * {@linkplain Thread#interrupt() interrupted}, whichever happens first.\n+     * Operations are any tasks required to run a request previously\n+     * submitted with {@code send} or {@code sendAsync} to completion.\n+     *\n+     * <p> This method does not wait if the duration to wait is less than or\n+     * equal to zero. In this case, the method just tests if the thread has\n+     * terminated.\n+     *\n+     * @implSpec\n+     * The default implementation of this method does nothing and returns true.\n+     * Subclasses should override this method to implement the proper behavior.\n+     * See the API Note on {@linkplain ##closing closing}.\n+     *\n+     * @param duration the maximum time to wait\n+     * @return {@code true} if this client terminated and\n+     *         {@code false} if the timeout elapsed before termination\n+     * @throws InterruptedException if interrupted while waiting\n+     *\n+     * @since 21\n+     *\/\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        Objects.requireNonNull(duration);\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if all operations have completed following\n+     * a shutdown.\n+     * Operations are any tasks required to run a request previously\n+     * submitted with {@code send} or {@code sendAsync} to completion.\n+     * <p> Note that {@code isTerminated} is never {@code true} unless\n+     * either {@code shutdown} or {@code shutdownNow} was called first.\n+     *\n+     * @implSpec\n+     * The default implementation of this method does nothing and returns false.\n+     * Subclasses should override this method to implement the proper behavior.\n+     * See the API Note on {@linkplain ##closing closing}.\n+     *\n+     * @return {@code true} if all tasks have completed following a shutdown\n+     *\n+     * @since 21\n+     *\/\n+    public boolean isTerminated() {\n+        return false;\n+    }\n+\n+    \/**\n+     * This method attempts to initiate an immediate shutdown.\n+     * An implementation of this method may attempt to\n+     * interrupt operations that are actively running.\n+     * Operations are any tasks required to run a request previously\n+     * submitted with {@code send} or {@code sendAsync} to completion.\n+     * The behavior of actively running operations when interrupted\n+     * is undefined. In particular, there is no guarantee that\n+     * interrupted operations will terminate, or that code waiting\n+     * on these operations will ever be notified.\n+     *\n+     * @implSpec\n+     * The default implementation of this method simply calls {@link #shutdown()}.\n+     * Subclasses should override this method to implement the appropriate\n+     * behavior. See the API Note on {@linkplain ##closing closing}.\n+     *\n+     * @since 21\n+     *\/\n+    public void shutdownNow() {\n+        shutdown();\n+    }\n+\n+    \/**\n+     * Initiates an orderly shutdown in which  requests previously\n+     * submitted to {@code send} or {@code sendAsync}\n+     * are run to completion, but no new request will be accepted.\n+     * Running a request to completion may involve running several\n+     * operations in the background, including {@linkplain ##closing\n+     * waiting for responses to be delivered}.\n+     * This method waits until all operations have completed execution\n+     * and the client has terminated.\n+     *\n+     * <p> If interrupted while waiting, this method may attempt to stop all\n+     * operations by calling {@link #shutdownNow()}. It then continues to wait\n+     * until all actively executing operations have completed.\n+     * The interrupt status will be re-asserted before this method returns.\n+     *\n+     * <p> If already terminated, invoking this method has no effect.\n+     *\n+     * @implSpec\n+     * The default implementation invokes {@code shutdown()} and waits for tasks\n+     * to complete execution with {@code awaitTermination}. See the API Note on\n+     * {@linkplain ##closing closing}.\n+     *\n+     * @since 21\n+     *\/\n+    @Override\n+    public void close() {\n+        boolean terminated = isTerminated();\n+        if (!terminated) {\n+            shutdown();\n+            boolean interrupted = false;\n+            while (!terminated) {\n+                try {\n+                    terminated = awaitTermination(Duration.ofDays(1L));\n+                } catch (InterruptedException e) {\n+                    if (!interrupted) {\n+                        interrupted = true;\n+                        shutdownNow();\n+                        if (isTerminated()) break;\n+                    }\n+                }\n+            }\n+            if (interrupted) {\n+                Thread.currentThread().interrupt();\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpClient.java","additions":175,"deletions":4,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,0 +170,25 @@\n+    @Override\n+    public boolean isTerminated() {\n+        return impl.isTerminated();\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        impl.shutdown();\n+    }\n+\n+    @Override\n+    public void shutdownNow() {\n+        impl.shutdownNow();\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        return impl.awaitTermination(duration);\n+    }\n+\n+    @Override\n+    public void close() {\n+        impl.close();\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientFacade.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n-import java.nio.channels.SocketChannel;\n@@ -407,0 +406,1 @@\n+    private volatile boolean shutdownRequested;\n@@ -609,0 +609,23 @@\n+    @Override\n+    public void shutdown() {\n+        shutdownRequested = true;\n+        selmgr.wakeupSelector();\n+    }\n+\n+    @Override\n+    public void shutdownNow() {\n+        shutdown();\n+        selmgr.abort(new IOException(\"shutdownNow\"));\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        \/\/ Implicit NPE will be thrown if duration is null\n+        return selmgr.join(duration);\n+    }\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return isStarted.get() && !isAlive.get();\n+    }\n+\n@@ -632,3 +655,5 @@\n-        if (openedConnections.add(plainHttpConnection)) {\n-            pendingTCPConnectionCount.incrementAndGet();\n-        }\n+        if (!finished()) {\n+            if (openedConnections.add(plainHttpConnection)) {\n+                pendingTCPConnectionCount.incrementAndGet();\n+            }\n+        } else closeConnection(plainHttpConnection);\n@@ -668,1 +693,1 @@\n-        if (count == 0 && facadeRef.refersTo(null)) {\n+        if (count == 0 && (facadeRef.refersTo(null) || shutdownRequested)) {\n@@ -690,1 +715,1 @@\n-        if (count == 0 && facadeRef.refersTo(null)) {\n+        if (count == 0 && (facadeRef.refersTo(null) || shutdownRequested)) {\n@@ -712,1 +737,1 @@\n-        if (count == 0 && facadeRef.refersTo(null)) {\n+        if (count == 0 && (facadeRef.refersTo(null) || shutdownRequested)) {\n@@ -827,1 +852,12 @@\n-    boolean isReferenced() {\n+    boolean finished() {\n+        if (referenceCount() > 0) return false;\n+        if (shutdownRequested) {\n+            synchronized (this) {\n+                \/\/ avoid race with sendAsync\n+                if (referenceCount() == 0) return true;\n+            }\n+        }\n+        return !isReferenced();\n+    }\n+\n+    private boolean isReferenced() {\n@@ -958,0 +994,4 @@\n+        if (shutdownRequested) {\n+            return MinimalFuture.failedFuture(new IOException(\"closed\"));\n+        }\n+\n@@ -975,1 +1015,6 @@\n-        requestReference();\n+        synchronized (this) {\n+            if (shutdownRequested) {\n+                return MinimalFuture.failedFuture(new IOException(\"closed\"));\n+            }\n+            requestReference();\n+        }\n@@ -1264,1 +1309,1 @@\n-                    if (!owner.isReferenced()) {\n+                    if (owner.finished()) {\n@@ -1267,1 +1312,1 @@\n-                                \"HttpClient no longer referenced. Exiting...\");\n+                                \"HttpClient finished. Exiting...\");\n@@ -1308,1 +1353,1 @@\n-                        if (!owner.isReferenced()) {\n+                        if (owner.finished()) {\n@@ -1311,1 +1356,1 @@\n-                                    \"HttpClient no longer referenced. Exiting...\");\n+                                    \"HttpClient finished. Exiting...\");\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":59,"deletions":14,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -143,3 +143,4 @@\n-                client().connectionOpened(PlainHttpConnection.this);\n-                \/\/ complete async since the event runs on the SelectorManager thread\n-                cf.completeAsync(() -> ConnectState.SUCCESS, client().theExecutor());\n+                if (connectionOpened()) {\n+                    \/\/ complete async since the event runs on the SelectorManager thread\n+                    cf.completeAsync(() -> ConnectState.SUCCESS, client().theExecutor());\n+                } else throw new ConnectException(\"Connection closed\");\n@@ -216,2 +217,3 @@\n-                client().connectionOpened(this);\n-                cf.complete(ConnectState.SUCCESS);\n+                if (connectionOpened()) {\n+                    cf.complete(ConnectState.SUCCESS);\n+                } else throw new ConnectException(\"connection closed\");\n@@ -239,0 +241,12 @@\n+    boolean connectionOpened() {\n+        boolean closed = this.closed;\n+        if (closed) return false;\n+        synchronized (this) {\n+            closed = this.closed;\n+            if (!closed) {\n+                client().connectionOpened(this);\n+            }\n+        }\n+        return !closed;\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,452 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267140\n+ * @summary Test HttpClient::shutdownNow. Any running operation will\n+ *          be aborted and the client should eventually exit.\n+ *          This test tests shutdownNow, awaitTermination, and\n+ *          isTerminated.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       AsyncShutdownNow\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.err;\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class AsyncShutdownNow implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"AsyncShutdownNow message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    static Throwable getCause(Throwable t) {\n+        while (t instanceof CompletionException || t instanceof ExecutionException) {\n+            t = t.getCause();\n+        }\n+        return t;\n+    }\n+\n+    static String readBody(InputStream in) {\n+        try {\n+            return new String(in.readAllBytes(), StandardCharsets.UTF_8);\n+        } catch (IOException io) {\n+            throw new UncheckedIOException(io);\n+        }\n+    }\n+\n+    static boolean hasExpectedMessage(IOException io) {\n+        String message = io.getMessage();\n+        if (message == null) return false;\n+        \/\/ exception from sendAsync()\n+        if (message.equals(\"closed\")) return true;\n+        \/\/ exception from selmgr.abort\n+        if (message.equals(\"shutdownNow\")) return true;\n+        return false;\n+    }\n+\n+    static void checkCause(String what, Throwable cause) {\n+        Throwable t = cause;\n+        Throwable accepted = null;\n+        while (t != null) {\n+            out.println(what + \": checking \" + t);\n+            if (t instanceof IOException io && hasExpectedMessage(io)) {\n+                out.println(what + \": Got expected message in cause: \" + io);\n+                return;\n+            } else if (t instanceof ClosedChannelException) {\n+                out.println(what + \": Accepting ClosedChannelException as a valid cause: \" + t);\n+                accepted = t;\n+            }\n+            t = t.getCause();\n+        }\n+        if (accepted != null) {\n+            out.println(what + \": Didn't find expected shutdownNow\/closed, \" +\n+                    \"but accepting \" + accepted.getClass().getSimpleName()\n+                    + \" as a valid cause: \" + accepted);\n+            return;\n+        }\n+        throw new AssertionError(what + \": Unexpected exception: \" + cause, cause);\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        Throwable failed = null;\n+        try {\n+            List<CompletableFuture<String>> bodies = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                final int si = i;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(AsyncShutdownNow::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down client now%n\", i, sleep);\n+                    client.shutdownNow();\n+                }\n+                var cf = bodyCF.exceptionally((t) -> {\n+                    Throwable cause = getCause(t);\n+                    out.println(si + \": Got expected exception: \" + cause);\n+                    if (UncheckedIOException.class.isAssignableFrom(cause.getClass())) {\n+                        if (cause.getCause() != null) {\n+                            out.println(si + \": Got expected exception: \" + cause);\n+                            cause = cause.getCause();\n+                        }\n+                    }\n+                    checkCause(String.valueOf(si), cause);\n+                    return null;\n+                });\n+                bodies.add(cf);\n+            }\n+            CompletableFuture.allOf(bodies.toArray(new CompletableFuture<?>[0])).get();\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(client, readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(client.isTerminated());\n+    }\n+\n+    static Throwable cleanup(HttpClient client, ExecutorService readerService, Throwable failed) {\n+        try {\n+            try {\n+                if (client.awaitTermination(Duration.ofMillis(2000))) {\n+                    out.println(\"Client terminated within expected delay\");\n+                } else {\n+                    AssertionError error = new AssertionError(\"client still running\");\n+                    if (failed != null) {\n+                        failed.addSuppressed(error);\n+                    } else failed = error;\n+                }\n+            } finally {\n+                readerService.shutdown();\n+                readerService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (InterruptedException ie) {\n+            if (failed != null) {\n+                failed.addSuppressed(ie);\n+            } else failed = ie;\n+        }\n+        return failed;\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        out.printf(\"will shutdown client in step %d%n\", step);\n+        Throwable failed = null;\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                final int si = i;\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(AsyncShutdownNow::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        })\n+                        .thenApply((s) -> {\n+                            out.println(si + \":  Got body: \" + s);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down client now%n\", i, sleep);\n+                    client.shutdownNow();\n+                }\n+                bodyCF.handle((r, t) -> {\n+                    if (t != null) {\n+                        try {\n+                            Throwable cause = getCause(t);\n+                            out.println(si + \": Got expected exception: \" + cause);\n+                            if (UncheckedIOException.class.isAssignableFrom(cause.getClass())) {\n+                                if (cause.getCause() != null) {\n+                                    out.println(si + \": Got expected exception: \" + cause);\n+                                    cause = cause.getCause();\n+                                }\n+                            }\n+                            checkCause(String.valueOf(si), cause);\n+                        } catch (Throwable ase) {\n+                            return CompletableFuture.failedFuture(ase);\n+                        }\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return CompletableFuture.completedFuture(r);\n+                    }\n+                }).thenCompose((c) -> c).get();\n+            }\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(client, readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(client.isTerminated());\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.checkShutdown(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(\"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(\"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                for (int i=0; i<bytes.length; i++) {\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/AsyncShutdownNow.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import java.util.Objects;\n@@ -50,0 +51,2 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n@@ -75,1 +78,1 @@\n-        for (HttpClient client : clients) {\n+        for (HttpClient c : clients) {\n@@ -77,9 +80,11 @@\n-            assertFalse(client.authenticator().isPresent());\n-            assertFalse(client.cookieHandler().isPresent());\n-            assertFalse(client.connectTimeout().isPresent());\n-            assertFalse(client.executor().isPresent());\n-            assertFalse(client.proxy().isPresent());\n-            assertTrue(client.sslParameters() != null);\n-            assertTrue(client.followRedirects().equals(HttpClient.Redirect.NEVER));\n-            assertTrue(client.sslContext() == SSLContext.getDefault());\n-            assertTrue(client.version().equals(HttpClient.Version.HTTP_2));\n+            try (var client = c) {\n+                assertFalse(client.authenticator().isPresent());\n+                assertFalse(client.cookieHandler().isPresent());\n+                assertFalse(client.connectTimeout().isPresent());\n+                assertFalse(client.executor().isPresent());\n+                assertFalse(client.proxy().isPresent());\n+                assertTrue(client.sslParameters() != null);\n+                assertTrue(client.followRedirects().equals(HttpClient.Redirect.NEVER));\n+                assertTrue(client.sslContext() == SSLContext.getDefault());\n+                assertTrue(client.version().equals(HttpClient.Version.HTTP_2));\n+            }\n@@ -105,0 +110,20 @@\n+    static class Closer implements AutoCloseable {\n+        final HttpClient.Builder builder;\n+        HttpClient client;\n+        Closer(HttpClient.Builder builder) {\n+            this.builder = Objects.requireNonNull(builder);\n+        }\n+        HttpClient build() {\n+            if (client != null) client.close();\n+            return client = builder.build();\n+        }\n+        @Override\n+        public void close() {\n+            if (client != null) client.close();\n+        }\n+    }\n+\n+    static Closer closeable(HttpClient.Builder builder) {\n+        return new Closer(builder);\n+    }\n+\n@@ -110,1 +135,3 @@\n-        assertTrue(builder.build().authenticator().get() == a);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().authenticator().get() == a);\n+        }\n@@ -113,1 +140,3 @@\n-        assertTrue(builder.build().authenticator().get() == b);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().authenticator().get() == b);\n+        }\n@@ -117,1 +146,3 @@\n-        assertTrue(builder.build().authenticator().get() == c);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().authenticator().get() == c);\n+        }\n@@ -125,1 +156,3 @@\n-        assertTrue(builder.build().cookieHandler().get() == a);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().cookieHandler().get() == a);\n+        }\n@@ -128,1 +161,3 @@\n-        assertTrue(builder.build().cookieHandler().get() == b);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().cookieHandler().get() == b);\n+        }\n@@ -132,1 +167,3 @@\n-        assertTrue(builder.build().cookieHandler().get() == c);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().cookieHandler().get() == c);\n+        }\n@@ -140,1 +177,3 @@\n-        assertTrue(builder.build().connectTimeout().get() == a);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().connectTimeout().get() == a);\n+        }\n@@ -143,1 +182,3 @@\n-        assertTrue(builder.build().connectTimeout().get() == b);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().connectTimeout().get() == b);\n+        }\n@@ -147,1 +188,3 @@\n-        assertTrue(builder.build().connectTimeout().get() == c);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().connectTimeout().get() == c);\n+        }\n@@ -156,1 +199,1 @@\n-        public void execute(Runnable r) { }\n+        public void execute(Runnable r) { r.run();}\n@@ -164,1 +207,3 @@\n-        assertTrue(builder.build().executor().get() == a);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().executor().get() == a);\n+        }\n@@ -167,1 +212,3 @@\n-        assertTrue(builder.build().executor().get() == b);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().executor().get() == b);\n+        }\n@@ -171,1 +218,3 @@\n-        assertTrue(builder.build().executor().get() == c);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().executor().get() == c);\n+        }\n@@ -179,1 +228,3 @@\n-        assertTrue(builder.build().proxy().get() == a);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().proxy().get() == a);\n+        }\n@@ -182,1 +233,3 @@\n-        assertTrue(builder.build().proxy().get() == b);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().proxy().get() == b);\n+        }\n@@ -186,1 +239,3 @@\n-        assertTrue(builder.build().proxy().get() == c);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().proxy().get() == c);\n+        }\n@@ -196,2 +251,6 @@\n-        assertTrue(builder.build().sslParameters() != (a));\n-        assertTrue(builder.build().sslParameters().getCipherSuites()[0].equals(\"A\"));\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslParameters() != (a));\n+        }\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslParameters().getCipherSuites()[0].equals(\"A\"));\n+        }\n@@ -201,2 +260,6 @@\n-        assertTrue(builder.build().sslParameters() != b);\n-        assertTrue(builder.build().sslParameters().getEnableRetransmissions());\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslParameters() != b);\n+        }\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslParameters().getEnableRetransmissions());\n+        }\n@@ -208,1 +271,3 @@\n-        assertTrue(builder.build().sslParameters().getProtocols()[0].equals(\"C\"));\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslParameters().getProtocols()[0].equals(\"C\"));\n+        }\n@@ -216,1 +281,3 @@\n-        assertTrue(builder.build().sslContext() == a);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslContext() == a);\n+        }\n@@ -219,1 +286,3 @@\n-        assertTrue(builder.build().sslContext() == b);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslContext() == b);\n+        }\n@@ -223,1 +292,3 @@\n-        assertTrue(builder.build().sslContext() == c);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().sslContext() == c);\n+        }\n@@ -230,1 +301,3 @@\n-        assertTrue(builder.build().followRedirects() == Redirect.ALWAYS);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().followRedirects() == Redirect.ALWAYS);\n+        }\n@@ -232,1 +305,3 @@\n-        assertTrue(builder.build().followRedirects() == Redirect.NEVER);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().followRedirects() == Redirect.NEVER);\n+        }\n@@ -235,1 +310,3 @@\n-        assertTrue(builder.build().followRedirects() == Redirect.NORMAL);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().followRedirects() == Redirect.NORMAL);\n+        }\n@@ -242,1 +319,3 @@\n-        assertTrue(builder.build().version() == Version.HTTP_2);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().version() == Version.HTTP_2);\n+        }\n@@ -244,1 +323,3 @@\n-        assertTrue(builder.build().version() == Version.HTTP_1_1);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().version() == Version.HTTP_1_1);\n+        }\n@@ -247,1 +328,3 @@\n-        assertTrue(builder.build().version() == Version.HTTP_2);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().version() == Version.HTTP_2);\n+        }\n@@ -249,1 +332,3 @@\n-        assertTrue(builder.build().version() == Version.HTTP_1_1);\n+        try (var closer = closeable(builder)) {\n+            assertTrue(closer.build().version() == Version.HTTP_1_1);\n+        }\n@@ -261,1 +346,1 @@\n-        builder.build();\n+        try (var httpClient = builder.build()) {}\n@@ -263,1 +348,1 @@\n-        builder.build();\n+        try (var httpClient = builder.build()) {}\n@@ -355,21 +440,22 @@\n-        HttpClient client = HttpClient.newHttpClient();\n-        HttpRequest request = HttpRequest.newBuilder(uri).build();\n-\n-        assertThrows(NPE, () -> client.send(null, BodyHandlers.discarding()));\n-        assertThrows(NPE, () -> client.send(request, null));\n-        assertThrows(NPE, () -> client.send(null, null));\n-\n-        assertThrows(NPE, () -> client.sendAsync(null, BodyHandlers.discarding()));\n-        assertThrows(NPE, () -> client.sendAsync(request, null));\n-        assertThrows(NPE, () -> client.sendAsync(null, null));\n-\n-        assertThrows(NPE, () -> client.sendAsync(null, BodyHandlers.discarding(), null));\n-        assertThrows(NPE, () -> client.sendAsync(request, null, null));\n-        assertThrows(NPE, () -> client.sendAsync(null, null, null));\n-\n-        \/\/ CONNECT is disallowed in the implementation, since it is used for\n-        \/\/ tunneling, and is handled separately for security checks.\n-        HttpRequest connectRequest = new HttpConnectRequest();\n-        assertThrows(IAE, () -> client.send(connectRequest, BodyHandlers.discarding()));\n-        assertThrows(IAE, () -> client.sendAsync(connectRequest, BodyHandlers.discarding()));\n-        assertThrows(IAE, () -> client.sendAsync(connectRequest, BodyHandlers.discarding(), null));\n+        try (HttpClient client = HttpClient.newHttpClient()) {\n+            HttpRequest request = HttpRequest.newBuilder(uri).build();\n+\n+            assertThrows(NPE, () -> client.send(null, BodyHandlers.discarding()));\n+            assertThrows(NPE, () -> client.send(request, null));\n+            assertThrows(NPE, () -> client.send(null, null));\n+\n+            assertThrows(NPE, () -> client.sendAsync(null, BodyHandlers.discarding()));\n+            assertThrows(NPE, () -> client.sendAsync(request, null));\n+            assertThrows(NPE, () -> client.sendAsync(null, null));\n+\n+            assertThrows(NPE, () -> client.sendAsync(null, BodyHandlers.discarding(), null));\n+            assertThrows(NPE, () -> client.sendAsync(request, null, null));\n+            assertThrows(NPE, () -> client.sendAsync(null, null, null));\n+\n+            \/\/ CONNECT is disallowed in the implementation, since it is used for\n+            \/\/ tunneling, and is handled separately for security checks.\n+            HttpRequest connectRequest = new HttpConnectRequest();\n+            assertThrows(IAE, () -> client.send(connectRequest, BodyHandlers.discarding()));\n+            assertThrows(IAE, () -> client.sendAsync(connectRequest, BodyHandlers.discarding()));\n+            assertThrows(IAE, () -> client.sendAsync(connectRequest, BodyHandlers.discarding(), null));\n+        }\n@@ -397,0 +483,103 @@\n+    @Test\n+    static void testDefaultShutdown() throws Exception {\n+        try (HttpClient client = new MockHttpClient()) {\n+            client.shutdown(); \/\/ does nothing\n+        }\n+    }\n+\n+    @Test\n+    static void testDefaultShutdownNow() throws Exception {\n+        try (HttpClient client = new MockHttpClient()) {\n+            client.shutdownNow(); \/\/ calls shutdown, doesn't wait\n+        }\n+\n+        AtomicInteger shutdownCalled = new AtomicInteger();\n+        HttpClient mock = new MockHttpClient() {\n+            @Override\n+            public void shutdown() {\n+                super.shutdown();\n+                shutdownCalled.incrementAndGet();\n+            }\n+        };\n+        try (HttpClient client = mock) {\n+            client.shutdownNow();  \/\/ calls shutdown, doesn't wait\n+        }\n+\n+        \/\/ once from shutdownNow(), and once from close()\n+        assertEquals(shutdownCalled.get(), 2);\n+    }\n+\n+    @Test\n+    static void testDefaultIsTerminated() throws Exception {\n+        try (HttpClient client = new MockHttpClient()) {\n+            assertFalse(client.isTerminated());\n+        }\n+    }\n+\n+    @Test\n+    static void testDefaultAwaitTermination() throws Exception {\n+        try (HttpClient client = new MockHttpClient()) {\n+            assertTrue(client.awaitTermination(Duration.ofDays(1)));\n+        }\n+        try (HttpClient client = new MockHttpClient()) {\n+            assertThrows(NullPointerException.class,\n+                    () -> client.awaitTermination(null));\n+        }\n+    }\n+\n+    @Test\n+    static void testDefaultClose() {\n+        AtomicInteger shutdownCalled = new AtomicInteger();\n+        AtomicInteger awaitTerminationCalled = new AtomicInteger();\n+        AtomicInteger shutdownNowCalled = new AtomicInteger();\n+        HttpClient mock = new MockHttpClient() {\n+            @Override\n+            public void shutdown() {\n+                super.shutdown();\n+                shutdownCalled.incrementAndGet();\n+            }\n+            @Override\n+            public void shutdownNow() {\n+                super.shutdownNow();\n+                shutdownNowCalled.incrementAndGet();\n+            }\n+\n+            @Override\n+            public boolean awaitTermination(Duration duration) throws InterruptedException {\n+                int count = awaitTerminationCalled.incrementAndGet();\n+                if (count == 1) return false;\n+                if (count == 2) return true;\n+                if (count == 3) {\n+                    Thread.currentThread().interrupt();\n+                    throw new InterruptedException();\n+                }\n+                return super.awaitTermination(duration);\n+            }\n+        };\n+\n+        \/\/ first time around:\n+        \/\/   close()\n+        \/\/      shutdown() 0->1\n+        \/\/      awaitTermination() 0->1 -> false\n+        \/\/      awaitTermination() 1->2 -> true\n+        try (HttpClient client = mock) { }\n+        assertEquals(shutdownCalled.get(), 1); \/\/ called by close()\n+        assertEquals(shutdownNowCalled.get(), 0); \/\/ not called\n+        assertEquals(awaitTerminationCalled.get(), 2); \/\/ called by close() twice\n+        assertFalse(Thread.currentThread().isInterrupted());\n+\n+        \/\/ second time around:\n+        \/\/   close()\n+        \/\/      shutdown() 1->2\n+        \/\/      awaitTermination() 2->3 -> interrupt, throws\n+        \/\/      shutdownNow() 0->1\n+        \/\/         calls shutdown() 2->3\n+        \/\/      awaitTermination() 3->4 -> true\n+        try (HttpClient client = mock) { }\n+        assertEquals(shutdownCalled.get(), 3); \/\/ called by close() and shutdownNow()\n+        assertEquals(shutdownNowCalled.get(), 1); \/\/ called by close() due to interrupt\n+        assertEquals(awaitTerminationCalled.get(), 4); \/\/ called by close twice\n+        assertTrue(Thread.currentThread().isInterrupted());\n+        assertTrue(Thread.interrupted());\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientBuilderTest.java","additions":254,"deletions":65,"binary":false,"changes":319,"status":"modified"},{"patch":"@@ -0,0 +1,347 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267140\n+ * @summary Test for HttpClient::close. Any running operation should\n+ *          succeed and the client should eventually exit.\n+ *          This test tests close, awaitTermination, and\n+ *          isTerminated.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       HttpClientClose\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.err;\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class HttpClientClose implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"HttpClientClose message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    static String readBody(InputStream in) {\n+        try {\n+            return new String(in.readAllBytes(), StandardCharsets.UTF_8);\n+        } catch (IOException io) {\n+            throw new UncheckedIOException(io);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        Throwable failed = null;\n+        HttpClient toCheck = null;\n+        try (HttpClient client = toCheck = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build()) {\n+            TRACKER.track(client);\n+\n+            List<CompletableFuture<String>> bodies = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                final int si = i;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(HttpClientClose::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                var cf = bodyCF;\n+                bodies.add(cf);\n+            }\n+            CompletableFuture.allOf(bodies.toArray(new CompletableFuture<?>[0])).get();\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(toCheck.isTerminated());\n+    }\n+\n+    static Throwable cleanup(ExecutorService readerService, Throwable failed) {\n+        try {\n+            readerService.shutdown();\n+            readerService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+        } catch (InterruptedException ie) {\n+            if (failed != null) {\n+                failed.addSuppressed(ie);\n+            } else failed = ie;\n+        }\n+        return failed;\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        Throwable failed = null;\n+        HttpClient toCheck = null;\n+        try (HttpClient client = toCheck = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build()) {\n+            TRACKER.track(client);\n+\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                final int si = i;\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(HttpClientClose::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        })\n+                        .thenApply((s) -> {\n+                            out.println(si + \":  Got body: \" + s);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                bodyCF.get();\n+            }\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(toCheck.isTerminated());\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.checkShutdown(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(\"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(\"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                for (int i=0; i<bytes.length; i++) {\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientClose.java","additions":347,"deletions":0,"binary":false,"changes":347,"status":"added"},{"patch":"@@ -0,0 +1,476 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267140\n+ * @summary Test for HttpClient::shutdown. Any running operation should\n+ *          succeed but new operations will be rejected. The client\n+ *          should eventually exit.\n+ *          This test tests shutdown, awaitTermination, and\n+ *          isTerminated.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       HttpClientShutdown\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.channels.ClosedChannelException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.err;\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class HttpClientShutdown implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"HttpClientShutdown message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+    static volatile long start = System.nanoTime();\n+\n+    static final String now() {\n+        var duration = Duration.ofNanos(System.nanoTime() - start);\n+        var secs = duration.toSeconds();\n+        var ms = duration.toMillisPart();\n+        if (secs > 0) {\n+            return String.format(\"[%ss %sms] \", secs, ms);\n+        } else {\n+            return String.format(\"[%sms] \", ms);\n+        }\n+    }\n+\n+    static Throwable getCause(Throwable t) {\n+        while (t instanceof CompletionException || t instanceof ExecutionException) {\n+            t = t.getCause();\n+        }\n+        return t;\n+    }\n+\n+    static String readBody(InputStream in) {\n+        try {\n+            return new String(in.readAllBytes(), StandardCharsets.UTF_8);\n+        } catch (IOException io) {\n+            throw new UncheckedIOException(io);\n+        }\n+    }\n+\n+    static boolean hasExpectedMessage(IOException io) {\n+        String message = io.getMessage();\n+        if (message == null) return false;\n+        \/\/ exception from sendAsync()\n+        if (message.equals(\"closed\")) return true;\n+        return false;\n+    }\n+\n+    static void checkCause(String what, Throwable cause) {\n+        Throwable t = cause;\n+        Throwable accepted = null;\n+        while (t != null) {\n+            out.println(now() + what + \": checking \" + t);\n+            if (t instanceof IOException io && hasExpectedMessage(io)) {\n+                out.println(now() + what + \": Got expected message in cause: \" + io);\n+                return;\n+            } else if (t instanceof ClosedChannelException) {\n+                out.println(now() + what + \": Accepting ClosedChannelException as a valid cause: \" + t);\n+                accepted = t;\n+            }\n+            t = t.getCause();\n+        }\n+        if (accepted != null) {\n+            out.println(now() + what + \": Didn't find expected closed, \" +\n+                    \"but accepting \" + accepted.getClass().getSimpleName()\n+                    + \" as a valid cause: \" + accepted);\n+            return;\n+        }\n+        throw new AssertionError(what + \": Unexpected exception: \" + cause, cause);\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- %sstarting (%s) ----%n\", now(), uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        Throwable failed = null;\n+        try {\n+            List<CompletableFuture<String>> bodies = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(now() + \"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                final int si = i;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(now() + si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(HttpClientShutdown::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            out.println(now() + si +\": Got expected message: \" + s);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(now() + \"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i < step) {\n+                    bodies.add(bodyCF);\n+                    continue;\n+                }\n+                if (i == step) {\n+                    out.printf(now() + \"%d: shutting down client%n\", i, sleep);\n+                    client.shutdown();\n+                }\n+                var cf = bodyCF.exceptionally((t) -> {\n+                    Throwable cause = getCause(t);\n+                    if (UncheckedIOException.class.isInstance(cause)) {\n+                        if (cause.getCause() != null) {\n+                            cause = cause.getCause();\n+                        }\n+                    }\n+                    out.println(now() + si + \": Got expected exception: \" + cause);\n+                    checkCause(String.valueOf(si), cause);\n+                    return null;\n+                });\n+                bodies.add(cf);\n+            }\n+            CompletableFuture.allOf(bodies.toArray(new CompletableFuture<?>[0])).get();\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(client, readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(client.isTerminated());\n+    }\n+\n+    static Throwable cleanup(HttpClient client, ExecutorService readerService, Throwable failed) {\n+        try {\n+            try {\n+                out.println(now() + \"awaiting termination...\");\n+                if (client.awaitTermination(Duration.ofMillis(2000))) {\n+                    out.println(now() + \"Client terminated within expected delay\");\n+                } else {\n+                    out.println(now() + \"Client still running!\");\n+                    AssertionError error = new AssertionError(\"client still running\");\n+                    if (failed != null) {\n+                        failed.addSuppressed(error);\n+                    } else failed = error;\n+                }\n+            } finally {\n+                readerService.shutdown();\n+                readerService.awaitTermination(2000, TimeUnit.MILLISECONDS);\n+            }\n+        } catch (InterruptedException ie) {\n+            if (failed != null) {\n+                failed.addSuppressed(ie);\n+            } else failed = ie;\n+        }\n+        return failed;\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- %sstarting (%s) ----%n\", now(), uriString);\n+        ExecutorService readerService = Executors.newCachedThreadPool();\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        out.printf(now() + \"will shutdown client in step %d%n\", step);\n+        Throwable failed = null;\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(now() + \"Iteration %d request: %s%n\", i, request.uri());\n+                final int si = i;\n+                CompletableFuture<HttpResponse<InputStream>> responseCF;\n+                CompletableFuture<String> bodyCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofInputStream())\n+                        .thenApply((response) -> {\n+                            out.println(now() + si + \":  Got response: \" + response);\n+                            assertEquals(response.statusCode(), 200);\n+                            return response;\n+                        });\n+                bodyCF = responseCF.thenApplyAsync(HttpResponse::body, readerService)\n+                        .thenApply(HttpClientShutdown::readBody)\n+                        .thenApply((s) -> {\n+                            assertEquals(s, MESSAGE);\n+                            return s;\n+                        })\n+                        .thenApply((s) -> {\n+                            out.println(now() + si + \":  Got body: \" + s);\n+                            return s;\n+                        });\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(now() + \"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i < step) {\n+                    bodyCF.get();\n+                    continue;\n+                }\n+                if (i == step) {\n+                    out.printf(now() + \"%d: shutting down client%n\", i, sleep);\n+                    client.shutdown();\n+                }\n+                bodyCF.handle((r, t) -> {\n+                    if (t != null) {\n+                        try {\n+                            Throwable cause = getCause(t);\n+                            if (UncheckedIOException.class.isInstance(cause)) {\n+                                if (cause.getCause() != null) {\n+                                    cause = cause.getCause();\n+                                }\n+                            }\n+                            out.println(now() + si + \": Got expected exception: \" + cause);\n+                            checkCause(String.valueOf(si), cause);\n+                        } catch (Throwable ase) {\n+                            return CompletableFuture.failedFuture(ase);\n+                        }\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return CompletableFuture.completedFuture(r);\n+                    }\n+                }).thenCompose((c) -> c).get();\n+            }\n+        } catch (Throwable throwable) {\n+            failed = throwable;\n+        } finally {\n+            failed = cleanup(client, readerService, failed);\n+        }\n+        if (failed instanceof Exception ex) throw ex;\n+        if (failed instanceof Error e) throw e;\n+        assertTrue(client.isTerminated());\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+        start = System.nanoTime();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.checkShutdown(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(now() + \"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(now() + \"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            long previous;\n+            long begin = previous = System.nanoTime();\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                out.println(now() + \"Start sending body for: \" + t.getRequestURI());\n+                for (int i=0; i<bytes.length; i++) {\n+                    long now = System.nanoTime();\n+                    long sincePrevious = Duration.ofNanos(now - previous).toMillis();\n+                    long sinceBegin = Duration.ofNanos(now - begin).toMillis();\n+                    if (i > 0 && (sincePrevious > 25)) {\n+                        previous = now;\n+                        out.printf(\"%s%s\/%s bytes sent in %sms for: %s%n\", now(),\n+                                i, bytes.length, sinceBegin, t.getRequestURI());\n+                    }\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+                out.println(now() + \"Body sent (\" + bytes.length + \" bytes) for: \" + t.getRequestURI());\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpClientShutdown.java","additions":476,"deletions":0,"binary":false,"changes":476,"status":"added"},{"patch":"@@ -0,0 +1,385 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267140\n+ * @summary Test HttpClient::shutdownNow. Any running operation will\n+ *          be aborted and the client should eventually exit.\n+ *          This test tests shutdownNow, awaitTermination, and\n+ *          isTerminated.\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ *        ReferenceTracker\n+ * @run testng\/othervm\n+ *       -Djdk.internal.httpclient.debug=true\n+ *       -Djdk.httpclient.HttpClient.log=trace,headers,requests\n+ *       ShutdownNow\n+ *\/\n+\/\/ -Djdk.internal.httpclient.debug=true\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Redirect;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.channels.ClosedChannelException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.RandomFactory;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.out;\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class ShutdownNow implements HttpServerAdapters {\n+\n+    static {\n+        HttpServerAdapters.enableServerLogging();\n+    }\n+    static final Random RANDOM = RandomFactory.getRandom();\n+\n+    SSLContext sslContext;\n+    HttpTestServer httpTestServer;        \/\/ HTTP\/1.1    [ 4 servers ]\n+    HttpTestServer httpsTestServer;       \/\/ HTTPS\/1.1\n+    HttpTestServer http2TestServer;       \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;      \/\/ HTTP\/2 ( h2  )\n+    String httpURI;\n+    String httpsURI;\n+    String http2URI;\n+    String https2URI;\n+\n+    static final String MESSAGE = \"ShutdownNow message body\";\n+    static final int ITERATIONS = 3;\n+\n+    @DataProvider(name = \"positive\")\n+    public Object[][] positive() {\n+        return new Object[][] {\n+                { httpURI,    },\n+                { httpsURI,   },\n+                { http2URI,   },\n+                { https2URI,  },\n+        };\n+    }\n+\n+    static final AtomicLong requestCounter = new AtomicLong();\n+    final ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    static Throwable getCause(Throwable t) {\n+        while (t instanceof CompletionException || t instanceof ExecutionException) {\n+            t = t.getCause();\n+        }\n+        return t;\n+    }\n+\n+    static boolean hasExpectedMessage(IOException io) {\n+        String message = io.getMessage();\n+        if (message == null) return false;\n+        \/\/ exception from sendAsync()\n+        if (message.equals(\"closed\")) return true;\n+        \/\/ exception from selmgr.abort\n+        if (message.equals(\"shutdownNow\")) return true;\n+        return false;\n+    }\n+\n+    static void checkCause(String what, Throwable cause) {\n+        Throwable t = cause;\n+        Throwable accepted = null;\n+        while (t != null) {\n+            out.println(what + \": checking \" + t);\n+            if (t instanceof IOException io && hasExpectedMessage(io)) {\n+                out.println(what + \": Got expected message in cause: \" + io);\n+                return;\n+            } else if (t instanceof ClosedChannelException) {\n+                out.println(what + \": Accepting ClosedChannelException as a valid cause: \" + t);\n+                accepted = t;\n+            }\n+            t = t.getCause();\n+        }\n+        if (accepted != null) {\n+            out.println(what + \": Didn't find expected shutdownNow\/closed, \" +\n+                    \"but accepting \" + accepted.getClass().getSimpleName()\n+                    + \" as a valid cause: \" + accepted);\n+            return;\n+        }\n+        throw new AssertionError(what + \": Unexpected exception: \" + cause, cause);\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testConcurrent(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        try {\n+            List<CompletableFuture<HttpResponse<String>>> responses = new ArrayList<>();\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/concurrent\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                        .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                        .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<String>> responseCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofString());\n+\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down client now%n\", i, sleep);\n+                    client.shutdownNow();\n+                }\n+                final int si = i;\n+                var cf = responseCF.thenApply((response) -> {\n+                    out.println(si + \":  Got response: \" + response);\n+                    out.println(si + \":  Got body Path: \" + response.body());\n+                    assertEquals(response.statusCode(), 200);\n+                    assertEquals(response.body(), MESSAGE);\n+                    return response;\n+                }).exceptionally((t) -> {\n+                    Throwable cause = getCause(t);\n+                    out.println(si + \": Got expected exception: \" + cause);\n+                    checkCause(String.valueOf(si), cause);\n+                    return null;\n+                });\n+                responses.add(cf);\n+            }\n+            CompletableFuture.allOf(responses.toArray(new CompletableFuture<?>[0])).get();\n+        } finally {\n+            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+                out.println(\"Client terminated within expected delay\");\n+            } else {\n+                throw new AssertionError(\"client still running\");\n+            }\n+            assertTrue(client.isTerminated());\n+        }\n+    }\n+\n+    @Test(dataProvider = \"positive\")\n+    void testSequential(String uriString) throws Exception {\n+        out.printf(\"%n---- starting (%s) ----%n\", uriString);\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n+        TRACKER.track(client);\n+\n+        int step = RANDOM.nextInt(ITERATIONS);\n+        out.printf(\"will shutdown client in step %d%n\", step);\n+        try {\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                URI uri = URI.create(uriString + \"\/sequential\/iteration-\" + i);\n+                HttpRequest request = HttpRequest.newBuilder(uri)\n+                            .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                            .build();\n+                out.printf(\"Iteration %d request: %s%n\", i, request.uri());\n+                CompletableFuture<HttpResponse<String>> responseCF;\n+                responseCF = client.sendAsync(request, BodyHandlers.ofString());\n+                long sleep = RANDOM.nextLong(5);\n+                if (sleep > 0) {\n+                    out.printf(\"%d: sleeping %d ms%n\", i, sleep);\n+                    Thread.sleep(sleep);\n+                }\n+                if (i == step) {\n+                    out.printf(\"%d: shutting down client now%n\", i, sleep);\n+                    client.shutdownNow();\n+                }\n+                final int si = i;\n+                responseCF.thenApply((response) -> {\n+                    out.println(si + \":  Got response: \" + response);\n+                    out.println(si + \":  Got body Path: \" + response.body());\n+                    assertEquals(response.statusCode(), 200);\n+                    assertEquals(response.body(), MESSAGE);\n+                    return response;\n+                }).handle((r,t) -> {\n+                    if (t != null) {\n+                        try {\n+                            Throwable cause = getCause(t);\n+                            out.println(si + \": Got expected exception: \" + cause);\n+                            checkCause(String.valueOf(si), cause);\n+                         } catch (Throwable ase) {\n+                            return CompletableFuture.failedFuture(ase);\n+                        }\n+                        return CompletableFuture.completedFuture(null);\n+                    } else {\n+                        return CompletableFuture.completedFuture(r);\n+                    }\n+                }).thenCompose((c) -> c).get();\n+            }\n+       } finally {\n+            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+                out.println(\"Client terminated within expected delay\");\n+            } else {\n+                throw new AssertionError(\"client still running\");\n+            }\n+            assertTrue(client.isTerminated());\n+        }\n+    }\n+\n+    \/\/ -- Infrastructure\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        out.println(\"\\n**** Setup ****\\n\");\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        httpTestServer = HttpTestServer.create(HTTP_1_1);\n+        httpTestServer.addHandler(new ServerRequestHandler(), \"\/http1\/exec\/\");\n+        httpURI = \"http:\/\/\" + httpTestServer.serverAuthority() + \"\/http1\/exec\/retry\";\n+        httpsTestServer = HttpTestServer.create(HTTP_1_1, sslContext);\n+        httpsTestServer.addHandler(new ServerRequestHandler(),\"\/https1\/exec\/\");\n+        httpsURI = \"https:\/\/\" + httpsTestServer.serverAuthority() + \"\/https1\/exec\/retry\";\n+\n+        http2TestServer = HttpTestServer.create(HTTP_2);\n+        http2TestServer.addHandler(new ServerRequestHandler(), \"\/http2\/exec\/\");\n+        http2URI = \"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/exec\/retry\";\n+        https2TestServer = HttpTestServer.create(HTTP_2, sslContext);\n+        https2TestServer.addHandler(new ServerRequestHandler(), \"\/https2\/exec\/\");\n+        https2URI = \"https:\/\/\" + https2TestServer.serverAuthority() + \"\/https2\/exec\/retry\";\n+\n+        httpTestServer.start();\n+        httpsTestServer.start();\n+        http2TestServer.start();\n+        https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        Thread.sleep(100);\n+        AssertionError fail = TRACKER.check(5000);\n+        try {\n+            httpTestServer.stop();\n+            httpsTestServer.stop();\n+            http2TestServer.stop();\n+            https2TestServer.stop();\n+        } finally {\n+            if (fail != null) throw fail;\n+        }\n+    }\n+\n+    static class ServerRequestHandler implements HttpTestHandler {\n+        ConcurrentHashMap<String,String> closedRequests = new ConcurrentHashMap<>();\n+\n+        @java.lang.Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            out.println(\"ServerRequestHandler for: \" + t.getRequestURI());\n+\n+            List<String> uuids = t.getRequestHeaders().get(\"X-uuid\");\n+            if (uuids == null || uuids.size() != 1) {\n+                readAllRequestData(t);\n+                try (OutputStream os = t.getResponseBody()) {\n+                    String msg = \"Incorrect uuid header values:[\" + uuids + \"]\";\n+                    (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                }\n+                return;\n+            }\n+\n+            String uuid = uuids.get(0);\n+            \/\/ retrying\n+            if (closedRequests.putIfAbsent(uuid, t.getRequestURI().toString()) == null) {\n+                if (t.getExchangeVersion() == HTTP_1_1) {\n+                    \/\/ Throwing an exception here only causes a retry\n+                    \/\/ with HTTP_1_1 - where it forces the server to close\n+                    \/\/ the connection.\n+                    \/\/ For HTTP\/2 then throwing an IOE would cause the server\n+                    \/\/ to close the stream, and throwing anything else would\n+                    \/\/ cause it to close the connection, but neither would\n+                    \/\/ cause the client to retry.\n+                    \/\/ So we simply do not try to retry with HTTP\/2.\n+                    out.println(\"Server will close connection, client will retry: \"\n+                            + t.getRequestURI().toString());\n+                    throw new IOException(\"Closing on first request\");\n+                }\n+            }\n+\n+            \/\/ not retrying\n+            readAllRequestData(t);\n+            try (OutputStream os = t.getResponseBody()) {\n+                byte[] bytes = MESSAGE.getBytes(UTF_8);\n+                t.sendResponseHeaders(200, bytes.length);\n+                for (int i=0; i<bytes.length; i++) {\n+                    os.write(bytes, i, 1);\n+                    os.flush();\n+                    try {\n+                        Thread.sleep(RANDOM.nextInt(5));\n+                    } catch (InterruptedException x) { }\n+                }\n+            }\n+\n+            closedRequests.remove(uuid);\n+        }\n+    }\n+\n+    static void readAllRequestData(HttpTestExchange t) throws IOException {\n+        try (InputStream is = t.getRequestBody()) {\n+            is.readAllBytes();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/ShutdownNow.java","additions":385,"deletions":0,"binary":false,"changes":385,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,0 +115,30 @@\n+\n+    @Override\n+    public boolean isTerminated() {\n+        return client.isTerminated();\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        client.shutdown();\n+    }\n+\n+    @Override\n+    public void shutdownNow() {\n+        client.shutdownNow();\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        return client.awaitTermination(duration);\n+    }\n+\n+    @Override\n+    public void close() { client.close(); }\n+\n+    \/**\n+     * Invokes the default implementation of HttpClient::close\n+     * Can be closed by subclasses if necessary.\n+     *\/\n+    protected void defaultClose() { super.close();}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/offline\/DelegatingHttpClient.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import java.time.Duration;\n@@ -30,0 +31,1 @@\n+import java.util.Arrays;\n@@ -32,0 +34,1 @@\n+import java.util.Objects;\n@@ -34,0 +37,2 @@\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n@@ -43,0 +48,3 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n@@ -49,0 +57,3 @@\n+ * Can delegate to an actual HttpClient created from a supplied\n+ * HttpClient.Builder if needed, by calling methods on its\n+ * DelegatingClient super class.\n@@ -56,0 +67,2 @@\n+    private final ConcurrentLinkedQueue<CompletableFuture<?>> responses = new ConcurrentLinkedQueue();\n+    volatile boolean shutdownRequested;\n@@ -184,0 +197,7 @@\n+        CompletableFuture<HttpResponse<T>> cf = new CompletableFuture<>();\n+        synchronized (this) {\n+            if (shutdownRequested) {\n+                return CompletableFuture.failedFuture(new IOException(\"closed\"));\n+            }\n+            responses.add(cf);\n+        }\n@@ -204,1 +224,0 @@\n-        CompletableFuture<HttpResponse<T>> cf = new CompletableFuture<>();\n@@ -206,0 +225,1 @@\n+                    responses.remove(cf);\n@@ -243,0 +263,71 @@\n+\n+    @Override\n+    public boolean isTerminated() {\n+        \/\/ return true if this and the wrapped client are terminated\n+        synchronized (this) {\n+            if (!shutdownRequested) return false;\n+            return responses.isEmpty() && super.isTerminated();\n+        }\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        \/\/ shutdown the wrapped client\n+        super.shutdown();\n+        \/\/ mark shutdown requested\n+        shutdownRequested = true;\n+    }\n+\n+    @Override\n+    public void shutdownNow() {\n+        \/\/ shutdown the wrapped client now\n+        super.shutdownNow();\n+        \/\/ mark shutdown requested\n+        shutdownRequested = true;\n+        \/\/ cancel all completable futures\n+        CompletableFuture[] futures;\n+        synchronized (this) {\n+            if (responses.isEmpty()) return ;\n+            futures = responses.toArray(CompletableFuture[]::new);\n+            responses.removeAll(Arrays.asList(futures));\n+        }\n+        for (var op : futures) {\n+            op.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public boolean awaitTermination(Duration duration) throws InterruptedException {\n+        Objects.requireNonNull(duration);\n+        CompletableFuture[] futures = responses.toArray(CompletableFuture[]::new);\n+        if (futures.length == 0) {\n+            \/\/ nothing to do here: wait for the wrapped client\n+            return super.awaitTermination(duration) && isTerminated();\n+        }\n+\n+        \/\/ waits for our own completable futures to get completed\n+        var all = CompletableFuture.allOf(futures);\n+        Duration max = Duration.ofMillis(Long.MAX_VALUE);\n+        long timeout = duration.compareTo(max) > 0 ? Long.MAX_VALUE : duration.toMillis();\n+        try {\n+            all.exceptionally((t) -> null).get(timeout, TimeUnit.MILLISECONDS);\n+        } catch (TimeoutException te) {\n+            return isTerminated();\n+        } catch (InterruptedException ie) {\n+            throw ie;\n+        } catch (ExecutionException failed) {\n+            return isTerminated();\n+        }\n+        return isTerminated();\n+    }\n+\n+    @Override\n+    public void close() {\n+        try {\n+            \/\/ closes this client\n+            defaultClose();\n+        } finally {\n+            \/\/ closes the wrapped client (which should already be closed)\n+            super.close();\n+        }\n+    }\n","filename":"test\/jdk\/java\/net\/httpclient\/offline\/FixedResponseHttpClient.java","additions":93,"deletions":2,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -66,13 +66,15 @@\n-        HttpClient client = getClient();\n-\n-        HttpRequest request = HttpRequest.newBuilder()\n-                .uri(URI.create(\"https:\/\/openjdk.org\/\"))\n-                .build();\n-\n-        client.sendAsync(request, BodyHandlers.ofString())\n-                .thenAccept(response -> {\n-                    System.out.println(\"response: \" + response);\n-                    assertEquals(response.statusCode(), 200);\n-                    assertTrue(response.headers().firstValue(\"Server\").isPresent());\n-                    assertEquals(response.body(), \"A response message\"); } )\n-                .join();\n+        try (HttpClient client = getClient()) {\n+\n+            HttpRequest request = HttpRequest.newBuilder()\n+                    .uri(URI.create(\"https:\/\/openjdk.org\/\"))\n+                    .build();\n+\n+            client.sendAsync(request, BodyHandlers.ofString())\n+                    .thenAccept(response -> {\n+                        System.out.println(\"response: \" + response);\n+                        assertEquals(response.statusCode(), 200);\n+                        assertTrue(response.headers().firstValue(\"Server\").isPresent());\n+                        assertEquals(response.body(), \"A response message\");\n+                    })\n+                    .join();\n+        }\n@@ -83,13 +85,15 @@\n-        HttpClient client = getClient();\n-\n-        HttpRequest request = HttpRequest.newBuilder()\n-                .uri(URI.create(\"https:\/\/openjdk.org\/\"))\n-                .build();\n-\n-        client.sendAsync(request, BodyHandlers.ofByteArray())\n-                .thenAccept(response -> {\n-                    System.out.println(\"response: \" + response);\n-                    assertEquals(response.statusCode(), 200);\n-                    assertTrue(response.headers().firstValue(\"Content-Type\").isPresent());\n-                    assertEquals(response.body(), \"A response message\".getBytes(UTF_8)); } )\n-                .join();\n+        try (HttpClient client = getClient()) {\n+\n+            HttpRequest request = HttpRequest.newBuilder()\n+                    .uri(URI.create(\"https:\/\/openjdk.org\/\"))\n+                    .build();\n+\n+            client.sendAsync(request, BodyHandlers.ofByteArray())\n+                    .thenAccept(response -> {\n+                        System.out.println(\"response: \" + response);\n+                        assertEquals(response.statusCode(), 200);\n+                        assertTrue(response.headers().firstValue(\"Content-Type\").isPresent());\n+                        assertEquals(response.body(), \"A response message\".getBytes(UTF_8));\n+                    })\n+                    .join();\n+        }\n@@ -101,1 +105,1 @@\n-        HttpClient client = FixedResponseHttpClient.createClientFrom(\n+        HttpClient fixedClient = FixedResponseHttpClient.createClientFrom(\n@@ -121,8 +125,12 @@\n-        client.sendAsync(request, BodyHandlers.ofString())\n-                .thenAccept(response -> {\n-                    assertEquals(response.statusCode(), 404);\n-                    response.headers().firstValue(\"Content-Type\")\n-                            .ifPresentOrElse(type -> assertEquals(type, \"text\/html\"),\n-                                             () -> fail(\"Content-Type not present\"));\n-                    assertTrue(response.body().contains(\"404 Not Found\")); } )\n-                .join();\n+        try (var client = fixedClient) {\n+            client.sendAsync(request, BodyHandlers.ofString())\n+                    .thenAccept(response -> {\n+                        assertEquals(response.statusCode(), 404);\n+                        response.headers().firstValue(\"Content-Type\")\n+                                .ifPresentOrElse(type -> assertEquals(type, \"text\/html\"),\n+                                        () -> fail(\"Content-Type not present\"));\n+                        assertTrue(response.body().contains(\"404 Not Found\"));\n+                    })\n+                    .join();\n+        }\n+        assertTrue(fixedClient.isTerminated());\n@@ -133,1 +141,1 @@\n-        HttpClient client = FixedResponseHttpClient.createEchoClient(\n+        try (HttpClient client = FixedResponseHttpClient.createEchoClient(\n@@ -136,13 +144,15 @@\n-                headersOf(\"Connection\",  \"keep-alive\"));\n-\n-        HttpRequest request = HttpRequest.newBuilder()\n-                .uri(URI.create(\"https:\/\/openjdk.org\/echo\"))\n-                .POST(BodyPublishers.ofString(\"Hello World\"))\n-                .build();\n-\n-        client.sendAsync(request, BodyHandlers.ofString())\n-                .thenAccept(response -> {\n-                    System.out.println(\"response: \" + response);\n-                    assertEquals(response.statusCode(), 200);\n-                    assertEquals(response.body(), \"Hello World\"); } )\n-                .join();\n+                headersOf(\"Connection\",  \"keep-alive\"))) {\n+\n+            HttpRequest request = HttpRequest.newBuilder()\n+                    .uri(URI.create(\"https:\/\/openjdk.org\/echo\"))\n+                    .POST(BodyPublishers.ofString(\"Hello World\"))\n+                    .build();\n+\n+            client.sendAsync(request, BodyHandlers.ofString())\n+                    .thenAccept(response -> {\n+                        System.out.println(\"response: \" + response);\n+                        assertEquals(response.statusCode(), 200);\n+                        assertEquals(response.body(), \"Hello World\");\n+                    })\n+                    .join();\n+        }\n@@ -153,1 +163,1 @@\n-        HttpClient client = FixedResponseHttpClient.createEchoClient(\n+        try (HttpClient client = FixedResponseHttpClient.createEchoClient(\n@@ -156,1 +166,1 @@\n-                headersOf(\"Connection\",  \"keep-alive\"));\n+                headersOf(\"Connection\",  \"keep-alive\"))) {\n@@ -158,4 +168,4 @@\n-        HttpRequest request = HttpRequest.newBuilder()\n-                .uri(URI.create(\"https:\/\/openjdk.org\/echo\"))\n-                .POST(BodyPublishers.ofString(\"Hello chegar!!\"))\n-                .build();\n+            HttpRequest request = HttpRequest.newBuilder()\n+                    .uri(URI.create(\"https:\/\/openjdk.org\/echo\"))\n+                    .POST(BodyPublishers.ofString(\"Hello chegar!!\"))\n+                    .build();\n@@ -163,4 +173,5 @@\n-        HttpResponse<String> response = client.send(request, BodyHandlers.ofString());\n-        System.out.println(\"response: \" + response);\n-        assertEquals(response.statusCode(), 200);\n-        assertEquals(response.body(), \"Hello chegar!!\");\n+            HttpResponse<String> response = client.send(request, BodyHandlers.ofString());\n+            System.out.println(\"response: \" + response);\n+            assertEquals(response.statusCode(), 200);\n+            assertEquals(response.body(), \"Hello chegar!!\");\n+        }\n","filename":"test\/jdk\/java\/net\/httpclient\/offline\/OfflineTesting.java","additions":70,"deletions":59,"binary":false,"changes":129,"status":"modified"}]}