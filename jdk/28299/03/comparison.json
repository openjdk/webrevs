{"files":[{"patch":"@@ -7176,0 +7176,1 @@\n+  bool is_decrypt = false;\n@@ -7186,0 +7187,1 @@\n+    is_decrypt = true;\n@@ -7219,1 +7221,1 @@\n-  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n+  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object, is_decrypt);\n@@ -7234,1 +7236,1 @@\n-\n+  bool is_decrypt= false;\n@@ -7245,0 +7247,1 @@\n+    is_decrypt = true;\n@@ -7298,1 +7301,1 @@\n-  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n+  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object, is_decrypt);\n@@ -7322,1 +7325,1 @@\n-\n+  bool is_decrypt = false;\n@@ -7333,0 +7336,1 @@\n+    is_decrypt = true;\n@@ -7384,1 +7388,1 @@\n-  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object);\n+  Node* k_start = get_key_start_from_aescrypt_object(aescrypt_object, is_decrypt);\n@@ -7477,2 +7481,1 @@\n-Node * LibraryCallKit::get_key_start_from_aescrypt_object(Node *aescrypt_object) {\n-#if defined(PPC64) || defined(S390) || defined(RISCV64)\n+Node* LibraryCallKit::get_key_start_from_aescrypt_object(Node* aescrypt_object, bool is_decrypt) {\n@@ -7482,7 +7485,3 @@\n-  \/\/ The ppc64 and riscv64 stubs of encryption and decryption use the same round keys (sessionK[0]).\n-  Node* objSessionK = load_field_from_object(aescrypt_object, \"sessionK\", \"[[I\");\n-  assert (objSessionK != nullptr, \"wrong version of com.sun.crypto.provider.AES_Crypt\");\n-  if (objSessionK == nullptr) {\n-    return (Node *) nullptr;\n-  }\n-  Node* objAESCryptKey = load_array_element(objSessionK, intcon(0), TypeAryPtr::OOPS, \/* set_ctrl *\/ true);\n+  \/\/ The following platform specific stubs of encryption and decryption use the same round keys.\n+#if defined(PPC64) || defined(S390) || defined(RISCV64)\n+  bool use_decryption_key = false;\n@@ -7490,3 +7489,4 @@\n-  Node* objAESCryptKey = load_field_from_object(aescrypt_object, \"K\", \"[I\");\n-#endif \/\/ PPC64\n-  assert (objAESCryptKey != nullptr, \"wrong version of com.sun.crypto.provider.AES_Crypt\");\n+  bool use_decryption_key = is_decrypt;\n+#endif\n+  Node* objAESCryptKey = load_field_from_object(aescrypt_object, use_decryption_key ? \"sessionKd\" : \"sessionKe\", \"[I\");\n+  assert(objAESCryptKey != nullptr, \"wrong version of com.sun.crypto.provider.AES_Crypt\");\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-  Node* get_key_start_from_aescrypt_object(Node* aescrypt_object);\n+  Node* get_key_start_from_aescrypt_object(Node* aescrypt_object, bool is_decrypt = false);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,5 +57,5 @@\n-    \/\/ Following two attributes are specific to Intrinsics where sessionK is\n-    \/\/ used for PPC64, S390, and RISCV64 architectures, whereas K is used for\n-    \/\/ everything else.\n-    private int[][] sessionK = null;\n-    private int[] K = null;\n+    \/\/ Following attributes are specific to Intrinsics, where sessionKe is the\n+    \/\/ unprocessed key that is also used for decryption on PPC64, S390 and\n+    \/\/ RISCV64 architectures. Other ones use sessionKd for decryption.\n+    private int[] sessionKe = null; \/\/ key for encryption\n+    private int[] sessionKd = null; \/\/ preprocessed key for decryption\n@@ -907,1 +907,0 @@\n-        int decrypt = decrypting ? 1 : 0;\n@@ -923,0 +922,1 @@\n+\n@@ -924,5 +924,7 @@\n-            if (sessionK == null) {\n-                sessionK = new int[2][];\n-            } else {\n-                Arrays.fill(sessionK[0], 0);\n-                Arrays.fill(sessionK[1], 0);\n+            if (sessionKe != null) {\n+                Arrays.fill(sessionKe, 0);\n+            }\n+            sessionKe = genRoundKeys(key, rounds);\n+            if (sessionKd != null) {\n+                Arrays.fill(sessionKd, 0);\n+                sessionKd = null;\n@@ -930,2 +932,0 @@\n-            sessionK[0] = genRoundKeys(key, rounds);\n-            sessionK[1] = genInvRoundKeys(sessionK[0], rounds);\n@@ -937,1 +937,6 @@\n-        K = sessionK[decrypt];\n+\n+        if (decrypting) {\n+            if (sessionKd == null) {\n+                sessionKd = genInvRoundKeys(sessionKe, rounds);\n+            }\n+        }\n@@ -1038,0 +1043,1 @@\n+        int[] K = sessionKe;\n@@ -1216,0 +1222,1 @@\n+        int[] K = sessionKd;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/AES_Crypt.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"}]}