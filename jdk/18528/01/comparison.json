{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n@@ -98,0 +100,7 @@\n+\n+    if (log_is_enabled(Debug, monitorinflation)) {\n+      \/\/ The VMThread calls do_final_audit_and_print_stats() which calls\n+      \/\/ audit_and_print_stats() at the Info level at VM exit time.\n+      LogStreamHandle(Debug, monitorinflation) ls;\n+      ObjectSynchronizer::audit_and_print_stats(&ls, false \/* on_exit *\/);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -591,6 +591,0 @@\n-\n-  if (log_is_enabled(Debug, monitorinflation)) {\n-    \/\/ The VMThread calls do_final_audit_and_print_stats() which calls\n-    \/\/ audit_and_print_stats() at the Info level at VM exit time.\n-    ObjectSynchronizer::audit_and_print_stats(false \/* on_exit *\/);\n-  }\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1953,3 +1953,2 @@\n-    \/\/ The other audit_and_print_stats() call is done at the Debug\n-    \/\/ level at a safepoint in SafepointSynchronize::do_cleanup_tasks.\n-    audit_and_print_stats(true \/* on_exit *\/);\n+    LogStreamHandle(Info, monitorinflation) ls;\n+    audit_and_print_stats(&ls, true \/* on_exit *\/);\n@@ -1959,5 +1958,3 @@\n-\/\/ This function can be called at a safepoint or it can be called when\n-\/\/ we are trying to exit the VM. When we are trying to exit the VM, the\n-\/\/ list walker functions can run in parallel with the other list\n-\/\/ operations so spin-locking is used for safety.\n-\/\/\n+\/\/ This function can be called by the monitor deflation thread or it can be called when\n+\/\/ we are trying to exit the VM. The list walker functions can run in parallel with\n+\/\/ the other list operations.\n@@ -1965,3 +1962,1 @@\n-\/\/ aid; pass 'true' for the 'on_exit' parameter to have in-use monitor\n-\/\/ details logged at the Info level and 'false' for the 'on_exit'\n-\/\/ parameter to have in-use monitor details logged at the Trace level.\n+\/\/ aid.\n@@ -1969,16 +1964,1 @@\n-void ObjectSynchronizer::audit_and_print_stats(bool on_exit) {\n-  assert(on_exit || SafepointSynchronize::is_at_safepoint(), \"invariant\");\n-\n-  LogStreamHandle(Debug, monitorinflation) lsh_debug;\n-  LogStreamHandle(Info, monitorinflation) lsh_info;\n-  LogStreamHandle(Trace, monitorinflation) lsh_trace;\n-  LogStream* ls = nullptr;\n-  if (log_is_enabled(Trace, monitorinflation)) {\n-    ls = &lsh_trace;\n-  } else if (log_is_enabled(Debug, monitorinflation)) {\n-    ls = &lsh_debug;\n-  } else if (log_is_enabled(Info, monitorinflation)) {\n-    ls = &lsh_info;\n-  }\n-  assert(ls != nullptr, \"sanity check\");\n-\n+void ObjectSynchronizer::audit_and_print_stats(outputStream* ls, bool on_exit) {\n@@ -1996,6 +1976,8 @@\n-  if ((on_exit && log_is_enabled(Info, monitorinflation)) ||\n-      (!on_exit && log_is_enabled(Trace, monitorinflation))) {\n-    \/\/ When exiting this log output is at the Info level. When called\n-    \/\/ at a safepoint, this log output is at the Trace level since\n-    \/\/ there can be a lot of it.\n-    log_in_use_monitor_details(ls, !on_exit \/* log_all *\/);\n+  \/\/ When exiting, only log the interesting entries at the Info level.\n+  \/\/ When called at intervals by the MonitorDeflationThread, log output at the Trace level since\n+  \/\/ there can be a lot of it.\n+  if (!on_exit && log_is_enabled(Trace, monitorinflation)) {\n+    LogStreamHandle(Trace, monitorinflation) ls_tr;\n+    log_in_use_monitor_details(&ls_tr, true \/* log_all *\/);\n+  } else if (on_exit) {\n+    log_in_use_monitor_details(ls, false \/* log_all *\/);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":15,"deletions":33,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  static void audit_and_print_stats(bool on_exit);\n+  static void audit_and_print_stats(outputStream* out, bool on_exit);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,87 @@\n+\n+    private static ProcessBuilder processCommand(String loggingLevel) {\n+        return ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \/\/ Test doesn't need much Java heap:\n+            \"-Xmx100M\",\n+            \/\/ AvgMonitorsPerThreadEstimate == 1 means we'll start with\n+            \/\/ an in_use_list_ceiling of <n-threads> plus a couple of\n+            \/\/ of monitors for threads that call Object.wait().\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:AvgMonitorsPerThreadEstimate=1\",\n+            \/\/ MonitorUsedDeflationThreshold == 10 means we'll request\n+            \/\/ deflations when 10% of monitors are used rather than the\n+            \/\/ default 90%. This should allow the test to tolerate a burst\n+            \/\/ of used monitors by threads not under this test's control.\n+            \"-XX:MonitorUsedDeflationThreshold=10\",\n+            \/\/ Enable monitorinflation logging so we can see that\n+            \/\/ MonitorUsedDeflationThreshold and\n+            \/\/ NoAsyncDeflationProgressMaxoption are working.\n+            \"-Xlog:monitorinflation=\" + loggingLevel,\n+            \/\/ Run the test with inflate_count == 33 since that\n+            \/\/ reproduced the bug with JDK13. With inflate_count == 33, an\n+            \/\/ initial ceiling == 12 and MonitorUsedDeflationThreshold == 10,\n+            \/\/ we should hit NoAsyncDeflationProgressMax at least 3 times.\n+            \"MonitorUsedDeflationThresholdTest\", \"33\");\n+    }\n+\n+    private static void testProcess1() throws Exception {\n+        ProcessBuilder pb = processCommand(\"info\");\n+\n+        OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+        output_detail.shouldHaveExitValue(0);\n+\n+        \/\/ This mesg means:\n+        \/\/ - AvgMonitorsPerThreadEstimate == 1 reduced in_use_list_ceiling\n+        \/\/   to a small number.\n+        \/\/ - and we crossed MonitorUsedDeflationThreshold:\n+        output_detail.shouldMatch(\"begin deflating: .*\");\n+        System.out.println(\"Found beginning of a deflation cycle.\");\n+\n+        \/\/ This mesg means we hit NoAsyncDeflationProgressMax and\n+        \/\/ had to adjust the in_use_list_ceiling:\n+        String too_many = output_detail.firstMatch(\"Too many deflations without progress; .*\", 0);\n+        if (too_many == null) {\n+            output_detail.reportDiagnosticSummary();\n+            throw new RuntimeException(\"Did not find too_many string in output.\\n\");\n+        }\n+        System.out.println(\"too_many='\" + too_many + \"'\");\n+        \/\/ Uncomment the following line for dumping test output in passing runs:\n+        \/\/ output_detail.reportDiagnosticSummary();\n+\n+        System.out.println(\"PASSED.\");\n+    }\n+\n+    private static void testProcess2() throws Exception {\n+        ProcessBuilder pb = processCommand(\"debug\");\n+        OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+        output_detail.shouldHaveExitValue(0);\n+\n+        \/\/ Test that logging reports in_use_list with each iteration of the deflation thread in debug mode.\n+        \/\/ but not monitor details with each report\n+        output_detail.shouldMatch(   \".debug..monitorinflation. Checking in_use_list:\");\n+        output_detail.shouldNotMatch(\".debug..monitorinflation. .*is_busy\");\n+\n+        \/\/ Reporting stats at exit is in Info mode, and contains monitor details\n+        output_detail.shouldMatch(\".info ..monitorinflation. Checking in_use_list:\");\n+        output_detail.shouldMatch(\".info ..monitorinflation. .*is_busy\");\n+\n+        System.out.println(\"PASSED.\");\n+    }\n+\n+    private static void testProcess3() throws Exception {\n+        ProcessBuilder pb = processCommand(\"trace\");\n+        OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n+        output_detail.shouldHaveExitValue(0);\n+\n+        \/\/ Test that logging reports in_use_list with each iteration of the deflation thread in debug mode.\n+        \/\/ and monitor details with each report\n+        output_detail.shouldMatch(\".debug..monitorinflation. Checking in_use_list:\");\n+        output_detail.shouldMatch(\".trace..monitorinflation. .*is_busy\");\n+\n+        \/\/ Reporting stats at exit is in Info mode, and contains monitor details\n+        output_detail.shouldMatch(\".info ..monitorinflation. Checking in_use_list:\");\n+        output_detail.shouldMatch(\".info ..monitorinflation. .*is_busy\");\n+\n+        System.out.println(\"PASSED.\");\n+    }\n+\n@@ -75,49 +162,4 @@\n-            \/\/ Without args we invoke the test in a java sub-process:\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n-                \/\/ Test doesn't need much Java heap:\n-                \"-Xmx100M\",\n-                \/\/ AvgMonitorsPerThreadEstimate == 1 means we'll start with\n-                \/\/ an in_use_list_ceiling of <n-threads> plus a couple of\n-                \/\/ of monitors for threads that call Object.wait().\n-                \"-XX:+UnlockDiagnosticVMOptions\",\n-                \"-XX:AvgMonitorsPerThreadEstimate=1\",\n-                \/\/ MonitorUsedDeflationThreshold == 10 means we'll request\n-                \/\/ deflations when 10% of monitors are used rather than the\n-                \/\/ default 90%. This should allow the test to tolerate a burst\n-                \/\/ of used monitors by threads not under this test's control.\n-                \"-XX:MonitorUsedDeflationThreshold=10\",\n-                \/\/ Enable monitorinflation logging so we can see that\n-                \/\/ MonitorUsedDeflationThreshold and\n-                \/\/ NoAsyncDeflationProgressMaxoption are working.\n-                \"-Xlog:monitorinflation=info\",\n-                \/\/ Enable some safepoint logging for diagnostic purposes.\n-                \"-Xlog:safepoint+cleanup=info\",\n-                \"-Xlog:safepoint+stats=debug\",\n-                \/\/ Run the test with inflate_count == 33 since that\n-                \/\/ reproduced the bug with JDK13. With inflate_count == 33, an\n-                \/\/ initial ceiling == 12 and MonitorUsedDeflationThreshold == 10,\n-                \/\/ we should hit NoAsyncDeflationProgressMax at least 3 times.\n-                \"MonitorUsedDeflationThresholdTest\", \"33\");\n-\n-            OutputAnalyzer output_detail = new OutputAnalyzer(pb.start());\n-            output_detail.shouldHaveExitValue(0);\n-\n-            \/\/ This mesg means:\n-            \/\/ - AvgMonitorsPerThreadEstimate == 1 reduced in_use_list_ceiling\n-            \/\/   to a small number.\n-            \/\/ - and we crossed MonitorUsedDeflationThreshold:\n-            output_detail.shouldMatch(\"begin deflating: .*\");\n-            System.out.println(\"Found beginning of a deflation cycle.\");\n-\n-            \/\/ This mesg means we hit NoAsyncDeflationProgressMax and\n-            \/\/ had to adjust the in_use_list_ceiling:\n-            String too_many = output_detail.firstMatch(\"Too many deflations without progress; .*\", 0);\n-            if (too_many == null) {\n-                output_detail.reportDiagnosticSummary();\n-                throw new RuntimeException(\"Did not find too_many string in output.\\n\");\n-            }\n-            System.out.println(\"too_many='\" + too_many + \"'\");\n-            \/\/ Uncomment the following line for dumping test output in passing runs:\n-            \/\/ output_detail.reportDiagnosticSummary();\n-\n-            System.out.println(\"PASSED.\");\n+            \/\/ Without args we invoke the tests in a java sub-process.\n+            testProcess1();\n+            testProcess2();\n+            testProcess3();\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorUsedDeflationThresholdTest.java","additions":92,"deletions":50,"binary":false,"changes":142,"status":"modified"}]}