{"files":[{"patch":"@@ -31,15 +31,3 @@\n-G1IHOPControl::G1IHOPControl(double initial_ihop_percent,\n-                             G1OldGenAllocationTracker const* old_gen_alloc_tracker) :\n-  _initial_ihop_percent(initial_ihop_percent),\n-  _target_occupancy(0),\n-  _last_allocation_time_s(0.0),\n-  _old_gen_alloc_tracker(old_gen_alloc_tracker)\n-{\n-  assert(_initial_ihop_percent >= 0.0 && _initial_ihop_percent <= 100.0, \"Initial IHOP value must be between 0 and 100 but is %.3f\", initial_ihop_percent);\n-}\n-\n-void G1IHOPControl::update_target_occupancy(size_t new_target_occupancy) {\n-  log_debug(gc, ihop)(\"Target occupancy update: old: %zuB, new: %zuB\",\n-                      _target_occupancy, new_target_occupancy);\n-  _target_occupancy = new_target_occupancy;\n-}\n+double G1IHOPControl::predict(const TruncatedSeq* seq) const {\n+  assert(_is_adaptive, \"precondition\");\n+  assert(_predictor != nullptr, \"precondition\");\n@@ -47,3 +35,1 @@\n-void G1IHOPControl::report_statistics(G1NewTracer* new_tracer, size_t non_young_occupancy) {\n-  print_log(non_young_occupancy);\n-  send_trace_event(new_tracer, non_young_occupancy);\n+  return  _predictor->predict_zero_bounded(seq);\n@@ -52,2 +38,2 @@\n-void G1IHOPControl::update_allocation_info(double allocation_time_s, size_t additional_buffer_size) {\n-  assert(allocation_time_s >= 0.0, \"Allocation time must be positive but is %.3f\", allocation_time_s);\n+bool G1IHOPControl::have_enough_data_for_prediction() const {\n+  assert(_is_adaptive, \"precondition\");\n@@ -55,26 +41,2 @@\n-  _last_allocation_time_s = allocation_time_s;\n-}\n-\n-void G1IHOPControl::print_log(size_t non_young_occupancy) {\n-  assert(_target_occupancy > 0, \"Target occupancy still not updated yet.\");\n-  size_t cur_conc_mark_start_threshold = get_conc_mark_start_threshold();\n-  log_debug(gc, ihop)(\"Basic information (value update), threshold: %zuB (%1.2f), target occupancy: %zuB, non-young occupancy: %zuB, \"\n-                      \"recent allocation size: %zuB, recent allocation duration: %1.2fms, recent old gen allocation rate: %1.2fB\/s, recent marking phase length: %1.2fms\",\n-                      cur_conc_mark_start_threshold,\n-                      percent_of(cur_conc_mark_start_threshold, _target_occupancy),\n-                      _target_occupancy,\n-                      non_young_occupancy,\n-                      _old_gen_alloc_tracker->last_period_old_gen_bytes(),\n-                      _last_allocation_time_s * 1000.0,\n-                      _last_allocation_time_s > 0.0 ? _old_gen_alloc_tracker->last_period_old_gen_bytes() \/ _last_allocation_time_s : 0.0,\n-                      last_marking_length_s() * 1000.0);\n-}\n-\n-void G1IHOPControl::send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy) {\n-  assert(_target_occupancy > 0, \"Target occupancy still not updated yet.\");\n-  tracer->report_basic_ihop_statistics(get_conc_mark_start_threshold(),\n-                                       _target_occupancy,\n-                                       non_young_occupancy,\n-                                       _old_gen_alloc_tracker->last_period_old_gen_bytes(),\n-                                       _last_allocation_time_s,\n-                                       last_marking_length_s());\n+  return ((size_t)_marking_times_s.num() >= G1AdaptiveIHOPNumInitialSamples) &&\n+         ((size_t)_allocation_rate_s.num() >= G1AdaptiveIHOPNumInitialSamples);\n@@ -83,4 +45,2 @@\n-G1StaticIHOPControl::G1StaticIHOPControl(double ihop_percent,\n-                                         G1OldGenAllocationTracker const* old_gen_alloc_tracker) :\n-  G1IHOPControl(ihop_percent, old_gen_alloc_tracker),\n-  _last_marking_length_s(0.0) {\n+double G1IHOPControl::last_marking_length_s() const {\n+  return _marking_times_s.last();\n@@ -89,14 +49,2 @@\n-G1AdaptiveIHOPControl::G1AdaptiveIHOPControl(double ihop_percent,\n-                                             G1OldGenAllocationTracker const* old_gen_alloc_tracker,\n-                                             G1Predictions const* predictor,\n-                                             size_t heap_reserve_percent,\n-                                             size_t heap_waste_percent) :\n-  G1IHOPControl(ihop_percent, old_gen_alloc_tracker),\n-  _heap_reserve_percent(heap_reserve_percent),\n-  _heap_waste_percent(heap_waste_percent),\n-  _predictor(predictor),\n-  _marking_times_s(10, 0.05),\n-  _allocation_rate_s(10, 0.05),\n-  _last_unrestrained_young_size(0)\n-{\n-}\n+size_t G1IHOPControl::actual_target_threshold() const {\n+  assert(_is_adaptive, \"precondition\");\n@@ -104,2 +52,0 @@\n-size_t G1AdaptiveIHOPControl::actual_target_threshold() const {\n-  guarantee(_target_occupancy > 0, \"Target occupancy still not updated yet.\");\n@@ -113,2 +59,2 @@\n-\n-  double safe_total_heap_percentage = MIN2((double)(_heap_reserve_percent + _heap_waste_percent), 100.0);\n+  double safe_total_heap_percentage =\n+    MIN2((double)(_heap_reserve_percent + _heap_waste_percent), 100.0);\n@@ -119,1 +65,29 @@\n-    );\n+  );\n+}\n+\n+G1IHOPControl::G1IHOPControl(double ihop_percent,\n+                             const G1OldGenAllocationTracker* old_gen_alloc_tracker,\n+                             bool adaptive,\n+                             const G1Predictions* predictor,\n+                             size_t heap_reserve_percent,\n+                             size_t heap_waste_percent)\n+  : _is_adaptive(adaptive),\n+    _initial_ihop_percent(ihop_percent),\n+    _target_occupancy(0),\n+    _heap_reserve_percent(heap_reserve_percent),\n+    _heap_waste_percent(heap_waste_percent),\n+    _last_allocation_time_s(0.0),\n+    _old_gen_alloc_tracker(old_gen_alloc_tracker),\n+    _predictor(predictor),\n+    _marking_times_s(10, 0.05),\n+    _allocation_rate_s(10, 0.05),\n+    _last_unrestrained_young_size(0) {\n+  assert(_initial_ihop_percent >= 0.0 && _initial_ihop_percent <= 100.0,\n+         \"IHOP percent out of range: %.3f\", ihop_percent);\n+  assert(!_is_adaptive || _predictor != nullptr, \"precondition\");\n+}\n+\n+void G1IHOPControl::update_target_occupancy(size_t new_target_occupancy) {\n+  log_debug(gc, ihop)(\"Target occupancy update: old: %zuB, new: %zuB\",\n+                      _target_occupancy, new_target_occupancy);\n+  _target_occupancy = new_target_occupancy;\n@@ -122,2 +96,3 @@\n-double G1AdaptiveIHOPControl::predict(TruncatedSeq const* seq) const {\n-  return _predictor->predict_zero_bounded(seq);\n+void G1IHOPControl::report_statistics(G1NewTracer* new_tracer, size_t non_young_occupancy) {\n+  print_log(non_young_occupancy);\n+  send_trace_event(new_tracer, non_young_occupancy);\n@@ -126,3 +101,6 @@\n-bool G1AdaptiveIHOPControl::have_enough_data_for_prediction() const {\n-  return ((size_t)_marking_times_s.num() >= G1AdaptiveIHOPNumInitialSamples) &&\n-         ((size_t)_allocation_rate_s.num() >= G1AdaptiveIHOPNumInitialSamples);\n+void G1IHOPControl::update_allocation_info(double allocation_time_s, size_t additional_buffer_size) {\n+  assert(allocation_time_s > 0, \"Invalid allocation time: %.3f\", allocation_time_s);\n+  _last_allocation_time_s = allocation_time_s;\n+  double alloc_rate = _old_gen_alloc_tracker->last_period_old_gen_growth() \/ allocation_time_s;\n+  _allocation_rate_s.add(alloc_rate);\n+  _last_unrestrained_young_size = additional_buffer_size;\n@@ -131,21 +109,3 @@\n-size_t G1AdaptiveIHOPControl::get_conc_mark_start_threshold() {\n-  if (have_enough_data_for_prediction()) {\n-    double pred_marking_time = predict(&_marking_times_s);\n-    double pred_promotion_rate = predict(&_allocation_rate_s);\n-    size_t pred_promotion_size = (size_t)(pred_marking_time * pred_promotion_rate);\n-\n-    size_t predicted_needed_bytes_during_marking =\n-      pred_promotion_size +\n-      \/\/ In reality we would need the maximum size of the young gen during\n-      \/\/ marking. This is a conservative estimate.\n-      _last_unrestrained_young_size;\n-\n-    size_t internal_threshold = actual_target_threshold();\n-    size_t predicted_initiating_threshold = predicted_needed_bytes_during_marking < internal_threshold ?\n-                                            internal_threshold - predicted_needed_bytes_during_marking :\n-                                            0;\n-    return predicted_initiating_threshold;\n-  } else {\n-    \/\/ Use the initial value.\n-    return (size_t)(_initial_ihop_percent * _target_occupancy \/ 100.0);\n-  }\n+void G1IHOPControl::update_marking_length(double marking_length_s) {\n+  assert(marking_length_s >= 0.0, \"Invalid marking length: %.3f\", marking_length_s);\n+  _marking_times_s.add(marking_length_s);\n@@ -154,2 +114,2 @@\n-double G1AdaptiveIHOPControl::last_mutator_period_old_allocation_rate() const {\n-  assert(_last_allocation_time_s > 0, \"This should not be called when the last GC is full\");\n+size_t G1IHOPControl::get_conc_mark_start_threshold() {\n+  guarantee(_target_occupancy > 0, \"Target occupancy must be initialized\");\n@@ -157,2 +117,3 @@\n-  return _old_gen_alloc_tracker->last_period_old_gen_growth() \/ _last_allocation_time_s;\n-}\n+  if (!_is_adaptive || !have_enough_data_for_prediction()) {\n+    return (size_t)(_initial_ihop_percent * _target_occupancy \/ 100.0);\n+  }\n@@ -160,4 +121,5 @@\n-void G1AdaptiveIHOPControl::update_allocation_info(double allocation_time_s,\n-                                                   size_t additional_buffer_size) {\n-  G1IHOPControl::update_allocation_info(allocation_time_s, additional_buffer_size);\n-  _allocation_rate_s.add(last_mutator_period_old_allocation_rate());\n+  double pred_marking_time = predict(&_marking_times_s);\n+  double pred_rate = predict(&_allocation_rate_s);\n+  size_t pred_bytes = (size_t)(pred_marking_time * pred_rate);\n+  size_t predicted_needed = pred_bytes + _last_unrestrained_young_size;\n+  size_t internal_threshold = actual_target_threshold();\n@@ -165,1 +127,3 @@\n-  _last_unrestrained_young_size = additional_buffer_size;\n+  return predicted_needed < internal_threshold\n+         ? internal_threshold - predicted_needed\n+         : 0;\n@@ -168,4 +132,17 @@\n-void G1AdaptiveIHOPControl::update_marking_length(double marking_length_s) {\n-   assert(marking_length_s >= 0.0, \"Marking length must be larger than zero but is %.3f\", marking_length_s);\n-  _marking_times_s.add(marking_length_s);\n-}\n+void G1IHOPControl::print_log(size_t non_young_occupancy) {\n+  assert(_target_occupancy > 0, \"Target occupancy still not updated yet.\");\n+  size_t cur_conc_mark_start_threshold = get_conc_mark_start_threshold();\n+  log_debug(gc, ihop)(\"Basic information (value update), threshold: %zuB (%1.2f), target occupancy: %zuB, non-young occupancy: %zuB, \"\n+                      \"recent allocation size: %zuB, recent allocation duration: %1.2fms, recent old gen allocation rate: %1.2fB\/s, recent marking phase length: %1.2fms\",\n+                      cur_conc_mark_start_threshold,\n+                      percent_of(cur_conc_mark_start_threshold, _target_occupancy),\n+                      _target_occupancy,\n+                      non_young_occupancy,\n+                      _old_gen_alloc_tracker->last_period_old_gen_bytes(),\n+                      _last_allocation_time_s * 1000.0,\n+                      _last_allocation_time_s > 0.0 ? _old_gen_alloc_tracker->last_period_old_gen_bytes() \/ _last_allocation_time_s : 0.0,\n+                      last_marking_length_s() * 1000.0);\n+\n+  if (!_is_adaptive) {\n+    return;\n+  }\n@@ -173,2 +150,0 @@\n-void G1AdaptiveIHOPControl::print_log(size_t non_young_occupancy) {\n-  G1IHOPControl::print_log(non_young_occupancy);\n@@ -179,2 +154,2 @@\n-                      get_conc_mark_start_threshold(),\n-                      percent_of(get_conc_mark_start_threshold(), actual_threshold),\n+                      cur_conc_mark_start_threshold,\n+                      percent_of(cur_conc_mark_start_threshold, actual_threshold),\n@@ -189,9 +164,18 @@\n-void G1AdaptiveIHOPControl::send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy) {\n-  G1IHOPControl::send_trace_event(tracer, non_young_occupancy);\n-  tracer->report_adaptive_ihop_statistics(get_conc_mark_start_threshold(),\n-                                          actual_target_threshold(),\n-                                          non_young_occupancy,\n-                                          _last_unrestrained_young_size,\n-                                          predict(&_allocation_rate_s),\n-                                          predict(&_marking_times_s),\n-                                          have_enough_data_for_prediction());\n+void G1IHOPControl::send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy) {\n+  assert(_target_occupancy > 0, \"Target occupancy still not updated yet.\");\n+  tracer->report_basic_ihop_statistics(get_conc_mark_start_threshold(),\n+                                       _target_occupancy,\n+                                       non_young_occupancy,\n+                                       _old_gen_alloc_tracker->last_period_old_gen_bytes(),\n+                                       _last_allocation_time_s,\n+                                       last_marking_length_s());\n+\n+  if (_is_adaptive) {\n+    tracer->report_adaptive_ihop_statistics(get_conc_mark_start_threshold(),\n+                                            actual_target_threshold(),\n+                                            non_young_occupancy,\n+                                            _last_unrestrained_young_size,\n+                                            predict(&_allocation_rate_s),\n+                                            predict(&_marking_times_s),\n+                                            have_enough_data_for_prediction());\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1IHOPControl.cpp","additions":105,"deletions":121,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -35,3 +35,4 @@\n-\/\/ Base class for algorithms that calculate the heap occupancy at which\n-\/\/ concurrent marking should start. This heap usage threshold should be relative\n-\/\/ to old gen size.\n+\/\/ Implements two strategies for calculating the concurrent mark starting occupancy threshold:\n+\/\/ - Static mode: Uses a fixed percentage of the target heap occupancy.\n+\/\/ - Adaptive mode: Predicts a threshold based on allocation rates and marking durations\n+\/\/   to ensure the target occupancy is never exceeded during marking.\n@@ -39,1 +40,3 @@\n- protected:\n+ private:\n+  const bool _is_adaptive;\n+\n@@ -42,0 +45,1 @@\n+\n@@ -46,0 +50,6 @@\n+  \/\/ Percentage of maximum heap capacity we should avoid to touch\n+  const size_t _heap_reserve_percent;\n+\n+  \/\/ Percentage of free heap that should be considered as waste.\n+  const size_t _heap_waste_percent;\n+\n@@ -48,1 +58,0 @@\n-\n@@ -50,67 +59,0 @@\n-  \/\/ Initialize an instance with the old gen allocation tracker and the\n-  \/\/ initial IHOP value in percent. The target occupancy will be updated\n-  \/\/ at the first heap expansion.\n-  G1IHOPControl(double ihop_percent, G1OldGenAllocationTracker const* old_gen_alloc_tracker);\n-\n-  \/\/ Most recent time from the end of the concurrent start to the start of the first\n-  \/\/ mixed gc.\n-  virtual double last_marking_length_s() const = 0;\n-\n-  virtual void print_log(size_t non_young_occupancy);\n-  virtual void send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy);\n-\n-public:\n-  virtual ~G1IHOPControl() { }\n-\n-  \/\/ Get the current non-young occupancy at which concurrent marking should start.\n-  virtual size_t get_conc_mark_start_threshold() = 0;\n-\n-  \/\/ Adjust target occupancy.\n-  virtual void update_target_occupancy(size_t new_target_occupancy);\n-  \/\/ Update information about time during which allocations in the Java heap occurred,\n-  \/\/ how large these allocations were in bytes, and an additional buffer.\n-  \/\/ The allocations should contain any amount of space made unusable for further\n-  \/\/ allocation, e.g. any waste caused by TLAB allocation, space at the end of\n-  \/\/ humongous objects that can not be used for allocation, etc.\n-  \/\/ Together with the target occupancy, this additional buffer should contain the\n-  \/\/ difference between old gen size and total heap size at the start of reclamation,\n-  \/\/ and space required for that reclamation.\n-  virtual void update_allocation_info(double allocation_time_s, size_t additional_buffer_size);\n-  \/\/ Update the time spent in the mutator beginning from the end of concurrent start to\n-  \/\/ the first mixed gc.\n-  virtual void update_marking_length(double marking_length_s) = 0;\n-\n-  void report_statistics(G1NewTracer* tracer, size_t non_young_occupancy);\n-};\n-\n-\/\/ The returned concurrent mark starting occupancy threshold is a fixed value\n-\/\/ relative to the maximum heap size.\n-class G1StaticIHOPControl : public G1IHOPControl {\n-  \/\/ Most recent mutator time between the end of concurrent mark to the start of the\n-  \/\/ first mixed gc.\n-  double _last_marking_length_s;\n- protected:\n-  double last_marking_length_s() const { return _last_marking_length_s; }\n- public:\n-  G1StaticIHOPControl(double ihop_percent, G1OldGenAllocationTracker const* old_gen_alloc_tracker);\n-\n-  size_t get_conc_mark_start_threshold() {\n-    guarantee(_target_occupancy > 0, \"Target occupancy must have been initialized.\");\n-    return (size_t) (_initial_ihop_percent * _target_occupancy \/ 100.0);\n-  }\n-\n-  virtual void update_marking_length(double marking_length_s) {\n-   assert(marking_length_s > 0.0, \"Marking length must be larger than zero but is %.3f\", marking_length_s);\n-    _last_marking_length_s = marking_length_s;\n-  }\n-};\n-\n-\/\/ This algorithm tries to return a concurrent mark starting occupancy value that\n-\/\/ makes sure that during marking the given target occupancy is never exceeded,\n-\/\/ based on predictions of current allocation rate and time periods between\n-\/\/ concurrent start and the first mixed gc.\n-class G1AdaptiveIHOPControl : public G1IHOPControl {\n-  size_t _heap_reserve_percent; \/\/ Percentage of maximum heap capacity we should avoid to touch\n-  size_t _heap_waste_percent;   \/\/ Percentage of free heap that should be considered as waste.\n-\n-  const G1Predictions * _predictor;\n@@ -118,0 +60,1 @@\n+  const G1Predictions* _predictor;\n@@ -131,1 +74,1 @@\n-  double predict(TruncatedSeq const* seq) const;\n+  double predict(const TruncatedSeq* seq) const;\n@@ -134,0 +77,1 @@\n+  double last_marking_length_s() const;\n@@ -140,8 +84,2 @@\n-  \/\/ This method calculates the old gen allocation rate based on the net survived\n-  \/\/ bytes that are allocated in the old generation in the last mutator period.\n-  double last_mutator_period_old_allocation_rate() const;\n- protected:\n-  virtual double last_marking_length_s() const { return _marking_times_s.last(); }\n-\n-  virtual void print_log(size_t non_young_occupancy);\n-  virtual void send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy);\n+ void print_log(size_t non_young_occupancy);\n+ void send_trace_event(G1NewTracer* tracer, size_t non_young_occupancy);\n@@ -150,5 +88,23 @@\n-  G1AdaptiveIHOPControl(double ihop_percent,\n-                        G1OldGenAllocationTracker const* old_gen_alloc_tracker,\n-                        G1Predictions const* predictor,\n-                        size_t heap_reserve_percent, \/\/ The percentage of total heap capacity that should not be tapped into.\n-                        size_t heap_waste_percent);  \/\/ The percentage of the free space in the heap that we think is not usable for allocation.\n+  G1IHOPControl(double ihop_percent,\n+                const G1OldGenAllocationTracker* old_gen_alloc_tracker,\n+                bool adaptive,\n+                const G1Predictions* predictor,\n+                size_t heap_reserve_percent,\n+                size_t heap_waste_percent);\n+\n+  \/\/ Adjust target occupancy.\n+  void update_target_occupancy(size_t new_target_occupancy);\n+\n+  \/\/ Update information about time during which allocations in the Java heap occurred,\n+  \/\/ how large these allocations were in bytes, and an additional buffer.\n+  \/\/ The allocations should contain any amount of space made unusable for further\n+  \/\/ allocation, e.g. any waste caused by TLAB allocation, space at the end of\n+  \/\/ humongous objects that can not be used for allocation, etc.\n+  \/\/ Together with the target occupancy, this additional buffer should contain the\n+  \/\/ difference between old gen size and total heap size at the start of reclamation,\n+  \/\/ and space required for that reclamation.\n+  void update_allocation_info(double allocation_time_s, size_t additional_buffer_size);\n+\n+  \/\/ Update the time spent in the mutator beginning from the end of concurrent start to\n+  \/\/ the first mixed gc.\n+  void update_marking_length(double marking_length_s);\n@@ -156,1 +112,2 @@\n-  virtual size_t get_conc_mark_start_threshold();\n+  \/\/ Get the current non-young occupancy at which concurrent marking should start.\n+  size_t get_conc_mark_start_threshold();\n@@ -158,2 +115,1 @@\n-  virtual void update_allocation_info(double allocation_time_s, size_t additional_buffer_size);\n-  virtual void update_marking_length(double marking_length_s);\n+  void report_statistics(G1NewTracer* tracer, size_t non_young_occupancy);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1IHOPControl.hpp","additions":45,"deletions":89,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-class G1AdaptiveIHOPControl;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OldGenAllocationTracker.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1029,9 +1029,6 @@\n-  if (G1UseAdaptiveIHOP) {\n-    return new G1AdaptiveIHOPControl(InitiatingHeapOccupancyPercent,\n-                                     old_gen_alloc_tracker,\n-                                     predictor,\n-                                     G1ReservePercent,\n-                                     G1HeapWastePercent);\n-  } else {\n-    return new G1StaticIHOPControl(InitiatingHeapOccupancyPercent, old_gen_alloc_tracker);\n-  }\n+  return new G1IHOPControl(InitiatingHeapOccupancyPercent,\n+                           old_gen_alloc_tracker,\n+                           G1UseAdaptiveIHOP,\n+                           predictor,\n+                           G1ReservePercent,\n+                           G1HeapWastePercent);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-TEST_VM(G1StaticIHOPControl, simple) {\n+TEST_VM(G1IHOPControl, static_simple) {\n@@ -70,1 +70,1 @@\n-\n+  const bool is_adaptive = false;\n@@ -74,1 +74,1 @@\n-  G1StaticIHOPControl ctrl(initial_ihop, &alloc_tracker);\n+  G1IHOPControl ctrl(initial_ihop, &alloc_tracker, is_adaptive, nullptr, 0, 0);\n@@ -102,1 +102,1 @@\n-TEST_VM(G1AdaptiveIHOPControl, simple) {\n+TEST_VM(G1IHOPControl, adaptive_simple) {\n@@ -108,0 +108,1 @@\n+  const bool is_adaptive = true;\n@@ -117,1 +118,1 @@\n-  G1AdaptiveIHOPControl ctrl(initial_threshold, &alloc_tracker, &pred, 0, 0);\n+  G1IHOPControl ctrl(initial_threshold, &alloc_tracker, is_adaptive, &pred, 0, 0);\n@@ -180,1 +181,1 @@\n-TEST_VM(G1AdaptiveIHOPControl, humongous) {\n+TEST_VM(G1IHOPControl, adaptive_humongous) {\n@@ -186,0 +187,1 @@\n+  const bool is_adaptive = true;\n@@ -194,1 +196,1 @@\n-  G1AdaptiveIHOPControl ctrl(initial_threshold, &alloc_tracker, &pred, 0, 0);\n+  G1IHOPControl ctrl(initial_threshold, &alloc_tracker, is_adaptive, &pred, 0, 0);\n@@ -216,1 +218,1 @@\n-  G1AdaptiveIHOPControl ctrl2(initial_threshold, &alloc_tracker, &pred, 0, 0);\n+  G1IHOPControl ctrl2(initial_threshold, &alloc_tracker, is_adaptive, &pred, 0, 0);\n@@ -232,1 +234,1 @@\n-  G1AdaptiveIHOPControl ctrl3(initial_threshold, &alloc_tracker, &pred, 0, 0);\n+  G1IHOPControl ctrl3(initial_threshold, &alloc_tracker, is_adaptive, &pred, 0, 0);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1IHOPControl.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"}]}