{"files":[{"patch":"@@ -580,1 +580,1 @@\n-    public static final Binary SUADD = binary(\"SUADD\", \"+\", VectorSupport.VECTOR_OP_SUADD, VO_NOFP);\n+    public static final Associative SUADD = assoc(\"SUADD\", \"+\", VectorSupport.VECTOR_OP_SUADD, VO_NOFP+VO_ASSOC);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -408,0 +408,46 @@\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1019,0 +1065,15 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(-1));\n+            })\n+    );\n+\n@@ -1031,0 +1092,6 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(BYTE_GENERATORS.get(1))\n+                    .flatMap(fa -> BYTE_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> BYTE_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1067,0 +1134,16 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocProvider() {\n+        return BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3423,0 +3506,45 @@\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocByte128VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Byte128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                     IntFunction<byte[]> fc, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Byte128VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -408,0 +408,46 @@\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1019,0 +1065,15 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(-1));\n+            })\n+    );\n+\n@@ -1031,0 +1092,6 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(BYTE_GENERATORS.get(1))\n+                    .flatMap(fa -> BYTE_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> BYTE_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1067,0 +1134,16 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocProvider() {\n+        return BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3423,0 +3506,45 @@\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocByte256VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Byte256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                     IntFunction<byte[]> fc, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Byte256VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -408,0 +408,46 @@\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1019,0 +1065,15 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(-1));\n+            })\n+    );\n+\n@@ -1031,0 +1092,6 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(BYTE_GENERATORS.get(1))\n+                    .flatMap(fa -> BYTE_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> BYTE_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1067,0 +1134,16 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocProvider() {\n+        return BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3423,0 +3506,45 @@\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocByte512VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Byte512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                     IntFunction<byte[]> fc, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Byte512VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -408,0 +408,46 @@\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1019,0 +1065,15 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(-1));\n+            })\n+    );\n+\n@@ -1031,0 +1092,6 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(BYTE_GENERATORS.get(1))\n+                    .flatMap(fa -> BYTE_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> BYTE_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1067,0 +1134,16 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocProvider() {\n+        return BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3423,0 +3506,45 @@\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocByte64VectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Byte64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                     IntFunction<byte[]> fc, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Byte64VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -413,0 +413,46 @@\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1024,0 +1070,15 @@\n+    static final List<IntFunction<byte[]>> BYTE_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"byte[Byte.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE));\n+            }),\n+            withToString(\"byte[Byte.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(Byte.MAX_VALUE - 100));\n+            }),\n+            withToString(\"byte[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (byte)(-1));\n+            })\n+    );\n+\n@@ -1036,0 +1097,6 @@\n+    static final List<List<IntFunction<byte[]>>> BYTE_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(BYTE_GENERATORS.get(1))\n+                    .flatMap(fa -> BYTE_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> BYTE_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1072,0 +1139,16 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocProvider() {\n+        return BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3428,0 +3511,45 @@\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocByteMaxVectorTests(IntFunction<byte[]> fa, IntFunction<byte[]> fb, IntFunction<byte[]> fc) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, ByteMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                     IntFunction<byte[]> fc, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, ByteMaxVectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -426,0 +426,46 @@\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -426,0 +426,46 @@\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -426,0 +426,46 @@\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -426,0 +426,46 @@\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -431,0 +431,46 @@\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -426,0 +426,46 @@\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -426,0 +426,46 @@\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -426,0 +426,46 @@\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -426,0 +426,46 @@\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -429,0 +429,46 @@\n+    }\n+\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -408,0 +408,46 @@\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1009,0 +1055,15 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(-1));\n+            })\n+    );\n+\n@@ -1021,0 +1082,6 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(INT_GENERATORS.get(1))\n+                    .flatMap(fa -> INT_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> INT_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1057,0 +1124,16 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocProvider() {\n+        return INT_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3467,0 +3550,45 @@\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocInt128VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Int128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                     IntFunction<int[]> fc, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Int128VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -408,0 +408,46 @@\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1009,0 +1055,15 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(-1));\n+            })\n+    );\n+\n@@ -1021,0 +1082,6 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(INT_GENERATORS.get(1))\n+                    .flatMap(fa -> INT_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> INT_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1057,0 +1124,16 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocProvider() {\n+        return INT_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3467,0 +3550,45 @@\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocInt256VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Int256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                     IntFunction<int[]> fc, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Int256VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -408,0 +408,46 @@\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1009,0 +1055,15 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(-1));\n+            })\n+    );\n+\n@@ -1021,0 +1082,6 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(INT_GENERATORS.get(1))\n+                    .flatMap(fa -> INT_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> INT_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1057,0 +1124,16 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocProvider() {\n+        return INT_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3467,0 +3550,45 @@\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocInt512VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Int512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                     IntFunction<int[]> fc, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Int512VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -408,0 +408,46 @@\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1009,0 +1055,15 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(-1));\n+            })\n+    );\n+\n@@ -1021,0 +1082,6 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(INT_GENERATORS.get(1))\n+                    .flatMap(fa -> INT_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> INT_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1057,0 +1124,16 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocProvider() {\n+        return INT_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3467,0 +3550,45 @@\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocInt64VectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Int64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                     IntFunction<int[]> fc, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Int64VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -413,0 +413,46 @@\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1014,0 +1060,15 @@\n+    static final List<IntFunction<int[]>> INT_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"int[Integer.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE));\n+            }),\n+            withToString(\"int[Integer.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(Integer.MAX_VALUE - 100));\n+            }),\n+            withToString(\"int[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (int)(-1));\n+            })\n+    );\n+\n@@ -1026,0 +1087,6 @@\n+    static final List<List<IntFunction<int[]>>> INT_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(INT_GENERATORS.get(1))\n+                    .flatMap(fa -> INT_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> INT_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1062,0 +1129,16 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocProvider() {\n+        return INT_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3472,0 +3555,45 @@\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocIntMaxVectorTests(IntFunction<int[]> fa, IntFunction<int[]> fb, IntFunction<int[]> fc) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, IntMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                     IntFunction<int[]> fc, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, IntMaxVectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -365,0 +365,46 @@\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -999,0 +1045,15 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(-1));\n+            })\n+    );\n+\n@@ -1011,0 +1072,6 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(LONG_GENERATORS.get(1))\n+                    .flatMap(fa -> LONG_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> LONG_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1047,0 +1114,16 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocProvider() {\n+        return LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3489,0 +3572,45 @@\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocLong128VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Long128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                     IntFunction<long[]> fc, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Long128VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -365,0 +365,46 @@\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -999,0 +1045,15 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(-1));\n+            })\n+    );\n+\n@@ -1011,0 +1072,6 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(LONG_GENERATORS.get(1))\n+                    .flatMap(fa -> LONG_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> LONG_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1047,0 +1114,16 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocProvider() {\n+        return LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3489,0 +3572,45 @@\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocLong256VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Long256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                     IntFunction<long[]> fc, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Long256VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -365,0 +365,46 @@\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -999,0 +1045,15 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(-1));\n+            })\n+    );\n+\n@@ -1011,0 +1072,6 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(LONG_GENERATORS.get(1))\n+                    .flatMap(fa -> LONG_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> LONG_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1047,0 +1114,16 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocProvider() {\n+        return LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3489,0 +3572,45 @@\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocLong512VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Long512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                     IntFunction<long[]> fc, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Long512VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -365,0 +365,46 @@\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -999,0 +1045,15 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(-1));\n+            })\n+    );\n+\n@@ -1011,0 +1072,6 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(LONG_GENERATORS.get(1))\n+                    .flatMap(fa -> LONG_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> LONG_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1047,0 +1114,16 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocProvider() {\n+        return LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3489,0 +3572,45 @@\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocLong64VectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Long64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                     IntFunction<long[]> fc, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Long64VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -370,0 +370,46 @@\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1004,0 +1050,15 @@\n+    static final List<IntFunction<long[]>> LONG_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"long[Long.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE));\n+            }),\n+            withToString(\"long[Long.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(Long.MAX_VALUE - 100));\n+            }),\n+            withToString(\"long[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (long)(-1));\n+            })\n+    );\n+\n@@ -1016,0 +1077,6 @@\n+    static final List<List<IntFunction<long[]>>> LONG_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(LONG_GENERATORS.get(1))\n+                    .flatMap(fa -> LONG_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> LONG_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1052,0 +1119,16 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocProvider() {\n+        return LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3494,0 +3577,45 @@\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocLongMaxVectorTests(IntFunction<long[]> fa, IntFunction<long[]> fb, IntFunction<long[]> fc) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, LongMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                     IntFunction<long[]> fc, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, LongMaxVectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -408,0 +408,46 @@\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1009,0 +1055,15 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-1));\n+            })\n+    );\n+\n@@ -1021,0 +1082,6 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(SHORT_GENERATORS.get(1))\n+                    .flatMap(fa -> SHORT_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> SHORT_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1057,0 +1124,16 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocProvider() {\n+        return SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3414,0 +3497,45 @@\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocShort128VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Short128VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                     IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Short128VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -408,0 +408,46 @@\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1009,0 +1055,15 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-1));\n+            })\n+    );\n+\n@@ -1021,0 +1082,6 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(SHORT_GENERATORS.get(1))\n+                    .flatMap(fa -> SHORT_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> SHORT_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1057,0 +1124,16 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocProvider() {\n+        return SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3414,0 +3497,45 @@\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocShort256VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Short256VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                     IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Short256VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -408,0 +408,46 @@\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1009,0 +1055,15 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-1));\n+            })\n+    );\n+\n@@ -1021,0 +1082,6 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(SHORT_GENERATORS.get(1))\n+                    .flatMap(fa -> SHORT_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> SHORT_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1057,0 +1124,16 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocProvider() {\n+        return SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3414,0 +3497,45 @@\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocShort512VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Short512VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                     IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Short512VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -408,0 +408,46 @@\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1009,0 +1055,15 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-1));\n+            })\n+    );\n+\n@@ -1021,0 +1082,6 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(SHORT_GENERATORS.get(1))\n+                    .flatMap(fa -> SHORT_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> SHORT_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1057,0 +1124,16 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocProvider() {\n+        return SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3414,0 +3497,45 @@\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocShort64VectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, Short64VectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                     IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Short64VectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -413,0 +413,46 @@\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1014,0 +1060,15 @@\n+    static final List<IntFunction<short[]>> SHORT_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"short[Short.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE));\n+            }),\n+            withToString(\"short[Short.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(Short.MAX_VALUE - 100));\n+            }),\n+            withToString(\"short[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> (short)(-1));\n+            })\n+    );\n+\n@@ -1026,0 +1087,6 @@\n+    static final List<List<IntFunction<short[]>>> SHORT_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of(SHORT_GENERATORS.get(1))\n+                    .flatMap(fa -> SHORT_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> SHORT_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1062,0 +1129,16 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocProvider() {\n+        return SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n@@ -3419,0 +3502,45 @@\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocProvider\")\n+    static void SUADDAssocShortMaxVectorTests(IntFunction<short[]> fa, IntFunction<short[]> fb, IntFunction<short[]> fc) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, ShortMaxVectorTests::SUADD);\n+    }\n+\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                     IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, ShortMaxVectorTests::SUADD);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+saturating_binary_assocative=\"SaturatingBinary-op-associative\"\n+saturating_binary_assocative_masked=\"SaturatingBinary-Masked-op-associative\"\n@@ -329,0 +331,6 @@\n+function gen_saturating_binary_op_associative {\n+  echo \"Generating saturating binary associative op $1 ($2)...\"\n+  gen_op_tmpl $saturating_binary_assocative \"$@\"\n+  gen_op_tmpl $saturating_binary_assocative_masked \"$@\"\n+}\n+\n@@ -490,0 +498,1 @@\n+gen_saturating_binary_op_associative \"SUADD\" \"VectorMath.addSaturatingUnsigned(a, b)\" \"BITWISE\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,18 @@\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        $type$[] rl = fr.apply(SPECIES.length());\n+        $type$[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingBinary-Masked-op-associative.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        $type$[] rl = fr.apply(SPECIES.length());\n+        $type$[] rr = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $Type$Vector av = $Type$Vector.fromArray(SPECIES, a, i);\n+                $Type$Vector bv = $Type$Vector.fromArray(SPECIES, b, i);\n+                $Type$Vector cv = $Type$Vector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv).lanewise(VectorOperators.SUADD, cv).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv)).intoArray(rr, i);\n+            }\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingBinary-op-associative.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+\n+    @Test(dataProvider = \"$type$SaturatingBinaryOpAssocMaskProvider\")\n+    static void [[TEST]]Assoc$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                                     IntFunction<$type$[]> fc, IntFunction<boolean[]> fm) {\n+[[KERNEL]]\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, $vectorteststype$::[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-SaturatingBinary-Masked-op-associative.template","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+    @Test(dataProvider = \"$type$SaturatingBinaryOpAssocProvider\")\n+    static void [[TEST]]Assoc$vectorteststype$(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb, IntFunction<$type$[]> fc) {\n+[[KERNEL]]\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, $vectorteststype$::[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-SaturatingBinary-op-associative.template","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -505,0 +505,46 @@\n+    static void assertArraysEqualsAssociative($type$[] rl, $type$[] rr, $type$[] a, $type$[] b, $type$[] c, FBinOp f) {\n+        int i = 0;\n+        try {\n+            for (; i < a.length; i++) {\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i]), c[i]), \"left associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i])), \"right associative test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i]);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative($type$[] rl, $type$[] rr, $type$[] a, $type$[] b, $type$[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative($type$[] rl, $type$[] rr, $type$[] a, $type$[] b, $type$[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1281,0 +1327,15 @@\n+    static final List<IntFunction<$type$[]>> $TYPE$_SATURATING_GENERATORS_ASSOC = List.of(\n+            withToString(\"$type$[$Boxtype$.MAX_VALUE]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MAX_VALUE));\n+            }),\n+            withToString(\"$type$[$Boxtype$.MAX_VALUE - 100]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)($Boxtype$.MAX_VALUE - 100));\n+            }),\n+            withToString(\"$type$[-1]\", (int s) -> {\n+                return fill(s * BUFFER_REPS,\n+                            i -> ($type$)(-1));\n+            })\n+    );\n+\n@@ -1295,0 +1356,6 @@\n+    static final List<List<IntFunction<$type$[]>>> $TYPE$_SATURATING_GENERATOR_TRIPLETS =\n+            Stream.of($TYPE$_GENERATORS.get(1))\n+                    .flatMap(fa -> $TYPE$_SATURATING_GENERATORS_ASSOC.stream().map(fb -> List.of(fa, fb)))\n+                    .flatMap(pair -> $TYPE$_SATURATING_GENERATORS_ASSOC.stream().map(f -> List.of(pair.get(0), pair.get(1), f)))\n+                    .collect(Collectors.toList());\n+\n@@ -1333,0 +1400,16 @@\n+    @DataProvider\n+    public Object[][] $type$SaturatingBinaryOpAssocProvider() {\n+        return $TYPE$_SATURATING_GENERATOR_TRIPLETS.stream().map(List::toArray).\n+                toArray(Object[][]::new);\n+    }\n+\n+    @DataProvider\n+    public Object[][] $type$SaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> $TYPE$_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":83,"deletions":0,"binary":false,"changes":83,"status":"modified"}]}