{"files":[{"patch":"@@ -428,0 +428,26 @@\n+   static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1098,0 +1124,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3476,0 +3511,25 @@\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocByte128VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                     IntFunction<byte[]> fc, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Byte128VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -428,0 +428,26 @@\n+   static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1098,0 +1124,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3476,0 +3511,25 @@\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocByte256VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                     IntFunction<byte[]> fc, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Byte256VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -428,0 +428,26 @@\n+   static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1098,0 +1124,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3476,0 +3511,25 @@\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocByte512VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                     IntFunction<byte[]> fc, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Byte512VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -428,0 +428,26 @@\n+   static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1098,0 +1124,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3476,0 +3511,25 @@\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocByte64VectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                     IntFunction<byte[]> fc, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Byte64VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -433,0 +433,26 @@\n+   static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(byte[] rl, byte[] rr, byte[] a, byte[] b, byte[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1103,0 +1129,9 @@\n+    @DataProvider\n+    public Object[][] byteSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> BYTE_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3481,0 +3516,25 @@\n+    @Test(dataProvider = \"byteSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocByteMaxVectorTestsMasked(IntFunction<byte[]> fa, IntFunction<byte[]> fb,\n+                                                     IntFunction<byte[]> fc, IntFunction<boolean[]> fm) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        byte[] rl = fr.apply(SPECIES.length());\n+        byte[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, ByteMaxVectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ByteMaxVectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -446,0 +446,26 @@\n+   static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -446,0 +446,26 @@\n+   static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -446,0 +446,26 @@\n+   static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -446,0 +446,26 @@\n+   static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -448,0 +448,26 @@\n+        }\n+    }\n+\n+   static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(double[] rl, double[] rr, double[] a, double[] b, double[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n","filename":"test\/jdk\/jdk\/incubator\/vector\/DoubleMaxVectorTests.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -446,0 +446,26 @@\n+   static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -446,0 +446,26 @@\n+   static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -446,0 +446,26 @@\n+   static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -446,0 +446,26 @@\n+   static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -449,0 +449,26 @@\n+    }\n+\n+   static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(float[] rl, float[] rr, float[] a, float[] b, float[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/FloatMaxVectorTests.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -428,0 +428,26 @@\n+   static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1088,0 +1114,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3520,0 +3555,25 @@\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocInt128VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                     IntFunction<int[]> fc, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Int128VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -428,0 +428,26 @@\n+   static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1088,0 +1114,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3520,0 +3555,25 @@\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocInt256VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                     IntFunction<int[]> fc, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Int256VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -428,0 +428,26 @@\n+   static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1088,0 +1114,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3520,0 +3555,25 @@\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocInt512VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                     IntFunction<int[]> fc, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Int512VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -428,0 +428,26 @@\n+   static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1088,0 +1114,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3520,0 +3555,25 @@\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocInt64VectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                     IntFunction<int[]> fc, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Int64VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -433,0 +433,26 @@\n+   static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(int[] rl, int[] rr, int[] a, int[] b, int[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1093,0 +1119,9 @@\n+    @DataProvider\n+    public Object[][] intSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> INT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3525,0 +3560,25 @@\n+    @Test(dataProvider = \"intSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocIntMaxVectorTestsMasked(IntFunction<int[]> fa, IntFunction<int[]> fb,\n+                                                     IntFunction<int[]> fc, IntFunction<boolean[]> fm) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        int[] rl = fr.apply(SPECIES.length());\n+        int[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, IntMaxVectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/IntMaxVectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -385,0 +385,26 @@\n+   static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1078,0 +1104,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3542,0 +3577,25 @@\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocLong128VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                     IntFunction<long[]> fc, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Long128VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -385,0 +385,26 @@\n+   static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1078,0 +1104,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3542,0 +3577,25 @@\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocLong256VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                     IntFunction<long[]> fc, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Long256VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -385,0 +385,26 @@\n+   static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1078,0 +1104,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3542,0 +3577,25 @@\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocLong512VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                     IntFunction<long[]> fc, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Long512VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -385,0 +385,26 @@\n+   static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1078,0 +1104,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3542,0 +3577,25 @@\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocLong64VectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                     IntFunction<long[]> fc, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Long64VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -390,0 +390,26 @@\n+   static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(long[] rl, long[] rr, long[] a, long[] b, long[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1083,0 +1109,9 @@\n+    @DataProvider\n+    public Object[][] longSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> LONG_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3547,0 +3582,25 @@\n+    @Test(dataProvider = \"longSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocLongMaxVectorTestsMasked(IntFunction<long[]> fa, IntFunction<long[]> fb,\n+                                                     IntFunction<long[]> fc, IntFunction<boolean[]> fm) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        long[] rl = fr.apply(SPECIES.length());\n+        long[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, LongMaxVectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/LongMaxVectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -428,0 +428,26 @@\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1088,0 +1114,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3467,0 +3502,25 @@\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocShort128VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                     IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Short128VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -428,0 +428,26 @@\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1088,0 +1114,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3467,0 +3502,25 @@\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocShort256VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                     IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Short256VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -428,0 +428,26 @@\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1088,0 +1114,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3467,0 +3502,25 @@\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocShort512VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                     IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Short512VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -428,0 +428,26 @@\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1088,0 +1114,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3467,0 +3502,25 @@\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocShort64VectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                     IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, Short64VectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -433,0 +433,26 @@\n+   static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative(short[] rl, short[] rr, short[] a, short[] b, short[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1093,0 +1119,9 @@\n+    @DataProvider\n+    public Object[][] shortSaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> SHORT_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n@@ -3472,0 +3507,25 @@\n+    @Test(dataProvider = \"shortSaturatingBinaryOpAssocMaskProvider\")\n+    static void SUADDAssocShortMaxVectorTestsMasked(IntFunction<short[]> fa, IntFunction<short[]> fb,\n+                                                     IntFunction<short[]> fc, IntFunction<boolean[]> fm) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        short[] rl = fr.apply(SPECIES.length());\n+        short[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n+\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, ShortMaxVectorTests::SUADD);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/ShortMaxVectorTests.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+saturating_binary_assocative_masked=\"SaturatingBinary-Masked-op-associative\"\n@@ -333,0 +334,1 @@\n+  gen_op_tmpl $saturating_binary_assocative_masked \"$@\"\n","filename":"test\/jdk\/jdk\/incubator\/vector\/gen-template.sh","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,18 @@\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$[] b = fb.apply(SPECIES.length());\n+        $type$[] c = fc.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        $type$[] rl = fr.apply(SPECIES.length());\n+        $type$[] rr = fr.apply(SPECIES.length());\n+\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+                $abstractvectortype$ cv = $abstractvectortype$.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).lanewise(VectorOperators.SUADD, cv, vmask).intoArray(rl, i);\n+                av.lanewise(VectorOperators.SUADD, bv.lanewise(VectorOperators.SUADD, cv, vmask), vmask).intoArray(rr, i);\n+            }\n+        }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Kernel-SaturatingBinary-Masked-op-associative.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -0,0 +1,7 @@\n+\n+    @Test(dataProvider = \"$type$SaturatingBinaryOpAssocMaskProvider\")\n+    static void [[TEST]]Assoc$vectorteststype$Masked(IntFunction<$type$[]> fa, IntFunction<$type$[]> fb,\n+                                                     IntFunction<$type$[]> fc, IntFunction<boolean[]> fm) {\n+[[KERNEL]]\n+        assertArraysEqualsAssociative(rl, rr, a, b, c, mask, $vectorteststype$::[[TEST]]);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-SaturatingBinary-Masked-op-associative.template","additions":7,"deletions":0,"binary":false,"changes":7,"status":"added"},{"patch":"@@ -525,0 +525,26 @@\n+   static void assertArraysEqualsAssociative($type$[] rl, $type$[] rr, $type$[] a, $type$[] b, $type$[] c, boolean[] mask, FBinOp f) {\n+       assertArraysEqualsAssociative(rl, rr, a, b, c, mask, FBinMaskOp.lift(f));\n+   }\n+\n+    static void assertArraysEqualsAssociative($type$[] rl, $type$[] rr, $type$[] a, $type$[] b, $type$[] c, boolean[] mask, FBinMaskOp f) {\n+        int i = 0;\n+        boolean mask_bit = false;\n+        try {\n+            for (; i < a.length; i++) {\n+                mask_bit = mask[i % SPECIES.length()];\n+                \/\/Left associative\n+                Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit));\n+\n+                \/\/Right associative\n+                Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit));\n+\n+                \/\/Results equal sanity check\n+                Assert.assertEquals(rl[i], rr[i]);\n+            }\n+        } catch (AssertionError e) {\n+            Assert.assertEquals(rl[i], f.apply(f.apply(a[i], b[i], mask_bit), c[i], mask_bit), \"left associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rr[i], f.apply(a[i], f.apply(b[i], c[i], mask_bit), mask_bit), \"right associative masked test at index #\" + i + \", input1 = \" + a[i] + \", input2 = \" + b[i] + \", input3 = \" + c[i] + \", mask = \" + mask_bit);\n+            Assert.assertEquals(rl[i], rr[i], \"Result checks not equal at index #\" + i + \"leftRes = \" + rl[i] + \", rightRes = \" + rr[i]);\n+        }\n+    }\n+\n@@ -1364,0 +1390,9 @@\n+    @DataProvider\n+    public Object[][] $type$SaturatingBinaryOpAssocMaskProvider() {\n+        return BOOLEAN_MASK_GENERATORS.stream().\n+                flatMap(fm -> $TYPE$_SATURATING_GENERATOR_TRIPLETS.stream().map(lfa -> {\n+                    return Stream.concat(lfa.stream(), Stream.of(fm)).toArray();\n+                })).\n+                toArray(Object[][]::new);\n+    }\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-header.template","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"}]}