{"files":[{"patch":"@@ -119,1 +119,1 @@\n-int LogFileStreamOutput::write_internal_lines(const LogDecorations& decorations, const char* msg, int msg_len) {\n+int LogFileStreamOutput::write_internal(const LogDecorations& decorations, const char* msg) {\n@@ -125,1 +125,0 @@\n-    int written_msg = 0;\n@@ -132,6 +131,0 @@\n-    WRITE_LOG_WITH_RESULT_CHECK(jio_fprintf(_stream, \"%s\\n\", msg), written_msg);\n-    \/\/ If we have not written the whole message length by now then we must have a multi-line message.\n-    \/\/ If we have active decorators then pad the line with an empty decorator string so\n-    \/\/ that the output lines up for clear visual reading.\n-    while (written_msg < msg_len) {\n-      msg = base + written_msg;\n@@ -139,0 +132,6 @@\n+    \/\/ Search for newlines in the string and repeatedly print the substrings that end\n+    \/\/ with each newline.\n+    const char* next = strstr(msg, \"\\n\");\n+    while (next != NULL) {  \/\/ We have some newlines to print\n+      int to_print = next - base;\n+      WRITE_LOG_WITH_RESULT_CHECK(jio_fprintf(_stream, \"%.*s\\n\", to_print, base), written);\n@@ -142,1 +141,2 @@\n-      WRITE_LOG_WITH_RESULT_CHECK(jio_fprintf(_stream, \"%s\\n\", msg), written_msg);\n+      base = next + 1;\n+      next = strstr(base, \"\\n\");\n@@ -144,1 +144,3 @@\n-    written += written_msg;\n+\n+    \/\/ Print the end of the message\n+    WRITE_LOG_WITH_RESULT_CHECK(jio_fprintf(_stream, \"%s\\n\", base), written);\n@@ -169,30 +171,0 @@\n-int LogFileStreamOutput::write_internal(const LogDecorations& decorations, const char* msg) {\n-  int msg_len = checked_cast<int>(strlen(msg));\n-\n-  \/\/ Do not handle multiline messages if foldmultilines has been specified\n-  if (_fold_multilines) return write_internal_lines(decorations, msg, msg_len);\n-\n-  \/\/ Handle multiline strings: split the string replacing newlines with terminators,\n-  \/\/ and then force write_internal_line to print all of them (i.e. not stopping at the\n-  \/\/ first null but until msg_len bytes are printed)\n-  ALLOW_C_FUNCTION(::malloc, char* dupstr = (char*)::malloc((msg_len + 1) * sizeof(char));)\n-  if (dupstr == nullptr) {\n-    return 0;\n-  }\n-  memcpy(dupstr, msg, msg_len + 1);\n-  char* tmp = dupstr;\n-\n-  char* end = dupstr + msg_len;\n-  while (tmp < end) {\n-    if (*tmp == '\\n') {\n-      *tmp = '\\0';\n-    }\n-    ++tmp;\n-  }\n-  int written = write_internal_lines(decorations, dupstr, msg_len);\n-\n-  ALLOW_C_FUNCTION(::free, ::free(dupstr);)\n-\n-  return written;\n-}\n-\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":12,"deletions":40,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -53,1 +53,0 @@\n-  int write_internal_lines(const LogDecorations& decorations, const char* msg, int msg_len);\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}