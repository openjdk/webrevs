{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.nio.file.FileSystem;\n@@ -32,1 +31,0 @@\n-import java.nio.file.FileSystems;\n@@ -37,1 +35,0 @@\n-import java.util.Collections;\n@@ -41,0 +38,1 @@\n+import java.util.Objects;\n@@ -59,1 +57,0 @@\n-    private static final int PACKAGES_LEN = PACKAGES.length();\n@@ -61,1 +58,1 @@\n-    private final FileSystem defaultFS;\n+    private final Path modulesDir;\n@@ -63,1 +60,1 @@\n-    private final Map<String, PathNode> nodes = Collections.synchronizedMap(new HashMap<>());\n+    private final Map<String, PathNode> nodes = new HashMap<>();\n@@ -67,2 +64,2 @@\n-        defaultFS = FileSystems.getDefault();\n-        String str = defaultFS.getSeparator();\n+        this.modulesDir = modulesDir;\n+        String str = modulesDir.getFileSystem().getSeparator();\n@@ -82,1 +79,1 @@\n-        PathNode(String name, Path path, BasicFileAttributes attrs) {  \/\/ path\n+        private PathNode(String name, Path path, BasicFileAttributes attrs) {  \/\/ path\n@@ -87,1 +84,1 @@\n-        PathNode(String name, Node link) {              \/\/ link\n+        private PathNode(String name, Node link) {              \/\/ link\n@@ -92,1 +89,1 @@\n-        PathNode(String name, List<Node> children) {    \/\/ dir\n+        private PathNode(String name, List<Node> children) {    \/\/ dir\n@@ -97,0 +94,5 @@\n+        @Override\n+        public boolean isResource() {\n+            return link == null && !getFileAttributes().isDirectory();\n+        }\n+\n@@ -115,1 +117,1 @@\n-        byte[] getContent() throws IOException {\n+        private byte[] getContent() throws IOException {\n@@ -129,1 +131,1 @@\n-                        p = explodedModulesDir.relativize(p);\n+                        p = modulesDir.relativize(p);\n@@ -155,1 +157,1 @@\n-    public void close() throws IOException {\n+    public synchronized void close() throws IOException {\n@@ -164,1 +166,0 @@\n-    \/\/ find Node for the given Path\n@@ -166,2 +167,2 @@\n-    public synchronized Node findNode(String str) {\n-        Node node = findModulesNode(str);\n+    public synchronized Node findNode(String name) {\n+        PathNode node = nodes.get(name);\n@@ -171,22 +172,6 @@\n-        \/\/ lazily created for paths like \/packages\/<package>\/<module>\/xyz\n-        \/\/ For example \/packages\/java.lang\/java.base\/java\/lang\/\n-        if (str.startsWith(PACKAGES)) {\n-            \/\/ pkgEndIdx marks end of <package> part\n-            int pkgEndIdx = str.indexOf('\/', PACKAGES_LEN);\n-            if (pkgEndIdx != -1) {\n-                \/\/ modEndIdx marks end of <module> part\n-                int modEndIdx = str.indexOf('\/', pkgEndIdx + 1);\n-                if (modEndIdx != -1) {\n-                    \/\/ make sure we have such module link!\n-                    \/\/ ie., \/packages\/<package>\/<module> is valid\n-                    Node linkNode = nodes.get(str.substring(0, modEndIdx));\n-                    if (linkNode == null || !linkNode.isLink()) {\n-                        return null;\n-                    }\n-                    \/\/ map to \"\/modules\/zyz\" path and return that node\n-                    \/\/ For example, \"\/modules\/java.base\/java\/lang\" for\n-                    \/\/ \"\/packages\/java.lang\/java.base\/java\/lang\".\n-                    String mod = MODULES + str.substring(pkgEndIdx + 1);\n-                    return findModulesNode(mod);\n-                }\n-            }\n+        \/\/ If null, this was not the name of \"\/modules\/...\" node, and since all\n+        \/\/ \"\/packages\/...\" nodes were created and cached in advance, the name\n+        \/\/ cannot reference a valid node.\n+        Path path = underlyingModulesPath(name);\n+        if (path == null) {\n+            return null;\n@@ -194,1 +179,2 @@\n-        return null;\n+        \/\/ This can still return null for hidden files.\n+        return createModulesNode(name, path);\n@@ -197,16 +183,23 @@\n-    \/\/ find a Node for a path that starts like \"\/modules\/...\"\n-    Node findModulesNode(String str) {\n-        PathNode node = nodes.get(str);\n-        if (node != null) {\n-            return node;\n-        }\n-        \/\/ lazily created \"\/modules\/xyz\/abc\/\" Node\n-        \/\/ This is mapped to default file system path \"<JDK_MODULES_DIR>\/xyz\/abc\"\n-        Path p = underlyingPath(str);\n-        if (p != null) {\n-            try {\n-                BasicFileAttributes attrs = Files.readAttributes(p, BasicFileAttributes.class);\n-                if (attrs.isRegularFile()) {\n-                    Path f = p.getFileName();\n-                    if (f.toString().startsWith(\"_the.\"))\n-                        return null;\n+    \/**\n+     * Lazily creates and caches a {@code Node} for the given \"\/modules\/...\" name\n+     * and corresponding path to a file or directory.\n+     *\n+     * @param name a resource or directory node name, of the form \"\/modules\/...\".\n+     * @param path the path of a file for a resource or directory.\n+     * @return the newly created and cached node, or {@code null} if the given\n+     *     path references a file which must be hidden in the node hierarchy.\n+     *\/\n+    private Node createModulesNode(String name, Path path) {\n+        assert !nodes.containsKey(name) : \"Node must not already exist: \" + name;\n+        assert isNonEmptyModulesPath(name) : \"Invalid modules name: \" + name;\n+\n+        try {\n+            \/\/ We only know if we're creating a resource of directory when we\n+            \/\/ look up file attributes, and we only do that once. Thus, we can\n+            \/\/ only reject \"marker files\" here, rather than by inspecting the\n+            \/\/ given name string, since it doesn't apply to directories.\n+            BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);\n+            if (attrs.isRegularFile()) {\n+                Path f = path.getFileName();\n+                if (f.toString().startsWith(\"_the.\")) {\n+                    return null;\n@@ -214,5 +207,2 @@\n-                node = new PathNode(str, p, attrs);\n-                nodes.put(str, node);\n-                return node;\n-            } catch (IOException x) {\n-                \/\/ does not exists or unable to determine\n+            } else if (!attrs.isDirectory()) {\n+                return null;\n@@ -220,0 +210,6 @@\n+            PathNode node = new PathNode(name, path, attrs);\n+            nodes.put(name, node);\n+            return node;\n+        } catch (IOException x) {\n+            \/\/ Since the path reference a file, any errors should not be ignored.\n+            throw new UncheckedIOException(x);\n@@ -221,1 +217,0 @@\n-        return null;\n@@ -224,4 +219,9 @@\n-    Path underlyingPath(String str) {\n-        if (str.startsWith(MODULES)) {\n-            str = frontSlashToNativeSlash(str.substring(\"\/modules\".length()));\n-            return defaultFS.getPath(explodedModulesDir.toString(), str);\n+    \/**\n+     * Returns the expected file path for name in the \"\/modules\/...\" namespace,\n+     * or {@code null} if the name is not in the \"\/modules\/...\" namespace or the\n+     * path does not reference a file.\n+     *\/\n+    private Path underlyingModulesPath(String name) {\n+        if (isNonEmptyModulesPath(name)) {\n+            Path path = modulesDir.resolve(frontSlashToNativeSlash(name.substring(MODULES.length())));\n+            return Files.exists(path) ? path : null;\n@@ -232,0 +232,6 @@\n+    private static boolean isNonEmptyModulesPath(String name) {\n+        \/\/ Don't just check the prefix, there must be something after it too\n+        \/\/ (otherwise you end up with an empty string after trimming).\n+        return name.startsWith(MODULES) && name.length() > MODULES.length();\n+    }\n+\n@@ -252,1 +258,1 @@\n-        try (DirectoryStream<Path> stream = Files.newDirectoryStream(explodedModulesDir)) {\n+        try (DirectoryStream<Path> stream = Files.newDirectoryStream(modulesDir)) {\n@@ -257,1 +263,1 @@\n-                    findModulesNode(MODULES + moduleName);\n+                    Objects.requireNonNull(createModulesNode(MODULES + moduleName, module));\n@@ -264,6 +270,3 @@\n-                                List<String> moduleNames = packageToModules.get(pkgName);\n-                                if (moduleNames == null) {\n-                                    moduleNames = new ArrayList<>();\n-                                    packageToModules.put(pkgName, moduleNames);\n-                                }\n-                                moduleNames.add(moduleName);\n+                                packageToModules\n+                                        .computeIfAbsent(pkgName, k -> new ArrayList<>())\n+                                        .add(moduleName);\n@@ -278,2 +281,2 @@\n-        PathNode modulesDir = new PathNode(\"\/modules\", new ArrayList<>(nodes.values()));\n-        nodes.put(modulesDir.getName(), modulesDir);\n+        PathNode modulesRootNode = new PathNode(\"\/modules\", new ArrayList<>(nodes.values()));\n+        nodes.put(modulesRootNode.getName(), modulesRootNode);\n@@ -288,1 +291,1 @@\n-                Node moduleNode = findModulesNode(MODULES + moduleName);\n+                Node moduleNode = Objects.requireNonNull(nodes.get(MODULES + moduleName));\n@@ -298,2 +301,2 @@\n-        PathNode packagesDir = new PathNode(\"\/packages\", packagesChildren);\n-        nodes.put(packagesDir.getName(), packagesDir);\n+        PathNode packagesRootNode = new PathNode(\"\/packages\", packagesChildren);\n+        nodes.put(packagesRootNode.getName(), packagesRootNode);\n@@ -303,2 +306,2 @@\n-        rootChildren.add(packagesDir);\n-        rootChildren.add(modulesDir);\n+        rootChildren.add(packagesRootNode);\n+        rootChildren.add(modulesRootNode);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/ExplodedImage.java","additions":85,"deletions":82,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    static final String RUNTIME_HOME;\n+    private static final String RUNTIME_HOME;\n@@ -83,1 +83,1 @@\n-    static final Path moduleImageFile;\n+    private static final Path moduleImageFile;\n@@ -85,1 +85,1 @@\n-    static final boolean modulesImageExists;\n+    private static final boolean modulesImageExists;\n@@ -87,1 +87,1 @@\n-    static final Path explodedModulesDir;\n+    private static final Path explodedModulesDir;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/SystemImage.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Whitebox tests for ExplodedImage to ensure compatibility with ImageReader.\n+ * @modules java.base\/jdk.internal.jrtfs java.base\/jdk.internal.jimage\n+ * @run junit\/othervm java.base\/jdk.internal.jrtfs.ExplodedImageTest\n+ *\/\n+public class ExplodedImageTestDriver {}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/whitebox\/ExplodedImageTestDriver.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,4 @@\n+modules = \\\n+    java.base\/jdk.internal.jimage \\\n+    java.base\/jdk.internal.jrtfs\n+bootclasspath.dirs=.\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/whitebox\/TEST.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jrtfs;\n+\n+import jdk.internal.jimage.ImageReader;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestInstance;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/**\n+ * Tests an {@link ExplodedImage} view of a class-file hierarchy.\n+ *\n+ * <p>For simplicity and performance, only a subset of the JRT files are copied\n+ * to disk for testing.\n+ *\/\n+@TestInstance(TestInstance.Lifecycle.PER_CLASS)\n+public class ExplodedImageTest {\n+\n+    private Path modulesRoot;\n+    private SystemImage explodedImage;\n+    private String pathSeparator;\n+\n+    @BeforeAll\n+    public void createTestDirectory(@TempDir Path modulesRoot) throws IOException {\n+        this.modulesRoot = modulesRoot;\n+        this.pathSeparator = modulesRoot.getFileSystem().getSeparator();\n+        \/\/ Copy only a useful subset of files for testing. Use at least two\n+        \/\/ modules with \"overlapping\" packages to test \/package links better.\n+        unpackModulesDirectoriesFromJrtFileSystem(modulesRoot,\n+                \"java.base\/java\/util\",\n+                \"java.base\/java\/util\/zip\",\n+                \"java.logging\/java\/util\/logging\");\n+        this.explodedImage = new ExplodedImage(modulesRoot);\n+    }\n+\n+    \/** Unpacks a list of \"\/modules\/...\" directories non-recursively into the specified root directory. *\/\n+    private static void unpackModulesDirectoriesFromJrtFileSystem(Path modulesRoot, String... dirNames)\n+            throws IOException {\n+        FileSystem jrtfs = FileSystems.getFileSystem(URI.create(\"jrt:\/\"));\n+        List<Path> srcDirs = Arrays.stream(dirNames).map(s -> \"\/modules\/\" + s).map(jrtfs::getPath).toList();\n+        for (Path srcDir : srcDirs) {\n+            \/\/ Skip-1 to remove \"modules\" segment (not part of the file system path).\n+            Path dstDir = StreamSupport.stream(srcDir.spliterator(), false)\n+                    .skip(1)\n+                    .reduce(modulesRoot, (path, segment) -> path.resolve(segment.toString()));\n+            Files.createDirectories(dstDir);\n+            try (DirectoryStream<Path> files = Files.newDirectoryStream(srcDir)) {\n+                for (Path srcFile : files) {\n+                    Files.copy(srcFile, dstDir.resolve(srcFile.getFileName().toString()));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void topLevelNodes() throws IOException {\n+        ImageReader.Node root = explodedImage.findNode(\"\/\");\n+        ImageReader.Node modules = explodedImage.findNode(\"\/modules\");\n+        ImageReader.Node packages = explodedImage.findNode(\"\/packages\");\n+        assertEquals(\n+                Set.of(modules.getName(), packages.getName()),\n+                root.getChildNames().collect(Collectors.toSet()));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/modules\/java.base\/java\/util\/List.class\",\n+            \"\/modules\/java.base\/java\/util\/zip\/ZipEntry.class\",\n+            \"\/modules\/java.logging\/java\/util\/logging\/Logger.class\"})\n+    public void basicLookupResource(String expectedResourceName) throws IOException {\n+        ImageReader.Node node = assertResourceNode(expectedResourceName);\n+\n+        Path fsRelPath = getRelativePath(expectedResourceName);\n+        assertArrayEquals(\n+                Files.readAllBytes(modulesRoot.resolve(fsRelPath)),\n+                explodedImage.getResource(node));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/modules\/java.base\",\n+            \"\/modules\/java.logging\",\n+            \"\/modules\/java.base\/java\",\n+            \"\/modules\/java.base\/java\/util\",\n+            \"\/modules\/java.logging\/java\/util\",\n+    })\n+    public void basicLookupDirectory(String expectedDirectoryName) throws IOException {\n+        ImageReader.Node node = assertDirectoryNode(expectedDirectoryName);\n+\n+        Path fsRelPath = getRelativePath(expectedDirectoryName);\n+        List<String> fsChildBaseNames;\n+        try (DirectoryStream<Path> paths = Files.newDirectoryStream(modulesRoot.resolve(fsRelPath))) {\n+            fsChildBaseNames = StreamSupport.stream(paths.spliterator(), false)\n+                    .map(Path::getFileName)\n+                    .map(Path::toString)\n+                    .toList();\n+        }\n+        List<String> nodeChildBaseNames = node.getChildNames()\n+                .map(s -> s.substring(node.getName().length() + 1))\n+                .toList();\n+        assertEquals(fsChildBaseNames, nodeChildBaseNames, \"expected same child names\");\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/packages\/java\/java.base\",\n+            \"\/packages\/java\/java.logging\",\n+            \"\/packages\/java.util\/java.base\",\n+            \"\/packages\/java.util\/java.logging\",\n+            \"\/packages\/java.util.zip\/java.base\"})\n+    public void basicLookupPackageLinks(String expectedLinkName) throws IOException {\n+        ImageReader.Node node = assertLinkNode(expectedLinkName);\n+        ImageReader.Node resolved = node.resolveLink();\n+        assertSame(explodedImage.findNode(resolved.getName()), resolved);\n+        String moduleName = expectedLinkName.substring(expectedLinkName.lastIndexOf('\/') + 1);\n+        assertEquals(\"\/modules\/\" + moduleName, resolved.getName());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/packages\/java\",\n+            \"\/packages\/java.util\",\n+            \"\/packages\/java.util.zip\"})\n+    public void packageDirectories(String expectedDirectoryName) throws IOException {\n+        ImageReader.Node node = assertDirectoryNode(expectedDirectoryName);\n+        assertTrue(node.getChildNames().findFirst().isPresent(),\n+                \"Package directories should not be empty: \" + node);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\",\n+            \".\",\n+            \"\/.\",\n+            \"modules\",\n+            \"packages\",\n+            \"\/modules\/\",\n+            \"\/modules\/xxxx\",\n+            \"\/modules\/java.base\/java\/lang\/Xxxx.class\",\n+            \"\/packages\/\",\n+            \"\/packages\/xxxx\",\n+            \"\/packages\/java.xxxx\",\n+            \"\/packages\/java.util.\",\n+            \/\/ Mismatched module.\n+            \"\/packages\/java.util.logging\/java.base\",\n+            \"\/packages\/java.util.zip\/java.logging\",\n+            \/\/ Links are not resolved as they are fetched (old\/broken behaviour).\n+            \"\/packages\/java.util\/java.base\/java\/util\/Vector.class\",\n+    })\n+    public void invalidNames(String invalidName) throws IOException {\n+        assertNull(explodedImage.findNode(invalidName), \"No node expected for: \" + invalidName);\n+    }\n+\n+    private ImageReader.Node assertResourceNode(String name) throws IOException {\n+        ImageReader.Node node = explodedImage.findNode(name);\n+        assertNotNull(node);\n+        assertEquals(name, node.getName(), \"expected node name: \" + name);\n+        assertTrue(node.isResource(), \"expected a resource: \" + node);\n+        assertFalse(node.isDirectory(), \"resources are not directories: \" + node);\n+        assertFalse(node.isLink(), \"resources are not links: \" + node);\n+        return node;\n+    }\n+\n+    private ImageReader.Node assertDirectoryNode(String name) throws IOException {\n+        ImageReader.Node node = explodedImage.findNode(name);\n+        assertNotNull(node);\n+        assertEquals(name, node.getName(), \"expected node name: \" + name);\n+        assertTrue(node.isDirectory(), \"expected a directory: \" + node);\n+        assertFalse(node.isResource(), \"directories are not resources: \" + node);\n+        assertFalse(node.isLink(), \"directories are not links: \" + node);\n+        return node;\n+    }\n+\n+    private ImageReader.Node assertLinkNode(String name) throws IOException {\n+        ImageReader.Node node = explodedImage.findNode(name);\n+        assertNotNull(node);\n+        assertEquals(name, node.getName(), \"expected node name: \" + name);\n+        assertTrue(node.isLink(), \"expected a link: \" + node);\n+        assertFalse(node.isResource(), \"links are not resources: \" + node);\n+        assertFalse(node.isDirectory(), \"links are not directories: \" + node);\n+        return node;\n+    }\n+\n+    private Path getRelativePath(String name) {\n+        return Path.of(name.substring(\"\/modules\/\".length()).replace(\"\/\", pathSeparator));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/jrtfs\/whitebox\/java.base\/jdk\/internal\/jrtfs\/ExplodedImageTest.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"}]}