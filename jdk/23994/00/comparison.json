{"files":[{"patch":"@@ -624,5 +624,2 @@\n-void* os::malloc(size_t size, MemTag mem_tag) {\n-  return os::malloc(size, mem_tag, CALLER_PC);\n-}\n-\n-void* os::malloc(size_t size, MemTag mem_tag, const NativeCallStack& stack) {\n+size_t os::pre_alloc(void** raw_ptr, void* old_ptr, size_t size, MemTag mem_tag, const NativeCallStack& stack) {\n+  *raw_ptr = nullptr;\n@@ -631,2 +628,1 @@\n-  void* rc = nullptr;\n-  if (NMTPreInit::handle_malloc(&rc, size)) {\n+  if (NMTPreInit::handle_realloc(raw_ptr, old_ptr, size, mem_tag)) {\n@@ -635,1 +631,1 @@\n-    return rc;\n+    return size;\n@@ -644,1 +640,0 @@\n-\n@@ -647,1 +642,1 @@\n-    return nullptr;\n+    return 0;\n@@ -651,1 +646,0 @@\n-\n@@ -654,1 +648,1 @@\n-    return nullptr;\n+    return 0;\n@@ -657,4 +651,7 @@\n-  ALLOW_C_FUNCTION(::malloc, void* const outer_ptr = ::malloc(outer_size);)\n-  if (outer_ptr == nullptr) {\n-    return nullptr;\n-  }\n+  return outer_size;\n+}\n+\n+void* os::post_alloc(void* raw_ptr, size_t size, long chunk, MemTag mem_tag, const NativeCallStack& stack) {\n+  if (MemTracker::enabled()) {\n+    \/\/ Register alloc with NMT\n+    void* const client_ptr = MemTracker::record_malloc((address)raw_ptr, size, mem_tag, stack);\n@@ -662,1 +659,6 @@\n-  void* const inner_ptr = MemTracker::record_malloc((address)outer_ptr, size, mem_tag, stack);\n+    if (CDSConfig::is_dumping_static_archive()) {\n+      \/\/ Need to deterministically fill all the alignment gaps in C++ structures.\n+      ::memset((char*)client_ptr + chunk, 0, chunk);\n+    } else {\n+      DEBUG_ONLY(::memset((char*)client_ptr + chunk, uninitBlockPad, chunk);)\n+    }\n@@ -664,3 +666,2 @@\n-  if (CDSConfig::is_dumping_static_archive()) {\n-    \/\/ Need to deterministically fill all the alignment gaps in C++ structures.\n-    ::memset(inner_ptr, 0, size);\n+    DEBUG_ONLY(break_if_ptr_caught(client_ptr);)\n+    return client_ptr;\n@@ -668,1 +669,1 @@\n-    DEBUG_ONLY(::memset(inner_ptr, uninitBlockPad, size);)\n+    return raw_ptr;\n@@ -670,2 +671,0 @@\n-  DEBUG_ONLY(break_if_ptr_caught(inner_ptr);)\n-  return inner_ptr;\n@@ -674,2 +673,2 @@\n-void* os::realloc(void *memblock, size_t size, MemTag mem_tag) {\n-  return os::realloc(memblock, size, mem_tag, CALLER_PC);\n+void* os::malloc(size_t size, MemTag mem_tag) {\n+  return os::malloc(size, mem_tag, CALLER_PC);\n@@ -678,3 +677,1 @@\n-void* os::realloc(void *memblock, size_t size, MemTag mem_tag, const NativeCallStack& stack) {\n-\n-  \/\/ Special handling for NMT preinit phase before arguments are parsed\n+void* os::malloc(size_t size, MemTag mem_tag, const NativeCallStack& stack) {\n@@ -682,1 +679,2 @@\n-  if (NMTPreInit::handle_realloc(&rc, memblock, size, mem_tag)) {\n+  size_t outer_size = os::pre_alloc(&rc, nullptr, size, mem_tag, stack);\n+  if (rc != nullptr) {\n@@ -685,0 +683,7 @@\n+  ALLOW_C_FUNCTION(::malloc, rc = ::malloc(outer_size);)\n+  return os::post_alloc(rc, size, 0, mem_tag, stack);\n+}\n+\n+void* os::realloc(void *memblock, size_t size, MemTag mem_tag) {\n+  return os::realloc(memblock, size, mem_tag, CALLER_PC);\n+}\n@@ -686,0 +691,1 @@\n+void* os::realloc(void *memblock, size_t size, MemTag mem_tag, const NativeCallStack& stack) {\n@@ -690,6 +696,5 @@\n-  DEBUG_ONLY(check_crash_protection());\n-\n-  \/\/ On realloc(p, 0), implementers of realloc(3) have the choice to return either\n-  \/\/ null or a unique non-null pointer. To unify libc behavior across our platforms\n-  \/\/ we chose the latter.\n-  size = MAX2((size_t)1, size);\n+  void* rc = nullptr;\n+  size_t outer_size = os::pre_alloc(&rc, memblock, size, mem_tag, stack);\n+  if (rc != nullptr) {\n+    return rc;\n+  }\n@@ -697,0 +702,4 @@\n+  MallocHeader::FreeInfo* free_info = nullptr;\n+  MallocHeader* header = nullptr;\n+  void* old_ptr = memblock;\n+  long chunk = 0;\n@@ -698,10 +707,7 @@\n-    \/\/ NMT realloc handling\n-\n-    const size_t new_outer_size = size + MemTracker::overhead_per_malloc();\n-\n-    \/\/ Handle size overflow.\n-    if (new_outer_size < size) {\n-      return nullptr;\n-    }\n-\n-    const size_t old_size = MallocTracker::malloc_header(memblock)->size();\n+    \/\/ Perform integrity checks on and mark the old block as dead *before* calling the real realloc(3)\n+    \/\/ since it may invalidate the old block, including its header.\n+    header = MallocHeader::resolve_checked(memblock);\n+    MallocHeader::FreeInfo free_info_local = header->free_info();\n+    free_info = &free_info_local;\n+    chunk = size - free_info->size;\n+    header->mark_block_as_dead();\n@@ -710,1 +716,1 @@\n-    if ((size > old_size) && MemTracker::check_exceeds_limit(size - old_size, mem_tag)) {\n+    if ((size > free_info->size) && MemTracker::check_exceeds_limit(chunk, mem_tag)) {\n@@ -714,3 +720,1 @@\n-    \/\/ Perform integrity checks on and mark the old block as dead *before* calling the real realloc(3) since it\n-    \/\/ may invalidate the old block, including its header.\n-    MallocHeader* header = MallocHeader::resolve_checked(memblock);\n+    \/\/ Perform integrity checks on and mark the old block as dead *before* calling the real realloc(3) since it may invalidate the old block, including its header.\n@@ -719,1 +723,0 @@\n-    const MallocHeader::FreeInfo free_info = header->free_info();\n@@ -722,0 +725,2 @@\n+    old_ptr = header;\n+  }\n@@ -723,6 +728,6 @@\n-    \/\/ the real realloc\n-    ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc(header, new_outer_size);)\n-\n-    if (new_outer_ptr == nullptr) {\n-      \/\/ realloc(3) failed and the block still exists.\n-      \/\/ We have however marked it as dead, revert this change.\n+  \/\/ The real realloc\n+  ALLOW_C_FUNCTION(::realloc, rc = ::realloc(old_ptr, outer_size);)\n+  if (rc == nullptr) {\n+    \/\/ realloc(3) failed and the block still exists.\n+    \/\/ We have however marked it as dead, revert this change.\n+    if (MemTracker::enabled()) {\n@@ -730,25 +735,0 @@\n-      return nullptr;\n-    }\n-    \/\/ realloc(3) succeeded, variable header now points to invalid memory and we need to deaccount the old block.\n-    MemTracker::deaccount(free_info);\n-\n-    \/\/ After a successful realloc(3), we account the resized block with its new size\n-    \/\/ to NMT.\n-    void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, mem_tag, stack);\n-\n-#ifdef ASSERT\n-    assert(old_size == free_info.size, \"Sanity\");\n-    if (old_size < size) {\n-      \/\/ We also zap the newly extended region.\n-      ::memset((char*)new_inner_ptr + old_size, uninitBlockPad, size - old_size);\n-    }\n-#endif\n-\n-    rc = new_inner_ptr;\n-\n-  } else {\n-\n-    \/\/ NMT disabled.\n-    ALLOW_C_FUNCTION(::realloc, rc = ::realloc(memblock, size);)\n-    if (rc == nullptr) {\n-      return nullptr;\n@@ -756,1 +736,1 @@\n-\n+    return nullptr;\n@@ -759,1 +739,3 @@\n-  DEBUG_ONLY(break_if_ptr_caught(rc);)\n+  if (MemTracker::enabled()) {\n+    MemTracker::deaccount(*free_info);\n+  }\n@@ -761,1 +743,1 @@\n-  return rc;\n+  return os::post_alloc(rc, size, chunk, mem_tag, stack);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":66,"deletions":84,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -260,0 +260,3 @@\n+  static size_t pre_alloc(void** raw_ptr, void* old_ptr, size_t size, MemTag mem_tag, const NativeCallStack& stack);\n+  static void* post_alloc(void* raw_ptr, size_t size, long chunk, MemTag mem_tag, const NativeCallStack& stack);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}