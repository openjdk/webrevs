{"files":[{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8317636\n+ * @summary The test verifies heap walking API (FollowReferences) reports\n+ *     field indeces in correct order (as described by jvmtiHeapReferenceInfoField spec).\n+ *     For simplification only primitive field callback is tested\n+ *     and all fields in the test classes are 'int'.\n+ *     Field IDs are not reported to the callback, so the test uses field values\n+ *     to distinguish between fields, so all field values in the test classes should be unique.\n+ * @run main\/othervm\/native -agentlib:FieldIndicesTest FieldIndicesTest\n+ *\/\n+\n+import java.lang.ref.Reference;\n+\n+\/\/ Test class hierarchy is based on the example described in the spec.\n+\/\/ Extra fields added to improve coverage.\n+interface I0 {\n+    int p = 10;\n+    \/\/ extra fields\n+    public int p5 = 11;\n+    int p6 = 12;\n+    public int p1 = 13;\n+}\n+\n+interface I1 extends I0 {\n+    int x = 20;\n+    \/\/ extra fields\n+    int x1 = 21;\n+    public int x2 = 22;\n+}\n+\n+interface I2 extends I0 {\n+    int y = 30;\n+    \/\/ extra fields\n+    int y9 = 31;\n+    public int y4 = 32;\n+    public int y3 = 33;\n+}\n+\n+class C1 implements I1 {\n+    public static int a = 40;\n+    private int b = 41;\n+    \/\/ extra fields\n+    private int a1 = 42;\n+    protected static int b7 = 43;\n+    static int b2 = 44;\n+    final protected int a3 = 45;\n+    static int a2 = 46;\n+    public int b1 = 47;\n+}\n+\n+class C2 extends C1 implements I2 {\n+    static int q = 60;\n+    final int r = 61;\n+    \/\/ extra fields\n+    private int q11 = 61;\n+    final static int q9 = 62;\n+    static int q2 = 63;\n+    final protected int r3 = 64;\n+    public int r7 = 65;\n+}\n+\n+public class FieldIndicesTest {\n+    static {\n+        System.loadLibrary(\"FieldIndicesTest\");\n+    }\n+\n+    private static native void prepare(Object testObject);\n+\n+    private static native void test(Object rootObject);\n+\n+    private static native boolean testFailed();\n+\n+    private static void prepare(String name, Object testObject) {\n+        System.out.println(\">>prepare(\" + name + \")\");\n+        prepare(testObject);\n+        System.out.println(\"<<prepare(\" + name + \")\");\n+        System.out.println();\n+    }\n+\n+    private static void test(String name, Object rootObject) {\n+        System.out.println(\">>test(\" + name + \")\");\n+        test(rootObject);\n+        System.out.println(\"<<test(\" + name + \")\");\n+        System.out.println();\n+    }\n+\n+    public static void main(String argv[]) {\n+        C1 obj1 = new C1();\n+        C2 obj2 = new C2();\n+\n+        prepare(\"obj1\", obj1);\n+        prepare(\"obj2\", obj2);\n+\n+        test(\"obj1\", obj1);\n+        test(\"obj2\", obj2);\n+\n+        Reference.reachabilityFence(obj1);\n+        Reference.reachabilityFence(obj2);\n+\n+        if (testFailed()) {\n+            throw new RuntimeException(\"Test failed. See log for details\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/FollowReferences\/FieldIndices\/FieldIndicesTest.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,515 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdint.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv* jvmti = nullptr;\n+static bool test_failed = false;\n+\n+static void* allocate(JNIEnv* env, jlong size) {\n+  unsigned char* result = nullptr;\n+  check_jvmti_status(env,\n+    jvmti->Allocate(size, &result),\n+    \"Allocate failed\");\n+  return result;\n+}\n+\n+static void deallocate(JNIEnv* env, void* mem) {\n+  check_jvmti_status(env,\n+    jvmti->Deallocate((unsigned char*)mem),\n+    \"Deallocate failed\");\n+}\n+\n+\/\/ Converts JNI class name signature to simple name (in place).\n+static void sig2name(char* str) {\n+  size_t len = strlen(str);\n+  if (len >=2 && str[0] == 'L' && str[len-1] == ';') {\n+    len -=2;\n+    memmove(str, str+1, len);\n+    str[len] = '\\0';\n+  }\n+  \/\/ Replace '\/' with '.'.\n+  for (char* pos = str; (pos = strchr(pos, '\/')) != nullptr; ) {\n+    *pos = '.';\n+  }\n+}\n+\n+static bool is_static_field(JNIEnv* env, jclass klass, jfieldID fid) {\n+  enum {\n+    ACC_STATIC        = 0x0008\n+  };\n+\n+  jint access_flags = 0;\n+  check_jvmti_status(env,\n+    jvmti->GetFieldModifiers(klass, fid, &access_flags),\n+    \"GetFieldModifiers failed\");\n+  return (access_flags & ACC_STATIC) != 0;\n+}\n+\n+static void verify_int_field(JNIEnv* env, jclass klass, jfieldID fid) {\n+  char* name = nullptr;\n+  char* sig = nullptr;\n+  check_jvmti_status(env,\n+    jvmti->GetFieldName(klass, fid, &name, &sig, nullptr),\n+    \"GetFieldName failed\");\n+\n+  if (strcmp(sig, \"I\") != 0) {\n+    printf(\"ERROR: field '%s' is not int ('%s')\\n\", name, sig);\n+    fflush(nullptr);\n+    fatal(env, \"unexpected field type\");\n+  }\n+\n+  deallocate(env, name);\n+  deallocate(env, sig);\n+}\n+\n+\n+\/*\n+Per jvmtiHeapReferenceInfoField spec (reference information for\n+JVMTI_HEAP_REFERENCE_FIELD and JVMTI_HEAP_REFERENCE_STATIC_FIELD references.):\n+If the referrer object is not an interface, then the field indices are determined as follows:\n+- make a list of all the fields in C and its superclasses,\n+  starting with all the fields in java.lang.Object and ending with all the fields in C.\n+- Within this list, put the fields for a given class in the order returned by GetClassFields.\n+- Assign the fields in this list indices n, n+1, ..., in order,\n+  where n is the count of the fields in all the interfaces implemented by C.\n+  Note that C implements all interfaces directly implemented by its superclasses;\n+  as well as all superinterfaces of these interfaces.\n+If the referrer object is an interface, then the field indices are determined as follows:\n+- make a list of the fields directly declared in I.\n+- Within this list, put the fields in the order returned by GetClassFields.\n+- Assign the fields in this list indices n, n+1, ..., in order,\n+  where n is the count of the fields in all the superinterfaces of I.\n+\n+'Klass' struct contains all required data to calculate field indices.\n+Also contains static field values.\n+For each test class, the 'Klass' struct is created and a pointer to it is set as the jclass's tag.\n+*\/\n+\n+struct Klass {\n+  jclass klass;\n+  char* name;\n+  Klass* super_klass;\n+\n+  struct Field {\n+    jfieldID id;\n+    char* name;\n+\n+    \/\/ Field value for static fields (0 for instance fields).\n+    \/\/ All fields in the test classes are 'int'.\n+    jint value;\n+\n+    void init(JNIEnv* env, jclass klass, jfieldID fid);\n+  };\n+\n+  \/\/ Fields of the class and its superclasses\n+  \/\/ as described in jvmtiHeapReferenceInfoField spec.\n+  Field* fields;\n+  jint field_count;\n+\n+  \/\/ Interfaces implemented by this klass, superclasses and superinterfaces.\n+  Klass** interfaces;\n+  jint interface_count;\n+\n+  \/\/ Number of fields in all implemented interfaces.\n+  jint interface_field_count;\n+\n+  static Klass* explore(JNIEnv* env, jclass klass);\n+\n+private:\n+  \/\/ Initializes fields, field_count.\n+  void explore_fields(JNIEnv* env);\n+  \/\/ Initializes interfaces, interface_count.\n+  void explore_interfaces(JNIEnv* env);\n+\n+  void print() const;\n+};\n+\n+\/*\n+For each test object, the 'Object' struct is created and a pointer to it is set as the jobject's tag.\n+*\/\n+struct Object {\n+  Klass* klass;\n+  \/\/ Values of instance fields (0 for static fields).\n+  \/\/ Size of the array == klass->field_count.\n+  jint* field_values;\n+\n+  static Object* explore(JNIEnv* env, jobject obj);\n+};\n+\n+\n+void Klass::Field::init(JNIEnv* env, jclass klass, jfieldID fid) {\n+  id = fid;\n+  check_jvmti_status(env,\n+    jvmti->GetFieldName(klass, fid, &name, nullptr, nullptr),\n+    \"GetFieldName failed\");\n+  if (is_static_field(env, klass, fid)) {\n+    verify_int_field(env, klass, fid);\n+    value = env->GetStaticIntField(klass, fid);\n+  } else {\n+    value = 0;\n+  }\n+}\n+\n+void Klass::explore_fields(JNIEnv* env) {\n+  jint this_count;\n+  jfieldID* this_fields;\n+  check_jvmti_status(env,\n+    jvmti->GetClassFields(klass, &this_count, &this_fields),\n+    \"GetClassFields failed\");\n+\n+  jint super_count = super_klass != nullptr ? super_klass->field_count : 0;\n+\n+  fields = (Field*)allocate(env, sizeof(Field) * (super_count + this_count));\n+  field_count = 0;\n+\n+  if (super_klass != 0) {\n+    \/\/ super_klass->fields already contains fields from all superclasses in the required order.\n+    for (int i = 0; i < super_count; i++) {\n+      fields[field_count++].init(env, super_klass->klass, super_klass->fields[i].id);\n+    }\n+  }\n+\n+  \/\/ Add field of this class to the end of the list.\n+  for (int i = 0; i < this_count; i++) {\n+    fields[field_count++].init(env, klass, this_fields[i]);\n+  }\n+  deallocate(env, this_fields);\n+}\n+\n+\n+\/\/ Calculates maximum number of implemented interfaces of the klass and its superinterfaces.\n+static jint get_max_interface_count(JNIEnv* env, jclass klass) {\n+  jint interface_count;\n+  jclass* interfaces;\n+  check_jvmti_status(env,\n+    jvmti->GetImplementedInterfaces(klass, &interface_count, &interfaces),\n+    \"GetImplementedInterfaces failed\");\n+\n+  jint result = interface_count;\n+  \/\/ interfaces implemented by superinterfaces\n+  for (jint i = 0; i < interface_count; i++) {\n+    result += get_max_interface_count(env, interfaces[i]);\n+  }\n+\n+  deallocate(env, interfaces);\n+\n+  return result;\n+}\n+\n+\/\/ Explores all interfaces implemented by 'klass', sorts out duplicates,\n+\/\/ and stores the interfaces in the 'arr' starting from 'index'.\n+\/\/ Returns number of the interfaces added.\n+static jint fill_interfaces(Klass** arr, jint index, JNIEnv* env, jclass klass) {\n+  jint interface_count;\n+  jclass* interfaces;\n+  check_jvmti_status(env,\n+    jvmti->GetImplementedInterfaces(klass, &interface_count, &interfaces),\n+    \"GetImplementedInterfaces failed\");\n+\n+  jint count = 0;\n+  for (jint i = 0; i < interface_count; i++) {\n+    \/\/ Skip interface if it's already in the array\n+    \/\/ (i.e. implemented by another superclass\/superinterface).\n+    bool dup = false;\n+    for (jint j = 0; j < index; j++) {\n+      if (env->IsSameObject(arr[j]->klass, interfaces[i]) == JNI_TRUE) {\n+        dup = true;\n+        break;\n+      }\n+    }\n+    if (dup) {\n+      continue;\n+    }\n+\n+    \/\/ Add the interface.\n+    arr[index + count] = Klass::explore(env, interfaces[i]);\n+    count++;\n+\n+    \/\/ And explore its superinterfaces.\n+    count += fill_interfaces(arr, index + count, env, interfaces[i]);\n+  }\n+\n+  deallocate(env, interfaces);\n+\n+  return count;\n+}\n+\n+void Klass::explore_interfaces(JNIEnv* env) {\n+  jint max_count = get_max_interface_count(env, klass);\n+  if (super_klass != nullptr) {\n+    max_count += super_klass->interface_count;\n+  }\n+\n+  \/\/ Allocate array for maximum possible count.\n+  interfaces = (Klass**)allocate(env, sizeof(Klass*) * max_count);\n+\n+  interface_count = 0;\n+  if (super_klass != nullptr) {\n+    \/\/ Add all interfaces implemented by super_klass first.\n+    interface_count = super_klass->interface_count;\n+    memcpy(interfaces, super_klass->interfaces, sizeof(Klass*) * super_klass->interface_count);\n+  }\n+\n+  \/\/ Interfaces implemented by the klass.\n+  interface_count += fill_interfaces(interfaces, interface_count, env, klass);\n+}\n+\n+void Klass::print() const {\n+  printf(\"Explored klass: %s, super: %s\\n\",\n+         name, super_klass == nullptr ? nullptr : super_klass->name);\n+  printf(\"  interfaces (%d):\\n\", (int)interface_count);\n+  for (jint i = 0; i < interface_count; i++) {\n+    printf(\"    %d: %s\\n\", (int)i, interfaces[i]->name);\n+  }\n+  printf(\"  fields (%d):\\n\", (int)field_count);\n+  for (jint i = 0; i < field_count; i++) {\n+    printf(\"    %d: %s (value = %d)\\n\",\n+           (int)i, fields[i].name, (int)fields[i].value);\n+  }\n+  printf(\"  interface_field_count: %d\\n\", (int)interface_field_count);\n+}\n+\n+Klass* Klass::explore(JNIEnv* env, jclass klass) {\n+  jlong tag = 0;\n+  check_jvmti_status(env,\n+    jvmti->GetTag(klass, &tag),\n+    \"GetTag failed\");\n+  if (tag != 0) { \/\/ already explored\n+    return (Klass*)tag;\n+  }\n+\n+  Klass* result = (Klass*)allocate(env, sizeof(Klass));\n+\n+  result->klass = (jclass)env->NewGlobalRef(klass);\n+\n+  check_jvmti_status(env,\n+    jvmti->GetClassSignature(klass, &result->name, nullptr),\n+    \"GetClassSignature failed\");\n+  sig2name(result->name);\n+\n+  \/\/ Explore superclass first.\n+  jclass super_klass = env->GetSuperclass(klass);\n+  result->super_klass = super_klass == nullptr ? nullptr : Klass::explore(env, super_klass);\n+\n+  result->explore_fields(env);\n+\n+  result->explore_interfaces(env);\n+\n+  \/\/ Calculate interface_field_count.\n+  result->interface_field_count = 0;\n+  for (jint i = 0; i < result->interface_count; i++) {\n+    result->interface_field_count += result->interfaces[i]->field_count;\n+  }\n+\n+  check_jvmti_status(env,\n+    jvmti->SetTag(klass, (jlong)result),\n+    \"SetTag failed\");\n+\n+  result->print();\n+\n+  return result;\n+}\n+\n+Object* Object::explore(JNIEnv* env, jobject obj) {\n+  jlong tag = 0;\n+  check_jvmti_status(env,\n+    jvmti->GetTag(obj, &tag),\n+    \"GetTag failed\");\n+  if (tag != 0) { \/\/ already explored\n+    return (Object*)tag;\n+  }\n+\n+  jclass obj_klass = env->GetObjectClass(obj);\n+  Klass* klass = Klass::explore(env, obj_klass);\n+  jint* values = (jint*)allocate(env, sizeof(jint) * klass->field_count);\n+\n+  for (jint i = 0; i < klass->field_count; i++) {\n+    jfieldID fid = klass->fields[i].id;\n+    if (is_static_field(env, obj_klass, fid)) {\n+      values[i] = 0;\n+    } else {\n+      verify_int_field(env, obj_klass, fid);\n+      values[i] = env->GetIntField(obj, fid);\n+    }\n+  }\n+\n+  Object* result = (Object*)allocate(env, sizeof(Object));\n+  result->klass = klass;\n+  result->field_values = values;\n+\n+  check_jvmti_status(env,\n+    jvmti->SetTag(obj, (jlong)result),\n+    \"SetTag failed\");\n+\n+  return result;\n+}\n+\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  jint res = jvm->GetEnv((void **)&jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == nullptr) {\n+    printf(\"jvm->GetEnv failed\\n\");\n+    fflush(nullptr);\n+    return JNI_ERR;\n+  }\n+\n+  jvmtiCapabilities caps;\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_tag_objects = 1;\n+  jvmtiError err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"AddCapabilities failed: %s (%d)\\n\", TranslateError(err), err);\n+    fflush(nullptr);\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+\n+static bool check_index_bounds(jint index, Klass* klass) {\n+  if (index < klass->interface_field_count) {\n+    printf(\"ERROR: field_index is too small (%d < %d)\\n\",\n+           (int)index, (int)klass->interface_field_count);\n+    test_failed = true;\n+    return false;\n+  }\n+  if (index >= klass->interface_field_count + klass->field_count) {\n+    printf(\"ERROR: field_index is too big (%d >= %d)\\n\",\n+           (int)index, (int)(klass->interface_field_count + klass->field_count));\n+    test_failed = true;\n+    return false;\n+  }\n+  return true;\n+}\n+\n+static char* get_field_name(Klass* klass, jint index) {\n+  index -= klass->interface_field_count;\n+  if (index < 0 || index >= klass->field_count) {\n+    return nullptr;\n+  }\n+  return klass->fields[index].name;\n+}\n+\n+\n+jint JNICALL primitiveFieldCallback(\n+   jvmtiHeapReferenceKind        reference_kind,\n+   const jvmtiHeapReferenceInfo* reference_info,\n+   jlong                         class_tag,\n+   jlong*                        tag_ptr,\n+   jvalue                        value,\n+   jvmtiPrimitiveType            value_type,\n+   void*                         user_data)\n+{\n+  if (*tag_ptr == 0) {\n+    return 0;\n+  }\n+\n+  jint index = reference_info->field.index;\n+  jint int_value = value.i;\n+  if (value_type != JVMTI_PRIMITIVE_TYPE_INT) {\n+    printf(\"ERROR: unexpected value type in primitiveFieldCallback: '%c'\\n\", (char)value_type);\n+    test_failed = true;\n+    int_value = -1;\n+  }\n+\n+  if (reference_kind == JVMTI_HEAP_REFERENCE_FIELD) {\n+    Object* obj = (Object*)(*tag_ptr);\n+    Klass* klass = obj->klass;\n+    printf(\"primitiveFieldCallback(JVMTI_HEAP_REFERENCE_FIELD): \"\n+           \"klass=%s, index=%d, type=%c, value=%d\\n\",\n+           klass->name, index,\n+           (int)value_type, (int)value.i);\n+    if (check_index_bounds(index, klass)) {\n+      jint expected_value = obj->field_values[index - klass->interface_field_count];\n+      if (int_value != expected_value) {\n+        printf(\"  ERROR: wrong instance value: (%d, expected %d)\\n\",\n+               (int)int_value, (int)expected_value);\n+        test_failed = true;\n+      } else {\n+        printf(\"  OK: field %s.%s, value %d\\n\",\n+               klass->name, get_field_name(klass, index), (int)int_value);\n+      }\n+    }\n+  } else if (reference_kind == JVMTI_HEAP_REFERENCE_STATIC_FIELD) {\n+    Klass* klass = (Klass*)(*tag_ptr);\n+    printf(\"primitiveFieldCallback(JVMTI_HEAP_REFERENCE_STATIC_FIELD): \"\n+           \"klass=%s, index=%d, type=%c, value=%d\\n\",\n+           klass->name, index,\n+           (int)value_type, (int)value.i);\n+    if (check_index_bounds(index, klass)) {\n+      jint expected_value = klass->fields[index - klass->interface_field_count].value;\n+      if (int_value != expected_value) {\n+        printf(\"  ERROR: wrong static value: (%d, expected %d)\\n\\n\\n\",\n+               (int)int_value, (int)expected_value);\n+        test_failed = true;\n+      } else {\n+        printf(\"  OK: field %s.%s, value %d\\n\",\n+               klass->name, get_field_name(klass, index), (int)int_value);\n+      }\n+    }\n+  } else {\n+    printf(\"ERROR: unexpected reference_kind in primitiveFieldCallback: %d\\n\", (int)reference_kind);\n+    test_failed = true;\n+  }\n+\n+  fflush(nullptr);\n+  return 0;\n+}\n+\n+\n+JNIEXPORT void JNICALL\n+Java_FieldIndicesTest_prepare(JNIEnv *env, jclass cls, jobject testObj) {\n+  Object::explore(env, testObj);\n+  fflush(nullptr);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_FieldIndicesTest_test(JNIEnv *env, jclass cls, jobject rootObject) {\n+  jvmtiHeapCallbacks heapCallbacks;\n+  memset(&heapCallbacks, 0, sizeof(heapCallbacks));\n+\n+  heapCallbacks.primitive_field_callback = primitiveFieldCallback;\n+\n+  check_jvmti_status(env,\n+    jvmti->FollowReferences(JVMTI_HEAP_FILTER_UNTAGGED, \/\/ heap_filter\n+                            nullptr,                    \/\/ class\n+                            rootObject,                 \/\/ initial_object\n+                            &heapCallbacks,\n+                            nullptr),\n+    \"FollowReferences failed\");\n+  fflush(nullptr);\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_FieldIndicesTest_testFailed(JNIEnv *env, jclass cls) {\n+  return test_failed ? JNI_TRUE : JNI_FALSE;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/FollowReferences\/FieldIndices\/libFieldIndicesTest.cpp","additions":515,"deletions":0,"binary":false,"changes":515,"status":"added"}]}