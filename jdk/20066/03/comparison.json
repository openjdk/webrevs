{"files":[{"patch":"@@ -597,0 +597,63 @@\n+template<typename IntegerType>\n+static const IntegerType* and_value(const IntegerType* r0, const IntegerType* r1) {\n+  typedef typename IntegerType::NativeType NativeType;\n+  static_assert(std::is_signed<NativeType>::value, \"Native type of IntegerType must be signed!\");\n+\n+  int widen = MAX2(r0->_widen, r1->_widen);\n+\n+  \/\/ If both types are constants, we can calculate a constant result.\n+  if (r0->is_con() && r1->is_con()) {\n+    return IntegerType::make(r0->get_con() & r1->get_con());\n+  }\n+\n+  \/\/ If both ranges are positive, the result will range from 0 up to the hi value of the smaller range. The minimum\n+  \/\/ of the two constrains the upper bound because any higher value in the other range will see all zeroes, so it will be masked out.\n+  if (r0->_lo >= 0 && r1->_lo >= 0) {\n+    return IntegerType::make(0, MIN2(r0->_hi, r1->_hi), widen);\n+  }\n+\n+  \/\/ If only one range is positive, the result will range from 0 up to that range's maximum value.\n+  \/\/ For the operation 'x & C' where C is a positive constant, the result will be in the range [0..C]. With that observation,\n+  \/\/ we can say that for any integer c such that 0 <= c <= C will also be in the range [0..C]. Therefore, 'x & [c..C]'\n+  \/\/ where c >= 0 will be in the range [0..C].\n+  if (r0->_lo >= 0) {\n+    return IntegerType::make(0, r0->_hi, widen);\n+  }\n+\n+  if (r1->_lo >= 0) {\n+    return IntegerType::make(0, r1->_hi, widen);\n+  }\n+\n+  \/\/ At this point, all positive ranges will have already been handled, so the only remaining cases will be negative ranges\n+  \/\/ and constants.\n+\n+  assert(r0->_lo < 0 && r1->_lo < 0, \"positive ranges should already be handled!\");\n+\n+  \/\/ As two's complement means that both numbers will start with leading 1s, the lower bound of both ranges will contain\n+  \/\/ the common leading 1s of both minimum values. In order to count them with count_leading_zeros, the bits are inverted.\n+  NativeType sel_val = ~MIN2(r0->_lo, r1->_lo);\n+\n+  NativeType min;\n+  if (sel_val == 0) {\n+    \/\/ Since count_leading_zeros is undefined at 0, we short-circuit the condition where both ranges have a minimum of -1.\n+    min = -1;\n+  } else {\n+    \/\/ To get the number of bits to shift, we count the leading 0-bits and then subtract one, as the sign bit is already set.\n+    int shift_bits = count_leading_zeros(sel_val) - 1;\n+    min = std::numeric_limits<NativeType>::min() >> shift_bits;\n+  }\n+\n+  NativeType max;\n+  if (r0->_hi < 0 && r1->_hi < 0) {\n+    \/\/ If both ranges are negative, then the same optimization as both positive ranges will apply, and the smaller hi\n+    \/\/ value will mask off any bits set by higher values.\n+    max = MIN2(r0->_hi, r1->_hi);\n+  } else {\n+    \/\/ In the case of ranges that cross zero, negative values can cause the higher order bits to be set, so the maximum\n+    \/\/ positive value can be as high as the larger hi value.\n+    max = MAX2(r0->_hi, r1->_hi);\n+  }\n+\n+  return IntegerType::make(min, max, widen);\n+}\n+\n@@ -604,14 +667,2 @@\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-  int widen = MAX2(r0->_widen,r1->_widen);\n-\n-  \/\/ If either input is a constant, might be able to trim cases\n-  if( !r0->is_con() && !r1->is_con() )\n-    return TypeInt::INT;        \/\/ No constants to be had\n-\n-  \/\/ Both constants?  Return bits\n-  if( r0->is_con() && r1->is_con() )\n-    return TypeInt::make( r0->get_con() & r1->get_con() );\n-\n-  if( r0->is_con() && r0->get_con() > 0 )\n-    return TypeInt::make(0, r0->get_con(), widen);\n+  const TypeInt* r0 = t0->is_int();\n+  const TypeInt* r1 = t1->is_int();\n@@ -619,8 +670,1 @@\n-  if( r1->is_con() && r1->get_con() > 0 )\n-    return TypeInt::make(0, r1->get_con(), widen);\n-\n-  if( r0 == TypeInt::BOOL || r1 == TypeInt::BOOL ) {\n-    return TypeInt::BOOL;\n-  }\n-\n-  return TypeInt::INT;          \/\/ No constants to be had\n+  return and_value<TypeInt>(r0, r1);\n@@ -754,17 +798,2 @@\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-  int widen = MAX2(r0->_widen,r1->_widen);\n-\n-  \/\/ If either input is a constant, might be able to trim cases\n-  if( !r0->is_con() && !r1->is_con() )\n-    return TypeLong::LONG;      \/\/ No constants to be had\n-\n-  \/\/ Both constants?  Return bits\n-  if( r0->is_con() && r1->is_con() )\n-    return TypeLong::make( r0->get_con() & r1->get_con() );\n-\n-  if( r0->is_con() && r0->get_con() > 0 )\n-    return TypeLong::make(CONST64(0), r0->get_con(), widen);\n-\n-  if( r1->is_con() && r1->get_con() > 0 )\n-    return TypeLong::make(CONST64(0), r1->get_con(), widen);\n+  const TypeLong* r0 = t0->is_long();\n+  const TypeLong* r1 = t1->is_long();\n@@ -772,1 +801,1 @@\n-  return TypeLong::LONG;        \/\/ No constants to be had\n+  return and_value<TypeLong>(r0, r1);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":69,"deletions":40,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * @bug 8297384\n+ * @bug 8297384 8335444\n+ * @key randomness\n@@ -41,1 +42,1 @@\n-    @Run(test = { \"test1\", \"test2\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\", \"test10\" })\n@@ -50,0 +51,4 @@\n+        assertResult(10, 20);\n+        assertResult(10, -20);\n+        assertResult(-10, 20);\n+        assertResult(-10, -20);\n@@ -51,0 +56,1 @@\n+        assertResult(b, a);\n@@ -59,0 +65,8 @@\n+        Asserts.assertEQ((a & 15) >= 0, test3(a, b));\n+        Asserts.assertEQ((a & 15) > 15, test4(a, b));\n+        Asserts.assertEQ((a & (b >>> 1)) >= 0, test5(a, b));\n+        Asserts.assertEQ((a & (b >>> 30)) > 3, test6(a, b));\n+        Asserts.assertEQ(((byte)a & -8) >= -128, test7(a, b));\n+        Asserts.assertEQ(((byte)a & -8) <= 127, test8(a, b));\n+        Asserts.assertEQ(((a & 255) & (char)b) > 255, test9(a, b));\n+        Asserts.assertEQ((((a & 1) - 3) & ((b & 2) - 10)) > -8, test10(a, b));\n@@ -77,0 +91,56 @@\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & 15 => [0, 15]\n+    public boolean test3(int a, int b) {\n+        return (a & 15) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & 15 => [0, 15]\n+    public boolean test4(int a, int b) {\n+        return (a & 15) > 15;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & [0, int_max] => [0, int_max]\n+    public boolean test5(int a, int b) {\n+        return (a & (b >>> 1)) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & [0, 3] => [0, 3]\n+    public boolean test6(int a, int b) {\n+        return (a & (b >>> 30)) > 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks [-128, 127] & -8 => [-128, 127]\n+    public boolean test7(int a, int b) {\n+        return ((byte)a & -8) >= -128;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks [-128, 127] & -8 => [-128, 127]\n+    public boolean test8(int a, int b) {\n+        return ((byte)a & -8) <= 127;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks that [0, 255] & [0, 65535] => [0, 255]\n+    public boolean test9(int a, int b) {\n+        return ((a & 255) & (char)b) > 255;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks that [-3, -2] & [-10, -8] => [-16, -8]\n+    public boolean test10(int a, int b) {\n+        return (((a & 1) - 3) & ((b & 2) - 10)) > -8;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AndINodeIdealizationTests.java","additions":72,"deletions":2,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * @bug 8322589\n+ * @bug 8322589 8335444\n+ * @key randomness\n@@ -41,1 +42,1 @@\n-    @Run(test = { \"test1\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\" })\n@@ -50,0 +51,4 @@\n+        assertResult(10, 20);\n+        assertResult(10, -20);\n+        assertResult(-10, 20);\n+        assertResult(-10, -20);\n@@ -51,0 +56,1 @@\n+        assertResult(b, a);\n@@ -58,0 +64,8 @@\n+        Asserts.assertEQ((a & 15) >= 0, test2(a, b));\n+        Asserts.assertEQ((a & 15) > 15, test3(a, b));\n+        Asserts.assertEQ((a & (b >>> 1)) >= 0, test4(a, b));\n+        Asserts.assertEQ((a & (b >>> 62)) > 3, test5(a, b));\n+        Asserts.assertEQ(((byte)a & -8L) >= -128, test6(a, b));\n+        Asserts.assertEQ(((byte)a & -8L) <= 127, test7(a, b));\n+        Asserts.assertEQ(((a & 255) & (char)b) > 255, test8(a, b));\n+        Asserts.assertEQ((((a & 1) - 3) & ((b & 2) - 10)) > -8, test9(a, b));\n@@ -68,0 +82,56 @@\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & 15 => [0, 15]\n+    public boolean test2(long a, long b) {\n+        return (a & 15) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & 15 => [0, 15]\n+    public boolean test3(long a, long b) {\n+        return (a & 15) > 15;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & [0, long_max] => [0, long_max]\n+    public boolean test4(long a, long b) {\n+        return (a & (b >>> 1)) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & [0, 3] => [0, 3]\n+    public boolean test5(long a, long b) {\n+        return (a & (b >>> 62)) > 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks [-128, 127] & -8 => [-128, 127]\n+    public boolean test6(long a, long b) {\n+        return ((byte)a & -8L) >= -128;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks [-128, 127] & -8 => [-128, 127]\n+    public boolean test7(long a, long b) {\n+        return ((byte)a & -8L) <= 127;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks that [0, 255] & [0, 65535] => [0, 255]\n+    public boolean test8(long a, long b) {\n+        return ((a & 255) & (char)b) > 255;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks that [-3, -2] & [-10, -8] => [-16, -8]\n+    public boolean test9(long a, long b) {\n+        return (((a & 1) - 3) & ((b & 2) - 10)) > -8;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AndLNodeIdealizationTests.java","additions":72,"deletions":2,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,3 +75,2 @@\n-    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n-        counts = {IRNode.AND_VB, \">0\"})\n-    @IR(applyIfCPUFeatureAnd = {\"avx512f\", \"false\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        phase = CompilePhase.BEFORE_MACRO_EXPANSION,\n@@ -78,2 +78,0 @@\n-    @IR(applyIfCPUFeature = {\"avx512f\", \"true\"},\n-        counts = {IRNode.MACRO_LOGIC_V, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,3 @@\n+    private boolean[] boolsA;\n+    private boolean[] boolsB;\n+    private boolean[] resZ;\n@@ -61,0 +64,3 @@\n+        boolsA = new boolean[COUNT];\n+        boolsB = new boolean[COUNT];\n+        resZ = new boolean[COUNT];\n@@ -76,0 +82,2 @@\n+            boolsA[i] = r.nextBoolean();\n+            boolsB[i] = r.nextBoolean();\n@@ -369,0 +377,7 @@\n+    @Benchmark\n+    public void andZ() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resZ[i] = boolsA[i] & boolsB[i];\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"}]}