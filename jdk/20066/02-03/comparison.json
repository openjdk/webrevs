{"files":[{"patch":"@@ -600,0 +600,1 @@\n+  static_assert(std::is_signed<NativeType>::value, \"Native type of IntegerType must be signed!\");\n@@ -601,1 +602,1 @@\n-  int widen = MAX2(r0->_widen,r1->_widen);\n+  int widen = MAX2(r0->_widen, r1->_widen);\n@@ -603,2 +604,2 @@\n-  \/\/ If both are constants, we can calculate a precise result.\n-  if(r0->is_con() && r1->is_con()) {\n+  \/\/ If both types are constants, we can calculate a constant result.\n+  if (r0->is_con() && r1->is_con()) {\n@@ -608,1 +609,2 @@\n-  \/\/ If both ranges are positive, the result will range from 0 up to the maximum value of the smaller range.\n+  \/\/ If both ranges are positive, the result will range from 0 up to the hi value of the smaller range. The minimum\n+  \/\/ of the two constrains the upper bound because any higher value in the other range will see all zeroes, so it will be masked out.\n@@ -614,0 +616,3 @@\n+  \/\/ For the operation 'x & C' where C is a positive constant, the result will be in the range [0..C]. With that observation,\n+  \/\/ we can say that for any integer c such that 0 <= c <= C will also be in the range [0..C]. Therefore, 'x & [c..C]'\n+  \/\/ where c >= 0 will be in the range [0..C].\n@@ -626,1 +631,0 @@\n-  static_assert(std::is_signed<NativeType>::value, \"native type of IntegerType must be signed!\");\n@@ -628,2 +632,2 @@\n-  \/\/ The lower bound of both ranges will contain the common leading 1-bits. In order to count them with count_leading_zeros,\n-  \/\/ the bits are inverted.\n+  \/\/ As two's complement means that both numbers will start with leading 1s, the lower bound of both ranges will contain\n+  \/\/ the common leading 1s of both minimum values. In order to count them with count_leading_zeros, the bits are inverted.\n@@ -632,4 +636,20 @@\n-  \/\/ To get the number of bits to shift, we count the leading 0-bits and then subtract one, as the sign bit is already set.\n-  \/\/ Since count_leading_zeros is undefined at 0 (~(-1)) the number of digits in the native type can be used instead,\n-  \/\/ as it returns 31 and 63 for signed integers and longs respectively.\n-  int shift_bits = sel_val == 0 ? std::numeric_limits<NativeType>::digits : count_leading_zeros(sel_val) - 1;\n+  NativeType min;\n+  if (sel_val == 0) {\n+    \/\/ Since count_leading_zeros is undefined at 0, we short-circuit the condition where both ranges have a minimum of -1.\n+    min = -1;\n+  } else {\n+    \/\/ To get the number of bits to shift, we count the leading 0-bits and then subtract one, as the sign bit is already set.\n+    int shift_bits = count_leading_zeros(sel_val) - 1;\n+    min = std::numeric_limits<NativeType>::min() >> shift_bits;\n+  }\n+\n+  NativeType max;\n+  if (r0->_hi < 0 && r1->_hi < 0) {\n+    \/\/ If both ranges are negative, then the same optimization as both positive ranges will apply, and the smaller hi\n+    \/\/ value will mask off any bits set by higher values.\n+    max = MIN2(r0->_hi, r1->_hi);\n+  } else {\n+    \/\/ In the case of ranges that cross zero, negative values can cause the higher order bits to be set, so the maximum\n+    \/\/ positive value can be as high as the larger hi value.\n+    max = MAX2(r0->_hi, r1->_hi);\n+  }\n@@ -637,2 +657,1 @@\n-  \/\/ Since the result of bitwise-and can be as high as the largest value of each range, the result should find the maximum.\n-  return IntegerType::make(std::numeric_limits<NativeType>::min() >> shift_bits, MAX2(r0->_hi, r1->_hi), widen);\n+  return IntegerType::make(min, max, widen);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":32,"deletions":13,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\", \"test10\" })\n@@ -72,0 +72,1 @@\n+        Asserts.assertEQ((((a & 1) - 3) & ((b & 2) - 10)) > -8, test10(a, b));\n@@ -139,0 +140,7 @@\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks that [-3, -2] & [-10, -8] => [-16, -8]\n+    public boolean test10(int a, int b) {\n+        return (((a & 1) - 3) & ((b & 2) - 10)) > -8;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AndINodeIdealizationTests.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\" })\n@@ -71,0 +71,1 @@\n+        Asserts.assertEQ((((a & 1) - 3) & ((b & 2) - 10)) > -8, test9(a, b));\n@@ -130,0 +131,7 @@\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks that [-3, -2] & [-10, -8] => [-16, -8]\n+    public boolean test9(long a, long b) {\n+        return (((a & 1) - 3) & ((b & 2) - 10)) > -8;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AndLNodeIdealizationTests.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"}]}