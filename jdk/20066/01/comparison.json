{"files":[{"patch":"@@ -597,0 +597,44 @@\n+template<typename IntegerType>\n+static const IntegerType* and_value(const IntegerType* r0, const IntegerType* r1) {\n+  typedef typename IntegerType::NativeType NativeType;\n+\n+  int widen = MAX2(r0->_widen,r1->_widen);\n+\n+  \/\/ If both are constants, we can calculate a precise result.\n+  if(r0->is_con() && r1->is_con()) {\n+    return IntegerType::make(r0->get_con() & r1->get_con());\n+  }\n+\n+  \/\/ If both ranges are positive, the result will range from 0 up to the maximum value of the smaller range.\n+  if (r0->_lo >= 0 && r1->_lo >= 0) {\n+    return IntegerType::make(0, MIN2(r0->_hi, r1->_hi), widen);\n+  }\n+\n+  \/\/ If only one range is positive, the result will range from 0 up to that range's maximum value.\n+  if (r0->_lo >= 0) {\n+    return IntegerType::make(0, r0->_hi, widen);\n+  }\n+\n+  if (r1->_lo >= 0) {\n+    return IntegerType::make(0, r1->_hi, widen);\n+  }\n+\n+  \/\/ At this point, all positive ranges will have already been handled, so the only remaining cases will be negative ranges\n+  \/\/ and constants.\n+\n+  assert(r0->_lo < 0 && r1->_lo < 0, \"positive ranges should already be handled!\");\n+  static_assert(std::is_signed<NativeType>::value, \"native type of IntegerType must be signed!\");\n+\n+  \/\/ The lower bound of both ranges will contain the common leading 1-bits. In order to count them with count_leading_zeros,\n+  \/\/ the bits are inverted.\n+  NativeType sel_val = ~MIN2(r0->_lo, r1->_lo);\n+\n+  \/\/ To get the number of bits to shift, we count the leading 0-bits and then subtract one, as the sign bit is already set.\n+  \/\/ Since count_leading_zeros is undefined at 0 (~(-1)) the number of digits in the native type can be used instead,\n+  \/\/ as it returns 31 and 63 for signed integers and longs respectively.\n+  int shift_bits = sel_val == 0 ? std::numeric_limits<NativeType>::digits : count_leading_zeros(sel_val) - 1;\n+\n+  \/\/ Since the result of bitwise-and can be as high as the largest value of each range, the result should find the maximum.\n+  return IntegerType::make(std::numeric_limits<NativeType>::min() >> shift_bits, MAX2(r0->_hi, r1->_hi), widen);\n+}\n+\n@@ -604,17 +648,2 @@\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-  int widen = MAX2(r0->_widen,r1->_widen);\n-\n-  \/\/ If either input is a constant, might be able to trim cases\n-  if( !r0->is_con() && !r1->is_con() )\n-    return TypeInt::INT;        \/\/ No constants to be had\n-\n-  \/\/ Both constants?  Return bits\n-  if( r0->is_con() && r1->is_con() )\n-    return TypeInt::make( r0->get_con() & r1->get_con() );\n-\n-  if( r0->is_con() && r0->get_con() > 0 )\n-    return TypeInt::make(0, r0->get_con(), widen);\n-\n-  if( r1->is_con() && r1->get_con() > 0 )\n-    return TypeInt::make(0, r1->get_con(), widen);\n+  const TypeInt* r0 = t0->is_int();\n+  const TypeInt* r1 = t1->is_int();\n@@ -622,5 +651,1 @@\n-  if( r0 == TypeInt::BOOL || r1 == TypeInt::BOOL ) {\n-    return TypeInt::BOOL;\n-  }\n-\n-  return TypeInt::INT;          \/\/ No constants to be had\n+  return and_value<TypeInt>(r0, r1);\n@@ -754,17 +779,2 @@\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-  int widen = MAX2(r0->_widen,r1->_widen);\n-\n-  \/\/ If either input is a constant, might be able to trim cases\n-  if( !r0->is_con() && !r1->is_con() )\n-    return TypeLong::LONG;      \/\/ No constants to be had\n-\n-  \/\/ Both constants?  Return bits\n-  if( r0->is_con() && r1->is_con() )\n-    return TypeLong::make( r0->get_con() & r1->get_con() );\n-\n-  if( r0->is_con() && r0->get_con() > 0 )\n-    return TypeLong::make(CONST64(0), r0->get_con(), widen);\n-\n-  if( r1->is_con() && r1->get_con() > 0 )\n-    return TypeLong::make(CONST64(0), r1->get_con(), widen);\n+  const TypeLong* r0 = t0->is_long();\n+  const TypeLong* r1 = t1->is_long();\n@@ -772,1 +782,1 @@\n-  return TypeLong::LONG;        \/\/ No constants to be had\n+  return and_value<TypeLong>(r0, r1);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":50,"deletions":40,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * @bug 8297384\n+ * @bug 8297384 8335444\n+ * @key randomness\n@@ -41,1 +42,1 @@\n-    @Run(test = { \"test1\", \"test2\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\", \"test9\" })\n@@ -50,0 +51,4 @@\n+        assertResult(10, 20);\n+        assertResult(10, -20);\n+        assertResult(-10, 20);\n+        assertResult(-10, -20);\n@@ -51,0 +56,1 @@\n+        assertResult(b, a);\n@@ -59,0 +65,7 @@\n+        Asserts.assertEQ((a & 15) >= 0, test3(a, b));\n+        Asserts.assertEQ((a & 15) > 15, test4(a, b));\n+        Asserts.assertEQ((a & (b >>> 1)) >= 0, test5(a, b));\n+        Asserts.assertEQ((a & (b >>> 30)) > 3, test6(a, b));\n+        Asserts.assertEQ(((byte)a & -8) >= -128, test7(a, b));\n+        Asserts.assertEQ(((byte)a & -8) <= 127, test8(a, b));\n+        Asserts.assertEQ(((a & 255) & (char)b) > 255, test9(a, b));\n@@ -77,0 +90,49 @@\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & 15 => [0, 15]\n+    public boolean test3(int a, int b) {\n+        return (a & 15) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & 15 => [0, 15]\n+    public boolean test4(int a, int b) {\n+        return (a & 15) > 15;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & [0, int_max] => [0, int_max]\n+    public boolean test5(int a, int b) {\n+        return (a & (b >>> 1)) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & [0, 3] => [0, 3]\n+    public boolean test6(int a, int b) {\n+        return (a & (b >>> 30)) > 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks [-128, 127] & -8 => [-128, 127]\n+    public boolean test7(int a, int b) {\n+        return ((byte)a & -8) >= -128;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks [-128, 127] & -8 => [-128, 127]\n+    public boolean test8(int a, int b) {\n+        return ((byte)a & -8) <= 127;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks that [0, 255] & [0, 65535] => [0, 255]\n+    public boolean test9(int a, int b) {\n+        return ((a & 255) & (char)b) > 255;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AndINodeIdealizationTests.java","additions":64,"deletions":2,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * @bug 8322589\n+ * @bug 8322589 8335444\n+ * @key randomness\n@@ -41,1 +42,1 @@\n-    @Run(test = { \"test1\" })\n+    @Run(test = { \"test1\", \"test2\", \"test3\", \"test4\", \"test5\", \"test6\", \"test7\", \"test8\" })\n@@ -50,0 +51,4 @@\n+        assertResult(10, 20);\n+        assertResult(10, -20);\n+        assertResult(-10, 20);\n+        assertResult(-10, -20);\n@@ -51,0 +56,1 @@\n+        assertResult(b, a);\n@@ -58,0 +64,7 @@\n+        Asserts.assertEQ((a & 15) >= 0, test2(a, b));\n+        Asserts.assertEQ((a & 15) > 15, test3(a, b));\n+        Asserts.assertEQ((a & (b >>> 1)) >= 0, test4(a, b));\n+        Asserts.assertEQ((a & (b >>> 62)) > 3, test5(a, b));\n+        Asserts.assertEQ(((byte)a & -8L) >= -128, test6(a, b));\n+        Asserts.assertEQ(((byte)a & -8L) <= 127, test7(a, b));\n+        Asserts.assertEQ(((a & 255) & (char)b) > 255, test8(a, b));\n@@ -68,0 +81,49 @@\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & 15 => [0, 15]\n+    public boolean test2(long a, long b) {\n+        return (a & 15) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & 15 => [0, 15]\n+    public boolean test3(long a, long b) {\n+        return (a & 15) > 15;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & [0, long_max] => [0, long_max]\n+    public boolean test4(long a, long b) {\n+        return (a & (b >>> 1)) >= 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks a & [0, 3] => [0, 3]\n+    public boolean test5(long a, long b) {\n+        return (a & (b >>> 62)) > 3;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks [-128, 127] & -8 => [-128, 127]\n+    public boolean test6(long a, long b) {\n+        return ((byte)a & -8L) >= -128;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks [-128, 127] & -8 => [-128, 127]\n+    public boolean test7(long a, long b) {\n+        return ((byte)a & -8L) <= 127;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND })\n+    \/\/ Checks that [0, 255] & [0, 65535] => [0, 255]\n+    public boolean test8(long a, long b) {\n+        return ((a & 255) & (char)b) > 255;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/AndLNodeIdealizationTests.java","additions":64,"deletions":2,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,3 +75,1 @@\n-    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n-        counts = {IRNode.AND_VB, \">0\"})\n-    @IR(applyIfCPUFeatureAnd = {\"avx512f\", \"false\", \"sse2\", \"true\"},\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n@@ -78,2 +77,0 @@\n-    @IR(applyIfCPUFeature = {\"avx512f\", \"true\"},\n-        counts = {IRNode.MACRO_LOGIC_V, \">0\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/BasicBooleanOpTest.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,3 @@\n+    private boolean[] boolsA;\n+    private boolean[] boolsB;\n+    private boolean[] resZ;\n@@ -61,0 +64,3 @@\n+        boolsA = new boolean[COUNT];\n+        boolsB = new boolean[COUNT];\n+        resZ = new boolean[COUNT];\n@@ -76,0 +82,2 @@\n+            boolsA[i] = r.nextBoolean();\n+            boolsB[i] = r.nextBoolean();\n@@ -369,0 +377,7 @@\n+    @Benchmark\n+    public void andZ() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resZ[i] = boolsA[i] & boolsB[i];\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"}]}