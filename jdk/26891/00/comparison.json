{"files":[{"patch":"@@ -63,0 +63,1 @@\n+    _caller_jvms->set_receiver_info(caller_jvms->receiver_info());\n@@ -440,1 +441,0 @@\n-    \/\/ count the current method and the callee\n@@ -442,5 +442,5 @@\n-    int inline_level = 0;\n-    if (!is_compiled_lambda_form) {\n-      if (method() == callee_method) {\n-        inline_level++;\n-      }\n+    const bool is_method_handle_invoker = is_compiled_lambda_form && !jvms->method()->is_compiled_lambda_form();\n+\n+    ciInstance* lform_callee_recv = nullptr;\n+    if (is_compiled_lambda_form && !is_method_handle_invoker) { \/\/ MH invokers don't have a receiver\n+      lform_callee_recv = jvms->compute_receiver_info(callee_method);\n@@ -448,3 +448,3 @@\n-    \/\/ count callers of current method and callee\n-    Node* callee_argument0 = is_compiled_lambda_form ? jvms->map()->argument(jvms, 0)->uncast() : nullptr;\n-    for (JVMState* j = jvms->caller(); j != nullptr && j->has_method(); j = j->caller()) {\n+\n+    int inline_level = 0;\n+    for (JVMState* j = jvms; j != nullptr && j->has_method(); j = j->caller()) {\n@@ -452,6 +452,9 @@\n-        if (is_compiled_lambda_form) {\n-          \/\/ Since compiled lambda forms are heavily reused we allow recursive inlining.  If it is truly\n-          \/\/ a recursion (using the same \"receiver\") we limit inlining otherwise we can easily blow the\n-          \/\/ compiler stack.\n-          Node* caller_argument0 = j->map()->argument(j, 0)->uncast();\n-          if (caller_argument0 == callee_argument0) {\n+        \/\/ Since compiled lambda forms are heavily reused we allow recursive inlining.  If it is truly\n+        \/\/ a recursion (using the same \"receiver\") we limit inlining otherwise we can easily blow the\n+        \/\/ compiler stack.\n+        if (lform_callee_recv != nullptr) {\n+          ciInstance* lform_caller_recv = j->receiver_info();\n+          assert(lform_caller_recv != nullptr || j->depth() == 1 ||\n+                 !j->caller()->method()->is_compiled_lambda_form(), \/\/ MH invoker\n+                 \"missing receiver info\");\n+          if (lform_caller_recv == lform_callee_recv || lform_caller_recv == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -265,1 +265,2 @@\n-  _method(method) {\n+  _method(method),\n+  _receiver_info(nullptr) {\n@@ -281,1 +282,2 @@\n-  _method(nullptr) {\n+  _method(nullptr),\n+  _receiver_info(nullptr) {\n@@ -616,0 +618,1 @@\n+  n->set_receiver_info(_receiver_info);\n@@ -690,0 +693,14 @@\n+\/\/ Compute receiver info for a compiled lambda form at call site.\n+ciInstance* JVMState::compute_receiver_info(ciMethod* callee) const {\n+  assert(callee != nullptr && callee->is_compiled_lambda_form(), \"\");\n+  if (has_method() && method()->is_compiled_lambda_form()) { \/\/ callee is not a MH invoker\n+    Node* recv = map()->argument(this, 0);\n+    assert(recv != nullptr, \"\");\n+    const TypeOopPtr* recv_toop = recv->bottom_type()->isa_oopptr();\n+    if (recv_toop != nullptr && recv_toop->const_oop() != nullptr) {\n+      return recv_toop->const_oop()->as_instance();\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -1367,1 +1384,1 @@\n-void SafePointNode::set_local(JVMState* jvms, uint idx, Node *c) {\n+void SafePointNode::set_local(const JVMState* jvms, uint idx, Node *c) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -220,0 +220,1 @@\n+  ciInstance*       _receiver_info; \/\/ Constant receiver instance for compiled lambda forms\n@@ -262,0 +263,1 @@\n+  ciInstance*    receiver_info() const { assert(has_method(), \"\"); return _receiver_info; }\n@@ -307,0 +309,1 @@\n+  void              set_receiver_info(ciInstance* recv) { assert(has_method() || recv == nullptr, \"\"); _receiver_info = recv; }\n@@ -314,0 +317,1 @@\n+  ciInstance* compute_receiver_info(ciMethod* callee) const;\n@@ -377,1 +381,1 @@\n-  void verify_input(JVMState* jvms, uint idx) const {\n+  void verify_input(const JVMState* jvms, uint idx) const {\n@@ -386,3 +390,5 @@\n-  Node *local(JVMState* jvms, uint idx) const {\n-    verify_input(jvms, jvms->locoff() + idx);\n-    return in(jvms->locoff() + idx);\n+  Node* local(const JVMState* jvms, uint idx) const {\n+    uint loc_idx = jvms->locoff() + idx;\n+    assert(jvms->is_loc(loc_idx), \"not a local slot\");\n+    verify_input(jvms, loc_idx);\n+    return in(loc_idx);\n@@ -390,3 +396,5 @@\n-  Node *stack(JVMState* jvms, uint idx) const {\n-    verify_input(jvms, jvms->stkoff() + idx);\n-    return in(jvms->stkoff() + idx);\n+  Node* stack(const JVMState* jvms, uint idx) const {\n+    uint stk_idx = jvms->stkoff() + idx;\n+    assert(jvms->is_stk(stk_idx), \"not a stack slot\");\n+    verify_input(jvms, stk_idx);\n+    return in(stk_idx);\n@@ -394,2 +402,4 @@\n-  Node *argument(JVMState* jvms, uint idx) const {\n-    verify_input(jvms, jvms->argoff() + idx);\n+  Node* argument(const JVMState* jvms, uint idx) const {\n+    uint arg_idx = jvms->argoff() + idx;\n+    assert(jvms->is_stk(arg_idx), \"not an argument slot\");\n+    verify_input(jvms, arg_idx);\n@@ -398,1 +408,1 @@\n-  Node *monitor_box(JVMState* jvms, uint idx) const {\n+  Node* monitor_box(const JVMState* jvms, uint idx) const {\n@@ -400,1 +410,3 @@\n-    return in(jvms->monitor_box_offset(idx));\n+    uint mon_box_idx = jvms->monitor_box_offset(idx);\n+    assert(jvms->is_monitor_box(mon_box_idx), \"not a monitor box offset\");\n+    return in(mon_box_idx);\n@@ -402,1 +414,1 @@\n-  Node *monitor_obj(JVMState* jvms, uint idx) const {\n+  Node* monitor_obj(const JVMState* jvms, uint idx) const {\n@@ -404,1 +416,3 @@\n-    return in(jvms->monitor_obj_offset(idx));\n+    uint mon_obj_idx = jvms->monitor_obj_offset(idx);\n+    assert(jvms->is_mon(mon_obj_idx) && !jvms->is_monitor_box(mon_obj_idx), \"not a monitor obj offset\");\n+    return in(mon_obj_idx);\n@@ -407,1 +421,1 @@\n-  void  set_local(JVMState* jvms, uint idx, Node *c);\n+  void  set_local(const JVMState* jvms, uint idx, Node *c);\n@@ -409,1 +423,1 @@\n-  void  set_stack(JVMState* jvms, uint idx, Node *c) {\n+  void  set_stack(const JVMState* jvms, uint idx, Node *c) {\n@@ -413,1 +427,1 @@\n-  void  set_argument(JVMState* jvms, uint idx, Node *c) {\n+  void  set_argument(const JVMState* jvms, uint idx, Node *c) {\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":30,"deletions":16,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1152,0 +1152,7 @@\n+\n+  \/\/ Capture receiver info for compiled lambda forms.\n+  if (method()->is_compiled_lambda_form()) {\n+    ciInstance* recv_info = _caller->compute_receiver_info(method());\n+    jvms->set_receiver_info(recv_info);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}