{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,32 +40,1 @@\n-    static class Result {\n-        private final WindowsPathType type;\n-        private final String root;\n-        private final String path;\n-\n-        Result(WindowsPathType type, String root, String path) {\n-            this.type = type;\n-            this.root = root;\n-            this.path = path;\n-        }\n-\n-        \/**\n-         * The path type\n-         *\/\n-        WindowsPathType type() {\n-            return type;\n-        }\n-\n-        \/**\n-         * The root component\n-         *\/\n-        String root() {\n-            return root;\n-        }\n-\n-        \/**\n-         * The normalized path (includes root)\n-         *\/\n-        String path() {\n-            return path;\n-        }\n-    }\n+    record Result(WindowsPathType type, String root, String path) {};\n@@ -120,1 +89,1 @@\n-                \/\/ UNC: We keep the first two slash, collapse all the\n+                \/\/ UNC: We keep the first two slashes, collapse all the\n@@ -173,3 +142,1 @@\n-            StringBuilder sb = new StringBuilder(input.length());\n-            sb.append(root);\n-            return new Result(type, root, normalize(sb, input, off));\n+            return new Result(type, root, normalize(root, input, off));\n@@ -185,4 +152,22 @@\n-    private static String normalize(StringBuilder sb, String path, int off) {\n-        int len = path.length();\n-        off = nextNonSlash(path, off, len);\n-        int start = off;\n+    private static String normalize(String root, String path, int pathOff) {\n+\n+        int rootLen = root.length();\n+        int pathLen = path.length();\n+\n+        \/\/ the result array will initally contain the characters of root in\n+        \/\/ the first rootLen elements followed by the chanacters of path from\n+        \/\/ position index pathOff to the end of path\n+        char[] result = new char[rootLen + pathLen - pathOff];\n+        root.getChars(0, rootLen, result, 0);\n+        path.getChars(pathOff, pathLen, result, rootLen);\n+\n+        \/\/ the portion of array derived from path is normalized by copying\n+        \/\/ from position srcPos to position dstPos, and as the invariant\n+        \/\/ dstPos <= srcPos holds, no characters can be overwritten\n+        int dstPos = rootLen;\n+        int srcPos = nextNonSlash(result, rootLen, result.length);\n+\n+        \/\/ pathPos is the position in array which is being tested as to\n+        \/\/ whether the element at that position is a slash\n+        int pathPos = srcPos;\n+\n@@ -190,2 +175,2 @@\n-        while (off < len) {\n-            char c = path.charAt(off);\n+        while (pathPos < result.length) {\n+            char c = result[pathPos];\n@@ -196,6 +181,8 @@\n-                                                   off - 1);\n-                sb.append(path, start, off);\n-                off = nextNonSlash(path, off, len);\n-                if (off != len)   \/\/no slash at the end of normalized path\n-                    sb.append('\\\\');\n-                start = off;\n+                                                   pathPos - 1);\n+                int nchars = pathPos - srcPos;\n+                System.arraycopy(result, srcPos, result, dstPos, nchars);\n+                dstPos += nchars;\n+                pathPos = nextNonSlash(result, pathPos, result.length);\n+                if (pathPos != result.length)   \/\/no slash at the end of normalized path\n+                    result[dstPos++] = '\\\\';\n+                srcPos = pathPos;\n@@ -206,1 +193,1 @@\n-                                                   off);\n+                                                   pathPos);\n@@ -208,1 +195,1 @@\n-                off++;\n+                pathPos++;\n@@ -211,1 +198,1 @@\n-        if (start != off) {\n+        if (srcPos != pathPos) {\n@@ -215,2 +202,4 @@\n-                                               off - 1);\n-            sb.append(path, start, off);\n+                                               pathPos - 1);\n+            int nchars = pathPos - srcPos;\n+            System.arraycopy(result, srcPos, result, dstPos, nchars);\n+            dstPos += nchars;\n@@ -218,1 +207,1 @@\n-        return sb.toString();\n+        return new String(result, 0, dstPos);\n@@ -230,0 +219,5 @@\n+    private static final int nextNonSlash(char[] path, int off, int end) {\n+        while (off < end && isSlash(path[off])) { off++; }\n+        return off;\n+    }\n+\n@@ -242,0 +236,12 @@\n+    private static final int nextSlash(char[] path, int off, int end) {\n+        char c;\n+        while (off < end && !isSlash(c=path[off])) {\n+            if (isInvalidPathChar(c))\n+                throw new InvalidPathException(new String(path),\n+                                               \"Illegal character [\" + c + \"] in path\",\n+                                               off);\n+            off++;\n+        }\n+        return off;\n+    }\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsPathParser.java","additions":61,"deletions":55,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.nio.file;\n+\n+import java.nio.file.Path;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+@State(Scope.Benchmark)\n+public class PathOfString {\n+    @Param({\"C:\\\\Users\\\\foo\\\\bar\\\\gus.txt\",              \/\/ absolute\n+            \"C:\\\\Users\\\\\\\\foo\\\\\\\\bar\\\\gus.txt\",          \/\/ ... with extra '\\\\'s\n+            \"\\\\\\\\.\\\\UNC\\\\localhost\\\\C$\\\\Users\\\\foo\",     \/\/ UNC\n+            \"\\\\\\\\.\\\\UNC\\\\localhost\\\\C$\\\\\\\\Users\\\\\\\\foo\", \/\/ ... with extra '\\\\'s\n+            \"\\\\\\\\?\\\\C:\\\\Users\\\\foo\\\\bar\\\\gus.txt\",       \/\/ long path prefix\n+            \"\\\\\\\\?\\\\C:\\\\Users\\\\\\\\foo\\\\bar\\\\\\\\gus.txt\",   \/\/ ... with extra '\\\\'s\n+            \".\\\\foo\\\\bar\\\\gus.txt\",                      \/\/ relative\n+            \".\\\\foo\\\\\\\\bar\\\\\\\\gus.txt\",                  \/\/ ... with extra '\\\\'s\n+            \"\\\\foo\\\\bar\\\\gus.txt\",                     \/\/ current drive-relative\n+            \"\\\\foo\\\\\\\\bar\\\\\\\\gus.txt\",                 \/\/ ... with extra '\\\\'s\n+            \"C:foo\\\\bar\\\\gus.txt\",         \/\/ drive's current directory-relative\n+            \"C:foo\\\\\\\\bar\\\\\\\\gus.txt\"})    \/\/ ... with extra '\\\\'s\n+\n+    public String path;\n+\n+    @Benchmark\n+    public Path parse() {\n+        return Path.of(path);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/nio\/file\/PathOfString.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"}]}