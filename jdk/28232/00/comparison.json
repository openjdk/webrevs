{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.net.http.HttpHeaders;\n@@ -67,0 +68,2 @@\n+    volatile Response cachedProxyResponse; \/\/ cached response from proxy 407\n+    volatile byte[] cachedProxyBody; \/\/ cached body from proxy 407 response\n@@ -231,0 +234,24 @@\n+        \/\/ If we have a cached proxy body (from 407 response), use it\n+        if (cachedProxyBody != null) {\n+            try {\n+                \/\/ Use cached response and body\n+                Response proxyResponse = cachedProxyResponse;\n+                byte[] bodyBytes = cachedProxyBody;\n+                cachedProxyResponse = null;\n+                cachedProxyBody = null;\n+\n+                HttpResponse.BodySubscriber<T> subscriber = handler.apply(\n+                        new ResponseInfoImpl(proxyResponse));\n+                subscriber.onSubscribe(new java.util.concurrent.Flow.Subscription() {\n+                    public void request(long n) {\n+                        subscriber.onNext(java.util.List.of(java.nio.ByteBuffer.wrap(bodyBytes)));\n+                        subscriber.onComplete();\n+                    }\n+                    public void cancel() {}\n+                });\n+                return subscriber.getBody().toCompletableFuture();\n+            } catch (Exception e) {\n+                return MinimalFuture.failedFuture(e);\n+            }\n+        }\n+\n@@ -458,1 +485,1 @@\n-        if (t instanceof ProxyAuthenticationRequired) {\n+        if (t instanceof ProxyAuthenticationRequired par) {\n@@ -460,2 +487,7 @@\n-            bodyIgnored = MinimalFuture.completedFuture(null);\n-            Response proxyResponse = ((ProxyAuthenticationRequired)t).proxyResponse;\n+            \/\/ Cache the proxy response and body if available\n+            cachedProxyResponse = par.proxyResponse;\n+            cachedProxyBody = par.proxyResponseBody;\n+            \/\/ Don't set bodyIgnored if we have a cached body\n+            if (cachedProxyBody == null) {\n+                bodyIgnored = MinimalFuture.completedFuture(null);\n+            }\n@@ -464,2 +496,3 @@\n-                    proxyResponse.headers, c, proxyResponse.statusCode,\n-                    proxyResponse.version, true);\n+                    cachedProxyResponse.headers, c, cachedProxyResponse.statusCode,\n+                    cachedProxyResponse.version, cachedProxyBody == null); \/\/ body ignored only if not cached\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+\n@@ -40,0 +41,1 @@\n+import static java.net.http.HttpResponse.BodyHandlers.ofByteArray;\n@@ -44,2 +46,2 @@\n- * encrypt. Used by WebSocket, as well as HTTP over SSL + Proxy.\n- * Wrapped in SSLTunnelConnection or AsyncSSLTunnelConnection for encryption.\n+ * encrypt. Used by WebSocket, as well as HTTP over SSL + Proxy. Wrapped in\n+ * SSLTunnelConnection or AsyncSSLTunnelConnection for encryption.\n@@ -68,1 +70,3 @@\n-        if (debug.on()) debug.log(\"Connecting plain connection\");\n+        if (debug.on()) {\n+            debug.log(\"Connecting plain connection\");\n+        }\n@@ -70,19 +74,35 @@\n-            .thenCompose(unused -> delegate.finishConnect())\n-            .thenCompose((Void v) -> {\n-                if (debug.on()) debug.log(\"sending HTTP\/1.1 CONNECT\");\n-                HttpClientImpl client = client();\n-                assert client != null;\n-                HttpRequestImpl req = new HttpRequestImpl(\"CONNECT\", address, proxyHeaders);\n-                MultiExchange<Void> mulEx = new MultiExchange<>(null, req,\n-                        client, discarding(), null);\n-                Exchange<Void> connectExchange = mulEx.getExchange();\n-\n-                return connectExchange\n-                        .responseAsyncImpl(delegate)\n-                        .thenCompose((Response resp) -> {\n-                            CompletableFuture<Void> cf = new MinimalFuture<>();\n-                            if (debug.on()) debug.log(\"got response: %d\", resp.statusCode());\n-                            if (resp.statusCode() == 407) {\n-                                return connectExchange.ignoreBody().handle((r,t) -> {\n-                                    \/\/ close delegate after reading body: we won't\n-                                    \/\/ be reusing that connection anyway.\n+                .thenCompose(unused -> delegate.finishConnect())\n+                .thenCompose((Void v) -> {\n+                    if (debug.on()) {\n+                        debug.log(\"sending HTTP\/1.1 CONNECT\");\n+                    }\n+                    HttpClientImpl client = client();\n+                    assert client != null;\n+                    HttpRequestImpl req = new HttpRequestImpl(\n+                            \"CONNECT\", address, proxyHeaders);\n+                    MultiExchange<byte[]> mulEx = new MultiExchange<>(\n+                            null, req, client, ofByteArray(), null);\n+                    Exchange<byte[]> connectExchange = mulEx.getExchange();\n+\n+                    return connectExchange\n+                            .responseAsyncImpl(delegate)\n+                            .thenCompose((Response resp) -> {\n+                                CompletableFuture<Void> cf =\n+                                        new MinimalFuture<>();\n+                                if (debug.on()) {\n+                                    debug.log(\"got response: %d\",\n+                                            resp.statusCode());\n+                                }\n+                                if (resp.statusCode() == 407) {\n+                                    \/\/ Read the 407 body\n+                                    return connectExchange.readBodyAsync(ofByteArray())\n+                                            .handle((bodyBytes, t) -> {\n+                                                \/\/ close delegate after reading body: we won't\n+                                                \/\/ be reusing that connection anyway.\n+                                                delegate.close();\n+                                                ProxyAuthenticationRequired authenticationRequired =\n+                                                        new ProxyAuthenticationRequired(resp, bodyBytes);\n+                                                cf.completeExceptionally(authenticationRequired);\n+                                                return cf;\n+                                            }).thenCompose(Function.identity());\n+                                } else if (resp.statusCode() != 200) {\n@@ -90,31 +110,34 @@\n-                                    ProxyAuthenticationRequired authenticationRequired =\n-                                            new ProxyAuthenticationRequired(resp);\n-                                    cf.completeExceptionally(authenticationRequired);\n-                                    return cf;\n-                                }).thenCompose(Function.identity());\n-                            } else if (resp.statusCode() != 200) {\n-                                delegate.close();\n-                                cf.completeExceptionally(new IOException(\n-                                        \"Tunnel failed, got: \"+ resp.statusCode()));\n-                            } else {\n-                                \/\/ get the initial\/remaining bytes\n-                                ByteBuffer b = ((Http1Exchange<?>)connectExchange.exchImpl).drainLeftOverBytes();\n-                                int remaining = b.remaining();\n-                                assert remaining == 0: \"Unexpected remaining: \" + remaining;\n-                                cf.complete(null);\n-                            }\n-                            return cf;\n-                        })\n-                        .handle((result, ex) -> {\n-                            if (ex == null) {\n-                                return MinimalFuture.completedFuture(result);\n-                            } else {\n-                                if (debug.on())\n-                                    debug.log(\"tunnel failed with \\\"%s\\\"\", ex.toString());\n-                                Throwable t = ex;\n-                                if (t instanceof CompletionException)\n-                                    t = t.getCause();\n-                                if (t instanceof HttpTimeoutException) {\n-                                    String msg = \"proxy tunneling CONNECT request timed out\";\n-                                    t = new HttpTimeoutException(msg);\n-                                    t.initCause(ex);\n+                                    cf.completeExceptionally(new IOException(\n+                                            \"Tunnel failed, got: \"\n+                                                    + resp.statusCode()));\n+                                } else {\n+                                    \/\/ get the initial\/remaining bytes\n+                                    ByteBuffer b = ((Http1Exchange<?>) connectExchange.exchImpl)\n+                                            .drainLeftOverBytes();\n+                                    int remaining = b.remaining();\n+                                    assert remaining == 0\n+                                            : \"Unexpected remaining: \" + remaining;\n+                                    cf.complete(null);\n+                                }\n+                                return cf;\n+                            })\n+                            .handle((result, ex) -> {\n+                                if (ex == null) {\n+                                    return MinimalFuture.completedFuture(\n+                                            result);\n+                                } else {\n+                                    if (debug.on()) {\n+                                        debug.log(\"tunnel failed with \\\"%s\\\"\",\n+                                                ex.toString());\n+                                    }\n+                                    Throwable t = ex;\n+                                    if (t instanceof CompletionException) {\n+                                        t = t.getCause();\n+                                    }\n+                                    if (t instanceof HttpTimeoutException) {\n+                                        String msg =\n+                                                \"proxy tunneling CONNECT request timed out\";\n+                                        t = new HttpTimeoutException(msg);\n+                                        t.initCause(ex);\n+                                    }\n+                                    return MinimalFuture.<Void>failedFuture(t);\n@@ -122,5 +145,3 @@\n-                                return MinimalFuture.<Void>failedFuture(t);\n-                            }\n-                        })\n-                        .thenCompose(Function.identity());\n-            });\n+                            })\n+                            .thenCompose(Function.identity());\n+                });\n@@ -135,1 +156,3 @@\n-    boolean isTunnel() { return true; }\n+    boolean isTunnel() {\n+        return true;\n+    }\n@@ -138,1 +161,3 @@\n-    HttpPublisher publisher() { return delegate.publisher(); }\n+    HttpPublisher publisher() {\n+        return delegate.publisher();\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainTunnelingConnection.java","additions":85,"deletions":60,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+    final transient byte[] proxyResponseBody;\n@@ -38,6 +39,0 @@\n-    \/**\n-     * Constructs a {@code ProxyAuthenticationRequired} with the specified detail\n-     * message and cause.\n-     *\n-     * @param   proxyResponse the response from the proxy\n-     *\/\n@@ -45,0 +40,4 @@\n+        this(proxyResponse, null);\n+    }\n+\n+    public ProxyAuthenticationRequired(Response proxyResponse, byte[] proxyResponseBody) {\n@@ -48,0 +47,1 @@\n+        this.proxyResponseBody = proxyResponseBody;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ProxyAuthenticationRequired.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * @test\n+ * @bug 8328894\n+ * @summary HttpResponse.body() returns null with HTTPS target and failed proxy authentication\n+ * @library \/test\/lib\n+ * @run main\/othervm ProxyAuthHttpTest\n+ *\/\n+\n+import java.io.*;\n+import java.net.*;\n+import java.net.http.*;\n+import java.util.concurrent.*;\n+import java.util.stream.*;\n+import com.sun.net.httpserver.HttpServer;\n+\n+\/**\n+ * This test reproduces JDK-8328894:\n+ * When a proxy requires authentication, HTTPS requests receive a 407 response\n+ * but HttpResponse.body() returns null, while HTTP requests return a proper body.\n+ *\n+ * This test verifies the fix by testing:\n+ * 1. Basic HTTP and HTTPS 407 responses with body\n+ * 2. Various BodyHandlers (ofString, ofByteArray, ofInputStream, ofLines)\n+ * 3. Response headers (Content-Type, Content-Length, status code)\n+ * 4. Body content correctness\n+ *\/\n+public class ProxyAuthHttpTest {\n+\n+    static HttpServer targetServer;\n+    static ServerSocket proxySocket;\n+    static volatile boolean stop = false;\n+\n+    static final String EXPECTED_BODY = \"<html><body>Proxy Authentication Required<\/body><\/html>\";\n+    static int testsPassed = 0;\n+    static int testsFailed = 0;\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ 1. Start dummy target HTTP server (never actually reached)\n+        targetServer = HttpServer.create(new InetSocketAddress(0), 0);\n+        targetServer.createContext(\"\/\", exchange -> {\n+            byte[] body = \"OK\".getBytes();\n+            exchange.sendResponseHeaders(200, body.length);\n+            try (OutputStream os = exchange.getResponseBody()) {\n+                os.write(body);\n+            }\n+        });\n+        targetServer.start();\n+\n+        \/\/ 2. Start simple proxy that always responds 407\n+        proxySocket = new ServerSocket(0);\n+        Thread proxyThread = new Thread(ProxyAuthHttpTest::runProxy, \"proxy-thread\");\n+        proxyThread.setDaemon(true);\n+        proxyThread.start();\n+\n+        int proxyPort = proxySocket.getLocalPort();\n+        System.out.println(\"Proxy running on port \" + proxyPort);\n+\n+        \/\/ 3. Build HttpClient using this proxy\n+        InetSocketAddress proxyAddr = new InetSocketAddress(\"127.0.0.1\", proxyPort);\n+        HttpClient client = HttpClient.newBuilder()\n+                .proxy(ProxySelector.of(proxyAddr))\n+                .build();\n+\n+        try {\n+            \/\/ 4. Run comprehensive tests\n+            System.out.println(\"\\n=== Testing HTTP 407 responses ===\");\n+            testBasicResponse(client, \"http:\/\/example.invalid\/\");\n+            testBodyHandlerString(client, \"http:\/\/example.invalid\/\");\n+            testBodyHandlerByteArray(client, \"http:\/\/example.invalid\/\");\n+            testBodyHandlerInputStream(client, \"http:\/\/example.invalid\/\");\n+            testBodyHandlerLines(client, \"http:\/\/example.invalid\/\");\n+            testResponseHeaders(client, \"http:\/\/example.invalid\/\");\n+\n+            System.out.println(\"\\n=== Testing HTTPS 407 responses ===\");\n+            testBasicResponse(client, \"https:\/\/example.invalid\/\");\n+            testBodyHandlerString(client, \"https:\/\/example.invalid\/\");\n+            testBodyHandlerByteArray(client, \"https:\/\/example.invalid\/\");\n+            testBodyHandlerInputStream(client, \"https:\/\/example.invalid\/\");\n+            testBodyHandlerLines(client, \"https:\/\/example.invalid\/\");\n+            testResponseHeaders(client, \"https:\/\/example.invalid\/\");\n+\n+            \/\/ 5. Print summary\n+            System.out.println(\"\\n=== Test Summary ===\");\n+            System.out.println(\"Passed: \" + testsPassed);\n+            System.out.println(\"Failed: \" + testsFailed);\n+\n+            if (testsFailed > 0) {\n+                throw new RuntimeException(testsFailed + \" test(s) failed\");\n+            }\n+        } finally {\n+            stop = true;\n+            proxySocket.close();\n+            targetServer.stop(0);\n+        }\n+    }\n+\n+    private static void runProxy() {\n+        try {\n+            while (!stop) {\n+                Socket s = proxySocket.accept();\n+                new Thread(() -> handleProxyConnection(s)).start();\n+            }\n+        } catch (IOException ignored) {}\n+    }\n+\n+    private static void handleProxyConnection(Socket s) {\n+        try (Socket socket = s;\n+             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+             OutputStream out = socket.getOutputStream()) {\n+\n+            String firstLine = in.readLine();\n+            if (firstLine == null) return;\n+\n+            System.out.println(\"Proxy received: \" + firstLine);\n+\n+            String body = \"<html><body>Proxy Authentication Required<\/body><\/html>\";\n+            byte[] bytes = body.getBytes();\n+\n+            String resp = \"HTTP\/1.1 407 Proxy Authentication Required\\r\\n\" +\n+                    \"Content-Type: text\/html; charset=utf-8\\r\\n\" +\n+                    \"Proxy-Authenticate: Basic realm=\\\"Proxy\\\"\\r\\n\" +\n+                    \"Content-Length: \" + bytes.length + \"\\r\\n\" +\n+                    \"\\r\\n\";\n+\n+            out.write(resp.getBytes());\n+            out.write(bytes);\n+            out.flush();\n+        } catch (IOException ignored) {}\n+    }\n+\n+    \/\/ Test helper\n+    private static void test(String testName, boolean passed, String message) {\n+        if (passed) {\n+            System.out.println(\"  [PASS] \" + testName);\n+            testsPassed++;\n+        } else {\n+            System.out.println(\"  [FAIL] \" + testName + \": \" + message);\n+            testsFailed++;\n+        }\n+    }\n+\n+    \/\/ Test 1: Basic response body not null\n+    private static void testBasicResponse(HttpClient client, String url) throws Exception {\n+        System.out.println(\"\\nTest: Basic response (\" + url + \")\");\n+        HttpRequest req = HttpRequest.newBuilder(URI.create(url)).GET().build();\n+        HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());\n+\n+        test(\"Status code is 407\", res.statusCode() == 407,\n+             \"Expected 407, got \" + res.statusCode());\n+        test(\"Body is not null\", res.body() != null,\n+             \"Body is null\");\n+        test(\"Body matches expected\", EXPECTED_BODY.equals(res.body()),\n+             \"Expected '\" + EXPECTED_BODY + \"', got '\" + res.body() + \"'\");\n+    }\n+\n+    \/\/ Test 2: BodyHandlers.ofString()\n+    private static void testBodyHandlerString(HttpClient client, String url) throws Exception {\n+        System.out.println(\"\\nTest: BodyHandler.ofString() (\" + url + \")\");\n+        HttpRequest req = HttpRequest.newBuilder(URI.create(url)).GET().build();\n+        HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());\n+\n+        test(\"Body is not null\", res.body() != null, \"Body is null\");\n+        test(\"Body is String type\", res.body() instanceof String, \"Wrong type\");\n+        test(\"Body content correct\", EXPECTED_BODY.equals(res.body()),\n+             \"Content mismatch\");\n+    }\n+\n+    \/\/ Test 3: BodyHandlers.ofByteArray()\n+    private static void testBodyHandlerByteArray(HttpClient client, String url) throws Exception {\n+        System.out.println(\"\\nTest: BodyHandler.ofByteArray() (\" + url + \")\");\n+        HttpRequest req = HttpRequest.newBuilder(URI.create(url)).GET().build();\n+        HttpResponse<byte[]> res = client.send(req, HttpResponse.BodyHandlers.ofByteArray());\n+\n+        test(\"Body is not null\", res.body() != null, \"Body is null\");\n+        test(\"Body length correct\", res.body().length == EXPECTED_BODY.length(),\n+             \"Expected length \" + EXPECTED_BODY.length() + \", got \" + res.body().length);\n+        test(\"Body content correct\", EXPECTED_BODY.equals(new String(res.body())),\n+             \"Content mismatch\");\n+    }\n+\n+    \/\/ Test 4: BodyHandlers.ofInputStream()\n+    private static void testBodyHandlerInputStream(HttpClient client, String url) throws Exception {\n+        System.out.println(\"\\nTest: BodyHandler.ofInputStream() (\" + url + \")\");\n+        HttpRequest req = HttpRequest.newBuilder(URI.create(url)).GET().build();\n+        HttpResponse<InputStream> res = client.send(req, HttpResponse.BodyHandlers.ofInputStream());\n+\n+        test(\"Body is not null\", res.body() != null, \"Body is null\");\n+\n+        try (InputStream is = res.body()) {\n+            String content = new String(is.readAllBytes());\n+            test(\"Body content correct\", EXPECTED_BODY.equals(content),\n+                 \"Content mismatch\");\n+        }\n+    }\n+\n+    \/\/ Test 5: BodyHandlers.ofLines()\n+    private static void testBodyHandlerLines(HttpClient client, String url) throws Exception {\n+        System.out.println(\"\\nTest: BodyHandler.ofLines() (\" + url + \")\");\n+        HttpRequest req = HttpRequest.newBuilder(URI.create(url)).GET().build();\n+        HttpResponse<Stream<String>> res = client.send(req, HttpResponse.BodyHandlers.ofLines());\n+\n+        test(\"Body is not null\", res.body() != null, \"Body is null\");\n+\n+        String content = res.body().collect(Collectors.joining());\n+        test(\"Body content correct\", EXPECTED_BODY.equals(content),\n+             \"Content mismatch\");\n+    }\n+\n+    \/\/ Test 6: Response headers\n+    private static void testResponseHeaders(HttpClient client, String url) throws Exception {\n+        System.out.println(\"\\nTest: Response headers (\" + url + \")\");\n+        HttpRequest req = HttpRequest.newBuilder(URI.create(url)).GET().build();\n+        HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());\n+\n+        test(\"Status code is 407\", res.statusCode() == 407,\n+             \"Expected 407, got \" + res.statusCode());\n+\n+        var headers = res.headers();\n+        test(\"Has Content-Type header\",\n+             headers.firstValue(\"Content-Type\").isPresent(),\n+             \"Content-Type header missing\");\n+        test(\"Content-Type is text\/html\",\n+             headers.firstValue(\"Content-Type\").orElse(\"\").contains(\"text\/html\"),\n+             \"Wrong Content-Type: \" + headers.firstValue(\"Content-Type\").orElse(\"\"));\n+        test(\"Has Content-Length header\",\n+             headers.firstValue(\"Content-Length\").isPresent(),\n+             \"Content-Length header missing\");\n+        test(\"Content-Length is correct\",\n+             headers.firstValue(\"Content-Length\").orElse(\"\").equals(String.valueOf(EXPECTED_BODY.length())),\n+             \"Wrong Content-Length: \" + headers.firstValue(\"Content-Length\").orElse(\"\"));\n+        test(\"Has Proxy-Authenticate header\",\n+             headers.firstValue(\"Proxy-Authenticate\").isPresent(),\n+             \"Proxy-Authenticate header missing\");\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxyAuthHttpTest.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"}]}