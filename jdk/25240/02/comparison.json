{"files":[{"patch":"@@ -48,1 +48,7 @@\n-          \"Enable JVMCI. Defaults to true if UseJVMCICompiler is true.\")    \\\n+          \"Enable JVMCI support in the VM. \"                                \\\n+          \"Defaults to true if UseJVMCICompiler is true or \"                \\\n+          \"--add-modules=jdk.internal.vm.ci was specified. \"                \\\n+          \"If true and UseJVMCINativeLibrary is false (i.e. libjvmci is \"   \\\n+          \"not available or not selected), the behavior of adding the \"     \\\n+          \"jdk.internal.vm.ci module is triggered, as if the \"   \\\n+          \"--add-modules=jdk.internal.vm.ci option was specified.\")         \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+#if INCLUDE_JVMCI\n+bool   Arguments::_jvmci_module_added           = false;\n+#endif\n@@ -1801,3 +1804,5 @@\n-    PropertyList_unique_add(&_system_properties, \"jdk.internal.vm.ci.enabled\", \"true\",\n-        AddProperty, UnwriteableProperty, InternalProperty);\n-    if (ClassLoader::is_module_observable(\"jdk.internal.vm.ci\")) {\n+    \/\/ libjvmci doesn't require resolving jdk.internal.vm.ci as it is\n+    \/\/ compiled into the libjvmci image itself. Without libjvmci, there\n+    \/\/ is no other representation of the jdk.internal.vm.ci module\n+    \/\/ so it needs to be added to the root module set.\n+    if (!UseJVMCINativeLibrary && ClassLoader::is_module_observable(\"jdk.internal.vm.ci\") && !_jvmci_module_added) {\n@@ -2250,0 +2255,13 @@\n+#if INCLUDE_JVMCI\n+      if (!_jvmci_module_added) {\n+        const char *jvmci_module = strstr(tail, \"jdk.internal.vm.ci\");\n+        if (jvmci_module != nullptr) {\n+          char before = *(jvmci_module - 1);\n+          char after  = *(jvmci_module + strlen(\"jdk.internal.vm.ci\"));\n+          if ((before == '=' || before == ',') && (after == '\\0' || after == ',')) {\n+            FLAG_SET_DEFAULT(EnableJVMCI, true);\n+            _jvmci_module_added = true;\n+          }\n+        }\n+      }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -200,0 +200,4 @@\n+#if INCLUDE_JVMCI\n+  \/\/ was jdk.internal.vm.ci module specified in the --add-modules option?\n+  static bool _jvmci_module_added;\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-        Services.checkJVMCIEnabled();\n@@ -88,1 +87,0 @@\n-        Services.checkJVMCIEnabled();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/services\/JVMCIServiceLocator.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,11 +67,0 @@\n-    static final boolean JVMCI_ENABLED = Boolean.parseBoolean(VM.getSavedProperties().get(\"jdk.internal.vm.ci.enabled\"));\n-\n-    \/**\n-     * Checks that JVMCI is enabled in the VM and throws an error if it isn't.\n-     *\/\n-    static void checkJVMCIEnabled() {\n-        if (!JVMCI_ENABLED) {\n-            throw new Error(\"The EnableJVMCI VM option must be true (i.e., -XX:+EnableJVMCI) to use JVMCI\");\n-        }\n-    }\n-\n@@ -87,1 +76,0 @@\n-        checkJVMCIEnabled();\n@@ -116,1 +104,0 @@\n-        checkJVMCIEnabled();\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/services\/Services.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -173,0 +173,1 @@\n+                \"--add-modules=jdk.internal.vm.ci\",\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotJVMCIRuntime.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}