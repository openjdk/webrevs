{"files":[{"patch":"@@ -302,1 +302,1 @@\n-        String def = type.getAnnotationValue(Threshold.class, \"0 ns\");\n+        String def = type.getAnnotationValue(Threshold.class, ThresholdSetting.DEFAULT_VALUE);\n@@ -314,1 +314,1 @@\n-        String def = type.getAnnotationValue(Cutoff.class, Cutoff.INFINITY);\n+        String def = type.getAnnotationValue(Cutoff.class, CutoffSetting.DEFAULT_VALUE);\n@@ -320,1 +320,1 @@\n-        String def = type.getAnnotationValue(Throttle.class, Throttle.DEFAULT);\n+        String def = type.getAnnotationValue(Throttle.class, ThrottleSetting.DEFAULT_VALUE);\n@@ -333,1 +333,1 @@\n-        String def = type.getAnnotationValue(Period.class, \"everyChunk\");\n+        String def = type.getAnnotationValue(Period.class, PeriodSetting.DEFAULT_VALUE);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal.settings;\n+\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import jdk.jfr.internal.PlatformEventType;\n+\n+abstract class BooleanSetting extends JDKSettingControl {\n+    private final PlatformEventType eventType;\n+    private final String defaultValue;\n+    private String value;\n+\n+    public BooleanSetting(PlatformEventType eventType, String defaultValue) {\n+        this.eventType = Objects.requireNonNull(eventType);\n+        this.defaultValue = defaultValue;\n+        this.value = defaultValue;\n+        if (parse(defaultValue) == null) {\n+            throw new InternalError(\"Only 'true' or 'false' is allowed with class BooleanSetting\");\n+        }\n+    }\n+\n+    protected abstract void apply(PlatformEventType eventType, boolean value);\n+\n+    @Override\n+    public String combine(Set<String> values) {\n+        String text = null;\n+        for (String value : values) {\n+            Boolean b = parse(value);\n+            if (b != null) {\n+                if (b.booleanValue()) {\n+                    return \"true\";\n+                }\n+                text = \"false\";\n+            }\n+        }\n+        return Objects.requireNonNullElse(text, defaultValue);\n+    }\n+\n+    @Override\n+    public void setValue(String value) {\n+        Boolean b = parse(value);\n+        if (b != null) {\n+            apply(eventType, b.booleanValue());\n+            this.value = value;\n+        }\n+    }\n+\n+    @Override\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    private static Boolean parse(String value) {\n+        if (\"true\".equals(value)) {\n+            return Boolean.TRUE;\n+        }\n+        if (\"false\".equals(value)) {\n+            return Boolean.FALSE;\n+        }\n+        return null;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/BooleanSetting.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.settings;\n-\n-import java.util.Set;\n-\n-\/**\n- * Helper class for settings that use boolean numbers\n- *\n- *\/\n-final class BooleanValue  {\n-    private String value = \"false\";\n-    private boolean booleanValue;\n-\n-    private BooleanValue(boolean b) {\n-        booleanValue = b;\n-        value = b ? \"true\" : \"false\";\n-    }\n-\n-    public String union(Set<String> values) {\n-        for (String v : values) {\n-            if (\"true\".equals(v)) {\n-                return \"true\";\n-            }\n-        }\n-        return \"false\";\n-    }\n-\n-    public void setValue(String value) {\n-        this.value = value;\n-        this.booleanValue = Boolean.valueOf(value);\n-    }\n-\n-    public final String getValue() {\n-        return this.value;\n-    }\n-\n-    public boolean getBoolean() {\n-        return booleanValue;\n-    }\n-\n-    public static BooleanValue valueOf(String defaultValue) {\n-        if (\"true\".equals(defaultValue)) {\n-            return new BooleanValue(true);\n-        }\n-        if (\"false\".equals(defaultValue)) {\n-            return new BooleanValue(false);\n-        }\n-        throw new InternalError(\"Unknown default value for settings '\" + defaultValue + \"'\");\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/BooleanValue.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import static jdk.jfr.internal.util.ValueParser.MISSING;\n+\n@@ -46,2 +48,2 @@\n-\n-    private String value = \"0 ns\";\n+    public static final String DEFAULT_VALUE = ValueParser.INFINITY;\n+    private String value = DEFAULT_VALUE;\n@@ -57,1 +59,1 @@\n-        String text = \"0 ns\";\n+        String text = null;\n@@ -59,2 +61,2 @@\n-            long l =  ValueParser.parseTimespanWithInfinity(value);\n-            if (l > max) {\n+            long nanos = ValueParser.parseTimespanWithInfinity(value, MISSING);\n+            if (nanos != MISSING && nanos > max) {\n@@ -62,1 +64,1 @@\n-                max = l;\n+                max = nanos;\n@@ -65,1 +67,1 @@\n-        return text;\n+        return Objects.requireNonNullElse(text, DEFAULT_VALUE);\n@@ -70,3 +72,5 @@\n-        long l =  ValueParser.parseTimespanWithInfinity(value);\n-        this.value = value;\n-        eventType.setCutoff(l);\n+        long nanos = ValueParser.parseTimespanWithInfinity(value, MISSING);\n+        if (nanos != MISSING) {\n+            eventType.setCutoff(nanos);\n+            this.value = value;\n+        }\n@@ -84,5 +88,1 @@\n-        try {\n-            return ValueParser.parseTimespanWithInfinity(value);\n-        } catch (NumberFormatException nfe) {\n-            return 0L;\n-        }\n+        return ValueParser.parseTimespanWithInfinity(value, 0L);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/CutoffSetting.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.util.Objects;\n-import java.util.Set;\n-\n@@ -44,4 +41,1 @@\n-public final class EnabledSetting extends JDKSettingControl {\n-    private final BooleanValue booleanValue;\n-    private final PlatformEventType eventType;\n-\n+public final class EnabledSetting extends BooleanSetting {\n@@ -49,7 +43,1 @@\n-        this.booleanValue = BooleanValue.valueOf(defaultValue);\n-        this.eventType = Objects.requireNonNull(eventType);\n-    }\n-\n-    @Override\n-    public String combine(Set<String> values) {\n-        return booleanValue.union(values);\n+        super(eventType, defaultValue);\n@@ -59,3 +47,2 @@\n-    public void setValue(String value) {\n-        booleanValue.setValue(value);\n-        eventType.setEnabled(booleanValue.getBoolean());\n+    protected void apply(PlatformEventType eventType, boolean value) {\n+        eventType.setEnabled(value);\n@@ -68,5 +55,0 @@\n-\n-    @Override\n-    public String getValue() {\n-        return booleanValue.getValue();\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/EnabledSetting.java","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+        this.value = levels[0];\n@@ -54,1 +55,1 @@\n-        int maxIndex = 0;\n+        int maxIndex = 0; \/\/ index 0 contains the default value\n@@ -56,1 +57,1 @@\n-            maxIndex = Math.max(maxIndex, indexOf(value));\n+            maxIndex = Math.max(maxIndex, levels.indexOf(value));\n@@ -63,2 +64,5 @@\n-        this.value = value;\n-        this.eventType.setLevel(indexOf(value));\n+        int index = levels.indexOf(value);\n+        if (index != -1) {\n+            this.eventType.setLevel(index);\n+            this.value = value;\n+        }\n@@ -71,5 +75,0 @@\n-\n-    private int indexOf(String value) {\n-        int index = levels.indexOf(value);\n-        return index < 0 ? 0 : index;\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/LevelSetting.java","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import static jdk.jfr.internal.util.ValueParser.MISSING;\n@@ -49,0 +50,1 @@\n+    public static final String DEFAULT_VALUE = EVERY_CHUNK;\n@@ -59,1 +61,0 @@\n-\n@@ -77,7 +78,3 @@\n-                long l = ValueParser.parseTimespanWithInfinity(value);\n-                \/\/ Always accept first specified value\n-                if (min == null) {\n-                    text = value;\n-                    min = l;\n-                } else {\n-                    if (l < min) {\n+                long nanos = ValueParser.parseTimespanWithInfinity(value, MISSING);\n+                if (nanos != MISSING) {\n+                    if (min == null || nanos < min) {\n@@ -85,1 +82,1 @@\n-                        min = l;\n+                        min = nanos;\n@@ -100,1 +97,1 @@\n-        return EVERY_CHUNK; \/\/ also default\n+        return DEFAULT_VALUE; \/\/ \"everyChunk\" is default\n@@ -116,1 +113,4 @@\n-            long nanos = ValueParser.parseTimespanWithInfinity(value);\n+            long nanos = ValueParser.parseTimespanWithInfinity(value, MISSING);\n+            if (nanos == MISSING) {\n+                return;\n+            }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/PeriodSetting.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-import java.util.Objects;\n-import java.util.Set;\n-\n-import jdk.jfr.Description;\n@@ -33,0 +29,1 @@\n+import jdk.jfr.Description;\n@@ -44,4 +41,2 @@\n-public final class StackTraceSetting extends JDKSettingControl {\n-    private static final long typeId =  Type.getTypeId(StackTraceSetting.class);\n-    private final BooleanValue booleanValue;\n-    private final PlatformEventType eventType;\n+public final class StackTraceSetting extends BooleanSetting {\n+    private static final long typeId = Type.getTypeId(StackTraceSetting.class);\n@@ -50,13 +45,1 @@\n-        this.booleanValue = BooleanValue.valueOf(defaultValue);\n-        this.eventType = Objects.requireNonNull(eventType);\n-    }\n-\n-    @Override\n-    public String combine(Set<String> values) {\n-        return booleanValue.union(values);\n-    }\n-\n-    @Override\n-    public void setValue(String value) {\n-        booleanValue.setValue(value);\n-        eventType.setStackTraceEnabled(booleanValue.getBoolean());\n+        super(eventType, defaultValue);\n@@ -66,2 +49,2 @@\n-    public String getValue() {\n-        return booleanValue.getValue();\n+    protected void apply(PlatformEventType eventType, boolean value) {\n+        eventType.setStackTraceEnabled(value);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/StackTraceSetting.java","additions":7,"deletions":24,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import static jdk.jfr.internal.util.ValueParser.MISSING;\n+\n@@ -39,0 +41,1 @@\n+\n@@ -45,0 +48,1 @@\n+    public static final String DEFAULT_VALUE = \"0 ns\";\n@@ -46,1 +50,1 @@\n-    private String value = \"0 ns\";\n+    private String value = DEFAULT_VALUE;\n@@ -58,7 +62,3 @@\n-            long l = ValueParser.parseTimespanWithInfinity(value);\n-            \/\/ always accept first value\n-            if (min == null) {\n-                min = l;\n-                text = value;\n-            } else {\n-                if (l < min) {\n+            long nanos = ValueParser.parseTimespanWithInfinity(value, MISSING);\n+            if (nanos != MISSING) {\n+                if (min == null || nanos < min) {\n@@ -66,1 +66,1 @@\n-                    min = l;\n+                    min = nanos;\n@@ -70,1 +70,1 @@\n-        return text == null ? \"0 ns\" : text;\n+        return Objects.requireNonNullElse(text, DEFAULT_VALUE);\n@@ -75,3 +75,5 @@\n-        long l = ValueParser.parseTimespanWithInfinity(value);\n-        this.value = value;\n-        eventType.setThreshold(l);\n+        long nanos = ValueParser.parseTimespanWithInfinity(value, MISSING);\n+        if (nanos != MISSING) {\n+            eventType.setThreshold(nanos);\n+            this.value = value;\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThresholdSetting.java","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+import static jdk.jfr.internal.util.TimespanUnit.SECONDS;\n+import static jdk.jfr.internal.util.TimespanUnit.MILLISECONDS;\n+\n@@ -37,0 +40,1 @@\n+import jdk.jfr.internal.Throttle;\n@@ -38,0 +42,3 @@\n+import jdk.jfr.internal.util.Rate;\n+import jdk.jfr.internal.util.TimespanUnit;\n+import jdk.jfr.internal.util.Utils;\n@@ -44,3 +51,1 @@\n-    static final String OFF_TEXT = \"off\";\n-    private static final long OFF = -2;\n-    private String value = \"0\/s\";\n+    public static final String DEFAULT_VALUE = Throttle.DEFAULT;\n@@ -48,0 +53,1 @@\n+    private String value = DEFAULT_VALUE;\n@@ -55,2 +61,2 @@\n-        long max = OFF;\n-        String text = \"off\";\n+        Rate max = null;\n+        String text = null;\n@@ -58,4 +64,6 @@\n-            long l = parseValueSafe(value);\n-            if (l > max) {\n-                text = value;\n-                max = l;\n+            Rate rate = Rate.of(value);\n+            if (rate != null) {\n+                if (max == null || rate.isHigher(max)) {\n+                    text = value;\n+                    max = rate;\n+                }\n@@ -64,1 +72,2 @@\n-        return text;\n+        \/\/ \"off\" is default\n+        return Objects.requireNonNullElse(text, DEFAULT_VALUE);\n@@ -67,5 +76,6 @@\n-    private static long parseValueSafe(String s) {\n-        long value = 0L;\n-        try {\n-            value = parseThrottleValue(s);\n-        } catch (NumberFormatException nfe) {\n+    @Override\n+    public void setValue(String value) {\n+        if (\"off\".equals(value)) {\n+            eventType.setThrottle(-2, 1000);\n+            this.value = value;\n+            return;\n@@ -73,2 +83,0 @@\n-        return value;\n-    }\n@@ -76,9 +84,16 @@\n-    @Override\n-    public void setValue(String s) {\n-        long size = 0;\n-        long millis = 1000;\n-        try {\n-            size = parseThrottleValue(s);\n-            millis = parseThrottleTimeUnit(s);\n-            this.value = s;\n-        } catch (NumberFormatException nfe) {\n+        Rate rate = Rate.of(value);\n+        if (rate != null) {\n+            long millis = 1000;\n+            long samples = rate.amount();\n+            TimespanUnit unit = rate.unit();\n+            \/\/ if unit is more than 1 s, set millis\n+            if (unit.nanos > SECONDS.nanos) {\n+                millis = unit.nanos \/ MILLISECONDS.nanos;\n+            }\n+            \/\/ if unit is less than 1 s, scale samples\n+            if (unit.nanos < SECONDS.nanos) {\n+                long perSecond = SECONDS.nanos \/ unit.nanos;\n+                samples *= Utils.multiplyOverflow(samples, perSecond, Long.MAX_VALUE);\n+            }\n+            eventType.setThrottle(samples, millis);\n+            this.value = value;\n@@ -86,1 +101,0 @@\n-        eventType.setThrottle(size, millis);\n@@ -93,32 +107,0 @@\n-\n-    private static long parseThrottleValue(String s) {\n-        if (s.equals(OFF_TEXT)) {\n-            return OFF;\n-        }\n-        String parsedValue = parseThrottleString(s, true);\n-        long normalizedValue = 0;\n-        try {\n-            normalizedValue = ThrottleUnit.normalizeValueAsMillis(Long.parseLong(parsedValue), s);\n-        } catch (NumberFormatException nfe) {\n-            throwThrottleNumberFormatException(s);\n-        }\n-        return normalizedValue;\n-    }\n-\n-    private static long parseThrottleTimeUnit(String s) {\n-        return ThrottleUnit.asMillis(s);\n-    }\n-\n-    \/\/ Expected input format is \"x\/y\" where x is a non-negative long\n-    \/\/ and y is a time unit. Split the string at the delimiter.\n-    static String parseThrottleString(String s, boolean value) {\n-        String[] split = s.split(\"\/\");\n-        if (split.length != 2) {\n-            throwThrottleNumberFormatException(s);\n-        }\n-        return value ? split[0].trim() : split[1].trim();\n-    }\n-\n-    private static void throwThrottleNumberFormatException(String s) {\n-        throw new NumberFormatException(\"'\" + s + \"' is not valid. Should be a non-negative numeric value followed by a delimiter. i.e. '\/', and then followed by a unit e.g. 100\/s.\");\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThrottleSetting.java","additions":42,"deletions":60,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Datadog, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jfr.internal.settings;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-enum ThrottleUnit {\n-        NANOSECONDS(\"ns\", TimeUnit.SECONDS.toNanos(1), TimeUnit.SECONDS.toMillis(1)),\n-        MICROSECONDS(\"us\", TimeUnit.SECONDS.toNanos(1) \/ 1000, TimeUnit.SECONDS.toMillis(1)),\n-        MILLISECONDS(\"ms\", TimeUnit.SECONDS.toMillis(1), TimeUnit.SECONDS.toMillis(1)),\n-        SECONDS(\"s\", 1, TimeUnit.SECONDS.toMillis(1)),\n-        MINUTES(\"m\", 1, TimeUnit.MINUTES.toMillis(1)),\n-        HOUR(\"h\", 1, TimeUnit.HOURS.toMillis(1)),\n-        DAY(\"d\", 1, TimeUnit.DAYS.toMillis(1));\n-\n-        private final String text;\n-        private final long factor;\n-        private final long millis;\n-\n-        ThrottleUnit(String t, long factor, long millis) {\n-            this.text = t;\n-            this.factor = factor;\n-            this.millis = millis;\n-        }\n-\n-        private static ThrottleUnit parse(String s) {\n-            if (s.equals(ThrottleSetting.OFF_TEXT)) {\n-                return MILLISECONDS;\n-            }\n-            return unit(ThrottleSetting.parseThrottleString(s, false));\n-        }\n-\n-        private static ThrottleUnit unit(String s) {\n-            if (s.endsWith(\"ns\") || s.endsWith(\"us\") || s.endsWith(\"ms\")) {\n-                return value(s.substring(s.length() - 2));\n-            }\n-            if (s.endsWith(\"s\") || s.endsWith(\"m\") || s.endsWith(\"h\") || s.endsWith(\"d\")) {\n-                return value(s.substring(s.length() - 1));\n-            }\n-            throw new NumberFormatException(\"'\" + s + \"' is not a valid time unit.\");\n-        }\n-\n-        private static ThrottleUnit value(String s) {\n-            for (ThrottleUnit t : values()) {\n-                if (t.text.equals(s)) {\n-                    return t;\n-                }\n-            }\n-            throw new NumberFormatException(\"'\" + s + \"' is not a valid time unit.\");\n-        }\n-\n-        static long asMillis(String s) {\n-            return parse(s).millis;\n-        }\n-\n-        static long normalizeValueAsMillis(long value, String s) {\n-            return value * parse(s).factor;\n-        }\n-    }\n\\ No newline at end of file\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/settings\/ThrottleUnit.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+public record Rate(long amount, TimespanUnit unit) {\n+\n+    public static Rate of(String text) {\n+        String[] splitted = text.split(\"\/\");\n+        if (splitted.length != 2) {\n+            return null;\n+        }\n+        String value = splitted[0].strip();\n+        String unit = splitted[1].strip();\n+        TimespanUnit tu = TimespanUnit.fromText(unit);\n+        if (unit == null) {\n+            return null;\n+        }\n+        try {\n+            long v = Long.parseLong(value);\n+            if (v >= 0) {\n+                return new Rate(v, tu);\n+            }\n+        } catch (NumberFormatException nfe) {\n+            \/\/ Ignore\n+        }\n+        return null;\n+    }\n+\n+    public boolean isHigher(Rate that) {\n+        return this.inNanos() > that.inNanos();\n+    }\n+\n+    private double inNanos() {\n+        return (double) amount \/ unit.nanos;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Rate.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.util;\n+\n+public enum TimespanUnit {\n+    NANOSECONDS (\"ns\",                           1L, 1000),\n+    MICROSECONDS(\"us\",                        1000L, 1000),\n+    MILLISECONDS(\"ms\",                   1_000_000L, 1000),\n+    SECONDS     (\"s\",                1_000_000_000L,   60),\n+    MINUTES     (\"m\",           60 * 1_000_000_000L,   60),\n+    HOURS       (\"h\",      60 * 60 * 1_000_000_000L,   24),\n+    DAYS        (\"d\", 24 * 60 * 60 * 1_000_000_000L,    7);\n+    public final String text;\n+    public final long nanos;\n+    public final int size;\n+    TimespanUnit(String text, long nanos, int size) {\n+        this.text = text;\n+        this.nanos = nanos;\n+        this.size = size;\n+    }\n+\n+    public static TimespanUnit fromText(String text) {\n+        for (TimespanUnit tu : values()) {\n+            \/\/ Case-sensitive by design\n+            if (tu.text.equals(text)) {\n+                return tu;\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/TimespanUnit.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -433,0 +433,8 @@\n+\n+    public static long multiplyOverflow(long a, long b, long defaultValue) {\n+        try {\n+            return Math.multiplyExact(a, b);\n+        } catch (ArithmeticException ae) {\n+            return defaultValue;\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/Utils.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,17 +43,0 @@\n-    private static enum TimespanUnit {\n-        NANOSECONDS(\"ns\", 1000),\n-        MICROSECONDS(\"us\", 1000),\n-        MILLISECONDS(\"ms\", 1000),\n-        SECONDS(\"s\", 60), MINUTES(\"m\", 60),\n-        HOURS(\"h\", 24),\n-        DAYS(\"d\", 7);\n-\n-        private final String text;\n-        private final long amount;\n-\n-        TimespanUnit(String unit, long amount) {\n-            this.text = unit;\n-            this.amount = amount;\n-        }\n-    }\n-\n@@ -85,1 +68,1 @@\n-            long amount = unit.amount;\n+            long amount = unit.size;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueFormatter.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -35,1 +35,10 @@\n-    private static final String INFINITY = \"infinity\";\n+    public static final String INFINITY = \"infinity\";\n+    public static final long MISSING = Long.MIN_VALUE;\n+\n+    public static long parseTimespanWithInfinity(String s, long defaultValue) {\n+        try {\n+            return parseTimespanWithInfinity(s);\n+        } catch (NumberFormatException nfe) {\n+            return defaultValue;\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/ValueParser.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.settings;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import jdk.jfr.EventType;\n+import jdk.jfr.FlightRecorder;\n+import jdk.jfr.Recording;\n+import jdk.jfr.SettingDescriptor;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+\/**\n+ * @test\n+ * @summary Tests that methods on all SettingControls have expected behavior.\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.api.settings.TestSettingControl\n+ *\/\n+public class TestSettingControl {\n+    record SettingTest(String setting, String defaultValue, String event, List<String> exampleValues) {\n+        public String eventSettingName() {\n+            return event + \"#\" + setting;\n+        }\n+    }\n+\n+    \/\/ Example values should be listed in precedence order with the lowest precedence first.\n+    static List<SettingTest> SETTING_TESTS = List.of(\n+        new SettingTest(\"enabled\", \"false\", \"jdk.JavaMonitorWait\",List.of(\"false\", \"true\")),\n+        new SettingTest(\"stackTrace\", \"true\", \"jdk.JavaMonitorWait\", List.of(\"false\", \"true\")),\n+        new SettingTest(\"threshold\", \"0 ns\", \"jdk.JavaMonitorWait\", List.of(\"infinity\", \"10 ms\", \"0 ns\")),\n+        new SettingTest(\"level\", \"forRemoval\", \"jdk.DeprecatedInvocation\", List.of(\"off\", \"forRemoval\")),\n+        new SettingTest(\"period\", \"everyChunk\", \"jdk.ExceptionStatistics\", List.of(\"everyChunk\", \"60 s\", \"1 s\")),\n+        new SettingTest(\"cutoff\", \"infinity\", \"jdk.OldObjectSample\", List.of(\"0 ms\", \"1 s\", \"infinity\")),\n+        new SettingTest(\"throttle\", \"off\", \"jdk.ObjectAllocationSample\", List.of(\"off\", \"100\/s\", \"10\/ms\"))\n+    );\n+\n+    public static void main(String... args) throws Exception {\n+        testTesting();\n+        testDefault();\n+        testDefaultWithInvalid();\n+        testPrecedence();\n+        testPrecedenceWithInvalid();\n+    }\n+\n+    \/\/ Ensure that all known SettingControl\/types are tested at least once\n+    private static void testTesting() throws Exception {\n+        Set<String> foundSettings = new HashSet<>();\n+        for (EventType eventType : allEventTypes()) {\n+            for (SettingDescriptor s : eventType.getSettingDescriptors()) {\n+                foundSettings.add(s.getName());\n+            }\n+        }\n+        for (SettingTest st : SETTING_TESTS) {\n+            foundSettings.remove(st.setting());\n+        }\n+        if (!foundSettings.isEmpty()) {\n+            throw new Exception(\"All event SettingControls should be tested. Missing test for \" + foundSettings);\n+        }\n+    }\n+\n+    \/\/ Ensure that the default values for all SettingControls are correct\n+    private static void testDefault() throws Exception {\n+        for (SettingTest settingTest : SETTING_TESTS) {\n+            SettingDescriptor s = findSettingDescriptor(settingTest);\n+            if (!settingTest.defaultValue().equals(s.getDefaultValue())) {\n+                String message = \"Incorrect default value \" + quote(s.getDefaultValue());\n+                message += \" for setting \" + settingTest.eventSettingName() + \". \";\n+                message += \"Expected \" + quote(settingTest.defaultValue());\n+                throw new Exception(message);\n+            }\n+        }\n+    }\n+\n+    \/\/ Ensure that default settings are used if an invalid setting is specified.\n+    private static void testDefaultWithInvalid() throws Exception {\n+        Map<String, String> settings = createEnabledMap();\n+        for (SettingTest settingTest : SETTING_TESTS) {\n+            settings.put(settingTest.eventSettingName(), \"%#&2672g\");\n+        }\n+        Map<String, String> result = check(\"testDefaultWithInvalid\", List.of(settings));\n+        for (var entry : new ArrayList<>(result.entrySet())) {\n+            String key = entry.getKey();\n+            String removed = result.remove(key);\n+            if (removed == null) {\n+                throw new Exception(\"Expected setting \" + quote(key) + \" to exist\");\n+            }\n+            String setting = key.substring(key.indexOf(\"#\") + 1);\n+            SettingTest st = findSettingTest(setting);\n+            if (st == null) {\n+                throw new Exception(\"Found unexpected setting \" + quote(key));\n+            }\n+            if (!removed.equals(st.defaultValue())) {\n+                String message = \"Expected default value \" + quote(st.defaultValue());\n+                message += \" for setting \" + quote(setting) + \" when\";\n+                message += \" an invalid settings value was specified\";\n+                throw new Exception(message);\n+            }\n+        }\n+        if (!result.isEmpty()) {\n+            throw new Exception(\"Found unexpected setting when testing preserved default\");\n+        }\n+    }\n+\n+    \/\/ Only enabled events will use settings\n+    private static Map<String, String> createEnabledMap() {\n+        Map<String, String> settings = new TreeMap<>();\n+        for (SettingTest settingTest : SETTING_TESTS) {\n+            settings.put(settingTest.event + \"#enabled\", \"true\");\n+        }\n+        return settings;\n+    }\n+\n+    \/\/ Ensure that precedence are respected when multiple settings are specified\n+    private static void testPrecedence() throws Exception {\n+        testPrecedence(\"testPrecedence\");\n+    }\n+\n+    \/\/ Ensure that precedence are respected when an incorrect setting is used\n+    private static void testPrecedenceWithInvalid() throws Exception {\n+        testPrecedence(\"testPrecedenceWithInvalid\");\n+    }\n+\n+    \/\/ * * * HELPER METHODS * * *\n+\n+    private static void testPrecedence(String testName) throws Exception {\n+        List<Map<String, String>> settingsList = new ArrayList<>();\n+        int maxExamples = 0;\n+        for (SettingTest t : SETTING_TESTS) {\n+            maxExamples = Math.max(t.exampleValues().size(), maxExamples);\n+        }\n+        for (int i = 0; i < maxExamples; i++) {\n+            Map<String, String> settings = createEnabledMap();\n+            for (SettingTest settingTest : SETTING_TESTS) {\n+                List<String> examples = settingTest.exampleValues();\n+                String name = settingTest.eventSettingName();\n+                if (i < examples.size()) {\n+                    settings.put(name, examples.get(i));\n+                }\n+                \/\/ Insert the invalid setting first\n+                if (testName.contains(\"Invalid\") && i == 0) {\n+                    settings.put(name, \"%#&2672g\");\n+                }\n+            }\n+            settingsList.add(settings);\n+        }\n+        Map<String, String> results = check(testName, settingsList);\n+        Map<String, String> reversed = check(testName + \"-reversed\", settingsList.reversed());\n+        if (!reversed.equals(results)) {\n+            throw new Exception(\"Active settings should not depend on the order event settings are applied\");\n+        }\n+        for (SettingTest t : SETTING_TESTS) {\n+            String expected = t.exampleValues().get(t.exampleValues().size() - 1);\n+            String found = results.get(t.eventSettingName());\n+            if (!expected.equals(found)) {\n+                throw new Exception(\"Expected \" + expected + \" to be used with setting \" + quote(t.setting()) + \", not \" + quote(found));\n+            }\n+        }\n+    }\n+\n+    private static Map<String, String> check(String testName, List<Map<String, String>> settingsList) throws Exception {\n+        System.out.println(\"*** Check for \" + testName + \" ****\");\n+        System.out.println(\"Input:\");\n+        int index = 0;\n+        for (var settings : settingsList) {\n+            System.out.println(\"Setting[\" + index + \"] = {\");\n+            for (var e : settings.entrySet()) {\n+                System.out.println(\"  \" + e.getKey() + \"=\" + e.getValue());\n+            }\n+            System.out.println(\"}\");\n+            index++;\n+        }\n+        int settingsCount = settingsList.size();\n+\n+        \/\/ Start a recording for each settings\n+        List<Recording> recordings = new ArrayList<>();\n+        for (int i = 0; i < settingsCount; i++) {\n+            Recording r = new Recording();\n+            Map<String, String> settings = settingsList.get(i);\n+            settings.put(\"jdk.ActiveSetting#enabled\", \"true\");\n+            r.setSettings(settings);\n+            r.start();\n+            recordings.add(r);\n+        }\n+\n+        \/\/ Stop all recordings\n+        for (Recording r : recordings) {\n+            r.stop();\n+        }\n+\n+        \/\/ Dump the innermost recording\n+        Path p = Path.of(\"recording.jfr\");\n+        Recording inner = recordings.get(settingsCount - 1);\n+        inner.dump(p);\n+\n+        \/\/ Close all recordings\n+        for (Recording r : recordings) {\n+            r.close();\n+        }\n+        System.out.println(\"Result:\");\n+        Map<String, String> r = lastSettings(p);\n+        for (var e : r.entrySet()) {\n+            System.out.println(e.getKey() + \"=\" + e.getValue());\n+        }\n+        System.out.println(\"*************\");\n+        System.out.println();\n+        Files.delete(p);\n+        return r;\n+    }\n+\n+    private static SettingTest findSettingTest(String name) throws Exception {\n+        for (SettingTest settingTest : SETTING_TESTS) {\n+            if (name.equals(settingTest.setting())) {\n+                return settingTest;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static Map<String, String> lastSettings(Path p) throws Exception {\n+        List<RecordedEvent> events = RecordingFile.readAllEvents(p);\n+        Instant timestamp = findLastActiveSetting(events);\n+        Map<String, String> lastInnerMostSettings = new HashMap<>();\n+        for (SettingTest t : SETTING_TESTS) {\n+            long id = eventTypeNameToId(t.event());\n+            for (RecordedEvent event : events) {\n+                if (event.getEventType().getName().equals(\"jdk.ActiveSetting\")) {\n+                    if (event.getStartTime().equals(timestamp) && id == event.getLong(\"id\")) {\n+                        String name = event.getString(\"name\");\n+                        String value = event.getString(\"value\");\n+                        if (t.setting.equals(name)) {\n+                            String fullName = t.event() + \"#\" + name;\n+                            String previous = lastInnerMostSettings.put(fullName, value);\n+                            if (previous != null) {\n+                                throw new Exception(\"Expected only one ActiveSetting event per event setting\");\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return lastInnerMostSettings;\n+    }\n+\n+    private static Instant findLastActiveSetting(List<RecordedEvent> events) {\n+        Instant lastTimestamp = null;\n+        for (RecordedEvent event : events) {\n+            if (event.getEventType().getName().equals(\"jdk.ActiveSetting\")) {\n+                Instant t = event.getStartTime();\n+                if (lastTimestamp == null || t.isBefore(lastTimestamp)) {\n+                    lastTimestamp = t;\n+                }\n+            }\n+        }\n+        return lastTimestamp;\n+    }\n+\n+    private static long eventTypeNameToId(String name) throws Exception {\n+        for (EventType eventType : allEventTypes()) {\n+            if (eventType.getName().equals(name)) {\n+                return eventType.getId();\n+            }\n+        }\n+        throw new Exception(\"Could not find event type with name \" + name);\n+    }\n+\n+    private static SettingDescriptor findSettingDescriptor(SettingTest settingTest) throws Exception {\n+        for (EventType eventType : allEventTypes()) {\n+            if (eventType.getName().equals(settingTest.event())) {\n+                for (SettingDescriptor s : eventType.getSettingDescriptors()) {\n+                    if (settingTest.setting().equals(s.getName())) {\n+                        return s;\n+                    }\n+                }\n+            }\n+        }\n+        throw new Exception(\"Could not find setting with name \" + settingTest.event() + \"#\" + settingTest.setting());\n+    }\n+\n+    private static List<EventType> allEventTypes() {\n+        return FlightRecorder.getFlightRecorder().getEventTypes();\n+    }\n+\n+    private static String quote(String text) {\n+        return \"'\" + text + \"'\";\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/settings\/TestSettingControl.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"}]}