{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.Arrays;\n@@ -572,0 +573,3 @@\n+            if (model.getTransparentPixel() > 0) {\n+                Arrays.fill(saved_image, (byte) model.getTransparentPixel());\n+            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/GifImageDecoder.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.imageio.IIOImage;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageTypeSpecifier;\n+import javax.imageio.ImageWriter;\n+import javax.imageio.ImageWriteParam;\n+import javax.imageio.metadata.IIOMetadata;\n+import javax.imageio.metadata.IIOMetadataNode;\n+import javax.imageio.stream.ImageOutputStream;\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.IndexColorModel;\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URL;\n+\n+\/**\n+ * This constructs sample gif files used to test different combinations\n+ * of gif frame disposal methods and transparent pixel indices.\n+ *\/\n+public class GifBuilder {\n+\n+    \/**\n+     * Different disposal methods for gif frames. These names exactly\n+     * correspond to the String identifier ImageIO uses.\n+     *\/\n+    public enum Disposal {none, doNotDispose, restoreToBackgroundColor,\n+        restoreToPrevious};\n+\n+\n+    \/**\n+     * @param disposal the frame disposal method\n+     * @param isFirstTableIndexTransparent if true then the transparent pixel\n+     *                                     is set to 0. If false then the\n+     *                                     transparent pixel is set to the\n+     *                                     last index.\n+     *\/\n+    public record FrameDescription(Disposal disposal, boolean\n+            isFirstTableIndexTransparent) {}\n+\n+    \/**\n+     * This creates a sample gif image based on a series of FrameDescriptions,\n+     * and the calls {@link GifComparison#run(URL)}\n+     *\/\n+    public static void test(FrameDescription... frameDescriptions)\n+            throws Throwable {\n+        File file = createTestFile(frameDescriptions);\n+        try {\n+            GifComparison.run(file.toURI().toURL());\n+        } finally {\n+            file.delete();\n+        }\n+    }\n+\n+    private static File createTestFile(FrameDescription... frameDescriptions)\n+            throws IOException {\n+        Color[] colors = new Color[] {\n+                Color.red,\n+                Color.yellow,\n+                Color.green,\n+                Color.cyan\n+        };\n+        File file = File.createTempFile(\"GifBuilder\", \".gif\");\n+        ImageOutputStream ios = ImageIO.createImageOutputStream(file);\n+        ImageWriter gifWriter = ImageIO.getImageWritersByFormatName(\"GIF\").\n+                next();\n+        gifWriter.setOutput(ios);\n+        ImageWriteParam wparam = gifWriter.getDefaultWriteParam();\n+        IIOMetadata streamMetadata = gifWriter.\n+                getDefaultStreamMetadata(wparam);\n+        gifWriter.prepareWriteSequence(streamMetadata);\n+\n+        IndexColorModel icm = createIndexColorModel(colors, colors.length - 1);\n+\n+        ImageTypeSpecifier s = ImageTypeSpecifier.createFromBufferedImageType(\n+                BufferedImage.TYPE_BYTE_INDEXED);\n+        IIOMetadata metadata = gifWriter.getDefaultImageMetadata(s, wparam);\n+        String metaFormatName = metadata.getNativeMetadataFormatName();\n+\n+        for (FrameDescription frameDescription : frameDescriptions) {\n+\n+            \/\/ prepare the image:\n+            int width = 100 + 50 * (icm.getMapSize() - 2);\n+            BufferedImage bi = new BufferedImage(width, 100,\n+                    BufferedImage.TYPE_BYTE_INDEXED, icm);\n+            Graphics2D g = bi.createGraphics();\n+            g.setComposite(AlphaComposite.Clear);\n+            g.fillRect(0, 0, bi.getWidth(), bi.getHeight());\n+            g.setComposite(AlphaComposite.SrcOver);\n+            int x = 0;\n+            for (int a = 0; a < icm.getMapSize() - 1; a++) {\n+                if (a != icm.getTransparentPixel()) {\n+                    Color color = new Color(icm.getRGB(a));\n+                    g.setColor(color);\n+                    g.fillOval(x, 0, 100, 100);\n+                    x += 50;\n+                }\n+            }\n+            g.dispose();\n+\n+            \/\/ wrap attributes for gifWriter:\n+            int transparentPixel = frameDescription.isFirstTableIndexTransparent\n+                    ? 0 : icm.getMapSize() - 1;\n+            IIOMetadata frameMetadata = gifWriter.getDefaultImageMetadata(\n+                    ImageTypeSpecifier.createFromRenderedImage(bi), wparam);\n+            IIOMetadataNode root = new IIOMetadataNode(metaFormatName);\n+            IIOMetadataNode gce = new IIOMetadataNode(\n+                    \"GraphicControlExtension\");\n+            gce.setAttribute(\"disposalMethod\",\n+                    frameDescription.disposal.name());\n+            gce.setAttribute(\"userInputFlag\", \"FALSE\");\n+            gce.setAttribute(\"transparentColorFlag\", \"TRUE\");\n+            gce.setAttribute(\"delayTime\", \"0\");\n+            gce.setAttribute(\"transparentColorIndex\",\n+                    Integer.toString(transparentPixel));\n+            root.appendChild(gce);\n+            frameMetadata.mergeTree(metaFormatName, root);\n+            IIOImage img = new IIOImage(bi,  null, frameMetadata);\n+            gifWriter.writeToSequence(img, wparam);\n+        }\n+        gifWriter.endWriteSequence();\n+        ios.flush();\n+        ios.close();\n+\n+        return file;\n+    }\n+\n+    private static IndexColorModel createIndexColorModel(Color[] colors,\n+                                                 int transparentIndex) {\n+        byte[] r = new byte[colors.length];\n+        byte[] g = new byte[colors.length];\n+        byte[] b = new byte[colors.length];\n+        for (int a = 0; a < colors.length; a++) {\n+            r[a] = (byte) colors[a].getRed();\n+            g[a] = (byte) colors[a].getGreen();\n+            b[a] = (byte) colors[a].getBlue();\n+        }\n+        int bits = (int)(Math.log(colors.length) \/ Math.log(2) + .5);\n+        return new IndexColorModel(bits, colors.length, r, g, b,\n+                transparentIndex);\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/gif\/GifBuilder.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,406 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageReader;\n+import javax.imageio.metadata.IIOMetadata;\n+import javax.imageio.metadata.IIOMetadataNode;\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ImageConsumer;\n+import java.awt.image.IndexColorModel;\n+import java.net.URL;\n+import java.util.Hashtable;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\/**\n+ * This compares the last frame of ImageIO's rendering of a gif with the\n+ * ToolkitImage's rendering.\n+ * <p>\n+ * This is intended to serve as a helper class for more specific test cases.\n+ *\/\n+public class GifComparison {\n+\n+    \/**\n+     * This inspects the last frame of a gif and throws an Error \/ Exception\n+     * if ImageIO and ToolkitImage produce different BufferedImage renderings.\n+     *\n+     * @param srcURL the URL of the image to inspect\n+     *\n+     * @return the last frame encoded as a TYPE_INT_ARGB image.\n+     *         <p>\n+     *         Unit tests may further inspect this image to make sure certain\n+     *         conditions are met.\n+     *\/\n+    public static BufferedImage run(URL srcURL) throws Throwable {\n+        System.out.println(\"Comparing ImageIO vs ToolkitImage rendering of \" +\n+                srcURL);\n+        ImageIOModel ioModel = new ImageIOModel(srcURL);\n+        AWTModel awtModel = new AWTModel(srcURL);\n+\n+        BufferedImage lastImage = null;\n+\n+        int a = ioModel.frames.size() - 1;\n+        BufferedImage ioImg = ioModel.getFrame(a);\n+        BufferedImage awtImage = awtModel.getFrame(a);\n+\n+        lastImage = awtImage;\n+\n+        if (!(ioImg.getWidth() == awtImage.getWidth() &&\n+                ioImg.getHeight() == awtImage.getHeight()))\n+            throw new Error(\"These images are not the same size: \" +\n+                    ioImg.getWidth() + \"x\" + ioImg.getHeight() + \" vs \" +\n+                    awtImage.getWidth() + \"x\" + awtImage.getHeight());\n+\n+        for (int y = 0; y < ioImg.getHeight(); y++) {\n+            for (int x = 0; x < ioImg.getWidth(); x++) {\n+                int argb1 = ioImg.getRGB(x, y);\n+                int argb2 = awtImage.getRGB(x, y);\n+\n+                int alpha1 = (argb1 & 0xff000000) >> 24;\n+                int alpha2 = (argb2 & 0xff000000) >> 24;\n+                if (alpha1 == 0 && alpha2 == 0) {\n+                    continue;\n+                } else if (alpha1 == 0 || alpha2 == 0) {\n+                    throw new Error(\"pixels at (\" + x + \", \" + y +\n+                            \") have different opacities: \" +\n+                            Integer.toUnsignedString(argb1, 16) + \" vs \" +\n+                            Integer.toUnsignedString(argb2, 16));\n+                }\n+                int rgb1 = argb1 & 0xffffff;\n+                int rgb2 = argb2 & 0xffffff;\n+                if (rgb1 != rgb2) {\n+                    throw new Error(\"pixels at (\" + x + \", \" + y +\n+                            \") have different opaque RGB values: \" +\n+                            Integer.toUnsignedString(rgb1, 16) + \" vs \" +\n+                            Integer.toUnsignedString(rgb2, 16));\n+                }\n+            }\n+        }\n+        System.out.println(\"Passed\");\n+        return lastImage;\n+    }\n+}\n+\n+\/**\n+ * This identifies frames of a GIF image using ImageIO classes.\n+ *\/\n+class ImageIOModel {\n+\n+    record Frame(int x, int y, int w, int h, String disposalMethod,\n+                 int transparentColorIndex) {}\n+\n+    private final URL url;\n+    private int width, height;\n+\n+    final List<Frame> frames = new LinkedList<>();\n+    private Color backgroundColor;\n+\n+    ImageIOModel(URL url) throws Exception {\n+        this.url = url;\n+\n+        ImageReader reader = ImageIO.getImageReadersByFormatName(\"gif\").next();\n+        try {\n+            initialize(reader);\n+        } finally {\n+            reader.dispose();\n+        }\n+    }\n+\n+    private void initialize(ImageReader reader) throws Exception {\n+        reader.setInput(ImageIO.createImageInputStream(url.openStream()));\n+        IIOMetadata metadata = reader.getStreamMetadata();\n+        IIOMetadataNode globalRoot = (IIOMetadataNode) metadata.getAsTree(\n+                metadata.getNativeMetadataFormatName());\n+\n+        NodeList globalScreenDescriptor = globalRoot.getElementsByTagName(\n+                \"LogicalScreenDescriptor\");\n+        if (globalScreenDescriptor.getLength() > 0) {\n+            IIOMetadataNode screenDescriptor = (IIOMetadataNode)\n+                    globalScreenDescriptor.item(0);\n+\n+            if (screenDescriptor != null) {\n+                width = Integer.parseInt(\n+                        screenDescriptor.getAttribute(\"logicalScreenWidth\"));\n+                height = Integer.parseInt(\n+                        screenDescriptor.getAttribute(\"logicalScreenHeight\"));\n+            }\n+        }\n+\n+        NodeList globalColorTable = globalRoot.getElementsByTagName(\n+                \"GlobalColorTable\");\n+        if (globalColorTable.getLength() > 0) {\n+            IIOMetadataNode colorTable = (IIOMetadataNode)\n+                    globalColorTable.item(0);\n+\n+            if (colorTable != null) {\n+                String bgIndex = colorTable.getAttribute(\n+                        \"backgroundColorIndex\");\n+                IIOMetadataNode colorEntry = (IIOMetadataNode)\n+                        colorTable.getFirstChild();\n+                while (colorEntry != null) {\n+                    if (colorEntry.getAttribute(\"index\").equals(bgIndex)) {\n+                        int red = Integer.parseInt(colorEntry.getAttribute(\n+                                \"red\"));\n+                        int green = Integer.parseInt(colorEntry.getAttribute(\n+                                \"green\"));\n+                        int blue = Integer.parseInt(colorEntry.getAttribute(\n+                                \"blue\"));\n+\n+                        backgroundColor = new Color(red, green, blue);\n+                        break;\n+                    }\n+\n+                    colorEntry = (IIOMetadataNode) colorEntry.getNextSibling();\n+                }\n+            }\n+        }\n+\n+        int frameCount = reader.getNumImages(true);\n+\n+        for (int frameIndex = 0; frameIndex < frameCount; frameIndex++) {\n+            IIOMetadataNode root = (IIOMetadataNode) reader.\n+                    getImageMetadata(frameIndex).\n+                    getAsTree(\"javax_imageio_gif_image_1.0\");\n+            IIOMetadataNode gce = (IIOMetadataNode) root.\n+                    getElementsByTagName(\"GraphicControlExtension\").item(0);\n+            NodeList children = root.getChildNodes();\n+            int transparentColorIndex = -1;\n+            if (\"TRUE\".equalsIgnoreCase(gce.getAttribute(\n+                    \"transparentColorFlag\"))) {\n+                transparentColorIndex = Integer.parseInt(gce.getAttribute(\n+                        \"transparentColorIndex\"));\n+            }\n+\n+            String disposalMethodStr = gce.getAttribute(\"disposalMethod\");\n+\n+            int frameX = 0;\n+            int frameY = 0;\n+            int frameWidth = width;\n+            int frameHeight = height;\n+\n+            for (int nodeIndex = 0; nodeIndex < children.getLength();\n+                 nodeIndex++) {\n+                Node nodeItem = children.item(nodeIndex);\n+\n+                if (nodeItem.getNodeName().equals(\"ImageDescriptor\")) {\n+                    NamedNodeMap map = nodeItem.getAttributes();\n+\n+                    frameX = Integer.parseInt(map.getNamedItem(\n+                            \"imageLeftPosition\").getNodeValue());\n+                    frameY = Integer.parseInt(map.getNamedItem(\n+                            \"imageTopPosition\").getNodeValue());\n+                    frameWidth = Integer.parseInt(map.getNamedItem(\n+                            \"imageWidth\").getNodeValue());\n+                    frameHeight = Integer.parseInt(map.getNamedItem(\n+                            \"imageHeight\").getNodeValue());\n+                    width = Math.max(width, frameX + frameWidth);\n+                    height = Math.max(height, frameY + frameHeight);\n+                }\n+            }\n+\n+            frames.add(new Frame(frameX, frameY, frameWidth, frameHeight,\n+                    disposalMethodStr, transparentColorIndex));\n+        }\n+    }\n+\n+    public BufferedImage getFrame(int frameIndex) throws Exception {\n+        ImageReader reader = ImageIO.getImageReadersByFormatName(\"gif\").next();\n+        reader.setInput(ImageIO.createImageInputStream(url.openStream()));\n+        try {\n+            BufferedImage image = new BufferedImage(width, height,\n+                    BufferedImage.TYPE_INT_ARGB);\n+            BufferedImage previousImage = null;\n+\n+            for (int a = 0; a <= frameIndex; a++) {\n+                Frame f = frames.get(a);\n+                if (Objects.equals(f.disposalMethod, \"restoreToPrevious\")) {\n+                    if (previousImage == null) {\n+                        previousImage = new BufferedImage(image.getWidth(),\n+                                image.getHeight(),\n+                                BufferedImage.TYPE_INT_ARGB);\n+                    }\n+                }\n+\n+                if (previousImage != null) {\n+                    Graphics2D g = previousImage.createGraphics();\n+                    g.setComposite(AlphaComposite.Clear);\n+                    g.fillRect(0, 0, image.getWidth(), image.getHeight());\n+                    g.setComposite(AlphaComposite.SrcOver);\n+                    g.drawImage(image, 0, 0, null);\n+                    g.dispose();\n+                }\n+\n+                BufferedImage frame = reader.read(a);\n+                Graphics2D g = image.createGraphics();\n+                g.drawImage(frame, f.x, f.y, null);\n+                g.dispose();\n+                IndexColorModel icm = (IndexColorModel) frame.getColorModel();\n+\n+                if (a != frameIndex) {\n+                    switch (f.disposalMethod) {\n+                        case \"restoreToBackgroundColor\" -> {\n+                            g = image.createGraphics();\n+                            int t = icm.getTransparentPixel();\n+                            if (t >= 0 && t == f.transparentColorIndex) {\n+                                g.setComposite(AlphaComposite.Clear);\n+                                g.fillRect(f.x, f.y, f.w, f.h);\n+                            } else {\n+                                g.setColor(backgroundColor);\n+                                g.fillRect(f.x, f.y, f.w, f.h);\n+                            }\n+                            g.dispose();\n+                        }\n+                        case \"restoreToPrevious\" -> {\n+                            g = image.createGraphics();\n+                            g.setComposite(AlphaComposite.Clear);\n+                            g.fillRect(f.x, f.y, f.w, f.h);\n+                            g.setComposite(AlphaComposite.SrcOver);\n+                            g.drawImage(previousImage, f.x, f.y,\n+                                    f.x + f.w, f.y + f.h,\n+                                    f.x, f.y,\n+                                    f.x + f.w, f.y + f.h, null);\n+                            g.dispose();\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return image;\n+        } finally {\n+            reader.dispose();\n+        }\n+    }\n+}\n+\n+\n+\/**\n+ * This identifies frames of a GIF image using ToolkitImage \/ ImageProducer.\n+ *\/\n+class AWTModel {\n+    private final URL url;\n+\n+    AWTModel(URL url) {\n+        this.url = url;\n+    }\n+\n+    public BufferedImage getFrame(int frameIndex) {\n+        \/\/ Unfortunately the AWT gif decoder calls Thread.sleep if the frame\n+        \/\/ delay is non-zero. So this method may take a long time to render a\n+        \/\/ frame simply because the decoder is calling Thread.sleep constantly.\n+\n+        Image image = Toolkit.getDefaultToolkit().createImage(url);\n+\n+        AtomicReference<BufferedImage> returnValue = new AtomicReference<>();\n+        Semaphore semaphore = new Semaphore(1);\n+        semaphore.acquireUninterruptibly();\n+        image.getSource().startProduction(new ImageConsumer() {\n+            BufferedImage bi;\n+            int frameCtr = 0;\n+\n+            @Override\n+            public void setDimensions(int width, int height) {\n+                bi = new BufferedImage(width, height,\n+                        BufferedImage.TYPE_INT_ARGB);\n+            }\n+\n+            @Override\n+            public void setProperties(Hashtable<?, ?> props) {}\n+\n+            @Override\n+            public void setColorModel(ColorModel model) {}\n+\n+            @Override\n+            public void setHints(int hintflags) {}\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h,\n+                                  ColorModel model, byte[] pixels, int off,\n+                                  int scansize) {\n+                try {\n+                    final int yMax = y + h;\n+                    final int xMax = x + w;\n+\n+                    IndexColorModel icm = (IndexColorModel) model;\n+                    int[] colorModelRGBs = new int[icm.getMapSize()];\n+                    icm.getRGBs(colorModelRGBs);\n+                    int[] argbRow = new int[bi.getWidth()];\n+\n+                    for (int y_ = y; y_ < yMax; y_++) {\n+                        int i = y_ * scansize + off;\n+                        for (int x_ = x; x_ < xMax; x_++, i++) {\n+                            int pixel = pixels[i] & 0xff;\n+                            argbRow[x_ - x] = colorModelRGBs[pixel];\n+                        }\n+                        bi.getRaster().setDataElements(x, y_, w, 1, argbRow);\n+                    }\n+                } catch (RuntimeException e) {\n+                    \/\/ we don't expect this to happen, but if something goes\n+                    \/\/ wrong nobody else will print our stacktrace for us:\n+                    e.printStackTrace();\n+                    throw e;\n+                }\n+            }\n+\n+            @Override\n+            public void setPixels(int x, int y, int w, int h,\n+                                  ColorModel model, int[] pixels, int off,\n+                                  int scansize) {}\n+\n+            @Override\n+            public void imageComplete(int status) {\n+                try {\n+                    frameCtr++;\n+                    if (frameCtr == frameIndex + 1) {\n+                        returnValue.set(bi);\n+                        semaphore.release();\n+                        \/\/ if we don't detach this consumer the producer will\n+                        \/\/ loop forever\n+                        image.getSource().removeConsumer(this);\n+                        image.flush();\n+                    }\n+                } catch(Exception e) {\n+                    e.printStackTrace();\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        });\n+\n+        semaphore.acquireUninterruptibly();\n+\n+        return returnValue.get();\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/gif\/GifComparison.java","additions":406,"deletions":0,"binary":false,"changes":406,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8356137\n+ * @summary This test verifies a non-zero transparent pixel in gifs works when\n+ * the disposal method changes from 2 to 1\n+ *\/\n+\n+public class GifEmptyBackgroundTest {\n+    public static void main(String[] args) throws Throwable {\n+        GifBuilder.test(\n+                new GifBuilder.FrameDescription(\n+                        GifBuilder.Disposal.restoreToBackgroundColor, false),\n+                new GifBuilder.FrameDescription(\n+                        GifBuilder.Disposal.doNotDispose, false),\n+                new GifBuilder.FrameDescription(\n+                        GifBuilder.Disposal.doNotDispose, false) );\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/image\/gif\/GifEmptyBackgroundTest.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"}]}