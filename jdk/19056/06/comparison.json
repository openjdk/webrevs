{"files":[{"patch":"@@ -644,6 +644,1 @@\n-void DefNewGeneration::collect(bool   full,\n-                               bool   clear_all_soft_refs,\n-                               size_t size,\n-                               bool   is_tlab) {\n-  assert(full || size > 0, \"otherwise we don't want to collect\");\n-\n+bool DefNewGeneration::collect(bool clear_all_soft_refs) {\n@@ -652,8 +647,0 @@\n-  \/\/ If the next generation is too full to accommodate promotion\n-  \/\/ from this generation, pass on collection; let the next generation\n-  \/\/ do it.\n-  if (!collection_attempt_is_safe()) {\n-    log_trace(gc)(\":: Collection attempt not safe ::\");\n-    heap->set_incremental_collection_failed(); \/\/ Slight lie: we did not even attempt one\n-    return;\n-  }\n@@ -777,0 +764,2 @@\n+\n+  return !_promotion_failed;\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -211,1 +211,1 @@\n-  virtual bool should_allocate(size_t word_size, bool is_tlab) {\n+  bool should_allocate(size_t word_size, bool is_tlab) {\n@@ -213,0 +213,1 @@\n+    assert(word_size != 0, \"precondition\");\n@@ -216,1 +217,0 @@\n-    const bool non_zero      = word_size > 0;\n@@ -223,1 +223,0 @@\n-                  non_zero   &&\n@@ -256,4 +255,1 @@\n-  virtual void collect(bool   full,\n-                       bool   clear_all_soft_refs,\n-                       size_t size,\n-                       bool   is_tlab);\n+  bool collect(bool clear_all_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -73,11 +73,0 @@\n-\n-void Generation::print_summary_info_on(outputStream* st) {\n-  StatRecord* sr = stat_record();\n-  double time = sr->accumulated_time.seconds();\n-  st->print_cr(\"Accumulated %s generation GC time %3.7f secs, \"\n-               \"%u GC's, avg GC time %3.7f\",\n-               SerialHeap::heap()->is_young_gen(this) ? \"young\" : \"old\" ,\n-               time,\n-               sr->invocations,\n-               sr->invocations > 0 ? time \/ sr->invocations : 0.0);\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -110,14 +110,0 @@\n-  \/\/ Returns \"true\" iff this generation should be used to allocate an\n-  \/\/ object of the given size.  Young generations might\n-  \/\/ wish to exclude very large objects, for example, since, if allocated\n-  \/\/ often, they would greatly increase the frequency of young-gen\n-  \/\/ collection.\n-  virtual bool should_allocate(size_t word_size, bool is_tlab) {\n-    bool result = false;\n-    size_t overflow_limit = (size_t)1 << (BitsPerSize_t - LogHeapWordSize);\n-    if (!is_tlab || supports_tlab_allocation()) {\n-      result = (word_size > 0) && (word_size < overflow_limit);\n-    }\n-    return result;\n-  }\n-\n@@ -134,25 +120,0 @@\n-  \/\/ Returns \"true\" iff collect() should subsequently be called on this\n-  \/\/ this generation. See comment below.\n-  \/\/ This is a generic implementation which can be overridden.\n-  \/\/\n-  \/\/ Note: in the current (1.4) implementation, when serialHeap's\n-  \/\/ incremental_collection_will_fail flag is set, all allocations are\n-  \/\/ slow path (the only fast-path place to allocate is DefNew, which\n-  \/\/ will be full if the flag is set).\n-  \/\/ Thus, older generations which collect younger generations should\n-  \/\/ test this flag and collect if it is set.\n-  virtual bool should_collect(bool   full,\n-                              size_t word_size,\n-                              bool   is_tlab) {\n-    return (full || should_allocate(word_size, is_tlab));\n-  }\n-\n-  \/\/ Perform a garbage collection.\n-  \/\/ If full is true attempt a full garbage collection of this generation.\n-  \/\/ Otherwise, attempting to (at least) free enough space to support an\n-  \/\/ allocation of the given \"word_size\".\n-  virtual void collect(bool   full,\n-                       bool   clear_all_soft_refs,\n-                       size_t word_size,\n-                       bool   is_tlab) = 0;\n-\n@@ -175,9 +136,0 @@\n-  struct StatRecord {\n-    int invocations;\n-    elapsedTimer accumulated_time;\n-    StatRecord() :\n-      invocations(0),\n-      accumulated_time(elapsedTimer()) {}\n-  };\n-private:\n-  StatRecord _stat_record;\n@@ -185,4 +137,0 @@\n-  StatRecord* stat_record() { return &_stat_record; }\n-\n-  virtual void print_summary_info_on(outputStream* st);\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":0,"deletions":52,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-    Generation *young = _young_gen;\n+    DefNewGeneration *young = _young_gen;\n@@ -382,1 +382,1 @@\n-    VM_GenCollectForAllocation op(size, is_tlab, gc_count_before);\n+    VM_SerialCollectForAllocation op(size, is_tlab, gc_count_before);\n@@ -435,6 +435,6 @@\n-void SerialHeap::collect_generation(Generation* gen, bool full, size_t size,\n-                                    bool is_tlab, bool run_verification, bool clear_soft_refs) {\n-  FormatBuffer<> title(\"Collect gen: %s\", gen->short_name());\n-  GCTraceTime(Trace, gc, phases) t1(title);\n-  TraceCollectorStats tcs(gen->counters());\n-  TraceMemoryManagerStats tmms(gen->gc_manager(), gc_cause(), heap()->is_young_gen(gen) ? \"end of minor GC\" : \"end of major GC\");\n+bool SerialHeap::is_young_gc_safe() const {\n+  if (!_young_gen->to()->is_empty()) {\n+    return false;\n+  }\n+  return _old_gen->promotion_attempt_is_safe(_young_gen->used());\n+}\n@@ -442,2 +442,13 @@\n-  gen->stat_record()->invocations++;\n-  gen->stat_record()->accumulated_time.start();\n+bool SerialHeap::do_young_collection(bool clear_soft_refs) {\n+  if (!is_young_gc_safe()) {\n+    return false;\n+  }\n+  IsSTWGCActiveMark gc_active_mark;\n+  SvcGCMarker sgcm(SvcGCMarker::MINOR);\n+  GCIdMark gc_id_mark;\n+  GCTraceCPUTime tcpu(_young_gen->gc_tracer());\n+  GCTraceTime(Info, gc) t(\"Pause Young\", nullptr, gc_cause(), true);\n+  TraceCollectorStats tcs(_young_gen->counters());\n+  TraceMemoryManagerStats tmms(_young_gen->gc_manager(), gc_cause(), \"end of minor GC\");\n+  print_heap_before_gc();\n+  const PreGenGCValues pre_gc_values = get_pre_gc_values();\n@@ -445,3 +456,0 @@\n-  \/\/ Must be done anew before each collection because\n-  \/\/ a previous collection will do mangling and will\n-  \/\/ change top of some spaces.\n@@ -449,4 +457,4 @@\n-\n-  log_trace(gc)(\"%s invoke=%d size=\" SIZE_FORMAT, heap()->is_young_gen(gen) ? \"Young\" : \"Old\", gen->stat_record()->invocations, size * HeapWordSize);\n-\n-  if (run_verification && VerifyBeforeGC) {\n+  increment_total_collections(false);\n+  const bool should_verify = total_collections() >= VerifyGCStartAt;\n+  if (should_verify && VerifyBeforeGC) {\n+    prepare_for_verify();\n@@ -455,0 +463,1 @@\n+  gc_prologue(false);\n@@ -457,3 +466,1 @@\n-  \/\/ Do collection work\n-  {\n-    save_marks();   \/\/ save marks for all gens\n+  save_marks();\n@@ -461,2 +468,1 @@\n-    gen->collect(full, clear_soft_refs, size, is_tlab);\n-  }\n+  bool result = _young_gen->collect(clear_soft_refs);\n@@ -466,3 +472,1 @@\n-  gen->stat_record()->accumulated_time.stop();\n-\n-  update_gc_stats(gen, full);\n+  update_gc_stats(_young_gen, false);\n@@ -470,1 +474,1 @@\n-  if (run_verification && VerifyAfterGC) {\n+  if (should_verify && VerifyAfterGC) {\n@@ -473,136 +477,0 @@\n-}\n-\n-void SerialHeap::do_collection(bool full,\n-                               bool clear_all_soft_refs,\n-                               size_t size,\n-                               bool is_tlab,\n-                               GenerationType max_generation) {\n-  ResourceMark rm;\n-  DEBUG_ONLY(Thread* my_thread = Thread::current();)\n-\n-  assert(SafepointSynchronize::is_at_safepoint(), \"should be at safepoint\");\n-  assert(my_thread->is_VM_thread(), \"only VM thread\");\n-  assert(Heap_lock->is_locked(),\n-         \"the requesting thread should have the Heap_lock\");\n-  guarantee(!is_stw_gc_active(), \"collection is not reentrant\");\n-\n-  if (GCLocker::check_active_before_gc()) {\n-    return; \/\/ GC is disabled (e.g. JNI GetXXXCritical operation)\n-  }\n-\n-  const bool do_clear_all_soft_refs = clear_all_soft_refs ||\n-                          soft_ref_policy()->should_clear_all_soft_refs();\n-\n-  ClearedAllSoftRefs casr(do_clear_all_soft_refs, soft_ref_policy());\n-\n-  IsSTWGCActiveMark active_gc_mark;\n-\n-  bool complete = full && (max_generation == OldGen);\n-  bool old_collects_young = complete;\n-  bool do_young_collection = !old_collects_young && _young_gen->should_collect(full, size, is_tlab);\n-\n-  const PreGenGCValues pre_gc_values = get_pre_gc_values();\n-\n-  bool run_verification = total_collections() >= VerifyGCStartAt;\n-  bool prepared_for_verification = false;\n-  bool do_full_collection = false;\n-\n-  if (do_young_collection) {\n-    GCIdMark gc_id_mark;\n-    GCTraceCPUTime tcpu(((DefNewGeneration*)_young_gen)->gc_tracer());\n-    GCTraceTime(Info, gc) t(\"Pause Young\", nullptr, gc_cause(), true);\n-\n-    print_heap_before_gc();\n-\n-    if (run_verification && VerifyBeforeGC) {\n-      prepare_for_verify();\n-      prepared_for_verification = true;\n-    }\n-\n-    gc_prologue(complete);\n-    increment_total_collections(complete);\n-\n-    collect_generation(_young_gen,\n-                       full,\n-                       size,\n-                       is_tlab,\n-                       run_verification,\n-                       do_clear_all_soft_refs);\n-\n-    if (size > 0 && (!is_tlab || _young_gen->supports_tlab_allocation()) &&\n-        size * HeapWordSize <= _young_gen->unsafe_max_alloc_nogc()) {\n-      \/\/ Allocation request was met by young GC.\n-      size = 0;\n-    }\n-\n-    \/\/ Ask if young collection is enough. If so, do the final steps for young collection,\n-    \/\/ and fallthrough to the end.\n-    do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);\n-    if (!do_full_collection) {\n-      \/\/ Adjust generation sizes.\n-      _young_gen->compute_new_size();\n-\n-      print_heap_change(pre_gc_values);\n-\n-      \/\/ Track memory usage and detect low memory after GC finishes\n-      MemoryService::track_memory_usage();\n-\n-      gc_epilogue(complete);\n-    }\n-\n-    print_heap_after_gc();\n-\n-  } else {\n-    \/\/ No young collection, ask if we need to perform Full collection.\n-    do_full_collection = should_do_full_collection(size, full, is_tlab, max_generation);\n-  }\n-\n-  if (do_full_collection) {\n-    GCIdMark gc_id_mark;\n-    GCTraceCPUTime tcpu(SerialFullGC::gc_tracer());\n-    GCTraceTime(Info, gc) t(\"Pause Full\", nullptr, gc_cause(), true);\n-\n-    print_heap_before_gc();\n-\n-    if (!prepared_for_verification && run_verification && VerifyBeforeGC) {\n-      prepare_for_verify();\n-    }\n-\n-    if (!do_young_collection) {\n-      gc_prologue(complete);\n-      increment_total_collections(complete);\n-    }\n-\n-    \/\/ Accounting quirk: total full collections would be incremented when \"complete\"\n-    \/\/ is set, by calling increment_total_collections above. However, we also need to\n-    \/\/ account Full collections that had \"complete\" unset.\n-    if (!complete) {\n-      increment_total_full_collections();\n-    }\n-\n-    CodeCache::on_gc_marking_cycle_start();\n-\n-    ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n-                              false \/* unregister_nmethods_during_purge *\/,\n-                              false \/* lock_nmethod_free_separately *\/);\n-\n-    collect_generation(_old_gen,\n-                       full,\n-                       size,\n-                       is_tlab,\n-                       run_verification,\n-                       do_clear_all_soft_refs);\n-\n-    CodeCache::on_gc_marking_cycle_finish();\n-    CodeCache::arm_all_nmethods();\n-\n-    \/\/ Adjust generation sizes.\n-    _old_gen->compute_new_size();\n-    _young_gen->compute_new_size();\n-\n-    \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n-    ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n-    DEBUG_ONLY(MetaspaceUtils::verify();)\n-\n-    \/\/ Need to clear claim bits for the next mark.\n-    ClassLoaderDataGraph::clear_claimed_marks();\n@@ -610,2 +478,1 @@\n-    \/\/ Resize the metaspace capacity after full collections\n-    MetaspaceGC::compute_new_size();\n+  _young_gen->compute_new_size();\n@@ -613,1 +480,1 @@\n-    print_heap_change(pre_gc_values);\n+  print_heap_change(pre_gc_values);\n@@ -615,2 +482,2 @@\n-    \/\/ Track memory usage and detect low memory after GC finishes\n-    MemoryService::track_memory_usage();\n+  \/\/ Track memory usage and detect low memory after GC finishes\n+  MemoryService::track_memory_usage();\n@@ -618,3 +485,1 @@\n-    \/\/ Need to tell the epilogue code we are done with Full GC, regardless what was\n-    \/\/ the initial value for \"complete\" flag.\n-    gc_epilogue(true);\n+  gc_epilogue(false);\n@@ -622,3 +487,1 @@\n-    print_heap_after_gc();\n-  }\n-}\n+  print_heap_after_gc();\n@@ -626,3 +489,1 @@\n-bool SerialHeap::should_do_full_collection(size_t size, bool full, bool is_tlab,\n-                                           SerialHeap::GenerationType max_gen) const {\n-  return max_gen == OldGen && _old_gen->should_collect(full, size, is_tlab);\n+  return result;\n@@ -652,1 +513,2 @@\n-  GCCauseSetter x(this, GCCause::_allocation_failure);\n+  assert(size != 0, \"precondition\");\n+\n@@ -655,1 +517,1 @@\n-  assert(size != 0, \"Precondition violated\");\n+  GCLocker::check_active_before_gc();\n@@ -663,18 +525,0 @@\n-  } else if (!incremental_collection_will_fail(false \/* don't consult_young *\/)) {\n-    \/\/ Do an incremental collection.\n-    do_collection(false,                     \/\/ full\n-                  false,                     \/\/ clear_all_soft_refs\n-                  size,                      \/\/ size\n-                  is_tlab,                   \/\/ is_tlab\n-                  SerialHeap::OldGen); \/\/ max_generation\n-  } else {\n-    log_trace(gc)(\" :: Trying full because partial may fail :: \");\n-    \/\/ Try a full collection; see delta for bug id 6266275\n-    \/\/ for the original code and why this has been simplified\n-    \/\/ with from-space allocation criteria modified and\n-    \/\/ such allocation moved out of the safepoint path.\n-    do_collection(true,                      \/\/ full\n-                  false,                     \/\/ clear_all_soft_refs\n-                  size,                      \/\/ size\n-                  is_tlab,                   \/\/ is_tlab\n-                  SerialHeap::OldGen); \/\/ max_generation\n@@ -683,1 +527,3 @@\n-  result = attempt_allocation(size, is_tlab, false \/*first_only*\/);\n+  \/\/ If young-gen can handle this allocation, attempt young-gc firstly.\n+  bool should_run_young_gc = _young_gen->should_allocate(size, is_tlab);\n+  collect_at_safepoint(!should_run_young_gc);\n@@ -685,0 +531,1 @@\n+  result = attempt_allocation(size, is_tlab, false \/*first_only*\/);\n@@ -686,1 +533,0 @@\n-    assert(is_in_reserved(result), \"result not in heap\");\n@@ -703,6 +549,2 @@\n-\n-    do_collection(true,                      \/\/ full\n-                  true,                      \/\/ clear_all_soft_refs\n-                  size,                      \/\/ size\n-                  is_tlab,                   \/\/ is_tlab\n-                  SerialHeap::OldGen); \/\/ max_generation\n+    const bool clear_all_soft_refs = true;\n+    do_full_collection_no_gc_locker(clear_all_soft_refs);\n@@ -713,1 +555,5 @@\n-    assert(is_in_reserved(result), \"result not in heap\");\n+    return result;\n+  }\n+  \/\/ The previous full-gc can shrink the heap, so re-expand it.\n+  result = expand_heap_and_allocate(size, is_tlab);\n+  if (result != nullptr) {\n@@ -789,0 +635,22 @@\n+void SerialHeap::try_collect_at_safepoint(bool full) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"precondition\");\n+  if (GCLocker::check_active_before_gc()) {\n+    return;\n+  }\n+  collect_at_safepoint(full);\n+}\n+\n+void SerialHeap::collect_at_safepoint(bool full) {\n+  assert(!GCLocker::is_active(), \"precondition\");\n+  bool clear_soft_refs = must_clear_all_soft_refs();\n+\n+  if (!full) {\n+    bool success = do_young_collection(clear_soft_refs);\n+    if (success) {\n+      return;\n+    }\n+    \/\/ Upgrade to Full-GC if young-gc fails\n+  }\n+  do_full_collection_no_gc_locker(clear_soft_refs);\n+}\n+\n@@ -812,4 +680,0 @@\n-  const GenerationType max_generation = should_run_young_gc\n-                                      ? YoungGen\n-                                      : OldGen;\n-\n@@ -817,2 +681,4 @@\n-    VM_GenCollectFull op(gc_count_before, full_gc_count_before,\n-                         cause, max_generation);\n+    VM_SerialGCCollect op(!should_run_young_gc,\n+                          gc_count_before,\n+                          full_gc_count_before,\n+                          cause);\n@@ -841,21 +707,77 @@\n-   do_full_collection(clear_all_soft_refs, OldGen);\n-}\n-\n-void SerialHeap::do_full_collection(bool clear_all_soft_refs,\n-                                    GenerationType last_generation) {\n-  do_collection(true,                   \/\/ full\n-                clear_all_soft_refs,    \/\/ clear_all_soft_refs\n-                0,                      \/\/ size\n-                false,                  \/\/ is_tlab\n-                last_generation);       \/\/ last_generation\n-  \/\/ Hack XXX FIX ME !!!\n-  \/\/ A scavenge may not have been attempted, or may have\n-  \/\/ been attempted and failed, because the old gen was too full\n-  if (gc_cause() == GCCause::_gc_locker && incremental_collection_failed()) {\n-    log_debug(gc, jni)(\"GC locker: Trying a full collection because scavenge failed\");\n-    \/\/ This time allow the old gen to be collected as well\n-    do_collection(true,                \/\/ full\n-                  clear_all_soft_refs, \/\/ clear_all_soft_refs\n-                  0,                   \/\/ size\n-                  false,               \/\/ is_tlab\n-                  OldGen);             \/\/ last_generation\n+  if (GCLocker::check_active_before_gc()) {\n+    return;\n+  }\n+  do_full_collection_no_gc_locker(clear_all_soft_refs);\n+}\n+\n+void SerialHeap::do_full_collection_no_gc_locker(bool clear_all_soft_refs) {\n+  IsSTWGCActiveMark gc_active_mark;\n+  SvcGCMarker sgcm(SvcGCMarker::FULL);\n+  GCIdMark gc_id_mark;\n+  GCTraceCPUTime tcpu(SerialFullGC::gc_tracer());\n+  GCTraceTime(Info, gc) t(\"Pause Full\", nullptr, gc_cause(), true);\n+  TraceCollectorStats tcs(_old_gen->counters());\n+  TraceMemoryManagerStats tmms(_old_gen->gc_manager(), gc_cause(), \"end of major GC\");\n+  const PreGenGCValues pre_gc_values = get_pre_gc_values();\n+  print_heap_before_gc();\n+\n+  increment_total_collections(true);\n+  const bool should_verify = total_collections() >= VerifyGCStartAt;\n+  if (should_verify && VerifyBeforeGC) {\n+    prepare_for_verify();\n+    Universe::verify(\"Before GC\");\n+  }\n+\n+  gc_prologue(true);\n+  COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::clear());\n+  CodeCache::on_gc_marking_cycle_start();\n+  ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n+                            false \/* unregister_nmethods_during_purge *\/,\n+                            false \/* lock_nmethod_free_separately *\/);\n+\n+  STWGCTimer* gc_timer = SerialFullGC::gc_timer();\n+  gc_timer->register_gc_start();\n+\n+  SerialOldTracer* gc_tracer = SerialFullGC::gc_tracer();\n+  gc_tracer->report_gc_start(gc_cause(), gc_timer->gc_start());\n+\n+  pre_full_gc_dump(gc_timer);\n+\n+  SerialFullGC::invoke_at_safepoint(clear_all_soft_refs);\n+\n+  post_full_gc_dump(gc_timer);\n+\n+  gc_timer->register_gc_end();\n+\n+  gc_tracer->report_gc_end(gc_timer->gc_end(), gc_timer->time_partitions());\n+  CodeCache::on_gc_marking_cycle_finish();\n+  CodeCache::arm_all_nmethods();\n+  COMPILER2_OR_JVMCI_PRESENT(DerivedPointerTable::update_pointers());\n+\n+  \/\/ Adjust generation sizes.\n+  _old_gen->compute_new_size();\n+  _young_gen->compute_new_size();\n+\n+  \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n+  ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n+  DEBUG_ONLY(MetaspaceUtils::verify();)\n+\n+  \/\/ Need to clear claim bits for the next mark.\n+  ClassLoaderDataGraph::clear_claimed_marks();\n+\n+  \/\/ Resize the metaspace capacity after full collections\n+  MetaspaceGC::compute_new_size();\n+\n+  print_heap_change(pre_gc_values);\n+\n+  \/\/ Track memory usage and detect low memory after GC finishes\n+  MemoryService::track_memory_usage();\n+\n+  \/\/ Need to tell the epilogue code we are done with Full GC, regardless what was\n+  \/\/ the initial value for \"complete\" flag.\n+  gc_epilogue(true);\n+\n+  print_heap_after_gc();\n+\n+  if (should_verify && VerifyAfterGC) {\n+    Universe::verify(\"After GC\");\n@@ -985,5 +907,1 @@\n-  if (log_is_enabled(Debug, gc, heap, exit)) {\n-    LogStreamHandle(Debug, gc, heap, exit) lsh;\n-    _young_gen->print_summary_info_on(&lsh);\n-    _old_gen->print_summary_info_on(&lsh);\n-  }\n+ \/\/ Does nothing\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":155,"deletions":237,"binary":false,"changes":392,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-  friend class VM_GenCollectForAllocation;\n-  friend class VM_GenCollectFull;\n@@ -90,1 +88,1 @@\n-private:\n+\n@@ -101,3 +99,1 @@\n-  \/\/ Collects the given generation.\n-  void collect_generation(Generation* gen, bool full, size_t size, bool is_tlab,\n-                          bool run_verification, bool clear_soft_refs);\n+  bool do_young_collection(bool clear_soft_refs);\n@@ -110,1 +106,0 @@\n-private:\n@@ -119,16 +114,0 @@\n-  \/\/ Helper function for two callbacks below.\n-  \/\/ Considers collection of the first max_level+1 generations.\n-  void do_collection(bool           full,\n-                     bool           clear_all_soft_refs,\n-                     size_t         size,\n-                     bool           is_tlab,\n-                     GenerationType max_generation);\n-\n-  \/\/ Callback from VM_GenCollectForAllocation operation.\n-  \/\/ This function does everything necessary\/possible to satisfy an\n-  \/\/ allocation request that failed in the youngest generation that should\n-  \/\/ have handled it (including collection, expansion, etc.)\n-  HeapWord* satisfy_failed_allocation(size_t size, bool is_tlab);\n-\n-  \/\/ Callback from VM_GenCollectFull operation.\n-  \/\/ Perform a full collection of the first max_level+1 generations.\n@@ -136,1 +115,3 @@\n-  void do_full_collection(bool clear_all_soft_refs, GenerationType max_generation);\n+  void do_full_collection_no_gc_locker(bool clear_all_soft_refs);\n+\n+  void collect_at_safepoint(bool full);\n@@ -142,0 +123,2 @@\n+  bool is_young_gc_safe() const;\n+\n@@ -162,0 +145,9 @@\n+  \/\/ Callback from VM_SerialCollectForAllocation operation.\n+  \/\/ This function does everything necessary\/possible to satisfy an\n+  \/\/ allocation request that failed in the youngest generation that should\n+  \/\/ have handled it (including collection, expansion, etc.)\n+  HeapWord* satisfy_failed_allocation(size_t size, bool is_tlab);\n+\n+  \/\/ Callback from VM_SerialGCCollect.\n+  void try_collect_at_safepoint(bool full);\n+\n@@ -308,4 +300,0 @@\n-  \/\/ Return true if we need to perform full collection.\n-  bool should_do_full_collection(size_t size, bool full,\n-                                 bool is_tlab, GenerationType max_gen) const;\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":16,"deletions":28,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -29,3 +29,1 @@\n-void VM_GenCollectForAllocation::doit() {\n-  SvcGCMarker sgcm(SvcGCMarker::MINOR);\n-\n+void VM_SerialCollectForAllocation::doit() {\n@@ -42,3 +40,1 @@\n-void VM_GenCollectFull::doit() {\n-  SvcGCMarker sgcm(SvcGCMarker::FULL);\n-\n+void VM_SerialGCCollect::doit() {\n@@ -47,1 +43,1 @@\n-  gch->do_full_collection(gch->must_clear_all_soft_refs(), _max_generation);\n+  gch->try_collect_at_safepoint(_full);\n","filename":"src\/hotspot\/share\/gc\/serial\/serialVMOperations.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-class VM_GenCollectForAllocation : public VM_CollectForAllocation {\n+class VM_SerialCollectForAllocation : public VM_CollectForAllocation {\n@@ -35,3 +35,3 @@\n-  VM_GenCollectForAllocation(size_t word_size,\n-                             bool tlab,\n-                             uint gc_count_before)\n+  VM_SerialCollectForAllocation(size_t word_size,\n+                                bool tlab,\n+                                uint gc_count_before)\n@@ -42,2 +42,1 @@\n-  ~VM_GenCollectForAllocation()  {}\n-  virtual VMOp_Type type() const { return VMOp_GenCollectForAllocation; }\n+  virtual VMOp_Type type() const { return VMOp_SerialCollectForAllocation; }\n@@ -49,3 +48,1 @@\n-class VM_GenCollectFull: public VM_GC_Operation {\n- private:\n-  SerialHeap::GenerationType _max_generation;\n+class VM_SerialGCCollect: public VM_GC_Operation {\n@@ -53,9 +50,7 @@\n-  VM_GenCollectFull(uint gc_count_before,\n-                    uint full_gc_count_before,\n-                    GCCause::Cause gc_cause,\n-                    SerialHeap::GenerationType max_generation)\n-    : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before,\n-                      max_generation != SerialHeap::YoungGen \/* full *\/),\n-      _max_generation(max_generation) { }\n-  ~VM_GenCollectFull() {}\n-  virtual VMOp_Type type() const { return VMOp_GenCollectFull; }\n+  VM_SerialGCCollect(bool full,\n+                     uint gc_count_before,\n+                     uint full_gc_count_before,\n+                     GCCause::Cause gc_cause)\n+    : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before, full) {}\n+\n+  virtual VMOp_Type type() const { return VMOp_SerialGCCollect; }\n","filename":"src\/hotspot\/share\/gc\/serial\/serialVMOperations.hpp","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -456,23 +456,0 @@\n-void TenuredGeneration::collect(bool   full,\n-                                bool   clear_all_soft_refs,\n-                                size_t size,\n-                                bool   is_tlab) {\n-  SerialHeap* gch = SerialHeap::heap();\n-\n-  STWGCTimer* gc_timer = SerialFullGC::gc_timer();\n-  gc_timer->register_gc_start();\n-\n-  SerialOldTracer* gc_tracer = SerialFullGC::gc_tracer();\n-  gc_tracer->report_gc_start(gch->gc_cause(), gc_timer->gc_start());\n-\n-  gch->pre_full_gc_dump(gc_timer);\n-\n-  SerialFullGC::invoke_at_safepoint(clear_all_soft_refs);\n-\n-  gch->post_full_gc_dump(gc_timer);\n-\n-  gc_timer->register_gc_end();\n-\n-  gc_tracer->report_gc_end(gc_timer->gc_end(), gc_timer->time_partitions());\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -138,5 +138,0 @@\n-  virtual void collect(bool full,\n-                       bool clear_all_soft_refs,\n-                       size_t size,\n-                       bool is_tlab);\n-\n@@ -152,0 +147,9 @@\n+  bool should_allocate(size_t word_size, bool is_tlab) {\n+    bool result = false;\n+    size_t overflow_limit = (size_t)1 << (BitsPerSize_t - LogHeapWordSize);\n+    if (!is_tlab || supports_tlab_allocation()) {\n+      result = (word_size > 0) && (word_size < overflow_limit);\n+    }\n+    return result;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,4 +39,0 @@\n-  nonstatic_field(Generation,                        _stat_record,           Generation::StatRecord)        \\\n-                                                                                                            \\\n-  nonstatic_field(Generation::StatRecord,            invocations,            int)                           \\\n-  nonstatic_field(Generation::StatRecord,            accumulated_time,       elapsedTimer)                  \\\n@@ -70,1 +66,0 @@\n-  declare_toplevel_type(Generation::StatRecord)                               \\\n","filename":"src\/hotspot\/share\/gc\/serial\/vmStructs_serial.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-\/\/        VM_GenCollectFull\n+\/\/        VM_SerialGCCollect\n@@ -47,1 +47,1 @@\n-\/\/          VM_GenCollectForAllocation\n+\/\/          VM_SerialCollectForAllocation\n@@ -66,1 +66,1 @@\n-\/\/  VM_GenCollectForAllocation\n+\/\/  VM_SerialCollectForAllocation\n@@ -72,1 +72,1 @@\n-\/\/  VM_GenCollectFull\n+\/\/  VM_SerialGCCollect\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-  template(GenCollectFull)                        \\\n-  template(GenCollectForAllocation)               \\\n+  template(SerialCollectForAllocation)            \\\n+  template(SerialGCCollect)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,3 +53,0 @@\n-  \/\/ Fields for class StatRecord\n-  private static Field         statRecordField;\n-  private static CIntegerField invocationField;\n@@ -70,4 +67,0 @@\n-    \/\/ StatRecord\n-    statRecordField         = type.getField(\"_stat_record\");\n-    type                    = db.lookupType(\"Generation::StatRecord\");\n-    invocationField         = type.getCIntegerField(\"invocations\");\n@@ -80,4 +73,0 @@\n-  public int invocations() {\n-    return getStatRecord().getInvocations();\n-  }\n-\n@@ -126,15 +115,0 @@\n-\n-  public static class StatRecord extends VMObject {\n-    public StatRecord(Address addr) {\n-      super(addr);\n-    }\n-\n-    public int getInvocations() {\n-      return (int) invocationField.getValue(addr);\n-    }\n-\n-  }\n-\n-  private StatRecord getStatRecord() {\n-    return VMObjectFactory.newObject(StatRecord.class, addr.addOffsetTo(statRecordField.getOffset()));\n-  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/serial\/Generation.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-    tty.println(\"Young Generation - Invocations: \" + youngGen().invocations());\n+    tty.println(\"Young Generation: \");\n@@ -102,1 +102,1 @@\n-    tty.println(\"Old Generation - Invocations: \" + oldGen().invocations());\n+    tty.println(\"Old Generation: \");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/serial\/SerialHeap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}