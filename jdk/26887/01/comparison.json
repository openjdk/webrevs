{"files":[{"patch":"@@ -39,0 +39,5 @@\n+ * <p>\n+ * Note: Per RFC 8446, if no \"signature_algorithms_cert\" extension is\n+ *       present, then the \"signature_algorithms\" extension also applies to\n+ *       signatures appearing in certificates.\n+ *       See {@code SignatureAlgorithmsExtension} for details.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertSignAlgsExtension.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.ArrayList;\n@@ -70,0 +71,3 @@\n+    private static final List<ProtocolVersion> tls13Protocols =\n+            Arrays.asList(ProtocolVersion.PROTOCOLS_OF_13);\n+\n@@ -194,11 +198,1 @@\n-            int vectorLen = SignatureScheme.sizeInRecord() *\n-                    chc.localSupportedSignAlgs.size();\n-            byte[] extData = new byte[vectorLen + 2];\n-            ByteBuffer m = ByteBuffer.wrap(extData);\n-            Record.putInt16(m, vectorLen);\n-            for (SignatureScheme ss : chc.localSupportedSignAlgs) {\n-                Record.putInt16(m, ss.id);\n-            }\n-\n-            \/\/ Update the context.\n-            chc.handshakeExtensions.put(\n+            return produceNetworkLoad(chc,\n@@ -206,3 +200,1 @@\n-                    new SignatureSchemesSpec(chc.localSupportedSignAlgs));\n-\n-            return extData;\n+                    SSLExtension.CH_SIGNATURE_ALGORITHMS_CERT);\n@@ -394,13 +386,3 @@\n-            \/\/ localSupportedSignAlgs has been already updated when we\n-            \/\/ set the negotiated protocol.\n-            int vectorLen = SignatureScheme.sizeInRecord()\n-                    * shc.localSupportedSignAlgs.size();\n-            byte[] extData = new byte[vectorLen + 2];\n-            ByteBuffer m = ByteBuffer.wrap(extData);\n-            Record.putInt16(m, vectorLen);\n-            for (SignatureScheme ss : shc.localSupportedSignAlgs) {\n-                Record.putInt16(m, ss.id);\n-            }\n-\n-            \/\/ Update the context.\n-            shc.handshakeExtensions.put(\n+            \/\/ localSupportedSignAlgs and localSupportedCertSignAlgs have been\n+            \/\/ already updated when we set the negotiated protocol.\n+            return produceNetworkLoad(shc,\n@@ -408,3 +390,1 @@\n-                    new SignatureSchemesSpec(shc.localSupportedSignAlgs));\n-\n-            return extData;\n+                    SSLExtension.CR_SIGNATURE_ALGORITHMS_CERT);\n@@ -549,0 +529,59 @@\n+\n+    \/**\n+     * Produce network load and update context.\n+     *\n+     * @param hc HandshakeContext\n+     * @param signatureAlgorithmsExt \"signature_algorithms\" extension\n+     * @param signatureAlgorithmsCertExt \"signature_algorithms_cert\"\n+     *         extension\n+     * @return network load as byte array\n+     *\/\n+    private static byte[] produceNetworkLoad(\n+            HandshakeContext hc, SSLExtension signatureAlgorithmsExt,\n+            SSLExtension signatureAlgorithmsCertExt) throws IOException {\n+\n+        List<SignatureScheme> sigAlgs;\n+\n+        \/\/ If we don't produce \"signature_algorithms_cert\" extension, then\n+        \/\/ the \"signature_algorithms\" extension should contain signatures\n+        \/\/ supported for both: handshake signatures and certificate signatures.\n+        if (hc.sslConfig.isAvailable(signatureAlgorithmsCertExt)) {\n+            sigAlgs = hc.localSupportedSignAlgs;\n+        } else {\n+            sigAlgs = new ArrayList<>(hc.localSupportedSignAlgs);\n+            sigAlgs.retainAll(hc.localSupportedCertSignAlgs);\n+            \/\/ Per RFC 8446, we MAY include RSASSA-PKCS1-v1_5 and Legacy\n+            \/\/ algorithms in \"signature_algorithms\" extension. We choose to do\n+            \/\/ so for TLSv1.3 if such signature schemes would be present in\n+            \/\/ \"signature_algorithms_cert\" extension if it were sent.\n+            \/\/ Because it's stated in RFC 8446 that these signature schemes\n+            \/\/ can only be used in certificates, we could keep them in\n+            \/\/ \"signature_algorithms\" without risking that the TLSv1.3 peer\n+            \/\/ will misunderstand that those algorithms can be used for\n+            \/\/ the handshake signature.\n+            if (tls13Protocols.contains(hc.negotiatedProtocol)\n+                    || (hc.activeProtocols.size() == 1\n+                    && tls13Protocols.contains(\n+                    hc.activeProtocols.getFirst()))) {\n+                List<SignatureScheme> sigCertAlgs = new ArrayList<>(\n+                        hc.localSupportedCertSignAlgs);\n+                sigCertAlgs.retainAll(SignatureScheme.TLS13_CERT_ONLY);\n+                sigAlgs.addAll(sigCertAlgs);\n+            }\n+        }\n+\n+        int vectorLen = SignatureScheme.sizeInRecord() * sigAlgs.size();\n+        byte[] extData = new byte[vectorLen + 2];\n+        ByteBuffer m = ByteBuffer.wrap(extData);\n+        Record.putInt16(m, vectorLen);\n+\n+        for (SignatureScheme ss : sigAlgs) {\n+            Record.putInt16(m, ss.id);\n+        }\n+\n+        \/\/ Update the context.\n+        hc.handshakeExtensions.put(\n+                signatureAlgorithmsExt, new SignatureSchemesSpec(sigAlgs));\n+\n+        return extData;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureAlgorithmsExtension.java","additions":69,"deletions":30,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -221,0 +221,10 @@\n+    \/\/ RSASSA-PKCS1-v1_5 plus Legacy signature schemes as defined in RFC 8446,\n+    \/\/ those can be used only for certificate signatures in TLSv1.3.\n+    static final List<SignatureScheme> TLS13_CERT_ONLY = List.of(\n+            RSA_PKCS1_SHA256,\n+            RSA_PKCS1_SHA384,\n+            RSA_PKCS1_SHA512,\n+            ECDSA_SHA1,\n+            RSA_PKCS1_SHA1\n+    );\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365820\n+ * @summary Apply certificate scope constraints to algorithms in\n+ *          \"signature_algorithms\" extension when\n+ *          \"signature_algorithms_cert\" extension is not being sent.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableSignatureSchemePerScopeNoClientCertSignAlgsExtTLS12\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertFalse;\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.security.Security;\n+import java.util.List;\n+\n+\/\/ Test disabled signature_algorithms_cert extension on the client side\n+\/\/ for TLSv1.2.\n+public class DisableSignatureSchemePerScopeNoClientCertSignAlgsExtTLS12 extends\n+        DisableSignatureSchemePerScopeTLS12 {\n+\n+    protected DisableSignatureSchemePerScopeNoClientCertSignAlgsExtTLS12()\n+            throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\n+                \"jdk.tls.disabledAlgorithms\", DISABLED_CONSTRAINTS);\n+        \/\/ Disable signature_algorithms_cert extension for the client.\n+        System.setProperty(\"jdk.tls.client.disableExtensions\",\n+                \"signature_algorithms_cert\");\n+        new DisableSignatureSchemePerScopeNoClientCertSignAlgsExtTLS12().run();\n+    }\n+\n+    @Override\n+    protected void checkClientHello() throws Exception {\n+        \/\/ --- Check signature_algorithms extension ---\n+\n+        \/\/ Get signature_algorithms extension signature schemes.\n+        List<String> sigAlgsSS = getSigSchemesCliHello(\n+                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO),\n+                SIG_ALGS_EXT);\n+\n+        \/\/ signature_algorithms extension MUST NOT contain disabled\n+        \/\/ handshake signature scheme.\n+        assertFalse(sigAlgsSS.contains(HANDSHAKE_DISABLED_SIG),\n+                \"Signature Scheme \" + HANDSHAKE_DISABLED_SIG\n+                + \" present in ClientHello's signature_algorithms extension\");\n+\n+        \/\/ signature_algorithms extension MUST NOT contain disabled\n+        \/\/ certificate signature scheme.\n+        assertFalse(sigAlgsSS.contains(CERTIFICATE_DISABLED_SIG),\n+                \"Signature Scheme \" + CERTIFICATE_DISABLED_SIG\n+                + \" present in ClientHello's signature_algorithms extension\");\n+\n+        \/\/ RSASSA-PKCS1-v1_5 and Legacy algorithms that we include in\n+        \/\/ \"signature_algorithms\" extension if \"signature_algorithms_cert\"\n+        \/\/ extension is not being sent as we MAY per RFC 8446.\n+        \/\/ These should be present in both: TLSv1.2 and TLSv1.3, so we\n+        \/\/ place this check here and TLS13 test should run this method as well.\n+        TLS13_CERT_ONLY.forEach(ss ->\n+                assertTrue(sigAlgsSS.contains(ss), \"Signature Scheme \"\n+                        + ss\n+                        + \" isn't present in ClientHello's\"\n+                        + \" signature_algorithms extension\"));\n+\n+        \/\/ Check signature_algorithms_cert extension should not be present.\n+        assertEquals(getSigSchemesCliHello(extractHandshakeMsg(\n+                        cTOs, TLS_HS_CLI_HELLO), SIG_ALGS_CERT_EXT).size(), 0,\n+                \"signature_algorithms_cert extension present in ClientHello\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeNoClientCertSignAlgsExtTLS12.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365820\n+ * @summary Apply certificate scope constraints to algorithms in\n+ *          \"signature_algorithms\" extension when\n+ *          \"signature_algorithms_cert\" extension is not being sent.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableSignatureSchemePerScopeNoClientCertSignAlgsExtTLS13\n+ *\/\n+\n+import java.security.Security;\n+\n+\/\/ Test disabled signature_algorithms_cert extension on the client side\n+\/\/ for TLSv1.3.\n+public class DisableSignatureSchemePerScopeNoClientCertSignAlgsExtTLS13 extends\n+        DisableSignatureSchemePerScopeNoClientCertSignAlgsExtTLS12 {\n+\n+    protected DisableSignatureSchemePerScopeNoClientCertSignAlgsExtTLS13()\n+            throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\n+                \"jdk.tls.disabledAlgorithms\", DISABLED_CONSTRAINTS);\n+        \/\/ Disable signature_algorithms_cert extension for the client.\n+        System.setProperty(\"jdk.tls.client.disableExtensions\",\n+                \"signature_algorithms_cert\");\n+        new DisableSignatureSchemePerScopeNoClientCertSignAlgsExtTLS13().run();\n+    }\n+\n+    @Override\n+    protected String getProtocol() {\n+        return \"TLSv1.3\";\n+    }\n+\n+    \/\/ TLSv1.3 sends CertificateRequest signature schemes in\n+    \/\/ signature_algorithms and signature_algorithms_cert extensions. Same as\n+    \/\/ ClientHello, but they are encrypted. So we skip CertificateRequest\n+    \/\/ signature schemes verification for TLSv1.3.\n+    @Override\n+    protected void checkCertificateRequest() {\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeNoClientCertSignAlgsExtTLS13.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -56,0 +56,11 @@\n+    \/\/ Signature schemes not supported in TLSv1.3 for the handshake but\n+    \/\/ supported for certificates.\n+    \/\/ This is regardless of jdk.tls.disabledAlgorithms configuration.\n+    protected static final List<String> TLS13_CERT_ONLY = List.of(\n+            \"ecdsa_sha1\",\n+            \"rsa_pkcs1_sha1\",\n+            \"rsa_pkcs1_sha256\",\n+            \"rsa_pkcs1_sha384\",\n+            \"rsa_pkcs1_sha512\"\n+    );\n+\n@@ -123,1 +134,1 @@\n-                + \" signature_algorithms extension\");\n+                + \" signature_algorithms_cert extension\");\n@@ -129,1 +140,1 @@\n-                + \" present in ClientHello's signature_algorithms extension\");\n+                + \" present in ClientHello's signature_algorithms_cert extension\");\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeTLS12.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -44,9 +44,0 @@\n-    \/\/ Signature schemes not supported in TLSv1.3 only for the handshake.\n-    \/\/ This is regardless of jdk.tls.disabledAlgorithms configuration.\n-    List<String> NOT_SUPPORTED_FOR_HANDSHAKE = List.of(\n-            \"rsa_pkcs1_sha1\",\n-            \"rsa_pkcs1_sha256\",\n-            \"rsa_pkcs1_sha384\",\n-            \"rsa_pkcs1_sha512\"\n-    );\n-\n@@ -78,1 +69,1 @@\n-        NOT_SUPPORTED_FOR_HANDSHAKE.forEach(ss ->\n+        TLS13_CERT_ONLY.forEach(ss ->\n@@ -89,3 +80,2 @@\n-        NOT_SUPPORTED_FOR_HANDSHAKE.forEach(ss ->\n-                assertTrue(sigAlgsCertSS.contains(ss),\n-                        \"Signature Scheme \" + ss\n+        TLS13_CERT_ONLY.forEach(ss ->\n+                assertTrue(sigAlgsCertSS.contains(ss), \"Signature Scheme \" + ss\n@@ -93,1 +83,1 @@\n-                        + \" signature_algorithms extension\"));\n+                        + \" signature_algorithms_cert extension\"));\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeTLS13.java","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"}]}