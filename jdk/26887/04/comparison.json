{"files":[{"patch":"@@ -39,0 +39,5 @@\n+ * <p>\n+ * Note: Per RFC 8446, if no \"signature_algorithms_cert\" extension is\n+ *       present, then the \"signature_algorithms\" extension also applies to\n+ *       signatures appearing in certificates.\n+ *       See {@code SignatureAlgorithmsExtension} for details.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertSignAlgsExtension.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.ArrayList;\n@@ -194,11 +195,1 @@\n-            int vectorLen = SignatureScheme.sizeInRecord() *\n-                    chc.localSupportedSignAlgs.size();\n-            byte[] extData = new byte[vectorLen + 2];\n-            ByteBuffer m = ByteBuffer.wrap(extData);\n-            Record.putInt16(m, vectorLen);\n-            for (SignatureScheme ss : chc.localSupportedSignAlgs) {\n-                Record.putInt16(m, ss.id);\n-            }\n-\n-            \/\/ Update the context.\n-            chc.handshakeExtensions.put(\n+            return produceNetworkLoad(chc,\n@@ -206,3 +197,1 @@\n-                    new SignatureSchemesSpec(chc.localSupportedSignAlgs));\n-\n-            return extData;\n+                    SSLExtension.CH_SIGNATURE_ALGORITHMS_CERT);\n@@ -394,13 +383,3 @@\n-            \/\/ localSupportedSignAlgs has been already updated when we\n-            \/\/ set the negotiated protocol.\n-            int vectorLen = SignatureScheme.sizeInRecord()\n-                    * shc.localSupportedSignAlgs.size();\n-            byte[] extData = new byte[vectorLen + 2];\n-            ByteBuffer m = ByteBuffer.wrap(extData);\n-            Record.putInt16(m, vectorLen);\n-            for (SignatureScheme ss : shc.localSupportedSignAlgs) {\n-                Record.putInt16(m, ss.id);\n-            }\n-\n-            \/\/ Update the context.\n-            shc.handshakeExtensions.put(\n+            \/\/ localSupportedSignAlgs and localSupportedCertSignAlgs have been\n+            \/\/ already updated when we set the negotiated protocol.\n+            return produceNetworkLoad(shc,\n@@ -408,3 +387,1 @@\n-                    new SignatureSchemesSpec(shc.localSupportedSignAlgs));\n-\n-            return extData;\n+                    SSLExtension.CR_SIGNATURE_ALGORITHMS_CERT);\n@@ -549,0 +526,41 @@\n+\n+    \/**\n+     * Produce network load and update context.\n+     *\n+     * @param hc HandshakeContext\n+     * @param signatureAlgorithmsExt \"signature_algorithms\" extension\n+     * @param signatureAlgorithmsCertExt \"signature_algorithms_cert\"\n+     *         extension\n+     * @return network load as byte array\n+     *\/\n+    private static byte[] produceNetworkLoad(\n+            HandshakeContext hc, SSLExtension signatureAlgorithmsExt,\n+            SSLExtension signatureAlgorithmsCertExt) throws IOException {\n+\n+        List<SignatureScheme> sigAlgs;\n+\n+        \/\/ If we don't produce \"signature_algorithms_cert\" extension, then\n+        \/\/ the \"signature_algorithms\" extension should contain signatures\n+        \/\/ supported for both: handshake signatures and certificate signatures.\n+        if (hc.sslConfig.isAvailable(signatureAlgorithmsCertExt)) {\n+            sigAlgs = hc.localSupportedSignAlgs;\n+        } else {\n+            sigAlgs = new ArrayList<>(hc.localSupportedSignAlgs);\n+            sigAlgs.retainAll(hc.localSupportedCertSignAlgs);\n+        }\n+\n+        int vectorLen = SignatureScheme.sizeInRecord() * sigAlgs.size();\n+        byte[] extData = new byte[vectorLen + 2];\n+        ByteBuffer m = ByteBuffer.wrap(extData);\n+        Record.putInt16(m, vectorLen);\n+\n+        for (SignatureScheme ss : sigAlgs) {\n+            Record.putInt16(m, ss.id);\n+        }\n+\n+        \/\/ Update the context.\n+        hc.handshakeExtensions.put(\n+                signatureAlgorithmsExt, new SignatureSchemesSpec(sigAlgs));\n+\n+        return extData;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureAlgorithmsExtension.java","additions":48,"deletions":30,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365820\n+ * @summary Apply certificate scope constraints to algorithms in\n+ *          \"signature_algorithms\" extension when\n+ *          \"signature_algorithms_cert\" extension is not being sent.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableCertSignAlgsExtForClientTLS12\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertFalse;\n+\n+import java.security.Security;\n+import java.util.List;\n+\n+\/\/ Test disabled signature_algorithms_cert extension on the client side\n+\/\/ for TLSv1.2.\n+public class DisableCertSignAlgsExtForClientTLS12 extends\n+        DisableSignatureSchemePerScopeTLS12 {\n+\n+    protected DisableCertSignAlgsExtForClientTLS12()\n+            throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\n+                \"jdk.tls.disabledAlgorithms\", DISABLED_CONSTRAINTS);\n+        \/\/ Disable signature_algorithms_cert extension for the client.\n+        System.setProperty(\"jdk.tls.client.disableExtensions\",\n+                \"signature_algorithms_cert\");\n+        new DisableCertSignAlgsExtForClientTLS12().run();\n+    }\n+\n+    @Override\n+    protected void checkClientHello() throws Exception {\n+        \/\/ --- Check signature_algorithms extension ---\n+\n+        \/\/ Get signature_algorithms extension signature schemes.\n+        List<String> sigAlgsSS = getSigSchemesCliHello(\n+                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO),\n+                SIG_ALGS_EXT);\n+\n+        \/\/ signature_algorithms extension MUST NOT contain disabled\n+        \/\/ handshake signature scheme.\n+        assertFalse(sigAlgsSS.contains(HANDSHAKE_DISABLED_SIG),\n+                \"Signature Scheme \" + HANDSHAKE_DISABLED_SIG\n+                        + \" present in ClientHello's signature_algorithms extension\");\n+\n+        \/\/ signature_algorithms extension MUST NOT contain disabled\n+        \/\/ certificate signature scheme.\n+        assertFalse(sigAlgsSS.contains(CERTIFICATE_DISABLED_SIG),\n+                \"Signature Scheme \" + CERTIFICATE_DISABLED_SIG\n+                        + \" present in ClientHello's signature_algorithms extension\");\n+\n+        \/\/ signature_algorithms_cert extension MUST NOT be present.\n+        assertEquals(getSigSchemesCliHello(extractHandshakeMsg(\n+                        cTOs, TLS_HS_CLI_HELLO), SIG_ALGS_CERT_EXT).size(), 0,\n+                \"signature_algorithms_cert extension present in ClientHello\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableCertSignAlgsExtForClientTLS12.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365820\n+ * @summary Apply certificate scope constraints to algorithms in\n+ *          \"signature_algorithms\" extension when\n+ *          \"signature_algorithms_cert\" extension is not being sent.\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableCertSignAlgsExtForClientTLS13\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertFalse;\n+\n+import java.security.Security;\n+import java.util.List;\n+\n+\/\/ Test disabled signature_algorithms_cert extension on the client side\n+\/\/ for TLSv1.3.\n+public class DisableCertSignAlgsExtForClientTLS13 extends\n+        DisableCertSignAlgsExtForClientTLS12 {\n+\n+    protected DisableCertSignAlgsExtForClientTLS13()\n+            throws Exception {\n+        super();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\n+                \"jdk.tls.disabledAlgorithms\", DISABLED_CONSTRAINTS);\n+        \/\/ Disable signature_algorithms_cert extension for the client.\n+        System.setProperty(\"jdk.tls.client.disableExtensions\",\n+                \"signature_algorithms_cert\");\n+        new DisableCertSignAlgsExtForClientTLS13().run();\n+    }\n+\n+    @Override\n+    protected String getProtocol() {\n+        return \"TLSv1.3\";\n+    }\n+\n+    @Override\n+    protected void checkClientHello() throws Exception {\n+        super.checkClientHello();\n+\n+        \/\/ Get signature_algorithms extension signature schemes.\n+        List<String> sigAlgsSS = getSigSchemesCliHello(\n+                extractHandshakeMsg(cTOs, TLS_HS_CLI_HELLO),\n+                SIG_ALGS_EXT);\n+\n+        \/\/ These signature schemes MOST NOT be present in signature_algorithms\n+        \/\/ extension.\n+        TLS13_CERT_ONLY.forEach(ss ->\n+                assertFalse(sigAlgsSS.contains(ss), \"Signature Scheme \" + ss\n+                        + \" present in ClientHello's\"\n+                        + \" signature_algorithms extension\"));\n+    }\n+\n+    \/\/ TLSv1.3 sends CertificateRequest signature schemes in\n+    \/\/ signature_algorithms and signature_algorithms_cert extensions. Same as\n+    \/\/ ClientHello, but they are encrypted. So we skip CertificateRequest\n+    \/\/ signature schemes verification for TLSv1.3.\n+    @Override\n+    protected void checkCertificateRequest() {\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableCertSignAlgsExtForClientTLS13.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8365820\n+ * @summary Apply certificate scope constraints to algorithms in\n+ *          \"signature_algorithms\" extension when\n+ *          \"signature_algorithms_cert\" extension is not being sent.\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @library \/javax\/net\/ssl\/templates\n+ *          \/test\/lib\n+ * @run main\/othervm DisableCertSignAlgsExtForServerTLS13\n+ *\/\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.Utils.runAndCheckException;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.net.SocketException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.KeyStore;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Date;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import jdk.test.lib.security.CertificateBuilder;\n+import sun.security.x509.AuthorityKeyIdentifierExtension;\n+import sun.security.x509.GeneralName;\n+import sun.security.x509.GeneralNames;\n+import sun.security.x509.KeyIdentifier;\n+import sun.security.x509.SerialNumber;\n+import sun.security.x509.X500Name;\n+\n+\/*\n+ * Test disabled signature_algorithms_cert extension on the server side.\n+ *\n+ * CertificateRequest's extensions are encrypted in TLSv1.3. So we can't verify\n+ * the content of the CertificateRequest's signature_algorithms extension\n+ * directly like we do it for extensions in ClientHello message.\n+ * Instead, we run a TLS handshake and check that certificate scope\n+ * constraints are being applied to algorithms in \"signature_algorithms\"\n+ * extension when \"signature_algorithms_cert\" extension is not being sent.\n+ *\/\n+\n+public class DisableCertSignAlgsExtForServerTLS13 extends SSLSocketTemplate {\n+\n+    private static final String KEY_ALGORITHM = \"RSA\";\n+    private static final String SERVER_CERT_SIG_ALG = \"RSASSA-PSS\";\n+    \/\/ SHA256withRSA signature algorithm is not allowed for certificate\n+    \/\/ signatures per TLSv1.3 spec. This is regardless of\n+    \/\/ jdk.tls.disabledAlgorithms configuration.\n+    private static final String CLIENT_CERT_SIG_ALG = \"SHA256withRSA\";\n+    private static final String TRUSTED_CERT_SIG_ALG = \"RSASSA-PSS\";\n+\n+    private final String protocol;\n+    private X509Certificate trustedCert;\n+    private X509Certificate serverCert;\n+    private X509Certificate clientCert;\n+    private KeyPair serverKeys;\n+    private KeyPair clientKeys;\n+\n+    protected DisableCertSignAlgsExtForServerTLS13(\n+            String protocol) throws Exception {\n+        super();\n+        this.protocol = protocol;\n+        setupCertificates();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Disable signature_algorithms_cert extension on the server side.\n+        System.setProperty(\"jdk.tls.server.disableExtensions\",\n+                \"signature_algorithms_cert\");\n+\n+        \/\/ Should run fine on TLSv1.2 because SHA256withRSA signature algorithm\n+        \/\/ is allowed for certificates in TLSv1.2.\n+        new DisableCertSignAlgsExtForServerTLS13(\"TLSv1.2\").run();\n+\n+        \/\/ Should fail for \"TLSv1.3\" and \"TLS\". It fails for \"TLS\" because the\n+        \/\/ protocol is already negotiated when server sends CertificateRequest\n+        \/\/ message.\n+        for (String protocol : new String[]{\"TLS\", \"TLSv1.3\"}) {\n+            runAndCheckException(\n+                    () -> new DisableCertSignAlgsExtForServerTLS13(\n+                            protocol).run(),\n+                    localEx -> {\n+                        Throwable remoteEx = localEx.getSuppressed()[0];\n+\n+                        for (Throwable ex :\n+                                new Throwable[]{localEx, remoteEx}) {\n+                            assertTrue((ex instanceof SSLHandshakeException\n+                                    && ex.getMessage()\n+                                    .contains(\"(certificate_required)\")\n+                                    \/\/ Sometimes we can get SocketException\n+                                    \/\/ instead, depends on network setup.\n+                                    || ex instanceof SocketException));\n+                        }\n+                    });\n+        }\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket sslServerSocket) {\n+        \/\/ Require a conforming certificate for the client.\n+        SSLParameters sslParameters = sslServerSocket.getSSLParameters();\n+        sslParameters.setNeedClientAuth(true);\n+        sslServerSocket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    public SSLContext createServerSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, serverCert, serverKeys.getPrivate(), protocol);\n+    }\n+\n+    @Override\n+    public SSLContext createClientSSLContext() throws Exception {\n+        return getSSLContext(\n+                trustedCert, clientCert, clientKeys.getPrivate(), protocol);\n+    }\n+\n+    private static SSLContext getSSLContext(\n+            X509Certificate trustedCertificate, X509Certificate keyCertificate,\n+            PrivateKey privateKey, String protocol)\n+            throws Exception {\n+\n+        \/\/ create a key store\n+        KeyStore ks = KeyStore.getInstance(\"PKCS12\");\n+        ks.load(null, null);\n+\n+        \/\/ import the trusted cert\n+        ks.setCertificateEntry(\"TLS Signer\", trustedCertificate);\n+\n+        \/\/ generate certificate chain\n+        Certificate[] chain = new Certificate[2];\n+        chain[0] = keyCertificate;\n+        chain[1] = trustedCertificate;\n+\n+        \/\/ import the key entry.\n+        final char[] passphrase = \"passphrase\".toCharArray();\n+        ks.setKeyEntry(\"Whatever\", privateKey, passphrase, chain);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"PKIX\");\n+        tmf.init(ks);\n+\n+        \/\/ create SSL context\n+        SSLContext ctx = SSLContext.getInstance(protocol);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        ctx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        return ctx;\n+    }\n+\n+    \/\/ Certificate-building helper methods.\n+\n+    private void setupCertificates() throws Exception {\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\n+                KEY_ALGORITHM);\n+        KeyPair caKeys = kpg.generateKeyPair();\n+        this.serverKeys = kpg.generateKeyPair();\n+        this.clientKeys = kpg.generateKeyPair();\n+\n+        this.trustedCert = createTrustedCert(caKeys);\n+\n+        this.serverCert = customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                serverKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), SERVER_CERT_SIG_ALG);\n+\n+        this.clientCert = customCertificateBuilder(\n+                \"CN=localhost, OU=SSL-Client, O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                clientKeys.getPublic(), caKeys.getPublic())\n+                .addBasicConstraintsExt(false, false, -1)\n+                .build(trustedCert, caKeys.getPrivate(), CLIENT_CERT_SIG_ALG);\n+    }\n+\n+    private static X509Certificate createTrustedCert(KeyPair caKeys)\n+            throws Exception {\n+        SecureRandom random = new SecureRandom();\n+\n+        KeyIdentifier kid = new KeyIdentifier(caKeys.getPublic());\n+        GeneralNames gns = new GeneralNames();\n+        GeneralName name = new GeneralName(new X500Name(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\"));\n+        gns.add(name);\n+        BigInteger serialNumber = BigInteger.valueOf(\n+                random.nextLong(1000000) + 1);\n+        return customCertificateBuilder(\n+                \"O=Some-Org, L=Some-City, ST=Some-State, C=US\",\n+                caKeys.getPublic(), caKeys.getPublic())\n+                .setSerialNumber(serialNumber)\n+                .addExtension(new AuthorityKeyIdentifierExtension(kid, gns,\n+                        new SerialNumber(serialNumber)))\n+                .addBasicConstraintsExt(true, true, -1)\n+                .build(null, caKeys.getPrivate(), TRUSTED_CERT_SIG_ALG);\n+    }\n+\n+    private static CertificateBuilder customCertificateBuilder(\n+            String subjectName, PublicKey publicKey, PublicKey caKey)\n+            throws CertificateException, IOException {\n+        SecureRandom random = new SecureRandom();\n+\n+        CertificateBuilder builder = new CertificateBuilder()\n+                .setSubjectName(subjectName)\n+                .setPublicKey(publicKey)\n+                .setNotBefore(\n+                        Date.from(Instant.now().minus(1, ChronoUnit.HOURS)))\n+                .setNotAfter(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))\n+                .setSerialNumber(\n+                        BigInteger.valueOf(random.nextLong(1000000) + 1))\n+                .addSubjectKeyIdExt(publicKey)\n+                .addAuthorityKeyIdExt(caKey);\n+        builder.addKeyUsageExt(\n+                new boolean[]{true, true, true, true, true, true});\n+\n+        return builder;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableCertSignAlgsExtForServerTLS13.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -56,0 +56,11 @@\n+    \/\/ Signature schemes not supported in TLSv1.3 for the handshake\n+    \/\/ regardless of jdk.tls.disabledAlgorithms configuration.\n+    \/\/ In TLSv1.2 these are supported for both: handshake and certificate.\n+    protected static final List<String> TLS13_CERT_ONLY = List.of(\n+            \"ecdsa_sha1\",\n+            \"rsa_pkcs1_sha1\",\n+            \"rsa_pkcs1_sha256\",\n+            \"rsa_pkcs1_sha384\",\n+            \"rsa_pkcs1_sha512\"\n+    );\n+\n@@ -123,1 +134,1 @@\n-                + \" signature_algorithms extension\");\n+                + \" signature_algorithms_cert extension\");\n@@ -129,1 +140,1 @@\n-                + \" present in ClientHello's signature_algorithms extension\");\n+                + \" present in ClientHello's signature_algorithms_cert extension\");\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeTLS12.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -44,9 +44,0 @@\n-    \/\/ Signature schemes not supported in TLSv1.3 only for the handshake.\n-    \/\/ This is regardless of jdk.tls.disabledAlgorithms configuration.\n-    List<String> NOT_SUPPORTED_FOR_HANDSHAKE = List.of(\n-            \"rsa_pkcs1_sha1\",\n-            \"rsa_pkcs1_sha256\",\n-            \"rsa_pkcs1_sha384\",\n-            \"rsa_pkcs1_sha512\"\n-    );\n-\n@@ -77,5 +68,6 @@\n-        \/\/ Should not be present in signature_algorithms extension.\n-        NOT_SUPPORTED_FOR_HANDSHAKE.forEach(ss ->\n-                assertFalse(sigAlgsSS.contains(ss),\n-                        \"Signature Scheme \" + ss\n-                        + \" present in ClientHello's signature_algorithms extension\"));\n+        \/\/ These signature schemes MOST NOT be present in signature_algorithms\n+        \/\/ extension.\n+        TLS13_CERT_ONLY.forEach(ss ->\n+                assertFalse(sigAlgsSS.contains(ss), \"Signature Scheme \" + ss\n+                        + \" present in ClientHello's\"\n+                        + \" signature_algorithms extension\"));\n@@ -88,4 +80,4 @@\n-        \/\/ Should be present in signature_algorithms_cert extension.\n-        NOT_SUPPORTED_FOR_HANDSHAKE.forEach(ss ->\n-                assertTrue(sigAlgsCertSS.contains(ss),\n-                        \"Signature Scheme \" + ss\n+        \/\/ These signature schemes MUST be present in\n+        \/\/ signature_algorithms_cert extension.\n+        TLS13_CERT_ONLY.forEach(ss ->\n+                assertTrue(sigAlgsCertSS.contains(ss), \"Signature Scheme \" + ss\n@@ -93,1 +85,1 @@\n-                        + \" signature_algorithms extension\"));\n+                        + \" signature_algorithms_cert extension\"));\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/DisableSignatureSchemePerScopeTLS13.java","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"}]}