{"files":[{"patch":"@@ -114,2 +114,1 @@\n-    \/\/ Returns true if marking has been aborted or false if completed.\n-    bool scan_large_object(G1HeapRegion* hr, const oop obj, MemRegion scan_range) {\n+    void scan_object_in_chunks(G1HeapRegion* hr, const oop obj, MemRegion scan_range) {\n@@ -125,8 +124,3 @@\n-        bool mark_aborted = yield_if_necessary();\n-        if (mark_aborted) {\n-          return true;\n-        } else if (!should_rebuild_or_scrub(hr)) {\n-          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n-          \/\/ have been reclaimed during above yield\/safepoint.\n-          log_trace(gc, marking)(\"Rebuild aborted for reclaimed region: %u\", hr->hrm_index());\n-          return false;\n+\n+        if (yield_if_necessary() || !should_rebuild_or_scrub(hr)) {\n+          return;\n@@ -138,1 +132,0 @@\n-      return false;\n@@ -150,2 +143,1 @@\n-      } else if (obj_size > ProcessingYieldLimitInWords) {\n-        \/\/ Large object, needs to be chunked to avoid stalling safepoints.\n+      } else {\n@@ -153,1 +145,1 @@\n-        scan_large_object(hr, obj, mr);\n+        scan_object_in_chunks(hr, obj, mr);\n@@ -155,1 +147,1 @@\n-        \/\/ we also ignore the marking abort result of scan_large_object - we will check\n+        \/\/ we also ignore the marking abort result of scan_object_in_chunks - we will check\n@@ -157,6 +149,0 @@\n-      } else {\n-        \/\/ Object smaller than yield limit, process it fully.\n-        obj->oop_iterate(&_rebuild_closure);\n-        \/\/ Update how much we have processed. Yield check in main loop\n-        \/\/ will handle this case.\n-        add_processed_words(obj_size);\n@@ -179,50 +165,2 @@\n-    \/\/ Scan the given region from bottom to parsable_bottom. Returns whether marking has\n-    \/\/ been aborted.\n-    bool scan_and_scrub_to_pb(G1HeapRegion* hr, HeapWord* start, HeapWord* const limit) {\n-\n-      while (start < limit) {\n-        if (_bitmap->is_marked(start)) {\n-          \/\/  Live object, need to scan to rebuild remembered sets for this object.\n-          start += scan_object(hr, start);\n-        } else {\n-          \/\/ Found dead object (which klass has potentially been unloaded). Scrub to next\n-          \/\/ marked object and continue.\n-          start = scrub_to_next_live(hr, start, limit);\n-        }\n-\n-        bool mark_aborted = yield_if_necessary();\n-        if (mark_aborted) {\n-          return true;\n-        } else if (!should_rebuild_or_scrub(hr)) {\n-          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n-          \/\/ have been reclaimed during above yield\/safepoint.\n-          log_trace(gc, marking)(\"Scan and scrub aborted for reclaimed region: %u\", hr->hrm_index());\n-          return false;\n-        }\n-      }\n-      return false;\n-    }\n-\n-    \/\/ Scan the given region from parsable_bottom to tars. Returns whether marking has\n-    \/\/ been aborted.\n-    bool scan_from_pb_to_tars(G1HeapRegion* hr, HeapWord* start, HeapWord* const limit) {\n-\n-      while (start < limit) {\n-        start += scan_object(hr, start);\n-        \/\/ Avoid stalling safepoints and stop iteration if mark cycle has been aborted.\n-        bool mark_aborted = yield_if_necessary();\n-        if (mark_aborted) {\n-          return true;\n-        } else if (!should_rebuild_or_scrub(hr)) {\n-          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n-          \/\/ have been reclaimed during above yield\/safepoint.\n-          log_trace(gc, marking)(\"Scan aborted for reclaimed region: %u\", hr->hrm_index());\n-          return false;\n-        }\n-      }\n-      return false;\n-    }\n-\n-    \/\/ Scan and scrub the given region to tars. Returns whether marking has\n-    \/\/ been aborted.\n-    bool scan_and_scrub_region(G1HeapRegion* hr, HeapWord* const pb) {\n+    \/\/ Scan and scrub the given region to tars.\n+    void scan_and_scrub_region(G1HeapRegion* hr, HeapWord* const pb) {\n@@ -234,3 +172,18 @@\n-      if (scan_and_scrub_to_pb(hr, hr->bottom(), pb)) {\n-        log_trace(gc, marking)(\"Scan and scrub aborted for region: %u\", hr->hrm_index());\n-        return true;\n+      {\n+        \/\/ Step 1: Scan the given region from bottom to parsable_bottom.\n+        HeapWord* start = hr->bottom();\n+        HeapWord* limit = pb;\n+        while (start < limit) {\n+          if (_bitmap->is_marked(start)) {\n+            \/\/  Live object, need to scan to rebuild remembered sets for this object.\n+            start += scan_object(hr, start);\n+          } else {\n+            \/\/ Found dead object (which klass has potentially been unloaded). Scrub to next\n+            \/\/ marked object and continue.\n+            start = scrub_to_next_live(hr, start, limit);\n+          }\n+\n+          if (yield_if_necessary() || !should_rebuild_or_scrub(hr)) {\n+            return;\n+          }\n+        }\n@@ -239,5 +192,0 @@\n-      \/\/ Yielding during scrubbing and scanning might have reclaimed the region, so need to\n-      \/\/ re-check after above.\n-      if (!should_rebuild_or_scrub(hr)) {\n-        return false;\n-      }\n@@ -248,4 +196,11 @@\n-      \/\/ Rebuild from TAMS (= parsable_bottom) to TARS.\n-      if (scan_from_pb_to_tars(hr, pb, _cm->top_at_rebuild_start(hr))) {\n-        log_trace(gc, marking)(\"Rebuild aborted for region: %u (%s)\", hr->hrm_index(), hr->get_short_type_str());\n-        return true;\n+      {\n+        \/\/ Step 2: Rebuild from TAMS (= parsable_bottom) to TARS.\n+        HeapWord* start = pb;\n+        HeapWord* limit = _cm->top_at_rebuild_start(hr);\n+        while (start < limit) {\n+          start += scan_object(hr, start);\n+\n+          if (yield_if_necessary() || !should_rebuild_or_scrub(hr)) {\n+            return;\n+          }\n+        }\n@@ -253,1 +208,0 @@\n-      return false;\n@@ -257,2 +211,2 @@\n-    \/\/ stalling safepoints. Returns whether the concurrent marking phase has been aborted.\n-    bool scan_humongous_region(G1HeapRegion* hr, HeapWord* const pb) {\n+    \/\/ stalling safepoints.\n+    void scan_humongous_region(G1HeapRegion* hr, HeapWord* const pb) {\n@@ -263,1 +217,1 @@\n-        return false;\n+        return;\n@@ -281,6 +235,1 @@\n-      bool mark_aborted = scan_large_object(hr, humongous, mr);\n-      if (mark_aborted) {\n-        log_trace(gc, marking)(\"Rebuild aborted for region: %u (%s)\", hr->hrm_index(), hr->get_short_type_str());\n-        return true;\n-      }\n-      return false;\n+      scan_object_in_chunks(hr, humongous, mr);\n@@ -315,1 +264,0 @@\n-      bool mark_aborted;\n@@ -318,1 +266,1 @@\n-        mark_aborted = scan_and_scrub_region(hr, pb);\n+        scan_and_scrub_region(hr, pb);\n@@ -322,1 +270,1 @@\n-        mark_aborted = scan_humongous_region(hr, pb);\n+        scan_humongous_region(hr, pb);\n@@ -325,1 +273,1 @@\n-      return mark_aborted;\n+      return _cm->has_aborted();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":45,"deletions":97,"binary":false,"changes":142,"status":"modified"}]}