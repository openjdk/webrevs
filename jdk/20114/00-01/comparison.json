{"files":[{"patch":"@@ -100,0 +100,14 @@\n+    \/\/ Yield if enough has been processed; returns if the concurrent marking cycle\n+    \/\/ has been aborted for any reason.\n+    bool yield_if_necessary(G1HeapRegion* hr) {\n+      if (_processed_words >= ProcessingYieldLimitInWords) {\n+        reset_processed_words();\n+        \/\/ If a yield occurs (potential young-gc pause), must recheck for\n+        \/\/ potential regions reclamation.\n+        if (_cm->do_yield_check() && !should_rebuild_or_scrub(hr)) {\n+          return true;\n+        }\n+      }\n+      return _cm->has_aborted();\n+    }\n+\n@@ -114,1 +128,1 @@\n-    void scan_object_in_chunks(G1HeapRegion* hr, const oop obj, MemRegion scan_range) {\n+    void scan_large_object(G1HeapRegion* hr, const oop obj, MemRegion scan_range) {\n@@ -125,1 +139,1 @@\n-        if (yield_if_necessary() || !should_rebuild_or_scrub(hr)) {\n+        if (yield_if_necessary(hr)) {\n@@ -143,1 +157,2 @@\n-      } else {\n+      } else if (obj_size > ProcessingYieldLimitInWords) {\n+        \/\/ Large object, needs to be chunked to avoid stalling safepoints.\n@@ -145,1 +160,1 @@\n-        scan_object_in_chunks(hr, obj, mr);\n+        scan_large_object(hr, obj, mr);\n@@ -147,1 +162,1 @@\n-        \/\/ we also ignore the marking abort result of scan_object_in_chunks - we will check\n+        \/\/ we also ignore the marking abort result of scan_large_object - we will check\n@@ -149,0 +164,6 @@\n+      } else {\n+        \/\/ Object smaller than yield limit, process it fully.\n+        obj->oop_iterate(&_rebuild_closure);\n+        \/\/ Update how much we have processed. Yield check in main loop\n+        \/\/ will handle this case.\n+        add_processed_words(obj_size);\n@@ -154,9 +175,12 @@\n-    \/\/ Scrub a range of dead objects starting at scrub_start. Will never scrub past limit.\n-    HeapWord* scrub_to_next_live(G1HeapRegion* hr, HeapWord* scrub_start, HeapWord* limit) {\n-      assert(!_bitmap->is_marked(scrub_start), \"Should not scrub live object\");\n-\n-      HeapWord* scrub_end = _bitmap->get_next_marked_addr(scrub_start, limit);\n-      hr->fill_range_with_dead_objects(scrub_start, scrub_end);\n-\n-      \/\/ Return the next object to handle.\n-      return scrub_end;\n+    \/\/ Scan or scrub depending on if addr is marked.\n+    HeapWord* scan_or_scrub(G1HeapRegion* hr, HeapWord* addr, HeapWord* limit) {\n+      if (_bitmap->is_marked(addr)) {\n+        \/\/  Live object, need to scan to rebuild remembered sets for this object.\n+        return addr + scan_object(hr, addr);\n+      } else {\n+        \/\/ Found dead object (which klass has potentially been unloaded). Scrub to next marked object.\n+        HeapWord* scrub_end = _bitmap->get_next_marked_addr(addr, limit);\n+        hr->fill_range_with_dead_objects(addr, scrub_end);\n+        \/\/ Return the next object to handle.\n+        return scrub_end;\n+      }\n@@ -177,8 +201,1 @@\n-          if (_bitmap->is_marked(start)) {\n-            \/\/  Live object, need to scan to rebuild remembered sets for this object.\n-            start += scan_object(hr, start);\n-          } else {\n-            \/\/ Found dead object (which klass has potentially been unloaded). Scrub to next\n-            \/\/ marked object and continue.\n-            start = scrub_to_next_live(hr, start, limit);\n-          }\n+          start = scan_or_scrub(hr, start, limit);\n@@ -186,1 +203,1 @@\n-          if (yield_if_necessary() || !should_rebuild_or_scrub(hr)) {\n+          if (yield_if_necessary(hr)) {\n@@ -203,1 +220,1 @@\n-          if (yield_if_necessary() || !should_rebuild_or_scrub(hr)) {\n+          if (yield_if_necessary(hr)) {\n@@ -235,1 +252,1 @@\n-      scan_object_in_chunks(hr, humongous, mr);\n+      scan_large_object(hr, humongous, mr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":42,"deletions":25,"binary":false,"changes":67,"status":"modified"}]}