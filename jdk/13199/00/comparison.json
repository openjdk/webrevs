{"files":[{"patch":"@@ -103,1 +103,1 @@\n-DISABLED_WARNINGS_microsoft := 4624 4244 4291 4146 4127\n+DISABLED_WARNINGS_microsoft := 4624 4244 4291 4146 4127 4722\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-#include \"runtime\/flags\/flagSetting.hpp\"\n@@ -406,1 +405,1 @@\n-  FlagSetting fs(Debugging, true);\n+  DebuggingContext debugging{};\n@@ -835,1 +834,1 @@\n-  FlagSetting fs(Debugging, true);\n+  DebuggingContext debugging{};\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -631,1 +631,3 @@\n-    if (Debugging || VMError::is_error_reported())  return nullptr;\n+    if (DebuggingContext::is_enabled() || VMError::is_error_reported()) {\n+      return nullptr;\n+    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -212,1 +212,1 @@\n-    if (VMError::is_error_reported() || Debugging) {\n+    if (VMError::is_error_reported() || DebuggingContext::is_enabled()) {\n","filename":"src\/hotspot\/share\/oops\/accessBackend.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -379,0 +379,3 @@\n+  \/\/ Don't complain if running a debugging command.\n+  if (DebuggingContext::is_enabled()) return;\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -174,0 +174,1 @@\n+  if (DebuggingContext::is_enabled()) return;\n@@ -184,0 +185,1 @@\n+  if (DebuggingContext::is_enabled()) return;\n@@ -193,0 +195,1 @@\n+  if (DebuggingContext::is_enabled()) return;\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -579,1 +579,1 @@\n-  [[noreturn]] static void infinite_sleep();\n+  ATTRIBUTE_NORETURN static void infinite_sleep();\n@@ -604,1 +604,1 @@\n-  [[noreturn]] static void exit(int num);\n+  ATTRIBUTE_NORETURN static void exit(int num);\n@@ -608,1 +608,1 @@\n-  [[noreturn]] static void _exit(int num);\n+  ATTRIBUTE_NORETURN static void _exit(int num);\n@@ -615,2 +615,2 @@\n-  [[noreturn]] static void abort(bool dump_core, void *siginfo, const void *context);\n-  [[noreturn]] static void abort(bool dump_core = true);\n+  ATTRIBUTE_NORETURN static void abort(bool dump_core, void *siginfo, const void *context);\n+  ATTRIBUTE_NORETURN static void abort(bool dump_core = true);\n@@ -623,1 +623,1 @@\n-  [[noreturn]] static void die();\n+  ATTRIBUTE_NORETURN static void die();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITY_ATTRIBUTENORETURN_HPP\n+#define SHARE_UTILITY_ATTRIBUTENORETURN_HPP\n+\n+\/\/ Provide a (temporary) macro for the [[noreturn]] attribute.\n+\/\/\n+\/\/ Unfortunately, some older (though still in use) compilers have bugs when\n+\/\/ using [[noreturn]].  For them we use an empty definition for the attribute.\n+\/\/\n+\/\/ Note: This can't be placed in globalDefinitions_xxx.hpp because the\n+\/\/ attribute is used in debug.hpp, which can't include globalDefinitions.hpp.\n+\n+\/\/ clang 12 (and possibly prior) crashes during build if we use [[noreturn]]\n+\/\/ for assertion failure reporting functions.  The problem seems to be fixed\n+\/\/ in clang 13.\n+#ifdef __clang__\n+#if __clang_major__ < 13\n+#define ATTRIBUTE_NORETURN\n+#endif\n+#endif\n+\n+\/\/ All other platforms can use [[noreturn]].\n+#ifndef ATTRIBUTE_NORETURN\n+#define ATTRIBUTE_NORETURN [[noreturn]]\n+#endif\n+\n+#endif \/\/ SHARE_UTILITY_ATTRIBUTENORETURN_HPP\n","filename":"src\/hotspot\/share\/utilities\/attributeNoreturn.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -79,2 +79,13 @@\n-\/\/ Set to suppress secondary error reporting.\n-bool Debugging = false;\n+int DebuggingContext::_enabled = 0; \/\/ Initially disabled.\n+\n+DebuggingContext::DebuggingContext() {\n+  _enabled += 1;                \/\/ Increase nesting count.\n+}\n+\n+DebuggingContext::~DebuggingContext() {\n+  if (is_enabled()) {\n+    _enabled -= 1;              \/\/ Decrease nesting count.\n+  } else {\n+    fatal(\"Debugging nesting confusion\");\n+  }\n+}\n@@ -169,1 +180,0 @@\n-  if (Debugging) return;\n@@ -191,1 +201,0 @@\n-  if (Debugging) return;\n@@ -211,1 +220,0 @@\n-  if (Debugging) return;\n@@ -281,2 +289,2 @@\n-  ResourceMark rm;\n-  bool debug_save;\n+  ResourceMark _rm;\n+  DebuggingContext _debugging;\n@@ -286,2 +294,0 @@\n-    debug_save = Debugging;\n-    Debugging = true;\n@@ -295,1 +301,0 @@\n-    Debugging = debug_save;\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"utilities\/attributeNoreturn.hpp\"\n@@ -49,0 +50,92 @@\n+\/\/ The DebuggingContext class provides a mechanism for temporarily disabling\n+\/\/ asserts and various consistency checks.  Ordinarily that would be a really\n+\/\/ bad idea, but it's essential for some of the debugging commands provided by\n+\/\/ HotSpot.  (See the Command class in debug.cpp.) These commands are intended\n+\/\/ to be invoked from the debugger while the program is otherwise stopped.\n+\/\/ The commands may invoke operations while the program is in a state where\n+\/\/ those operations are not normally permitted, with the state checked by an\n+\/\/ assert.  We want the debugging commands to bypass those checks.\n+class DebuggingContext {\n+  static int _enabled;          \/\/ Nesting counter.\n+\n+public:\n+  DebuggingContext();\n+  ~DebuggingContext();\n+  \/\/ Asserts and other code use this to determine whether to bypass checks\n+  \/\/ that would otherwise lead to program termination.\n+  static bool is_enabled() { return _enabled > 0; }\n+};\n+\n+\/\/ VMASSERT_CHECK_PASSED(P) provides the mechanism by which DebuggingContext\n+\/\/ disables asserts.  It returns true if P is true or DebuggingContext is\n+\/\/ enabled.  Assertion failure is reported if it returns false, terminating\n+\/\/ the program.\n+\/\/\n+\/\/ The DebuggingContext check being enabled isn't placed inside the report\n+\/\/ function, as that would prevent the report function from being noreturn.\n+\/\/ The report function should be noreturn so there isn't a control path to the\n+\/\/ assertion's continuation that has P being false.  Otherwise, the compiler\n+\/\/ might logically split the continuation to include that path explicitly,\n+\/\/ possibly leading to discovering (and warning about) invalid code.  For\n+\/\/ example, if P := x != nullptr, and the continuation contains a dereference\n+\/\/ of x, the compiler might warn because there is a control path (!P -> report\n+\/\/ -> continuation) where that dereference is known to be invalid.  (Of\n+\/\/ course, if execution actually took that path things would go wrong, but\n+\/\/ that's the risk the DebuggingContext mechanism takes.)\n+\/\/\n+\/\/ Similarly, the check for enabled DebuggingContext shouldn't follow P.\n+\/\/ Having this macro expand to `P || DebuggingContext::is_enabled()` has the\n+\/\/ same problem of a control path through !P to the assertion's continuation.\n+\/\/\n+\/\/ But it can't be just `DebuggingContext::is_enabled() || P` either.  That\n+\/\/ prevents the compiler from inferring based on P that it is true in the\n+\/\/ continuation.  But it also prevents the use of assertions in constexpr\n+\/\/ contexts, since that expression is not constexpr.\n+\/\/\n+\/\/ We could accomodate constexpr usage with std::is_constant_evaluated() (from\n+\/\/ C++20). Unfortunately, we don't currently support C++20.  However, most\n+\/\/ supported compilers have implemented it, and that implementation uses a\n+\/\/ compiler intrinsic that we can use directly without otherwise using C++20.\n+\/\/\n+\/\/ Note that if we could use std::is_constant_evaluated() then we could just\n+\/\/ use this definition for DebuggingContext::is_enabled:\n+\/\/   static constexpr bool is_enabled() {\n+\/\/     return !std::is_constant_evaluated() && _enabled;\n+\/\/   }\n+\/\/ The idea being that we are definitely not executing for debugging if doing\n+\/\/ constant evaluation in the compiler. We don't do something like that now,\n+\/\/ because we need a fallback when we don't have any mechanism for detecting\n+\/\/ constant evaluation.\n+#if defined(TARGET_COMPILER_gcc) || defined(TARGET_COMPILER_xlc)\n+\n+\/\/ gcc10 added both __has_builtin and __builtin_is_constant_evaluated.\n+\/\/ clang has had __has_builtin for a long time, so likely also in xlclang++.\n+\/\/ Similarly, clang has had __builtin_is_constant_evaluated for a long time.\n+\n+#ifdef __has_builtin\n+#if __has_builtin(__builtin_is_constant_evaluated)\n+#define VMASSERT_CHECK_PASSED(p) \\\n+  ((! __builtin_is_constant_evaluated() && DebuggingContext::is_enabled()) || (p))\n+#endif\n+#endif\n+\n+#elif defined(TARGET_COMPILER_visCPP)\n+\n+\/\/ std::is_constant_evaluated() and it's associated intrinsic are available in\n+\/\/ VS 2019 16.5.  The minimum supported version of VS 2019 is already past\n+\/\/ that, so we can rely on the intrinsic being available.\n+#define VMASSERT_CHECK_PASSED(p) \\\n+  ((! __builtin_is_constant_evaluated() && DebuggingContext::is_enabled()) || (p))\n+\n+#endif \/\/ End dispatch on TARGET_COMPILER_xxx\n+\n+\/\/ If we don't have a way to detect constant evaluation, then fall back to the\n+\/\/ less than ideal form of the check, and hope it works.  This succeeds at\n+\/\/ least for gcc.  The support needed to use the above definition was added in\n+\/\/ gcc10. The problems arising from analyzing the failed P case don't seem to\n+\/\/ appear until gcc12.  An alternative is to not provide DebuggingContext\n+\/\/ support for such a configuration.\n+#ifndef VMASSERT_CHECK_PASSED\n+#define VMASSERT_CHECK_PASSED(p) ((p) || DebuggingContext::is_enabled())\n+#endif\n+\n@@ -59,1 +152,1 @@\n-  if (!(p)) {                                                                  \\\n+  if (! VMASSERT_CHECK_PASSED(p)) {                                            \\\n@@ -62,1 +155,0 @@\n-    BREAKPOINT;                                                                \\\n@@ -85,1 +177,1 @@\n-  if (!(p)) {                                                                  \\\n+  if (! VMASSERT_CHECK_PASSED(p)) {                                            \\\n@@ -89,1 +181,0 @@\n-    BREAKPOINT;                                                                \\\n@@ -92,1 +183,1 @@\n-#endif\n+#endif \/\/ ASSERT\n@@ -100,0 +191,1 @@\n+\/\/ guarantee is not subject to DebuggingContext bypass.\n@@ -105,1 +197,0 @@\n-    BREAKPOINT;                                                                   \\\n@@ -113,1 +204,0 @@\n-  BREAKPOINT;                                                                     \\\n@@ -120,1 +210,0 @@\n-  BREAKPOINT;                                                                     \\\n@@ -127,1 +216,0 @@\n-  BREAKPOINT;                                                                     \\\n@@ -134,1 +222,0 @@\n-  BREAKPOINT;                                                                     \\\n@@ -141,1 +228,0 @@\n-  BREAKPOINT;                                                                     \\\n@@ -160,4 +246,0 @@\n-\/\/ Set to suppress secondary error reporting.\n-\/\/ Really should have a qualified name or something.\n-extern bool Debugging;\n-\n@@ -165,0 +247,1 @@\n+ATTRIBUTE_NORETURN\n@@ -166,0 +249,3 @@\n+\n+ATTRIBUTE_NORETURN\n+ATTRIBUTE_PRINTF(4, 5)\n@@ -167,1 +253,3 @@\n-                     const char* detail_fmt, ...) ATTRIBUTE_PRINTF(4, 5);\n+                     const char* detail_fmt, ...);\n+\n+ATTRIBUTE_NORETURN\n@@ -170,1 +258,7 @@\n-void report_fatal(VMErrorType error_type, const char* file, int line, const char* detail_fmt, ...) ATTRIBUTE_PRINTF(4, 5);\n+\n+ATTRIBUTE_NORETURN\n+ATTRIBUTE_PRINTF(4, 5)\n+void report_fatal(VMErrorType error_type, const char* file, int line, const char* detail_fmt, ...);\n+\n+ATTRIBUTE_NORETURN\n+ATTRIBUTE_PRINTF(5, 6)\n@@ -172,4 +266,7 @@\n-                             const char* detail_fmt, ...) ATTRIBUTE_PRINTF(5, 6);\n-void report_should_not_call(const char* file, int line);\n-void report_should_not_reach_here(const char* file, int line);\n-void report_unimplemented(const char* file, int line);\n+                             const char* detail_fmt, ...);\n+\n+ATTRIBUTE_NORETURN void report_should_not_call(const char* file, int line);\n+ATTRIBUTE_NORETURN void report_should_not_reach_here(const char* file, int line);\n+ATTRIBUTE_NORETURN void report_unimplemented(const char* file, int line);\n+\n+\/\/ NOT ATTRIBUTE_NORETURN\n@@ -178,1 +275,2 @@\n-void warning(const char* format, ...) ATTRIBUTE_PRINTF(1, 2);\n+ATTRIBUTE_PRINTF(1, 2)\n+void warning(const char* format, ...);\n","filename":"src\/hotspot\/share\/utilities\/debug.hpp","additions":121,"deletions":23,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/attributeNoreturn.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-  WINDOWS_ONLY([[noreturn]] static void raise_fail_fast(void* exrecord, void* context);)\n+  WINDOWS_ONLY(ATTRIBUTE_NORETURN static void raise_fail_fast(void* exrecord, void* context);)\n@@ -159,1 +159,1 @@\n-  [[noreturn]]\n+  ATTRIBUTE_NORETURN\n@@ -164,1 +164,1 @@\n-  [[noreturn]]\n+  ATTRIBUTE_NORETURN\n@@ -170,1 +170,1 @@\n-  [[noreturn]]\n+  ATTRIBUTE_NORETURN\n@@ -174,1 +174,1 @@\n-  [[noreturn]]\n+  ATTRIBUTE_NORETURN\n@@ -179,1 +179,1 @@\n-  [[noreturn]]\n+  ATTRIBUTE_NORETURN\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}