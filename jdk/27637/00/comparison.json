{"files":[{"patch":"@@ -780,1 +780,1 @@\n-    \/\/ this method should be in sync with com.sun.tools.javac.code.Types.checkUnconditionallyExactPrimitives\n+    \/\/ this method should be in sync with com.sun.tools.javac.code.Types.isUnconditionallyExactPrimitives\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\n+import java.lang.runtime.ExactConversionsSupport;\n@@ -189,0 +189,4 @@\n+    public boolean isNumeric() {\n+        return this.numericClass != 0;\n+    }\n+\n@@ -250,1 +254,1 @@\n-                return Byte.MIN_VALUE <= value && value <= Byte.MAX_VALUE;\n+                return ExactConversionsSupport.isIntToByteExact(value);\n@@ -252,1 +256,1 @@\n-                return Character.MIN_VALUE <= value && value <= Character.MAX_VALUE;\n+                return ExactConversionsSupport.isIntToCharExact(value);\n@@ -254,1 +258,1 @@\n-                return Short.MIN_VALUE <= value && value <= Short.MAX_VALUE;\n+                return ExactConversionsSupport.isIntToShortExact(value);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeTag.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.runtime.ExactConversionsSupport;\n@@ -5057,1 +5058,2 @@\n-    \/** Check unconditionality between any combination of reference or primitive types.\n+    \/** Check unconditionality between any combination of reference or primitive\n+     *  types.\n@@ -5059,6 +5061,16 @@\n-     *  Rules:\n-     *    an identity conversion\n-     *    a widening reference conversion\n-     *    a widening primitive conversion (delegates to `checkUnconditionallyExactPrimitives`)\n-     *    a boxing conversion\n-     *    a boxing conversion followed by a widening reference conversion\n+     *  The following are unconditionally exact regardless of the input\n+     *  expression:\n+     *\n+     *    - an identity conversion\n+     *    - a widening reference conversion\n+     *    - an exact widening primitive conversion\n+     *    - a boxing conversion\n+     *    - a boxing conversion followed by a widening reference conversion\n+     *\n+     *  Additionally, the following can be unconditionally exact if the source\n+     *  primitive is a constant expression and the conversions is exact for that\n+     *  constant expression:\n+     *\n+     *    - a narrowing primitive conversion\n+     *    - a widening and narrowing primitive conversion\n+     *    - a widening primitive conversion that is not exact\n@@ -5074,3 +5086,12 @@\n-        return target.isPrimitive()\n-                ? isUnconditionallyExactPrimitives(source, target)\n-                : isSubtype(boxedTypeOrType(erasure(source)), target);\n+        if (target.isPrimitive()) {\n+            if (source.isPrimitive() &&\n+                ((source.getTag().isStrictSubRangeOf(target.getTag())) &&\n+                        !((source.hasTag(BYTE) && target.hasTag(CHAR)) ||\n+                          (source.hasTag(INT) && target.hasTag(FLOAT)) ||\n+                          (source.hasTag(LONG) && (target.hasTag(DOUBLE) || target.hasTag(FLOAT)))))) return true;\n+            else {\n+                return false;\n+            }\n+        } else {\n+            return isSubtype(boxedTypeOrType(erasure(source)), target);\n+        }\n@@ -5078,0 +5099,3 @@\n+    \/\/ where\n+    public boolean isUnconditionallyExactConstantPrimitives(Type source, Type target) {\n+        if (!(source.constValue() instanceof Number value) || !target.getTag().isNumeric()) return false;\n@@ -5079,17 +5103,57 @@\n-    \/** Check unconditionality between primitive types.\n-     *\n-     *  - widening from one integral type to another,\n-     *  - widening from one floating point type to another,\n-     *  - widening from byte, short, or char to a floating point type,\n-     *  - widening from int to double.\n-     *\n-     *  @param selectorType     Type of selector\n-     *  @param targetType       Target type\n-     *\/\n-    public boolean isUnconditionallyExactPrimitives(Type selectorType, Type targetType) {\n-        return isSameType(selectorType, targetType) ||\n-                (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n-                ((selectorType.getTag().isStrictSubRangeOf(targetType.getTag())) &&\n-                        !((selectorType.hasTag(BYTE) && targetType.hasTag(CHAR)) ||\n-                          (selectorType.hasTag(INT)  && targetType.hasTag(FLOAT)) ||\n-                          (selectorType.hasTag(LONG) && (targetType.hasTag(DOUBLE) || targetType.hasTag(FLOAT)))));\n+        switch (source.getTag()) {\n+            case BYTE:\n+                switch (target.getTag()) {\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                }\n+                break;\n+            case CHAR:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+                }\n+                break;\n+            case SHORT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                }\n+                break;\n+            case INT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                    case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+                    case FLOAT:     return ExactConversionsSupport.isIntToFloatExact(value.intValue());\n+                }\n+                break;\n+            case FLOAT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isFloatToByteExact(value.floatValue());\n+                    case CHAR:      return ExactConversionsSupport.isFloatToCharExact(value.floatValue());\n+                    case SHORT:     return ExactConversionsSupport.isFloatToShortExact(value.floatValue());\n+                    case INT:       return ExactConversionsSupport.isFloatToIntExact(value.floatValue());\n+                    case LONG:      return ExactConversionsSupport.isFloatToLongExact(value.floatValue());\n+                }\n+                break;\n+            case LONG:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isLongToByteExact(value.longValue());\n+                    case CHAR:      return ExactConversionsSupport.isLongToCharExact(value.longValue());\n+                    case SHORT:     return ExactConversionsSupport.isLongToShortExact(value.longValue());\n+                    case INT:       return ExactConversionsSupport.isLongToIntExact(value.longValue());\n+                    case FLOAT:     return ExactConversionsSupport.isLongToFloatExact(value.longValue());\n+                    case DOUBLE:    return ExactConversionsSupport.isLongToDoubleExact(value.longValue());\n+                }\n+                break;\n+            case DOUBLE:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isDoubleToByteExact(value.doubleValue());\n+                    case CHAR:      return ExactConversionsSupport.isDoubleToCharExact(value.doubleValue());\n+                    case SHORT:     return ExactConversionsSupport.isDoubleToShortExact(value.doubleValue());\n+                    case INT:       return ExactConversionsSupport.isDoubleToIntExact(value.doubleValue());\n+                    case FLOAT:     return ExactConversionsSupport.isDoubleToFloatExact(value.doubleValue());\n+                    case LONG:      return ExactConversionsSupport.isDoubleToLongExact(value.doubleValue());\n+                }\n+                break;\n+        }\n+        return true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":91,"deletions":27,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+        allowPrimitivePatterns = preview.isEnabled() && Feature.PRIMITIVE_PATTERNS.allowedInSource(source);\n@@ -193,0 +194,4 @@\n+    \/** Are primitive patterns allowed\n+     *\/\n+    private final boolean allowPrimitivePatterns;\n+\n@@ -4737,2 +4742,9 @@\n-                    if (types.isUnconditionallyExact(currentType, testType) &&\n-                        !currentType.hasTag(ERROR) && !testType.hasTag(ERROR)) {\n+\n+                    if (unconditionalCaseLabel == testCaseLabel) unconditionalFound = true;\n+                    boolean dominatedCandidate = false;\n+                    if (!currentType.hasTag(ERROR) && !testType.hasTag(ERROR)) {\n+                        if (types.isUnconditionallyExact(currentType, testType)) {\n+                            dominatedCandidate = true;\n+                        } else if (currentType.constValue() instanceof Number) {\n+                            dominatedCandidate = types.isUnconditionallyExactConstantPrimitives(currentType, testType);\n+                        }\n@@ -4741,1 +4753,2 @@\n-                            dominated |= !(testCaseLabel instanceof JCConstantCaseLabel) &&\n+                            dominated = dominatedCandidate &&\n+                                         !(testCaseLabel instanceof JCConstantCaseLabel) &&\n@@ -4746,2 +4759,2 @@\n-                            dominated = patternDominated(testPatternCaseLabel.pat,\n-                                                         patternCL.pat);\n+                            dominated = dominatedCandidate &&\n+                                        patternDominated(testPatternCaseLabel.pat, patternCL.pat);\n@@ -4750,1 +4763,3 @@\n-\n+                    if (allowPrimitivePatterns && unconditionalFound && unconditionalCaseLabel != label) {\n+                        dominated = true;\n+                    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @compile\/fail\/ref=DominationWithPP.out --enable-preview --source ${jdk.version} -XDrawDiagnostics Domination.java\n@@ -30,1 +31,0 @@\n-\n@@ -221,0 +221,10 @@\n+\n+    int testCasePatternDominatedbyPreceedingUnconditionalCasePattern () {\n+        interface A {}\n+        interface B {}\n+        A aa = new A() {};\n+        switch (aa) {\n+            case A a : return 1;\n+            case B b : return -1;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -13,1 +13,2 @@\n-12 errors\n+Domination.java:228:18: compiler.err.pattern.dominated\n+13 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/DominationWithPP.out","additions":2,"deletions":1,"binary":false,"changes":3,"previous_filename":"test\/langtools\/tools\/javac\/patterns\/Domination.out","status":"copied"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Retain exhaustiveness properties of switches with a constant selector\n+ * @enablePreview\n+ * @compile\/fail\/ref=PrimitivePatternsSwitchConstants.out -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitivePatternsSwitchConstants.java\n+ *\/\n+public class PrimitivePatternsSwitchConstants {\n+    void testConstExpressions() {\n+        switch (42) {         \/\/ error: not exhaustive\n+            case byte _ :\n+        }\n+\n+        switch (42l) {        \/\/ error: not exhaustive\n+            case byte _ :\n+        }\n+\n+        switch (123456) {     \/\/ error: not exhaustive\n+            case byte _ :\n+        }\n+\n+        switch (16_777_216) { \/\/ error: not exhaustive\n+            case float _ :\n+        }\n+\n+        switch (16_777_217) { \/\/ error: not exhaustive\n+            case float _ :\n+        }\n+\n+        switch (42d) {        \/\/ error: not exhaustive\n+            case float _ :\n+        }\n+\n+        switch (1) {          \/\/ OK\n+            case long _ :\n+        }\n+\n+        final int i = 42;\n+        switch (i) {          \/\/ OK\n+            case long _ :\n+        }\n+\n+        switch (1) {          \/\/ error: non-exhaustive\n+            case Long _ :         \/\/ error: widening primitive conversion and boxing is not supported\n+        }\n+\n+        switch (42) {\n+            case byte bb  -> {}\n+            case int ii   -> {}   \/\/ OK\n+        };\n+\n+        switch (42) {\n+            case 42 -> {}\n+            case int ii -> {}     \/\/ OK\n+        };\n+\n+        switch (42) {\n+            case (byte) 42 -> {}\n+            case int ii -> {}     \/\/ OK\n+        };\n+\n+        switch (42) {\n+            case 42 -> {}\n+            default -> {}         \/\/ OK\n+        };\n+\n+        switch (42) {\n+            default -> {}         \/\/ OK\n+            case 42 -> {}\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchConstants.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+PrimitivePatternsSwitchConstants.java:43:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Long)\n+PrimitivePatternsSwitchConstants.java:9:9: compiler.err.not.exhaustive.statement\n+PrimitivePatternsSwitchConstants.java:13:9: compiler.err.not.exhaustive.statement\n+PrimitivePatternsSwitchConstants.java:17:9: compiler.err.not.exhaustive.statement\n+PrimitivePatternsSwitchConstants.java:21:9: compiler.err.not.exhaustive.statement\n+PrimitivePatternsSwitchConstants.java:25:9: compiler.err.not.exhaustive.statement\n+PrimitivePatternsSwitchConstants.java:29:9: compiler.err.not.exhaustive.statement\n+PrimitivePatternsSwitchConstants.java:42:9: compiler.err.not.exhaustive.statement\n+- compiler.note.preview.filename: PrimitivePatternsSwitchConstants.java, DEFAULT\n+- compiler.note.preview.recompile\n+8 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchConstants.out","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -62,1 +62,1 @@\n-            case byte ip     -> ip; \/\/ OK - not dominated!\n+            case byte ip     -> ip; \/\/ Error - dominated!\n@@ -268,0 +268,65 @@\n+\n+    public static void dominanceIntFloat() {\n+        int ii = 42;\n+        switch (ii) {\n+            case int i -> {}\n+            case float f -> {} \/\/ Error - dominated!\n+        }\n+    }\n+\n+    public static void noDominanceIntFloat() {\n+        int ii = 42;\n+        switch (ii) {\n+            case float f -> {}\n+            case int i -> {} \/\/ ok\n+        }\n+    }\n+\n+    public static void strengtheningDominance() {\n+        byte x = 42;\n+        switch (x) {\n+            case short s -> {}\n+            case 42      -> {}    \/\/ error: dominated\n+        }\n+\n+        long l = 42l;\n+        switch (l) {\n+            case short s -> {}\n+            case 42l     -> {}    \/\/ error: dominated\n+            case long _  -> {}\n+        }\n+\n+        char c = 'a';\n+        switch (c) {\n+            case short s -> {}\n+            case 42      -> {}    \/\/ error: dominated\n+            case char _  -> {}\n+        }\n+\n+        int x2 = 42;\n+        switch(x2) {\n+            case float f -> {}\n+            case 16_777_216 -> {}  \/\/ error: dominated\n+            default -> {}\n+        }\n+\n+        switch(x2) {\n+            case float f -> {}\n+            case 16_777_217 -> {} \/\/ OK\n+            default -> {}\n+        }\n+\n+        switch(x2) {\n+            case int ii   -> {}\n+            case float f -> {}    \/\/ error: dominated\n+        }\n+    }\n+\n+    public static void unconditionalFollowedByDefault() {\n+        int ii = 42;\n+        switch (ii) {\n+            case int i -> {}\n+            case float f -> {} \/\/ Error - dominated!\n+            default -> {}      \/\/ Error - unconditional and default\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.java","additions":66,"deletions":1,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+PrimitivePatternsSwitchErrors.java:62:18: compiler.err.pattern.dominated\n@@ -32,0 +33,8 @@\n+PrimitivePatternsSwitchErrors.java:273:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:289:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:295:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:302:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:309:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:321:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:330:13: compiler.err.unconditional.pattern.and.default\n+PrimitivePatternsSwitchErrors.java:329:18: compiler.err.pattern.dominated\n@@ -46,1 +55,1 @@\n-43 errors\n\\ No newline at end of file\n+52 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.out","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Check assignability of narrowing p.c. with constant expressions vs exact conversion methods\n+ * @library \/tools\/lib\/types\n+ * @modules jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ * @build TypeHarness\n+ * @compile PrimitiveUnconditionallyExactInAssignability.java\n+ * @run main PrimitiveUnconditionallyExactInAssignability\n+ *\/\n+\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.TypeTag;\n+\n+import java.lang.runtime.ExactConversionsSupport;\n+\n+import static com.sun.tools.javac.code.TypeTag.ERROR;\n+import static com.sun.tools.javac.code.TypeTag.INT;\n+\n+public class PrimitiveUnconditionallyExactInAssignability extends TypeHarness {\n+    PrimitiveUnconditionallyExactInAssignability() {\n+    }\n+\n+    void assertAssignmentNarrowingAndUnconditionality() {\n+        \/\/ byte b = <constant short> vs ExactConversionsSupport::isIntToByteExact\n+        assertAssignable(fac.Constant(Short.MIN_VALUE),                     predef.byteType, ExactConversionsSupport.isIntToByteExact(Short.MIN_VALUE));\n+        assertAssignable(fac.Constant((short) (Byte.MIN_VALUE - 1)),        predef.byteType, ExactConversionsSupport.isIntToByteExact((short) (Byte.MIN_VALUE - 1)));\n+        assertAssignable(fac.Constant((short) (Byte.MAX_VALUE + 1)),        predef.byteType, ExactConversionsSupport.isIntToByteExact((short) (Byte.MAX_VALUE + 1)));\n+        assertAssignable(fac.Constant(Short.MAX_VALUE),                     predef.byteType, ExactConversionsSupport.isIntToByteExact(Short.MAX_VALUE));\n+\n+        \/\/ byte b = <constant char> vs ExactConversionsSupport::isIntToByteExact\n+        assertAssignable(fac.Constant(Character.MIN_VALUE),                 predef.byteType, ExactConversionsSupport.isIntToByteExact(Character.MIN_VALUE));\n+        assertAssignable(fac.Constant((char) (Byte.MAX_VALUE + 1)),         predef.byteType, ExactConversionsSupport.isIntToByteExact((char) (Byte.MAX_VALUE + 1)));\n+        assertAssignable(fac.Constant(Character.MAX_VALUE),                 predef.byteType, ExactConversionsSupport.isIntToByteExact(Character.MAX_VALUE));\n+\n+        \/\/ byte b = <constant int>  vs ExactConversionsSupport::isIntToByteExact\n+        assertAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.byteType, ExactConversionsSupport.isIntToByteExact(Integer.MIN_VALUE));\n+        assertAssignable(fac.Constant((int) (Byte.MIN_VALUE - 1)),          predef.byteType, ExactConversionsSupport.isIntToByteExact((int) (Byte.MIN_VALUE - 1)));\n+        assertAssignable(fac.Constant((int) (Byte.MAX_VALUE + 1)),          predef.byteType, ExactConversionsSupport.isIntToByteExact((int) (Byte.MAX_VALUE + 1)));\n+        assertAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.byteType, ExactConversionsSupport.isIntToByteExact(Integer.MAX_VALUE));\n+\n+        \/\/ char c = <constant short> vs ExactConversionsSupport::isIntToCharExact\n+        assertAssignable(fac.Constant(Short.MIN_VALUE),                     predef.charType, ExactConversionsSupport.isIntToCharExact(Short.MIN_VALUE));\n+        assertAssignable(fac.Constant((short) (Character.MIN_VALUE - 1)),   predef.charType, ExactConversionsSupport.isIntToCharExact((short) (Character.MIN_VALUE - 1)));\n+        assertAssignable(fac.Constant((short) (Character.MAX_VALUE + 1)),   predef.charType, ExactConversionsSupport.isIntToCharExact((short) (Character.MIN_VALUE + 1)));\n+        assertAssignable(fac.Constant(Short.MAX_VALUE),                     predef.charType, ExactConversionsSupport.isIntToCharExact(Short.MAX_VALUE));\n+\n+        \/\/ char c = <constant int>   vs ExactConversionsSupport::isIntToCharExact\n+        assertAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.charType, ExactConversionsSupport.isIntToCharExact(Integer.MIN_VALUE));\n+        assertAssignable(fac.Constant((int) (Character.MIN_VALUE - 1)),     predef.charType, ExactConversionsSupport.isIntToCharExact((int) (Character.MIN_VALUE - 1)));\n+        assertAssignable(fac.Constant((int) (Character.MAX_VALUE + 1)),     predef.charType, ExactConversionsSupport.isIntToCharExact((int) (Character.MAX_VALUE + 1)));\n+        assertAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.charType, ExactConversionsSupport.isIntToCharExact(Integer.MAX_VALUE));\n+\n+        \/\/ short b = <constant char> vs ExactConversionsSupport::isIntToShortExact\n+        assertAssignable(fac.Constant(Character.MIN_VALUE),                 predef.shortType, ExactConversionsSupport.isIntToShortExact(Character.MIN_VALUE));\n+        assertAssignable(fac.Constant((char) (Character.MAX_VALUE + 1)),    predef.shortType, ExactConversionsSupport.isIntToShortExact((char) (Character.MAX_VALUE + 1)));\n+        assertAssignable(fac.Constant(Character.MAX_VALUE),                 predef.shortType, ExactConversionsSupport.isIntToShortExact(Character.MAX_VALUE));\n+\n+        \/\/ short b = <constant int>  vs ExactConversionsSupport::isIntToShortExact\n+        assertAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.shortType, ExactConversionsSupport.isIntToShortExact(Integer.MIN_VALUE));\n+        assertAssignable(fac.Constant((int) (Short.MIN_VALUE - 1)),         predef.shortType, ExactConversionsSupport.isIntToShortExact((int) (Short.MIN_VALUE - 1)));\n+        assertAssignable(fac.Constant((int) (Short.MAX_VALUE + 1)),         predef.shortType, ExactConversionsSupport.isIntToShortExact((int) (Short.MAX_VALUE + 1)));\n+        assertAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.shortType, ExactConversionsSupport.isIntToShortExact(Integer.MAX_VALUE));\n+    }\n+    void assertOriginalAssignmentNarrowingAndUnconditionality() {\n+        \/\/ byte b = <constant short> vs ExactConversionsSupport::isIntToByteExact\n+        assertOriginalAssignable(fac.Constant(Short.MIN_VALUE),                     predef.byteType, ExactConversionsSupport.isIntToByteExact(Short.MIN_VALUE));\n+        assertOriginalAssignable(fac.Constant((short) (Byte.MIN_VALUE - 1)),        predef.byteType, ExactConversionsSupport.isIntToByteExact((short) (Byte.MIN_VALUE - 1)));\n+        assertOriginalAssignable(fac.Constant((short) (Byte.MAX_VALUE + 1)),        predef.byteType, ExactConversionsSupport.isIntToByteExact((short) (Byte.MAX_VALUE + 1)));\n+        assertOriginalAssignable(fac.Constant(Short.MAX_VALUE),                     predef.byteType, ExactConversionsSupport.isIntToByteExact(Short.MAX_VALUE));\n+\n+        \/\/ byte b = <constant char> vs ExactConversionsSupport::isIntToByteExact\n+        assertOriginalAssignable(fac.Constant(Character.MIN_VALUE),                 predef.byteType, ExactConversionsSupport.isIntToByteExact(Character.MIN_VALUE));\n+        assertOriginalAssignable(fac.Constant((char) (Byte.MAX_VALUE + 1)),         predef.byteType, ExactConversionsSupport.isIntToByteExact((char) (Byte.MAX_VALUE + 1)));\n+        assertOriginalAssignable(fac.Constant(Character.MAX_VALUE),                 predef.byteType, ExactConversionsSupport.isIntToByteExact(Character.MAX_VALUE));\n+\n+        \/\/ byte b = <constant int>  vs ExactConversionsSupport::isIntToByteExact\n+        assertOriginalAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.byteType, ExactConversionsSupport.isIntToByteExact(Integer.MIN_VALUE));\n+        assertOriginalAssignable(fac.Constant((int) (Byte.MIN_VALUE - 1)),          predef.byteType, ExactConversionsSupport.isIntToByteExact((int) (Byte.MIN_VALUE - 1)));\n+        assertOriginalAssignable(fac.Constant((int) (Byte.MAX_VALUE + 1)),          predef.byteType, ExactConversionsSupport.isIntToByteExact((int) (Byte.MAX_VALUE + 1)));\n+        assertOriginalAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.byteType, ExactConversionsSupport.isIntToByteExact(Integer.MAX_VALUE));\n+\n+        \/\/ char c = <constant short> vs ExactConversionsSupport::isIntToCharExact\n+        assertOriginalAssignable(fac.Constant(Short.MIN_VALUE),                     predef.charType, ExactConversionsSupport.isIntToCharExact(Short.MIN_VALUE));\n+        assertOriginalAssignable(fac.Constant((short) (Character.MIN_VALUE - 1)),   predef.charType, ExactConversionsSupport.isIntToCharExact((short) (Character.MIN_VALUE - 1)));\n+        assertOriginalAssignable(fac.Constant((short) (Character.MAX_VALUE + 1)),   predef.charType, ExactConversionsSupport.isIntToCharExact((short) (Character.MIN_VALUE + 1)));\n+        assertOriginalAssignable(fac.Constant(Short.MAX_VALUE),                     predef.charType, ExactConversionsSupport.isIntToCharExact(Short.MAX_VALUE));\n+\n+        \/\/ char c = <constant int>   vs ExactConversionsSupport::isIntToCharExact\n+        assertOriginalAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.charType, ExactConversionsSupport.isIntToCharExact(Integer.MIN_VALUE));\n+        assertOriginalAssignable(fac.Constant((int) (Character.MIN_VALUE - 1)),     predef.charType, ExactConversionsSupport.isIntToCharExact((int) (Character.MIN_VALUE - 1)));\n+        assertOriginalAssignable(fac.Constant((int) (Character.MAX_VALUE + 1)),     predef.charType, ExactConversionsSupport.isIntToCharExact((int) (Character.MAX_VALUE + 1)));\n+        assertOriginalAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.charType, ExactConversionsSupport.isIntToCharExact(Integer.MAX_VALUE));\n+\n+        \/\/ short b = <constant char> vs ExactConversionsSupport::isIntToShortExact\n+        assertOriginalAssignable(fac.Constant(Character.MIN_VALUE),                 predef.shortType, ExactConversionsSupport.isIntToShortExact(Character.MIN_VALUE));\n+        assertOriginalAssignable(fac.Constant((char) (Character.MAX_VALUE + 1)),    predef.shortType, ExactConversionsSupport.isIntToShortExact((char) (Character.MAX_VALUE + 1)));\n+        assertOriginalAssignable(fac.Constant(Character.MAX_VALUE),                 predef.shortType, ExactConversionsSupport.isIntToShortExact(Character.MAX_VALUE));\n+\n+        \/\/ short b = <constant int>  vs ExactConversionsSupport::isIntToShortExact\n+        assertOriginalAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.shortType, ExactConversionsSupport.isIntToShortExact(Integer.MIN_VALUE));\n+        assertOriginalAssignable(fac.Constant((int) (Short.MIN_VALUE - 1)),         predef.shortType, ExactConversionsSupport.isIntToShortExact((int) (Short.MIN_VALUE - 1)));\n+        assertOriginalAssignable(fac.Constant((int) (Short.MAX_VALUE + 1)),         predef.shortType, ExactConversionsSupport.isIntToShortExact((int) (Short.MAX_VALUE + 1)));\n+        assertOriginalAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.shortType, ExactConversionsSupport.isIntToShortExact(Integer.MAX_VALUE));\n+    }\n+    \/\/ where\n+    public void assertOriginalAssignable(Type s, Type t, boolean expected) {\n+        if (originalIsAssignable(s, t) != expected) {\n+            String msg = expected ?\n+                    \" is not assignable to \" :\n+                    \" is assignable to \";\n+            error(s + msg + t);\n+        }\n+    }\n+    public boolean originalIsAssignable(Type t, Type s) {\n+        if (t.hasTag(ERROR))\n+            return true;\n+        if (t.getTag().isSubRangeOf(INT) && t.constValue() != null) {\n+            int value = ((Number)t.constValue()).intValue();\n+            switch (s.getTag()) {\n+                case BYTE:\n+                case CHAR:\n+                case SHORT:\n+                case INT:\n+                    if (originalCheckRange(s.getTag(), value))\n+                        return true;\n+                    break;\n+            }\n+        }\n+        return types.isConvertible(t, s);\n+    }\n+    public boolean originalCheckRange(TypeTag that, int value) {\n+        switch (that) {\n+            case BOOLEAN:\n+                return 0 <= value && value <= 1;\n+            case BYTE:\n+                return Byte.MIN_VALUE <= value && value <= Byte.MAX_VALUE;\n+            case CHAR:\n+                return Character.MIN_VALUE <= value && value <= Character.MAX_VALUE;\n+            case SHORT:\n+                return Short.MIN_VALUE <= value && value <= Short.MAX_VALUE;\n+            case INT:\n+                return true;\n+            default:\n+                throw new AssertionError();\n+        }\n+    }\n+\n+    private void error(String msg) {\n+        throw new AssertionError(\"Unexpected result in original isAssignable: \" + msg);\n+    }\n+\n+    public static void main(String[] args) {\n+        PrimitiveUnconditionallyExactInAssignability harness = new PrimitiveUnconditionallyExactInAssignability();\n+        harness.assertAssignmentNarrowingAndUnconditionality();\n+        harness.assertOriginalAssignmentNarrowingAndUnconditionality();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveUnconditionallyExactInAssignability.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Check the unconditionally exact for constant primitives used in the exhaustiveness check\n+ * @library \/tools\/lib\/types\n+ * @modules jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ * @build TypeHarness\n+ * @compile PrimitiveUnconditionallyExactInExhaustiveSwitches.java\n+ * @run main PrimitiveUnconditionallyExactInExhaustiveSwitches\n+ *\/\n+\n+public class PrimitiveUnconditionallyExactInExhaustiveSwitches extends TypeHarness {\n+\n+    PrimitiveUnconditionallyExactInExhaustiveSwitches() {\n+    }\n+    public void testByte() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))), predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (0))),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.byteType, true);\n+    }\n+    public void testShort() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (0))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.shortType, true);\n+    }\n+    public void testChar() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (0))),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.charType, true);\n+    }\n+    public void testInt() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (0))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.intType, true);\n+    }\n+    public void testLong() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (0))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.longType, true);\n+    }\n+    public void testFloat() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((byte) (0)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.floatType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.floatType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.floatType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.floatType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.floatType, true);\n+    }\n+    public void testDouble() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (0))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.doubleType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.doubleType, true);\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        PrimitiveUnconditionallyExactInExhaustiveSwitches harness = new PrimitiveUnconditionallyExactInExhaustiveSwitches();\n+        harness.testByte();\n+        harness.testShort();\n+        harness.testChar();\n+        harness.testInt();\n+        harness.testDouble();\n+        harness.testLong();\n+        harness.testFloat();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveUnconditionallyExactInExhaustiveSwitches.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile --enable-preview --source ${jdk.version} T8332463a.java\n+ * @compile\/fail\/ref=T8332463a.out -XDrawDiagnostics --enable-preview --source ${jdk.version} T8332463a.java\n@@ -35,1 +35,1 @@\n-            case short s  -> 2;\n+            case short s  -> 2; \/\/ dominated\n@@ -43,1 +43,1 @@\n-            case byte ip    -> 2;\n+            case byte ip    -> 2; \/\/ dominated\n@@ -51,1 +51,1 @@\n-            case (byte) 0   -> 2;\n+            case (byte) 0   -> 2; \/\/ dominated\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8332463a.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,6 @@\n+T8332463a.java:35:18: compiler.err.pattern.dominated\n+T8332463a.java:43:18: compiler.err.pattern.dominated\n+T8332463a.java:51:18: compiler.err.pattern.dominated\n+- compiler.note.preview.filename: T8332463a.java, DEFAULT\n+- compiler.note.preview.recompile\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8332463a.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -29,2 +29,1 @@\n- * @compile T8332463b.java\n- *  @compile --enable-preview --source ${jdk.version} T8332463b.java\n+ * @compile\/fail\/ref=T8332463b.out -XDrawDiagnostics --enable-preview --source ${jdk.version} T8332463b.java\n@@ -37,1 +36,1 @@\n-            case (short) 0 -> 2;\n+            case (short) 0 -> 2;  \/\/ dominated\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8332463b.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+T8332463b.java:36:18: compiler.err.pattern.dominated\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8332463b.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -191,0 +191,15 @@\n+    \/** assert that 's' is unconditionally exact to 't' *\/\n+    public void assertIsUnconditionallyExactConstantPrimitives(Type s, Type t) {\n+        assertIsUnconditionallyExactConstantPrimitives(s, t, true);\n+    }\n+\n+    \/** assert that 's' is\/is not unconditionally exact to 't' *\/\n+    public void assertIsUnconditionallyExactConstantPrimitives(Type s, Type t, boolean expected) {\n+        if (types.isUnconditionallyExactConstantPrimitives(s, t) != expected) {\n+            String msg = expected ?\n+                    \" is not unconditionally exact to \" :\n+                    \" is unconditionally exact to \";\n+            error(s + msg + t);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/lib\/types\/TypeHarness.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}