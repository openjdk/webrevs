{"files":[{"patch":"@@ -780,1 +780,1 @@\n-    \/\/ this method should be in sync with com.sun.tools.javac.code.Types.checkUnconditionallyExactPrimitives\n+    \/\/ this method should be in sync with com.sun.tools.javac.code.Types.isUnconditionallyExactTypeBased\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\n+import java.lang.runtime.ExactConversionsSupport;\n@@ -189,0 +189,4 @@\n+    public boolean isNumeric() {\n+        return this.numericClass != 0;\n+    }\n+\n@@ -250,1 +254,1 @@\n-                return Byte.MIN_VALUE <= value && value <= Byte.MAX_VALUE;\n+                return ExactConversionsSupport.isIntToByteExact(value);\n@@ -252,1 +256,1 @@\n-                return Character.MIN_VALUE <= value && value <= Character.MAX_VALUE;\n+                return ExactConversionsSupport.isIntToCharExact(value);\n@@ -254,1 +258,1 @@\n-                return Short.MIN_VALUE <= value && value <= Short.MAX_VALUE;\n+                return ExactConversionsSupport.isIntToShortExact(value);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeTag.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.runtime.ExactConversionsSupport;\n@@ -5089,2 +5090,3 @@\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditionality\">\n-    \/** Check unconditionality between any combination of reference or primitive types.\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditional Exactness\">\n+    \/** Check type-based unconditional exactness between any combination of\n+     *  reference or primitive types according to JLS 5.7.2.\n@@ -5092,6 +5094,8 @@\n-     *  Rules:\n-     *    an identity conversion\n-     *    a widening reference conversion\n-     *    a widening primitive conversion (delegates to `checkUnconditionallyExactPrimitives`)\n-     *    a boxing conversion\n-     *    a boxing conversion followed by a widening reference conversion\n+     *  The following are unconditionally exact regardless of the input\n+     *  expression:\n+     *\n+     *    - an identity conversion\n+     *    - a widening reference conversion\n+     *    - an exact widening primitive conversion\n+     *    - a boxing conversion\n+     *    - a boxing conversion followed by a widening reference conversion\n@@ -5102,1 +5106,1 @@\n-    public boolean isUnconditionallyExact(Type source, Type target) {\n+    public boolean isUnconditionallyExactTypeBased(Type source, Type target) {\n@@ -5107,3 +5111,12 @@\n-        return target.isPrimitive()\n-                ? isUnconditionallyExactPrimitives(source, target)\n-                : isSubtype(boxedTypeOrType(erasure(source)), target);\n+        if (target.isPrimitive()) {\n+            if (source.isPrimitive() &&\n+                ((source.getTag().isStrictSubRangeOf(target.getTag())) &&\n+                        !((source.hasTag(BYTE) && target.hasTag(CHAR)) ||\n+                          (source.hasTag(INT) && target.hasTag(FLOAT)) ||\n+                          (source.hasTag(LONG) && (target.hasTag(DOUBLE) || target.hasTag(FLOAT)))))) return true;\n+            else {\n+                return false;\n+            }\n+        } else {\n+            return isSubtype(boxedTypeOrType(erasure(source)), target);\n+        }\n@@ -5112,1 +5125,7 @@\n-    \/** Check unconditionality between primitive types.\n+    \/** Check value-based unconditional exactness between any combination of\n+     *  reference or primitive types for the value of a constant expression\n+     *   according to JLS 5.7.2.\n+     *\n+     *  The following can be unconditionally exact if the source primitive is a\n+     *  constant expression and the conversions is exact for that constant\n+     *  expression:\n@@ -5114,4 +5133,72 @@\n-     *  - widening from one integral type to another,\n-     *  - widening from one floating point type to another,\n-     *  - widening from byte, short, or char to a floating point type,\n-     *  - widening from int to double.\n+     *    - a narrowing primitive conversion\n+     *    - a widening and narrowing primitive conversion\n+     *    - a widening primitive conversion that is not exact\n+     *\n+     *  @param source     Source primitive or reference type, should be a numeric value\n+     *  @param target     Target primitive or reference type\n+     *\/\n+    public boolean isUnconditionallyExactValueBased(Type source, Type target) {\n+        if (!(source.constValue() instanceof Number value) || !target.getTag().isNumeric()) return false;\n+\n+        switch (source.getTag()) {\n+            case BYTE:\n+                switch (target.getTag()) {\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                }\n+                break;\n+            case CHAR:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+                }\n+                break;\n+            case SHORT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                }\n+                break;\n+            case INT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isIntToByteExact(value.intValue());\n+                    case CHAR:      return ExactConversionsSupport.isIntToCharExact(value.intValue());\n+                    case SHORT:     return ExactConversionsSupport.isIntToShortExact(value.intValue());\n+                    case FLOAT:     return ExactConversionsSupport.isIntToFloatExact(value.intValue());\n+                }\n+                break;\n+            case FLOAT:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isFloatToByteExact(value.floatValue());\n+                    case CHAR:      return ExactConversionsSupport.isFloatToCharExact(value.floatValue());\n+                    case SHORT:     return ExactConversionsSupport.isFloatToShortExact(value.floatValue());\n+                    case INT:       return ExactConversionsSupport.isFloatToIntExact(value.floatValue());\n+                    case LONG:      return ExactConversionsSupport.isFloatToLongExact(value.floatValue());\n+                }\n+                break;\n+            case LONG:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isLongToByteExact(value.longValue());\n+                    case CHAR:      return ExactConversionsSupport.isLongToCharExact(value.longValue());\n+                    case SHORT:     return ExactConversionsSupport.isLongToShortExact(value.longValue());\n+                    case INT:       return ExactConversionsSupport.isLongToIntExact(value.longValue());\n+                    case FLOAT:     return ExactConversionsSupport.isLongToFloatExact(value.longValue());\n+                    case DOUBLE:    return ExactConversionsSupport.isLongToDoubleExact(value.longValue());\n+                }\n+                break;\n+            case DOUBLE:\n+                switch (target.getTag()) {\n+                    case BYTE:      return ExactConversionsSupport.isDoubleToByteExact(value.doubleValue());\n+                    case CHAR:      return ExactConversionsSupport.isDoubleToCharExact(value.doubleValue());\n+                    case SHORT:     return ExactConversionsSupport.isDoubleToShortExact(value.doubleValue());\n+                    case INT:       return ExactConversionsSupport.isDoubleToIntExact(value.doubleValue());\n+                    case FLOAT:     return ExactConversionsSupport.isDoubleToFloatExact(value.doubleValue());\n+                    case LONG:      return ExactConversionsSupport.isDoubleToLongExact(value.doubleValue());\n+                }\n+                break;\n+        }\n+        return true;\n+    }\n+\n+    \/** Check both type or value-based unconditional exactness between any\n+     *  combination of reference or primitive types for the value of a constant\n+     *  expression according to JLS 5.7.2.\n@@ -5119,2 +5206,2 @@\n-     *  @param selectorType     Type of selector\n-     *  @param targetType       Target type\n+     *  @param source     Source primitive or reference type, should be a numeric value\n+     *  @param target     Target primitive or reference type\n@@ -5122,7 +5209,3 @@\n-    public boolean isUnconditionallyExactPrimitives(Type selectorType, Type targetType) {\n-        return isSameType(selectorType, targetType) ||\n-                (selectorType.isPrimitive() && targetType.isPrimitive()) &&\n-                ((selectorType.getTag().isStrictSubRangeOf(targetType.getTag())) &&\n-                        !((selectorType.hasTag(BYTE) && targetType.hasTag(CHAR)) ||\n-                          (selectorType.hasTag(INT)  && targetType.hasTag(FLOAT)) ||\n-                          (selectorType.hasTag(LONG) && (targetType.hasTag(DOUBLE) || targetType.hasTag(FLOAT)))));\n+    public boolean isUnconditionallyExactCombined(Type currentType, Type testType) {\n+        return isUnconditionallyExactTypeBased(currentType, testType) ||\n+                (currentType.constValue() instanceof Number && isUnconditionallyExactValueBased(currentType, testType));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":109,"deletions":26,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -1864,1 +1864,1 @@\n-                                types.isUnconditionallyExact(seltype, patternType);\n+                                types.isUnconditionallyExactTypeBased(seltype, patternType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.Function;\n@@ -170,0 +169,1 @@\n+        allowPrimitivePatterns = preview.isEnabled() && Feature.PRIMITIVE_PATTERNS.allowedInSource(source);\n@@ -193,0 +193,4 @@\n+    \/** Are primitive patterns allowed\n+     *\/\n+    private final boolean allowPrimitivePatterns;\n+\n@@ -4767,0 +4771,7 @@\n+\n+                    \/\/ an unconditional pattern cannot be followed by any other label\n+                    if (allowPrimitivePatterns && unconditionalCaseLabel == testCaseLabel && unconditionalCaseLabel != label) {\n+                        log.error(label.pos(), Errors.PatternDominated);\n+                        continue;\n+                    }\n+\n@@ -4768,5 +4779,5 @@\n-                    if (types.isUnconditionallyExact(currentType, testType) &&\n-                        !currentType.hasTag(ERROR) && !testType.hasTag(ERROR)) {\n-                        \/\/the current label is potentially dominated by the existing (test) label, check:\n-                        if (label instanceof JCConstantCaseLabel) {\n-                            dominated |= !(testCaseLabel instanceof JCConstantCaseLabel) &&\n+                    if (!currentType.hasTag(ERROR) && !testType.hasTag(ERROR)) {\n+                        \/\/ the current label is potentially dominated by the existing (test) label, check:\n+                        if (types.isUnconditionallyExactCombined(currentType, testType) &&\n+                                label instanceof JCConstantCaseLabel) {\n+                            dominated = !(testCaseLabel instanceof JCConstantCaseLabel) &&\n@@ -4777,2 +4788,1 @@\n-                            dominated = patternDominated(testPatternCaseLabel.pat,\n-                                                         patternCL.pat);\n+                            dominated = patternDominated(testPatternCaseLabel.pat, patternCL.pat);\n@@ -4781,1 +4791,0 @@\n-\n@@ -4801,1 +4810,1 @@\n-            if (!types.isUnconditionallyExact(currentPatternType, existingPatternType)) {\n+            if (!types.isUnconditionallyExactTypeBased(currentPatternType, existingPatternType)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -571,2 +571,2 @@\n-                    types.isUnconditionallyExact(seltype, pattype) :\n-                    (bp.type.isPrimitive() && types.isUnconditionallyExact(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n+                    types.isUnconditionallyExactTypeBased(seltype, pattype) :\n+                    (bp.type.isPrimitive() && types.isUnconditionallyExactTypeBased(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ExhaustivenessComputer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Notes;\n@@ -2838,1 +2837,1 @@\n-            if (types.isUnconditionallyExact(tree.expr.type, tree.pattern.type)) {\n+            if (types.isUnconditionallyExactTypeBased(tree.expr.type, tree.pattern.type)) {\n@@ -2847,1 +2846,1 @@\n-                if (types.isUnconditionallyExact(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n+                if (types.isUnconditionallyExactTypeBased(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -924,1 +924,1 @@\n-                                types.isUnconditionallyExact(commonNestedExpression.type, types.erasure(binding.type))) &&\n+                                types.isUnconditionallyExactTypeBased(commonNestedExpression.type, types.erasure(binding.type))) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @compile\/fail\/ref=DominationWithPP.out --enable-preview --source ${jdk.version} -XDrawDiagnostics Domination.java\n@@ -30,1 +31,0 @@\n-\n@@ -221,0 +221,10 @@\n+\n+    int testCasePatternDominatedbyPreceedingUnconditionalCasePattern () {\n+        interface A {}\n+        interface B {}\n+        A aa = new A() {};\n+        switch (aa) {\n+            case A a : return 1;\n+            case B b : return -1;\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/Domination.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -13,1 +13,2 @@\n-12 errors\n+Domination.java:228:18: compiler.err.pattern.dominated\n+13 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/DominationWithPP.out","additions":2,"deletions":1,"binary":false,"changes":3,"previous_filename":"test\/langtools\/tools\/javac\/patterns\/Domination.out","status":"copied"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @summary Retain exhaustiveness properties of switches with a constant selector\n+ * @enablePreview\n+ * @compile\/fail\/ref=PrimitivePatternsSwitchConstants.out -XDrawDiagnostics -XDshould-stop.at=FLOW PrimitivePatternsSwitchConstants.java\n+ *\/\n+public class PrimitivePatternsSwitchConstants {\n+    void testConstExpressions() {\n+        switch (42) {         \/\/ error: not exhaustive\n+            case byte _ :\n+        }\n+\n+        switch (42l) {        \/\/ error: not exhaustive\n+            case byte _ :\n+        }\n+\n+        switch (123456) {     \/\/ error: not exhaustive\n+            case byte _ :\n+        }\n+\n+        switch (16_777_216) { \/\/ error: not exhaustive\n+            case float _ :\n+        }\n+\n+        switch (16_777_217) { \/\/ error: not exhaustive\n+            case float _ :\n+        }\n+\n+        switch (42d) {        \/\/ error: not exhaustive\n+            case float _ :\n+        }\n+\n+        switch (1) {          \/\/ OK\n+            case long _ :\n+        }\n+\n+        final int i = 42;\n+        switch (i) {          \/\/ OK\n+            case long _ :\n+        }\n+\n+        switch (1) {          \/\/ error: non-exhaustive\n+            case Long _ :         \/\/ error: widening primitive conversion and boxing is not supported\n+        }\n+\n+        switch (42) {\n+            case byte bb  -> {}\n+            case int ii   -> {}   \/\/ OK\n+        };\n+\n+        switch (42) {\n+            case 42 -> {}\n+            case int ii -> {}     \/\/ OK\n+        };\n+\n+        switch (42) {\n+            case (byte) 42 -> {}\n+            case int ii -> {}     \/\/ OK\n+        };\n+\n+        switch (42) {\n+            case 42 -> {}\n+            default -> {}         \/\/ OK\n+        };\n+\n+        switch (42) {\n+            default -> {}         \/\/ OK\n+            case 42 -> {}\n+        };\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchConstants.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+PrimitivePatternsSwitchConstants.java:43:18: compiler.err.prob.found.req: (compiler.misc.inconvertible.types: int, java.lang.Long)\n+PrimitivePatternsSwitchConstants.java:9:9: compiler.err.not.exhaustive.statement\n+PrimitivePatternsSwitchConstants.java:13:9: compiler.err.not.exhaustive.statement\n+PrimitivePatternsSwitchConstants.java:17:9: compiler.err.not.exhaustive.statement\n+PrimitivePatternsSwitchConstants.java:21:9: compiler.err.not.exhaustive.statement\n+PrimitivePatternsSwitchConstants.java:25:9: compiler.err.not.exhaustive.statement\n+PrimitivePatternsSwitchConstants.java:29:9: compiler.err.not.exhaustive.statement\n+PrimitivePatternsSwitchConstants.java:42:9: compiler.err.not.exhaustive.statement\n+- compiler.note.preview.filename: PrimitivePatternsSwitchConstants.java, DEFAULT\n+- compiler.note.preview.recompile\n+8 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchConstants.out","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -62,1 +62,1 @@\n-            case byte ip     -> ip; \/\/ OK - not dominated!\n+            case byte ip     -> ip; \/\/ Error - dominated!\n@@ -268,0 +268,65 @@\n+\n+    public static void dominanceIntFloat() {\n+        int ii = 42;\n+        switch (ii) {\n+            case int i -> {}\n+            case float f -> {} \/\/ Error - dominated!\n+        }\n+    }\n+\n+    public static void noDominanceIntFloat() {\n+        int ii = 42;\n+        switch (ii) {\n+            case float f -> {}\n+            case int i -> {} \/\/ ok\n+        }\n+    }\n+\n+    public static void strengtheningDominance() {\n+        byte x = 42;\n+        switch (x) {\n+            case short s -> {}\n+            case 42      -> {}    \/\/ error: dominated\n+        }\n+\n+        long l = 42l;\n+        switch (l) {\n+            case short s -> {}\n+            case 42l     -> {}    \/\/ error: dominated\n+            case long _  -> {}\n+        }\n+\n+        char c = 'a';\n+        switch (c) {\n+            case short s -> {}\n+            case 42      -> {}    \/\/ error: dominated\n+            case char _  -> {}\n+        }\n+\n+        int x2 = 42;\n+        switch(x2) {\n+            case float f -> {}\n+            case 16_777_216 -> {}  \/\/ error: dominated\n+            default -> {}\n+        }\n+\n+        switch(x2) {\n+            case float f -> {}\n+            case 16_777_217 -> {} \/\/ OK\n+            default -> {}\n+        }\n+\n+        switch(x2) {\n+            case int ii   -> {}\n+            case float f -> {}    \/\/ error: dominated\n+        }\n+    }\n+\n+    public static void unconditionalFollowedByDefault() {\n+        int ii = 42;\n+        switch (ii) {\n+            case int i -> {}\n+            case float f -> {} \/\/ Error - dominated!\n+            default -> {}      \/\/ Error - unconditional and default\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.java","additions":66,"deletions":1,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+PrimitivePatternsSwitchErrors.java:62:18: compiler.err.pattern.dominated\n@@ -32,0 +33,8 @@\n+PrimitivePatternsSwitchErrors.java:273:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:289:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:295:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:302:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:309:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:321:18: compiler.err.pattern.dominated\n+PrimitivePatternsSwitchErrors.java:330:13: compiler.err.unconditional.pattern.and.default\n+PrimitivePatternsSwitchErrors.java:329:18: compiler.err.pattern.dominated\n@@ -46,1 +55,1 @@\n-43 errors\n\\ No newline at end of file\n+52 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitivePatternsSwitchErrors.out","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Check assignability of narrowing p.c. with constant expressions vs exact conversion methods\n+ * @library \/tools\/lib\/types\n+ * @modules jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ * @build TypeHarness\n+ * @compile PrimitiveUnconditionallyExactInAssignability.java\n+ * @run main PrimitiveUnconditionallyExactInAssignability\n+ *\/\n+\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.TypeTag;\n+\n+import java.lang.runtime.ExactConversionsSupport;\n+\n+import static com.sun.tools.javac.code.TypeTag.ERROR;\n+import static com.sun.tools.javac.code.TypeTag.INT;\n+\n+public class PrimitiveUnconditionallyExactInAssignability extends TypeHarness {\n+    PrimitiveUnconditionallyExactInAssignability() {\n+    }\n+\n+    void assertOriginalAssignmentNarrowingAndUnconditionality() {\n+        \/\/ byte b = <constant short> vs ExactConversionsSupport::isIntToByteExact\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Short.MIN_VALUE),                     predef.byteType, ExactConversionsSupport.isIntToByteExact(Short.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((short) (Byte.MIN_VALUE - 1)),        predef.byteType, ExactConversionsSupport.isIntToByteExact((short) (Byte.MIN_VALUE - 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((short) (Byte.MAX_VALUE + 1)),        predef.byteType, ExactConversionsSupport.isIntToByteExact((short) (Byte.MAX_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Short.MAX_VALUE),                     predef.byteType, ExactConversionsSupport.isIntToByteExact(Short.MAX_VALUE));\n+\n+        \/\/ byte b = <constant char> vs ExactConversionsSupport::isIntToByteExact\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Character.MIN_VALUE),                 predef.byteType, ExactConversionsSupport.isIntToByteExact(Character.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((char) (Byte.MAX_VALUE + 1)),         predef.byteType, ExactConversionsSupport.isIntToByteExact((char) (Byte.MAX_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Character.MAX_VALUE),                 predef.byteType, ExactConversionsSupport.isIntToByteExact(Character.MAX_VALUE));\n+\n+        \/\/ byte b = <constant int>  vs ExactConversionsSupport::isIntToByteExact\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.byteType, ExactConversionsSupport.isIntToByteExact(Integer.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((int) (Byte.MIN_VALUE - 1)),          predef.byteType, ExactConversionsSupport.isIntToByteExact((int) (Byte.MIN_VALUE - 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((int) (Byte.MAX_VALUE + 1)),          predef.byteType, ExactConversionsSupport.isIntToByteExact((int) (Byte.MAX_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.byteType, ExactConversionsSupport.isIntToByteExact(Integer.MAX_VALUE));\n+\n+        \/\/ char c = <constant short> vs ExactConversionsSupport::isIntToCharExact\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Short.MIN_VALUE),                     predef.charType, ExactConversionsSupport.isIntToCharExact(Short.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((short) (Character.MIN_VALUE - 1)),   predef.charType, ExactConversionsSupport.isIntToCharExact((short) (Character.MIN_VALUE - 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((short) (Character.MAX_VALUE + 1)),   predef.charType, ExactConversionsSupport.isIntToCharExact((short) (Character.MIN_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Short.MAX_VALUE),                     predef.charType, ExactConversionsSupport.isIntToCharExact(Short.MAX_VALUE));\n+\n+        \/\/ char c = <constant int>   vs ExactConversionsSupport::isIntToCharExact\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.charType, ExactConversionsSupport.isIntToCharExact(Integer.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((int) (Character.MIN_VALUE - 1)),     predef.charType, ExactConversionsSupport.isIntToCharExact((int) (Character.MIN_VALUE - 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((int) (Character.MAX_VALUE + 1)),     predef.charType, ExactConversionsSupport.isIntToCharExact((int) (Character.MAX_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.charType, ExactConversionsSupport.isIntToCharExact(Integer.MAX_VALUE));\n+\n+        \/\/ short b = <constant char> vs ExactConversionsSupport::isIntToShortExact\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Character.MIN_VALUE),                 predef.shortType, ExactConversionsSupport.isIntToShortExact(Character.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((char) (Character.MAX_VALUE + 1)),    predef.shortType, ExactConversionsSupport.isIntToShortExact((char) (Character.MAX_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Character.MAX_VALUE),                 predef.shortType, ExactConversionsSupport.isIntToShortExact(Character.MAX_VALUE));\n+\n+        \/\/ short b = <constant int>  vs ExactConversionsSupport::isIntToShortExact\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.shortType, ExactConversionsSupport.isIntToShortExact(Integer.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((int) (Short.MIN_VALUE - 1)),         predef.shortType, ExactConversionsSupport.isIntToShortExact((int) (Short.MIN_VALUE - 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((int) (Short.MAX_VALUE + 1)),         predef.shortType, ExactConversionsSupport.isIntToShortExact((int) (Short.MAX_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.shortType, ExactConversionsSupport.isIntToShortExact(Integer.MAX_VALUE));\n+    }\n+    \/\/ where\n+    public void assertOriginaAndUpdatedAssignable(Type s, Type t, boolean expected) {\n+        assertAssignable(s, t, originalIsAssignable(s, t));\n+    }\n+    public boolean originalIsAssignable(Type t, Type s) {\n+        if (t.hasTag(ERROR))\n+            return true;\n+        if (t.getTag().isSubRangeOf(INT) && t.constValue() != null) {\n+            int value = ((Number)t.constValue()).intValue();\n+            switch (s.getTag()) {\n+                case BYTE:\n+                case CHAR:\n+                case SHORT:\n+                case INT:\n+                    if (originalCheckRange(s.getTag(), value))\n+                        return true;\n+                    break;\n+            }\n+        }\n+        return types.isConvertible(t, s);\n+    }\n+    public boolean originalCheckRange(TypeTag that, int value) {\n+        switch (that) {\n+            case BOOLEAN:\n+                return 0 <= value && value <= 1;\n+            case BYTE:\n+                return Byte.MIN_VALUE <= value && value <= Byte.MAX_VALUE;\n+            case CHAR:\n+                return Character.MIN_VALUE <= value && value <= Character.MAX_VALUE;\n+            case SHORT:\n+                return Short.MIN_VALUE <= value && value <= Short.MAX_VALUE;\n+            case INT:\n+                return true;\n+            default:\n+                throw new AssertionError();\n+        }\n+    }\n+\n+    private void error(String msg) {\n+        throw new AssertionError(\"Unexpected result in original isAssignable: \" + msg);\n+    }\n+\n+    public static void main(String[] args) {\n+        PrimitiveUnconditionallyExactInAssignability harness = new PrimitiveUnconditionallyExactInAssignability();\n+        harness.assertOriginalAssignmentNarrowingAndUnconditionality();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveUnconditionallyExactInAssignability.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Check the unconditionally exact for constant primitives used in the exhaustiveness check\n+ * @library \/tools\/lib\/types\n+ * @modules jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ * @build TypeHarness\n+ * @compile PrimitiveUnconditionallyExactInExhaustiveSwitches.java\n+ * @run main PrimitiveUnconditionallyExactInExhaustiveSwitches\n+ *\/\n+\n+public class PrimitiveUnconditionallyExactInExhaustiveSwitches extends TypeHarness {\n+\n+    PrimitiveUnconditionallyExactInExhaustiveSwitches() {\n+    }\n+    public void testByte() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))), predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (0))),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.byteType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.byteType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.byteType, true);\n+    }\n+    public void testShort() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (0))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.shortType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.shortType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.shortType, true);\n+    }\n+    public void testChar() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (0))),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.charType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.charType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.charType, true);\n+    }\n+    public void testInt() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (0))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.intType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.intType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.intType, true);\n+    }\n+    public void testLong() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (0))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.longType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.longType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.longType, true);\n+    }\n+    public void testFloat() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((byte) (0)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.floatType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.floatType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.floatType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.floatType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.floatType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.floatType, true);\n+    }\n+    public void testDouble() {\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MAX_VALUE))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (0))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((byte) (Byte.MIN_VALUE))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MAX_VALUE))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (0))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((short) (Short.MIN_VALUE))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MAX_VALUE))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((char) (Character.MIN_VALUE))),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MAX_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Integer.MIN_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MAX_VALUE)),predef.doubleType, false);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((0L)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Long.MIN_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MAX_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((float) 0)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.MIN_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NaN)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.POSITIVE_INFINITY)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Float.NEGATIVE_INFINITY)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0f)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0f)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MAX_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant(((double) 0)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.MIN_VALUE)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NaN)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.POSITIVE_INFINITY)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((Double.NEGATIVE_INFINITY)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((-0.0d)),predef.doubleType, true);\n+        assertIsUnconditionallyExactConstantPrimitives(fac.Constant((+0.0d)),predef.doubleType, true);\n+    }\n+\n+\n+    public static void main(String[] args) {\n+        PrimitiveUnconditionallyExactInExhaustiveSwitches harness = new PrimitiveUnconditionallyExactInExhaustiveSwitches();\n+        harness.testByte();\n+        harness.testShort();\n+        harness.testChar();\n+        harness.testInt();\n+        harness.testDouble();\n+        harness.testLong();\n+        harness.testFloat();\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveUnconditionallyExactInExhaustiveSwitches.java","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @compile --enable-preview --source ${jdk.version} T8332463a.java\n+ * @compile\/fail\/ref=T8332463a.out -XDrawDiagnostics --enable-preview --source ${jdk.version} T8332463a.java\n@@ -35,1 +35,1 @@\n-            case short s  -> 2;\n+            case short s  -> 2; \/\/ dominated\n@@ -43,1 +43,1 @@\n-            case byte ip    -> 2;\n+            case byte ip    -> 2; \/\/ dominated\n@@ -51,1 +51,1 @@\n-            case (byte) 0   -> 2;\n+            case (byte) 0   -> 2; \/\/ dominated\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8332463a.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,6 @@\n+T8332463a.java:35:18: compiler.err.pattern.dominated\n+T8332463a.java:43:18: compiler.err.pattern.dominated\n+T8332463a.java:51:18: compiler.err.pattern.dominated\n+- compiler.note.preview.filename: T8332463a.java, DEFAULT\n+- compiler.note.preview.recompile\n+3 errors\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8332463a.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -29,2 +29,1 @@\n- * @compile T8332463b.java\n- *  @compile --enable-preview --source ${jdk.version} T8332463b.java\n+ * @compile\/fail\/ref=T8332463b.out -XDrawDiagnostics --enable-preview --source ${jdk.version} T8332463b.java\n@@ -37,1 +36,1 @@\n-            case (short) 0 -> 2;\n+            case (short) 0 -> 2;  \/\/ dominated\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8332463b.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+T8332463b.java:36:18: compiler.err.pattern.dominated\n+1 error\n","filename":"test\/langtools\/tools\/javac\/patterns\/T8332463b.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -76,1 +76,3 @@\n-            types::isUnconditionallyExact,\n+            types::isUnconditionallyExactValueBased,\n+            types::isUnconditionallyExactTypeBased,\n+            types::isUnconditionallyExactCombined,\n","filename":"test\/langtools\/tools\/javac\/types\/UnknownTypeTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -191,0 +191,15 @@\n+    \/** assert that 's' is unconditionally exact to 't' *\/\n+    public void assertIsUnconditionallyExactConstantPrimitives(Type s, Type t) {\n+        assertIsUnconditionallyExactConstantPrimitives(s, t, true);\n+    }\n+\n+    \/** assert that 's' is\/is not unconditionally exact to 't' *\/\n+    public void assertIsUnconditionallyExactConstantPrimitives(Type s, Type t, boolean expected) {\n+        if (types.isUnconditionallyExactValueBased(s, t) != expected) {\n+            String msg = expected ?\n+                    \" is not unconditionally exact to \" :\n+                    \" is unconditionally exact to \";\n+            error(s + msg + t);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/lib\/types\/TypeHarness.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}