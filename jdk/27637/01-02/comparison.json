{"files":[{"patch":"@@ -5057,3 +5057,3 @@\n-    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditionality\">\n-    \/** Check unconditionality between any combination of reference or primitive\n-     *  types.\n+    \/\/ <editor-fold defaultstate=\"collapsed\" desc=\"Unconditional Exactness\">\n+    \/** Check type-based unconditional exactness between any combination of\n+     *  reference or primitive types according to JLS 5.7.2.\n@@ -5070,8 +5070,0 @@\n-     *  Additionally, the following can be unconditionally exact if the source\n-     *  primitive is a constant expression and the conversions is exact for that\n-     *  constant expression:\n-     *\n-     *    - a narrowing primitive conversion\n-     *    - a widening and narrowing primitive conversion\n-     *    - a widening primitive conversion that is not exact\n-     *\n@@ -5081,1 +5073,1 @@\n-    public boolean isUnconditionallyExact(Type source, Type target) {\n+    public boolean isUnconditionallyExactTypeBased(Type source, Type target) {\n@@ -5099,2 +5091,17 @@\n-    \/\/ where\n-    public boolean isUnconditionallyExactConstantPrimitives(Type source, Type target) {\n+\n+    \/** Check value-based unconditional exactness between any combination of\n+     *  reference or primitive types for the value of a constant expression\n+     *   according to JLS 5.7.2.\n+     *\n+     *  The following can be unconditionally exact if the source primitive is a\n+     *  constant expression and the conversions is exact for that constant\n+     *  expression:\n+     *\n+     *    - a narrowing primitive conversion\n+     *    - a widening and narrowing primitive conversion\n+     *    - a widening primitive conversion that is not exact\n+     *\n+     *  @param source     Source primitive or reference type, should be a numeric value\n+     *  @param target     Target primitive or reference type\n+     *\/\n+    public boolean isUnconditionallyExactValueBased(Type source, Type target) {\n@@ -5161,0 +5168,12 @@\n+\n+    \/** Check both type or value-based unconditional exactness between any\n+     *  combination of reference or primitive types for the value of a constant\n+     *  expression according to JLS 5.7.2.\n+     *\n+     *  @param source     Source primitive or reference type, should be a numeric value\n+     *  @param target     Target primitive or reference type\n+     *\/\n+    public boolean isUnconditionallyExactCombined(Type currentType, Type testType) {\n+        return isUnconditionallyExactTypeBased(currentType, testType) ||\n+                (currentType.constValue() instanceof Number && isUnconditionallyExactValueBased(currentType, testType));\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":33,"deletions":14,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1862,1 +1862,1 @@\n-                                types.isUnconditionallyExact(seltype, patternType);\n+                                types.isUnconditionallyExactTypeBased(seltype, patternType);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.function.Function;\n@@ -4743,2 +4742,3 @@\n-                    if (unconditionalCaseLabel == testCaseLabel) unconditionalFound = true;\n-                    boolean dominatedCandidate = false;\n+                    if (unconditionalCaseLabel == testCaseLabel) {\n+                        unconditionalFound = true;\n+                    }\n@@ -4746,5 +4746,0 @@\n-                        if (types.isUnconditionallyExact(currentType, testType)) {\n-                            dominatedCandidate = true;\n-                        } else if (currentType.constValue() instanceof Number) {\n-                            dominatedCandidate = types.isUnconditionallyExactConstantPrimitives(currentType, testType);\n-                        }\n@@ -4752,4 +4747,4 @@\n-                        if (label instanceof JCConstantCaseLabel) {\n-                            dominated = dominatedCandidate &&\n-                                         !(testCaseLabel instanceof JCConstantCaseLabel) &&\n-                                         TreeInfo.unguardedCase(testCase);\n+                        if (label instanceof JCConstantCaseLabel &&\n+                                types.isUnconditionallyExactCombined(currentType, testType)) {\n+                            dominated = !(testCaseLabel instanceof JCConstantCaseLabel) &&\n+                                    TreeInfo.unguardedCase(testCase);\n@@ -4759,2 +4754,1 @@\n-                            dominated = dominatedCandidate &&\n-                                        patternDominated(testPatternCaseLabel.pat, patternCL.pat);\n+                            dominated = patternDominated(testPatternCaseLabel.pat, patternCL.pat);\n@@ -4785,1 +4779,1 @@\n-            if (!types.isUnconditionallyExact(currentPatternType, existingPatternType)) {\n+            if (!types.isUnconditionallyExactTypeBased(currentPatternType, existingPatternType)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -514,2 +514,2 @@\n-                    types.isUnconditionallyExact(seltype, pattype) :\n-                    (bp.type.isPrimitive() && types.isUnconditionallyExact(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n+                    types.isUnconditionallyExactTypeBased(seltype, pattype) :\n+                    (bp.type.isPrimitive() && types.isUnconditionallyExactTypeBased(types.unboxedType(seltype), bp.type)) || types.isSubtype(seltype, pattype);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ExhaustivenessComputer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import com.sun.tools.javac.resources.CompilerProperties.Notes;\n@@ -2838,1 +2837,1 @@\n-            if (types.isUnconditionallyExact(tree.expr.type, tree.pattern.type)) {\n+            if (types.isUnconditionallyExactTypeBased(tree.expr.type, tree.pattern.type)) {\n@@ -2847,1 +2846,1 @@\n-                if (types.isUnconditionallyExact(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n+                if (types.isUnconditionallyExactTypeBased(types.unboxedType(tree.expr.type), tree.pattern.type)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -924,1 +924,1 @@\n-                                types.isUnconditionallyExact(commonNestedExpression.type, types.erasure(binding.type))) &&\n+                                types.isUnconditionallyExactTypeBased(commonNestedExpression.type, types.erasure(binding.type))) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,41 +51,0 @@\n-    void assertAssignmentNarrowingAndUnconditionality() {\n-        \/\/ byte b = <constant short> vs ExactConversionsSupport::isIntToByteExact\n-        assertAssignable(fac.Constant(Short.MIN_VALUE),                     predef.byteType, ExactConversionsSupport.isIntToByteExact(Short.MIN_VALUE));\n-        assertAssignable(fac.Constant((short) (Byte.MIN_VALUE - 1)),        predef.byteType, ExactConversionsSupport.isIntToByteExact((short) (Byte.MIN_VALUE - 1)));\n-        assertAssignable(fac.Constant((short) (Byte.MAX_VALUE + 1)),        predef.byteType, ExactConversionsSupport.isIntToByteExact((short) (Byte.MAX_VALUE + 1)));\n-        assertAssignable(fac.Constant(Short.MAX_VALUE),                     predef.byteType, ExactConversionsSupport.isIntToByteExact(Short.MAX_VALUE));\n-\n-        \/\/ byte b = <constant char> vs ExactConversionsSupport::isIntToByteExact\n-        assertAssignable(fac.Constant(Character.MIN_VALUE),                 predef.byteType, ExactConversionsSupport.isIntToByteExact(Character.MIN_VALUE));\n-        assertAssignable(fac.Constant((char) (Byte.MAX_VALUE + 1)),         predef.byteType, ExactConversionsSupport.isIntToByteExact((char) (Byte.MAX_VALUE + 1)));\n-        assertAssignable(fac.Constant(Character.MAX_VALUE),                 predef.byteType, ExactConversionsSupport.isIntToByteExact(Character.MAX_VALUE));\n-\n-        \/\/ byte b = <constant int>  vs ExactConversionsSupport::isIntToByteExact\n-        assertAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.byteType, ExactConversionsSupport.isIntToByteExact(Integer.MIN_VALUE));\n-        assertAssignable(fac.Constant((int) (Byte.MIN_VALUE - 1)),          predef.byteType, ExactConversionsSupport.isIntToByteExact((int) (Byte.MIN_VALUE - 1)));\n-        assertAssignable(fac.Constant((int) (Byte.MAX_VALUE + 1)),          predef.byteType, ExactConversionsSupport.isIntToByteExact((int) (Byte.MAX_VALUE + 1)));\n-        assertAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.byteType, ExactConversionsSupport.isIntToByteExact(Integer.MAX_VALUE));\n-\n-        \/\/ char c = <constant short> vs ExactConversionsSupport::isIntToCharExact\n-        assertAssignable(fac.Constant(Short.MIN_VALUE),                     predef.charType, ExactConversionsSupport.isIntToCharExact(Short.MIN_VALUE));\n-        assertAssignable(fac.Constant((short) (Character.MIN_VALUE - 1)),   predef.charType, ExactConversionsSupport.isIntToCharExact((short) (Character.MIN_VALUE - 1)));\n-        assertAssignable(fac.Constant((short) (Character.MAX_VALUE + 1)),   predef.charType, ExactConversionsSupport.isIntToCharExact((short) (Character.MIN_VALUE + 1)));\n-        assertAssignable(fac.Constant(Short.MAX_VALUE),                     predef.charType, ExactConversionsSupport.isIntToCharExact(Short.MAX_VALUE));\n-\n-        \/\/ char c = <constant int>   vs ExactConversionsSupport::isIntToCharExact\n-        assertAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.charType, ExactConversionsSupport.isIntToCharExact(Integer.MIN_VALUE));\n-        assertAssignable(fac.Constant((int) (Character.MIN_VALUE - 1)),     predef.charType, ExactConversionsSupport.isIntToCharExact((int) (Character.MIN_VALUE - 1)));\n-        assertAssignable(fac.Constant((int) (Character.MAX_VALUE + 1)),     predef.charType, ExactConversionsSupport.isIntToCharExact((int) (Character.MAX_VALUE + 1)));\n-        assertAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.charType, ExactConversionsSupport.isIntToCharExact(Integer.MAX_VALUE));\n-\n-        \/\/ short b = <constant char> vs ExactConversionsSupport::isIntToShortExact\n-        assertAssignable(fac.Constant(Character.MIN_VALUE),                 predef.shortType, ExactConversionsSupport.isIntToShortExact(Character.MIN_VALUE));\n-        assertAssignable(fac.Constant((char) (Character.MAX_VALUE + 1)),    predef.shortType, ExactConversionsSupport.isIntToShortExact((char) (Character.MAX_VALUE + 1)));\n-        assertAssignable(fac.Constant(Character.MAX_VALUE),                 predef.shortType, ExactConversionsSupport.isIntToShortExact(Character.MAX_VALUE));\n-\n-        \/\/ short b = <constant int>  vs ExactConversionsSupport::isIntToShortExact\n-        assertAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.shortType, ExactConversionsSupport.isIntToShortExact(Integer.MIN_VALUE));\n-        assertAssignable(fac.Constant((int) (Short.MIN_VALUE - 1)),         predef.shortType, ExactConversionsSupport.isIntToShortExact((int) (Short.MIN_VALUE - 1)));\n-        assertAssignable(fac.Constant((int) (Short.MAX_VALUE + 1)),         predef.shortType, ExactConversionsSupport.isIntToShortExact((int) (Short.MAX_VALUE + 1)));\n-        assertAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.shortType, ExactConversionsSupport.isIntToShortExact(Integer.MAX_VALUE));\n-    }\n@@ -94,4 +53,4 @@\n-        assertOriginalAssignable(fac.Constant(Short.MIN_VALUE),                     predef.byteType, ExactConversionsSupport.isIntToByteExact(Short.MIN_VALUE));\n-        assertOriginalAssignable(fac.Constant((short) (Byte.MIN_VALUE - 1)),        predef.byteType, ExactConversionsSupport.isIntToByteExact((short) (Byte.MIN_VALUE - 1)));\n-        assertOriginalAssignable(fac.Constant((short) (Byte.MAX_VALUE + 1)),        predef.byteType, ExactConversionsSupport.isIntToByteExact((short) (Byte.MAX_VALUE + 1)));\n-        assertOriginalAssignable(fac.Constant(Short.MAX_VALUE),                     predef.byteType, ExactConversionsSupport.isIntToByteExact(Short.MAX_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Short.MIN_VALUE),                     predef.byteType, ExactConversionsSupport.isIntToByteExact(Short.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((short) (Byte.MIN_VALUE - 1)),        predef.byteType, ExactConversionsSupport.isIntToByteExact((short) (Byte.MIN_VALUE - 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((short) (Byte.MAX_VALUE + 1)),        predef.byteType, ExactConversionsSupport.isIntToByteExact((short) (Byte.MAX_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Short.MAX_VALUE),                     predef.byteType, ExactConversionsSupport.isIntToByteExact(Short.MAX_VALUE));\n@@ -100,3 +59,3 @@\n-        assertOriginalAssignable(fac.Constant(Character.MIN_VALUE),                 predef.byteType, ExactConversionsSupport.isIntToByteExact(Character.MIN_VALUE));\n-        assertOriginalAssignable(fac.Constant((char) (Byte.MAX_VALUE + 1)),         predef.byteType, ExactConversionsSupport.isIntToByteExact((char) (Byte.MAX_VALUE + 1)));\n-        assertOriginalAssignable(fac.Constant(Character.MAX_VALUE),                 predef.byteType, ExactConversionsSupport.isIntToByteExact(Character.MAX_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Character.MIN_VALUE),                 predef.byteType, ExactConversionsSupport.isIntToByteExact(Character.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((char) (Byte.MAX_VALUE + 1)),         predef.byteType, ExactConversionsSupport.isIntToByteExact((char) (Byte.MAX_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Character.MAX_VALUE),                 predef.byteType, ExactConversionsSupport.isIntToByteExact(Character.MAX_VALUE));\n@@ -105,4 +64,4 @@\n-        assertOriginalAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.byteType, ExactConversionsSupport.isIntToByteExact(Integer.MIN_VALUE));\n-        assertOriginalAssignable(fac.Constant((int) (Byte.MIN_VALUE - 1)),          predef.byteType, ExactConversionsSupport.isIntToByteExact((int) (Byte.MIN_VALUE - 1)));\n-        assertOriginalAssignable(fac.Constant((int) (Byte.MAX_VALUE + 1)),          predef.byteType, ExactConversionsSupport.isIntToByteExact((int) (Byte.MAX_VALUE + 1)));\n-        assertOriginalAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.byteType, ExactConversionsSupport.isIntToByteExact(Integer.MAX_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.byteType, ExactConversionsSupport.isIntToByteExact(Integer.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((int) (Byte.MIN_VALUE - 1)),          predef.byteType, ExactConversionsSupport.isIntToByteExact((int) (Byte.MIN_VALUE - 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((int) (Byte.MAX_VALUE + 1)),          predef.byteType, ExactConversionsSupport.isIntToByteExact((int) (Byte.MAX_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.byteType, ExactConversionsSupport.isIntToByteExact(Integer.MAX_VALUE));\n@@ -111,4 +70,4 @@\n-        assertOriginalAssignable(fac.Constant(Short.MIN_VALUE),                     predef.charType, ExactConversionsSupport.isIntToCharExact(Short.MIN_VALUE));\n-        assertOriginalAssignable(fac.Constant((short) (Character.MIN_VALUE - 1)),   predef.charType, ExactConversionsSupport.isIntToCharExact((short) (Character.MIN_VALUE - 1)));\n-        assertOriginalAssignable(fac.Constant((short) (Character.MAX_VALUE + 1)),   predef.charType, ExactConversionsSupport.isIntToCharExact((short) (Character.MIN_VALUE + 1)));\n-        assertOriginalAssignable(fac.Constant(Short.MAX_VALUE),                     predef.charType, ExactConversionsSupport.isIntToCharExact(Short.MAX_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Short.MIN_VALUE),                     predef.charType, ExactConversionsSupport.isIntToCharExact(Short.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((short) (Character.MIN_VALUE - 1)),   predef.charType, ExactConversionsSupport.isIntToCharExact((short) (Character.MIN_VALUE - 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((short) (Character.MAX_VALUE + 1)),   predef.charType, ExactConversionsSupport.isIntToCharExact((short) (Character.MIN_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Short.MAX_VALUE),                     predef.charType, ExactConversionsSupport.isIntToCharExact(Short.MAX_VALUE));\n@@ -117,4 +76,4 @@\n-        assertOriginalAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.charType, ExactConversionsSupport.isIntToCharExact(Integer.MIN_VALUE));\n-        assertOriginalAssignable(fac.Constant((int) (Character.MIN_VALUE - 1)),     predef.charType, ExactConversionsSupport.isIntToCharExact((int) (Character.MIN_VALUE - 1)));\n-        assertOriginalAssignable(fac.Constant((int) (Character.MAX_VALUE + 1)),     predef.charType, ExactConversionsSupport.isIntToCharExact((int) (Character.MAX_VALUE + 1)));\n-        assertOriginalAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.charType, ExactConversionsSupport.isIntToCharExact(Integer.MAX_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.charType, ExactConversionsSupport.isIntToCharExact(Integer.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((int) (Character.MIN_VALUE - 1)),     predef.charType, ExactConversionsSupport.isIntToCharExact((int) (Character.MIN_VALUE - 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((int) (Character.MAX_VALUE + 1)),     predef.charType, ExactConversionsSupport.isIntToCharExact((int) (Character.MAX_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.charType, ExactConversionsSupport.isIntToCharExact(Integer.MAX_VALUE));\n@@ -123,3 +82,3 @@\n-        assertOriginalAssignable(fac.Constant(Character.MIN_VALUE),                 predef.shortType, ExactConversionsSupport.isIntToShortExact(Character.MIN_VALUE));\n-        assertOriginalAssignable(fac.Constant((char) (Character.MAX_VALUE + 1)),    predef.shortType, ExactConversionsSupport.isIntToShortExact((char) (Character.MAX_VALUE + 1)));\n-        assertOriginalAssignable(fac.Constant(Character.MAX_VALUE),                 predef.shortType, ExactConversionsSupport.isIntToShortExact(Character.MAX_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Character.MIN_VALUE),                 predef.shortType, ExactConversionsSupport.isIntToShortExact(Character.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((char) (Character.MAX_VALUE + 1)),    predef.shortType, ExactConversionsSupport.isIntToShortExact((char) (Character.MAX_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Character.MAX_VALUE),                 predef.shortType, ExactConversionsSupport.isIntToShortExact(Character.MAX_VALUE));\n@@ -128,4 +87,4 @@\n-        assertOriginalAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.shortType, ExactConversionsSupport.isIntToShortExact(Integer.MIN_VALUE));\n-        assertOriginalAssignable(fac.Constant((int) (Short.MIN_VALUE - 1)),         predef.shortType, ExactConversionsSupport.isIntToShortExact((int) (Short.MIN_VALUE - 1)));\n-        assertOriginalAssignable(fac.Constant((int) (Short.MAX_VALUE + 1)),         predef.shortType, ExactConversionsSupport.isIntToShortExact((int) (Short.MAX_VALUE + 1)));\n-        assertOriginalAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.shortType, ExactConversionsSupport.isIntToShortExact(Integer.MAX_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Integer.MIN_VALUE),                   predef.shortType, ExactConversionsSupport.isIntToShortExact(Integer.MIN_VALUE));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((int) (Short.MIN_VALUE - 1)),         predef.shortType, ExactConversionsSupport.isIntToShortExact((int) (Short.MIN_VALUE - 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant((int) (Short.MAX_VALUE + 1)),         predef.shortType, ExactConversionsSupport.isIntToShortExact((int) (Short.MAX_VALUE + 1)));\n+        assertOriginaAndUpdatedAssignable(fac.Constant(Integer.MAX_VALUE),                   predef.shortType, ExactConversionsSupport.isIntToShortExact(Integer.MAX_VALUE));\n@@ -134,7 +93,2 @@\n-    public void assertOriginalAssignable(Type s, Type t, boolean expected) {\n-        if (originalIsAssignable(s, t) != expected) {\n-            String msg = expected ?\n-                    \" is not assignable to \" :\n-                    \" is assignable to \";\n-            error(s + msg + t);\n-        }\n+    public void assertOriginaAndUpdatedAssignable(Type s, Type t, boolean expected) {\n+        assertAssignable(s, t, originalIsAssignable(s, t));\n@@ -182,1 +136,0 @@\n-        harness.assertAssignmentNarrowingAndUnconditionality();\n","filename":"test\/langtools\/tools\/javac\/patterns\/PrimitiveUnconditionallyExactInAssignability.java","additions":28,"deletions":75,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -76,1 +76,3 @@\n-            types::isUnconditionallyExact,\n+            types::isUnconditionallyExactValueBased,\n+            types::isUnconditionallyExactTypeBased,\n+            types::isUnconditionallyExactCombined,\n","filename":"test\/langtools\/tools\/javac\/types\/UnknownTypeTest.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-        if (types.isUnconditionallyExactConstantPrimitives(s, t) != expected) {\n+        if (types.isUnconditionallyExactValueBased(s, t) != expected) {\n","filename":"test\/langtools\/tools\/lib\/types\/TypeHarness.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}