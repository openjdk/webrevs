{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -330,0 +330,2 @@\n+  \/\/ Returns true if the platform efficiently implements the given masked vector\n+  \/\/ operation using predicate features, false otherwise.\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -846,1 +846,2 @@\n-    Flag_is_predicated_vector        = 1ULL << 14,\n+    Flag_is_predicated_vector        = 1ULL << 14, \/\/ Marked on a vector node that has an additional\n+                                                   \/\/ mask input controlling the lane operations.\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2446,0 +2446,6 @@\n+\/\/ Create a vector mask type with the given element basic type and length.\n+\/\/ - Returns \"TypeVectMask\" (PVectMask) for platforms that support the predicate\n+\/\/   feature and it is implemented properly in the backend, allowing the mask to\n+\/\/   be stored in a predicate\/mask register.\n+\/\/ - Returns a normal vector type \"TypeVectA ~ TypeVectZ\" (NVectMask) otherwise,\n+\/\/   where the vector mask is stored in a vector register.\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1015,1 +1015,1 @@\n-\/\/ Class of Vector Types\n+\/\/ Basic class of vector (mask) types.\n@@ -1055,0 +1055,10 @@\n+\/\/ TypeVect subclasses representing vectors or vector masks with \"BVectMask\" or \"NVectMask\"\n+\/\/ layout (see vectornode.hpp for detailed notes on vector mask representations), mapped\n+\/\/ to vector registers and distinguished by vector register size:\n+\/\/\n+\/\/ - TypeVectA: Scalable vector type (variable size, e.g., AArch64 SVE, RISC-V RVV)\n+\/\/ - TypeVectS: 32-bit vector type\n+\/\/ - TypeVectD: 64-bit vector type\n+\/\/ - TypeVectX: 128-bit vector type\n+\/\/ - TypeVectY: 256-bit vector type\n+\/\/ - TypeVectZ: 512-bit vector type\n@@ -1085,0 +1095,3 @@\n+\/\/ Class of TypeVectMask, representing vector masks with \"PVectMask\" layout (see\n+\/\/ vectornode.hpp for detailed notes on vector mask representations), mapped to\n+\/\/ dedicated hardware predicate\/mask registers.\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,56 @@\n-\/\/------------------------------VectorNode-------------------------------------\n+\/\/=======================Notes-for-VectorMask-Representation=======================\n+\/\/\n+\/\/ There are three distinct representations for vector masks based on platform and\n+\/\/ use scenarios:\n+\/\/\n+\/\/ - BVectMask: Platform-independent mask stored in a vector register with 8-bit\n+\/\/   lanes containing 1\/0 values. The corresponding type is TypeVectA ~ TypeVectZ.\n+\/\/\n+\/\/ - NVectMask: Platform-specific mask stored in vector registers with N-bit lanes,\n+\/\/   where all bits in each lane are either set (true) or unset (false). Generated\n+\/\/   on architectures without predicate\/mask feature, such as AArch64 NEON, x86\n+\/\/   AVX2, etc. The corresponding type is TypeVectA ~ TypeVectZ.\n+\/\/\n+\/\/ - PVectMask: Platform-specific mask stored in predicate\/mask registers. Generated\n+\/\/   on architectures with predicate\/mask feature, such as AArch64 SVE, x86 AVX-512,\n+\/\/   and RISC-V Vector Extension (RVV). The corresponding type is TypeVectMask.\n+\/\/\n+\/\/ NVectMask and PVectMask encode element data type and vector length information.\n+\/\/ They are the primary mask representations used in most mask and masked vector\n+\/\/ operations. While BVectMask primarily represents mask values loaded from or\n+\/\/ stored to Java boolean memory, and is currently used in certain mask operations\n+\/\/ (i.e. VectorMaskOpNode).\n+\/\/\n+\/\/=========================Notes-for-Masked-Vector-Nodes===========================\n+\/\/\n+\/\/ Each lane-wise and cross-lane (reduction) ALU node supports both non-masked\n+\/\/ and masked operations.\n+\/\/\n+\/\/ Currently masked vector nodes are only used to implement the Vector API's masked\n+\/\/ operations (which might also be used for auto-vectorization in future), such as:\n+\/\/   Vector<E> lanewise(VectorOperators.Binary op, Vector<E> v, VectorMask<E> m)\n+\/\/\n+\/\/ They are generated during intrinsification for Vector API, only on architectures\n+\/\/ that support the relevant predicated instructions. The compiler uses\n+\/\/ \"Matcher::match_rule_supported_vector_masked()\" to check whether the current\n+\/\/ platform supports the predicated\/masked vector instructions for an operation. It\n+\/\/ generates the masked vector node for the operation if supported. Otherwise, it\n+\/\/ generates the unpredicated vector node and implements the masked operation with\n+\/\/ the help of a VectorBlendNode. Please see more details from API intrinsification\n+\/\/ in vectorIntrinsics.cpp.\n+\/\/\n+\/\/ To differentiate the masked and non-masked nodes, flag \"Flag_is_predicated_vector\"\n+\/\/ is set for the masked version. Meanwhile, there is an additional mask input for\n+\/\/ the masked nodes.\n+\/\/\n+\/\/ For example:\n+\/\/   - Non-masked version:\n+\/\/          in1  in2\n+\/\/           \\   \/\n+\/\/         AddVBNode\n+\/\/\n+\/\/   - Masked version (with \"Flag_is_predicated_vector\" being set):\n+\/\/       in1  in2  mask\n+\/\/         \\   |   \/\n+\/\/         AddVBNode\n+\n@@ -106,0 +161,2 @@\n+  \/\/ Returns true if the lower vlen bits (bits [0, vlen-1]) of the long value\n+  \/\/ are all 1s or all 0s, indicating a \"mask all\" or \"mask none\" pattern.\n@@ -179,1 +236,0 @@\n-\/\/------------------------------AddVBNode--------------------------------------\n@@ -187,1 +243,0 @@\n-\/\/------------------------------AddVSNode--------------------------------------\n@@ -195,1 +250,0 @@\n-\/\/------------------------------AddVINode--------------------------------------\n@@ -203,1 +257,0 @@\n-\/\/------------------------------AddVLNode--------------------------------------\n@@ -211,1 +264,0 @@\n-\/\/------------------------------AddVHFNode--------------------------------------\n@@ -219,1 +271,0 @@\n-\/\/------------------------------AddVFNode--------------------------------------\n@@ -227,1 +278,0 @@\n-\/\/------------------------------AddVDNode--------------------------------------\n@@ -235,1 +285,0 @@\n-\/\/------------------------------ReductionNode------------------------------------\n@@ -297,1 +346,0 @@\n-\/\/------------------------------AddReductionVINode--------------------------------------\n@@ -305,1 +353,0 @@\n-\/\/------------------------------AddReductionVLNode--------------------------------------\n@@ -313,1 +360,0 @@\n-\/\/------------------------------AddReductionVFNode--------------------------------------\n@@ -340,1 +386,0 @@\n-\/\/------------------------------AddReductionVDNode--------------------------------------\n@@ -367,1 +412,0 @@\n-\/\/------------------------------SubVBNode--------------------------------------\n@@ -375,1 +419,0 @@\n-\/\/------------------------------SubVSNode--------------------------------------\n@@ -383,1 +426,0 @@\n-\/\/------------------------------SubVINode--------------------------------------\n@@ -391,1 +433,0 @@\n-\/\/------------------------------SubVLNode--------------------------------------\n@@ -399,1 +440,0 @@\n-\/\/------------------------------SaturatingAddVNode-----------------------------\n@@ -407,1 +447,0 @@\n-\/\/------------------------------SaturatingSubVNode-----------------------------\n@@ -415,1 +454,0 @@\n-\/\/------------------------------SubVHFNode--------------------------------------\n@@ -423,2 +461,0 @@\n-\n-\/\/------------------------------SubVFNode--------------------------------------\n@@ -432,1 +468,0 @@\n-\/\/------------------------------SubVDNode--------------------------------------\n@@ -440,1 +475,0 @@\n-\/\/------------------------------MulVBNode--------------------------------------\n@@ -448,1 +482,0 @@\n-\/\/------------------------------MulVSNode--------------------------------------\n@@ -456,1 +489,0 @@\n-\/\/------------------------------MulVINode--------------------------------------\n@@ -464,1 +496,0 @@\n-\/\/------------------------------MulVLNode--------------------------------------\n@@ -476,1 +507,0 @@\n-\/\/------------------------------MulVFNode--------------------------------------\n@@ -484,1 +514,0 @@\n-\/\/------------------------------MulVFNode--------------------------------------\n@@ -492,1 +521,0 @@\n-\/\/------------------------------MulVDNode--------------------------------------\n@@ -500,1 +528,0 @@\n-\/\/------------------------------MulAddVS2VINode--------------------------------\n@@ -508,1 +535,0 @@\n-\/\/------------------------------FmaVNode--------------------------------------\n@@ -518,1 +544,0 @@\n-\/\/------------------------------FmaVDNode--------------------------------------\n@@ -526,1 +551,0 @@\n-\/\/------------------------------FmaVFNode--------------------------------------\n@@ -534,1 +558,0 @@\n-\/\/------------------------------FmaVHFNode-------------------------------------\n@@ -542,1 +565,0 @@\n-\/\/------------------------------MulReductionVINode--------------------------------------\n@@ -550,1 +572,0 @@\n-\/\/------------------------------MulReductionVLNode--------------------------------------\n@@ -558,1 +579,0 @@\n-\/\/------------------------------MulReductionVFNode--------------------------------------\n@@ -584,1 +604,0 @@\n-\/\/------------------------------MulReductionVDNode--------------------------------------\n@@ -610,1 +629,0 @@\n-\/\/------------------------------DivVHFNode-------------------------------------\n@@ -618,1 +636,0 @@\n-\/\/------------------------------DivVFNode--------------------------------------\n@@ -626,1 +643,0 @@\n-\/\/------------------------------DivVDNode--------------------------------------\n@@ -634,1 +650,0 @@\n-\/\/------------------------------AbsVBNode--------------------------------------\n@@ -642,1 +657,0 @@\n-\/\/------------------------------AbsVSNode--------------------------------------\n@@ -650,1 +664,0 @@\n-\/\/------------------------------MinVNode--------------------------------------\n@@ -658,1 +671,0 @@\n-\/\/------------------------------MinVHFNode------------------------------------\n@@ -666,1 +678,0 @@\n-\/\/------------------------------MaxVHFNode------------------------------------\n@@ -674,0 +685,1 @@\n+\/\/ Vector Unsigned Min\n@@ -684,2 +696,0 @@\n-\n-\/\/------------------------------MaxVNode--------------------------------------\n@@ -693,0 +703,1 @@\n+\/\/ Vector Unsigned Max\n@@ -703,1 +714,0 @@\n-\/\/------------------------------AbsVINode--------------------------------------\n@@ -711,1 +721,0 @@\n-\/\/------------------------------AbsVLNode--------------------------------------\n@@ -719,1 +728,0 @@\n-\/\/------------------------------AbsVFNode--------------------------------------\n@@ -727,1 +735,0 @@\n-\/\/------------------------------AbsVDNode--------------------------------------\n@@ -735,1 +742,0 @@\n-\/\/------------------------------NegVNode---------------------------------------\n@@ -749,1 +755,0 @@\n-\/\/------------------------------NegVINode--------------------------------------\n@@ -757,1 +762,0 @@\n-\/\/------------------------------NegVLNode--------------------------------------\n@@ -765,1 +769,0 @@\n-\/\/------------------------------NegVFNode--------------------------------------\n@@ -773,1 +776,0 @@\n-\/\/------------------------------NegVDNode--------------------------------------\n@@ -781,1 +783,0 @@\n-\/\/------------------------------PopCountVINode---------------------------------\n@@ -789,1 +790,0 @@\n-\/\/------------------------------PopCountVLNode---------------------------------\n@@ -799,1 +799,0 @@\n-\/\/------------------------------SqrtVHFNode-------------------------------------\n@@ -807,1 +806,0 @@\n-\/\/------------------------------SqrtVFNode--------------------------------------\n@@ -814,1 +812,1 @@\n-\/\/------------------------------RoundDoubleVNode--------------------------------\n+\n@@ -822,1 +820,0 @@\n-\/\/------------------------------SqrtVDNode--------------------------------------\n@@ -830,2 +827,1 @@\n-\/\/------------------------------ShiftVNode-----------------------------------\n-\/\/ Class ShiftV functionality.  This covers the common behaviors for all kinds\n+\/\/ Class ShiftV functionality. This covers the common behaviors for all kinds\n@@ -851,1 +847,0 @@\n-\/\/------------------------------LShiftVBNode-----------------------------------\n@@ -860,1 +855,0 @@\n-\/\/------------------------------LShiftVSNode-----------------------------------\n@@ -869,1 +863,0 @@\n-\/\/------------------------------LShiftVINode-----------------------------------\n@@ -878,1 +871,0 @@\n-\/\/------------------------------LShiftVLNode-----------------------------------\n@@ -887,1 +879,0 @@\n-\/\/------------------------------RShiftVBNode-----------------------------------\n@@ -896,1 +887,0 @@\n-\/\/------------------------------RShiftVSNode-----------------------------------\n@@ -905,1 +895,0 @@\n-\/\/------------------------------RShiftVINode-----------------------------------\n@@ -914,1 +903,0 @@\n-\/\/------------------------------RShiftVLNode-----------------------------------\n@@ -923,1 +911,0 @@\n-\/\/------------------------------URShiftVBNode----------------------------------\n@@ -932,1 +919,0 @@\n-\/\/------------------------------URShiftVSNode----------------------------------\n@@ -941,1 +927,0 @@\n-\/\/------------------------------URShiftVINode----------------------------------\n@@ -950,1 +935,0 @@\n-\/\/------------------------------URShiftVLNode----------------------------------\n@@ -959,1 +943,0 @@\n-\/\/------------------------------LShiftCntVNode---------------------------------\n@@ -967,1 +950,0 @@\n-\/\/------------------------------RShiftCntVNode---------------------------------\n@@ -975,1 +957,0 @@\n-\/\/------------------------------AndVNode---------------------------------------\n@@ -984,1 +965,0 @@\n-\/\/------------------------------AndReductionVNode--------------------------------------\n@@ -992,2 +972,1 @@\n-\/\/------------------------------OrVNode---------------------------------------\n-\/\/ Vector or byte, short, int, long as a reduction\n+\/\/ Vector or integer\n@@ -1001,2 +980,1 @@\n-\/\/------------------------------OrReductionVNode--------------------------------------\n-\/\/ Vector xor byte, short, int, long as a reduction\n+\/\/ Vector or byte, short, int, long as a reduction\n@@ -1009,1 +987,0 @@\n-\/\/------------------------------XorVNode---------------------------------------\n@@ -1019,2 +996,1 @@\n-\/\/------------------------------XorReductionVNode--------------------------------------\n-\/\/ Vector and int, long as a reduction\n+\/\/ Vector xor byte, short, int, long as a reduction\n@@ -1027,1 +1003,0 @@\n-\/\/------------------------------MinReductionVNode--------------------------------------\n@@ -1035,2 +1010,1 @@\n-\/\/------------------------------MaxReductionVNode--------------------------------------\n-\/\/ Vector min byte, short, int, long, float, double as a reduction\n+\/\/ Vector max byte, short, int, long, float, double as a reduction\n@@ -1043,1 +1017,0 @@\n-\/\/------------------------------CompressVNode--------------------------------------\n@@ -1054,0 +1027,1 @@\n+\/\/ Vector mask compress\n@@ -1063,1 +1037,0 @@\n-\/\/------------------------------ExpandVNode--------------------------------------\n@@ -1076,1 +1049,0 @@\n-\/\/------------------------------LoadVectorNode---------------------------------\n@@ -1118,1 +1090,0 @@\n-\/\/------------------------------LoadVectorGatherNode------------------------------\n@@ -1141,1 +1112,0 @@\n-\/\/------------------------------StoreVectorNode--------------------------------\n@@ -1183,1 +1153,0 @@\n-\/\/------------------------------StoreVectorScatterNode------------------------------\n@@ -1185,1 +1154,0 @@\n-\n@@ -1203,1 +1171,0 @@\n-\/\/------------------------------StoreVectorMaskedNode--------------------------------\n@@ -1224,1 +1191,0 @@\n-\/\/------------------------------LoadVectorMaskedNode--------------------------------\n@@ -1248,1 +1214,0 @@\n-\/\/-------------------------------LoadVectorGatherMaskedNode---------------------------------\n@@ -1271,1 +1236,0 @@\n-\/\/------------------------------StoreVectorScatterMaskedNode--------------------------------\n@@ -1315,1 +1279,0 @@\n-\/\/------------------------------VectorCmpMaskedNode--------------------------------\n@@ -1328,1 +1291,2 @@\n-\/\/------------------------------VectorMaskGenNode----------------------------------\n+\/\/ Generate a vector mask based on the given length. Lanes with indices in\n+\/\/ [0, length) are set to true, while the remaining lanes are set to false.\n@@ -1341,1 +1305,2 @@\n-\/\/------------------------------VectorMaskOpNode-----------------------------------\n+\/\/ Base class for certain vector mask operations. The supported input mask can\n+\/\/ be either \"BVectMask\" or \"PVectMask\" depending on the platform.\n@@ -1362,0 +1327,1 @@\n+\/\/ Count the number of true (set) lanes in the vector mask.\n@@ -1369,0 +1335,2 @@\n+\/\/ Returns the index of the first true (set) lane in the vector mask.\n+\/\/ If no lanes are set, returns the vector length.\n@@ -1376,0 +1344,2 @@\n+\/\/ Returns the index of the last true (set) lane in the vector mask.\n+\/\/ If no lanes are set, returns -1 .\n@@ -1383,0 +1353,4 @@\n+\/\/ Pack the mask lane values into a long value, supporting at most the\n+\/\/ first 64 lanes. Each mask lane is packed into one bit in the long\n+\/\/ value, ordered from the least significant bit to the most significant\n+\/\/ bit.\n@@ -1394,0 +1368,3 @@\n+\/\/ Unpack bits from a long value into vector mask lane values. Each bit\n+\/\/ in the long value is unpacked into one mask lane, ordered from the\n+\/\/ least significant bit to the sign bit.\n@@ -1403,1 +1380,3 @@\n-\/\/-------------------------- Vector mask broadcast -----------------------------------\n+\/\/ Broadcast a scalar value to all lanes of a vector mask. All lanes are set\n+\/\/ to true if the input value is non-zero, or false if the input value is\n+\/\/ zero. This node is only used to generate a mask with \"PVectMask\" layout.\n@@ -1410,1 +1389,2 @@\n-\/\/--------------------------- Vector mask logical and --------------------------------\n+\/\/ Perform a bitwise AND operation between two vector masks. This node is\n+\/\/ only used for vector masks with \"PVectMask\" layout.\n@@ -1417,1 +1397,2 @@\n-\/\/--------------------------- Vector mask logical or ---------------------------------\n+\/\/ Perform a bitwise OR operation between two vector masks. This node is\n+\/\/ only used for vector masks with \"PVectMask\" layout.\n@@ -1424,1 +1405,2 @@\n-\/\/--------------------------- Vector mask logical xor --------------------------------\n+\/\/ Perform a bitwise XOR operation between two vector masks. This node is\n+\/\/ only used for vector masks with \"PVectMask\" layout.\n@@ -1431,2 +1413,1 @@\n-\/\/=========================Promote_Scalar_to_Vector============================\n-\n+\/\/ Replicate a scalar value to all lanes of a vector.\n@@ -1442,1 +1423,1 @@\n-\/\/======================Populate_Indices_into_a_Vector=========================\n+\/\/ Populate indices into a vector.\n@@ -1451,1 +1432,0 @@\n-\/\/------------------------------PackNode---------------------------------------\n@@ -1469,1 +1449,0 @@\n-\/\/------------------------------PackBNode--------------------------------------\n@@ -1477,1 +1456,0 @@\n-\/\/------------------------------PackSNode--------------------------------------\n@@ -1486,1 +1464,0 @@\n-\/\/------------------------------PackINode--------------------------------------\n@@ -1495,1 +1472,0 @@\n-\/\/------------------------------PackLNode--------------------------------------\n@@ -1504,1 +1480,0 @@\n-\/\/------------------------------Pack2LNode-------------------------------------\n@@ -1512,1 +1487,0 @@\n-\/\/------------------------------PackFNode--------------------------------------\n@@ -1521,1 +1495,0 @@\n-\/\/------------------------------PackDNode--------------------------------------\n@@ -1530,1 +1503,0 @@\n-\/\/------------------------------Pack2DNode-------------------------------------\n@@ -1538,1 +1510,4 @@\n-\n+\/\/ Load the IOTA constant vector containing sequential indices starting from 0\n+\/\/ and incrementing by 1 up to \"VLENGTH - 1\". So far, the first input is an int\n+\/\/ constant 0. For example, a 128-bit vector with int (32-bit) elements produces\n+\/\/ a vector like \"[0, 1, 2, 3]\".\n@@ -1547,2 +1522,1 @@\n-\/\/------------------------------ExtractNode------------------------------------\n-\/\/ Extract a scalar from a vector at position \"pos\"\n+\/\/ The base class for all extract nodes.\n@@ -1557,2 +1531,1 @@\n-\/\/------------------------------ExtractBNode-----------------------------------\n-\/\/ Extract a byte from a vector at position \"pos\"\n+\/\/ Extract a byte from a vector at position \"pos\".\n@@ -1567,2 +1540,1 @@\n-\/\/------------------------------ExtractUBNode----------------------------------\n-\/\/ Extract a boolean from a vector at position \"pos\"\n+\/\/ Extract a boolean from a vector at position \"pos\".\n@@ -1577,2 +1549,1 @@\n-\/\/------------------------------ExtractCNode-----------------------------------\n-\/\/ Extract a char from a vector at position \"pos\"\n+\/\/ Extract a char from a vector at position \"pos\".\n@@ -1587,2 +1558,1 @@\n-\/\/------------------------------ExtractSNode-----------------------------------\n-\/\/ Extract a short from a vector at position \"pos\"\n+\/\/ Extract a short from a vector at position \"pos\".\n@@ -1597,2 +1567,1 @@\n-\/\/------------------------------ExtractINode-----------------------------------\n-\/\/ Extract an int from a vector at position \"pos\"\n+\/\/ Extract an int from a vector at position \"pos\".\n@@ -1607,2 +1576,1 @@\n-\/\/------------------------------ExtractLNode-----------------------------------\n-\/\/ Extract a long from a vector at position \"pos\"\n+\/\/ Extract a long from a vector at position \"pos\".\n@@ -1617,2 +1585,1 @@\n-\/\/------------------------------ExtractFNode-----------------------------------\n-\/\/ Extract a float from a vector at position \"pos\"\n+\/\/ Extract a float from a vector at position \"pos\".\n@@ -1627,2 +1594,1 @@\n-\/\/------------------------------ExtractDNode-----------------------------------\n-\/\/ Extract a double from a vector at position \"pos\"\n+\/\/ Extract a double from a vector at position \"pos\".\n@@ -1637,1 +1603,0 @@\n-\/\/------------------------------MacroLogicVNode-------------------------------\n@@ -1656,0 +1621,2 @@\n+\/\/ Compare two vectors lane-wise using the specified predicate and produce a\n+\/\/ vector mask.\n@@ -1700,0 +1667,2 @@\n+\/\/ Test whether all or any lanes in the first input vector mask is true,\n+\/\/ based on the specified predicate.\n@@ -1722,0 +1691,3 @@\n+\/\/ Blend two vectors based on a vector mask. For each lane, select the value\n+\/\/ from the first input vector (vec1) if the corresponding mask lane is set,\n+\/\/ otherwise select from the second input vector (vec2).\n@@ -1735,0 +1707,4 @@\n+\/\/ Rearrange lane elements from a source vector under the control of a shuffle\n+\/\/ (indexes) vector. Each lane in the shuffle vector specifies which lane from\n+\/\/ the source vector to select for the corresponding output lane. All indexes\n+\/\/ are in the range [0, VLENGTH).\n@@ -1739,1 +1715,0 @@\n-    \/\/ assert(mask->is_VectorMask(), \"VectorBlendNode requires that third argument be a mask\");\n@@ -1747,3 +1722,6 @@\n-\n-\/\/ Select elements from two source vectors based on the wrapped indexes held in\n-\/\/ the first vector.\n+\/\/ Select lane elements from two source vectors (\"src1\" and \"src2\") under the\n+\/\/ control of an \"indexes\" vector. The two source vectors are logically concatenated\n+\/\/ to form a table of 2*VLENGTH elements, where src1 occupies indices [0, VLENGTH)\n+\/\/ and src2 occupies indices [VLENGTH, 2*VLENGTH). Each lane in the \"indexes\"\n+\/\/ vector specifies which element from this table to select for the corresponding\n+\/\/ output lane.\n@@ -1761,7 +1739,13 @@\n-\/\/ The target may not directly support the rearrange operation for an element type. In those cases,\n-\/\/ we can transform the rearrange into a different element type. For example, on x86 before AVX512,\n-\/\/ there is no rearrange instruction for short elements, what we will then do is to transform the\n-\/\/ shuffle vector into one that we can do byte rearrange such that it would provide the same\n-\/\/ result. This could have been done in VectorRearrangeNode during code emission but we eagerly\n-\/\/ expand this out because it is often the case that an index vector is reused in many rearrange\n-\/\/ operations. This allows the index preparation to be GVN-ed as well as hoisted out of loops, etc.\n+\/\/ Transform a shuffle vector when the target does not directly support rearrange\n+\/\/ operations for the original element type. In such cases, the rearrange can be\n+\/\/ transformed to use a different element type.\n+\/\/\n+\/\/ For example, on x86 before AVX512, there are no rearrange instructions for short\n+\/\/ elements. The shuffle vector is transformed into one suitable for byte rearrange\n+\/\/ that produces the same result. This could have been done in VectorRearrangeNode\n+\/\/ during code emission, but we eagerly expand it out because shuffle vectors are\n+\/\/ often reused in many rearrange operations. This allows the transformation to be\n+\/\/ GVN-ed and hoisted out of loops.\n+\/\/\n+\/\/ Input:  Original shuffle vector (indices for the desired element type)\n+\/\/ Output: Transformed shuffle vector (indices for the supported element type)\n@@ -1776,0 +1760,2 @@\n+\/\/ Convert a \"BVectMask\" into a platform-specific vector mask (either \"NVectMask\"\n+\/\/ or \"PVectMask\").\n@@ -1787,0 +1773,2 @@\n+\/\/ Convert a platform-specific vector mask (either \"NVectMask\" or \"PVectMask\")\n+\/\/ into a \"BVectMask\".\n@@ -1798,0 +1786,2 @@\n+\/\/ Lane-wise type cast a vector mask to the given vector type. The vector length\n+\/\/ of the input and output must be the same.\n@@ -1834,0 +1824,2 @@\n+\/\/ Lane-wise type cast a vector to the given vector type. This is the base\n+\/\/ class for all vector type cast operations.\n@@ -1846,0 +1838,1 @@\n+\/\/ Cast a byte vector to the given vector type.\n@@ -1854,0 +1847,1 @@\n+\/\/ Cast a short vector to the given vector type.\n@@ -1862,0 +1856,1 @@\n+\/\/ Cast an int vector to the given vector type.\n@@ -1870,0 +1865,1 @@\n+\/\/ Cast a long vector to the given vector type.\n@@ -1878,0 +1874,1 @@\n+\/\/ Cast a float vector to the given vector type.\n@@ -1886,0 +1883,1 @@\n+\/\/ Cast a double vector to the given vector type.\n@@ -1894,0 +1892,1 @@\n+\/\/ Cast a half float vector to float vector type.\n@@ -1902,0 +1901,1 @@\n+\/\/ Cast a float vector to a half float vector type.\n@@ -1910,2 +1910,5 @@\n-\/\/ So far, VectorUCastNode can only be used in Vector API unsigned extensions\n-\/\/ between integral types. E.g., extending byte to float is not supported now.\n+\/\/ Unsigned vector cast operations can only be used in Vector API unsigned\n+\/\/ extensions between integral types so far. E.g., extending byte to float\n+\/\/ is not supported now.\n+\n+\/\/ Unsigned cast a byte vector to the given vector type.\n@@ -1923,0 +1926,1 @@\n+\/\/ Unsigned cast a short vector to the given vector type.\n@@ -1933,0 +1937,1 @@\n+\/\/ Unsigned cast an int vector to the given vector type.\n@@ -1942,0 +1947,1 @@\n+\/\/ Vector round float to nearest integer.\n@@ -1950,0 +1956,1 @@\n+\/\/ Vector round double to nearest integer.\n@@ -1958,0 +1965,1 @@\n+\/\/ Insert a new value into a vector lane at the specified position.\n@@ -1971,0 +1979,3 @@\n+\/\/ Box a vector value into a Vector API object (e.g., IntMaxVector).\n+\/\/ This is a macro node that gets expanded during vector optimization\n+\/\/ phase.\n@@ -1998,0 +2009,2 @@\n+\/\/ Allocate storage for boxing a vector value. This is used during vector\n+\/\/ box expansion.\n@@ -2012,0 +2025,3 @@\n+\/\/ Unbox a Vector API object (e.g., IntMaxVector) to extract the underlying\n+\/\/ vector value. This is a macro node expanded during vector optimization\n+\/\/ phase.\n@@ -2030,0 +2046,1 @@\n+\/\/ Lane-wise right rotation of the first input by the second input.\n@@ -2039,0 +2056,1 @@\n+\/\/ Lane-wise left rotation of the first input by the second input.\n@@ -2048,0 +2066,1 @@\n+\/\/ Count the number of leading zeros in each lane of the input.\n@@ -2059,0 +2078,1 @@\n+\/\/ Count the number of trailing zeros in each lane of the input.\n@@ -2070,0 +2090,1 @@\n+\/\/ Reverse the bits within each lane (e.g., 0b10110010 becomes 0b01001101).\n@@ -2079,0 +2100,1 @@\n+\/\/ Reverse the byte order within each lane (e.g., 0x12345678 becomes 0x78563412).\n@@ -2088,0 +2110,1 @@\n+\/\/ Vector signum float.\n@@ -2096,0 +2119,1 @@\n+\/\/ Vector signum double.\n@@ -2104,0 +2128,2 @@\n+\/\/ Compress (extract and pack) bits in each lane of the first input\n+\/\/ based on the mask input.\n@@ -2111,0 +2137,2 @@\n+\/\/ Expand (deposit) bits in each lane of the first input based on the\n+\/\/ mask input.\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":184,"deletions":156,"binary":false,"changes":340,"status":"modified"}]}