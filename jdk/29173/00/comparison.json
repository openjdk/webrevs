{"files":[{"patch":"@@ -50,0 +50,1 @@\n+import jdk.jpackage.internal.util.MacBundle;\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,97 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Optional;\n-import jdk.jpackage.internal.model.AppImageLayout;\n-\n-\/**\n- * An abstraction of macOS Application bundle.\n- *\n- * @see <a href=\"https:\/\/en.wikipedia.org\/wiki\/Bundle_(macOS)#Application_bundles\">https:\/\/en.wikipedia.org\/wiki\/Bundle_(macOS)#Application_bundles<\/a>\n- *\/\n-record MacBundle(Path root) {\n-\n-    MacBundle {\n-        Objects.requireNonNull(root);\n-    }\n-\n-    boolean isValid() {\n-        return Files.isDirectory(contentsDir()) && Files.isDirectory(macOsDir()) && Files.isRegularFile(infoPlistFile());\n-    }\n-\n-    boolean isSigned() {\n-        return Files.isDirectory(contentsDir().resolve(\"_CodeSignature\"));\n-    }\n-\n-    Path contentsDir() {\n-        return root.resolve(\"Contents\");\n-    }\n-\n-    Path homeDir() {\n-        return contentsDir().resolve(\"Home\");\n-    }\n-\n-    Path macOsDir() {\n-        return contentsDir().resolve(\"MacOS\");\n-    }\n-\n-    Path resourcesDir() {\n-        return contentsDir().resolve(\"Resources\");\n-    }\n-\n-    Path infoPlistFile() {\n-        return contentsDir().resolve(\"Info.plist\");\n-    }\n-\n-    static Optional<MacBundle> fromPath(Path path) {\n-        var bundle = new MacBundle(path);\n-        if (bundle.isValid()) {\n-            return Optional.of(bundle);\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n-    static Optional<MacBundle> fromAppImageLayout(AppImageLayout layout) {\n-        final var root = layout.rootDirectory();\n-        final var bundleSubdir = root.relativize(layout.runtimeDirectory());\n-        final var contentsDirname = Path.of(\"Contents\");\n-        var bundleRoot = root;\n-        for (int i = 0; i != bundleSubdir.getNameCount(); i++) {\n-            var nameComponent = bundleSubdir.getName(i);\n-            if (contentsDirname.equals(nameComponent)) {\n-                return Optional.of(new MacBundle(bundleRoot));\n-            } else {\n-                bundleRoot = bundleRoot.resolve(nameComponent);\n-            }\n-        }\n-        return Optional.empty();\n-    }\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBundle.java","additions":0,"deletions":97,"binary":false,"changes":97,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import static jdk.jpackage.internal.cli.StandardOption.ICON;\n@@ -35,0 +34,1 @@\n+import static jdk.jpackage.internal.cli.StandardOption.ICON;\n@@ -55,0 +55,1 @@\n+import java.util.List;\n@@ -60,0 +61,1 @@\n+import jdk.jpackage.internal.cli.OptionValue;\n@@ -74,0 +76,1 @@\n+import jdk.jpackage.internal.util.MacBundle;\n@@ -279,10 +282,6 @@\n-        app.externalApp()\n-                .map(ExternalApplication::extra)\n-                .flatMap(MAC_SIGN::findIn)\n-                .ifPresent(builder::predefinedAppImageSigned);\n-\n-        PREDEFINED_RUNTIME_IMAGE.findIn(options)\n-                .map(MacBundle::new)\n-                .filter(MacBundle::isValid)\n-                .map(MacBundle::isSigned)\n-                .ifPresent(builder::predefinedAppImageSigned);\n+        for (OptionValue<Path> ov : List.of(PREDEFINED_APP_IMAGE, PREDEFINED_RUNTIME_IMAGE)) {\n+            ov.findIn(options)\n+                    .flatMap(MacBundle::fromPath)\n+                    .map(MacPackagingPipeline::isSigned)\n+                    .ifPresent(builder::predefinedAppImageSigned);\n+        }\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromOptions.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,2 @@\n+import jdk.jpackage.internal.util.MacBundle;\n+import jdk.jpackage.internal.util.PListReader;\n@@ -181,3 +183,0 @@\n-                final var predefinedRuntimeBundle = Optional.of(\n-                        new MacBundle(p.predefinedAppImage().orElseThrow())).filter(MacBundle::isValid);\n-\n@@ -187,1 +186,1 @@\n-                if (predefinedRuntimeBundle.isPresent()) {\n+                if (MacBundle.fromPath(p.predefinedAppImage().orElseThrow()).isPresent()) {\n@@ -198,1 +197,1 @@\n-                if (predefinedRuntimeBundle.map(MacBundle::isSigned).orElse(false) && !((MacPackage)p).app().sign()) {\n+                if (((MacPackage)p).predefinedAppImageSigned().orElse(false) && !((MacPackage)p).app().sign()) {\n@@ -282,0 +281,24 @@\n+    static boolean isSigned(MacBundle bundle) {\n+\n+        var result = toSupplier(Executor.of(\n+                \"\/usr\/sbin\/spctl\",\n+                \"-vv\",\n+                \"--raw\",\n+                \"--assess\",\n+                \"--type\", \"exec\",\n+                bundle.root().toString()).setQuiet(true).saveOutput(true).binaryOutput()::execute).get();\n+\n+        switch (result.getExitCode()) {\n+            case 0, 3 -> {\n+                \/\/ These exit codes are accompanied with valid plist xml.\n+                return toSupplier(() -> {\n+                    return new PListReader(result.byteStdout()).findValue(\"assessment:originator\").isPresent();\n+                }).get();\n+            }\n+            default -> {\n+                \/\/ Likely to be an \"a sealed resource is missing or invalid\" error.\n+                return false;\n+            }\n+        }\n+    }\n+\n@@ -289,1 +312,1 @@\n-            srcMacBundle = MacBundle.fromAppImageLayout(srcAppImage);\n+            srcMacBundle = macBundleFromAppImageLayout(srcAppImage);\n@@ -300,1 +323,1 @@\n-                        MacBundle.fromAppImageLayout(dstAppImage).orElseThrow().root(),\n+                        macBundleFromAppImageLayout(dstAppImage).orElseThrow().root(),\n@@ -418,1 +441,1 @@\n-        final var infoPlistFile = MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow().infoPlistFile();\n+        final var infoPlistFile = macBundleFromAppImageLayout(env.resolvedLayout()).orElseThrow().infoPlistFile();\n@@ -471,1 +494,1 @@\n-            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow());\n+            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(macBundleFromAppImageLayout(env.resolvedLayout()).orElseThrow());\n@@ -553,1 +576,1 @@\n-            return MacBundle.fromAppImageLayout(env.resolvedLayout()).orElseThrow();\n+            return macBundleFromAppImageLayout(env.resolvedLayout()).orElseThrow();\n@@ -598,0 +621,16 @@\n+    private static Optional<MacBundle> macBundleFromAppImageLayout(AppImageLayout layout) {\n+        final var root = layout.rootDirectory();\n+        final var bundleSubdir = root.relativize(layout.runtimeDirectory());\n+        final var contentsDirname = Path.of(\"Contents\");\n+        var bundleRoot = root;\n+        for (int i = 0; i != bundleSubdir.getNameCount(); i++) {\n+            var nameComponent = bundleSubdir.getName(i);\n+            if (contentsDirname.equals(nameComponent)) {\n+                return Optional.of(new MacBundle(bundleRoot));\n+            } else {\n+                bundleRoot = bundleRoot.resolve(nameComponent);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackagingPipeline.java","additions":50,"deletions":11,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_SIGNED;\n@@ -99,3 +98,0 @@\n-        SIGNED(MAC_SIGNED, app -> {\n-            return Optional.of(Boolean.toString(app.sign()));\n-        }),\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacApplication.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,1 @@\n+        validator = other.validator;\n@@ -138,1 +139,1 @@\n-                Optional.of(arryValuePattern()),\n+                Optional.of(arrayValuePattern()),\n@@ -142,0 +143,10 @@\n+    Optional<? extends Validator<T, RuntimeException>> createValidator() {\n+        return Optional.ofNullable(validator).or(() -> {\n+            if (validatorBuilder.hasValidatingMethod()) {\n+                return Optional.of(validatorBuilder.create());\n+            } else {\n+                return Optional.empty();\n+            }\n+        });\n+    }\n+\n@@ -165,0 +176,1 @@\n+        validator = null;\n@@ -170,0 +182,1 @@\n+        validator = null;\n@@ -185,0 +198,1 @@\n+        validator = null;\n@@ -228,0 +242,1 @@\n+        validator = null;\n@@ -234,0 +249,1 @@\n+        validator = null;\n@@ -240,0 +256,7 @@\n+        validator = null;\n+        return this;\n+    }\n+\n+    OptionSpecBuilder<T> validator(Validator<T, RuntimeException> v) {\n+        validatorBuilder.predicate(null).consumer(null);\n+        validator = Objects.requireNonNull(v);\n@@ -250,0 +273,1 @@\n+        validator = null;\n@@ -426,8 +450,0 @@\n-    private Optional<Validator<T, ? extends RuntimeException>> createValidator() {\n-        if (validatorBuilder.hasValidatingMethod()) {\n-            return Optional.of(validatorBuilder.create());\n-        } else {\n-            return Optional.empty();\n-        }\n-    }\n-\n@@ -443,1 +459,1 @@\n-    private String arryValuePattern() {\n+    private String arrayValuePattern() {\n@@ -471,0 +487,1 @@\n+    private Validator<T, RuntimeException> validator;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/OptionSpecBuilder.java","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -172,9 +172,0 @@\n-    \/**\n-     * Is an application image is signed. macOS-only.\n-     *\/\n-    public static final OptionValue<Boolean> MAC_SIGNED = booleanOption(\"signed\")\n-            .inScope(AppImageFileOptionScope.APP)\n-            .mutate(setPlatformScope(OperatingSystem.MACOS))\n-            .toOptionValueBuilder().id(StandardOption.MAC_SIGN.id()).create();\n-\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardAppImageFileOption.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -236,0 +236,6 @@\n+                    var directoryValidator = b.createValidator().orElseThrow();\n+                    var macBundleValidator = b\n+                            .validatorExceptionFormatString(\"error.parameter-not-mac-bundle\")\n+                            .validator(StandardValidator.IS_VALID_MAC_BUNDLE)\n+                            .createValidator().orElseThrow();\n+                    b.validator(Validator.and(directoryValidator, macBundleValidator));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardOption.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import jdk.jpackage.internal.util.MacBundle;\n@@ -141,0 +142,4 @@\n+    public static Predicate<Path> IS_VALID_MAC_BUNDLE = path -> {\n+        return MacBundle.fromPath(path).isPresent();\n+    };\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/StandardValidator.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.util.Collection;\n@@ -33,0 +32,1 @@\n+import java.util.stream.Stream;\n@@ -39,2 +39,37 @@\n-    default Validator<T, ? extends Exception> andThen(Validator<T, ? extends Exception> after) {\n-        return reduce(this, after);\n+    default Validator<T, ? extends Exception> and(Validator<T, ? extends Exception> after) {\n+        Objects.requireNonNull(after);\n+        var before = this;\n+        return (optionName, optionValue) -> {\n+            return Stream.concat(\n+                    before.validate(optionName, optionValue).stream(),\n+                    after.validate(optionName, optionValue).stream()\n+            ).toList();\n+        };\n+    }\n+\n+    default Validator<T, ? extends Exception> or(Validator<T, ? extends Exception> after) {\n+        Objects.requireNonNull(after);\n+        var before = this;\n+        return (optionName, optionValue) -> {\n+            var bErrors = before.validate(optionName, optionValue);\n+            if (bErrors.isEmpty()) {\n+                return List.of();\n+            }\n+\n+            var aErrors = after.validate(optionName, optionValue);\n+            if (aErrors.isEmpty()) {\n+                return List.of();\n+            }\n+\n+            return Stream.concat(bErrors.stream(), aErrors.stream()).toList();\n+        };\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T, U extends Exception> Validator<T, U> and(Validator<T, U> first, Validator<T, U> second) {\n+        return (Validator<T, U>)first.and(second);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T, U extends Exception> Validator<T, U> or(Validator<T, U> first, Validator<T, U> second) {\n+        return (Validator<T, U>)first.or(second);\n@@ -254,11 +289,0 @@\n-\n-    @SafeVarargs\n-    private static <T> Validator<T, ? extends Exception> reduce(Validator<T, ? extends Exception>... validators) {\n-        @SuppressWarnings(\"varargs\")\n-        var theValidators = List.of(validators);\n-        return (optionName, optionValue) -> {\n-            return theValidators.stream().map(validator -> {\n-                return validator.validate(optionName, optionValue);\n-            }).flatMap(Collection::stream).map(Exception.class::cast).toList();\n-        };\n-    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/cli\/Validator.java","additions":39,"deletions":15,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+error.parameter-not-mac-bundle=The value \"{0}\" provided for parameter {1} is not a valid macOS bundle\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.util;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * An abstraction of macOS Application bundle.\n+ *\n+ * @see <a href=\"https:\/\/en.wikipedia.org\/wiki\/Bundle_(macOS)#Application_bundles\">https:\/\/en.wikipedia.org\/wiki\/Bundle_(macOS)#Application_bundles<\/a>\n+ *\/\n+public record MacBundle(Path root) {\n+\n+    public MacBundle {\n+        Objects.requireNonNull(root);\n+    }\n+\n+    public boolean isValid() {\n+        return Files.isDirectory(contentsDir()) && Files.isDirectory(macOsDir()) && Files.isRegularFile(infoPlistFile());\n+    }\n+\n+    public Path contentsDir() {\n+        return root.resolve(\"Contents\");\n+    }\n+\n+    public Path homeDir() {\n+        return contentsDir().resolve(\"Home\");\n+    }\n+\n+    public Path macOsDir() {\n+        return contentsDir().resolve(\"MacOS\");\n+    }\n+\n+    public Path resourcesDir() {\n+        return contentsDir().resolve(\"Resources\");\n+    }\n+\n+    public Path infoPlistFile() {\n+        return contentsDir().resolve(\"Info.plist\");\n+    }\n+\n+    public static Optional<MacBundle> fromPath(Path path) {\n+        var bundle = new MacBundle(path);\n+        if (bundle.isValid()) {\n+            return Optional.of(bundle);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/MacBundle.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -50,1 +50,1 @@\n-        String version, boolean macSigned, boolean macAppStore, Map<String, Map<String, String>> launchers) {\n+        String version, boolean macAppStore, Map<String, Map<String, String>> launchers) {\n@@ -69,1 +69,1 @@\n-        this(mainLauncherName, mainLauncherClassName, \"1.0\", false, false, Map.of(mainLauncherName, Map.of()));\n+        this(mainLauncherName, mainLauncherClassName, \"1.0\", false, Map.of(mainLauncherName, Map.of()));\n@@ -106,4 +106,0 @@\n-            xml.writeStartElement(\"signed\");\n-            xml.writeCharacters(Boolean.toString(macSigned));\n-            xml.writeEndElement();\n-\n@@ -143,4 +139,0 @@\n-            var macSigned = Optional.ofNullable(xPath.evaluate(\n-                    \"\/jpackage-state\/signed\/text()\", doc)).map(\n-                            Boolean::parseBoolean).orElse(false);\n-\n@@ -174,1 +166,0 @@\n-                    macSigned,\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AppImageFile.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1388,1 +1388,1 @@\n-                return AppImageFile.load(Path.of(getArgumentValue(\"--app-image\"))).macSigned();\n+                return MacHelper.isBundleSigned(Path.of(getArgumentValue(\"--app-image\")));\n@@ -1409,7 +1409,2 @@\n-                boolean expectedValue = MacHelper.appImageSigned(this);\n-                boolean actualValue = aif.macSigned();\n-                TKit.assertEquals(expectedValue, actualValue,\n-                    \"Check for unexpected value of <signed> property in app image file\");\n-\n-                expectedValue = hasArgument(\"--mac-app-store\");\n-                actualValue = aif.macAppStore();\n+                var expectedValue = hasArgument(\"--mac-app-store\");\n+                var actualValue = aif.macAppStore();\n@@ -1440,1 +1435,1 @@\n-                if (AppImageFile.load(Path.of(appImage)).macSigned()) {\n+                if (MacHelper.isBundleSigned(Path.of(appImage))) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -48,0 +49,1 @@\n+import java.util.Arrays;\n@@ -62,2 +64,0 @@\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n@@ -70,0 +70,1 @@\n+import jdk.jpackage.internal.util.MacBundle;\n@@ -92,2 +93,2 @@\n-        \/\/ Explode DMG assuming this can require interaction, thus use `yes`.\n-        final var attachStdout = Executor.of(\"sh\", \"-c\", String.join(\" \",\n+        \/\/ Explode the DMG assuming this can require interaction if the DMG has a license, thus use `yes`.\n+        final var attachExec = Executor.of(\"sh\", \"-c\", String.join(\" \",\n@@ -102,1 +103,3 @@\n-        )).saveOutput().storeOutputInFiles().executeAndRepeatUntilExitCode(0, 10, 6).stdout();\n+        )).saveOutput().storeOutputInFiles().binaryOutput();\n+\n+        final var attachResult = attachExec.executeAndRepeatUntilExitCode(0, 10, 6);\n@@ -108,0 +111,18 @@\n+            byte[] stdout = attachResult.byteStdout();\n+\n+            \/\/ If the DMG has a license, it will be printed to the stdout before the plist content.\n+            \/\/ All bytes before the XML declaration of the plist must be skipped.\n+            \/\/ We need to find the location of the {'<', '?', 'x', 'm', 'l'} byte array\n+            \/\/ (the XML declaration) in the captured binary stdout.\n+            \/\/ Instead of crafting an ad-hoc function that operates on byte arrays,\n+            \/\/ we will convert the byte array into a String instance using\n+            \/\/ an 8-bit character set (ISO-8859-1) and use the standard String#indexOf().\n+            var startPlistIndex = new String(stdout, StandardCharsets.ISO_8859_1).indexOf(\"<?xml\");\n+\n+            byte[] plistXml;\n+            if (startPlistIndex > 0) {\n+                plistXml = Arrays.copyOfRange(stdout, startPlistIndex, stdout.length);\n+            } else {\n+                plistXml = stdout;\n+            }\n+\n@@ -109,1 +130,1 @@\n-            mountPoint = readPList(attachStdout).queryArrayValue(\"system-entities\", false)\n+            mountPoint = readPList(plistXml).queryArrayValue(\"system-entities\", false)\n@@ -120,1 +141,1 @@\n-                attachStdout.forEach(TKit::trace);\n+                attachResult.toCharacterResult(attachExec.charset(), false).stdout().forEach(TKit::trace);\n@@ -171,6 +192,1 @@\n-        return ThrowingSupplier.toSupplier(() -> readPList(Files.readAllLines(\n-                path))).get();\n-    }\n-\n-    public static PListReader readPList(List<String> lines) {\n-        return readPList(lines.stream());\n+        return readPList(toFunction(Files::readAllBytes).apply(path));\n@@ -179,5 +195,4 @@\n-    public static PListReader readPList(Stream<String> lines) {\n-        return ThrowingSupplier.toSupplier(() -> new PListReader(lines\n-                \/\/ Skip leading lines before xml declaration\n-                .dropWhile(Pattern.compile(\"\\\\s?<\\\\?xml\\\\b.+\\\\?>\").asPredicate().negate())\n-                .collect(Collectors.joining()).getBytes(StandardCharsets.UTF_8))).get();\n+    public static PListReader readPList(byte[] xml) {\n+        return ThrowingSupplier.toSupplier(() -> {\n+            return new PListReader(xml);\n+        }).get();\n@@ -268,1 +283,1 @@\n-        var runtimeImage = Optional.ofNullable(cmd.getArgumentValue(\"--runtime-image\")).map(Path::of);\n+        var runtimeImageBundle = Optional.ofNullable(cmd.getArgumentValue(\"--runtime-image\")).map(Path::of).flatMap(MacBundle::fromPath);\n@@ -271,1 +286,1 @@\n-        if (cmd.isRuntime() && Files.isDirectory(runtimeImage.orElseThrow().resolve(\"Contents\/_CodeSignature\"))) {\n+        if (cmd.isRuntime() && runtimeImageBundle.map(MacHelper::isBundleSigned).orElse(false)) {\n@@ -274,1 +289,1 @@\n-        } else if (appImage.map(AppImageFile::load).map(AppImageFile::macSigned).orElse(false)) {\n+        } else if (appImage.map(MacHelper::isBundleSigned).orElse(false)) {\n@@ -304,0 +319,8 @@\n+    static boolean isBundleSigned(Path bundleRoot) {\n+        return isBundleSigned(MacBundle.fromPath(bundleRoot).orElseThrow(IllegalArgumentException::new));\n+    }\n+\n+    static boolean isBundleSigned(MacBundle bundle) {\n+        return MacSignVerify.findSpctlSignOrigin(MacSignVerify.SpctlType.EXEC, bundle.root(), true).isPresent();\n+    }\n+\n@@ -386,1 +409,1 @@\n-        var plistPath = ApplicationLayout.macAppImage().resolveAt(predefinedAppImage).contentDirectory().resolve(\"Info.plist\");\n+        var plistPath = MacBundle.fromPath(predefinedAppImage).orElseThrow().infoPlistFile();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacHelper.java","additions":45,"deletions":22,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n@@ -33,1 +32,0 @@\n-import java.util.NoSuchElementException;\n@@ -36,1 +34,0 @@\n-import java.util.Set;\n@@ -69,1 +66,1 @@\n-        \/\/ Let is fail in the following TKit.assertEquals() call with a proper log message.\n+        \/\/ Let it fail in the following TKit.assertEquals() call with a proper log message.\n@@ -95,1 +92,5 @@\n-        final var exec = Executor.of(\"\/usr\/bin\/codesign\", \"-d\", \"--entitlements\", \"-\", \"--xml\", path.toString()).saveOutput().dumpOutput();\n+        final var exec = Executor.of(\n+                \"\/usr\/bin\/codesign\",\n+                \"-d\",\n+                \"--entitlements\", \"-\",\n+                \"--xml\", path.toString()).saveOutput().dumpOutput().binaryOutput();\n@@ -97,2 +98,2 @@\n-        var xml = result.stdout();\n-        if (xml.isEmpty()) {\n+        var xml = result.byteStdout();\n+        if (xml.length == 0) {\n@@ -138,9 +139,22 @@\n-        final var exec = Executor.of(\"\/usr\/sbin\/spctl\", \"-vv\", \"--raw\", \"--assess\", \"--type\", type.value(), path.toString()).saveOutput().discardStderr();\n-        final var result = exec.executeWithoutExitCodeCheck();\n-        TKit.assertTrue(Set.of(0, 3).contains(result.getExitCode()),\n-                String.format(\"Check exit code of command %s is either 0 or 3\", exec.getPrintableCommandLine()));\n-        return toSupplier(() -> {\n-            try {\n-                return Optional.of(new PListReader(String.join(\"\", result.getOutput()).getBytes()).queryValue(\"assessment:originator\"));\n-            } catch (NoSuchElementException ex) {\n-                return Optional.<String>empty();\n+        return findSpctlSignOrigin(type, path, false);\n+    }\n+\n+    public static Optional<String> findSpctlSignOrigin(SpctlType type, Path path, boolean acceptBrokenSignature) {\n+        final var exec = Executor.of(\n+                \"\/usr\/sbin\/spctl\",\n+                \"-vv\",\n+                \"--raw\",\n+                \"--assess\",\n+                \"--type\", type.value(),\n+                path.toString()).saveOutput().discardStderr().binaryOutput();\n+        Executor.Result result;\n+        if (acceptBrokenSignature) {\n+            result = exec.executeWithoutExitCodeCheck();\n+            switch (result.getExitCode()) {\n+                case 0, 3 -> {\n+                    \/\/ NOP\n+                }\n+                default -> {\n+                    \/\/ No plist XML to process.\n+                    return Optional.empty();\n+                }\n@@ -148,1 +162,4 @@\n-        }).get();\n+        } else {\n+            result = exec.execute(0, 3);\n+        }\n+        return MacHelper.readPList(result.byteStdout()).findValue(\"assessment:originator\");\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/MacSignVerify.java","additions":34,"deletions":17,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import static jdk.jpackage.internal.cli.StandardAppImageFileOption.MAC_SIGNED;\n@@ -517,1 +516,0 @@\n-                \"<signed>true<\/signed>\",\n@@ -549,2 +547,1 @@\n-                .addExtra(MAC_APP_STORE, false)\n-                .addExtra(MAC_SIGNED, true)).create());\n+                .addExtra(MAC_APP_STORE, false)).create());\n@@ -583,1 +580,0 @@\n-                        \"<signed>true<\/signed>\",\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/AppImageFileTest.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import jdk.jpackage.internal.cli.Validator.ParsedValue;\n+import jdk.jpackage.internal.cli.Validator.ValidatorException;\n@@ -155,0 +157,25 @@\n+    static final class RecordingValidator<T, U extends Exception> implements Validator<T, U> {\n+\n+        RecordingValidator(Validator<T, U> validator) {\n+            this.validator = Objects.requireNonNull(validator);\n+        }\n+\n+        @Override\n+        public List<U> validate(OptionName optionName, ParsedValue<T> optionValue) {\n+            counter++;\n+            return validator.validate(optionName, optionValue);\n+        }\n+\n+        int counter() {\n+            return counter;\n+        }\n+\n+        void resetCounter() {\n+            counter = 0;\n+        }\n+\n+        private final Validator<T, U> validator;\n+        private int counter;\n+    }\n+\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/TestUtils.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.Objects;\n@@ -38,0 +37,1 @@\n+import java.util.stream.Stream;\n@@ -39,0 +39,1 @@\n+import jdk.jpackage.internal.cli.TestUtils.RecordingValidator;\n@@ -190,13 +191,1 @@\n-    public void test_andThen() {\n-\n-        Function<String, Validator<String, Exception>> createFailingValidator = exceptionMessage -> {\n-            Objects.requireNonNull(exceptionMessage);\n-            var exceptionFactory = OptionValueExceptionFactory.build().ctor(TestException::new).messageFormatter((_, _) -> {\n-                return exceptionMessage;\n-            }).create();\n-\n-            return Validator.<String, Exception>build()\n-                    .predicate(_ -> false)\n-                    .formatString(\"\")\n-                    .exceptionFactory(exceptionFactory).create();\n-        };\n+    public void test_and() {\n@@ -208,1 +197,1 @@\n-        var pass = Validator.<String, RuntimeException>build().predicate(_ -> true).create();\n+        var pass = new RecordingValidator<>(Validator.<String, RuntimeException>build().predicate(_ -> true).create());\n@@ -210,3 +199,3 @@\n-        var foo = createFailingValidator.apply(\"foo\");\n-        var bar = createFailingValidator.apply(\"bar\");\n-        var buz = createFailingValidator.apply(\"buz\");\n+        var foo = failingValidator(\"foo\");\n+        var bar = failingValidator(\"bar\");\n+        var buz = failingValidator(\"buz\");\n@@ -218,1 +207,2 @@\n-        ),  validate.apply(foo.andThen(bar).andThen(pass).andThen(buz)));\n+        ), validate.apply(foo.and(bar).and(pass).and(buz)));\n+        assertEquals(1, pass.counter());\n@@ -220,0 +210,1 @@\n+        pass.resetCounter();\n@@ -224,1 +215,26 @@\n-        ),  validate.apply(pass.andThen(bar).andThen(buz).andThen(foo)));\n+        ), validate.apply(pass.and(bar).and(buz).and(foo)));\n+        assertEquals(1, pass.counter());\n+\n+        assertExceptionListEquals(List.of(\n+                new TestException(\"foo\"),\n+                new TestException(\"foo\")\n+        ), validate.apply(foo.and(foo)));\n+\n+        pass.resetCounter();\n+        assertExceptionListEquals(List.of(\n+        ), validate.apply(pass.and(pass)));\n+        assertEquals(2, pass.counter());\n+    }\n+\n+    @Test\n+    public void test_or() {\n+\n+        Function<Validator<String, ? extends Exception>, List<? extends Exception>> validate = validator -> {\n+            return validator.validate(OptionName.of(\"a\"), ParsedValue.create(\"str\", StringToken.of(\"str\")));\n+        };\n+\n+        var pass = new RecordingValidator<>(Validator.<String, RuntimeException>build().predicate(_ -> true).create());\n+\n+        var foo = new RecordingValidator<>(failingValidator(\"foo\"));\n+        var bar = new RecordingValidator<>(failingValidator(\"bar\"));\n+        var buz = new RecordingValidator<>(failingValidator(\"buz\"));\n@@ -226,0 +242,30 @@\n+        Runnable resetCounters = () -> {\n+            Stream.of(pass, foo, bar, buz).forEach(RecordingValidator::resetCounter);\n+        };\n+\n+        assertExceptionListEquals(List.of(\n+                new TestException(\"foo\"),\n+                new TestException(\"bar\"),\n+                new TestException(\"buz\")\n+        ), validate.apply(foo.or(bar).or(buz)));\n+        assertEquals(1, foo.counter());\n+        assertEquals(1, bar.counter());\n+        assertEquals(1, buz.counter());\n+\n+        resetCounters.run();\n+        assertExceptionListEquals(List.of(\n+        ), validate.apply(foo.or(bar).or(pass).or(buz)));\n+        assertEquals(1, foo.counter());\n+        assertEquals(1, bar.counter());\n+        assertEquals(1, pass.counter());\n+        assertEquals(0, buz.counter());\n+\n+        resetCounters.run();\n+        assertExceptionListEquals(List.of(\n+        ), validate.apply(pass.or(bar).or(buz).or(foo)));\n+        assertEquals(1, pass.counter());\n+        assertEquals(0, bar.counter());\n+        assertEquals(0, buz.counter());\n+        assertEquals(0, foo.counter());\n+\n+        resetCounters.run();\n@@ -229,1 +275,7 @@\n-        ),  validate.apply(foo.andThen(foo)));\n+        ), validate.apply(foo.or(foo)));\n+        assertEquals(2, foo.counter());\n+\n+        resetCounters.run();\n+        assertExceptionListEquals(List.of(\n+        ),  validate.apply(pass.or(pass)));\n+        assertEquals(1, pass.counter());\n@@ -272,0 +324,11 @@\n+    private static Validator<String, Exception> failingValidator(String exceptionMessage) {\n+        var exceptionFactory = OptionValueExceptionFactory.build().ctor(TestException::new).messageFormatter((_, _) -> {\n+            return exceptionMessage;\n+        }).create();\n+\n+        return Validator.<String, Exception>build()\n+                .predicate(_ -> false)\n+                .formatString(\"\")\n+                .exceptionFactory(exceptionFactory).create();\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/cli\/ValidatorTest.java","additions":85,"deletions":22,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.jpackage.internal.util.MacBundle;\n@@ -136,2 +137,1 @@\n-        Path appImageDir = TKit.createTempDirectory(\"appimage\");\n-        Files.createFile(appImageDir.resolve(\"foo\"));\n+        Path appImageDir = createInvalidAppImage();\n@@ -148,2 +148,1 @@\n-        Path appImageDir = TKit.createTempDirectory(\"appimage\");\n-        Files.createFile(appImageDir.resolve(\"foo\"));\n+        Path appImageDir = createInvalidAppImage();\n@@ -230,0 +229,15 @@\n+    private static Path createInvalidAppImage() throws IOException {\n+        Path appImageDir = TKit.createTempDirectory(\"appimage\");\n+        if (TKit.isOSX()) {\n+            \/\/ Create minimal macOS bundle to prevent jpackage bail out early\n+            \/\/ with \"error.parameter-not-mac-bundle\" error.\n+            var bundle = new MacBundle(appImageDir);\n+            Files.createDirectories(bundle.macOsDir());\n+            Files.createFile(bundle.infoPlistFile());\n+        } else {\n+            Files.createFile(appImageDir.resolve(\"foo\"));\n+        }\n+\n+        return appImageDir;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppImagePackageTest.java","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -646,1 +646,6 @@\n-                        .error(\"ERR_MissingJLinkOptMacAppStore\", \"--strip-native-commands\")\n+                        .error(\"ERR_MissingJLinkOptMacAppStore\", \"--strip-native-commands\"),\n+                \/\/ Predefined app image must be a valid macOS bundle.\n+                testSpec().noAppDesc().nativeType().addArgs(\"--app-image\", Token.EMPTY_DIR.token())\n+                        .error(\"error.parameter-not-mac-bundle\", JPackageCommand.cannedArgument(cmd -> {\n+                            return Path.of(cmd.getArgumentValue(\"--app-image\"));\n+                        }, Token.EMPTY_DIR.token()), \"--app-image\")\n","filename":"test\/jdk\/tools\/jpackage\/share\/ErrorTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}