{"files":[{"patch":"@@ -640,0 +640,6 @@\n+\/\/ Helper for [try_]collect().\n+static G1GCCounters collection_counters(G1CollectedHeap* g1h) {\n+  MutexLocker ml(Heap_lock);\n+  return G1GCCounters(g1h);\n+}\n+\n@@ -665,1 +671,1 @@\n-    collect(GCCause::_g1_humongous_allocation);\n+    try_collect(word_size, GCCause::_g1_humongous_allocation, collection_counters(this));\n@@ -675,0 +681,2 @@\n+    \/\/ The amount of bytes the humongous object will actually take.\n+    size_t humongous_byte_size = G1HeapRegion::align_up_to_region_byte_size(word_size * HeapWordSize);\n@@ -679,1 +687,0 @@\n-      size_t size_in_regions = humongous_obj_size_in_regions(word_size);\n@@ -686,1 +693,1 @@\n-          add_allocated_humongous_bytes_since_last_gc(size_in_regions * G1HeapRegion::GrainBytes);\n+          add_allocated_humongous_bytes_since_last_gc(humongous_byte_size);\n@@ -700,1 +707,0 @@\n-        size_t size_in_regions = humongous_obj_size_in_regions(word_size);\n@@ -702,1 +708,1 @@\n-          record_collection_pause_humongous_allocation(size_in_regions * G1HeapRegion::GrainBytes);\n+          record_collection_pause_humongous_allocation(humongous_byte_size);\n@@ -745,1 +751,3 @@\n-    if (result != nullptr && policy()->need_to_start_conc_mark(\"STW humongous allocation\")) {\n+    if (result != nullptr &&\n+        \/\/ We just allocated the humongous object, so the given allocation size is 0.\n+        policy()->need_to_start_conc_mark(\"STW humongous allocation\", 0 \/* allocation_word_size *\/)) {\n@@ -884,3 +892,3 @@\n-void G1CollectedHeap::do_full_collection(bool clear_all_soft_refs,\n-                                         bool do_maximal_compaction,\n-                                         size_t allocation_word_size) {\n+void G1CollectedHeap::do_full_collection(size_t allocation_word_size,\n+                                         bool clear_all_soft_refs,\n+                                         bool do_maximal_compaction) {\n@@ -903,3 +911,3 @@\n-  do_full_collection(clear_all_soft_refs,\n-                     false \/* do_maximal_compaction *\/,\n-                     size_t(0) \/* allocation_word_size *\/);\n+  do_full_collection(size_t(0) \/* allocation_word_size *\/,\n+                     clear_all_soft_refs,\n+                     false \/* do_maximal_compaction *\/);\n@@ -911,3 +919,3 @@\n-  do_full_collection(true  \/* clear_all_soft_refs *\/,\n-                     false \/* do_maximal_compaction *\/,\n-                     size_t(0) \/* allocation_word_size *\/);\n+  do_full_collection(size_t(0) \/* allocation_word_size *\/,\n+                     true  \/* clear_all_soft_refs *\/,\n+                     false \/* do_maximal_compaction *\/);\n@@ -982,3 +990,3 @@\n-    do_full_collection(maximal_compaction \/* clear_all_soft_refs *\/,\n-                       maximal_compaction \/* do_maximal_compaction *\/,\n-                       word_size \/* allocation_word_size *\/);\n+    do_full_collection(word_size \/* allocation_word_size *\/,\n+                       maximal_compaction \/* clear_all_soft_refs *\/,\n+                       maximal_compaction \/* do_maximal_compaction *\/);\n@@ -1774,6 +1782,0 @@\n-\/\/ Helper for collect().\n-static G1GCCounters collection_counters(G1CollectedHeap* g1h) {\n-  MutexLocker ml(Heap_lock);\n-  return G1GCCounters(g1h);\n-}\n-\n@@ -1781,1 +1783,1 @@\n-  try_collect(cause, collection_counters(this));\n+  try_collect(0 \/* allocation_word_size *\/, cause, collection_counters(this));\n@@ -1867,1 +1869,2 @@\n-bool G1CollectedHeap::try_collect_concurrently(GCCause::Cause cause,\n+bool G1CollectedHeap::try_collect_concurrently(size_t allocation_word_size,\n+                                               GCCause::Cause cause,\n@@ -1878,1 +1881,1 @@\n-    VM_G1TryInitiateConcMark op(gc_counter, cause);\n+    VM_G1TryInitiateConcMark op(allocation_word_size, gc_counter, cause);\n@@ -1928,0 +1931,1 @@\n+      assert(allocation_word_size == 0, \"must be\");\n@@ -2025,1 +2029,2 @@\n-bool G1CollectedHeap::try_collect(GCCause::Cause cause,\n+bool G1CollectedHeap::try_collect(size_t allocation_word_size,\n+                                  GCCause::Cause cause,\n@@ -2028,1 +2033,2 @@\n-    return try_collect_concurrently(cause,\n+    return try_collect_concurrently(allocation_word_size,\n+                                    cause,\n@@ -2034,0 +2040,1 @@\n+    assert(allocation_word_size == 0, \"must be\");\n@@ -2042,0 +2049,3 @@\n+    \/\/ The only path to get here is because of a periodic collection using a Full GC\n+    \/\/ or WhiteBox full gc.\n+    assert(allocation_word_size == 0, \"must be\");\n@@ -2058,1 +2068,1 @@\n-    do_collection_pause_at_safepoint();\n+    do_collection_pause_at_safepoint(0 \/* allocation_word_size *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":40,"deletions":30,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -299,1 +299,2 @@\n-  \/\/ Attempt to start a concurrent cycle with the indicated cause.\n+  \/\/ Attempt to start a concurrent cycle with the indicated cause, for potentially\n+  \/\/ allocating allocation_word_size words.\n@@ -301,1 +302,2 @@\n-  bool try_collect_concurrently(GCCause::Cause cause,\n+  bool try_collect_concurrently(size_t allocation_word_size,\n+                                GCCause::Cause cause,\n@@ -507,3 +509,3 @@\n-  void do_full_collection(bool clear_all_soft_refs,\n-                          bool do_maximal_compaction,\n-                          size_t allocation_word_size);\n+  void do_full_collection(size_t allocation_word_size,\n+                          bool clear_all_soft_refs,\n+                          bool do_maximal_compaction);\n@@ -761,3 +763,3 @@\n-  HeapWord* do_collection_pause(size_t         word_size,\n-                                uint           gc_count_before,\n-                                bool*          succeeded,\n+  HeapWord* do_collection_pause(size_t word_size,\n+                                uint gc_count_before,\n+                                bool* succeeded,\n@@ -766,2 +768,3 @@\n-  \/\/ Perform an incremental collection at a safepoint, possibly\n-  \/\/ followed by a by-policy upgrade to a full collection.\n+  \/\/ Perform an incremental collection at a safepoint, possibly followed by a\n+  \/\/ by-policy upgrade to a full collection.\n+  \/\/ The collection should expect to be followed by an allocation of allocation_word_size.\n@@ -770,1 +773,1 @@\n-  void do_collection_pause_at_safepoint(size_t allocation_word_size = 0);\n+  void do_collection_pause_at_safepoint(size_t allocation_word_size);\n@@ -1040,1 +1043,2 @@\n-  \/\/ Perform a collection of the heap with the given cause.\n+  \/\/ Try to perform a collection of the heap with the given cause to allocate allocation_word_size\n+  \/\/ words.\n@@ -1042,1 +1046,1 @@\n-  bool try_collect(GCCause::Cause cause, const G1GCCounters& counters_before);\n+  bool try_collect(size_t allocation_word_size, GCCause::Cause cause, const G1GCCounters& counters_before);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-  _heap->policy()->record_full_collection_end();\n+  _heap->policy()->record_full_collection_end(allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    if (!g1h->try_collect(GCCause::_g1_periodic_collection, counters)) {\n+    if (!g1h->try_collect(0 \/* allocation_word_size *\/, GCCause::_g1_periodic_collection, counters)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PeriodicGCTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -569,1 +569,1 @@\n-void G1Policy::record_full_collection_end() {\n+void G1Policy::record_full_collection_end(size_t allocation_word_size) {\n@@ -580,1 +580,1 @@\n-  collector_state()->set_initiate_conc_mark_if_possible(need_to_start_conc_mark(\"end of Full GC\"));\n+  collector_state()->set_initiate_conc_mark_if_possible(need_to_start_conc_mark(\"end of Full GC\", allocation_word_size));\n@@ -746,1 +746,1 @@\n-bool G1Policy::need_to_start_conc_mark(const char* source, size_t alloc_word_size) {\n+bool G1Policy::need_to_start_conc_mark(const char* source, size_t allocation_word_size) {\n@@ -754,2 +754,7 @@\n-  size_t alloc_byte_size = alloc_word_size * HeapWordSize;\n-  size_t marking_request_bytes = cur_used_bytes + alloc_byte_size;\n+  size_t allocation_byte_size = allocation_word_size * HeapWordSize;\n+  \/\/ For humongous allocations, we need to consider that we actually use full regions\n+  \/\/ for allocations. So compare the threshold to this size.\n+  if (_g1h->is_humongous(allocation_word_size)) {\n+    allocation_byte_size = G1HeapRegion::align_up_to_region_byte_size(allocation_byte_size);\n+  }\n+  size_t marking_request_bytes = cur_used_bytes + allocation_byte_size;\n@@ -762,1 +767,1 @@\n-                              cur_used_bytes, alloc_byte_size, marking_initiating_used_threshold, (double) marking_initiating_used_threshold \/ _g1h->capacity() * 100, source);\n+                              cur_used_bytes, allocation_byte_size, marking_initiating_used_threshold, (double) marking_initiating_used_threshold \/ _g1h->capacity() * 100, source);\n@@ -767,1 +772,1 @@\n-bool G1Policy::concurrent_operation_is_full_mark(const char* msg) {\n+bool G1Policy::concurrent_operation_is_full_mark(const char* msg, size_t allocation_word_size) {\n@@ -769,1 +774,1 @@\n-    ((_g1h->gc_cause() != GCCause::_g1_humongous_allocation) || need_to_start_conc_mark(msg));\n+    ((_g1h->gc_cause() != GCCause::_g1_humongous_allocation) || need_to_start_conc_mark(msg, allocation_word_size));\n@@ -798,1 +803,3 @@\n-void G1Policy::record_young_collection_end(bool concurrent_operation_is_full_mark, bool allocation_failure) {\n+void G1Policy::record_young_collection_end(bool concurrent_operation_is_full_mark,\n+                                           bool allocation_failure,\n+                                           size_t allocation_word_size) {\n@@ -811,1 +818,1 @@\n-    maybe_start_marking();\n+    maybe_start_marking(allocation_word_size);\n@@ -968,1 +975,1 @@\n-      maybe_start_marking();\n+      maybe_start_marking(allocation_word_size);\n@@ -1371,2 +1378,2 @@\n-void G1Policy::maybe_start_marking() {\n-  if (need_to_start_conc_mark(\"end of GC\")) {\n+void G1Policy::maybe_start_marking(size_t allocation_word_size) {\n+  if (need_to_start_conc_mark(\"end of GC\", allocation_word_size)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-  void maybe_start_marking();\n+  void maybe_start_marking(size_t allocation_word_size);\n@@ -310,1 +310,1 @@\n-  bool need_to_start_conc_mark(const char* source, size_t alloc_word_size = 0);\n+  bool need_to_start_conc_mark(const char* source, size_t allocation_word_size);\n@@ -312,1 +312,1 @@\n-  bool concurrent_operation_is_full_mark(const char* msg = nullptr);\n+  bool concurrent_operation_is_full_mark(const char* msg, size_t allocation_word_size);\n@@ -319,1 +319,3 @@\n-  void record_young_collection_end(bool concurrent_operation_is_full_mark, bool allocation_failure);\n+  void record_young_collection_end(bool concurrent_operation_is_full_mark,\n+                                   bool allocation_failure,\n+                                   size_t allocation_word_size);\n@@ -323,1 +325,1 @@\n-  void record_full_collection_end();\n+  void record_full_collection_end(size_t allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,3 +55,3 @@\n-  g1h->do_full_collection(clear_all_soft_refs \/* clear_all_soft_refs *\/,\n-                          false \/* do_maximal_compaction *\/,\n-                          size_t(0) \/* allocation_word_size *\/);\n+  g1h->do_full_collection(size_t(0) \/* allocation_word_size *\/,\n+                          clear_all_soft_refs,\n+                          false \/* do_maximal_compaction *\/);\n@@ -60,1 +60,2 @@\n-VM_G1TryInitiateConcMark::VM_G1TryInitiateConcMark(uint gc_count_before,\n+VM_G1TryInitiateConcMark::VM_G1TryInitiateConcMark(size_t allocation_word_size,\n+                                                   uint gc_count_before,\n@@ -63,0 +64,1 @@\n+  _word_size(allocation_word_size),\n@@ -100,1 +102,1 @@\n-    g1h->do_collection_pause_at_safepoint();\n+    g1h->do_collection_pause_at_safepoint(_word_size);\n@@ -105,2 +107,2 @@\n-VM_G1CollectForAllocation::VM_G1CollectForAllocation(size_t         word_size,\n-                                                     uint           gc_count_before,\n+VM_G1CollectForAllocation::VM_G1CollectForAllocation(size_t word_size,\n+                                                     uint gc_count_before,\n@@ -114,1 +116,1 @@\n-  g1h->do_collection_pause_at_safepoint();\n+  g1h->do_collection_pause_at_safepoint(_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  size_t _word_size;\n@@ -56,1 +57,2 @@\n-  VM_G1TryInitiateConcMark(uint gc_count_before,\n+  VM_G1TryInitiateConcMark(size_t word_size,\n+                           uint gc_count_before,\n@@ -71,2 +73,2 @@\n-  VM_G1CollectForAllocation(size_t         word_size,\n-                            uint           gc_count_before,\n+  VM_G1CollectForAllocation(size_t word_size,\n+                            uint gc_count_before,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1186,1 +1186,1 @@\n-    _concurrent_operation_is_full_mark = policy()->concurrent_operation_is_full_mark(\"Revise IHOP\");\n+    _concurrent_operation_is_full_mark = policy()->concurrent_operation_is_full_mark(\"Revise IHOP\", _allocation_word_size);\n@@ -1192,1 +1192,1 @@\n-    policy()->record_young_collection_end(_concurrent_operation_is_full_mark, evacuation_alloc_failed());\n+    policy()->record_young_collection_end(_concurrent_operation_is_full_mark, evacuation_alloc_failed(), _allocation_word_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}