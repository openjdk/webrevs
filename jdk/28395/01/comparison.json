{"files":[{"patch":"@@ -101,0 +101,1 @@\n+import jdk.internal.net.http.common.Utils.UseVTForSelector;\n@@ -129,0 +130,10 @@\n+    static final UseVTForSelector USE_VT_FOR_SELECTOR =\n+        Utils.useVTForSelector(\"jdk.internal.httpclient.tcp.selector.useVirtualThreads\", \"default\");\n+    private static boolean useVtForSelector() {\n+        return switch (USE_VT_FOR_SELECTOR) {\n+            case ALWAYS -> true;\n+            case NEVER -> false;\n+            default -> true;\n+        };\n+    }\n+\n@@ -296,1 +307,0 @@\n-        var cf = pending.cf;\n@@ -345,0 +355,1 @@\n+    private final Thread selmgrThread;\n@@ -512,1 +523,5 @@\n-        selmgr.setDaemon(true);\n+        selmgrThread = useVtForSelector()\n+                ? Thread.ofVirtual().name(\"HttpClient-\" + id + \"-SelectorManager\")\n+                .inheritInheritableThreadLocals(false).unstarted(selmgr)\n+                : Thread.ofPlatform().name(\"HttpClient-\" + id + \"-SelectorManager\")\n+                .inheritInheritableThreadLocals(false).daemon().unstarted(selmgr);\n@@ -531,1 +546,1 @@\n-            selmgr.start();\n+            selmgrThread.start();\n@@ -638,1 +653,1 @@\n-        return selmgr.join(duration);\n+        return selmgrThread.join(duration);\n@@ -930,1 +945,1 @@\n-        return Thread.currentThread() == selmgr;\n+        return Thread.currentThread() == selmgrThread;\n@@ -1160,1 +1175,1 @@\n-    private static final class SelectorManager extends Thread {\n+    private static final class SelectorManager implements Runnable {\n@@ -1199,3 +1214,0 @@\n-            super(null, null,\n-                  \"HttpClient-\" + ref.id + \"-SelectorManager\",\n-                  0, false);\n@@ -1224,1 +1236,1 @@\n-            if (Thread.currentThread() == this) {\n+            if (owner.isSelectorThread()) {\n@@ -1318,0 +1330,4 @@\n+        String getName() {\n+            return owner.selmgrThread.getName();\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -245,0 +245,9 @@\n+    public enum UseVTForSelector { ALWAYS, NEVER, DEFAULT }\n+\n+    public static UseVTForSelector useVTForSelector(String property, String defval) {\n+        String useVtForSelector = System.getProperty(property, defval);\n+        return Stream.of(UseVTForSelector.values())\n+                .filter((v) -> v.name().equalsIgnoreCase(useVtForSelector))\n+                .findFirst().orElse(UseVTForSelector.DEFAULT);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Utils.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -146,0 +146,1 @@\n+        var label = \"quic:\" + connection.uniqueId();\n@@ -147,1 +148,1 @@\n-                + (peerIsServer ? \"server\" : \"client\") + \")\");\n+                + (peerIsServer ? \"server\" : \"client\") + \") on \" + label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/ConnectionTerminatorImpl.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -349,2 +349,4 @@\n-        final TerminationCause cause = forSilentTermination(\"connection idle timed out (\"\n-                + timeoutMillis + \" milli seconds)\");\n+        var type = connection.isClientConnection() ? \"client\" : \"server\";\n+        var label = \"quic:\" + connection.uniqueId();\n+        final TerminationCause cause = forSilentTermination(type + \" connection idle timed out (\"\n+                + timeoutMillis + \" milli seconds) on \" + label);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/IdleTimeoutManager.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import jdk.internal.net.http.common.Utils.UseVTForSelector;\n@@ -119,1 +120,0 @@\n-    enum UseVTForSelector { ALWAYS, NEVER, DEFAULT }\n@@ -147,5 +147,2 @@\n-        String useVtForSelector =\n-                System.getProperty(\"jdk.internal.httpclient.quic.selector.useVirtualThreads\", \"default\");\n-        USE_VT_FOR_SELECTOR = Stream.of(UseVTForSelector.values())\n-                .filter((v) -> v.name().equalsIgnoreCase(useVtForSelector))\n-                .findFirst().orElse(UseVTForSelector.DEFAULT);\n+        var property = \"jdk.internal.httpclient.quic.selector.useVirtualThreads\";\n+        USE_VT_FOR_SELECTOR = Utils.useVTForSelector(property, \"default\");\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicEndpoint.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import jdk.internal.net.http.common.Utils.UseVTForSelector;\n@@ -50,1 +51,0 @@\n-import jdk.internal.net.http.quic.QuicEndpoint.UseVTForSelector;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/quic\/QuicSelector.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -393,6 +393,0 @@\n-    private boolean isSelectorManager(Thread t) {\n-        String name = t.getName();\n-        if (name == null) return false;\n-        return name.contains(\"SelectorManager\");\n-    }\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.test.lib.net.SimpleSSLContext;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Assertions;\n+\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.net.http.HttpClient.Version.HTTP_3;\n+import static java.net.http.HttpOption.H3_DISCOVERY;\n+import static java.net.http.HttpOption.Http3DiscoveryMode.HTTP_3_URI_ONLY;\n+\n+\/*\n+ * @test id=default\n+ * @bug 8372159\n+ * @summary Verifies whether `SelectorManager` uses virtual threads\n+ *          as expected when no explicit configuration is provided\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors\n+ *              H2SelectorVTTest\n+ *\/\n+\/*\n+ * @test id=never\n+ * @bug 8372159\n+ * @summary Verifies that `SelectorManager` does *not* use virtual threads\n+            when explicitly configured to \"never\" use them\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.internal.httpclient.tcp.selector.useVirtualThreads=never\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors\n+ *              H2SelectorVTTest\n+ *\/\n+\/*\n+ * @test id=always\n+ * @bug 8372159\n+ * @summary Verifies that `SelectorManager` does *always* use virtual threads\n+            when explicitly configured to \"always\" use them\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.internal.httpclient.tcp.selector.useVirtualThreads=always\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors\n+ *              H2SelectorVTTest\n+ *\/\n+\/*\n+ * @test id=explicit-default\n+ * @bug 8372159\n+ * @summary Verifies whether `SelectorManager` uses virtual threads\n+ *          as expected when `default` is explicitly configured\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.internal.httpclient.tcp.selector.useVirtualThreads=default\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors\n+ *              H2SelectorVTTest\n+ *\/\n+\/*\n+ * @test id=garbage\n+ * @bug 8372159\n+ * @summary Verifies whether `SelectorManager` uses virtual threads when\n+            it is configured using an invalid value\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ *        jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @run junit\/othervm\n+ *              -Djdk.internal.httpclient.tcp.selector.useVirtualThreads=garbage\n+ *              -Djdk.httpclient.HttpClient.log=requests,responses,headers,errors\n+ *              H2SelectorVTTest\n+ *\/\n+\/\/ -Djava.security.debug=all\n+class H2SelectorVTTest implements HttpServerAdapters {\n+\n+    private static SSLContext sslContext;\n+    private static HttpTestServer h2Server;\n+    private static String requestURI;\n+\n+    enum UseVTForSelector { ALWAYS, NEVER, DEFAULT }\n+    private static final String PROP_NAME = \"jdk.internal.httpclient.tcp.selector.useVirtualThreads\";\n+    private static final UseVTForSelector USE_VT_FOR_SELECTOR;\n+    static {\n+        String useVtForSelector =\n+                System.getProperty(PROP_NAME, \"default\");\n+        USE_VT_FOR_SELECTOR = Stream.of(UseVTForSelector.values())\n+                .filter((v) -> v.name().equalsIgnoreCase(useVtForSelector))\n+                .findFirst().orElse(UseVTForSelector.DEFAULT);\n+    }\n+\n+    private static boolean isTCPSelectorThreadVirtual() {\n+        return switch (USE_VT_FOR_SELECTOR) {\n+            case ALWAYS -> true;\n+            case NEVER  -> false;\n+            default     -> true;\n+        };\n+    }\n+\n+    @BeforeAll\n+    static void beforeClass() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null) {\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+        }\n+        \/\/ create an H3 only server\n+        h2Server = HttpTestServer.create(HTTP_2, sslContext);\n+        h2Server.addHandler((exchange) -> exchange.sendResponseHeaders(200, 0), \"\/hello\");\n+        h2Server.start();\n+        System.out.println(\"Server started at \" + h2Server.getAddress());\n+        requestURI = \"https:\/\/\" + h2Server.serverAuthority() + \"\/hello\";\n+    }\n+\n+    @AfterAll\n+    static void afterClass() throws Exception {\n+        if (h2Server != null) {\n+            System.out.println(\"Stopping server \" + h2Server.getAddress());\n+            h2Server.stop();\n+        }\n+    }\n+\n+    \/**\n+     * Issues various HTTP\/2 requests and verifies the responses are received\n+     *\/\n+    @Test\n+    void testBasicRequests() throws Exception {\n+        try (final HttpClient client = HttpClient.newBuilder()\n+                .proxy(NO_PROXY)\n+                .sslContext(sslContext).build()) {\n+            final URI reqURI = new URI(requestURI);\n+            final HttpRequest.Builder reqBuilder = HttpRequest.newBuilder(reqURI);\n+\n+            \/\/ GET\n+            final HttpRequest req1 = reqBuilder.copy().GET().build();\n+            System.out.println(\"\\nIssuing request: \" + req1);\n+            final HttpResponse<?> resp1 = client.send(req1, BodyHandlers.ofString());\n+            Assertions.assertEquals(200, resp1.statusCode(), \"unexpected response code for GET request\");\n+            assertSelectorThread(client);\n+\n+            \/\/ POST\n+            final HttpRequest req2 = reqBuilder.copy().POST(BodyPublishers.ofString(\"foo\")).build();\n+            System.out.println(\"\\nIssuing request: \" + req2);\n+            final HttpResponse<?> resp2 = client.send(req2, BodyHandlers.ofString());\n+            Assertions.assertEquals(200, resp2.statusCode(), \"unexpected response code for POST request\");\n+            assertSelectorThread(client);\n+\n+            \/\/ HEAD\n+            final HttpRequest req3 = reqBuilder.copy().HEAD().build();\n+            System.out.println(\"\\nIssuing request: \" + req3);\n+            final HttpResponse<?> resp3 = client.send(req3, BodyHandlers.ofString());\n+            Assertions.assertEquals(200, resp3.statusCode(), \"unexpected response code for HEAD request\");\n+            assertSelectorThread(client);\n+        }\n+    }\n+\n+    private static void assertSelectorThread(HttpClient client) {\n+        String cname = client.toString();\n+        String clientId = cname.substring(cname.indexOf('(') + 1, cname.length() -1);\n+        String name = \"HttpClient-\" + clientId + \"-SelectorManager\";\n+        Set<String> threads = new HashSet<>(Thread.getAllStackTraces().keySet().stream()\n+                .map(Thread::getName)\n+                .toList());\n+        boolean found = threads.contains(name);\n+        String status = found == isTCPSelectorThreadVirtual() ? \"ERROR\" : \"SUCCESS\";\n+        String propval = System.getProperty(PROP_NAME);\n+        if (propval == null) {\n+            System.out.printf(\"%s not defined, virtual=%s, thread found=%s%n\",\n+                    PROP_NAME, isTCPSelectorThreadVirtual(), found);\n+        } else {\n+            System.out.printf(\"%s=%s, virtual=%s, thread found=%s%n\",\n+                    PROP_NAME, propval, isTCPSelectorThreadVirtual(), found);\n+        }\n+        final String msg;\n+        if (found) {\n+            msg = \"%s found in %s\".formatted(name, threads);\n+            System.out.printf(\"%s: %s%n\", status, msg);\n+        } else {\n+            msg = \"%s not found in %s\".formatted(name, threads);\n+            System.out.printf(\"%s: %s%n\", status, msg);\n+        }\n+        Assertions.assertEquals(!isTCPSelectorThreadVirtual(), found, msg);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/H2SelectorVTTest.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"}]}