{"files":[{"patch":"@@ -105,0 +105,10 @@\n+    \/**\n+     * {@return the constant pool entry of a given type whose index is given\n+     * at the specified offset within the classfile}\n+     * @param offset the offset of the index within the classfile\n+     * @param cls the entry type\n+     * @throws ConstantPoolException if the index is out of range of the\n+     *         constant pool size, or zero, or the entry is not of the given type\n+     *\/\n+    <T extends PoolEntry> T readEntry(int offset, Class<T> cls);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/ClassReader.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,0 +41,5 @@\n+    \/**\n+     * {@return index of the entry in the bootstrap method table for this constant}\n+     *\/\n+    int bootstrapMethodIndex();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/constantpool\/DynamicConstantPoolEntry.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-                fieldEntry = (FieldRefEntry) code.classReader.readEntry(pos + 1);\n+                fieldEntry = code.classReader.readEntry(pos + 1, FieldRefEntry.class);\n@@ -416,1 +416,1 @@\n-                methodEntry = (MemberRefEntry) code.classReader.readEntry(pos + 1);\n+                methodEntry = code.classReader.readEntry(pos + 1, MemberRefEntry.class);\n@@ -456,1 +456,1 @@\n-                methodEntry = (InterfaceMethodRefEntry) code.classReader.readEntry(pos + 1);\n+                methodEntry = code.classReader.readEntry(pos + 1, InterfaceMethodRefEntry.class);\n@@ -496,1 +496,1 @@\n-                indyEntry = (InvokeDynamicEntry) code.classReader.readEntry(pos + 1);\n+                indyEntry = code.classReader.readEntry(pos + 1, InvokeDynamicEntry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -818,0 +818,7 @@\n+        \/**\n+         * @return the bsmIndex\n+         *\/\n+        public int bootstrapMethodIndex() {\n+            return bsmIndex;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,8 +61,8 @@\n-            case AEV_BYTE -> new AnnotationImpl.OfByteImpl((IntegerEntry)classReader.readEntry(p));\n-            case AEV_CHAR -> new AnnotationImpl.OfCharacterImpl((IntegerEntry)classReader.readEntry(p));\n-            case AEV_DOUBLE -> new AnnotationImpl.OfDoubleImpl((DoubleEntry)classReader.readEntry(p));\n-            case AEV_FLOAT -> new AnnotationImpl.OfFloatImpl((FloatEntry)classReader.readEntry(p));\n-            case AEV_INT -> new AnnotationImpl.OfIntegerImpl((IntegerEntry)classReader.readEntry(p));\n-            case AEV_LONG -> new AnnotationImpl.OfLongImpl((LongEntry)classReader.readEntry(p));\n-            case AEV_SHORT -> new AnnotationImpl.OfShortImpl((IntegerEntry)classReader.readEntry(p));\n-            case AEV_BOOLEAN -> new AnnotationImpl.OfBooleanImpl((IntegerEntry)classReader.readEntry(p));\n+            case AEV_BYTE -> new AnnotationImpl.OfByteImpl(classReader.readEntry(p, IntegerEntry.class));\n+            case AEV_CHAR -> new AnnotationImpl.OfCharacterImpl(classReader.readEntry(p, IntegerEntry.class));\n+            case AEV_DOUBLE -> new AnnotationImpl.OfDoubleImpl(classReader.readEntry(p, DoubleEntry.class));\n+            case AEV_FLOAT -> new AnnotationImpl.OfFloatImpl(classReader.readEntry(p, FloatEntry.class));\n+            case AEV_INT -> new AnnotationImpl.OfIntegerImpl(classReader.readEntry(p, IntegerEntry.class));\n+            case AEV_LONG -> new AnnotationImpl.OfLongImpl(classReader.readEntry(p, LongEntry.class));\n+            case AEV_SHORT -> new AnnotationImpl.OfShortImpl(classReader.readEntry(p, IntegerEntry.class));\n+            case AEV_BOOLEAN -> new AnnotationImpl.OfBooleanImpl(classReader.readEntry(p, IntegerEntry.class));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -486,1 +486,1 @@\n-            return (ConstantValueEntry) classReader.readEntry(payloadStart);\n+            return classReader.readEntry(payloadStart, ConstantValueEntry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.Collection;\n@@ -40,4 +39,0 @@\n-import jdk.internal.classfile.constantpool.MethodHandleEntry;\n-import jdk.internal.classfile.constantpool.ModuleEntry;\n-import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n-import jdk.internal.classfile.constantpool.PackageEntry;\n@@ -64,0 +59,4 @@\n+import jdk.internal.classfile.constantpool.MethodHandleEntry;\n+import jdk.internal.classfile.constantpool.ModuleEntry;\n+import jdk.internal.classfile.constantpool.NameAndTypeEntry;\n+import jdk.internal.classfile.constantpool.PackageEntry;\n@@ -159,1 +158,1 @@\n-            thisClass = readClassEntry(thisClassPos);\n+            thisClass = readEntry(thisClassPos, ClassEntry.class);\n@@ -394,0 +393,7 @@\n+    @Override\n+    public <T extends PoolEntry> T readEntry(int pos, Class<T> cls) {\n+        var e = readEntry(pos);\n+        if (cls.isInstance(e)) return cls.cast(e);\n+        throw new ConstantPoolException(\"Not a \" + cls.getSimpleName() + \" at index: \" + readU2(pos));\n+    }\n+\n@@ -420,2 +426,1 @@\n-        if (readEntry(pos) instanceof ModuleEntry me) return me;\n-        throw new ConstantPoolException(\"Not a module entry at pos: \" + pos);\n+        return readEntry(pos, ModuleEntry.class);\n@@ -426,2 +431,1 @@\n-        if (readEntry(pos) instanceof PackageEntry pe) return pe;\n-        throw new ConstantPoolException(\"Not a package entry at pos: \" + pos);\n+        return readEntry(pos, PackageEntry.class);\n@@ -432,2 +436,1 @@\n-        if (readEntry(pos) instanceof ClassEntry ce) return ce;\n-        throw new ConstantPoolException(\"Not a class entry at pos: \" + pos);\n+        return readEntry(pos, ClassEntry.class);\n@@ -438,2 +441,1 @@\n-        if (readEntry(pos) instanceof NameAndTypeEntry nate) return nate;\n-        throw new ConstantPoolException(\"Not a name and type entry at pos: \" + pos);\n+        return readEntry(pos, NameAndTypeEntry.class);\n@@ -444,2 +446,1 @@\n-        if (readEntry(pos) instanceof MethodHandleEntry mhe) return mhe;\n-        throw new ConstantPoolException(\"Not a method handle entry at pos: \" + pos);\n+        return readEntry(pos, MethodHandleEntry.class);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassReaderImpl.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -189,0 +189,1 @@\n+        jdk.jdeps,\n@@ -193,0 +194,1 @@\n+        jdk.jdeps,\n@@ -196,0 +198,1 @@\n+        jdk.jdeps,\n@@ -198,0 +201,1 @@\n+        jdk.jdeps,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,11 +28,8 @@\n-import com.sun.tools.classfile.Annotation;\n-import com.sun.tools.classfile.TypeAnnotation;\n-import com.sun.tools.classfile.Annotation.Annotation_element_value;\n-import com.sun.tools.classfile.Annotation.Array_element_value;\n-import com.sun.tools.classfile.Annotation.Class_element_value;\n-import com.sun.tools.classfile.Annotation.Enum_element_value;\n-import com.sun.tools.classfile.Annotation.Primitive_element_value;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n+import java.util.List;\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.TypeAnnotation;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n@@ -71,1 +68,1 @@\n-        writeDescriptor(annot.type_index, resolveIndices);\n+        writeDescriptor(annot.className(), resolveIndices);\n@@ -73,1 +70,1 @@\n-            boolean showParens = annot.num_element_value_pairs > 0;\n+            boolean showParens = annot.elements().size() > 0;\n@@ -78,2 +75,2 @@\n-            for (int i = 0; i < annot.num_element_value_pairs; i++) {\n-                write(annot.element_value_pairs[i], true);\n+            for (var element : annot.elements()) {\n+                write(element, true);\n@@ -88,1 +85,1 @@\n-            for (int i = 0; i < annot.num_element_value_pairs; i++) {\n+            for (int i = 0; i < annot.elements().size(); i++) {\n@@ -91,1 +88,1 @@\n-                write(annot.element_value_pairs[i], false);\n+                write(annot.elements().get(i), false);\n@@ -97,2 +94,2 @@\n-    public void write(TypeAnnotation annot) {\n-        write(annot, true, false);\n+    public void write(TypeAnnotation annot, CodeAttribute lr) {\n+        write(annot, true, false, lr);\n@@ -101,1 +98,1 @@\n-        write(annot.annotation, true);\n+        write(annot, true);\n@@ -105,2 +102,3 @@\n-    public void write(TypeAnnotation annot, boolean showOffsets, boolean resolveIndices) {\n-        write(annot.annotation, resolveIndices);\n+    public void write(TypeAnnotation annot, boolean showOffsets,\n+            boolean resolveIndices, CodeAttribute lr) {\n+        write(annot, resolveIndices);\n@@ -108,1 +106,1 @@\n-        write(annot.position, showOffsets);\n+        write(annot.targetInfo(), annot.targetPath(), showOffsets, lr);\n@@ -111,2 +109,4 @@\n-    public void write(TypeAnnotation.Position pos, boolean showOffsets) {\n-        print(pos.type);\n+    public void write(TypeAnnotation.TargetInfo targetInfo,\n+            List<TypeAnnotation.TypePathComponent> targetPath,\n+            boolean showOffsets, CodeAttribute lr) {\n+        print(targetInfo.targetType());\n@@ -114,11 +114,45 @@\n-        switch (pos.type) {\n-        \/\/ instanceof\n-        case INSTANCEOF:\n-        \/\/ new expression\n-        case NEW:\n-        \/\/ constructor\/method reference receiver\n-        case CONSTRUCTOR_REFERENCE:\n-        case METHOD_REFERENCE:\n-            if (showOffsets) {\n-                print(\", offset=\");\n-                print(pos.offset);\n+        switch (targetInfo) {\n+            \/\/ instanceof\n+            \/\/ new expression\n+            \/\/ constructor\/method reference receiver\n+            case TypeAnnotation.OffsetTarget pos -> {\n+                if (showOffsets) {\n+                    print(\", offset=\");\n+                    print(lr.labelToBci(pos.target()));\n+                }\n+            }\n+            case TypeAnnotation.LocalVarTarget pos -> {\n+                if (pos.table().isEmpty()) {\n+                    print(\", lvarOffset is Null!\");\n+                    break;\n+                }\n+                print(\", {\");\n+                var table = pos.table();\n+                for (int i = 0; i < table.size(); ++i) {\n+                    var e = table.get(i);\n+                    if (i != 0) print(\"; \");\n+                    int startPc = lr.labelToBci(e.startLabel());\n+                    if (showOffsets) {\n+                        print(\"start_pc=\");\n+                        print(startPc);\n+                    }\n+                    print(\", length=\");\n+                    print(lr.labelToBci(e.endLabel()) - startPc);\n+                    print(\", index=\");\n+                    print(e.index());\n+                }\n+                print(\"}\");\n+            }\n+            case TypeAnnotation.CatchTarget pos -> {\n+                print(\", exception_index=\");\n+                print(pos.exceptionTableIndex());\n+            }\n+            case TypeAnnotation.TypeParameterTarget pos -> {\n+                print(\", param_index=\");\n+                print(pos.typeParameterIndex());\n+            }\n+            case TypeAnnotation.TypeParameterBoundTarget pos -> {\n+                print(\", param_index=\");\n+                print(pos.typeParameterIndex());\n+                print(\", bound_index=\");\n+                print(pos.boundIndex());\n@@ -126,8 +160,3 @@\n-            break;\n-        \/\/ local variable\n-        case LOCAL_VARIABLE:\n-        \/\/ resource variable\n-        case RESOURCE_VARIABLE:\n-            if (pos.lvarOffset == null) {\n-                print(\", lvarOffset is Null!\");\n-                break;\n+            case TypeAnnotation.SupertypeTarget pos -> {\n+                print(\", type_index=\");\n+                print(pos.supertypeIndex());\n@@ -135,3 +164,9 @@\n-            print(\", {\");\n-            for (int i = 0; i < pos.lvarOffset.length; ++i) {\n-                if (i != 0) print(\"; \");\n+            case TypeAnnotation.ThrowsTarget pos -> {\n+                print(\", type_index=\");\n+                print(pos.throwsTargetIndex());\n+            }\n+            case TypeAnnotation.FormalParameterTarget pos -> {\n+                print(\", param_index=\");\n+                print(pos.formalParameterIndex());\n+            }\n+            case TypeAnnotation.TypeArgumentTarget pos -> {\n@@ -139,2 +174,2 @@\n-                    print(\"start_pc=\");\n-                    print(pos.lvarOffset[i]);\n+                    print(\", offset=\");\n+                    print(lr.labelToBci(pos.target()));\n@@ -142,4 +177,2 @@\n-                print(\", length=\");\n-                print(pos.lvarLength[i]);\n-                print(\", index=\");\n-                print(pos.lvarIndex[i]);\n+                print(\", type_index=\");\n+                print(pos.typeArgumentIndex());\n@@ -147,50 +180,2 @@\n-            print(\"}\");\n-            break;\n-        \/\/ exception parameter\n-        case EXCEPTION_PARAMETER:\n-            print(\", exception_index=\");\n-            print(pos.exception_index);\n-            break;\n-        \/\/ method receiver\n-        case METHOD_RECEIVER:\n-            \/\/ Do nothing\n-            break;\n-        \/\/ type parameter\n-        case CLASS_TYPE_PARAMETER:\n-        case METHOD_TYPE_PARAMETER:\n-            print(\", param_index=\");\n-            print(pos.parameter_index);\n-            break;\n-        \/\/ type parameter bound\n-        case CLASS_TYPE_PARAMETER_BOUND:\n-        case METHOD_TYPE_PARAMETER_BOUND:\n-            print(\", param_index=\");\n-            print(pos.parameter_index);\n-            print(\", bound_index=\");\n-            print(pos.bound_index);\n-            break;\n-        \/\/ class extends or implements clause\n-        case CLASS_EXTENDS:\n-            print(\", type_index=\");\n-            print(pos.type_index);\n-            break;\n-        \/\/ throws\n-        case THROWS:\n-            print(\", type_index=\");\n-            print(pos.type_index);\n-            break;\n-        \/\/ method parameter\n-        case METHOD_FORMAL_PARAMETER:\n-            print(\", param_index=\");\n-            print(pos.parameter_index);\n-            break;\n-        \/\/ type cast\n-        case CAST:\n-        \/\/ method\/constructor\/reference type argument\n-        case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n-        case METHOD_INVOCATION_TYPE_ARGUMENT:\n-        case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n-        case METHOD_REFERENCE_TYPE_ARGUMENT:\n-            if (showOffsets) {\n-                print(\", offset=\");\n-                print(pos.offset);\n+            case TypeAnnotation.EmptyTarget pos -> {\n+                \/\/ Do nothing\n@@ -198,11 +183,3 @@\n-            print(\", type_index=\");\n-            print(pos.type_index);\n-            break;\n-        \/\/ We don't need to worry about these\n-        case METHOD_RETURN:\n-        case FIELD:\n-            break;\n-        case UNKNOWN:\n-            throw new AssertionError(\"AnnotationWriter: UNKNOWN target type should never occur!\");\n-        default:\n-            throw new AssertionError(\"AnnotationWriter: Unknown target type for position: \" + pos);\n+            default ->\n+                throw new AssertionError(\"AnnotationWriter: Unhandled target type: \"\n+                        + targetInfo.getClass());\n@@ -212,1 +189,1 @@\n-        if (!pos.location.isEmpty()) {\n+        if (!targetPath.isEmpty()) {\n@@ -214,1 +191,4 @@\n-            print(pos.location);\n+            print(targetPath.stream().map(tp -> tp.typePathKind().toString() +\n+                    (tp.typePathKind() == TypeAnnotation.TypePathComponent.Kind.TYPE_ARGUMENT\n+                            ? (\"(\" + tp.typeArgumentIndex() + \")\")\n+                            : \"\")).toList());\n@@ -218,2 +198,2 @@\n-    public void write(Annotation.element_value_pair pair, boolean resolveIndices) {\n-        writeIndex(pair.element_name_index, resolveIndices);\n+    public void write(AnnotationElement pair, boolean resolveIndices) {\n+        writeIndex(pair.name(), resolveIndices);\n@@ -221,1 +201,1 @@\n-        write(pair.value, resolveIndices);\n+        write(pair.value(), resolveIndices);\n@@ -224,1 +204,1 @@\n-    public void write(Annotation.element_value value) {\n+    public void write(AnnotationValue value) {\n@@ -232,5 +212,1 @@\n-    public void write(Annotation.element_value value, boolean resolveIndices) {\n-        ev_writer.write(value, resolveIndices);\n-    }\n-\n-    private void writeDescriptor(int index, boolean resolveIndices) {\n+    private void writeDescriptor(Utf8Entry entry, boolean resolveIndices) {\n@@ -238,7 +214,2 @@\n-            try {\n-                ConstantPool constant_pool = classWriter.getClassFile().constant_pool;\n-                Descriptor d = new Descriptor(index);\n-                print(d.getFieldType(constant_pool));\n-                return;\n-            } catch (ConstantPoolException | InvalidDescriptor ignore) {\n-            }\n+            print(classWriter.sigPrinter.print(Signature.parseFrom(entry.stringValue())));\n+            return;\n@@ -246,2 +217,1 @@\n-\n-        print(\"#\" + index);\n+        print(\"#\" + entry.index());\n@@ -250,1 +220,1 @@\n-    private void writeIndex(int index, boolean resolveIndices) {\n+    private void writeIndex(PoolEntry entry, boolean resolveIndices) {\n@@ -252,1 +222,1 @@\n-            print(constantWriter.stringValue(index));\n+            print(constantWriter.stringValue(entry));\n@@ -254,1 +224,1 @@\n-            print(\"#\" + index);\n+            print(\"#\" + entry.index());\n@@ -257,42 +227,39 @@\n-    element_value_Writer ev_writer = new element_value_Writer();\n-\n-    class element_value_Writer implements Annotation.element_value.Visitor<Void,Boolean> {\n-        public void write(Annotation.element_value value, boolean resolveIndices) {\n-            value.accept(this, resolveIndices);\n-        }\n-\n-        @Override\n-        public Void visitPrimitive(Primitive_element_value ev, Boolean resolveIndices) {\n-            if (resolveIndices) {\n-                int index = ev.const_value_index;\n-                switch (ev.tag) {\n-                    case 'B':\n-                        print(\"(byte) \");\n-                        print(constantWriter.stringValue(index));\n-                        break;\n-                    case 'C':\n-                        print(\"'\");\n-                        print(constantWriter.charValue(index));\n-                        print(\"'\");\n-                        break;\n-                    case 'D':\n-                    case 'F':\n-                    case 'I':\n-                    case 'J':\n-                        print(constantWriter.stringValue(index));\n-                        break;\n-                    case 'S':\n-                        print(\"(short) \");\n-                        print(constantWriter.stringValue(index));\n-                        break;\n-                    case 'Z':\n-                        print(constantWriter.booleanValue(index));\n-                        break;\n-                    case 's':\n-                        print(\"\\\"\");\n-                        print(constantWriter.stringValue(index));\n-                        print(\"\\\"\");\n-                        break;\n-                    default:\n-                        print(((char) ev.tag) + \"#\" + ev.const_value_index);\n-                        break;\n+    public void write(AnnotationValue value, boolean resolveIndices) {\n+        switch (value) {\n+            case AnnotationValue.OfConstant ev -> {\n+                if (resolveIndices) {\n+                    var entry = ev.constant();\n+                    switch (ev.tag()) {\n+                        case 'B':\n+                            print(\"(byte) \");\n+                            print(constantWriter.stringValue(entry));\n+                            break;\n+                        case 'C':\n+                            print(\"'\");\n+                            print(constantWriter.charValue(entry));\n+                            print(\"'\");\n+                            break;\n+                        case 'D':\n+                        case 'F':\n+                        case 'I':\n+                        case 'J':\n+                            print(constantWriter.stringValue(entry));\n+                            break;\n+                        case 'S':\n+                            print(\"(short) \");\n+                            print(constantWriter.stringValue(entry));\n+                            break;\n+                        case 'Z':\n+                            print(constantWriter.booleanValue(entry));\n+                            break;\n+                        case 's':\n+                            print(\"\\\"\");\n+                            print(constantWriter.stringValue(entry));\n+                            print(\"\\\"\");\n+                            break;\n+                        default:\n+                            print(ev.tag() + \"#\" + entry.index());\n+                            break;\n+                    }\n+                } else {\n+                    print(ev.tag() + \"#\" + ev.constant().index());\n@@ -300,2 +267,0 @@\n-            } else {\n-                print(((char) ev.tag) + \"#\" + ev.const_value_index);\n@@ -303,11 +268,9 @@\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitEnum(Enum_element_value ev, Boolean resolveIndices) {\n-            if (resolveIndices) {\n-                writeIndex(ev.type_name_index, resolveIndices);\n-                print(\".\");\n-                writeIndex(ev.const_name_index, resolveIndices);\n-            } else {\n-                print(((char) ev.tag) + \"#\" + ev.type_name_index + \".#\" + ev.const_name_index);\n+            case AnnotationValue.OfEnum ev -> {\n+                if (resolveIndices) {\n+                    writeIndex(ev.className(), resolveIndices);\n+                    print(\".\");\n+                    writeIndex(ev.constantName(), resolveIndices);\n+                } else {\n+                    print(ev.tag() + \"#\" + ev.className().index() + \".#\"\n+                            + ev.constantName().index());\n+                }\n@@ -315,10 +278,7 @@\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitClass(Class_element_value ev, Boolean resolveIndices) {\n-            if (resolveIndices) {\n-                print(\"class \");\n-                writeIndex(ev.class_info_index, resolveIndices);\n-            } else {\n-                print(((char) ev.tag) + \"#\" + ev.class_info_index);\n+            case AnnotationValue.OfClass ev -> {\n+                if (resolveIndices) {\n+                    print(\"class \");\n+                    writeIndex(ev.className(), resolveIndices);\n+                } else {\n+                    print(ev.tag() + \"#\" + ev.className().index());\n+                }\n@@ -326,17 +286,12 @@\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitAnnotation(Annotation_element_value ev, Boolean resolveIndices) {\n-            print((char) ev.tag);\n-            AnnotationWriter.this.write(ev.annotation_value, resolveIndices);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visitArray(Array_element_value ev, Boolean resolveIndices) {\n-            print(\"[\");\n-            for (int i = 0; i < ev.num_values; i++) {\n-                if (i > 0)\n-                    print(\",\");\n-                write(ev.values[i], resolveIndices);\n+            case AnnotationValue.OfAnnotation ev -> {\n+                print(ev.tag());\n+                AnnotationWriter.this.write(ev.annotation(), resolveIndices);\n+            }\n+            case AnnotationValue.OfArray ev -> {\n+                print(\"[\");\n+                for (int i = 0; i < ev.values().size(); i++) {\n+                    if (i > 0)\n+                        print(\",\");\n+                    write(ev.values().get(i), resolveIndices);\n+                }\n+                print(\"]\");\n@@ -344,2 +299,0 @@\n-            print(\"]\");\n-            return null;\n@@ -347,1 +300,0 @@\n-\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AnnotationWriter.java","additions":174,"deletions":222,"binary":false,"changes":396,"status":"modified"},{"patch":"@@ -28,57 +28,10 @@\n-import java.util.Collection;\n-\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.AnnotationDefault_attribute;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.BootstrapMethods_attribute;\n-import com.sun.tools.classfile.CharacterRangeTable_attribute;\n-import com.sun.tools.classfile.CharacterRangeTable_attribute.Entry;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.CompilationID_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CONSTANT_Class_info;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.ConstantValue_attribute;\n-import com.sun.tools.classfile.DefaultAttribute;\n-import com.sun.tools.classfile.Deprecated_attribute;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.EnclosingMethod_attribute;\n-import com.sun.tools.classfile.Exceptions_attribute;\n-import com.sun.tools.classfile.InnerClasses_attribute;\n-import com.sun.tools.classfile.InnerClasses_attribute.Info;\n-import com.sun.tools.classfile.LineNumberTable_attribute;\n-import com.sun.tools.classfile.LocalVariableTable_attribute;\n-import com.sun.tools.classfile.LocalVariableTypeTable_attribute;\n-import com.sun.tools.classfile.MethodParameters_attribute;\n-import com.sun.tools.classfile.Module_attribute;\n-import com.sun.tools.classfile.ModuleHashes_attribute;\n-import com.sun.tools.classfile.ModuleMainClass_attribute;\n-import com.sun.tools.classfile.ModulePackages_attribute;\n-import com.sun.tools.classfile.ModuleResolution_attribute;\n-import com.sun.tools.classfile.ModuleTarget_attribute;\n-import com.sun.tools.classfile.NestHost_attribute;\n-import com.sun.tools.classfile.NestMembers_attribute;\n-import com.sun.tools.classfile.Record_attribute;\n-import com.sun.tools.classfile.RuntimeInvisibleAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeInvisibleParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeInvisibleTypeAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleParameterAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;\n-import com.sun.tools.classfile.PermittedSubclasses_attribute;\n-import com.sun.tools.classfile.Signature_attribute;\n-import com.sun.tools.classfile.SourceDebugExtension_attribute;\n-import com.sun.tools.classfile.SourceFile_attribute;\n-import com.sun.tools.classfile.SourceID_attribute;\n-import com.sun.tools.classfile.StackMapTable_attribute;\n-import com.sun.tools.classfile.StackMap_attribute;\n-import com.sun.tools.classfile.Synthetic_attribute;\n-import com.sun.tools.classfile.Type;\n-\n-import static com.sun.tools.classfile.AccessFlags.*;\n-\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.StringUtils;\n+import java.lang.reflect.Modifier;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Locale;\n+import jdk.internal.classfile.*;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.attribute.*;\n+import static jdk.internal.classfile.Classfile.*;\n+import static jdk.internal.classfile.attribute.StackMapFrameInfo.*;\n@@ -94,3 +47,2 @@\n-public class AttributeWriter extends BasicWriter\n-        implements Attribute.Visitor<Void,Void>\n-{\n+public class AttributeWriter extends BasicWriter {\n+\n@@ -113,8 +65,2 @@\n-    public void write(Object owner, Attribute attr, ConstantPool constant_pool) {\n-        if (attr != null) {\n-            Assert.checkNonNull(constant_pool);\n-            Assert.checkNonNull(owner);\n-            this.constant_pool = constant_pool;\n-            this.owner = owner;\n-            attr.accept(this, null);\n-        }\n+    public void write(List<Attribute<?>> attrs) {\n+        write(attrs, null);\n@@ -123,1 +69,1 @@\n-    public void write(Object owner, Attributes attrs, ConstantPool constant_pool) {\n+    public void write(List<Attribute<?>> attrs, CodeAttribute lr) {\n@@ -125,6 +71,5 @@\n-            Assert.checkNonNull(constant_pool);\n-            Assert.checkNonNull(owner);\n-            this.constant_pool = constant_pool;\n-            this.owner = owner;\n-            for (Attribute attr: attrs)\n-                attr.accept(this, null);\n+            for (var attr : attrs) try {\n+                write(attr, lr);\n+            } catch (IllegalArgumentException e) {\n+                report(e);\n+            }\n@@ -134,26 +79,11 @@\n-    @Override\n-    public Void visitDefault(DefaultAttribute attr, Void ignore) {\n-        byte[] data = attr.info;\n-        int i = 0;\n-        int j = 0;\n-        print(\"  \");\n-        try {\n-            print(attr.getName(constant_pool));\n-        } catch (ConstantPoolException e) {\n-            report(e);\n-            print(\"attribute name = #\" + attr.attribute_name_index);\n-        }\n-        print(\": \");\n-        print(\"length = 0x\" + toHex(attr.info.length));\n-        if (attr.reason != null) {\n-            print(\" (\" + attr.reason + \")\");\n-        }\n-        println();\n-\n-        print(\"   \");\n-\n-        while (i < data.length) {\n-            print(toHex(data[i], 2));\n-\n-            j++;\n-            if (j == 16) {\n+    public void write(Attribute<?> a, CodeAttribute lr) {\n+        switch (a) {\n+            case UnknownAttribute attr -> {\n+                byte[] data = attr.contents();\n+                int i = 0;\n+                int j = 0;\n+                print(\"  \");\n+                print(attr.attributeName());\n+                print(\": \");\n+                print(\"length = 0x\" + toHex(data.length));\n+                print(\" (unknown attribute)\");\n@@ -162,3 +92,14 @@\n-                j = 0;\n-            } else {\n-                print(\" \");\n+                while (i < data.length) {\n+                    print(toHex(data[i], 2));\n+\n+                    j++;\n+                    if (j == 16) {\n+                        println();\n+                        print(\"   \");\n+                        j = 0;\n+                    } else {\n+                        print(\" \");\n+                    }\n+                    i++;\n+                }\n+                println();\n@@ -166,31 +107,7 @@\n-            i++;\n-        }\n-        println();\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitAnnotationDefault(AnnotationDefault_attribute attr, Void ignore) {\n-        println(\"AnnotationDefault:\");\n-        indent(+1);\n-        print(\"default_value: \");\n-        annotationWriter.write(attr.default_value);\n-        indent(-1);\n-        println();\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitBootstrapMethods(BootstrapMethods_attribute attr, Void p) {\n-        println(Attribute.BootstrapMethods + \":\");\n-        for (int i = 0; i < attr.bootstrap_method_specifiers.length ; i++) {\n-            BootstrapMethods_attribute.BootstrapMethodSpecifier bsm = attr.bootstrap_method_specifiers[i];\n-            indent(+1);\n-            print(i + \": #\" + bsm.bootstrap_method_ref + \" \");\n-            println(constantWriter.stringValue(bsm.bootstrap_method_ref));\n-            indent(+1);\n-            println(\"Method arguments:\");\n-            indent(+1);\n-            for (int j = 0; j < bsm.bootstrap_arguments.length; j++) {\n-                print(\"#\" + bsm.bootstrap_arguments[j] + \" \");\n-                println(constantWriter.stringValue(bsm.bootstrap_arguments[j]));\n+            case AnnotationDefaultAttribute attr -> {\n+                println(\"AnnotationDefault:\");\n+                indent(+1);\n+                print(\"default_value: \");\n+                annotationWriter.write(attr.defaultValue());\n+                indent(-1);\n+                println();\n@@ -198,119 +115,183 @@\n-            indent(-3);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitCharacterRangeTable(CharacterRangeTable_attribute attr, Void ignore) {\n-        println(\"CharacterRangeTable:\");\n-        indent(+1);\n-        for (Entry e : attr.character_range_table) {\n-            print(String.format(\"    %2d, %2d, %6x, %6x, %4x\",\n-                    e.start_pc, e.end_pc,\n-                    e.character_range_start, e.character_range_end,\n-                    e.flags));\n-            tab();\n-            print(String.format(\"\/\/ %2d, %2d, %4d:%02d, %4d:%02d\",\n-                    e.start_pc, e.end_pc,\n-                    (e.character_range_start >> 10), (e.character_range_start & 0x3ff),\n-                    (e.character_range_end >> 10), (e.character_range_end & 0x3ff)));\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_STATEMENT) != 0)\n-                print(\", statement\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_BLOCK) != 0)\n-                print(\", block\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_ASSIGNMENT) != 0)\n-                print(\", assignment\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_FLOW_CONTROLLER) != 0)\n-                print(\", flow-controller\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_FLOW_TARGET) != 0)\n-                print(\", flow-target\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_INVOKE) != 0)\n-                print(\", invoke\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_CREATE) != 0)\n-                print(\", create\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_BRANCH_TRUE) != 0)\n-                print(\", branch-true\");\n-            if ((e.flags & CharacterRangeTable_attribute.CRT_BRANCH_FALSE) != 0)\n-                print(\", branch-false\");\n-            println();\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitCode(Code_attribute attr, Void ignore) {\n-        codeWriter.write(attr, constant_pool);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitCompilationID(CompilationID_attribute attr, Void ignore) {\n-        constantWriter.write(attr.compilationID_index);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitConstantValue(ConstantValue_attribute attr, Void ignore) {\n-        print(\"ConstantValue: \");\n-        constantWriter.write(attr.constantvalue_index);\n-        println();\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitDeprecated(Deprecated_attribute attr, Void ignore) {\n-        println(\"Deprecated: true\");\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitEnclosingMethod(EnclosingMethod_attribute attr, Void ignore) {\n-        print(\"EnclosingMethod: #\" + attr.class_index + \".#\" + attr.method_index);\n-        tab();\n-        print(\"\/\/ \" + getJavaClassName(attr));\n-        if (attr.method_index != 0)\n-            print(\".\" + getMethodName(attr));\n-        println();\n-        return null;\n-    }\n-\n-    private String getJavaClassName(EnclosingMethod_attribute a) {\n-        try {\n-            return getJavaName(a.getClassName(constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    private String getMethodName(EnclosingMethod_attribute a) {\n-        try {\n-            return a.getMethodName(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    @Override\n-    public Void visitExceptions(Exceptions_attribute attr, Void ignore) {\n-        println(\"Exceptions:\");\n-        indent(+1);\n-        print(\"throws \");\n-        for (int i = 0; i < attr.number_of_exceptions; i++) {\n-            if (i > 0)\n-                print(\", \");\n-            print(getJavaException(attr, i));\n-        }\n-        println();\n-        indent(-1);\n-        return null;\n-    }\n-\n-    private String getJavaException(Exceptions_attribute attr, int index) {\n-        try {\n-            return getJavaName(attr.getException(index, constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n+            case BootstrapMethodsAttribute attr -> {\n+                println(\"BootstrapMethods:\");\n+                for (int i = 0; i < attr.bootstrapMethodsSize() ; i++) {\n+                    var bsm = attr.bootstrapMethods().get(i);\n+                    indent(+1);\n+                    print(i + \": #\" + bsm.bootstrapMethod().index() + \" \");\n+                    println(constantWriter.stringValue(bsm.bootstrapMethod()));\n+                    indent(+1);\n+                    println(\"Method arguments:\");\n+                    indent(+1);\n+                    for (var arg : bsm.arguments()) {\n+                        print(\"#\" + arg.index() + \" \");\n+                        println(constantWriter.stringValue(arg));\n+                    }\n+                    indent(-3);\n+                }\n+            }\n+            case CharacterRangeTableAttribute attr -> {\n+                println(\"CharacterRangeTable:\");\n+                indent(+1);\n+                for (var e : attr.characterRangeTable()) {\n+                    print(String.format(\"    %2d, %2d, %6x, %6x, %4x\",\n+                            e.startPc(), e.endPc(),\n+                            e.characterRangeStart(), e.characterRangeEnd(),\n+                            e.flags()));\n+                    tab();\n+                    print(String.format(\"\/\/ %2d, %2d, %4d:%02d, %4d:%02d\",\n+                            e.startPc(), e.endPc(),\n+                            (e.characterRangeStart() >> 10),\n+                            (e.characterRangeStart() & 0x3ff),\n+                            (e.characterRangeEnd() >> 10),\n+                            (e.characterRangeEnd() & 0x3ff)));\n+                    if ((e.flags() & CRT_STATEMENT) != 0)\n+                        print(\", statement\");\n+                    if ((e.flags() & CRT_BLOCK) != 0)\n+                        print(\", block\");\n+                    if ((e.flags() & CRT_ASSIGNMENT) != 0)\n+                        print(\", assignment\");\n+                    if ((e.flags() & CRT_FLOW_CONTROLLER) != 0)\n+                        print(\", flow-controller\");\n+                    if ((e.flags() & CRT_FLOW_TARGET) != 0)\n+                        print(\", flow-target\");\n+                    if ((e.flags() & CRT_INVOKE) != 0)\n+                        print(\", invoke\");\n+                    if ((e.flags() & CRT_CREATE) != 0)\n+                        print(\", create\");\n+                    if ((e.flags() & CRT_BRANCH_TRUE) != 0)\n+                        print(\", branch-true\");\n+                    if ((e.flags() & CRT_BRANCH_FALSE) != 0)\n+                        print(\", branch-false\");\n+                    println();\n+                }\n+                indent(-1);\n+            }\n+            case CodeAttribute attr -> codeWriter.write(attr);\n+            case CompilationIDAttribute attr ->\n+                constantWriter.write(attr.compilationId().index());\n+            case ConstantValueAttribute attr -> {\n+                print(\"ConstantValue: \");\n+                constantWriter.write(attr.constant().index());\n+                println();\n+            }\n+            case DeprecatedAttribute attr -> println(\"Deprecated: true\");\n+            case EnclosingMethodAttribute attr -> {\n+                print(\"EnclosingMethod: #\" + attr.enclosingClass().index() + \".#\"\n+                        +  attr.enclosingMethod().map(PoolEntry::index).orElse(0));\n+                tab();\n+                print(\"\/\/ \" + getJavaName(attr.enclosingClass().asInternalName()));\n+                if (attr.enclosingMethod().isPresent())\n+                    print(\".\" + attr.enclosingMethod().get().name().stringValue());\n+                println();\n+            }\n+            case ExceptionsAttribute attr -> {\n+                println(\"Exceptions:\");\n+                indent(+1);\n+                print(\"throws \");\n+                var exc = attr.exceptions();\n+                for (int i = 0; i < exc.size(); i++) {\n+                    if (i > 0)\n+                        print(\", \");\n+                    print(getJavaName(exc.get(i).asInternalName()));\n+                }\n+                println();\n+                indent(-1);\n+            }\n+            case InnerClassesAttribute attr -> {\n+                boolean first = true;\n+                for (var info : attr.classes()) {\n+                    \/\/access\n+                    int access_flags = info.flagsMask();\n+                    if (options.checkAccess(access_flags)) {\n+                        if (first) {\n+                            println(\"InnerClasses:\");\n+                            indent(+1);\n+                            first = false;\n+                        }\n+                        for (var flag : info.flags()) {\n+                            if (flag.sourceModifier() && (flag != AccessFlag.ABSTRACT\n+                                    || !info.has(AccessFlag.INTERFACE))) {\n+                                print(Modifier.toString(flag.mask()) + \" \");\n+                            }\n+                        }\n+                        if (info.innerName().isPresent()) {\n+                            print(\"#\" + info.innerName().get().index() + \"= \");\n+                        }\n+                        print(\"#\" + info.innerClass().index());\n+                        if (info.outerClass().isPresent()) {\n+                            print(\" of #\" + info.outerClass().get().index());\n+                        }\n+                        print(\";\");\n+                        tab();\n+                        print(\"\/\/ \");\n+                        if (info.innerName().isPresent()) {\n+                            print(info.innerName().get().stringValue() + \"=\");\n+                        }\n+                        constantWriter.write(info.innerClass().index());\n+                        if (info.outerClass().isPresent()) {\n+                            print(\" of \");\n+                            constantWriter.write(info.outerClass().get().index());\n+                        }\n+                        println();\n+                    }\n+                }\n+                if (!first)\n+                    indent(-1);\n+            }\n+            case LineNumberTableAttribute attr -> {\n+                println(\"LineNumberTable:\");\n+                indent(+1);\n+                for (var entry: attr.lineNumbers()) {\n+                    println(\"line \" + entry.lineNumber() + \": \" + entry.startPc());\n+                }\n+                indent(-1);\n+            }\n+            case LocalVariableTableAttribute attr -> {\n+                println(\"LocalVariableTable:\");\n+                indent(+1);\n+                println(\"Start  Length  Slot  Name   Signature\");\n+                for (var entry : attr.localVariables()) {\n+                    println(String.format(\"%5d %7d %5d %5s   %s\",\n+                            entry.startPc(), entry.length(), entry.slot(),\n+                            constantWriter.stringValue(entry.name()),\n+                            constantWriter.stringValue(entry.type())));\n+                }\n+                indent(-1);\n+            }\n+            case LocalVariableTypeTableAttribute attr -> {\n+                println(\"LocalVariableTypeTable:\");\n+                indent(+1);\n+                println(\"Start  Length  Slot  Name   Signature\");\n+                for (var entry : attr.localVariableTypes()) {\n+                    println(String.format(\"%5d %7d %5d %5s   %s\",\n+                            entry.startPc(), entry.length(), entry.slot(),\n+                            constantWriter.stringValue(entry.name()),\n+                            constantWriter.stringValue(entry.signature())));\n+                }\n+                indent(-1);\n+            }\n+            case NestHostAttribute attr -> {\n+                print(\"NestHost: \");\n+                constantWriter.write(attr.nestHost().index());\n+                println();\n+            }\n+            case MethodParametersAttribute attr -> {\n+                final String header = String.format(format, \"Name\", \"Flags\");\n+                println(\"MethodParameters:\");\n+                indent(+1);\n+                println(header);\n+                for (var entry : attr.parameters()) {\n+                    String namestr =\n+                        entry.name().isPresent() ?\n+                        constantWriter.stringValue(entry.name().get()) : \"<no name>\";\n+                    String flagstr =\n+                        (entry.has(AccessFlag.FINAL) ? \"final \" : \"\") +\n+                        (entry.has(AccessFlag.MANDATED) ? \"mandated \" : \"\") +\n+                        (entry.has(AccessFlag.SYNTHETIC) ? \"synthetic\" : \"\");\n+                    println(String.format(format, namestr, flagstr));\n+                }\n+                indent(-1);\n+            }\n+            case ModuleAttribute attr -> {\n+                println(\"Module:\");\n+                indent(+1);\n@@ -318,10 +299,72 @@\n-    @Override\n-    public Void visitInnerClasses(InnerClasses_attribute attr, Void ignore) {\n-        boolean first = true;\n-        for (Info info : attr.classes) {\n-            \/\/access\n-            AccessFlags access_flags = info.inner_class_access_flags;\n-            if (options.checkAccess(access_flags)) {\n-                if (first) {\n-                    writeInnerClassHeader();\n-                    first = false;\n+                print(\"#\" + attr.moduleName().index());\n+                print(\",\");\n+                print(String.format(\"%x\", attr.moduleFlagsMask()));\n+                tab();\n+                print(\"\/\/ \" + constantWriter.stringValue(attr.moduleName()));\n+                if (attr.has(AccessFlag.OPEN))\n+                    print(\" ACC_OPEN\");\n+                if (attr.has(AccessFlag.MANDATED))\n+                    print(\" ACC_MANDATED\");\n+                if (attr.has(AccessFlag.SYNTHETIC))\n+                    print(\" ACC_SYNTHETIC\");\n+                println();\n+                var ver = attr.moduleVersion();\n+                print(\"#\" + ver.map(Utf8Entry::index).orElse(0));\n+                if (ver.isPresent()) {\n+                    tab();\n+                    print(\"\/\/ \" + constantWriter.stringValue(ver.get()));\n+                }\n+                println();\n+                {\n+                    var entries = attr.requires();\n+                    print(entries.size());\n+                    tab();\n+                    println(\"\/\/ \" + \"requires\");\n+                    indent(+1);\n+                    for (var e: entries) {\n+                        print(\"#\" + e.requires().index() + \",\"\n+                                + String.format(\"%x\", e.requiresFlagsMask()));\n+                        tab();\n+                        print(\"\/\/ \" + constantWriter.stringValue(e.requires()));\n+                        if (e.has(AccessFlag.TRANSITIVE))\n+                            print(\" ACC_TRANSITIVE\");\n+                        if (e.has(AccessFlag.STATIC_PHASE))\n+                            print(\" ACC_STATIC_PHASE\");\n+                        if (e.has(AccessFlag.SYNTHETIC))\n+                            print(\" ACC_SYNTHETIC\");\n+                        if (e.has(AccessFlag.MANDATED))\n+                            print(\" ACC_MANDATED\");\n+                        println();\n+                        var reqVer = e.requiresVersion();\n+                        print(\"#\" + reqVer.map(Utf8Entry::index).orElse(0));\n+                        if (reqVer.isPresent()) {\n+                            tab();\n+                            print(\"\/\/ \" + constantWriter.stringValue(reqVer.get()));\n+                        }\n+                        println();\n+                    }\n+                    indent(-1);\n+                }\n+                {\n+                    var entries = attr.exports();\n+                    print(entries.size());\n+                    tab();\n+                    println(\"\/\/ exports\");\n+                    indent(+1);\n+                    for (var e: entries) {\n+                        printExportOpenEntry(e.exportedPackage().index(),\n+                                e.exportsFlagsMask(), e.exportsTo());\n+                    }\n+                    indent(-1);\n+                }\n+                {\n+                    var entries = attr.opens();\n+                    print(entries.size());\n+                    tab();\n+                    println(\"\/\/ opens\");\n+                    indent(+1);\n+                    for (var e: entries) {\n+                        printExportOpenEntry(e.openedPackage().index(),\n+                                e.opensFlagsMask(), e.opensTo());\n+                    }\n+                    indent(-1);\n@@ -329,4 +372,12 @@\n-                for (String name: access_flags.getInnerClassModifiers())\n-                    print(name + \" \");\n-                if (info.inner_name_index != 0) {\n-                    print(\"#\" + info.inner_name_index + \"= \");\n+                {\n+                    var entries = attr.uses();\n+                    print(entries.size());\n+                    tab();\n+                    println(\"\/\/ \" + \"uses\");\n+                    indent(+1);\n+                    for (var e: entries) {\n+                        print(\"#\" + e.index());\n+                        tab();\n+                        println(\"\/\/ \" + constantWriter.stringValue(e));\n+                    }\n+                    indent(-1);\n@@ -334,3 +385,21 @@\n-                print(\"#\" + info.inner_class_info_index);\n-                if (info.outer_class_info_index != 0) {\n-                    print(\" of #\" + info.outer_class_info_index);\n+                {\n+                    var entries = attr.provides();\n+                    print(entries.size());\n+                    tab();\n+                    println(\"\/\/ \" + \"provides\");\n+                    indent(+1);\n+                    for (var e: entries) {\n+                        print(\"#\" + e.provides().index());\n+                        tab();\n+                        print(\"\/\/ \");\n+                        print(constantWriter.stringValue(e.provides()));\n+                        println(\" with ... \" + e.providesWith().size());\n+                        indent(+1);\n+                        for (var with : e.providesWith()) {\n+                            print(\"#\" + with.index());\n+                            tab();\n+                            println(\"\/\/ ... with \" + constantWriter.stringValue(with));\n+                        }\n+                        indent(-1);\n+                    }\n+                    indent(-1);\n@@ -338,1 +407,6 @@\n-                print(\";\");\n+                indent(-1);\n+            }\n+            case ModuleHashesAttribute attr -> {\n+                println(\"ModuleHashes:\");\n+                indent(+1);\n+                print(\"algorithm: #\" + attr.algorithm().index());\n@@ -340,3 +414,10 @@\n-                print(\"\/\/ \");\n-                if (info.inner_name_index != 0) {\n-                    print(getInnerName(constant_pool, info) + \"=\");\n+                println(\"\/\/ \" + attr.algorithm().stringValue());\n+                print(attr.hashes().size());\n+                tab();\n+                println(\"\/\/ hashes\");\n+                for (var e : attr.hashes()) {\n+                    print(\"#\" + e.moduleName().index());\n+                    tab();\n+                    println(\"\/\/ \" + e.moduleName().name().stringValue());\n+                    println(\"hash_length: \" + e.hash().length);\n+                    println(\"hash: [\" + toHex(e.hash()) + \"]\");\n@@ -344,4 +425,15 @@\n-                constantWriter.write(info.inner_class_info_index);\n-                if (info.outer_class_info_index != 0) {\n-                    print(\" of \");\n-                    constantWriter.write(info.outer_class_info_index);\n+                indent(-1);\n+            }\n+            case ModuleMainClassAttribute attr -> {\n+                print(\"ModuleMainClass: #\" + attr.mainClass().index());\n+                tab();\n+                print(\"\/\/ \" + getJavaName(attr.mainClass().asInternalName()));\n+                println();\n+            }\n+            case ModulePackagesAttribute attr -> {\n+                println(\"ModulePackages: \");\n+                indent(+1);\n+                for (var p : attr.packages()) {\n+                    print(\"#\" + p.index());\n+                    tab();\n+                    println(\"\/\/ \" + getJavaName(p.name().stringValue()));\n@@ -349,0 +441,17 @@\n+                indent(-1);\n+            }\n+            case ModuleResolutionAttribute attr -> {\n+                println(\"ModuleResolution:\");\n+                indent(+1);\n+                print(String.format(\"%x\", attr.resolutionFlags()));\n+                tab();\n+                print(\"\/\/ \");\n+                int flags = attr.resolutionFlags();\n+                if ((flags & DO_NOT_RESOLVE_BY_DEFAULT) != 0)\n+                    print(\" DO_NOT_RESOLVE_BY_DEFAULT\");\n+                if ((flags & WARN_DEPRECATED) != 0)\n+                    print(\" WARN_DEPRECATED\");\n+                if ((flags & WARN_DEPRECATED_FOR_REMOVAL) != 0)\n+                    print(\" WARN_DEPRECATED_FOR_REMOVAL\");\n+                if ((flags & WARN_INCUBATING) != 0)\n+                    print(\" WARN_INCUBATING\");\n@@ -350,0 +459,1 @@\n+                indent(-1);\n@@ -351,154 +461,4 @@\n-        }\n-        if (!first)\n-            indent(-1);\n-        return null;\n-    }\n-\n-    String getInnerName(ConstantPool constant_pool, InnerClasses_attribute.Info info) {\n-        try {\n-            return info.getInnerName(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    private void writeInnerClassHeader() {\n-        println(\"InnerClasses:\");\n-        indent(+1);\n-    }\n-\n-    @Override\n-    public Void visitLineNumberTable(LineNumberTable_attribute attr, Void ignore) {\n-        println(\"LineNumberTable:\");\n-        indent(+1);\n-        for (LineNumberTable_attribute.Entry entry: attr.line_number_table) {\n-            println(\"line \" + entry.line_number + \": \" + entry.start_pc);\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitLocalVariableTable(LocalVariableTable_attribute attr, Void ignore) {\n-        println(\"LocalVariableTable:\");\n-        indent(+1);\n-        println(\"Start  Length  Slot  Name   Signature\");\n-        for (LocalVariableTable_attribute.Entry entry : attr.local_variable_table) {\n-            println(String.format(\"%5d %7d %5d %5s   %s\",\n-                    entry.start_pc, entry.length, entry.index,\n-                    constantWriter.stringValue(entry.name_index),\n-                    constantWriter.stringValue(entry.descriptor_index)));\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitLocalVariableTypeTable(LocalVariableTypeTable_attribute attr, Void ignore) {\n-        println(\"LocalVariableTypeTable:\");\n-        indent(+1);\n-        println(\"Start  Length  Slot  Name   Signature\");\n-        for (LocalVariableTypeTable_attribute.Entry entry : attr.local_variable_table) {\n-            println(String.format(\"%5d %7d %5d %5s   %s\",\n-                    entry.start_pc, entry.length, entry.index,\n-                    constantWriter.stringValue(entry.name_index),\n-                    constantWriter.stringValue(entry.signature_index)));\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitNestHost(NestHost_attribute attr, Void aVoid) {\n-        print(\"NestHost: \");\n-        constantWriter.write(attr.top_index);\n-        println();\n-        return null;\n-    }\n-\n-    private String getJavaClassName(ModuleMainClass_attribute a) {\n-        try {\n-            return getJavaName(a.getMainClassName(constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    private static final String format = \"%-31s%s\";\n-\n-    @Override\n-    public Void visitMethodParameters(MethodParameters_attribute attr,\n-                                      Void ignore) {\n-        final String header = String.format(format, \"Name\", \"Flags\");\n-        println(\"MethodParameters:\");\n-        indent(+1);\n-        println(header);\n-        for (MethodParameters_attribute.Entry entry :\n-                 attr.method_parameter_table) {\n-            String namestr =\n-                entry.name_index != 0 ?\n-                constantWriter.stringValue(entry.name_index) : \"<no name>\";\n-            String flagstr =\n-                (0 != (entry.flags & ACC_FINAL) ? \"final \" : \"\") +\n-                (0 != (entry.flags & ACC_MANDATED) ? \"mandated \" : \"\") +\n-                (0 != (entry.flags & ACC_SYNTHETIC) ? \"synthetic\" : \"\");\n-            println(String.format(format, namestr, flagstr));\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitModule(Module_attribute attr, Void ignore) {\n-        println(\"Module:\");\n-        indent(+1);\n-\n-        print(\"#\" + attr.module_name);\n-        print(\",\");\n-        print(String.format(\"%x\", attr.module_flags));\n-        tab();\n-        print(\"\/\/ \" + constantWriter.stringValue(attr.module_name));\n-        if ((attr.module_flags & Module_attribute.ACC_OPEN) != 0)\n-            print(\" ACC_OPEN\");\n-        if ((attr.module_flags & Module_attribute.ACC_MANDATED) != 0)\n-            print(\" ACC_MANDATED\");\n-        if ((attr.module_flags & Module_attribute.ACC_SYNTHETIC) != 0)\n-            print(\" ACC_SYNTHETIC\");\n-        println();\n-        print(\"#\" + attr.module_version_index);\n-        if (attr.module_version_index != 0) {\n-            tab();\n-            print(\"\/\/ \" + constantWriter.stringValue(attr.module_version_index));\n-        }\n-        println();\n-\n-        printRequiresTable(attr);\n-        printExportsTable(attr);\n-        printOpensTable(attr);\n-        printUsesTable(attr);\n-        printProvidesTable(attr);\n-        indent(-1);\n-        return null;\n-    }\n-\n-    protected void printRequiresTable(Module_attribute attr) {\n-        Module_attribute.RequiresEntry[] entries = attr.requires;\n-        print(entries.length);\n-        tab();\n-        println(\"\/\/ \" + \"requires\");\n-        indent(+1);\n-        for (Module_attribute.RequiresEntry e: entries) {\n-            print(\"#\" + e.requires_index + \",\" + String.format(\"%x\", e.requires_flags));\n-            tab();\n-            print(\"\/\/ \" + constantWriter.stringValue(e.requires_index));\n-            if ((e.requires_flags & Module_attribute.ACC_TRANSITIVE) != 0)\n-                print(\" ACC_TRANSITIVE\");\n-            if ((e.requires_flags & Module_attribute.ACC_STATIC_PHASE) != 0)\n-                print(\" ACC_STATIC_PHASE\");\n-            if ((e.requires_flags & Module_attribute.ACC_SYNTHETIC) != 0)\n-                print(\" ACC_SYNTHETIC\");\n-            if ((e.requires_flags & Module_attribute.ACC_MANDATED) != 0)\n-                print(\" ACC_MANDATED\");\n-            println();\n-            print(\"#\" + e.requires_version_index);\n-            if (e.requires_version_index != 0) {\n+            case ModuleTargetAttribute attr -> {\n+                println(\"ModuleTarget:\");\n+                indent(+1);\n+                print(\"target_platform: #\" + attr.targetPlatform().index());\n@@ -506,1 +466,2 @@\n-                print(\"\/\/ \" + constantWriter.stringValue(e.requires_version_index));\n+                println(\"\/\/ \" + attr.targetPlatform().stringValue());\n+                indent(-1);\n@@ -508,1 +469,138 @@\n-            println();\n+            case NestMembersAttribute attr -> {\n+                println(\"NestMembers:\");\n+                indent(+1);\n+                for (var m : attr.nestMembers()) {\n+                    println(constantWriter.stringValue(m));\n+                }\n+                indent(-1);\n+            }\n+            case RecordAttribute attr -> {\n+                println(\"Record:\");\n+                indent(+1);\n+                for (var componentInfo : attr.components()) {\n+                    var sigAttr = componentInfo.findAttribute(Attributes.SIGNATURE);\n+                    print(getJavaName(\n+                            new ClassWriter.SignaturePrinter(options.verbose).print(\n+                                    sigAttr.map(SignatureAttribute::asTypeSignature)\n+                                            .orElse(Signature.of(\n+                                                    componentInfo.descriptorSymbol())))));\n+                    print(\" \");\n+                    print(componentInfo.name().stringValue());\n+                    print(\";\");\n+                    println();\n+                    indent(+1);\n+                    if (options.showDescriptors) {\n+                        println(\"descriptor: \" + componentInfo.descriptor().stringValue());\n+                    }\n+                    if (options.showAllAttrs) {\n+                        write(componentInfo.attributes());\n+                        println();\n+                    }\n+                    indent(-1);\n+                }\n+                indent(-1);\n+            }\n+            case RuntimeVisibleAnnotationsAttribute attr ->\n+                printAnnotations(\"RuntimeVisibleAnnotations:\", attr.annotations());\n+            case RuntimeInvisibleAnnotationsAttribute attr ->\n+                printAnnotations(\"RuntimeInvisibleAnnotations:\", attr.annotations());\n+            case RuntimeVisibleTypeAnnotationsAttribute attr ->\n+                printTypeAnnotations(\"RuntimeVisibleTypeAnnotations:\",\n+                        attr.annotations(), lr);\n+            case RuntimeInvisibleTypeAnnotationsAttribute attr ->\n+                printTypeAnnotations(\"RuntimeInvisibleTypeAnnotations:\",\n+                        attr.annotations(), lr);\n+            case RuntimeVisibleParameterAnnotationsAttribute attr ->\n+                printParameterAnnotations(\"RuntimeVisibleParameterAnnotations:\",\n+                        attr.parameterAnnotations());\n+            case RuntimeInvisibleParameterAnnotationsAttribute attr ->\n+                printParameterAnnotations(\"RuntimeInvisibleParameterAnnotations:\",\n+                        attr.parameterAnnotations());\n+            case PermittedSubclassesAttribute attr -> {\n+                println(\"PermittedSubclasses:\");\n+                indent(+1);\n+                for (var sc : attr.permittedSubclasses()) {\n+                    println(constantWriter.stringValue(sc));\n+                }\n+                indent(-1);\n+            }\n+            case SignatureAttribute attr -> {\n+                print(\"Signature: #\" + attr.signature().index());\n+                tab();\n+                println(\"\/\/ \" + attr.signature().stringValue());\n+            }\n+            case SourceDebugExtensionAttribute attr -> {\n+                println(\"SourceDebugExtension:\");\n+                indent(+1);\n+                for (String s: new String(attr.contents(), StandardCharsets.UTF_8)\n+                        .split(\"[\\r\\n]+\")) {\n+                    println(s);\n+                }\n+                indent(-1);\n+            }\n+            case SourceFileAttribute attr ->\n+                println(\"SourceFile: \\\"\" + attr.sourceFile().stringValue() + \"\\\"\");\n+            case SourceIDAttribute attr ->\n+                constantWriter.write(attr.sourceId().index());\n+            case StackMapTableAttribute attr -> {\n+                var entries = attr.entries();\n+                println(\"StackMapTable: number_of_entries = \" + entries.size());\n+                indent(+1);\n+                int lastOffset = -1;\n+                for (var frame : entries) {\n+                    int frameType = frame.frameType();\n+                    if (frameType < 64) {\n+                        printHeader(frameType, \"\/* same *\/\");\n+                    } else if (frameType < 128) {\n+                        printHeader(frameType, \"\/* same_locals_1_stack_item *\/\");\n+                        indent(+1);\n+                        printMap(\"stack\", frame.stack(), lr);\n+                        indent(-1);\n+                    } else {\n+                        int offsetDelta = lr.labelToBci(frame.target()) - lastOffset - 1;\n+                        switch (frameType) {\n+                            case 247 -> {\n+                                printHeader(frameType, \"\/* same_locals_1_stack_item_frame_extended *\/\");\n+                                indent(+1);\n+                                println(\"offset_delta = \" + offsetDelta);\n+                                printMap(\"stack\", frame.stack(), lr);\n+                                indent(-1);\n+                            }\n+                            case 248, 249, 250 -> {\n+                                printHeader(frameType, \"\/* chop *\/\");\n+                                indent(+1);\n+                                println(\"offset_delta = \" + offsetDelta);\n+                                indent(-1);\n+                            }\n+                            case 251 -> {\n+                                printHeader(frameType, \"\/* same_frame_extended *\/\");\n+                                indent(+1);\n+                                println(\"offset_delta = \" + offsetDelta);\n+                                indent(-1);\n+                            }\n+                            case 252, 253, 254 -> {\n+                                printHeader(frameType, \"\/* append *\/\");\n+                                indent(+1);\n+                                println(\"offset_delta = \" + offsetDelta);\n+                                var locals = frame.locals();\n+                                printMap(\"locals\", locals.subList(locals.size()\n+                                        - frameType + 251, locals.size()), lr);\n+                                indent(-1);\n+                            }\n+                            case 255 -> {\n+                                printHeader(frameType, \"\/* full_frame *\/\");\n+                                indent(+1);\n+                                println(\"offset_delta = \" + offsetDelta);\n+                                printMap(\"locals\", frame.locals(), lr);\n+                                printMap(\"stack\", frame.stack(), lr);\n+                                indent(-1);\n+                            }\n+                        }\n+                    }\n+                    lastOffset = lr.labelToBci(frame.target());\n+                }\n+                indent(-1);\n+            }\n+            case SyntheticAttribute attr ->\n+                println(\"Synthetic: true\");\n+            default -> {}\n@@ -510,1 +608,0 @@\n-        indent(-1);\n@@ -513,11 +610,5 @@\n-    protected void printExportsTable(Module_attribute attr) {\n-        Module_attribute.ExportsEntry[] entries = attr.exports;\n-        print(entries.length);\n-        tab();\n-        println(\"\/\/ exports\");\n-        indent(+1);\n-        for (Module_attribute.ExportsEntry e: entries) {\n-            printExportOpenEntry(e.exports_index, e.exports_flags, e.exports_to_index);\n-        }\n-        indent(-1);\n-    }\n+    \/\/ToDo move somewhere to Bytecode API\n+    public static final int DO_NOT_RESOLVE_BY_DEFAULT   = 0x0001;\n+    public static final int WARN_DEPRECATED             = 0x0002;\n+    public static final int WARN_DEPRECATED_FOR_REMOVAL = 0x0004;\n+    public static final int WARN_INCUBATING             = 0x0008;\n@@ -525,11 +616,1 @@\n-    protected void printOpensTable(Module_attribute attr) {\n-        Module_attribute.OpensEntry[] entries = attr.opens;\n-        print(entries.length);\n-        tab();\n-        println(\"\/\/ opens\");\n-        indent(+1);\n-        for (Module_attribute.OpensEntry e: entries) {\n-            printExportOpenEntry(e.opens_index, e.opens_flags, e.opens_to_index);\n-        }\n-        indent(-1);\n-    }\n+    private static final String format = \"%-31s%s\";\n@@ -537,1 +618,1 @@\n-    protected void printExportOpenEntry(int index, int flags, int[] to_index) {\n+    protected void printExportOpenEntry(int index, int flags, List<ModuleEntry> to_index) {\n@@ -542,1 +623,1 @@\n-        if ((flags & Module_attribute.ACC_MANDATED) != 0)\n+        if ((flags & ACC_MANDATED) != 0)\n@@ -544,1 +625,1 @@\n-        if ((flags & Module_attribute.ACC_SYNTHETIC) != 0)\n+        if ((flags & ACC_SYNTHETIC) != 0)\n@@ -546,1 +627,1 @@\n-        if (to_index.length == 0) {\n+        if (to_index.size() == 0) {\n@@ -549,1 +630,1 @@\n-            println(\" to ... \" + to_index.length);\n+            println(\" to ... \" + to_index.size());\n@@ -551,2 +632,2 @@\n-            for (int to: to_index) {\n-                print(\"#\" + to);\n+            for (var to: to_index) {\n+                print(\"#\" + to.index());\n@@ -560,273 +641,2 @@\n-    protected void printUsesTable(Module_attribute attr) {\n-        int[] entries = attr.uses_index;\n-        print(entries.length);\n-        tab();\n-        println(\"\/\/ \" + \"uses\");\n-        indent(+1);\n-        for (int e: entries) {\n-            print(\"#\" + e);\n-            tab();\n-            println(\"\/\/ \" + constantWriter.stringValue(e));\n-        }\n-        indent(-1);\n-    }\n-\n-    protected void printProvidesTable(Module_attribute attr) {\n-        Module_attribute.ProvidesEntry[] entries = attr.provides;\n-        print(entries.length);\n-        tab();\n-        println(\"\/\/ \" + \"provides\");\n-        indent(+1);\n-        for (Module_attribute.ProvidesEntry e: entries) {\n-            print(\"#\" + e.provides_index);\n-            tab();\n-            print(\"\/\/ \");\n-            print(constantWriter.stringValue(e.provides_index));\n-            println(\" with ... \" + e.with_count);\n-            indent(+1);\n-            for (int with : e.with_index) {\n-                print(\"#\" + with);\n-                tab();\n-                println(\"\/\/ ... with \" + constantWriter.stringValue(with));\n-            }\n-            indent(-1);\n-        }\n-        indent(-1);\n-    }\n-\n-    @Override\n-    public Void visitModuleHashes(ModuleHashes_attribute attr, Void ignore) {\n-        println(\"ModuleHashes:\");\n-        indent(+1);\n-        print(\"algorithm: #\" + attr.algorithm_index);\n-        tab();\n-        println(\"\/\/ \" + getAlgorithm(attr));\n-        print(attr.hashes_table_length);\n-        tab();\n-        println(\"\/\/ hashes\");\n-        for (ModuleHashes_attribute.Entry e : attr.hashes_table) {\n-            print(\"#\" + e.module_name_index);\n-            tab();\n-            println(\"\/\/ \" + getModuleName(e));\n-            println(\"hash_length: \" + e.hash.length);\n-            println(\"hash: [\" + toHex(e.hash) + \"]\");\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    private String getAlgorithm(ModuleHashes_attribute attr) {\n-        try {\n-            return constant_pool.getUTF8Value(attr.algorithm_index);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    private String getModuleName(ModuleHashes_attribute.Entry entry) {\n-        try {\n-            int utf8Index = constant_pool.getModuleInfo(entry.module_name_index).name_index;\n-            return constant_pool.getUTF8Value(utf8Index);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    @Override\n-    public Void visitModuleMainClass(ModuleMainClass_attribute attr, Void ignore) {\n-        print(\"ModuleMainClass: #\" + attr.main_class_index);\n-        tab();\n-        print(\"\/\/ \" + getJavaClassName(attr));\n-        println();\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitModulePackages(ModulePackages_attribute attr, Void ignore) {\n-        println(\"ModulePackages: \");\n-        indent(+1);\n-        for (int i = 0; i < attr.packages_count; i++) {\n-            print(\"#\" + attr.packages_index[i]);\n-            tab();\n-            println(\"\/\/ \" + getJavaPackage(attr, i));\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    private String getJavaPackage(ModulePackages_attribute attr, int index) {\n-        try {\n-            return getJavaName(attr.getPackage(index, constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    @Override\n-    public Void visitModuleResolution(ModuleResolution_attribute attr, Void ignore) {\n-        println(\"ModuleResolution:\");\n-        indent(+1);\n-        print(String.format(\"%x\", attr.resolution_flags));\n-        tab();\n-        print(\"\/\/ \");\n-        int flags = attr.resolution_flags;\n-        if ((flags & ModuleResolution_attribute.DO_NOT_RESOLVE_BY_DEFAULT) != 0)\n-            print(\" DO_NOT_RESOLVE_BY_DEFAULT\");\n-        if ((flags & ModuleResolution_attribute.WARN_DEPRECATED) != 0)\n-            print(\" WARN_DEPRECATED\");\n-        if ((flags & ModuleResolution_attribute.WARN_DEPRECATED_FOR_REMOVAL) != 0)\n-            print(\" WARN_DEPRECATED_FOR_REMOVAL\");\n-        if ((flags & ModuleResolution_attribute.WARN_INCUBATING) != 0)\n-            print(\" WARN_INCUBATING\");\n-        println();\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitModuleTarget(ModuleTarget_attribute attr, Void ignore) {\n-        println(\"ModuleTarget:\");\n-        indent(+1);\n-        print(\"target_platform: #\" + attr.target_platform_index);\n-        if (attr.target_platform_index != 0) {\n-            tab();\n-            print(\"\/\/ \" + getTargetPlatform(attr));\n-        }\n-        println();\n-        indent(-1);\n-        return null;\n-    }\n-\n-    private String getTargetPlatform(ModuleTarget_attribute attr) {\n-        try {\n-            return constant_pool.getUTF8Value(attr.target_platform_index);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    @Override\n-    public Void visitNestMembers(NestMembers_attribute attr, Void aVoid) {\n-        println(\"NestMembers:\");\n-        indent(+1);\n-        try {\n-            CONSTANT_Class_info[] children = attr.getChildren(constant_pool);\n-            for (int i = 0; i < attr.members_indexes.length; i++) {\n-                println(constantWriter.stringValue(children[i]));\n-            }\n-            indent(-1);\n-        } catch (ConstantPoolException ex) {\n-            throw new AssertionError(ex);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitRecord(Record_attribute attr, Void p) {\n-        println(\"Record:\");\n-        indent(+1);\n-        for (Record_attribute.ComponentInfo componentInfo : attr.component_info_arr) {\n-            Signature_attribute sigAttr = (Signature_attribute) componentInfo.attributes.get(Attribute.Signature);\n-\n-            if (sigAttr == null)\n-                print(getJavaFieldType(componentInfo.descriptor));\n-            else {\n-                try {\n-                    Type t = sigAttr.getParsedSignature().getType(constant_pool);\n-                    print(getJavaName(t.toString()));\n-                } catch (ConstantPoolException e) {\n-                    \/\/ report error?\n-                    \/\/ fall back on non-generic descriptor\n-                    print(getJavaFieldType(componentInfo.descriptor));\n-                }\n-            }\n-\n-            print(\" \");\n-            try {\n-                print(componentInfo.getName(constant_pool));\n-            } catch (ConstantPoolException e) {\n-                report(e);\n-                return null;\n-            }\n-            print(\";\");\n-            println();\n-            indent(+1);\n-            if (options.showDescriptors) {\n-                println(\"descriptor: \" + getValue(componentInfo.descriptor));\n-            }\n-            if (options.showAllAttrs) {\n-                for (Attribute componentAttr: componentInfo.attributes)\n-                    write(componentInfo, componentAttr, constant_pool);\n-                println();\n-            }\n-            indent(-1);\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    String getValue(Descriptor d) {\n-        try {\n-            return d.getValue(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    void writeList(String prefix, Collection<?> items, String suffix) {\n-        print(prefix);\n-        String sep = \"\";\n-        for (Object item: items) {\n-            print(sep);\n-            print(item);\n-            sep = \", \";\n-        }\n-        print(suffix);\n-    }\n-\n-    String getJavaFieldType(Descriptor d) {\n-        try {\n-            return getJavaName(d.getFieldType(constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        } catch (InvalidDescriptor e) {\n-            return report(e);\n-        }\n-    }\n-\n-    void writeModifiers(Collection<String> items) {\n-        for (Object item: items) {\n-            print(item);\n-            print(\" \");\n-        }\n-    }\n-\n-    @Override\n-    public Void visitRuntimeVisibleAnnotations(RuntimeVisibleAnnotations_attribute attr, Void ignore) {\n-        println(\"RuntimeVisibleAnnotations:\");\n-        indent(+1);\n-        for (int i = 0; i < attr.annotations.length; i++) {\n-            print(i + \": \");\n-            annotationWriter.write(attr.annotations[i]);\n-            println();\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitRuntimeInvisibleAnnotations(RuntimeInvisibleAnnotations_attribute attr, Void ignore) {\n-        println(\"RuntimeInvisibleAnnotations:\");\n-        indent(+1);\n-        for (int i = 0; i < attr.annotations.length; i++) {\n-            print(i + \": \");\n-            annotationWriter.write(attr.annotations[i]);\n-            println();\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitRuntimeVisibleTypeAnnotations(RuntimeVisibleTypeAnnotations_attribute attr, Void ignore) {\n-        println(\"RuntimeVisibleTypeAnnotations:\");\n+    private void printAnnotations(String message, List<? extends Annotation> anno) {\n+        println(message);\n@@ -834,1 +644,1 @@\n-        for (int i = 0; i < attr.annotations.length; i++) {\n+        for (int i = 0; i < anno.size(); i++) {\n@@ -836,1 +646,1 @@\n-            annotationWriter.write(attr.annotations[i]);\n+            annotationWriter.write(anno.get(i));\n@@ -840,1 +650,0 @@\n-        return null;\n@@ -843,3 +652,3 @@\n-    @Override\n-    public Void visitRuntimeInvisibleTypeAnnotations(RuntimeInvisibleTypeAnnotations_attribute attr, Void ignore) {\n-        println(\"RuntimeInvisibleTypeAnnotations:\");\n+    private void printTypeAnnotations(String message,\n+            List<? extends TypeAnnotation> anno, CodeAttribute lr) {\n+        println(message);\n@@ -847,1 +656,1 @@\n-        for (int i = 0; i < attr.annotations.length; i++) {\n+        for (int i = 0; i < anno.size(); i++) {\n@@ -849,1 +658,1 @@\n-            annotationWriter.write(attr.annotations[i]);\n+            annotationWriter.write(anno.get(i), lr);\n@@ -853,1 +662,0 @@\n-        return null;\n@@ -856,1 +664,1 @@\n-    private void visitParameterAnnotations(String message, RuntimeParameterAnnotations_attribute attr) {\n+    private void printParameterAnnotations(String message, List<List<Annotation>> paramsAnno) {\n@@ -859,1 +667,1 @@\n-        for (int param = 0; param < attr.parameter_annotations.length; param++) {\n+        for (int param = 0; param < paramsAnno.size(); param++) {\n@@ -862,1 +670,2 @@\n-            for (int i = 0; i < attr.parameter_annotations[param].length; i++) {\n+            var annos = paramsAnno.get(param);\n+            for (int i = 0; i < annos.size(); i++) {\n@@ -864,1 +673,1 @@\n-                annotationWriter.write(attr.parameter_annotations[param][i]);\n+                annotationWriter.write(annos.get(i));\n@@ -872,97 +681,3 @@\n-    @Override\n-    public Void visitRuntimeVisibleParameterAnnotations(RuntimeVisibleParameterAnnotations_attribute attr, Void ignore) {\n-        visitParameterAnnotations(\"RuntimeVisibleParameterAnnotations:\", (RuntimeParameterAnnotations_attribute) attr);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitRuntimeInvisibleParameterAnnotations(RuntimeInvisibleParameterAnnotations_attribute attr, Void ignore) {\n-        visitParameterAnnotations(\"RuntimeInvisibleParameterAnnotations:\", (RuntimeParameterAnnotations_attribute) attr);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitPermittedSubclasses(PermittedSubclasses_attribute attr, Void ignore) {\n-        println(\"PermittedSubclasses:\");\n-        indent(+1);\n-        try {\n-            CONSTANT_Class_info[] subtypes = attr.getSubtypes(constant_pool);\n-            for (int i = 0; i < subtypes.length; i++) {\n-                println(constantWriter.stringValue(subtypes[i]));\n-            }\n-            indent(-1);\n-        } catch (ConstantPoolException ex) {\n-            throw new AssertionError(ex);\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitSignature(Signature_attribute attr, Void ignore) {\n-        print(\"Signature: #\" + attr.signature_index);\n-        tab();\n-        println(\"\/\/ \" + getSignature(attr));\n-        return null;\n-    }\n-\n-    String getSignature(Signature_attribute info) {\n-        try {\n-            return info.getSignature(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    @Override\n-    public Void visitSourceDebugExtension(SourceDebugExtension_attribute attr, Void ignore) {\n-        println(\"SourceDebugExtension:\");\n-        indent(+1);\n-        for (String s: attr.getValue().split(\"[\\r\\n]+\")) {\n-            println(s);\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitSourceFile(SourceFile_attribute attr, Void ignore) {\n-        println(\"SourceFile: \\\"\" + getSourceFile(attr) + \"\\\"\");\n-        return null;\n-    }\n-\n-    private String getSourceFile(SourceFile_attribute attr) {\n-        try {\n-            return attr.getSourceFile(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    @Override\n-    public Void visitSourceID(SourceID_attribute attr, Void ignore) {\n-        constantWriter.write(attr.sourceID_index);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitStackMap(StackMap_attribute attr, Void ignore) {\n-        println(\"StackMap: number_of_entries = \" + attr.number_of_entries);\n-        indent(+1);\n-        StackMapTableWriter w = new StackMapTableWriter();\n-        for (StackMapTable_attribute.stack_map_frame entry : attr.entries) {\n-            w.write(entry);\n-        }\n-        indent(-1);\n-        return null;\n-    }\n-\n-    @Override\n-    public Void visitStackMapTable(StackMapTable_attribute attr, Void ignore) {\n-        println(\"StackMapTable: number_of_entries = \" + attr.number_of_entries);\n-        indent(+1);\n-        StackMapTableWriter w = new StackMapTableWriter();\n-        for (StackMapTable_attribute.stack_map_frame entry : attr.entries) {\n-            w.write(entry);\n-        }\n-        indent(-1);\n-        return null;\n+    void printHeader(int frameType, String extra) {\n+        print(\"frame_type = \" + frameType + \" \");\n+        println(extra);\n@@ -971,96 +686,8 @@\n-    class StackMapTableWriter \/\/ also handles CLDC StackMap attributes\n-            implements StackMapTable_attribute.stack_map_frame.Visitor<Void,Void> {\n-        public void write(StackMapTable_attribute.stack_map_frame frame) {\n-            frame.accept(this, null);\n-        }\n-\n-        @Override\n-        public Void visit_same_frame(StackMapTable_attribute.same_frame frame, Void p) {\n-            printHeader(frame, \"\/* same *\/\");\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_same_locals_1_stack_item_frame(StackMapTable_attribute.same_locals_1_stack_item_frame frame, Void p) {\n-            printHeader(frame, \"\/* same_locals_1_stack_item *\/\");\n-            indent(+1);\n-            printMap(\"stack\", frame.stack);\n-            indent(-1);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_same_locals_1_stack_item_frame_extended(StackMapTable_attribute.same_locals_1_stack_item_frame_extended frame, Void p) {\n-            printHeader(frame, \"\/* same_locals_1_stack_item_frame_extended *\/\");\n-            indent(+1);\n-            println(\"offset_delta = \" + frame.offset_delta);\n-            printMap(\"stack\", frame.stack);\n-            indent(-1);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_chop_frame(StackMapTable_attribute.chop_frame frame, Void p) {\n-            printHeader(frame, \"\/* chop *\/\");\n-            indent(+1);\n-            println(\"offset_delta = \" + frame.offset_delta);\n-            indent(-1);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_same_frame_extended(StackMapTable_attribute.same_frame_extended frame, Void p) {\n-            printHeader(frame, \"\/* same_frame_extended *\/\");\n-            indent(+1);\n-            println(\"offset_delta = \" + frame.offset_delta);\n-            indent(-1);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_append_frame(StackMapTable_attribute.append_frame frame, Void p) {\n-            printHeader(frame, \"\/* append *\/\");\n-            indent(+1);\n-            println(\"offset_delta = \" + frame.offset_delta);\n-            printMap(\"locals\", frame.locals);\n-            indent(-1);\n-            return null;\n-        }\n-\n-        @Override\n-        public Void visit_full_frame(StackMapTable_attribute.full_frame frame, Void p) {\n-            if (frame instanceof StackMap_attribute.stack_map_frame) {\n-                printHeader(frame, \"offset = \" + frame.offset_delta);\n-                indent(+1);\n-            } else {\n-                printHeader(frame, \"\/* full_frame *\/\");\n-                indent(+1);\n-                println(\"offset_delta = \" + frame.offset_delta);\n-            }\n-            printMap(\"locals\", frame.locals);\n-            printMap(\"stack\", frame.stack);\n-            indent(-1);\n-            return null;\n-        }\n-\n-        void printHeader(StackMapTable_attribute.stack_map_frame frame, String extra) {\n-            print(\"frame_type = \" + frame.frame_type + \" \");\n-            println(extra);\n-        }\n-\n-        void printMap(String name, StackMapTable_attribute.verification_type_info[] map) {\n-            print(name + \" = [\");\n-            for (int i = 0; i < map.length; i++) {\n-                StackMapTable_attribute.verification_type_info info = map[i];\n-                int tag = info.tag;\n-                switch (tag) {\n-                    case StackMapTable_attribute.verification_type_info.ITEM_Object:\n-                        print(\" \");\n-                        constantWriter.write(((StackMapTable_attribute.Object_variable_info) info).cpool_index);\n-                        break;\n-                    case StackMapTable_attribute.verification_type_info.ITEM_Uninitialized:\n-                        print(\" \" + mapTypeName(tag));\n-                        print(\" \" + ((StackMapTable_attribute.Uninitialized_variable_info) info).offset);\n-                        break;\n-                    default:\n-                        print(\" \" + mapTypeName(tag));\n+    void printMap(String name, List<VerificationTypeInfo> map, CodeAttribute lr) {\n+        print(name + \" = [\");\n+        for (int i = 0; i < map.size(); i++) {\n+            var info = map.get(i);\n+            switch (info) {\n+                case ObjectVerificationTypeInfo obj -> {\n+                    print(\" \");\n+                    constantWriter.write(obj.className().index());\n@@ -1068,37 +695,5 @@\n-                print(i == (map.length - 1) ? \" \" : \",\");\n-            }\n-            println(\"]\");\n-        }\n-\n-        String mapTypeName(int tag) {\n-            switch (tag) {\n-            case StackMapTable_attribute.verification_type_info.ITEM_Top:\n-                return \"top\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Integer:\n-                return \"int\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Float:\n-                return \"float\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Long:\n-                return \"long\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Double:\n-                return \"double\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Null:\n-                return \"null\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_UninitializedThis:\n-                return \"this\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Object:\n-                return \"CP\";\n-\n-            case StackMapTable_attribute.verification_type_info.ITEM_Uninitialized:\n-                return \"uninitialized\";\n-\n-            default:\n-                report(\"unrecognized verification_type_info tag: \" + tag);\n-                return \"[tag:\" + tag + \"]\";\n+                case UninitializedVerificationTypeInfo u -> {\n+                    print(\" uninitialized \" + lr.labelToBci(u.newTarget()));\n+                }\n+                case SimpleVerificationTypeInfo s ->\n+                    print(\" \" + mapTypeName(s));\n@@ -1106,0 +701,1 @@\n+            print(i == (map.size() - 1) ? \" \" : \",\");\n@@ -1107,0 +703,1 @@\n+        println(\"]\");\n@@ -1109,4 +706,10 @@\n-    @Override\n-    public Void visitSynthetic(Synthetic_attribute attr, Void ignore) {\n-        println(\"Synthetic: true\");\n-        return null;\n+    String mapTypeName(SimpleVerificationTypeInfo type) {\n+        return switch (type) {\n+            case ITEM_TOP -> \"top\";\n+            case ITEM_INTEGER -> \"int\";\n+            case ITEM_FLOAT -> \"float\";\n+            case ITEM_LONG -> \"long\";\n+            case ITEM_DOUBLE -> \"double\";\n+            case ITEM_NULL -> \"null\";\n+            case ITEM_UNINITIALIZED_THIS -> \"this\";\n+        };\n@@ -1124,1 +727,1 @@\n-        return StringUtils.toUpperCase(Integer.toString(i, 16));\n+        return Integer.toString(i, 16).toUpperCase(Locale.US);\n@@ -1128,1 +731,1 @@\n-        String s = StringUtils.toUpperCase(Integer.toHexString(i));\n+        String s = Integer.toHexString(i).toUpperCase(Locale.US);\n@@ -1131,1 +734,1 @@\n-        return StringUtils.toUpperCase(s);\n+        return s;\n@@ -1146,3 +749,0 @@\n-\n-    private ConstantPool constant_pool;\n-    private Object owner;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AttributeWriter.java","additions":591,"deletions":991,"binary":false,"changes":1582,"status":"modified"},{"patch":"@@ -29,4 +29,1 @@\n-\n-import com.sun.tools.classfile.AttributeException;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.DescriptorException;\n+import java.util.function.Supplier;\n@@ -60,0 +57,8 @@\n+    protected void print(Supplier<Object> safeguardedCode) {\n+        try {\n+            print(safeguardedCode.get());\n+        } catch (IllegalArgumentException e) {\n+            print(report(e));\n+        }\n+    }\n+\n@@ -74,0 +79,5 @@\n+    protected void println(Supplier<Object> safeguardedCode) {\n+        print(safeguardedCode);\n+        lineWriter.println();\n+    }\n+\n@@ -86,11 +96,1 @@\n-    protected String report(AttributeException e) {\n-        out.println(\"Error: \" + e.getMessage()); \/\/ i18n?\n-        return \"???\";\n-    }\n-\n-    protected String report(ConstantPoolException e) {\n-        out.println(\"Error: \" + e.getMessage()); \/\/ i18n?\n-        return \"???\";\n-    }\n-\n-    protected String report(DescriptorException e) {\n+    protected String report(Exception e) {\n@@ -98,0 +98,1 @@\n+        errorReported = true;\n@@ -103,0 +104,1 @@\n+        errorReported = true;\n@@ -126,0 +128,1 @@\n+    protected boolean errorReported;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/BasicWriter.java","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -35,29 +35,17 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Attributes;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.ConstantValue_attribute;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Exceptions_attribute;\n-import com.sun.tools.classfile.Field;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.Module_attribute;\n-import com.sun.tools.classfile.Signature;\n-import com.sun.tools.classfile.Signature_attribute;\n-import com.sun.tools.classfile.SourceFile_attribute;\n-import com.sun.tools.classfile.Type;\n-import com.sun.tools.classfile.Type.ArrayType;\n-import com.sun.tools.classfile.Type.ClassSigType;\n-import com.sun.tools.classfile.Type.ClassType;\n-import com.sun.tools.classfile.Type.MethodType;\n-import com.sun.tools.classfile.Type.SimpleType;\n-import com.sun.tools.classfile.Type.TypeParamType;\n-import com.sun.tools.classfile.Type.WildcardType;\n-\n-import static com.sun.tools.classfile.AccessFlags.*;\n-import static com.sun.tools.classfile.ConstantPool.CONSTANT_Module;\n-import static com.sun.tools.classfile.ConstantPool.CONSTANT_Package;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.Modifier;\n+import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n+import jdk.internal.classfile.AccessFlags;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassSignature;\n+import jdk.internal.classfile.Classfile;\n+import static jdk.internal.classfile.Classfile.*;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.FieldModel;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.MethodSignature;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.attribute.SignatureAttribute;\n@@ -88,0 +76,1 @@\n+        sigPrinter = new SignaturePrinter(options.verbose);\n@@ -107,2 +96,2 @@\n-    protected ClassFile getClassFile() {\n-        return classFile;\n+    protected ClassModel getClassModel() {\n+        return classModel;\n@@ -111,3 +100,2 @@\n-    protected void setClassFile(ClassFile cf) {\n-        classFile = cf;\n-        constant_pool = classFile.constant_pool;\n+    protected void setClassFile(ClassModel cm) {\n+        classModel = cm;\n@@ -116,1 +104,1 @@\n-    protected Method getMethod() {\n+    protected MethodModel getMethod() {\n@@ -120,1 +108,1 @@\n-    protected void setMethod(Method m) {\n+    protected void setMethod(MethodModel m) {\n@@ -124,2 +112,3 @@\n-    public void write(ClassFile cf) {\n-        setClassFile(cf);\n+    public boolean write(ClassModel cm) {\n+        errorReported = false;\n+        setClassFile(cm);\n@@ -139,1 +128,2 @@\n-                    println(\"Last modified \" + df.format(lm) + \"; size \" + size + \" bytes\");\n+                    println(\"Last modified \" + df.format(lm) + \"; size \" + size\n+                            + \" bytes\");\n@@ -154,4 +144,2 @@\n-        Attribute sfa = cf.getAttribute(Attribute.SourceFile);\n-        if (sfa instanceof SourceFile_attribute) {\n-            println(\"Compiled from \\\"\" + getSourceFile((SourceFile_attribute) sfa) + \"\\\"\");\n-        }\n+        cm.findAttribute(Attributes.SOURCE_FILE).ifPresent(sfa ->\n+            println(\"Compiled from \\\"\" + sfa.sourceFile().stringValue() + \"\\\"\"));\n@@ -163,19 +151,7 @@\n-        AccessFlags flags = cf.access_flags;\n-        writeModifiers(flags.getClassModifiers());\n-\n-        if (classFile.access_flags.is(AccessFlags.ACC_MODULE)) {\n-            Attribute attr = classFile.attributes.get(Attribute.Module);\n-            if (attr instanceof Module_attribute) {\n-                Module_attribute modAttr = (Module_attribute) attr;\n-                String name;\n-                try {\n-                    \/\/ FIXME: compatibility code\n-                    if (constant_pool.get(modAttr.module_name).getTag() == CONSTANT_Module) {\n-                        name = getJavaName(constant_pool.getModuleInfo(modAttr.module_name).getName());\n-                    } else {\n-                        name = getJavaName(constant_pool.getUTF8Value(modAttr.module_name));\n-                    }\n-                } catch (ConstantPoolException e) {\n-                    name = report(e);\n-                }\n-                if ((modAttr.module_flags & Module_attribute.ACC_OPEN) != 0) {\n+        writeModifiers(getClassModifiers(cm.flags().flagsMask()));\n+\n+        if ((classModel.flags().flagsMask() & ACC_MODULE) != 0) {\n+            var attr = classModel.findAttribute(Attributes.MODULE);\n+            if (attr.isPresent()) {\n+                var modAttr = attr.get();\n+                if ((modAttr.moduleFlagsMask() & ACC_OPEN) != 0) {\n@@ -185,2 +161,2 @@\n-                print(name);\n-                if (modAttr.module_version_index != 0) {\n+                print(() -> modAttr.moduleName().name().stringValue());\n+                if (modAttr.moduleVersion().isPresent()) {\n@@ -188,1 +164,1 @@\n-                    print(getUTF8Value(modAttr.module_version_index));\n+                    print(() -> modAttr.moduleVersion().get().stringValue());\n@@ -193,1 +169,1 @@\n-                print(getJavaName(classFile));\n+                print(() -> getJavaName(classModel.thisClass().asInternalName()));\n@@ -196,1 +172,1 @@\n-            if (classFile.isClass())\n+            if ((classModel.flags().flagsMask() & ACC_INTERFACE) == 0)\n@@ -198,1 +174,1 @@\n-            else if (classFile.isInterface())\n+            else\n@@ -201,1 +177,1 @@\n-            print(getJavaName(classFile));\n+            print(() -> getJavaName(classModel.thisClass().asInternalName()));\n@@ -204,8 +180,11 @@\n-        Signature_attribute sigAttr = getSignature(cf.attributes);\n-        if (sigAttr == null) {\n-            \/\/ use info from class file header\n-            if (classFile.isClass() && classFile.super_class != 0 ) {\n-                String sn = getJavaSuperclassName(cf);\n-                if (!sn.equals(\"java.lang.Object\")) {\n-                    print(\" extends \");\n-                    print(sn);\n+        try {\n+            var sigAttr = classModel.findAttribute(Attributes.SIGNATURE).orElse(null);\n+            if (sigAttr == null) {\n+                \/\/ use info from class file header\n+                if ((classModel.flags().flagsMask() & ACC_INTERFACE) == 0\n+                        && classModel.superclass().isPresent()) {\n+                    String sn = getJavaName(classModel.superclass().get().asInternalName());\n+                    if (!sn.equals(\"java.lang.Object\")) {\n+                        print(\" extends \");\n+                        print(sn);\n+                    }\n@@ -213,16 +192,5 @@\n-            }\n-            for (int i = 0; i < classFile.interfaces.length; i++) {\n-                print(i == 0 ? (classFile.isClass() ? \" implements \" : \" extends \") : \",\");\n-                print(getJavaInterfaceName(classFile, i));\n-            }\n-        } else {\n-            try {\n-                Type t = sigAttr.getParsedSignature().getType(constant_pool);\n-                JavaTypePrinter p = new JavaTypePrinter(classFile.isInterface());\n-                \/\/ The signature parser cannot disambiguate between a\n-                \/\/ FieldType and a ClassSignatureType that only contains a superclass type.\n-                if (t instanceof Type.ClassSigType) {\n-                    print(p.print(t));\n-                } else if (options.verbose || !t.isObject()) {\n-                    print(\" extends \");\n-                    print(p.print(t));\n+                var interfaces = classModel.interfaces();\n+                for (int i = 0; i < interfaces.size(); i++) {\n+                    print(i == 0 ? ((classModel.flags().flagsMask() & ACC_INTERFACE) == 0\n+                            ? \" implements \" : \" extends \") : \",\");\n+                    print(getJavaName(interfaces.get(i).asInternalName()));\n@@ -230,4 +198,3 @@\n-            } catch (ConstantPoolException e) {\n-                print(report(e));\n-            } catch (IllegalStateException e) {\n-                report(\"Invalid value for Signature attribute: \" + e.getMessage());\n+            } else {\n+                var t = sigAttr.asClassSignature();\n+                print(sigPrinter.print(t, (classModel.flags().flagsMask() & ACC_INTERFACE) != 0));\n@@ -235,0 +202,2 @@\n+        } catch (IllegalArgumentException e) {\n+            report(e);\n@@ -240,8 +209,7 @@\n-            println(\"minor version: \" + cf.minor_version);\n-            println(\"major version: \" + cf.major_version);\n-            writeList(String.format(\"flags: (0x%04x) \", flags.flags), flags.getClassFlags(), \"\\n\");\n-            print(\"this_class: #\" + cf.this_class);\n-            if (cf.this_class != 0) {\n-                tab();\n-                print(\"\/\/ \" + constantWriter.stringValue(cf.this_class));\n-            }\n+            println(\"minor version: \" + classModel.minorVersion());\n+            println(\"major version: \" + classModel.majorVersion());\n+            writeList(String.format(\"flags: (0x%04x) \", cm.flags().flagsMask()),\n+                    getClassFlags(cm.flags().flagsMask()), \"\\n\");\n+            print(\"this_class: #\");print(() -> classModel.thisClass().index());\n+            tab();\n+            print(() -> \"\/\/ \" + classModel.thisClass().asInternalName());\n@@ -249,4 +217,9 @@\n-            print(\"super_class: #\" + cf.super_class);\n-            if (cf.super_class != 0) {\n-                tab();\n-                print(\"\/\/ \" + constantWriter.stringValue(cf.super_class));\n+            print(\"super_class: #\");print(() -> classModel.superclass()\n+                    .map(ClassEntry::index).orElse(0));\n+            try {\n+                if (classModel.superclass().isPresent()) {\n+                    tab();\n+                    print(() -> \"\/\/ \" + classModel.superclass().get().asInternalName());\n+                }\n+            } catch (IllegalArgumentException e) {\n+                report(e);\n@@ -255,4 +228,4 @@\n-            print(\"interfaces: \" + cf.interfaces.length);\n-            print(\", fields: \" + cf.fields.length);\n-            print(\", methods: \" + cf.methods.length);\n-            println(\", attributes: \" + cf.attributes.attrs.length);\n+            print(\"interfaces: \");print(() -> classModel.interfaces().size());\n+            print(\", fields: \" + classModel.fields().size());\n+            print(\", methods: \" + classModel.methods().size());\n+            println(\", attributes: \" + classModel.attributes().size());\n@@ -267,1 +240,1 @@\n-        if (flags.is(AccessFlags.ACC_MODULE) && !options.verbose) {\n+        if ((cm.flags().flagsMask() & ACC_MODULE) != 0 && !options.verbose) {\n@@ -276,1 +249,1 @@\n-            attrWriter.write(cf, cf.attributes, constant_pool);\n+            attrWriter.write(classModel.attributes());\n@@ -278,0 +251,1 @@\n+        return !errorReported;\n@@ -280,2 +254,0 @@\n-        class JavaTypePrinter implements Type.Visitor<StringBuilder,StringBuilder> {\n-            boolean isInterface;\n@@ -283,3 +255,1 @@\n-            JavaTypePrinter(boolean isInterface) {\n-                this.isInterface = isInterface;\n-            }\n+    final SignaturePrinter sigPrinter;\n@@ -287,3 +257,1 @@\n-            String print(Type t) {\n-                return t.accept(this, new StringBuilder()).toString();\n-            }\n+    public static record SignaturePrinter(boolean verbose) {\n@@ -291,4 +259,22 @@\n-            String printTypeArgs(List<? extends TypeParamType> typeParamTypes) {\n-                StringBuilder builder = new StringBuilder();\n-                appendIfNotEmpty(builder, \"<\", typeParamTypes, \"> \");\n-                return builder.toString();\n+        public String print(ClassSignature cs, boolean isInterface) {\n+            var sb = new StringBuilder();\n+            print(sb, cs.typeParameters());\n+            if (isInterface) {\n+                String sep = \" extends \";\n+                for (var is : cs.superinterfaceSignatures()) {\n+                    sb.append(sep);\n+                    print(sb, is);\n+                    sep = \", \";\n+                }\n+            } else {\n+                if (cs.superclassSignature() != null\n+                        && (verbose || !isObject(cs.superclassSignature()))) {\n+                    sb.append(\" extends \");\n+                    print(sb, cs.superclassSignature());\n+                }\n+                String sep = \" implements \";\n+                for (var is : cs.superinterfaceSignatures()) {\n+                    sb.append(sep);\n+                    print(sb, is);\n+                    sep = \", \";\n+                }\n@@ -296,0 +282,2 @@\n+            return sb.toString();\n+        }\n@@ -297,5 +285,5 @@\n-            @Override\n-            public StringBuilder visitSimpleType(SimpleType type, StringBuilder sb) {\n-                sb.append(getJavaName(type.name));\n-                return sb;\n-            }\n+        public String print(Signature sig) {\n+            var sb = new StringBuilder();\n+            print(sb, sig);\n+            return sb.toString();\n+        }\n@@ -303,6 +291,5 @@\n-            @Override\n-            public StringBuilder visitArrayType(ArrayType type, StringBuilder sb) {\n-                append(sb, type.elemType);\n-                sb.append(\"[]\");\n-                return sb;\n-            }\n+        public String printTypeParams(List<Signature.TypeParam> tps) {\n+            var sb = new StringBuilder();\n+            print(sb, tps);\n+            return sb.toString();\n+        }\n@@ -310,7 +297,9 @@\n-            @Override\n-            public StringBuilder visitMethodType(MethodType type, StringBuilder sb) {\n-                appendIfNotEmpty(sb, \"<\", type.typeParamTypes, \"> \");\n-                append(sb, type.returnType);\n-                append(sb, \" (\", type.paramTypes, \")\");\n-                appendIfNotEmpty(sb, \" throws \", type.throwsTypes, \"\");\n-                return sb;\n+        public String printList(String prefix, List<? extends Signature> args,\n+                String postfix) {\n+            var sb = new StringBuilder();\n+            sb.append(prefix);\n+            String sep = \"\";\n+            for (var arg : args) {\n+                sb.append(sep);\n+                print(sb, arg);\n+                sep = \", \";\n@@ -318,0 +307,2 @@\n+            return sb.append(postfix).toString();\n+        }\n@@ -319,10 +310,24 @@\n-            @Override\n-            public StringBuilder visitClassSigType(ClassSigType type, StringBuilder sb) {\n-                appendIfNotEmpty(sb, \"<\", type.typeParamTypes, \">\");\n-                if (isInterface) {\n-                    appendIfNotEmpty(sb, \" extends \", type.superinterfaceTypes, \"\");\n-                } else {\n-                    if (type.superclassType != null\n-                            && (options.verbose || !type.superclassType.isObject())) {\n-                        sb.append(\" extends \");\n-                        append(sb, type.superclassType);\n+        private boolean isObject(Signature sig) {\n+            return (sig instanceof Signature.ClassTypeSig cts)\n+                    && cts.outerType().isEmpty()\n+                    && cts.className().equals(\"java\/lang\/Object\")\n+                    && (cts.typeArgs().isEmpty());\n+        }\n+\n+        private void print(StringBuilder sb, List<Signature.TypeParam> tps) {\n+            if (!tps.isEmpty()) {\n+                sb.append('<');\n+                String sep = \"\";\n+                for (var tp : tps) {\n+                    sb.append(sep).append(tp.identifier());\n+                    sep = \" extends \";\n+                    if (tp.classBound().isPresent()\n+                            && (verbose || !isObject(tp.classBound().get()))) {\n+                        sb.append(sep);\n+                        print(sb, tp.classBound().get());\n+                        sep = \" & \";\n+                    }\n+                    for (var bound: tp.interfaceBounds()) {\n+                        sb.append(sep);\n+                        print(sb, bound);\n+                        sep = \" & \";\n@@ -330,1 +335,1 @@\n-                    appendIfNotEmpty(sb, \" implements \", type.superinterfaceTypes, \"\");\n+                    sep = \", \";\n@@ -332,1 +337,1 @@\n-                return sb;\n+                sb.append('>');\n@@ -334,0 +339,1 @@\n+        }\n@@ -335,4 +341,6 @@\n-            @Override\n-            public StringBuilder visitClassType(ClassType type, StringBuilder sb) {\n-                if (type.outerType != null) {\n-                    append(sb, type.outerType);\n+        private void print(StringBuilder sb, Signature sig) {\n+            if (sig instanceof Signature.BaseTypeSig bts) {\n+                    sb.append(ClassDesc.ofDescriptor(\"\" + bts.baseType()).displayName());\n+            } else if (sig instanceof Signature.ClassTypeSig cts) {\n+                if (cts.outerType().isPresent()) {\n+                    print(sb, cts.outerType().get());\n@@ -341,17 +349,5 @@\n-                sb.append(getJavaName(type.name));\n-                appendIfNotEmpty(sb, \"<\", type.typeArgs, \">\");\n-                return sb;\n-            }\n-\n-            @Override\n-            public StringBuilder visitTypeParamType(TypeParamType type, StringBuilder sb) {\n-                sb.append(type.name);\n-                String sep = \" extends \";\n-                if (type.classBound != null\n-                        && (options.verbose || !type.classBound.isObject())) {\n-                    sb.append(sep);\n-                    append(sb, type.classBound);\n-                    sep = \" & \";\n-                }\n-                if (type.interfaceBounds != null) {\n-                    for (Type bound: type.interfaceBounds) {\n+                sb.append(getJavaName(cts.className()));\n+                if (!cts.typeArgs().isEmpty()) {\n+                    String sep = \"\";\n+                    sb.append('<');\n+                    for (var ta : cts.typeArgs()) {\n@@ -359,2 +355,2 @@\n-                        append(sb, bound);\n-                        sep = \" & \";\n+                        print(sb, ta);\n+                        sep = \", \";\n@@ -362,0 +358,1 @@\n+                    sb.append('>');\n@@ -363,1 +360,5 @@\n-                return sb;\n+            } else if (sig instanceof Signature.TypeVarSig tvs) {\n+                sb.append(tvs.identifier());\n+            } else if (sig instanceof Signature.ArrayTypeSig ats) {\n+                print(sb, ats.componentSignature());\n+                sb.append(\"[]\");\n@@ -365,0 +366,1 @@\n+        }\n@@ -366,16 +368,7 @@\n-            @Override\n-            public StringBuilder visitWildcardType(WildcardType type, StringBuilder sb) {\n-                switch (type.kind) {\n-                    case UNBOUNDED:\n-                        sb.append(\"?\");\n-                        break;\n-                    case EXTENDS:\n-                        sb.append(\"? extends \");\n-                        append(sb, type.boundType);\n-                        break;\n-                    case SUPER:\n-                        sb.append(\"? super \");\n-                        append(sb, type.boundType);\n-                        break;\n-                    default:\n-                        throw new AssertionError();\n+        private void print(StringBuilder sb, Signature.TypeArg ta) {\n+            switch (ta.wildcardIndicator()) {\n+                case DEFAULT -> print(sb, ta.boundType().get());\n+                case UNBOUNDED -> sb.append('?');\n+                case EXTENDS -> {\n+                    sb.append(\"? extends \");\n+                    print(sb, ta.boundType().get());\n@@ -383,14 +376,3 @@\n-                return sb;\n-            }\n-\n-            private void append(StringBuilder sb, Type t) {\n-                t.accept(this, sb);\n-            }\n-\n-            private void append(StringBuilder sb, String prefix, List<? extends Type> list, String suffix) {\n-                sb.append(prefix);\n-                String sep = \"\";\n-                for (Type t: list) {\n-                    sb.append(sep);\n-                    append(sb, t);\n-                    sep = \", \";\n+                case SUPER -> {\n+                    sb.append(\"? super \");\n+                    print(sb, ta.boundType().get());\n@@ -398,10 +380,0 @@\n-                sb.append(suffix);\n-            }\n-\n-            private void appendIfNotEmpty(StringBuilder sb, String prefix, List<? extends Type> list, String suffix) {\n-                if (!isEmpty(list))\n-                    append(sb, prefix, list, suffix);\n-            }\n-\n-            private boolean isEmpty(List<? extends Type> list) {\n-                return (list == null || list.isEmpty());\n@@ -410,0 +382,1 @@\n+    }\n@@ -412,1 +385,1 @@\n-        for (Field f: classFile.fields) {\n+        for (var f: classModel.fields()) {\n@@ -417,2 +390,2 @@\n-    protected void writeField(Field f) {\n-        if (!options.checkAccess(f.access_flags))\n+    protected void writeField(FieldModel f) {\n+        if (!options.checkAccess(f.flags().flagsMask()))\n@@ -421,15 +394,7 @@\n-        AccessFlags flags = f.access_flags;\n-        writeModifiers(flags.getFieldModifiers());\n-        Signature_attribute sigAttr = getSignature(f.attributes);\n-        if (sigAttr == null)\n-            print(getJavaFieldType(f.descriptor));\n-        else {\n-            try {\n-                Type t = sigAttr.getParsedSignature().getType(constant_pool);\n-                print(getJavaName(t.toString()));\n-            } catch (ConstantPoolException e) {\n-                \/\/ report error?\n-                \/\/ fall back on non-generic descriptor\n-                print(getJavaFieldType(f.descriptor));\n-            }\n-        }\n+        var flags = AccessFlags.ofField(f.flags().flagsMask());\n+        writeModifiers(flags.flags().stream().filter(fl -> fl.sourceModifier())\n+                .map(fl -> Modifier.toString(fl.mask())).toList());\n+        print(() -> sigPrinter.print(\n+                f.findAttribute(Attributes.SIGNATURE)\n+                        .map(SignatureAttribute::asTypeSignature)\n+                        .orElseGet(() -> Signature.of(f.fieldTypeSymbol()))));\n@@ -437,1 +402,1 @@\n-        print(getFieldName(f));\n+        print(() -> f.fieldName().stringValue());\n@@ -439,2 +404,2 @@\n-            Attribute a = f.attributes.get(Attribute.ConstantValue);\n-            if (a instanceof ConstantValue_attribute) {\n+            var a = f.findAttribute(Attributes.CONSTANT_VALUE);\n+            if (a.isPresent()) {\n@@ -442,2 +407,2 @@\n-                ConstantValue_attribute cv = (ConstantValue_attribute) a;\n-                print(getConstantValue(f.descriptor, cv.constantvalue_index));\n+                var cv = a.get();\n+                print(() -> getConstantValue(f.fieldTypeSymbol(), cv.constant()));\n@@ -453,2 +418,3 @@\n-        if (options.showDescriptors)\n-            println(\"descriptor: \" + getValue(f.descriptor));\n+        if (options.showDescriptors) {\n+            print(\"descriptor: \");println(() -> f.fieldType().stringValue());\n+        }\n@@ -457,1 +423,3 @@\n-            writeList(String.format(\"flags: (0x%04x) \", flags.flags), flags.getFieldFlags(), \"\\n\");\n+            writeList(String.format(\"flags: (0x%04x) \", flags.flagsMask()),\n+                    flags.flags().stream().map(fl -> \"ACC_\" + fl.name()).toList(),\n+                    \"\\n\");\n@@ -460,2 +428,1 @@\n-            for (Attribute attr: f.attributes)\n-                attrWriter.write(f, attr, constant_pool);\n+            attrWriter.write(f.attributes());\n@@ -472,1 +439,1 @@\n-        for (Method m: classFile.methods)\n+        for (MethodModel m: classModel.methods())\n@@ -480,2 +447,2 @@\n-    protected void writeMethod(Method m) {\n-        if (!options.checkAccess(m.access_flags))\n+    protected void writeMethod(MethodModel m) {\n+        if (!options.checkAccess(m.flags().flagsMask()))\n@@ -486,1 +453,1 @@\n-        AccessFlags flags = m.access_flags;\n+        int flags = m.flags().flagsMask();\n@@ -488,3 +455,3 @@\n-        Descriptor d;\n-        Type.MethodType methodType;\n-        List<? extends Type> methodExceptions;\n+        var modifiers = new ArrayList<String>();\n+        for (var f : AccessFlags.ofMethod(flags).flags())\n+            if (f.sourceModifier()) modifiers.add(Modifier.toString(f.mask()));\n@@ -492,19 +459,5 @@\n-        Signature_attribute sigAttr = getSignature(m.attributes);\n-        if (sigAttr == null) {\n-            d = m.descriptor;\n-            methodType = null;\n-            methodExceptions = null;\n-        } else {\n-            Signature methodSig = sigAttr.getParsedSignature();\n-            d = methodSig;\n-            try {\n-                methodType = (Type.MethodType) methodSig.getType(constant_pool);\n-                methodExceptions = methodType.throwsTypes;\n-                if (methodExceptions != null && methodExceptions.isEmpty())\n-                    methodExceptions = null;\n-            } catch (ConstantPoolException | IllegalStateException e) {\n-                \/\/ report error?\n-                \/\/ fall back on standard descriptor\n-                methodType = null;\n-                methodExceptions = null;\n-            }\n+        String name = \"???\";\n+        try {\n+            name = m.methodName().stringValue();\n+        } catch (IllegalArgumentException e) {\n+            report(e);\n@@ -513,8 +466,6 @@\n-        Set<String> modifiers = flags.getMethodModifiers();\n-\n-        String name = getName(m);\n-        if (classFile.isInterface() &&\n-                (!flags.is(AccessFlags.ACC_ABSTRACT)) && !name.equals(\"<clinit>\")) {\n-            if (classFile.major_version > DEFAULT_ALLOWED_MAJOR_VERSION ||\n-                    (classFile.major_version == DEFAULT_ALLOWED_MAJOR_VERSION && classFile.minor_version >= DEFAULT_ALLOWED_MINOR_VERSION)) {\n-                if (!flags.is(AccessFlags.ACC_STATIC | AccessFlags.ACC_PRIVATE)) {\n+        if ((classModel.flags().flagsMask() & ACC_INTERFACE) != 0 &&\n+                ((flags & ACC_ABSTRACT) == 0) && !name.equals(\"<clinit>\")) {\n+            if (classModel.majorVersion() > DEFAULT_ALLOWED_MAJOR_VERSION ||\n+                    (classModel.majorVersion() == DEFAULT_ALLOWED_MAJOR_VERSION\n+                    && classModel.minorVersion() >= DEFAULT_ALLOWED_MINOR_VERSION)) {\n+                if ((flags & (ACC_STATIC | ACC_PRIVATE)) == 0) {\n@@ -525,1 +476,0 @@\n-\n@@ -527,18 +477,0 @@\n-        if (methodType != null) {\n-            print(new JavaTypePrinter(false).printTypeArgs(methodType.typeParamTypes));\n-        }\n-        switch (name) {\n-            case \"<init>\":\n-                print(getJavaName(classFile));\n-                print(getJavaParameterTypes(d, flags));\n-                break;\n-            case \"<clinit>\":\n-                print(\"{}\");\n-                break;\n-            default:\n-                print(getJavaReturnType(d));\n-                print(\" \");\n-                print(name);\n-                print(getJavaParameterTypes(d, flags));\n-                break;\n-        }\n@@ -546,4 +478,32 @@\n-        Attribute e_attr = m.attributes.get(Attribute.Exceptions);\n-        if (e_attr != null) { \/\/ if there are generic exceptions, there must be erased exceptions\n-            if (e_attr instanceof Exceptions_attribute) {\n-                Exceptions_attribute exceptions = (Exceptions_attribute) e_attr;\n+        try {\n+            var sigAttr = m.findAttribute(Attributes.SIGNATURE);\n+            MethodSignature d;\n+            if (sigAttr.isEmpty()) {\n+                d = MethodSignature.parseFrom(m.methodType().stringValue());\n+            } else {\n+                d = sigAttr.get().asMethodSignature();\n+            }\n+\n+            if (!d.typeParameters().isEmpty()) {\n+                print(sigPrinter.printTypeParams(d.typeParameters()) + \" \");\n+            }\n+            switch (name) {\n+                case \"<init>\":\n+                    print(getJavaName(classModel.thisClass().asInternalName()));\n+                    print(getJavaParameterTypes(d, flags));\n+                    break;\n+                case \"<clinit>\":\n+                    print(\"{}\");\n+                    break;\n+                default:\n+                    print(getJavaName(sigPrinter.print(d.result())));\n+                    print(\" \");\n+                    print(name);\n+                    print(getJavaParameterTypes(d, flags));\n+                    break;\n+            }\n+\n+            var e_attr = m.findAttribute(Attributes.EXCEPTIONS);\n+            \/\/ if there are generic exceptions, there must be erased exceptions\n+            if (e_attr.isPresent()) {\n+                var exceptions = e_attr.get();\n@@ -551,2 +511,2 @@\n-                if (methodExceptions != null) { \/\/ use generic list if available\n-                    writeList(\"\", methodExceptions, \"\");\n+                if (d != null && !d.throwableSignatures().isEmpty()) { \/\/ use generic list if available\n+                    print(() -> sigPrinter.printList(\"\", d.throwableSignatures(), \"\"));\n@@ -554,1 +514,2 @@\n-                    for (int i = 0; i < exceptions.number_of_exceptions; i++) {\n+                    var exNames = exceptions.exceptions();\n+                    for (int i = 0; i < exNames.size(); i++) {\n@@ -557,1 +518,2 @@\n-                        print(getJavaException(exceptions, i));\n+                        int ii = i;\n+                        print(() -> getJavaName(exNames.get(ii).asInternalName()));\n@@ -560,2 +522,0 @@\n-            } else {\n-                report(\"Unexpected or invalid value for Exceptions attribute\");\n@@ -563,0 +523,2 @@\n+        } catch (IllegalArgumentException e) {\n+            report(e);\n@@ -570,1 +532,1 @@\n-            println(\"descriptor: \" + getValue(m.descriptor));\n+            print(\"descriptor: \");println(() -> m.methodType().stringValue());\n@@ -574,1 +536,8 @@\n-            writeList(String.format(\"flags: (0x%04x) \", flags.flags), flags.getMethodFlags(), \"\\n\");\n+            StringBuilder sb = new StringBuilder();\n+            String sep = \"\";\n+            sb.append(String.format(\"flags: (0x%04x) \", flags));\n+            for (var f : AccessFlags.ofMethod(flags).flags()) {\n+                sb.append(sep).append(\"ACC_\").append(f.name());\n+                sep = \", \";\n+            }\n+            println(sb.toString());\n@@ -577,8 +546,1 @@\n-        Code_attribute code = null;\n-        Attribute c_attr = m.attributes.get(Attribute.Code);\n-        if (c_attr != null) {\n-            if (c_attr instanceof Code_attribute)\n-                code = (Code_attribute) c_attr;\n-            else\n-                report(\"Unexpected or invalid value for Code attribute\");\n-        }\n+        var code = (CodeAttribute)m.code().orElse(null);\n@@ -587,3 +549,1 @@\n-            Attribute[] attrs = m.attributes.attrs;\n-            for (Attribute attr: attrs)\n-                attrWriter.write(m, attr, constant_pool);\n+            attrWriter.write(m.attributes());\n@@ -598,2 +558,4 @@\n-                attrWriter.write(code, code.attributes.get(Attribute.LineNumberTable), constant_pool);\n-                attrWriter.write(code, code.attributes.get(Attribute.LocalVariableTable), constant_pool);\n+                code.findAttribute(Attributes.LINE_NUMBER_TABLE)\n+                        .ifPresent(a -> attrWriter.write(a, code));\n+                code.findAttribute(Attributes.LOCAL_VARIABLE_TABLE)\n+                        .ifPresent(a -> attrWriter.write(a, code));\n@@ -622,0 +584,3 @@\n+    public static final int ACC_TRANSITIVE = 0x0020;\n+    public static final int ACC_STATIC_PHASE = 0x0040;\n+\n@@ -623,2 +588,2 @@\n-        Attribute attr = classFile.attributes.get(Attribute.Module);\n-        if (!(attr instanceof Module_attribute))\n+        var attr = classModel.findAttribute(Attributes.MODULE);\n+        if (attr.isEmpty())\n@@ -627,2 +592,2 @@\n-        Module_attribute m = (Module_attribute) attr;\n-        for (Module_attribute.RequiresEntry entry: m.requires) {\n+        var m = attr.get();\n+        for (var entry: m.requires()) {\n@@ -630,1 +595,1 @@\n-            if ((entry.requires_flags & Module_attribute.ACC_STATIC_PHASE) != 0)\n+            if ((entry.requiresFlagsMask() & ACC_STATIC_PHASE) != 0)\n@@ -632,1 +597,1 @@\n-            if ((entry.requires_flags & Module_attribute.ACC_TRANSITIVE) != 0)\n+            if ((entry.requiresFlagsMask() & ACC_TRANSITIVE) != 0)\n@@ -636,6 +601,1 @@\n-            try {\n-                mname = getModuleName(entry.requires_index);\n-            } catch (ConstantPoolException e) {\n-                mname = report(e);\n-            }\n-            print(mname);\n+            print(entry.requires().name().stringValue());\n@@ -645,1 +605,1 @@\n-        for (Module_attribute.ExportsEntry entry: m.exports) {\n+        for (var entry: m.exports()) {\n@@ -648,7 +608,1 @@\n-            String pname;\n-            try {\n-                pname = getPackageName(entry.exports_index).replace('\/', '.');\n-            } catch (ConstantPoolException e) {\n-                pname = report(e);\n-            }\n-            print(pname);\n+            print(entry.exportedPackage().name().stringValue().replace('\/', '.'));\n@@ -656,7 +610,1 @@\n-            for (int i: entry.exports_to_index) {\n-                String mname;\n-                try {\n-                    mname = getModuleName(i);\n-                } catch (ConstantPoolException e) {\n-                    mname = report(e);\n-                }\n+            for (var mod: entry.exportsTo()) {\n@@ -670,1 +618,1 @@\n-                print(mname);\n+                print(mod.name().stringValue());\n@@ -677,1 +625,1 @@\n-        for (Module_attribute.OpensEntry entry: m.opens) {\n+        for (var entry: m.opens()) {\n@@ -680,7 +628,1 @@\n-            String pname;\n-            try {\n-                pname = getPackageName(entry.opens_index).replace('\/', '.');\n-            } catch (ConstantPoolException e) {\n-                pname = report(e);\n-            }\n-            print(pname);\n+            print(entry.openedPackage().name().stringValue().replace('\/', '.'));\n@@ -688,7 +630,1 @@\n-            for (int i: entry.opens_to_index) {\n-                String mname;\n-                try {\n-                    mname = getModuleName(i);\n-                } catch (ConstantPoolException e) {\n-                    mname = report(e);\n-                }\n+            for (var mod: entry.opensTo()) {\n@@ -702,1 +638,1 @@\n-                print(mname);\n+                print(mod.name().stringValue());\n@@ -709,1 +645,1 @@\n-        for (int entry: m.uses_index) {\n+        for (var entry: m.uses()) {\n@@ -711,1 +647,1 @@\n-            print(getClassName(entry).replace('\/', '.'));\n+            print(entry.asInternalName().replace('\/', '.'));\n@@ -715,1 +651,1 @@\n-        for (Module_attribute.ProvidesEntry entry: m.provides) {\n+        for (var entry: m.provides()) {\n@@ -717,1 +653,1 @@\n-            print(getClassName(entry.provides_index).replace('\/', '.'));\n+            print(entry.provides().asInternalName().replace('\/', '.'));\n@@ -719,1 +655,1 @@\n-            for (int i: entry.with_index) {\n+            for (var ce: entry.providesWith()) {\n@@ -727,1 +663,1 @@\n-                print(getClassName(i).replace('\/', '.'));\n+                print(ce.asInternalName().replace('\/', '.'));\n@@ -735,32 +671,0 @@\n-    String getModuleName(int index) throws ConstantPoolException {\n-        if (constant_pool.get(index).getTag() == CONSTANT_Module) {\n-            return constant_pool.getModuleInfo(index).getName();\n-        } else {\n-            return constant_pool.getUTF8Value(index);\n-        }\n-    }\n-\n-    String getPackageName(int index) throws ConstantPoolException {\n-        if (constant_pool.get(index).getTag() == CONSTANT_Package) {\n-            return constant_pool.getPackageInfo(index).getName();\n-        } else {\n-            return constant_pool.getUTF8Value(index);\n-        }\n-    }\n-\n-    String getUTF8Value(int index) {\n-        try {\n-            return classFile.constant_pool.getUTF8Value(index);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getClassName(int index) {\n-        try {\n-            return classFile.constant_pool.getClassInfo(index).getName();\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n@@ -783,6 +687,2 @@\n-    Signature_attribute getSignature(Attributes attributes) {\n-        return (Signature_attribute) attributes.get(Attribute.Signature);\n-    }\n-\n-    String adjustVarargs(AccessFlags flags, String params) {\n-        if (flags.is(ACC_VARARGS)) {\n+    String adjustVarargs(int flags, String params) {\n+        if ((flags & ACC_VARARGS) != 0) {\n@@ -797,84 +697,3 @@\n-    String getJavaName(ClassFile cf) {\n-        try {\n-            return getJavaName(cf.getName());\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getJavaSuperclassName(ClassFile cf) {\n-        try {\n-            return getJavaName(cf.getSuperclassName());\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getJavaInterfaceName(ClassFile cf, int index) {\n-        try {\n-            return getJavaName(cf.getInterfaceName(index));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getJavaFieldType(Descriptor d) {\n-        try {\n-            return getJavaName(d.getFieldType(constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        } catch (InvalidDescriptor e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getJavaReturnType(Descriptor d) {\n-        try {\n-            return getJavaName(d.getReturnType(constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        } catch (InvalidDescriptor e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getJavaParameterTypes(Descriptor d, AccessFlags flags) {\n-        try {\n-            return getJavaName(adjustVarargs(flags, d.getParameterTypes(constant_pool)));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        } catch (InvalidDescriptor e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getJavaException(Exceptions_attribute attr, int index) {\n-        try {\n-            return getJavaName(attr.getException(index, constant_pool));\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getValue(Descriptor d) {\n-        try {\n-            return d.getValue(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getFieldName(Field f) {\n-        try {\n-            return f.getName(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n-    String getName(Method m) {\n-        try {\n-            return m.getName(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n+    String getJavaParameterTypes(MethodSignature d, int flags) {\n+        return getJavaName(adjustVarargs(flags,\n+                sigPrinter.printList(\"(\", d.arguments(), \")\")));\n@@ -887,8 +706,0 @@\n-    String getSourceFile(SourceFile_attribute attr) {\n-        try {\n-            return attr.getSourceFile(constant_pool);\n-        } catch (ConstantPoolException e) {\n-            return report(e);\n-        }\n-    }\n-\n@@ -904,26 +715,14 @@\n-    String getConstantValue(Descriptor d, int index) {\n-        try {\n-            ConstantPool.CPInfo cpInfo = constant_pool.get(index);\n-\n-            switch (cpInfo.getTag()) {\n-                case ConstantPool.CONSTANT_Integer: {\n-                    ConstantPool.CONSTANT_Integer_info info =\n-                            (ConstantPool.CONSTANT_Integer_info) cpInfo;\n-                    String t = d.getValue(constant_pool);\n-                    switch (t) {\n-                        case \"C\":\n-                            \/\/ character\n-                            return getConstantCharValue((char) info.value);\n-                        case \"Z\":\n-                            \/\/ boolean\n-                            return String.valueOf(info.value == 1);\n-                        default:\n-                            \/\/ other: assume integer\n-                            return String.valueOf(info.value);\n-                    }\n-                }\n-\n-                case ConstantPool.CONSTANT_String: {\n-                    ConstantPool.CONSTANT_String_info info =\n-                            (ConstantPool.CONSTANT_String_info) cpInfo;\n-                    return getConstantStringValue(info.getString());\n+    String getConstantValue(ClassDesc d, ConstantValueEntry cpInfo) {\n+        switch (cpInfo.tag()) {\n+            case Classfile.TAG_INTEGER: {\n+                var val = (Integer)cpInfo.constantValue();\n+                switch (d.descriptorString()) {\n+                    case \"C\":\n+                        \/\/ character\n+                        return getConstantCharValue((char)val.intValue());\n+                    case \"Z\":\n+                        \/\/ boolean\n+                        return String.valueOf(val == 1);\n+                    default:\n+                        \/\/ other: assume integer\n+                        return String.valueOf(val);\n@@ -931,3 +730,0 @@\n-\n-                default:\n-                    return constantWriter.stringValue(cpInfo);\n@@ -935,2 +731,4 @@\n-        } catch (ConstantPoolException e) {\n-            return \"#\" + index;\n+            case Classfile.TAG_STRING:\n+                return getConstantStringValue(cpInfo.constantValue().toString());\n+            default:\n+                return constantWriter.stringValue(cpInfo);\n@@ -974,0 +772,82 @@\n+    private static Set<String> getClassModifiers(int mask) {\n+        return getModifiers(AccessFlags.ofClass((mask & ACC_INTERFACE) != 0\n+                ? mask & ~ACC_ABSTRACT : mask).flags());\n+    }\n+\n+    private static Set<String> getMethodModifiers(int mask) {\n+        return getModifiers(AccessFlags.ofMethod(mask).flags());\n+    }\n+\n+    private static Set<String> getFieldModifiers(int mask) {\n+        return getModifiers(AccessFlags.ofField(mask).flags());\n+    }\n+\n+    private static Set<String> getModifiers(Set<java.lang.reflect.AccessFlag> flags) {\n+        Set<String> s = new LinkedHashSet<>();\n+        for (var f : flags)\n+            if (f.sourceModifier()) s.add(Modifier.toString(f.mask()));\n+        return s;\n+    }\n+\n+    private static Set<String> getClassFlags(int mask) {\n+        return getFlags(mask, AccessFlags.ofClass(mask).flags());\n+    }\n+\n+    private static Set<String> getMethodFlags(int mask) {\n+        return getFlags(mask, AccessFlags.ofMethod(mask).flags());\n+    }\n+\n+    private static Set<String> getFieldFlags(int mask) {\n+        return getFlags(mask, AccessFlags.ofField(mask).flags());\n+    }\n+\n+    private static Set<String> getFlags(int mask, Set<java.lang.reflect.AccessFlag> flags) {\n+        Set<String> s = new LinkedHashSet<>();\n+        for (var f: flags) {\n+            s.add(\"ACC_\" + f.name());\n+            mask = mask & ~f.mask();\n+        }\n+        while (mask != 0) {\n+            int bit = Integer.highestOneBit(mask);\n+            s.add(\"0x\" + Integer.toHexString(bit));\n+            mask = mask & ~bit;\n+        }\n+        return s;\n+    }\n+\n+    public static enum AccessFlag {\n+        ACC_PUBLIC      (Classfile.ACC_PUBLIC,       \"public\",       true,  true,  true,  true ),\n+        ACC_PRIVATE     (Classfile.ACC_PRIVATE,      \"private\",      false, true,  true,  true ),\n+        ACC_PROTECTED   (Classfile.ACC_PROTECTED,    \"protected\",    false, true,  true,  true ),\n+        ACC_STATIC      (Classfile.ACC_STATIC,       \"static\",       false, true,  true,  true ),\n+        ACC_FINAL       (Classfile.ACC_FINAL,        \"final\",        true,  true,  true,  true ),\n+        ACC_SUPER       (Classfile.ACC_SUPER,        null,           true,  false, false, false),\n+        ACC_SYNCHRONIZED(Classfile.ACC_SYNCHRONIZED, \"synchronized\", false, false, false, true ),\n+        ACC_VOLATILE    (Classfile.ACC_VOLATILE,     \"volatile\",     false, false, true,  false),\n+        ACC_BRIDGE      (Classfile.ACC_BRIDGE,       null,           false, false, false, true ),\n+        ACC_TRANSIENT   (Classfile.ACC_TRANSIENT,    \"transient\",    false, false, true,  false),\n+        ACC_VARARGS     (Classfile.ACC_VARARGS,      null,           false, false, false, true ),\n+        ACC_NATIVE      (Classfile.ACC_NATIVE,       \"native\",       false, false, false, true ),\n+        ACC_INTERFACE   (Classfile.ACC_INTERFACE,    null,           true,   true, false, false),\n+        ACC_ABSTRACT    (Classfile.ACC_ABSTRACT,     \"abstract\",     true,   true, false, true ),\n+        ACC_STRICT      (Classfile.ACC_STRICT,       \"strictfp\",     false, false, false, true ),\n+        ACC_SYNTHETIC   (Classfile.ACC_SYNTHETIC,    null,           true,  true,  true,  true ),\n+        ACC_ANNOTATION  (Classfile.ACC_ANNOTATION,   null,           true,   true, false, false),\n+        ACC_ENUM        (Classfile.ACC_ENUM,         null,           true,   true, true,  false),\n+        ACC_MODULE      (Classfile.ACC_MODULE,       null,           true,  false, false, false);\n+\n+        public final int flag;\n+        public final String modifier;\n+        public final boolean isClass, isInnerClass, isField, isMethod;\n+\n+        AccessFlag(int flag, String modifier, boolean isClass,\n+                boolean isInnerClass, boolean isField, boolean isMethod) {\n+            this.flag = flag;\n+            this.modifier = modifier;\n+            this.isClass = isClass;\n+            this.isInnerClass = isInnerClass;\n+            this.isField = isField;\n+            this.isMethod = isMethod;\n+        }\n+    }\n+\n@@ -978,1 +858,1 @@\n-    private ClassFile classFile;\n+    private ClassModel classModel;\n@@ -984,2 +864,1 @@\n-    private ConstantPool constant_pool;\n-    private Method method;\n+    private MethodModel method;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ClassWriter.java","additions":420,"deletions":541,"binary":false,"changes":961,"status":"modified"},{"patch":"@@ -31,8 +31,9 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.DescriptorException;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Instruction.TypeKind;\n-import com.sun.tools.classfile.Method;\n+import java.util.Locale;\n+import java.util.stream.Collectors;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.constantpool.*;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.instruction.*;\n@@ -71,1 +72,1 @@\n-    void write(Code_attribute attr, ConstantPool constant_pool) {\n+    void write(CodeAttribute attr) {\n@@ -74,1 +75,1 @@\n-        writeVerboseHeader(attr, constant_pool);\n+        writeVerboseHeader(attr);\n@@ -77,1 +78,1 @@\n-        attrWriter.write(attr, attr.attributes, constant_pool);\n+        attrWriter.write(attr.attributes(), attr);\n@@ -81,18 +82,8 @@\n-    public void writeVerboseHeader(Code_attribute attr, ConstantPool constant_pool) {\n-        Method method = classWriter.getMethod();\n-        String argCount;\n-        try {\n-            int n = method.descriptor.getParameterCount(constant_pool);\n-            if (!method.access_flags.is(AccessFlags.ACC_STATIC))\n-                ++n;  \/\/ for 'this'\n-            argCount = Integer.toString(n);\n-        } catch (ConstantPoolException e) {\n-            argCount = report(e);\n-        } catch (DescriptorException e) {\n-            argCount = report(e);\n-        }\n-\n-        println(\"stack=\" + attr.max_stack +\n-                \", locals=\" + attr.max_locals +\n-                \", args_size=\" + argCount);\n-\n+    public void writeVerboseHeader(CodeAttribute attr) {\n+        MethodModel method = attr.parent().get();\n+        int n = method.methodTypeSymbol().parameterCount();\n+        if ((method.flags().flagsMask() & Classfile.ACC_STATIC) == 0)\n+            ++n;  \/\/ for 'this'\n+        println(\"stack=\" + attr.maxStack() +\n+                \", locals=\" + attr.maxLocals() +\n+                \", args_size=\" + Integer.toString(n));\n@@ -101,1 +92,1 @@\n-    public void writeInstrs(Code_attribute attr) {\n+    public void writeInstrs(CodeAttribute attr) {\n@@ -104,8 +95,9 @@\n-        for (Instruction instr: attr.getInstructions()) {\n-            try {\n-                for (InstructionDetailWriter w: detailWriters)\n-                    w.writeDetails(instr);\n-                writeInstr(instr);\n-            } catch (ArrayIndexOutOfBoundsException | IllegalStateException e) {\n-                println(report(\"error at or after byte \" + instr.getPC()));\n-                break;\n+        int pc = 0;\n+        try {\n+            for (var coe: attr) {\n+                if (coe instanceof Instruction instr) {\n+                    for (InstructionDetailWriter w: detailWriters)\n+                        w.writeDetails(pc, instr);\n+                    writeInstr(pc, instr, attr);\n+                    pc += instr.sizeInBytes();\n+                }\n@@ -113,0 +105,2 @@\n+        } catch (IllegalArgumentException e) {\n+            report(\"error at or after byte \" + pc);\n@@ -116,12 +110,1 @@\n-            w.flush();\n-    }\n-\n-    public void writeInstr(Instruction instr) {\n-        print(String.format(\"%4d: %-13s \", instr.getPC(), instr.getMnemonic()));\n-        \/\/ compute the number of indentations for the body of multi-line instructions\n-        \/\/ This is 6 (the width of \"%4d: \"), divided by the width of each indentation level,\n-        \/\/ and rounded up to the next integer.\n-        int indentWidth = options.indentWidth;\n-        int indent = (6 + indentWidth - 1) \/ indentWidth;\n-        instr.accept(instructionPrinter, indent);\n-        println();\n+            w.flush(pc);\n@@ -129,7 +112,0 @@\n-    \/\/ where\n-    Instruction.KindVisitor<Void,Integer> instructionPrinter =\n-            new Instruction.KindVisitor<>() {\n-\n-        public Void visitNoOperands(Instruction instr, Integer indent) {\n-            return null;\n-        }\n@@ -137,56 +113,62 @@\n-        public Void visitArrayType(Instruction instr, TypeKind kind, Integer indent) {\n-            print(\" \" + kind.name);\n-            return null;\n-        }\n-\n-        public Void visitBranch(Instruction instr, int offset, Integer indent) {\n-            print((instr.getPC() + offset));\n-            return null;\n-        }\n-\n-        public Void visitConstantPoolRef(Instruction instr, int index, Integer indent) {\n-            print(\"#\" + index);\n-            tab();\n-            print(\"\/\/ \");\n-            printConstant(index);\n-            return null;\n-        }\n-\n-        public Void visitConstantPoolRefAndValue(Instruction instr, int index, int value, Integer indent) {\n-            print(\"#\" + index + \",  \" + value);\n-            tab();\n-            print(\"\/\/ \");\n-            printConstant(index);\n-            return null;\n-        }\n-\n-        public Void visitLocal(Instruction instr, int index, Integer indent) {\n-            print(index);\n-            return null;\n-        }\n-\n-        public Void visitLocalAndValue(Instruction instr, int index, int value, Integer indent) {\n-            print(index + \", \" + value);\n-            return null;\n-        }\n-\n-        public Void visitLookupSwitch(Instruction instr,\n-                int default_, int npairs, int[] matches, int[] offsets, Integer indent) {\n-            int pc = instr.getPC();\n-            print(\"{ \/\/ \" + npairs);\n-            indent(indent);\n-            for (int i = 0; i < npairs; i++) {\n-                print(String.format(\"%n%12d: %d\", matches[i], (pc + offsets[i])));\n-            }\n-            print(\"\\n     default: \" + (pc + default_) + \"\\n}\");\n-            indent(-indent);\n-            return null;\n-        }\n-\n-        public Void visitTableSwitch(Instruction instr,\n-                int default_, int low, int high, int[] offsets, Integer indent) {\n-            int pc = instr.getPC();\n-            print(\"{ \/\/ \" + low + \" to \" + high);\n-            indent(indent);\n-            for (int i = 0; i < offsets.length; i++) {\n-                print(String.format(\"%n%12d: %d\", (low + i), (pc + offsets[i])));\n+    public void writeInstr(int pc, Instruction ins, CodeAttribute lr) {\n+        print(String.format(\"%4d: %-13s \", pc, ins.opcode().name().toLowerCase(Locale.US)));\n+        try {\n+            \/\/ compute the number of indentations for the body of multi-line instructions\n+            \/\/ This is 6 (the width of \"%4d: \"), divided by the width of each indentation level,\n+            \/\/ and rounded up to the next integer.\n+            int indentWidth = options.indentWidth;\n+            int indent = (6 + indentWidth - 1) \/ indentWidth;\n+            switch (ins) {\n+                case BranchInstruction instr ->\n+                    print(lr.labelToBci(instr.target()));\n+                case ConstantInstruction.ArgumentConstantInstruction instr ->\n+                    print(instr.constantValue());\n+                case ConstantInstruction.LoadConstantInstruction instr ->\n+                    printConstantPoolRef(instr.constantEntry());\n+                case FieldInstruction instr ->\n+                    printConstantPoolRef(instr.field());\n+                case InvokeDynamicInstruction instr ->\n+                    printConstantPoolRefAndValue(instr.invokedynamic(), 0);\n+                case InvokeInstruction instr -> {\n+                    if (instr.isInterface() && instr.opcode() != Opcode.INVOKESTATIC)\n+                        printConstantPoolRefAndValue(instr.method(), instr.count());\n+                    else printConstantPoolRef(instr.method());\n+                }\n+                case LoadInstruction instr ->\n+                    print(instr.sizeInBytes() > 1 ? instr.slot() : \"\");\n+                case StoreInstruction instr ->\n+                    print(instr.sizeInBytes() > 1 ? instr.slot() : \"\");\n+                case IncrementInstruction instr ->\n+                    print(instr.slot() + \", \" + instr.constant());\n+                case LookupSwitchInstruction instr -> {\n+                    var cases = instr.cases();\n+                    print(\"{ \/\/ \" + cases.size());\n+                    indent(indent);\n+                    for (var c : cases)\n+                        print(String.format(\"%n%12d: %d\", c.caseValue(),\n+                                lr.labelToBci(c.target())));\n+                    print(\"\\n     default: \" + lr.labelToBci(instr.defaultTarget()) + \"\\n}\");\n+                    indent(-indent);\n+                }\n+                case NewMultiArrayInstruction instr ->\n+                    printConstantPoolRefAndValue(instr.arrayType(), instr.dimensions());\n+                case NewObjectInstruction instr ->\n+                    printConstantPoolRef(instr.className());\n+                case NewPrimitiveArrayInstruction instr ->\n+                    print(\" \" + instr.typeKind().typeName());\n+                case NewReferenceArrayInstruction instr ->\n+                    printConstantPoolRef(instr.componentType());\n+                case TableSwitchInstruction instr -> {\n+                    print(\"{ \/\/ \" + instr.lowValue() + \" to \" + instr.highValue());\n+                    indent(indent);\n+                    var caseMap = instr.cases().stream().collect(\n+                            Collectors.toMap(SwitchCase::caseValue, SwitchCase::target));\n+                    for (int i = instr.lowValue(); i <= instr.highValue(); i++)\n+                        print(String.format(\"%n%12d: %d\", i,\n+                                lr.labelToBci(caseMap.getOrDefault(i, instr.defaultTarget()))));\n+                    print(\"\\n     default: \" + lr.labelToBci(instr.defaultTarget()) + \"\\n}\");\n+                    indent(-indent);\n+                }\n+                case TypeCheckInstruction instr ->\n+                    printConstantPoolRef(instr.type());\n+                default -> {}\n@@ -194,8 +176,3 @@\n-            print(\"\\n     default: \" + (pc + default_) + \"\\n}\");\n-            indent(-indent);\n-            return null;\n-        }\n-\n-        public Void visitValue(Instruction instr, int value, Integer indent) {\n-            print(value);\n-            return null;\n+            println();\n+        } catch (IllegalArgumentException e) {\n+            println(report(e));\n@@ -203,0 +180,1 @@\n+    }\n@@ -204,4 +182,6 @@\n-        public Void visitUnknown(Instruction instr, Integer indent) {\n-            return null;\n-        }\n-    };\n+    private void printConstantPoolRef(PoolEntry entry) {\n+        print(\"#\" + entry.index());\n+        tab();\n+        print(\"\/\/ \");\n+        constantWriter.write(entry.index());\n+    }\n@@ -209,0 +189,6 @@\n+    private void printConstantPoolRefAndValue(PoolEntry entry, int value) {\n+        print(\"#\" + entry.index() + \",  \" + value);\n+        tab();\n+        print(\"\/\/ \");\n+        constantWriter.write(entry.index());\n+    }\n@@ -210,2 +196,3 @@\n-    public void writeExceptionTable(Code_attribute attr) {\n-        if (attr.exception_table_length > 0) {\n+    public void writeExceptionTable(CodeAttribute attr) {\n+        var excTable = attr.exceptionHandlers();\n+        if (excTable.size() > 0) {\n@@ -215,2 +202,1 @@\n-            for (int i = 0; i < attr.exception_table.length; i++) {\n-                Code_attribute.Exception_data handler = attr.exception_table[i];\n+            for (var handler : excTable) {\n@@ -218,1 +204,3 @@\n-                        handler.start_pc, handler.end_pc, handler.handler_pc));\n+                        attr.labelToBci(handler.tryStart()),\n+                        attr.labelToBci(handler.tryEnd()),\n+                        attr.labelToBci(handler.handler())));\n@@ -220,2 +208,2 @@\n-                int catch_type = handler.catch_type;\n-                if (catch_type == 0) {\n+                var catch_type = handler.catchType();\n+                if (catch_type.isEmpty()) {\n@@ -225,1 +213,1 @@\n-                    println(constantWriter.stringValue(catch_type));\n+                    println(constantWriter.stringValue(catch_type.get()));\n@@ -233,5 +221,1 @@\n-    private void printConstant(int index) {\n-        constantWriter.write(index);\n-    }\n-\n-    private List<InstructionDetailWriter> getDetailWriters(Code_attribute attr) {\n+    private List<InstructionDetailWriter> getDetailWriters(CodeAttribute attr) {\n@@ -240,1 +224,1 @@\n-            sourceWriter.reset(classWriter.getClassFile(), attr);\n+            sourceWriter.reset(attr);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/CodeWriter.java","additions":123,"deletions":139,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -28,5 +28,2 @@\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-\n-import static com.sun.tools.classfile.ConstantPool.*;\n+import jdk.internal.classfile.constantpool.*;\n+import static jdk.internal.classfile.Classfile.*;\n@@ -58,1 +55,1 @@\n-        ConstantPool constant_pool = classWriter.getClassFile().constant_pool;\n+        var constant_pool = classWriter.getClassModel().constantPool();\n@@ -63,111 +60,0 @@\n-        ConstantPool.Visitor<Integer, Void> v = new ConstantPool.Visitor<>() {\n-            public Integer visitClass(CONSTANT_Class_info info, Void p) {\n-                print(\"#\" + info.name_index);\n-                tab();\n-                println(\"\/\/ \" + stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitDouble(CONSTANT_Double_info info, Void p) {\n-                println(stringValue(info));\n-                return 2;\n-            }\n-\n-            public Integer visitFieldref(CONSTANT_Fieldref_info info, Void p) {\n-                print(\"#\" + info.class_index + \".#\" + info.name_and_type_index);\n-                tab();\n-                println(\"\/\/ \" + stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitFloat(CONSTANT_Float_info info, Void p) {\n-                println(stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitInteger(CONSTANT_Integer_info info, Void p) {\n-                println(stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitInterfaceMethodref(CONSTANT_InterfaceMethodref_info info, Void p) {\n-                print(\"#\" + info.class_index + \".#\" + info.name_and_type_index);\n-                tab();\n-                println(\"\/\/ \" + stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitInvokeDynamic(CONSTANT_InvokeDynamic_info info, Void p) {\n-                print(\"#\" + info.bootstrap_method_attr_index + \":#\" + info.name_and_type_index);\n-                tab();\n-                println(\"\/\/ \" + stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitDynamicConstant(CONSTANT_Dynamic_info info, Void p) {\n-                print(\"#\" + info.bootstrap_method_attr_index + \":#\" + info.name_and_type_index);\n-                tab();\n-                println(\"\/\/ \" + stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitLong(CONSTANT_Long_info info, Void p) {\n-                println(stringValue(info));\n-                return 2;\n-            }\n-\n-            public Integer visitMethodref(CONSTANT_Methodref_info info, Void p) {\n-                print(\"#\" + info.class_index + \".#\" + info.name_and_type_index);\n-                tab();\n-                println(\"\/\/ \" + stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitMethodHandle(CONSTANT_MethodHandle_info info, Void p) {\n-                print(info.reference_kind.tag + \":#\" + info.reference_index);\n-                tab();\n-                println(\"\/\/ \" + stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitMethodType(CONSTANT_MethodType_info info, Void p) {\n-                print(\"#\" + info.descriptor_index);\n-                tab();\n-                println(\"\/\/  \" + stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitModule(CONSTANT_Module_info info, Void p) {\n-                print(\"#\" + info.name_index);\n-                tab();\n-                println(\"\/\/ \" + stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitNameAndType(CONSTANT_NameAndType_info info, Void p) {\n-                print(\"#\" + info.name_index + \":#\" + info.type_index);\n-                tab();\n-                println(\"\/\/ \" + stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitPackage(CONSTANT_Package_info info, Void p) {\n-                print(\"#\" + info.name_index);\n-                tab();\n-                println(\"\/\/ \" + stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitString(CONSTANT_String_info info, Void p) {\n-                print(\"#\" + info.string_index);\n-                tab();\n-                println(\"\/\/ \" + stringValue(info));\n-                return 1;\n-            }\n-\n-            public Integer visitUtf8(CONSTANT_Utf8_info info, Void p) {\n-                println(stringValue(info));\n-                return 1;\n-            }\n-\n-        };\n@@ -181,5 +67,60 @@\n-                CPInfo cpInfo = constant_pool.get(cpx);\n-                print(String.format(\" = %-18s \", cpTagName(cpInfo)));\n-                cpx += cpInfo.accept(v, null);\n-            } catch (ConstantPool.InvalidIndex ex) {\n-                \/\/ should not happen\n+                var cpInfo = constant_pool.entryByIndex(cpx);\n+                print(String.format(\" = %-18s \", cpTagName(cpInfo.tag())));\n+                switch (cpInfo) {\n+                    case ClassEntry info -> {\n+                        print(() -> \"#\" + info.name().index());\n+                        tab();\n+                        println(() -> \"\/\/ \" + stringValue(info));\n+                    }\n+                    case AnnotationConstantValueEntry info -> {\n+                        println(() -> stringValue(info));\n+                    }\n+                    case MemberRefEntry info -> {\n+                        print(() -> \"#\" + info.owner().index() + \".#\"\n+                                + info.nameAndType().index());\n+                        tab();\n+                        println(() -> \"\/\/ \" + stringValue(info));\n+                    }\n+                    case DynamicConstantPoolEntry info -> {\n+                        print(() -> \"#\" + info.bootstrapMethodIndex() + \":#\"\n+                                + info.nameAndType().index());\n+                        tab();\n+                        println(() -> \"\/\/ \" + stringValue(info));\n+                    }\n+                    case MethodHandleEntry info -> {\n+                        print(() -> info.kind() + \":#\" + info.reference().index());\n+                        tab();\n+                        println(() -> \"\/\/ \" + stringValue(info));\n+                    }\n+                    case MethodTypeEntry info -> {\n+                        print(() -> \"#\" + info.descriptor().index());\n+                        tab();\n+                        println(() -> \"\/\/  \" + stringValue(info));\n+                    }\n+                    case ModuleEntry info -> {\n+                        print(() -> \"#\" + info.name().index());\n+                        tab();\n+                        println(() -> \"\/\/ \" + stringValue(info));\n+                    }\n+                    case NameAndTypeEntry info -> {\n+                        print(() -> \"#\" + info.name().index() + \":#\" + info.type().index());\n+                        tab();\n+                        println(() -> \"\/\/ \" + stringValue(info));\n+                    }\n+                    case PackageEntry info -> {\n+                        print(() -> \"#\" + info.name().index());\n+                        tab();\n+                        println(\"\/\/ \" + stringValue(info));\n+                    }\n+                    case StringEntry info -> {\n+                        print(() -> \"#\" + info.utf8().index());\n+                        tab();\n+                        println(() -> \"\/\/ \" + stringValue(info));\n+                    }\n+                    default ->\n+                        throw new IllegalArgumentException(\"unknown entry: \"+ cpInfo);\n+                }\n+                cpx += cpInfo.width();\n+            } catch (IllegalArgumentException e) {\n+                println(report(e));\n+                cpx++;\n@@ -192,1 +133,0 @@\n-        ClassFile classFile = classWriter.getClassFile();\n@@ -197,22 +137,8 @@\n-\n-        CPInfo cpInfo;\n-        try {\n-            cpInfo = classFile.constant_pool.get(cpx);\n-        } catch (ConstantPoolException e) {\n-            print(\"#\" + cpx);\n-            return;\n-        }\n-\n-        int tag = cpInfo.getTag();\n-        switch (tag) {\n-            case CONSTANT_Methodref:\n-            case CONSTANT_InterfaceMethodref:\n-            case CONSTANT_Fieldref:\n-                \/\/ simplify references within this class\n-                CPRefInfo ref = (CPRefInfo) cpInfo;\n-                try {\n-                    if (ref.class_index == classFile.this_class)\n-                         cpInfo = classFile.constant_pool.get(ref.name_and_type_index);\n-                } catch (ConstantPool.InvalidIndex e) {\n-                    \/\/ ignore, for now\n-                }\n+        var classModel = classWriter.getClassModel();\n+\n+        var cpInfo = classModel.constantPool().entryByIndex(cpx);\n+        var tag = cpInfo.tag();\n+        if (cpInfo instanceof MemberRefEntry ref) {\n+            \/\/ simplify references within this class\n+            if (ref.owner().index() == classModel.thisClass().index())\n+                 cpInfo = ref.nameAndType();\n@@ -223,3 +149,19 @@\n-    String cpTagName(CPInfo cpInfo) {\n-        String n = cpInfo.getClass().getSimpleName();\n-        return n.replace(\"CONSTANT_\", \"\").replace(\"_info\", \"\");\n+    String cpTagName(int tag) {\n+        return switch (tag) {\n+            case TAG_UTF8 -> \"Utf8\";\n+            case TAG_INTEGER -> \"Integer\";\n+            case TAG_FLOAT -> \"Float\";\n+            case TAG_LONG -> \"Long\";\n+            case TAG_DOUBLE -> \"Double\";\n+            case TAG_CLASS -> \"Class\";\n+            case TAG_STRING -> \"String\";\n+            case TAG_FIELDREF -> \"Fieldref\";\n+            case TAG_METHODHANDLE -> \"MethodHandle\";\n+            case TAG_METHODTYPE -> \"MethodType\";\n+            case TAG_METHODREF -> \"Methodref\";\n+            case TAG_INTERFACEMETHODREF -> \"InterfaceMethodref\";\n+            case TAG_INVOKEDYNAMIC -> \"InvokeDynamic\";\n+            case TAG_CONSTANTDYNAMIC -> \"Dynamic\";\n+            case TAG_NAMEANDTYPE -> \"NameAndType\";\n+            default -> \"Unknown\";\n+        };\n@@ -229,33 +171,26 @@\n-        switch (tag) {\n-            case CONSTANT_Utf8:\n-                return \"Utf8\";\n-            case CONSTANT_Integer:\n-                return \"int\";\n-            case CONSTANT_Float:\n-                return \"float\";\n-            case CONSTANT_Long:\n-                return \"long\";\n-            case CONSTANT_Double:\n-                return \"double\";\n-            case CONSTANT_Class:\n-                return \"class\";\n-            case CONSTANT_String:\n-                return \"String\";\n-            case CONSTANT_Fieldref:\n-                return \"Field\";\n-            case CONSTANT_MethodHandle:\n-                return \"MethodHandle\";\n-            case CONSTANT_MethodType:\n-                return \"MethodType\";\n-            case CONSTANT_Methodref:\n-                return \"Method\";\n-            case CONSTANT_InterfaceMethodref:\n-                return \"InterfaceMethod\";\n-            case CONSTANT_InvokeDynamic:\n-                return \"InvokeDynamic\";\n-            case CONSTANT_Dynamic:\n-                return \"Dynamic\";\n-            case CONSTANT_NameAndType:\n-                return \"NameAndType\";\n-            default:\n-                return \"(unknown tag \" + tag + \")\";\n+        return switch (tag) {\n+            case TAG_UTF8 -> \"Utf8\";\n+            case TAG_INTEGER -> \"int\";\n+            case TAG_FLOAT -> \"float\";\n+            case TAG_LONG -> \"long\";\n+            case TAG_DOUBLE -> \"double\";\n+            case TAG_CLASS -> \"class\";\n+            case TAG_STRING -> \"String\";\n+            case TAG_FIELDREF -> \"Field\";\n+            case TAG_METHODHANDLE -> \"MethodHandle\";\n+            case TAG_METHODTYPE -> \"MethodType\";\n+            case TAG_METHODREF -> \"Method\";\n+            case TAG_INTERFACEMETHODREF -> \"InterfaceMethod\";\n+            case TAG_INVOKEDYNAMIC -> \"InvokeDynamic\";\n+            case TAG_CONSTANTDYNAMIC -> \"Dynamic\";\n+            case TAG_NAMEANDTYPE -> \"NameAndType\";\n+            default -> \"(unknown tag \" + tag + \")\";\n+        };\n+    }\n+\n+    String booleanValue(PoolEntry info) {\n+        if (info instanceof IntegerEntry ie) {\n+           switch (ie.intValue()) {\n+               case 0: return \"false\";\n+               case 1: return \"true\";\n+           }\n@@ -263,0 +198,1 @@\n+        return \"#\" + info.index();\n@@ -266,13 +202,7 @@\n-        ClassFile classFile = classWriter.getClassFile();\n-        try {\n-            CPInfo info = classFile.constant_pool.get(constant_pool_index);\n-            if (info instanceof CONSTANT_Integer_info) {\n-                int value = ((CONSTANT_Integer_info) info).value;\n-               switch (value) {\n-                   case 0: return \"false\";\n-                   case 1: return \"true\";\n-               }\n-            }\n-            return \"#\" + constant_pool_index;\n-        } catch (ConstantPool.InvalidIndex e) {\n-            return report(e);\n+        var info = classWriter.getClassModel().constantPool()\n+                .entryByIndex(constant_pool_index);\n+        if (info instanceof IntegerEntry ie) {\n+           switch (ie.intValue()) {\n+               case 0: return \"false\";\n+               case 1: return \"true\";\n+           }\n@@ -280,0 +210,1 @@\n+        return \"#\" + constant_pool_index;\n@@ -282,12 +213,6 @@\n-    String charValue(int constant_pool_index) {\n-        ClassFile classFile = classWriter.getClassFile();\n-        try {\n-            CPInfo info = classFile.constant_pool.get(constant_pool_index);\n-            if (info instanceof CONSTANT_Integer_info) {\n-                int value = ((CONSTANT_Integer_info) info).value;\n-                return String.valueOf((char) value);\n-            } else {\n-                return \"#\" + constant_pool_index;\n-            }\n-        } catch (ConstantPool.InvalidIndex e) {\n-            return report(e);\n+    String charValue(PoolEntry info) {\n+        if (info instanceof IntegerEntry ie) {\n+            int value = ie.intValue();\n+            return String.valueOf((char) value);\n+        } else {\n+            return \"#\" + info.index();\n@@ -297,6 +222,8 @@\n-    String stringValue(int constant_pool_index) {\n-        ClassFile classFile = classWriter.getClassFile();\n-        try {\n-            return stringValue(classFile.constant_pool.get(constant_pool_index));\n-        } catch (ConstantPool.InvalidIndex e) {\n-            return report(e);\n+    String charValue(int constant_pool_index) {\n+        var info = classWriter.getClassModel().constantPool()\n+                .entryByIndex(constant_pool_index);\n+        if (info instanceof IntegerEntry ie) {\n+            int value = ie.intValue();\n+            return String.valueOf((char) value);\n+        } else {\n+            return \"#\" + constant_pool_index;\n@@ -306,2 +233,3 @@\n-    String stringValue(CPInfo cpInfo) {\n-        return stringValueVisitor.visit(cpInfo);\n+    String stringValue(int constant_pool_index) {\n+        return stringValue(classWriter.getClassModel().constantPool()\n+                .entryByIndex(constant_pool_index));\n@@ -310,163 +238,46 @@\n-    StringValueVisitor stringValueVisitor = new StringValueVisitor();\n-\n-    private class StringValueVisitor implements ConstantPool.Visitor<String, Void> {\n-        public String visit(CPInfo info) {\n-            return info.accept(this, null);\n-        }\n-\n-        public String visitClass(CONSTANT_Class_info info, Void p) {\n-            return getCheckedName(info);\n-        }\n-\n-        String getCheckedName(CONSTANT_Class_info info) {\n-            try {\n-                return checkName(info.getName());\n-            } catch (ConstantPoolException e) {\n-                return report(e);\n-            }\n-        }\n-\n-        public String visitDouble(CONSTANT_Double_info info, Void p) {\n-            return info.value + \"d\";\n-        }\n-\n-        public String visitFieldref(CONSTANT_Fieldref_info info, Void p) {\n-            return visitRef(info, p);\n-        }\n-\n-        public String visitFloat(CONSTANT_Float_info info, Void p) {\n-            return info.value + \"f\";\n-        }\n-\n-        public String visitInteger(CONSTANT_Integer_info info, Void p) {\n-            return String.valueOf(info.value);\n-        }\n-\n-        public String visitInterfaceMethodref(CONSTANT_InterfaceMethodref_info info, Void p) {\n-            return visitRef(info, p);\n-        }\n-\n-        public String visitInvokeDynamic(CONSTANT_InvokeDynamic_info info, Void p) {\n-            try {\n-                String callee = stringValue(info.getNameAndTypeInfo());\n-                return \"#\" + info.bootstrap_method_attr_index + \":\" + callee;\n-            } catch (ConstantPoolException e) {\n-                return report(e);\n-            }\n-        }\n-\n-        public String visitDynamicConstant(CONSTANT_Dynamic_info info, Void p) {\n-            try {\n-                String callee = stringValue(info.getNameAndTypeInfo());\n-                return \"#\" + info.bootstrap_method_attr_index + \":\" + callee;\n-            } catch (ConstantPoolException e) {\n-                return report(e);\n-            }\n-        }\n-\n-        public String visitLong(CONSTANT_Long_info info, Void p) {\n-            return info.value + \"l\";\n-        }\n-\n-        public String visitModule(CONSTANT_Module_info info, Void p) {\n-            try {\n-                return checkName(info.getName());\n-            } catch (ConstantPoolException e) {\n-                return report(e);\n-            }\n-        }\n-\n-        public String visitNameAndType(CONSTANT_NameAndType_info info, Void p) {\n-            return getCheckedName(info) + \":\" + getType(info);\n-        }\n-\n-        String getCheckedName(CONSTANT_NameAndType_info info) {\n-            try {\n-                return checkName(info.getName());\n-            } catch (ConstantPoolException e) {\n-                return report(e);\n-            }\n-        }\n-\n-        public String visitPackage(CONSTANT_Package_info info, Void p) {\n-            try {\n-                return checkName(info.getName());\n-            } catch (ConstantPoolException e) {\n-                return report(e);\n-            }\n-        }\n-\n-        String getType(CONSTANT_NameAndType_info info) {\n-            try {\n-                return info.getType();\n-            } catch (ConstantPoolException e) {\n-                return report(e);\n-            }\n-        }\n-\n-        public String visitMethodHandle(CONSTANT_MethodHandle_info info, Void p) {\n-            try {\n-                return info.reference_kind + \" \" + stringValue(info.getCPRefInfo());\n-            } catch (ConstantPoolException e) {\n-                return report(e);\n-            }\n-        }\n-\n-        public String visitMethodType(CONSTANT_MethodType_info info, Void p) {\n-            try {\n-                return info.getType();\n-            } catch (ConstantPoolException e) {\n-                return report(e);\n-            }\n-        }\n-\n-        public String visitMethodref(CONSTANT_Methodref_info info, Void p) {\n-            return visitRef(info, p);\n-        }\n-\n-        public String visitString(CONSTANT_String_info info, Void p) {\n-            try {\n-                ClassFile classFile = classWriter.getClassFile();\n-                int string_index = info.string_index;\n-                return stringValue(classFile.constant_pool.getUTF8Info(string_index));\n-            } catch (ConstantPoolException e) {\n-                return report(e);\n-            }\n-        }\n-\n-        public String visitUtf8(CONSTANT_Utf8_info info, Void p) {\n-            String s = info.value;\n-            StringBuilder sb = new StringBuilder();\n-            for (int i = 0; i < s.length(); i++) {\n-                char c = s.charAt(i);\n-                switch (c) {\n-                    case '\\t':\n-                        sb.append('\\\\').append('t');\n-                        break;\n-                    case '\\n':\n-                        sb.append('\\\\').append('n');\n-                        break;\n-                    case '\\r':\n-                        sb.append('\\\\').append('r');\n-                        break;\n-                    case '\\b':\n-                        sb.append('\\\\').append('b');\n-                        break;\n-                    case '\\f':\n-                        sb.append('\\\\').append('f');\n-                        break;\n-                    case '\\\"':\n-                        sb.append('\\\\').append('\\\"');\n-                        break;\n-                    case '\\'':\n-                        sb.append('\\\\').append('\\'');\n-                        break;\n-                    case '\\\\':\n-                        sb.append('\\\\').append('\\\\');\n-                        break;\n-                    default:\n-                        if (Character.isISOControl(c)) {\n-                            sb.append(String.format(\"\\\\u%04x\", (int) c));\n-                            break;\n-                        }\n-                        sb.append(c);\n+    String stringValue(PoolEntry cpInfo) {\n+        return switch (cpInfo) {\n+            case ClassEntry info -> checkName(info.asInternalName());\n+            case DoubleEntry info -> info.doubleValue() + \"d\";\n+            case MemberRefEntry info -> checkName(info.owner().asInternalName())\n+                + '.' + stringValue(info.nameAndType());\n+            case FloatEntry info -> info.floatValue()+ \"f\";\n+            case IntegerEntry info -> String.valueOf(info.intValue());\n+            case DynamicConstantPoolEntry info -> \"#\" + info.bootstrapMethodIndex()\n+                + \":\" + stringValue(info.nameAndType());\n+            case LongEntry info -> info.longValue()+ \"l\";\n+            case ModuleEntry info -> checkName(info.name().stringValue());\n+            case NameAndTypeEntry info -> checkName(info.name().stringValue())\n+                + ':' + info.type().stringValue();\n+            case PackageEntry info -> checkName(info.name().stringValue());\n+            case MethodHandleEntry info -> {\n+                String kind = switch (info.asSymbol().kind()) {\n+                    case STATIC, INTERFACE_STATIC -> \"REF_invokeStatic\";\n+                    case VIRTUAL -> \"REF_invokeVirtual\";\n+                    case INTERFACE_VIRTUAL -> \"REF_invokeInterface\";\n+                    case SPECIAL, INTERFACE_SPECIAL -> \"REF_invokeSpecial\";\n+                    case CONSTRUCTOR -> \"REF_newInvokeSpecial\";\n+                    case GETTER -> \"REF_getField\";\n+                    case SETTER -> \"REF_putField\";\n+                    case STATIC_GETTER -> \"REF_getStatic\";\n+                    case STATIC_SETTER -> \"REF_putStatic\";\n+                };\n+                yield kind + \" \" + stringValue(info.reference());\n+            }\n+            case MethodTypeEntry info -> info.descriptor().stringValue();\n+            case StringEntry info -> stringValue(info.utf8());\n+            case Utf8Entry info -> {\n+                StringBuilder sb = new StringBuilder();\n+                for (char c : info.stringValue().toCharArray()) {\n+                    sb.append(switch (c) {\n+                        case '\\t' -> \"\\\\t\";\n+                        case '\\n' -> \"\\\\n\";\n+                        case '\\r' -> \"\\\\r\";\n+                        case '\\b' -> \"\\\\b\";\n+                        case '\\f' -> \"\\\\f\";\n+                        case '\\\"' -> \"\\\\\\\"\";\n+                        case '\\'' -> \"\\\\\\'\";\n+                        case '\\\\' -> \"\\\\\\\\\";\n+                        default -> Character.isISOControl(c)\n+                                ? String.format(\"\\\\u%04x\", (int) c) : c;\n+                    });\n@@ -474,0 +285,1 @@\n+                yield sb.toString();\n@@ -475,21 +287,2 @@\n-            return sb.toString();\n-        }\n-\n-        String visitRef(CPRefInfo info, Void p) {\n-            String cn = getCheckedClassName(info);\n-            String nat;\n-            try {\n-                nat = stringValue(info.getNameAndTypeInfo());\n-            } catch (ConstantPoolException e) {\n-                nat = report(e);\n-            }\n-            return cn + \".\" + nat;\n-        }\n-\n-        String getCheckedClassName(CPRefInfo info) {\n-            try {\n-                return checkName(info.getClassName());\n-            } catch (ConstantPoolException e) {\n-                return report(e);\n-            }\n-        }\n+            default -> throw new IllegalArgumentException(\"unknown \" + cpInfo);\n+        };\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/ConstantWriter.java","additions":191,"deletions":398,"binary":false,"changes":589,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import com.sun.tools.classfile.Instruction;\n+import jdk.internal.classfile.Instruction;\n@@ -59,2 +59,2 @@\n-    abstract void writeDetails(Instruction instr);\n-    void flush() { }\n+    abstract void writeDetails(int pc, Instruction instr);\n+    void flush(int pc) { }\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/InstructionDetailWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,1 +70,4 @@\n-import com.sun.tools.classfile.*;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.constantpool.*;\n+import static jdk.internal.classfile.Classfile.*;\n@@ -169,1 +172,1 @@\n-                task.options.showAccess = AccessFlags.ACC_PUBLIC;\n+                task.options.showAccess = ACC_PUBLIC;\n@@ -177,1 +180,1 @@\n-                task.options.showAccess = AccessFlags.ACC_PROTECTED;\n+                task.options.showAccess = ACC_PROTECTED;\n@@ -196,1 +199,1 @@\n-                task.options.showAccess = AccessFlags.ACC_PRIVATE;\n+                task.options.showAccess = ACC_PRIVATE;\n@@ -352,1 +355,0 @@\n-        attributeFactory = new Attribute.Factory();\n@@ -636,1 +638,1 @@\n-            } catch (FatalError e) {\n+            } catch (IllegalArgumentException e) {\n@@ -657,1 +659,1 @@\n-            throws IOException, ConstantPoolException {\n+            throws IOException {\n@@ -666,9 +668,3 @@\n-            if (cfInfo.cf.this_class == 0) {\n-                if (!className.equals(\"module-info\")) {\n-                    reportWarning(\"warn.unexpected.class\", fo.getName(), className);\n-                }\n-            } else {\n-                String cfName = cfInfo.cf.getName();\n-                if (!cfName.replaceAll(\"[\/$]\", \".\").equals(className.replaceAll(\"[\/$]\", \".\"))) {\n-                    reportWarning(\"warn.unexpected.class\", fo.getName(), className);\n-                }\n+            String cfName = cfInfo.cm.thisClass().asInternalName();\n+            if (!cfName.replaceAll(\"[\/$]\", \".\").equals(className.replaceAll(\"[\/$]\", \".\"))) {\n+                reportWarning(\"warn.unexpected.class\", fo.getName(), className);\n@@ -677,1 +673,1 @@\n-        write(cfInfo);\n+        if (!write(cfInfo)) return EXIT_ERROR;\n@@ -680,4 +676,4 @@\n-            ClassFile cf = cfInfo.cf;\n-            Attribute a = cf.getAttribute(Attribute.InnerClasses);\n-            if (a instanceof InnerClasses_attribute) {\n-                InnerClasses_attribute inners = (InnerClasses_attribute) a;\n+            ClassModel cm = cfInfo.cm;\n+            var a = cm.findAttribute(jdk.internal.classfile.Attributes.INNER_CLASSES);\n+            if (a.isPresent()) {\n+                var inners = a.get();\n@@ -686,8 +682,6 @@\n-                    for (int i = 0; i < inners.classes.length; i++) {\n-                        int outerIndex = inners.classes[i].outer_class_info_index;\n-                        ConstantPool.CONSTANT_Class_info outerClassInfo = cf.constant_pool.getClassInfo(outerIndex);\n-                        String outerClassName = outerClassInfo.getName();\n-                        if (outerClassName.equals(cf.getName())) {\n-                            int innerIndex = inners.classes[i].inner_class_info_index;\n-                            ConstantPool.CONSTANT_Class_info innerClassInfo = cf.constant_pool.getClassInfo(innerIndex);\n-                            String innerClassName = innerClassInfo.getName();\n+                    for (var inner : inners.classes()) {\n+                        var outerClassInfo = inner.outerClass();\n+                        String outerClassName = outerClassInfo.map(ClassEntry::asInternalName).orElse(null);\n+                        if (cm.thisClass().asInternalName().equals(outerClassName)) {\n+                            var innerClassInfo = inner.innerClass();\n+                            String innerClassName = innerClassInfo.asInternalName();\n@@ -701,1 +695,1 @@\n-                } catch (ConstantPoolException e) {\n+                } catch (IllegalArgumentException e) {\n@@ -705,3 +699,0 @@\n-            } else if (a != null) {\n-                reportError(\"err.bad.innerclasses.attribute\", className);\n-                return EXIT_ERROR;\n@@ -814,1 +805,1 @@\n-        ClassFileInfo(JavaFileObject fo, ClassFile cf, byte[] digest, int size) {\n+        ClassFileInfo(JavaFileObject fo, ClassModel cm, byte[] digest, int size) {\n@@ -816,1 +807,1 @@\n-            this.cf = cf;\n+            this.cm = cm;\n@@ -821,1 +812,1 @@\n-        public final ClassFile cf;\n+        public final ClassModel cm;\n@@ -826,1 +817,1 @@\n-    public ClassFileInfo read(JavaFileObject fo) throws IOException, ConstantPoolException {\n+    public ClassFileInfo read(JavaFileObject fo) throws IOException {\n@@ -839,2 +830,1 @@\n-\n-            ClassFile cf = ClassFile.read(in, attributeFactory);\n+            ClassModel cm = Classfile.of().parse(in.readAllBytes());\n@@ -843,1 +833,1 @@\n-            return new ClassFileInfo(fo, cf, digest, size);\n+            return new ClassFileInfo(fo, cm, digest, size);\n@@ -849,1 +839,1 @@\n-    public void write(ClassFileInfo info) {\n+    public boolean write(ClassFileInfo info) {\n@@ -858,50 +848,1 @@\n-        classWriter.write(info.cf);\n-    }\n-\n-    protected void setClassFile(ClassFile classFile) {\n-        ClassWriter classWriter = ClassWriter.instance(context);\n-        classWriter.setClassFile(classFile);\n-    }\n-\n-    protected void setMethod(Method enclosingMethod) {\n-        ClassWriter classWriter = ClassWriter.instance(context);\n-        classWriter.setMethod(enclosingMethod);\n-    }\n-\n-    protected void write(Attribute value) {\n-        AttributeWriter attrWriter = AttributeWriter.instance(context);\n-        ClassWriter classWriter = ClassWriter.instance(context);\n-        ClassFile cf = classWriter.getClassFile();\n-        attrWriter.write(cf, value, cf.constant_pool);\n-    }\n-\n-    protected void write(Attributes attrs) {\n-        AttributeWriter attrWriter = AttributeWriter.instance(context);\n-        ClassWriter classWriter = ClassWriter.instance(context);\n-        ClassFile cf = classWriter.getClassFile();\n-        attrWriter.write(cf, attrs, cf.constant_pool);\n-    }\n-\n-    protected void write(ConstantPool constant_pool) {\n-        ConstantWriter constantWriter = ConstantWriter.instance(context);\n-        constantWriter.writeConstantPool(constant_pool);\n-    }\n-\n-    protected void write(ConstantPool constant_pool, int value) {\n-        ConstantWriter constantWriter = ConstantWriter.instance(context);\n-        constantWriter.write(value);\n-    }\n-\n-    protected void write(ConstantPool.CPInfo value) {\n-        ConstantWriter constantWriter = ConstantWriter.instance(context);\n-        constantWriter.println(value);\n-    }\n-\n-    protected void write(Field value) {\n-        ClassWriter classWriter = ClassWriter.instance(context);\n-        classWriter.writeField(value);\n-    }\n-\n-    protected void write(Method value) {\n-        ClassWriter classWriter = ClassWriter.instance(context);\n-        classWriter.writeMethod(value);\n+        return classWriter.write(info.cm);\n@@ -947,1 +888,2 @@\n-                            throw new IOException(\"multiple definitions found for \" + moduleName);\n+                            throw new IOException(\"multiple definitions found for \"\n+                                    + moduleName);\n@@ -960,1 +902,2 @@\n-            String name = o.aliases[0].replaceAll(\"^-+\", \"\").replaceAll(\"-+\", \"_\"); \/\/ there must always be at least one name\n+            \/\/ there must always be at least one name\n+            String name = o.aliases[0].replaceAll(\"^-+\", \"\").replaceAll(\"-+\", \"_\");\n@@ -1003,1 +946,2 @@\n-                return getMessage(\"version.resource.missing\", System.getProperty(\"java.version\"));\n+                return getMessage(\"version.resource.missing\",\n+                        System.getProperty(\"java.version\"));\n@@ -1067,1 +1011,2 @@\n-                return getClass().getName() + \"[key=\" + key + \",args=\" + Arrays.asList(args) + \"]\";\n+                return getClass().getName() + \"[key=\" + key + \",args=\"\n+                        + Arrays.asList(args) + \"]\";\n@@ -1092,1 +1037,2 @@\n-                b = ResourceBundle.getBundle(\"com.sun.tools.javap.resources.javap\", locale);\n+                b = ResourceBundle.getBundle(\"com.sun.tools.javap.resources.javap\",\n+                        locale);\n@@ -1095,1 +1041,2 @@\n-                throw new InternalError(\"Cannot find javap resource bundle for locale \" + locale);\n+                throw new InternalError(\"Cannot find javap resource bundle for locale \"\n+                        + locale);\n@@ -1117,1 +1064,0 @@\n-    protected Attribute.Factory attributeFactory;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/JavapTask.java","additions":44,"deletions":98,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -28,8 +28,0 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.LocalVariableTable_attribute;\n@@ -39,1 +31,0 @@\n-import java.util.ListIterator;\n@@ -41,0 +32,5 @@\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.attribute.LocalVariableInfo;\n@@ -50,1 +46,1 @@\n-public class LocalVariableTableWriter extends  InstructionDetailWriter {\n+public class LocalVariableTableWriter extends InstructionDetailWriter {\n@@ -53,2 +49,3 @@\n-            public boolean match(LocalVariableTable_attribute.Entry entry, int pc) {\n-                return (pc == entry.start_pc);\n+            @Override\n+            public boolean match(LocalVariableInfo entry, int pc) {\n+                return (pc == entry.startPc());\n@@ -58,2 +55,3 @@\n-            public boolean match(LocalVariableTable_attribute.Entry entry, int pc) {\n-                return (pc == entry.start_pc + entry.length);\n+            @Override\n+            public boolean match(LocalVariableInfo entry, int pc) {\n+                return (pc == entry.startPc() + entry.length());\n@@ -65,1 +63,1 @@\n-        public abstract boolean match(LocalVariableTable_attribute.Entry entry, int pc);\n+        public abstract boolean match(LocalVariableInfo entry, int pc);\n@@ -82,1 +80,1 @@\n-    public void reset(Code_attribute attr) {\n+    public void reset(CodeModel attr) {\n@@ -85,3 +83,3 @@\n-        LocalVariableTable_attribute lvt =\n-                (LocalVariableTable_attribute) (attr.attributes.get(Attribute.LocalVariableTable));\n-        if (lvt == null)\n+        var lvt = attr.findAttribute(Attributes.LOCAL_VARIABLE_TABLE);\n+\n+        if (lvt.isEmpty())\n@@ -90,4 +88,3 @@\n-        for (int i = 0; i < lvt.local_variable_table.length; i++) {\n-            LocalVariableTable_attribute.Entry entry = lvt.local_variable_table[i];\n-            put(entry.start_pc, entry);\n-            put(entry.start_pc + entry.length, entry);\n+        for (var entry : lvt.get().localVariables()) {\n+            put(entry.startPc(), entry);\n+            put(entry.startPc() + entry.length(), entry);\n@@ -97,2 +94,2 @@\n-    public void writeDetails(Instruction instr) {\n-        int pc = instr.getPC();\n+    @Override\n+    public void writeDetails(int pc, Instruction instr) {\n@@ -104,2 +101,1 @@\n-    public void flush() {\n-        int pc = codeAttr.code_length;\n+    public void flush(int pc) {\n@@ -110,1 +106,0 @@\n-        ConstantPool constant_pool = classWriter.getClassFile().constant_pool;\n@@ -112,1 +107,1 @@\n-        List<LocalVariableTable_attribute.Entry> entries = pcMap.get(pc);\n+        var entries = pcMap.get(pc);\n@@ -114,2 +109,1 @@\n-            for (ListIterator<LocalVariableTable_attribute.Entry> iter =\n-                    entries.listIterator(kind == NoteKind.END ? entries.size() : 0);\n+            for (var iter = entries.listIterator(kind == NoteKind.END ? entries.size() : 0);\n@@ -117,2 +111,1 @@\n-                LocalVariableTable_attribute.Entry entry =\n-                        kind == NoteKind.END ? iter.previous() : iter.next();\n+                var entry = kind == NoteKind.END ? iter.previous() : iter.next();\n@@ -123,1 +116,1 @@\n-                    print(entry.index);\n+                    print(entry.slot());\n@@ -125,8 +118,2 @@\n-                    Descriptor d = new Descriptor(entry.descriptor_index);\n-                    try {\n-                        print(d.getFieldType(constant_pool));\n-                    } catch (InvalidDescriptor e) {\n-                        print(report(e));\n-                    } catch (ConstantPoolException e) {\n-                        print(report(e));\n-                    }\n+                    print(classWriter.sigPrinter.print(\n+                            Signature.parseFrom(entry.type().stringValue())));\n@@ -134,5 +121,1 @@\n-                    try {\n-                        print(constant_pool.getUTF8Value(entry.name_index));\n-                    } catch (ConstantPoolException e) {\n-                        print(report(e));\n-                    }\n+                    print(entry.name().stringValue());\n@@ -145,2 +128,2 @@\n-    private void put(int pc, LocalVariableTable_attribute.Entry entry) {\n-        List<LocalVariableTable_attribute.Entry> list = pcMap.get(pc);\n+    private void put(int pc, LocalVariableInfo entry) {\n+        var list = pcMap.get(pc);\n@@ -156,2 +139,2 @@\n-    private Code_attribute codeAttr;\n-    private Map<Integer, List<LocalVariableTable_attribute.Entry>> pcMap;\n+    private CodeModel codeAttr;\n+    private Map<Integer, List<LocalVariableInfo>> pcMap;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/LocalVariableTableWriter.java","additions":34,"deletions":51,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -28,9 +28,0 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.LocalVariableTypeTable_attribute;\n-import com.sun.tools.classfile.Signature;\n@@ -40,1 +31,0 @@\n-import java.util.ListIterator;\n@@ -42,0 +32,5 @@\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.Signature;\n+import jdk.internal.classfile.attribute.LocalVariableTypeInfo;\n@@ -54,2 +49,3 @@\n-            public boolean match(LocalVariableTypeTable_attribute.Entry entry, int pc) {\n-                return (pc == entry.start_pc);\n+            @Override\n+            public boolean match(LocalVariableTypeInfo entry, int pc) {\n+                return (pc == entry.startPc());\n@@ -59,2 +55,3 @@\n-            public boolean match(LocalVariableTypeTable_attribute.Entry entry, int pc) {\n-                return (pc == entry.start_pc + entry.length);\n+            @Override\n+            public boolean match(LocalVariableTypeInfo entry, int pc) {\n+                return (pc == entry.startPc() + entry.length());\n@@ -66,1 +63,1 @@\n-        public abstract boolean match(LocalVariableTypeTable_attribute.Entry entry, int pc);\n+        public abstract boolean match(LocalVariableTypeInfo entry, int pc);\n@@ -83,1 +80,1 @@\n-    public void reset(Code_attribute attr) {\n+    public void reset(CodeModel attr) {\n@@ -86,3 +83,3 @@\n-        LocalVariableTypeTable_attribute lvt =\n-                (LocalVariableTypeTable_attribute) (attr.attributes.get(Attribute.LocalVariableTypeTable));\n-        if (lvt == null)\n+        var lvt = attr.findAttribute(Attributes.LOCAL_VARIABLE_TYPE_TABLE);\n+\n+        if (lvt.isEmpty())\n@@ -91,4 +88,3 @@\n-        for (int i = 0; i < lvt.local_variable_table.length; i++) {\n-            LocalVariableTypeTable_attribute.Entry entry = lvt.local_variable_table[i];\n-            put(entry.start_pc, entry);\n-            put(entry.start_pc + entry.length, entry);\n+        for (var entry : lvt.get().localVariableTypes()) {\n+            put(entry.startPc(), entry);\n+            put(entry.startPc() + entry.length(), entry);\n@@ -98,2 +94,2 @@\n-    public void writeDetails(Instruction instr) {\n-        int pc = instr.getPC();\n+    @Override\n+    public void writeDetails(int pc, Instruction instr) {\n@@ -105,2 +101,1 @@\n-    public void flush() {\n-        int pc = codeAttr.code_length;\n+    public void flush(int pc) {\n@@ -111,1 +106,0 @@\n-        ConstantPool constant_pool = classWriter.getClassFile().constant_pool;\n@@ -113,1 +107,1 @@\n-        List<LocalVariableTypeTable_attribute.Entry> entries = pcMap.get(pc);\n+        var entries = pcMap.get(pc);\n@@ -115,2 +109,1 @@\n-            for (ListIterator<LocalVariableTypeTable_attribute.Entry> iter =\n-                    entries.listIterator(kind == NoteKind.END ? entries.size() : 0);\n+            for (var iter = entries.listIterator(kind == NoteKind.END ? entries.size() : 0);\n@@ -118,2 +111,1 @@\n-                LocalVariableTypeTable_attribute.Entry entry =\n-                        kind == NoteKind.END ? iter.previous() : iter.next();\n+                var entry = kind == NoteKind.END ? iter.previous() : iter.next();\n@@ -124,1 +116,1 @@\n-                    print(entry.index);\n+                    print(entry.slot());\n@@ -126,1 +118,0 @@\n-                    Descriptor d = new Signature(entry.signature_index);\n@@ -128,4 +119,3 @@\n-                        print(d.getFieldType(constant_pool).replace(\"\/\", \".\"));\n-                    } catch (InvalidDescriptor e) {\n-                        print(report(e));\n-                    } catch (ConstantPoolException e) {\n+                        print(classWriter.sigPrinter.print(Signature.parseFrom(\n+                                entry.signature().stringValue())).replace(\"\/\", \".\"));\n+                    } catch (Exception e) {\n@@ -135,5 +125,1 @@\n-                    try {\n-                        print(constant_pool.getUTF8Value(entry.name_index));\n-                    } catch (ConstantPoolException e) {\n-                        print(report(e));\n-                    }\n+                    print(entry.name().stringValue());\n@@ -146,2 +132,2 @@\n-    private void put(int pc, LocalVariableTypeTable_attribute.Entry entry) {\n-        List<LocalVariableTypeTable_attribute.Entry> list = pcMap.get(pc);\n+    private void put(int pc, LocalVariableTypeInfo entry) {\n+        var list = pcMap.get(pc);\n@@ -157,2 +143,2 @@\n-    private Code_attribute codeAttr;\n-    private Map<Integer, List<LocalVariableTypeTable_attribute.Entry>> pcMap;\n+    private CodeModel codeAttr;\n+    private Map<Integer, List<LocalVariableTypeInfo>> pcMap;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/LocalVariableTypeTableWriter.java","additions":34,"deletions":48,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import com.sun.tools.classfile.AccessFlags;\n+import static jdk.internal.classfile.Classfile.*;\n@@ -57,1 +57,1 @@\n-    public boolean checkAccess(AccessFlags flags){\n+    public boolean checkAccess(int flags){\n@@ -59,3 +59,3 @@\n-        boolean isPublic = flags.is(AccessFlags.ACC_PUBLIC);\n-        boolean isProtected = flags.is(AccessFlags.ACC_PROTECTED);\n-        boolean isPrivate = flags.is(AccessFlags.ACC_PRIVATE);\n+        boolean isPublic = (flags & ACC_PUBLIC) != 0;\n+        boolean isProtected = (flags & ACC_PROTECTED) != 0;\n+        boolean isPrivate = (flags & ACC_PRIVATE) != 0;\n@@ -64,1 +64,1 @@\n-        if ((showAccess == AccessFlags.ACC_PUBLIC) && (isProtected || isPrivate || isPackage))\n+        if ((showAccess == ACC_PUBLIC) && (isProtected || isPrivate || isPackage))\n@@ -66,1 +66,1 @@\n-        else if ((showAccess == AccessFlags.ACC_PROTECTED) && (isPrivate || isPackage))\n+        else if ((showAccess == ACC_PROTECTED) && (isPrivate || isPackage))\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/Options.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.Set;\n@@ -43,7 +42,4 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.LineNumberTable_attribute;\n-import com.sun.tools.classfile.SourceFile_attribute;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.Instruction;\n@@ -77,2 +73,2 @@\n-    public void reset(ClassFile cf, Code_attribute attr) {\n-        setSource(cf);\n+    public void reset(CodeModel attr) {\n+        setSource(attr.parent().get().parent().get());\n@@ -82,1 +78,2 @@\n-    public void writeDetails(Instruction instr) {\n+    @Override\n+    public void writeDetails(int pc, Instruction instr) {\n@@ -84,1 +81,1 @@\n-        Set<Integer> lines = lineMap.get(instr.getPC());\n+        var lines = lineMap.get(pc);\n@@ -108,1 +105,1 @@\n-    private void setLineMap(Code_attribute attr) {\n+    private void setLineMap(CodeModel attr) {\n@@ -111,13 +108,8 @@\n-        for (Attribute a: attr.attributes) {\n-            if (a instanceof LineNumberTable_attribute) {\n-                LineNumberTable_attribute t = (LineNumberTable_attribute) a;\n-                for (LineNumberTable_attribute.Entry e: t.line_number_table) {\n-                    int start_pc = e.start_pc;\n-                    int line = e.line_number;\n-                    SortedSet<Integer> pcLines = map.get(start_pc);\n-                    if (pcLines == null) {\n-                        pcLines = new TreeSet<>();\n-                        map.put(start_pc, pcLines);\n-                    }\n-                    pcLines.add(line);\n-                    allLines.add(line);\n+        for (var t : attr.findAttributes(Attributes.LINE_NUMBER_TABLE)) {\n+            for (var e: t.lineNumbers()) {\n+                int start_pc = e.startPc();\n+                int line = e.lineNumber();\n+                SortedSet<Integer> pcLines = map.get(start_pc);\n+                if (pcLines == null) {\n+                    pcLines = new TreeSet<>();\n+                    map.put(start_pc, pcLines);\n@@ -125,0 +117,2 @@\n+                pcLines.add(line);\n+                allLines.add(line);\n@@ -131,1 +125,1 @@\n-    private void setSource(ClassFile cf) {\n+    private void setSource(ClassModel cf) {\n@@ -138,1 +132,1 @@\n-    private String readSource(ClassFile cf) {\n+    private String readSource(ClassModel cf) {\n@@ -153,4 +147,3 @@\n-            String className = cf.getName();\n-            SourceFile_attribute sf =\n-                    (SourceFile_attribute) cf.attributes.get(Attribute.SourceFile);\n-            if (sf == null) {\n+            String className = cf.thisClass().asInternalName();\n+            var sf = cf.findAttribute(Attributes.SOURCE_FILE);\n+            if (sf.isEmpty()) {\n@@ -160,1 +153,1 @@\n-            String sourceFile = sf.getSourceFile(cf.constant_pool);\n+            String sourceFile = sf.get().sourceFile().stringValue();\n@@ -175,3 +168,0 @@\n-        } catch (ConstantPoolException e) {\n-            report(e);\n-            return null;\n@@ -208,1 +198,1 @@\n-    private ClassFile classFile;\n+    private ClassModel classFile;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/SourceWriter.java","additions":27,"deletions":37,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Arrays;\n@@ -30,0 +29,1 @@\n+import java.util.List;\n@@ -31,0 +31,2 @@\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.Classfile;\n@@ -32,13 +34,4 @@\n-import com.sun.tools.classfile.AccessFlags;\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPoolException;\n-import com.sun.tools.classfile.Descriptor;\n-import com.sun.tools.classfile.Descriptor.InvalidDescriptor;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.StackMapTable_attribute;\n-import com.sun.tools.classfile.StackMapTable_attribute.*;\n-\n-import static com.sun.tools.classfile.StackMapTable_attribute.verification_type_info.*;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n+import jdk.internal.classfile.attribute.StackMapFrameInfo;\n+import jdk.internal.classfile.attribute.StackMapTableAttribute;\n@@ -65,1 +58,0 @@\n-        classWriter = ClassWriter.instance(context);\n@@ -68,2 +60,2 @@\n-    public void reset(Code_attribute attr) {\n-        setStackMap((StackMapTable_attribute) attr.attributes.get(Attribute.StackMapTable));\n+    public void reset(CodeAttribute code) {\n+        setStackMap(code);\n@@ -72,1 +64,3 @@\n-    void setStackMap(StackMapTable_attribute attr) {\n+    void setStackMap(CodeAttribute code) {\n+        StackMapTableAttribute attr = code.findAttribute(Attributes.STACK_MAP_TABLE)\n+                .orElse(null);\n@@ -77,19 +71,5 @@\n-\n-        Method m = classWriter.getMethod();\n-        Descriptor d = m.descriptor;\n-        String[] args;\n-        try {\n-            ConstantPool cp = classWriter.getClassFile().constant_pool;\n-            String argString = d.getParameterTypes(cp);\n-            args = argString.substring(1, argString.length() - 1).split(\"[, ]+\");\n-        } catch (ConstantPoolException | InvalidDescriptor e) {\n-            return;\n-        }\n-        boolean isStatic = m.access_flags.is(AccessFlags.ACC_STATIC);\n-\n-        verification_type_info[] initialLocals = new verification_type_info[(isStatic ? 0 : 1) + args.length];\n-        if (!isStatic)\n-            initialLocals[0] = new CustomVerificationTypeInfo(\"this\");\n-        for (int i = 0; i < args.length; i++) {\n-            initialLocals[(isStatic ? 0 : 1) + i] =\n-                    new CustomVerificationTypeInfo(args[i].replace(\".\", \"\/\"));\n+        var m = code.parent().get();\n+        if ((m.flags().flagsMask() & Classfile.ACC_STATIC) == 0) {\n+            thisClassName =  m.parent().get().thisClass().asInternalName();\n+        } else {\n+            thisClassName = null;\n@@ -99,12 +79,3 @@\n-        StackMapBuilder builder = new StackMapBuilder();\n-\n-        \/\/ using -1 as the pc for the initial frame effectively compensates for\n-        \/\/ the difference in behavior for the first stack map frame (where the\n-        \/\/ pc offset is just offset_delta) compared to subsequent frames (where\n-        \/\/ the pc offset is always offset_delta+1).\n-        int pc = -1;\n-\n-        map.put(pc, new StackMap(initialLocals, empty));\n-\n-        for (int i = 0; i < attr.entries.length; i++)\n-            pc = attr.entries[i].accept(builder, pc);\n+        this.code = code;\n+        for (var fr : attr.entries())\n+            map.put(code.labelToBci(fr.target()), fr);\n@@ -117,2 +88,3 @@\n-    public void writeDetails(Instruction instr) {\n-        writeDetails(instr.getPC());\n+    @Override\n+    public void writeDetails(int pc, Instruction instr) {\n+        writeDetails(pc);\n@@ -125,1 +97,1 @@\n-        StackMap m = map.get(pc);\n+        var m = map.get(pc);\n@@ -127,2 +99,2 @@\n-            print(\"StackMap locals: \", m.locals);\n-            print(\"StackMap stack: \", m.stack);\n+            print(\"StackMap locals: \", m.locals(), true);\n+            print(\"StackMap stack: \", m.stack(), false);\n@@ -133,1 +105,2 @@\n-    void print(String label, verification_type_info[] entries) {\n+    void print(String label, List<StackMapFrameInfo.VerificationTypeInfo> entries,\n+            boolean firstThis) {\n@@ -135,1 +108,1 @@\n-        for (int i = 0; i < entries.length; i++) {\n+        for (var e : entries) {\n@@ -137,1 +110,2 @@\n-            print(entries[i]);\n+            print(e, firstThis);\n+            firstThis = false;\n@@ -142,1 +116,1 @@\n-    void print(verification_type_info entry) {\n+    void print(StackMapFrameInfo.VerificationTypeInfo entry, boolean firstThis) {\n@@ -148,8 +122,5 @@\n-        switch (entry.tag) {\n-            case -1:\n-                print(((CustomVerificationTypeInfo) entry).text);\n-                break;\n-\n-            case ITEM_Top:\n-                print(\"top\");\n-                break;\n+        switch (entry) {\n+            case StackMapFrameInfo.SimpleVerificationTypeInfo s -> {\n+                switch (s) {\n+                    case ITEM_TOP ->\n+                        print(\"top\");\n@@ -157,3 +128,2 @@\n-            case ITEM_Integer:\n-                print(\"int\");\n-                break;\n+                    case ITEM_INTEGER ->\n+                        print(\"int\");\n@@ -161,3 +131,2 @@\n-            case ITEM_Float:\n-                print(\"float\");\n-                break;\n+                    case ITEM_FLOAT ->\n+                        print(\"float\");\n@@ -165,3 +134,2 @@\n-            case ITEM_Long:\n-                print(\"long\");\n-                break;\n+                    case ITEM_LONG ->\n+                        print(\"long\");\n@@ -169,3 +137,2 @@\n-            case ITEM_Double:\n-                print(\"double\");\n-                break;\n+                    case ITEM_DOUBLE ->\n+                        print(\"double\");\n@@ -173,3 +140,2 @@\n-            case ITEM_Null:\n-                print(\"null\");\n-                break;\n+                    case ITEM_NULL ->\n+                        print(\"null\");\n@@ -177,11 +143,2 @@\n-            case ITEM_UninitializedThis:\n-                print(\"uninit_this\");\n-                break;\n-\n-            case ITEM_Object:\n-                try {\n-                    ConstantPool cp = classWriter.getClassFile().constant_pool;\n-                    ConstantPool.CONSTANT_Class_info class_info = cp.getClassInfo(((Object_variable_info) entry).cpool_index);\n-                    print(cp.getUTF8Value(class_info.name_index));\n-                } catch (ConstantPoolException e) {\n-                    print(\"??\");\n+                    case ITEM_UNINITIALIZED_THIS ->\n+                        print(\"uninit_this\");\n@@ -189,22 +146,1 @@\n-                break;\n-\n-            case ITEM_Uninitialized:\n-                print(((Uninitialized_variable_info) entry).offset);\n-                break;\n-        }\n-\n-    }\n-\n-    private Map<Integer, StackMap> map;\n-    private ClassWriter classWriter;\n-\n-    class StackMapBuilder\n-            implements StackMapTable_attribute.stack_map_frame.Visitor<Integer, Integer> {\n-\n-        public Integer visit_same_frame(same_frame frame, Integer pc) {\n-            int new_pc = pc + frame.getOffsetDelta() + 1;\n-            StackMap m = map.get(pc);\n-            assert (m != null);\n-            map.put(new_pc, m);\n-            return new_pc;\n-        }\n+            }\n@@ -212,8 +148,4 @@\n-        public Integer visit_same_locals_1_stack_item_frame(same_locals_1_stack_item_frame frame, Integer pc) {\n-            int new_pc = pc + frame.getOffsetDelta() + 1;\n-            StackMap prev = map.get(pc);\n-            assert (prev != null);\n-            StackMap m = new StackMap(prev.locals, frame.stack);\n-            map.put(new_pc, m);\n-            return new_pc;\n-        }\n+            case StackMapFrameInfo.ObjectVerificationTypeInfo o -> {\n+                String cln = o.className().asInternalName();\n+                print(firstThis && cln.equals(thisClassName) ? \"this\" : cln);\n+            }\n@@ -221,7 +153,2 @@\n-        public Integer visit_same_locals_1_stack_item_frame_extended(same_locals_1_stack_item_frame_extended frame, Integer pc) {\n-            int new_pc = pc + frame.getOffsetDelta() + 1;\n-            StackMap prev = map.get(pc);\n-            assert (prev != null);\n-            StackMap m = new StackMap(prev.locals, frame.stack);\n-            map.put(new_pc, m);\n-            return new_pc;\n+            case StackMapFrameInfo.UninitializedVerificationTypeInfo u ->\n+                print(code.labelToBci(u.newTarget()));\n@@ -230,56 +157,0 @@\n-        public Integer visit_chop_frame(chop_frame frame, Integer pc) {\n-            int new_pc = pc + frame.getOffsetDelta() + 1;\n-            StackMap prev = map.get(pc);\n-            assert (prev != null);\n-            int k = 251 - frame.frame_type;\n-            verification_type_info[] new_locals = Arrays.copyOf(prev.locals, prev.locals.length - k);\n-            StackMap m = new StackMap(new_locals, empty);\n-            map.put(new_pc, m);\n-            return new_pc;\n-        }\n-\n-        public Integer visit_same_frame_extended(same_frame_extended frame, Integer pc) {\n-            int new_pc = pc + frame.getOffsetDelta();\n-            StackMap m = map.get(pc);\n-            assert (m != null);\n-            map.put(new_pc, m);\n-            return new_pc;\n-        }\n-\n-        public Integer visit_append_frame(append_frame frame, Integer pc) {\n-            int new_pc = pc + frame.getOffsetDelta() + 1;\n-            StackMap prev = map.get(pc);\n-            assert (prev != null);\n-            verification_type_info[] new_locals = new verification_type_info[prev.locals.length + frame.locals.length];\n-            System.arraycopy(prev.locals, 0, new_locals, 0, prev.locals.length);\n-            System.arraycopy(frame.locals, 0, new_locals, prev.locals.length, frame.locals.length);\n-            StackMap m = new StackMap(new_locals, empty);\n-            map.put(new_pc, m);\n-            return new_pc;\n-        }\n-\n-        public Integer visit_full_frame(full_frame frame, Integer pc) {\n-            int new_pc = pc + frame.getOffsetDelta() + 1;\n-            StackMap m = new StackMap(frame.locals, frame.stack);\n-            map.put(new_pc, m);\n-            return new_pc;\n-        }\n-\n-    }\n-\n-    static class StackMap {\n-        StackMap(verification_type_info[] locals, verification_type_info[] stack) {\n-            this.locals = locals;\n-            this.stack = stack;\n-        }\n-\n-        private final verification_type_info[] locals;\n-        private final verification_type_info[] stack;\n-    }\n-\n-    static class CustomVerificationTypeInfo extends verification_type_info {\n-        public CustomVerificationTypeInfo(String text) {\n-            super(-1);\n-            this.text = text;\n-        }\n-        private String text;\n@@ -288,1 +159,3 @@\n-    private final verification_type_info[] empty = { };\n+    private Map<Integer, StackMapFrameInfo> map;\n+    private String thisClassName;\n+    private CodeAttribute code;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/StackMapWriter.java","additions":59,"deletions":186,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.Code_attribute.Exception_data;\n-import com.sun.tools.classfile.Instruction;\n@@ -34,1 +31,0 @@\n-import java.util.ListIterator;\n@@ -36,0 +32,3 @@\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.instruction.ExceptionCatch;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n@@ -48,2 +47,2 @@\n-            public boolean match(Exception_data entry, int pc) {\n-                return (pc == entry.start_pc);\n+            public boolean match(ExceptionCatch entry, int pc, CodeAttribute lr) {\n+                return (pc == lr.labelToBci(entry.tryStart()));\n@@ -53,2 +52,2 @@\n-            public boolean match(Exception_data entry, int pc) {\n-                return (pc == entry.end_pc);\n+            public boolean match(ExceptionCatch entry, int pc, CodeAttribute lr) {\n+                return (pc == lr.labelToBci(entry.tryEnd()));\n@@ -58,2 +57,2 @@\n-            public boolean match(Exception_data entry, int pc) {\n-                return (pc == entry.handler_pc);\n+            public boolean match(ExceptionCatch entry, int pc, CodeAttribute lr) {\n+                return (pc == lr.labelToBci(entry.handler()));\n@@ -65,1 +64,1 @@\n-        public abstract boolean match(Exception_data entry, int pc);\n+        public abstract boolean match(ExceptionCatch entry, int pc, CodeAttribute lr);\n@@ -82,1 +81,1 @@\n-    public void reset(Code_attribute attr) {\n+    public void reset(CodeAttribute attr) {\n@@ -85,2 +84,4 @@\n-        for (int i = 0; i < attr.exception_table.length; i++) {\n-            Exception_data entry = attr.exception_table[i];\n+        lr = attr;\n+        var excs = attr.exceptionHandlers();\n+        for (int i = 0; i < excs.size(); i++) {\n+            var entry = excs.get(i);\n@@ -88,3 +89,3 @@\n-            put(entry.start_pc, entry);\n-            put(entry.end_pc, entry);\n-            put(entry.handler_pc, entry);\n+            put(lr.labelToBci(entry.tryStart()), entry);\n+            put(lr.labelToBci(entry.tryEnd()), entry);\n+            put(lr.labelToBci(entry.handler()), entry);\n@@ -94,4 +95,5 @@\n-    public void writeDetails(Instruction instr) {\n-        writeTrys(instr, NoteKind.END);\n-        writeTrys(instr, NoteKind.START);\n-        writeTrys(instr, NoteKind.HANDLER);\n+    @Override\n+    public void writeDetails(int pc, Instruction instr) {\n+        writeTrys(pc, instr, NoteKind.END);\n+        writeTrys(pc, instr, NoteKind.START);\n+        writeTrys(pc, instr, NoteKind.HANDLER);\n@@ -100,1 +102,1 @@\n-    public void writeTrys(Instruction instr, NoteKind kind) {\n+    public void writeTrys(int pc, Instruction instr, NoteKind kind) {\n@@ -102,2 +104,1 @@\n-        int pc = instr.getPC();\n-        List<Exception_data> entries = pcMap.get(pc);\n+        var entries = pcMap.get(pc);\n@@ -105,1 +106,1 @@\n-            for (ListIterator<Exception_data> iter =\n+            for (var iter =\n@@ -108,1 +109,1 @@\n-                Exception_data entry =\n+                var entry =\n@@ -110,1 +111,1 @@\n-                if (kind.match(entry, pc)) {\n+                if (kind.match(entry, pc, lr)) {\n@@ -116,1 +117,2 @@\n-                    if (entry.catch_type == 0)\n+                    var ct = entry.catchType();\n+                    if (ct.isEmpty())\n@@ -119,1 +121,1 @@\n-                        print(\"#\" + entry.catch_type);\n+                        print(\"#\" + ct.get().index());\n@@ -121,1 +123,1 @@\n-                        constantWriter.write(entry.catch_type);\n+                        constantWriter.write(ct.get().index());\n@@ -129,2 +131,2 @@\n-    private void put(int pc, Exception_data entry) {\n-        List<Exception_data> list = pcMap.get(pc);\n+    private void put(int pc, ExceptionCatch entry) {\n+        var list = pcMap.get(pc);\n@@ -139,2 +141,2 @@\n-    private Map<Integer, List<Exception_data>> pcMap;\n-    private Map<Exception_data, Integer> indexMap;\n+    private Map<Integer, List<ExceptionCatch>> pcMap;\n+    private Map<ExceptionCatch, Integer> indexMap;\n@@ -142,0 +144,1 @@\n+    private CodeAttribute lr;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/TryBlockWriter.java","additions":37,"deletions":34,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -28,9 +28,0 @@\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.TypeAnnotation;\n-import com.sun.tools.classfile.TypeAnnotation.Position;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n-import com.sun.tools.classfile.RuntimeInvisibleTypeAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeTypeAnnotations_attribute;\n-import com.sun.tools.classfile.RuntimeVisibleTypeAnnotations_attribute;\n@@ -40,0 +31,1 @@\n+import java.util.Locale;\n@@ -41,1 +33,6 @@\n-import com.sun.tools.javac.util.StringUtils;\n+import java.util.Optional;\n+import jdk.internal.classfile.Attributes;\n+import jdk.internal.classfile.Instruction;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.TypeAnnotation;\n+import jdk.internal.classfile.attribute.CodeAttribute;\n@@ -77,2 +74,2 @@\n-    public void reset(Code_attribute attr) {\n-        Method m = classWriter.getMethod();\n+    public void reset(CodeAttribute attr) {\n+        MethodModel m = attr.parent().get();\n@@ -80,2 +77,7 @@\n-        check(NoteKind.VISIBLE, (RuntimeVisibleTypeAnnotations_attribute) m.attributes.get(Attribute.RuntimeVisibleTypeAnnotations));\n-        check(NoteKind.INVISIBLE, (RuntimeInvisibleTypeAnnotations_attribute) m.attributes.get(Attribute.RuntimeInvisibleTypeAnnotations));\n+        codeAttribute = attr;\n+        check(NoteKind.VISIBLE,\n+                m.findAttribute(Attributes.RUNTIME_VISIBLE_TYPE_ANNOTATIONS)\n+                        .map(a -> a.annotations()));\n+        check(NoteKind.INVISIBLE,\n+                m.findAttribute(Attributes.RUNTIME_INVISIBLE_TYPE_ANNOTATIONS)\n+                        .map(a -> a.annotations()));\n@@ -84,2 +86,2 @@\n-    private void check(NoteKind kind, RuntimeTypeAnnotations_attribute attr) {\n-        if (attr == null)\n+    private void check(NoteKind kind, Optional<List<TypeAnnotation>> annos) {\n+        if (annos.isEmpty())\n@@ -88,10 +90,9 @@\n-        for (TypeAnnotation anno: attr.annotations) {\n-            Position p = anno.position;\n-            Note note = null;\n-            if (p.offset != -1)\n-                addNote(p.offset, note = new Note(kind, anno));\n-            if (p.lvarOffset != null) {\n-                for (int i = 0; i < p.lvarOffset.length; i++) {\n-                    if (note == null)\n-                        note = new Note(kind, anno);\n-                    addNote(p.lvarOffset[i], note);\n+        for (TypeAnnotation anno: annos.get()) {\n+            switch (anno.targetInfo()) {\n+                case TypeAnnotation.LocalVarTarget p -> {\n+                    Note note = null;\n+                    for (var lvar : p.table()) {\n+                        if (note == null)\n+                            note = new Note(kind, anno);\n+                        addNote(codeAttribute.labelToBci(lvar.startLabel()), note);\n+                    }\n@@ -99,0 +100,5 @@\n+                case TypeAnnotation.OffsetTarget p ->\n+                    addNote(codeAttribute.labelToBci(p.target()), new Note(kind, anno));\n+                case TypeAnnotation.TypeArgumentTarget p ->\n+                    addNote(codeAttribute.labelToBci(p.target()), new Note(kind, anno));\n+                default -> {}\n@@ -111,1 +117,1 @@\n-    void writeDetails(Instruction instr) {\n+    void writeDetails(int pc, Instruction instr) {\n@@ -113,1 +119,0 @@\n-        int pc = instr.getPC();\n@@ -119,1 +124,1 @@\n-                annotationWriter.write(n.anno, false, true);\n+                annotationWriter.write(n.anno, false, true, codeAttribute);\n@@ -121,1 +126,1 @@\n-                println(StringUtils.toLowerCase(n.kind.toString()));\n+                println(n.kind.toString().toLowerCase(Locale.US));\n@@ -129,0 +134,1 @@\n+    private CodeAttribute codeAttribute;\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/TypeAnnotationWriter.java","additions":36,"deletions":30,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+serviceability\/sa\/ClhsdbDumpclass.java 8316342 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.io.StringWriter;\n@@ -37,4 +38,11 @@\n-        if (com.sun.tools.javap.Main.run(new String[]{\"-c\", System.getProperty(\"test.classes\") + \"\/InvalidSignature.class\"},\n-                new PrintWriter(System.out)) != 0) {\n-            throw new AssertionError();\n-        }\n+        var sw = new StringWriter();\n+        int res = com.sun.tools.javap.Main.run(\n+                new String[]{\"-c\", System.getProperty(\"test.classes\") + \"\/InvalidSignature.class\"},\n+                new PrintWriter(sw));\n+        System.out.println(sw);\n+        if (res == 0)\n+            throw new AssertionError(\"Failure exit code expected\");\n+        if (sw.toString().contains(\"Fatal error\"))\n+            throw new AssertionError(\"Unguarded fatal error\");\n+        if (sw.toString().contains(\"error while reading constant pool\"))\n+            throw new AssertionError(\"Unguarded constant pool error\");\n","filename":"test\/langtools\/tools\/javap\/8260403\/T8260403.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -63,1 +63,3 @@\n-                expectEqual(cfInfo.cf.byteLength(), cfInfo.size);\n+                try (var in = fo.openInputStream()) {\n+                    expectEqual(in.readAllBytes().length, cfInfo.size);\n+                }\n","filename":"test\/langtools\/tools\/javap\/T6866657.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,3 @@\n-                expectEqual(cfInfo.cf.byteLength(), cfInfo.size);\n+                try (var in = fo.openInputStream()) {\n+                    expectEqual(in.readAllBytes().length, cfInfo.size);\n+                }\n","filename":"test\/langtools\/tools\/javap\/T7186925.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+class Malformed {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  0; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Utf8 \"Code\"; \/\/ #1\n+    Method #0 #0; \/\/ #2\n+    class #0; \/\/ #3\n+  } \/\/ Constant Pool\n+\n+  0x0000; \/\/ access\n+  #0;\/\/ this_cpx\n+  #3;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+    #0;\n+    #3;\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ fields\n+    { \/\/ Member\n+      0x0000; \/\/ access\n+      #0; \/\/ name_cpx\n+      #0; \/\/ sig_cpx\n+      [] { \/\/ Attributes\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ fields\n+\n+  [] { \/\/ methods\n+    { \/\/ Member\n+      0x0000; \/\/ access\n+      #0; \/\/ name_cpx\n+      #0; \/\/ sig_cpx\n+      [] { \/\/ Attributes\n+        Attr(#1) { \/\/ Code\n+          0; \/\/ max_stack\n+          0; \/\/ max_locals\n+          Bytes[]{\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    } \/\/ Member\n+  } \/\/ methods\n+\n+  [] { \/\/ Attributes\n+  } \/\/ Attributes\n+} \/\/ end class Malformed\n+\n","filename":"test\/langtools\/tools\/javap\/malformed\/Malformed.jcod","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8294969\n+ * @summary javap test safeguarding malformed class file\n+ * @build Malformed\n+ * @run main MalformedTest\n+ * @modules jdk.jdeps\/com.sun.tools.javap\n+ *\/\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+\n+public class MalformedTest {\n+\n+    public static void main(String args[]) throws Exception {\n+        var sw = new StringWriter();\n+        int res = com.sun.tools.javap.Main.run(\n+                new String[]{\"-c\", \"-v\", System.getProperty(\"test.classes\") + \"\/Malformed.class\"},\n+                new PrintWriter(sw));\n+        System.out.println(sw);\n+        if (res == 0)\n+            throw new AssertionError(\"Failure exit code expected\");\n+        if (sw.toString().contains(\"Fatal error\"))\n+            throw new AssertionError(\"Unguarded fatal error\");\n+        if (sw.toString().contains(\"error while reading constant pool\"))\n+            throw new AssertionError(\"Unguarded constant pool error\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javap\/malformed\/MalformedTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"}]}