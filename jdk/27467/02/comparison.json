{"files":[{"patch":"@@ -917,0 +917,11 @@\n+  static uint32_t encode_csrrw(Register Rd, const uint32_t csr, Register Rs1) {\n+    guarantee(is_uimm12(csr), \"csr is invalid\");\n+    uint32_t insn = 0;\n+    patch((address)&insn, 6, 0, 0b1110011);\n+    patch((address)&insn, 14, 12, 0b001);\n+    patch_reg((address)&insn, 7, Rd);\n+    patch_reg((address)&insn, 15, Rs1);\n+    patch((address)&insn, 31, 20, csr);\n+    return insn;\n+  }\n+\n@@ -3696,8 +3707,7 @@\n-#define INSN(NAME)                                                                           \\\n-  void NAME(Register Rd, int32_t imm) {                                                      \\\n-    \/* lui -> c.lui *\/                                                                       \\\n-    if (do_compress() && (Rd != x0 && Rd != x2 && imm != 0 && is_simm18(imm))) {             \\\n-      c_lui(Rd, imm);                                                                        \\\n-      return;                                                                                \\\n-    }                                                                                        \\\n-    _lui(Rd, imm);                                                                           \\\n+  void lui(Register Rd, int32_t imm) {\n+    \/* lui -> c.lui *\/\n+    if (do_compress() && (Rd != x0 && Rd != x2 && imm != 0 && is_simm18(imm))) {\n+      c_lui(Rd, imm);\n+      return;\n+    }\n+    _lui(Rd, imm);\n@@ -3706,3 +3716,0 @@\n-  INSN(lui);\n-\n-#undef INSN\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1353,0 +1353,1 @@\n+  Assembler::IncompressibleScope scope(_masm);\n@@ -1363,0 +1364,1 @@\n+  Assembler::IncompressibleScope scope(_masm);\n@@ -1845,0 +1847,4 @@\n+  Assembler::IncompressibleScope scope(_masm);\n+  \/\/ Post call nops must be natural aligned due to cmodx rules.\n+  align_call(lir_rtcall);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -358,0 +358,2 @@\n+  assert(!in_compressible_scope(), \"Must be\");\n+  assert_alignment(pc());\n@@ -361,5 +363,3 @@\n-  relocate(post_call_nop_Relocation::spec(), [&] {\n-    InlineSkippedInstructionsCounter skipCounter(this);\n-    nop();\n-    li32(zr, 0);\n-  });\n+  InlineSkippedInstructionsCounter skipCounter(this);\n+  nop();\n+  li32(zr, 0);\n@@ -5016,1 +5016,1 @@\n-  IncompressibleScope scope(this); \/\/ relocations\n+  assert(!in_compressible_scope(), \"Must be\");\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -334,5 +334,0 @@\n-void NativeIllegalInstruction::insert(address code_pos) {\n-  assert_cond(code_pos != nullptr);\n-  Assembler::sd_instr(code_pos, 0xffffffff);   \/\/ all bits ones is permanently reserved as an illegal instruction\n-}\n-\n@@ -340,1 +335,3 @@\n-  return uint_at(0) == 0xc0101073; \/\/ an illegal instruction, 'csrrw x0, time, x0'\n+  \/\/ an illegal instruction, 'csrrw x0, time, x0'\n+  uint32_t encoded = Assembler::encode_csrrw(x0, Assembler::time, x0);\n+  return uint_at(0) == encoded;\n@@ -350,0 +347,2 @@\n+  MacroAssembler::assert_alignment(code_pos);\n+\n@@ -381,0 +380,1 @@\n+  MacroAssembler::assert_alignment(addr_at(4));\n@@ -392,1 +392,5 @@\n-void NativeDeoptInstruction::verify() {\n+bool NativeDeoptInstruction::is_deopt_at(address instr) {\n+  assert(instr != nullptr, \"Must be\");\n+  uint32_t value = Assembler::ld_instr(instr);\n+  uint32_t encoded = Assembler::encode_csrrw(x0, Assembler::instret, x0);\n+  return value == encoded;\n@@ -397,4 +401,3 @@\n-  \/\/ 0xc0201073 encodes CSRRW x0, instret, x0\n-  uint32_t insn = 0xc0201073;\n-  uint32_t *pos = (uint32_t *) code_pos;\n-  *pos = insn;\n+  MacroAssembler::assert_alignment(code_pos);\n+  uint32_t encoded = Assembler::encode_csrrw(x0, Assembler::instret, x0);\n+  Assembler::sd_instr(code_pos, encoded);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -297,6 +297,0 @@\n-class NativeIllegalInstruction: public NativeInstruction {\n- public:\n-  \/\/ Insert illegal opcode as specific address\n-  static void insert(address code_pos);\n-};\n-\n@@ -356,8 +350,1 @@\n-  void verify();\n-\n-  static bool is_deopt_at(address instr) {\n-    assert(instr != nullptr, \"\");\n-    uint32_t value = Assembler::ld_instr(instr);\n-    \/\/ 0xc0201073 encodes CSRRW x0, instret, x0\n-    return value == 0xc0201073;\n-  }\n+  static bool is_deopt_at(address instr);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1272,0 +1272,20 @@\n+int CallRuntimeDirectNode::compute_padding(int current_offset) const\n+{\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n+\n+int CallLeafDirectNode::compute_padding(int current_offset) const\n+{\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n+\n+int CallLeafDirectVectorNode::compute_padding(int current_offset) const\n+{\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n+\n+int CallLeafNoFPDirectNode::compute_padding(int current_offset) const\n+{\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n+\n@@ -8178,1 +8198,1 @@\n- \n+\n@@ -10512,0 +10532,1 @@\n+  ins_alignment(4);\n@@ -10529,0 +10550,1 @@\n+  ins_alignment(4);\n@@ -10546,0 +10568,1 @@\n+  ins_alignment(4);\n@@ -10563,0 +10586,1 @@\n+  ins_alignment(4);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1005,2 +1005,10 @@\n-    \/\/ Make sure the call is patchable\n-    __ align(NativeInstruction::instruction_size);\n+    address call_pc;\n+    {\n+      Assembler::IncompressibleScope scope(masm);\n+      \/\/ Make sure the call is patchable\n+      __ align(NativeInstruction::instruction_size);\n+\n+      call_pc = __ reloc_call(resolve);\n+      if (call_pc == nullptr) {\n+        fatal(\"CodeCache is full at gen_continuation_enter\");\n+      }\n@@ -1008,3 +1016,2 @@\n-    const address tr_call = __ reloc_call(resolve);\n-    if (tr_call == nullptr) {\n-      fatal(\"CodeCache is full at gen_continuation_enter\");\n+      oop_maps->add_gc_map(__ pc() - start, map);\n+      __ post_call_nop();\n@@ -1012,4 +1019,0 @@\n-\n-    oop_maps->add_gc_map(__ pc() - start, map);\n-    __ post_call_nop();\n-\n@@ -1018,1 +1021,1 @@\n-    address stub = CompiledDirectCall::emit_to_interp_stub(masm, tr_call);\n+    address stub = CompiledDirectCall::emit_to_interp_stub(masm, call_pc);\n@@ -1037,2 +1040,5 @@\n-  \/\/ Make sure the call is patchable\n-  __ align(NativeInstruction::instruction_size);\n+  address call_pc;\n+  {\n+    Assembler::IncompressibleScope scope(masm);\n+    \/\/ Make sure the call is patchable\n+    __ align(NativeInstruction::instruction_size);\n@@ -1040,4 +1046,4 @@\n-  const address tr_call = __ reloc_call(resolve);\n-  if (tr_call == nullptr) {\n-    fatal(\"CodeCache is full at gen_continuation_enter\");\n-  }\n+    call_pc = __ reloc_call(resolve);\n+    if (call_pc == nullptr) {\n+      fatal(\"CodeCache is full at gen_continuation_enter\");\n+    }\n@@ -1045,2 +1051,3 @@\n-  oop_maps->add_gc_map(__ pc() - start, map);\n-  __ post_call_nop();\n+    oop_maps->add_gc_map(__ pc() - start, map);\n+    __ post_call_nop();\n+  }\n@@ -1052,5 +1059,11 @@\n-  ContinuationEntry::_thaw_call_pc_offset = __ pc() - start;\n-  __ rt_call(CAST_FROM_FN_PTR(address, StubRoutines::cont_thaw()));\n-  oop_maps->add_gc_map(__ pc() - start, map->deep_copy());\n-  ContinuationEntry::_return_pc_offset = __ pc() - start;\n-  __ post_call_nop();\n+  \/\/ Post call nops must be natural aligned due to cmodx rules.\n+  {\n+    Assembler::IncompressibleScope scope(masm);\n+    __ align(NativeInstruction::instruction_size);\n+\n+    ContinuationEntry::_thaw_call_pc_offset = __ pc() - start;\n+    __ rt_call(CAST_FROM_FN_PTR(address, StubRoutines::cont_thaw()));\n+    oop_maps->add_gc_map(__ pc() - start, map->deep_copy());\n+    ContinuationEntry::_return_pc_offset = __ pc() - start;\n+    __ post_call_nop();\n+  }\n@@ -1085,1 +1098,1 @@\n-  address stub = CompiledDirectCall::emit_to_interp_stub(masm, tr_call);\n+  address stub = CompiledDirectCall::emit_to_interp_stub(masm, call_pc);\n@@ -1118,0 +1131,3 @@\n+  \/\/ Post call nops must be natural aligned due to cmodx rules.\n+  __ align(NativeInstruction::instruction_size);\n+\n@@ -1121,1 +1137,4 @@\n-  __ post_call_nop(); \/\/ this must be exactly after the pc value that is pushed into the frame info, we use this nop for fast CodeBlob lookup\n+  {\n+    Assembler::IncompressibleScope scope(masm);\n+    __ post_call_nop(); \/\/ this must be exactly after the pc value that is pushed into the frame info, we use this nop for fast CodeBlob lookup\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":44,"deletions":25,"binary":false,"changes":69,"status":"modified"}]}