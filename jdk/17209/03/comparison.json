{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -243,0 +243,2 @@\n+            closed = true;\n+            IOException finishException = null;\n@@ -245,0 +247,3 @@\n+            } catch (IOException ioe){\n+                finishException = ioe;\n+                throw ioe;\n@@ -246,1 +251,1 @@\n-                if (usesDefaultDeflater)\n+                if (usesDefaultDeflater) {\n@@ -248,0 +253,13 @@\n+                }\n+                if (finishException == null) {\n+                    out.close();\n+                } else {\n+                    try {\n+                        out.close();\n+                    } catch (IOException ioe) {\n+                        if (finishException != ioe) {\n+                            ioe.addSuppressed(finishException);\n+                        }\n+                        throw ioe;\n+                    }\n+                }\n@@ -249,2 +267,0 @@\n-            out.close();\n-            closed = true;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/DeflaterOutputStream.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 8313739\n+   @summary Verify that ZipOutputStream closes the wrapped stream even after failed writes\n+   @run junit CloseWrappedStream\n+   *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class CloseWrappedStream {\n+\n+    \/**\n+     * Verify that closing a ZipOutputStream closes the wrapped output stream,\n+     * also when the wrapped stream throws while remaining data is flushed\n+     *\/\n+    @Test\n+    public void exceptionDuringFinish() {\n+        \/\/ A wrapped stream which should be closed even after a write failure\n+        WrappedOutputStream wrappedStream = new WrappedOutputStream();\n+\n+        IOException exception = assertThrows(IOException.class, () -> {\n+            try (ZipOutputStream zo = new ZipOutputStream(wrappedStream)) {\n+                zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+                zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+                \/\/ Make finish() throw IOException\n+                wrappedStream.failOnWrite = true;\n+            } \/\/ Close throws when deflated data is flushed to wrapped stream\n+        });\n+\n+        \/\/ Check that we failed with the expected message\n+        assertEquals(WrappedOutputStream.WRITE_MSG, exception.getMessage());\n+\n+        \/\/ Verify that the wrapped stream was closed once\n+        assertEquals(1, wrappedStream.timesClosed,\n+                \"Expected wrapped output stream to be closed once\");\n+    }\n+\n+    \/**\n+     * Sanity check that the wrapped stream is closed also for the\n+     * normal case where the wrapped stream does not throw\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void noExceptions() throws IOException {\n+\n+        WrappedOutputStream wrappedStream = new WrappedOutputStream();\n+\n+        try (ZipOutputStream zo = new ZipOutputStream(wrappedStream)) {\n+            zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+            zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+        }\n+\n+        \/\/ Verify that the wrapped stream was closed once\n+        assertEquals(1, wrappedStream.timesClosed,\n+                \"Expected wrapped output stream to be closed once\");\n+    }\n+\n+    \/**\n+     * Check that the exception handling is correct when the\n+     * wrapped stream throws while being closed\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void exceptionDuringClose() throws IOException {\n+\n+        WrappedOutputStream wrappedStream = new WrappedOutputStream();\n+\n+        \/\/ Keep a reference so we can double-close\n+        AtomicReference<ZipOutputStream> ref = new AtomicReference<>();\n+\n+        IOException exception = assertThrows(IOException.class, () -> {\n+            try (ZipOutputStream zo = new ZipOutputStream(wrappedStream)) {\n+                ref.set(zo);\n+                zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+                zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+                wrappedStream.failOnClose = true;\n+            }\n+        });\n+\n+        \/\/ Double-closing the ZipOutputStream should have no effect\n+        ref.get().close();\n+\n+        \/\/ Check that we failed with the expected message\n+        assertEquals(WrappedOutputStream.CLOSE_MSG, exception.getMessage());\n+\n+        \/\/ There should be no suppressed exceptions\n+        assertEquals(0, exception.getSuppressed().length);\n+\n+        \/\/ Verify that the wrapped stream was closed once\n+        assertEquals(1, wrappedStream.timesClosed,\n+                \"Expected wrapped output stream to be closed once\");\n+    }\n+\n+    \/**\n+     * Check that the exception handling is correct when the wrapped\n+     * stream throws while calling finish AND while being closed\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void exceptionDuringFinishAndClose() throws IOException {\n+\n+        WrappedOutputStream wrappedStream = new WrappedOutputStream();\n+\n+\n+        IOException exception = assertThrows(IOException.class, () -> {\n+            try (ZipOutputStream zo = new ZipOutputStream(wrappedStream)) {\n+\n+                zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+                zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+                \/\/ Will cause wrapped stream to throw during finish()\n+                wrappedStream.failOnWrite = true;\n+                \/\/ Will cause wrapped stream to throw during close()\n+                wrappedStream.failOnClose = true;\n+            }\n+        });\n+\n+        \/\/ We expect the top-level exception to be from the close operation\n+        assertEquals(WrappedOutputStream.CLOSE_MSG, exception.getMessage());\n+\n+        \/\/ The exception from the finish operation should be suppressed\n+        assertEquals(1, exception.getSuppressed().length, \"Expected suppressed exception\");\n+        assertEquals(WrappedOutputStream.WRITE_MSG, exception.getSuppressed()[0].getMessage());\n+\n+        \/\/ Verify that the wrapped stream was closed once\n+        assertEquals(1, wrappedStream.timesClosed,\n+                \"Expected wrapped output stream to be closed once\");\n+    }\n+\n+    \/**\n+     * Check that the exception handling is correct when the wrapped stream throws\n+     * the same IOException (identical instance) for write and close operations.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void sameExceptionDuringFinishAndClose() throws IOException {\n+\n+        WrappedOutputStream wrappedStream = new WrappedOutputStream();\n+\n+        IOException exception = assertThrows(IOException.class, () -> {\n+            try (ZipOutputStream zo = new ZipOutputStream(wrappedStream)) {\n+                zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+                zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+                \/\/ Make operations fail with the same exception instance\n+                wrappedStream.failException = new IOException(\"same fail\");\n+                wrappedStream.failOnWrite = true;\n+                wrappedStream.failOnClose = true;\n+            }\n+        });\n+        \/\/ We expect the top-level exception to be from the close operation\n+        assertSame(wrappedStream.failException, exception);\n+\n+        \/\/ The exception should not suppress itself\n+        assertEquals(0, exception.getSuppressed().length, \"Expected no suppressed exception\");\n+\n+        \/\/ Verify that the wrapped stream was closed once\n+        assertEquals(1, wrappedStream.timesClosed,\n+                \"Expected wrapped output stream to be closed once\");\n+    }\n+\n+    \/**\n+     * Output stream which conditionally throws IOException on writes\n+     * and tracks its close status.\n+     *\/\n+    static class WrappedOutputStream extends FilterOutputStream {\n+        static final String WRITE_MSG = \"fail during write\";\n+        static final String CLOSE_MSG = \"fail during close\";\n+        boolean failOnWrite = false;\n+        boolean failOnClose = false;\n+        IOException failException = null;\n+        int timesClosed = 0;\n+\n+        public WrappedOutputStream() {\n+            super(new ByteArrayOutputStream());\n+        }\n+\n+        @Override\n+        public synchronized void write(byte[] b, int off, int len) throws IOException{\n+            if (failOnWrite) {\n+                throw failException != null ? failException : new IOException(WRITE_MSG);\n+            } else {\n+                super.write(b, off, len);\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            timesClosed++;\n+            if (failOnClose) {\n+                throw failException != null ? failException : new IOException(CLOSE_MSG);\n+            } else {\n+                super.close();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipOutputStream\/CloseWrappedStream.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"}]}