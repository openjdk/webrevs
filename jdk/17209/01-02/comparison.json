{"files":[{"patch":"@@ -243,0 +243,1 @@\n+            closed = true;\n@@ -253,1 +254,1 @@\n-                try {\n+                if (finishException == null) {\n@@ -255,3 +256,8 @@\n-                } catch (IOException ioe) {\n-                    if (finishException != ioe) {\n-                        ioe.addSuppressed(finishException);\n+                } else {\n+                    try {\n+                        out.close();\n+                    } catch (IOException ioe) {\n+                        if (finishException != ioe) {\n+                            ioe.addSuppressed(finishException);\n+                        }\n+                        throw ioe;\n@@ -259,1 +265,0 @@\n-                    throw ioe;\n@@ -261,1 +266,0 @@\n-                closed = true;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/DeflaterOutputStream.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -43,1 +44,1 @@\n-     * also when the wrapped stream throws when remaining data is flushed\n+     * also when the wrapped stream throws while remaining data is flushed\n@@ -46,1 +47,1 @@\n-    public void closeWrappedStreamAfterFailure()  {\n+    public void exceptionDuringFinish()  {\n@@ -54,2 +55,2 @@\n-                \/\/ Make next write throw IOException\n-                wrappedStream.fail = true;\n+                \/\/ Make finish() throw IOException\n+                wrappedStream.failOnWrite = true;\n@@ -59,4 +60,6 @@\n-        \/\/ Sanity check that we failed with the expected message\n-        assertEquals(WrappedOutputStream.MSG, exception.getMessage());\n-        \/\/ Verify that the wrapped stream was closed\n-        assertTrue(wrappedStream.closed, \"Expected wrapped output stream to be closed\");\n+        \/\/ Check that we failed with the expected message\n+        assertEquals(WrappedOutputStream.WRITE_MSG, exception.getMessage());\n+\n+        \/\/ Verify that the wrapped stream was closed once\n+        assertEquals(1, wrappedStream.timesClosed,\n+                \"Expected wrapped output stream to be closed once\");\n@@ -66,2 +69,3 @@\n-     * Sanity check that the wrapped stream is closed also for the normal case\n-     * where the wrapped stream does not throw\n+     * Sanity check that the wrapped stream is closed also for the\n+     * normal case where the wrapped stream does not throw\n+     *\n@@ -71,1 +75,1 @@\n-    public void closeWrappedStreamNormal() throws IOException {\n+    public void noExceptions() throws IOException {\n@@ -80,2 +84,108 @@\n-        \/\/ Verify that the wrapped stream was closed\n-        assertTrue(wrappedStream.closed, \"Expected wrapped output stream to be closed\");\n+        \/\/ Verify that the wrapped stream was closed once\n+        assertEquals(1, wrappedStream.timesClosed,\n+                \"Expected wrapped output stream to be closed once\");\n+    }\n+\n+    \/**\n+     * Check that the exception handling is correct when the\n+     * wrapped stream throws while being closed\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void exceptionDuringClose() throws IOException {\n+\n+        WrappedOutputStream wrappedStream = new WrappedOutputStream();\n+\n+        \/\/ Keep a reference so we can double-close\n+        AtomicReference<ZipOutputStream> ref = new AtomicReference<>();\n+\n+        IOException exception = assertThrows(IOException.class, () -> {\n+            try (ZipOutputStream zo = new ZipOutputStream(wrappedStream)) {\n+                ref.set(zo);\n+                zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+                zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+                wrappedStream.failOnClose = true;\n+            }\n+        });\n+\n+        \/\/ Double-closing the ZipOutputStream should have no effect\n+        ref.get().close();\n+\n+        \/\/ Check that we failed with the expected message\n+        assertEquals(WrappedOutputStream.CLOSE_MSG, exception.getMessage());\n+\n+        \/\/ There should be no suppressed exceptions\n+        assertEquals(0, exception.getSuppressed().length);\n+\n+        \/\/ Verify that the wrapped stream was closed once\n+        assertEquals(1, wrappedStream.timesClosed,\n+                \"Expected wrapped output stream to be closed once\");\n+    }\n+\n+    \/**\n+     * Check that the exception handling is correct when the wrapped\n+     * stream throws while calling finish AND while being closed\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void exceptionDuringFinishAndClose() throws IOException {\n+\n+        WrappedOutputStream wrappedStream = new WrappedOutputStream();\n+\n+\n+        IOException exception = assertThrows(IOException.class, () -> {\n+            try (ZipOutputStream zo = new ZipOutputStream(wrappedStream)) {\n+\n+                zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+                zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+                \/\/ Will cause wrapped stream to throw during finish()\n+                wrappedStream.failOnWrite = true;\n+                \/\/ Will cause wrapped stream to throw during close()\n+                wrappedStream.failOnClose = true;\n+            }\n+        });\n+\n+        \/\/ We expect the top-level exception to be from the close operation\n+        assertEquals(WrappedOutputStream.CLOSE_MSG, exception.getMessage());\n+\n+        \/\/ The exception from the finish operation should be suppressed\n+        assertEquals(1, exception.getSuppressed().length, \"Expected suppressed exception\");\n+        assertEquals(WrappedOutputStream.WRITE_MSG, exception.getSuppressed()[0].getMessage());\n+\n+        \/\/ Verify that the wrapped stream was closed once\n+        assertEquals(1, wrappedStream.timesClosed,\n+                \"Expected wrapped output stream to be closed once\");\n+    }\n+\n+    \/**\n+     * Check that the exception handling is correct when the wrapped stream throws\n+     * the same IOException (identical instance) for write and close operations.\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @Test\n+    public void sameExceptionDuringFinishAndClose() throws IOException {\n+\n+        WrappedOutputStream wrappedStream = new WrappedOutputStream();\n+\n+        IOException exception = assertThrows(IOException.class, () -> {\n+            try (ZipOutputStream zo = new ZipOutputStream(wrappedStream)) {\n+                zo.putNextEntry(new ZipEntry(\"file.txt\"));\n+                zo.write(\"hello\".getBytes(StandardCharsets.UTF_8));\n+                \/\/ Make operations fail with the same exception instance\n+                wrappedStream.failException = new IOException(\"same fail\");\n+                wrappedStream.failOnWrite = true;\n+                wrappedStream.failOnClose = true;\n+            }\n+        });\n+        \/\/ We expect the top-level exception to be from the close operation\n+        assertSame(wrappedStream.failException, exception);\n+\n+        \/\/ The exception should not suppress itself\n+        assertEquals(0, exception.getSuppressed().length, \"Expected no suppressed exception\");\n+\n+        \/\/ Verify that the wrapped stream was closed once\n+        assertEquals(1, wrappedStream.timesClosed,\n+                \"Expected wrapped output stream to be closed once\");\n@@ -89,3 +199,6 @@\n-        static final String MSG = \"injected failure\";\n-        boolean fail = false;\n-        boolean closed = false;\n+        static final String WRITE_MSG = \"fail during write\";\n+        static final String CLOSE_MSG = \"fail during close\";\n+        boolean failOnWrite = false;\n+        boolean failOnClose = false;\n+        IOException failException = null;\n+        int timesClosed = 0;\n@@ -99,2 +212,2 @@\n-            if (fail) {\n-                throw new IOException(MSG);\n+            if (failOnWrite) {\n+                throw failException != null ? failException : new IOException(WRITE_MSG);\n@@ -108,2 +221,6 @@\n-            closed = true;\n-            super.close();\n+            timesClosed++;\n+            if (failOnClose) {\n+                throw failException != null ? failException : new IOException(CLOSE_MSG);\n+            } else {\n+                super.close();\n+            }\n","filename":"test\/jdk\/java\/util\/zip\/ZipOutputStream\/CloseWrappedStream.java","additions":137,"deletions":20,"binary":false,"changes":157,"status":"modified"}]}