{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,3 +71,0 @@\n-    if (!msg) {\n-        msg = \"no further information\";\n-    }\n@@ -76,2 +73,6 @@\n-        jio_snprintf(fullMsg, sizeof(fullMsg), \"socket closed: %s\", msg);\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", fullMsg);\n+        if (msg == NULL) {\n+            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"socket closed\");\n+        } else {\n+            jio_snprintf(fullMsg, sizeof(fullMsg), \"socket closed: %s\", msg);\n+            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", fullMsg);\n+        }\n","filename":"src\/java.base\/unix\/native\/libnet\/net_util_md.c","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,7 +142,0 @@\n-    \/*\n-     * Default message text if not provided\n-     *\/\n-    if (!msg) {\n-        msg = \"no further information\";\n-    }\n-\n@@ -166,2 +159,7 @@\n-        jio_snprintf(fullMsg, sizeof(fullMsg), \"%s: %s\",\n-                     (char *)winsock_errors[i].errString, msg);\n+        if (msg == NULL) {\n+            jio_snprintf(fullMsg, sizeof(fullMsg), \"%s\",\n+                         (char *)winsock_errors[i].errString);\n+        } else {\n+            jio_snprintf(fullMsg, sizeof(fullMsg), \"%s: %s\",\n+                         (char *)winsock_errors[i].errString, msg);\n+        }\n@@ -169,4 +167,8 @@\n-        jio_snprintf(fullMsg, sizeof(fullMsg),\n-                     \"Unrecognized Windows Sockets error: %d: %s\",\n-                     errorNum, msg);\n-\n+        if (msg == NULL) {\n+            jio_snprintf(fullMsg, sizeof(fullMsg),\n+                         \"Unrecognized Windows Sockets error: %d\", errorNum);\n+        } else {\n+            jio_snprintf(fullMsg, sizeof(fullMsg),\n+                         \"Unrecognized Windows Sockets error: %d: %s\",\n+                         errorNum, msg);\n+        }\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -736,1 +736,1 @@\n-            NET_ThrowNew(env, optError, \"getsockopt\");\n+            NET_ThrowNew(env, optError, NULL);\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/Net.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.ConnectException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.SocketChannel;\n+import java.time.Duration;\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static org.junit.jupiter.api.Assumptions.assumeFalse;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8376290\n+ * @summary Verify that when a SocketChannel is registered with a Selector\n+ *          with an interest in CONNECT operation, then SocketChannel.finishConnect()\n+ *          throws the correct exception message, if the connect() fails\n+ * @run junit ${test.main.class}\n+ *\/\n+class ConnectionRefusedMessage {\n+\n+    \/*\n+     * On a non-blocking SocketChannel, registered with a Selector, this test method\n+     * attempts a SocketChannel.connect() against an address that is expected to return\n+     * Connection refused. The test then calls SocketChannel.finishConnect() when the\n+     * Selector makes available the ready key for this connect operation and expects\n+     * that finishConnect() throws a ConnectException with the expected exception message.\n+     *\/\n+    @Test\n+    void testFinishConnect() throws Exception {\n+        \/\/ find a suitable address against which the connect() attempt\n+        \/\/ will result in a Connection refused exception\n+        final InetSocketAddress destAddr = findSuitableRefusedAddress();\n+        \/\/ skip the test if we couldn't find a port which would raise a connection refused error\n+        assumeTrue(destAddr != null,\n+                \"couldn't find a suitable port which will generate a connection refused error\");\n+        try (Selector selector = Selector.open();\n+             SocketChannel sc = SocketChannel.open()) {\n+\n+            \/\/ non-blocking\n+            sc.configureBlocking(false);\n+            sc.register(selector, SelectionKey.OP_CONNECT);\n+\n+            System.err.println(\"establishing connection to \" + destAddr);\n+            boolean connected = sc.connect(destAddr);\n+            \/\/ this test checks the exception message of a ConnectException, so it's\n+            \/\/ OK to skip the test if something unexpectedly accepted the connection\n+            assumeFalse(connected, \"unexpectedly connected to \" + destAddr);\n+            \/\/ wait for ready ops\n+            int numReady = selector.select(Duration.ofMinutes(10).toMillis());\n+            System.err.println(\"Num ready keys = \" + numReady);\n+            for (SelectionKey readyKey : selector.selectedKeys()) {\n+                System.err.println(\"ready key: \" + readyKey);\n+                assertTrue(readyKey.isConnectable(), \"unexpected key, readyOps = \"\n+                        + readyKey.readyOps());\n+                readyKey.cancel();\n+                try {\n+                    boolean success = sc.finishConnect();\n+                    if (success) {\n+                        \/\/ this test checks the exception message of a ConnectException, so it's\n+                        \/\/ OK to skip the test if something unexpectedly accepted the connection\n+                        assumeTrue(success, \"unexpectedly connected to \" + destAddr);\n+                    }\n+                    fail(\"ConnectException was not thrown\");\n+                } catch (ConnectException ce) {\n+                    System.err.println(\"got (expected) ConnectException - \" + ce);\n+                    \/\/ verify exception message\n+                    if (!\"Connection refused\".equals(ce.getMessage())) {\n+                        \/\/ propagate the original exception\n+                        fail(\"unexpected exception message: \" + ce.getMessage(), ce);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ Try to find a suitable port to provoke a \"Connection Refused\" error.\n+    private static InetSocketAddress findSuitableRefusedAddress() throws IOException {\n+        final InetAddress loopbackAddr = InetAddress.getLoopbackAddress();\n+        \/\/ port 47 is reserved - there should be nothing listening on it\n+        InetSocketAddress destAddr = new InetSocketAddress(loopbackAddr, 47);\n+        try (SocketChannel sc1 = SocketChannel.open(destAddr)) {\n+            \/\/ If we manage to connect, let's try to use some other\n+            \/\/ port.\n+            \/\/ port 51 is reserved too - there should be nothing there.\n+            destAddr = new InetSocketAddress(loopbackAddr, 51);\n+            try (SocketChannel sc2 = SocketChannel.open(destAddr)) {\n+            }\n+            \/\/ OK, last attempt...\n+            \/\/ port 61 is reserved too - there should be nothing there.\n+            destAddr = new InetSocketAddress(loopbackAddr, 61);\n+            try (SocketChannel sc3 = SocketChannel.open(destAddr)) {\n+            }\n+            return null;\n+        } catch (ConnectException x) {\n+        }\n+        \/\/ the address which will generate a connection refused, when a connection is attempted\n+        return destAddr;\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/ConnectionRefusedMessage.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"}]}