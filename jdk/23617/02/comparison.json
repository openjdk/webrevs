{"files":[{"patch":"@@ -1302,0 +1302,16 @@\n+\/\/ When a counted loop is created, the loop phi type may be narrowed down. As a consequence, the control input of some\n+\/\/ nodes may be cleared: in particular in the case of a division by the loop iv, the Div node would lose its control\n+\/\/ dependency if the loop phi is never zero. After pre\/main\/post loops are created (and possibly unrolling), the\n+\/\/ loop phi type is only correct if the loop is indeed reachable: there's an implicit dependency between the loop phi\n+\/\/ type and the zero trip guard for the main or post loop and as a consequence a dependency between the Div node and the\n+\/\/ zero trip guard. This makes the dependency explicit by adding a CastII for the loop entry input of the loop phi. If\n+\/\/ the backedge of the main or post loop is removed, a Div node won't be able to float above the zero trip guard of the\n+\/\/ loop and can't execute even if the loop is not reached.\n+void PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, CountedLoopNode* loop) {\n+  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n+  register_new_node(castii, ctrl);\n+  Node* phi = loop->phi();\n+  assert(phi->in(LoopNode::EntryControl) == incr, \"replacing wrong input?\");\n+  _igvn.replace_input_of(phi, LoopNode::EntryControl, castii);\n+}\n+\n@@ -1458,0 +1474,2 @@\n+  \/\/ CastII for the main loop:\n+  cast_incr_before_loop(pre_incr, min_taken, main_head);\n@@ -1598,1 +1616,1 @@\n-                                       Node*& incr, Node* limit, CountedLoopNode*& post_head) {\n+                                       Node* incr, Node* limit, CountedLoopNode*& post_head) {\n@@ -1689,0 +1707,2 @@\n+  \/\/ CastII for the new post loop:\n+  cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n@@ -1781,1 +1801,1 @@\n-    LoopNode* target_loop_head, const Node* old_target_loop_entry,\n+    CountedLoopNode* target_loop_head, const Node* old_target_loop_entry,\n@@ -1792,0 +1812,1 @@\n+      assert(out != target_loop_head->init_trip(), \"CastII on loop entry?\");\n@@ -2681,1 +2702,2 @@\n-          Node* init = cl->init_trip();\n+          Node* init = cl->uncasted_init_trip(true);\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -6059,0 +6059,18 @@\n+Node* CountedLoopNode::uncasted_init_trip(bool uncast) {\n+  Node* init = init_trip();\n+  if (uncast && init->is_CastII()) {\n+    \/\/ skip over the cast added by PhaseIdealLoop::cast_incr_before_loop() when pre\/post\/main loops are created because\n+    \/\/ it can get in the way of type propagation. For instance, the index tested by an assert predicate, if the cast is\n+    \/\/ not skipped over, could be (1):\n+    \/\/ (AddI (CastII (AddI pre_loop_iv -2) int) 1)\n+    \/\/ while without the cast, it is (2):\n+    \/\/ (AddI (AddI pre_loop_iv -2) 1)\n+    \/\/ which is be transformed to (3):\n+    \/\/ (AddI pre_loop_iv -1)\n+    \/\/ The compiler may be able to constant fold the assert predicate condition for (3) but not (1)\n+    assert(init->as_CastII()->carry_dependency() && skip_assertion_predicates_with_halt() == init->in(0), \"casted iv phi from pre loop expected\");\n+    init = init->in(1);\n+  }\n+  return init;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -368,0 +368,2 @@\n+  Node* uncasted_init_trip(bool uncasted);\n+\n@@ -976,0 +978,2 @@\n+  void cast_incr_before_loop(Node* incr, Node* ctrl, CountedLoopNode* loop);\n+\n@@ -1000,1 +1004,1 @@\n-  void rewire_old_target_loop_entry_dependency_to_new_entry(LoopNode* target_loop_head,\n+  void rewire_old_target_loop_entry_dependency_to_new_entry(CountedLoopNode* target_loop_head,\n@@ -1354,1 +1358,1 @@\n-                         Node*& incr, Node* limit, CountedLoopNode*& post_head);\n+                         Node* incr, Node* limit, CountedLoopNode*& post_head);\n@@ -1582,2 +1586,0 @@\n-  bool split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk);\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1092,19 +1092,0 @@\n-\/\/ Split some nodes that take a counted loop phi as input at a counted\n-\/\/ loop can cause vectorization of some expressions to fail\n-bool PhaseIdealLoop::split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk) {\n-  if (!n_blk->is_CountedLoop()) {\n-    return false;\n-  }\n-\n-  int opcode = n->Opcode();\n-\n-  if (opcode != Op_AndI &&\n-      opcode != Op_MulI &&\n-      opcode != Op_RotateRight &&\n-      opcode != Op_RShiftI) {\n-    return false;\n-  }\n-\n-  return n->in(1) == n_blk->as_BaseCountedLoop()->phi();\n-}\n-\n@@ -1197,4 +1178,0 @@\n-  if (split_thru_phi_could_prevent_vectorization(n, n_blk)) {\n-    return n;\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -760,1 +760,1 @@\n-  OpaqueLoopInitNode* opaque_init = new OpaqueLoopInitNode(_phase->C, _loop_head->init_trip());\n+  OpaqueLoopInitNode* opaque_init = new OpaqueLoopInitNode(_phase->C, _loop_head->uncasted_init_trip(_loop_head->is_main_loop()));\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349139\n+ * @summary C2: Div looses dependency on condition that guarantees divisor not null in counted loop\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestDivDependentOnMainLoopGuard::*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:StressSeed=139899009 TestDivDependentOnMainLoopGuard\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestDivDependentOnMainLoopGuard::*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestDivDependentOnMainLoopGuard\n+ *\/\n+\n+public class TestDivDependentOnMainLoopGuard {\n+\n+    public static final int N = 400;\n+\n+    public int iArrFld[]=new int[N];\n+\n+    public void mainTest(String[] strArr1, int otherPhi) {\n+\n+        int i=57657, i1=577, i2=6, i3=157, i4=12, i23=61271;\n+        boolean bArr[]=new boolean[N];\n+\n+        for (i = 9; 379 > i; i++) {\n+            i2 = 1;\n+            do {\n+                i1 <<= i3;\n+            } while (++i2 < 68);\n+            for (i23 = 68; i23 > 2; otherPhi=i23-1, i23--) {\n+                bArr[i23 + 1] = true;\n+                try {\n+                    i1 = (-42360 \/ i23);\n+                    iArrFld[i + 1] = otherPhi;\n+                } catch (ArithmeticException a_e) {}\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestDivDependentOnMainLoopGuard _instance = new TestDivDependentOnMainLoopGuard();\n+        for (int i = 0; i < 10; i++ ) {\n+            _instance.mainTest(strArr, 0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/controldependency\/TestDivDependentOnMainLoopGuard.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349139\n+ * @summary C2: Div looses dependency on condition that guarantees divisor not null in counted loop\n+ * @run main\/othervm -XX:-BackgroundCompilation TestMainLoopNoBackedgeFloatingDiv\n+ *\/\n+\n+public class TestMainLoopNoBackedgeFloatingDiv {\n+    private static int field;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+           test1(1000, 0, false);\n+           test1Helper(1000, 0, false, false);\n+        }\n+       test1(1, 0, false);\n+    }\n+\n+    private static int test1(int stop, int res, boolean alwaysTrueInMain) {\n+        stop = Integer.max(stop, 1);\n+        res = test1Helper(stop, res, alwaysTrueInMain, true);\n+        return res;\n+    }\n+\n+    private static int test1Helper(int stop, int res, boolean alwaysTrueInMain, boolean flag) {\n+        for (int i = stop; i >= 1; i--) {\n+            res = res \/ i;\n+            if (alwaysTrueInMain) {\n+                break;\n+            }\n+            alwaysTrueInMain = flag;\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/controldependency\/TestMainLoopNoBackedgeFloatingDiv.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"}]}