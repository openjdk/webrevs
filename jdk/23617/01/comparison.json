{"files":[{"patch":"@@ -1297,0 +1297,16 @@\n+\/\/ When a counted loop is created, the loop phi type may be narrowed down. As a consequence, the control input of some\n+\/\/ nodes may be cleared: in particular in the case of a division by the loop iv, the Div node would lose its control\n+\/\/ dependency if the loop phi is never zero. After pre\/main\/post loops are created (and possibly unrolling), the\n+\/\/ loop phi type is only correct if the loop is indeed reachable: there's an implicit dependency between the loop phi\n+\/\/ type and the zero trip guard for the main or post loop and as a consequence a dependency between the Div node and the\n+\/\/ zero trip guard. This makes the dependency explicit by adding a CastII for the loop entry input of the loop phi. If\n+\/\/ the backedge of the main or post loop is removed, a Div node won't be able to float above the zero trip guard of the\n+\/\/ loop and can't execute even if the loop is not reached.\n+void PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, CountedLoopNode* loop) {\n+  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n+  register_new_node(castii, ctrl);\n+  Node* phi = loop->phi();\n+  assert(phi->in(LoopNode::EntryControl) == incr, \"replacing wrong input?\");\n+  _igvn.replace_input_of(phi, LoopNode::EntryControl, castii);\n+}\n+\n@@ -1453,0 +1469,2 @@\n+  \/\/ CastII for the main loop:\n+  cast_incr_before_loop(pre_incr, min_taken, main_head);\n@@ -1593,1 +1611,1 @@\n-                                       Node*& incr, Node* limit, CountedLoopNode*& post_head) {\n+                                       Node* incr, Node* limit, CountedLoopNode*& post_head) {\n@@ -1684,0 +1702,2 @@\n+  \/\/ CastII for the new post loop:\n+  cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n@@ -1698,2 +1718,0 @@\n-  Node* init = main_loop_head->init_trip();\n-\n@@ -1777,1 +1795,1 @@\n-    LoopNode* target_loop_head, const Node* old_target_loop_entry,\n+    CountedLoopNode* target_loop_head, const Node* old_target_loop_entry,\n@@ -1788,0 +1806,1 @@\n+      assert(out != target_loop_head->init_trip(), \"CastII on loop entry?\");\n@@ -2683,1 +2702,2 @@\n-          Node* init = cl->init_trip();\n+          Node* init = cl->uncasted_init_trip(true);\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -6087,0 +6087,11 @@\n+Node* CountedLoopNode::uncasted_init_trip(bool uncast) {\n+  Node* init = init_trip();\n+  if (uncast && init->is_CastII()) {\n+    \/\/ skip over the cast added by PhaseIdealLoop::cast_incr_before_loop() when pre\/post\/main loops are created because\n+    \/\/ it can get in the way of type propagation\n+    assert(init->as_CastII()->carry_dependency() && skip_assertion_predicates_with_halt() == init->in(0), \"casted iv phi from pre loop expected\");\n+    init = init->in(1);\n+  }\n+  return init;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -334,0 +334,2 @@\n+  Node* uncasted_init_trip(bool uncasted);\n+\n@@ -941,0 +943,2 @@\n+  void cast_incr_before_loop(Node* incr, Node* ctrl, CountedLoopNode* loop);\n+\n@@ -965,1 +969,1 @@\n-  void rewire_old_target_loop_entry_dependency_to_new_entry(LoopNode* target_loop_head,\n+  void rewire_old_target_loop_entry_dependency_to_new_entry(CountedLoopNode* target_loop_head,\n@@ -1319,1 +1323,1 @@\n-                         Node*& incr, Node* limit, CountedLoopNode*& post_head);\n+                         Node* incr, Node* limit, CountedLoopNode*& post_head);\n@@ -1550,2 +1554,0 @@\n-  bool split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk);\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1090,19 +1090,0 @@\n-\/\/ Split some nodes that take a counted loop phi as input at a counted\n-\/\/ loop can cause vectorization of some expressions to fail\n-bool PhaseIdealLoop::split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk) {\n-  if (!n_blk->is_CountedLoop()) {\n-    return false;\n-  }\n-\n-  int opcode = n->Opcode();\n-\n-  if (opcode != Op_AndI &&\n-      opcode != Op_MulI &&\n-      opcode != Op_RotateRight &&\n-      opcode != Op_RShiftI) {\n-    return false;\n-  }\n-\n-  return n->in(1) == n_blk->as_BaseCountedLoop()->phi();\n-}\n-\n@@ -1195,4 +1176,0 @@\n-  if (split_thru_phi_could_prevent_vectorization(n, n_blk)) {\n-    return n;\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -719,1 +719,1 @@\n-  OpaqueLoopInitNode* opaque_init = new OpaqueLoopInitNode(_phase->C, _loop_head->init_trip());\n+  OpaqueLoopInitNode* opaque_init = new OpaqueLoopInitNode(_phase->C, _loop_head->uncasted_init_trip(_loop_head->is_main_loop()));\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8349139\n+ * @summary C2: Div looses dependency on condition that guarantees divisor not null in counted loop\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestDivDependentOnMainLoopGuard::*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM -XX:StressSeed=139899009 TestDivDependentOnMainLoopGuard\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestDivDependentOnMainLoopGuard::*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestDivDependentOnMainLoopGuard\n+ *\/\n+\n+public class TestDivDependentOnMainLoopGuard {\n+\n+    public static final int N = 400;\n+\n+    public int iArrFld[]=new int[N];\n+\n+    public void mainTest(String[] strArr1, int otherPhi) {\n+\n+        int i=57657, i1=577, i2=6, i3=157, i4=12, i23=61271;\n+        boolean bArr[]=new boolean[N];\n+\n+        for (i = 9; 379 > i; i++) {\n+            i2 = 1;\n+            do {\n+                i1 <<= i3;\n+            } while (++i2 < 68);\n+            for (i23 = 68; i23 > 2; otherPhi=i23-1, i23--) {\n+                bArr[i23 + 1] = true;\n+                try {\n+                    i1 = (-42360 \/ i23);\n+                    iArrFld[i + 1] = otherPhi;\n+                } catch (ArithmeticException a_e) {}\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestDivDependentOnMainLoopGuard _instance = new TestDivDependentOnMainLoopGuard();\n+        for (int i = 0; i < 10; i++ ) {\n+            _instance.mainTest(strArr, 0);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/controldependency\/TestDivDependentOnMainLoopGuard.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}