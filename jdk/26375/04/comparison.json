{"files":[{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-    table->set_boot(write_classes(nullptr, true));\n+    table->set_boot1(write_classes(nullptr, true));\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/dynamicArchive.hpp\"\n@@ -32,0 +33,2 @@\n+#include \"classfile\/classLoaderDataShared.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n@@ -53,1 +56,1 @@\n-bool AOTLinkedClassBulkLoader::class_preloading_finished() {\n+bool AOTLinkedClassBulkLoader::has_finished_loading_classes() {\n@@ -64,0 +67,127 @@\n+\/\/ This function is called before the VM executes any Java code (include AOT-compiled Java methods).\n+\/\/\n+\/\/ We populate the boot\/platform\/app class loaders with classes from the AOT cache. This is a fundamental\n+\/\/ step in restoring the JVM's state from the snapshot recorded in the AOT cache: other AOT optimizations\n+\/\/ such as AOT compiled methods can make direct references to the preloaded classes, knowing that\n+\/\/ these classes are guaranteed to be in at least the loaded state.\n+\/\/\n+\/\/ Preloading requires that the Java heap objects of java.lang.Class, java.lang.Package and\n+\/\/ java.security.ProtectionDomain already exist for the preloaded classes. Therefore, we support preloading\n+\/\/ only for the classes in the static CDS archive. Classes in the dynamic archive are not supported because\n+\/\/ the dynamic archive does not include Java heap objects.\n+void AOTLinkedClassBulkLoader::preload_classes(JavaThread* current) {\n+  preload_classes_impl(current);\n+  if (current->has_pending_exception()) {\n+    exit_on_exception(current);\n+  }\n+}\n+\n+void AOTLinkedClassBulkLoader::preload_classes_impl(TRAPS) {\n+  precond(CDSConfig::is_using_preloaded_classes());\n+  log_info(aot, load)(\"Start preloading classes\");\n+\n+  ClassLoaderDataShared::restore_archived_modules_for_preloading_classes(THREAD);\n+  Handle h_platform_loader(THREAD, SystemDictionary::java_platform_loader());\n+  Handle h_system_loader(THREAD, SystemDictionary::java_system_loader());\n+\n+  \/\/ Preloading is supported only for the static archive. Classes in the dynamic archive are loaded\n+  \/\/ later in load_javabase_classes() and load_non_javabase_classes().\n+  preload_classes_in_table(AOTLinkedClassTable::for_static_archive()->boot1(), \"boot1\", Handle(), CHECK);\n+  preload_classes_in_table(AOTLinkedClassTable::for_static_archive()->boot2(), \"boot2\", Handle(), CHECK);\n+  preload_classes_in_table(AOTLinkedClassTable::for_static_archive()->platform(), \"plat\", h_platform_loader, CHECK);\n+  preload_classes_in_table(AOTLinkedClassTable::for_static_archive()->app(), \"app\", h_system_loader, CHECK);\n+\n+  log_info(aot, load)(\"Finished preloading classes\");\n+}\n+\n+void AOTLinkedClassBulkLoader::preload_classes_in_table(Array<InstanceKlass*>* classes,\n+                                                        const char* category_name, Handle loader, TRAPS) {\n+  if (classes == nullptr) {\n+    return;\n+  }\n+\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(loader());\n+  for (int i = 0; i < classes->length(); i++) {\n+    InstanceKlass* ik = classes->at(i);\n+    if (log_is_enabled(Info, aot, load)) {\n+      ResourceMark rm(THREAD);\n+      log_info(aot, load)(\"Preload %-5s %s%s\", category_name, ik->external_name(),\n+                          ik->is_hidden() ? \" (hidden)\" : \"\");\n+    }\n+\n+    SystemDictionary::preload_class(loader, ik, CHECK);\n+\n+    if (ik->is_hidden()) {\n+      DEBUG_ONLY({\n+        \/\/ Make sure we don't make this hidden class available by name, even if we don't\n+        \/\/ use any special ClassLoaderData.\n+        ResourceMark rm(THREAD);\n+        assert(SystemDictionary::find_instance_klass(THREAD, ik->name(), loader) == nullptr,\n+               \"hidden classes cannot be accessible by name: %s\", ik->external_name());\n+      });\n+    } else {\n+      precond(SystemDictionary::find_instance_klass(THREAD, ik->name(), loader) == ik);\n+    }\n+  }\n+}\n+\n+#ifdef ASSERT\n+void AOTLinkedClassBulkLoader::validate_module_of_preloaded_classes() {\n+  oop javabase_module_oop = ModuleEntryTable::javabase_moduleEntry()->module_oop();\n+  for (int i = T_BOOLEAN; i < T_LONG+1; i++) {\n+    TypeArrayKlass* tak = Universe::typeArrayKlass((BasicType)i);\n+    validate_module(tak, \"boot1\", javabase_module_oop);\n+  }\n+\n+  JavaThread* current = JavaThread::current();\n+  Handle h_platform_loader(current, SystemDictionary::java_platform_loader());\n+  Handle h_system_loader(current, SystemDictionary::java_system_loader());\n+\n+  validate_module_of_preloaded_classes_in_table(AOTLinkedClassTable::for_static_archive()->boot1(), \"boot1\", Handle());\n+  validate_module_of_preloaded_classes_in_table(AOTLinkedClassTable::for_static_archive()->boot2(), \"boot2\", Handle());\n+  validate_module_of_preloaded_classes_in_table(AOTLinkedClassTable::for_static_archive()->platform(), \"plat\", h_platform_loader);\n+  validate_module_of_preloaded_classes_in_table(AOTLinkedClassTable::for_static_archive()->app(), \"app\", h_system_loader);\n+}\n+\n+void AOTLinkedClassBulkLoader::validate_module_of_preloaded_classes_in_table(Array<InstanceKlass*>* classes,\n+                                                                            const char* category_name, Handle loader) {\n+  if (classes == nullptr) {\n+    return;\n+  }\n+\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(loader());\n+  for (int i = 0; i < classes->length(); i++) {\n+    InstanceKlass* ik = classes->at(i);\n+    PackageEntry* pkg_entry = ik->package();\n+    oop module_oop;\n+    if (pkg_entry == nullptr) {\n+      module_oop = loader_data->unnamed_module()->module_oop();\n+    } else {\n+      module_oop = pkg_entry->module()->module_oop();\n+    }\n+\n+    validate_module(ik, category_name, module_oop);\n+  }\n+}\n+\n+void AOTLinkedClassBulkLoader::validate_module(Klass* k, const char* category_name, oop module_oop) {\n+  assert(module_oop != nullptr, \"module system must have been initialized\");\n+\n+  if (log_is_enabled(Debug, aot, module)) {\n+    ResourceMark rm;\n+    log_debug(aot, module)(\"Validate module of %-5s %s\", category_name, k->external_name());\n+  }\n+  precond(java_lang_Class::module(k->java_mirror()) == module_oop);\n+\n+  ArrayKlass* ak = k->array_klass_or_null();\n+  while (ak != nullptr) {\n+    if (log_is_enabled(Debug, aot, module)) {\n+      ResourceMark rm;\n+      log_debug(aot, module)(\"Validate module of %-5s %s\", category_name, ak->external_name());\n+    }\n+    precond(java_lang_Class::module(ak->java_mirror()) == module_oop);\n+    ak = ak->array_klass_or_null();\n+  }\n+}\n+#endif\n+\n@@ -72,0 +202,2 @@\n+  DEBUG_ONLY(validate_module_of_preloaded_classes());\n+\n@@ -87,0 +219,7 @@\n+  if (CDSConfig::is_using_preloaded_classes()) {\n+    DynamicArchive::setup_and_restore_array_klasses(current);\n+    if (current->has_pending_exception()) {\n+      exit_on_exception(current);\n+    }\n+  }\n+\n@@ -162,1 +301,1 @@\n-    load_classes_impl(class_category, table->boot(), category_name, loader, CHECK);\n+    load_classes_impl(table->boot1(), category_name, loader, CHECK);\n@@ -166,1 +305,1 @@\n-    load_classes_impl(class_category, table->boot2(), category_name, loader, CHECK);\n+    load_classes_impl(table->boot2(), category_name, loader, CHECK);\n@@ -171,1 +310,1 @@\n-      initiate_loading(THREAD, category_name, loader, table->boot());\n+      initiate_loading(THREAD, category_name, loader, table->boot1());\n@@ -173,1 +312,1 @@\n-      load_classes_impl(class_category, table->platform(), category_name, loader, CHECK);\n+      load_classes_impl(table->platform(), category_name, loader, CHECK);\n@@ -178,1 +317,1 @@\n-      initiate_loading(THREAD, category_name, loader, table->boot());\n+      initiate_loading(THREAD, category_name, loader, table->boot1());\n@@ -181,1 +320,1 @@\n-      load_classes_impl(class_category, table->app(), category_name, loader, CHECK);\n+      load_classes_impl(table->app(), category_name, loader, CHECK);\n@@ -191,1 +330,1 @@\n-void AOTLinkedClassBulkLoader::load_classes_impl(AOTLinkedClassCategory class_category, Array<InstanceKlass*>* classes,\n+void AOTLinkedClassBulkLoader::load_classes_impl(Array<InstanceKlass*>* classes,\n@@ -336,1 +475,1 @@\n-  init_required_classes_for_loader(Handle(), AOTLinkedClassTable::for_static_archive()->boot(), CHECK);\n+  init_required_classes_for_loader(Handle(), AOTLinkedClassTable::for_static_archive()->boot1(), CHECK);\n@@ -432,1 +571,1 @@\n-    replay_training_at_init(table->boot(),     CHECK);\n+    replay_training_at_init(table->boot1(),    CHECK);\n@@ -437,1 +576,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":150,"deletions":11,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -45,0 +45,9 @@\n+\/\/ The classes are loaded in two steps:\n+\/\/\n+\/\/ [1] preload_classes():\n+\/\/     This happens before any Java bytecode is executed, to load aot-linked classes in the static archive,\n+\/\/     placing them into the \"loaded\" state.\n+\/\/\n+\/\/ [2] load_javabase_classes() and load_non_javabase_classes():\n+\/\/     This happens after some Java code is executed, to load aot-linked classes in the dynamic archive.\n+\/\/     This steps also puts all aot-linked classes into at least the \"linked\" state.\n@@ -50,0 +59,5 @@\n+  static bool _preloading_non_javavase_classes;\n+\n+  static void preload_classes_impl(TRAPS);\n+  static void preload_classes_in_table(Array<InstanceKlass*>* classes,\n+                                       const char* category_name, Handle loader, TRAPS);\n@@ -54,1 +68,1 @@\n-  static void load_classes_impl(AOTLinkedClassCategory class_category, Array<InstanceKlass*>* classes,\n+  static void load_classes_impl(Array<InstanceKlass*>* classes,\n@@ -59,0 +73,8 @@\n+\n+#ifdef ASSERT\n+  static void validate_module_of_preloaded_classes();\n+  static void validate_module_of_preloaded_classes_in_table(Array<InstanceKlass*>* classes,\n+                                                            const char* category_name, Handle loader);\n+  static void validate_module(Klass* k, const char* category_name, oop module_oop);\n+#endif\n+\n@@ -61,1 +83,1 @@\n-\n+  static void preload_classes(JavaThread* current);\n@@ -68,1 +90,1 @@\n-  static bool class_preloading_finished();\n+  static bool has_finished_loading_classes() NOT_CDS_RETURN_(true);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.hpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  soc->do_ptr((void**)&_boot);\n+  soc->do_ptr((void**)&_boot1);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,2 +47,2 @@\n-  Array<InstanceKlass*>* _boot;  \/\/ only java.base classes\n-  Array<InstanceKlass*>* _boot2; \/\/ boot classes in other modules\n+  Array<InstanceKlass*>* _boot1; \/\/ boot classes in java.base module\n+  Array<InstanceKlass*>* _boot2; \/\/ boot classes in all other (named and unnamed) modules\n@@ -54,1 +54,1 @@\n-    _boot(nullptr), _boot2(nullptr),\n+    _boot1(nullptr), _boot2(nullptr),\n@@ -64,1 +64,1 @@\n-  Array<InstanceKlass*>* boot()     const { return _boot;     }\n+  Array<InstanceKlass*>* boot1()    const { return _boot1;    }\n@@ -69,1 +69,1 @@\n-  void set_boot    (Array<InstanceKlass*>* value) { _boot     = value; }\n+  void set_boot1   (Array<InstanceKlass*>* value) { _boot1    = value; }\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassTable.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#include \"cds\/aotOopChecker.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+oop AOTOopChecker::get_oop_field(oop obj, const char* name, const char* sig) {\n+  Symbol* name_sym = SymbolTable::probe(name, checked_cast<int>(strlen(name)));\n+  assert(name_sym != nullptr, \"Symbol must have been resolved for an existing field of this obj\");\n+  Symbol* sig_sym = SymbolTable::probe(sig, checked_cast<int>(strlen(sig)));\n+  assert(sig_sym != nullptr, \"Symbol must have been resolved for an existing field of this obj\");\n+\n+  fieldDescriptor fd;\n+  Klass* k = InstanceKlass::cast(obj->klass())->find_field(name_sym, sig_sym, &fd);\n+  assert(k != nullptr, \"field must exist\");\n+  precond(!fd.is_static());\n+  precond(fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY);\n+  return obj->obj_field(fd.offset());\n+}\n+\n+\/\/ Make sure we are not caching objects with assumptions that can be violated in\n+\/\/ the production run.\n+void AOTOopChecker::check(oop obj) {\n+  precond(vmClasses::URL_klass()->is_final());\n+\n+  if (obj->klass()->is_subclass_of(vmClasses::URL_klass())) {\n+    \/\/ URLs are referenced by the CodeSources\/ProtectDomains that are cached\n+    \/\/ for AOT-linked classes loaded by the platform\/app loaders.\n+    \/\/\n+    \/\/ Do not cache any URLs whose URLStreamHandler can be overridden by the application.\n+    \/\/ - \"jrt\" and \"file\" will always use the built-in URLStreamHandler. See\n+    \/\/   java.net.URL::isOverrideable().\n+    \/\/ -  When an AOT-linked class is loaded from a JAR file, its URL is something\n+    \/\/    like file:HelloWorl.jar, and does NOT use the \"jar\" protocol.\n+    oop protocol = get_oop_field(obj, \"protocol\", \"Ljava\/lang\/String;\");\n+    if (!java_lang_String::equals(protocol, \"jrt\", 3) &&\n+        !java_lang_String::equals(protocol, \"file\", 4)) {\n+      ResourceMark rm;\n+      log_error(aot)(\"Must cache only URLs with jrt\/file protocols but got: %s\",\n+                     java_lang_String::as_quoted_ascii(protocol));\n+      HeapShared::debug_trace();\n+      MetaspaceShared::unrecoverable_writing_error();\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/aotOopChecker.cpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTOOPCHECKER_HPP\n+#define SHARE_CDS_AOTOOPCHECKER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class AOTOopChecker : AllStatic {\n+  static oop get_oop_field(oop obj, const char* name, const char* sig);\n+\n+public:\n+  \/\/ obj is an object that's about to be stored into the AOT cache. Check if it\n+  \/\/ can be safely cached.\n+  static void check(oop obj);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTOOPCHECKER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotOopChecker.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -53,0 +53,1 @@\n+bool CDSConfig::_has_preloaded_classes = false;\n@@ -68,1 +69,2 @@\n-  return (is_dumping_archive()              ? IS_DUMPING_ARCHIVE : 0) |\n+  return (is_dumping_aot_linked_classes()   ? IS_DUMPING_AOT_LINKED_CLASSES : 0) |\n+         (is_dumping_archive()              ? IS_DUMPING_ARCHIVE : 0) |\n@@ -992,0 +994,10 @@\n+\/\/ Preload classes = load classes from the AOT cache into the boot\/platform\/app loaders before\n+\/\/ executing any Java code.\n+bool CDSConfig::is_using_preloaded_classes() {\n+  return is_using_full_module_graph() && _has_preloaded_classes;\n+}\n+\n+void CDSConfig::set_has_preloaded_classes(bool has_preloaded_classes) {\n+  _has_preloaded_classes |= has_preloaded_classes;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  static bool _has_preloaded_classes;\n@@ -81,5 +82,6 @@\n-  static const int IS_DUMPING_ARCHIVE              = 1 << 0;\n-  static const int IS_DUMPING_METHOD_HANDLES       = 1 << 1;\n-  static const int IS_DUMPING_STATIC_ARCHIVE       = 1 << 2;\n-  static const int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 3;\n-  static const int IS_USING_ARCHIVE                = 1 << 4;\n+  static const int IS_DUMPING_AOT_LINKED_CLASSES   = 1 << 0;\n+  static const int IS_DUMPING_ARCHIVE              = 1 << 1;\n+  static const int IS_DUMPING_METHOD_HANDLES       = 1 << 2;\n+  static const int IS_DUMPING_STATIC_ARCHIVE       = 1 << 3;\n+  static const int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 4;\n+  static const int IS_USING_ARCHIVE                = 1 << 5;\n@@ -164,0 +166,3 @@\n+  static bool is_using_preloaded_classes()                   NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static void set_has_preloaded_classes(bool has_preloaded_classes) NOT_CDS_JAVA_HEAP_RETURN;\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -43,1 +43,3 @@\n-\/\/ -- Handling of Enum objects\n+\/\/ !!! This is legacy support for enum classes before JEP 483. This code is not needed when\n+\/\/ !!! CDSConfig::is_initing_classes_at_dump_time()==true.\n+\/\/\n@@ -65,0 +67,1 @@\n+  assert(!CDSConfig::is_initing_classes_at_dump_time(), \"only for legacy support of enums\");\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+\/\/ This is legacy support for enum classes before JEP 483. This code is not needed when\n+\/\/ CDSConfig::is_initing_classes_at_dump_time()==true.\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  ADD_EXCL(\"java\/lang\/ClassLoader\",                      \"scl\");                   \/\/ A\n+  ADD_EXCL(\"java\/lang\/ClassLoader$Holder\",               \"scl\");                   \/\/ A\n@@ -149,0 +149,4 @@\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    ADD_EXCL(\"java\/lang\/Package$VersionInfo\",             \"NULL_VERSION_INFO\");    \/\/ D\n+  }\n+\n@@ -230,4 +234,10 @@\n-        if (field_ik == vmClasses::internal_Unsafe_klass() && ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n-          \/\/ There's only a single instance of jdk\/internal\/misc\/Unsafe, so all references will\n-          \/\/ be pointing to this singleton, which has been archived.\n-          return;\n+        if (ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+          if (field_ik == vmClasses::internal_Unsafe_klass()) {\n+            \/\/ There's only a single instance of jdk\/internal\/misc\/Unsafe, so all references will\n+            \/\/ be pointing to this singleton, which has been archived.\n+            return;\n+          }\n+          if (field_ik == vmClasses::Boolean_klass()) {\n+            \/\/ TODO: check if is TRUE or FALSE\n+            return;\n+          }\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -435,2 +435,0 @@\n-      assert(!oak->is_typeArray_klass(), \"all type array classes must be in static archive\");\n-\n@@ -453,0 +451,15 @@\n+void DynamicArchive::setup_and_restore_array_klasses(TRAPS) {\n+  precond(CDSConfig::is_using_preloaded_classes());\n+\n+  if (_dynamic_archive_array_klasses != nullptr) {\n+    setup_array_klasses();\n+    for (int i = 0; i < _dynamic_archive_array_klasses->length(); i++) {\n+      ObjArrayKlass* oak = _dynamic_archive_array_klasses->at(i);\n+      Klass* elm = oak->element_klass();\n+      assert(MetaspaceShared::is_shared_static((void*)elm), \"must be\");\n+      RecursiveLocker rl(MultiArray_lock, THREAD);\n+      oak->restore_unshareable_info(elm->class_loader_data(), Handle(), CHECK);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+  static void setup_and_restore_array_klasses(TRAPS);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1861,0 +1861,5 @@\n+    if (is_static()) {\n+      \/\/ The aot-linked classes in the dynamic archive don't have archived mirror\/package\/protection domain, so they\n+      \/\/ cannot be preloaded.\n+      CDSConfig::set_has_preloaded_classes(true);\n+    }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/aotOopChecker.hpp\"\n@@ -303,0 +304,2 @@\n+    AOTOopChecker::check(obj); \/\/ Make sure contents of this oop are safe.\n+\n@@ -588,1 +591,1 @@\n-static void copy_java_mirror_hashcode(oop orig_mirror, oop scratch_m) {\n+void HeapShared::copy_java_mirror(oop orig_mirror, oop scratch_m) {\n@@ -604,0 +607,5 @@\n+\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    java_lang_Class::set_module(scratch_m, java_lang_Class::module(orig_mirror));\n+    java_lang_Class::set_protection_domain(scratch_m, java_lang_Class::protection_domain(orig_mirror));\n+  }\n@@ -701,1 +709,1 @@\n-    copy_java_mirror_hashcode(orig_mirror, m);\n+    copy_java_mirror(orig_mirror, m);\n@@ -1612,2 +1620,2 @@\n-    \/\/ The enum klasses are archived with aot-initialized mirror.\n-    \/\/ See AOTClassInitializer::can_archive_initialized_mirror().\n+    \/\/ The classes of all archived enum instances have been marked as aot-init,\n+    \/\/ so there's nothing else to be done in the production run.\n@@ -1615,0 +1623,2 @@\n+    \/\/ This is legacy support for enum classes before JEP 483 -- we cannot rerun\n+    \/\/ the enum's <clinit> in the production run, so special handling is needed.\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -342,0 +342,1 @@\n+  static void copy_java_mirror(oop orig_mirror, oop scratch_m);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-\/\/ [0] All classes are loaded in MetaspaceShared::preload_classes(). All metadata are\n+\/\/ [0] All classes are loaded in MetaspaceShared::load_classes(). All metadata are\n@@ -798,3 +798,1 @@\n-\/\/ Preload classes from a list, populate the shared spaces and dump to a\n-\/\/ file.\n-void MetaspaceShared::preload_and_dump(TRAPS) {\n+void MetaspaceShared::dump_static_archive(TRAPS) {\n@@ -803,1 +801,1 @@\n- HandleMark hm(THREAD);\n+  HandleMark hm(THREAD);\n@@ -811,1 +809,1 @@\n-  preload_and_dump_impl(builder, THREAD);\n+  dump_static_archive_impl(builder, THREAD);\n@@ -877,1 +875,1 @@\n-void MetaspaceShared::preload_classes(TRAPS) {\n+void MetaspaceShared::load_classes(TRAPS) {\n@@ -904,2 +902,2 @@\n-  \/\/ Some classes are used at CDS runtime but are not loaded, and therefore archived, at\n-  \/\/ dumptime. We can perform dummmy calls to these classes at dumptime to ensure they\n+  \/\/ Some classes are used at CDS runtime but are not yet loaded at this point.\n+  \/\/ We can perform dummmy calls to these classes at dumptime to ensure they\n@@ -921,1 +919,1 @@\n-void MetaspaceShared::preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) {\n+void MetaspaceShared::dump_static_archive_impl(StaticArchiveBuilder& builder, TRAPS) {\n@@ -924,1 +922,1 @@\n-    preload_classes(CHECK);\n+    load_classes(CHECK);\n@@ -1982,1 +1980,3 @@\n-    DynamicArchive::setup_array_klasses();\n+    if (!CDSConfig::is_using_preloaded_classes()) {\n+      DynamicArchive::setup_array_klasses();\n+    }\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  static void preload_and_dump(TRAPS) NOT_CDS_RETURN;\n+  static void dump_static_archive(TRAPS) NOT_CDS_RETURN;\n@@ -82,2 +82,2 @@\n-  static void preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) NOT_CDS_RETURN;\n-  static void preload_classes(TRAPS) NOT_CDS_RETURN;\n+  static void dump_static_archive_impl(StaticArchiveBuilder& builder, TRAPS) NOT_CDS_RETURN;\n+  static void load_classes(TRAPS) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -283,0 +283,11 @@\n+void ClassLoaderDataShared::restore_archived_modules_for_preloading_classes(JavaThread* current) {\n+  precond(CDSConfig::is_using_preloaded_classes());\n+\n+  precond(_platform_loader_root_index >= 0);\n+  precond(_system_loader_root_index >= 0);\n+\n+  Handle h_platform_loader(current, HeapShared::get_root(_platform_loader_root_index));\n+  Handle h_system_loader(current, HeapShared::get_root(_system_loader_root_index));\n+  Modules::init_archived_modules(current, h_platform_loader, h_system_loader);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -40,0 +41,1 @@\n+  static void restore_archived_modules_for_preloading_classes(JavaThread* current) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1016,0 +1016,9 @@\n+  if (CDSConfig::is_using_preloaded_classes()) {\n+    oop archived_module = java_lang_Class::module(mirror());\n+    if (archived_module != nullptr) {\n+      precond(module() == nullptr || module() == archived_module);\n+      precond(MetaspaceShared::is_shared_static((void*)k));\n+      return;\n+    }\n+  }\n+\n@@ -1055,3 +1064,5 @@\n-  GrowableArray<Klass*>* mirror_list =\n-    new (mtClass) GrowableArray<Klass*>(40, mtClass);\n-  set_fixup_mirror_list(mirror_list);\n+  if (!CDSConfig::is_using_preloaded_classes()) {\n+    GrowableArray<Klass*>* mirror_list =\n+      new (mtClass) GrowableArray<Klass*>(40, mtClass);\n+    set_fixup_mirror_list(mirror_list);\n+  }\n@@ -1162,0 +1173,1 @@\n+    assert(!CDSConfig::is_using_preloaded_classes(), \"should not come here\");\n@@ -1207,1 +1219,1 @@\n-  if (!vmClasses::Class_klass_loaded()) {\n+  if (!vmClasses::Class_klass_loaded() && !CDSConfig::is_using_preloaded_classes()) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -237,0 +237,1 @@\n+  friend class HeapShared;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -703,0 +703,20 @@\n+  if (h_platform_loader.is_null()) {\n+    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null platform loader object\");\n+  }\n+\n+  if (h_system_loader.is_null()) {\n+    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null system loader object\");\n+  }\n+\n+  if (CDSConfig::is_using_preloaded_classes()) {\n+    \/\/ Already initialized\n+    precond(SystemDictionary::java_platform_loader() == h_platform_loader());\n+    precond(SystemDictionary::java_system_loader() == h_system_loader());\n+  } else {\n+    init_archived_modules(THREAD, h_platform_loader, h_system_loader);\n+  }\n+}\n+\n+void Modules::init_archived_modules(JavaThread* current, Handle h_platform_loader, Handle h_system_loader) {\n+  assert(CDSConfig::is_using_full_module_graph(), \"must be\");\n+  ExceptionMark em(current);\n@@ -711,6 +731,3 @@\n-  Handle java_base_module(THREAD, ClassLoaderDataShared::restore_archived_oops_for_null_class_loader_data());\n-  \/\/ Patch any previously loaded class's module field with java.base's java.lang.Module.\n-  ModuleEntryTable::patch_javabase_entries(THREAD, java_base_module);\n-\n-  if (h_platform_loader.is_null()) {\n-    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null platform loader object\");\n+  if (CDSConfig::is_using_preloaded_classes()) {\n+    ClassLoaderData* boot_loader_data = ClassLoaderData::the_null_class_loader_data();\n+    ClassLoaderDataShared::archived_boot_unnamed_module()->restore_archived_oops(boot_loader_data);\n@@ -719,2 +736,4 @@\n-  if (h_system_loader.is_null()) {\n-    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null system loader object\");\n+  Handle java_base_module(current, ClassLoaderDataShared::restore_archived_oops_for_null_class_loader_data());\n+  if (!CDSConfig::is_using_preloaded_classes()) {\n+    \/\/ Patch any previously loaded class's module field with java.base's java.lang.Module.\n+    ModuleEntryTable::patch_javabase_entries(current, java_base_module);\n@@ -780,1 +799,3 @@\n-    unnamed_module->restore_archived_oops(boot_loader_data);\n+    if (!CDSConfig::is_using_preloaded_classes()) {\n+      unnamed_module->restore_archived_oops(boot_loader_data);\n+    }\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":30,"deletions":9,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+  static void init_archived_modules(JavaThread* current, Handle h_platform_loader, Handle h_system_loader)\n+                                   NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,3 +199,5 @@\n-  assert(_java_system_loader.is_empty(), \"already set!\");\n-  _java_system_loader = cld->class_loader_handle();\n-\n+  if (_java_system_loader.is_empty()) {\n+    _java_system_loader = cld->class_loader_handle();\n+  } else {\n+    assert(_java_system_loader.resolve() == cld->class_loader(), \"sanity\");\n+  }\n@@ -205,2 +207,5 @@\n-  assert(_java_platform_loader.is_empty(), \"already set!\");\n-  _java_platform_loader = cld->class_loader_handle();\n+  if (_java_platform_loader.is_empty()) {\n+    _java_platform_loader = cld->class_loader_handle();\n+  } else {\n+    assert(_java_platform_loader.resolve() == cld->class_loader(), \"sanity\");\n+  }\n@@ -1152,0 +1157,52 @@\n+\/\/ This is much more lightweight than SystemDictionary::resolve_or_null\n+\/\/ - There's only a single Java thread at this point. No need for placeholder.\n+\/\/ - All supertypes of ik have been loaded\n+\/\/ - There's no circularity (checked in AOT assembly phase)\n+\/\/ - There's no need to call java.lang.ClassLoader::load_class() because the boot\/platform\/app\n+\/\/   loaders are well-behaved\n+void SystemDictionary::preload_class(Handle class_loader, InstanceKlass* ik, TRAPS) {\n+  precond(Universe::is_bootstrapping());\n+  precond(java_platform_loader() != nullptr && java_system_loader() != nullptr);\n+  precond(class_loader() == nullptr || class_loader() == java_platform_loader() ||class_loader() == java_system_loader());\n+  precond(CDSConfig::is_using_preloaded_classes());\n+  precond(MetaspaceShared::is_shared_static((void*)ik));\n+  precond(!ik->is_loaded());\n+\n+#ifdef ASSERT\n+  \/\/ preload_class() must be called in the correct order -- all super types must have\n+  \/\/ already been loaded.\n+  if (ik->java_super() != nullptr) {\n+    assert(ik->java_super()->is_loaded(), \"must be\");\n+  }\n+\n+  Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n+  int num_interfaces = interfaces->length();\n+  for (int index = 0; index < num_interfaces; index++) {\n+    assert(interfaces->at(index)->is_loaded(), \"must be\");\n+  }\n+#endif\n+\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());\n+  oop java_mirror = ik->archived_java_mirror();\n+  precond(java_mirror != nullptr);\n+\n+  Handle pd(THREAD, java_lang_Class::protection_domain(java_mirror));\n+  PackageEntry* pkg_entry = ik->package();\n+  assert(pkg_entry != nullptr || ClassLoader::package_from_class_name(ik->name()) == nullptr,\n+         \"non-empty packages must have been archived\");\n+\n+  \/\/ TODO: the following assert requires JDK-8365580\n+  \/\/ assert(is_shared_class_visible(ik->name(), ik, pkg_entry, class_loader), \"must be\");\n+\n+  ik->restore_unshareable_info(loader_data, pd, pkg_entry, CHECK);\n+  load_shared_class_misc(ik, loader_data);\n+  ik->add_to_hierarchy(THREAD);\n+\n+  if (!ik->is_hidden()) {\n+    update_dictionary(THREAD, ik, loader_data);\n+  }\n+\n+  assert(java_lang_Class::module(java_mirror) != nullptr, \"must have been archived\");\n+  assert(ik->is_loaded(), \"Must be in at least loaded state\");\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":62,"deletions":5,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-  \/\/ Used by SystemDictionaryShared and LambdaProxyClassDictionary\n+  \/\/ Used by AOTLinkedClassBulkLoader, LambdaProxyClassDictionary, and SystemDictionaryShared\n@@ -340,0 +340,1 @@\n+  static void preload_class(Handle class_loader, InstanceKlass* ik, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,1 +104,5 @@\n-    resolve(id, CHECK);\n+    if (CDSConfig::is_using_preloaded_classes()) {\n+      precond(klass_at(id)->is_loaded());\n+    } else {\n+      resolve(id, CHECK);\n+    }\n@@ -118,0 +122,4 @@\n+  if (CDSConfig::is_using_preloaded_classes()) {\n+    AOTLinkedClassBulkLoader::preload_classes(THREAD);\n+  }\n+\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -850,1 +850,1 @@\n-      comp_level == CompLevel_full_optimization CDS_ONLY(&& !AOTLinkedClassBulkLoader::class_preloading_finished())) {\n+      comp_level == CompLevel_full_optimization CDS_ONLY(&& !AOTLinkedClassBulkLoader::has_finished_loading_classes())) {\n@@ -1443,1 +1443,1 @@\n-      next_level == CompLevel_full_optimization CDS_ONLY(&& !AOTLinkedClassBulkLoader::class_preloading_finished())) {\n+      next_level == CompLevel_full_optimization CDS_ONLY(&& !AOTLinkedClassBulkLoader::has_finished_loading_classes())) {\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -54,6 +53,1 @@\n-  ClassLoaderData* cld = k->class_loader_data();\n-  if (cld != nullptr) {\n-    ClaimMetadataVisitingOopIterateClosure::do_cld(cld);\n-  } else {\n-    assert(AOTLinkedClassBulkLoader::is_pending_aot_linked_class(k), \"sanity\");\n-  }\n+  ClaimMetadataVisitingOopIterateClosure::do_cld(k->class_loader_data());\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -584,0 +584,4 @@\n+  if (CDSConfig::is_using_preloaded_classes()) {\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -451,1 +451,1 @@\n-    MetaspaceShared::preload_and_dump(thread);\n+    MetaspaceShared::dump_static_archive(thread);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -892,1 +892,1 @@\n-    MetaspaceShared::preload_and_dump(CHECK_JNI_ERR);\n+    MetaspaceShared::dump_static_archive(CHECK_JNI_ERR);\n@@ -895,1 +895,1 @@\n-    MetaspaceShared::preload_and_dump(CHECK_JNI_ERR);\n+    MetaspaceShared::dump_static_archive(CHECK_JNI_ERR);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+import jdk.internal.misc.CDS;\n@@ -67,0 +68,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -223,0 +226,1 @@\n+@AOTSafeClassInitializer\n@@ -227,0 +231,5 @@\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n@@ -1852,2 +1861,2 @@\n-                assert VM.isBooted() && scl != null;\n-                return scl;\n+                assert VM.isBooted() && Holder.scl != null;\n+                return Holder.scl;\n@@ -1878,1 +1887,1 @@\n-        if (scl != null) {\n+        if (Holder.scl != null) {\n@@ -1889,1 +1898,1 @@\n-                scl = (ClassLoader) ctor.newInstance(builtinLoader);\n+                Holder.scl = (ClassLoader) ctor.newInstance(builtinLoader);\n@@ -1904,1 +1913,1 @@\n-            scl = builtinLoader;\n+            Holder.scl = builtinLoader;\n@@ -1906,1 +1915,1 @@\n-        return scl;\n+        return Holder.scl;\n@@ -1919,3 +1928,7 @@\n-    \/\/ The system class loader\n-    \/\/ @GuardedBy(\"ClassLoader.class\")\n-    private static volatile ClassLoader scl;\n+    \/\/ Holder has the field(s) that need to be initialized during JVM bootstrap even if\n+    \/\/ the outer is aot-initialized.\n+    private static class Holder {\n+        \/\/ The system class loader\n+        \/\/ @GuardedBy(\"ClassLoader.class\")\n+        private static volatile ClassLoader scl;\n+    }\n@@ -2596,1 +2609,15 @@\n-        reinitObjectField(\"packages\", new ConcurrentHashMap<>());\n+\n+        if (CDS.isDumpingAOTLinkedClasses()) {\n+            if (System.getProperty(\"cds.debug.archived.packages\") != null) {\n+                for (Map.Entry<String, NamedPackage> entry : packages.entrySet()) {\n+                    String key = entry.getKey();\n+                    NamedPackage value = entry.getValue();\n+                    System.out.println(\"Archiving \" +\n+                                       (value instanceof Package ? \"Package\" : \"NamedPackage\") +\n+                                       \" \\\"\" + key + \"\\\" for \" + this);\n+                }\n+            }\n+        } else {\n+            reinitObjectField(\"packages\", new ConcurrentHashMap<>());\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":38,"deletions":11,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -94,0 +96,1 @@\n+@AOTSafeClassInitializer\n@@ -2672,0 +2675,5 @@\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -519,0 +521,1 @@\n+@AOTSafeClassInitializer\n@@ -3729,0 +3732,1 @@\n+\n@@ -3730,0 +3734,5 @@\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/net\/URI.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -217,0 +219,1 @@\n+@AOTSafeClassInitializer\n@@ -1761,0 +1764,5 @@\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/net\/URL.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.misc.CDS;\n@@ -246,1 +247,15 @@\n-        pdcache.clear();\n+        if (CDS.isDumpingAOTLinkedClasses()) {\n+            for (CodeSourceKey key : pdcache.keySet()) {\n+                if (key.cs.getCodeSigners() != null) {\n+                    \/\/ We don't archive any signed classes, so we don't need to cache their ProtectionDomains.\n+                    pdcache.remove(key);\n+                }\n+            }\n+            if (System.getProperty(\"cds.debug.archived.protection.domains\") != null) {\n+                for (CodeSourceKey key : pdcache.keySet()) {\n+                    System.out.println(\"Archiving ProtectionDomain \" + key.cs + \" for \" + this);\n+                }\n+            }\n+        } else {\n+            pdcache.clear();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureClassLoader.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -78,3 +78,7 @@\n-    \/\/ native libraries loaded by the boot class loader\n-    private static final NativeLibraries NATIVE_LIBS\n-        = NativeLibraries.newInstance(null);\n+    \/\/ Holder has the field(s) that need to be initialized during JVM bootstrap even if\n+    \/\/ the outer is aot-initialized.\n+    private static class Holder {\n+        \/\/ native libraries loaded by the boot class loader\n+        private static final NativeLibraries NATIVE_LIBS\n+            = NativeLibraries.newInstance(null);\n+    }\n@@ -107,1 +111,1 @@\n-        return NATIVE_LIBS;\n+        return Holder.NATIVE_LIBS;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/BootLoader.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-            if (loadedLibraryNames.contains(name)) {\n+            if (Holder.loadedLibraryNames.contains(name)) {\n@@ -206,1 +206,1 @@\n-            loadedLibraryNames.add(name);\n+            Holder.loadedLibraryNames.add(name);\n@@ -246,0 +246,5 @@\n+    \/\/ Called at the end of AOTCache assembly phase.\n+    public void clear() {\n+        libraries.clear();\n+    }\n+\n@@ -371,1 +376,1 @@\n-                if (!loadedLibraryNames.remove(name)) {\n+                if (!Holder.loadedLibraryNames.remove(name)) {\n@@ -398,2 +403,5 @@\n-    \/\/ All native libraries we've loaded.\n-    private static final Set<String> loadedLibraryNames =\n+    \/\/ Holder has the fields that need to be initialized during JVM bootstrap even if\n+    \/\/ the outer is aot-initialized.\n+    static class Holder {\n+        \/\/ All native libraries we've loaded.\n+        private static final Set<String> loadedLibraryNames =\n@@ -401,0 +409,1 @@\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -50,5 +50,7 @@\n-    private static final int IS_DUMPING_ARCHIVE              = 1 << 0;\n-    private static final int IS_DUMPING_METHOD_HANDLES       = 1 << 1;\n-    private static final int IS_DUMPING_STATIC_ARCHIVE       = 1 << 2;\n-    private static final int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 3;\n-    private static final int IS_USING_ARCHIVE                = 1 << 4;\n+    private static final int IS_DUMPING_AOT_LINKED_CLASSES   = 1 << 0;\n+    private static final int IS_DUMPING_ARCHIVE              = 1 << 1;\n+    private static final int IS_DUMPING_METHOD_HANDLES       = 1 << 2;\n+    private static final int IS_DUMPING_STATIC_ARCHIVE       = 1 << 3;\n+    private static final int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 4;\n+    private static final int IS_USING_ARCHIVE                = 1 << 5;\n+\n@@ -85,0 +87,4 @@\n+    public static boolean isDumpingAOTLinkedClasses() {\n+        return (configStatus & IS_DUMPING_AOT_LINKED_CLASSES) != 0;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -20,0 +20,4 @@\n+\n+# These tests fail often with AotJdk due to JDK-8323727\n+compiler\/arguments\/TestStressReflectiveCode.java 8323727 generic-all\n+compiler\/arraycopy\/TestCloneWithStressReflectiveCode.java 8323727 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-AotJdk.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ *             InterfaceWithEnum EnumWithClinit\n@@ -104,0 +105,5 @@\n+\n+            \/\/ For MethodHandleTestApp.testLambdaWithEnums()\n+            if (runMode == RunMode.ASSEMBLY) {\n+                out.shouldNotContain(\"EnumWithClinit.<clinit>\");\n+            }\n@@ -209,0 +215,2 @@\n+        testLambdaWithEnums();\n+\n@@ -278,0 +286,23 @@\n+\n+\n+    static boolean InterfaceWithEnum_inited = false;\n+\n+    \/\/ Enum types used in lambdas shouldn't be initialized during the assembly phase.\n+    static void testLambdaWithEnums() {\n+        if (InterfaceWithEnum_inited) {\n+            throw new RuntimeException(\"InterfaceWithEnum should not be inited\");\n+        }\n+\n+        InterfaceWithEnum iwe = (x) -> {\n+            System.out.println(\"Hello from testLambdaWithEnums\");\n+        };\n+\n+        System.out.println(iwe);\n+        if (InterfaceWithEnum_inited) {\n+            throw new RuntimeException(\"InterfaceWithEnum should not be inited\");\n+        }\n+        iwe.func(EnumWithClinit.Dummy);\n+        if (!InterfaceWithEnum_inited) {\n+            throw new RuntimeException(\"InterfaceWithEnum should be inited\");\n+        }\n+    }\n@@ -335,0 +366,12 @@\n+interface InterfaceWithEnum {\n+    void func(EnumWithClinit e);\n+}\n+\n+enum EnumWithClinit {\n+    Dummy;\n+    static {\n+        MethodHandleTestApp.InterfaceWithEnum_inited = true;\n+        System.out.println(\"EnumWithClinit.<clinit>\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/MethodHandleTest.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"}]}