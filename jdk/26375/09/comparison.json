{"files":[{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-    table->set_boot(write_classes(nullptr, true));\n+    table->set_boot1(write_classes(nullptr, true));\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/dynamicArchive.hpp\"\n@@ -32,0 +33,2 @@\n+#include \"classfile\/classLoaderDataShared.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n@@ -44,5 +47,0 @@\n-bool AOTLinkedClassBulkLoader::_boot2_completed = false;\n-bool AOTLinkedClassBulkLoader::_platform_completed = false;\n-bool AOTLinkedClassBulkLoader::_app_completed = false;\n-bool AOTLinkedClassBulkLoader::_all_completed = false;\n-\n@@ -53,8 +51,15 @@\n-bool AOTLinkedClassBulkLoader::class_preloading_finished() {\n-  if (!CDSConfig::is_using_aot_linked_classes()) {\n-    return true;\n-  } else {\n-    \/\/ The ConstantPools of preloaded classes have references to other preloaded classes. We don't\n-    \/\/ want any Java code (including JVMCI compiler) to use these classes until all of them\n-    \/\/ are loaded.\n-    return AtomicAccess::load_acquire(&_all_completed);\n+\/\/ This function is called before the VM executes any Java code (include AOT-compiled Java methods).\n+\/\/\n+\/\/ We populate the boot\/platform\/app class loaders with classes from the AOT cache. This is a fundamental\n+\/\/ step in restoring the JVM's state from the snapshot recorded in the AOT cache: other AOT optimizations\n+\/\/ such as AOT compiled methods can make direct references to the preloaded classes, knowing that\n+\/\/ these classes are guaranteed to be in at least the loaded state.\n+\/\/\n+\/\/ Preloading requires that the Java heap objects of java.lang.Class, java.lang.Package and\n+\/\/ java.security.ProtectionDomain already exist for the preloaded classes. Therefore, we support preloading\n+\/\/ only for the classes in the static CDS archive. Classes in the dynamic archive are not supported because\n+\/\/ the dynamic archive does not include Java heap objects.\n+void AOTLinkedClassBulkLoader::preload_classes(JavaThread* current) {\n+  preload_classes_impl(current);\n+  if (current->has_pending_exception()) {\n+    exit_on_exception(current);\n@@ -64,3 +69,20 @@\n-void AOTLinkedClassBulkLoader::load_javabase_classes(JavaThread* current) {\n-  assert(CDSConfig::is_using_aot_linked_classes(), \"sanity\");\n-  load_classes_in_loader(current, AOTLinkedClassCategory::BOOT1, nullptr); \/\/ only java.base classes\n+void AOTLinkedClassBulkLoader::preload_classes_impl(TRAPS) {\n+  precond(CDSConfig::is_using_aot_linked_classes());\n+\n+  ClassLoaderDataShared::restore_archived_modules_for_preloading_classes(THREAD);\n+  Handle h_platform_loader(THREAD, SystemDictionary::java_platform_loader());\n+  Handle h_system_loader(THREAD, SystemDictionary::java_system_loader());\n+\n+  AOTLinkedClassTable* table = AOTLinkedClassTable::get();\n+\n+  preload_classes_in_table(table->boot1(), \"boot1\", Handle(), CHECK);\n+  preload_classes_in_table(table->boot2(), \"boot2\", Handle(), CHECK);\n+\n+  initiate_loading(THREAD, \"plat\", h_platform_loader, table->boot1());\n+  initiate_loading(THREAD, \"plat\", h_platform_loader, table->boot2());\n+  preload_classes_in_table(table->platform(), \"plat\", h_platform_loader, CHECK);\n+\n+  initiate_loading(THREAD, \"app\", h_system_loader, table->boot1());\n+  initiate_loading(THREAD, \"app\", h_system_loader, table->boot2());\n+  initiate_loading(THREAD, \"app\", h_system_loader, table->platform());\n+  preload_classes_in_table(table->app(), \"app\", h_system_loader, CHECK);\n@@ -69,2 +91,5 @@\n-void AOTLinkedClassBulkLoader::load_non_javabase_classes(JavaThread* current) {\n-  assert(CDSConfig::is_using_aot_linked_classes(), \"sanity\");\n+void AOTLinkedClassBulkLoader::preload_classes_in_table(Array<InstanceKlass*>* classes,\n+                                                        const char* category_name, Handle loader, TRAPS) {\n+  if (classes == nullptr) {\n+    return;\n+  }\n@@ -72,6 +97,8 @@\n-  \/\/ is_using_aot_linked_classes() requires is_using_full_module_graph(). As a result,\n-  \/\/ the platform\/system class loader should already have been initialized as part\n-  \/\/ of the FMG support.\n-  assert(CDSConfig::is_using_full_module_graph(), \"must be\");\n-  assert(SystemDictionary::java_platform_loader() != nullptr, \"must be\");\n-  assert(SystemDictionary::java_system_loader() != nullptr,   \"must be\");\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(loader());\n+  for (int i = 0; i < classes->length(); i++) {\n+    InstanceKlass* ik = classes->at(i);\n+    if (log_is_enabled(Info, aot, load)) {\n+      ResourceMark rm(THREAD);\n+      log_info(aot, load)(\"%-5s %s%s\", category_name, ik->external_name(),\n+                          ik->is_hidden() ? \" (hidden)\" : \"\");\n+    }\n@@ -79,2 +106,1 @@\n-  load_classes_in_loader(current, AOTLinkedClassCategory::BOOT2, nullptr); \/\/ all boot classes outside of java.base\n-  _boot2_completed = true;\n+    SystemDictionary::preload_class(loader, ik, CHECK);\n@@ -82,2 +108,13 @@\n-  load_classes_in_loader(current, AOTLinkedClassCategory::PLATFORM, SystemDictionary::java_platform_loader());\n-  _platform_completed = true;\n+    if (ik->is_hidden()) {\n+      DEBUG_ONLY({\n+        \/\/ Make sure we don't make this hidden class available by name, even if we don't\n+        \/\/ use any special ClassLoaderData.\n+        ResourceMark rm(THREAD);\n+        assert(SystemDictionary::find_instance_klass(THREAD, ik->name(), loader) == nullptr,\n+               \"hidden classes cannot be accessible by name: %s\", ik->external_name());\n+      });\n+    } else {\n+      precond(SystemDictionary::find_instance_klass(THREAD, ik->name(), loader) == ik);\n+    }\n+  }\n+}\n@@ -85,1 +122,7 @@\n-  load_classes_in_loader(current, AOTLinkedClassCategory::APP, SystemDictionary::java_system_loader());\n+#ifdef ASSERT\n+void AOTLinkedClassBulkLoader::validate_module_of_preloaded_classes() {\n+  oop javabase_module_oop = ModuleEntryTable::javabase_moduleEntry()->module_oop();\n+  for (int i = T_BOOLEAN; i < T_LONG+1; i++) {\n+    TypeArrayKlass* tak = Universe::typeArrayKlass((BasicType)i);\n+    validate_module(tak, \"boot1\", javabase_module_oop);\n+  }\n@@ -87,3 +130,38 @@\n-  if (AOTPrintTrainingInfo) {\n-    tty->print_cr(\"==================== archived_training_data ** after all classes preloaded ====================\");\n-    TrainingData::print_archived_training_data_on(tty);\n+  JavaThread* current = JavaThread::current();\n+  Handle h_platform_loader(current, SystemDictionary::java_platform_loader());\n+  Handle h_system_loader(current, SystemDictionary::java_system_loader());\n+  AOTLinkedClassTable* table = AOTLinkedClassTable::get();\n+\n+  validate_module_of_preloaded_classes_in_table(table->boot1(), \"boot1\", Handle());\n+  validate_module_of_preloaded_classes_in_table(table->boot2(), \"boot2\", Handle());\n+  validate_module_of_preloaded_classes_in_table(table->platform(), \"plat\", h_platform_loader);\n+  validate_module_of_preloaded_classes_in_table(table->app(), \"app\", h_system_loader);\n+}\n+\n+void AOTLinkedClassBulkLoader::validate_module_of_preloaded_classes_in_table(Array<InstanceKlass*>* classes,\n+                                                                             const char* category_name, Handle loader) {\n+  if (classes == nullptr) {\n+    return;\n+  }\n+\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(loader());\n+  for (int i = 0; i < classes->length(); i++) {\n+    InstanceKlass* ik = classes->at(i);\n+    PackageEntry* pkg_entry = ik->package();\n+    oop module_oop;\n+    if (pkg_entry == nullptr) {\n+      module_oop = loader_data->unnamed_module()->module_oop();\n+    } else {\n+      module_oop = pkg_entry->module()->module_oop();\n+    }\n+\n+    validate_module(ik, category_name, module_oop);\n+  }\n+}\n+\n+void AOTLinkedClassBulkLoader::validate_module(Klass* k, const char* category_name, oop module_oop) {\n+  assert(module_oop != nullptr, \"module system must have been initialized\");\n+\n+  if (log_is_enabled(Debug, aot, module)) {\n+    ResourceMark rm;\n+    log_debug(aot, module)(\"Validate module of %-5s %s\", category_name, k->external_name());\n@@ -91,0 +169,1 @@\n+  precond(java_lang_Class::module(k->java_mirror()) == module_oop);\n@@ -92,2 +171,9 @@\n-  _app_completed = true;\n-  AtomicAccess::release_store(&_all_completed, true);\n+  ArrayKlass* ak = k->array_klass_or_null();\n+  while (ak != nullptr) {\n+    if (log_is_enabled(Debug, aot, module)) {\n+      ResourceMark rm;\n+      log_debug(aot, module)(\"Validate module of %-5s %s\", category_name, ak->external_name());\n+    }\n+    precond(java_lang_Class::module(ak->java_mirror()) == module_oop);\n+    ak = ak->array_klass_or_null();\n+  }\n@@ -95,0 +181,1 @@\n+#endif\n@@ -96,2 +183,2 @@\n-void AOTLinkedClassBulkLoader::load_classes_in_loader(JavaThread* current, AOTLinkedClassCategory class_category, oop class_loader_oop) {\n-  load_classes_in_loader_impl(class_category, class_loader_oop, current);\n+void AOTLinkedClassBulkLoader::link_or_init_javabase_classes(JavaThread* current) {\n+  link_or_init_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot1(), current);\n@@ -99,2 +186,0 @@\n-    \/\/ We cannot continue, as we might have loaded some of the aot-linked classes, which\n-    \/\/ may have dangling C++ pointers to other aot-linked classes that we have failed to load.\n@@ -105,9 +190,4 @@\n-void AOTLinkedClassBulkLoader::exit_on_exception(JavaThread* current) {\n-  assert(current->has_pending_exception(), \"precondition\");\n-  ResourceMark rm(current);\n-  if (current->pending_exception()->is_a(vmClasses::OutOfMemoryError_klass())) {\n-    log_error(aot)(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n-                   \"%zuM\", MaxHeapSize\/M);\n-  } else {\n-    log_error(aot)(\"%s: %s\", current->pending_exception()->klass()->external_name(),\n-                   java_lang_String::as_utf8_string(java_lang_Throwable::message(current->pending_exception())));\n+void AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes(JavaThread* current) {\n+  link_or_init_non_javabase_classes_impl(current);\n+  if (current->has_pending_exception()) {\n+    exit_on_exception(current);\n@@ -115,1 +195,0 @@\n-  vm_exit_during_initialization(\"Unexpected exception when loading aot-linked classes.\");\n@@ -118,2 +197,16 @@\n-void AOTLinkedClassBulkLoader::load_classes_in_loader_impl(AOTLinkedClassCategory class_category, oop class_loader_oop, TRAPS) {\n-  Handle h_loader(THREAD, class_loader_oop);\n+void AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes_impl(TRAPS) {\n+  assert(CDSConfig::is_using_aot_linked_classes(), \"sanity\");\n+\n+  DEBUG_ONLY(validate_module_of_preloaded_classes());\n+\n+  \/\/ is_using_aot_linked_classes() requires is_using_full_module_graph(). As a result,\n+  \/\/ the platform\/system class loader should already have been initialized as part\n+  \/\/ of the FMG support.\n+  assert(CDSConfig::is_using_full_module_graph(), \"must be\");\n+\n+  Handle h_platform_loader(THREAD, SystemDictionary::java_platform_loader());\n+  Handle h_system_loader(THREAD, SystemDictionary::java_system_loader());\n+\n+  assert(h_platform_loader() != nullptr, \"must be\");\n+  assert(h_system_loader() != nullptr,   \"must be\");\n+\n@@ -121,22 +214,3 @@\n-  load_table(table, class_category, h_loader, CHECK);\n-\n-  \/\/ Initialize the InstanceKlasses of all archived heap objects that are reachable from the\n-  \/\/ archived java class mirrors.\n-  switch (class_category) {\n-  case AOTLinkedClassCategory::BOOT1:\n-    \/\/ Delayed until finish_loading_javabase_classes(), as the VM is not ready to\n-    \/\/ execute some of the <clinit> methods.\n-    break;\n-  case AOTLinkedClassCategory::BOOT2:\n-    init_required_classes_for_loader(h_loader, table->boot2(), CHECK);\n-    break;\n-  case AOTLinkedClassCategory::PLATFORM:\n-    init_required_classes_for_loader(h_loader, table->platform(), CHECK);\n-    break;\n-  case AOTLinkedClassCategory::APP:\n-    init_required_classes_for_loader(h_loader, table->app(), CHECK);\n-    break;\n-  case AOTLinkedClassCategory::UNREGISTERED:\n-    ShouldNotReachHere();\n-    break;\n-  }\n+  link_or_init_classes_for_loader(Handle(), table->boot2(), CHECK);\n+  link_or_init_classes_for_loader(h_platform_loader, table->platform(), CHECK);\n+  link_or_init_classes_for_loader(h_system_loader, table->app(), CHECK);\n@@ -149,6 +223,0 @@\n-}\n-\n-void AOTLinkedClassBulkLoader::load_table(AOTLinkedClassTable* table, AOTLinkedClassCategory class_category, Handle loader, TRAPS) {\n-  if (class_category != AOTLinkedClassCategory::BOOT1) {\n-    assert(Universe::is_module_initialized(), \"sanity\");\n-  }\n@@ -156,29 +224,3 @@\n-  const char* category_name = AOTClassLinker::class_category_name(class_category);\n-  switch (class_category) {\n-  case AOTLinkedClassCategory::BOOT1:\n-    load_classes_impl(class_category, table->boot(), category_name, loader, CHECK);\n-    break;\n-\n-  case AOTLinkedClassCategory::BOOT2:\n-    load_classes_impl(class_category, table->boot2(), category_name, loader, CHECK);\n-    break;\n-\n-  case AOTLinkedClassCategory::PLATFORM:\n-    {\n-      initiate_loading(THREAD, category_name, loader, table->boot());\n-      initiate_loading(THREAD, category_name, loader, table->boot2());\n-      load_classes_impl(class_category, table->platform(), category_name, loader, CHECK);\n-    }\n-    break;\n-  case AOTLinkedClassCategory::APP:\n-    {\n-      initiate_loading(THREAD, category_name, loader, table->boot());\n-      initiate_loading(THREAD, category_name, loader, table->boot2());\n-      initiate_loading(THREAD, category_name, loader, table->platform());\n-      load_classes_impl(class_category, table->app(), category_name, loader, CHECK);\n-    }\n-    break;\n-  case AOTLinkedClassCategory::UNREGISTERED:\n-  default:\n-    ShouldNotReachHere(); \/\/ Currently aot-linked classes are not supported for this category.\n-    break;\n+  if (AOTPrintTrainingInfo) {\n+    tty->print_cr(\"==================== archived_training_data ** after all classes preloaded ====================\");\n+    TrainingData::print_archived_training_data_on(tty);\n@@ -188,16 +230,10 @@\n-void AOTLinkedClassBulkLoader::load_classes_impl(AOTLinkedClassCategory class_category, Array<InstanceKlass*>* classes,\n-                                                 const char* category_name, Handle loader, TRAPS) {\n-  if (classes == nullptr) {\n-    return;\n-  }\n-\n-  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(loader());\n-\n-  for (int i = 0; i < classes->length(); i++) {\n-    InstanceKlass* ik = classes->at(i);\n-    if (log_is_enabled(Info, aot, load)) {\n-      ResourceMark rm(THREAD);\n-      log_info(aot, load)(\"%-5s %s%s%s\", category_name, ik->external_name(),\n-                          ik->is_loaded() ? \" (already loaded)\" : \"\",\n-                          ik->is_hidden() ? \" (hidden)\" : \"\");\n-    }\n+\/\/ For the AOT cache to function properly, all classes in the AOTLinkedClassTable\n+\/\/ must be loaded and linked. In addition, AOT-initialized classes must be moved to\n+\/\/ the initialized state.\n+\/\/\n+\/\/ We can encounter a failure during the loading, linking, or initialization of\n+\/\/ classes in the AOTLinkedClassTable only if:\n+\/\/   - We ran out of memory,\n+\/\/   - There is a serious error in the VM implemenation\n+\/\/ When this happens, the VM may be in an inconsistent state (e.g., we have a cached\n+\/\/ heap object of class X, but X is not linked). We must exit the JVM now.\n@@ -205,21 +241,9 @@\n-    if (!ik->is_loaded()) {\n-      if (ik->is_hidden()) {\n-        load_hidden_class(loader_data, ik, CHECK);\n-      } else {\n-        InstanceKlass* actual;\n-        if (loader_data == ClassLoaderData::the_null_class_loader_data()) {\n-          actual = SystemDictionary::load_instance_class(ik->name(), loader, CHECK);\n-        } else {\n-          actual = SystemDictionaryShared::find_or_load_shared_class(ik->name(), loader, CHECK);\n-        }\n-\n-        if (actual != ik) {\n-          ResourceMark rm(THREAD);\n-          log_error(aot)(\"Unable to resolve %s class from %s: %s\", category_name, CDSConfig::type_of_archive_being_loaded(), ik->external_name());\n-          log_error(aot)(\"Expected: \" INTPTR_FORMAT \", actual: \" INTPTR_FORMAT, p2i(ik), p2i(actual));\n-          log_error(aot)(\"JVMTI class retransformation is not supported when archive was generated with -XX:+AOTClassLinking.\");\n-          AOTMetaspace::unrecoverable_loading_error();\n-        }\n-        assert(actual->is_loaded(), \"must be\");\n-      }\n-    }\n+void AOTLinkedClassBulkLoader::exit_on_exception(JavaThread* current) {\n+  assert(current->has_pending_exception(), \"precondition\");\n+  ResourceMark rm(current);\n+  if (current->pending_exception()->is_a(vmClasses::OutOfMemoryError_klass())) {\n+    log_error(aot)(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n+                   \"%zuM\", MaxHeapSize\/M);\n+  } else {\n+    log_error(aot)(\"%s: %s\", current->pending_exception()->klass()->external_name(),\n+                   java_lang_String::as_utf8_string(java_lang_Throwable::message(current->pending_exception())));\n@@ -227,0 +251,1 @@\n+  vm_exit_during_initialization(\"Unexpected exception when loading aot-linked classes.\");\n@@ -258,1 +283,1 @@\n-        log_info(aot, load)(\"%s %s (initiated, defined by %s)\", category_name, ik->external_name(),\n+        log_info(aot, load)(\"%-5s %s (initiated, defined by %s)\", category_name, ik->external_name(),\n@@ -266,70 +291,0 @@\n-\/\/ Currently, we archive only three types of hidden classes:\n-\/\/    - LambdaForms\n-\/\/    - lambda proxy classes\n-\/\/    - StringConcat classes\n-\/\/ See HeapShared::is_archivable_hidden_klass().\n-\/\/\n-\/\/ LambdaForm classes (with names like java\/lang\/invoke\/LambdaForm$MH+0x800000015) logically\n-\/\/ belong to the boot loader, but they are usually stored in their own special ClassLoaderData to\n-\/\/ facilitate class unloading, as a LambdaForm may refer to a class loaded by a custom loader\n-\/\/ that may be unloaded.\n-\/\/\n-\/\/ We only support AOT-resolution of indys in the boot\/platform\/app loader, so there's no need\n-\/\/ to support class unloading. For simplicity, we put all archived LambdaForm classes in the\n-\/\/ \"main\" ClassLoaderData of the boot loader.\n-\/\/\n-\/\/ (Even if we were to support other loaders, we would still feel free to ignore any requirement\n-\/\/ of class unloading, for any class asset in the AOT cache.  Anything that makes it into the AOT\n-\/\/ cache has a lifetime dispensation from unloading.  After all, the AOT cache never grows, and\n-\/\/ we can assume that the user is content with its size, and doesn't need its footprint to shrink.)\n-\/\/\n-\/\/ Lambda proxy classes are normally stored in the same ClassLoaderData as their nest hosts, and\n-\/\/ StringConcat are normally stored in the main ClassLoaderData of the boot class loader. We\n-\/\/ do the same for the archived copies of such classes.\n-void AOTLinkedClassBulkLoader::load_hidden_class(ClassLoaderData* loader_data, InstanceKlass* ik, TRAPS) {\n-  assert(HeapShared::is_lambda_form_klass(ik) ||\n-         HeapShared::is_lambda_proxy_klass(ik) ||\n-         HeapShared::is_string_concat_klass(ik), \"sanity\");\n-  DEBUG_ONLY({\n-      assert(ik->super()->is_loaded(), \"must be\");\n-      for (int i = 0; i < ik->local_interfaces()->length(); i++) {\n-        assert(ik->local_interfaces()->at(i)->is_loaded(), \"must be\");\n-      }\n-    });\n-\n-  Handle pd;\n-  PackageEntry* pkg_entry = nullptr;\n-\n-  \/\/ Since a hidden class does not have a name, it cannot be reloaded\n-  \/\/ normally via the system dictionary. Instead, we have to finish the\n-  \/\/ loading job here.\n-\n-  if (HeapShared::is_lambda_proxy_klass(ik)) {\n-    InstanceKlass* nest_host = ik->nest_host_not_null();\n-    assert(nest_host->is_loaded(), \"must be\");\n-    pd = Handle(THREAD, nest_host->protection_domain());\n-    pkg_entry = nest_host->package();\n-  }\n-\n-  ik->restore_unshareable_info(loader_data, pd, pkg_entry, CHECK);\n-  SystemDictionary::load_shared_class_misc(ik, loader_data);\n-  ik->add_to_hierarchy(THREAD);\n-  assert(ik->is_loaded(), \"Must be in at least loaded state\");\n-\n-  DEBUG_ONLY({\n-      \/\/ Make sure we don't make this hidden class available by name, even if we don't\n-      \/\/ use any special ClassLoaderData.\n-      Handle loader(THREAD, loader_data->class_loader());\n-      ResourceMark rm(THREAD);\n-      assert(SystemDictionary::resolve_or_null(ik->name(), loader, THREAD) == nullptr,\n-             \"hidden classes cannot be accessible by name: %s\", ik->external_name());\n-      if (HAS_PENDING_EXCEPTION) {\n-        CLEAR_PENDING_EXCEPTION;\n-      }\n-    });\n-}\n-\n-void AOTLinkedClassBulkLoader::finish_loading_javabase_classes(TRAPS) {\n-  init_required_classes_for_loader(Handle(), AOTLinkedClassTable::get()->boot(), CHECK);\n-}\n-\n@@ -340,1 +295,1 @@\n-void AOTLinkedClassBulkLoader::init_required_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS) {\n+void AOTLinkedClassBulkLoader::link_or_init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS) {\n@@ -364,50 +319,0 @@\n-bool AOTLinkedClassBulkLoader::is_pending_aot_linked_class(Klass* k) {\n-  if (!CDSConfig::is_using_aot_linked_classes()) {\n-    return false;\n-  }\n-\n-  if (_all_completed) { \/\/ no more pending aot-linked classes\n-    return false;\n-  }\n-\n-  if (k->is_objArray_klass()) {\n-    k = ObjArrayKlass::cast(k)->bottom_klass();\n-  }\n-  if (!k->is_instance_klass()) {\n-    \/\/ type array klasses (and their higher dimensions),\n-    \/\/ must have been loaded before a GC can ever happen.\n-    return false;\n-  }\n-\n-  \/\/ There's a small window during VM start-up where a not-yet loaded aot-linked\n-  \/\/ class k may be discovered by the GC during VM initialization. This can happen\n-  \/\/ when the heap contains an aot-cached instance of k, but k is not ready to be\n-  \/\/ loaded yet. (TODO: JDK-8342429 eliminates this possibility)\n-  \/\/\n-  \/\/ The following checks try to limit this window as much as possible for each of\n-  \/\/ the four AOTLinkedClassCategory of classes that can be aot-linked.\n-\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  if (ik->defined_by_boot_loader()) {\n-    if (ik->module() != nullptr && ik->in_javabase_module()) {\n-      \/\/ AOTLinkedClassCategory::BOOT1 -- all aot-linked classes in\n-      \/\/ java.base must have been loaded before a GC can ever happen.\n-      return false;\n-    } else {\n-      \/\/ AOTLinkedClassCategory::BOOT2 classes cannot be loaded until\n-      \/\/ module system is ready.\n-      return !_boot2_completed;\n-    }\n-  } else if (ik->defined_by_platform_loader()) {\n-    \/\/ AOTLinkedClassCategory::PLATFORM classes cannot be loaded until\n-    \/\/ the platform class loader is initialized.\n-    return !_platform_completed;\n-  } else if (ik->defined_by_app_loader()) {\n-    \/\/ AOTLinkedClassCategory::APP cannot be loaded until the app class loader\n-    \/\/ is initialized.\n-    return !_app_completed;\n-  } else {\n-    return false;\n-  }\n-}\n-\n@@ -428,1 +333,1 @@\n-    replay_training_at_init(table->boot(),     CHECK);\n+    replay_training_at_init(table->boot1(),    CHECK);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":172,"deletions":267,"binary":false,"changes":439,"status":"modified"},{"patch":"@@ -45,0 +45,9 @@\n+\/\/ The classes are loaded in two steps:\n+\/\/\n+\/\/ [1] preload_classes():\n+\/\/     This happens before any Java bytecode is executed, to load aot-linked classes in the static archive,\n+\/\/     placing them into the \"loaded\" state.\n+\/\/\n+\/\/ [2] load_javabase_classes() and load_non_javabase_classes():\n+\/\/     This happens after some Java code is executed, to load aot-linked classes in the dynamic archive.\n+\/\/     This steps also puts all aot-linked classes into at least the \"linked\" state.\n@@ -46,7 +55,3 @@\n-  static bool _boot2_completed;\n-  static bool _platform_completed;\n-  static bool _app_completed;\n-  static bool _all_completed;\n-  static void load_classes_in_loader(JavaThread* current, AOTLinkedClassCategory class_category, oop class_loader_oop);\n-  static void load_classes_in_loader_impl(AOTLinkedClassCategory class_category, oop class_loader_oop, TRAPS);\n-  static void load_table(AOTLinkedClassTable* table, AOTLinkedClassCategory class_category, Handle loader, TRAPS);\n+  static void preload_classes_impl(TRAPS);\n+  static void preload_classes_in_table(Array<InstanceKlass*>* classes,\n+                                       const char* category_name, Handle loader, TRAPS);\n@@ -54,4 +59,2 @@\n-  static void load_classes_impl(AOTLinkedClassCategory class_category, Array<InstanceKlass*>* classes,\n-                                const char* category_name, Handle loader, TRAPS);\n-  static void load_hidden_class(ClassLoaderData* loader_data, InstanceKlass* ik, TRAPS);\n-  static void init_required_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS);\n+  static void link_or_init_non_javabase_classes_impl(TRAPS);\n+  static void link_or_init_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS);\n@@ -59,0 +62,8 @@\n+\n+#ifdef ASSERT\n+  static void validate_module_of_preloaded_classes();\n+  static void validate_module_of_preloaded_classes_in_table(Array<InstanceKlass*>* classes,\n+                                                            const char* category_name, Handle loader);\n+  static void validate_module(Klass* k, const char* category_name, oop module_oop);\n+#endif\n+\n@@ -61,4 +72,3 @@\n-\n-  static void load_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n-  static void load_non_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n-  static void finish_loading_javabase_classes(TRAPS) NOT_CDS_RETURN;\n+  static void preload_classes(JavaThread* current);\n+  static void link_or_init_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void link_or_init_non_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n@@ -68,2 +78,0 @@\n-  static bool class_preloading_finished();\n-  static bool is_pending_aot_linked_class(Klass* k) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.hpp","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  soc->do_ptr((void**)&_boot);\n+  soc->do_ptr((void**)&_boot1);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassTable.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,2 @@\n-  Array<InstanceKlass*>* _boot;  \/\/ only java.base classes\n-  Array<InstanceKlass*>* _boot2; \/\/ boot classes in other modules\n+  Array<InstanceKlass*>* _boot1; \/\/ boot classes in java.base module\n+  Array<InstanceKlass*>* _boot2; \/\/ boot classes in all other (named and unnamed) modules\n@@ -51,1 +51,1 @@\n-    _boot(nullptr), _boot2(nullptr),\n+    _boot1(nullptr), _boot2(nullptr),\n@@ -58,1 +58,1 @@\n-  Array<InstanceKlass*>* boot()     const { return _boot;     }\n+  Array<InstanceKlass*>* boot1()    const { return _boot1;    }\n@@ -63,1 +63,1 @@\n-  void set_boot    (Array<InstanceKlass*>* value) { _boot     = value; }\n+  void set_boot1   (Array<InstanceKlass*>* value) { _boot1    = value; }\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassTable.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-\/\/ [0] All classes are loaded in AOTMetaspace::preload_classes(). All metadata are\n+\/\/ [0] All classes are loaded in AOTMetaspace::load_classes(). All metadata are\n@@ -825,3 +825,1 @@\n-\/\/ Preload classes from a list, populate the shared spaces and dump to a\n-\/\/ file.\n-void AOTMetaspace::preload_and_dump(TRAPS) {\n+void AOTMetaspace::dump_static_archive(TRAPS) {\n@@ -830,1 +828,1 @@\n- HandleMark hm(THREAD);\n+  HandleMark hm(THREAD);\n@@ -838,1 +836,1 @@\n-  preload_and_dump_impl(builder, THREAD);\n+  dump_static_archive_impl(builder, THREAD);\n@@ -904,1 +902,1 @@\n-void AOTMetaspace::preload_classes(TRAPS) {\n+void AOTMetaspace::load_classes(TRAPS) {\n@@ -931,2 +929,2 @@\n-  \/\/ Some classes are used at CDS runtime but are not loaded, and therefore archived, at\n-  \/\/ dumptime. We can perform dummmy calls to these classes at dumptime to ensure they\n+  \/\/ Some classes are used at CDS runtime but are not yet loaded at this point.\n+  \/\/ We can perform dummmy calls to these classes at dumptime to ensure they\n@@ -948,1 +946,1 @@\n-void AOTMetaspace::preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) {\n+void AOTMetaspace::dump_static_archive_impl(StaticArchiveBuilder& builder, TRAPS) {\n@@ -951,1 +949,1 @@\n-    preload_classes(CHECK);\n+    load_classes(CHECK);\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  static void preload_and_dump(TRAPS) NOT_CDS_RETURN;\n+  static void dump_static_archive(TRAPS) NOT_CDS_RETURN;\n@@ -82,2 +82,2 @@\n-  static void preload_and_dump_impl(StaticArchiveBuilder& builder, TRAPS) NOT_CDS_RETURN;\n-  static void preload_classes(TRAPS) NOT_CDS_RETURN;\n+  static void dump_static_archive_impl(StaticArchiveBuilder& builder, TRAPS) NOT_CDS_RETURN;\n+  static void load_classes(TRAPS) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotMetaspace.hpp\"\n+#include \"cds\/aotOopChecker.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+oop AOTOopChecker::get_oop_field(oop obj, const char* name, const char* sig) {\n+  Symbol* name_sym = SymbolTable::probe(name, checked_cast<int>(strlen(name)));\n+  assert(name_sym != nullptr, \"Symbol must have been resolved for an existing field of this obj\");\n+  Symbol* sig_sym = SymbolTable::probe(sig, checked_cast<int>(strlen(sig)));\n+  assert(sig_sym != nullptr, \"Symbol must have been resolved for an existing field of this obj\");\n+\n+  fieldDescriptor fd;\n+  Klass* k = InstanceKlass::cast(obj->klass())->find_field(name_sym, sig_sym, &fd);\n+  assert(k != nullptr, \"field must exist\");\n+  precond(!fd.is_static());\n+  precond(fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY);\n+  return obj->obj_field(fd.offset());\n+}\n+\n+\/\/ Make sure we are not caching objects with assumptions that can be violated in\n+\/\/ the production run.\n+void AOTOopChecker::check(oop obj) {\n+  \/\/ Currently we only check URL objects, but more rules may be added in the future.\n+\n+  if (obj->klass()->is_subclass_of(vmClasses::URL_klass())) {\n+    \/\/ If URL could be subclassed, obj may have new fields that we don't know about.\n+    precond(vmClasses::URL_klass()->is_final());\n+\n+    \/\/ URLs are referenced by the CodeSources\/ProtectDomains that are cached\n+    \/\/ for AOT-linked classes loaded by the platform\/app loaders.\n+    \/\/\n+    \/\/ Do not cache any URLs whose URLStreamHandler can be overridden by the application.\n+    \/\/ - \"jrt\" and \"file\" will always use the built-in URLStreamHandler. See\n+    \/\/   java.net.URL::isOverrideable().\n+    \/\/ -  When an AOT-linked class is loaded from a JAR file, its URL is something\n+    \/\/    like file:HelloWorl.jar, and does NOT use the \"jar\" protocol.\n+    oop protocol = get_oop_field(obj, \"protocol\", \"Ljava\/lang\/String;\");\n+    if (!java_lang_String::equals(protocol, \"jrt\", 3) &&\n+        !java_lang_String::equals(protocol, \"file\", 4)) {\n+      ResourceMark rm;\n+      log_error(aot)(\"Must cache only URLs with jrt\/file protocols but got: %s\",\n+                     java_lang_String::as_quoted_ascii(protocol));\n+      HeapShared::debug_trace();\n+      AOTMetaspace::unrecoverable_writing_error();\n+    }\n+  }\n+}\n+\n+#endif \/\/INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/aotOopChecker.cpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTOOPCHECKER_HPP\n+#define SHARE_CDS_AOTOOPCHECKER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class AOTOopChecker : AllStatic {\n+  static oop get_oop_field(oop obj, const char* name, const char* sig);\n+\n+public:\n+  \/\/ obj is an object that's about to be stored into the AOT cache. Check if it\n+  \/\/ can be safely cached.\n+  static void check(oop obj);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTOOPCHECKER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotOopChecker.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -70,1 +70,2 @@\n-  return (is_dumping_archive()              ? IS_DUMPING_ARCHIVE : 0) |\n+  return (is_dumping_aot_linked_classes()   ? IS_DUMPING_AOT_LINKED_CLASSES : 0) |\n+         (is_dumping_archive()              ? IS_DUMPING_ARCHIVE : 0) |\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,5 +83,6 @@\n-  static const int IS_DUMPING_ARCHIVE              = 1 << 0;\n-  static const int IS_DUMPING_METHOD_HANDLES       = 1 << 1;\n-  static const int IS_DUMPING_STATIC_ARCHIVE       = 1 << 2;\n-  static const int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 3;\n-  static const int IS_USING_ARCHIVE                = 1 << 4;\n+  static const int IS_DUMPING_AOT_LINKED_CLASSES   = 1 << 0;\n+  static const int IS_DUMPING_ARCHIVE              = 1 << 1;\n+  static const int IS_DUMPING_METHOD_HANDLES       = 1 << 2;\n+  static const int IS_DUMPING_STATIC_ARCHIVE       = 1 << 3;\n+  static const int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 4;\n+  static const int IS_USING_ARCHIVE                = 1 << 5;\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -43,1 +43,3 @@\n-\/\/ -- Handling of Enum objects\n+\/\/ !!! This is legacy support for enum classes before JEP 483. This file is not used when\n+\/\/ !!! CDSConfig::is_initing_classes_at_dump_time()==true.\n+\/\/\n@@ -65,0 +67,1 @@\n+  assert(!CDSConfig::is_initing_classes_at_dump_time(), \"only for legacy support of enums\");\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+\/\/ This is legacy support for enum classes before JEP 483. This code is not needed when\n+\/\/ CDSConfig::is_initing_classes_at_dump_time()==true.\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  ADD_EXCL(\"java\/lang\/ClassLoader\",                      \"scl\");                   \/\/ A\n+  ADD_EXCL(\"java\/lang\/ClassLoader$Holder\",               \"scl\");                   \/\/ A\n@@ -149,0 +149,4 @@\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    ADD_EXCL(\"java\/lang\/Package$VersionInfo\",             \"NULL_VERSION_INFO\");    \/\/ D\n+  }\n+\n@@ -230,4 +234,10 @@\n-        if (field_ik == vmClasses::internal_Unsafe_klass() && ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n-          \/\/ There's only a single instance of jdk\/internal\/misc\/Unsafe, so all references will\n-          \/\/ be pointing to this singleton, which has been archived.\n-          return;\n+        if (ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+          if (field_ik == vmClasses::internal_Unsafe_klass()) {\n+            \/\/ There's only a single instance of jdk\/internal\/misc\/Unsafe, so all references will\n+            \/\/ be pointing to this singleton, which has been archived.\n+            return;\n+          }\n+          if (field_ik == vmClasses::Boolean_klass()) {\n+            \/\/ TODO: check if is TRUE or FALSE\n+            return;\n+          }\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -446,2 +446,0 @@\n-      assert(!oak->is_typeArray_klass(), \"all type array classes must be in static archive\");\n-\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/aotOopChecker.hpp\"\n@@ -303,0 +304,2 @@\n+    AOTOopChecker::check(obj); \/\/ Make sure contents of this oop are safe.\n+\n@@ -588,1 +591,1 @@\n-static void copy_java_mirror_hashcode(oop orig_mirror, oop scratch_m) {\n+void HeapShared::copy_java_mirror(oop orig_mirror, oop scratch_m) {\n@@ -604,0 +607,5 @@\n+\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    java_lang_Class::set_module(scratch_m, java_lang_Class::module(orig_mirror));\n+    java_lang_Class::set_protection_domain(scratch_m, java_lang_Class::protection_domain(orig_mirror));\n+  }\n@@ -701,1 +709,1 @@\n-    copy_java_mirror_hashcode(orig_mirror, m);\n+    copy_java_mirror(orig_mirror, m);\n@@ -1612,2 +1620,2 @@\n-    \/\/ The enum klasses are archived with aot-initialized mirror.\n-    \/\/ See AOTClassInitializer::can_archive_initialized_mirror().\n+    \/\/ The classes of all archived enum instances have been marked as aot-init,\n+    \/\/ so there's nothing else to be done in the production run.\n@@ -1615,0 +1623,2 @@\n+    \/\/ This is legacy support for enum classes before JEP 483 -- we cannot rerun\n+    \/\/ the enum's <clinit> in the production run, so special handling is needed.\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -342,0 +342,1 @@\n+  static void copy_java_mirror(oop orig_mirror, oop scratch_m);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -283,0 +283,13 @@\n+\/\/ This is called before AOTLinkedClassBulkLoader starts preloading classes. It makes sure that\n+\/\/ when we preload any class, its module is already valid.\n+void ClassLoaderDataShared::restore_archived_modules_for_preloading_classes(JavaThread* current) {\n+  precond(CDSConfig::is_using_aot_linked_classes());\n+\n+  precond(_platform_loader_root_index >= 0);\n+  precond(_system_loader_root_index >= 0);\n+\n+  Handle h_platform_loader(current, HeapShared::get_root(_platform_loader_root_index));\n+  Handle h_system_loader(current, HeapShared::get_root(_system_loader_root_index));\n+  Modules::init_archived_modules(current, h_platform_loader, h_system_loader);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -40,0 +41,1 @@\n+  static void restore_archived_modules_for_preloading_classes(JavaThread* current) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1016,0 +1016,9 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    oop archived_module = java_lang_Class::module(mirror());\n+    if (archived_module != nullptr) {\n+      precond(module() == nullptr || module() == archived_module);\n+      precond(AOTMetaspace::in_aot_cache_static_region((void*)k));\n+      return;\n+    }\n+  }\n+\n@@ -1022,0 +1031,4 @@\n+    \/\/ With AOT-linked classes, java.base should have been defined before the\n+    \/\/ VM loads any classes.\n+    precond(!CDSConfig::is_using_aot_linked_classes());\n+\n@@ -1055,7 +1068,13 @@\n-  GrowableArray<Klass*>* mirror_list =\n-    new (mtClass) GrowableArray<Klass*>(40, mtClass);\n-  set_fixup_mirror_list(mirror_list);\n-\n-  GrowableArray<Klass*>* module_list =\n-    new (mtModule) GrowableArray<Klass*>(500, mtModule);\n-  set_fixup_module_field_list(module_list);\n+  if (!CDSConfig::is_using_aot_linked_classes()) {\n+    \/\/ fixup_mirror_list() is not used when we have preloaded classes. See\n+    \/\/ Universe::fixup_mirrors().\n+    GrowableArray<Klass*>* mirror_list =\n+      new (mtClass) GrowableArray<Klass*>(40, mtClass);\n+    set_fixup_mirror_list(mirror_list);\n+\n+    \/\/ With AOT-linked classes, java.base module is defined before any class\n+    \/\/ is loaded, so there's no need for fixup_module_field_list().\n+    GrowableArray<Klass*>* module_list =\n+      new (mtModule) GrowableArray<Klass*>(500, mtModule);\n+    set_fixup_module_field_list(module_list);\n+  }\n@@ -1161,0 +1180,1 @@\n+    assert(!CDSConfig::is_using_aot_linked_classes(), \"should not come here\");\n@@ -1206,1 +1226,1 @@\n-  if (!vmClasses::Class_klass_loaded()) {\n+  if (!vmClasses::Class_klass_loaded() && !CDSConfig::is_using_aot_linked_classes()) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -237,0 +237,1 @@\n+  friend class HeapShared;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -700,0 +700,2 @@\n+  assert(!CDSConfig::is_using_aot_linked_classes(), \"patching is not necessary with AOT-linked classes\");\n+\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -703,0 +703,20 @@\n+  if (h_platform_loader.is_null()) {\n+    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null platform loader object\");\n+  }\n+\n+  if (h_system_loader.is_null()) {\n+    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null system loader object\");\n+  }\n+\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    \/\/ Already initialized\n+    precond(SystemDictionary::java_platform_loader() == h_platform_loader());\n+    precond(SystemDictionary::java_system_loader() == h_system_loader());\n+  } else {\n+    init_archived_modules(THREAD, h_platform_loader, h_system_loader);\n+  }\n+}\n+\n+void Modules::init_archived_modules(JavaThread* current, Handle h_platform_loader, Handle h_system_loader) {\n+  assert(CDSConfig::is_using_full_module_graph(), \"must be\");\n+  ExceptionMark em(current);\n@@ -711,6 +731,3 @@\n-  Handle java_base_module(THREAD, ClassLoaderDataShared::restore_archived_oops_for_null_class_loader_data());\n-  \/\/ Patch any previously loaded class's module field with java.base's java.lang.Module.\n-  ModuleEntryTable::patch_javabase_entries(THREAD, java_base_module);\n-\n-  if (h_platform_loader.is_null()) {\n-    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null platform loader object\");\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    ClassLoaderData* boot_loader_data = ClassLoaderData::the_null_class_loader_data();\n+    ClassLoaderDataShared::archived_boot_unnamed_module()->restore_archived_oops(boot_loader_data);\n@@ -719,2 +736,4 @@\n-  if (h_system_loader.is_null()) {\n-    THROW_MSG(vmSymbols::java_lang_NullPointerException(), \"Null system loader object\");\n+  Handle java_base_module(current, ClassLoaderDataShared::restore_archived_oops_for_null_class_loader_data());\n+  if (!CDSConfig::is_using_aot_linked_classes()) {\n+    \/\/ Patch any previously loaded class's module field with java.base's java.lang.Module.\n+    ModuleEntryTable::patch_javabase_entries(current, java_base_module);\n@@ -780,1 +799,3 @@\n-    unnamed_module->restore_archived_oops(boot_loader_data);\n+    if (!CDSConfig::is_using_aot_linked_classes()) {\n+      unnamed_module->restore_archived_oops(boot_loader_data);\n+    }\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":30,"deletions":9,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -60,0 +60,2 @@\n+  static void init_archived_modules(JavaThread* current, Handle h_platform_loader, Handle h_system_loader)\n+                                   NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,3 +199,5 @@\n-  assert(_java_system_loader.is_empty(), \"already set!\");\n-  _java_system_loader = cld->class_loader_handle();\n-\n+  if (_java_system_loader.is_empty()) {\n+    _java_system_loader = cld->class_loader_handle();\n+  } else {\n+    assert(_java_system_loader.resolve() == cld->class_loader(), \"sanity\");\n+  }\n@@ -205,2 +207,5 @@\n-  assert(_java_platform_loader.is_empty(), \"already set!\");\n-  _java_platform_loader = cld->class_loader_handle();\n+  if (_java_platform_loader.is_empty()) {\n+    _java_platform_loader = cld->class_loader_handle();\n+  } else {\n+    assert(_java_platform_loader.resolve() == cld->class_loader(), \"sanity\");\n+  }\n@@ -1152,0 +1157,52 @@\n+\/\/ This is much more lightweight than SystemDictionary::resolve_or_null\n+\/\/ - There's only a single Java thread at this point. No need for placeholder.\n+\/\/ - All supertypes of ik have been loaded\n+\/\/ - There's no circularity (checked in AOT assembly phase)\n+\/\/ - There's no need to call java.lang.ClassLoader::load_class() because the boot\/platform\/app\n+\/\/   loaders are well-behaved\n+void SystemDictionary::preload_class(Handle class_loader, InstanceKlass* ik, TRAPS) {\n+  precond(Universe::is_bootstrapping());\n+  precond(java_platform_loader() != nullptr && java_system_loader() != nullptr);\n+  precond(class_loader() == nullptr || class_loader() == java_platform_loader() ||class_loader() == java_system_loader());\n+  precond(CDSConfig::is_using_aot_linked_classes());\n+  precond(AOTMetaspace::in_aot_cache_static_region((void*)ik));\n+  precond(!ik->is_loaded());\n+\n+#ifdef ASSERT\n+  \/\/ preload_class() must be called in the correct order -- all super types must have\n+  \/\/ already been loaded.\n+  if (ik->java_super() != nullptr) {\n+    assert(ik->java_super()->is_loaded(), \"must be\");\n+  }\n+\n+  Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n+  int num_interfaces = interfaces->length();\n+  for (int index = 0; index < num_interfaces; index++) {\n+    assert(interfaces->at(index)->is_loaded(), \"must be\");\n+  }\n+#endif\n+\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(class_loader());\n+  oop java_mirror = ik->archived_java_mirror();\n+  precond(java_mirror != nullptr);\n+\n+  Handle pd(THREAD, java_lang_Class::protection_domain(java_mirror));\n+  PackageEntry* pkg_entry = ik->package();\n+  assert(pkg_entry != nullptr || ClassLoader::package_from_class_name(ik->name()) == nullptr,\n+         \"non-empty packages must have been archived\");\n+\n+  \/\/ TODO: the following assert requires JDK-8365580\n+  \/\/ assert(is_shared_class_visible(ik->name(), ik, pkg_entry, class_loader), \"must be\");\n+\n+  ik->restore_unshareable_info(loader_data, pd, pkg_entry, CHECK);\n+  load_shared_class_misc(ik, loader_data);\n+  ik->add_to_hierarchy(THREAD);\n+\n+  if (!ik->is_hidden()) {\n+    update_dictionary(THREAD, ik, loader_data);\n+  }\n+\n+  assert(java_lang_Class::module(java_mirror) != nullptr, \"must have been archived\");\n+  assert(ik->is_loaded(), \"Must be in at least loaded state\");\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":62,"deletions":5,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-  \/\/ Used by SystemDictionaryShared and LambdaProxyClassDictionary\n+  \/\/ Used by AOTLinkedClassBulkLoader, LambdaProxyClassDictionary, and SystemDictionaryShared\n@@ -340,0 +340,1 @@\n+  static void preload_class(Handle class_loader, InstanceKlass* ik, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,1 +104,5 @@\n-    resolve(id, CHECK);\n+    if (CDSConfig::is_using_aot_linked_classes()) {\n+      precond(klass_at(id)->is_loaded());\n+    } else {\n+      resolve(id, CHECK);\n+    }\n@@ -118,0 +122,4 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    AOTLinkedClassBulkLoader::preload_classes(THREAD);\n+  }\n+\n@@ -213,3 +221,0 @@\n-  if (CDSConfig::is_using_aot_linked_classes()) {\n-    AOTLinkedClassBulkLoader::load_javabase_classes(THREAD);\n-  }\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -855,7 +855,0 @@\n-#if INCLUDE_JVMCI\n-  if (EnableJVMCI && UseJVMCICompiler &&\n-      comp_level == CompLevel_full_optimization CDS_ONLY(&& !AOTLinkedClassBulkLoader::class_preloading_finished())) {\n-    return nullptr;\n-  }\n-#endif\n-\n@@ -1449,6 +1442,1 @@\n-#if INCLUDE_JVMCI\n-  if (EnableJVMCI && UseJVMCICompiler &&\n-      next_level == CompLevel_full_optimization CDS_ONLY(&& !AOTLinkedClassBulkLoader::class_preloading_finished())) {\n-    next_level = cur_level;\n-  }\n-#endif\n+\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -54,6 +53,1 @@\n-  ClassLoaderData* cld = k->class_loader_data();\n-  if (cld != nullptr) {\n-    ClaimMetadataVisitingOopIterateClosure::do_cld(cld);\n-  } else {\n-    assert(AOTLinkedClassBulkLoader::is_pending_aot_linked_class(k), \"sanity\");\n-  }\n+  ClaimMetadataVisitingOopIterateClosure::do_cld(k->class_loader_data());\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -586,0 +586,5 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    \/\/ All mirrors of preloaded classes are already restored. No need to fix up.\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -453,1 +453,1 @@\n-    AOTMetaspace::preload_and_dump(thread);\n+    AOTMetaspace::dump_static_archive(thread);\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -775,1 +775,1 @@\n-    AOTLinkedClassBulkLoader::finish_loading_javabase_classes(CHECK_JNI_ERR);\n+    AOTLinkedClassBulkLoader::link_or_init_javabase_classes(THREAD);\n@@ -794,1 +794,1 @@\n-    AOTLinkedClassBulkLoader::load_non_javabase_classes(THREAD);\n+    AOTLinkedClassBulkLoader::link_or_init_non_javabase_classes(THREAD);\n@@ -892,1 +892,1 @@\n-    AOTMetaspace::preload_and_dump(CHECK_JNI_ERR);\n+    AOTMetaspace::dump_static_archive(CHECK_JNI_ERR);\n@@ -895,1 +895,1 @@\n-    AOTMetaspace::preload_and_dump(CHECK_JNI_ERR);\n+    AOTMetaspace::dump_static_archive(CHECK_JNI_ERR);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import jdk.internal.misc.CDS;\n@@ -68,0 +69,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -224,0 +227,1 @@\n+@AOTSafeClassInitializer\n@@ -228,0 +232,5 @@\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n@@ -1861,2 +1870,2 @@\n-                assert VM.isBooted() && scl != null;\n-                return scl;\n+                assert VM.isBooted() && Holder.scl != null;\n+                return Holder.scl;\n@@ -1887,1 +1896,1 @@\n-        if (scl != null) {\n+        if (Holder.scl != null) {\n@@ -1898,1 +1907,1 @@\n-                scl = (ClassLoader) ctor.newInstance(builtinLoader);\n+                Holder.scl = (ClassLoader) ctor.newInstance(builtinLoader);\n@@ -1913,1 +1922,1 @@\n-            scl = builtinLoader;\n+            Holder.scl = builtinLoader;\n@@ -1915,1 +1924,1 @@\n-        return scl;\n+        return Holder.scl;\n@@ -1928,3 +1937,7 @@\n-    \/\/ The system class loader\n-    \/\/ @GuardedBy(\"ClassLoader.class\")\n-    private static volatile ClassLoader scl;\n+    \/\/ Holder has the field(s) that need to be initialized during JVM bootstrap even if\n+    \/\/ the outer is aot-initialized.\n+    private static class Holder {\n+        \/\/ The system class loader\n+        \/\/ @GuardedBy(\"ClassLoader.class\")\n+        private static volatile ClassLoader scl;\n+    }\n@@ -2605,1 +2618,15 @@\n-        reinitObjectField(\"packages\", new ConcurrentHashMap<>());\n+\n+        if (CDS.isDumpingAOTLinkedClasses()) {\n+            if (System.getProperty(\"cds.debug.archived.packages\") != null) {\n+                for (Map.Entry<String, NamedPackage> entry : packages.entrySet()) {\n+                    String key = entry.getKey();\n+                    NamedPackage value = entry.getValue();\n+                    System.out.println(\"Archiving \" +\n+                                       (value instanceof Package ? \"Package\" : \"NamedPackage\") +\n+                                       \" \\\"\" + key + \"\\\" for \" + this);\n+                }\n+            }\n+        } else {\n+            reinitObjectField(\"packages\", new ConcurrentHashMap<>());\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -94,0 +96,1 @@\n+@AOTSafeClassInitializer\n@@ -2668,0 +2671,5 @@\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/ModuleDescriptor.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -519,0 +521,1 @@\n+@AOTSafeClassInitializer\n@@ -3729,0 +3732,1 @@\n+\n@@ -3730,0 +3734,5 @@\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/net\/URI.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import jdk.internal.vm.annotation.AOTRuntimeSetup;\n+import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n@@ -217,0 +219,1 @@\n+@AOTSafeClassInitializer\n@@ -1761,0 +1764,5 @@\n+        runtimeSetup();\n+    }\n+\n+    @AOTRuntimeSetup\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/java\/net\/URL.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.misc.CDS;\n@@ -246,1 +247,15 @@\n-        pdcache.clear();\n+        if (CDS.isDumpingAOTLinkedClasses()) {\n+            for (CodeSourceKey key : pdcache.keySet()) {\n+                if (key.cs.getCodeSigners() != null) {\n+                    \/\/ We don't archive any signed classes, so we don't need to cache their ProtectionDomains.\n+                    pdcache.remove(key);\n+                }\n+            }\n+            if (System.getProperty(\"cds.debug.archived.protection.domains\") != null) {\n+                for (CodeSourceKey key : pdcache.keySet()) {\n+                    System.out.println(\"Archiving ProtectionDomain \" + key.cs + \" for \" + this);\n+                }\n+            }\n+        } else {\n+            pdcache.clear();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureClassLoader.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -78,3 +78,7 @@\n-    \/\/ native libraries loaded by the boot class loader\n-    private static final NativeLibraries NATIVE_LIBS\n-        = NativeLibraries.newInstance(null);\n+    \/\/ Holder has the field(s) that need to be initialized during JVM bootstrap even if\n+    \/\/ the outer is aot-initialized.\n+    private static class Holder {\n+        \/\/ native libraries loaded by the boot class loader\n+        private static final NativeLibraries NATIVE_LIBS\n+            = NativeLibraries.newInstance(null);\n+    }\n@@ -107,1 +111,1 @@\n-        return NATIVE_LIBS;\n+        return Holder.NATIVE_LIBS;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/BootLoader.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-            if (loadedLibraryNames.contains(name)) {\n+            if (Holder.loadedLibraryNames.contains(name)) {\n@@ -206,1 +206,1 @@\n-            loadedLibraryNames.add(name);\n+            Holder.loadedLibraryNames.add(name);\n@@ -246,0 +246,5 @@\n+    \/\/ Called at the end of AOTCache assembly phase.\n+    public void clear() {\n+        libraries.clear();\n+    }\n+\n@@ -371,1 +376,1 @@\n-                if (!loadedLibraryNames.remove(name)) {\n+                if (!Holder.loadedLibraryNames.remove(name)) {\n@@ -398,2 +403,5 @@\n-    \/\/ All native libraries we've loaded.\n-    private static final Set<String> loadedLibraryNames =\n+    \/\/ Holder has the fields that need to be initialized during JVM bootstrap even if\n+    \/\/ the outer is aot-initialized.\n+    static class Holder {\n+        \/\/ All native libraries we've loaded.\n+        private static final Set<String> loadedLibraryNames =\n@@ -401,0 +409,1 @@\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -50,5 +50,7 @@\n-    private static final int IS_DUMPING_ARCHIVE              = 1 << 0;\n-    private static final int IS_DUMPING_METHOD_HANDLES       = 1 << 1;\n-    private static final int IS_DUMPING_STATIC_ARCHIVE       = 1 << 2;\n-    private static final int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 3;\n-    private static final int IS_USING_ARCHIVE                = 1 << 4;\n+    private static final int IS_DUMPING_AOT_LINKED_CLASSES   = 1 << 0;\n+    private static final int IS_DUMPING_ARCHIVE              = 1 << 1;\n+    private static final int IS_DUMPING_METHOD_HANDLES       = 1 << 2;\n+    private static final int IS_DUMPING_STATIC_ARCHIVE       = 1 << 3;\n+    private static final int IS_LOGGING_LAMBDA_FORM_INVOKERS = 1 << 4;\n+    private static final int IS_USING_ARCHIVE                = 1 << 5;\n+\n@@ -85,0 +87,4 @@\n+    public static boolean isDumpingAOTLinkedClasses() {\n+        return (configStatus & IS_DUMPING_AOT_LINKED_CLASSES) != 0;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -20,0 +20,4 @@\n+\n+# These tests fail often with AotJdk due to JDK-8323727\n+compiler\/arguments\/TestStressReflectiveCode.java 8323727 generic-all\n+compiler\/arraycopy\/TestCloneWithStressReflectiveCode.java 8323727 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-AotJdk.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ *             InterfaceWithEnum EnumWithClinit\n@@ -104,0 +105,5 @@\n+\n+            \/\/ For MethodHandleTestApp.testLambdaWithEnums()\n+            if (runMode == RunMode.ASSEMBLY) {\n+                out.shouldNotContain(\"EnumWithClinit.<clinit>\");\n+            }\n@@ -209,0 +215,2 @@\n+        testLambdaWithEnums();\n+\n@@ -278,0 +286,23 @@\n+\n+\n+    static boolean InterfaceWithEnum_inited = false;\n+\n+    \/\/ Enum types used in lambdas shouldn't be initialized during the assembly phase.\n+    static void testLambdaWithEnums() {\n+        if (InterfaceWithEnum_inited) {\n+            throw new RuntimeException(\"InterfaceWithEnum should not be inited\");\n+        }\n+\n+        InterfaceWithEnum iwe = (x) -> {\n+            System.out.println(\"Hello from testLambdaWithEnums\");\n+        };\n+\n+        System.out.println(iwe);\n+        if (InterfaceWithEnum_inited) {\n+            throw new RuntimeException(\"InterfaceWithEnum should not be inited\");\n+        }\n+        iwe.func(EnumWithClinit.Dummy);\n+        if (!InterfaceWithEnum_inited) {\n+            throw new RuntimeException(\"InterfaceWithEnum should be inited\");\n+        }\n+    }\n@@ -335,0 +366,12 @@\n+interface InterfaceWithEnum {\n+    void func(EnumWithClinit e);\n+}\n+\n+enum EnumWithClinit {\n+    Dummy;\n+    static {\n+        MethodHandleTestApp.InterfaceWithEnum_inited = true;\n+        System.out.println(\"EnumWithClinit.<clinit>\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/MethodHandleTest.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"}]}