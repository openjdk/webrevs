{"files":[{"patch":"@@ -399,0 +399,2 @@\n+ -runtime\/Monitor\/StressWrapper_TestRecursiveLocking_36M.java \\\n+ -runtime\/Monitor\/TestRecursiveLocking.java \\\n@@ -602,0 +604,1 @@\n+ -runtime\/Monitor\/StressWrapper_TestRecursiveLocking_36M.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=Xint_outer_inner\n+ * @requires vm.flagless\n+ * @summary Tests recursive locking in -Xint in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\/\n+\n+\/*\n+ * @test id=Xint_alternate_AB\n+ * @requires vm.flagless\n+ * @summary Tests recursive locking in -Xint in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\/\n+\n+\/*\n+ * @test id=C1_outer_inner\n+ * @requires vm.flagless\n+ * @requires vm.compiler1.enabled\n+ * @summary Tests recursive locking in C1 in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\/\n+\n+\/*\n+ * @test id=C1_alternate_AB\n+ * @requires vm.flagless\n+ * @requires vm.compiler1.enabled\n+ * @summary Tests recursive locking in C1 in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\/\n+\n+\/*\n+ * @test id=C2_outer_inner\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests recursive locking in C2 in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 1\n+ *\/\n+\n+\/*\n+ * @test id=C2_alternate_AB\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests recursive locking in C2 in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=0\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=1\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\n+ * @run main\/othervm\/timeout=240 -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=2\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 120 2\n+ *\/\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/StressWrapper_TestRecursiveLocking_36M.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,560 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=Xint_outer_inner\n+ * @requires vm.flagless\n+ * @summary Tests recursive locking in -Xint in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\/\n+\n+\/*\n+ * @test id=Xint_alternate_AB\n+ * @requires vm.flagless\n+ * @summary Tests recursive locking in -Xint in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -Xint\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\/\n+\n+\/*\n+ * @test id=C1_outer_inner\n+ * @requires vm.flagless\n+ * @requires vm.compiler1.enabled\n+ * @summary Tests recursive locking in C1 in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\/\n+\n+\/*\n+ * @test id=C1_alternate_AB\n+ * @requires vm.flagless\n+ * @requires vm.compiler1.enabled\n+ * @summary Tests recursive locking in C1 in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:TieredStopAtLevel=1\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\/\n+\n+\/*\n+ * @test id=C2_outer_inner\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests recursive locking in C2 in outer then inner mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=0\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=1\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:-EliminateNestedLocks\n+ *     -XX:LockingMode=2\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 1\n+ *\/\n+\n+\/*\n+ * @test id=C2_alternate_AB\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled\n+ * @summary Tests recursive locking in C2 in alternate A and B mode.\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=0\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=1\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:.\n+ *     -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *     -XX:LockingMode=2\n+ *     -XX:-EliminateNestedLocks\n+ *     -ms256m -mx256m\n+ *     TestRecursiveLocking 5 2\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.whitebox.WhiteBox;\n+import jtreg.SkippedException;\n+\n+public class TestRecursiveLocking {\n+    static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    static final int flagLockingMode = WB.getIntVMFlag(\"LockingMode\").intValue();\n+    static final int constLockStackCapacity = WB.getLockStackCapacity();\n+    static final int LM_MONITOR = 0;\n+    static final int LM_LEGACY = 1;\n+    static final int LM_LIGHTWEIGHT = 2;\n+    static final SyncThread syncThread = new SyncThread();\n+\n+    \/\/ This SynchronizedObject class and the OUTER followed by INNER testing\n+    \/\/ model is adapted from runtime\/lockStack\/TestLockStackCapacity.java.\n+    static class SynchronizedObject {\n+        private int counter;\n+\n+        synchronized void runInner(int depth, SynchronizedObject outer) {\n+            counter++;\n+\n+            \/\/ Legacy mode has no lock stack. I.e. there is no limit\n+            \/\/ on recursion, so for legacy mode we can't say that\n+            \/\/ \"outer\" must be inflated here, which we can say for all\n+            \/\/ the other locking modes.\n+            if (flagLockingMode != LM_LEGACY) {\n+                outer.assertInflated();\n+            }\n+\n+            \/\/ We havn't reached the stack lock capasity (recursion\n+            \/\/ level), so we shouldn't be inflated here. Except for\n+            \/\/ monitor mode, which is always inflated.\n+            if (flagLockingMode != LM_MONITOR) {\n+                assertNotInflated();\n+            }\n+            if (depth == 1) {\n+                return;\n+            } else {\n+                runInner(depth - 1, outer);\n+            }\n+            if (flagLockingMode != LM_MONITOR) {\n+                assertNotInflated();\n+            }\n+        }\n+\n+        synchronized void runOuter(int depth, SynchronizedObject inner) {\n+            counter++;\n+\n+            if (flagLockingMode != LM_MONITOR) {\n+                assertNotInflated();\n+            }\n+            if (depth == 1) {\n+                inner.runInner(constLockStackCapacity, this);\n+            } else {\n+                runOuter(depth - 1, inner);\n+            }\n+            if (flagLockingMode != LM_LEGACY) {\n+                assertInflated();\n+            }\n+        }\n+\n+        \/\/ This test nests x recurcive locks of INNER, in x recursive\n+        \/\/ locks of OUTER.  The number x is taken from the max number\n+        \/\/ of elements in the lock stack.\n+        public void runOuterInnerTest() {\n+            final SynchronizedObject OUTER = new SynchronizedObject();\n+            final SynchronizedObject INNER = new SynchronizedObject();\n+\n+            \/\/ Just checking since they are new objects:\n+            OUTER.assertNotInflated();\n+            INNER.assertNotInflated();\n+\n+            synchronized (OUTER) {\n+                OUTER.counter++;\n+\n+                if (flagLockingMode != LM_MONITOR) {\n+                    OUTER.assertNotInflated();\n+                }\n+                INNER.assertNotInflated();\n+                OUTER.runOuter(constLockStackCapacity - 1, INNER);\n+\n+                if (flagLockingMode != LM_LEGACY) {\n+                    OUTER.assertInflated();\n+                }\n+                if (flagLockingMode != LM_MONITOR) {\n+                    INNER.assertNotInflated();\n+                }\n+            }\n+\n+            \/\/ Verify that the nested monitors have been properly released:\n+            syncThread.verifyCanBeSynced(OUTER);\n+            syncThread.verifyCanBeSynced(INNER);\n+\n+            Asserts.assertEquals(OUTER.counter, constLockStackCapacity);\n+            Asserts.assertEquals(INNER.counter, constLockStackCapacity);\n+        }\n+\n+        synchronized void runA(int depth, SynchronizedObject B) {\n+            counter++;\n+\n+            if (flagLockingMode == LM_LIGHTWEIGHT) {\n+                \/\/ First time we lock A, A is the only one on the lock\n+                \/\/ stack.\n+                if (counter == 1) {\n+                    assertNotInflated();\n+                } else {\n+                    \/\/ Second time we want to lock A, the lock stack\n+                    \/\/ looks like this [A, B].  Lightweight locking\n+                    \/\/ doesn't allow interleaving ([A, B, A]), instead\n+                    \/\/ it inflates A and removed it from the lock\n+                    \/\/ stack. Which leaves us with only [B] on the lock\n+                    \/\/ stack. After more recursions it will grow to\n+                    \/\/ [B, B ... B].\n+                    assertInflated();\n+                }\n+            } else if (flagLockingMode == LM_MONITOR) {\n+                assertInflated();\n+            }\n+\n+            \/\/ Call runB() at the same depth as runA's depth:\n+            B.runB(depth, this);\n+        }\n+\n+        synchronized void runB(int depth, SynchronizedObject A) {\n+            counter++;\n+\n+            if (flagLockingMode != LM_MONITOR) {\n+                \/\/ Legacy tolerates endless recursions. While testing\n+                \/\/ lightweight we don't go deeper than the size of the\n+                \/\/ lock stack, which in this test case will be filled\n+                \/\/ with a number of B-elements. See comment in runA()\n+                \/\/ above for more info.\n+                assertNotInflated();\n+            } else {\n+                assertInflated();\n+            }\n+\n+            if (depth == 1) {\n+                \/\/ Reached LockStackCapacity in depth so we're done.\n+                return;\n+            } else {\n+                A.runA(depth - 1, this);\n+            }\n+        }\n+\n+        \/\/ This test alternates by locking A and B.\n+        public void runAlternateABTest() {\n+            final SynchronizedObject A = new SynchronizedObject();\n+            final SynchronizedObject B = new SynchronizedObject();\n+\n+            \/\/ Just checking since they are new objects:\n+            A.assertNotInflated();\n+            B.assertNotInflated();\n+\n+            A.runA(constLockStackCapacity, B);\n+\n+            \/\/ Verify that the nested monitors have been properly released:\n+            syncThread.verifyCanBeSynced(A);\n+            syncThread.verifyCanBeSynced(B);\n+\n+            Asserts.assertEquals(A.counter, constLockStackCapacity);\n+            Asserts.assertEquals(B.counter, constLockStackCapacity);\n+            if (flagLockingMode == LM_LEGACY) {\n+                A.assertNotInflated();\n+            }\n+            \/\/ Implied else: for LM_MONITOR or LM_LIGHTWEIGHT it can be\n+            \/\/ either inflated or not point because A is not locked anymore\n+            \/\/ and subject to deflation.\n+\n+            if (flagLockingMode != LM_MONITOR) {\n+                B.assertNotInflated();\n+            }\n+        }\n+\n+        void assertNotInflated() {\n+            Asserts.assertFalse(WB.isMonitorInflated(this));\n+        }\n+\n+        void assertInflated() {\n+            Asserts.assertTrue(WB.isMonitorInflated(this));\n+        }\n+    }\n+\n+    static void usage() {\n+        System.err.println();\n+        System.err.println(\"Usage: java TestRecursiveLocking [n_secs]\");\n+        System.err.println(\"       java TestRecursiveLocking n_secs [mode]\");\n+        System.err.println();\n+        System.err.println(\"where:\");\n+        System.err.println(\"    n_secs  ::= > 0\");\n+        System.err.println(\"            Default n_secs is 15.\");\n+        System.err.println(\"    mode    ::= 1 - outer and inner\");\n+        System.err.println(\"            ::= 2 - alternate A and B\");\n+        System.err.println(\"            Default mode is 1.\");\n+        System.exit(1);\n+    }\n+\n+    public static void main(String... argv) throws Exception {\n+        int mode = 2;\n+        int n_secs = 30;\n+\n+        if (argv.length != 0 && argv.length != 1 && argv.length != 2) {\n+            usage();\n+        } else if (argv.length > 0) {\n+            try {\n+                n_secs = Integer.parseInt(argv[0]);\n+                if (n_secs <= 0) {\n+                    throw new NumberFormatException(\"Not > 0: '\" + argv[0]\n+                                                    + \"'\");\n+                }\n+            } catch (NumberFormatException nfe) {\n+                System.err.println();\n+                System.err.println(nfe);\n+                System.err.println(\"ERROR: '\" + argv[0]\n+                                   + \"': invalid n_secs value.\");\n+                usage();\n+            }\n+\n+            if (argv.length > 1) {\n+                try {\n+                    mode = Integer.parseInt(argv[1]);\n+                    if (mode != 1 && mode != 2) {\n+                        throw new NumberFormatException(\"Not 1 -> 2: '\"\n+                                                        + argv[1] + \"'\");\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    System.err.println();\n+                    System.err.println(nfe);\n+                    System.err.println(\"ERROR: '\" + argv[1]\n+                                       + \"': invalid mode value.\");\n+                    usage();\n+                }\n+            }\n+        }\n+\n+        System.out.println(\"INFO: LockingMode=\" + flagLockingMode);\n+        System.out.println(\"INFO: LockStackCapacity=\" + constLockStackCapacity);\n+        System.out.println(\"INFO: n_secs=\" + n_secs);\n+        System.out.println(\"INFO: mode=\" + mode);\n+\n+        long loopCount = 0;\n+        long endTime = System.currentTimeMillis() + n_secs * 1000;\n+\n+        syncThread.waitForStart();\n+\n+        while (System.currentTimeMillis() < endTime) {\n+            loopCount++;\n+            SynchronizedObject syncObj = new SynchronizedObject();\n+            switch (mode) {\n+            case 1:\n+                syncObj.runOuterInnerTest();\n+                break;\n+\n+            case 2:\n+                syncObj.runAlternateABTest();\n+                break;\n+\n+            default:\n+                throw new RuntimeException(\"bad mode parameter: \" + mode);\n+            }\n+        }\n+\n+        syncThread.setDone();\n+        try {\n+            syncThread.join();\n+        } catch (InterruptedException ie) {\n+            \/\/ This should not happen.\n+            ie.printStackTrace();\n+        }\n+\n+        System.out.println(\"INFO: main executed \" + loopCount + \" loops in \"\n+                           + n_secs + \" seconds.\");\n+    }\n+}\n+\n+class SyncThread extends Thread {\n+    static final boolean verbose = false;  \/\/ set to true for debugging\n+    private boolean done = false;\n+    private boolean haveWork = false;\n+    private Object obj;\n+    private Object waiter = new Object();\n+\n+    public void run() {\n+        if (verbose) System.out.println(\"SyncThread: running.\");\n+        synchronized (waiter) {\n+            \/\/ Let main know that we are running:\n+            if (verbose) System.out.println(\"SyncThread: notify main running.\");\n+            waiter.notify();\n+\n+            while (!done) {\n+                if (verbose) System.out.println(\"SyncThread: waiting.\");\n+                try {\n+                    waiter.wait();\n+                } catch (InterruptedException ie) {\n+                }\n+                if (haveWork) {\n+                    if (verbose) System.out.println(\"SyncThread: working.\");\n+                    synchronized (obj) {\n+                    }\n+                    if (verbose) System.out.println(\"SyncThread: worked.\");\n+                    haveWork = false;\n+                    waiter.notify();\n+                    if (verbose) System.out.println(\"SyncThread: notified.\");\n+                }\n+                else if (verbose) {\n+                    System.out.println(\"SyncThread: notified without work.\");\n+                }\n+            }\n+        }\n+        if (verbose) System.out.println(\"SyncThread: exiting.\");\n+    }\n+\n+    public void setDone() {\n+        synchronized (waiter) {\n+            if (verbose) System.out.println(\"main: set done.\");\n+            done = true;\n+            waiter.notify();\n+        }\n+    }\n+\n+    public void verifyCanBeSynced(Object obj) {\n+        synchronized (waiter) {\n+            if (verbose) System.out.println(\"main: queueing up work.\");\n+            this.obj = obj;\n+            haveWork = true;\n+            if (verbose) System.out.println(\"main: notifying SyncThread.\");\n+            waiter.notify();\n+            if (verbose) System.out.println(\"main: waiting for SyncThread.\");\n+            while (haveWork) {\n+                try {\n+                    waiter.wait();\n+                } catch (InterruptedException ie) {\n+                }\n+            }\n+            if (verbose) System.out.println(\"main: waited for SyncThread.\");\n+        }\n+    }\n+\n+    public void waitForStart() {\n+        synchronized (waiter) {\n+            this.start();\n+\n+            \/\/ Wait for SyncThread to actually get running:\n+            if (verbose) System.out.println(\"main: wait for SyncThread start.\");\n+            try {\n+                waiter.wait();\n+            } catch (InterruptedException ie) {\n+            }\n+            if (verbose) System.out.println(\"main: waited for SyncThread start.\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/TestRecursiveLocking.java","additions":560,"deletions":0,"binary":false,"changes":560,"status":"added"}]}