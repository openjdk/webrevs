{"files":[{"patch":"@@ -804,1 +804,0 @@\n-                                         VMRegPair *regs2,\n@@ -806,1 +805,0 @@\n-  assert(regs2 == nullptr, \"not needed on AArch64\");\n@@ -900,1 +898,0 @@\n-                                         VMRegPair *regs2,\n@@ -903,1 +900,1 @@\n-  int result = c_calling_convention_priv(sig_bt, regs, regs2, total_args_passed);\n+  int result = c_calling_convention_priv(sig_bt, regs, total_args_passed);\n@@ -1459,1 +1456,1 @@\n-  out_arg_slots = c_calling_convention_priv(out_sig_bt, out_regs, nullptr, total_c_args);\n+  out_arg_slots = c_calling_convention_priv(out_sig_bt, out_regs, total_c_args);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-                                        VMRegPair *regs2,\n@@ -259,2 +258,0 @@\n-  assert(regs2 == nullptr, \"not needed on arm\");\n-\n@@ -798,1 +795,1 @@\n-  int out_arg_slots = c_calling_convention(out_sig_bt, out_regs, nullptr, total_c_args);\n+  int out_arg_slots = c_calling_convention(out_sig_bt, out_regs, total_c_args);\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -139,4 +139,0 @@\n-    \/\/ Only the first 8 parameters are not placed on the stack. Aix disassembly\n-    \/\/ shows that xlC places all float args after argument 8 on the stack AND\n-    \/\/ in a register. This is not documented, but we follow this convention, too.\n-    n_regs_not_on_stack_c = 8,\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -186,2 +186,1 @@\n-        \/\/ TODO: Check if AIX needs 4 Byte offset\n-        __ stfs(as_FloatRegister(from_reg), reg2offset(to_reg, out_stk_bias), R1_SP);\n+        __ stfs(as_FloatRegister(from_reg), reg2offset(to_reg, out_stk_bias) + float_on_stack_offset_in_bytes, R1_SP);\n@@ -211,1 +210,1 @@\n-        case 4: __ lfs(as_FloatRegister(to_reg), reg2offset(from_reg, in_stk_bias), callerSP); break;\n+        case 4: __ lfs(as_FloatRegister(to_reg), reg2offset(from_reg, in_stk_bias) + float_on_stack_offset_in_bytes, callerSP); break;\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,9 @@\n+#ifdef VM_LITTLE_ENDIAN\n+  \/\/ Floats are in the least significant word of an argument slot.\n+  const int float_on_stack_offset_in_bytes = 0;\n+#else\n+  \/\/ Although AIX runs on big endian CPU, float is in the most\n+  \/\/ significant word of an argument slot.\n+  const int float_on_stack_offset_in_bytes = AIX_ONLY(0) NOT_AIX(4);\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/ppc\/globalDefinitions_ppc.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -744,1 +744,0 @@\n-                                        VMRegPair *regs2,\n@@ -785,4 +784,3 @@\n-  \/\/ `Stk' counts stack slots. Due to alignment, 32 bit values occupy\n-  \/\/ 2 such slots, like 64 bit values do.\n-  const int inc_stk_for_intfloat   = 2; \/\/ 2 slots for ints and floats\n-  const int inc_stk_for_longdouble = 2; \/\/ 2 slots for longs and doubles\n+  const int additional_frame_header_slots = ((frame::native_abi_minframe_size - frame::jit_out_preserve_size)\n+                                            \/ VMRegImpl::stack_slot_size);\n+  const int float_offset_in_slots = float_on_stack_offset_in_bytes \/ VMRegImpl::stack_slot_size;\n@@ -790,1 +788,0 @@\n-  int i;\n@@ -792,2 +789,0 @@\n-  \/\/ Leave room for C-compatible ABI_REG_ARGS.\n-  int stk = (frame::native_abi_reg_args_size - frame::jit_out_preserve_size) \/ VMRegImpl::stack_slot_size;\n@@ -796,0 +791,1 @@\n+  bool stack_used = false;\n@@ -797,11 +793,0 @@\n-  \/\/ Avoid passing C arguments in the wrong stack slots.\n-#if defined(ABI_ELFv2)\n-  assert((SharedRuntime::out_preserve_stack_slots() + stk) * VMRegImpl::stack_slot_size == 96,\n-         \"passing C arguments in wrong stack slots\");\n-#else\n-  assert((SharedRuntime::out_preserve_stack_slots() + stk) * VMRegImpl::stack_slot_size == 112,\n-         \"passing C arguments in wrong stack slots\");\n-#endif\n-  \/\/ We fill-out regs AND regs2 if an argument must be passed in a\n-  \/\/ register AND in a stack slot. If regs2 is null in such a\n-  \/\/ situation, we bail-out with a fatal error.\n@@ -809,2 +794,2 @@\n-    \/\/ Initialize regs2 to BAD.\n-    if (regs2 != nullptr) regs2[i].set_bad();\n+    \/\/ Each argument corresponds to a slot in the Parameter Save Area (if not omitted)\n+    int stk = (arg * 2) + additional_frame_header_slots;\n@@ -813,1 +798,0 @@\n-\n@@ -835,1 +819,1 @@\n-        stk += inc_stk_for_longdouble;\n+        stack_used = true;\n@@ -847,15 +831,0 @@\n-#if defined(LINUX)\n-      \/\/ Linux uses ELF ABI. Both original ELF and ELFv2 ABIs have float\n-      \/\/ in the least significant word of an argument slot.\n-#if defined(VM_LITTLE_ENDIAN)\n-#define FLOAT_WORD_OFFSET_IN_SLOT 0\n-#else\n-#define FLOAT_WORD_OFFSET_IN_SLOT 1\n-#endif\n-#elif defined(AIX)\n-      \/\/ Although AIX runs on big endian CPU, float is in the most\n-      \/\/ significant word of an argument slot.\n-#define FLOAT_WORD_OFFSET_IN_SLOT 0\n-#else\n-#error \"unknown OS\"\n-#endif\n@@ -866,14 +835,0 @@\n-\n-        \/\/ Argument i for i > 8 is placed on the stack even if it's\n-        \/\/ placed in a register (if it's a float arg). Aix disassembly\n-        \/\/ shows that xlC places these float args on the stack AND in\n-        \/\/ a register. This is not documented, but we follow this\n-        \/\/ convention, too.\n-        if (arg >= Argument::n_regs_not_on_stack_c) {\n-          \/\/ ... and on the stack.\n-          guarantee(regs2 != nullptr, \"must pass float in register and stack slot\");\n-          VMReg reg2 = VMRegImpl::stack2reg(stk + FLOAT_WORD_OFFSET_IN_SLOT);\n-          regs2[i].set1(reg2);\n-          stk += inc_stk_for_intfloat;\n-        }\n-\n@@ -882,2 +837,2 @@\n-        reg = VMRegImpl::stack2reg(stk + FLOAT_WORD_OFFSET_IN_SLOT);\n-        stk += inc_stk_for_intfloat;\n+        reg = VMRegImpl::stack2reg(stk + float_offset_in_slots);\n+        stack_used = true;\n@@ -893,13 +848,0 @@\n-\n-        \/\/ Argument i for i > 8 is placed on the stack even if it's\n-        \/\/ placed in a register (if it's a double arg). Aix disassembly\n-        \/\/ shows that xlC places these float args on the stack AND in\n-        \/\/ a register. This is not documented, but we follow this\n-        \/\/ convention, too.\n-        if (arg >= Argument::n_regs_not_on_stack_c) {\n-          \/\/ ... and on the stack.\n-          guarantee(regs2 != nullptr, \"must pass float in register and stack slot\");\n-          VMReg reg2 = VMRegImpl::stack2reg(stk);\n-          regs2[i].set2(reg2);\n-          stk += inc_stk_for_longdouble;\n-        }\n@@ -909,1 +851,1 @@\n-        stk += inc_stk_for_longdouble;\n+        stack_used = true;\n@@ -924,1 +866,11 @@\n-  return align_up(stk, 2);\n+  \/\/ Return size of the stack frame excluding the jit_out_preserve part in single-word slots.\n+#if defined(ABI_ELFv2)\n+  assert(additional_frame_header_slots == 0, \"ABIv2 shouldn't use extra slots\");\n+  \/\/ ABIv2 allows omitting the Parameter Save Area if the callee's prototype\n+  \/\/ indicates that all parameters can be passed in registers.\n+  return stack_used ? (arg * 2) : 0;\n+#else\n+  \/\/ The Parameter Save Area needs to be at least 8 double-word slots for ABIv1.\n+  \/\/ We have to add extra slots because ABIv1 uses a larger header.\n+  return MAX2(arg, 8) * 2 + additional_frame_header_slots;\n+#endif\n@@ -2143,1 +2095,0 @@\n-  VMRegPair *out_regs2  = NEW_RESOURCE_ARRAY(VMRegPair, total_c_args);\n@@ -2196,1 +2147,1 @@\n-  int stack_slots = c_calling_convention(out_sig_bt, out_regs, out_regs2, total_c_args) + \/\/ 1+2)\n+  int stack_slots = c_calling_convention(out_sig_bt, out_regs, total_c_args) + \/\/ 1+2)\n@@ -2361,5 +2312,0 @@\n-    if (out_regs2[out].first()->is_Register()) {\n-      reg_destroyed[out_regs2[out].first()->as_Register()->encoding()] = true;\n-    } else if (out_regs2[out].first()->is_FloatRegister()) {\n-      freg_destroyed[out_regs2[out].first()->as_FloatRegister()->encoding()] = true;\n-    }\n@@ -2392,3 +2338,0 @@\n-        if (out_regs2[out].first()->is_valid()) {\n-          float_move(masm, in_regs[in], out_regs2[out], r_callers_sp, r_temp_1);\n-        }\n@@ -2398,3 +2341,0 @@\n-        if (out_regs2[out].first()->is_valid()) {\n-          double_move(masm, in_regs[in], out_regs2[out], r_callers_sp, r_temp_1);\n-        }\n@@ -2478,1 +2418,1 @@\n-    RegisterSaver::push_frame_and_save_argument_registers(masm, R12_scratch2, frame_size, total_c_args, out_regs, out_regs2);\n+    RegisterSaver::push_frame_and_save_argument_registers(masm, R12_scratch2, frame_size, total_c_args, out_regs);\n@@ -2486,1 +2426,1 @@\n-    RegisterSaver::restore_argument_registers_and_pop_frame(masm, frame_size, total_c_args, out_regs, out_regs2);\n+    RegisterSaver::restore_argument_registers_and_pop_frame(masm, frame_size, total_c_args, out_regs);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":24,"deletions":84,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -292,15 +292,1 @@\n-#if defined(LINUX)\n-  \/\/ Linux uses ELF ABI. Both original ELF and ELFv2 ABIs have float\n-  \/\/ in the least significant word of an argument slot.\n-#if defined(VM_LITTLE_ENDIAN)\n-  __ stfs(floatSlot, 0, arg_c);\n-#else\n-  __ stfs(floatSlot, 4, arg_c);\n-#endif\n-#elif defined(AIX)\n-  \/\/ Although AIX runs on big endian CPU, float is in most significant\n-  \/\/ word of an argument slot.\n-  __ stfs(floatSlot, 0, arg_c);\n-#else\n-#error \"unknown OS\"\n-#endif\n+  __ stfs(floatSlot, float_on_stack_offset_in_bytes, arg_c);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -697,1 +697,0 @@\n-                                         VMRegPair *regs2,\n@@ -699,1 +698,0 @@\n-  assert(regs2 == nullptr, \"not needed on riscv\");\n@@ -1348,1 +1346,1 @@\n-  int out_arg_slots = c_calling_convention(out_sig_bt, out_regs, nullptr, total_c_args);\n+  int out_arg_slots = c_calling_convention(out_sig_bt, out_regs, total_c_args);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -763,1 +763,0 @@\n-                                        VMRegPair *regs2,\n@@ -765,1 +764,0 @@\n-  assert(regs2 == nullptr, \"second VMRegPair array not used on this platform\");\n@@ -1460,1 +1458,1 @@\n-  int stack_slots = c_calling_convention(out_sig_bt, out_regs, \/*regs2=*\/nullptr, total_c_args) + \/\/ 1+2\n+  int stack_slots = c_calling_convention(out_sig_bt, out_regs, total_c_args) + \/\/ 1+2\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -981,1 +981,0 @@\n-                                         VMRegPair *regs2,\n@@ -983,1 +982,1 @@\n-  assert(regs2 == nullptr, \"not needed on x86\");\n+\n@@ -1369,1 +1368,1 @@\n-  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, nullptr, total_c_args);\n+  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, total_c_args);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1056,1 +1056,0 @@\n-                                         VMRegPair *regs2,\n@@ -1058,1 +1057,1 @@\n-  assert(regs2 == nullptr, \"not needed on x86\");\n+\n@@ -1806,1 +1805,1 @@\n-  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, nullptr, total_c_args);\n+  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, total_c_args);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-                                         VMRegPair *regs2,\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  intptr_t out_preserve = SharedRuntime::c_calling_convention(sig_bt, regs, nullptr, sizeargs);\n+  intptr_t out_preserve = SharedRuntime::c_calling_convention(sig_bt, regs, sizeargs);\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1235,1 +1235,1 @@\n-  SharedRuntime::c_calling_convention(sig_bt, parm_regs, \/*regs2=*\/nullptr, argcnt);\n+  SharedRuntime::c_calling_convention(sig_bt, parm_regs, argcnt);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -390,2 +390,1 @@\n-  static int c_calling_convention(const BasicType *sig_bt, VMRegPair *regs, VMRegPair *regs2,\n-                                  int total_args_passed);\n+  static int c_calling_convention(const BasicType *sig_bt, VMRegPair *regs, int total_args_passed);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -208,7 +208,1 @@\n-            VMStorage stack;\n-            if (!useABIv2 && is32Bit) {\n-                stackAlloc(4, STACK_SLOT_SIZE); \/\/ Skip first half of stack slot.\n-                stack = stackAlloc(4, 4);\n-            } else {\n-                stack = stackAlloc(is32Bit ? 4 : 8, STACK_SLOT_SIZE);\n-            }\n+            VMStorage stack = stackAlloc(is32Bit ? 4 : 8, STACK_SLOT_SIZE);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ppc64\/CallArranger.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"}]}