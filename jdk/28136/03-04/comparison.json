{"files":[{"patch":"@@ -88,1 +88,1 @@\n-\/\/ NOTE: size 0 and 1 are used for initial and final shuffles respectivelly of\n+\/\/ NOTE: size 0 and 1 are used for initial and final shuffles respectively of\n@@ -248,8 +248,8 @@\n-\/\/    the odd numbered slots of a scratch2 register.\n-\/\/ 2. Swap the even and odd numbered slots of the original input registers.*\n-\/\/ 3. Similar to step 1, but into output register.\n-\/\/ 4. Combine the outputs of step 1 and step 3 into the output of the Montgomery\n-\/\/    multiplication.\n-\/\/ (*For levels 0-6 in the Ntt and levels 1-7 of the inverse Ntt, need NOT swap\n-\/\/ the second operand (zetas) since the odd slots contain the same number\n-\/\/ as the corresponding even one. This is indicated by input2NeedsShuffle=false)\n+\/\/    the odd numbered slots of the scratch2 register.\n+\/\/ 2. Swap the even and odd numbered slots of the original input registers.(*Note)\n+\/\/ 3. Similar to step 1, but multiplication result is placed into output register.\n+\/\/ 4. Combine odd\/even slots respectively from the scratch2 and output registers\n+\/\/    into the output register for the final result of the Montgomery multiplication.\n+\/\/ (*Note: For levels 0-6 in the Ntt and levels 1-7 of the inverse Ntt, need NOT\n+\/\/         swap the second operand (zetas) since the odd slots contain the same number\n+\/\/         as the corresponding even one. This is indicated by input2NeedsShuffle=false)\n@@ -282,1 +282,1 @@\n-    \/\/ scratch = input1_even*intput2_even\n+    \/\/ scratch = input1_even * intput2_even\n@@ -479,1 +479,1 @@\n-    \/\/ coeffs3, coeffs1 = coeffs1±scratch1\n+    \/\/ coeffs3, coeffs1 = coeffs1 ± scratch1\n@@ -524,1 +524,1 @@\n-      shuffle(Scratch1, Coeffs1_2, Coeffs2_2, distance * 32); \/\/Coeffs2_2 freed\n+      shuffle(Scratch1, Coeffs1_2, Coeffs2_2, distance * 32); \/\/ Coeffs2_2 freed\n@@ -529,1 +529,1 @@\n-      shuffle(Scratch1, Coeffs3_2, Coeffs4_2, distance * 32); \/\/Coeffs4_2 freed\n+      shuffle(Scratch1, Coeffs3_2, Coeffs4_2, distance * 32); \/\/ Coeffs4_2 freed\n@@ -554,7 +554,7 @@\n-    \/\/ Since we cannot fit the entire payload into registers, we process\n-    \/\/ input in two stages. First half, load 8 registers 32 integers each apart.\n-    \/\/ With one load, we can process level 0-2 (128-, 64- and 32-integers apart)\n-    \/\/ Remaining levels, load 8 registers from consecutive memory (16-, 8-, 4-,\n-    \/\/ 2-, 1-integer appart)\n-    \/\/ Levels 5, 6, 7 (4-, 2-, 1-integer appart) require shuffles within registers\n-    \/\/ Other levels, shuffles can be done by re-aranging register order\n+    \/\/ Since we cannot fit the entire payload into registers, we process the\n+    \/\/ input in two stages. For the first half, load 8 registers, each 32 integers\n+    \/\/ apart. With one load, we can process level 0-2 (128-, 64- and 32-integers\n+    \/\/ apart). For the remaining levels, load 8 registers from consecutive memory\n+    \/\/ (16-, 8-, 4-, 2-, 1-integer apart)\n+    \/\/ Levels 5, 6, 7 (4-, 2-, 1-integer apart) require shuffles within registers.\n+    \/\/ On the other levels, shuffles can be done by rearanging the register order\n@@ -562,1 +562,1 @@\n-    \/\/ Four batches of 8 registers each, 128 bytes appart\n+    \/\/ Four batches of 8 registers each, 128 bytes apart\n@@ -701,1 +701,1 @@\n-  \/\/ the substration is (Montgomery) multiplied by the corresponding zetas.\n+  \/\/ the subtration is (Montgomery) multiplied by the corresponding zetas.\n@@ -850,1 +850,1 @@\n-    \/\/ Four batches of 8 registers each, 128 bytes appart\n+    \/\/ Four batches of 8 registers each, 128 bytes apart\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_dilithium.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"}]}