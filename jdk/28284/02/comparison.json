{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Collections;\n@@ -29,0 +30,1 @@\n+import java.util.stream.IntStream;\n@@ -78,2 +80,1 @@\n-    \/\/ threadList and loadObjectList are filled by attach0 method\n-    private List<ThreadProxy> threadList;\n+    \/\/ loadObjectList are filled by attach0 method\n@@ -82,0 +83,2 @@\n+    private List<JavaThread> javaThreadList;\n+\n@@ -244,0 +247,12 @@\n+    private void fillJavaThreadList() {\n+      \/\/ TODO: thread list on macOS is now supported for corefile only.\n+      if (!isCore && isDarwin) {\n+          javaThreadList = Collections.emptyList();\n+      } else {\n+          Threads threads = VM.getVM().getThreads();\n+          javaThreadList = IntStream.range(0, threads.getNumberOfThreads())\n+                                    .mapToObj(threads::getJavaThreadAt)\n+                                    .toList();\n+      }\n+    }\n+\n@@ -247,1 +262,0 @@\n-        threadList = new ArrayList<>();\n@@ -267,1 +281,0 @@\n-        threadList = new ArrayList<>();\n@@ -281,1 +294,1 @@\n-        threadList = null;\n+        javaThreadList = null;\n@@ -495,1 +508,6 @@\n-      return threadList;\n+      if (javaThreadList == null) {\n+        fillJavaThreadList();\n+      }\n+      return javaThreadList.stream()\n+                           .map(JavaThread::getThreadProxy)\n+                           .toList();\n@@ -564,1 +582,1 @@\n-        all java threads recorded in Threads. Also adds the ThreadProxy to threadList *\/\n+        all java threads recorded in Threads. *\/\n@@ -567,3 +585,4 @@\n-        Threads threads = VM.getVM().getThreads();\n-        int len = threads.getNumberOfThreads();\n-        long[] result = new long[len * 3];    \/\/ triple\n+        if (javaThreadList == null) {\n+            fillJavaThreadList();\n+        }\n+        long[] result = new long[javaThreadList.size() * 3];    \/\/ triple\n@@ -572,2 +591,1 @@\n-        for (int k = 0; k < threads.getNumberOfThreads(); k++) {\n-            JavaThread t = threads.getJavaThreadAt(k);\n+        for (var t : javaThreadList) {\n@@ -576,3 +594,1 @@\n-            BsdThread bsdt = (BsdThread)t.getThreadProxy();\n-            long uid = bsdt.getUniqueThreadId();\n-            if (threadList != null) threadList.add(bsdt);\n+            long uid = ((BsdThread)t.getThreadProxy()).getUniqueThreadId();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdDebuggerLocal.java","additions":32,"deletions":16,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.utilities.*;\n@@ -40,1 +42,1 @@\n-  public default CFrame sender(ThreadProxy th, Address fp, Address pc) {\n+  public default CFrame sender(ThreadProxy th, Address sp, Address fp, Address pc) {\n@@ -73,0 +75,5 @@\n+\n+  \/** Get Frame instance assosiated with this CFrame. *\/\n+  public default Frame toFrame() {\n+    throw new UnsupportedPlatformException();\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/cdbg\/CFrame.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,2 @@\n+       Address sp  = context.getRegisterAsAddress(AMD64ThreadContext.RSP);\n+       if (sp == null) return null;\n@@ -86,1 +88,1 @@\n-       return LinuxAMD64CFrame.getTopFrame(dbg, pc, context);\n+       return LinuxAMD64CFrame.getTopFrame(dbg, sp, pc, context);\n@@ -96,0 +98,2 @@\n+       Address sp = context.getRegisterAsAddress(AARCH64ThreadContext.SP);\n+       if (sp == null) return null;\n@@ -100,1 +104,1 @@\n-       return new LinuxAARCH64CFrame(dbg, fp, pc);\n+       return new LinuxAARCH64CFrame(dbg, sp, fp, pc);\n@@ -103,0 +107,2 @@\n+       Address sp = context.getRegisterAsAddress(RISCV64ThreadContext.SP);\n+       if (sp == null) return null;\n@@ -107,1 +113,1 @@\n-       return new LinuxRISCV64CFrame(dbg, fp, pc);\n+       return new LinuxRISCV64CFrame(dbg, sp, fp, pc);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/LinuxCDebugger.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,3 @@\n+import sun.jvm.hotspot.code.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.runtime.aarch64.*;\n@@ -35,1 +38,1 @@\n-   public LinuxAARCH64CFrame(LinuxDebugger dbg, Address fp, Address pc) {\n+   public LinuxAARCH64CFrame(LinuxDebugger dbg, Address sp, Address fp, Address pc) {\n@@ -37,0 +40,1 @@\n+      this.sp = sp;\n@@ -58,1 +62,1 @@\n-      return sender(thread, null, null);\n+      return sender(thread, null, null, null);\n@@ -62,1 +66,1 @@\n-   public CFrame sender(ThreadProxy thread, Address nextFP, Address nextPC) {\n+   public CFrame sender(ThreadProxy thread, Address nextSP, Address nextFP, Address nextPC) {\n@@ -89,1 +93,26 @@\n-      return new LinuxAARCH64CFrame(dbg, nextFP, nextPC);\n+\n+      if (nextSP == null) {\n+        CodeCache cc = VM.getVM().getCodeCache();\n+        CodeBlob currentBlob = cc.findBlobUnsafe(pc());\n+\n+        \/\/ This case is different from HotSpot. See JDK-8371194 for details.\n+        if (currentBlob != null && (currentBlob.isContinuationStub() || currentBlob.isNativeMethod())) {\n+          \/\/ Use FP since it should always be valid for these cases.\n+          \/\/ TODO: These should be walked as Frames not CFrames.\n+          nextSP = fp.addOffsetTo(2 * ADDRESS_SIZE);\n+        } else {\n+          CodeBlob codeBlob = cc.findBlobUnsafe(nextPC);\n+          boolean useCodeBlob = codeBlob != null && codeBlob.getFrameSize() > 0;\n+          nextSP = useCodeBlob ? nextFP.addOffsetTo((2 * ADDRESS_SIZE) - codeBlob.getFrameSize()) : nextFP;\n+        }\n+      }\n+      if (nextSP == null) {\n+        return null;\n+      }\n+\n+      return new LinuxAARCH64CFrame(dbg, nextSP, nextFP, nextPC);\n+   }\n+\n+   @Override\n+   public Frame toFrame() {\n+     return new AARCH64Frame(sp, fp, pc);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/aarch64\/LinuxAARCH64CFrame.java","additions":34,"deletions":5,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.runtime.amd64.*;\n@@ -35,1 +37,1 @@\n-   public static LinuxAMD64CFrame getTopFrame(LinuxDebugger dbg, Address rip, ThreadContext context) {\n+   public static LinuxAMD64CFrame getTopFrame(LinuxDebugger dbg, Address rsp, Address rip, ThreadContext context) {\n@@ -48,1 +50,1 @@\n-          return new LinuxAMD64CFrame(dbg, cfa, rip, dwarf, true);\n+          return new LinuxAMD64CFrame(dbg, rsp, cfa, rip, dwarf, true);\n@@ -56,1 +58,1 @@\n-                           : new LinuxAMD64CFrame(dbg, cfa, rip, dwarf);\n+                           : new LinuxAMD64CFrame(dbg, rsp, cfa, rip, dwarf);\n@@ -59,2 +61,2 @@\n-   private LinuxAMD64CFrame(LinuxDebugger dbg, Address cfa, Address rip, DwarfParser dwarf) {\n-      this(dbg, cfa, rip, dwarf, false);\n+   private LinuxAMD64CFrame(LinuxDebugger dbg, Address rsp, Address cfa, Address rip, DwarfParser dwarf) {\n+      this(dbg, rsp, cfa, rip, dwarf, false);\n@@ -63,2 +65,2 @@\n-   private LinuxAMD64CFrame(LinuxDebugger dbg, Address cfa, Address rip, DwarfParser dwarf, boolean finalFrame) {\n-      this(dbg, cfa, rip, dwarf, finalFrame, false);\n+   private LinuxAMD64CFrame(LinuxDebugger dbg, Address rsp, Address cfa, Address rip, DwarfParser dwarf, boolean finalFrame) {\n+      this(dbg, rsp, cfa, rip, dwarf, finalFrame, false);\n@@ -67,1 +69,1 @@\n-   private LinuxAMD64CFrame(LinuxDebugger dbg, Address cfa, Address rip, DwarfParser dwarf, boolean finalFrame, boolean use1ByteBeforeToLookup) {\n+   private LinuxAMD64CFrame(LinuxDebugger dbg, Address rsp, Address cfa, Address rip, DwarfParser dwarf, boolean finalFrame, boolean use1ByteBeforeToLookup) {\n@@ -69,0 +71,1 @@\n+      this.rsp = rsp;\n@@ -110,1 +113,8 @@\n-   private Address getNextCFA(DwarfParser nextDwarf, ThreadContext context, Address senderFP) {\n+   private Address getNextRSP() {\n+     \/\/ next RSP should be previous slot of return address.\n+     var bp = dwarf == null ? cfa.addOffsetTo(ADDRESS_SIZE) \/\/ top of BP points callser BP\n+                            : cfa.addOffsetTo(dwarf.getReturnAddressOffsetFromCFA());\n+     return bp.addOffsetTo(ADDRESS_SIZE);\n+   }\n+\n+   private Address getNextCFA(DwarfParser nextDwarf, ThreadContext context, Address senderFP, Address senderPC) {\n@@ -118,1 +128,1 @@\n-     if (nextDwarf == null) { \/\/ Next frame is Java\n+     if (VM.getVM().getCodeCache().contains(senderPC)) { \/\/ Next frame is Java\n@@ -122,1 +132,1 @@\n-       if (dwarf == null) { \/\/ Current frame is Java\n+       if (VM.getVM().getCodeCache().contains(pc())) { \/\/ Current frame is Java\n@@ -125,0 +135,4 @@\n+         if (nextDwarf == null) { \/\/ maybe runtime entrypoint (_start())\n+           throw new DebuggerException(\"nextDwarf is null even though native call\");\n+         }\n+\n@@ -133,4 +147,1 @@\n-           \/\/ next RSP should be previous slot of return address.\n-           Address nextRSP = cfa.addOffsetTo(dwarf.getReturnAddressOffsetFromCFA())\n-                                .addOffsetTo(ADDRESS_SIZE);\n-           nextCFA = nextRSP.addOffsetTo(nextDwarf.getCFAOffset());\n+           nextCFA = getNextRSP().addOffsetTo(nextDwarf.getCFAOffset());\n@@ -156,1 +167,1 @@\n-     return sender(th, null, null);\n+     return sender(th, null, null, null);\n@@ -160,1 +171,1 @@\n-   public CFrame sender(ThreadProxy th, Address fp, Address pc) {\n+   public CFrame sender(ThreadProxy th, Address sp, Address fp, Address pc) {\n@@ -167,0 +178,5 @@\n+     Address nextRSP = sp != null ? sp : getNextRSP();\n+     if (nextRSP == null) {\n+       return null;\n+     }\n+\n@@ -186,1 +202,1 @@\n-         return new LinuxAMD64CFrame(dbg, null, nextPC, nextDwarf, true);\n+         return null;\n@@ -190,3 +206,6 @@\n-     Address nextCFA = getNextCFA(nextDwarf, context, fp);\n-     return nextCFA == null ? null\n-                            : new LinuxAMD64CFrame(dbg, nextCFA, nextPC, nextDwarf, false, fallback);\n+     try {\n+       Address nextCFA = getNextCFA(nextDwarf, context, fp, nextPC);\n+       return new LinuxAMD64CFrame(dbg, nextRSP, nextCFA, nextPC, nextDwarf, false, fallback);\n+     } catch (DebuggerException _) {\n+       return null;\n+     }\n@@ -213,0 +232,5 @@\n+   @Override\n+   public Frame toFrame() {\n+     return new AMD64Frame(rsp, cfa, rip);\n+   }\n+\n@@ -215,0 +239,1 @@\n+   private Address rsp;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/amd64\/LinuxAMD64CFrame.java","additions":46,"deletions":21,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.runtime.ppc64.*;\n@@ -74,0 +76,6 @@\n+  @Override\n+  public Frame toFrame() {\n+    \/\/ 2nd arg (raw_fp) would be derived from sp in c'tor of PPC64Frame.\n+    return new PPC64Frame(sp, null, pc);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/ppc64\/LinuxPPC64CFrame.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.runtime.riscv64.*;\n@@ -38,0 +40,1 @@\n+   private static final int C_FRAME_SENDER_SP_OFFSET   =  0;\n@@ -39,1 +42,1 @@\n-   public LinuxRISCV64CFrame(LinuxDebugger dbg, Address fp, Address pc) {\n+   public LinuxRISCV64CFrame(LinuxDebugger dbg, Address sp, Address fp, Address pc) {\n@@ -41,0 +44,1 @@\n+      this.sp = sp;\n@@ -62,1 +66,1 @@\n-      return sender(thread, null, null);\n+      return sender(thread, null, null, null);\n@@ -66,1 +70,1 @@\n-   public CFrame sender(ThreadProxy thread, Address nextFP, Address nextPC) {\n+   public CFrame sender(ThreadProxy thread, Address nextSP, Address nextFP, Address nextPC) {\n@@ -80,0 +84,7 @@\n+      if (nextSP == null) {\n+        nextSP = fp.getAddressAt(C_FRAME_SENDER_SP_OFFSET * ADDRESS_SIZE);\n+      }\n+      if (nextSP == null) {\n+        return null;\n+      }\n+\n@@ -94,1 +105,6 @@\n-      return new LinuxRISCV64CFrame(dbg, nextFP, nextPC);\n+      return new LinuxRISCV64CFrame(dbg, nextSP, nextFP, nextPC);\n+   }\n+\n+   @Override\n+   public Frame toFrame() {\n+      return new RISCV64Frame(sp, fp, pc);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/riscv64\/LinuxRISCV64CFrame.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -275,3 +275,1 @@\n-      } else if (cb.isContinuationStub()) {\n-        return senderForContinuationStub(map, cb);\n-      } else {\n+      } else if (cb.getFrameSize() > 0) {\n@@ -392,1 +390,5 @@\n-    Address senderSP = getUnextendedSP().addOffsetTo(cb.getFrameSize());\n+\n+    \/\/ TODO: senderSP should consider not only PreserveFramePointer but also _sp_is_trusted.\n+    Address senderSP = !VM.getVM().getCommandLineBooleanFlag(\"PreserveFramePointer\")\n+                           ? getUnextendedSP().addOffsetTo(cb.getFrameSize())\n+                           : getSenderSP();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/aarch64\/AARCH64Frame.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -275,3 +275,1 @@\n-      } else if (cb.isContinuationStub()) {\n-        return senderForContinuationStub(map, cb);\n-      } else {\n+      } else if (cb.getFrameSize() > 0) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/amd64\/AMD64Frame.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-         initJFrameCache();\n@@ -99,0 +98,1 @@\n+         Map<ThreadProxy, JavaThread> proxyToThread = createProxyToThread();;\n@@ -112,0 +112,1 @@\n+                  Address senderSP = null;\n@@ -134,1 +135,1 @@\n-                         nameInfo = getJavaNames(th, f.localVariableBase());\n+                         nameInfo = getJavaNames(jthread, f);\n@@ -159,1 +160,1 @@\n-                                  nameInfo = getJavaNames(th, f.localVariableBase());\n+                                  nameInfo = getJavaNames(jthread, f);\n@@ -167,0 +168,6 @@\n+                               if (cb.getFrameSize() > 0) {\n+                                  Frame senderFrame = f.toFrame().sender(jthread.newRegisterMap(true));\n+                                  senderSP = senderFrame.getSP();\n+                                  senderFP = senderFrame.getFP();\n+                                  senderPC = senderFrame.getPC();\n+                               }\n@@ -183,0 +190,1 @@\n+                         senderSP = nameInfo.senderSP();\n@@ -187,1 +195,1 @@\n-                  f = f.sender(th, senderFP, senderPC);\n+                  f = f.sender(th, senderSP, senderFP, senderPC);\n@@ -215,2 +223,0 @@\n-   private Map<ThreadProxy, JavaVFrame[]> jframeCache;\n-   private Map<ThreadProxy, JavaThread> proxyToThread;\n@@ -221,4 +227,2 @@\n-   private void initJFrameCache() {\n-      \/\/ cache frames for subsequent reference\n-      jframeCache = new HashMap<>();\n-      proxyToThread = new HashMap<>();\n+   private Map<ThreadProxy, JavaThread> createProxyToThread() {\n+      Map<ThreadProxy, JavaThread> proxyToThread = new HashMap<>();\n@@ -227,14 +231,2 @@\n-         JavaThread cur = threads.getJavaThreadAt(i);\n-         List<JavaVFrame> tmp = new ArrayList<>(10);\n-         try {\n-            for (JavaVFrame vf = cur.getLastJavaVFrameDbg(); vf != null; vf = vf.javaSender()) {\n-               tmp.add(vf);\n-            }\n-         } catch (Exception exp) {\n-            \/\/ may be we may get frames for other threads, continue\n-            \/\/ after printing stack trace.\n-            exp.printStackTrace();\n-         }\n-         JavaVFrame[] jvframes = tmp.toArray(new JavaVFrame[0]);\n-         jframeCache.put(cur.getThreadProxy(), jvframes);\n-         proxyToThread.put(cur.getThreadProxy(), cur);\n+         JavaThread jthread = threads.getJavaThreadAt(i);\n+         proxyToThread.put(jthread.getThreadProxy(), jthread);\n@@ -242,0 +234,1 @@\n+      return proxyToThread;\n@@ -248,8 +241,1 @@\n-   private static record JavaNameInfo(String[] names, Address senderFP, Address senderPC) {};\n-\n-   private JavaNameInfo getJavaNames(ThreadProxy th, Address fp) {\n-      if (fp == null) {\n-         return null;\n-      }\n-      JavaVFrame[] jvframes = jframeCache.get(th);\n-      if (jvframes == null) return null; \/\/ not a java thread\n+   private static record JavaNameInfo(String[] names, Address senderSP, Address senderFP, Address senderPC) {};\n@@ -257,0 +243,1 @@\n+   private JavaNameInfo getJavaNames(JavaThread jthread, CFrame f) {\n@@ -258,16 +245,15 @@\n-      JavaVFrame bottomJVFrame = null;\n-      for (int fCount = 0; fCount < jvframes.length; fCount++) {\n-         JavaVFrame vf = jvframes[fCount];\n-         Frame f = vf.getFrame();\n-         if (fp.equals(f.getFP())) {\n-            bottomJVFrame = vf;\n-            StringBuilder sb = new StringBuilder();\n-            Method method = vf.getMethod();\n-            \/\/ a special char to identify java frames in output\n-            sb.append(\"* \");\n-            sb.append(method.externalNameAndSignature());\n-            sb.append(\" bci:\").append(vf.getBCI());\n-            int lineNumber = method.getLineNumberFromBCI(vf.getBCI());\n-            if (lineNumber != -1) {\n-                sb.append(\" line:\").append(lineNumber);\n-            }\n+      Address senderSP = null;\n+      Address senderFP = null;\n+      Address senderPC = null;\n+      VFrame vf = VFrame.newVFrame(f.toFrame(), jthread.newRegisterMap(true), jthread, true, true);\n+      while (vf != null && vf.isJavaFrame()) {\n+         StringBuilder sb = new StringBuilder();\n+         Method method = ((JavaVFrame)vf).getMethod();\n+         \/\/ a special char to identify java frames in output\n+         sb.append(\"* \");\n+         sb.append(method.externalNameAndSignature());\n+         sb.append(\" bci:\").append(((JavaVFrame)vf).getBCI());\n+         int lineNumber = method.getLineNumberFromBCI(((JavaVFrame)vf).getBCI());\n+         if (lineNumber != -1) {\n+            sb.append(\" line:\").append(lineNumber);\n+         }\n@@ -275,3 +261,3 @@\n-            if (verbose) {\n-               sb.append(\" Method*:\").append(method.getAddress());\n-            }\n+         if (verbose) {\n+            sb.append(\" Method*:\").append(method.getAddress());\n+         }\n@@ -279,10 +265,4 @@\n-            if (vf.isCompiledFrame()) {\n-               sb.append(\" (Compiled frame\");\n-               if (vf.isDeoptimized()) {\n-                 sb.append(\" [deoptimized]\");\n-               }\n-            } else if (vf.isInterpretedFrame()) {\n-               sb.append(\" (Interpreted frame\");\n-            }\n-            if (vf.mayBeImpreciseDbg()) {\n-               sb.append(\"; information may be imprecise\");\n+         if (vf.isCompiledFrame()) {\n+            sb.append(\" (Compiled frame\");\n+            if (vf.isDeoptimized()) {\n+               sb.append(\" [deoptimized]\");\n@@ -290,2 +270,2 @@\n-            sb.append(\")\");\n-            names.add(sb.toString());\n+         } else if (vf.isInterpretedFrame()) {\n+            sb.append(\" (Interpreted frame\");\n@@ -293,1 +273,5 @@\n-      }\n+         if (vf.mayBeImpreciseDbg()) {\n+            sb.append(\"; information may be imprecise\");\n+         }\n+         sb.append(\")\");\n+         names.add(sb.toString());\n@@ -295,4 +279,4 @@\n-      Address senderFP = null;\n-      Address senderPC = null;\n-      if (bottomJVFrame != null) {\n-         Frame senderFrame = bottomJVFrame.getFrame().sender((RegisterMap)bottomJVFrame.getRegisterMap().clone());\n+         \/\/ Keep registers in sender Frame\n+         Frame senderFrame = vf.getFrame()\n+                               .sender((RegisterMap)vf.getRegisterMap().clone());\n+         senderSP = senderFrame.getSP();\n@@ -301,0 +285,3 @@\n+\n+         \/\/ Get sender VFrame for next stack walking\n+         vf = vf.sender(true);\n@@ -303,1 +290,1 @@\n-      return new JavaNameInfo(names.toArray(new String[0]), senderFP, senderPC);\n+      return new JavaNameInfo(names.toArray(new String[0]), senderSP, senderFP, senderPC);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/PStack.java","additions":56,"deletions":69,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -147,1 +147,0 @@\n-serviceability\/sa\/TestJhsdbJstackMixedWithXComp.java 8371194 linux-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.Arrays;\n@@ -35,1 +36,1 @@\n- * @test\n+ * @test id=xcomp\n@@ -43,0 +44,22 @@\n+\n+\/**\n+ * @test id=xcomp-preserve-frame-pointer\n+ * @bug 8370176\n+ * @requires vm.hasSA\n+ * @requires os.family == \"linux\"\n+ * @requires os.arch == \"amd64\"\n+ * @library \/test\/lib\n+ * @run driver TestJhsdbJstackMixedWithXComp -XX:+PreserveFramePointer\n+ *\/\n+\n+\/**\n+ * @test id=xcomp-disable-tiered-compilation\n+ * @bug 8370176\n+ * @requires vm.hasSA\n+ * @requires os.family == \"linux\"\n+ * @requires os.arch == \"amd64\"\n+ * @library \/test\/lib\n+ * @run driver TestJhsdbJstackMixedWithXComp -XX:-TieredCompilation\n+ *\/\n+\n+\n@@ -92,0 +115,4 @@\n+            List<String> jvmOpts = new ArrayList<>();\n+            jvmOpts.add(\"-Xcomp\");\n+            jvmOpts.addAll(Arrays.asList(args));\n+\n@@ -93,1 +120,1 @@\n-            LingeredApp.startApp(app, \"-Xcomp\");\n+            LingeredApp.startApp(app, jvmOpts.toArray(new String[0]));\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/TestJhsdbJstackMixedWithXComp.java","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"}]}