{"files":[{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8272746\n+ * @summary Verify that ZipFile rejects files with CEN sizes exceeding the limit\n+ * @run testng\/othervm EndOfCenValidation\n+ *\/\n+\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.EnumSet;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * This test augments {@link TestTooManyEntries}. It creates sparse ZIPs where the\n+ * the CEN size is inflated to the desired value. This helps this test run\n+ * fast with much less resources.\n+ *\n+ * While the CEN in these files are zero-filled and the produced ZIPs are technically\n+ * invalid, the CEN is never actually read by ZipFile since it does END\n+ * record validation before reading the CEN.\n+ *\/\n+public class EndOfCenValidation {\n+\n+    \/\/ Zip files produced by this test\n+    public static final Path CEN_TOO_LARGE_ZIP = Path.of(\"cen-size-too-large.zip\");\n+    public static final Path INVALID_CEN_SIZE = Path.of(\"invalid-zen-size.zip\");\n+    public static final Path BAD_CEN_OFFSET_ZIP = Path.of(\"bad-cen-offset.zip\");\n+    \/\/ Some ZipFile constants for manipulating the END header\n+    private static final int ENDHDR = ZipFile.ENDHDR; \/\/ End of central directory record size\n+    private static final int ENDSIZ = ZipFile.ENDSIZ; \/\/ Offset of CEN size field within ENDHDR\n+    private static final int ENDOFF = ZipFile.ENDOFF; \/\/ Offset of CEN offset field within ENDHDR\n+    \/\/ Maximum allowed CEN size allowed by ZipFile\n+    private static int MAX_CEN_SIZE = Integer.MAX_VALUE - ENDHDR - 1;\n+\n+    \/\/ Expected message when CEN size does not match file size\n+    private static final String INVALID_CEN_BAD_SIZE = \"invalid END header (bad central directory size)\";\n+    \/\/ Expected message when CEN offset is too large\n+    private static final String INVALID_CEN_BAD_OFFSET = \"invalid END header (bad central directory offset)\";\n+    \/\/ Expected message when CEN size is too large\n+    private static final String INVALID_CEN_SIZE_TOO_LARGE = \"invalid END header (central directory size too large)\";\n+\n+    \/\/ A valid ZIP file, used as a template\n+    private byte[] zipBytes;\n+\n+    \/**\n+     * Create a valid ZIP file, used as a template\n+     *\/\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        zipBytes = templateZip();\n+    }\n+\n+    \/**\n+     * Delete big files after test, in case the file system did not support sparse files.\n+     *\/\n+    @AfterTest\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(CEN_TOO_LARGE_ZIP);\n+        Files.deleteIfExists(INVALID_CEN_SIZE);\n+        Files.deleteIfExists(BAD_CEN_OFFSET_ZIP);\n+    }\n+\n+    \/**\n+     * Validates that an end of central directory record with\n+     * a CEN length exceeding {@link #MAX_CEN_SIZE} limit is rejected\n+     *\/\n+    @Test\n+    public void shouldRejectTooLargeCenSize() throws IOException {\n+        int size = MAX_CEN_SIZE + 1;\n+\n+        Path zip = zipWithModifiedEndRecord(size, true, 0, CEN_TOO_LARGE_ZIP);\n+\n+        ZipException ex = expectThrows(ZipException.class, () -> {\n+            new ZipFile(zip.toFile());\n+        });\n+\n+        assertEquals(ex.getMessage(), INVALID_CEN_SIZE_TOO_LARGE);\n+    }\n+\n+    \/**\n+     * Validate that an end of central directory record with a\n+     * CEN size which exceeds the position of the EOC record is rejected.\n+     *\/\n+    @Test\n+    public void shouldRejectInvalidCenSize() throws IOException {\n+\n+        int size = MAX_CEN_SIZE;\n+\n+        Path zip = zipWithModifiedEndRecord(size, false, 0, INVALID_CEN_SIZE);\n+\n+        ZipException ex = expectThrows(ZipException.class, () -> {\n+            new ZipFile(zip.toFile());\n+        });\n+\n+        assertEquals(ex.getMessage(), INVALID_CEN_BAD_SIZE);\n+    }\n+\n+    \/**\n+     * Validate that an end of central directory record with a CEN offset which\n+     * is larger than the EOC position minus the CEN size is rejected\n+     * @throws IOException\n+     *\/\n+    @Test\n+    public void shouldRejectInvalidCenOffset() throws IOException {\n+\n+        int size = MAX_CEN_SIZE;\n+\n+        Path zip = zipWithModifiedEndRecord(size, true, 100, BAD_CEN_OFFSET_ZIP);\n+\n+        ZipException ex = expectThrows(ZipException.class, () -> {\n+            new ZipFile(zip.toFile());\n+        });\n+\n+        assertEquals(ex.getMessage(), INVALID_CEN_BAD_OFFSET);\n+    }\n+\n+    \/**\n+     * Create an ZIP file with a single entry, then modify the CEN size\n+     * in the End of central directory record to the given size.\n+     *\n+     * The CEN is optionally \"inflated\" with trailing zero bytes such that\n+     * its actual size matches the one stated in the Eoc record.\n+     *\n+     * The CEN offset is optiontially adjusted by the given amount\n+     *\n+     * The resulting ZIP is technically not valid, but it does allow us\n+     * to test that large or invalid CEN sizes are rejected\n+     * @param cenSize the CEN size to put in the END record\n+     * @param inflateCen if true, zero-pad the CEN to the desired size\n+     * @param cenOffAdjust Adjust the CEN offset field of the END record with this amount\n+     *\/\n+    private Path zipWithModifiedEndRecord(int cenSize,\n+                                          boolean inflateCen,\n+                                          int cenOffAdjust,\n+                                          Path zip) throws IOException {\n+\n+        \/\/ A byte buffer for reading the EOC\n+        ByteBuffer buffer = ByteBuffer.wrap(zipBytes.clone()).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        \/\/ Offset of the EOC record\n+        int eocOff = buffer.limit() - ENDHDR;\n+\n+        \/\/ Modify the CEN size\n+        int sizeOffset = eocOff + ENDSIZ;\n+        int currentCenSize = buffer.getInt(sizeOffset);\n+        buffer.putInt(sizeOffset, cenSize);\n+\n+        \/\/ Optionally modify the CEN offset\n+        if (cenOffAdjust != 0) {\n+            int offOffset = eocOff + ENDOFF;\n+            int currentCenOff = buffer.getInt(offOffset);\n+            buffer.putInt(offOffset, currentCenOff + cenOffAdjust);\n+        }\n+\n+        \/\/ When creating a sparse file, the file must not already exit\n+        Files.deleteIfExists(zip);\n+\n+        \/\/ Open a FileChannel for writing a sparse file\n+        EnumSet<StandardOpenOption> options = EnumSet.of(StandardOpenOption.CREATE_NEW,\n+                StandardOpenOption.WRITE,\n+                StandardOpenOption.SPARSE);\n+\n+        try (FileChannel channel = FileChannel.open(zip, options)) {\n+\n+            \/\/ Write everything up to EOC\n+            channel.write(buffer.slice(0, buffer.limit() - ENDHDR));\n+\n+            if (inflateCen) {\n+                \/\/ Inject \"empty bytes\" to make the actual CEN size match the EOC\n+                int injectBytes = cenSize - currentCenSize;\n+                channel.position(channel.position() + injectBytes);\n+            }\n+            \/\/ Write the modified EOC\n+            channel.write(buffer.slice(buffer.limit() - ENDHDR, ENDHDR));\n+        }\n+        return zip;\n+    }\n+\n+    \/**\n+     * Produce a byte array of a ZIP with a single entry\n+     *\n+     * @throws IOException\n+     *\/\n+    private byte[] templateZip() throws IOException {\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        try (ZipOutputStream zo = new ZipOutputStream(bout)) {\n+            ZipEntry entry = new ZipEntry(\"duke.txt\");\n+            zo.putNextEntry(entry);\n+            zo.write(\"duke\".getBytes(StandardCharsets.UTF_8));\n+        }\n+        return bout.toByteArray();\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/EndOfCenValidation.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"}]}