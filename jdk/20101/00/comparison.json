{"files":[{"patch":"@@ -2382,2 +2382,2 @@\n-        \/\/ First character after the prefix was un-parseable, should\n-        \/\/ fail regardless if lenient or strict.\n+        \/\/ First character after the prefix was un-parseable or parsing integer\n+        \/\/ only with no integer portion. Should fail regardless if lenient or strict.\n@@ -2424,2 +2424,2 @@\n-            \/\/ If intPos is 0, the entire value was integer\n-            if (isParseIntegerOnly() && pos.intPos > 0) {\n+            \/\/ If intPos is -1, the entire value was integer and index should be full pos\n+            if (isParseIntegerOnly() && pos.intPos != -1) {\n@@ -2477,1 +2477,1 @@\n-        int intIndex = 0;\n+        int intIndex = -1;\n@@ -2573,0 +2573,4 @@\n+                    if (isParseIntegerOnly() && startPos == position) {\n+                        \/\/ Parsing int only with no integer portion, fail\n+                        return new NumericPosition(-1, intIndex);\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8327640 8331485 8333456\n+ * @bug 8327640 8331485 8333456 8335668\n@@ -131,0 +131,21 @@\n+    \/\/ 8335668: Parsing with integer only against String with no integer portion\n+    \/\/ should fail, not return 0. Expected error index should be 0\n+    @Test\n+    public void integerParseOnlyFractionOnlyTest() {\n+        var fmt = NumberFormat.getIntegerInstance();\n+        failParse(fmt, localizeText(\".\"), 0);\n+        failParse(fmt, localizeText(\".0\"), 0);\n+        failParse(fmt, localizeText(\".55\"), 0);\n+    }\n+\n+    \/\/ 8335668: Parsing with integer only against String with no integer portion\n+    \/\/ should fail, not return 0. Expected error index should be 0\n+    @Test \/\/ Non-localized, run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactIntegerParseOnlyFractionOnlyTest() {\n+        var fmt = NumberFormat.getIntegerInstance();\n+        failParse(fmt, \".K\", 0);\n+        failParse(fmt, \".0K\", 0);\n+        failParse(fmt, \".55K\", 0);\n+    }\n+\n@@ -316,1 +337,5 @@\n-                Arguments.of(\"10,000,000\", 10000000d))\n+                Arguments.of(\"10,000,000\", 10000000d),\n+                \/\/ Smaller value cases (w\/ decimal)\n+                Arguments.of(\".1\", .1d),\n+                Arguments.of(\"1.1\", 1.1d),\n+                Arguments.of(\"11.1\", 11.1d))\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/LenientParseTest.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8327640 8331485 8333755\n+ * @bug 8327640 8331485 8333755 8335668\n@@ -206,0 +206,21 @@\n+    \/\/ 8335668: Parsing with integer only against String with no integer portion\n+    \/\/ should fail, not return 0. Expected error index should be 0\n+    @Test\n+    public void integerParseOnlyFractionOnlyTest() {\n+        var fmt = NumberFormat.getIntegerInstance();\n+        failParse(fmt, localizeText(\".\"), 0);\n+        failParse(fmt, localizeText(\".0\"), 0);\n+        failParse(fmt, localizeText(\".55\"), 0);\n+    }\n+\n+    \/\/ 8335668: Parsing with integer only against String with no integer portion\n+    \/\/ should fail, not return 0. Expected error index should be 0\n+    @Test \/\/ Non-localized, run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactIntegerParseOnlyFractionOnlyTest() {\n+        var fmt = NumberFormat.getIntegerInstance();\n+        failParse(fmt, \".K\", 0);\n+        failParse(fmt, \".0K\", 0);\n+        failParse(fmt, \".55K\", 0);\n+    }\n+\n@@ -429,2 +450,2 @@\n-                Arguments.of(\".22a\", 3),\n-                Arguments.of(\".1a1\", 2),\n+                Arguments.of(\"1.22a\", 4),\n+                Arguments.of(\"1.1a1\", 3),\n@@ -456,1 +477,5 @@\n-                Arguments.of(\"10,000,000\", 10000000d))\n+                Arguments.of(\"10,000,000\", 10000000d),\n+                \/\/ Smaller value cases (w\/ decimal)\n+                Arguments.of(\".1\", .1d),\n+                Arguments.of(\"1.1\", 1.1d),\n+                Arguments.of(\"11.1\", 11.1d))\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/StrictParseTest.java","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"}]}