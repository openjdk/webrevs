{"files":[{"patch":"@@ -2299,0 +2299,7 @@\n+\n+    \/\/ check we are not in critical section\n+    Label L_skip;\n+    __ cmpl(Address(r15_thread, JavaThread::jni_critical_offset()), 0);\n+    __ jccb(Assembler::zero, L_skip);\n+    __ stop(\"Leaving native code while in JNI critical section, potential deadlock\");\n+    __ bind(L_skip);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1037,0 +1037,7 @@\n+\n+    \/\/ check we are not in critical section\n+    Label L_skip;\n+    __ cmpl(Address(r15_thread, JavaThread::jni_critical_offset()), 0);\n+    __ jccb(Assembler::zero, L_skip);\n+    __ stop(\"Leaving native code while in JNI critical section, potential deadlock\");\n+    __ bind(L_skip);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -99,4 +99,0 @@\n-  if (CheckJNICalls && java_thread->in_critical()) {\n-    fatal(\"Deadlock due to GC while in JNI critical section\");\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -175,4 +175,0 @@\n-  if (CheckJNICalls && JavaThread::current()->in_critical()) {\n-    fatal(\"Deadlock due to GC while in JNI critical section\");\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-static const char * warn_other_function_in_critical = \"Warning: Calling other JNI functions in the scope of \" \\\n+static const char * fatal_other_function_in_critical = \"Calling other JNI functions in the scope of \" \\\n@@ -216,1 +216,3 @@\n-    tty->print_cr(\"%s\", warn_other_function_in_critical);\n+    tty->print_cr(\"%s\", fatal_other_function_in_critical);\n+    \/\/ Ideally the following, but at least AWT code triggers this (ouch!):\n+    \/\/ NativeReportJNIFatalError(thr, fatal_other_function_in_critical);\n@@ -225,1 +227,3 @@\n-    tty->print_cr(\"%s\", warn_other_function_in_critical);\n+    tty->print_cr(\"%s\", fatal_other_function_in_critical);\n+    \/\/ Ideally the following, but at least AWT code triggers this (ouch!):\n+    \/\/ NativeReportJNIFatalError(thr, fatal_other_function_in_critical);\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -101,0 +101,4 @@\n+    if (CheckJNICalls && (to == _thread_in_Java) && thread->in_critical()) {\n+      fatal(\"Leaving native code while in JNI critical section, potential deadlock\");\n+    }\n+\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -939,0 +939,2 @@\n+  static ByteSize jni_critical_offset()          { return byte_offset_of(JavaThread, _jni_active_critical); }\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,2 +37,1 @@\n- * @summary Test that GC is either completing well, or fail with JNI check error\n- *          when GC is requested when current thread is in JNI critical region\n+ * @summary Test that we are catching bugs when leaving JNI critical region into unsafe code\n@@ -51,1 +50,1 @@\n-            \/\/ Supports JNI Critical by not moving anything\n+            \/\/ Supports JNI Critical by not moving anything and never tracking thread status\n@@ -55,1 +54,1 @@\n-            \/\/ Supports JNI Critical by pinning regions (JEP 423)\n+            \/\/ Supports JNI Critical by pinning regions (JEP 423) and never tracking thread status\n@@ -59,1 +58,1 @@\n-            \/\/ Supports JNI Critical with GCLocker, can deadlock\n+            \/\/ Supports JNI Critical with GCLocker, tracks thread status\n@@ -63,1 +62,1 @@\n-            \/\/ Supports JNI Critical with GCLocker, can deadlock\n+            \/\/ Supports JNI Critical with GCLocker, tracks thread status\n@@ -67,1 +66,1 @@\n-            \/\/ Supports JNI Critical by pinning regions\n+            \/\/ Supports JNI Critical by pinning regions, and never tracking thread status\n@@ -71,1 +70,1 @@\n-            \/\/ Supports JNI Critical by GCLocker-like mechanism, can deadlock\n+            \/\/ Supports JNI Critical by GCLocker-like mechanism, tracks thread status\n@@ -89,1 +88,1 @@\n-        oa.stdoutShouldContain(\"Deadlock due to GC while in JNI critical section\");\n+        oa.stdoutShouldContain(\"Leaving native code while in JNI critical section, potential deadlock\");\n@@ -103,0 +102,2 @@\n+            \/\/ Do anything that could trigger a safepoint while we are in JNI critical section, really.\n+            \/\/ Asking for GC also shows the opportunity to deadlock with GCLocker.\n","filename":"test\/hotspot\/jtreg\/gc\/jni\/TestGCInJNICritical.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"}]}