{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-import static sun.nio.fs.UnixNativeDispatcher.lutimes;\n+import static sun.nio.fs.UnixNativeDispatcher.utimensat;\n@@ -53,41 +53,5 @@\n-        boolean useLutimes = false;\n-        try {\n-            useLutimes = !followLinks &&\n-                UnixFileAttributes.get(path, false).isSymbolicLink();\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(path);\n-        }\n-\n-        int fd = -1;\n-        if (!useLutimes) {\n-            try {\n-                fd = path.openForAttributeAccess(followLinks);\n-            } catch (UnixException x) {\n-                x.rethrowAsIOException(path);\n-            }\n-        }\n-\n-        try {\n-            \/\/ not all volumes support setattrlist(2), so set the last\n-            \/\/ modified and last access times using futimens(2)\/lutimes(3)\n-            if (lastModifiedTime != null || lastAccessTime != null) {\n-                \/\/ if not changing both attributes then need existing attributes\n-                if (lastModifiedTime == null || lastAccessTime == null) {\n-                    try {\n-                        UnixFileAttributes attrs = UnixFileAttributes.get(fd);\n-                        if (lastModifiedTime == null)\n-                            lastModifiedTime = attrs.lastModifiedTime();\n-                        if (lastAccessTime == null)\n-                            lastAccessTime = attrs.lastAccessTime();\n-                    } catch (UnixException x) {\n-                        x.rethrowAsIOException(path);\n-                    }\n-                }\n-\n-                \/\/ update times\n-                TimeUnit timeUnit = useLutimes ?\n-                    TimeUnit.MICROSECONDS : TimeUnit.NANOSECONDS;\n-                long modValue = lastModifiedTime.to(timeUnit);\n-                long accessValue= lastAccessTime.to(timeUnit);\n-\n-                boolean retry = false;\n+        \/\/ not all volumes support setattrlist(2), so set the last\n+        \/\/ modified and last access times using utimensat(2)\n+        if (lastModifiedTime != null || lastAccessTime != null) {\n+            \/\/ if not changing both attributes then need existing attributes\n+            if (lastModifiedTime == null || lastAccessTime == null) {\n@@ -95,4 +59,5 @@\n-                    if (useLutimes)\n-                        lutimes(path, accessValue, modValue);\n-                    else\n-                        futimens(fd, accessValue, modValue);\n+                    UnixFileAttributes attrs = UnixFileAttributes.get(path, followLinks);\n+                    if (lastModifiedTime == null)\n+                        lastModifiedTime = attrs.lastModifiedTime();\n+                    if (lastAccessTime == null)\n+                        lastAccessTime = attrs.lastAccessTime();\n@@ -100,20 +65,1 @@\n-                    \/\/ if futimens fails with EINVAL and one\/both of the times is\n-                    \/\/ negative then we adjust the value to the epoch and retry.\n-                    if (x.errno() == UnixConstants.EINVAL &&\n-                        (modValue < 0L || accessValue < 0L)) {\n-                        retry = true;\n-                    } else {\n-                        x.rethrowAsIOException(path);\n-                    }\n-                }\n-                if (retry) {\n-                    if (modValue < 0L) modValue = 0L;\n-                    if (accessValue < 0L) accessValue= 0L;\n-                    try {\n-                        if (useLutimes)\n-                            lutimes(path, accessValue, modValue);\n-                        else\n-                            futimens(fd, accessValue, modValue);\n-                    } catch (UnixException x) {\n-                        x.rethrowAsIOException(path);\n-                    }\n+                    x.rethrowAsIOException(path);\n@@ -123,4 +69,22 @@\n-            \/\/ set the creation time using setattrlist\n-            if (createTime != null) {\n-                long createValue = createTime.to(TimeUnit.NANOSECONDS);\n-                int commonattr = UnixConstants.ATTR_CMN_CRTIME;\n+            \/\/ update times\n+            long modValue = lastModifiedTime.to(TimeUnit.NANOSECONDS);\n+            long accessValue= lastAccessTime.to(TimeUnit.NANOSECONDS);\n+\n+            boolean retry = false;\n+            int flags = followLinks ? 0 : UnixConstants.AT_SYMLINK_NOFOLLOW;\n+            try {\n+                utimensat(UnixConstants.AT_FDCWD, path, accessValue,\n+                          modValue, flags);\n+            } catch (UnixException x) {\n+                \/\/ if utimensat fails with EINVAL and one\/both of the times is\n+                \/\/ negative then we adjust the value to the epoch and retry.\n+                if (x.errno() == UnixConstants.EINVAL &&\n+                    (modValue < 0L || accessValue < 0L)) {\n+                    retry = true;\n+                } else {\n+                    x.rethrowAsIOException(path);\n+                }\n+            }\n+            if (retry) {\n+                if (modValue < 0L) modValue = 0L;\n+                if (accessValue < 0L) accessValue= 0L;\n@@ -128,6 +92,2 @@\n-                    if (useLutimes)\n-                        setattrlist(path, commonattr, 0L, 0L, createValue,\n-                            followLinks ?  0 : UnixConstants.FSOPT_NOFOLLOW);\n-                    else\n-                        fsetattrlist(fd, commonattr, 0L, 0L, createValue,\n-                            followLinks ?  0 : UnixConstants.FSOPT_NOFOLLOW);\n+                    utimensat(UnixConstants.AT_FDCWD, path, accessValue,\n+                              modValue, flags);\n@@ -138,3 +98,12 @@\n-        } finally {\n-            if (!useLutimes)\n-                close(fd, e -> null);\n+        }\n+\n+        \/\/ set the creation time using setattrlist\n+        if (createTime != null) {\n+            long createValue = createTime.to(TimeUnit.NANOSECONDS);\n+            int commonattr = UnixConstants.ATTR_CMN_CRTIME;\n+            try {\n+                setattrlist(path, commonattr, 0L, 0L, createValue,\n+                    followLinks ?  0 : UnixConstants.FSOPT_NOFOLLOW);\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(path);\n+            }\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileAttributeViews.java","additions":49,"deletions":80,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -75,25 +75,10 @@\n-            boolean haveFd = false;\n-            boolean useFutimes = false;\n-            boolean useFutimens = false;\n-            boolean useLutimes = false;\n-            boolean useUtimensat = false;\n-            int fd = -1;\n-            try {\n-                if (!followLinks) {\n-                    \/\/ these path-based syscalls also work if following links\n-                    if (!(useUtimensat = utimensatSupported())) {\n-                        useLutimes = lutimesSupported();\n-                    }\n-                }\n-                if (!useUtimensat && !useLutimes) {\n-                    fd = file.openForAttributeAccess(followLinks);\n-                    if (fd != -1) {\n-                        haveFd = true;\n-                        if (!(useFutimens = futimensSupported())) {\n-                            useFutimes = futimesSupported();\n-                        }\n-                    }\n-                }\n-            } catch (UnixException x) {\n-                if (!(x.errno() == ENXIO ||\n-                     (x.errno() == ELOOP && (useUtimensat || useLutimes)))) {\n+            \/\/ if not changing both attributes then need existing attributes\n+            if (lastModifiedTime == null || lastAccessTime == null) {\n+                try {\n+                    UnixFileAttributes attrs =\n+                        UnixFileAttributes.get(file, followLinks);\n+                    if (lastModifiedTime == null)\n+                        lastModifiedTime = attrs.lastModifiedTime();\n+                    if (lastAccessTime == null)\n+                        lastAccessTime = attrs.lastAccessTime();\n+                } catch (UnixException x) {\n@@ -104,2 +89,3 @@\n-            try {\n-                \/\/ assert followLinks || !UnixFileAttributes.get(fd).isSymbolicLink();\n+            \/\/ update times\n+            long modValue = lastModifiedTime.to(TimeUnit.NANOSECONDS);\n+            long accessValue= lastAccessTime.to(TimeUnit.NANOSECONDS);\n@@ -107,13 +93,13 @@\n-                \/\/ if not changing both attributes then need existing attributes\n-                if (lastModifiedTime == null || lastAccessTime == null) {\n-                    try {\n-                        UnixFileAttributes attrs = haveFd ?\n-                            UnixFileAttributes.get(fd) :\n-                            UnixFileAttributes.get(file, followLinks);\n-                        if (lastModifiedTime == null)\n-                            lastModifiedTime = attrs.lastModifiedTime();\n-                        if (lastAccessTime == null)\n-                            lastAccessTime = attrs.lastAccessTime();\n-                    } catch (UnixException x) {\n-                        x.rethrowAsIOException(file);\n-                    }\n+            boolean retry = false;\n+            try {\n+                utimensat(AT_FDCWD, file, accessValue, modValue,\n+                          followLinks ? 0 : AT_SYMLINK_NOFOLLOW);\n+            } catch (UnixException x) {\n+                \/\/ if utimensat fails with EINVAL and one\/both of\n+                \/\/ the times is negative then we adjust the value to the\n+                \/\/ epoch and retry.\n+                if (x.errno() == EINVAL &&\n+                    (modValue < 0L || accessValue < 0L)) {\n+                    retry = true;\n+                } else {\n+                    x.rethrowAsIOException(file);\n@@ -121,8 +107,4 @@\n-\n-                \/\/ update times\n-                TimeUnit timeUnit = (useFutimens || useUtimensat) ?\n-                    TimeUnit.NANOSECONDS : TimeUnit.MICROSECONDS;\n-                long modValue = lastModifiedTime.to(timeUnit);\n-                long accessValue= lastAccessTime.to(timeUnit);\n-\n-                boolean retry = false;\n+            }\n+            if (retry) {\n+                if (modValue < 0L) modValue = 0L;\n+                if (accessValue < 0L) accessValue= 0L;\n@@ -130,12 +112,2 @@\n-                    if (useFutimens) {\n-                        futimens(fd, accessValue, modValue);\n-                    } else if (useFutimes) {\n-                        futimes(fd, accessValue, modValue);\n-                    } else if (useLutimes) {\n-                        lutimes(file, accessValue, modValue);\n-                    } else if (useUtimensat) {\n-                        utimensat(AT_FDCWD, file, accessValue, modValue,\n-                                  followLinks ? 0 : AT_SYMLINK_NOFOLLOW);\n-                    } else {\n-                        utimes(file, accessValue, modValue);\n-                    }\n+                    utimensat(AT_FDCWD, file, accessValue, modValue,\n+                              followLinks ? 0 : AT_SYMLINK_NOFOLLOW);\n@@ -143,28 +115,1 @@\n-                    \/\/ if futimes\/utimes fails with EINVAL and one\/both of the times is\n-                    \/\/ negative then we adjust the value to the epoch and retry.\n-                    if (x.errno() == EINVAL &&\n-                        (modValue < 0L || accessValue < 0L)) {\n-                        retry = true;\n-                    } else {\n-                        x.rethrowAsIOException(file);\n-                    }\n-                }\n-                if (retry) {\n-                    if (modValue < 0L) modValue = 0L;\n-                    if (accessValue < 0L) accessValue= 0L;\n-                    try {\n-                        if (useFutimens) {\n-                            futimens(fd, accessValue, modValue);\n-                        } else if (useFutimes) {\n-                            futimes(fd, accessValue, modValue);\n-                        } else if (useLutimes) {\n-                            lutimes(file, accessValue, modValue);\n-                        } else if (useUtimensat) {\n-                            utimensat(AT_FDCWD, file, accessValue, modValue,\n-                                      followLinks ? 0 : AT_SYMLINK_NOFOLLOW);\n-                        } else {\n-                            utimes(file, accessValue, modValue);\n-                        }\n-                    } catch (UnixException x) {\n-                        x.rethrowAsIOException(file);\n-                    }\n+                    x.rethrowAsIOException(file);\n@@ -172,2 +117,0 @@\n-            } finally {\n-                close(fd, e -> null);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileAttributeViews.java","additions":33,"deletions":90,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -580,4 +580,4 @@\n-                    if (dfd >= 0 && futimesSupported()) {\n-                        futimes(dfd,\n-                                attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                                attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                    if (dfd >= 0) {\n+                        futimens(dfd,\n+                                 attrs.lastAccessTime().to(TimeUnit.NANOSECONDS),\n+                                 attrs.lastModifiedTime().to(TimeUnit.NANOSECONDS));\n@@ -585,3 +585,3 @@\n-                        utimes(target,\n-                               attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                               attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                        utimensat(AT_FDCWD, target,\n+                                  attrs.lastAccessTime().to(TimeUnit.NANOSECONDS),\n+                                  attrs.lastModifiedTime().to(TimeUnit.NANOSECONDS), 0);\n@@ -730,9 +730,3 @@\n-                        if (futimesSupported()) {\n-                            futimes(fo,\n-                                    attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                                    attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                        } else {\n-                            utimes(target,\n-                                   attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                                   attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                        }\n+                        futimens(fo,\n+                                 attrs.lastAccessTime().to(TimeUnit.NANOSECONDS),\n+                                 attrs.lastModifiedTime().to(TimeUnit.NANOSECONDS));\n@@ -817,3 +811,4 @@\n-                    utimes(target,\n-                           attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                           attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                    utimensat(AT_FDCWD, target,\n+                              attrs.lastAccessTime().to(TimeUnit.NANOSECONDS),\n+                              attrs.lastModifiedTime().to(TimeUnit.NANOSECONDS),\n+                              0);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":14,"deletions":19,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -350,22 +350,0 @@\n-    \/**\n-     * utimes(const char* path, const struct timeval times[2])\n-     *\/\n-    static void utimes(UnixPath path, long times0, long times1)\n-        throws UnixException\n-    {\n-        try (NativeBuffer buffer = copyToNativeBuffer(path)) {\n-            utimes0(buffer.address(), times0, times1);\n-        }\n-    }\n-    private static native void utimes0(long pathAddress, long times0, long times1)\n-        throws UnixException;\n-\n-    \/**\n-     * futimes(int fildes, const struct timeval times[2])\n-     *\/\n-    static void futimes(int fd, long times0, long times1) throws UnixException {\n-        futimes0(fd, times0, times1);\n-    }\n-    private static native void futimes0(int fd, long times0, long times1)\n-        throws UnixException;\n-\n@@ -381,13 +359,0 @@\n-    \/**\n-     * lutimes(const char* path, const struct timeval times[2])\n-     *\/\n-    static void lutimes(UnixPath path, long times0, long times1)\n-        throws UnixException\n-    {\n-        try (NativeBuffer buffer = copyToNativeBuffer(path)) {\n-            lutimes0(buffer.address(), times0, times1);\n-        }\n-    }\n-    private static native void lutimes0(long pathAddress, long times0, long times1)\n-        throws UnixException;\n-\n@@ -571,5 +536,1 @@\n-    private static final int SUPPORTS_FUTIMES       = 1 << 2;\n-    private static final int SUPPORTS_FUTIMENS      = 1 << 3;\n-    private static final int SUPPORTS_LUTIMES       = 1 << 4;\n-    private static final int SUPPORTS_UTIMENSAT     = 1 << 5;\n-    private static final int SUPPORTS_XATTR         = 1 << 6;\n+    private static final int SUPPORTS_XATTR         = 1 << 3;\n@@ -586,28 +547,0 @@\n-    \/**\n-     * Supports futimes\n-     *\/\n-    static boolean futimesSupported() {\n-        return (capabilities & SUPPORTS_FUTIMES) != 0;\n-    }\n-\n-    \/**\n-     * Supports futimens\n-     *\/\n-    static boolean futimensSupported() {\n-        return (capabilities & SUPPORTS_FUTIMENS) != 0;\n-    }\n-\n-    \/**\n-     * Supports lutimes\n-     *\/\n-    static boolean lutimesSupported() {\n-        return (capabilities & SUPPORTS_LUTIMES) != 0;\n-    }\n-\n-    \/**\n-     * Supports utimensat\n-     *\/\n-    static boolean utimensatSupported() {\n-        return (capabilities & SUPPORTS_UTIMENSAT) != 0;\n-    }\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixNativeDispatcher.java","additions":1,"deletions":68,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -418,3 +418,3 @@\n-                        futimes(fd,\n-                                lastAccessTime.to(TimeUnit.MICROSECONDS),\n-                                lastModifiedTime.to(TimeUnit.MICROSECONDS));\n+                        futimens(fd,\n+                                 lastAccessTime.to(TimeUnit.NANOSECONDS),\n+                                 lastModifiedTime.to(TimeUnit.NANOSECONDS));\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixSecureDirectoryStream.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -207,3 +207,0 @@\n-typedef int futimes_func(int, const struct timeval *);\n-typedef int futimens_func(int, const struct timespec *);\n-typedef int lutimes_func(const char *, const struct timeval *);\n@@ -214,2 +211,0 @@\n-typedef int utimensat_func(int dirfd, const char *pathname,\n-                           const struct timespec[2], int flags);\n@@ -222,3 +217,0 @@\n-static futimes_func* my_futimes_func = NULL;\n-static futimens_func* my_futimens_func = NULL;\n-static lutimes_func* my_lutimes_func = NULL;\n@@ -228,1 +220,0 @@\n-static utimensat_func* my_utimensat_func = NULL;\n@@ -378,12 +369,0 @@\n-#if defined(__linux__) && defined(__arm__)\n-    my_futimes_func = (futimes_func*) lookup_time_t_function(\"futimes\",\n-        \"__futimes64\");\n-    my_lutimes_func = (lutimes_func*) lookup_time_t_function(\"lutimes\",\n-        \"__lutimes64\");\n-    my_futimens_func = (futimens_func*) lookup_time_t_function(\"futimens\",\n-        \"__futimens64\");\n-#else\n-    my_futimes_func = (futimes_func*) dlsym(RTLD_DEFAULT, \"futimes\");\n-    my_lutimes_func = (lutimes_func*) dlsym(RTLD_DEFAULT, \"lutimes\");\n-    my_futimens_func = (futimens_func*) dlsym(RTLD_DEFAULT, \"futimens\");\n-#endif\n@@ -405,14 +384,0 @@\n-    \/* supports futimes, futimens, and\/or lutimes *\/\n-\n-#ifdef _ALLBSD_SOURCE\n-    capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;\n-    capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_LUTIMES;\n-#else\n-    if (my_futimes_func != NULL)\n-        capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMES;\n-    if (my_lutimes_func != NULL)\n-        capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_LUTIMES;\n-#endif\n-    if (my_futimens_func != NULL)\n-        capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_FUTIMENS;\n-\n@@ -423,1 +388,1 @@\n-        my_futimes_func != NULL && my_fdopendir_func != NULL)\n+        my_fdopendir_func != NULL)\n@@ -438,4 +403,0 @@\n-    my_utimensat_func = (utimensat_func*) dlsym(RTLD_DEFAULT, \"utimensat\");\n-    if (my_utimensat_func != NULL) {\n-        capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_UTIMENSAT;\n-    }\n@@ -908,27 +869,0 @@\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_UnixNativeDispatcher_futimes0(JNIEnv* env, jclass this, jint filedes,\n-    jlong accessTime, jlong modificationTime)\n-{\n-    struct timeval times[2];\n-    int err = 0;\n-\n-    times[0].tv_sec = accessTime \/ 1000000;\n-    times[0].tv_usec = accessTime % 1000000;\n-\n-    times[1].tv_sec = modificationTime \/ 1000000;\n-    times[1].tv_usec = modificationTime % 1000000;\n-\n-#ifdef _ALLBSD_SOURCE\n-    RESTARTABLE(futimes(filedes, &times[0]), err);\n-#else\n-    if (my_futimes_func == NULL) {\n-        JNU_ThrowInternalError(env, \"my_futimes_func is NULL\");\n-        return;\n-    }\n-    RESTARTABLE((*my_futimes_func)(filedes, &times[0]), err);\n-#endif\n-    if (err == -1) {\n-        throwUnixException(env, errno);\n-    }\n-}\n-\n@@ -948,33 +882,1 @@\n-    if (my_futimens_func == NULL) {\n-        JNU_ThrowInternalError(env, \"my_futimens_func is NULL\");\n-        return;\n-    }\n-    RESTARTABLE((*my_futimens_func)(filedes, &times[0]), err);\n-    if (err == -1) {\n-        throwUnixException(env, errno);\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_UnixNativeDispatcher_lutimes0(JNIEnv* env, jclass this,\n-    jlong pathAddress, jlong accessTime, jlong modificationTime)\n-{\n-    int err;\n-    struct timeval times[2];\n-    const char* path = (const char*)jlong_to_ptr(pathAddress);\n-\n-    times[0].tv_sec = accessTime \/ 1000000;\n-    times[0].tv_usec = accessTime % 1000000;\n-\n-    times[1].tv_sec = modificationTime \/ 1000000;\n-    times[1].tv_usec = modificationTime % 1000000;\n-\n-#ifdef _ALLBSD_SOURCE\n-    RESTARTABLE(lutimes(path, &times[0]), err);\n-#else\n-    if (my_lutimes_func == NULL) {\n-        JNU_ThrowInternalError(env, \"my_lutimes_func is NULL\");\n-        return;\n-    }\n-    RESTARTABLE((*my_lutimes_func)(path, &times[0]), err);\n-#endif\n+    RESTARTABLE(futimens(filedes, &times[0]), err);\n@@ -989,1 +891,0 @@\n-#if defined(__linux__)\n@@ -1000,5 +901,1 @@\n-    if (my_utimensat_func == NULL) {\n-        JNU_ThrowInternalError(env, \"my_utimensat_func is NULL\");\n-        return;\n-    }\n-    RESTARTABLE((*my_utimensat_func)(fd, path, &times[0], flags), err);\n+    RESTARTABLE(utimensat(fd, path, &times[0], flags), err);\n@@ -1009,3 +906,0 @@\n-#else\n-    JNU_ThrowInternalError(env, \"should not reach here\");\n-#endif\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":3,"deletions":109,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -54,12 +54,0 @@\n-        if (!Platform.isWindows()) {\n-            \/\/ Check whether futimens() system call is supported\n-            Class unixNativeDispatcherClass =\n-                Class.forName(\"sun.nio.fs.UnixNativeDispatcher\");\n-            Method futimensSupported =\n-                unixNativeDispatcherClass.getDeclaredMethod(\"futimensSupported\");\n-            futimensSupported.setAccessible(true);\n-            if (!(boolean)futimensSupported.invoke(null)) {\n-                throw new SkippedException(\"futimens() not supported\");\n-            }\n-        }\n-\n@@ -83,4 +71,2 @@\n-        if (Platform.isLinux()) {\n-            testNanosLink(false);\n-            testNanosLink(true);\n-        }\n+        testNanosLink(false);\n+        testNanosLink(true);\n@@ -133,1 +119,8 @@\n-            var newTime = FileTime.from(1730417633157646106L, NANOSECONDS);\n+            long timeNanos = 1730417633157646106L;\n+\n+            \/\/ Windows file time resolution is 100ns so truncate\n+            if (Platform.isWindows()) {\n+                timeNanos = 100L*(timeNanos\/100L);\n+            }\n+\n+            var newTime = FileTime.from(timeNanos, NANOSECONDS);\n","filename":"test\/jdk\/java\/nio\/file\/attribute\/BasicFileAttributeView\/SetTimesNanos.java","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"}]}