{"files":[{"patch":"@@ -29,1 +29,0 @@\n-#include \"metaprogramming\/enableIf.hpp\"\n@@ -92,2 +91,6 @@\n-\n-\/\/ (3) Atomic pointers and atomic integers additionally provide\n+\/\/\n+\/\/ (3) Constructors for all atomic types are constexpr, to ensure non-local\n+\/\/ atomic variables are constant initialized (C++17 6.6.2) when initialized\n+\/\/ with suitable arguments.\n+\/\/\n+\/\/ (4) Atomic pointers and atomic integers additionally provide\n@@ -105,1 +108,1 @@\n-\/\/ (4) Atomic integers additionally provide\n+\/\/ (5) Atomic integers additionally provide\n@@ -115,1 +118,1 @@\n-\/\/ (5) Atomic pointers additionally provide\n+\/\/ (6) Atomic pointers additionally provide\n@@ -220,1 +223,1 @@\n-  explicit CommonCore(T value) : _value(value) {}\n+  explicit constexpr CommonCore(T value) : _value(value) {}\n@@ -293,1 +296,1 @@\n-  explicit SupportsArithmetic(T value) : CommonCore<T>(value) {}\n+  explicit constexpr SupportsArithmetic(T value) : CommonCore<T>(value) {}\n@@ -336,1 +339,1 @@\n-  explicit Atomic(T value = 0) : SupportsArithmetic<T>(value) {}\n+  explicit constexpr Atomic(T value = 0) : SupportsArithmetic<T>(value) {}\n@@ -376,1 +379,1 @@\n-  explicit Atomic(T value = 0) : CommonCore<T>(value) {}\n+  explicit constexpr Atomic(T value = 0) : CommonCore<T>(value) {}\n@@ -392,1 +395,1 @@\n-  explicit Atomic(T value = nullptr) : SupportsArithmetic<T>(value) {}\n+  explicit constexpr Atomic(T value = nullptr) : SupportsArithmetic<T>(value) {}\n@@ -413,1 +416,10 @@\n-  static Decayed decay(T x) { return Translator::decay(x); }\n+  \/\/ The decay function and the constructors are constexpr so that a non-local\n+  \/\/ atomic object constructed with constant arguments will be a constant\n+  \/\/ initialization.  One might ask why it's not a problem that some\n+  \/\/ specializations of these functions are not constant expressions. The\n+  \/\/ answer lies in C++17 10.1.5\/6, along with us having *some* constexpr\n+  \/\/ translator decay functions, constexpr ctors for some translated types,\n+  \/\/ and constexpr ctors for some decayed types.  Also, C++23 removes those\n+  \/\/ restrictions on constexpr functions and ctors.\n+\n+  static constexpr Decayed decay(T x) { return Translator::decay(x); }\n@@ -418,1 +430,1 @@\n-  explicit Atomic(UseDecayedCtor) : _value() {}\n+  explicit constexpr Atomic(UseDecayedCtor) : _value() {}\n@@ -427,1 +439,1 @@\n-  Atomic() : Atomic(DefaultCtorSelect()) {}\n+  constexpr Atomic() : Atomic(DefaultCtorSelect()) {}\n@@ -429,1 +441,1 @@\n-  explicit Atomic(T value) : _value(decay(value)) {}\n+  explicit constexpr Atomic(T value) : _value(decay(value)) {}\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":26,"deletions":14,"binary":false,"changes":40,"status":"modified"}]}