{"files":[{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"gc\/z\/zAllocator.hpp\"\n-#include \"gc\/z\/zObjectAllocator.hpp\"\n-#include \"gc\/z\/zPageAge.inline.hpp\"\n-\n-ZAllocatorEden*          ZAllocator::_eden;\n-ZAllocatorForRelocation* ZAllocator::_relocation[ZAllocator::_relocation_allocators];\n-\n-ZAllocator::ZAllocator(ZPageAge age)\n-  : _object_allocator(age) {}\n-\n-void ZAllocator::retire_pages() {\n-  _object_allocator.retire_pages();\n-}\n-\n-ZAllocatorEden::ZAllocatorEden()\n-  : ZAllocator(ZPageAge::eden) {\n-  ZAllocator::_eden = this;\n-}\n-\n-size_t ZAllocatorEden::remaining() const {\n-  return _object_allocator.remaining();\n-}\n-\n-ZPageAge ZAllocatorForRelocation::install() {\n-  for (uint i = 0; i < ZAllocator::_relocation_allocators; ++i) {\n-    if (_relocation[i] == nullptr) {\n-      _relocation[i] = this;\n-      return to_zpageage(i + 1);\n-    }\n-  }\n-\n-  ShouldNotReachHere();\n-  return ZPageAge::eden;\n-}\n-\n-ZAllocatorForRelocation::ZAllocatorForRelocation()\n-  : ZAllocator(install()) {}\n-\n-zaddress ZAllocatorForRelocation::alloc_object(size_t size) {\n-  return _object_allocator.alloc_object_for_relocation(size);\n-}\n-\n-void ZAllocatorForRelocation::undo_alloc_object(zaddress addr, size_t size) {\n-  _object_allocator.undo_alloc_object_for_relocation(addr, size);\n-}\n-\n-ZPage* ZAllocatorForRelocation::alloc_page_for_relocation(ZPageType type, size_t size, ZAllocationFlags flags) {\n-  return _object_allocator.alloc_page_for_relocation(type, size, flags);\n-}\n","filename":"src\/hotspot\/share\/gc\/z\/zAllocator.cpp","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_GC_Z_ZALLOCATOR_HPP\n-#define SHARE_GC_Z_ZALLOCATOR_HPP\n-\n-#include \"gc\/z\/zAllocationFlags.hpp\"\n-#include \"gc\/z\/zObjectAllocator.hpp\"\n-#include \"gc\/z\/zPageAge.hpp\"\n-#include \"gc\/z\/zPageType.hpp\"\n-\n-class ZAllocatorEden;\n-class ZAllocatorForRelocation;\n-class ZPage;\n-\n-class ZAllocator {\n-public:\n-  static constexpr uint _relocation_allocators = ZPageAgeCount - 1;\n-\n-protected:\n-  ZObjectAllocator _object_allocator;\n-\n-  static ZAllocatorEden*          _eden;\n-  static ZAllocatorForRelocation* _relocation[ZAllocator::_relocation_allocators];\n-\n-public:\n-  static ZAllocatorEden* eden();\n-  static ZAllocatorForRelocation* relocation(ZPageAge page_age);\n-  static ZAllocatorForRelocation* old();\n-\n-  ZAllocator(ZPageAge age);\n-\n-  void retire_pages();\n-};\n-\n-class ZAllocatorEden : public ZAllocator {\n-public:\n-  ZAllocatorEden();\n-\n-  \/\/ Mutator allocation\n-  zaddress alloc_tlab(size_t size);\n-  zaddress alloc_object(size_t size);\n-\n-  \/\/ Statistics\n-  size_t remaining() const;\n-};\n-\n-class ZAllocatorForRelocation : public ZAllocator {\n-private:\n-  ZPageAge install();\n-\n-public:\n-  ZAllocatorForRelocation();\n-\n-  \/\/ Relocation\n-  zaddress alloc_object(size_t size);\n-  void undo_alloc_object(zaddress addr, size_t size);\n-\n-  ZPage* alloc_page_for_relocation(ZPageType type, size_t size, ZAllocationFlags flags);\n-};\n-\n-#endif \/\/ SHARE_GC_Z_ZALLOCATOR_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zAllocator.hpp","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_GC_Z_ZALLOCATOR_INLINE_HPP\n-#define SHARE_GC_Z_ZALLOCATOR_INLINE_HPP\n-\n-#include \"gc\/z\/zAllocator.hpp\"\n-\n-#include \"gc\/z\/zAddress.inline.hpp\"\n-#include \"gc\/z\/zHeap.hpp\"\n-#include \"gc\/z\/zPageAge.inline.hpp\"\n-\n-inline ZAllocatorEden* ZAllocator::eden() {\n-  return _eden;\n-}\n-\n-inline ZAllocatorForRelocation* ZAllocator::relocation(ZPageAge page_age) {\n-  return _relocation[untype(page_age - 1)];\n-}\n-\n-inline ZAllocatorForRelocation* ZAllocator::old() {\n-  return relocation(ZPageAge::old);\n-}\n-\n-inline zaddress ZAllocatorEden::alloc_tlab(size_t size) {\n-  guarantee(size <= ZHeap::heap()->max_tlab_size(), \"TLAB too large\");\n-  return _object_allocator.alloc_object(size);\n-}\n-\n-inline zaddress ZAllocatorEden::alloc_object(size_t size) {\n-  const zaddress addr = _object_allocator.alloc_object(size);\n-\n-  if (is_null(addr)) {\n-    ZHeap::heap()->out_of_memory();\n-  }\n-\n-  return addr;\n-}\n-\n-#endif \/\/ SHARE_GC_Z_ZALLOCATOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zAllocator.inline.hpp","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/z\/zAllocator.inline.hpp\"\n@@ -139,1 +138,1 @@\n-  const zaddress addr = ZAllocator::eden()->alloc_tlab(size_in_bytes);\n+  const zaddress addr = ZHeap::heap()->alloc_tlab(size_in_bytes);\n@@ -155,1 +154,1 @@\n-  return (HeapWord*)ZAllocator::eden()->alloc_object(size_in_bytes);\n+  return (HeapWord*)ZHeap::heap()->alloc_object(size_in_bytes);\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"gc\/z\/zAllocator.inline.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"gc\/z\/zObjectAllocator.hpp\"\n@@ -844,4 +844,1 @@\n-  ZAllocator::eden()->retire_pages();\n-  for (ZPageAge age : ZPageAgeRangeSurvivor) {\n-    ZAllocator::relocation(age)->retire_pages();\n-  }\n+  ZObjectAllocator::retire_pages(ZPageAgeRangeYoung);\n@@ -1204,1 +1201,1 @@\n-  ZAllocator::old()->retire_pages();\n+  ZObjectAllocator::retire_pages(ZPageAgeRangeOld);\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/z\/zObjectAllocator.hpp\"\n@@ -60,2 +61,0 @@\n-    _allocator_eden(),\n-    _allocator_relocation(),\n@@ -147,1 +146,1 @@\n-  size_t size = _allocator_eden.remaining();\n+  size_t size = ZObjectAllocator::remaining_in_eden();\n@@ -219,1 +218,1 @@\n-void ZHeap::out_of_memory() {\n+void ZHeap::out_of_memory() const {\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/z\/zAllocator.hpp\"\n@@ -51,3 +50,0 @@\n-  ZAllocatorEden          _allocator_eden;\n-  ZAllocatorForRelocation _allocator_relocation[ZAllocator::_relocation_allocators];\n-\n@@ -74,1 +70,1 @@\n-  void out_of_memory();\n+  void out_of_memory() const;\n@@ -118,0 +114,2 @@\n+  zaddress alloc_object(size_t size) const;\n+  zaddress alloc_tlab(size_t size) const;\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/z\/zObjectAllocator.hpp\"\n@@ -77,0 +78,15 @@\n+inline zaddress ZHeap::alloc_object(size_t size) const {\n+  const zaddress addr = ZObjectAllocator::alloc_object(size, ZPageAge::eden);\n+\n+  if (is_null(addr)) {\n+    out_of_memory();\n+  }\n+\n+  return addr;\n+}\n+\n+inline zaddress ZHeap::alloc_tlab(size_t size) const {\n+  guarantee(size <= max_tlab_size(), \"TLAB too large\");\n+  return ZObjectAllocator::alloc_object(size, ZPageAge::eden);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.inline.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/z\/zObjectAllocator.hpp\"\n@@ -71,0 +72,1 @@\n+  ZObjectAllocator::initialize();\n","filename":"src\/hotspot\/share\/gc\/z\/zInitialize.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include \"gc\/z\/zAllocationFlags.hpp\"\n@@ -30,1 +31,2 @@\n-#include \"gc\/z\/zPageTable.inline.hpp\"\n+#include \"gc\/z\/zPageAge.inline.hpp\"\n+#include \"gc\/z\/zPageType.hpp\"\n@@ -39,0 +41,2 @@\n+#include \"utilities\/deferred.hpp\"\n+#include \"utilities\/valueObjArray.hpp\"\n@@ -43,1 +47,42 @@\n-ZObjectAllocator::ZObjectAllocator(ZPageAge age)\n+class ZObjectAllocatorImpl {\n+public:\n+  const ZPageAge     _age;\n+  const bool         _use_per_cpu_shared_small_pages;\n+  ZPerCPU<ZPage*>    _shared_small_page;\n+  ZContended<ZPage*> _shared_medium_page;\n+  ZLock              _medium_page_alloc_lock;\n+\n+  ZObjectAllocatorImpl(ZPageAge age);\n+\n+  ZPage** shared_small_page_addr();\n+  ZPage* const* shared_small_page_addr() const;\n+\n+  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags);\n+  void undo_alloc_page(ZPage* page);\n+\n+  \/\/ Allocate an object in a shared page. Allocate and\n+  \/\/ atomically install a new page if necessary.\n+  zaddress alloc_object_in_shared_page(ZPage** shared_page,\n+                                       ZPageType page_type,\n+                                       size_t page_size,\n+                                       size_t size,\n+                                       ZAllocationFlags flags);\n+\n+  zaddress alloc_object_in_medium_page(size_t size,\n+                                       ZAllocationFlags flags);\n+\n+  zaddress alloc_large_object(size_t size, ZAllocationFlags flags);\n+  zaddress alloc_medium_object(size_t size, ZAllocationFlags flags);\n+  zaddress alloc_small_object(size_t size, ZAllocationFlags flags);\n+  zaddress alloc_object(size_t size, ZAllocationFlags flags);\n+\n+  void retire_pages();\n+};\n+\n+static Deferred<ValueObjArray<ZObjectAllocatorImpl, ZObjectAllocator::NumAllocators>> ZObjectAllocators;\n+\n+static ZObjectAllocatorImpl* allocator(ZPageAge age) {\n+  return ZObjectAllocators->at((int)untype(age));\n+}\n+\n+ZObjectAllocatorImpl::ZObjectAllocatorImpl(ZPageAge age)\n@@ -50,1 +95,1 @@\n-ZPage** ZObjectAllocator::shared_small_page_addr() {\n+ZPage** ZObjectAllocatorImpl::shared_small_page_addr() {\n@@ -54,1 +99,1 @@\n-ZPage* const* ZObjectAllocator::shared_small_page_addr() const {\n+ZPage* const* ZObjectAllocatorImpl::shared_small_page_addr() const {\n@@ -58,5 +103,1 @@\n-ZPage* ZObjectAllocator::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags) {\n-  return ZHeap::heap()->alloc_page(type, size, flags, _age);\n-}\n-\n-ZPage* ZObjectAllocator::alloc_page_for_relocation(ZPageType type, size_t size, ZAllocationFlags flags) {\n+ZPage* ZObjectAllocatorImpl::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags) {\n@@ -66,1 +107,1 @@\n-void ZObjectAllocator::undo_alloc_page(ZPage* page) {\n+void ZObjectAllocatorImpl::undo_alloc_page(ZPage* page) {\n@@ -70,5 +111,5 @@\n-zaddress ZObjectAllocator::alloc_object_in_shared_page(ZPage** shared_page,\n-                                                       ZPageType page_type,\n-                                                       size_t page_size,\n-                                                       size_t size,\n-                                                       ZAllocationFlags flags) {\n+zaddress ZObjectAllocatorImpl::alloc_object_in_shared_page(ZPage** shared_page,\n+                                                           ZPageType page_type,\n+                                                           size_t page_size,\n+                                                           size_t size,\n+                                                           ZAllocationFlags flags) {\n@@ -119,2 +160,2 @@\n-zaddress ZObjectAllocator::alloc_object_in_medium_page(size_t size,\n-                                                       ZAllocationFlags flags) {\n+zaddress ZObjectAllocatorImpl::alloc_object_in_medium_page(size_t size,\n+                                                           ZAllocationFlags flags) {\n@@ -168,1 +209,1 @@\n-zaddress ZObjectAllocator::alloc_large_object(size_t size, ZAllocationFlags flags) {\n+zaddress ZObjectAllocatorImpl::alloc_large_object(size_t size, ZAllocationFlags flags) {\n@@ -182,1 +223,1 @@\n-zaddress ZObjectAllocator::alloc_medium_object(size_t size, ZAllocationFlags flags) {\n+zaddress ZObjectAllocatorImpl::alloc_medium_object(size_t size, ZAllocationFlags flags) {\n@@ -186,1 +227,1 @@\n-zaddress ZObjectAllocator::alloc_small_object(size_t size, ZAllocationFlags flags) {\n+zaddress ZObjectAllocatorImpl::alloc_small_object(size_t size, ZAllocationFlags flags) {\n@@ -190,1 +231,1 @@\n-zaddress ZObjectAllocator::alloc_object(size_t size, ZAllocationFlags flags) {\n+zaddress ZObjectAllocatorImpl::alloc_object(size_t size, ZAllocationFlags flags) {\n@@ -203,8 +244,2 @@\n-zaddress ZObjectAllocator::alloc_object(size_t size) {\n-  const ZAllocationFlags flags;\n-  return alloc_object(size, flags);\n-}\n-\n-zaddress ZObjectAllocator::alloc_object_for_relocation(size_t size) {\n-  ZAllocationFlags flags;\n-  flags.set_non_blocking();\n+void ZObjectAllocatorImpl::retire_pages() {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"Should be at safepoint\");\n@@ -212,1 +247,3 @@\n-  return alloc_object(size, flags);\n+  \/\/ Reset allocation pages\n+  _shared_medium_page.set(nullptr);\n+  _shared_small_page.set_all(nullptr);\n@@ -215,13 +252,3 @@\n-void ZObjectAllocator::undo_alloc_object_for_relocation(zaddress addr, size_t size) {\n-  ZPage* const page = ZHeap::heap()->page(addr);\n-\n-  if (page->is_large()) {\n-    undo_alloc_page(page);\n-    ZStatInc(ZCounterUndoObjectAllocationSucceeded);\n-  } else {\n-    if (page->undo_alloc_object_atomic(addr, size)) {\n-      ZStatInc(ZCounterUndoObjectAllocationSucceeded);\n-    } else {\n-      ZStatInc(ZCounterUndoObjectAllocationFailed);\n-    }\n-  }\n+void ZObjectAllocator::initialize() {\n+  ZPageAgeRange::Iterator it = ZPageAgeRange().begin();\n+  ZObjectAllocators.initialize(it);\n@@ -230,2 +257,4 @@\n-ZPageAge ZObjectAllocator::age() const {\n-  return _age;\n+void ZObjectAllocator::retire_pages(ZPageAgeRange range) {\n+  for (ZPageAge age : range) {\n+    allocator(age)->retire_pages();\n+  }\n@@ -234,1 +263,1 @@\n-size_t ZObjectAllocator::remaining() const {\n+size_t ZObjectAllocator::remaining_in_eden() {\n@@ -237,1 +266,2 @@\n-  const ZPage* const page = Atomic::load_acquire(shared_small_page_addr());\n+  ZPage** const shared_addr = allocator(ZPageAge::eden)->shared_small_page_addr();\n+  const ZPage* const page = Atomic::load_acquire(shared_addr);\n@@ -245,2 +275,2 @@\n-void ZObjectAllocator::retire_pages() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Should be at safepoint\");\n+zaddress ZObjectAllocator::alloc_object(size_t size, ZPageAge age) {\n+  ZAllocationFlags flags;\n@@ -248,3 +278,21 @@\n-  \/\/ Reset allocation pages\n-  _shared_medium_page.set(nullptr);\n-  _shared_small_page.set_all(nullptr);\n+  if (age != ZPageAge::eden) {\n+    \/\/ Object allocation for relocation should not block\n+    flags.set_non_blocking();\n+  }\n+\n+  return allocator(age)->alloc_object(size, flags);\n+}\n+\n+void ZObjectAllocator::undo_alloc_object(zaddress addr, size_t size, ZPageAge age) {\n+  ZPage* const page = ZHeap::heap()->page(addr);\n+\n+  if (page->is_large()) {\n+    allocator(age)->undo_alloc_page(page);\n+    ZStatInc(ZCounterUndoObjectAllocationSucceeded);\n+  } else {\n+    if (page->undo_alloc_object_atomic(addr, size)) {\n+      ZStatInc(ZCounterUndoObjectAllocationSucceeded);\n+    } else {\n+      ZStatInc(ZCounterUndoObjectAllocationFailed);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":100,"deletions":52,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-#include \"gc\/z\/zAllocationFlags.hpp\"\n-#include \"gc\/z\/zLock.hpp\"\n@@ -31,35 +29,1 @@\n-#include \"gc\/z\/zPageType.hpp\"\n-#include \"gc\/z\/zValue.hpp\"\n-\n-class ZPage;\n-class ZPageTable;\n-\n-class ZObjectAllocator {\n-private:\n-  ZPageAge           _age;\n-  const bool         _use_per_cpu_shared_small_pages;\n-  ZPerCPU<ZPage*>    _shared_small_page;\n-  ZContended<ZPage*> _shared_medium_page;\n-  ZLock              _medium_page_alloc_lock;\n-\n-  ZPage** shared_small_page_addr();\n-  ZPage* const* shared_small_page_addr() const;\n-\n-  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags);\n-  void undo_alloc_page(ZPage* page);\n-\n-  \/\/ Allocate an object in a shared page. Allocate and\n-  \/\/ atomically install a new page if necessary.\n-  zaddress alloc_object_in_shared_page(ZPage** shared_page,\n-                                       ZPageType page_type,\n-                                       size_t page_size,\n-                                       size_t size,\n-                                       ZAllocationFlags flags);\n-\n-  zaddress alloc_object_in_medium_page(size_t size,\n-                                       ZAllocationFlags flags);\n-\n-  zaddress alloc_large_object(size_t size, ZAllocationFlags flags);\n-  zaddress alloc_medium_object(size_t size, ZAllocationFlags flags);\n-  zaddress alloc_small_object(size_t size, ZAllocationFlags flags);\n-  zaddress alloc_object(size_t size, ZAllocationFlags flags);\n+#include \"memory\/allStatic.hpp\"\n@@ -67,0 +31,1 @@\n+class ZObjectAllocator : public AllStatic {\n@@ -68,4 +33,2 @@\n-  ZObjectAllocator(ZPageAge age);\n-\n-  \/\/ Mutator allocation\n-  zaddress alloc_object(size_t size);\n+  static constexpr uint NumAllocators = ZPageAgeCount;\n+  static constexpr uint NumRelocationAllocators = NumAllocators - 1;\n@@ -73,3 +36,1 @@\n-  \/\/ Relocation\n-  zaddress alloc_object_for_relocation(size_t size);\n-  void undo_alloc_object_for_relocation(zaddress addr, size_t size);\n+  static void initialize();\n@@ -77,1 +38,1 @@\n-  ZPage* alloc_page_for_relocation(ZPageType type, size_t size, ZAllocationFlags flags);\n+  static void retire_pages(ZPageAgeRange range);\n@@ -79,1 +40,1 @@\n-  ZPageAge age() const;\n+  static size_t remaining_in_eden();\n@@ -81,3 +42,3 @@\n-  size_t remaining() const;\n-\n-  void retire_pages();\n+  \/\/ Mutator allocation\n+  static zaddress alloc_object(size_t size, ZPageAge age);\n+  static void undo_alloc_object(zaddress addr, size_t size, ZPageAge age);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.hpp","additions":11,"deletions":50,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/z\/zAllocator.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"gc\/z\/zObjectAllocator.hpp\"\n@@ -37,1 +37,1 @@\n-#include \"gc\/z\/zPageAge.hpp\"\n+#include \"gc\/z\/zPageAge.inline.hpp\"\n@@ -328,0 +328,1 @@\n+  const ZPageAge to_age = forwarding->to_age();\n@@ -329,3 +330,1 @@\n-  ZAllocatorForRelocation* allocator = ZAllocator::relocation(forwarding->to_age());\n-\n-  const zaddress to_addr = allocator->alloc_object(size);\n+  const zaddress to_addr = ZObjectAllocator::alloc_object(size, to_age);\n@@ -346,1 +345,1 @@\n-    allocator->undo_alloc_object(to_addr, size);\n+    ZObjectAllocator::undo_alloc_object(to_addr, size, to_age);\n@@ -388,1 +387,1 @@\n-static ZPage* alloc_page(ZAllocatorForRelocation* allocator, ZPageType type, size_t size) {\n+static ZPage* alloc_page(ZForwarding* forwarding) {\n@@ -395,0 +394,4 @@\n+  const ZPageType type = forwarding->type();\n+  const size_t size = forwarding->size();\n+  const ZPageAge age = forwarding->to_age();\n+\n@@ -399,1 +402,1 @@\n-  return allocator->alloc_page_for_relocation(type, size, flags);\n+  return ZHeap::heap()->alloc_page(type, size, flags, age);\n@@ -429,2 +432,1 @@\n-    ZAllocatorForRelocation* const allocator = ZAllocator::relocation(forwarding->to_age());\n-    ZPage* const page = alloc_page(allocator, forwarding->type(), forwarding->size());\n+    ZPage* const page = alloc_page(forwarding);\n@@ -470,1 +472,1 @@\n-  ZPage*             _shared[ZAllocator::_relocation_allocators];\n+  ZPage*             _shared[ZObjectAllocator::NumRelocationAllocators];\n@@ -483,1 +485,1 @@\n-    for (uint i = 0; i < ZAllocator::_relocation_allocators; ++i) {\n+    for (uint i = 0; i < ZObjectAllocator::NumRelocationAllocators; ++i) {\n@@ -512,2 +514,1 @@\n-      ZAllocatorForRelocation* const allocator = ZAllocator::relocation(forwarding->to_age());\n-      ZPage* const to_page = alloc_page(allocator, forwarding->type(), forwarding->size());\n+      ZPage* const to_page = alloc_page(forwarding);\n@@ -565,1 +566,1 @@\n-  ZPage*              _target[ZAllocator::_relocation_allocators];\n+  ZPage*              _target[ZObjectAllocator::NumRelocationAllocators];\n@@ -919,1 +920,1 @@\n-    for (uint i = 0; i < ZAllocator::_relocation_allocators; ++i) {\n+    for (uint i = 0; i < ZObjectAllocator::NumRelocationAllocators; ++i) {\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"}]}