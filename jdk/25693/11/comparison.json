{"files":[{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"gc\/z\/zAllocator.hpp\"\n-#include \"gc\/z\/zObjectAllocator.hpp\"\n-#include \"gc\/z\/zPageAge.inline.hpp\"\n-\n-ZAllocatorEden*          ZAllocator::_eden;\n-ZAllocatorForRelocation* ZAllocator::_relocation[ZAllocator::_relocation_allocators];\n-\n-ZAllocator::ZAllocator(ZPageAge age)\n-  : _object_allocator(age) {}\n-\n-void ZAllocator::retire_pages() {\n-  _object_allocator.retire_pages();\n-}\n-\n-ZAllocatorEden::ZAllocatorEden()\n-  : ZAllocator(ZPageAge::eden) {\n-  ZAllocator::_eden = this;\n-}\n-\n-size_t ZAllocatorEden::remaining() const {\n-  return _object_allocator.remaining();\n-}\n-\n-ZPageAge ZAllocatorForRelocation::install() {\n-  for (uint i = 0; i < ZAllocator::_relocation_allocators; ++i) {\n-    if (_relocation[i] == nullptr) {\n-      _relocation[i] = this;\n-      return to_zpageage(i + 1);\n-    }\n-  }\n-\n-  ShouldNotReachHere();\n-  return ZPageAge::eden;\n-}\n-\n-ZAllocatorForRelocation::ZAllocatorForRelocation()\n-  : ZAllocator(install()) {}\n-\n-zaddress ZAllocatorForRelocation::alloc_object(size_t size) {\n-  return _object_allocator.alloc_object_for_relocation(size);\n-}\n-\n-void ZAllocatorForRelocation::undo_alloc_object(zaddress addr, size_t size) {\n-  _object_allocator.undo_alloc_object_for_relocation(addr, size);\n-}\n-\n-ZPage* ZAllocatorForRelocation::alloc_page_for_relocation(ZPageType type, size_t size, ZAllocationFlags flags) {\n-  return _object_allocator.alloc_page_for_relocation(type, size, flags);\n-}\n","filename":"src\/hotspot\/share\/gc\/z\/zAllocator.cpp","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_GC_Z_ZALLOCATOR_HPP\n-#define SHARE_GC_Z_ZALLOCATOR_HPP\n-\n-#include \"gc\/z\/zAllocationFlags.hpp\"\n-#include \"gc\/z\/zObjectAllocator.hpp\"\n-#include \"gc\/z\/zPageAge.hpp\"\n-#include \"gc\/z\/zPageType.hpp\"\n-\n-class ZAllocatorEden;\n-class ZAllocatorForRelocation;\n-class ZPage;\n-\n-class ZAllocator {\n-public:\n-  static constexpr uint _relocation_allocators = ZPageAgeCount - 1;\n-\n-protected:\n-  ZObjectAllocator _object_allocator;\n-\n-  static ZAllocatorEden*          _eden;\n-  static ZAllocatorForRelocation* _relocation[ZAllocator::_relocation_allocators];\n-\n-public:\n-  static ZAllocatorEden* eden();\n-  static ZAllocatorForRelocation* relocation(ZPageAge page_age);\n-  static ZAllocatorForRelocation* old();\n-\n-  ZAllocator(ZPageAge age);\n-\n-  void retire_pages();\n-};\n-\n-class ZAllocatorEden : public ZAllocator {\n-public:\n-  ZAllocatorEden();\n-\n-  \/\/ Mutator allocation\n-  zaddress alloc_tlab(size_t size);\n-  zaddress alloc_object(size_t size);\n-\n-  \/\/ Statistics\n-  size_t remaining() const;\n-};\n-\n-class ZAllocatorForRelocation : public ZAllocator {\n-private:\n-  ZPageAge install();\n-\n-public:\n-  ZAllocatorForRelocation();\n-\n-  \/\/ Relocation\n-  zaddress alloc_object(size_t size);\n-  void undo_alloc_object(zaddress addr, size_t size);\n-\n-  ZPage* alloc_page_for_relocation(ZPageType type, size_t size, ZAllocationFlags flags);\n-};\n-\n-#endif \/\/ SHARE_GC_Z_ZALLOCATOR_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zAllocator.hpp","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_GC_Z_ZALLOCATOR_INLINE_HPP\n-#define SHARE_GC_Z_ZALLOCATOR_INLINE_HPP\n-\n-#include \"gc\/z\/zAllocator.hpp\"\n-\n-#include \"gc\/z\/zAddress.inline.hpp\"\n-#include \"gc\/z\/zHeap.hpp\"\n-#include \"gc\/z\/zPageAge.inline.hpp\"\n-\n-inline ZAllocatorEden* ZAllocator::eden() {\n-  return _eden;\n-}\n-\n-inline ZAllocatorForRelocation* ZAllocator::relocation(ZPageAge page_age) {\n-  return _relocation[untype(page_age - 1)];\n-}\n-\n-inline ZAllocatorForRelocation* ZAllocator::old() {\n-  return relocation(ZPageAge::old);\n-}\n-\n-inline zaddress ZAllocatorEden::alloc_tlab(size_t size) {\n-  guarantee(size <= ZHeap::heap()->max_tlab_size(), \"TLAB too large\");\n-  return _object_allocator.alloc_object(size);\n-}\n-\n-inline zaddress ZAllocatorEden::alloc_object(size_t size) {\n-  const zaddress addr = _object_allocator.alloc_object(size);\n-\n-  if (is_null(addr)) {\n-    ZHeap::heap()->out_of_memory();\n-  }\n-\n-  return addr;\n-}\n-\n-#endif \/\/ SHARE_GC_Z_ZALLOCATOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zAllocator.inline.hpp","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/z\/zAllocator.inline.hpp\"\n@@ -139,1 +138,1 @@\n-  const zaddress addr = ZAllocator::eden()->alloc_tlab(size_in_bytes);\n+  const zaddress addr = ZHeap::heap()->alloc_tlab(size_in_bytes);\n@@ -155,1 +154,1 @@\n-  return (HeapWord*)ZAllocator::eden()->alloc_object(size_in_bytes);\n+  return (HeapWord*)ZHeap::heap()->alloc_object(size_in_bytes);\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_GC_Z_ZDEFERREDCONSTRUCTED_HPP\n+#define SHARE_GC_Z_ZDEFERREDCONSTRUCTED_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+template <typename T>\n+class ZDeferredConstructed {\n+  union {\n+    T _t;\n+  };\n+\n+  DEBUG_ONLY(bool _initialized;)\n+\n+  NONCOPYABLE(ZDeferredConstructed);\n+\n+public:\n+  ZDeferredConstructed();\n+  ~ZDeferredConstructed();\n+\n+  T* get();\n+  const T* get() const;\n+\n+  T& operator*();\n+  const T& operator*() const;\n+\n+  T* operator->();\n+  const T* operator->() const;\n+\n+  template <typename... Ts>\n+  void initialize(Ts&&... args);\n+};\n+\n+#endif \/\/ SHARE_GC_Z_ZDEFERREDCONSTRUCTED_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zDeferredConstructed.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+* Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\n+*\/\n+\n+#ifndef SHARE_GC_Z_ZDEFERREDCONSTRUCTED_INLINE_HPP\n+#define SHARE_GC_Z_ZDEFERREDCONSTRUCTED_INLINE_HPP\n+\n+#include \"gc\/z\/zDeferredConstructed.hpp\"\n+\n+#include <new>\n+#include <type_traits>\n+\n+template <typename T>\n+inline ZDeferredConstructed<T>::ZDeferredConstructed()\n+  DEBUG_ONLY(: _initialized(false)) {\n+  \/\/ Do not construct value immediately. Value is constructed at a later point\n+  \/\/ in time using initialize().\n+}\n+\n+template <typename T>\n+inline ZDeferredConstructed<T>::~ZDeferredConstructed() {\n+  assert(_initialized, \"must be initialized before being destructed\");\n+  _t.~T();\n+}\n+\n+template <typename T>\n+inline T* ZDeferredConstructed<T>::get() {\n+  assert(_initialized, \"must be initialized before access\");\n+  return &_t;\n+}\n+\n+template <typename T>\n+inline const T* ZDeferredConstructed<T>::get() const {\n+  assert(_initialized, \"must be initialized before access\");\n+  return &_t;\n+}\n+\n+template <typename T>\n+inline T& ZDeferredConstructed<T>::operator*() {\n+  return *get();\n+}\n+\n+template <typename T>\n+inline const T& ZDeferredConstructed<T>::operator*() const {\n+  return *get();\n+}\n+\n+template <typename T>\n+inline T* ZDeferredConstructed<T>::operator->() {\n+  return get();\n+}\n+\n+template <typename T>\n+inline const T* ZDeferredConstructed<T>::operator->() const {\n+  return get();\n+}\n+\n+template <typename T>\n+template <typename... Ts>\n+inline void ZDeferredConstructed<T>::initialize(Ts&&... args) {\n+  assert(!_initialized, \"Double initialization forbidden\");\n+  DEBUG_ONLY(_initialized = true;)\n+  using NCVP = std::add_pointer_t<std::remove_cv_t<T>>;\n+  ::new (const_cast<NCVP>(get())) T(args...);\n+}\n+\n+#endif \/\/ SHARE_GC_Z_ZDEFERREDCONSTRUCTED_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zDeferredConstructed.inline.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"gc\/z\/zAllocator.inline.hpp\"\n@@ -44,0 +43,1 @@\n+#include \"gc\/z\/zObjectAllocator.hpp\"\n@@ -848,4 +848,1 @@\n-  ZAllocator::eden()->retire_pages();\n-  for (ZPageAge age : ZPageAgeRangeSurvivor) {\n-    ZAllocator::relocation(age)->retire_pages();\n-  }\n+  ZHeap::heap()->retire_allocating_pages(ZPageAgeRangeYoung);\n@@ -1208,1 +1205,1 @@\n-  ZAllocator::old()->retire_pages();\n+  ZHeap::heap()->retire_allocating_pages(ZPageAgeRangeOld);\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/z\/zObjectAllocator.hpp\"\n@@ -54,0 +55,2 @@\n+static const ZStatCounter ZCounterUndoObjectAllocationSucceeded(\"Memory\", \"Undo Object Allocation Succeeded\", ZStatUnitOpsPerSecond);\n+static const ZStatCounter ZCounterUndoObjectAllocationFailed(\"Memory\", \"Undo Object Allocation Failed\", ZStatUnitOpsPerSecond);\n@@ -60,2 +63,1 @@\n-    _allocator_eden(),\n-    _allocator_relocation(),\n+    _object_allocator(),\n@@ -147,1 +149,1 @@\n-  size_t size = _allocator_eden.remaining();\n+  size_t size = _object_allocator.fast_available(ZPageAge::eden);\n@@ -160,0 +162,1 @@\n+\n@@ -219,1 +222,1 @@\n-void ZHeap::out_of_memory() {\n+void ZHeap::out_of_memory() const {\n@@ -295,0 +298,15 @@\n+void ZHeap::undo_alloc_object_for_relocation(zaddress addr, size_t size) {\n+  ZPage* const page = this->page(addr);\n+\n+  if (page->is_large()) {\n+    undo_alloc_page(page);\n+    ZStatInc(ZCounterUndoObjectAllocationSucceeded);\n+  } else {\n+    if (page->undo_alloc_object_atomic(addr, size)) {\n+      ZStatInc(ZCounterUndoObjectAllocationSucceeded);\n+    } else {\n+      ZStatInc(ZCounterUndoObjectAllocationFailed);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/z\/zAllocator.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"gc\/z\/zObjectAllocator.hpp\"\n@@ -46,1 +46,1 @@\n-  static ZHeap*           _heap;\n+  static ZHeap*    _heap;\n@@ -48,2 +48,2 @@\n-  ZPageAllocator          _page_allocator;\n-  ZPageTable              _page_table;\n+  ZPageAllocator   _page_allocator;\n+  ZPageTable       _page_table;\n@@ -51,2 +51,1 @@\n-  ZAllocatorEden          _allocator_eden;\n-  ZAllocatorForRelocation _allocator_relocation[ZAllocator::_relocation_allocators];\n+  ZObjectAllocator _object_allocator;\n@@ -54,1 +53,1 @@\n-  ZServiceability         _serviceability;\n+  ZServiceability  _serviceability;\n@@ -56,2 +55,2 @@\n-  ZGenerationOld          _old;\n-  ZGenerationYoung        _young;\n+  ZGenerationOld   _old;\n+  ZGenerationYoung _young;\n@@ -59,1 +58,1 @@\n-  ZTLABUsage              _tlab_usage;\n+  ZTLABUsage       _tlab_usage;\n@@ -61,1 +60,1 @@\n-  bool                    _initialized;\n+  bool             _initialized;\n@@ -74,1 +73,1 @@\n-  void out_of_memory();\n+  void out_of_memory() const;\n@@ -116,0 +115,1 @@\n+  void retire_allocating_pages(ZPageAgeRange range);\n@@ -118,0 +118,5 @@\n+  zaddress alloc_object(size_t size);\n+  zaddress alloc_tlab(size_t size);\n+  zaddress alloc_object_for_relocation(size_t size, ZPageAge age);\n+  void undo_alloc_object_for_relocation(zaddress addr, size_t size);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"gc\/z\/zObjectAllocator.hpp\"\n@@ -77,0 +78,23 @@\n+inline void ZHeap::retire_allocating_pages(ZPageAgeRange range) {\n+  _object_allocator.retire_pages(range);\n+}\n+\n+inline zaddress ZHeap::alloc_object(size_t size) {\n+  const zaddress addr = _object_allocator.alloc(size);\n+\n+  if (is_null(addr)) {\n+    out_of_memory();\n+  }\n+\n+  return addr;\n+}\n+\n+inline zaddress ZHeap::alloc_tlab(size_t size) {\n+  guarantee(size <= max_tlab_size(), \"TLAB too large\");\n+  return _object_allocator.alloc(size);\n+}\n+\n+inline zaddress ZHeap::alloc_object_for_relocation(size_t size, ZPageAge age) {\n+  return _object_allocator.alloc_for_relocation(size, age);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.inline.hpp","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include \"gc\/z\/zDeferredConstructed.inline.hpp\"\n@@ -30,2 +31,2 @@\n-#include \"gc\/z\/zPageTable.inline.hpp\"\n-#include \"gc\/z\/zStat.hpp\"\n+#include \"gc\/z\/zPageAge.inline.hpp\"\n+#include \"gc\/z\/zPageType.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"logging\/log.hpp\"\n@@ -40,4 +40,1 @@\n-static const ZStatCounter ZCounterUndoObjectAllocationSucceeded(\"Memory\", \"Undo Object Allocation Succeeded\", ZStatUnitOpsPerSecond);\n-static const ZStatCounter ZCounterUndoObjectAllocationFailed(\"Memory\", \"Undo Object Allocation Failed\", ZStatUnitOpsPerSecond);\n-\n-ZObjectAllocator::ZObjectAllocator(ZPageAge age)\n+ZObjectAllocator::PerAge::PerAge(ZPageAge age)\n@@ -50,1 +47,1 @@\n-ZPage** ZObjectAllocator::shared_small_page_addr() {\n+ZPage** ZObjectAllocator::PerAge::shared_small_page_addr() {\n@@ -54,1 +51,1 @@\n-ZPage* const* ZObjectAllocator::shared_small_page_addr() const {\n+ZPage* const* ZObjectAllocator::PerAge::shared_small_page_addr() const {\n@@ -58,5 +55,1 @@\n-ZPage* ZObjectAllocator::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags) {\n-  return ZHeap::heap()->alloc_page(type, size, flags, _age);\n-}\n-\n-ZPage* ZObjectAllocator::alloc_page_for_relocation(ZPageType type, size_t size, ZAllocationFlags flags) {\n+ZPage* ZObjectAllocator::PerAge::alloc_page(ZPageType type, size_t size, ZAllocationFlags flags) {\n@@ -66,1 +59,1 @@\n-void ZObjectAllocator::undo_alloc_page(ZPage* page) {\n+void ZObjectAllocator::PerAge::undo_alloc_page(ZPage* page) {\n@@ -70,5 +63,5 @@\n-zaddress ZObjectAllocator::alloc_object_in_shared_page(ZPage** shared_page,\n-                                                       ZPageType page_type,\n-                                                       size_t page_size,\n-                                                       size_t size,\n-                                                       ZAllocationFlags flags) {\n+zaddress ZObjectAllocator::PerAge::alloc_object_in_shared_page(ZPage** shared_page,\n+                                                               ZPageType page_type,\n+                                                               size_t page_size,\n+                                                               size_t size,\n+                                                               ZAllocationFlags flags) {\n@@ -119,2 +112,2 @@\n-zaddress ZObjectAllocator::alloc_object_in_medium_page(size_t size,\n-                                                       ZAllocationFlags flags) {\n+zaddress ZObjectAllocator::PerAge::alloc_object_in_medium_page(size_t size,\n+                                                               ZAllocationFlags flags) {\n@@ -168,1 +161,1 @@\n-zaddress ZObjectAllocator::alloc_large_object(size_t size, ZAllocationFlags flags) {\n+zaddress ZObjectAllocator::PerAge::alloc_large_object(size_t size, ZAllocationFlags flags) {\n@@ -182,1 +175,1 @@\n-zaddress ZObjectAllocator::alloc_medium_object(size_t size, ZAllocationFlags flags) {\n+zaddress ZObjectAllocator::PerAge::alloc_medium_object(size_t size, ZAllocationFlags flags) {\n@@ -186,1 +179,1 @@\n-zaddress ZObjectAllocator::alloc_small_object(size_t size, ZAllocationFlags flags) {\n+zaddress ZObjectAllocator::PerAge::alloc_small_object(size_t size, ZAllocationFlags flags) {\n@@ -190,1 +183,1 @@\n-zaddress ZObjectAllocator::alloc_object(size_t size, ZAllocationFlags flags) {\n+zaddress ZObjectAllocator::PerAge::alloc_object(size_t size, ZAllocationFlags flags) {\n@@ -203,3 +196,6 @@\n-zaddress ZObjectAllocator::alloc_object(size_t size) {\n-  const ZAllocationFlags flags;\n-  return alloc_object(size, flags);\n+void ZObjectAllocator::PerAge::retire_pages() {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"Should be at safepoint\");\n+\n+  \/\/ Reset allocation pages\n+  _shared_medium_page.set(nullptr);\n+  _shared_small_page.set_all(nullptr);\n@@ -208,3 +204,2 @@\n-zaddress ZObjectAllocator::alloc_object_for_relocation(size_t size) {\n-  ZAllocationFlags flags;\n-  flags.set_non_blocking();\n+ZObjectAllocator::ZObjectAllocator()\n+  : _allocators() {\n@@ -212,1 +207,3 @@\n-  return alloc_object(size, flags);\n+  for (ZPageAge age : ZPageAgeRange()) {\n+    _allocators[untype(age)].initialize(age);\n+  }\n@@ -215,2 +212,3 @@\n-void ZObjectAllocator::undo_alloc_object_for_relocation(zaddress addr, size_t size) {\n-  ZPage* const page = ZHeap::heap()->page(addr);\n+ZObjectAllocator::PerAge* ZObjectAllocator::allocator(ZPageAge age) {\n+  return _allocators[untype(age)].get();\n+}\n@@ -218,10 +216,2 @@\n-  if (page->is_large()) {\n-    undo_alloc_page(page);\n-    ZStatInc(ZCounterUndoObjectAllocationSucceeded);\n-  } else {\n-    if (page->undo_alloc_object_atomic(addr, size)) {\n-      ZStatInc(ZCounterUndoObjectAllocationSucceeded);\n-    } else {\n-      ZStatInc(ZCounterUndoObjectAllocationFailed);\n-    }\n-  }\n+const ZObjectAllocator::PerAge* ZObjectAllocator::allocator(ZPageAge age) const {\n+  return _allocators[untype(age)].get();\n@@ -230,2 +220,4 @@\n-ZPageAge ZObjectAllocator::age() const {\n-  return _age;\n+void ZObjectAllocator::retire_pages(ZPageAgeRange range) {\n+  for (ZPageAge age : range) {\n+    allocator(age)->retire_pages();\n+  }\n@@ -234,1 +226,1 @@\n-size_t ZObjectAllocator::remaining() const {\n+size_t ZObjectAllocator::fast_available(ZPageAge age) const {\n@@ -237,1 +229,2 @@\n-  const ZPage* const page = Atomic::load_acquire(shared_small_page_addr());\n+  ZPage* const* const shared_addr = allocator(age)->shared_small_page_addr();\n+  const ZPage* const page = Atomic::load_acquire(shared_addr);\n@@ -245,2 +238,4 @@\n-void ZObjectAllocator::retire_pages() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Should be at safepoint\");\n+zaddress ZObjectAllocator::alloc(size_t size) {\n+  ZAllocationFlags flags;\n+  return allocator(ZPageAge::eden)->alloc_object(size, flags);\n+}\n@@ -248,3 +243,7 @@\n-  \/\/ Reset allocation pages\n-  _shared_medium_page.set(nullptr);\n-  _shared_small_page.set_all(nullptr);\n+zaddress ZObjectAllocator::alloc_for_relocation(size_t size, ZPageAge age) {\n+  ZAllocationFlags flags;\n+\n+  \/\/ Object allocation for relocation should not block\n+  flags.set_non_blocking();\n+\n+  return allocator(age)->alloc_object(size, flags);\n@@ -252,0 +251,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.cpp","additions":54,"deletions":54,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zDeferredConstructed.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"gc\/z\/zPage.hpp\"\n@@ -31,1 +33,0 @@\n-#include \"gc\/z\/zPageType.hpp\"\n@@ -34,3 +35,0 @@\n-class ZPage;\n-class ZPageTable;\n-\n@@ -39,27 +37,7 @@\n-  ZPageAge           _age;\n-  const bool         _use_per_cpu_shared_small_pages;\n-  ZPerCPU<ZPage*>    _shared_small_page;\n-  ZContended<ZPage*> _shared_medium_page;\n-  ZLock              _medium_page_alloc_lock;\n-\n-  ZPage** shared_small_page_addr();\n-  ZPage* const* shared_small_page_addr() const;\n-\n-  ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags);\n-  void undo_alloc_page(ZPage* page);\n-\n-  \/\/ Allocate an object in a shared page. Allocate and\n-  \/\/ atomically install a new page if necessary.\n-  zaddress alloc_object_in_shared_page(ZPage** shared_page,\n-                                       ZPageType page_type,\n-                                       size_t page_size,\n-                                       size_t size,\n-                                       ZAllocationFlags flags);\n-\n-  zaddress alloc_object_in_medium_page(size_t size,\n-                                       ZAllocationFlags flags);\n-\n-  zaddress alloc_large_object(size_t size, ZAllocationFlags flags);\n-  zaddress alloc_medium_object(size_t size, ZAllocationFlags flags);\n-  zaddress alloc_small_object(size_t size, ZAllocationFlags flags);\n-  zaddress alloc_object(size_t size, ZAllocationFlags flags);\n+  class PerAge {\n+  private:\n+    const ZPageAge     _age;\n+    const bool         _use_per_cpu_shared_small_pages;\n+    ZPerCPU<ZPage*>    _shared_small_page;\n+    ZContended<ZPage*> _shared_medium_page;\n+    ZLock              _medium_page_alloc_lock;\n@@ -67,2 +45,2 @@\n-public:\n-  ZObjectAllocator(ZPageAge age);\n+  public:\n+    PerAge(ZPageAge age);\n@@ -70,2 +48,16 @@\n-  \/\/ Mutator allocation\n-  zaddress alloc_object(size_t size);\n+    ZPage** shared_small_page_addr();\n+    ZPage* const* shared_small_page_addr() const;\n+\n+    ZPage* alloc_page(ZPageType type, size_t size, ZAllocationFlags flags);\n+    void undo_alloc_page(ZPage* page);\n+\n+    \/\/ Allocate an object in a shared page. Allocate and\n+    \/\/ atomically install a new page if necessary.\n+    zaddress alloc_object_in_shared_page(ZPage** shared_page,\n+                                         ZPageType page_type,\n+                                         size_t page_size,\n+                                         size_t size,\n+                                         ZAllocationFlags flags);\n+\n+    zaddress alloc_object_in_medium_page(size_t size,\n+                                         ZAllocationFlags flags);\n@@ -73,3 +65,4 @@\n-  \/\/ Relocation\n-  zaddress alloc_object_for_relocation(size_t size);\n-  void undo_alloc_object_for_relocation(zaddress addr, size_t size);\n+    zaddress alloc_large_object(size_t size, ZAllocationFlags flags);\n+    zaddress alloc_medium_object(size_t size, ZAllocationFlags flags);\n+    zaddress alloc_small_object(size_t size, ZAllocationFlags flags);\n+    zaddress alloc_object(size_t size, ZAllocationFlags flags);\n@@ -77,1 +70,2 @@\n-  ZPage* alloc_page_for_relocation(ZPageType type, size_t size, ZAllocationFlags flags);\n+    void retire_pages();\n+  };\n@@ -79,1 +73,1 @@\n-  ZPageAge age() const;\n+  ZDeferredConstructed<PerAge> _allocators[ZPageAgeCount];\n@@ -81,1 +75,12 @@\n-  size_t remaining() const;\n+  PerAge* allocator(ZPageAge age);\n+  const PerAge* allocator(ZPageAge age) const;\n+\n+public:\n+  ZObjectAllocator();\n+\n+  void retire_pages(ZPageAgeRange range);\n+\n+  size_t fast_available(ZPageAge age) const;\n+\n+  \/\/ Mutator allocation\n+  zaddress alloc(size_t size);\n@@ -83,1 +88,2 @@\n-  void retire_pages();\n+  \/\/ Mutator relocation\n+  zaddress alloc_for_relocation(size_t size, ZPageAge age);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjectAllocator.hpp","additions":49,"deletions":43,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+constexpr uint ZNumRelocationAges = ZPageAgeCount - 1;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAge.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/z\/zAllocator.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"gc\/z\/zObjectAllocator.hpp\"\n@@ -37,1 +37,1 @@\n-#include \"gc\/z\/zPageAge.hpp\"\n+#include \"gc\/z\/zPageAge.inline.hpp\"\n@@ -328,0 +328,1 @@\n+  const ZPageAge to_age = forwarding->to_age();\n@@ -329,3 +330,1 @@\n-  ZAllocatorForRelocation* allocator = ZAllocator::relocation(forwarding->to_age());\n-\n-  const zaddress to_addr = allocator->alloc_object(size);\n+  const zaddress to_addr = ZHeap::heap()->alloc_object_for_relocation(size, to_age);\n@@ -346,1 +345,1 @@\n-    allocator->undo_alloc_object(to_addr, size);\n+    ZHeap::heap()->undo_alloc_object_for_relocation(to_addr, size);\n@@ -388,1 +387,1 @@\n-static ZPage* alloc_page(ZAllocatorForRelocation* allocator, ZPageType type, size_t size) {\n+static ZPage* alloc_page(ZForwarding* forwarding) {\n@@ -395,0 +394,4 @@\n+  const ZPageType type = forwarding->type();\n+  const size_t size = forwarding->size();\n+  const ZPageAge age = forwarding->to_age();\n+\n@@ -399,1 +402,1 @@\n-  return allocator->alloc_page_for_relocation(type, size, flags);\n+  return ZHeap::heap()->alloc_page(type, size, flags, age);\n@@ -429,2 +432,1 @@\n-    ZAllocatorForRelocation* const allocator = ZAllocator::relocation(forwarding->to_age());\n-    ZPage* const page = alloc_page(allocator, forwarding->type(), forwarding->size());\n+    ZPage* const page = alloc_page(forwarding);\n@@ -470,1 +472,1 @@\n-  ZPage*             _shared[ZAllocator::_relocation_allocators];\n+  ZPage*             _shared[ZNumRelocationAges];\n@@ -483,1 +485,1 @@\n-    for (uint i = 0; i < ZAllocator::_relocation_allocators; ++i) {\n+    for (uint i = 0; i < ZNumRelocationAges; ++i) {\n@@ -512,2 +514,1 @@\n-      ZAllocatorForRelocation* const allocator = ZAllocator::relocation(forwarding->to_age());\n-      ZPage* const to_page = alloc_page(allocator, forwarding->type(), forwarding->size());\n+      ZPage* const to_page = alloc_page(forwarding);\n@@ -565,1 +566,1 @@\n-  ZPage*              _target[ZAllocator::_relocation_allocators];\n+  ZPage*              _target[ZNumRelocationAges];\n@@ -919,1 +920,1 @@\n-    for (uint i = 0; i < ZAllocator::_relocation_allocators; ++i) {\n+    for (uint i = 0; i < ZNumRelocationAges; ++i) {\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"}]}