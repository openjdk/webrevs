{"files":[{"patch":"@@ -57,1 +57,1 @@\n- * Implements SSL using two SubscriberWrappers.\n+ * Implements SSL using two {@link SubscriberWrapper}s.\n@@ -59,3 +59,4 @@\n- * <p> Constructor takes two Flow.Subscribers: one that receives the network\n- * data (after it has been encrypted by SSLFlowDelegate) data, and one that\n- * receives the application data (before it has been encrypted by SSLFlowDelegate).\n+ * <p> Constructor takes two {@linkplain Flow.Subscriber subscribers} - {@code downReader}\n+ * and {@code downWriter}. {@code downReader} receives the application data (after it has\n+ * been decrypted by SSLFlowDelegate). {@code downWriter} receives the network data (after it has\n+ * been encrypted by SSLFlowDelegate).\n@@ -63,3 +64,4 @@\n- * <p> Methods upstreamReader() and upstreamWriter() return the corresponding\n- * Flow.Subscribers containing Flows for the encrypted\/decrypted upstream data.\n- * See diagram below.\n+ * <p> Method {@link #upstreamWriter()} returns a {@linkplain Subscriber subscriber} which should\n+ * be subscribed with a {@linkplain Flow.Publisher publisher} which publishes application data\n+ * that can then be encrypted into network data by this SSLFlowDelegate and handed off to the\n+ * {@code downWriter}.\n@@ -67,1 +69,9 @@\n- * <p> How Flow.Subscribers are used in this class, and where they come from:\n+ * <p> Method {@link #upstreamReader()} returns a {@link Subscriber subscriber} which should be\n+ * subscribed with a {@linkplain Flow.Publisher publisher} which publishes encrypted network data\n+ * that can then be decrypted into application data by this SSLFlowDelegate and handed off to the\n+ * {@code downReader}.\n+ *\n+ * <p> Errors are reported to the {@code downReader} subscriber.\n+ *\n+ * <p> The diagram below illustrates how the Flow.Subscribers are used in this class, and where\n+ * they come from:\n@@ -76,11 +86,15 @@\n- *                         +------------------+\n- *        upstreamWriter   |                  | downWriter\n- *        ---------------> |                  | ------------>\n- *  obtained from this     |                  | supplied to constructor\n- *                         | SSLFlowDelegate  |\n- *        downReader       |                  | upstreamReader\n- *        <--------------- |                  | <--------------\n- * supplied to constructor |                  | obtained from this\n- *                         +------------------+\n- *\n- * Errors are reported to the downReader Flow.Subscriber\n+ *                  |                                   |\n+ *  upstreamWriter  |                                   | upstreamReader\n+ *  obtained from   |                                   | obtained from\n+ * upstreamWriter() |                                   | upstreamReader()\n+ *                  v                                   v\n+ *      +-----------------------------------------------------------+\n+ *      *                                                           *\n+ *      *                       SSLFlowDelegate                     *\n+ *      *        encrypts                            decrypts       *\n+ *      +-----------------------------------------------------------+\n+ *                  |                                   |\n+ *    downWriter    |                                   | downReader\n+ *    supplied to   |                                   | supplied to\n+ *    constructor   |                                   | constructor\n+ *                  v                                   v\n@@ -480,1 +494,1 @@\n-                            requestMore();\n+                            requestMoreDataIfNeeded();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/SSLFlowDelegate.java","additions":34,"deletions":20,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8308144\n+ * @summary tests that the SSLFlowDelegate doesn't accumulate application data when the\n+ *          downReader doesn't request any\n+ * @modules java.net.http\/jdk.internal.net.http\n+ * @run testng\/othervm  -Djdk.internal.httpclient.debug=true\n+ *                      -Djavax.net.debug=ssl:handshake\n+ *                      java.net.http\/jdk.internal.net.http.SSLFlowDelegateTest\n+ *\/\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/SSLFlowDelegateTestDriver.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,595 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.reflect.Field;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.SubmissionPublisher;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+\n+import jdk.internal.net.http.common.Logger;\n+import jdk.internal.net.http.common.SSLFlowDelegate;\n+import jdk.internal.net.http.common.SubscriberWrapper;\n+import jdk.internal.net.http.common.Utils;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+\/\/ jtreg test definition for this test resides in SSLFlowDelegateTestDriver.java\n+public class SSLFlowDelegateTest {\n+    private static final String ALPN = \"foobar\";\n+    private static final String debugTag = SSLFlowDelegateTest.class.getSimpleName();\n+    private static final Random random = new Random();\n+    private static final byte DATA_BYTE = (byte) random.nextInt();\n+\n+    private ExecutorService executor;\n+    private SSLContext sslContext;\n+    private SSLParameters sslParams;\n+    private SSLServerSocket sslServerSocket;\n+    private SSLEngine clientEngine;\n+    private CompletableFuture<Void> testCompletion;\n+\n+    @BeforeTest\n+    public void beforeTest() throws Exception {\n+        this.executor = Executors.newCachedThreadPool();\n+        this.sslContext = new jdk.internal.net.http.SimpleSSLContext().get();\n+        this.testCompletion = new CompletableFuture<>();\n+\n+        final SSLParameters sp = new SSLParameters();\n+        sp.setApplicationProtocols(new String[]{ALPN});\n+        this.sslParams = sp;\n+\n+        this.sslServerSocket = startServer(this.sslContext);\n+        println(debugTag, \"Server started at \" + this.sslServerSocket.getInetAddress() + \":\"\n+                + this.sslServerSocket.getLocalPort());\n+\n+        this.clientEngine = createClientEngine(this.sslContext);\n+    }\n+\n+    @AfterTest\n+    public void afterTest() throws Exception {\n+        if (this.sslServerSocket != null) {\n+            println(debugTag, \"Closing server socket \" + this.sslServerSocket);\n+            this.sslServerSocket.close();\n+        }\n+        if (this.executor != null) {\n+            println(debugTag, \"Shutting down the executor \" + this.executor);\n+            this.executor.shutdownNow();\n+        }\n+    }\n+\n+    private static void println(final String debugTag, final String msg) {\n+        println(debugTag, msg, null);\n+    }\n+\n+    private static void println(final String debugTag, final String msg, final Throwable t) {\n+        final Logger logger = Utils.getDebugLogger(() -> debugTag);\n+        logger.log(msg);\n+        if (t != null) {\n+            t.printStackTrace();\n+        }\n+    }\n+\n+    private SSLServerSocket createSSLServerSocket(\n+            final SSLContext ctx, final InetSocketAddress bindAddr) throws IOException {\n+        final SSLServerSocketFactory fac = ctx.getServerSocketFactory();\n+        final SSLServerSocket sslServerSocket = (SSLServerSocket) fac.createServerSocket();\n+        sslServerSocket.setReuseAddress(false);\n+        sslServerSocket.setSSLParameters(this.sslParams);\n+        sslServerSocket.bind(bindAddr);\n+        return sslServerSocket;\n+    }\n+\n+    private SSLServerSocket startServer(final SSLContext ctx) throws Exception {\n+        final SSLServerSocket sslServerSocket = createSSLServerSocket(ctx,\n+                new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+        final Runnable serverResponsePusher = new ServerResponsePusher(sslServerSocket,\n+                this.testCompletion);\n+        final Thread serverThread = new Thread(serverResponsePusher, \"serverResponsePusher\");\n+        \/\/ start the thread which will accept() a socket connection and send data over it\n+        serverThread.start();\n+        return sslServerSocket;\n+    }\n+\n+    private SSLEngine createClientEngine(final SSLContext ctx) {\n+        final SSLEngine clientEngine = ctx.createSSLEngine();\n+        clientEngine.setSSLParameters(this.sslParams);\n+        clientEngine.setUseClientMode(true);\n+        return clientEngine;\n+    }\n+\n+    \/**\n+     * Constructs a {@code SSLFlowDelegate} with a {@code downReader} which only requests one\n+     * item and then never requests any more. After that one item has been received by the\n+     * {@code downReader}, this test feeds the\n+     * {@linkplain SSLFlowDelegate#upstreamReader() upstreamReader} with (network SSL) data in\n+     * such a manner that while\n+     * {@link SSLEngine#unwrap(ByteBuffer, ByteBuffer) unwrapping} it in the internal implementation\n+     * of {@code SSLFlowDelegate}, it will often trigger {@code BUFFER_UNDERFLOW} state.\n+     * This test then verifies that the {@code SSLFlowDelegate} when it reaches such a state will\n+     * not keep asking for more (network SSL) data and decrypting it to application data and\n+     * accumulating it (since the {@code downReader} won't be using any of this accumulated data).\n+     *\/\n+    @Test\n+    public void testUnsolicitedBytes() throws Exception {\n+        \/\/ initiate a connection to the server\n+        try (final Socket socket = new Socket(sslServerSocket.getInetAddress(),\n+                sslServerSocket.getLocalPort())) {\n+            println(debugTag, \"connected to server, local socket: \" + socket);\n+            \/\/ this future is completed when the AppResponseReceiver subscriber receives\n+            \/\/ the sole item that is requests for (through just one subscription.request(1))\n+            final CompletableFuture<Long> soleExpectedAppData = new CompletableFuture<>();\n+            \/\/ the \"testCompletion\" CompletableFuture represents that future that's used\n+            \/\/ in various places in this test. If the \"testCompletion\" completes before\n+            \/\/ the \"soleExpectedAppData\" completes (typically due to some exception),\n+            \/\/ then we complete the \"soleExpectedAppData\" too.\n+            this.testCompletion.whenComplete((r, t) -> {\n+                if (soleExpectedAppData.isDone()) {\n+                    return;\n+                }\n+                if (t == null) {\n+                    soleExpectedAppData.complete(-1L); \/\/ -1 indicates no item received\n+                    return;\n+                }\n+                soleExpectedAppData.completeExceptionally(t);\n+            });\n+            \/\/ the \"downReader\" Subscriber which is passed to the constructor of SSLFlowDelegate.\n+            \/\/ This subscriber receives the (decrypted) application data. This subscriber requests\n+            \/\/ only one item (no restriction on how many bytes are received in this one item).\n+            final AppResponseReceiver appResponseReceiver = new AppResponseReceiver(\n+                    this.testCompletion, soleExpectedAppData);\n+            \/\/ the \"downWriter\" Subscriber which is passed to the constructor of the\n+            \/\/ SSLFlowDelegate.\n+            \/\/ This subscriber receives the (encrypted) network data and just writes it out to the\n+            \/\/ connected socket's OutputStream. Makes no restrictions on how much items (and thus\n+            \/\/ bytes) it receives and just keeps writing as and when it receives the data.\n+            final SocketWriter networkDataWriter = new SocketWriter(socket, this.testCompletion);\n+            \/\/ construct the SSLFlowDelegate\n+            final SSLFlowDelegate sslFlowDelegate = new SSLFlowDelegate(clientEngine, executor,\n+                    appResponseReceiver, networkDataWriter);\n+            \/\/ the SocketReader runs in a thread and it keeps reading data from the connected\n+            \/\/ socket's InputStream. This data keeps coming from the ServerResponsePusher which too\n+            \/\/ is running in a thread of its own and is writing it out over the connected socket's\n+            \/\/ OutputStream. The SocketReader and ServerResponsePusher are convenience constructs\n+            \/\/ which use the simple APIs (InputStream\/OutputStream) provided by SSLServerSocket\n+            \/\/ and (SSL)Socket to generate SSL network data. This generated data is then fed to\n+            \/\/ the relevant subscribers of SSLFlowDelegate. The SocketReader and the\n+            \/\/ ServerResponsePusher play no other role than just generating this SSL network data.\n+            final SocketReader socketReader = new SocketReader(socket, executor,\n+                    sslFlowDelegate.upstreamReader(), this.testCompletion);\n+            \/\/ start reading from the socket in separate thread\n+            new Thread(socketReader, \"socketReader\").start();\n+\n+            \/\/ we use this publisher only to trigger the SSL handshake and the publisher itself\n+            \/\/ doesn't publish any data i.e. there is no application client \"request\" data needed\n+            \/\/ in this test\n+            final Flow.Publisher<List<ByteBuffer>> publisher = new ZeroDataPublisher<>();\n+            println(debugTag, \"Subscribing the upstreamWriter() to trigger SSL handshake\");\n+            \/\/ now connect all the pieces.\n+            \/\/ this call to subscribe the upstreamWriter() triggers the SSL handshake (doesn't\n+            \/\/ matter if our zero app data publisher publishes no app data; SSL handshake\n+            \/\/ doesn't require app data). see SSLFlowDelegate$Writer.onSubscribe() where\n+            \/\/ it triggers the SSL handshake when this subscription happens\n+            publisher.subscribe(sslFlowDelegate.upstreamWriter());\n+            println(debugTag, \"Waiting for handshake to complete\");\n+            final String negotiatedALPN = sslFlowDelegate.alpn().join();\n+            println(debugTag, \"handshake completed, with negotiated ALPN: \" + negotiatedALPN);\n+            Assert.assertEquals(negotiatedALPN, ALPN, \"unexpected ALPN negotiated\");\n+            try {\n+                \/\/ now wait for the initial (and the only) chunk of application data to be\n+                \/\/ received by the AppResponseReceiver\n+                println(debugTag, \"waiting for the sole expected chunk of application data to\" +\n+                        \" become available to \" + appResponseReceiver);\n+                final long numAppDataBytesReceived = soleExpectedAppData.join();\n+                println(debugTag, \"Received \" + numAppDataBytesReceived + \" app data bytes,\" +\n+                        \" no more app data expected\");\n+                \/\/ at this point, we have received the only expected item in the downReader\n+                \/\/ i.e. the AppResponseReceiver. We no longer expect the SSLFlowDelegate to be\n+                \/\/ accumulating any decrypted application data (because the downReader hasn't\n+                \/\/ requested any).\n+                \/\/ We will now let the SocketReader and the ServerResponsePusher threads to keep\n+                \/\/ generating and feeding the SSL network data to the SSLFlowDelegate subscribers,\n+                \/\/ until they are \"done\" (either normally or exceptionally). Those threads decide\n+                \/\/ when to stop generating the SSL network data.\n+                this.testCompletion.join();\n+            } catch (CompletionException ce) {\n+                \/\/ fail with a Assert.fail instead of throwing an exception, thus providing a\n+                \/\/ better failure report\n+                failTest(ce);\n+            }\n+            println(debugTag, \"now checking if any unsolicited bytes accumulated\");\n+            \/\/ SSL network data generation has completed, now check if the SSLFlowDelegate\n+            \/\/ decrypted and accumulated any application data when it shouldn't have.\n+            assertNoUnsolicitedBytes(sslFlowDelegate);\n+            println(debugTag, \"testing completed successfully, no unsolicited bytes accumulated\");\n+        }\n+    }\n+\n+    private void failTest(final CompletionException ce) {\n+        final Throwable cause = ce.getCause();\n+        Assert.fail(cause.getMessage() == null ? \"test failed\" : cause.getMessage(), cause);\n+    }\n+\n+    \/\/ uses reflection to get hold of the SSLFlowDelegate.reader.outputQ member field,\n+    \/\/ which is a ConcurrentLinkedQueue holding the decrypted application data that\n+    \/\/ is supposed to be sent to the downReader subscriber of the SSLFlowDelegate.\n+    \/\/ Asserts that this outputQ has 0 bytes of data accumulated\n+    private void assertNoUnsolicitedBytes(final SSLFlowDelegate sslFlowDelegate) throws Exception {\n+        final Field readerField = SSLFlowDelegate.class.getDeclaredField(\"reader\");\n+        readerField.setAccessible(true);\n+\n+        final Field readerOutputQField = SubscriberWrapper.class.getDeclaredField(\"outputQ\");\n+        readerOutputQField.setAccessible(true);\n+\n+        final Object reader = readerField.get(sslFlowDelegate);\n+        final ConcurrentLinkedQueue<List<ByteBuffer>> outputQ =\n+                ConcurrentLinkedQueue.class.cast(readerOutputQField.get(reader));\n+        long numUnsolicitated = 0;\n+        List<ByteBuffer> accumulations;\n+        while ((accumulations = outputQ.poll()) != null) {\n+            println(debugTag, \"found some items in outputQ\");\n+            for (final ByteBuffer buf : accumulations) {\n+                if (!buf.hasRemaining()) {\n+                    continue;\n+                }\n+                try {\n+                    numUnsolicitated = Math.addExact(numUnsolicitated, buf.remaining());\n+                } catch (ArithmeticException ame) {\n+                    numUnsolicitated = Long.MAX_VALUE;\n+                    break;\n+                }\n+            }\n+            println(debugTag, \"num unsolicited bytes so far = \" + numUnsolicitated);\n+        }\n+        Assert.assertEquals(numUnsolicitated, 0,\n+                \"SSLFlowDelegate has accumulated \" + numUnsolicitated + \" unsolicited bytes\");\n+    }\n+\n+    \/\/ A publisher which accepts only one subscriber and doesn't ever publish any data\n+    private static final class ZeroDataPublisher<T> implements Flow.Publisher<T> {\n+        private final AtomicBoolean hasSubscriber = new AtomicBoolean();\n+\n+        @Override\n+        public void subscribe(final Subscriber<? super T> subscriber) {\n+            if (!hasSubscriber.compareAndSet(false, true)) {\n+                \/\/ we allow only one subscriber\n+                throw new IllegalStateException(\"Cannot subscribe more than once\");\n+            }\n+            subscriber.onSubscribe(new Flow.Subscription() {\n+                @Override\n+                public void request(long n) {\n+                    \/\/ no-op, we don't publish any data\n+                }\n+\n+                @Override\n+                public void cancel() {\n+                    \/\/ no-op\n+                }\n+            });\n+        }\n+    }\n+\n+    \/\/ a Subscriber which subscribers for encrypted SSL network data that it will then\n+    \/\/ write to a connected (SSL) Socket's OutputStream\n+    private static final class SocketWriter implements Subscriber<List<ByteBuffer>> {\n+        private static final String debugTag = SocketWriter.class.getSimpleName();\n+\n+        private final Socket socket;\n+        private final CompletableFuture<Void> completion;\n+        private volatile Flow.Subscription subscription;\n+        private final AtomicLong numBytesWritten = new AtomicLong();\n+\n+        private SocketWriter(final Socket socket, final CompletableFuture<Void> completion) {\n+            this.socket = socket;\n+            this.completion = completion;\n+        }\n+\n+        @Override\n+        public void onSubscribe(final Flow.Subscription subscription) {\n+            this.subscription = subscription;\n+            println(debugTag, \"onSubscribe invoked, requesting for data to write to socket\");\n+            subscription.request(1);\n+        }\n+\n+        @Override\n+        public void onNext(final List<ByteBuffer> bufs) {\n+            try {\n+                final OutputStream os =\n+                        new BufferedOutputStream(this.socket.getOutputStream());\n+\n+                \/\/ these buffers contain encrypted SSL network data that we receive\n+                \/\/ from the SSLFlowDelegate. We just write them out to the\n+                \/\/ Socket's OutputStream.\n+                for (final ByteBuffer buf : bufs) {\n+                    int len = buf.remaining();\n+                    int written = writeToStream(os, buf);\n+                    assert len == written;\n+                    this.numBytesWritten.addAndGet(len);\n+                    assert !buf.hasRemaining()\n+                            : \"buffer has \" + buf.remaining() + \" bytes left\";\n+                    this.subscription.request(1); \/\/ willing to write out more data when available\n+                }\n+            } catch (Throwable e) {\n+                println(debugTag, \"failed: \" + e, e);\n+                completion.completeExceptionally(e);\n+            }\n+        }\n+\n+        @Override\n+        public void onError(final Throwable throwable) {\n+            println(debugTag, \"error: \" + throwable, throwable);\n+            completion.completeExceptionally(throwable);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            println(debugTag, \"onComplete(), total bytes written: \" + this.numBytesWritten.get());\n+        }\n+\n+        private int writeToStream(final OutputStream os, final ByteBuffer buf) throws IOException {\n+            final byte[] b = buf.array();\n+            final int offset = buf.arrayOffset() + buf.position();\n+            final int n = buf.limit() - buf.position();\n+            os.write(b, offset, n);\n+            buf.position(buf.limit());\n+            os.flush();\n+            return n;\n+        }\n+    }\n+\n+    \/\/ a background task that keeps reading encrypted SSL network data from a connected\n+    \/\/ (SSL) Socket and publishes this data to the SSLFlowDelegate's upstreamReader() subscriber.\n+    \/\/ Very importantly, irrespective of how many bytes of data this SocketReader reads\n+    \/\/ of the Socket's InputStream in one read() operation, it publishes this data to the\n+    \/\/ upstreamReader() subscriber in very small chunks, so that when the upstreamReader()\n+    \/\/ subscriber receives it and starts unwrapping that SSL network data, it often\n+    \/\/ encounters a BUFFER_UNDERFLOW state.\n+    private static final class SocketReader implements Runnable {\n+        private static final String debugTag = SocketReader.class.getSimpleName();\n+\n+        \/\/ the size of data that will be published to the upstreamReader() subscriber.\n+        \/\/ small enough; no other meaning to this value\n+        private static final int VERY_SMALL_DATA_SIZE = 123;\n+\n+        private final Socket socket;\n+        private final SubmissionPublisher<List<ByteBuffer>> publisher;\n+        private final CompletableFuture<Void> completion;\n+\n+        private SocketReader(final Socket socket, final Executor executor,\n+                             final Subscriber<List<ByteBuffer>> incomingNetworkDataSubscriber,\n+                             final CompletableFuture<Void> completion) {\n+            this.socket = socket;\n+            this.completion = completion;\n+            this.publisher = new SubmissionPublisher<>(executor, Flow.defaultBufferSize(),\n+                    (s, t) -> completion.completeExceptionally(t));\n+            this.publisher.subscribe(incomingNetworkDataSubscriber);\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                \/\/ reads off the SSLSocket the data from the \"server\"\n+                final InputStream is = socket.getInputStream();\n+                long numBytesRead = 0;\n+                long numBytesPublished = 0;\n+                while (true) {\n+                    final byte[] buf = new byte[10240]; \/\/ this size doesn't matter\n+                    final int n = is.read(buf);\n+                    if (n == -1) {\n+                        println(debugTag, \"got EOF, now closing resources; total read \"\n+                                + numBytesRead + \" bytes, total published \" + numBytesPublished\n+                                + \" bytes\");\n+                        closeAndComplete(is);\n+                        return;\n+                    }\n+                    println(debugTag, \"read \" + n + \" bytes from socket\");\n+                    numBytesRead = Math.addExact(numBytesRead, n);\n+                    int remaining = n;\n+                    int index = 0;\n+                    while (remaining > 0) {\n+                        final int chunkSize = Math.min(remaining, VERY_SMALL_DATA_SIZE);\n+                        final byte[] chunk = Arrays.copyOfRange(buf, index, index + chunkSize);\n+                        index += chunkSize;\n+                        remaining -= chunkSize;\n+                        final int lagOrDrops = publisher.offer(\n+                                List.of(ByteBuffer.wrap(chunk)), 2, TimeUnit.SECONDS, null);\n+                        if (lagOrDrops < 0) {\n+                            println(debugTag, \"dropped a chunk, re-offering\");\n+                            \/\/ dropped, we now re-attempt once more and if that too is dropped,\n+                            \/\/ we stop\n+                            final int newLagOrDrops = publisher.offer(\n+                                    List.of(ByteBuffer.wrap(chunk)), 2, TimeUnit.SECONDS, null);\n+                            if (newLagOrDrops < 0) {\n+                                println(debugTag, \"dropped the re-offered chunk; closing resources,\" +\n+                                        \" total bytes read: \" + numBytesRead +\n+                                        \" total bytes published: \" + numBytesPublished);\n+                                closeAndComplete(is);\n+                                return;\n+                            }\n+                        }\n+                        numBytesPublished += chunkSize;\n+                        println(debugTag, \"published \" + numBytesPublished + \" bytes of total \"\n+                                + numBytesRead + \" bytes read\");\n+                    }\n+                }\n+            } catch (Throwable e) {\n+                println(debugTag, \"failed: \" + e, e);\n+                completion.completeExceptionally(e);\n+            }\n+        }\n+\n+        private void closeAndComplete(final InputStream is) {\n+            publisher.close();\n+            completion.complete(null);\n+            Utils.close(is);\n+        }\n+    }\n+\n+    \/\/ a background task which accepts one socket connection on a SSLServerSocket and keeps\n+    \/\/ writing (application) data to the OutputStream of that socket.\n+    private static final class ServerResponsePusher implements Runnable {\n+        private static final String debugTag = ServerResponsePusher.class.getSimpleName();\n+        private final SSLServerSocket sslServerSocket;\n+        private final CompletableFuture<Void> completion;\n+\n+        private ServerResponsePusher(final SSLServerSocket sslServerSocket,\n+                                     final CompletableFuture<Void> completion) {\n+            this.sslServerSocket = sslServerSocket;\n+            this.completion = completion;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                \/\/ accept a connection\n+                try (final Socket socket = this.sslServerSocket.accept()) {\n+                    println(debugTag, \"Accepted connection from \" + socket);\n+                    try (final OutputStream os = socket.getOutputStream()) {\n+                        final byte[] resp = new byte[10240]; \/\/ this size doesn't matter\n+                        Arrays.fill(resp, DATA_BYTE);\n+                        long numWritten = 0;\n+                        \/\/ reasonable number of times to generate enough network data\n+                        final int numTimes = 50;\n+                        for (int i = 0; i < numTimes; i++) {\n+                            println(debugTag, \"writing \" + resp.length + \" bytes, \"\n+                                    + numWritten + \" written so far\");\n+                            os.write(resp);\n+                            numWritten += resp.length;\n+                            os.flush();\n+                        }\n+                        println(debugTag, \"stopped writing, total bytes written: \" + numWritten);\n+                    }\n+                }\n+            } catch (Throwable e) {\n+                println(debugTag, \"error: \" + e, e);\n+                this.completion.completeExceptionally(e);\n+            }\n+        }\n+    }\n+\n+    \/\/ the \"downReader\" Subscriber which is passed to the constructor of SSLFlowDelegate.\n+    \/\/ This subscriber receives the (decrypted) application data. This subscriber requests\n+    \/\/ only one item (no restriction on how many bytes are received in this one item).\n+    private static final class AppResponseReceiver implements Subscriber<List<ByteBuffer>> {\n+        private static final String debugTag = AppResponseReceiver.class.getSimpleName();\n+\n+        private final byte[] expectedData = new byte[1024]; \/\/ no significance of the size\n+\n+        private final AtomicLong numBytesReceived;\n+        private volatile Flow.Subscription subscription;\n+        private final CompletableFuture<Void> completion;\n+        private final CompletableFuture<Long> soleExpectedAppData;\n+        private boolean receivedOneItem;\n+\n+        private AppResponseReceiver(final CompletableFuture<Void> completion,\n+                                    final CompletableFuture<Long> soleExpectedAppData) {\n+            this.numBytesReceived = new AtomicLong(0);\n+            this.soleExpectedAppData = soleExpectedAppData;\n+            this.completion = completion;\n+            Arrays.fill(expectedData, DATA_BYTE);\n+        }\n+\n+        @Override\n+        public void onSubscribe(Flow.Subscription subscription) {\n+            println(debugTag, \"onSubscribe invoked\");\n+            this.subscription = subscription;\n+            subscription.request(1); \/\/ the sole item request this subscriber will make\n+        }\n+\n+        @Override\n+        public void onNext(final List<ByteBuffer> buffers) {\n+            if (receivedOneItem) {\n+                \/\/ don't throw an exception since that will go against the Subscriber's\n+                \/\/ specification, instead complete the future exceptionally\n+                completion.completeExceptionally(new AssertionError(\"onNext() called more than\" +\n+                        \" once, even though no request was made\"));\n+                return;\n+            }\n+            receivedOneItem = true;\n+            \/\/ these buffers contain (decrypted) application data that the SSLFlowDelegate has\n+            \/\/ forwarded to this subscriber\n+            for (final ByteBuffer buf : buffers) {\n+                final int numBytes = buf.remaining();\n+                \/\/ verify the content of the received application data\n+                while (buf.hasRemaining()) {\n+                    final int size = Math.min(buf.remaining(), expectedData.length);\n+                    final byte[] actual = new byte[size];\n+                    buf.get(actual);\n+                    \/\/ this is just convenience\/performance optimization - instead of checking\n+                    \/\/ one byte at a time, we compare multiple bytes\n+                    final int index = Arrays.mismatch(expectedData, 0, size, actual, 0, size);\n+                    if (index != -1) {\n+                        final String errMsg = \"Unexpected byte received: \" + actual[index];\n+                        println(debugTag, \"Cancelling subscription due to error: \" + errMsg);\n+                        subscription.cancel();\n+                        completion.completeExceptionally(new AssertionError(errMsg));\n+                        return;\n+                    }\n+                }\n+                numBytesReceived.addAndGet(numBytes);\n+            }\n+            println(debugTag, \"Received \" + numBytesReceived.get() + \" bytes,\" +\n+                    \" will not request any more data\");\n+            soleExpectedAppData.complete(numBytesReceived.get());\n+        }\n+\n+        @Override\n+        public void onError(final Throwable throwable) {\n+            completion.completeExceptionally(throwable);\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            final long n = numBytesReceived.get();\n+            println(debugTag, \"Completed: received \" + n + \" bytes\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/whitebox\/java.net.http\/jdk\/internal\/net\/http\/SSLFlowDelegateTest.java","additions":595,"deletions":0,"binary":false,"changes":595,"status":"added"}]}