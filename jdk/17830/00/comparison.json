{"files":[{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n@@ -95,30 +94,0 @@\n-\n-\/\/ Ignores \"ref\" and calls allocate().\n-oop Generation::promote(oop obj, size_t obj_size) {\n-  assert(obj_size == obj->size(), \"bad obj_size passed in\");\n-\n-#ifndef PRODUCT\n-  if (SerialHeap::heap()->promotion_should_fail()) {\n-    return nullptr;\n-  }\n-#endif  \/\/ #ifndef PRODUCT\n-\n-  \/\/ Allocate new object.\n-  HeapWord* result = allocate(obj_size, false);\n-  if (result == nullptr) {\n-    \/\/ Promotion of obj into gen failed.  Try to expand and allocate.\n-    result = expand_and_allocate(obj_size, false);\n-    if (result == nullptr) {\n-      return nullptr;\n-    }\n-  }\n-\n-  \/\/ Copy to new location.\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(obj), result, obj_size);\n-  oop new_obj = cast_to_oop<HeapWord*>(result);\n-\n-  \/\/ Transform object if it is a stack chunk.\n-  ContinuationGCSupport::transform_stack_chunk(new_obj);\n-\n-  return new_obj;\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -145,9 +145,0 @@\n-  \/\/ \"obj\" is the address of an object in a younger generation.  Allocate space\n-  \/\/ for \"obj\" in the current (or some higher) generation, and copy \"obj\" into\n-  \/\/ the newly allocated space, if possible, returning the result (or null if\n-  \/\/ the allocation failed).\n-  \/\/\n-  \/\/ The \"obj_size\" argument is just obj->size(), passed along so the caller can\n-  \/\/ avoid repeating the virtual call to retrieve it.\n-  virtual oop promote(oop obj, size_t obj_size);\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n@@ -416,0 +417,29 @@\n+oop TenuredGeneration::promote(oop obj, size_t obj_size) {\n+  assert(obj_size == obj->size(), \"bad obj_size passed in\");\n+\n+#ifndef PRODUCT\n+  if (SerialHeap::heap()->promotion_should_fail()) {\n+    return nullptr;\n+  }\n+#endif  \/\/ #ifndef PRODUCT\n+\n+  \/\/ Allocate new object.\n+  HeapWord* result = allocate(obj_size, false);\n+  if (result == nullptr) {\n+    \/\/ Promotion of obj into gen failed.  Try to expand and allocate.\n+    result = expand_and_allocate(obj_size, false);\n+    if (result == nullptr) {\n+      return nullptr;\n+    }\n+  }\n+\n+  \/\/ Copy to new location.\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(obj), result, obj_size);\n+  oop new_obj = cast_to_oop<HeapWord*>(result);\n+\n+  \/\/ Transform object if it is a stack chunk.\n+  ContinuationGCSupport::transform_stack_chunk(new_obj);\n+\n+  return new_obj;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -163,0 +163,8 @@\n+  \/\/ \"obj\" is the address of an object in young-gen.  Allocate space for \"obj\"\n+  \/\/ in the old-gen, and copy \"obj\" into the newly allocated space, if\n+  \/\/ possible, returning the result (or null if the allocation failed).\n+  \/\/\n+  \/\/ The \"obj_size\" argument is just obj->size(), passed along so the caller can\n+  \/\/ avoid repeating the virtual call to retrieve it.\n+  oop promote(oop obj, size_t obj_size);\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}