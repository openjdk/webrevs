{"files":[{"patch":"@@ -655,0 +655,2 @@\n+  CDSConfig::set_is_at_aot_safepoint(true);\n+\n@@ -720,0 +722,2 @@\n+\n+  CDSConfig::set_is_at_aot_safepoint(false);\n@@ -776,4 +780,1 @@\n-void AOTMetaspace::link_shared_classes(TRAPS) {\n-  AOTClassLinker::initialize();\n-  AOTClassInitializer::init_test_class(CHECK);\n-\n+void AOTMetaspace::link_all_loaded_classes(JavaThread* current) {\n@@ -781,1 +782,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -789,1 +790,1 @@\n-        has_linked |= try_link_class(THREAD, ik);\n+        has_linked |= try_link_class(current, ik);\n@@ -799,0 +800,7 @@\n+}\n+\n+void AOTMetaspace::link_shared_classes(TRAPS) {\n+  AOTClassLinker::initialize();\n+  AOTClassInitializer::init_test_class(CHECK);\n+\n+  link_all_loaded_classes(THREAD);\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  static void link_all_loaded_classes(JavaThread* current);\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -940,1 +940,1 @@\n-      if (!ik->can_be_verified_at_dumptime()) {\n+      if (CDSConfig::is_old_class_for_verifier(ik)) {\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+bool CDSConfig::_is_at_aot_safepoint = false;\n@@ -925,0 +926,29 @@\n+bool CDSConfig::is_preserving_verification_constraints() {\n+  \/\/ Verification dependencies are classes used in assignability checks by the\n+  \/\/ bytecode verifier. In the following example, the verification dependencies\n+  \/\/ for X are A and B.\n+  \/\/\n+  \/\/     class X {\n+  \/\/        A getA() { return new B(); }\n+  \/\/     }\n+  \/\/\n+  \/\/ With the AOT cache, we can ensure that all the verification dependencies\n+  \/\/ (A and B in the above example) are unconditionally loaded during the bootstrap\n+  \/\/ of the production run. This means that if a class was successfully verified\n+  \/\/ in the assembly phase, all of the verifier's assignability checks will remain\n+  \/\/ valid in the production run, so we don't need to verify aot-linked classes again.\n+\n+  if (is_dumping_preimage_static_archive()) { \/\/ writing AOT config\n+    return AOTClassLinking;\n+  } else if (is_dumping_final_static_archive()) { \/\/ writing AOT cache\n+    return is_dumping_aot_linked_classes();\n+  } else {\n+    \/\/ For simplicity, we don't support this optimization with the old CDS workflow.\n+    return false;\n+  }\n+}\n+\n+bool CDSConfig::is_old_class_for_verifier(const InstanceKlass* ik) {\n+  return ik->major_version() < 50 \/*JAVA_6_VERSION*\/;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+class InstanceKlass;\n@@ -46,0 +47,1 @@\n+  static bool _is_at_aot_safepoint;\n@@ -102,0 +104,3 @@\n+  static bool is_at_aot_safepoint()                          { return CDS_ONLY(_is_at_aot_safepoint) NOT_CDS(false); }\n+  static void set_is_at_aot_safepoint(bool value)            { CDS_ONLY(_is_at_aot_safepoint = value); }\n+\n@@ -164,0 +169,4 @@\n+  \/\/ Bytecode verification\n+  static bool is_preserving_verification_constraints();\n+  static bool is_old_class_for_verifier(const InstanceKlass* ik);\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-void DumpTimeClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,\n+void DumpTimeClassInfo::add_verification_constraint(Symbol* name,\n@@ -76,3 +76,8 @@\n-    log_trace(aot, verification)(\"add_verification_constraint: %s: %s must be subclass of %s [0x%x] array len %d flags len %d\",\n-                                 k->external_name(), from_name->as_klass_external_name(),\n-                                 name->as_klass_external_name(), c, vc_array->length(), vcflags_array->length());\n+    if (from_name != nullptr) {\n+      log_trace(aot, verification)(\"add verification constraint: %s: %s must be subclass of %s [0x%x]\",\n+                                   _klass->external_name(), from_name->as_klass_external_name(),\n+                                   name->as_klass_external_name(), c);\n+    } else {\n+      log_trace(aot, verification)(\"added old verification constraint: %s: %s\", _klass->external_name(),\n+                                   name->as_klass_external_name());\n+    }\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-    DTVerifierConstraint(Symbol* n, Symbol* fn) : _name(n), _from_name(fn) {\n+    DTVerifierConstraint(Symbol* n, Symbol* fn = nullptr) : _name(n), _from_name(fn) {\n@@ -155,2 +155,3 @@\n-  void add_verification_constraint(InstanceKlass* k, Symbol* name,\n-         Symbol* from_name, bool from_field_is_protected, bool from_is_array, bool from_is_object);\n+  \/\/ For old verifier: only name is saved; all other fields are null\/false.\n+  void add_verification_constraint(Symbol* name,\n+         Symbol* from_name = nullptr, bool from_field_is_protected = false, bool from_is_array = false, bool from_is_object = false);\n@@ -178,0 +179,8 @@\n+  Symbol* verifier_constraint_name_at(int i) const {\n+    return _verifier_constraints->at(i).name();\n+  }\n+\n+  Symbol* verifier_constraint_from_name_at(int i) const {\n+    return _verifier_constraints->at(i).from_name();\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -113,0 +113,6 @@\n+    CDSConfig::set_is_at_aot_safepoint(true);\n+    doit_inner();\n+    CDSConfig::set_is_at_aot_safepoint(false);\n+  }\n+\n+  void doit_inner() {\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -474,2 +474,2 @@\n-    bool always_exclude = SystemDictionaryShared::check_for_exclusion(caller_ik, nullptr) ||\n-                          SystemDictionaryShared::check_for_exclusion(nest_host, nullptr);\n+    bool always_exclude = SystemDictionaryShared::should_be_excluded(caller_ik) ||\n+                          SystemDictionaryShared::should_be_excluded(nest_host);\n@@ -479,1 +479,1 @@\n-      if (always_exclude || SystemDictionaryShared::check_for_exclusion(ik, nullptr)) {\n+      if (always_exclude || SystemDictionaryShared::should_be_excluded(ik)) {\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,6 @@\n+\n+  if (CDSConfig::is_preserving_verification_constraints() && CDSConfig::is_dumping_final_static_archive()) {\n+    \/\/ The production run doesn't need the verifier constraints, as we can guarantee that all classes checked by\n+    \/\/ the verifier during AOT training\/assembly phases cannot be replaced in the production run.\n+    _num_verifier_constraints = 0;\n+  }\n@@ -47,2 +53,2 @@\n-      vf_constraints[i]._name      = builder->any_to_offset_u4(info._verifier_constraints->at(i).name());\n-      vf_constraints[i]._from_name = builder->any_to_offset_u4(info._verifier_constraints->at(i).from_name());\n+      vf_constraints[i]._name = builder->any_to_offset_u4(info._verifier_constraints->at(i).name());\n+      vf_constraints[i]._from_name = builder->any_or_null_to_offset_u4(info._verifier_constraints->at(i).from_name());\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -62,1 +62,3 @@\n-    Symbol* from_name() { return ArchiveUtils::offset_to_archived_address<Symbol*>(_from_name); }\n+    Symbol* from_name() {\n+      return (_from_name == 0) ? nullptr : ArchiveUtils::offset_to_archived_address<Symbol*>(_from_name);\n+    }\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -207,5 +207,6 @@\n-bool SystemDictionaryShared::check_for_exclusion(InstanceKlass* k, DumpTimeClassInfo* info) {\n-  if (CDSConfig::is_dumping_dynamic_archive() && AOTMetaspace::in_aot_cache(k)) {\n-    \/\/ We have reached a super type that's already in the base archive. Treat it\n-    \/\/ as \"not excluded\".\n-    return false;\n+bool SystemDictionaryShared::should_be_excluded_impl(InstanceKlass* k, DumpTimeClassInfo* info) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+\n+  if (!info->has_checked_exclusion()) {\n+    check_exclusion_for_self_and_dependencies(k);\n+    assert(info->has_checked_exclusion(), \"must be\");\n@@ -214,3 +215,21 @@\n-  if (info == nullptr) {\n-    info = _dumptime_table->get(k);\n-    assert(info != nullptr, \"supertypes of any classes in _dumptime_table must either be shared, or must also be in _dumptime_table\");\n+  return info->is_excluded();\n+}\n+\n+\/\/ <func> returns bool and takes a single parameter of Symbol*\n+\/\/ The return value indicates whether we want to keep on iterating or not.\n+template<typename Function>\n+void SystemDictionaryShared::iterate_verification_constraint_names(InstanceKlass* k, DumpTimeClassInfo* info, Function func) {\n+  int n = info->num_verifier_constraints();\n+  bool cont; \/\/ continue iterating?\n+  for (int i = 0; i < n; i++) {\n+    cont = func(info->verifier_constraint_name_at(i));\n+    if (!cont) {\n+      return; \/\/ early termination\n+    }\n+    Symbol* from_name = info->verifier_constraint_from_name_at(i);\n+    if (from_name != nullptr) {\n+      cont = func(from_name);\n+      if (!cont) {\n+        return; \/\/ early termination\n+      }\n+    }\n@@ -218,0 +237,1 @@\n+}\n@@ -219,3 +239,48 @@\n-  if (!info->has_checked_exclusion()) {\n-    if (check_for_exclusion_impl(k)) {\n-      info->set_excluded();\n+\/\/ This is a table of classes that need to be checked for exclusion.\n+class SystemDictionaryShared::ExclusionCheckCandidates\n+  : public HashTable<InstanceKlass*, DumpTimeClassInfo*, 15889> {\n+  void add_candidate(InstanceKlass* k) {\n+    if (contains(k)) {\n+      return;\n+    }\n+    if (CDSConfig::is_dumping_dynamic_archive() && AOTMetaspace::in_aot_cache(k)) {\n+      return;\n+    }\n+\n+    DumpTimeClassInfo* info = SystemDictionaryShared::get_info_locked(k);\n+    if (info->has_checked_exclusion()) {\n+      \/\/ We have check exclusion of k and all of its dependencies, so there's no need to check again.\n+      return;\n+    }\n+\n+    put(k, info);\n+\n+    if (!k->is_loaded()) {\n+      \/\/ super types are not yet initialized for k.\n+      return;\n+    }\n+\n+    InstanceKlass* super = k->java_super();\n+    if (super != nullptr) {\n+      add_candidate(super);\n+    }\n+\n+    Array<InstanceKlass*>* interfaces = k->local_interfaces();\n+    int len = interfaces->length();\n+    for (int i = 0; i < len; i++) {\n+      add_candidate(interfaces->at(i));\n+    }\n+\n+    InstanceKlass* nest_host = k->nest_host_or_null();\n+    if (nest_host != nullptr && nest_host != k) {\n+      add_candidate(nest_host);\n+    }\n+\n+    if (CDSConfig::is_preserving_verification_constraints()) {\n+      SystemDictionaryShared::iterate_verification_constraint_names(k, info, [&] (Symbol* constraint_class_name) {\n+        Klass* constraint_bottom_class = find_verification_constraint_bottom_class(k, constraint_class_name);\n+        if (constraint_bottom_class != nullptr && constraint_bottom_class->is_instance_klass()) {\n+          add_candidate(InstanceKlass::cast(constraint_bottom_class));\n+        }\n+        return true; \/\/ Keep iterating.\n+      });\n@@ -223,1 +288,0 @@\n-    info->set_has_checked_exclusion();\n@@ -226,1 +290,65 @@\n-  return info->is_excluded();\n+public:\n+  ExclusionCheckCandidates(InstanceKlass* k) {\n+    add_candidate(k);\n+  }\n+};\n+\n+\/\/ A class X is excluded if check_self_exclusion() returns true for X or any of\n+\/\/ X's \"exclusion dependency\" classes, which include:\n+\/\/     - ik's super types\n+\/\/     - ik's nest host (if any)\n+\/\/\n+\/\/  plus, if CDSConfig::is_preserving_verification_constraints()==true:\n+\/\/     - ik's verification constraints. These are the classes used in assignability checks\n+\/\/         when verifying ik's bytecodes.\n+\/\/\n+\/\/ This method ensure that exclusion check is performed on X and all of its exclusion dependencies.\n+void SystemDictionaryShared::check_exclusion_for_self_and_dependencies(InstanceKlass* ik) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  ResourceMark rm;\n+\n+  \/\/ This will recursively find ik and all of its exclusion dependencies that have not yet been checked.\n+  ExclusionCheckCandidates candidates(ik);\n+\n+  \/\/ (1) Check each class to see if it should be excluded due to its own problems\n+  candidates.iterate_all([&] (InstanceKlass* k, DumpTimeClassInfo* info) {\n+    if (check_self_exclusion(k)) {\n+      info->set_excluded();\n+    }\n+  });\n+\n+  \/\/ (2) Check each class to see if it should be excluded because of problems in a depeendency class\n+  while (true) {\n+    bool found_new_exclusion = false;\n+\n+    candidates.iterate_all([&] (InstanceKlass* k, DumpTimeClassInfo* info) {\n+      if (!info->is_excluded() && check_dependencies_exclusion(k, info)) {\n+        info->set_excluded();\n+        found_new_exclusion = true;\n+      }\n+    });\n+\n+    \/\/ Algorithm notes:\n+    \/\/\n+    \/\/ The dependencies form a directed graph, possibly cyclic. Class X is excluded\n+    \/\/ if it has at least one directed path that reaches class Y, where\n+    \/\/ check_self_exclusion(Y) returns true.\n+    \/\/\n+    \/\/ Because of the possibility of cycles in the graph, we cannot use simple\n+    \/\/ recursion. Otherwise we will either never terminate, or will miss some paths.\n+    \/\/\n+    \/\/ Hence, we keep doing a linear scan of the candidates until we stop finding\n+    \/\/ new exclusions.\n+    \/\/\n+    \/\/ In the worst case, we find one exclusion per iteration of the while loop,\n+    \/\/ so the while loop gets executed O(N^2) times. However, in reality we have\n+    \/\/ very few exclusions, so in most cases the while loop executes only once, and we\n+    \/\/ walk each edge in the dependencies graph exactly once.\n+    if (!found_new_exclusion) {\n+      break;\n+    }\n+  }\n+  candidates.iterate_all([&] (InstanceKlass* k, DumpTimeClassInfo* info) {\n+    \/\/ All candidates have been fully checked, so we don't need to check them again.\n+    info->set_has_checked_exclusion();\n+  });\n@@ -251,1 +379,2 @@\n-bool SystemDictionaryShared::check_for_exclusion_impl(InstanceKlass* k) {\n+bool SystemDictionaryShared::check_self_exclusion(InstanceKlass* k) {\n+  assert_lock_strong(DumpTimeTable_lock);\n@@ -304,3 +433,2 @@\n-      \/\/ However, we do not speculatively link old classes, as they are not recorded by\n-      \/\/ SystemDictionaryShared::record_linking_constraint(). As a result, such an unlinked\n-      \/\/ class may fail to verify in AOTLinkedClassBulkLoader::init_required_classes_for_loader(),\n+      \/\/ Old classes may not be linked if CDSConfig::is_preserving_verification_constraints()==false.\n+      \/\/ An unlinked class may fail to verify in AOTLinkedClassBulkLoader::init_required_classes_for_loader(),\n@@ -332,4 +460,7 @@\n-  InstanceKlass* super = k->super();\n-  if (super != nullptr && check_for_exclusion(super, nullptr)) {\n-    ResourceMark rm;\n-    aot_log_warning(aot)(\"Skipping %s: super class %s is excluded\", k->name()->as_C_string(), super->name()->as_C_string());\n+  return false;\n+}\n+\n+\/\/ Returns true if DumpTimeClassInfo::is_excluded() is true for at least one of k's exclusion dependencies.\n+bool SystemDictionaryShared::check_dependencies_exclusion(InstanceKlass* k, DumpTimeClassInfo* info) {\n+  InstanceKlass* super = k->java_super();\n+  if (super != nullptr && is_dependency_excluded(k, super, \"super\")) {\n@@ -343,3 +474,1 @@\n-    if (check_for_exclusion(intf, nullptr)) {\n-      ResourceMark rm;\n-      aot_log_warning(aot)(\"Skipping %s: interface %s is excluded\", k->name()->as_C_string(), intf->name()->as_C_string());\n+    if (is_dependency_excluded(k, intf, \"interface\")) {\n@@ -351,1 +480,33 @@\n-  if (nest_host != nullptr && nest_host != k && check_for_exclusion(nest_host, nullptr)) {\n+  if (nest_host != nullptr && nest_host != k && is_dependency_excluded(k, nest_host, \"nest host class\")) {\n+    return true;\n+  }\n+\n+  if (CDSConfig::is_preserving_verification_constraints()) {\n+    bool excluded = false;\n+\n+    iterate_verification_constraint_names(k, info, [&] (Symbol* constraint_class_name) {\n+      if (check_verification_constraint_exclusion(k, constraint_class_name)) {\n+        \/\/ If one of the verification constraint class has been excluded, the assignability checks\n+        \/\/ by the verifier may no longer be valid in the production run. For safety, exclude this class.\n+        excluded = true;\n+        return false; \/\/ terminate iteration; k will be excluded\n+      } else {\n+        return true; \/\/ keep iterating\n+      }\n+    });\n+\n+    if (excluded) {\n+      \/\/ At least one verification constraint class has been excluded\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool SystemDictionaryShared::is_dependency_excluded(InstanceKlass* k, InstanceKlass* dependency, const char* type) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && AOTMetaspace::in_aot_cache(dependency)) {\n+    return false;\n+  }\n+  DumpTimeClassInfo* dependency_info = get_info_locked(dependency);\n+  if (dependency_info->is_excluded()) {\n@@ -353,1 +514,1 @@\n-    aot_log_warning(aot)(\"Skipping %s: nest_host class %s is excluded\", k->name()->as_C_string(), nest_host->name()->as_C_string());\n+    aot_log_warning(aot)(\"Skipping %s: %s %s is excluded\", k->name()->as_C_string(), type, dependency->name()->as_C_string());\n@@ -356,0 +517,2 @@\n+  return false;\n+}\n@@ -357,1 +520,35 @@\n-  return false; \/\/ false == k should NOT be excluded\n+bool SystemDictionaryShared::check_verification_constraint_exclusion(InstanceKlass* k, Symbol* constraint_class_name) {\n+  Klass* constraint_bottom_class = find_verification_constraint_bottom_class(k, constraint_class_name);\n+  if (constraint_bottom_class == nullptr) {\n+    \/\/ We don't have a bottom class (constraint_class_name is a type array), or constraint_class_name\n+    \/\/ has not been loaded. The latter case happens when the new verifier was checking\n+    \/\/ if constraint_class_name is assignable to an interface, and found the answer without resolving\n+    \/\/ constraint_class_name.\n+    \/\/\n+    \/\/ Since this class is not even loaded, it surely cannot be excluded.\n+    return false;\n+  } else if (constraint_bottom_class->is_instance_klass()) {\n+    if (is_dependency_excluded(k, InstanceKlass::cast(constraint_bottom_class), \"verification constraint\")) {\n+      return true;\n+    }\n+  } else {\n+    assert(constraint_bottom_class->is_typeArray_klass(), \"must be\");\n+  }\n+\n+  return false;\n+}\n+\n+Klass* SystemDictionaryShared::find_verification_constraint_bottom_class(InstanceKlass* k, Symbol* constraint_class_name) {\n+  Thread* current = Thread::current();\n+  Handle loader(current, k->class_loader());\n+  Klass* constraint_class = SystemDictionary::find_instance_or_array_klass(current, constraint_class_name, loader);\n+  if (constraint_class == nullptr) {\n+    return nullptr;\n+  }\n+\n+  if (constraint_class->is_objArray_klass()) {\n+    constraint_class = ObjArrayKlass::cast(constraint_class)->bottom_klass();\n+  }\n+\n+  precond(constraint_class->is_typeArray_klass() || constraint_class->is_instance_klass());\n+  return constraint_class;\n@@ -559,1 +756,1 @@\n-  copy_verification_constraints_from_preimage(k);\n+  copy_verification_info_from_preimage(k);\n@@ -654,1 +851,1 @@\n-\/\/ it can be checked by check_for_exclusion().\n+\/\/ it can be checked by should_be_excluded_impl().\n@@ -659,2 +856,4 @@\n-  if (k->is_objArray_klass()) {\n-    return should_be_excluded(ObjArrayKlass::cast(k)->bottom_klass());\n+  if (CDSConfig::is_dumping_dynamic_archive() && AOTMetaspace::in_aot_cache(k)) {\n+    \/\/ We have reached a super type that's already in the base archive. Treat it\n+    \/\/ as \"not excluded\".\n+    return false;\n@@ -663,1 +862,4 @@\n-  if (!k->is_instance_klass()) {\n+  if (k->is_objArray_klass()) {\n+    return should_be_excluded(ObjArrayKlass::cast(k)->bottom_klass());\n+  } else if (!k->is_instance_klass()) {\n+    assert(k->is_typeArray_klass(), \"must be\");\n@@ -675,1 +877,1 @@\n-        \/\/ check_for_exclusion() below doesn't link unlinked classes. We come\n+        \/\/ should_be_excluded_impl() below doesn't link unlinked classes. We come\n@@ -684,0 +886,4 @@\n+\n+        \/\/ Also link any classes that were loaded for the verification of ik or its supertypes.\n+        \/\/ Otherwise we might miss the verification constraints of those classes.\n+        AOTMetaspace::link_all_loaded_classes(THREAD);\n@@ -691,1 +897,1 @@\n-      return check_for_exclusion(ik, p);\n+      return should_be_excluded_impl(ik, p);\n@@ -693,0 +899,9 @@\n+      \/\/ When called within the CDS safepoint, the correctness of this function\n+      \/\/ relies on the call to AOTMetaspace::link_all_loaded_classes()\n+      \/\/ that happened right before we enter the CDS safepoint.\n+      \/\/\n+      \/\/ Do not call this function in other types of safepoints. For example, if this\n+      \/\/ is called in a GC safepoint, a klass may be improperly excluded because some\n+      \/\/ of its verification constraints have not yet been linked.\n+      assert(CDSConfig::is_at_aot_safepoint(), \"Do not call this function in any other safepoint\");\n+\n@@ -700,1 +915,1 @@\n-      return check_for_exclusion(ik, p);\n+      return should_be_excluded_impl(ik, p);\n@@ -706,0 +921,1 @@\n+  assert_at_safepoint();\n@@ -716,1 +932,1 @@\n-    SystemDictionaryShared::check_for_exclusion(k, &info);\n+    SystemDictionaryShared::should_be_excluded_impl(k, &info);\n@@ -796,1 +1012,1 @@\n-  info->add_verification_constraint(k, name, from_name, from_field_is_protected,\n+  info->add_verification_constraint(name, from_name, from_field_is_protected,\n@@ -821,0 +1037,9 @@\n+\/\/ When the old verifier is verifying the class <ik> at dump time, it tries to resolve a\n+\/\/ class with the given <name>. For the verification result to be valid at run time, we must\n+\/\/ ensure that <name> resolves to the exact same Klass as in dump time.\n+void SystemDictionaryShared::add_old_verification_constraint(Thread* current, InstanceKlass* ik, Symbol* name) {\n+  precond(CDSConfig::is_preserving_verification_constraints());\n+  DumpTimeClassInfo* info = get_info(ik);\n+  info->add_verification_constraint(name);\n+}\n+\n@@ -839,0 +1064,7 @@\n+      if (from_name == nullptr) {\n+        \/\/ This is for old verifier. No need to check, as we can guarantee that all classes checked by\n+        \/\/ the old verifier during AOT training phase cannot be replaced in the asembly phase.\n+        precond(CDSConfig::is_dumping_final_static_archive());\n+        continue;\n+      }\n+\n@@ -863,1 +1095,1 @@\n-void SystemDictionaryShared::copy_verification_constraints_from_preimage(InstanceKlass* klass) {\n+void SystemDictionaryShared::copy_verification_info_from_preimage(InstanceKlass* klass) {\n@@ -875,1 +1107,1 @@\n-      dt_info->add_verification_constraint(klass, name, from_name,\n+      dt_info->add_verification_constraint(name, from_name,\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":271,"deletions":39,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-\n+  class ExclusionCheckCandidates;\n@@ -178,1 +178,11 @@\n-  static bool check_for_exclusion_impl(InstanceKlass* k);\n+  static bool should_be_excluded_impl(InstanceKlass* k, DumpTimeClassInfo* info);\n+\n+  \/\/ exclusion checks\n+  static void check_exclusion_for_self_and_dependencies(InstanceKlass *k);\n+  static bool check_self_exclusion(InstanceKlass* k);\n+  static bool check_dependencies_exclusion(InstanceKlass* k, DumpTimeClassInfo* info);\n+  static bool check_verification_constraint_exclusion(InstanceKlass* k, Symbol* constraint_class_name);\n+  static bool is_dependency_excluded(InstanceKlass* k, InstanceKlass* dependency, const char* type);\n+  static bool is_excluded_verification_constraint(InstanceKlass* k, Symbol* constraint_class_name);\n+  static Klass* find_verification_constraint_bottom_class(InstanceKlass* k, Symbol* constraint_class_name);\n+\n@@ -183,1 +193,1 @@\n-  static void copy_verification_constraints_from_preimage(InstanceKlass* klass);\n+  static void copy_verification_info_from_preimage(InstanceKlass* klass);\n@@ -186,0 +196,3 @@\n+  template<typename Function>\n+  static void iterate_verification_constraint_names(InstanceKlass* k, DumpTimeClassInfo* info, Function func);\n+\n@@ -242,0 +255,1 @@\n+  static void add_old_verification_constraint(Thread* current, InstanceKlass* k, Symbol* name);\n@@ -261,1 +275,0 @@\n-  static bool check_for_exclusion(InstanceKlass* k, DumpTimeClassInfo* info);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2842,5 +2842,0 @@\n-\/\/ Check if a class or any of its supertypes has a version older than 50.\n-\/\/ CDS will not perform verification of old classes during dump time because\n-\/\/ without changing the old verifier, the verification constraint cannot be\n-\/\/ retrieved during dump time.\n-\/\/ Verification of archived old classes will be performed during run time.\n@@ -2853,1 +2848,8 @@\n-  if (major_version() < 50 \/*JAVA_6_VERSION*\/) {\n+\n+  if (CDSConfig::is_preserving_verification_constraints()) {\n+    return true;\n+  }\n+\n+  if (CDSConfig::is_old_class_for_verifier(this)) {\n+    \/\/ The old verifier does not save verification constraints, so at run time\n+    \/\/ SystemDictionaryShared::check_verification_constraints() will not work for this class.\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -326,3 +326,2 @@\n-  if (SafepointSynchronize::is_at_safepoint() &&\n-      CDSConfig::is_dumping_archive() &&\n-      CDSConfig::current_thread_is_vm_or_dumper()) {\n+  if (CDSConfig::is_at_aot_safepoint()) {\n+    \/\/ Check for CDS exclusion only at CDS safe point.\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -557,1 +557,5 @@\n-    bool is_excluded = !holder()->is_loaded() || SystemDictionaryShared::check_for_exclusion(holder(), nullptr);\n+    bool is_excluded = !holder()->is_loaded();\n+    if (CDSConfig::is_at_aot_safepoint()) {\n+      \/\/ Check for AOT exclusion only at AOT safe point.\n+      is_excluded |= SystemDictionaryShared::should_be_excluded(holder());\n+    }\n@@ -576,1 +580,2 @@\n-    if (SystemDictionaryShared::check_for_exclusion(holder()->method_holder(), nullptr)) {\n+    if (CDSConfig::is_at_aot_safepoint() && SystemDictionaryShared::should_be_excluded(holder()->method_holder())) {\n+      \/\/ Check for AOT exclusion only at AOT safe point.\n","filename":"src\/hotspot\/share\/oops\/trainingData.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -853,0 +853,7 @@\n+#if INCLUDE_CDS\n+  if (CDSConfig::is_preserving_verification_constraints() && from_class->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(from_class);\n+    SystemDictionaryShared::add_old_verification_constraint(THREAD, ik, h_name);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-  MUTEX_DEFN(DumpRegion_lock                 , PaddedMutex  , nosafepoint);\n+  MUTEX_DEFL(DumpRegion_lock                 , PaddedMutex  , DumpTimeTable_lock);\n@@ -313,1 +313,1 @@\n-  MUTEX_DEFN(ScratchObjects_lock             , PaddedMutex  , nosafepoint-1); \/\/ Holds DumpTimeTable_lock\n+  MUTEX_DEFL(ScratchObjects_lock             , PaddedMutex  , DumpTimeTable_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -529,0 +529,1 @@\n+ -runtime\/cds\/appcds\/LambdaContainsOldInf.java \\\n@@ -536,1 +537,1 @@\n- -runtime\/cds\/appcds\/dynamicArchive\/ModulePath.java \\\n+ -runtime\/cds\/appcds\/dynamicArchive\/LambdaContainsOldInf.java \\\n@@ -541,0 +542,2 @@\n+ -runtime\/cds\/appcds\/dynamicArchive\/ModulePath.java \\\n+ -runtime\/cds\/appcds\/dynamicArchive\/NestHostOldInf.java \\\n@@ -544,0 +547,1 @@\n+ -runtime\/cds\/appcds\/dynamicArchive\/RedefineCallerClassTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-                out.shouldContain(\"check_verification_constraint: TestApp$Foo$Taz: TestApp$Foo$ShouldBeExcludedChild must be subclass of TestApp$Foo$ShouldBeExcluded\");\n@@ -262,8 +261,3 @@\n-                \/\/ When verifying this method, we need to check the constraint that\n-                \/\/ ShouldBeExcluded must be a supertype of ShouldBeExcludedChild. This information\n-                \/\/ is checked by SystemDictionaryShared::check_verification_constraints() when the Taz\n-                \/\/ class is linked during the production run.\n-                \/\/\n-                \/\/ Because ShouldBeExcluded is excluded from the AOT archive, it must be loaded\n-                \/\/ dynamically from app.jar inside SystemDictionaryShared::check_verification_constraints().\n-                \/\/ This must happen after the app class loader has been fully restored from the AOT cache.\n+                \/\/ Taz should be excluded from the AOT cache because it has a verification constraint that\n+                \/\/ \"ShouldBeExcludedChild must be a subtype of ShouldBeExcluded\", but ShouldBeExcluded is\n+                \/\/ excluded from the AOT cache.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/ExcludedClasses.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class OldA\n+    version 49:0\n+{\n+\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/OldA.jasm","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Store old classes linked state in AOT cache as long as their verification constraints are not excluded.\n+ * @bug 8317269\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build OldClass OldA OldClassWithVerifierConstraints OldClassWithExcludedVerifierConstraints\n+ * @build OldClassSupport\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 AppUsesOldClass MyIntf OldClass OldA NewB MyEvent MyEvent2\n+ *                 OldClassWithVerifierConstraints\n+ *                 OldClassWithExcludedVerifierConstraints\n+ *                 NewClassWithExcludedVerifierConstraints\n+ * @run driver OldClassSupport\n+ *\/\n+\n+import jdk.jfr.Event;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class OldClassSupport {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = \"AppUsesOldClass\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester tester = new Tester();\n+        tester.run(new String[] {\"AOT\", \"--two-step-training\"} );\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            return new String[] {\n+                \"-Xlog:aot+class=debug\",\n+                \"-Xlog:aot+resolve=trace\",\n+            };\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\"-Xlog:cds+class=debug\", mainClass};\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) {\n+            Class[] included = {\n+                OldClass.class,\n+                OldA.class,\n+                NewB.class,\n+                OldClassWithVerifierConstraints.class,\n+            };\n+\n+            Class[] excluded = {\n+                OldClassWithExcludedVerifierConstraints.class,\n+                NewClassWithExcludedVerifierConstraints.class,\n+            };\n+\n+\n+            if (runMode == RunMode.TRAINING) {\n+                shouldInclude(out, false, included);\n+                shouldNotInclude(out, excluded);\n+                shouldSkip(out, excluded);\n+            } else if (runMode == RunMode.ASSEMBLY) {\n+                shouldInclude(out, true, included);\n+                shouldNotInclude(out, excluded);\n+            }\n+        }\n+    }\n+\n+    static void shouldInclude(OutputAnalyzer out, boolean linked, Class[] classes) {\n+        for (Class c : classes) {\n+            out.shouldMatch(\"aot,class.* = 0x.* app *\" + c.getName() + (linked ? \" .*aot-linked\" : \"\"));\n+        }\n+    }\n+\n+    static void shouldNotInclude(OutputAnalyzer out, Class[] classes) {\n+        for (Class c : classes) {\n+            out.shouldNotMatch(\"aot,class.* = 0x.* app *\" + c.getName());\n+        }\n+    }\n+\n+    static void shouldSkip(OutputAnalyzer out, Class[] classes) {\n+        for (Class c : classes) {\n+            out.shouldMatch(\"Skipping \" + c.getName() + \": verification constraint .* is excluded\");\n+        }\n+    }\n+}\n+\n+class AppUsesOldClass {\n+    public static void main(String args[]) {\n+        System.out.println(\"Old Class Instance: \" + new OldClass());\n+\n+        System.out.println(get_OldA_from_NewB());\n+        System.out.println(OldClassWithVerifierConstraints.get_OldA_from_NewB());\n+        System.out.println(OldClassWithExcludedVerifierConstraints.get_Event_from_MyEvent());\n+        System.out.println(NewClassWithExcludedVerifierConstraints.get_MyEvent_from_MyEvent2());\n+        System.out.println(new MyEvent());\n+\n+        \/\/ OldClassWithExcludedVerifierConstraints should still be excluded even it has been used\n+        \/\/ in a lambda expression during the training run.\n+        run((OldClassWithExcludedVerifierConstraints x) -> {\n+                System.out.println(x);\n+            });\n+    }\n+\n+    static OldA get_OldA_from_NewB() {\n+        return new NewB();\n+    }\n+\n+    static void run(MyIntf intf) {\n+        intf.function(new OldClassWithExcludedVerifierConstraints());\n+    }\n+}\n+\n+interface MyIntf {\n+    public void function(OldClassWithExcludedVerifierConstraints x);\n+}\n+\n+class NewB extends OldA {}\n+\n+class MyEvent extends Event {}\n+class MyEvent2 extends MyEvent {}\n+\n+class NewClassWithExcludedVerifierConstraints {\n+    static MyEvent get_MyEvent_from_MyEvent2() {\n+        return new MyEvent2();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/OldClassSupport.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This old class has a verification constraint that \"MyEvent must be a subtype of Event\". However,\n+\/\/ Event and all of its subtypes are excluded from the AOT cache, so this class must also be excluded.\n+\n+super public class OldClassWithExcludedVerifierConstraints\n+    version 49:0\n+{\n+\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+static Method get_Event_from_MyEvent:\"()Ljdk\/jfr\/Event;\"\n+    stack 2 locals 0\n+{\n+        new              class MyEvent;\n+        dup;\n+        invokespecial    Method MyEvent.\"<init>\":\"()V\";\n+        areturn;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/OldClassWithExcludedVerifierConstraints.jasm","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This old class as a verification constraint that \"NewB must be a subtype of OldA\". Since both\n+\/\/ OldA and NewB are not excluded, then this class should be cached in aot-linked state.\n+\n+super public class OldClassWithVerifierConstraints\n+    version 49:0\n+{\n+\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+static Method get_OldA_from_NewB:\"()LOldA;\"\n+    stack 2 locals 0\n+{\n+        new              class NewB;\n+        dup;\n+        invokespecial    Method NewB.\"<init>\":\"()V\";\n+        areturn;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/OldClassWithVerifierConstraints.jasm","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8317269\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @summary Test for verification of classes that are aot-linked\n+ * @library \/test\/jdk\/lib\/testlibrary\n+ *          \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build GoodOldClass\n+ *        BadOldClass BadOldClass2 BadOldClass3 BadOldClass4\n+ *        BadNewClass BadNewClass2 BadNewClass3 BadNewClass4\n+ * @build AOTClassLinkingVerification\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app1.jar\n+ *                 AOTClassLinkingVerificationApp\n+ *                 Unlinked UnlinkedSuper\n+ *                 BadOldClass\n+ *                 BadOldClass2\n+ *                 BadOldClass3\n+ *                 BadOldClass4\n+ *                 BadNewClass\n+ *                 BadNewClass2\n+ *                 BadNewClass3\n+ *                 BadNewClass4\n+ *                 GoodOldClass Vehicle Car\n+ *                 Util\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app2.jar\n+ *                 Foo NotFoo\n+ *                 UnlinkedSub\n+ * @run driver AOTClassLinkingVerification\n+ *\/\n+\n+import java.io.File;\n+import java.lang.invoke.MethodHandles;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class AOTClassLinkingVerification {\n+    static final String app1Jar = ClassFileInstaller.getJarPath(\"app1.jar\");\n+    static final String app2Jar = ClassFileInstaller.getJarPath(\"app2.jar\");\n+    static final String wbJar = TestCommon.getTestJar(\"WhiteBox.jar\");\n+    static final String bootAppendWhiteBox = \"-Xbootclasspath\/a:\" + wbJar;\n+    static final String mainClass = AOTClassLinkingVerificationApp.class.getName();\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester(String testName) {\n+            super(testName);\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            if (runMode == RunMode.TRAINING ||\n+                runMode == RunMode.ASSEMBLY) {\n+                return new String[] {\n+                    \"-XX:+AOTClassLinking\", \"-Xlog:cds+class=debug\", bootAppendWhiteBox,\n+                };\n+            } else {\n+                return new String[] {\n+                    \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+WhiteBoxAPI\", bootAppendWhiteBox,\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            if (runMode == RunMode.TRAINING ||\n+                runMode == RunMode.ASSEMBLY) {\n+                return app1Jar;\n+            } else {\n+                return app1Jar + File.pathSeparator + app2Jar;\n+            }\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            if (runMode == RunMode.TRAINING ||\n+                runMode == RunMode.ASSEMBLY) {\n+                return new String[] {\n+                    \"AOTClassLinkingVerificationApp\", app1Jar, \"ASSEMBLY\"\n+                };\n+            } else {\n+                return new String[] {\n+                    \"AOTClassLinkingVerificationApp\", app1Jar, \"PRODUCTION\"\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            if (runMode == RunMode.TRAINING) {\n+                out.shouldContain(\"Preload Warning: Verification failed for BadNewClass\");\n+                out.shouldContain(\"Preload Warning: Verification failed for BadNewClass2\");\n+                out.shouldContain(\"Preload Warning: Verification failed for BadNewClass3\");\n+                out.shouldContain(\"Preload Warning: Verification failed for BadNewClass4\");\n+                out.shouldContain(\"Preload Warning: Verification failed for BadOldClass\");\n+                out.shouldContain(\"Preload Warning: Verification failed for BadOldClass2\");\n+                out.shouldContain(\"Preload Warning: Verification failed for BadOldClass3\");\n+                out.shouldContain(\"Preload Warning: Verification failed for BadOldClass4\");\n+                out.shouldContain(\"Preload Warning: Verification failed for Unlinked\");\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Dump without app2.jar so:\n+        \/\/  - Unlinked can be resolved, but UnlinkedSuper UnlinkedSub cannot be resolved,\n+        \/\/    so Unlinked cannot be verified at dump time.\n+        \/\/  - BadOldClass2 can be resolved, but Foo and NotFoo cannot be resolved,\n+        \/\/    so BadOldClass2 cannot be verified at dump time.\n+        \/\/  - BadNewClass2 can be resolved, but Foo and NotFoo cannot be resolved,\n+        \/\/    so BadNewClass2 cannot be verified at dump time.\n+        Tester t1 = new Tester(\"verification-aot-linked-classes\");\n+        t1.run(\"AOT\");\n+    }\n+}\n+\n+class AOTClassLinkingVerificationApp {\n+    static WhiteBox wb = WhiteBox.getWhiteBox();\n+    static ClassLoader classLoader = AOTClassLinkingVerificationApp.class.getClassLoader();\n+    static File app1Jar;\n+    static boolean isProduction;\n+    public static void main(String[] args) throws Exception {\n+        app1Jar = new File(args[0]);\n+        isProduction = args[1].equals(\"PRODUCTION\");\n+        if (isProduction) {\n+            assertNotShared(UnlinkedSub.class);\n+            assertShared(UnlinkedSuper.class);\n+            assertNotShared(Unlinked.class); \/\/ failed verification during dump time\n+            assertNotShared(Foo.class);\n+            assertNotShared(NotFoo.class);\n+        }\n+        String s = null;\n+        try {\n+            s = Unlinked.doit();\n+        } catch (NoClassDefFoundError ncdfe) {\n+            \/\/ UnlinkedSub is in app2Jar but only app1Jar is used during training\n+            \/\/ and assembly phases. So NoClassDefFoundError is expected during\n+            \/\/ during training and assembly phases.\n+            if (isProduction) {\n+                throw ncdfe;\n+            }\n+        }\n+        if (isProduction && !s.equals(\"heyhey\")) {\n+            throw new RuntimeException(\"Unlinked.doit() returns wrong result: \" + s);\n+        }\n+\n+        \/\/ ===============================================================================\n+\n+        checkSimpleBadClass(\"BadOldClass\");\n+\n+        Class cls_BadOldClass2 = Class.forName(\"BadOldClass2\", false, classLoader);\n+        if (isProduction) {\n+            assertNotShared(cls_BadOldClass2); \/\/ failed verification during dump time\n+        }\n+        try {\n+            cls_BadOldClass2.newInstance();\n+            throw new RuntimeException(\"BadOldClass2 cannot be verified\");\n+        } catch (NoClassDefFoundError ncdfe) {\n+            \/\/ BadOldClass2 loads Foo and NotFoo which is in app2Jar which is used\n+            \/\/ only in production run.\n+            if (isProduction) {\n+                throw ncdfe;\n+            }\n+        } catch (VerifyError expected) {}\n+\n+        checkSimpleBadClass(\"BadOldClass3\");\n+        checkSimpleBadClass(\"BadOldClass4\");\n+\n+        \/\/ ===============================================================================\n+\n+        checkSimpleBadClass(\"BadNewClass\");\n+\n+        Class cls_BadNewClass2 = Class.forName(\"BadNewClass2\", false, classLoader);\n+        if (isProduction) {\n+            assertNotShared(cls_BadNewClass2); \/\/ failed verification during dump time\n+        }\n+        try {\n+            cls_BadNewClass2.newInstance();\n+            throw new RuntimeException(\"BadNewClass2 cannot be verified\");\n+        } catch (NoClassDefFoundError ncdfe) {\n+            \/\/ BadNewClass2 loads Foo and NotFoo which is in app2Jar which is used\n+            \/\/ only in production run.\n+            if (isProduction) {\n+                throw ncdfe;\n+            }\n+        } catch (VerifyError expected) {}\n+\n+        checkSimpleBadClass(\"BadNewClass3\");\n+        checkSimpleBadClass(\"BadNewClass4\");\n+\n+        \/\/ ===============================================================================\n+\n+        if (isProduction) {\n+            assertAlreadyLoaded(\"Vehicle\");\n+            assertAlreadyLoaded(\"Car\");\n+            assertAlreadyLoaded(\"GoodOldClass\");\n+\n+            assertShared(GoodOldClass.class);\n+            assertShared(Vehicle.class);\n+            assertShared(Car.class);\n+        }\n+\n+        GoodOldClass.doit(); \/\/ Should not fail\n+    }\n+\n+    static void checkSimpleBadClass(String className) throws Exception {\n+        Class cls = Class.forName(className, false, classLoader);\n+        if (isProduction) {\n+            assertNotShared(cls); \/\/ failed verification during dump time\n+        }\n+        try {\n+            cls.newInstance();\n+            throw new RuntimeException(className + \" should not pass verification\");\n+        } catch (VerifyError expected) {}\n+    }\n+\n+    static void assertShared(Class c) {\n+        if (!wb.isSharedClass(c)) {\n+            throw new RuntimeException(\"wb.isSharedClass(\" + c.getName() + \") should be true\");\n+        }\n+    }\n+\n+    static void assertNotShared(Class c) {\n+        if (wb.isSharedClass(c)) {\n+            throw new RuntimeException(\"wb.isSharedClass(\" + c.getName() + \") should be false\");\n+        }\n+    }\n+\n+    static void assertAlreadyLoaded(String className) throws Exception {\n+        byte[] data = Util.getClassFileFromJar(app1Jar, className);\n+        try {\n+            MethodHandles.lookup().defineClass(data);\n+        } catch (LinkageError e) {\n+            if (e.getMessage().contains(\"duplicate class definition for \" + className)) {\n+                return;\n+            } else {\n+                throw e;\n+            }\n+        }\n+        throw new RuntimeException(className + \" must have already been loaded\");\n+    }\n+}\n+\n+\n+class Unlinked {\n+    static String doit() {\n+        UnlinkedSuper sup = new UnlinkedSub();\n+        return sup.doit();\n+    }\n+}\n+\n+abstract class UnlinkedSuper {\n+    abstract String doit();\n+}\n+\n+class UnlinkedSub extends UnlinkedSuper {\n+    String doit() {\n+        return \"heyhey\";\n+    }\n+}\n+\n+class Foo {}\n+class NotFoo {}\n+\n+class Vehicle {}\n+class Car extends Vehicle {}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/AOTClassLinkingVerification.java","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -25,2 +25,2 @@\n-super public class BadOldClassB\n-    version 49:0\n+super public class BadNewClass\n+    version 52:0\n@@ -29,1 +29,0 @@\n-\n@@ -53,1 +52,1 @@\n-} \/\/ end Class BadOldClassB\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadNewClass.jasm","additions":3,"deletions":4,"binary":false,"changes":7,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadOldClassB.jasm","status":"copied"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class BadNewClass2\n+    version 52:0\n+{\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+    \/*\n+     * The following method tries to return a NotFoo as a Foo.\n+     * Verifier should fail.\n+     *\/\n+public Method doit:\"()LFoo;\"\n+    stack 2 locals 1\n+{\n+        new              class NotFoo;\n+        dup;\n+        invokespecial    Method NotFoo.\"<init>\":\"()V\";\n+        astore_0;\n+        aload_0;\n+        areturn;   \/\/ tries to return a NotFoo as a Foo\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadNewClass2.jasm","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class BadNewClass3\n+    version 52:0\n+{\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+    \/*\n+     * The following method tries to return a String[][] as an Integer[].\n+     * Verifier should fail.\n+     *\n+     * Note: the arrays must have different number of dimensions, or else\n+     * the new verifier will just check the \"bottom\" classes. I.e., String and Integer\n+     *\/\n+public Method doit:\"()[Ljava\/lang\/Integer;\"\n+    stack 2 locals 1\n+{\n+        iconst_1;\n+        iconst_1;\n+        multianewarray class \"[[Ljava\/lang\/String;\", 2;\n+        areturn;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadNewClass3.jasm","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class BadNewClass4\n+    version 52:0\n+{\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+    \/*\n+     * The following method tries to return a String[][] as an Integer[][].\n+     * Verifier should fail.\n+     *\n+     * Note: the new verifier looks up the Integer and String types,\n+     * not the array types.\n+     *\/\n+public Method doit:\"()[[Ljava\/lang\/Integer;\"\n+    stack 2 locals 1\n+{\n+        iconst_1;\n+        iconst_1;\n+        multianewarray class \"[[Ljava\/lang\/String;\", 2;\n+        areturn;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadNewClass4.jasm","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n-super public class BadOldClassB\n+super public class BadOldClass\n@@ -29,1 +29,0 @@\n-\n@@ -53,1 +52,1 @@\n-} \/\/ end Class BadOldClassB\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadOldClass.jasm","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadOldClassB.jasm","status":"copied"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class BadOldClass2\n+    version 49:0\n+{\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+    \/*\n+     * The following method tries to return a NotFoo as a Foo.\n+     * Verifier should fail.\n+     *\/\n+public Method doit:\"()LFoo;\"\n+    stack 2 locals 1\n+{\n+        new              class NotFoo;\n+        dup;\n+        invokespecial    Method NotFoo.\"<init>\":\"()V\";\n+        astore_0;\n+        aload_0;\n+        areturn;   \/\/ tries to return a NotFoo as a Foo\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadOldClass2.jasm","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class BadOldClass3\n+    version 49:0\n+{\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+    \/*\n+     * The following method tries to return a String[][] as an Integer[].\n+     * Verifier should fail.\n+     *\n+     * Note: the arrays have different number of dimensions. The old verifier\n+     * rejects this immediately without looking up the String\/Integer types.\n+     *\/\n+public Method doit:\"()[Ljava\/lang\/Integer;\"\n+    stack 2 locals 1\n+{\n+        iconst_1;\n+        iconst_1;\n+        multianewarray class \"[[Ljava\/lang\/String;\", 2;\n+        areturn;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadOldClass3.jasm","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class BadOldClass4\n+    version 49:0\n+{\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+    \/*\n+     * The following method tries to return a String[][] as an Integer[][].\n+     * Verifier should fail.\n+     *\n+     * Note: the old verifier looks up the Integer and String types,\n+     * not the array types.\n+     *\/\n+public Method doit:\"()[[Ljava\/lang\/Integer;\"\n+    stack 2 locals 1\n+{\n+        iconst_1;\n+        iconst_1;\n+        multianewarray class \"[[Ljava\/lang\/String;\", 2;\n+        areturn;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadOldClass4.jasm","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -150,1 +150,1 @@\n-                out.shouldContain(\"Skipping BadOldClassA: Unlinked class not supported by AOTConfiguration\");\n+                out.shouldContain(\"Skipping BadOldClassA: Failed verification\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class GoodOldClass\n+    version 49:0\n+{\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+\n+public static Method doit:\"()LVehicle;\"\n+    stack 2 locals 1\n+{\n+        new              class Car;\n+        dup;\n+        invokespecial    Method Car.\"<init>\":\"()V\";\n+        astore_0;\n+        aload_0;\n+        areturn;   \/\/ tries to return a Car as a Vehicle\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/GoodOldClass.jasm","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"}]}