{"files":[{"patch":"@@ -934,1 +934,1 @@\n-      if (!ik->can_be_verified_at_dumptime()) {\n+      if (CDSConfig::is_old_class_for_verifier(ik)) {\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+bool CDSConfig::_is_at_cds_safepoint = false;\n@@ -913,0 +914,29 @@\n+bool CDSConfig::is_preserving_verification_dependencies() {\n+  \/\/ Verification dependencies are classes used in assignability checks by the\n+  \/\/ bytecode verifier. In the following example, the verification dependencies\n+  \/\/ for X are A and B.\n+  \/\/\n+  \/\/     class X {\n+  \/\/        A getA() { return new B(); }\n+  \/\/     }\n+  \/\/\n+  \/\/ With the AOT cache, we can ensure that all the verification dependencies\n+  \/\/ (A and B in the above example) are unconditionally loaded during the bootstrap\n+  \/\/ of the production run. This means that if a class was successfully verified\n+  \/\/ in the assembly phase, all of the verifier's assignability checks will remain\n+  \/\/ valid in the production run, so we don't need to verify aot-lined classes again.\n+\n+  if (is_dumping_preimage_static_archive()) { \/\/ writing AOT config\n+    return AOTClassLinking;\n+  } else if (is_dumping_final_static_archive()) { \/\/ writing AOT cache\n+    return is_dumping_aot_linked_classes();\n+  } else {\n+    \/\/ For simplicity, we don't support this optimization with the old CDS workflow.\n+    return false;\n+  }\n+}\n+\n+bool CDSConfig::is_old_class_for_verifier(const InstanceKlass* ik) {\n+  return ik->major_version() < 50 \/*JAVA_6_VERSION*\/;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+class InstanceKlass;\n@@ -46,0 +47,1 @@\n+  static bool _is_at_cds_safepoint;\n@@ -102,0 +104,3 @@\n+  static bool is_at_cds_safepoint()                          { return CDS_ONLY(_is_at_cds_safepoint) NOT_CDS(false); }\n+  static void set_is_at_cds_safepoint(bool value)            { CDS_ONLY(_is_at_cds_safepoint = value); }\n+\n@@ -164,0 +169,4 @@\n+  \/\/ Bytecode verification\n+  static bool is_preserving_verification_dependencies();\n+  static bool is_old_class_for_verifier(const InstanceKlass* ik);\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+  if (_old_verifier_dependencies != nullptr) {\n+    delete _old_verifier_dependencies;\n+  }\n@@ -46,0 +49,1 @@\n+                                     num_old_verifier_dependencies(),\n@@ -50,1 +54,1 @@\n-void DumpTimeClassInfo::add_verification_constraint(InstanceKlass* k, Symbol* name,\n+void DumpTimeClassInfo::add_verification_constraint(Symbol* name,\n@@ -76,3 +80,3 @@\n-    log_trace(aot, verification)(\"add_verification_constraint: %s: %s must be subclass of %s [0x%x] array len %d flags len %d\",\n-                                 k->external_name(), from_name->as_klass_external_name(),\n-                                 name->as_klass_external_name(), c, vc_array->length(), vcflags_array->length());\n+    log_trace(aot, verification)(\"add_verification_constraint: %s: %s must be subclass of %s [0x%x]\",\n+                                 _klass->external_name(), from_name->as_klass_external_name(),\n+                                 name->as_klass_external_name(), c);\n@@ -82,0 +86,14 @@\n+void DumpTimeClassInfo::add_old_verification_dependency(Symbol* name) {\n+  if (_old_verifier_dependencies == nullptr) {\n+    _old_verifier_dependencies = new (mtClass) GrowableArray<Symbol*>(4, mtClass);\n+  }\n+  _old_verifier_dependencies->append(name);\n+\n+  if (log_is_enabled(Trace, aot, verification)) {\n+    ResourceMark rm;\n+    log_trace(aot, verification)(\"add old verification dependency: %s: %s must be also be archived\",\n+                                 _klass->external_name(), name->as_klass_external_name());\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+  GrowableArray<Symbol*>*              _old_verifier_dependencies;\n@@ -149,0 +150,1 @@\n+    _old_verifier_dependencies = nullptr;\n@@ -155,1 +157,1 @@\n-  void add_verification_constraint(InstanceKlass* k, Symbol* name,\n+  void add_verification_constraint(Symbol* name,\n@@ -157,0 +159,1 @@\n+  void add_old_verification_dependency(Symbol* name);\n@@ -178,0 +181,16 @@\n+  Symbol* verifier_constraint_name_at(int i) const {\n+    return _verifier_constraints->at(i).name();\n+  }\n+\n+  Symbol* verifier_constraint_from_name_at(int i) const {\n+    return _verifier_constraints->at(i).from_name();\n+  }\n+\n+  int num_old_verifier_dependencies() const {\n+    return array_length_or_zero(_old_verifier_dependencies);\n+  }\n+\n+  Symbol* old_verifier_dependency_at(int i) const {\n+    return _old_verifier_dependencies->at(i);\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -474,2 +474,2 @@\n-    bool always_exclude = SystemDictionaryShared::check_for_exclusion(caller_ik, nullptr) ||\n-                          SystemDictionaryShared::check_for_exclusion(nest_host, nullptr);\n+    bool always_exclude = SystemDictionaryShared::should_be_excluded(caller_ik) ||\n+                          SystemDictionaryShared::should_be_excluded(nest_host);\n@@ -479,1 +479,1 @@\n-      if (always_exclude || SystemDictionaryShared::check_for_exclusion(ik, nullptr)) {\n+      if (always_exclude || SystemDictionaryShared::should_be_excluded(ik)) {\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -636,0 +636,2 @@\n+  CDSConfig::set_is_at_cds_safepoint(true);\n+\n@@ -701,0 +703,2 @@\n+\n+  CDSConfig::set_is_at_cds_safepoint(false);\n@@ -757,4 +761,1 @@\n-void MetaspaceShared::link_shared_classes(TRAPS) {\n-  AOTClassLinker::initialize();\n-  AOTClassInitializer::init_test_class(CHECK);\n-\n+void MetaspaceShared::link_all_loaded_classes(JavaThread* current) {\n@@ -762,1 +763,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -770,1 +771,1 @@\n-        has_linked |= try_link_class(THREAD, ik);\n+        has_linked |= try_link_class(current, ik);\n@@ -780,0 +781,7 @@\n+}\n+\n+void MetaspaceShared::link_shared_classes(TRAPS) {\n+  AOTClassLinker::initialize();\n+  AOTClassInitializer::init_test_class(CHECK);\n+\n+  link_all_loaded_classes(THREAD);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+  static void link_all_loaded_classes(JavaThread* current);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -77,0 +77,2 @@\n+\n+  regen_klass->set_shared_classpath_index(orig_klass->shared_classpath_index());\n","filename":"src\/hotspot\/share\/cds\/regeneratedClasses.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,8 @@\n+  _num_old_verifier_dependencies = info.num_old_verifier_dependencies();\n+  if (_num_old_verifier_dependencies > 0) {\n+    u4* constraints = old_verifier_dependencies();\n+    for (i = 0; i < _num_old_verifier_dependencies; i++) {\n+      constraints[i] = builder->any_to_offset_u4(info.old_verifier_dependency_at(i));\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  int _num_old_verifier_dependencies;\n@@ -82,0 +83,2 @@\n+  \/\/ The following optional fields are sorted (somewhat) by access frequency.\n+  \/\/\n@@ -87,0 +90,1 @@\n+  \/\/ optional u4                      _old_verifier_dependencies[_num_old_verifier_dependencies]\n@@ -98,0 +102,3 @@\n+  static size_t old_verifier_dependencies_size(int num_old_verifier_dependencies) {\n+    return align_up(sizeof(u4) * num_old_verifier_dependencies, wordSize);\n+  }\n@@ -118,0 +125,1 @@\n+  int num_old_verifier_dependencies() const { return _num_old_verifier_dependencies; }\n@@ -119,2 +127,2 @@\n-  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints,\n-                          int num_enum_klass_static_fields) {\n+  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_old_verifier_dependencies,\n+                          int num_loader_constraints, int num_enum_klass_static_fields) {\n@@ -127,0 +135,1 @@\n+           old_verifier_dependencies_size(num_old_verifier_dependencies) +\n@@ -148,1 +157,1 @@\n-  size_t enum_klass_static_fields_offset() const {\n+  size_t old_verifier_dependencies_offset() const {\n@@ -151,0 +160,3 @@\n+  size_t enum_klass_static_fields_offset() const {\n+    return old_verifier_dependencies_offset() + old_verifier_dependencies_size(_num_old_verifier_dependencies);\n+  }\n@@ -155,1 +167,3 @@\n-\n+  void check_old_verifier_constraint_offset(int i) const {\n+    assert(0 <= i && i < _num_old_verifier_dependencies, \"sanity\");\n+  }\n@@ -178,0 +192,4 @@\n+  Symbol* old_verifier_constraint_at(int i) {\n+    check_old_verifier_constraint_offset(i);\n+    return ArchiveUtils::offset_to_archived_address<Symbol*>(old_verifier_dependencies()[i]);\n+  }\n@@ -184,0 +202,5 @@\n+  u4* old_verifier_dependencies() {\n+    assert(_num_old_verifier_dependencies > 0, \"sanity\");\n+    return (u4*)(address(this) + old_verifier_dependencies_offset());\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1195,4 +1195,2 @@\n-    if (loader == nullptr) {\n-      \/\/ JFR classes\n-      ik->set_shared_classpath_index(0);\n-    }\n+    \/\/ JFR classes, or other classes defined with JNI DefineClass()\n+    ik->set_shared_classpath_index(-1);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -206,5 +206,6 @@\n-bool SystemDictionaryShared::check_for_exclusion(InstanceKlass* k, DumpTimeClassInfo* info) {\n-  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_in_shared_metaspace(k)) {\n-    \/\/ We have reached a super type that's already in the base archive. Treat it\n-    \/\/ as \"not excluded\".\n-    return false;\n+bool SystemDictionaryShared::should_be_excluded_impl(InstanceKlass* k, DumpTimeClassInfo* info) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+\n+  if (!info->has_checked_exclusion()) {\n+    check_exclusion_for_self_and_dependencies(k);\n+    assert(info->has_checked_exclusion(), \"must be\");\n@@ -213,3 +214,16 @@\n-  if (info == nullptr) {\n-    info = _dumptime_table->get(k);\n-    assert(info != nullptr, \"supertypes of any classes in _dumptime_table must either be shared, or must also be in _dumptime_table\");\n+  return info->is_excluded();\n+}\n+\n+\/\/ <func> returns bool and takes a single parameter of Symbol*\n+\/\/ - If <func> returns true for any name, this method terminates immediately.\n+\/\/ - If <func> never returns true, we will iterate over all the names.\n+template<typename Function>\n+void SystemDictionaryShared::iterate_all_verification_dependency_names(InstanceKlass* k, DumpTimeClassInfo* info, Function func) {\n+  int n = info->num_verifier_constraints();\n+  for (int i = 0; i < n; i++) {\n+    if (func(info->verifier_constraint_name_at(i))) {\n+      return;\n+    }\n+    if (func(info->verifier_constraint_from_name_at(i))) {\n+      return;\n+    }\n@@ -218,3 +232,4 @@\n-  if (!info->has_checked_exclusion()) {\n-    if (check_for_exclusion_impl(k)) {\n-      info->set_excluded();\n+  n = info->num_old_verifier_dependencies();\n+  for (int i = 0; i < n; i++) {\n+    if (func(info->old_verifier_dependency_at(i))) {\n+      return;\n@@ -222,1 +237,0 @@\n-    info->set_has_checked_exclusion();\n@@ -224,0 +238,1 @@\n+}\n@@ -225,1 +240,116 @@\n-  return info->is_excluded();\n+\/\/ This is a table of classes that need to be check for exclusion.\n+class SystemDictionaryShared::ExclusionCheckCandidates\n+  : public ResourceHashtable<InstanceKlass*, DumpTimeClassInfo*, 15889> {\n+  void add_candidate(InstanceKlass* k) {\n+    if (contains(k)) {\n+      return;\n+    }\n+    if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_in_shared_metaspace(k)) {\n+      return;\n+    }\n+\n+    DumpTimeClassInfo* info = SystemDictionaryShared::get_info_locked(k);\n+    if (info->has_checked_exclusion()) {\n+      \/\/ We have check exclusion of k and all of its dependencies, so there's no need to check again.\n+      return;\n+    }\n+\n+    put(k, info);\n+\n+    if (!k->is_loaded()) {\n+      \/\/ super types are not yet initialized for k.\n+      return;\n+    }\n+\n+    InstanceKlass* super = k->java_super();\n+    if (super != nullptr) {\n+      add_candidate(super);\n+    }\n+\n+    Array<InstanceKlass*>* interfaces = k->local_interfaces();\n+    int len = interfaces->length();\n+    for (int i = 0; i < len; i++) {\n+      add_candidate(interfaces->at(i));\n+    }\n+\n+    InstanceKlass* nest_host = k->nest_host_or_null();\n+    if (nest_host != nullptr && nest_host != k) {\n+      add_candidate(nest_host);\n+    }\n+\n+    if (CDSConfig::is_preserving_verification_dependencies()) {\n+      SystemDictionaryShared::iterate_all_verification_dependency_names(k, info, [&] (Symbol* dependency_class_name) {\n+        Klass* dependency_bottom_class = find_verification_dependency_bottom_class(k, dependency_class_name);\n+        if (dependency_bottom_class != nullptr && dependency_bottom_class->is_instance_klass()) {\n+          add_candidate(InstanceKlass::cast(dependency_bottom_class));\n+        }\n+        return false; \/\/ Keep iterating.\n+      });\n+    }\n+  }\n+\n+public:\n+  ExclusionCheckCandidates(InstanceKlass* k) {\n+    add_candidate(k);\n+  }\n+};\n+\n+\/\/ A class X is excluded if check_self_exclusion() returns true for X or any of\n+\/\/ X's \"exclusion dependency\" classes, which include:\n+\/\/     - ik's super types\n+\/\/     - ik's nest host (if any)\n+\/\/\n+\/\/  plus, if CDSConfig::is_preserving_verification_dependencies()==true:\n+\/\/     - ik's verification dependencies. These are the classes used in assignability checks\n+\/\/         when verifying ik's bytecodes.\n+\/\/\n+\/\/ This method ensure that exclusion check is performed on X and all of its exclusion dependencies.\n+void SystemDictionaryShared::check_exclusion_for_self_and_dependencies(InstanceKlass *ik) {\n+  assert_lock_strong(DumpTimeTable_lock);\n+  ResourceMark rm;\n+\n+  \/\/ This will recursive find ik and all of its exclusion dependencies that have not yet been checked.\n+  ExclusionCheckCandidates candidates(ik);\n+\n+  \/\/ (1) Check each class to see if it should be excluded due to its own problems\n+  candidates.iterate_all([&] (InstanceKlass* k, DumpTimeClassInfo* info) {\n+    if (check_self_exclusion(k)) {\n+      info->set_excluded();\n+    }\n+  });\n+\n+  \/\/ (2) Check each class to see if it should be excluded because of problems in a depeendency class\n+  while (true) {\n+    bool found_new_exclusion = false;\n+\n+    candidates.iterate_all([&] (InstanceKlass* k, DumpTimeClassInfo* info) {\n+      if (!info->is_excluded() && check_dependencies_exclusion(k, info)) {\n+        info->set_excluded();\n+        found_new_exclusion = true;\n+      }\n+    });\n+\n+    \/\/ Algorithm notes:\n+    \/\/\n+    \/\/ The dependencies is a directed graph, possibly cyclic. Class X is excluded\n+    \/\/ if it has at least one directed path that reaches class Y, where\n+    \/\/ check_self_exclusion(Y) returns true.\n+    \/\/\n+    \/\/ Because of the possibility of cycles in the graph, we cannot use simple\n+    \/\/ recursion. Otherwise we will either never terminate, or will miss some paths.\n+    \/\/\n+    \/\/ Hence, we keep doing a linear scan of the candidate until we stop finding\n+    \/\/ new exclusions.\n+    \/\/\n+    \/\/ In the worst case, we find one exclusion per iteration of the while loop,\n+    \/\/ so the while loop gets executed O(N^2) times. However, in reality we have\n+    \/\/ very few exclusions, so in most cases the while loop executes only once, and we\n+    \/\/ walk each edge in the dependencies graph exactly once.\n+    if (!found_new_exclusion) {\n+      break;\n+    }\n+  }\n+  candidates.iterate_all([&] (InstanceKlass* k, DumpTimeClassInfo* info) {\n+    \/\/ All candidates have been fully checked, so we don't need to check them again.\n+    info->set_has_checked_exclusion();\n+  });\n@@ -250,1 +380,2 @@\n-bool SystemDictionaryShared::check_for_exclusion_impl(InstanceKlass* k) {\n+bool SystemDictionaryShared::check_self_exclusion(InstanceKlass* k) {\n+  assert_lock_strong(DumpTimeTable_lock);\n@@ -303,3 +434,2 @@\n-      \/\/ However, we do not speculatively link old classes, as they are not recorded by\n-      \/\/ SystemDictionaryShared::record_linking_constraint(). As a result, such an unlinked\n-      \/\/ class may fail to verify in AOTLinkedClassBulkLoader::init_required_classes_for_loader(),\n+      \/\/ Old classes may not be linked if CDSConfig::is_preserving_verification_dependencies()==false.\n+      \/\/ An unlinked class may fail to verify in AOTLinkedClassBulkLoader::init_required_classes_for_loader(),\n@@ -331,0 +461,5 @@\n+  return false;\n+}\n+\n+\/\/ Returns true if the DumpTimeClassInfo::is_excluded() is true for at least one of k's exclusion dependencies.\n+bool SystemDictionaryShared::check_dependencies_exclusion(InstanceKlass* k, DumpTimeClassInfo* info) {\n@@ -332,3 +467,1 @@\n-  if (super != nullptr && check_for_exclusion(super, nullptr)) {\n-    ResourceMark rm;\n-    aot_log_warning(aot)(\"Skipping %s: super class %s is excluded\", k->name()->as_C_string(), super->name()->as_C_string());\n+  if (super != nullptr && is_dependency_excluded(k, super, \"super\")) {\n@@ -342,3 +475,1 @@\n-    if (check_for_exclusion(intf, nullptr)) {\n-      ResourceMark rm;\n-      aot_log_warning(aot)(\"Skipping %s: interface %s is excluded\", k->name()->as_C_string(), intf->name()->as_C_string());\n+    if (is_dependency_excluded(k, intf, \"interface\")) {\n@@ -350,1 +481,33 @@\n-  if (nest_host != nullptr && nest_host != k && check_for_exclusion(nest_host, nullptr)) {\n+  if (nest_host != nullptr && nest_host != k && is_dependency_excluded(k, nest_host, \"nest host class\")) {\n+    return true;\n+  }\n+\n+  if (CDSConfig::is_preserving_verification_dependencies()) {\n+    bool excluded = false;\n+\n+    iterate_all_verification_dependency_names(k, info, [&] (Symbol* dependency_class_name) {\n+      if (check_verification_dependency_exclusion(k, dependency_class_name)) {\n+        \/\/ If one of the verification dependency class has been excluded, the assignability checks\n+        \/\/ by the verifier may no longer be valid in the production run. For safety, exclude this class.\n+        excluded = true;\n+        return true; \/\/ terminate iteration; k will be excluded\n+      } else {\n+        return false; \/\/ keep iterating\n+      }\n+    });\n+\n+    if (excluded) {\n+      \/\/ At least one verification dependency class has been excluded\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+bool SystemDictionaryShared::is_dependency_excluded(InstanceKlass* k, InstanceKlass* dependency, const char* type) {\n+  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_in_shared_metaspace(dependency)) {\n+    return false;\n+  }\n+  DumpTimeClassInfo* dependency_info = get_info_locked(dependency);\n+  if (dependency_info->is_excluded()) {\n@@ -352,1 +515,1 @@\n-    aot_log_warning(aot)(\"Skipping %s: nest_host class %s is excluded\", k->name()->as_C_string(), nest_host->name()->as_C_string());\n+    aot_log_warning(aot)(\"Skipping %s: %s %s is excluded\", k->name()->as_C_string(), type, dependency->name()->as_C_string());\n@@ -355,0 +518,16 @@\n+  return false;\n+}\n+\n+bool SystemDictionaryShared::check_verification_dependency_exclusion(InstanceKlass* k, Symbol* dependency_class_name) {\n+  Klass* dependency_bottom_class = find_verification_dependency_bottom_class(k, dependency_class_name);\n+  if (dependency_bottom_class == nullptr) {\n+    \/\/ The new verifier was checking if dependency_class_name is assignable to an interface, and found\n+    \/\/ the answer without resolving dependency_class_name.\n+    return false;\n+  } else if (dependency_bottom_class->is_instance_klass()) {\n+    if (is_dependency_excluded(k, InstanceKlass::cast(dependency_bottom_class), \"verification dependency\")) {\n+      return true;\n+    }\n+  } else {\n+    assert(dependency_bottom_class->is_typeArray_klass(), \"must be\");\n+  }\n@@ -356,1 +535,17 @@\n-  return false; \/\/ false == k should NOT be excluded\n+  return false;\n+}\n+\n+Klass* SystemDictionaryShared::find_verification_dependency_bottom_class(InstanceKlass* k, Symbol* dependency_class_name) {\n+  Thread* current = Thread::current();\n+  Handle loader(current, k->class_loader());\n+  Klass* dependency_class = SystemDictionary::find_instance_or_array_klass(current, dependency_class_name, loader);\n+  if (dependency_class == nullptr) {\n+    return nullptr;\n+  }\n+\n+  if (dependency_class->is_objArray_klass()) {\n+    dependency_class = ObjArrayKlass::cast(dependency_class)->bottom_klass();\n+  }\n+\n+  precond(dependency_class->is_typeArray_klass() || dependency_class->is_instance_klass());\n+  return dependency_class;\n@@ -558,1 +753,1 @@\n-  copy_verification_constraints_from_preimage(k);\n+  copy_verification_info_from_preimage(k);\n@@ -653,1 +848,1 @@\n-\/\/ it can be checked by check_for_exclusion().\n+\/\/ it can be checked by should_be_excluded_impl().\n@@ -658,2 +853,4 @@\n-  if (k->is_objArray_klass()) {\n-    return should_be_excluded(ObjArrayKlass::cast(k)->bottom_klass());\n+  if (CDSConfig::is_dumping_dynamic_archive() && MetaspaceShared::is_in_shared_metaspace(k)) {\n+    \/\/ We have reached a super type that's already in the base archive. Treat it\n+    \/\/ as \"not excluded\".\n+    return false;\n@@ -662,1 +859,4 @@\n-  if (!k->is_instance_klass()) {\n+  if (k->is_objArray_klass()) {\n+    return should_be_excluded(ObjArrayKlass::cast(k)->bottom_klass());\n+  } else if (!k->is_instance_klass()) {\n+    assert(k->is_typeArray_klass(), \"must be\");\n@@ -674,1 +874,1 @@\n-        \/\/ check_for_exclusion() below doesn't link unlinked classes. We come\n+        \/\/ should_be_excluded_impl() below doesn't link unlinked classes. We come\n@@ -683,0 +883,4 @@\n+\n+        \/\/ Also link any classes that were loaded for the verification of ik or its supertypes.\n+        \/\/ Otherwise we might miss the verification constraints of those classes.\n+        MetaspaceShared::link_all_loaded_classes(THREAD);\n@@ -690,1 +894,1 @@\n-      return check_for_exclusion(ik, p);\n+      return should_be_excluded_impl(ik, p);\n@@ -699,1 +903,1 @@\n-      return check_for_exclusion(ik, p);\n+      return should_be_excluded_impl(ik, p);\n@@ -705,0 +909,1 @@\n+  assert_at_safepoint();\n@@ -715,1 +920,1 @@\n-    SystemDictionaryShared::check_for_exclusion(k, &info);\n+    SystemDictionaryShared::should_be_excluded_impl(k, &info);\n@@ -795,1 +1000,1 @@\n-  info->add_verification_constraint(k, name, from_name, from_field_is_protected,\n+  info->add_verification_constraint(name, from_name, from_field_is_protected,\n@@ -820,0 +1025,20 @@\n+\/\/ When the old verifier is verifying the class <ik> at dump time, it tries to resolve a\n+\/\/ class with the given <name>. For the verification result to be valid at run time, we must\n+\/\/ ensure that <name> resolves to the exact same Klass as in dump time.\n+void SystemDictionaryShared::add_old_verification_dependency(Thread* current, InstanceKlass* ik, Symbol* name) {\n+  precond(CDSConfig::is_preserving_verification_dependencies());\n+  DumpTimeClassInfo* info = get_info(ik);\n+  Handle loader(current, ik->class_loader());\n+  Klass* k = SystemDictionary::find_instance_or_array_klass(current, name, loader);\n+  if (k != nullptr) {\n+    if (k->is_objArray_klass()) {\n+      k = ObjArrayKlass::cast(k)->bottom_klass();\n+    }\n+    \/\/ No need to record any supertypes, as ik cannot be loaded at run time unless the\n+    \/\/ exact same set of super types are loaded.\n+    if (k->is_instance_klass() && !ik->is_subclass_of(k)) {\n+      info->add_old_verification_dependency(k->name());\n+    }\n+  }\n+}\n+\n@@ -862,1 +1087,1 @@\n-void SystemDictionaryShared::copy_verification_constraints_from_preimage(InstanceKlass* klass) {\n+void SystemDictionaryShared::copy_verification_info_from_preimage(InstanceKlass* klass) {\n@@ -874,1 +1099,1 @@\n-      dt_info->add_verification_constraint(klass, name, from_name,\n+      dt_info->add_verification_constraint(name, from_name,\n@@ -878,0 +1103,8 @@\n+\n+  length = rt_info->num_old_verifier_dependencies();\n+  if (length > 0) {\n+    for (int i = 0; i < length; i++) {\n+      Symbol* name = rt_info->old_verifier_constraint_at(i);\n+      dt_info->add_old_verification_dependency(name);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":271,"deletions":38,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-\n+  class ExclusionCheckCandidates;\n@@ -176,1 +176,11 @@\n-  static bool check_for_exclusion_impl(InstanceKlass* k);\n+  static bool should_be_excluded_impl(InstanceKlass* k, DumpTimeClassInfo* info);\n+\n+  \/\/ exclusion checks\n+  static void check_exclusion_for_self_and_dependencies(InstanceKlass *k);\n+  static bool check_self_exclusion(InstanceKlass* k);\n+  static bool check_dependencies_exclusion(InstanceKlass* k, DumpTimeClassInfo* info);\n+  static bool check_verification_dependency_exclusion(InstanceKlass* k, Symbol* dependency_class_name);\n+  static bool is_dependency_excluded(InstanceKlass* k, InstanceKlass* dependency, const char* type);\n+  static bool is_excluded_verification_dependency(InstanceKlass* k, Symbol* dependency_class_name);\n+  static Klass* find_verification_dependency_bottom_class(InstanceKlass* k, Symbol* dependency_class_name);\n+\n@@ -181,1 +191,1 @@\n-  static void copy_verification_constraints_from_preimage(InstanceKlass* klass);\n+  static void copy_verification_info_from_preimage(InstanceKlass* klass);\n@@ -184,0 +194,3 @@\n+  template<typename Function>\n+  static void iterate_all_verification_dependency_names(InstanceKlass* k, DumpTimeClassInfo* info, Function func);\n+\n@@ -240,0 +253,1 @@\n+  static void add_old_verification_dependency(Thread* current, InstanceKlass* k, Symbol* name);\n@@ -259,1 +273,0 @@\n-  static bool check_for_exclusion(InstanceKlass* k, DumpTimeClassInfo* info);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2843,5 +2843,0 @@\n-\/\/ Check if a class or any of its supertypes has a version older than 50.\n-\/\/ CDS will not perform verification of old classes during dump time because\n-\/\/ without changing the old verifier, the verification constraint cannot be\n-\/\/ retrieved during dump time.\n-\/\/ Verification of archived old classes will be performed during run time.\n@@ -2854,1 +2849,8 @@\n-  if (major_version() < 50 \/*JAVA_6_VERSION*\/) {\n+\n+  if (CDSConfig::is_preserving_verification_dependencies()) {\n+    return true;\n+  }\n+\n+  if (CDSConfig::is_old_class_for_verifier(this)) {\n+    \/\/ The old verifier does not save verification constraints, so at run time\n+    \/\/ SystemDictionaryShared::check_verification_constraints() will not work for this class.\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -326,3 +326,2 @@\n-  if (SafepointSynchronize::is_at_safepoint() &&\n-      CDSConfig::is_dumping_archive() &&\n-      CDSConfig::current_thread_is_vm_or_dumper()) {\n+  if (CDSConfig::is_at_cds_safepoint()) {\n+    \/\/ Check for CDS exclusion only at CDS safe point.\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -546,1 +546,5 @@\n-    bool is_excluded = !holder()->is_loaded() || SystemDictionaryShared::check_for_exclusion(holder(), nullptr);\n+    bool is_excluded = !holder()->is_loaded();\n+    if (CDSConfig::is_at_cds_safepoint()) {\n+      \/\/ Check for CDS exclusion only at CDS safe point.\n+      is_excluded |= SystemDictionaryShared::should_be_excluded(holder());\n+    }\n@@ -565,1 +569,2 @@\n-    if (SystemDictionaryShared::check_for_exclusion(holder()->method_holder(), nullptr)) {\n+    if (CDSConfig::is_at_cds_safepoint() && SystemDictionaryShared::should_be_excluded(holder()->method_holder())) {\n+      \/\/ Check for CDS exclusion only at CDS safe point.\n","filename":"src\/hotspot\/share\/oops\/trainingData.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -853,0 +853,7 @@\n+#if INCLUDE_CDS\n+  if (CDSConfig::is_preserving_verification_dependencies() && from_class->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(from_class);\n+    SystemDictionaryShared::add_old_verification_dependency(THREAD, ik, h_name);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-  MUTEX_DEFN(DumpRegion_lock                 , PaddedMutex  , nosafepoint);\n+  MUTEX_DEFL(DumpRegion_lock                 , PaddedMutex  , DumpTimeTable_lock);\n@@ -313,1 +313,1 @@\n-  MUTEX_DEFN(ScratchObjects_lock             , PaddedMutex  , nosafepoint-1); \/\/ Holds DumpTimeTable_lock\n+  MUTEX_DEFL(ScratchObjects_lock             , PaddedMutex  , DumpTimeTable_lock);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -529,0 +529,1 @@\n+ -runtime\/cds\/appcds\/LambdaContainsOldInf.java \\\n@@ -536,1 +537,1 @@\n- -runtime\/cds\/appcds\/dynamicArchive\/ModulePath.java \\\n+ -runtime\/cds\/appcds\/dynamicArchive\/LambdaContainsOldInf.java \\\n@@ -541,0 +542,2 @@\n+ -runtime\/cds\/appcds\/dynamicArchive\/ModulePath.java \\\n+ -runtime\/cds\/appcds\/dynamicArchive\/NestHostOldInf.java \\\n@@ -544,0 +547,1 @@\n+ -runtime\/cds\/appcds\/dynamicArchive\/RedefineCallerClassTest.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-                out.shouldContain(\"check_verification_constraint: TestApp$Foo$Taz: TestApp$Foo$ShouldBeExcludedChild must be subclass of TestApp$Foo$ShouldBeExcluded\");\n@@ -262,8 +261,3 @@\n-                \/\/ When verifying this method, we need to check the constraint that\n-                \/\/ ShouldBeExcluded must be a supertype of ShouldBeExcludedChild. This information\n-                \/\/ is checked by SystemDictionaryShared::check_verification_constraints() when the Taz\n-                \/\/ class is linked during the production run.\n-                \/\/\n-                \/\/ Because ShouldBeExcluded is excluded from the AOT archive, it must be loaded\n-                \/\/ dynamically from app.jar inside SystemDictionaryShared::check_verification_constraints().\n-                \/\/ This must happen after the app class loader has been fully restored from the AOT cache.\n+                \/\/ Taz should be excluded from the AOT cache because it has a verification constraint that\n+                \/\/ \"ShouldBeExcludedChild must be a subtype of ShouldBeExcluded\", but ShouldBeExcluded is\n+                \/\/ excluded from the AOT cache.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/ExcludedClasses.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class OldA\n+    version 49:0\n+{\n+\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/OldA.jasm","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Store old classes linked state in AOT cache as long as their verification constraints are not excluded.\n+ * @bug 8317269\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build OldClass OldA OldClassWithVerifierConstraints OldClassWithExcludedVerifierConstraints\n+ * @build OldClassSupport\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 AppUsesOldClass MyIntf OldClass OldA NewB MyEvent MyEvent2\n+ *                 OldClassWithVerifierConstraints\n+ *                 OldClassWithExcludedVerifierConstraints\n+ *                 NewClassWithExcludedVerifierConstraints\n+ * @run driver OldClassSupport\n+ *\/\n+\n+import jdk.jfr.Event;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class OldClassSupport {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = \"AppUsesOldClass\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester tester = new Tester();\n+        tester.run(new String[] {\"AOT\", \"--two-step-training\"} );\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            return new String[] {\n+                \"-Xlog:aot+class=debug\",\n+                \"-Xlog:aot+resolve=trace\",\n+            };\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\"-Xlog:cds+class=debug\", mainClass};\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) {\n+            Class[] included = {\n+                OldClass.class,\n+                OldA.class,\n+                NewB.class,\n+                OldClassWithVerifierConstraints.class,\n+            };\n+\n+            Class[] excluded = {\n+                OldClassWithExcludedVerifierConstraints.class,\n+                NewClassWithExcludedVerifierConstraints.class,\n+            };\n+\n+\n+            if (runMode == RunMode.TRAINING) {\n+                shouldInclude(out, false, included);\n+                shouldNotInclude(out, excluded);\n+                shouldSkip(out, excluded);\n+            } else if (runMode == RunMode.ASSEMBLY) {\n+                shouldInclude(out, true, included);\n+                shouldNotInclude(out, excluded);\n+            }\n+        }\n+    }\n+\n+    static void shouldInclude(OutputAnalyzer out, boolean linked, Class[] classes) {\n+        for (Class c : classes) {\n+            out.shouldMatch(\"aot,class.* = 0x.* app *\" + c.getName() + (linked ? \" .*aot-linked\" : \"\"));\n+        }\n+    }\n+\n+    static void shouldNotInclude(OutputAnalyzer out, Class[] classes) {\n+        for (Class c : classes) {\n+            out.shouldNotMatch(\"aot,class.* = 0x.* app *\" + c.getName());\n+        }\n+    }\n+\n+    static void shouldSkip(OutputAnalyzer out, Class[] classes) {\n+        for (Class c : classes) {\n+            out.shouldMatch(\"Skipping \" + c.getName() + \": verification dependency .* is excluded\");\n+        }\n+    }\n+}\n+\n+class AppUsesOldClass {\n+    public static void main(String args[]) {\n+        System.out.println(\"Old Class Instance: \" + new OldClass());\n+\n+        System.out.println(get_OldA_from_NewB());\n+        System.out.println(OldClassWithVerifierConstraints.get_OldA_from_NewB());\n+        System.out.println(OldClassWithExcludedVerifierConstraints.get_Event_from_MyEvent());\n+        System.out.println(NewClassWithExcludedVerifierConstraints.get_MyEvent_from_MyEvent2());\n+        System.out.println(new MyEvent());\n+\n+        \/\/ OldClassWithExcludedVerifierConstraints should still be excluded even it has been used\n+        \/\/ in a lambda expression during the training run.\n+        run((OldClassWithExcludedVerifierConstraints x) -> {\n+                System.out.println(x);\n+            });\n+    }\n+\n+    static OldA get_OldA_from_NewB() {\n+        return new NewB();\n+    }\n+\n+    static void run(MyIntf intf) {\n+        intf.function(new OldClassWithExcludedVerifierConstraints());\n+    }\n+}\n+\n+interface MyIntf {\n+    public void function(OldClassWithExcludedVerifierConstraints x);\n+}\n+\n+class NewB extends OldA {}\n+\n+class MyEvent extends Event {}\n+class MyEvent2 extends MyEvent {}\n+\n+class NewClassWithExcludedVerifierConstraints {\n+    static MyEvent get_MyEvent_from_MyEvent2() {\n+        return new MyEvent2();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/OldClassSupport.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This old class has a verification constraint that \"MyEvent must be a subtype of Event\". However,\n+\/\/ Event and all of its subtypes are excluded from the AOT cache, so this class must also be excluded.\n+\n+super public class OldClassWithExcludedVerifierConstraints\n+    version 49:0\n+{\n+\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+static Method get_Event_from_MyEvent:\"()Ljdk\/jfr\/Event;\"\n+    stack 2 locals 0\n+{\n+        new              class MyEvent;\n+        dup;\n+        invokespecial    Method MyEvent.\"<init>\":\"()V\";\n+        areturn;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/OldClassWithExcludedVerifierConstraints.jasm","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ This old class as a verification constraint that \"NewB must be a subtype of OldA\". Since both\n+\/\/ OldA and NewB are not excluded, then this class should be cached in aot-linked state.\n+\n+super public class OldClassWithVerifierConstraints\n+    version 49:0\n+{\n+\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+static Method get_OldA_from_NewB:\"()LOldA;\"\n+    stack 2 locals 0\n+{\n+        new              class NewB;\n+        dup;\n+        invokespecial    Method NewB.\"<init>\":\"()V\";\n+        areturn;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCache\/OldClassWithVerifierConstraints.jasm","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8317269\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @summary Test for verification of classes that are aot-linked\n+ * @library \/test\/jdk\/lib\/testlibrary\n+ *          \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build GoodOldClass BadOldClass BadOldClass2 BadNewClass BadNewClass2\n+ * @build AOTClassLinkingVerification\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app1.jar\n+ *                 AOTClassLinkingVerificationApp\n+ *                 Unlinked UnlinkedSuper\n+ *                 BadOldClass\n+ *                 BadOldClass2\n+ *                 BadNewClass\n+ *                 BadNewClass2\n+ *                 GoodOldClass Vehicle Car\n+ *                 Util\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app2.jar\n+ *                 Foo NotFoo\n+ *                 UnlinkedSub\n+ * @run driver AOTClassLinkingVerification\n+ *\/\n+\n+import java.io.File;\n+import java.lang.invoke.MethodHandles;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class AOTClassLinkingVerification {\n+    static final String app1Jar = ClassFileInstaller.getJarPath(\"app1.jar\");\n+    static final String app2Jar = ClassFileInstaller.getJarPath(\"app2.jar\");\n+    static final String wbJar = TestCommon.getTestJar(\"WhiteBox.jar\");\n+    static final String bootAppendWhiteBox = \"-Xbootclasspath\/a:\" + wbJar;\n+    static final String mainClass = AOTClassLinkingVerificationApp.class.getName();\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester(String testName) {\n+            super(testName);\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            if (runMode == RunMode.TRAINING ||\n+                runMode == RunMode.ASSEMBLY) {\n+                return new String[] {\n+                    \"-XX:+AOTClassLinking\", \"-Xlog:cds+class=debug\", bootAppendWhiteBox,\n+                };\n+            } else {\n+                return new String[] {\n+                    \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+WhiteBoxAPI\", bootAppendWhiteBox,\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            if (runMode == RunMode.TRAINING ||\n+                runMode == RunMode.ASSEMBLY) {\n+                return app1Jar;\n+            } else {\n+                return app1Jar + File.pathSeparator + app2Jar;\n+            }\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            if (runMode == RunMode.TRAINING ||\n+                runMode == RunMode.ASSEMBLY) {\n+                return new String[] {\n+                    \"AOTClassLinkingVerificationApp\", app1Jar, \"ASSEMBLY\"\n+                };\n+            } else {\n+                return new String[] {\n+                    \"AOTClassLinkingVerificationApp\", app1Jar, \"PRODUCTION\"\n+                };\n+            }\n+        }\n+\n+        @Override\n+        public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {\n+            if (runMode == RunMode.TRAINING ||\n+                runMode == RunMode.ASSEMBLY) {\n+                out.shouldContain(\"Preload Warning: Verification failed for BadNewClass2\");\n+                out.shouldContain(\"Preload Warning: Verification failed for BadNewClass\");\n+                out.shouldContain(\"Preload Warning: Verification failed for BadOldClass2\");\n+                out.shouldContain(\"Preload Warning: Verification failed for BadOldClass\");\n+                out.shouldContain(\"Preload Warning: Verification failed for Unlinked\");\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Dump without app2.jar so:\n+        \/\/  - Unlinked can be resolved, but UnlinkedSuper UnlinkedSub cannot be resolved,\n+        \/\/    so Unlinked cannot be verified at dump time.\n+        \/\/  - BadOldClass2 can be resolved, but Foo and NotFoo cannot be resolved,\n+        \/\/    so BadOldClass2 cannot be verified at dump time.\n+        \/\/  - BadNewClass2 can be resolved, but Foo and NotFoo cannot be resolved,\n+        \/\/    so BadNewClass2 cannot be verified at dump time.\n+        Tester t1 = new Tester(\"verification-aot-linked-classes\");\n+        t1.run(\"AOT\");\n+    }\n+}\n+\n+class AOTClassLinkingVerificationApp {\n+    static WhiteBox wb = WhiteBox.getWhiteBox();\n+    static ClassLoader classLoader = AOTClassLinkingVerificationApp.class.getClassLoader();\n+    static File app1Jar;\n+\n+    public static void main(String[] args) throws Exception {\n+        app1Jar = new File(args[0]);\n+        boolean isProduction = args[1].equals(\"PRODUCTION\");\n+        if (isProduction) {\n+            assertNotShared(UnlinkedSub.class);\n+            assertShared(UnlinkedSuper.class);\n+            assertNotShared(Unlinked.class); \/\/ failed verification during dump time\n+            assertNotShared(Foo.class);\n+            assertNotShared(NotFoo.class);\n+        }\n+        String s = null;\n+        try {\n+            s = Unlinked.doit();\n+        } catch (NoClassDefFoundError ncdfe) {\n+            \/\/ UnlinkedSub is in app2Jar but only app1Jar is used during training\n+            \/\/ and assembly phases. So NoClassDefFoundError is expected during\n+            \/\/ during training and assembly phases.\n+            if (isProduction) {\n+                throw ncdfe;\n+            }\n+        }\n+        if (isProduction && !s.equals(\"heyhey\")) {\n+            throw new RuntimeException(\"Unlinked.doit() returns wrong result: \" + s);\n+        }\n+\n+        Class cls_BadOldClass = Class.forName(\"BadOldClass\", false, classLoader);\n+        if (isProduction) {\n+            assertNotShared(cls_BadOldClass); \/\/ failed verification during dump time\n+        }\n+        try {\n+            cls_BadOldClass.newInstance();\n+            throw new RuntimeException(\"BadOldClass cannot be verified\");\n+        } catch (VerifyError expected) {}\n+\n+        Class cls_BadOldClass2 = Class.forName(\"BadOldClass2\", false, classLoader);\n+        if (isProduction) {\n+            assertNotShared(cls_BadOldClass2); \/\/ failed verification during dump time\n+        }\n+        try {\n+            cls_BadOldClass2.newInstance();\n+            throw new RuntimeException(\"BadOldClass2 cannot be verified\");\n+        } catch (NoClassDefFoundError ncdfe) {\n+            \/\/ BadOldClass2 loads Foo and NotFoo which is in app2Jar which is used\n+            \/\/ only in production run.\n+            if (isProduction) {\n+                throw ncdfe;\n+            }\n+        } catch (VerifyError expected) {}\n+\n+        Class cls_BadNewClass = Class.forName(\"BadNewClass\", false, classLoader);\n+        if (isProduction) {\n+            assertNotShared(cls_BadNewClass); \/\/ failed verification during dump time\n+        }\n+        try {\n+            cls_BadNewClass.newInstance();\n+            throw new RuntimeException(\"BadNewClass cannot be verified\");\n+        } catch (VerifyError expected) {}\n+\n+        Class cls_BadNewClass2 = Class.forName(\"BadNewClass2\", false, classLoader);\n+        if (isProduction) {\n+            assertNotShared(cls_BadNewClass2); \/\/ failed verification during dump time\n+        }\n+        try {\n+            cls_BadNewClass2.newInstance();\n+            throw new RuntimeException(\"BadNewClass2 cannot be verified\");\n+        } catch (NoClassDefFoundError ncdfe) {\n+            \/\/ BadNewClass2 loads Foo and NotFoo which is in app2Jar which is used\n+            \/\/ only in production run.\n+            if (isProduction) {\n+                throw ncdfe;\n+            }\n+        } catch (VerifyError expected) {}\n+\n+\n+        if (isProduction) {\n+            assertAlreadyLoaded(\"Vehicle\");\n+            assertAlreadyLoaded(\"Car\");\n+            assertAlreadyLoaded(\"GoodOldClass\");\n+\n+            assertShared(GoodOldClass.class);\n+            assertShared(Vehicle.class);\n+            assertShared(Car.class);\n+        }\n+\n+        GoodOldClass.doit(); \/\/ Should not fail\n+    }\n+\n+    static void assertShared(Class c) {\n+        if (!wb.isSharedClass(c)) {\n+            throw new RuntimeException(\"wb.isSharedClass(\" + c.getName() + \") should be true\");\n+        }\n+    }\n+\n+    static void assertNotShared(Class c) {\n+        if (wb.isSharedClass(c)) {\n+            throw new RuntimeException(\"wb.isSharedClass(\" + c.getName() + \") should be false\");\n+        }\n+    }\n+\n+    static void assertAlreadyLoaded(String className) throws Exception {\n+        byte[] data = Util.getClassFileFromJar(app1Jar, className);\n+        try {\n+            MethodHandles.lookup().defineClass(data);\n+        } catch (LinkageError e) {\n+            if (e.getMessage().contains(\"duplicate class definition for \" + className)) {\n+                return;\n+            } else {\n+                throw e;\n+            }\n+        }\n+        throw new RuntimeException(className + \" must have already been loaded\");\n+    }\n+}\n+\n+\n+class Unlinked {\n+    static String doit() {\n+        UnlinkedSuper sup = new UnlinkedSub();\n+        return sup.doit();\n+    }\n+}\n+\n+abstract class UnlinkedSuper {\n+    abstract String doit();\n+}\n+\n+class UnlinkedSub extends UnlinkedSuper {\n+    String doit() {\n+        return \"heyhey\";\n+    }\n+}\n+\n+class Foo {}\n+class NotFoo {}\n+\n+class Vehicle {}\n+class Car extends Vehicle {}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/AOTClassLinkingVerification.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * ORACLE PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+\n+\/\/ When -XX:+PreloadSharedClasses is enabled, this class will be\n+\/\/ archived in the unlinked state. When we try to use this class\n+\/\/ at runtime, a VerifyError should be thrown.\n+\n+super public class BadNewClass\n+    version 49:0\n+{\n+\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+    \/*\n+     * The following method tries to return an Object as a String.\n+     * Verifier should fail.\n+     *\/\n+public Method doit:\"()Ljava\/lang\/String;\"\n+    stack 2 locals 1\n+{\n+        new              class java\/lang\/Object;\n+        dup;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        astore_0;\n+        aload_0;\n+        areturn;   \/\/ tries to return an Object as a String\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadNewClass.jasm","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * ORACLE PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+\n+\/\/ When -XX:+PreloadSharedClasses is enabled, this class will be\n+\/\/ archived in the unlinked state. When we try to use this class\n+\/\/ at runtime, a VerifyError should be thrown.\n+\n+super public class BadNewClass2\n+    version 52:0\n+{\n+\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+    \/*\n+     * The following method tries to return a NotFoo as a Foo.\n+     * Verifier should fail.\n+     *\/\n+public Method doit:\"()LFoo;\"\n+    stack 2 locals 1\n+{\n+        new              class NotFoo;\n+        dup;\n+        invokespecial    Method NotFoo.\"<init>\":\"()V\";\n+        astore_0;\n+        aload_0;\n+        areturn;   \/\/ tries to return a NotFoo as a Foo\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadNewClass2.jasm","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * ORACLE PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+\n+\/\/ When -XX:+PreloadSharedClasses is enabled, this class will be\n+\/\/ archived in the unlinked state. When we try to use this class\n+\/\/ at runtime, a VerifyError should be thrown.\n+\n+super public class BadOldClass\n+    version 49:0\n+{\n+\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+    \/*\n+     * The following method tries to return an Object as a String.\n+     * Verifier should fail.\n+     *\/\n+public Method doit:\"()Ljava\/lang\/String;\"\n+    stack 2 locals 1\n+{\n+        new              class java\/lang\/Object;\n+        dup;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        astore_0;\n+        aload_0;\n+        areturn;   \/\/ tries to return an Object as a String\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadOldClass.jasm","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * ORACLE PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+\n+\/\/ When -XX:+PreloadSharedClasses is enabled, this class will be\n+\/\/ archived in the unlinked state. When we try to use this class\n+\/\/ at runtime, a VerifyError should be thrown.\n+\n+super public class BadOldClass2\n+    version 49:0\n+{\n+\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+    \/*\n+     * The following method tries to return a NotFoo as a Foo.\n+     * Verifier should fail.\n+     *\/\n+public Method doit:\"()LFoo;\"\n+    stack 2 locals 1\n+{\n+        new              class NotFoo;\n+        dup;\n+        invokespecial    Method NotFoo.\"<init>\":\"()V\";\n+        astore_0;\n+        aload_0;\n+        areturn;   \/\/ tries to return a NotFoo as a Foo\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BadOldClass2.jasm","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -150,1 +150,1 @@\n-                out.shouldContain(\"Skipping BadOldClassA: Unlinked class not supported by AOTConfiguration\");\n+                out.shouldContain(\"Skipping BadOldClassA: Failed verification\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * ORACLE PROPRIETARY\/CONFIDENTIAL. Use is subject to license terms.\n+ *\/\n+\n+\/\/ When -XX:+PreloadSharedClasses is enabled, this class will be\n+\/\/ archived in the unlinked state. When we try to use this class\n+\/\/ at runtime, a VerifyError should be thrown.\n+\n+super public class GoodOldClass\n+    version 49:0\n+{\n+\n+\n+public Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+\n+public static Method doit:\"()LVehicle;\"\n+    stack 2 locals 1\n+{\n+        new              class Car;\n+        dup;\n+        invokespecial    Method Car.\"<init>\":\"()V\";\n+        astore_0;\n+        aload_0;\n+        areturn;   \/\/ tries to return a Car as a Vehicle\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/GoodOldClass.jasm","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"}]}