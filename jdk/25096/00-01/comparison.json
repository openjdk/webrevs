{"files":[{"patch":"@@ -293,0 +293,13 @@\n+      \/\/ Currently, the masked versions of the following 8 Float16 operations are disabled.\n+      \/\/ When the support for Float16 vector classes is added in VectorAPI and the masked\n+      \/\/ Float16 IR can be generated, these masked operations will be enabled and relevant\n+      \/\/ backend support added.\n+      case Op_AddVHF:\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_MaxVHF:\n+      case Op_MinVHF:\n+      case Op_SqrtVHF:\n+      case Op_FmaVHF:\n+        return false;\n@@ -696,10 +709,0 @@\n-instruct vaddHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (AddVHF (Binary dst_src1 src2) pg));\n-  format %{ \"vaddHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n-  ins_encode %{\n-    __ sve_fadd($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -946,10 +949,0 @@\n-instruct vsubHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (SubVHF (Binary dst_src1 src2) pg));\n-  format %{ \"vsubHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n-  ins_encode %{\n-    __ sve_fsub($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -1169,10 +1162,0 @@\n-instruct vmulHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MulVHF (Binary dst_src1 src2) pg));\n-  format %{ \"vmulHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n-  ins_encode %{\n-    __ sve_fmul($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -1271,10 +1254,0 @@\n-instruct vdivHF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (DivVHF (Binary dst_src1 src2) pg));\n-  format %{ \"vdivHF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n-  ins_encode %{\n-    __ sve_fdiv($dst_src1$$FloatRegister, __ H, $pg$$PRegister, $src2$$FloatRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2171,10 +2144,0 @@\n-instruct vsqrtHF_masked(vReg dst_src, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src (SqrtVHF dst_src pg));\n-  format %{ \"vsqrtHF_masked $dst_src, $pg, $dst_src\" %}\n-  ins_encode %{\n-    __ sve_fsqrt($dst_src$$FloatRegister, __ H, $pg$$PRegister, $dst_src$$FloatRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2311,11 +2274,0 @@\n-instruct vmin_HF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MinVHF (Binary dst_src1 src2) pg));\n-  format %{ \"vmin_HF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n-  ins_encode %{\n-    __ sve_fmin($dst_src1$$FloatRegister, __ H,\n-                $pg$$PRegister, $src2$$FloatRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2502,11 +2454,0 @@\n-instruct vmax_HF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 (MaxVHF (Binary dst_src1 src2) pg));\n-  format %{ \"vmax_HF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n-  ins_encode %{\n-    __ sve_fmax($dst_src1$$FloatRegister, __ H,\n-                $pg$$PRegister, $src2$$FloatRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -2664,1 +2605,0 @@\n-  match(Set dst_src1 (FmaVHF (Binary dst_src1 src2) (Binary src3 pg)));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":13,"deletions":73,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -283,0 +283,13 @@\n+      \/\/ Currently, the masked versions of the following 8 Float16 operations are disabled.\n+      \/\/ When the support for Float16 vector classes is added in VectorAPI and the masked\n+      \/\/ Float16 IR can be generated, these masked operations will be enabled and relevant\n+      \/\/ backend support added.\n+      case Op_AddVHF:\n+      case Op_SubVHF:\n+      case Op_MulVHF:\n+      case Op_DivVHF:\n+      case Op_MaxVHF:\n+      case Op_MinVHF:\n+      case Op_SqrtVHF:\n+      case Op_FmaVHF:\n+        return false;\n@@ -544,1 +557,0 @@\n-BINARY_OP_PREDICATE(vaddHF, AddVHF, sve_fadd, H)\n@@ -570,1 +582,0 @@\n-BINARY_OP_PREDICATE(vsubHF, SubVHF, sve_fsub, H)\n@@ -648,1 +659,0 @@\n-BINARY_OP_PREDICATE(vmulHF, MulVHF, sve_fmul, H)\n@@ -660,1 +670,0 @@\n-BINARY_OP_PREDICATE(vdivHF, DivVHF, sve_fdiv, H)\n@@ -1052,1 +1061,0 @@\n-UNARY_OP_PREDICATE_WITH_SIZE(vsqrtHF, SqrtVHF, sve_fsqrt, H)\n@@ -1231,14 +1239,0 @@\n-dnl VMINMAX_HF_PREDICATE($1,   $2,      $3     )\n-dnl VMINMAX_HF_PREDICATE(type, op_name, insn_fp)\n-define(`VMINMAX_HF_PREDICATE', `\n-instruct v$1_HF_masked(vReg dst_src1, vReg src2, pRegGov pg) %{\n-  predicate(UseSVE > 0);\n-  match(Set dst_src1 ($2 (Binary dst_src1 src2) pg));\n-  format %{ \"v$1_HF_masked $dst_src1, $pg, $dst_src1, $src2\" %}\n-  ins_encode %{\n-    __ $3($dst_src1$$FloatRegister, __ H,\n-                $pg$$PRegister, $src2$$FloatRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}')dnl\n-dnl\n@@ -1259,1 +1253,0 @@\n-VMINMAX_HF_PREDICATE(min, MinVHF, sve_fmin)\n@@ -1286,1 +1279,0 @@\n-VMINMAX_HF_PREDICATE(max, MaxVHF, sve_fmax)\n@@ -1380,1 +1372,0 @@\n-  match(Set dst_src1 (FmaVHF (Binary dst_src1 src2) (Binary src3 pg)));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":13,"deletions":22,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -585,1 +585,1 @@\n-    \"SqrtVF\", \"SqrtVD\",\n+    \"SqrtVHF\", \"SqrtVF\", \"SqrtVD\",\n","filename":"src\/hotspot\/share\/adlc\/dfa.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}