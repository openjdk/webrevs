{"files":[{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright 2024 IBM Corporation. All rights reserved.\n@@ -3155,0 +3156,295 @@\n+\/\/ scans r_count pointer sized words at [r_addr] for occurrence of r_value,\n+\/\/ generic (r_count must be >0)\n+\/\/ iff found: CC eq, r_result == 0\n+void MacroAssembler::repne_scan(Register r_addr, Register r_value, Register r_count, Register r_result) {\n+  NearLabel L_loop, L_exit;\n+\n+  BLOCK_COMMENT(\"repne_scan {\");\n+#ifdef ASSERT\n+  z_chi(r_count, 0);\n+  asm_assert(bcondHigh, \"count must be positive\", 11);\n+#endif\n+\n+  clear_reg(r_result, true \/* whole_reg *\/, false \/* set_cc *\/);  \/\/ sets r_result=0, let's hope that search will be successful\n+\n+  bind(L_loop);\n+  z_cg(r_value, Address(r_addr));\n+  z_bre(L_exit); \/\/ branch on success\n+  z_la(r_addr, wordSize, r_addr);\n+  z_brct(r_count, L_loop);\n+\n+  \/\/ z_brct above doesn't change CC.\n+  \/\/ If the search operation is unsuccessful, then it's a failure case.\n+  z_lghi(r_result, 1);\n+\n+  bind(L_exit);\n+  BLOCK_COMMENT(\"} repne_scan\");\n+}\n+\n+\/\/ Ensure that the inline code and the stub are using the same registers.\n+#define LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS                 \\\n+do {                                                            \\\n+  assert(r_super_klass  == Z_ARG1                            && \\\n+         r_array_base   == Z_ARG5                            && \\\n+         r_array_length == Z_ARG4                            && \\\n+        (r_array_index  == Z_ARG3 || r_array_index == noreg) && \\\n+        (r_sub_klass    == Z_ARG2 || r_sub_klass   == noreg) && \\\n+        (r_bitmap       == Z_R10  || r_bitmap      == noreg) && \\\n+        (r_result       == Z_R11  || r_result      == noreg), \"registers must match s390.ad\"); \\\n+} while(0)\n+\n+\/\/ Note: this method also kills Z_R1_scratch register on machines older than z15\n+void MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register r_temp1,\n+                                                   Register r_temp2,\n+                                                   Register r_temp3,\n+                                                   Register r_temp4,\n+                                                   Register r_result,\n+                                                   u1 super_klass_slot) {\n+  NearLabel L_done, L_failure;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_base   = r_temp1,\n+    r_array_length = r_temp2,\n+    r_array_index  = r_temp3,\n+    r_bitmap       = r_temp4;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  z_lg(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  u1 bit = super_klass_slot;\n+  int shift_count = Klass::SECONDARY_SUPERS_TABLE_MASK - bit;\n+\n+  z_sllg(r_array_index, r_bitmap, shift_count); \/\/ take the bit to 63rd location\n+\n+  \/\/ Initialize r_result with 0 (indicating success). If searching fails, r_result will be loaded\n+  \/\/ with 1 (failure) at the end of this method.\n+  clear_reg(r_result, true \/* whole_reg *\/, false \/* set_cc *\/); \/\/ r_result = 0\n+\n+  \/\/ We test the MSB of r_array_index, i.e., its sign bit\n+  testbit(r_array_index, 63);\n+  z_bfalse(L_failure); \/\/ if not set, then jump!!!\n+\n+  \/\/ We will consult the secondary-super array.\n+  z_lg(r_array_base, Address(r_sub_klass, Klass::secondary_supers_offset()));\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the\n+  \/\/ data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+\n+  \/\/ Get the first array index that can contain super_klass.\n+  if (bit != 0) {\n+    pop_count_long(r_array_index, r_array_index, Z_R1_scratch); \/\/ kills Z_R1_scratch on machines older than z15\n+\n+    \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+    z_sllg(r_array_index, r_array_index, LogBytesPerWord); \/\/ scale\n+  } else {\n+    \/\/ Actually use index 0, but r_array_base and r_array_index are off by 1 word\n+    \/\/ such that the sum is precise.\n+    z_lghi(r_array_index, BytesPerWord); \/\/ for slow path (scaled)\n+  }\n+\n+  z_cg(r_super_klass, Address(r_array_base, r_array_index));\n+  branch_optimized(bcondEqual, L_done); \/\/ found a match; success\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  testbit(r_bitmap, (bit + 1) & Klass::SECONDARY_SUPERS_TABLE_MASK);\n+  z_bfalse(L_failure);\n+\n+  \/\/ Linear probe. Rotate the bitmap so that the next bit to test is\n+  \/\/ in Bit 2 for the look-ahead check in the slow path.\n+  if (bit != 0) {\n+    z_rllg(r_bitmap, r_bitmap, 64-bit); \/\/ rotate right\n+  }\n+\n+  \/\/ Calls into the stub generated by lookup_secondary_supers_table_slow_path.\n+  \/\/ Arguments: r_super_klass, r_array_base, r_array_index, r_bitmap.\n+  \/\/ Kills: r_array_length.\n+  \/\/ Returns: r_result\n+\n+  call_stub(StubRoutines::lookup_secondary_supers_table_slow_path_stub());\n+\n+  z_bru(L_done); \/\/ pass whatever result we got from a slow path\n+\n+  bind(L_failure);\n+  \/\/ TODO: use load immediate on condition and z_bru above will not be required\n+  z_lghi(r_result, 1);\n+\n+  bind(L_done);\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, r_result,\n+                                  r_temp1, r_temp2, r_temp3);\n+  }\n+}\n+\n+\/\/ Called by code generated by check_klass_subtype_slow_path\n+\/\/ above. This is called when there is a collision in the hashed\n+\/\/ lookup in the secondary supers array.\n+void MacroAssembler::lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                                             Register r_array_base,\n+                                                             Register r_array_index,\n+                                                             Register r_bitmap,\n+                                                             Register r_result,\n+                                                             Register r_temp1) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, r_result, r_temp1);\n+\n+  const Register\n+    r_array_length = r_temp1,\n+    r_sub_klass    = noreg;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table_slow_path {\");\n+  NearLabel L_done, L_failure;\n+\n+  \/\/ Load the array length.\n+  z_llgf(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+\n+  \/\/ And adjust the array base to point to the data.\n+  \/\/ NB!\n+  \/\/ Effectively increments the current slot index by 1.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"\");\n+  add2reg(r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ Linear probe\n+  NearLabel L_huge;\n+\n+  \/\/ The bitmap is full to bursting.\n+  z_cghi(r_bitmap, Klass::SECONDARY_SUPERS_BITMAP_FULL);\n+  z_bre(L_huge);\n+\n+  \/\/ NB! Our caller has checked bits 0 and 1 in the bitmap. The\n+  \/\/ current slot (at secondary_supers[r_array_index]) has not yet\n+  \/\/ been inspected, and r_array_index may be out of bounds if we\n+  \/\/ wrapped around the end of the array.\n+\n+  { \/\/ This is conventional linear probing, but instead of terminating\n+    \/\/ when a null entry is found in the table, we maintain a bitmap\n+    \/\/ in which a 0 indicates missing entries.\n+    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n+    \/\/ eventually terminates.\n+\n+#ifdef ASSERT\n+    \/\/ r_result is set to 0 by lookup_secondary_supers_table.\n+    \/\/ clear_reg(r_result, true \/* whole_reg *\/, false \/* set_cc *\/);\n+    z_cghi(r_result, 0);\n+    asm_assert(bcondEqual, \"r_result required to be 0, used by z_locgr\", 44);\n+\n+    \/\/ We should only reach here after having found a bit in the bitmap.\n+    z_ltgr(r_array_length, r_array_length);\n+    asm_assert(bcondHigh, \"array_length > 0, should hold\", 22);\n+#endif \/\/ ASSERT\n+\n+    \/\/ Compute limit in r_array_length\n+    add2reg(r_array_length, -1);\n+    z_sllg(r_array_length, r_array_length, LogBytesPerWord);\n+\n+    NearLabel L_loop;\n+    bind(L_loop);\n+\n+    \/\/ Check for wraparound.\n+    z_cgr(r_array_index, r_array_length);\n+    z_locgr(r_array_index, r_result, bcondHigh); \/\/ r_result is containing 0\n+\n+    z_cg(r_super_klass, Address(r_array_base, r_array_index));\n+    z_bre(L_done); \/\/ success\n+\n+    \/\/ look-ahead check: if Bit 2 is 0, we're done\n+    testbit(r_bitmap, 2);\n+    z_bfalse(L_failure);\n+\n+    z_rllg(r_bitmap, r_bitmap, 64-1); \/\/ rotate right\n+    add2reg(r_array_index, BytesPerWord);\n+\n+    z_bru(L_loop);\n+  }\n+\n+  { \/\/ Degenerate case: more than 64 secondary supers.\n+    \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+    \/\/ comparison or a binary search, but is that worth any added\n+    \/\/ complexity?\n+\n+    bind(L_huge);\n+    repne_scan(r_array_base, r_super_klass, r_array_length, r_result);\n+\n+    z_bru(L_done); \/\/ forward the result we got from repne_scan\n+  }\n+\n+  bind(L_failure);\n+  z_lghi(r_result, 1);\n+\n+  bind(L_done);\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table_slow_path\");\n+}\n+\n+\/\/ Make sure that the hashed lookup and a linear scan agree.\n+void MacroAssembler::verify_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register r_result \/* expected *\/,\n+                                                   Register r_temp1,\n+                                                   Register r_temp2,\n+                                                   Register r_temp3) {\n+  assert_different_registers(r_sub_klass, r_super_klass, r_result, r_temp1, r_temp2, r_temp3);\n+\n+  const Register\n+    r_array_base   = r_temp1,\n+    r_array_length = r_temp2,\n+    r_array_index  = r_temp3,\n+    r_bitmap       = noreg; \/\/ unused\n+\n+  const Register r_one = Z_R0_scratch;\n+  z_lghi(r_one, 1); \/\/ for locgr down there, to a load result for failure\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  BLOCK_COMMENT(\"verify_secondary_supers_table {\");\n+\n+  Label L_passed, L_failure;\n+\n+  \/\/ We will consult the secondary-super array.\n+  z_lg(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ Load the array length.\n+  z_llgf(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+\n+  \/\/ And adjust the array base to point to the data.\n+  z_aghi(r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  const Register r_linear_result = r_array_index; \/\/ reuse\n+  z_chi(r_array_length, 0);\n+  z_locgr(r_linear_result, r_one, bcondNotHigh); \/\/ load failure if array_length <= 0\n+  z_brc(bcondNotHigh, L_failure);\n+  repne_scan(r_array_base, r_super_klass, r_array_length, r_linear_result);\n+  bind(L_failure);\n+\n+  z_cr(r_result, r_linear_result);\n+  z_bre(L_passed);\n+\n+  assert_different_registers(Z_ARG1, r_sub_klass, r_linear_result, r_result);\n+  lgr_if_needed(Z_ARG1, r_super_klass);\n+  assert_different_registers(Z_ARG2, r_linear_result, r_result);\n+  lgr_if_needed(Z_ARG2, r_sub_klass);\n+  assert_different_registers(Z_ARG3, r_result);\n+  z_lgr(Z_ARG3, r_linear_result);\n+  z_lgr(Z_ARG4, r_result);\n+  const char* msg = \"mismatch\";\n+  load_const_optimized(Z_ARG5, (address)msg);\n+\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, Klass::on_secondary_supers_verification_failure));\n+  should_not_reach_here();\n+\n+  bind(L_passed);\n+\n+  BLOCK_COMMENT(\"} verify_secondary_supers_table\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":296,"deletions":0,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -711,0 +711,25 @@\n+  void repne_scan(Register r_addr, Register r_value, Register r_count, Register r_scratch);\n+\n+  void lookup_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register r_temp1,\n+                                     Register r_temp2,\n+                                     Register r_temp3,\n+                                     Register r_temp4,\n+                                     Register r_result,\n+                                     u1 super_klass_slot);\n+\n+  void lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                               Register r_array_base,\n+                                               Register r_array_index,\n+                                               Register r_bitmap,\n+                                               Register r_result,\n+                                               Register r_temp1);\n+\n+  void verify_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register r_result \/* expected *\/,\n+                                     Register r_temp1,\n+                                     Register r_temp2,\n+                                     Register r_temp3);\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -359,0 +359,2 @@\n+reg_class z_r10_ptr_reg(Z_R10_H, Z_R10);\n+reg_class z_r11_ptr_reg(Z_R11_H, Z_R11);\n@@ -2988,0 +2990,2 @@\n+  match(r10TempRegP);\n+  match(r11TempRegP);\n@@ -3000,0 +3004,14 @@\n+operand r10TempRegP() %{\n+  constraint(ALLOC_IN_RC(z_r10_ptr_reg));\n+  match(iRegP);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand r11TempRegP() %{\n+  constraint(ALLOC_IN_RC(z_r11_ptr_reg));\n+  match(iRegP);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -9563,0 +9581,26 @@\n+instruct partialSubtypeCheckConstSuper(rarg2RegP sub, rarg1RegP super, immP super_con,\n+                                       r11TempRegP result, rarg5RegP temp1, rarg4RegP temp2,\n+                                       rarg3RegP temp3, r10TempRegP temp4, flagsReg pcc) %{\n+  match(Set result (PartialSubtypeCheck sub (Binary super super_con)));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL pcc, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4);\n+  ins_cost(7 * DEFAULT_COST); \/\/ needs to be less than competing nodes\n+  format %{ \"partialSubtypeCheck $result, $sub, $super, $super_con\" %}\n+\n+  ins_encode %{\n+    u1 super_klass_slot = ((Klass*)$super_con$$constant)->hash_slot();\n+    if (InlineSecondarySupersTest) {\n+      __ lookup_secondary_supers_table($sub$$Register, $super$$Register,\n+                                                 $temp1$$Register, $temp2$$Register, $temp3$$Register,\n+                                                 $temp4$$Register, $result$$Register, super_klass_slot);\n+    } else {\n+      AddressLiteral stub_address(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot));\n+      __ load_const_optimized(Z_ARG4, stub_address);\n+      __ z_basr(Z_R14, Z_ARG4);\n+    }\n+\n+  %}\n+\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -708,0 +708,44 @@\n+  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+    const Register\n+        r_super_klass  = Z_ARG1,\n+        r_sub_klass    = Z_ARG2,\n+        r_array_index  = Z_ARG3,\n+        r_array_length = Z_ARG4,\n+        r_array_base   = Z_ARG5,\n+        r_bitmap       = Z_R10,\n+        r_result       = Z_R11;\n+    address start = __ pc();\n+\n+    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n+                                     r_array_base, r_array_length, r_array_index,\n+                                     r_bitmap, r_result, super_klass_index);\n+\n+    __ z_br(Z_R14);\n+\n+    return start;\n+  }\n+\n+  \/\/ Slow path implementation for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_slow_path_stub() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+\n+    address start = __ pc();\n+\n+    const Register\n+        r_super_klass  = Z_ARG1,\n+        r_array_base   = Z_ARG5,\n+        r_temp1        = Z_ARG4,\n+        r_array_index  = Z_ARG3,\n+        r_bitmap       = Z_R10,\n+        r_result       = Z_R11;\n+\n+    __ lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base,\n+                                               r_array_index, r_bitmap, r_result, r_temp1);\n+\n+    __ z_br(Z_R14);\n+\n+    return start;\n+  }\n+\n@@ -3250,0 +3294,8 @@\n+    if (UseSecondarySupersTable) {\n+      StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+      if (!InlineSecondarySupersTest) {\n+        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+          StubRoutines::_lookup_secondary_supers_table_stubs[slot] = generate_lookup_secondary_supers_table_stub(slot);\n+        }\n+      }\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":53,"deletions":1,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -275,0 +275,7 @@\n+  if (UseSecondarySupersTable && VM_Version::get_model_index() < 5 \/* z196\/z11 *\/) {\n+    if (!FLAG_IS_DEFAULT(UseSecondarySupersTable)) {\n+      warning(\"UseSecondarySupersTable requires z196 or later.\");\n+    }\n+    FLAG_SET_DEFAULT(UseSecondarySupersTable, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -416,0 +416,2 @@\n+  constexpr static bool supports_secondary_supers_table() { return true; }\n+\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}