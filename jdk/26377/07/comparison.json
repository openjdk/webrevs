{"files":[{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.security.MessageDigest;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.SignatureSpi;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidParameterException;\n+import java.security.SignatureException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.Cipher;\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.IllegalBlockSizeException;\n+\n+\/**\n+ * NONEwithRSA Signature implementation using the RSA\/ECB\/PKCS1Padding Cipher\n+ * implementation from SunJCE.\n+ *\/\n+public final class RSACipherAdaptor extends SignatureSpi {\n+\n+    private final RSACipher c;\n+    private ByteArrayOutputStream verifyBuf;\n+\n+    public RSACipherAdaptor() {\n+        c = new RSACipher();\n+    }\n+\n+    @Override\n+    protected void engineInitVerify(PublicKey publicKey)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.DECRYPT_MODE, publicKey, null);\n+        if (verifyBuf == null) {\n+            verifyBuf = new ByteArrayOutputStream(128);\n+        } else {\n+            verifyBuf.reset();\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.ENCRYPT_MODE, privateKey, null);\n+        verifyBuf = null;\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey, SecureRandom random)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.ENCRYPT_MODE, privateKey, random);\n+        verifyBuf = null;\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte b) throws SignatureException {\n+        engineUpdate(new byte[] {b}, 0, 1);\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte[] b, int off, int len)\n+            throws SignatureException {\n+        if (verifyBuf != null) {\n+            verifyBuf.write(b, off, len);\n+        } else {\n+            byte[] out = c.engineUpdate(b, off, len);\n+            if ((out != null) && (out.length != 0)) {\n+                throw new SignatureException\n+                       (\"Cipher unexpectedly returned data\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineSign() throws SignatureException {\n+        try {\n+            return c.engineDoFinal(null, 0, 0);\n+        } catch (IllegalBlockSizeException | BadPaddingException e) {\n+           throw new SignatureException(\"doFinal() failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    protected boolean engineVerify(byte[] sigBytes) throws SignatureException {\n+        try {\n+            byte[] out = c.engineDoFinal(sigBytes, 0, sigBytes.length);\n+            byte[] data = verifyBuf.toByteArray();\n+            verifyBuf.reset();\n+            return MessageDigest.isEqual(out, data);\n+        } catch (BadPaddingException e) {\n+            \/\/ e.g. wrong public key used\n+            \/\/ return false rather than throwing exception\n+            return false;\n+        } catch (IllegalBlockSizeException e) {\n+            throw new SignatureException(\"doFinal() failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    protected void engineSetParameter(AlgorithmParameterSpec params)\n+            throws InvalidAlgorithmParameterException {\n+        if (params != null) {\n+            throw new InvalidParameterException(\"Parameters not supported\");\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected void engineSetParameter(String param, Object value)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"Parameters not supported\");\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected Object engineGetParameter(String param)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"Parameters not supported\");\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RSACipherAdaptor.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -139,0 +139,6 @@\n+        attrs.put(\"SupportedKeyClasses\",\n+                \"java.security.interfaces.RSAPublicKey\" +\n+                \"|java.security.interfaces.RSAPrivateKey\");\n+        ps(\"Signature\", \"NONEwithRSA\",\n+                \"com.sun.crypto.provider.RSACipherAdaptor\", null, attrs);\n+        \/\/ continue adding cipher specific attributes\n@@ -150,3 +156,0 @@\n-        attrs.put(\"SupportedKeyClasses\",\n-                \"java.security.interfaces.RSAPublicKey\" +\n-                \"|java.security.interfaces.RSAPrivateKey\");\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.security.util.CryptoAlgorithmConstraints;\n@@ -844,2 +845,3 @@\n-     * The JDK Reference Implementation additionally uses the\n-     * {@code jdk.security.provider.preferred}\n+     * The JDK Reference Implementation additionally uses\n+     * <ul>\n+     * <li>the {@code jdk.security.provider.preferred}\n@@ -847,1 +849,1 @@\n-     * the preferred provider order for the specified algorithm. This\n+     * the preferred provider order for the specified keystore type. This\n@@ -850,0 +852,8 @@\n+     * <\/li>\n+     * <li>the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     * <\/li>\n+     * <\/ul>\n@@ -872,0 +882,5 @@\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"KEYSTORE\", type)) {\n+            throw new KeyStoreException(type + \" is disabled\");\n+        }\n+\n@@ -891,0 +906,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -920,1 +943,2 @@\n-        if (provider == null || provider.isEmpty())\n+\n+        if (provider == null || provider.isEmpty()) {\n@@ -922,0 +946,6 @@\n+        }\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"KEYSTORE\", type)) {\n+            throw new KeyStoreException(type + \" is disabled\");\n+        }\n+\n@@ -938,0 +968,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -966,1 +1004,2 @@\n-        if (provider == null)\n+\n+        if (provider == null) {\n@@ -968,0 +1007,6 @@\n+        }\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"KEYSTORE\", type)) {\n+            throw new KeyStoreException(type + \" is disabled\");\n+        }\n+\n@@ -1680,0 +1725,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value. Disallowed type will be skipped.\n+     *\n@@ -1733,0 +1786,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value. Disallowed type will be skipped.\n+     *\n@@ -1801,2 +1862,6 @@\n-                                keystore = new KeyStore(impl, p, s.getAlgorithm());\n-                                break;\n+                                String ksAlgo = s.getAlgorithm();\n+                                if (CryptoAlgorithmConstraints.permits(\n+                                        \"KEYSTORE\", ksAlgo)) {\n+                                    keystore = new KeyStore(impl, p, ksAlgo);\n+                                    break;\n+                                }\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyStore.java","additions":72,"deletions":7,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import sun.security.util.CryptoAlgorithmConstraints;\n@@ -158,2 +159,4 @@\n-     * The JDK Reference Implementation additionally uses the\n-     * {@code jdk.security.provider.preferred}\n+     * The JDK Reference Implementation additionally uses the following\n+     * security properties:\n+     * <ul>\n+     * <li>the {@code jdk.security.provider.preferred}\n@@ -164,0 +167,8 @@\n+     * <\/li>\n+     * <li>the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     * <\/li>\n+     * <\/ul>\n@@ -187,1 +198,4 @@\n-        MessageDigest md;\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"MessageDigest\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n+        }\n@@ -191,0 +205,1 @@\n+        MessageDigest md;\n@@ -219,0 +234,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -249,1 +272,2 @@\n-        if (provider == null || provider.isEmpty())\n+\n+        if (provider == null || provider.isEmpty()) {\n@@ -251,0 +275,5 @@\n+        }\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"MessageDigest\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n+        }\n@@ -252,1 +281,0 @@\n-        MessageDigest md;\n@@ -255,0 +283,1 @@\n+        MessageDigest md;\n@@ -274,0 +303,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -304,1 +341,2 @@\n-        if (provider == null)\n+\n+        if (provider == null) {\n@@ -306,0 +344,6 @@\n+        }\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"MessageDigest\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/MessageDigest.java","additions":50,"deletions":6,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -39,4 +39,0 @@\n-import javax.crypto.Cipher;\n-import javax.crypto.IllegalBlockSizeException;\n-import javax.crypto.BadPaddingException;\n-import javax.crypto.NoSuchPaddingException;\n@@ -47,0 +43,2 @@\n+import sun.security.util.CryptoAlgorithmConstraints;\n+\n@@ -216,14 +214,0 @@\n-    \/\/ name of the special signature alg\n-    private static final String RSA_SIGNATURE = \"NONEwithRSA\";\n-\n-    \/\/ name of the equivalent cipher alg\n-    private static final String RSA_CIPHER = \"RSA\/ECB\/PKCS1Padding\";\n-\n-    \/\/ all the services we need to lookup for compatibility with Cipher\n-    private static final List<ServiceId> rsaIds = List.of(\n-        new ServiceId(\"Signature\", \"NONEwithRSA\"),\n-        new ServiceId(\"Cipher\", \"RSA\/ECB\/PKCS1Padding\"),\n-        new ServiceId(\"Cipher\", \"RSA\/ECB\"),\n-        new ServiceId(\"Cipher\", \"RSA\/\/PKCS1Padding\"),\n-        new ServiceId(\"Cipher\", \"RSA\"));\n-\n@@ -244,2 +228,4 @@\n-     * The JDK Reference Implementation additionally uses the\n-     * {@code jdk.security.provider.preferred}\n+     * The JDK Reference Implementation additionally uses the following\n+     * security properties:\n+     * <ul>\n+     * <li>the {@code jdk.security.provider.preferred}\n@@ -250,0 +236,8 @@\n+     * <\/li>\n+     * <li>the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     * <\/li>\n+     * <\/ul>\n@@ -271,5 +265,3 @@\n-        Iterator<Service> t;\n-        if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {\n-            t = GetInstance.getServices(rsaIds);\n-        } else {\n-            t = GetInstance.getServices(\"Signature\", algorithm);\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"Signature\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n@@ -277,0 +269,2 @@\n+\n+        Iterator<Service> t = GetInstance.getServices(\"Signature\", algorithm);\n@@ -332,4 +326,0 @@\n-        if (s.getType().equals(\"Cipher\")) {\n-            \/\/ must be a CipherSpi, which we can wrap with the CipherAdapter\n-            return true;\n-        }\n@@ -373,0 +363,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -401,11 +399,3 @@\n-        if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {\n-            \/\/ exception compatibility with existing code\n-            if (provider == null || provider.isEmpty()) {\n-                throw new IllegalArgumentException(\"missing provider\");\n-            }\n-            Provider p = Security.getProvider(provider);\n-            if (p == null) {\n-                throw new NoSuchProviderException\n-                    (\"no such provider: \" + provider);\n-            }\n-            return getInstanceRSA(p);\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"Signature\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n@@ -413,0 +403,1 @@\n+\n@@ -427,0 +418,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -453,6 +452,3 @@\n-        if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {\n-            \/\/ exception compatibility with existing code\n-            if (provider == null) {\n-                throw new IllegalArgumentException(\"missing provider\");\n-            }\n-            return getInstanceRSA(provider);\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"Signature\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n@@ -460,0 +456,1 @@\n+\n@@ -465,22 +462,0 @@\n-    \/\/ return an implementation for NONEwithRSA, which is a special case\n-    \/\/ because of the Cipher.RSA\/ECB\/PKCS1Padding compatibility wrapper\n-    private static Signature getInstanceRSA(Provider p)\n-            throws NoSuchAlgorithmException {\n-        \/\/ try Signature first\n-        Service s = p.getService(\"Signature\", RSA_SIGNATURE);\n-        if (s != null) {\n-            Instance instance = GetInstance.getInstance(s, SignatureSpi.class);\n-            return getInstance(instance, RSA_SIGNATURE);\n-        }\n-        \/\/ check Cipher\n-        try {\n-            Cipher c = Cipher.getInstance(RSA_CIPHER, p);\n-            return Delegate.of(new CipherAdapter(c), RSA_SIGNATURE);\n-        } catch (GeneralSecurityException e) {\n-            \/\/ throw Signature style exception message to avoid confusion,\n-            \/\/ but append Cipher exception as cause\n-            throw new NoSuchAlgorithmException(\"no such algorithm: \"\n-                + RSA_SIGNATURE + \" for provider \" + p.getName(), e);\n-        }\n-    }\n-\n@@ -1182,15 +1157,4 @@\n-            if (s.getType().equals(\"Cipher\")) {\n-                \/\/ must be NONEwithRSA\n-                try {\n-                    Cipher c = Cipher.getInstance(RSA_CIPHER, s.getProvider());\n-                    return new CipherAdapter(c);\n-                } catch (NoSuchPaddingException e) {\n-                    throw new NoSuchAlgorithmException(e);\n-                }\n-            } else {\n-                Object o = s.newInstance(null);\n-                if (!(o instanceof SignatureSpi)) {\n-                    throw new NoSuchAlgorithmException\n-                        (\"Not a SignatureSpi: \" + o.getClass().getName());\n-                }\n-                return (SignatureSpi)o;\n+            Object o = s.newInstance(null);\n+            if (!(o instanceof SignatureSpi)) {\n+                throw new NoSuchAlgorithmException\n+                    (\"Not a SignatureSpi: \" + o.getClass().getName());\n@@ -1198,0 +1162,1 @@\n+            return (SignatureSpi)o;\n@@ -1474,88 +1439,0 @@\n-\n-    \/\/ adapter for RSA\/ECB\/PKCS1Padding ciphers\n-    @SuppressWarnings(\"deprecation\")\n-    private static class CipherAdapter extends SignatureSpi {\n-\n-        private final Cipher cipher;\n-\n-        private ByteArrayOutputStream data;\n-\n-        CipherAdapter(Cipher cipher) {\n-            this.cipher = cipher;\n-        }\n-\n-        protected void engineInitVerify(PublicKey publicKey)\n-                throws InvalidKeyException {\n-            cipher.init(Cipher.DECRYPT_MODE, publicKey);\n-            if (data == null) {\n-                data = new ByteArrayOutputStream(128);\n-            } else {\n-                data.reset();\n-            }\n-        }\n-\n-        protected void engineInitSign(PrivateKey privateKey)\n-                throws InvalidKeyException {\n-            cipher.init(Cipher.ENCRYPT_MODE, privateKey);\n-            data = null;\n-        }\n-\n-        protected void engineInitSign(PrivateKey privateKey,\n-                SecureRandom random) throws InvalidKeyException {\n-            cipher.init(Cipher.ENCRYPT_MODE, privateKey, random);\n-            data = null;\n-        }\n-\n-        protected void engineUpdate(byte b) throws SignatureException {\n-            engineUpdate(new byte[] {b}, 0, 1);\n-        }\n-\n-        protected void engineUpdate(byte[] b, int off, int len)\n-                throws SignatureException {\n-            if (data != null) {\n-                data.write(b, off, len);\n-                return;\n-            }\n-            byte[] out = cipher.update(b, off, len);\n-            if ((out != null) && (out.length != 0)) {\n-                throw new SignatureException\n-                    (\"Cipher unexpectedly returned data\");\n-            }\n-        }\n-\n-        protected byte[] engineSign() throws SignatureException {\n-            try {\n-                return cipher.doFinal();\n-            } catch (IllegalBlockSizeException | BadPaddingException e) {\n-                throw new SignatureException(\"doFinal() failed\", e);\n-            }\n-        }\n-\n-        protected boolean engineVerify(byte[] sigBytes)\n-                throws SignatureException {\n-            try {\n-                byte[] out = cipher.doFinal(sigBytes);\n-                byte[] dataBytes = data.toByteArray();\n-                data.reset();\n-                return MessageDigest.isEqual(out, dataBytes);\n-            } catch (BadPaddingException e) {\n-                \/\/ e.g. wrong public key used\n-                \/\/ return false rather than throwing exception\n-                return false;\n-            } catch (IllegalBlockSizeException e) {\n-                throw new SignatureException(\"doFinal() failed\", e);\n-            }\n-        }\n-\n-        protected void engineSetParameter(String param, Object value)\n-                throws InvalidParameterException {\n-            throw new InvalidParameterException(\"Parameters not supported\");\n-        }\n-\n-        protected Object engineGetParameter(String param)\n-                throws InvalidParameterException {\n-            throw new InvalidParameterException(\"Parameters not supported\");\n-        }\n-\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/Signature.java","additions":48,"deletions":171,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-\n@@ -49,0 +48,1 @@\n+import sun.security.util.CryptoAlgorithmConstraints;\n@@ -328,0 +328,1 @@\n+\n@@ -513,2 +514,4 @@\n-     * The JDK Reference Implementation additionally uses the\n-     * {@code jdk.security.provider.preferred}\n+     * The JDK Reference Implementation additionally uses the following\n+     * security properties:\n+     * <ul>\n+     * <li>the {@code jdk.security.provider.preferred}\n@@ -522,0 +525,8 @@\n+     * <\/li>\n+     * <li>the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     * <\/li>\n+     * <\/ul>\n@@ -550,0 +561,7 @@\n+\n+        \/\/ throws NoSuchAlgorithmException if java.security disables it\n+        if (!CryptoAlgorithmConstraints.permits(\"Cipher\", transformation)) {\n+            throw new NoSuchAlgorithmException(transformation +\n+                    \" is disabled\");\n+        }\n+\n@@ -613,0 +631,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -686,0 +712,8 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed. If the\n+     * {@systemProperty jdk.crypto.disabledAlgorithms} is set, it supersedes\n+     * the security property value.\n+     *\n@@ -723,0 +757,7 @@\n+\n+        \/\/ throws NoSuchAlgorithmException if java.security disables it\n+        if (!CryptoAlgorithmConstraints.permits(\"Cipher\", transformation)) {\n+            throw new NoSuchAlgorithmException(transformation +\n+                    \" is disabled\");\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":44,"deletions":3,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,10 @@\n-        String property = Security.getProperty(propertyName);\n+        return getAlgorithms(propertyName, false);\n+    }\n+\n+    \/\/ Get algorithm constraints from the specified security property or\n+    \/\/ system property if allowSystemOverride == true.\n+    static Set<String> getAlgorithms(String propertyName,\n+            boolean allowSystemOverride) {\n+        String property = allowSystemOverride ?\n+                SecurityProperties.getOverridableProperty(propertyName) :\n+                Security.getProperty(propertyName);\n@@ -68,1 +77,2 @@\n-        Set<String> algorithmsInPropertySet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n+        Set<String> algorithmsInPropertySet =\n+                new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n@@ -83,2 +93,3 @@\n-        \/\/ decompose the algorithm into sub-elements\n-        Set<String> elements = decomposer.decompose(algorithm);\n+        if (decomposer != null) {\n+            \/\/ decompose the algorithm into sub-elements\n+            Set<String> elements = decomposer.decompose(algorithm);\n@@ -86,4 +97,5 @@\n-        \/\/ check the element of the elements\n-        for (String element : elements) {\n-            if (algorithms.contains(element)) {\n-                return false;\n+            \/\/ check the element of the elements\n+            for (String element : elements) {\n+                if (algorithms.contains(element)) {\n+                    return false;\n+                }\n@@ -92,1 +104,0 @@\n-\n@@ -95,1 +106,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AbstractAlgorithmConstraints.java","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.lang.ref.SoftReference;\n+import java.security.AlgorithmParameters;\n+import java.security.CryptoPrimitive;\n+import java.security.Key;\n+import java.security.Security;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+\/**\n+ * This class implements the algorithm constraints for the\n+ * \"jdk.crypto.disabledAlgorithms\" security property. This security property\n+ * can be overridden by the system property of the same name. See the\n+ * java.security file for the syntax of the property value.\n+ *\/\n+public class CryptoAlgorithmConstraints extends AbstractAlgorithmConstraints {\n+    private static final Debug debug = Debug.getInstance(\"jca\");\n+\n+    \/\/ for validating the service\n+    private static final Set<String> SUPPORTED_SERVICES =\n+            Set.of(\"Cipher\", \"KeyStore\", \"MessageDigest\", \"Signature\");\n+\n+    \/\/ Disabled algorithm security property for JCE crypto services\n+    public static final String PROPERTY_CRYPTO_DISABLED_ALGS =\n+            \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static class CryptoHolder {\n+        static final CryptoAlgorithmConstraints CONSTRAINTS =\n+                new CryptoAlgorithmConstraints(PROPERTY_CRYPTO_DISABLED_ALGS);\n+    }\n+\n+    private static void debug(String msg) {\n+        if (debug != null) {\n+            debug.println(\"CryptoAlgoConstraints: \", msg);\n+        }\n+    }\n+\n+    public static boolean permits(String service, String algo) {\n+        String serviceDesc = service + \".\" + algo;\n+        return CryptoHolder.CONSTRAINTS.cachedCheckAlgorithm(serviceDesc);\n+    }\n+\n+    private final Set<String> disabledServices; \/\/ syntax is <service>.<algo>\n+    private volatile SoftReference<Map<String, Boolean>> cacheRef =\n+            new SoftReference<>(null);\n+\n+    \/**\n+     * Initialize algorithm constraints with the specified security property\n+     * {@code propertyName}. Note that if a system property of the same name\n+     * is set, it overrides the security property.\n+     *\n+     * @param propertyName the security property name that define the disabled\n+     *        algorithm constraints\n+     *\/\n+    CryptoAlgorithmConstraints(String propertyName) {\n+        super(null);\n+        disabledServices = getAlgorithms(propertyName, true);\n+        debug(\"Before \" + Arrays.deepToString(disabledServices.toArray()));\n+        for (String dk : disabledServices) {\n+            int idx = dk.indexOf(\".\");\n+            if (idx == -1) {\n+                \/\/ wrong syntax\n+                throw new IllegalArgumentException(\"Invalid entry: \" + dk);\n+            }\n+            String service = dk.substring(0, idx);\n+            String algo = dk.substring(idx + 1);\n+            if (service.length() == 0 || algo.length() == 0) {\n+                \/\/ missing service or algorithm\n+                throw new IllegalArgumentException(\"Invalid entry: \" + dk);\n+            }\n+            if (SUPPORTED_SERVICES.stream().anyMatch(e -> e.equalsIgnoreCase\n+                    (service))) {\n+                KnownOIDs oid = KnownOIDs.findMatch(algo);\n+                if (oid != null) {\n+                    debug(\"Add oid: \" + oid.value());\n+                    disabledServices.add(service + \".\" + oid.value());\n+                    debug(\"Add oid stdName: \" + oid.stdName());\n+                    disabledServices.add(service + \".\" + oid.stdName());\n+                    for (String a : oid.aliases()) {\n+                        debug(\"Add oid alias: \" + a);\n+                        disabledServices.add(service + \".\" + a);\n+                    }\n+                }\n+            } else {\n+                \/\/ unsupported service\n+                throw new IllegalArgumentException(\"Invalid entry: \" + dk);\n+            }\n+        }\n+        debug(\"After \" + Arrays.deepToString(disabledServices.toArray()));\n+    }\n+\n+    @Override\n+    public final boolean permits(Set<CryptoPrimitive> notUsed1,\n+            String serviceDesc, AlgorithmParameters notUsed2) {\n+        throw new UnsupportedOperationException(\"Unsupported permits() method\");\n+    }\n+\n+    @Override\n+    public final boolean permits(Set<CryptoPrimitive> primitives, Key key) {\n+        throw new UnsupportedOperationException(\"Unsupported permits() method\");\n+    }\n+\n+    @Override\n+    public final boolean permits(Set<CryptoPrimitive> primitives,\n+            String algorithm, Key key, AlgorithmParameters parameters) {\n+        throw new UnsupportedOperationException(\"Unsupported permits() method\");\n+    }\n+\n+    \/\/ Return false if algorithm is found in the disabledServices Set.\n+    \/\/ Otherwise, return true.\n+    private boolean cachedCheckAlgorithm(String serviceDesc) {\n+        Map<String, Boolean> cache;\n+        if ((cache = cacheRef.get()) == null) {\n+            synchronized (this) {\n+                if ((cache = cacheRef.get()) == null) {\n+                    cache = new ConcurrentHashMap<>();\n+                    cacheRef = new SoftReference<>(cache);\n+                }\n+            }\n+        }\n+        Boolean result = cache.get(serviceDesc);\n+        if (result != null) {\n+            return result;\n+        }\n+        result = checkAlgorithm(disabledServices, serviceDesc, null);\n+        cache.put(serviceDesc, result);\n+        return result;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/CryptoAlgorithmConstraints.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -187,1 +187,1 @@\n-    RSA(\"1.2.840.113549.1.1.1\"), \/\/ RSA encryption\n+    RSA(\"1.2.840.113549.1.1.1\", \"RSA\", \"RSA\/ECB\/PKCS1Padding\"), \/\/ RSA encryption\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -774,0 +774,44 @@\n+#\n+# Algorithm restrictions for Java Crypto API services\n+#\n+# In some environments, certain algorithms may be undesirable for certain\n+# cryptographic services. For example, \"MD2\" is generally no longer considered\n+# to be a secure hash algorithm.  This section describes the mechanism for\n+# disabling algorithms at the JCA\/JCE level based on service name and algorithm\n+# name.\n+#\n+# If a system property of the same name is also specified, it supersedes the\n+# security property value defined here.\n+#\n+# The syntax of the disabled services string is described as follows:\n+#       \"DisabledService {, DisabledService}\"\n+#\n+#   DisabledService:\n+#       Service.AlgorithmName\n+#\n+# Service:  (one of the following, more services may be added later)\n+#     Cipher | KeyStore | MessageDigest | Signature\n+#\n+#   AlgorithmName:\n+#       (see below)\n+#\n+# The \"AlgorithmName\" is the standard algorithm name of the disabled\n+# service. See the Java Security Standard Algorithm Names Specification\n+# for information about Standard Algorithm Names.  Matching is\n+# performed using a case-insensitive exact matching rule. For Cipher service,\n+# its algorithm is the transformation string.\n+#\n+# Note: If the property value contains entries with invalid syntax or\n+# unsupported services at the time of checking, an ExceptionInInitializerError\n+# with a cause of IllegalArgumentException will be thrown.\n+#\n+# Note: The restriction is applied in the various getInstance(...) methods\n+# of the supported Service classes, i.e. Cipher, KeyStore, MessageDigest,\n+# and Signature.\n+#\n+# Note: This property is currently used by the JDK Reference implementation.\n+# It is not guaranteed to be examined and used by other implementations.\n+#\n+# Example:\n+#   jdk.crypto.disabledAlgorithms=Cipher.RSA\/ECB\/PKCS1Padding, MessageDigest.MD2\n+\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs11;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.security.MessageDigest;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.SignatureSpi;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidParameterException;\n+import java.security.ProviderException;\n+import java.security.SignatureException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.Cipher;\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import sun.security.pkcs11.wrapper.PKCS11Exception;\n+\n+\/**\n+ * NONEwithRSA Signature implementation using the RSA\/ECB\/PKCS1Padding Cipher\n+ * implementation from SunPKCS11.\n+ *\/\n+public final class RSACipherAdaptor extends SignatureSpi {\n+\n+    private final P11RSACipher c;\n+    private ByteArrayOutputStream verifyBuf;\n+\n+    public RSACipherAdaptor(Token token, long mechanism) {\n+        try {\n+            c = new P11RSACipher(token, \"\", mechanism);\n+            c.engineSetPadding(\"pkcs1padding\");\n+        } catch (PKCS11Exception | NoSuchPaddingException e) {\n+            \/\/ should not happen, but wrap and re-throw if it were to happen\n+            throw new ProviderException(e);\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInitVerify(PublicKey publicKey)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.DECRYPT_MODE, publicKey, null);\n+        if (verifyBuf == null) {\n+            verifyBuf = new ByteArrayOutputStream(128);\n+        } else {\n+            verifyBuf.reset();\n+        }\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.ENCRYPT_MODE, privateKey, null);\n+        verifyBuf = null;\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey, SecureRandom random)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.ENCRYPT_MODE, privateKey, random);\n+        verifyBuf = null;\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte b) throws SignatureException {\n+        engineUpdate(new byte[] {b}, 0, 1);\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte[] b, int off, int len)\n+            throws SignatureException {\n+        if (verifyBuf != null) {\n+            verifyBuf.write(b, off, len);\n+        } else {\n+            byte[] out = c.engineUpdate(b, off, len);\n+            if ((out != null) && (out.length != 0)) {\n+                throw new SignatureException\n+                       (\"Cipher unexpectedly returned data\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected byte[] engineSign() throws SignatureException {\n+        try {\n+            return c.engineDoFinal(null, 0, 0);\n+        } catch (IllegalBlockSizeException | BadPaddingException e) {\n+           throw new SignatureException(\"doFinal() failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    protected boolean engineVerify(byte[] sigBytes) throws SignatureException {\n+        try {\n+            byte[] out = c.engineDoFinal(sigBytes, 0, sigBytes.length);\n+            byte[] data = verifyBuf.toByteArray();\n+            verifyBuf.reset();\n+            return MessageDigest.isEqual(out, data);\n+        } catch (BadPaddingException e) {\n+            \/\/ e.g. wrong public key used\n+            \/\/ return false rather than throwing exception\n+            return false;\n+        } catch (IllegalBlockSizeException e) {\n+            throw new SignatureException(\"doFinal() failed\", e);\n+        }\n+    }\n+\n+    @Override\n+    protected void engineSetParameter(AlgorithmParameterSpec params)\n+            throws InvalidAlgorithmParameterException {\n+        if (params != null) {\n+            throw new InvalidParameterException(\"Parameters not supported\");\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected void engineSetParameter(String param, Object value)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"Parameters not supported\");\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected Object engineGetParameter(String param)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"Parameters not supported\");\n+    }\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/RSACipherAdaptor.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -977,0 +977,2 @@\n+        d(SIG, \"NONEwithRSA\",    \"sun.security.pkcs11.RSACipherAdaptor\",\n+                m(CKM_RSA_PKCS));\n@@ -1428,0 +1430,2 @@\n+                } else if (algorithm.equals(\"NONEwithRSA\")) {\n+                    return new RSACipherAdaptor(token, mechanism);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @library \/test\/lib\n+ * @run main\/othervm TestDisabledAlgorithms KEYSTORE.JKs true\n+ * @run main\/othervm TestDisabledAlgorithms keySTORE.what false\n+ * @run main\/othervm TestDisabledAlgorithms kEYstoRe.jceKS false\n+ * @run main\/othervm -Djdk.crypto.disabledAlgorithms=\"keystore.jkS\" TestDisabledAlgorithms keySTORE.jceKs true\n+ * @run main\/othervm -Djdk.crypto.disabledAlgorithms=\"KEYstORE.what\" TestDisabledAlgorithms KeYStore.JKs false\n+ * @run main\/othervm -Djdk.crypto.disabledAlgorithms=\"keystOre.jceKS\" TestDisabledAlgorithms KEysTORE.JKS false\n+ *\/\n+import java.io.File;\n+import java.util.List;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.Provider;\n+import java.security.Security;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+public class TestDisabledAlgorithms {\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    \/\/ reuse existing JKS test keystore\n+    private final static String DIR = System.getProperty(\"test.src\", \".\");\n+    private static final char[] PASSWD = \"passphrase\".toCharArray();\n+    private static final String JKS_FN = \"keystore.jks\";\n+\n+    private static void test(List<String> algos, Provider p,\n+            boolean shouldThrow) throws Exception {\n+\n+        for (String a : algos) {\n+            System.out.println(\"Testing \" + (p != null ? p.getName() : \"\") +\n+                    \": \" + a + \", shouldThrow=\" + shouldThrow);\n+            if (shouldThrow) {\n+                if (p == null) {\n+                    Utils.runAndCheckException(() -> KeyStore.getInstance(a),\n+                            KeyStoreException.class);\n+                    Utils.runAndCheckException(\n+                            () -> KeyStore.getInstance(new File(DIR, JKS_FN),\n+                                PASSWD),\n+                            KeyStoreException.class);\n+                    Utils.runAndCheckException(\n+                            () -> KeyStore.getInstance(new File(DIR, JKS_FN),\n+                                () -> {\n+                                    return new KeyStore.PasswordProtection(PASSWD);\n+                                }),\n+                            KeyStoreException.class);\n+                } else {\n+                    \/\/ with a provider argument\n+                    Utils.runAndCheckException(() -> KeyStore.getInstance(a, p),\n+                            KeyStoreException.class);\n+                }\n+            } else {\n+                if (p == null) {\n+                    KeyStore k = KeyStore.getInstance(a);\n+                    System.out.println(\"Got KeyStore w\/ algo \" + k.getType());\n+                    k = KeyStore.getInstance(new File(DIR, JKS_FN), PASSWD);\n+                    System.out.println(\"Got KeyStore w\/ algo \" + k.getType());\n+                    k = KeyStore.getInstance(new File(DIR, JKS_FN),\n+                        () -> {\n+                            return new KeyStore.PasswordProtection(PASSWD);\n+                        });\n+                    System.out.println(\"Got KeyStore w\/ algo \" + k.getType());\n+                } else {\n+                    \/\/ with a provider argument\n+                    KeyStore k = KeyStore.getInstance(a, p);\n+                    System.out.println(\"Got KeyStore w\/ algo \" + k.getType());\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+\n+        List<String> algos = List.of(\"JKS\", \"jkS\");\n+        \/\/ test w\/o provider\n+        test(algos, null, shouldThrow);\n+\n+        \/\/ test w\/ provider\n+        Provider[] providers = Security.getProviders(\"KeyStore.JKS\");\n+        for (Provider p : providers) {\n+            test(algos, p, shouldThrow);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/KeyStore\/TestDisabledAlgorithms.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @library \/test\/lib\n+ * @run main\/othervm TestDisabledAlgorithms MESSAGEdigest.Sha-512 true\n+ * @run main\/othervm TestDisabledAlgorithms messageDIGest.what false\n+ * @run main\/othervm TestDisabledAlgorithms meSSagedIgest.sHA-512\/224 false\n+ *\/\n+import java.util.List;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.MessageDigest;\n+import java.security.Provider;\n+import java.security.Security;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+public class TestDisabledAlgorithms {\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static void test(List<String> algos, Provider p,\n+            boolean shouldThrow) throws Exception {\n+\n+        for (String a : algos) {\n+            System.out.println(\"Testing \" + (p != null ? p.getName() : \"\") +\n+                    \": \" + a + \", shouldThrow=\" + shouldThrow);\n+            if (shouldThrow) {\n+                if (p == null) {\n+                    Utils.runAndCheckException(() -> MessageDigest.getInstance(a),\n+                            NoSuchAlgorithmException.class);\n+                } else {\n+                    Utils.runAndCheckException(() -> MessageDigest.getInstance(a, p),\n+                            NoSuchAlgorithmException.class);\n+                }\n+            } else {\n+                MessageDigest m;\n+                if (p == null) {\n+                    m = MessageDigest.getInstance(a);\n+                } else {\n+                    m = MessageDigest.getInstance(a, p);\n+                }\n+                System.out.println(\"Got MessageDigest w\/ algo \" +\n+                        m.getAlgorithm());\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+\n+        List<String> algos = List.of(\"sHA-512\", \"shA-512\",\n+                \"2.16.840.1.101.3.4.2.3\");\n+        \/\/ test w\/o provider\n+        test(algos, null, shouldThrow);\n+\n+        \/\/ test w\/ provider\n+        Provider[] providers = Security.getProviders(\"MessageDigest.SHA-512\");\n+        for (Provider p : providers) {\n+            test(algos, p, shouldThrow);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/MessageDigest\/TestDisabledAlgorithms.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8244336\n+ * @summary Check that invalid property values for\n+ *         \"jdk.crypto.disabledAlgorithms\" are rejected\n+ * @library \/test\/lib\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"*\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \".\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \".AES\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"Cipher.\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"A.B\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"KeyStore.MY,.\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"KeyStore.MY,.AES\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"KeyStore.MY,Cipher.\"\n+ * @run main\/othervm InvalidCryptoDisabledAlgos \"KeyStore.MY,A.B\"\n+ *\/\n+import java.security.MessageDigest;\n+import java.security.Security;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+public class InvalidCryptoDisabledAlgos {\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"Invalid Property Value = \" + args[0]);\n+        Security.setProperty(\"jdk.crypto.disabledAlgorithms\", args[0]);\n+        \/\/ Trigger the check to parse and validate property value\n+        Utils.runAndCheckException(() -> MessageDigest.getInstance(\"SHA-512\"),\n+                t -> Asserts.assertTrue(\n+                        t instanceof ExceptionInInitializerError &&\n+                        t.getCause() instanceof IllegalArgumentException));\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Security\/SecurityPropFile\/InvalidCryptoDisabledAlgos.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @library \/test\/lib\n+ * @run main\/othervm TestDisabledAlgorithms SIGNATURe.sha512withRSA true\n+ * @run main\/othervm TestDisabledAlgorithms signaturE.what false\n+ * @run main\/othervm TestDisabledAlgorithms SiGnAtUrE.SHa512\/224withRSA false\n+ *\/\n+import java.util.List;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Signature;\n+import java.security.Provider;\n+import java.security.Security;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+public class TestDisabledAlgorithms {\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static void test(List<String> algos, Provider p,\n+            boolean shouldThrow) throws Exception {\n+\n+        for (String a : algos) {\n+            System.out.println(\"Testing \" + (p != null ? p.getName() : \"\") +\n+                    \": \" + a + \", shouldThrow=\" + shouldThrow);\n+            if (shouldThrow) {\n+                if (p == null) {\n+                    Utils.runAndCheckException(() -> Signature.getInstance(a),\n+                            NoSuchAlgorithmException.class);\n+                } else {\n+                    Utils.runAndCheckException(() -> Signature.getInstance(a, p),\n+                            NoSuchAlgorithmException.class);\n+                }\n+            } else {\n+                Signature s;\n+                if (p == null) {\n+                    s = Signature.getInstance(a);\n+                } else {\n+                    s = Signature.getInstance(a, p);\n+                }\n+                System.out.println(\"Got Signature w\/ algo \" + s.getAlgorithm());\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+\n+        List<String> algos = List.of(\"sha512withRsa\", \"1.2.840.113549.1.1.13\");\n+        \/\/ test w\/o provider\n+        test(algos, null, shouldThrow);\n+\n+        \/\/ test w\/ provider\n+        Provider[] providers = Security.getProviders(\"Signature.SHA512withRSA\");\n+        for (Provider p : providers) {\n+            test(algos, p, shouldThrow);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Signature\/TestDisabledAlgorithms.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @library \/test\/lib\n+ * @run main\/othervm TestDisabledAlgorithms CIPHEr.Rsa\/ECB\/PKCS1Padding true\n+ * @run main\/othervm TestDisabledAlgorithms cipheR.rsA true\n+ * @run main\/othervm TestDisabledAlgorithms CIPher.what false\n+ * @run main\/othervm TestDisabledAlgorithms cipHER.RSA\/ECB\/PKCS1Padding2 false\n+ *\/\n+import java.util.List;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.Signature;\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+public class TestDisabledAlgorithms {\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static final String TARGET = \"Cipher.RSA\/ECB\/PKCS1Padding\";\n+\n+    private static void test(List<String> algos, Provider p,\n+            boolean shouldThrow) throws Exception {\n+\n+        for (String a : algos) {\n+            System.out.println(\"Testing \" + (p != null ? p.getName() : \"\") +\n+                    \": \" + a + \", shouldThrow=\" + shouldThrow);\n+            if (shouldThrow) {\n+                if (p == null) {\n+                    Utils.runAndCheckException(() -> Cipher.getInstance(a),\n+                            NoSuchAlgorithmException.class);\n+                } else {\n+                    Utils.runAndCheckException(() -> Cipher.getInstance(a, p),\n+                            NoSuchAlgorithmException.class);\n+                }\n+            } else {\n+                Cipher c;\n+                if (p == null) {\n+                    c = Cipher.getInstance(a);\n+                } else {\n+                    c = Cipher.getInstance(a, p);\n+                }\n+                System.out.println(\"Got cipher w\/ algo \" + c.getAlgorithm());\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+\n+        List<String> algos = List.of(\"Rsa\/ECB\/PKCS1Padding\", \"rSA\");\n+\n+        \/\/ test w\/o provider\n+        test(algos, null, shouldThrow);\n+\n+        \/\/ test w\/ provider\n+        Provider[] providers = Security.getProviders();\n+        for (Provider p : providers) {\n+            if (p.getService(\"Cipher\", \"RSA\/ECB\/PKCS1Padding\") != null) {\n+                test(algos, p, shouldThrow);\n+            }\n+        }\n+\n+        \/\/ make sure NONEwithRSA signature is still available from SunJCE and\n+        \/\/ SunMSCAPI (windows)\n+        if (shouldThrow) {\n+            System.out.println(\"Testing NONEwithRSA signature support\");\n+            for (String pn : List.of(\"SunJCE\", \"SunMSCAPI\")) {\n+                Provider p = Security.getProvider(pn);\n+                if (p != null) {\n+                    Signature s = Signature.getInstance(\"NONEwithRSA\", p);\n+                    System.out.println(pn + \"=> yes\");\n+                } else {\n+                    System.out.println(pn + \"=> skip; not found\");\n+                }\n+            }\n+        }\n+        System.out.println(\"Done\");\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/TestDisabledAlgorithms.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @library \/test\/lib ..\n+ * @run main\/othervm TestDisabledAlgorithms CiPhEr.RSA\/ECB\/PKCS1Padding true\n+ * @run main\/othervm TestDisabledAlgorithms cIpHeR.rsA true\n+ * @run main\/othervm TestDisabledAlgorithms Cipher.what false\n+ * @run main\/othervm TestDisabledAlgorithms CiPhER.RSA\/ECB\/PKCS1Padding2 false\n+ *\/\n+import java.util.List;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+public class TestDisabledAlgorithms extends PKCS11Test {\n+\n+    boolean shouldThrow;\n+\n+    TestDisabledAlgorithms(boolean shouldThrow) {\n+        this.shouldThrow = shouldThrow;\n+    }\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static void test(String alg, Provider p, boolean shouldThrow)\n+            throws Exception {\n+        System.out.println(\"Testing \" + p.getName() + \": \" + alg +\n+                \", shouldThrow=\" + shouldThrow);\n+        if (shouldThrow) {\n+            Utils.runAndCheckException(() -> Cipher.getInstance(alg, p),\n+                    NoSuchAlgorithmException.class);\n+        } else {\n+            Cipher c = Cipher.getInstance(alg, p);\n+            System.out.println(\"Got cipher w\/ algo \" + c.getAlgorithm());\n+        }\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        for (String a : List.of(\"RSA\/ECB\/PKCS1Padding\", \"RSA\")) {\n+            test(a, p, shouldThrow);\n+        }\n+        System.out.println(\"Done\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+        main(new TestDisabledAlgorithms(shouldThrow), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestDisabledAlgorithms.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.security.*;\n+import java.security.interfaces.*;\n+import java.security.spec.*;\n+import java.util.stream.IntStream;\n+import jtreg.SkippedException;\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test the NONEwithRSA signature refactoring for JCE layer\n+ *     algorithm restriction\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ *\/\n+public class TestNONEwithRSA extends PKCS11Test {\n+\n+    private static final String SIGALG = \"NONEwithRSA\";\n+\n+    private static final int[] KEYSIZES = { 2048, 3072 };\n+    private static final byte[] DATA = generateData(100);\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestNONEwithRSA(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        try {\n+            Signature.getInstance(SIGALG, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            throw new SkippedException(\"Skip due to no support for \" + SIGALG);\n+        }\n+\n+        for (int kSize : KEYSIZES) {\n+            System.out.println(\"[KEYSIZE = \" + kSize + \"]\");\n+            KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\", p);\n+            kpg.initialize(kSize);\n+            KeyPair kp = kpg.generateKeyPair();\n+            PrivateKey privKey = kp.getPrivate();\n+            PublicKey pubKey = kp.getPublic();\n+            checkSignature(p, DATA, pubKey, privKey);\n+        }\n+    }\n+\n+    private static void checkSignature(Provider p, byte[] data, PublicKey pub,\n+            PrivateKey priv)\n+            throws NoSuchAlgorithmException, InvalidKeyException,\n+            SignatureException, NoSuchProviderException,\n+            InvalidAlgorithmParameterException {\n+\n+        Signature sig = Signature.getInstance(SIGALG, p);\n+        sig.initSign(priv);\n+\n+        sig.update(data);\n+        byte[] signedData = sig.sign();\n+\n+        \/\/ Make sure signature verifies with original data\n+        sig.initVerify(pub);\n+        sig.update(data);\n+        if (!sig.verify(signedData)) {\n+            throw new RuntimeException(\"Failed to verify signature\");\n+        }\n+\n+        \/\/ Make sure signature does NOT verify when the original data\n+        \/\/ has changed\n+        sig.initVerify(pub);\n+        sig.update(data);\n+        sig.update(data);\n+        if (sig.verify(signedData)) {\n+            throw new RuntimeException(\"Failed to detect bad signature\");\n+        }\n+        System.out.println(\"    => Passed\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/TestNONEwithRSA.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}