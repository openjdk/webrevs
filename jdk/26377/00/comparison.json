{"files":[{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.security.MessageDigest;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.SignatureSpi;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidParameterException;\n+import java.security.ProviderException;\n+import java.security.SignatureException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.Cipher;\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+\n+\/**\n+ * NONEwithRSA Signature implementation using RSA\/ECB\/PKCS1Padding Cipher\n+ * implementation.\n+ *\n+ * This is mostly refactored from the private static CipherAdapter class\n+ * in the java.security.Signature class\n+ *\/\n+public final class RSACipherAdaptor extends SignatureSpi {\n+\n+    private final RSACipher c;\n+    private ByteArrayOutputStream verifyBuf;\n+\n+    public RSACipherAdaptor() {\n+        c = new RSACipher();\n+    }\n+\n+    protected void engineInitVerify(PublicKey publicKey)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.DECRYPT_MODE, publicKey, null);\n+        if (verifyBuf == null) {\n+            verifyBuf = new ByteArrayOutputStream(128);\n+        } else {\n+            verifyBuf.reset();\n+        }\n+    }\n+\n+    protected void engineInitSign(PrivateKey privateKey)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.ENCRYPT_MODE, privateKey, null);\n+        verifyBuf = null;\n+    }\n+\n+    protected void engineInitSign(PrivateKey privateKey, SecureRandom random)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.ENCRYPT_MODE, privateKey, random);\n+        verifyBuf = null;\n+    }\n+\n+    protected void engineUpdate(byte b) throws SignatureException {\n+        engineUpdate(new byte[] {b}, 0, 1);\n+    }\n+\n+    protected void engineUpdate(byte[] b, int off, int len)\n+            throws SignatureException {\n+        if (verifyBuf != null) {\n+            verifyBuf.write(b, off, len);\n+        } else {\n+            byte[] out = c.engineUpdate(b, off, len);\n+            if ((out != null) && (out.length != 0)) {\n+                throw new SignatureException\n+                       (\"Cipher unexpectedly returned data\");\n+            }\n+        }\n+    }\n+\n+    protected byte[] engineSign() throws SignatureException {\n+        try {\n+            return c.engineDoFinal(null, 0, 0);\n+        } catch (IllegalBlockSizeException | BadPaddingException e) {\n+           throw new SignatureException(\"doFinal() failed\", e);\n+        }\n+    }\n+\n+    protected boolean engineVerify(byte[] sigBytes) throws SignatureException {\n+        try {\n+            byte[] out = c.engineDoFinal(sigBytes, 0, sigBytes.length);\n+            byte[] data = verifyBuf.toByteArray();\n+            verifyBuf.reset();\n+            return MessageDigest.isEqual(out, data);\n+        } catch (BadPaddingException e) {\n+            \/\/ e.g. wrong public key used\n+            \/\/ return false rather than throwing exception\n+            return false;\n+        } catch (IllegalBlockSizeException e) {\n+            throw new SignatureException(\"doFinal() failed\", e);\n+        }\n+    }\n+\n+    protected void engineSetParameter(AlgorithmParameterSpec params)\n+            throws InvalidAlgorithmParameterException {\n+        if (params != null) {\n+            throw new InvalidParameterException(\"Parameters not supported\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    protected void engineSetParameter(String param, Object value)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"Parameters not supported\");\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    protected Object engineGetParameter(String param)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"Parameters not supported\");\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/RSACipherAdaptor.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -139,0 +139,6 @@\n+        attrs.put(\"SupportedKeyClasses\",\n+                \"java.security.interfaces.RSAPublicKey\" +\n+                \"|java.security.interfaces.RSAPrivateKey\");\n+        ps(\"Signature\", \"NONEwithRSA\",\n+                \"com.sun.crypto.provider.RSACipherAdaptor\", null, attrs);\n+        \/\/ continue adding cipher specific attributes\n@@ -150,3 +156,0 @@\n-        attrs.put(\"SupportedKeyClasses\",\n-                \"java.security.interfaces.RSAPublicKey\" +\n-                \"|java.security.interfaces.RSAPrivateKey\");\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.security.util.CryptoAlgorithmConstraints;\n@@ -844,2 +845,3 @@\n-     * The JDK Reference Implementation additionally uses the\n-     * {@code jdk.security.provider.preferred}\n+     * The JDK Reference Implementation additionally uses\n+     * <ul>\n+     * <li>the {@code jdk.security.provider.preferred}\n@@ -847,1 +849,1 @@\n-     * the preferred provider order for the specified algorithm. This\n+     * the preferred provider order for the specified keystore type. This\n@@ -850,0 +852,6 @@\n+     * <\/li>\n+     * <li>the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed.\n+     * <\/li>\n+     * <\/ul>\n@@ -872,0 +880,5 @@\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"KEYSTORE\", type)) {\n+            throw new KeyStoreException(type + \" is disabled\");\n+        }\n+\n@@ -891,0 +904,6 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed.\n+     *\n@@ -920,1 +939,2 @@\n-        if (provider == null || provider.isEmpty())\n+\n+        if (provider == null || provider.isEmpty()) {\n@@ -922,0 +942,6 @@\n+        }\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"KEYSTORE\", type)) {\n+            throw new KeyStoreException(type + \" is disabled\");\n+        }\n+\n@@ -938,0 +964,6 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed.\n+     *\n@@ -966,1 +998,2 @@\n-        if (provider == null)\n+\n+        if (provider == null) {\n@@ -968,0 +1001,6 @@\n+        }\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"KEYSTORE\", type)) {\n+            throw new KeyStoreException(type + \" is disabled\");\n+        }\n+\n@@ -1680,0 +1719,7 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed. Disallowed type will be\n+     * skipped.\n+     *\n@@ -1733,0 +1779,7 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed. Disallowed type will be\n+     * skipped.\n+     *\n@@ -1793,1 +1846,3 @@\n-                    if (s.getType().equals(\"KeyStore\")) {\n+                    if (s.getType().equals(\"KeyStore\") &&\n+                            CryptoAlgorithmConstraints.permits(\"KEYSTORE\",\n+                            s.getAlgorithm())) {\n","filename":"src\/java.base\/share\/classes\/java\/security\/KeyStore.java","additions":61,"deletions":6,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import sun.security.util.CryptoAlgorithmConstraints;\n@@ -158,2 +159,3 @@\n-     * The JDK Reference Implementation additionally uses the\n-     * {@code jdk.security.provider.preferred}\n+     * The JDK Reference Implementation additionally uses\n+     * <ul>\n+     * <li>the {@code jdk.security.provider.preferred}\n@@ -164,0 +166,6 @@\n+     * <\/li>\n+     * <li>the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed.\n+     * <\/li>\n+     * <\/ul>\n@@ -187,1 +195,4 @@\n-        MessageDigest md;\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"MessageDigest\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n+        }\n@@ -191,0 +202,1 @@\n+        MessageDigest md;\n@@ -219,0 +231,6 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed.\n+     *\n@@ -249,1 +267,2 @@\n-        if (provider == null || provider.isEmpty())\n+\n+        if (provider == null || provider.isEmpty()) {\n@@ -251,0 +270,5 @@\n+        }\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"MessageDigest\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n+        }\n@@ -252,1 +276,0 @@\n-        MessageDigest md;\n@@ -255,0 +278,1 @@\n+        MessageDigest md;\n@@ -274,0 +298,6 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed.\n+     *\n@@ -304,1 +334,2 @@\n-        if (provider == null)\n+\n+        if (provider == null) {\n@@ -306,0 +337,6 @@\n+        }\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"MessageDigest\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/security\/MessageDigest.java","additions":43,"deletions":6,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -39,4 +39,0 @@\n-import javax.crypto.Cipher;\n-import javax.crypto.IllegalBlockSizeException;\n-import javax.crypto.BadPaddingException;\n-import javax.crypto.NoSuchPaddingException;\n@@ -47,0 +43,2 @@\n+import sun.security.util.CryptoAlgorithmConstraints;\n+\n@@ -216,14 +214,0 @@\n-    \/\/ name of the special signature alg\n-    private static final String RSA_SIGNATURE = \"NONEwithRSA\";\n-\n-    \/\/ name of the equivalent cipher alg\n-    private static final String RSA_CIPHER = \"RSA\/ECB\/PKCS1Padding\";\n-\n-    \/\/ all the services we need to lookup for compatibility with Cipher\n-    private static final List<ServiceId> rsaIds = List.of(\n-        new ServiceId(\"Signature\", \"NONEwithRSA\"),\n-        new ServiceId(\"Cipher\", \"RSA\/ECB\/PKCS1Padding\"),\n-        new ServiceId(\"Cipher\", \"RSA\/ECB\"),\n-        new ServiceId(\"Cipher\", \"RSA\/\/PKCS1Padding\"),\n-        new ServiceId(\"Cipher\", \"RSA\"));\n-\n@@ -244,2 +228,3 @@\n-     * The JDK Reference Implementation additionally uses the\n-     * {@code jdk.security.provider.preferred}\n+     * The JDK Reference Implementation additionally uses\n+     * <ul>\n+     * <li>the {@code jdk.security.provider.preferred}\n@@ -250,0 +235,6 @@\n+     * <\/li>\n+     * <li>the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed.\n+     * <\/li>\n+     * <\/ul>\n@@ -271,5 +262,3 @@\n-        Iterator<Service> t;\n-        if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {\n-            t = GetInstance.getServices(rsaIds);\n-        } else {\n-            t = GetInstance.getServices(\"Signature\", algorithm);\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"Signature\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n@@ -277,0 +266,2 @@\n+\n+        Iterator<Service> t = GetInstance.getServices(\"Signature\", algorithm);\n@@ -332,4 +323,0 @@\n-        if (s.getType().equals(\"Cipher\")) {\n-            \/\/ must be a CipherSpi, which we can wrap with the CipherAdapter\n-            return true;\n-        }\n@@ -373,0 +360,6 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed.\n+     *\n@@ -401,11 +394,3 @@\n-        if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {\n-            \/\/ exception compatibility with existing code\n-            if (provider == null || provider.isEmpty()) {\n-                throw new IllegalArgumentException(\"missing provider\");\n-            }\n-            Provider p = Security.getProvider(provider);\n-            if (p == null) {\n-                throw new NoSuchProviderException\n-                    (\"no such provider: \" + provider);\n-            }\n-            return getInstanceRSA(p);\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"Signature\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n@@ -413,0 +398,1 @@\n+\n@@ -427,0 +413,6 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed.\n+     *\n@@ -453,6 +445,3 @@\n-        if (algorithm.equalsIgnoreCase(RSA_SIGNATURE)) {\n-            \/\/ exception compatibility with existing code\n-            if (provider == null) {\n-                throw new IllegalArgumentException(\"missing provider\");\n-            }\n-            return getInstanceRSA(provider);\n+\n+        if (!CryptoAlgorithmConstraints.permits(\"Signature\", algorithm)) {\n+            throw new NoSuchAlgorithmException(algorithm + \" is disabled\");\n@@ -460,0 +449,1 @@\n+\n@@ -465,22 +455,0 @@\n-    \/\/ return an implementation for NONEwithRSA, which is a special case\n-    \/\/ because of the Cipher.RSA\/ECB\/PKCS1Padding compatibility wrapper\n-    private static Signature getInstanceRSA(Provider p)\n-            throws NoSuchAlgorithmException {\n-        \/\/ try Signature first\n-        Service s = p.getService(\"Signature\", RSA_SIGNATURE);\n-        if (s != null) {\n-            Instance instance = GetInstance.getInstance(s, SignatureSpi.class);\n-            return getInstance(instance, RSA_SIGNATURE);\n-        }\n-        \/\/ check Cipher\n-        try {\n-            Cipher c = Cipher.getInstance(RSA_CIPHER, p);\n-            return Delegate.of(new CipherAdapter(c), RSA_SIGNATURE);\n-        } catch (GeneralSecurityException e) {\n-            \/\/ throw Signature style exception message to avoid confusion,\n-            \/\/ but append Cipher exception as cause\n-            throw new NoSuchAlgorithmException(\"no such algorithm: \"\n-                + RSA_SIGNATURE + \" for provider \" + p.getName(), e);\n-        }\n-    }\n-\n@@ -1182,15 +1150,4 @@\n-            if (s.getType().equals(\"Cipher\")) {\n-                \/\/ must be NONEwithRSA\n-                try {\n-                    Cipher c = Cipher.getInstance(RSA_CIPHER, s.getProvider());\n-                    return new CipherAdapter(c);\n-                } catch (NoSuchPaddingException e) {\n-                    throw new NoSuchAlgorithmException(e);\n-                }\n-            } else {\n-                Object o = s.newInstance(null);\n-                if (!(o instanceof SignatureSpi)) {\n-                    throw new NoSuchAlgorithmException\n-                        (\"Not a SignatureSpi: \" + o.getClass().getName());\n-                }\n-                return (SignatureSpi)o;\n+            Object o = s.newInstance(null);\n+            if (!(o instanceof SignatureSpi)) {\n+                throw new NoSuchAlgorithmException\n+                    (\"Not a SignatureSpi: \" + o.getClass().getName());\n@@ -1198,0 +1155,1 @@\n+            return (SignatureSpi)o;\n@@ -1474,88 +1432,0 @@\n-\n-    \/\/ adapter for RSA\/ECB\/PKCS1Padding ciphers\n-    @SuppressWarnings(\"deprecation\")\n-    private static class CipherAdapter extends SignatureSpi {\n-\n-        private final Cipher cipher;\n-\n-        private ByteArrayOutputStream data;\n-\n-        CipherAdapter(Cipher cipher) {\n-            this.cipher = cipher;\n-        }\n-\n-        protected void engineInitVerify(PublicKey publicKey)\n-                throws InvalidKeyException {\n-            cipher.init(Cipher.DECRYPT_MODE, publicKey);\n-            if (data == null) {\n-                data = new ByteArrayOutputStream(128);\n-            } else {\n-                data.reset();\n-            }\n-        }\n-\n-        protected void engineInitSign(PrivateKey privateKey)\n-                throws InvalidKeyException {\n-            cipher.init(Cipher.ENCRYPT_MODE, privateKey);\n-            data = null;\n-        }\n-\n-        protected void engineInitSign(PrivateKey privateKey,\n-                SecureRandom random) throws InvalidKeyException {\n-            cipher.init(Cipher.ENCRYPT_MODE, privateKey, random);\n-            data = null;\n-        }\n-\n-        protected void engineUpdate(byte b) throws SignatureException {\n-            engineUpdate(new byte[] {b}, 0, 1);\n-        }\n-\n-        protected void engineUpdate(byte[] b, int off, int len)\n-                throws SignatureException {\n-            if (data != null) {\n-                data.write(b, off, len);\n-                return;\n-            }\n-            byte[] out = cipher.update(b, off, len);\n-            if ((out != null) && (out.length != 0)) {\n-                throw new SignatureException\n-                    (\"Cipher unexpectedly returned data\");\n-            }\n-        }\n-\n-        protected byte[] engineSign() throws SignatureException {\n-            try {\n-                return cipher.doFinal();\n-            } catch (IllegalBlockSizeException | BadPaddingException e) {\n-                throw new SignatureException(\"doFinal() failed\", e);\n-            }\n-        }\n-\n-        protected boolean engineVerify(byte[] sigBytes)\n-                throws SignatureException {\n-            try {\n-                byte[] out = cipher.doFinal(sigBytes);\n-                byte[] dataBytes = data.toByteArray();\n-                data.reset();\n-                return MessageDigest.isEqual(out, dataBytes);\n-            } catch (BadPaddingException e) {\n-                \/\/ e.g. wrong public key used\n-                \/\/ return false rather than throwing exception\n-                return false;\n-            } catch (IllegalBlockSizeException e) {\n-                throw new SignatureException(\"doFinal() failed\", e);\n-            }\n-        }\n-\n-        protected void engineSetParameter(String param, Object value)\n-                throws InvalidParameterException {\n-            throw new InvalidParameterException(\"Parameters not supported\");\n-        }\n-\n-        protected Object engineGetParameter(String param)\n-                throws InvalidParameterException {\n-            throw new InvalidParameterException(\"Parameters not supported\");\n-        }\n-\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/security\/Signature.java","additions":41,"deletions":171,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-\n@@ -49,0 +48,1 @@\n+import sun.security.util.CryptoAlgorithmConstraints;\n@@ -328,0 +328,1 @@\n+\n@@ -369,0 +370,1 @@\n+\n@@ -513,2 +515,3 @@\n-     * The JDK Reference Implementation additionally uses the\n-     * {@code jdk.security.provider.preferred}\n+     * The JDK Reference Implementation additionally uses\n+     * <ul>\n+     * <li>the {@code jdk.security.provider.preferred}\n@@ -522,0 +525,6 @@\n+     * <\/li>\n+     * <li>the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified algorithm is allowed.\n+     * <\/li>\n+     * <\/ul>\n@@ -550,0 +559,7 @@\n+\n+        \/\/ throws NoSuchAlgorithmException if java.security disables it\n+        if (!CryptoAlgorithmConstraints.permits(\"Cipher\", transformation)) {\n+            throw new NoSuchAlgorithmException(transformation +\n+                    \" is disabled\");\n+        }\n+\n@@ -686,0 +702,6 @@\n+     * @implNote\n+     * The JDK Reference Implementation additionally uses\n+     * the {@code jdk.crypto.disabledAlgorithms}\n+     * {@link Security#getProperty(String) Security} property to determine\n+     * if the specified keystore type is allowed.\n+     *\n@@ -723,0 +745,7 @@\n+\n+        \/\/ throws NoSuchAlgorithmException if java.security disables it\n+        if (!CryptoAlgorithmConstraints.permits(\"Cipher\", transformation)) {\n+            throw new NoSuchAlgorithmException(transformation +\n+                    \" is disabled\");\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":32,"deletions":3,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,2 @@\n-        Set<String> algorithmsInPropertySet = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n+        Set<String> algorithmsInPropertySet =\n+                new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n@@ -83,2 +84,3 @@\n-        \/\/ decompose the algorithm into sub-elements\n-        Set<String> elements = decomposer.decompose(algorithm);\n+        if (decomposer != null) {\n+            \/\/ decompose the algorithm into sub-elements\n+            Set<String> elements = decomposer.decompose(algorithm);\n@@ -86,4 +88,5 @@\n-        \/\/ check the element of the elements\n-        for (String element : elements) {\n-            if (algorithms.contains(element)) {\n-                return false;\n+            \/\/ check the element of the elements\n+            for (String element : elements) {\n+                if (algorithms.contains(element)) {\n+                    return false;\n+                }\n@@ -92,1 +95,0 @@\n-\n@@ -95,1 +97,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AbstractAlgorithmConstraints.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.lang.ref.SoftReference;\n+import java.security.AlgorithmParameters;\n+import java.security.CryptoPrimitive;\n+import java.security.Key;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import sun.security.util.KnownOIDs;\n+\n+\/**\n+ * Algorithm constraints for disabled crypto algorithms property\n+ *\n+ * See the \"jdk.crypto.disabledAlgorithms\" specification in java.security\n+ * for the syntax of the disabled algorithm string.\n+ *\/\n+public class CryptoAlgorithmConstraints extends AbstractAlgorithmConstraints {\n+    private static final Debug debug = Debug.getInstance(\"jca\");\n+\n+    private static class CryptoHolder {\n+        static final CryptoAlgorithmConstraints CONSTRAINTS =\n+                new CryptoAlgorithmConstraints(\"jdk.crypto.disabledAlgorithms\");\n+    }\n+\n+    private static void debug(String msg) {\n+        if (debug != null) {\n+            debug.println(\"CryptoAlgoConstraints: \", msg);\n+        }\n+    }\n+\n+    public static final boolean permits(String service, String algo) {\n+        return CryptoHolder.CONSTRAINTS.permits(null, service + \".\" + algo, null);\n+    }\n+\n+    private final Set<String> disabledServices; \/\/ syntax is <service>.<algo>\n+    private volatile SoftReference<Map<String, Boolean>> cacheRef =\n+            new SoftReference<>(null);\n+\n+    \/**\n+     * Initialize algorithm constraints with the specified security property.\n+     *\n+     * @param propertyName the security property name that define the disabled\n+     *        algorithm constraints\n+     *\/\n+    CryptoAlgorithmConstraints(String propertyName) {\n+        super(null);\n+        disabledServices = getAlgorithms(propertyName);\n+        debug(\"Before \" + Arrays.deepToString(disabledServices.toArray()));\n+        for (String dk : disabledServices) {\n+            int idx = dk.indexOf(\".\");\n+            if (idx == -1) {\n+                debug(\"Remove invalid entry: \" + dk);\n+                disabledServices.remove(dk);\n+                continue;\n+            }\n+            String service = dk.substring(0, idx);\n+            String algo = dk.substring(idx + 1);\n+            KnownOIDs oid = KnownOIDs.findMatch(algo);\n+            if (oid != null) {\n+                debug(\"Add oid: \" + oid.value());\n+                disabledServices.add(service + \".\" + oid.value());\n+                debug(\"Add oid stdName: \" + oid.stdName());\n+                disabledServices.add(service + \".\" + oid.stdName());\n+                for (String a : oid.aliases()) {\n+                    debug(\"Add oid alias: \" + a);\n+                    disabledServices.add(service + \".\" + a);\n+                }\n+            }\n+        }\n+        debug(\"After \" + Arrays.deepToString(disabledServices.toArray()));\n+    }\n+\n+    \/*\n+     * This checks if the specified service descriptor is in the\n+     * disabledServices Set. If found, this method return false.\n+     *\/\n+    @Override\n+    public final boolean permits(Set<CryptoPrimitive> notUsed1,\n+            String serviceDesc, AlgorithmParameters notUsed2) {\n+        if (serviceDesc == null || serviceDesc.isEmpty()) {\n+            throw new IllegalArgumentException(\"No algorithm name specified\");\n+        }\n+\n+        return cachedCheckAlgorithm(serviceDesc);\n+    }\n+\n+    @Override\n+    public final boolean permits(Set<CryptoPrimitive> primitives, Key key) {\n+        throw new UnsupportedOperationException(\"Unsupported permits() method\");\n+    }\n+\n+    @Override\n+    public final boolean permits(Set<CryptoPrimitive> primitives,\n+            String algorithm, Key key, AlgorithmParameters parameters) {\n+        throw new UnsupportedOperationException(\"Unsupported permits() method\");\n+    }\n+\n+    \/\/ Return false if algorithm is found in the disabledAlgorithms Set.\n+    \/\/ Otherwise, return true.\n+    private boolean cachedCheckAlgorithm(String serviceDesc) {\n+        Map<String, Boolean> cache;\n+        if ((cache = cacheRef.get()) == null) {\n+            synchronized (this) {\n+                if ((cache = cacheRef.get()) == null) {\n+                    cache = new ConcurrentHashMap<>();\n+                    cacheRef = new SoftReference<>(cache);\n+                }\n+            }\n+        }\n+        Boolean result = cache.get(serviceDesc);\n+        if (result != null) {\n+            return result;\n+        }\n+        \/\/ We won't check patterns if algorithm check fails.\n+        result = checkAlgorithm(disabledServices, serviceDesc, null);\n+        cache.put(serviceDesc, result);\n+        return result;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/CryptoAlgorithmConstraints.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -187,1 +187,1 @@\n-    RSA(\"1.2.840.113549.1.1.1\"), \/\/ RSA encryption\n+    RSA(\"1.2.840.113549.1.1.1\", \"RSA\", \"RSA\/ECB\/PKCS1Padding\"), \/\/ RSA encryption\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -774,0 +774,24 @@\n+#\n+# Algorithm restrictions for Java Crypto API services\n+# The syntax of the disabled services string is described as follows:\n+#       \"DisabledService {, DisabledService}\"\n+#\n+#   DisabledService:\n+#       Service.AlgorithmName\n+#\n+# Service:  (one of the following, more service may be added later)\n+#     Cipher | KeyStore | MessageDigest | Signature\n+#\n+#   AlgorithmName:\n+#       (see below)\n+#\n+# The \"AlgorithmName\" is the standard algorithm name of the disabled\n+# service. See the Java Security Standard Algorithm Names Specification\n+# for information about Standard Algorithm Names.  Matching is\n+# performed using a case-insensitive exact matching rule. For Cipher service,\n+# its algorithm is the transformation string.\n+#\n+# Note: Entries with unsupported services will be ignored\n+#\n+#jdk.crypto.disabledAlgorithms=Cipher.RSA\/ECB\/PKCS1Padding, MessageDigest.MD2\n+\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs11;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.security.MessageDigest;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.SignatureSpi;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidParameterException;\n+import java.security.ProviderException;\n+import java.security.SignatureException;\n+import java.security.spec.AlgorithmParameterSpec;\n+import javax.crypto.Cipher;\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import sun.security.pkcs11.wrapper.PKCS11Exception;\n+\n+\/**\n+ * NONEwithRSA Signature implementation using the RSA\/ECB\/PKCS1Padding Cipher\n+ * implementation also from PKCS11.\n+ *\n+ * This is mostly refactored from the private static CipherAdapter class\n+ * in the java.security.Signature class\n+ *\/\n+public final class RSACipherAdaptor extends SignatureSpi {\n+\n+    private final P11RSACipher c;\n+    private ByteArrayOutputStream verifyBuf;\n+\n+    public RSACipherAdaptor(Token token, long mechanism) {\n+        try {\n+            c = new P11RSACipher(token, \"\", mechanism);\n+            c.engineSetPadding(\"pkcs1padding\");\n+        } catch (PKCS11Exception | NoSuchPaddingException e) {\n+            \/\/ should not happen, but wrap and re-throw if it were to happen\n+            throw new ProviderException(e);\n+        }\n+    }\n+\n+    protected void engineInitVerify(PublicKey publicKey)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.DECRYPT_MODE, publicKey, null);\n+        if (verifyBuf == null) {\n+            verifyBuf = new ByteArrayOutputStream(128);\n+        } else {\n+            verifyBuf.reset();\n+        }\n+    }\n+\n+    protected void engineInitSign(PrivateKey privateKey)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.ENCRYPT_MODE, privateKey, null);\n+        verifyBuf = null;\n+    }\n+\n+    protected void engineInitSign(PrivateKey privateKey, SecureRandom random)\n+            throws InvalidKeyException {\n+        c.engineInit(Cipher.ENCRYPT_MODE, privateKey, random);\n+        verifyBuf = null;\n+    }\n+\n+    protected void engineUpdate(byte b) throws SignatureException {\n+        engineUpdate(new byte[] {b}, 0, 1);\n+    }\n+\n+    protected void engineUpdate(byte[] b, int off, int len)\n+            throws SignatureException {\n+        if (verifyBuf != null) {\n+            verifyBuf.write(b, off, len);\n+        } else {\n+            byte[] out = c.engineUpdate(b, off, len);\n+            if ((out != null) && (out.length != 0)) {\n+                throw new SignatureException\n+                       (\"Cipher unexpectedly returned data\");\n+            }\n+        }\n+    }\n+\n+    protected byte[] engineSign() throws SignatureException {\n+        try {\n+            return c.engineDoFinal(null, 0, 0);\n+        } catch (IllegalBlockSizeException | BadPaddingException e) {\n+           throw new SignatureException(\"doFinal() failed\", e);\n+        }\n+    }\n+\n+    protected boolean engineVerify(byte[] sigBytes) throws SignatureException {\n+        try {\n+            byte[] out = c.engineDoFinal(sigBytes, 0, sigBytes.length);\n+            byte[] data = verifyBuf.toByteArray();\n+            verifyBuf.reset();\n+            return MessageDigest.isEqual(out, data);\n+        } catch (BadPaddingException e) {\n+            \/\/ e.g. wrong public key used\n+            \/\/ return false rather than throwing exception\n+            return false;\n+        } catch (IllegalBlockSizeException e) {\n+            throw new SignatureException(\"doFinal() failed\", e);\n+        }\n+    }\n+\n+    protected void engineSetParameter(AlgorithmParameterSpec params)\n+            throws InvalidAlgorithmParameterException {\n+        if (params != null) {\n+            throw new InvalidParameterException(\"Parameters not supported\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    protected void engineSetParameter(String param, Object value)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"Parameters not supported\");\n+    }\n+\n+    @SuppressWarnings(\"deprecation\")\n+    protected Object engineGetParameter(String param)\n+            throws InvalidParameterException {\n+        throw new InvalidParameterException(\"Parameters not supported\");\n+    }\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/RSACipherAdaptor.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -977,0 +977,2 @@\n+        d(SIG, \"NONEwithRSA\",    \"sun.security.pkcs11.RSACipherAdaptor\",\n+                m(CKM_RSA_PKCS));\n@@ -1428,0 +1430,2 @@\n+                } else if (algorithm.equals(\"NONEwithRSA\")) {\n+                    return new RSACipherAdaptor(token, mechanism);\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @run main\/othervm TestDisabledAlgorithms KeyStore.JKs true\n+ * @run main\/othervm TestDisabledAlgorithms what false\n+ * @run main\/othervm TestDisabledAlgorithms KeyStore.jceKS false\n+ *\/\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.security.KeyStoreException;\n+import java.security.KeyStore;\n+import java.security.KeyStore.PasswordProtection;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.cert.CertificateException;\n+\n+public class TestDisabledAlgorithms {\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    \/\/ reuse existing JKS test keystore\n+    private final static String DIR = System.getProperty(\"test.src\", \".\");\n+    private static final char[] PASSWORD = \"passphrase\".toCharArray();\n+    private static final String KEYSTORE = DIR + \"\/keystore.jks\";\n+\n+    private static void test(List<String> algos, Provider p,\n+            boolean shouldThrow) throws Exception {\n+\n+        for (String a : algos) {\n+            System.out.println(\"Testing \" + (p != null ? p.getName() : \"\") +\n+                    \": \" + a + \", shouldThrow=\" + shouldThrow);\n+            KeyStore k;\n+            if (p == null) {\n+                try {\n+                    k = KeyStore.getInstance(a);\n+                    if (shouldThrow) {\n+                        throw new RuntimeException(\"Expected ex not thrown\");\n+                    }\n+                } catch (KeyStoreException e) {\n+                    if (!shouldThrow) {\n+                        throw new RuntimeException(\"Unexpected ex\", e);\n+                    }\n+                }\n+                try {\n+                    k = KeyStore.getInstance(new File(KEYSTORE), PASSWORD);\n+                    System.out.println(\"Got KeyStore obj w\/ algo \" + k.getType());\n+                    if (shouldThrow) {\n+                        throw new RuntimeException(\"Expected ex not thrown\");\n+                    }\n+                } catch (KeyStoreException e) {\n+                    if (!shouldThrow) {\n+                        throw new RuntimeException(\"Unexpected ex\", e);\n+                    }\n+                }\n+                try {\n+                    k = KeyStore.getInstance(new File(KEYSTORE),\n+                            ()-> {\n+                                return new KeyStore.PasswordProtection(PASSWORD);\n+                            });\n+                    System.out.println(\"Got KeyStore obj w\/ algo \" + k.getType());\n+                    if (shouldThrow) {\n+                        throw new RuntimeException(\"Expected ex not thrown\");\n+                    }\n+                } catch (KeyStoreException e) {\n+                    if (!shouldThrow) {\n+                        throw new RuntimeException(\"Unexpected ex\", e);\n+                    }\n+                }\n+            } else {\n+                try {\n+                    k = KeyStore.getInstance(a, p);\n+                    System.out.println(\"Got KeyStore obj w\/ algo \" + k.getType());\n+                    if (shouldThrow) {\n+                        throw new RuntimeException(\"Expected ex not thrown\");\n+                    }\n+                } catch (KeyStoreException e) {\n+                    if (!shouldThrow) {\n+                        throw new RuntimeException(\"Unexpected ex\", e);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+        Security.getProperty(PROP_NAME).equalsIgnoreCase(\"false\");\n+\n+        List<String> algos = List.of(\"JKS\", \"jkS\");\n+        \/\/ test w\/o provider\n+        test(algos, null, shouldThrow);\n+\n+        \/\/ test w\/ provider\n+        Provider[] providers = Security.getProviders(\"KeyStore.JKS\");\n+        for (Provider p : providers) {\n+            test(algos, p, shouldThrow);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/KeyStore\/TestDisabledAlgorithms.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @run main\/othervm TestDisabledAlgorithms MessageDigest.Sha-512 true\n+ * @run main\/othervm TestDisabledAlgorithms what false\n+ * @run main\/othervm TestDisabledAlgorithms MessagestDigest.SHA-512\/224 false\n+ *\/\n+import java.util.List;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.MessageDigest;\n+import java.security.Provider;\n+import java.security.Security;\n+\n+public class TestDisabledAlgorithms {\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static void test(List<String> algos, Provider p,\n+            boolean shouldThrow) {\n+\n+        for (String a : algos) {\n+            System.out.println(\"Testing \" + (p != null ? p.getName() : \"\") +\n+                    \": \" + a + \", shouldThrow=\" + shouldThrow);\n+            try {\n+                MessageDigest m;\n+                if (p == null) {\n+                    m = MessageDigest.getInstance(a);\n+                } else {\n+                    m = MessageDigest.getInstance(a, p);\n+                }\n+                System.out.println(\"Got MessageDigest obj w\/ algo \" +\n+                        m.getAlgorithm());\n+                if (shouldThrow) {\n+                    throw new RuntimeException(\"Expected ex not thrown\");\n+                }\n+            } catch (NoSuchAlgorithmException e) {\n+                if (!shouldThrow) {\n+                    throw new RuntimeException(\"Unexpected ex\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+        Security.getProperty(PROP_NAME).equalsIgnoreCase(\"false\");\n+\n+        List<String> algos = List.of(\"sHA-512\", \"shA-512\", \"2.16.840.1.101.3.4.2.3\");\n+        \/\/ test w\/o provider\n+        test(algos, null, shouldThrow);\n+\n+        \/\/ test w\/ provider\n+        Provider[] providers = Security.getProviders(\"MessageDigest.SHA-512\");\n+        for (Provider p : providers) {\n+            test(algos, p, shouldThrow);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/MessageDigest\/TestDisabledAlgorithms.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @run main\/othervm TestDisabledAlgorithms Signature.sha512withRSA true\n+ * @run main\/othervm TestDisabledAlgorithms what false\n+ * @run main\/othervm TestDisabledAlgorithms Signature.SHA512\/224withRSA false\n+ *\/\n+import java.util.List;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Signature;\n+import java.security.Provider;\n+import java.security.Security;\n+\n+public class TestDisabledAlgorithms {\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static void test(List<String> algos, Provider p,\n+            boolean shouldThrow) {\n+\n+        for (String a : algos) {\n+            System.out.println(\"Testing \" + (p != null ? p.getName() : \"\") +\n+                    \": \" + a + \", shouldThrow=\" + shouldThrow);\n+            try {\n+                Signature s;\n+                if (p == null) {\n+                    s = Signature.getInstance(a);\n+                } else {\n+                    s = Signature.getInstance(a, p);\n+                }\n+                System.out.println(\"Got Signature obj w\/ algo \" +\n+                        s.getAlgorithm());\n+                if (shouldThrow) {\n+                    throw new RuntimeException(\"Expected ex not thrown\");\n+                }\n+            } catch (NoSuchAlgorithmException e) {\n+                if (!shouldThrow) {\n+                    throw new RuntimeException(\"Unexpected ex\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+        Security.getProperty(PROP_NAME).equalsIgnoreCase(\"false\");\n+\n+        List<String> algos = List.of(\"sha512withRsa\", \"1.2.840.113549.1.1.13\");\n+        \/\/ test w\/o provider\n+        test(algos, null, shouldThrow);\n+\n+        \/\/ test w\/ provider\n+        Provider[] providers = Security.getProviders(\"Signature.SHA512withRSA\");\n+        for (Provider p : providers) {\n+            test(algos, p, shouldThrow);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/security\/Signature\/TestDisabledAlgorithms.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @run main\/othervm TestDisabledAlgorithms Cipher.Rsa\/ECB\/PKCS1Padding true\n+ * @run main\/othervm TestDisabledAlgorithms Cipher.rsA true\n+ * @run main\/othervm TestDisabledAlgorithms what false\n+ * @run main\/othervm TestDisabledAlgorithms Cipher.RSA\/ECB\/PKCS1Padding2 false\n+ *\/\n+import java.util.List;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import java.security.Signature;\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+public class TestDisabledAlgorithms {\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static final String TARGET = \"Cipher.RSA\/ECB\/PKCS1Padding\";\n+\n+    private static void test(List<String> algos, Provider p,\n+            boolean shouldThrow) {\n+\n+        for (String a : algos) {\n+            System.out.println(\"Testing \" + (p != null ? p.getName() : \"\") +\n+                    \": \" + a + \", shouldThrow=\" + shouldThrow);\n+            try {\n+                Cipher c;\n+                if (p == null) {\n+                    c = Cipher.getInstance(a);\n+                } else {\n+                    c = Cipher.getInstance(a, p);\n+                }\n+                System.out.println(\"Got cipher obj w\/ algo \" +\n+                        c.getAlgorithm());\n+                if (shouldThrow) {\n+                    throw new RuntimeException(\"Expected ex not thrown\");\n+                }\n+            } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n+                if (!shouldThrow) {\n+                    throw new RuntimeException(\"Unexpected ex\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+\n+        List<String> algos = List.of(\"Rsa\/ECB\/PKCS1Padding\", \"rSA\");\n+\n+        \/\/ test w\/o provider\n+        test(algos, null, shouldThrow);\n+\n+        \/\/ test w\/ provider\n+        Provider[] providers = Security.getProviders();\n+        for (Provider p : providers) {\n+            if (p.getService(\"Cipher\", \"RSA\/ECB\/PKCS1Padding\") != null) {\n+                test(algos, p, shouldThrow);\n+            }\n+        }\n+\n+        \/\/ make sure NONEwithRSA signature is still available from SunJCE and\n+        \/\/ SunMSCAPI (windows)\n+        if (shouldThrow) {\n+            System.out.println(\"Testing NONEwithRSA signature support\");\n+            for (String pn : List.of(\"SunJCE\", \"SunMSCAPI\")) {\n+                Provider p = Security.getProvider(pn);\n+                if (p != null) {\n+                    Signature s = Signature.getInstance(\"NONEwithRSA\", p);\n+                    System.out.println(pn + \"=> yes\");\n+                } else {\n+                    System.out.println(pn + \"=> skip; not found\");\n+                }\n+            }\n+        }\n+        System.out.println(\"Done\");\n+    }\n+}\n","filename":"test\/jdk\/javax\/crypto\/Cipher\/TestDisabledAlgorithms.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test JCE layer algorithm restriction\n+ * @library \/test\/lib ..\n+ * @run main\/othervm TestDisabledAlgorithms Cipher.RSA\/ECB\/PKCS1Padding true\n+ * @run main\/othervm TestDisabledAlgorithms Cipher.rsA true\n+ * @run main\/othervm TestDisabledAlgorithms what false\n+ * @run main\/othervm TestDisabledAlgorithms Cipher.RSA\/ECB\/PKCS1Padding2 false\n+ *\/\n+import java.util.List;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.Security;\n+import javax.crypto.Cipher;\n+import javax.crypto.NoSuchPaddingException;\n+\n+public class TestDisabledAlgorithms extends PKCS11Test {\n+\n+    boolean shouldThrow;\n+\n+    TestDisabledAlgorithms(boolean shouldThrow) {\n+        this.shouldThrow = shouldThrow;\n+    }\n+\n+    private static final String PROP_NAME = \"jdk.crypto.disabledAlgorithms\";\n+\n+    private static void test(String alg, Provider p, boolean shouldThrow) {\n+        System.out.println(\"Testing \" + p.getName() + \": \" + alg +\n+                \", shouldThrow=\" + shouldThrow);\n+        try {\n+            Cipher c = Cipher.getInstance(alg, p);\n+            System.out.println(\"Got cipher obj w\/ algo \" + c.getAlgorithm());\n+            if (shouldThrow) {\n+                throw new RuntimeException(\"Expected ex not thrown\");\n+            }\n+        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n+            if (!shouldThrow) {\n+                throw new RuntimeException(\"Unexpected ex\", e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        for (String a : List.of(\"RSA\/ECB\/PKCS1Padding\", \"RSA\")) {\n+            test(a, p, shouldThrow);\n+        }\n+        System.out.println(\"Done\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        String propValue = args[0];\n+        System.out.println(\"Setting Security Prop \" + PROP_NAME + \" = \" +\n+                propValue);\n+        Security.setProperty(PROP_NAME, propValue);\n+        boolean shouldThrow = Boolean.valueOf(args[1]);\n+        main(new TestDisabledAlgorithms(shouldThrow), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestDisabledAlgorithms.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.security.*;\n+import java.security.interfaces.*;\n+import java.security.spec.*;\n+import java.util.stream.IntStream;\n+import jtreg.SkippedException;\n+\n+\/**\n+ * @test\n+ * @bug 8244336\n+ * @summary Test the NONEwithRSA signature refactoring for JCE layer\n+ *     algorithm restriction\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ *\/\n+public class TestNONEwithRSA extends PKCS11Test {\n+\n+    private static final String SIGALG = \"NONEwithRSA\";\n+\n+    private static final int[] KEYSIZES = { 2048, 3072 };\n+    private static final byte[] DATA = generateData(100);\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestNONEwithRSA(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        try {\n+            Signature.getInstance(SIGALG, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            throw new SkippedException(\"Skip due to no support for \" + SIGALG);\n+        }\n+\n+        for (int kSize : KEYSIZES) {\n+            System.out.println(\"[KEYSIZE = \" + kSize + \"]\");\n+            KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"RSA\", p);\n+            kpg.initialize(kSize);\n+            KeyPair kp = kpg.generateKeyPair();\n+            PrivateKey privKey = kp.getPrivate();\n+            PublicKey pubKey = kp.getPublic();\n+            checkSignature(p, DATA, pubKey, privKey);\n+        }\n+    }\n+\n+    private static void checkSignature(Provider p, byte[] data, PublicKey pub,\n+            PrivateKey priv)\n+            throws NoSuchAlgorithmException, InvalidKeyException,\n+            SignatureException, NoSuchProviderException,\n+            InvalidAlgorithmParameterException {\n+\n+        Signature sig = Signature.getInstance(SIGALG, p);\n+        sig.initSign(priv);\n+\n+        sig.update(data);\n+        byte[] signedData = sig.sign();\n+\n+        \/\/ Make sure signature verifies with original data\n+        sig.initVerify(pub);\n+        sig.update(data);\n+        if (!sig.verify(signedData)) {\n+            throw new RuntimeException(\"Failed to verify signature\");\n+        }\n+\n+        \/\/ Make sure signature does NOT verify when the original data\n+        \/\/ has changed\n+        sig.initVerify(pub);\n+        sig.update(data);\n+        sig.update(data);\n+        if (sig.verify(signedData)) {\n+            throw new RuntimeException(\"Failed to detect bad signature\");\n+        }\n+        System.out.println(\"    => Passed\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Signature\/TestNONEwithRSA.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}