{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.Optional;\n@@ -38,1 +39,2 @@\n-import com.sun.tools.javac.code.TypeMetadata.Entry;\n+import com.sun.tools.javac.code.TypeMetadata.Annotations;\n+import com.sun.tools.javac.code.TypeMetadata.ConstantValue;\n@@ -89,9 +91,1 @@\n-    protected final TypeMetadata metadata;\n-\n-    public TypeMetadata getMetadata() {\n-        return metadata;\n-    }\n-\n-    public Entry getMetadataOfKind(final Entry.Kind kind) {\n-        return metadata != null ? metadata.get(kind) : null;\n-    }\n+    protected final List<TypeMetadata> metadata;\n@@ -191,1 +185,2 @@\n-        return null;\n+        return getMetadata(TypeMetadata.ConstantValue.class)\n+                .map(ConstantValue::value).orElse(null);\n@@ -233,1 +228,1 @@\n-    public Type(TypeSymbol tsym, TypeMetadata metadata) {\n+    public Type(TypeSymbol tsym, List<TypeMetadata> metadata) {\n@@ -348,1 +343,1 @@\n-        return metadata == TypeMetadata.EMPTY ? this : baseType();\n+        return metadata.isEmpty() ? this : baseType();\n@@ -353,0 +348,27 @@\n+     * Only to be used internally!\n+     *\/\n+    protected Type cloneWithMetadata(List<TypeMetadata> metadata) {\n+        throw new AssertionError(\"Cannot add metadata to this type: \" + getTag());\n+    }\n+\n+    \/**\n+     * Get all the type metadata associated with this type.\n+     *\/\n+    public List<TypeMetadata> getMetadata() {\n+        return metadata;\n+    }\n+\n+    \/**\n+     * Get the type metadata of the given kind associated with this type (if any).\n+     *\/\n+    public <M extends TypeMetadata> Optional<M> getMetadata(Class<M> metadataClass) {\n+        return metadata.stream()\n+                .filter(m -> metadataClass.isAssignableFrom(m.getClass()))\n+                .map(metadataClass::cast)\n+                .findFirst();\n+    }\n+\n+    \/**\n+     * Create a new copy of this type but with the specified type metadata.\n+     * If this type is already associated with a type metadata of the same class,\n+     * an exception is thrown.\n@@ -354,1 +376,14 @@\n-    public abstract Type cloneWithMetadata(TypeMetadata metadata);\n+    public Type addMetadata(TypeMetadata md) {\n+        Assert.check(getMetadata(md.getClass()).isEmpty());\n+        return cloneWithMetadata(metadata.append(md));\n+    }\n+\n+    \/**\n+     * Create a new copy of this type but without the specified type metadata.\n+     *\/\n+    public Type dropMetadata(Class<? extends TypeMetadata> metadataClass) {\n+        List<TypeMetadata> newMetadata = metadata.stream()\n+                .filter(m -> !metadataClass.isAssignableFrom(m.getClass()))\n+                .collect(List.collector());\n+        return cloneWithMetadata(newMetadata);\n+    }\n@@ -401,0 +436,4 @@\n+    public Type preannotatedType() {\n+        return addMetadata(new Annotations());\n+    }\n+\n@@ -402,2 +441,1 @@\n-        final Entry annoMetadata = new TypeMetadata.Annotations(annos);\n-        return cloneWithMetadata(metadata.combine(annoMetadata));\n+        return addMetadata(new Annotations(annos));\n@@ -407,4 +445,1 @@\n-        final TypeMetadata.Annotations metadata =\n-            (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);\n-\n-        return null != metadata && !metadata.getAnnotations().isEmpty();\n+        return getMetadata(TypeMetadata.Annotations.class).isPresent();\n@@ -415,4 +450,2 @@\n-        final TypeMetadata.Annotations metadata =\n-            (TypeMetadata.Annotations)getMetadataOfKind(Entry.Kind.ANNOTATIONS);\n-\n-        return metadata == null ? List.nil() : metadata.getAnnotations();\n+        return getMetadata(TypeMetadata.Annotations.class)\n+                .map(Annotations::annotations).orElse(List.nil());\n@@ -691,1 +724,1 @@\n-            this(tag, tsym, TypeMetadata.EMPTY);\n+            this(tag, tsym, List.nil());\n@@ -694,1 +727,1 @@\n-        private JCPrimitiveType(TypeTag tag, TypeSymbol tsym, TypeMetadata metadata) {\n+        private JCPrimitiveType(TypeTag tag, TypeSymbol tsym, List<TypeMetadata> metadata) {\n@@ -701,1 +734,1 @@\n-        public JCPrimitiveType cloneWithMetadata(TypeMetadata md) {\n+        protected JCPrimitiveType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -747,11 +780,1 @@\n-            final Object value = constValue;\n-            return new JCPrimitiveType(tag, tsym, metadata) {\n-                    @Override\n-                    public Object constValue() {\n-                        return value;\n-                    }\n-                    @Override\n-                    public Type baseType() {\n-                        return tsym.type;\n-                    }\n-                };\n+            return addMetadata(new ConstantValue(constValue));\n@@ -832,1 +855,1 @@\n-            this(type, kind, tsym, null, TypeMetadata.EMPTY);\n+            this(type, kind, tsym, null, List.nil());\n@@ -836,1 +859,1 @@\n-                            TypeMetadata metadata) {\n+                            List<TypeMetadata> metadata) {\n@@ -842,1 +865,1 @@\n-            this(type, kind, tsym, bound, TypeMetadata.EMPTY);\n+            this(type, kind, tsym, bound, List.nil());\n@@ -846,1 +869,1 @@\n-                            TypeVar bound, TypeMetadata metadata) {\n+                            TypeVar bound, List<TypeMetadata> metadata) {\n@@ -854,1 +877,1 @@\n-        public WildcardType cloneWithMetadata(TypeMetadata md) {\n+        protected WildcardType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -981,1 +1004,1 @@\n-            this(outer, typarams, tsym, TypeMetadata.EMPTY);\n+            this(outer, typarams, tsym, List.nil());\n@@ -985,1 +1008,1 @@\n-                         TypeMetadata metadata) {\n+                         List<TypeMetadata> metadata) {\n@@ -999,1 +1022,1 @@\n-        public ClassType cloneWithMetadata(TypeMetadata md) {\n+        protected ClassType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -1017,11 +1040,1 @@\n-            final Object value = constValue;\n-            return new ClassType(getEnclosingType(), typarams_field, tsym, metadata) {\n-                    @Override\n-                    public Object constValue() {\n-                        return value;\n-                    }\n-                    @Override\n-                    public Type baseType() {\n-                        return tsym.type;\n-                    }\n-                };\n+            return addMetadata(new ConstantValue(constValue));\n@@ -1193,1 +1206,1 @@\n-                               TypeMetadata metadata) {\n+                               List<TypeMetadata> metadata) {\n@@ -1218,5 +1231,0 @@\n-        @Override\n-        public UnionClassType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a union type\");\n-        }\n-\n@@ -1274,5 +1282,0 @@\n-        @Override\n-        public IntersectionClassType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to an intersection type\");\n-        }\n-\n@@ -1321,1 +1324,1 @@\n-            this(elemtype, arrayClass, TypeMetadata.EMPTY);\n+            this(elemtype, arrayClass, List.nil());\n@@ -1325,1 +1328,1 @@\n-                         TypeMetadata metadata) {\n+                         List<TypeMetadata> metadata) {\n@@ -1341,1 +1344,1 @@\n-        public ArrayType cloneWithMetadata(TypeMetadata md) {\n+        protected ArrayType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -1466,1 +1469,1 @@\n-            super(methodClass, TypeMetadata.EMPTY);\n+            super(methodClass, List.nil());\n@@ -1472,5 +1475,0 @@\n-        @Override\n-        public MethodType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a method type\");\n-        }\n-\n@@ -1563,6 +1561,1 @@\n-            super(tsym, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public PackageType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a package type\");\n+            super(tsym, List.nil());\n@@ -1601,6 +1594,1 @@\n-            super(tsym, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public ModuleType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a module type\");\n+            super(tsym, List.nil());\n@@ -1662,1 +1650,1 @@\n-            super(null, TypeMetadata.EMPTY);\n+            super(null, List.nil());\n@@ -1670,1 +1658,1 @@\n-            this(tsym, bound, lower, TypeMetadata.EMPTY);\n+            this(tsym, bound, lower, List.nil());\n@@ -1674,1 +1662,1 @@\n-                       TypeMetadata metadata) {\n+                       List<TypeMetadata> metadata) {\n@@ -1682,1 +1670,1 @@\n-        public TypeVar cloneWithMetadata(TypeMetadata md) {\n+        protected TypeVar cloneWithMetadata(List<TypeMetadata> md) {\n@@ -1765,1 +1753,1 @@\n-                            TypeMetadata metadata) {\n+                            List<TypeMetadata> metadata) {\n@@ -1771,1 +1759,1 @@\n-        public CapturedType cloneWithMetadata(TypeMetadata md) {\n+        protected CapturedType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -1810,1 +1798,1 @@\n-            this(tag, qtype, TypeMetadata.EMPTY);\n+            this(tag, qtype, List.nil());\n@@ -1814,1 +1802,1 @@\n-                             TypeMetadata metadata) {\n+                             List<TypeMetadata> metadata) {\n@@ -1847,5 +1835,0 @@\n-        @Override\n-        public ForAll cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a forall type\");\n-        }\n-\n@@ -2080,5 +2063,0 @@\n-        @Override\n-        public UndetVar cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to an UndetVar type\");\n-        }\n-\n@@ -2227,6 +2205,1 @@\n-            super(null, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public JCNoType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a JCNoType\");\n+            super(null, List.nil());\n@@ -2260,6 +2233,1 @@\n-            super(null, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public JCVoidType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a void type\");\n+            super(null, List.nil());\n@@ -2295,6 +2263,1 @@\n-            super(null, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public BottomType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a bottom type\");\n+            super(null, List.nil());\n@@ -2357,1 +2320,1 @@\n-                          TypeMetadata metadata) {\n+                          List<TypeMetadata> metadata) {\n@@ -2364,1 +2327,1 @@\n-        public ErrorType cloneWithMetadata(TypeMetadata md) {\n+        protected ErrorType cloneWithMetadata(List<TypeMetadata> md) {\n@@ -2435,6 +2398,1 @@\n-            super(null, TypeMetadata.EMPTY);\n-        }\n-\n-        @Override\n-        public UnknownType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to an unknown type\");\n+            super(null, List.nil());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":92,"deletions":134,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.tools.javac.util.Assert;\n@@ -30,3 +29,1 @@\n-import java.util.EnumMap;\n-import java.util.HashSet;\n-import java.util.Set;\n+import com.sun.tools.javac.util.ListBuffer;\n@@ -35,8 +32,15 @@\n- * TypeMetadata is essentially an immutable {@code EnumMap<Entry.Kind, <? extends Entry>>}\n- *\n- * A metadata class represented by a subtype of Entry can express a property on a Type instance.\n- * There should be at most one instance of an Entry per Entry.Kind on any given Type instance.\n- *\n- * Metadata classes of a specific kind are responsible for how they combine themselves.\n- *\n- * @implNote {@code Entry:combine} need not be commutative.\n+ * A type metadata is an object that can be stapled on a type. This is typically done using\n+ * {@link Type#addMetadata(TypeMetadata)}. Metadata associated to a type can also be removed,\n+ * typically using {@link Type#dropMetadata(Class)}. To drop <em>all<\/em> metadata from a given type,\n+ * the {@link Type#baseType()} method can also be used. This can be useful when comparing two\n+ * using reference equality (see also {@link Type#equalsIgnoreMetadata(Type)}).\n+ * <p>\n+ * There are no constraints on how a type metadata should be defined. Typically, a type\n+ * metadata will be defined as a small record, storing additional information (see {@link ConstantValue}).\n+ * In other cases, type metadata can be mutable and support complex state transitions\n+ * (see {@link Annotations}).\n+ * <p>\n+ * The only invariant the implementation requires is that there must be <em>one<\/em> metadata\n+ * of a given kind attached to a type, as this makes accessing and dropping metadata simpler.\n+ * If clients wish to store multiple metadata values that are logically related, they should\n+ * define a metadata type that collects such values in e.g. a list.\n@@ -44,32 +48,1 @@\n-public class TypeMetadata {\n-    public static final TypeMetadata EMPTY = new TypeMetadata();\n-\n-    private final EnumMap<Entry.Kind, Entry> contents;\n-\n-    \/**\n-     * Create a new empty TypeMetadata map.\n-     *\/\n-    private TypeMetadata() {\n-        contents = new EnumMap<>(Entry.Kind.class);\n-    }\n-\n-    \/**\n-     * Create a new TypeMetadata map containing the Entry {@code elem}.\n-     *\n-     * @param elem the sole contents of this map\n-     *\/\n-    public TypeMetadata(Entry elem) {\n-        this();\n-        Assert.checkNonNull(elem);\n-        contents.put(elem.kind(), elem);\n-    }\n-\n-    \/**\n-     * Creates a copy of TypeMetadata {@code other} with a shallow copy the other's metadata contents.\n-     *\n-     * @param other the TypeMetadata to copy contents from.\n-     *\/\n-    public TypeMetadata(TypeMetadata other) {\n-        Assert.checkNonNull(other);\n-        contents = other.contents.clone();\n-    }\n+public sealed interface TypeMetadata {\n@@ -78,5 +51,6 @@\n-     * Return a copy of this TypeMetadata with the metadata entry for {@code elem.kind()} combined\n-     * with {@code elem}.\n-     *\n-     * @param elem the new value\n-     * @return a new TypeMetadata updated with {@code Entry elem}\n+     * A type metadata object holding type annotations. This metadata needs to be mutable,\n+     * because type annotations are sometimes set in two steps. That is, a type can be created with\n+     * an empty set of annotations (e.g. during member enter). At some point later, the type\n+     * is then updated to contain the correct annotations. At this point we need to augment\n+     * the existing type (rather than creating a new one), as the type might already have been\n+     * saved inside other symbols.\n@@ -84,2 +58,1 @@\n-    public TypeMetadata combine(Entry elem) {\n-        Assert.checkNonNull(elem);\n+    record Annotations(ListBuffer<Attribute.TypeCompound> annotationBuffer) implements TypeMetadata {\n@@ -87,6 +60,2 @@\n-        TypeMetadata out = new TypeMetadata(this);\n-        Entry.Kind key = elem.kind();\n-        if (contents.containsKey(key)) {\n-            out.add(key, this.contents.get(key).combine(elem));\n-        } else {\n-            out.add(key, elem);\n+        Annotations() {\n+            this(new ListBuffer<>());\n@@ -94,2 +63,0 @@\n-        return out;\n-    }\n@@ -97,24 +64,3 @@\n-    \/**\n-     * Return a copy of this TypeMetadata with the metadata entry for all kinds from {@code other}\n-     * combined with the same kind from this.\n-     *\n-     * @param other the TypeMetadata to combine with this\n-     * @return a new TypeMetadata updated with all entries from {@code other}\n-     *\/\n-    public TypeMetadata combineAll(TypeMetadata other) {\n-        Assert.checkNonNull(other);\n-\n-        TypeMetadata out = new TypeMetadata();\n-        Set<Entry.Kind> keys = new HashSet<>(contents.keySet());\n-        keys.addAll(other.contents.keySet());\n-\n-        for(Entry.Kind key : keys) {\n-            if (contents.containsKey(key)) {\n-                if (other.contents.containsKey(key)) {\n-                    out.add(key, contents.get(key).combine(other.contents.get(key)));\n-                } else {\n-                    out.add(key, contents.get(key));\n-                }\n-            } else if (other.contents.containsKey(key)) {\n-                out.add(key, other.contents.get(key));\n-            }\n+        Annotations(List<Attribute.TypeCompound> annotations) {\n+            this();\n+            annotationBuffer.appendList(annotations);\n@@ -122,2 +68,0 @@\n-        return out;\n-    }\n@@ -125,29 +69,2 @@\n-    \/**\n-     * Return a TypeMetadata with the metadata entry for {@code kind} removed.\n-     *\n-     * This may be the same instance or a new TypeMetadata.\n-     *\n-     * @param kind the {@code Kind} to remove metadata for\n-     * @return a new TypeMetadata without {@code Kind kind}\n-     *\/\n-    public TypeMetadata without(Entry.Kind kind) {\n-        if (this == EMPTY || contents.get(kind) == null)\n-            return this;\n-\n-        TypeMetadata out = new TypeMetadata(this);\n-        out.contents.remove(kind);\n-        return out.contents.isEmpty() ? EMPTY : out;\n-    }\n-\n-    public Entry get(Entry.Kind kind) {\n-        return contents.get(kind);\n-    }\n-\n-    private void add(Entry.Kind kind, Entry elem) {\n-        contents.put(kind, elem);\n-    }\n-\n-    public interface Entry {\n-\n-        public enum Kind {\n-            ANNOTATIONS\n+        List<Attribute.TypeCompound> annotations() {\n+            return annotationBuffer.toList();\n@@ -155,14 +72,0 @@\n-\n-        \/**\n-         * Get the kind of metadata this object represents\n-         *\/\n-        public Kind kind();\n-\n-        \/**\n-         * Combine this type metadata with another metadata of the\n-         * same kind.\n-         *\n-         * @param other The metadata with which to combine this one.\n-         * @return The combined metadata.\n-         *\/\n-        public Entry combine(Entry other);\n@@ -172,1 +75,2 @@\n-     * A type metadata object holding type annotations.\n+     * A type metadata holding a constant value. This can be used to describe constant types,\n+     * such as the type of a string literal, or that of a numeric constant.\n@@ -174,31 +78,1 @@\n-    public static class Annotations implements Entry {\n-        private List<Attribute.TypeCompound> annos;\n-\n-        public static final List<Attribute.TypeCompound> TO_BE_SET = List.nil();\n-\n-        public Annotations(List<Attribute.TypeCompound> annos) {\n-            this.annos = annos;\n-        }\n-\n-        \/**\n-         * Get the type annotations contained in this metadata.\n-         *\n-         * @return The annotations.\n-         *\/\n-        public List<Attribute.TypeCompound> getAnnotations() {\n-            return annos;\n-        }\n-\n-        @Override\n-        public Annotations combine(Entry other) {\n-            Assert.check(annos == TO_BE_SET);\n-            annos = ((Annotations)other).annos;\n-            return this;\n-        }\n-\n-        @Override\n-        public Kind kind() { return Kind.ANNOTATIONS; }\n-\n-        @Override\n-        public String toString() { return \"ANNOTATIONS [ \" + annos + \" ]\"; }\n-    }\n+    record ConstantValue(Object value) implements TypeMetadata { }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeMetadata.java","additions":35,"deletions":161,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;\n+import com.sun.tools.javac.code.TypeMetadata.Annotations;\n@@ -2402,1 +2402,1 @@\n-                if (t.getMetadata() != TypeMetadata.EMPTY) {\n+                if (t.getMetadata().nonEmpty()) {\n@@ -2413,1 +2413,1 @@\n-                        default: return s.cloneWithMetadata(s.getMetadata().without(Kind.ANNOTATIONS));\n+                        default: return s.dropMetadata(Annotations.class);\n@@ -2440,1 +2440,1 @@\n-                            t.getMetadata().without(Kind.ANNOTATIONS));\n+                            t.dropMetadata(Annotations.class).getMetadata());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-import com.sun.tools.javac.code.TypeMetadata.Entry.Kind;\n+import com.sun.tools.javac.code.TypeMetadata.Annotations;\n@@ -1052,1 +1052,4 @@\n-            storeAt.getMetadataOfKind(Kind.ANNOTATIONS).combine(new TypeMetadata.Annotations(compounds));\n+            \/\/ the type already has annotation metadata, but it's empty\n+            Annotations metadata = storeAt.getMetadata(Annotations.class).orElseThrow(AssertionError::new);\n+            Assert.check(metadata.annotationBuffer().isEmpty());\n+            metadata.annotationBuffer().appendList(compounds);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-import com.sun.tools.javac.code.TypeMetadata.Annotations;\n@@ -5213,1 +5212,1 @@\n-        Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);\n+        Type annotatedType = underlyingType.preannotatedType();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-            super(null, TypeMetadata.EMPTY);\n+            super(null, List.nil());\n@@ -230,5 +230,0 @@\n-        @Override\n-        public DeferredType cloneWithMetadata(TypeMetadata md) {\n-            throw new AssertionError(\"Cannot add metadata to a deferred type\");\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/DeferredAttr.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2928,1 +2928,1 @@\n-            super(syms.noSymbol, TypeMetadata.EMPTY);\n+            super(syms.noSymbol, List.nil());\n@@ -2937,5 +2937,0 @@\n-        @Override\n-        public Type cloneWithMetadata(TypeMetadata metadata) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-                              TypeMetadata metadata) {\n+                              List<TypeMetadata> metadata) {\n@@ -62,1 +62,1 @@\n-    public UninitializedType cloneWithMetadata(final TypeMetadata md) {\n+    protected UninitializedType cloneWithMetadata(final List<TypeMetadata> md) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/UninitializedType.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}