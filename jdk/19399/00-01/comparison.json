{"files":[{"patch":"@@ -27,29 +27,29 @@\n- *         <p>Provides the classes which implement advanced dynamic\n- *       loading.  See the chapter <em>Advanced Dynamic Loading<\/em> in\n- *       the <a href=\"#spec\">JMX Specification<\/a>.<\/p>\n- *\n- *         <p>An MBean that is of a subclass of {@link\n- *       java.lang.ClassLoader} can be used as a class loader to create\n- *       other MBeans via the method {@link\n- *       javax.management.MBeanServer#createMBean(String, ObjectName,\n- *       ObjectName, Object[], String[])}, and to instantiate arbitrary\n- *       objects via the method {@link\n- *       javax.management.MBeanServer#instantiate(String, ObjectName,\n- *       Object[], String[])}.<\/p>\n- *\n- *         <p>Every MBean Server has a <em>class loader repository<\/em>\n- *       containing all MBeans registered in that MBean Server that\n- *       are of a subclass of {@link java.lang.ClassLoader}.  The class\n- *       loader repository is used by the forms of the\n- *       <code>createMBean<\/code> and <code>instantiate<\/code> methods\n- *       in the {@link javax.management.MBeanServer MBeanServer}\n- *       interface that do not have an explicit loader parameter.<\/p>\n- *\n- *         <p>If an MBean implements the interface {@link\n- *       javax.management.loading.PrivateClassLoader PrivateClassLoader},\n- *       then it is not added to the class loader repository.<\/p>\n- *\n- *       @see <a id=\"spec\" href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n- *         JMX Specification, version 1.4<\/a>\n- *\n- *         @since 1.5\n+ * <p>Provides the classes which implement advanced dynamic\n+ * loading.  See the chapter <em>Advanced Dynamic Loading<\/em> in\n+ * the <a href=\"#spec\">JMX Specification<\/a>.<\/p>\n+ *\n+ * <p>An MBean that is of a subclass of {@link\n+ * java.lang.ClassLoader} can be used as a class loader to create\n+ * other MBeans via the method {@link\n+ * javax.management.MBeanServer#createMBean(String, ObjectName,\n+ * ObjectName, Object[], String[])}, and to instantiate arbitrary\n+ * objects via the method {@link\n+ * javax.management.MBeanServer#instantiate(String, ObjectName,\n+ * Object[], String[])}.<\/p>\n+ *\n+ * <p>Every MBean Server has a <em>class loader repository<\/em>\n+ * containing all MBeans registered in that MBean Server that\n+ * are of a subclass of {@link java.lang.ClassLoader}.  The class\n+ * loader repository is used by the forms of the\n+ * <code>createMBean<\/code> and <code>instantiate<\/code> methods\n+ * in the {@link javax.management.MBeanServer MBeanServer}\n+ * interface that do not have an explicit loader parameter.<\/p>\n+ *\n+ * <p>If an MBean implements the interface {@link\n+ * javax.management.loading.PrivateClassLoader PrivateClassLoader},\n+ * then it is not added to the class loader repository.<\/p>\n+ *\n+ * @see <a id=\"spec\" href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n+ * JMX Specification, version 1.4<\/a>\n+ *\n+ * @since 1.5\n","filename":"src\/java.management\/share\/classes\/javax\/management\/loading\/package-info.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -28,41 +28,41 @@\n- *     <p>Provides the definition of the ModelMBean classes.  A Model\n- *       MBean is an MBean that acts as a bridge between the management\n- *       interface and the underlying managed resource.  Both the\n- *       management interface and the managed resource are specified as\n- *       Java objects.  The same Model MBean implementation can be\n- *       reused many times with different management interfaces and\n- *       managed resources, and it can provide common functionality\n- *       such as persistence and caching.<\/p>\n- *\n- *     <p>A Model MBean implements the {@link\n- *       javax.management.modelmbean.ModelMBean ModelMBean} interface.\n- *       It is a {@link javax.management.DynamicMBean DynamicMBean}\n- *       whose {@link javax.management.DynamicMBean#getMBeanInfo()\n- *       getMBeanInfo} method returns an object implementing {@link\n- *       javax.management.modelmbean.ModelMBeanInfo\n- *       ModelMBeanInfo}.<\/p>\n- *\n- *     <p>Every MBean has an {@link javax.management.MBeanInfo\n- *       MBeanInfo} with information about the MBean itself, and its\n- *       attributes, operations, constructors, and notifications.  A\n- *       Model MBean augments this <code>MBeanInfo<\/code> with {@link\n- *       javax.management.Descriptor Descriptor}s that encode\n- *       additional information in the form of (key,value) pairs.\n- *       Usually, <code>Descriptor<\/code>s are instances of {@link\n- *       javax.management.modelmbean.DescriptorSupport\n- *       DescriptorSupport}.<\/p>\n- *\n- *     <p>The class {@link\n- *       javax.management.modelmbean.RequiredModelMBean\n- *       RequiredModelMBean} provides a standard Model MBean\n- *       implementation.<\/p>\n- *\n- *     <p>The following example shows a Model MBean being used to make\n- *       the <code>get<\/code> method of a <code>HashMap<\/code>\n- *       available for management through an MBean server.  No other\n- *       methods are available through the MBean server.  There is\n- *       nothing special about <code>HashMap<\/code> here.  Public\n- *       methods from any public class can be exposed for management in\n- *       the same way.<\/p>\n- *\n- *     <pre>\n+ * <p>Provides the definition of the ModelMBean classes.  A Model\n+ * MBean is an MBean that acts as a bridge between the management\n+ * interface and the underlying managed resource.  Both the\n+ * management interface and the managed resource are specified as\n+ * Java objects.  The same Model MBean implementation can be\n+ * reused many times with different management interfaces and\n+ * managed resources, and it can provide common functionality\n+ * such as persistence and caching.<\/p>\n+ *\n+ * <p>A Model MBean implements the {@link\n+ * javax.management.modelmbean.ModelMBean ModelMBean} interface.\n+ * It is a {@link javax.management.DynamicMBean DynamicMBean}\n+ * whose {@link javax.management.DynamicMBean#getMBeanInfo()\n+ * getMBeanInfo} method returns an object implementing {@link\n+ * javax.management.modelmbean.ModelMBeanInfo\n+ * ModelMBeanInfo}.<\/p>\n+ *\n+ * <p>Every MBean has an {@link javax.management.MBeanInfo\n+ * MBeanInfo} with information about the MBean itself, and its\n+ * attributes, operations, constructors, and notifications.  A\n+ * Model MBean augments this <code>MBeanInfo<\/code> with {@link\n+ * javax.management.Descriptor Descriptor}s that encode\n+ * additional information in the form of (key,value) pairs.\n+ * Usually, <code>Descriptor<\/code>s are instances of {@link\n+ * javax.management.modelmbean.DescriptorSupport\n+ * DescriptorSupport}.<\/p>\n+ *\n+ * <p>The class {@link\n+ * javax.management.modelmbean.RequiredModelMBean\n+ * RequiredModelMBean} provides a standard Model MBean\n+ * implementation.<\/p>\n+ *\n+ * <p>The following example shows a Model MBean being used to make\n+ * the <code>get<\/code> method of a <code>HashMap<\/code>\n+ * available for management through an MBean server.  No other\n+ * methods are available through the MBean server.  There is\n+ * nothing special about <code>HashMap<\/code> here.  Public\n+ * methods from any public class can be exposed for management in\n+ * the same way.<\/p>\n+ *\n+ * <pre>\n@@ -110,1 +110,1 @@\n- *     <h2><a id=\"spec\">Package Specification<\/a><\/h2>\n+ * <h2><a id=\"spec\">Package Specification<\/a><\/h2>\n@@ -112,5 +112,5 @@\n- *     <ul>\n- *       <li>See the <i>JMX 1.4 Specification<\/i>\n- *          <a href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n- *              JMX Specification, version 1.4<\/a>\n- *     <\/ul>\n+ * <ul>\n+ *   <li>See the <i>JMX 1.4 Specification<\/i>\n+ *      <a href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n+ *          JMX Specification, version 1.4<\/a>\n+ * <\/ul>\n@@ -118,1 +118,1 @@\n- *     @since 1.5\n+ * @since 1.5\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/package-info.java","additions":48,"deletions":48,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -27,159 +27,159 @@\n- *       <p>Provides the definition of the monitor classes.  A Monitor is\n- *       an MBean that periodically observes the value of an attribute in\n- *       one or more other MBeans.  If the attribute meets a certain\n- *       condition, the Monitor emits a {@link\n- *       javax.management.monitor.MonitorNotification\n- *       MonitorNotification}. When the monitor MBean periodically calls\n- *       {@link javax.management.MBeanServer#getAttribute getAttribute}\n- *       to retrieve the value of the attribute being monitored it does\n- *       so within the access control context of the\n- *       {@link javax.management.monitor.Monitor#start} caller.<\/p>\n- *\n- *       <p id=\"complex\">The value being monitored can be a simple value\n- *       contained within a complex type. For example, the {@link\n- *       java.lang.management.MemoryMXBean MemoryMXBean} defined in\n- *       {@code java.lang.management} has an attribute\n- *       {@code HeapMemoryUsage} of type {@link\n- *       java.lang.management.MemoryUsage MemoryUsage}. To monitor the\n- *       amount of <i>used<\/i> memory, described by the {@code used}\n- *       property of {@code MemoryUsage}, you could monitor\n- *       \"{@code HeapMemoryUsage.used}\". That string would be the\n- *       argument to {@link\n- *       javax.management.monitor.MonitorMBean#setObservedAttribute(String)\n- *       setObservedAttribute}.<\/p>\n- *\n- *       <p>The rules used to interpret an {@code ObservedAttribute} like\n- *       {@code \"HeapMemoryUsage.used\"} are as follows. Suppose the string is\n- *       <i>A.e<\/i> (so <i>A<\/i> would be {@code \"HeapMemoryUsage\"} and <i>e<\/i>\n- *       would be {@code \"used\"} in the example).<\/p>\n- *\n- *       <p>First the value of the attribute <i>A<\/i> is obtained. Call it\n- *       <i>v<\/i>. A value <i>x<\/i> is extracted from <i>v<\/i> as follows:<\/p>\n- *\n- *       <ul>\n- *\n- *       <li>If <i>v<\/i> is a {@link javax.management.openmbean.CompositeData\n- *       CompositeData} and if <i>v<\/i>.{@link\n- *       javax.management.openmbean.CompositeData#get(String) get}(<i>e<\/i>)\n- *       returns a value then <i>x<\/i> is that value.<\/li>\n- *       <li>If <i>v<\/i> is an array and <i>e<\/i> is the string {@code \"length\"}\n- *       then <i>x<\/i> is the length of the array.<\/li>\n- *\n- *       <li>If the above rules do not produce a value, and if introspection, as\n- *       if by calling <a href=\"{@docRoot}\/java.desktop\/java\/beans\/Introspector.html#getBeanInfo(java.lang.Class)\">Introspector.getBeanInfo<\/a>\n- *       , for the class of <i>v<\/i>\n- *       (<i>v<\/i>.{@code getClass()}) identifies a property with the name\n- *       <i>e<\/i>, then <i>x<\/i> is the result of reading the property value. <\/li>\n- *\n- *       <\/ul>\n- *\n- *       <p>The third rule means for example that if the attribute\n- *       {@code HeapMemoryUsage} is a {@code MemoryUsage}, monitoring\n- *       {@code \"HeapMemoryUsage.used\"} will obtain the observed value by\n- *       calling {@code MemoryUsage.getUsed()}.<\/p>\n- *\n- *       <p>If the {@code ObservedAttribute} contains more than one period,\n- *       for example {@code \"ConnectionPool.connectionStats.length\"}, then the\n- *       above rules are applied iteratively. Here, <i>v<\/i> would initially be\n- *       the value of the attribute {@code ConnectionPool}, and <i>x<\/i> would\n- *       be derived by applying the above rules with <i>e<\/i> equal to\n- *       {@code \"connectionStats\"}. Then <i>v<\/i> would be set to this <i>x<\/i>\n- *       and a new <i>x<\/i> derived by applying the rules again with <i>e<\/i>\n- *       equal to {@code \"length\"}.<\/p>\n- *\n- *       <p>Although it is recommended that attribute names be valid Java\n- *       identifiers, it is possible for an attribute to be called\n- *       {@code HeapMemoryUsage.used}. This means that an\n- *       {@code ObservedAttribute} that is {@code HeapMemoryUsage.used}\n- *       could mean that the value to observe is either an attribute of that\n- *       name, or the property {@code used} within an attribute called\n- *       {@code HeapMemoryUsage}. So for compatibility reasons, when the\n- *       {@code ObservedAttribute} contains a period ({@code .}), the monitor\n- *       will check whether an attribute exists whose name is the full\n- *       {@code ObservedAttribute} string ({@code HeapMemoryUsage.used} in the\n- *       example). It does this by calling {@link\n- *       javax.management.MBeanServer#getMBeanInfo(javax.management.ObjectName)\n- *       getMBeanInfo} for the observed MBean and looking for a contained {@link\n- *       javax.management.MBeanAttributeInfo MBeanAttributeInfo} with the given\n- *       name. If one is found, then that is what is monitored. If more than one\n- *       MBean is being observed, the behavior is unspecified if some of them have\n- *       a {@code HeapMemoryUsage.used} attribute and others do not. An\n- *       implementation may therefore call {@code getMBeanInfo} on just one of\n- *       the MBeans in this case. The behavior is also unspecified if the result\n- *       of the check changes while the monitor is active.<\/p>\n- *\n- *       <p>The exact behavior of monitors is detailed in the\n- *     <a href=\"#spec\">JMX Specification<\/a>.  What follows is a\n- *     summary.<\/p>\n- *\n- *       <p>There are three kinds of Monitors:<\/p>\n- *\n- *       <ul>\n- *     <li>\n- *\n- *       <p>A {@link javax.management.monitor.CounterMonitor\n- *         CounterMonitor} observes attributes of integer\n- *         type.  The attributes are assumed to be non-negative, and\n- *         monotonically increasing except for a possible\n- *         <em>roll-over<\/em> at a specified <em>modulus<\/em>.  Each\n- *         observed attribute has an associated <em>threshold<\/em>\n- *         value.  A notification is sent when the attribute exceeds\n- *         its threshold.<\/p>\n- *\n- *       <p>An <em>offset<\/em> value can be specified.  When an\n- *         observed value exceeds its threshold, the threshold is\n- *         incremented by the offset, or by a multiple of the offset\n- *         sufficient to make the threshold greater than the new\n- *         observed value.<\/p>\n- *\n- *       <p>A <code>CounterMonitor<\/code> can operate in\n- *         <em>difference mode<\/em>.  In this mode, the value\n- *         compared against the threshold is the difference between\n- *         two successive observations of an attribute.<\/p>\n- *\n- *     <\/li>\n- *     <li>\n- *\n- *       <p>A {@link javax.management.monitor.GaugeMonitor\n- *         GaugeMonitor} observes attributes of numerical type.  Each\n- *         observed attribute has an associated <em>high\n- *           threshold<\/em> and <em>low threshold<\/em>.<\/p>\n- *\n- *       <p>When an observed attribute crosses the high threshold, if\n- *         the <em>notify high<\/em> flag is true, then a notification\n- *         is sent.  Subsequent crossings of the high threshold value\n- *         will not trigger further notifications until the gauge value\n- *         becomes less than or equal to the low threshold.<\/p>\n- *\n- *       <p>When an observed attribute crosses the low threshold, if\n- *         the <em>notify low<\/em> flag is true, then a notification\n- *         is sent.  Subsequent crossings of the low threshold value\n- *         will not trigger further notifications until the gauge\n- *         value becomes greater than or equal to the high\n- *         threshold.<\/p>\n- *\n- *       <p>Typically, only one of the notify high and notify low\n- *         flags is set.  The other threshold is used to provide a\n- *         <em>hysteresis<\/em> mechanism to avoid the repeated\n- *         triggering of notifications when an attribute makes small\n- *         oscillations around the threshold value.<\/p>\n- *\n- *       <p>A <code>GaugeMonitor<\/code> can operate in <em>difference\n- *           mode<\/em>.  In this mode, the value compared against the\n- *         high and low thresholds is the difference between two\n- *         successive observations of an attribute.<\/p>\n- *\n- *     <\/li>\n- *     <li>\n- *\n- *       <p>A {@link javax.management.monitor.StringMonitor\n- *         StringMonitor} observes attributes of type\n- *         <code>String<\/code>.  A notification is sent when an\n- *         observed attribute becomes equal and\/or not equal to a\n- *         given string.<\/p>\n- *\n- *     <\/li>\n- *       <\/ul>\n- *     @see <a id=\"spec\" href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n- *       JMX Specification, version 1.4<\/a>\n- *       @since 1.5\n+ * <p>Provides the definition of the monitor classes.  A Monitor is\n+ * an MBean that periodically observes the value of an attribute in\n+ * one or more other MBeans.  If the attribute meets a certain\n+ * condition, the Monitor emits a {@link\n+ * javax.management.monitor.MonitorNotification\n+ * MonitorNotification}. When the monitor MBean periodically calls\n+ * {@link javax.management.MBeanServer#getAttribute getAttribute}\n+ * to retrieve the value of the attribute being monitored it does\n+ * so within the access control context of the\n+ * {@link javax.management.monitor.Monitor#start} caller.<\/p>\n+ *\n+ * <p id=\"complex\">The value being monitored can be a simple value\n+ * contained within a complex type. For example, the {@link\n+ * java.lang.management.MemoryMXBean MemoryMXBean} defined in\n+ * {@code java.lang.management} has an attribute\n+ * {@code HeapMemoryUsage} of type {@link\n+ * java.lang.management.MemoryUsage MemoryUsage}. To monitor the\n+ * amount of <i>used<\/i> memory, described by the {@code used}\n+ * property of {@code MemoryUsage}, you could monitor\n+ * \"{@code HeapMemoryUsage.used}\". That string would be the\n+ * argument to {@link\n+ * javax.management.monitor.MonitorMBean#setObservedAttribute(String)\n+ * setObservedAttribute}.<\/p>\n+ *\n+ * <p>The rules used to interpret an {@code ObservedAttribute} like\n+ * {@code \"HeapMemoryUsage.used\"} are as follows. Suppose the string is\n+ * <i>A.e<\/i> (so <i>A<\/i> would be {@code \"HeapMemoryUsage\"} and <i>e<\/i>\n+ * would be {@code \"used\"} in the example).<\/p>\n+ *\n+ * <p>First the value of the attribute <i>A<\/i> is obtained. Call it\n+ * <i>v<\/i>. A value <i>x<\/i> is extracted from <i>v<\/i> as follows:<\/p>\n+ *\n+ *   <ul>\n+ *\n+ *   <li>If <i>v<\/i> is a {@link javax.management.openmbean.CompositeData\n+ *   CompositeData} and if <i>v<\/i>.{@link\n+ *   javax.management.openmbean.CompositeData#get(String) get}(<i>e<\/i>)\n+ *   returns a value then <i>x<\/i> is that value.<\/li>\n+ *   <li>If <i>v<\/i> is an array and <i>e<\/i> is the string {@code \"length\"}\n+ *   then <i>x<\/i> is the length of the array.<\/li>\n+ *\n+ *   <li>If the above rules do not produce a value, and if introspection, as\n+ *   if by calling <a href=\"{@docRoot}\/java.desktop\/java\/beans\/Introspector.html#getBeanInfo(java.lang.Class)\">Introspector.getBeanInfo<\/a>\n+ *   , for the class of <i>v<\/i>\n+ *   (<i>v<\/i>.{@code getClass()}) identifies a property with the name\n+ *   <i>e<\/i>, then <i>x<\/i> is the result of reading the property value. <\/li>\n+ *\n+ *   <\/ul>\n+ *\n+ *   <p>The third rule means for example that if the attribute\n+ *   {@code HeapMemoryUsage} is a {@code MemoryUsage}, monitoring\n+ *   {@code \"HeapMemoryUsage.used\"} will obtain the observed value by\n+ *   calling {@code MemoryUsage.getUsed()}.<\/p>\n+ *\n+ *   <p>If the {@code ObservedAttribute} contains more than one period,\n+ *   for example {@code \"ConnectionPool.connectionStats.length\"}, then the\n+ *   above rules are applied iteratively. Here, <i>v<\/i> would initially be\n+ *   the value of the attribute {@code ConnectionPool}, and <i>x<\/i> would\n+ *   be derived by applying the above rules with <i>e<\/i> equal to\n+ *   {@code \"connectionStats\"}. Then <i>v<\/i> would be set to this <i>x<\/i>\n+ *   and a new <i>x<\/i> derived by applying the rules again with <i>e<\/i>\n+ *   equal to {@code \"length\"}.<\/p>\n+ *\n+ *   <p>Although it is recommended that attribute names be valid Java\n+ *   identifiers, it is possible for an attribute to be called\n+ *   {@code HeapMemoryUsage.used}. This means that an\n+ *   {@code ObservedAttribute} that is {@code HeapMemoryUsage.used}\n+ *   could mean that the value to observe is either an attribute of that\n+ *   name, or the property {@code used} within an attribute called\n+ *   {@code HeapMemoryUsage}. So for compatibility reasons, when the\n+ *   {@code ObservedAttribute} contains a period ({@code .}), the monitor\n+ *   will check whether an attribute exists whose name is the full\n+ *   {@code ObservedAttribute} string ({@code HeapMemoryUsage.used} in the\n+ *   example). It does this by calling {@link\n+ *   javax.management.MBeanServer#getMBeanInfo(javax.management.ObjectName)\n+ *   getMBeanInfo} for the observed MBean and looking for a contained {@link\n+ *   javax.management.MBeanAttributeInfo MBeanAttributeInfo} with the given\n+ *   name. If one is found, then that is what is monitored. If more than one\n+ *   MBean is being observed, the behavior is unspecified if some of them have\n+ *   a {@code HeapMemoryUsage.used} attribute and others do not. An\n+ *   implementation may therefore call {@code getMBeanInfo} on just one of\n+ *   the MBeans in this case. The behavior is also unspecified if the result\n+ *   of the check changes while the monitor is active.<\/p>\n+ *\n+ *   <p>The exact behavior of monitors is detailed in the\n+ * <a href=\"#spec\">JMX Specification<\/a>.  What follows is a\n+ * summary.<\/p>\n+ *\n+ *   <p>There are three kinds of Monitors:<\/p>\n+ *\n+ *   <ul>\n+ * <li>\n+ *\n+ *   <p>A {@link javax.management.monitor.CounterMonitor\n+ *     CounterMonitor} observes attributes of integer\n+ *     type.  The attributes are assumed to be non-negative, and\n+ *     monotonically increasing except for a possible\n+ *     <em>roll-over<\/em> at a specified <em>modulus<\/em>.  Each\n+ *     observed attribute has an associated <em>threshold<\/em>\n+ *     value.  A notification is sent when the attribute exceeds\n+ *     its threshold.<\/p>\n+ *\n+ *   <p>An <em>offset<\/em> value can be specified.  When an\n+ *     observed value exceeds its threshold, the threshold is\n+ *     incremented by the offset, or by a multiple of the offset\n+ *     sufficient to make the threshold greater than the new\n+ *     observed value.<\/p>\n+ *\n+ *   <p>A <code>CounterMonitor<\/code> can operate in\n+ *     <em>difference mode<\/em>.  In this mode, the value\n+ *     compared against the threshold is the difference between\n+ *     two successive observations of an attribute.<\/p>\n+ *\n+ * <\/li>\n+ * <li>\n+ *\n+ *   <p>A {@link javax.management.monitor.GaugeMonitor\n+ *     GaugeMonitor} observes attributes of numerical type.  Each\n+ *     observed attribute has an associated <em>high\n+ *       threshold<\/em> and <em>low threshold<\/em>.<\/p>\n+ *\n+ *   <p>When an observed attribute crosses the high threshold, if\n+ *     the <em>notify high<\/em> flag is true, then a notification\n+ *     is sent.  Subsequent crossings of the high threshold value\n+ *     will not trigger further notifications until the gauge value\n+ *     becomes less than or equal to the low threshold.<\/p>\n+ *\n+ *   <p>When an observed attribute crosses the low threshold, if\n+ *     the <em>notify low<\/em> flag is true, then a notification\n+ *     is sent.  Subsequent crossings of the low threshold value\n+ *     will not trigger further notifications until the gauge\n+ *     value becomes greater than or equal to the high\n+ *     threshold.<\/p>\n+ *\n+ *   <p>Typically, only one of the notify high and notify low\n+ *     flags is set.  The other threshold is used to provide a\n+ *     <em>hysteresis<\/em> mechanism to avoid the repeated\n+ *     triggering of notifications when an attribute makes small\n+ *     oscillations around the threshold value.<\/p>\n+ *\n+ *   <p>A <code>GaugeMonitor<\/code> can operate in <em>difference\n+ *       mode<\/em>.  In this mode, the value compared against the\n+ *     high and low thresholds is the difference between two\n+ *     successive observations of an attribute.<\/p>\n+ *\n+ * <\/li>\n+ * <li>\n+ *\n+ *   <p>A {@link javax.management.monitor.StringMonitor\n+ *     StringMonitor} observes attributes of type\n+ *     <code>String<\/code>.  A notification is sent when an\n+ *     observed attribute becomes equal and\/or not equal to a\n+ *     given string.<\/p>\n+ *\n+ * <\/li>\n+ *   <\/ul>\n+ * @see <a id=\"spec\" href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n+ *   JMX Specification, version 1.4<\/a>\n+ *   @since 1.5\n","filename":"src\/java.management\/share\/classes\/javax\/management\/monitor\/package-info.java","additions":159,"deletions":159,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -27,118 +27,118 @@\n- *     <p>Provides the open data types and Open MBean descriptor classes.\n- *       An <em>Open MBean<\/em> is an MBean where the types of attributes\n- *       and of operation parameters and return values are built using a\n- *       small set of predefined Java classes.  Open MBeans facilitate\n- *       operation with remote management programs that do not necessarily\n- *       have access to application-specific types, including non-Java\n- *       programs.<\/p>\n- *\n- *     <p>Every MBean has an {@link javax.management.MBeanInfo\n- *       MBeanInfo} with information about the MBean itself, and its\n- *       attributes, operations, constructors, and notifications.  In an\n- *       Open MBean, this <code>MBeanInfo<\/code> implements the {@link\n- *       javax.management.openmbean.OpenMBeanInfo OpenMBeanInfo}\n- *       interface, usually by being an instance of {@link\n- *       javax.management.openmbean.OpenMBeanInfoSupport\n- *       OpenMBeanInfoSupport}.<\/p>\n- *\n- *     <p>The attribute information returned by {@link\n- *       javax.management.MBeanInfo#getAttributes()\n- *       MBeanInfo.getAttributes} for an Open MBean is an array of\n- *       objects implementing {@link\n- *       javax.management.openmbean.OpenMBeanAttributeInfo\n- *       OpenMBeanAttributeInfo}, usually instances of {@link\n- *       javax.management.openmbean.OpenMBeanAttributeInfoSupport\n- *       OpenMBeanAttributeInfoSupport}.  In addition to the usual\n- *       information about attributes, an\n- *       <code>OpenMBeanAttributeInfo<\/code> specifies the {@link\n- *       javax.management.openmbean.OpenType OpenType} of the attribute.\n- *       The possible <code>OpenType<\/code> values are predefined, which\n- *       is what ensures that remote managers will understand them.<\/p>\n- *\n- *     <p>Similar remarks apply to the parameter types of operations and\n- *       constructors, and to the return types of operations.<\/p>\n- *\n- *     <p>There is a distinction between an attribute's Java language\n- *       type, as returned by {@link\n- *       javax.management.MBeanAttributeInfo#getType() getType()}, and\n- *       its <code>OpenType<\/code>, as returned by {@link\n- *       javax.management.openmbean.OpenMBeanAttributeInfo#getOpenType()\n- *       getOpenType()}.  For example, if the Java language type is\n- *       <code>java.lang.String<\/code>, the <code>OpenType<\/code> will be\n- *       {@link javax.management.openmbean.SimpleType#STRING\n- *       SimpleType.String}.  If the Java language type is {@link\n- *       javax.management.openmbean.CompositeData}, the\n- *       <code>OpenType<\/code> will be a {@link\n- *       javax.management.openmbean.CompositeType CompositeType} that\n- *       describes the items in the <code>CompositeData<\/code> instances\n- *       for the attribute.<\/p>\n- *\n- *     <h2><a id=\"constraints\">Default values and constraints<\/a><\/h2>\n- *\n- *     <p>In Open MBeans, attributes and parameters can have default values\n- *       and\/or constraints associated with them in the {@code\n- *       OpenMBeanAttributeInfo} or {@code OpenMBeanParameterInfo}.\n- *       There are two ways to specify these constraints.  Either the\n- *       values are directly specified as parameters to one of the\n- *       constructors of {@code OpenMBeanAttributeInfoSupport} or\n- *       {@code OpenMBeanParameterInfoSupport}, for example\n- *       {@link\n- *       javax.management.openmbean.OpenMBeanParameterInfoSupport#OpenMBeanParameterInfoSupport(\n- *       String, String, OpenType, Object, Object[])}; or the values are\n- *       specified in a {@link javax.management.Descriptor Descriptor} given\n- *       as a parameter to one of the constructors.<\/p>\n- *\n- *     <p>When a {@code Descriptor} is used, the fields of interest are\n- *       these:<\/p>\n- *\n- *     <ul>\n- *\n- *       <li>{@code defaultValue} defines the value returned by\n- *     {@link javax.management.openmbean.OpenMBeanParameterInfo#getDefaultValue()\n- *     getDefaultValue()};\n- *\n- *       <li>{@code minValue} defines the value returned by {@link\n- *     javax.management.openmbean.OpenMBeanParameterInfo#getMinValue() getMinValue()};\n- *\n- *       <li>{@code maxValue} defines the value returned by {@link\n- *     javax.management.openmbean.OpenMBeanParameterInfo#getMaxValue() getMaxValue()};\n- *\n- *       <li>{@code legalValues} defines the values returned by {@link\n- *     javax.management.openmbean.OpenMBeanParameterInfo#getLegalValues() getLegalValues()}.\n- *\n- *     <\/ul>\n- *\n- *     <p>For {@code defaultValue}, {@code minValue}, and {@code\n- *       maxValue}, the associated value must either be of the Java type\n- *       corresponding to {@code openType}, or be a string that can be\n- *       converted into that type.  The conversion uses the static method\n- *       {@code valueOf(String)} if it finds one; otherwise a constructor\n- *       with a single {@code String} parameter if it finds one; otherwise\n- *       it fails.<\/p>\n- *\n- *     <p>For {@code legalValues}, the associated value must be either\n- *       an array or a {@code Set}, and the elements of the array or set\n- *       must be convertible as described for {@code defaultValue} etc.<\/p>\n- *\n- *     <p>The following conditions must be met for these fields:<\/p>\n- *\n- *     <ul>\n- *       <li>the values must be of the appropriate type, or be strings\n- *     that can be converted to the appropriate type as explained\n- *     above;\n- *\n- *       <li>if {@code legalValues} is present then neither {@code\n- *     minValue} nor {@code maxValue} must be present;\n- *\n- *       <li>if {@code defaultValue} is present then it must satisfy the\n- *     constraints defined by {@code legalValues}, {@code minValue}, or\n- *     {@code maxValue} when any of these is also present;\n- *\n- *       <li>if {@code minValue} and {@code maxValue} are both present\n- *     then {@code minValue} must not be greater than {@code maxValue}.\n- *     <\/ul>\n- *\n- *     @see <a href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n- *       JMX Specification, version 1.4<\/a>\n- *\n- *     @since 1.5\n+ * <p>Provides the open data types and Open MBean descriptor classes.\n+ * An <em>Open MBean<\/em> is an MBean where the types of attributes\n+ * and of operation parameters and return values are built using a\n+ * small set of predefined Java classes.  Open MBeans facilitate\n+ * operation with remote management programs that do not necessarily\n+ * have access to application-specific types, including non-Java\n+ * programs.<\/p>\n+ *\n+ * <p>Every MBean has an {@link javax.management.MBeanInfo\n+ * MBeanInfo} with information about the MBean itself, and its\n+ * attributes, operations, constructors, and notifications.  In an\n+ * Open MBean, this <code>MBeanInfo<\/code> implements the {@link\n+ * javax.management.openmbean.OpenMBeanInfo OpenMBeanInfo}\n+ * interface, usually by being an instance of {@link\n+ * javax.management.openmbean.OpenMBeanInfoSupport\n+ * OpenMBeanInfoSupport}.<\/p>\n+ *\n+ * <p>The attribute information returned by {@link\n+ * javax.management.MBeanInfo#getAttributes()\n+ * MBeanInfo.getAttributes} for an Open MBean is an array of\n+ * objects implementing {@link\n+ * javax.management.openmbean.OpenMBeanAttributeInfo\n+ * OpenMBeanAttributeInfo}, usually instances of {@link\n+ * javax.management.openmbean.OpenMBeanAttributeInfoSupport\n+ * OpenMBeanAttributeInfoSupport}.  In addition to the usual\n+ * information about attributes, an\n+ * <code>OpenMBeanAttributeInfo<\/code> specifies the {@link\n+ * javax.management.openmbean.OpenType OpenType} of the attribute.\n+ * The possible <code>OpenType<\/code> values are predefined, which\n+ * is what ensures that remote managers will understand them.<\/p>\n+ *\n+ * <p>Similar remarks apply to the parameter types of operations and\n+ * constructors, and to the return types of operations.<\/p>\n+ *\n+ * <p>There is a distinction between an attribute's Java language\n+ * type, as returned by {@link\n+ * javax.management.MBeanAttributeInfo#getType() getType()}, and\n+ * its <code>OpenType<\/code>, as returned by {@link\n+ * javax.management.openmbean.OpenMBeanAttributeInfo#getOpenType()\n+ * getOpenType()}.  For example, if the Java language type is\n+ * <code>java.lang.String<\/code>, the <code>OpenType<\/code> will be\n+ * {@link javax.management.openmbean.SimpleType#STRING\n+ * SimpleType.String}.  If the Java language type is {@link\n+ * javax.management.openmbean.CompositeData}, the\n+ * <code>OpenType<\/code> will be a {@link\n+ * javax.management.openmbean.CompositeType CompositeType} that\n+ * describes the items in the <code>CompositeData<\/code> instances\n+ * for the attribute.<\/p>\n+ *\n+ * <h2><a id=\"constraints\">Default values and constraints<\/a><\/h2>\n+ *\n+ * <p>In Open MBeans, attributes and parameters can have default values\n+ * and\/or constraints associated with them in the {@code\n+ * OpenMBeanAttributeInfo} or {@code OpenMBeanParameterInfo}.\n+ * There are two ways to specify these constraints.  Either the\n+ * values are directly specified as parameters to one of the\n+ * constructors of {@code OpenMBeanAttributeInfoSupport} or\n+ * {@code OpenMBeanParameterInfoSupport}, for example\n+ * {@link\n+ * javax.management.openmbean.OpenMBeanParameterInfoSupport#OpenMBeanParameterInfoSupport(\n+ *String, String, OpenType, Object, Object[])}; or the values are\n+ * specified in a {@link javax.management.Descriptor Descriptor} given\n+ * as a parameter to one of the constructors.<\/p>\n+ *\n+ * <p>When a {@code Descriptor} is used, the fields of interest are\n+ * these:<\/p>\n+ *\n+ * <ul>\n+ *\n+ *   <li>{@code defaultValue} defines the value returned by\n+ * {@link javax.management.openmbean.OpenMBeanParameterInfo#getDefaultValue()\n+ * getDefaultValue()};\n+ *\n+ *   <li>{@code minValue} defines the value returned by {@link\n+ * javax.management.openmbean.OpenMBeanParameterInfo#getMinValue() getMinValue()};\n+ *\n+ *   <li>{@code maxValue} defines the value returned by {@link\n+ * javax.management.openmbean.OpenMBeanParameterInfo#getMaxValue() getMaxValue()};\n+ *\n+ *   <li>{@code legalValues} defines the values returned by {@link\n+ * javax.management.openmbean.OpenMBeanParameterInfo#getLegalValues() getLegalValues()}.\n+ *\n+ * <\/ul>\n+ *\n+ * <p>For {@code defaultValue}, {@code minValue}, and {@code\n+ *   maxValue}, the associated value must either be of the Java type\n+ *   corresponding to {@code openType}, or be a string that can be\n+ *   converted into that type.  The conversion uses the static method\n+ *   {@code valueOf(String)} if it finds one; otherwise a constructor\n+ *   with a single {@code String} parameter if it finds one; otherwise\n+ *   it fails.<\/p>\n+ *\n+ * <p>For {@code legalValues}, the associated value must be either\n+ *   an array or a {@code Set}, and the elements of the array or set\n+ *   must be convertible as described for {@code defaultValue} etc.<\/p>\n+ *\n+ * <p>The following conditions must be met for these fields:<\/p>\n+ *\n+ * <ul>\n+ *   <li>the values must be of the appropriate type, or be strings\n+ * that can be converted to the appropriate type as explained\n+ * above;\n+ *\n+ *   <li>if {@code legalValues} is present then neither {@code\n+ * minValue} nor {@code maxValue} must be present;\n+ *\n+ *   <li>if {@code defaultValue} is present then it must satisfy the\n+ * constraints defined by {@code legalValues}, {@code minValue}, or\n+ * {@code maxValue} when any of these is also present;\n+ *\n+ *   <li>if {@code minValue} and {@code maxValue} are both present\n+ * then {@code minValue} must not be greater than {@code maxValue}.\n+ * <\/ul>\n+ *\n+ * @see <a href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n+ *   JMX Specification, version 1.4<\/a>\n+ *\n+ * @since 1.5\n","filename":"src\/java.management\/share\/classes\/javax\/management\/openmbean\/package-info.java","additions":118,"deletions":118,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * <p>Provides the core classes for the Java Management Extensions.<\/p>\n@@ -28,1 +29,9 @@\n- *        <p>Provides the core classes for the Java Management Extensions.<\/p>\n+ * <p>The Java Management Extensions\n+ * (JMX) API is a standard\n+ * API for management and monitoring.  Typical uses include:<\/p>\n+ *\n+ *     <ul>\n+ *         <li>consulting and changing application configuration<\/li>\n+ *\n+ *         <li>accumulating statistics about application behavior and\n+ *         making them available<\/li>\n@@ -30,3 +39,2 @@\n- *        <p>The Java Management Extensions\n- *            (JMX) API is a standard\n- *        API for management and monitoring.  Typical uses include:<\/p>\n+ *         <li>notifying of state changes and erroneous conditions.<\/li>\n+ *     <\/ul>\n@@ -34,2 +42,2 @@\n- *        <ul>\n- *            <li>consulting and changing application configuration<\/li>\n+ *     <p>The JMX API can also be used as part of a solution for\n+ *     managing systems, networks, and so on.<\/p>\n@@ -37,2 +45,3 @@\n- *            <li>accumulating statistics about application behavior and\n- *            making them available<\/li>\n+ *     <p>The API includes remote access, so a remote management\n+ *         program can interact with a running application for these\n+ *     purposes.<\/p>\n@@ -40,2 +49,1 @@\n- *            <li>notifying of state changes and erroneous conditions.<\/li>\n- *        <\/ul>\n+ *     <h2>MBeans<\/h2>\n@@ -43,2 +51,4 @@\n- *        <p>The JMX API can also be used as part of a solution for\n- *        managing systems, networks, and so on.<\/p>\n+ *     <p>The fundamental notion of the JMX API is the <em>MBean<\/em>.\n+ *         An MBean is a named <em>managed object<\/em> representing a\n+ *         resource.  It has a <em id=\"mgIface\">management interface<\/em>\n+ *         which must be <em>public<\/em> and consist of:<\/p>\n@@ -46,3 +56,3 @@\n- *        <p>The API includes remote access, so a remote management\n- *            program can interact with a running application for these\n- *        purposes.<\/p>\n+ *     <ul>\n+ *         <li>named and typed attributes that can be read and\/or\n+ *         written<\/li>\n@@ -50,1 +60,1 @@\n- *        <h2>MBeans<\/h2>\n+ *         <li>named and typed operations that can be invoked<\/li>\n@@ -52,4 +62,2 @@\n- *        <p>The fundamental notion of the JMX API is the <em>MBean<\/em>.\n- *            An MBean is a named <em>managed object<\/em> representing a\n- *            resource.  It has a <em id=\"mgIface\">management interface<\/em>\n- *            which must be <em>public<\/em> and consist of:<\/p>\n+ *         <li>typed notifications that can be emitted by the MBean.<\/li>\n+ *     <\/ul>\n@@ -57,3 +65,10 @@\n- *        <ul>\n- *            <li>named and typed attributes that can be read and\/or\n- *            written<\/li>\n+ *     <p>For example, an MBean representing an application's\n+ *         configuration could have attributes representing the different\n+ *         configuration items.  Reading the <code>CacheSize<\/code>\n+ *         attribute would return the current value of that item.\n+ *         Writing it would update the item, potentially changing the\n+ *         behavior of the running application.  An operation such as\n+ *         <code>save<\/code> could store the current configuration\n+ *         persistently.  A notification such as\n+ *         <code>ConfigurationChangedNotification<\/code> could be sent\n+ *     every time the configuration is changed.<\/p>\n@@ -61,1 +76,3 @@\n- *            <li>named and typed operations that can be invoked<\/li>\n+ *     <p>In the standard usage of the JMX API, MBeans are implemented\n+ *         as Java objects.  However, as explained below, these objects are\n+ *     not usually referenced directly.<\/p>\n@@ -63,330 +80,0 @@\n- *            <li>typed notifications that can be emitted by the MBean.<\/li>\n- *        <\/ul>\n- *\n- *        <p>For example, an MBean representing an application's\n- *            configuration could have attributes representing the different\n- *            configuration items.  Reading the <code>CacheSize<\/code>\n- *            attribute would return the current value of that item.\n- *            Writing it would update the item, potentially changing the\n- *            behavior of the running application.  An operation such as\n- *            <code>save<\/code> could store the current configuration\n- *            persistently.  A notification such as\n- *            <code>ConfigurationChangedNotification<\/code> could be sent\n- *        every time the configuration is changed.<\/p>\n- *\n- *        <p>In the standard usage of the JMX API, MBeans are implemented\n- *            as Java objects.  However, as explained below, these objects are\n- *        not usually referenced directly.<\/p>\n- *\n- *\n- *        <h3>Standard MBeans<\/h3>\n- *\n- *        <p>To make MBean implementation simple, the JMX API includes the\n- *            notion of <em>Standard MBeans<\/em>.  A Standard MBean is one\n- *            whose attributes and operations are deduced from a Java\n- *            interface using certain naming patterns, similar to those used\n- *            by JavaBeans.  For example, consider an interface like this:<\/p>\n- *\n- *        <pre>\n- *    public interface ConfigurationMBean {\n- *         public int getCacheSize();\n- *         public void setCacheSize(int size);\n- *         public long getLastChangedTime();\n- *         public void save();\n- *    }\n- *        <\/pre>\n- *\n- *        <p>The methods <code>getCacheSize<\/code> and\n- *            <code>setCacheSize<\/code> define a read-write attribute of\n- *            type <code>int<\/code> called <code>CacheSize<\/code> (with an\n- *        initial capital, unlike the JavaBeans convention).<\/p>\n- *\n- *        <p>The method <code>getLastChangedTime<\/code> defines an\n- *            attribute of type <code>long<\/code> called\n- *            <code>LastChangedTime<\/code>.  This is a read-only attribute,\n- *        since there is no method <code>setLastChangedTime<\/code>.<\/p>\n- *\n- *        <p>The method <code>save<\/code> defines an operation called\n- *            <code>save<\/code>.  It is not an attribute, since its name\n- *            does not begin with <code>get<\/code>, <code>set<\/code>, or\n- *        <code>is<\/code>.<\/p>\n- *\n- *        <p>The exact naming patterns for Standard MBeans are detailed in\n- *        the <a href=\"#spec\">JMX Specification<\/a>.<\/p>\n- *\n- *        <p>There are two ways to make a Java object that is an MBean\n- *            with this management interface.  One is for the object to be\n- *            of a class that has exactly the same name as the Java\n- *            interface but without the <code>MBean<\/code> suffix.  So in\n- *            the example the object would be of the class\n- *            <code>Configuration<\/code>, in the same Java package as\n- *            <code>ConfigurationMBean<\/code>.  The second way is to use the\n- *            {@link javax.management.StandardMBean StandardMBean}\n- *        class.<\/p>\n- *\n- *\n- *        <h3>MXBeans<\/h3>\n- *\n- *        <p>An <em>MXBean<\/em> is a variant of Standard MBean where complex\n- *            types are mapped to a standard set of types defined in the\n- *            {@link javax.management.openmbean} package.  MXBeans are appropriate\n- *            if you would otherwise need to reference application-specific\n- *            classes in your MBean interface.  They are described in detail\n- *        in the specification for {@link javax.management.MXBean MXBean}.<\/p>\n- *\n- *\n- *        <h3>Dynamic MBeans<\/h3>\n- *\n- *        <p>A <em>Dynamic MBean<\/em> is an MBean that defines its\n- *            management interface at run-time.  For example, a configuration\n- *            MBean could determine the names and types of the attributes it\n- *        exposes by parsing an XML file.<\/p>\n- *\n- *        <p>Any Java object of a class that implements the {@link\n- *            javax.management.DynamicMBean DynamicMBean} interface is a\n- *        Dynamic MBean.<\/p>\n- *\n- *\n- *        <h3>Open MBeans<\/h3>\n- *\n- *        <p>An <em>Open MBean<\/em> is a kind of Dynamic MBean where the\n- *            types of attributes and of operation parameters and return\n- *            values are built using a small set of predefined Java classes.\n- *            Open MBeans facilitate operation with remote management programs\n- *            that do not necessarily have access to application-specific\n- *            types, including non-Java programs.  Open MBeans are defined by\n- *            the package <a href=\"openmbean\/package-summary.html\"><code>\n- *        javax.management.openmbean<\/code><\/a>.<\/p>\n- *\n- *\n- *        <h3>Model MBeans<\/h3>\n- *\n- *        <p>A <em>Model MBean<\/em> is a kind of Dynamic MBean that acts\n- *            as a bridge between the management interface and the\n- *            underlying managed resource.  Both the management interface and\n- *            the managed resource are specified as Java objects.  The same\n- *            Model MBean implementation can be reused many times with\n- *            different management interfaces and managed resources, and it can\n- *            provide common functionality such as persistence and caching.\n- *            Model MBeans are defined by the package\n- *            <a href=\"modelmbean\/package-summary.html\"><code>\n- *        javax.management.modelmbean<\/code><\/a>.<\/p>\n- *\n- *\n- *        <h2>MBean Server<\/h2>\n- *\n- *        <p>To be useful, an MBean must be registered in an <em>MBean\n- *            Server<\/em>.  An MBean Server is a repository of MBeans.\n- *            Usually the only access to the MBeans is through the MBean\n- *            Server.  In other words, code no longer accesses the Java\n- *            object implementing the MBean directly, but instead accesses\n- *            the MBean by name through the MBean Server.  Each MBean has a\n- *            unique name within the MBean Server, defined by the {@link\n- *        javax.management.ObjectName ObjectName} class.<\/p>\n- *\n- *        <p>An MBean Server is an object implementing the interface\n- *            {@link javax.management.MBeanServer MBeanServer}.\n- *            The most convenient MBean Server to use is the\n- *            <em>Platform MBean Server<\/em>.  This is a\n- *            single MBean Server that can be shared by different managed\n- *            components running within the same Java Virtual Machine.  The\n- *            Platform MBean Server is accessed with the method {@link\n- *        java.lang.management.ManagementFactory#getPlatformMBeanServer()}.<\/p>\n- *\n- *        <p>Application code can also create a new MBean Server, or\n- *            access already-created MBean Servers, using the {@link\n- *        javax.management.MBeanServerFactory MBeanServerFactory} class.<\/p>\n- *\n- *\n- *        <h3>Creating MBeans in the MBean Server<\/h3>\n- *\n- *        <p>There are two ways to create an MBean.  One is to construct a\n- *            Java object that will be the MBean, then use the {@link\n- *            javax.management.MBeanServer#registerMBean registerMBean}\n- *            method to register it in the MBean Server.  The other is to\n- *            create and register the MBean in a single operation using one\n- *            of the {@link javax.management.MBeanServer#createMBean(String,\n- *        javax.management.ObjectName) createMBean} methods.<\/p>\n- *\n- *        <p>The <code>registerMBean<\/code> method is simpler for local\n- *            use, but cannot be used remotely.  The\n- *            <code>createMBean<\/code> method can be used remotely, but\n- *        sometimes requires attention to class loading issues.<\/p>\n- *\n- *        <p>An MBean can perform actions when it is registered in or\n- *            unregistered from an MBean Server if it implements the {@link\n- *            javax.management.MBeanRegistration MBeanRegistration}\n- *        interface.<\/p>\n- *\n- *\n- *        <h3>Accessing MBeans in the MBean Server<\/h3>\n- *\n- *        <p>Given an <code>ObjectName<\/code> <code>name<\/code> and an\n- *            <code>MBeanServer<\/code> <code>mbs<\/code>, you can access\n- *        attributes and operations as in this example:<\/p>\n- *\n- *        <pre>\n- *    int cacheSize = mbs.getAttribute(name, \"CacheSize\");\n- *    {@link javax.management.Attribute Attribute} newCacheSize =\n- *         new Attribute(\"CacheSize\", new Integer(2000));\n- *    mbs.setAttribute(name, newCacheSize);\n- *    mbs.invoke(name, \"save\", new Object[0], new Class[0]);\n- *        <\/pre>\n- *\n- *        <p id=\"proxy\">Alternatively, if you have a Java interface that\n- *            corresponds to the management interface for the MBean, you can use an\n- *        <em>MBean proxy<\/em> like this:<\/p>\n- *\n- *        <pre>\n- *    ConfigurationMBean conf =\n- *        {@link javax.management.JMX#newMBeanProxy\n- *            JMX.newMBeanProxy}(mbs, name, ConfigurationMBean.class);\n- *    int cacheSize = conf.getCacheSize();\n- *    conf.setCacheSize(2000);\n- *    conf.save();\n- *        <\/pre>\n- *\n- *        <p>Using an MBean proxy is just a convenience.  The second\n- *            example ends up calling the same <code>MBeanServer<\/code>\n- *        operations as the first one.<\/p>\n- *\n- *        <p>An MBean Server can be queried for MBeans whose names match\n- *            certain patterns and\/or whose attributes meet certain\n- *            constraints.  Name patterns are constructed using the {@link\n- *            javax.management.ObjectName ObjectName} class and constraints\n- *            are constructed using the {@link javax.management.Query Query}\n- *            class.  The methods {@link\n- *            javax.management.MBeanServer#queryNames queryNames} and {@link\n- *            javax.management.MBeanServer#queryMBeans queryMBeans} then\n- *        perform the query.<\/p>\n- *\n- *\n- *        <h3>MBean lifecycle<\/h3>\n- *\n- *        <p>An MBean can implement the {@link javax.management.MBeanRegistration\n- *            MBeanRegistration} interface in order to be told when it is registered\n- *            and unregistered in the MBean Server. Additionally, the {@link\n- *            javax.management.MBeanRegistration#preRegister preRegister} method\n- *            allows the MBean to get a reference to the <code>MBeanServer<\/code>\n- *            object and to get its <code>ObjectName<\/code> within the MBean\n- *        Server.<\/p>\n- *\n- *\n- *        <h2>Notifications<\/h2>\n- *\n- *        <p>A <em>notification<\/em> is an instance of the {@link\n- *            javax.management.Notification Notification} class or a\n- *            subclass.  In addition to its Java class, it has a\n- *            <em>type<\/em> string that can distinguish it from other\n- *        notifications of the same class.<\/p>\n- *\n- *        <p>An MBean that will emit notifications must implement the\n- *            {@link javax.management.NotificationBroadcaster\n- *            NotificationBroadcaster} or {@link\n- *            javax.management.NotificationEmitter NotificationEmitter}\n- *            interface.  Usually, it does this by subclassing\n- *            {@link javax.management.NotificationBroadcasterSupport\n- *            NotificationBroadcasterSupport} or delegating to an instance of\n- *        that class. Here is an example:<\/p>\n- *\n- *        <pre>\n- *    public class Configuration <b>extends NotificationBroadcasterSupport<\/b>\n- *            implements ConfigurationMBean {\n- *        ...\n- *        private void updated() {\n- *            Notification n = new Notification(...);\n- *            <b>{@link javax.management.NotificationBroadcasterSupport#sendNotification\n- *            sendNotification}(n)<\/b>;\n- *        }\n- *    }\n- *        <\/pre>\n- *\n- *\n- *        <p>Notifications can be received by a <em>listener<\/em>, which\n- *            is an object that implements the {@link\n- *            javax.management.NotificationListener NotificationListener}\n- *            interface.  You can add a listener to an MBean with the method\n- *            {@link\n- *            javax.management.MBeanServer#addNotificationListener(ObjectName,\n- *            NotificationListener, NotificationFilter, Object)}.\n- *            You can optionally supply a <em>filter<\/em> to this method, to\n- *            select only notifications of interest.  A filter is an object\n- *            that implements the {@link javax.management.NotificationFilter\n- *        NotificationFilter} interface.<\/p>\n- *\n- *        <p>An MBean can be a listener for notifications emitted by other\n- *            MBeans in the same MBean Server.  In this case, it implements\n- *            {@link javax.management.NotificationListener\n- *            NotificationListener} and the method {@link\n- *            javax.management.MBeanServer#addNotificationListener(ObjectName,\n- *        ObjectName, NotificationFilter, Object)} is used to listen.<\/p>\n- *\n- *\n- *        <h2>Remote Access to MBeans<\/h2>\n- *\n- *        <p>An MBean Server can be accessed remotely through a\n- *            <em>connector<\/em>.  A connector allows a remote Java\n- *            application to access an MBean Server in essentially the same\n- *            way as a local one.  The package\n- *            <a href=\"remote\/package-summary.html\"><code>\n- *        javax.management.remote<\/code><\/a> defines connectors.<\/p>\n- *\n- *        <p>The JMX specification also defines the notion of an\n- *            <em>adaptor<\/em>.  An adaptor translates between requests in a\n- *            protocol such as SNMP or HTML and accesses to an MBean Server.\n- *            So for example an SNMP GET operation might result in a\n- *        <code>getAttribute<\/code> on the MBean Server.<\/p>\n- *\n- *    <h3 id=\"interop\">Interoperability between versions of the JMX\n- *      specification<\/h3>\n- *\n- *        <p>When a client connects to a server using the JMX Remote\n- *            API, it is possible that they do not have the same version\n- *            of the JMX specification.  The version of the JMX\n- *            specification described here is version 1.4.  Previous\n- *            versions were 1.0, 1.1, and 1.2.  (There was no 1.3.)\n- *            The standard JMX Remote API is defined to work with version\n- *            1.2 onwards, so in standards-based deployment the only\n- *            interoperability questions that arise concern version 1.2\n- *        onwards.<\/p>\n- *\n- *        <p>Every version of the JMX specification continues to\n- *            implement the features of previous versions.  So when the\n- *            client is running an earlier version than the server, there\n- *            should not be any interoperability concerns.<\/p>\n- *\n- *        <p>When the client is running a later version than the server,\n- *            certain newer features may not be available, as detailed in\n- *            the next sections.  The client can determine the server's\n- *            version by examining the {@link\n- *            javax.management.MBeanServerDelegateMBean#getSpecificationVersion\n- *            SpecificationVersion} attribute of the {@code\n- *        MBeanServerDelegate}.<\/p>\n- *\n- *        <h4 id=\"interop-1.2\">If the remote MBean Server is 1.2<\/h4>\n- *\n- *    <ul>\n- *\n- *            <li><p>You cannot use wildcards in a key property of an\n- *                {@link javax.management.ObjectName ObjectName}, for\n- *                example {@code domain:type=Foo,name=*}. Wildcards that\n- *                match whole properties are still allowed, for example\n- *            {@code *:*} or {@code *:type=Foo,*}.<\/p>\n- *\n- *            <li><p>You cannot use {@link\n- *                javax.management.Query#isInstanceOf Query.isInstanceOf}\n- *            in a query.<\/p>\n- *\n- *            <li><p>You cannot use dot syntax such as {@code\n- *                HeapMemoryUsage.used} in the {@linkplain\n- *                javax.management.monitor.Monitor#setObservedAttribute\n- *                observed attribute} of a monitor, as described in the\n- *                documentation for the {@link javax.management.monitor}\n- *            package.<\/p>\n- *\n- *        <\/ul>\n- *\n- *        @see <a id=\"spec\" href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n- *        JMX Specification, version 1.4<\/a>\n- *\n- *        @since 1.5\n@@ -394,0 +81,311 @@\n+ *     <h3>Standard MBeans<\/h3>\n+ *\n+ *     <p>To make MBean implementation simple, the JMX API includes the\n+ *         notion of <em>Standard MBeans<\/em>.  A Standard MBean is one\n+ *         whose attributes and operations are deduced from a Java\n+ *         interface using certain naming patterns, similar to those used\n+ *         by JavaBeans.  For example, consider an interface like this:<\/p>\n+ *\n+ *     <pre>\n+ * public interface ConfigurationMBean {\n+ *      public int getCacheSize();\n+ *      public void setCacheSize(int size);\n+ *      public long getLastChangedTime();\n+ *      public void save();\n+ * }\n+ *     <\/pre>\n+ *\n+ *     <p>The methods <code>getCacheSize<\/code> and\n+ *         <code>setCacheSize<\/code> define a read-write attribute of\n+ *         type <code>int<\/code> called <code>CacheSize<\/code> (with an\n+ *     initial capital, unlike the JavaBeans convention).<\/p>\n+ *\n+ *     <p>The method <code>getLastChangedTime<\/code> defines an\n+ *         attribute of type <code>long<\/code> called\n+ *         <code>LastChangedTime<\/code>.  This is a read-only attribute,\n+ *     since there is no method <code>setLastChangedTime<\/code>.<\/p>\n+ *\n+ *     <p>The method <code>save<\/code> defines an operation called\n+ *         <code>save<\/code>.  It is not an attribute, since its name\n+ *         does not begin with <code>get<\/code>, <code>set<\/code>, or\n+ *     <code>is<\/code>.<\/p>\n+ *\n+ *     <p>The exact naming patterns for Standard MBeans are detailed in\n+ *     the <a href=\"#spec\">JMX Specification<\/a>.<\/p>\n+ *\n+ *     <p>There are two ways to make a Java object that is an MBean\n+ *         with this management interface.  One is for the object to be\n+ *         of a class that has exactly the same name as the Java\n+ *         interface but without the <code>MBean<\/code> suffix.  So in\n+ *         the example the object would be of the class\n+ *         <code>Configuration<\/code>, in the same Java package as\n+ *         <code>ConfigurationMBean<\/code>.  The second way is to use the\n+ *         {@link javax.management.StandardMBean StandardMBean}\n+ *     class.<\/p>\n+ *\n+ *\n+ *     <h3>MXBeans<\/h3>\n+ *\n+ *     <p>An <em>MXBean<\/em> is a variant of Standard MBean where complex\n+ *         types are mapped to a standard set of types defined in the\n+ *         {@link javax.management.openmbean} package.  MXBeans are appropriate\n+ *         if you would otherwise need to reference application-specific\n+ *         classes in your MBean interface.  They are described in detail\n+ *     in the specification for {@link javax.management.MXBean MXBean}.<\/p>\n+ *\n+ *\n+ *     <h3>Dynamic MBeans<\/h3>\n+ *\n+ *     <p>A <em>Dynamic MBean<\/em> is an MBean that defines its\n+ *         management interface at run-time.  For example, a configuration\n+ *         MBean could determine the names and types of the attributes it\n+ *     exposes by parsing an XML file.<\/p>\n+ *\n+ *     <p>Any Java object of a class that implements the {@link\n+ *         javax.management.DynamicMBean DynamicMBean} interface is a\n+ *     Dynamic MBean.<\/p>\n+ *\n+ *\n+ *     <h3>Open MBeans<\/h3>\n+ *\n+ *     <p>An <em>Open MBean<\/em> is a kind of Dynamic MBean where the\n+ *         types of attributes and of operation parameters and return\n+ *         values are built using a small set of predefined Java classes.\n+ *         Open MBeans facilitate operation with remote management programs\n+ *         that do not necessarily have access to application-specific\n+ *         types, including non-Java programs.  Open MBeans are defined by\n+ *         the package <a href=\"openmbean\/package-summary.html\"><code>\n+ *     javax.management.openmbean<\/code><\/a>.<\/p>\n+ *\n+ *\n+ *     <h3>Model MBeans<\/h3>\n+ *\n+ *     <p>A <em>Model MBean<\/em> is a kind of Dynamic MBean that acts\n+ *         as a bridge between the management interface and the\n+ *         underlying managed resource.  Both the management interface and\n+ *         the managed resource are specified as Java objects.  The same\n+ *         Model MBean implementation can be reused many times with\n+ *         different management interfaces and managed resources, and it can\n+ *         provide common functionality such as persistence and caching.\n+ *         Model MBeans are defined by the package\n+ *         <a href=\"modelmbean\/package-summary.html\"><code>\n+ *     javax.management.modelmbean<\/code><\/a>.<\/p>\n+ *\n+ *\n+ *     <h2>MBean Server<\/h2>\n+ *\n+ *     <p>To be useful, an MBean must be registered in an <em>MBean\n+ *         Server<\/em>.  An MBean Server is a repository of MBeans.\n+ *         Usually the only access to the MBeans is through the MBean\n+ *         Server.  In other words, code no longer accesses the Java\n+ *         object implementing the MBean directly, but instead accesses\n+ *         the MBean by name through the MBean Server.  Each MBean has a\n+ *         unique name within the MBean Server, defined by the {@link\n+ *     javax.management.ObjectName ObjectName} class.<\/p>\n+ *\n+ *     <p>An MBean Server is an object implementing the interface\n+ *         {@link javax.management.MBeanServer MBeanServer}.\n+ *         The most convenient MBean Server to use is the\n+ *         <em>Platform MBean Server<\/em>.  This is a\n+ *         single MBean Server that can be shared by different managed\n+ *         components running within the same Java Virtual Machine.  The\n+ *         Platform MBean Server is accessed with the method {@link\n+ *     java.lang.management.ManagementFactory#getPlatformMBeanServer()}.<\/p>\n+ *\n+ *     <p>Application code can also create a new MBean Server, or\n+ *         access already-created MBean Servers, using the {@link\n+ *     javax.management.MBeanServerFactory MBeanServerFactory} class.<\/p>\n+ *\n+ *\n+ *     <h3>Creating MBeans in the MBean Server<\/h3>\n+ *\n+ *     <p>There are two ways to create an MBean.  One is to construct a\n+ *         Java object that will be the MBean, then use the {@link\n+ *         javax.management.MBeanServer#registerMBean registerMBean}\n+ *         method to register it in the MBean Server.  The other is to\n+ *         create and register the MBean in a single operation using one\n+ *         of the {@link javax.management.MBeanServer#createMBean(String,\n+ *     javax.management.ObjectName) createMBean} methods.<\/p>\n+ *\n+ *     <p>The <code>registerMBean<\/code> method is simpler for local\n+ *         use, but cannot be used remotely.  The\n+ *         <code>createMBean<\/code> method can be used remotely, but\n+ *     sometimes requires attention to class loading issues.<\/p>\n+ *\n+ *     <p>An MBean can perform actions when it is registered in or\n+ *         unregistered from an MBean Server if it implements the {@link\n+ *         javax.management.MBeanRegistration MBeanRegistration}\n+ *     interface.<\/p>\n+ *\n+ *\n+ *     <h3>Accessing MBeans in the MBean Server<\/h3>\n+ *\n+ *     <p>Given an <code>ObjectName<\/code> <code>name<\/code> and an\n+ *         <code>MBeanServer<\/code> <code>mbs<\/code>, you can access\n+ *     attributes and operations as in this example:<\/p>\n+ *\n+ *     <pre>\n+ * int cacheSize = mbs.getAttribute(name, \"CacheSize\");\n+ * {@link javax.management.Attribute Attribute} newCacheSize =\n+ *      new Attribute(\"CacheSize\", new Integer(2000));\n+ * mbs.setAttribute(name, newCacheSize);\n+ * mbs.invoke(name, \"save\", new Object[0], new Class[0]);\n+ *     <\/pre>\n+ *\n+ *     <p id=\"proxy\">Alternatively, if you have a Java interface that\n+ *         corresponds to the management interface for the MBean, you can use an\n+ *     <em>MBean proxy<\/em> like this:<\/p>\n+ *\n+ *     <pre>\n+ * ConfigurationMBean conf =\n+ *     {@link javax.management.JMX#newMBeanProxy\n+ *         JMX.newMBeanProxy}(mbs, name, ConfigurationMBean.class);\n+ * int cacheSize = conf.getCacheSize();\n+ * conf.setCacheSize(2000);\n+ * conf.save();\n+ *     <\/pre>\n+ *\n+ *     <p>Using an MBean proxy is just a convenience.  The second\n+ *         example ends up calling the same <code>MBeanServer<\/code>\n+ *     operations as the first one.<\/p>\n+ *\n+ *     <p>An MBean Server can be queried for MBeans whose names match\n+ *         certain patterns and\/or whose attributes meet certain\n+ *         constraints.  Name patterns are constructed using the {@link\n+ *         javax.management.ObjectName ObjectName} class and constraints\n+ *         are constructed using the {@link javax.management.Query Query}\n+ *         class.  The methods {@link\n+ *         javax.management.MBeanServer#queryNames queryNames} and {@link\n+ *         javax.management.MBeanServer#queryMBeans queryMBeans} then\n+ *     perform the query.<\/p>\n+ *\n+ *\n+ *     <h3>MBean lifecycle<\/h3>\n+ *\n+ *     <p>An MBean can implement the {@link javax.management.MBeanRegistration\n+ *         MBeanRegistration} interface in order to be told when it is registered\n+ *         and unregistered in the MBean Server. Additionally, the {@link\n+ *         javax.management.MBeanRegistration#preRegister preRegister} method\n+ *         allows the MBean to get a reference to the <code>MBeanServer<\/code>\n+ *         object and to get its <code>ObjectName<\/code> within the MBean\n+ *     Server.<\/p>\n+ *\n+ *\n+ *     <h2>Notifications<\/h2>\n+ *\n+ *     <p>A <em>notification<\/em> is an instance of the {@link\n+ *         javax.management.Notification Notification} class or a\n+ *         subclass.  In addition to its Java class, it has a\n+ *         <em>type<\/em> string that can distinguish it from other\n+ *     notifications of the same class.<\/p>\n+ *\n+ *     <p>An MBean that will emit notifications must implement the\n+ *         {@link javax.management.NotificationBroadcaster\n+ *         NotificationBroadcaster} or {@link\n+ *         javax.management.NotificationEmitter NotificationEmitter}\n+ *         interface.  Usually, it does this by subclassing\n+ *         {@link javax.management.NotificationBroadcasterSupport\n+ *         NotificationBroadcasterSupport} or delegating to an instance of\n+ *     that class. Here is an example:<\/p>\n+ *\n+ *     <pre>\n+ * public class Configuration <b>extends NotificationBroadcasterSupport<\/b>\n+ *         implements ConfigurationMBean {\n+ *     ...\n+ *     private void updated() {\n+ *         Notification n = new Notification(...);\n+ *         <b>{@link javax.management.NotificationBroadcasterSupport#sendNotification\n+ *         sendNotification}(n)<\/b>;\n+ *     }\n+ * }\n+ *     <\/pre>\n+ *\n+ *\n+ *     <p>Notifications can be received by a <em>listener<\/em>, which\n+ *         is an object that implements the {@link\n+ *         javax.management.NotificationListener NotificationListener}\n+ *         interface.  You can add a listener to an MBean with the method\n+ *         {@link\n+ *         javax.management.MBeanServer#addNotificationListener(ObjectName,\n+ *         NotificationListener, NotificationFilter, Object)}.\n+ *         You can optionally supply a <em>filter<\/em> to this method, to\n+ *         select only notifications of interest.  A filter is an object\n+ *         that implements the {@link javax.management.NotificationFilter\n+ *     NotificationFilter} interface.<\/p>\n+ *\n+ *     <p>An MBean can be a listener for notifications emitted by other\n+ *         MBeans in the same MBean Server.  In this case, it implements\n+ *         {@link javax.management.NotificationListener\n+ *         NotificationListener} and the method {@link\n+ *         javax.management.MBeanServer#addNotificationListener(ObjectName,\n+ *     ObjectName, NotificationFilter, Object)} is used to listen.<\/p>\n+ *\n+ *\n+ *     <h2>Remote Access to MBeans<\/h2>\n+ *\n+ *     <p>An MBean Server can be accessed remotely through a\n+ *         <em>connector<\/em>.  A connector allows a remote Java\n+ *         application to access an MBean Server in essentially the same\n+ *         way as a local one.  The package\n+ *         <a href=\"remote\/package-summary.html\"><code>\n+ *     javax.management.remote<\/code><\/a> defines connectors.<\/p>\n+ *\n+ *     <p>The JMX specification also defines the notion of an\n+ *         <em>adaptor<\/em>.  An adaptor translates between requests in a\n+ *         protocol such as SNMP or HTML and accesses to an MBean Server.\n+ *         So for example an SNMP GET operation might result in a\n+ *     <code>getAttribute<\/code> on the MBean Server.<\/p>\n+ *\n+ * <h3 id=\"interop\">Interoperability between versions of the JMX\n+ *   specification<\/h3>\n+ *\n+ *     <p>When a client connects to a server using the JMX Remote\n+ *         API, it is possible that they do not have the same version\n+ *         of the JMX specification.  The version of the JMX\n+ *         specification described here is version 1.4.  Previous\n+ *         versions were 1.0, 1.1, and 1.2.  (There was no 1.3.)\n+ *         The standard JMX Remote API is defined to work with version\n+ *         1.2 onwards, so in standards-based deployment the only\n+ *         interoperability questions that arise concern version 1.2\n+ *     onwards.<\/p>\n+ *\n+ *     <p>Every version of the JMX specification continues to\n+ *         implement the features of previous versions.  So when the\n+ *         client is running an earlier version than the server, there\n+ *         should not be any interoperability concerns.<\/p>\n+ *\n+ *     <p>When the client is running a later version than the server,\n+ *         certain newer features may not be available, as detailed in\n+ *         the next sections.  The client can determine the server's\n+ *         version by examining the {@link\n+ *         javax.management.MBeanServerDelegateMBean#getSpecificationVersion\n+ *         SpecificationVersion} attribute of the {@code\n+ *     MBeanServerDelegate}.<\/p>\n+ *\n+ *     <h4 id=\"interop-1.2\">If the remote MBean Server is 1.2<\/h4>\n+ *\n+ * <ul>\n+ *\n+ *         <li><p>You cannot use wildcards in a key property of an\n+ *             {@link javax.management.ObjectName ObjectName}, for\n+ *             example {@code domain:type=Foo,name=*}. Wildcards that\n+ *             match whole properties are still allowed, for example\n+ *         {@code *:*} or {@code *:type=Foo,*}.<\/p>\n+ *\n+ *         <li><p>You cannot use {@link\n+ *             javax.management.Query#isInstanceOf Query.isInstanceOf}\n+ *         in a query.<\/p>\n+ *\n+ *         <li><p>You cannot use dot syntax such as {@code\n+ *             HeapMemoryUsage.used} in the {@linkplain\n+ *             javax.management.monitor.Monitor#setObservedAttribute\n+ *             observed attribute} of a monitor, as described in the\n+ *             documentation for the {@link javax.management.monitor}\n+ *         package.<\/p>\n+ *\n+ *     <\/ul>\n+ *\n+ *     @see <a id=\"spec\" href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n+ *     JMX Specification, version 1.4<\/a>\n+ *\n+ *     @since 1.5\n","filename":"src\/java.management\/share\/classes\/javax\/management\/package-info.java","additions":352,"deletions":354,"binary":false,"changes":706,"status":"modified"},{"patch":"@@ -26,64 +26,64 @@\n- *       <p>Provides the definition of the Relation Service.  The\n- *     Relation Service is used to record relationships between\n- *     MBeans in an MBean Server.  The Relation Service is itself an\n- *     MBean.  More than one instance of a {@link\n- *     javax.management.relation.RelationService RelationService}\n- *     MBean can be registered in an MBean Server.<\/p>\n- *\n- *       <p>A <em>relation type<\/em> defines a relationship between MBeans.\n- *     It contains <em>roles<\/em> that the MBeans play in the\n- *     relationship.  Usually there are at least two roles in a\n- *     relation type.<\/p>\n- *\n- *       <p>A <em>relation<\/em> is a named instance of a relation type,\n- *     where specific MBeans appear in the roles, represented by\n- *     their {@link javax.management.ObjectName ObjectName}s.<\/p>\n- *\n- *       <p>For example, suppose there are <code>Module<\/code> MBeans,\n- *     representing modules within an application.  A\n- *     <code>DependsOn<\/code> relation type could express the\n- *     relationship that some modules depend on others, which could\n- *     be used to determine the order in which the modules are\n- *     started or stopped.  The <code>DependsOn<\/code> relation type\n- *     would have two roles, <code>dependent<\/code> and\n- *     <code>dependedOn<\/code>.<\/p>\n- *\n- *       <p>Every role is <em>typed<\/em>, meaning that an MBean that\n- *     appears in that role must be an instance of the role's type.\n- *     In the <code>DependsOn<\/code> example, both roles would be of\n- *     type <code>Module<\/code>.<\/p>\n- *\n- *       <p>Every role has a <em>cardinality<\/em>, which provides lower\n- *     and upper bounds on the number of MBeans that can appear in\n- *     that role in a given relation instance.  Usually, the lower\n- *     and upper bounds are both 1, with exactly one MBean appearing\n- *     in the role.  The cardinality only limits the number of MBeans\n- *     in the role per relation instance.  The same MBean can appear\n- *     in the same role in any number of instances of a relation\n- *     type.  In the <code>DependsOn<\/code> example, a given module\n- *     can depend on many other modules, and be depended on by many\n- *     others, but any given relation instance links exactly one\n- *     <code>dependent<\/code> module with exactly one\n- *     <code>dependedOn<\/code> module.<\/p>\n- *\n- *       <p>A relation type can be created explicitly, as an object\n- *     implementing the {@link javax.management.relation.RelationType\n- *     RelationType} interface, typically a {@link\n- *     javax.management.relation.RelationTypeSupport\n- *     RelationTypeSupport}.  Alternatively, it can be created\n- *     implicitly using the Relation Service's {@link\n- *     javax.management.relation.RelationServiceMBean#createRelationType(String,\n- *     RoleInfo[]) createRelationType} method.<\/p>\n- *\n- *       <p>A relation instance can be created explicitly, as an object\n- *     implementing the {@link javax.management.relation.Relation\n- *     Relation} interface, typically a {@link\n- *     javax.management.relation.RelationSupport RelationSupport}.\n- *     (A <code>RelationSupport<\/code> is itself a valid MBean, so it\n- *     can be registered in the MBean Server, though this is not\n- *     required.)  Alternatively, a relation instance can be created\n- *     implicitly using the Relation Service's {@link\n- *     javax.management.relation.RelationServiceMBean#createRelation(String,\n- *     String, RoleList) createRelation} method.<\/p>\n- *\n- *       <p>The <code>DependsOn<\/code> example might be coded as follows.<\/p>\n+ * <p>Provides the definition of the Relation Service.  The\n+ * Relation Service is used to record relationships between\n+ * MBeans in an MBean Server.  The Relation Service is itself an\n+ * MBean.  More than one instance of a {@link\n+ * javax.management.relation.RelationService RelationService}\n+ * MBean can be registered in an MBean Server.<\/p>\n+ *\n+ * <p>A <em>relation type<\/em> defines a relationship between MBeans.\n+ * It contains <em>roles<\/em> that the MBeans play in the\n+ * relationship.  Usually there are at least two roles in a\n+ * relation type.<\/p>\n+ *\n+ * <p>A <em>relation<\/em> is a named instance of a relation type,\n+ * where specific MBeans appear in the roles, represented by\n+ * their {@link javax.management.ObjectName ObjectName}s.<\/p>\n+ *\n+ * <p>For example, suppose there are <code>Module<\/code> MBeans,\n+ * representing modules within an application.  A\n+ * <code>DependsOn<\/code> relation type could express the\n+ * relationship that some modules depend on others, which could\n+ * be used to determine the order in which the modules are\n+ * started or stopped.  The <code>DependsOn<\/code> relation type\n+ * would have two roles, <code>dependent<\/code> and\n+ * <code>dependedOn<\/code>.<\/p>\n+ *\n+ * <p>Every role is <em>typed<\/em>, meaning that an MBean that\n+ * appears in that role must be an instance of the role's type.\n+ * In the <code>DependsOn<\/code> example, both roles would be of\n+ * type <code>Module<\/code>.<\/p>\n+ *\n+ * <p>Every role has a <em>cardinality<\/em>, which provides lower\n+ * and upper bounds on the number of MBeans that can appear in\n+ * that role in a given relation instance.  Usually, the lower\n+ * and upper bounds are both 1, with exactly one MBean appearing\n+ * in the role.  The cardinality only limits the number of MBeans\n+ * in the role per relation instance.  The same MBean can appear\n+ * in the same role in any number of instances of a relation\n+ * type.  In the <code>DependsOn<\/code> example, a given module\n+ * can depend on many other modules, and be depended on by many\n+ * others, but any given relation instance links exactly one\n+ * <code>dependent<\/code> module with exactly one\n+ * <code>dependedOn<\/code> module.<\/p>\n+ *\n+ * <p>A relation type can be created explicitly, as an object\n+ * implementing the {@link javax.management.relation.RelationType\n+ * RelationType} interface, typically a {@link\n+ * javax.management.relation.RelationTypeSupport\n+ * RelationTypeSupport}.  Alternatively, it can be created\n+ * implicitly using the Relation Service's {@link\n+ * javax.management.relation.RelationServiceMBean#createRelationType(String,\n+ * RoleInfo[]) createRelationType} method.<\/p>\n+ *\n+ * <p>A relation instance can be created explicitly, as an object\n+ * implementing the {@link javax.management.relation.Relation\n+ * Relation} interface, typically a {@link\n+ * javax.management.relation.RelationSupport RelationSupport}.\n+ * (A <code>RelationSupport<\/code> is itself a valid MBean, so it\n+ * can be registered in the MBean Server, though this is not\n+ * required.)  Alternatively, a relation instance can be created\n+ * implicitly using the Relation Service's {@link\n+ * javax.management.relation.RelationServiceMBean#createRelation(String,\n+ * String, RoleList) createRelation} method.<\/p>\n+ *\n+ * <p>The <code>DependsOn<\/code> example might be coded as follows.<\/p>\n@@ -135,2 +135,2 @@\n- *     @see <a href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n- *       JMX Specification, version 1.4<\/a>\n+ * @see <a href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n+ * JMX Specification, version 1.4<\/a>\n@@ -138,1 +138,1 @@\n- *       @since 1.5\n+ * @since 1.5\n","filename":"src\/java.management\/share\/classes\/javax\/management\/relation\/package-info.java","additions":67,"deletions":67,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -27,19 +27,19 @@\n- *       <p>Interfaces for remote access to\n- *     JMX MBean servers.\n- *     This package defines the essential interfaces for making a JMX\n- *     MBean server manageable remotely. The specification of this\n- *         functionality is completed by Part III of the\n- *        <a href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n- *     JMX Specification, version 1.4<\/a><\/p>\n- *\n- *       <p>The JMX specification defines the notion of <b>connectors<\/b>.\n- *     A connector is attached to a JMX API MBean server and makes it\n- *     accessible to remote Java clients. The client end of a\n- *     connector exports essentially the same interface as the MBean\n- *     server, specifically the {@link\n- *     javax.management.MBeanServerConnection MBeanServerConnection}\n- *     interface.<\/p>\n- *\n- *       <p>A connector makes an MBean server remotely accessible through\n- *     a given protocol. The JMX Remote API allows the use of different\n- *         type of connectors:\n+ * <p>Interfaces for remote access to\n+ * JMX MBean servers.\n+ * This package defines the essential interfaces for making a JMX\n+ * MBean server manageable remotely. The specification of this\n+ * functionality is completed by Part III of the\n+ * <a href=\"https:\/\/jcp.org\/aboutJava\/communityprocess\/mrel\/jsr160\/index2.html\">\n+ * JMX Specification, version 1.4<\/a><\/p>\n+ *\n+ * <p>The JMX specification defines the notion of <b>connectors<\/b>.\n+ * A connector is attached to a JMX API MBean server and makes it\n+ * accessible to remote Java clients. The client end of a\n+ * connector exports essentially the same interface as the MBean\n+ * server, specifically the {@link\n+ * javax.management.MBeanServerConnection MBeanServerConnection}\n+ * interface.<\/p>\n+ *\n+ * <p>A connector makes an MBean server remotely accessible through\n+ * a given protocol. The JMX Remote API allows the use of different\n+ * type of connectors:\n","filename":"src\/java.management\/share\/classes\/javax\/management\/remote\/package-info.java","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -27,8 +27,8 @@\n- *       <p>Provides the definition of the Timer MBean.  A Timer MBean\n- *       maintains a list of scheduled notifications and, because it is a\n- *       {@link javax.management.NotificationBroadcaster\n- *       NotificationBroadcaster}, a list of listeners for those\n- *       notifications.  Whenever the time for one of the scheduled\n- *       notifications is reached, each listener receives the\n- *       notification.  Notifications can be repeated at a fixed\n- *       interval, and the number of repetitions can be bounded.<\/p>\n+ * <p>Provides the definition of the Timer MBean.  A Timer MBean\n+ * maintains a list of scheduled notifications and, because it is a\n+ * {@link javax.management.NotificationBroadcaster\n+ * NotificationBroadcaster}, a list of listeners for those\n+ * notifications.  Whenever the time for one of the scheduled\n+ * notifications is reached, each listener receives the\n+ * notification.  Notifications can be repeated at a fixed\n+ * interval, and the number of repetitions can be bounded.<\/p>\n@@ -36,6 +36,6 @@\n- *       <p>A listener for a Timer MBean can itself be an MBean, using\n- *       the method {@link\n- *       javax.management.MBeanServer#addNotificationListener(ObjectName,\n- *       ObjectName, NotificationFilter, Object)}.  In this way, a\n- *       management application can create an MBean representing a task,\n- *       then schedule that task using a Timer MBean.<\/p>\n+ * <p>A listener for a Timer MBean can itself be an MBean, using\n+ * the method {@link\n+ * javax.management.MBeanServer#addNotificationListener(ObjectName,\n+ * ObjectName, NotificationFilter, Object)}.  In this way, a\n+ * management application can create an MBean representing a task,\n+ * then schedule that task using a Timer MBean.<\/p>\n@@ -43,1 +43,1 @@\n- *     @since 1.5\n+ * @since 1.5\n","filename":"src\/java.management\/share\/classes\/javax\/management\/timer\/package-info.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"}]}