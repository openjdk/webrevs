{"files":[{"patch":"@@ -37,1 +37,0 @@\n-import java.util.stream.Collectors;\n@@ -141,1 +140,1 @@\n-    public void calculateLints(JavaFileObject sourceFile, JCTree tree) {\n+    public void calculateLints(JavaFileObject sourceFile, JCTree tree, EndPosTable endPositions) {\n@@ -143,1 +142,1 @@\n-        fileInfoMap.get(sourceFile).afterAttr(tree);\n+        fileInfoMap.get(sourceFile).afterAttr(tree, endPositions);\n@@ -177,3 +176,3 @@\n-     * Initially (immediately after parsing), \"unmappedDecls\" will contain a {@link JCTree} corresponding\n-     * to each top-level declaration in the source file. As those top-level declarations are attributed,\n-     * the {@link JCTree} is removed and a new {@link MappedDecl} subtree is added to the \"mappedDecls\" tree.\n+     * Initially (immediately after parsing), \"unmappedDecls\" contains a {@link Span} corresponding to each\n+     * top-level declaration in the source file. As each top-level declaration is attributed, the corresponding\n+     * {@link Span} is removed and the corresponding {@link LintRange} subtree is populated under \"rootRange\".\n@@ -183,3 +182,2 @@\n-        EndPosTable endPositions;                           \/\/ end position table for this source file (only during attribution)\n-        final MappedDecl mappedDecls;                       \/\/ root node with subtree for each mapped top-level declaration\n-        final List<JCTree> unmappedDecls;                   \/\/ unmapped (i.e., awaiting attribution) top-level declarations\n+        final LintRange rootRange;                              \/\/ the root LintRange (covering the entire source file)\n+        final List<Span> unmappedDecls = new ArrayList<>();     \/\/ unmapped top-level declarations awaiting attribution\n@@ -189,3 +187,2 @@\n-            this.endPositions = tree.endPositions;\n-            this.mappedDecls = new MappedDecl(rootLint);\n-            this.unmappedDecls = tree.defs.stream()\n+            rootRange = new LintRange(rootLint);\n+            tree.defs.stream()\n@@ -193,1 +190,2 @@\n-              .collect(Collectors.toCollection(ArrayList::new));\n+              .map(decl -> new Span(decl, tree.endPositions))\n+              .forEach(unmappedDecls::add);\n@@ -196,6 +194,5 @@\n-        \/\/ After attribution: Discard the tree from \"unmappedDecls\" and add a corresponding MappedDecl to \"mappedDecls\"\n-        void afterAttr(JCTree tree) {\n-            MappedDeclBuilder builder = null;\n-            for (Iterator<JCTree> i = unmappedDecls.iterator(); i.hasNext(); ) {\n-                if (contains(i.next(), tree.pos())) {\n-                    builder = new MappedDeclBuilder(mappedDecls, endPositions);\n+        \/\/ After attribution: Discard the span from \"unmappedDecls\" and populate the declaration's subtree under \"rootRange\"\n+        void afterAttr(JCTree tree, EndPosTable endPositions) {\n+            for (Iterator<Span> i = unmappedDecls.iterator(); i.hasNext(); ) {\n+                if (i.next().contains(tree.pos())) {\n+                    rootRange.populateSubtree(tree, endPositions);\n@@ -203,1 +200,1 @@\n-                    break;\n+                    return;\n@@ -206,4 +203,1 @@\n-            Assert.check(builder != null, \"top-level declaration not found\");\n-            builder.scan(tree);\n-            if (unmappedDecls.isEmpty())\n-                endPositions = null;                        \/\/ gc friendly\n+            throw new AssertionError(\"top-level declaration not found\");\n@@ -212,1 +206,1 @@\n-        \/\/ Find the (narrowest) Lint that applies to the given position, unless the position has not been mapped yet\n+        \/\/ Find the most specific Lint configuration applying to the given position, unless the position has not been mapped yet\n@@ -214,6 +208,2 @@\n-            boolean mapped = unmappedDecls.stream().noneMatch(tree -> contains(tree, pos));\n-            return mapped ? Optional.of(mappedDecls.bestMatch(pos).lint) : Optional.empty();\n-        }\n-\n-        boolean contains(JCTree tree, DiagnosticPosition pos) {\n-            return FileInfo.contains(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions), pos);\n+            boolean mapped = unmappedDecls.stream().noneMatch(span -> span.contains(pos));\n+            return mapped ? Optional.of(rootRange.bestMatch(pos).lint) : Optional.empty();\n@@ -227,5 +217,0 @@\n-\n-        static boolean contains(int startPos, int endPos, DiagnosticPosition pos) {\n-            int offset = pos.getLintPosition();\n-            return offset == startPos || (offset > startPos && offset < endPos);\n-        }\n@@ -234,1 +219,1 @@\n-\/\/ MappedDecl\n+\/\/ Span\n@@ -237,2 +222,1 @@\n-     * A module, package, class, method, or variable declaration within which all {@link Lint} configurations are known.\n-     * There is also a root instance that represents the entire file.\n+     * A lexical range.\n@@ -240,8 +224,1 @@\n-    private static class MappedDecl {\n-\n-        final int startPos;                                     \/\/ declaration's lexical starting position\n-        final int endPos;                                       \/\/ declaration's lexical ending position\n-        final Lint lint;                                        \/\/ the Lint configuration that applies at this declaration\n-        final Symbol symbol;                                    \/\/ declaration symbol (for debug purposes only; null for root)\n-        final MappedDecl parent;                                \/\/ the parent node of this node\n-        final List<MappedDecl> children;                        \/\/ the nested declarations one level below this node\n+    private record Span(int startPos, int endPos) {\n@@ -249,4 +226,1 @@\n-        \/\/ Create a node representing the entire file, using the root lint configuration\n-        MappedDecl(Lint rootLint) {\n-            this(Integer.MIN_VALUE, Integer.MAX_VALUE, rootLint, null, null);\n-        }\n+        static final Span MAXIMAL = new Span(Integer.MIN_VALUE, Integer.MAX_VALUE);\n@@ -254,22 +228,2 @@\n-        \/\/ Create a node representing the given declaration and its corresponding Lint configuration\n-        MappedDecl(JCTree tree, EndPosTable endPositions, Lint lint, Symbol symbol, MappedDecl parent) {\n-            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions), lint, symbol, parent);\n-            parent.children.add(this);\n-        }\n-\n-        MappedDecl(int startPos, int endPos, Lint lint, Symbol symbol, MappedDecl parent) {\n-            this.startPos = startPos;\n-            this.endPos = endPos;\n-            this.lint = lint;\n-            this.symbol = symbol;\n-            this.parent = parent;\n-            this.children = new ArrayList<>();\n-        }\n-\n-        \/\/ Find the narrowest node in this tree (including me) that contains the given position, if any\n-        MappedDecl bestMatch(DiagnosticPosition pos) {\n-            return children.stream()\n-              .map(child -> child.bestMatch(pos))\n-              .filter(Objects::nonNull)\n-              .reduce((a, b) -> a.contains(b) ? b : a)\n-              .orElseGet(() -> contains(pos) ? this : null);\n+        Span(JCTree tree, EndPosTable endPositions) {\n+            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions));\n@@ -279,1 +233,2 @@\n-            return FileInfo.contains(startPos, endPos, pos);\n+            int offset = pos.getLintPosition();\n+            return offset == startPos || (offset > startPos && offset < endPos);\n@@ -282,1 +237,1 @@\n-        boolean contains(MappedDecl that) {\n+        boolean contains(Span that) {\n@@ -285,6 +240,0 @@\n-\n-        @Override\n-        public String toString() {\n-            String label = symbol != null ? \"sym=\" + symbol : \"ROOT\";\n-            return String.format(\"MappedDecl[%d-%d,%s,lint=%s]\", startPos, endPos, label, lint);\n-        }\n@@ -293,1 +242,1 @@\n-\/\/ MappedDeclBuilder\n+\/\/ LintRange\n@@ -296,2 +245,1 @@\n-     * Builds a tree of {@link MappedDecl}s starting from a top-level declaration.\n-     * The tree is sparse: only declarations that differ from their parent are included.\n+     * A tree of nested lexical ranges and the {@link Lint} configurations that apply therein.\n@@ -299,1 +247,7 @@\n-    private static class MappedDeclBuilder extends TreeScanner {\n+    private record LintRange(\n+        Span span,                                      \/\/ declaration's lexical range\n+        Lint lint,                                      \/\/ the Lint configuration that applies at this declaration\n+        Symbol symbol,                                  \/\/ declaration symbol (for debug purposes only; null for root)\n+        LintRange parent,                               \/\/ the parent node of this node\n+        List<LintRange> children                        \/\/ the nested declarations one level below this node\n+    ) {\n@@ -301,19 +255,3 @@\n-        private final EndPosTable endPositions;\n-\n-        private MappedDecl parent;\n-        private Lint lint;\n-\n-        MappedDeclBuilder(MappedDecl rootNode, EndPosTable endPositions) {\n-            this.endPositions = endPositions;\n-            this.parent = rootNode;\n-            this.lint = rootNode.lint;              \/\/ i.e, rootLint\n-        }\n-\n-        @Override\n-        public void visitModuleDef(JCModuleDecl tree) {\n-            scanDecl(tree, tree.sym, super::visitModuleDef);\n-        }\n-\n-        @Override\n-        public void visitPackageDef(JCPackageDecl tree) {\n-            scanDecl(tree, tree.packge, super::visitPackageDef);\n+        \/\/ Create a node representing the entire file, using the root lint configuration\n+        LintRange(Lint rootLint) {\n+            this(Span.MAXIMAL, rootLint, null, null, new ArrayList<>());\n@@ -322,3 +260,4 @@\n-        @Override\n-        public void visitClassDef(JCClassDecl tree) {\n-            scanDecl(tree, tree.sym, super::visitClassDef);\n+        \/\/ Create a node representing the given declaration and its corresponding Lint configuration\n+        LintRange(JCTree tree, EndPosTable endPositions, Lint lint, Symbol symbol, LintRange parent) {\n+            this(new Span(tree, endPositions), lint, symbol, parent, new ArrayList<>());\n+            parent.children.add(this);\n@@ -327,3 +266,7 @@\n-        @Override\n-        public void visitMethodDef(JCMethodDecl tree) {\n-            scanDecl(tree, tree.sym, super::visitMethodDef);\n+        \/\/ Find the most specific node in this tree (including me) that contains the given position, if any\n+        LintRange bestMatch(DiagnosticPosition pos) {\n+            return children.stream()\n+              .map(child -> child.bestMatch(pos))\n+              .filter(Objects::nonNull)\n+              .reduce((a, b) -> a.span.contains(b.span) ? b : a)\n+              .orElseGet(() -> span.contains(pos) ? this : null);\n@@ -332,4 +275,4 @@\n-        @Override\n-        public void visitVarDef(JCVariableDecl tree) {\n-            scanDecl(tree, tree.sym, super::visitVarDef);\n-        }\n+        \/\/ Populate a sparse subtree corresponding to the given nested declaration.\n+        \/\/ Only when the Lint configuration differs from the parent is a node added.\n+        void populateSubtree(JCTree tree, EndPosTable endPositions) {\n+            new TreeScanner() {\n@@ -337,1 +280,1 @@\n-        private <T extends JCTree> void scanDecl(T tree, Symbol symbol, Consumer<? super T> recursor) {\n+                private LintRange parent = LintRange.this;\n@@ -339,5 +282,20 @@\n-            \/\/ The \"symbol\" can be null if there were earlier errors; skip this declaration if so\n-            if (symbol == null) {\n-                recursor.accept(tree);\n-                return;\n-            }\n+                @Override\n+                public void visitModuleDef(JCModuleDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitModuleDef);\n+                }\n+                @Override\n+                public void visitPackageDef(JCPackageDecl tree) {\n+                    scanDecl(tree, tree.packge, super::visitPackageDef);\n+                }\n+                @Override\n+                public void visitClassDef(JCClassDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitClassDef);\n+                }\n+                @Override\n+                public void visitMethodDef(JCMethodDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitMethodDef);\n+                }\n+                @Override\n+                public void visitVarDef(JCVariableDecl tree) {\n+                    scanDecl(tree, tree.sym, super::visitVarDef);\n+                }\n@@ -345,13 +303,22 @@\n-            \/\/ Update the current Lint in effect\n-            Lint previousLint = lint;\n-            lint = lint.augment(symbol);            \/\/ note: lint.augment() returns the same instance if there's no change\n-\n-            \/\/ Add a MappedDecl node here, but only if this declaration's Lint configuration is different from its parent\n-            if (lint != previousLint) {\n-                MappedDecl node = new MappedDecl(tree, endPositions, lint, symbol, parent);\n-                parent = node;\n-                try {\n-                    recursor.accept(tree);\n-                } finally {\n-                    parent = node.parent;\n-                    lint = previousLint;\n+                private <T extends JCTree> void scanDecl(T tree, Symbol symbol, Consumer<? super T> recursor) {\n+\n+                    \/\/ The \"symbol\" can be null if there were earlier errors; skip this declaration if so\n+                    if (symbol == null) {\n+                        recursor.accept(tree);\n+                        return;\n+                    }\n+\n+                    \/\/ Update the Lint using the declaration; if there's no change, then we don't need a new node here\n+                    Lint newLint = parent.lint.augment(symbol);\n+                    if (newLint == parent.lint) {       \/\/ note: lint.augment() returns the same instance if there's no change\n+                        recursor.accept(tree);\n+                        return;\n+                    }\n+\n+                    \/\/ Add a new node here\n+                    LintRange node = parent = new LintRange(tree, endPositions, newLint, symbol, parent);\n+                    try {\n+                        recursor.accept(tree);\n+                    } finally {\n+                        parent = node.parent;\n+                    }\n@@ -359,3 +326,6 @@\n-            } else {\n-                recursor.accept(tree);\n-            }\n+            }.scan(tree);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"LintRange[span=%s,sym=%s,lint=%s,children=%s]\", span, symbol, lint, children);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":106,"deletions":136,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -5299,1 +5299,1 @@\n-        lintMapper.calculateLints(env.toplevel.sourcefile, env.tree);\n+        lintMapper.calculateLints(env.toplevel.sourcefile, env.tree, env.toplevel.endPositions);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}