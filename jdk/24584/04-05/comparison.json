{"files":[{"patch":"@@ -177,3 +177,3 @@\n-     * Initially (immediately after parsing), \"rootNode\" will have an (unmapped) {@link DeclNode} child corresponding\n-     * to each top-level declaration in the source file. As those top-level declarations are attributed, the corresponding\n-     * {@link DeclNode} child is replaced with a {@link MappedDeclNode}, created via {@link MappedDeclNodeBuilder}.\n+     * Initially (immediately after parsing), \"unmappedDecls\" will contain a {@link Decl} corresponding\n+     * to each top-level declaration in the source file. As those top-level declarations are attributed,\n+     * the {@link Decl} is removed and a {@link MappedDecl} is added to \"mappedDecls\".\n@@ -183,1 +183,2 @@\n-        final MappedDeclNode rootNode = new MappedDeclNode(rootLint);   \/\/ tree of this file's \"interesting\" declaration nodes\n+        final List<Decl> unmappedDecls = new ArrayList<>();         \/\/ unmapped (i.e., awaiting attribution) top-level declarations\n+        final MappedDecl mappedDecls = new MappedDecl(rootLint);    \/\/ root node with subtree for each mapped top-level declaration\n@@ -185,1 +186,1 @@\n-        \/\/ After parsing: Create the root node and its immediate (unmapped) children\n+        \/\/ After parsing: Create a Decl corresponding to each top-level declaration and add to \"unmappedDecls\"\n@@ -189,1 +190,2 @@\n-              .forEach(decl -> new DeclNode(rootNode, decl, tree.endPositions));\n+              .map(decl -> new Decl(decl, tree.endPositions))\n+              .forEach(unmappedDecls::add);\n@@ -192,1 +194,1 @@\n-        \/\/ After attribution: Replace top-level DeclNode child with a MappedDeclNode subtree\n+        \/\/ After attribution: Discard the Decl from \"unmappedDecls\" and add a corresponding MappedDecl to \"mappedDecls\"\n@@ -194,5 +196,8 @@\n-            Assert.check(rootNode != null, \"source not parsed\");\n-            DeclNode node = findTopNode(tree.pos(), true);\n-            Assert.check(node != null, \"unknown declaration\");\n-            Assert.check(!(node instanceof MappedDeclNode), \"duplicate call\");\n-            new MappedDeclNodeBuilder(rootNode, endPositions).scan(tree);\n+            for (Iterator<Decl> i = unmappedDecls.iterator(); i.hasNext(); ) {\n+                if (i.next().contains(tree.pos())) {\n+                    new MappedDeclBuilder(mappedDecls, endPositions).scan(tree);\n+                    i.remove();\n+                    return;\n+                }\n+            }\n+            throw new AssertionError(\"top-level declaration not found\");\n@@ -203,21 +208,3 @@\n-            return switch (findTopNode(pos, false)) {       \/\/ find the top-level declaration containing \"pos\", if any\n-            case MappedDeclNode node                        \/\/ if the declaration has been attributed...\n-              -> Optional.of(node.find(pos).lint);          \/\/  -> return the most specific applicable Lint configuration\n-            case DeclNode node                              \/\/ if the declaration has not been attributed...\n-              -> Optional.empty();                          \/\/  -> we don't know yet\n-            case null                                       \/\/ if \"pos\" is outside of any declaration...\n-              -> Optional.of(rootLint);                     \/\/  -> use the root lint\n-            };\n-        }\n-\n-        \/\/ Find (and optionally remove) the top-level declaration containing \"pos\", if any\n-        DeclNode findTopNode(DiagnosticPosition pos, boolean remove) {\n-            for (Iterator<DeclNode> i = rootNode.children.iterator(); i.hasNext(); ) {\n-                DeclNode node = i.next();\n-                if (node.contains(pos)) {\n-                    if (remove)\n-                        i.remove();\n-                    return node;\n-                }\n-            }\n-            return null;\n+            if (unmappedDecls.stream().anyMatch(decl -> decl.contains(pos)))    \/\/ the top level declaration is not mapped yet\n+                return Optional.empty();\n+            return Optional.of(mappedDecls.bestMatch(pos).lint);                \/\/ return the narrowest matching declaration\n@@ -233,1 +220,1 @@\n-\/\/ DeclNode\n+\/\/ Decl\n@@ -236,2 +223,1 @@\n-     * Represents the lexical range corresponding to a module, package, class, method, or variable declaration,\n-     * or a \"root\" representing an entire file.\n+     * Represents a lexical range corresponding to a module, package, class, method, or variable declaration.\n@@ -239,1 +225,1 @@\n-    private static class DeclNode {\n+    private static class Decl {\n@@ -241,3 +227,2 @@\n-        final int startPos;                                     \/\/ declaration's starting position\n-        final int endPos;                                       \/\/ declaration's ending position\n-        final MappedDeclNode parent;                            \/\/ the immediately containing declaration (null for root)\n+        final int startPos;\n+        final int endPos;\n@@ -245,1 +230,1 @@\n-        DeclNode(int startPos, int endPos, MappedDeclNode parent) {\n+        Decl(int startPos, int endPos) {\n@@ -248,3 +233,0 @@\n-            this.parent = parent;\n-            if (parent != null)\n-                parent.children.add(this);\n@@ -253,3 +235,2 @@\n-        \/\/ Create a node representing the given declaration\n-        DeclNode(MappedDeclNode parent, JCTree tree, EndPosTable endPositions) {\n-            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions), parent);\n+        Decl(JCTree tree, EndPosTable endPositions) {\n+            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions));\n@@ -263,1 +244,1 @@\n-        boolean contains(DeclNode that) {\n+        boolean contains(Decl that) {\n@@ -269,1 +250,1 @@\n-            return String.format(\"DeclNode[%d-%d]\", startPos, endPos);\n+            return String.format(\"Decl[%d-%d]\", startPos, endPos);\n@@ -273,0 +254,2 @@\n+\/\/ MappedDecl\n+\n@@ -274,1 +257,1 @@\n-     * A {@link DeclNode} for which the corresponding {@link Lint} configuration is known.\n+     * A declaration for which the corresponding {@link Lint} configuration is known.\n@@ -276,1 +259,1 @@\n-    private static class MappedDeclNode extends DeclNode {\n+    private static class MappedDecl extends Decl {\n@@ -278,1 +261,0 @@\n-        final Symbol symbol;                                    \/\/ declaration symbol (null for root; for debug purposes only)\n@@ -280,1 +262,3 @@\n-        final List<DeclNode> children = new ArrayList<>();      \/\/ the nested declarations one level below this node\n+        final Symbol symbol;                                    \/\/ declaration symbol (for debug purposes only; null for root)\n+        final MappedDecl parent;                                \/\/ the parent node of this node\n+        final List<MappedDecl> children = new ArrayList<>();    \/\/ the nested declarations one level below this node\n@@ -283,3 +267,2 @@\n-        MappedDeclNode(Lint rootLint) {\n-            super(Integer.MIN_VALUE, Integer.MAX_VALUE, null);\n-            this.symbol = null;\n+        MappedDecl(Lint rootLint) {\n+            super(Integer.MIN_VALUE, Integer.MAX_VALUE);\n@@ -287,0 +270,2 @@\n+            this.symbol = null;\n+            this.parent = null;\n@@ -290,3 +275,2 @@\n-        MappedDeclNode(Symbol symbol, MappedDeclNode parent, JCTree tree, EndPosTable endPositions, Lint lint) {\n-            super(parent, tree, endPositions);\n-            this.symbol = symbol;\n+        MappedDecl(Symbol symbol, MappedDecl parent, JCTree tree, EndPosTable endPositions, Lint lint) {\n+            super(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions));\n@@ -294,0 +278,3 @@\n+            this.symbol = symbol;\n+            this.parent = parent;\n+            parent.children.add(this);\n@@ -297,1 +284,1 @@\n-        MappedDeclNode find(DiagnosticPosition pos) {\n+        MappedDecl bestMatch(DiagnosticPosition pos) {\n@@ -299,2 +286,1 @@\n-              .map(MappedDeclNode.class::cast)      \/\/ this cast is ok because this method is never invoked on the root instance\n-              .map(child -> child.find(pos))\n+              .map(child -> child.bestMatch(pos))\n@@ -309,1 +295,1 @@\n-            return String.format(\"MappedDeclNode[%d-%d,%s,lint=%s]\", startPos, endPos, label, lint);\n+            return String.format(\"MappedDecl[%d-%d,%s,lint=%s]\", startPos, endPos, label, lint);\n@@ -313,1 +299,1 @@\n-\/\/ MappedDeclNodeBuilder\n+\/\/ MappedDeclBuilder\n@@ -316,1 +302,2 @@\n-     * Builds a tree of {@link MappedDeclNode}s starting from a top-level declaration.\n+     * Builds a tree of {@link MappedDecl}s starting from a top-level declaration.\n+     * The tree is sparse: only \"interesting\" declarations are included.\n@@ -318,1 +305,1 @@\n-    private class MappedDeclNodeBuilder extends TreeScanner {\n+    private class MappedDeclBuilder extends TreeScanner {\n@@ -322,1 +309,1 @@\n-        private MappedDeclNode parent;\n+        private MappedDecl parent;\n@@ -325,1 +312,1 @@\n-        MappedDeclNodeBuilder(MappedDeclNode rootNode, EndPosTable endPositions) {\n+        MappedDeclBuilder(MappedDecl rootNode, EndPosTable endPositions) {\n@@ -368,1 +355,1 @@\n-            \/\/ If this declaration is not \"interesting\", we don't need to create a DeclNode for it\n+            \/\/ If this declaration is not \"interesting\", we don't need to create a MappedDecl for it\n@@ -374,2 +361,2 @@\n-            \/\/ Add a MappedDeclNode here\n-            MappedDeclNode node = new MappedDeclNode(symbol, parent, tree, endPositions, lint);\n+            \/\/ Add a MappedDecl here\n+            MappedDecl node = new MappedDecl(symbol, parent, tree, endPositions, lint);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":58,"deletions":71,"binary":false,"changes":129,"status":"modified"}]}