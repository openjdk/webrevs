{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Iterator;\n@@ -74,1 +75,1 @@\n-    \/\/ Per-source file lint information\n+    \/\/ Per-source file information. Note: during the parsing of a file, an entry exists but the FileInfo value is null\n@@ -125,1 +126,1 @@\n-     * @return the applicable {@link Lint}, if known\n+     * @return the applicable {@link Lint}, if known, otherwise empty\n@@ -155,1 +156,1 @@\n-     * Invoked when file parsing starts to create an entry for the new file.\n+     * Invoked when file parsing starts to create an entry for the new file (but with a null value).\n@@ -159,1 +160,1 @@\n-        fileInfoMap.put(sourceFile, new FileInfo());\n+        fileInfoMap.put(sourceFile, null);\n@@ -163,1 +164,1 @@\n-     * Invoked when file parsing completes to identify the top-level declarations.\n+     * Invoked when file parsing completes to put in place a corresponding {@link FileInfo}.\n@@ -167,1 +168,1 @@\n-        fileInfoMap.get(tree.sourcefile).afterParse(tree);\n+        fileInfoMap.put(tree.sourcefile, new FileInfo(tree));\n@@ -173,1 +174,1 @@\n-     * Holds {@link Lint} information for one source file.\n+     * Holds {@link Lint} information for a fully parsed source file.\n@@ -176,8 +177,3 @@\n-     * Instances evolve through three states:\n-     * <ul>\n-     *  <li>Before the file has been completely parsed, {@link #topSpans} is null.\n-     *  <li>Immediately after the file has been parsed, {@link #topSpans} contains zero or more {@link Span}s\n-     *      corresponding to the top-level declarations in the file, and {@code rootNode} has no children.\n-     *  <li>When a top-level declaration is attributed, a corresponding {@link DeclNode} child matching one\n-     *      of the {@link Span}s in {@link #topSpans} is created and added to {@link #rootNode}.\n-     * <\/ul>\n+     * Initially (immediately after parsing), \"rootNode\" will have an (unmapped) {@link DeclNode} child corresponding\n+     * to each top-level declaration in the source file. As those top-level declarations are attributed, the corresponding\n+     * {@link DeclNode} child is replaced with a {@link MappedDeclNode}, created via {@link MappedDeclNodeBuilder}.\n@@ -187,2 +183,1 @@\n-        List<Span> topSpans;                                \/\/ the spans of all top level declarations\n-        final DeclNode rootNode = new DeclNode(rootLint);   \/\/ tree of file's \"interesting\" declaration nodes\n+        final MappedDeclNode rootNode = new MappedDeclNode(rootLint);   \/\/ tree of this file's \"interesting\" declaration nodes\n@@ -190,16 +185,3 @@\n-        \/\/ Find the Lint that applies to the given position, if known\n-        Optional<Lint> lintAt(DiagnosticPosition pos) {\n-            if (topSpans == null)                           \/\/ has the file been parsed yet?\n-                return Optional.empty();                    \/\/ -> no, we don't know yet\n-            if (!findTopSpan(pos).isPresent())              \/\/ is the position within some top-level declaration?\n-                return Optional.of(rootLint);               \/\/ -> no, use the root lint\n-            DeclNode topNode = findTopNode(pos);\n-            if (topNode == null)                            \/\/ has that declaration been attributed yet?\n-                return Optional.empty();                    \/\/ -> no, we don't know yet\n-            DeclNode node = topNode.find(pos);              \/\/ find the best matching node (it must exist)\n-            return Optional.of(node.lint);                  \/\/ use its Lint\n-        }\n-\n-        void afterParse(JCCompilationUnit tree) {\n-            Assert.check(topSpans == null, \"source already parsed\");\n-            topSpans = tree.defs.stream()\n+        \/\/ After parsing: Create the root node and its immediate (unmapped) children\n+        FileInfo(JCCompilationUnit tree) {\n+            tree.defs.stream()\n@@ -207,2 +189,1 @@\n-              .map(decl -> new Span(decl, tree.endPositions))\n-              .collect(Collectors.toList());\n+              .forEach(decl -> new DeclNode(rootNode, decl, tree.endPositions));\n@@ -211,0 +192,1 @@\n+        \/\/ After attribution: Replace top-level DeclNode child with a MappedDeclNode subtree\n@@ -212,3 +194,5 @@\n-            Assert.check(topSpans != null, \"source not parsed\");\n-            Assert.check(findTopNode(tree.pos()) == null, \"duplicate call\");\n-            new DeclNodeTreeBuilder(rootNode, endPositions).scan(tree);\n+            Assert.check(rootNode != null, \"source not parsed\");\n+            DeclNode node = findTopNode(tree.pos(), true);\n+            Assert.check(node != null, \"unknown declaration\");\n+            Assert.check(!(node instanceof MappedDeclNode), \"duplicate call\");\n+            new MappedDeclNodeBuilder(rootNode, endPositions).scan(tree);\n@@ -217,4 +201,10 @@\n-        Optional<Span> findTopSpan(DiagnosticPosition pos) {\n-            return topSpans.stream()\n-              .filter(span -> span.contains(pos))\n-              .findFirst();\n+        \/\/ Find the Lint configuration that applies to the given position, if known\n+        Optional<Lint> lintAt(DiagnosticPosition pos) {\n+            return switch (findTopNode(pos, false)) {       \/\/ find the top-level declaration containing \"pos\", if any\n+            case MappedDeclNode node                        \/\/ if the declaration has been attributed...\n+              -> Optional.of(node.find(pos).lint);          \/\/  -> return the most specific applicable Lint configuration\n+            case DeclNode node                              \/\/ if the declaration has not been attributed...\n+              -> Optional.empty();                          \/\/  -> we don't know yet\n+            case null                                       \/\/ if \"pos\" is outside of any declaration...\n+              -> Optional.of(rootLint);                     \/\/  -> use the root lint\n+            };\n@@ -223,5 +213,11 @@\n-        DeclNode findTopNode(DiagnosticPosition pos) {\n-            return rootNode.children.stream()\n-              .filter(node -> node.contains(pos))\n-              .findFirst()\n-              .orElse(null);\n+        \/\/ Find (and optionally remove) the top-level declaration containing \"pos\", if any\n+        DeclNode findTopNode(DiagnosticPosition pos, boolean remove) {\n+            for (Iterator<DeclNode> i = rootNode.children.iterator(); i.hasNext(); ) {\n+                DeclNode node = i.next();\n+                if (node.contains(pos)) {\n+                    if (remove)\n+                        i.remove();\n+                    return node;\n+                }\n+            }\n+            return null;\n@@ -237,1 +233,1 @@\n-\/\/ Span\n+\/\/ DeclNode\n@@ -240,1 +236,2 @@\n-     * Represents a lexical range in a file.\n+     * Represents the lexical range corresponding to a module, package, class, method, or variable declaration,\n+     * or a \"root\" representing an entire file.\n@@ -242,1 +239,1 @@\n-    private static class Span {\n+    private static class DeclNode {\n@@ -244,2 +241,3 @@\n-        final int startPos;\n-        final int endPos;\n+        final int startPos;                                     \/\/ declaration's starting position\n+        final int endPos;                                       \/\/ declaration's ending position\n+        final MappedDeclNode parent;                            \/\/ the immediately containing declaration (null for root)\n@@ -247,1 +245,1 @@\n-        Span(int startPos, int endPos) {\n+        DeclNode(int startPos, int endPos, MappedDeclNode parent) {\n@@ -250,0 +248,3 @@\n+            this.parent = parent;\n+            if (parent != null)\n+                parent.children.add(this);\n@@ -252,6 +253,3 @@\n-        Span(JCTree tree, EndPosTable endPositions) {\n-            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions));\n-        }\n-\n-        boolean contains(int pos) {\n-            return pos == startPos || (pos > startPos && pos < endPos);\n+        \/\/ Create a node representing the given declaration\n+        DeclNode(MappedDeclNode parent, JCTree tree, EndPosTable endPositions) {\n+            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions), parent);\n@@ -261,1 +259,2 @@\n-            return contains(pos.getLintPosition());\n+            int offset = pos.getLintPosition();\n+            return offset == startPos || (offset > startPos && offset < endPos);\n@@ -264,1 +263,1 @@\n-        boolean contains(Span that) {\n+        boolean contains(DeclNode that) {\n@@ -270,1 +269,1 @@\n-            return String.format(\"Span[%d-%d]\", startPos, endPos);\n+            return String.format(\"DeclNode[%d-%d]\", startPos, endPos);\n@@ -274,2 +273,0 @@\n-\/\/ DeclNode\n-\n@@ -277,5 +274,1 @@\n-     * Represents a declaration and the {@link Lint} configuration that applies within its lexical range.\n-     *\n-     * <p>\n-     * For each file, there is a root node represents the entire source file. At the next level down are\n-     * nodes representing the top-level declarations in the file, and so on.\n+     * A {@link DeclNode} for which the corresponding {@link Lint} configuration is known.\n@@ -283,1 +276,1 @@\n-    private static class DeclNode extends Span {\n+    private static class MappedDeclNode extends DeclNode {\n@@ -285,3 +278,1 @@\n-        final Symbol symbol;                                    \/\/ the symbol declared by this declaration (null for root)\n-        final DeclNode parent;                                  \/\/ the immediately containing declaration (null for root)\n-        final List<DeclNode> children = new ArrayList<>();      \/\/ the immediately next level down declarations under this node\n+        final Symbol symbol;                                    \/\/ declaration symbol (null for root; for debug purposes only)\n@@ -289,0 +280,1 @@\n+        final List<DeclNode> children = new ArrayList<>();      \/\/ the nested declarations one level below this node\n@@ -290,3 +282,3 @@\n-        \/\/ Create a root node representing the entire file\n-        DeclNode(Lint rootLint) {\n-            super(Integer.MIN_VALUE, Integer.MAX_VALUE);\n+        \/\/ Create a node representing the entire file, using the root lint configuration\n+        MappedDeclNode(Lint rootLint) {\n+            super(Integer.MIN_VALUE, Integer.MAX_VALUE, null);\n@@ -294,1 +286,0 @@\n-            this.parent = null;\n@@ -298,3 +289,3 @@\n-        \/\/ Create a normal declaration node\n-        DeclNode(Symbol symbol, DeclNode parent, JCTree tree, EndPosTable endPositions, Lint lint) {\n-            super(tree, endPositions);\n+        \/\/ Create a node representing the given declaration and its corresponding Lint configuration\n+        MappedDeclNode(Symbol symbol, MappedDeclNode parent, JCTree tree, EndPosTable endPositions, Lint lint) {\n+            super(parent, tree, endPositions);\n@@ -302,1 +293,0 @@\n-            this.parent = parent;\n@@ -304,1 +294,0 @@\n-            parent.children.add(this);\n@@ -307,2 +296,2 @@\n-        \/\/ Find the narrowest node in this tree that contains the given position, if any\n-        DeclNode find(DiagnosticPosition pos) {\n+        \/\/ Find the narrowest node in this tree (including me) that contains the given position, if any\n+        MappedDeclNode find(DiagnosticPosition pos) {\n@@ -310,0 +299,1 @@\n+              .map(MappedDeclNode.class::cast)      \/\/ this cast is ok because this method is never invoked on the root instance\n@@ -316,5 +306,0 @@\n-        \/\/ Stream this node and all descendents via pre-order recursive descent\n-        Stream<DeclNode> stream() {\n-            return Stream.concat(Stream.of(this), children.stream().flatMap(DeclNode::stream));\n-        }\n-\n@@ -324,1 +309,1 @@\n-            return String.format(\"DeclNode[%s,lint=%s]\", label, lint);\n+            return String.format(\"MappedDeclNode[%d-%d,%s,lint=%s]\", startPos, endPos, label, lint);\n@@ -328,1 +313,1 @@\n-\/\/ DeclNodeTreeBuilder\n+\/\/ MappedDeclNodeBuilder\n@@ -331,1 +316,1 @@\n-     * Builds a tree of {@link DeclNode}s starting from a top-level declaration.\n+     * Builds a tree of {@link MappedDeclNode}s starting from a top-level declaration.\n@@ -333,1 +318,1 @@\n-    private class DeclNodeTreeBuilder extends TreeScanner {\n+    private class MappedDeclNodeBuilder extends TreeScanner {\n@@ -337,1 +322,1 @@\n-        private DeclNode parent;\n+        private MappedDeclNode parent;\n@@ -340,1 +325,1 @@\n-        DeclNodeTreeBuilder(DeclNode rootNode, EndPosTable endPositions) {\n+        MappedDeclNodeBuilder(MappedDeclNode rootNode, EndPosTable endPositions) {\n@@ -389,2 +374,2 @@\n-            \/\/ Add a DeclNode here\n-            DeclNode node = new DeclNode(symbol, parent, tree, endPositions, lint);\n+            \/\/ Add a MappedDeclNode here\n+            MappedDeclNode node = new MappedDeclNode(symbol, parent, tree, endPositions, lint);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":82,"deletions":97,"binary":false,"changes":179,"status":"modified"}]}