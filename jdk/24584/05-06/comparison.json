{"files":[{"patch":"@@ -141,1 +141,1 @@\n-    public void calculateLints(JavaFileObject sourceFile, JCTree tree, EndPosTable endPositions) {\n+    public void calculateLints(JavaFileObject sourceFile, JCTree tree) {\n@@ -143,1 +143,1 @@\n-        fileInfoMap.get(sourceFile).afterAttr(tree, endPositions);\n+        fileInfoMap.get(sourceFile).afterAttr(tree);\n@@ -168,1 +168,1 @@\n-        fileInfoMap.put(tree.sourcefile, new FileInfo(tree));\n+        fileInfoMap.put(tree.sourcefile, new FileInfo(rootLint, tree));\n@@ -177,1 +177,1 @@\n-     * Initially (immediately after parsing), \"unmappedDecls\" will contain a {@link Decl} corresponding\n+     * Initially (immediately after parsing), \"unmappedDecls\" will contain a {@link JCTree} corresponding\n@@ -179,1 +179,1 @@\n-     * the {@link Decl} is removed and a {@link MappedDecl} is added to \"mappedDecls\".\n+     * the {@link JCTree} is removed and a new {@link MappedDecl} subtree is added to the \"mappedDecls\" tree.\n@@ -181,1 +181,1 @@\n-    private class FileInfo {\n+    private static class FileInfo {\n@@ -183,2 +183,3 @@\n-        final List<Decl> unmappedDecls = new ArrayList<>();         \/\/ unmapped (i.e., awaiting attribution) top-level declarations\n-        final MappedDecl mappedDecls = new MappedDecl(rootLint);    \/\/ root node with subtree for each mapped top-level declaration\n+        EndPosTable endPositions;                           \/\/ end position table for this source file (only during attribution)\n+        final MappedDecl mappedDecls;                       \/\/ root node with subtree for each mapped top-level declaration\n+        final List<JCTree> unmappedDecls;                   \/\/ unmapped (i.e., awaiting attribution) top-level declarations\n@@ -186,3 +187,5 @@\n-        \/\/ After parsing: Create a Decl corresponding to each top-level declaration and add to \"unmappedDecls\"\n-        FileInfo(JCCompilationUnit tree) {\n-            tree.defs.stream()\n+        \/\/ After parsing: Add top-level declarations to our \"unmappedDecls\" list\n+        FileInfo(Lint rootLint, JCCompilationUnit tree) {\n+            this.endPositions = tree.endPositions;\n+            this.mappedDecls = new MappedDecl(rootLint);\n+            this.unmappedDecls = tree.defs.stream()\n@@ -190,2 +193,1 @@\n-              .map(decl -> new Decl(decl, tree.endPositions))\n-              .forEach(unmappedDecls::add);\n+              .collect(Collectors.toCollection(ArrayList::new));\n@@ -194,5 +196,6 @@\n-        \/\/ After attribution: Discard the Decl from \"unmappedDecls\" and add a corresponding MappedDecl to \"mappedDecls\"\n-        void afterAttr(JCTree tree, EndPosTable endPositions) {\n-            for (Iterator<Decl> i = unmappedDecls.iterator(); i.hasNext(); ) {\n-                if (i.next().contains(tree.pos())) {\n-                    new MappedDeclBuilder(mappedDecls, endPositions).scan(tree);\n+        \/\/ After attribution: Discard the tree from \"unmappedDecls\" and add a corresponding MappedDecl to \"mappedDecls\"\n+        void afterAttr(JCTree tree) {\n+            MappedDeclBuilder builder = null;\n+            for (Iterator<JCTree> i = unmappedDecls.iterator(); i.hasNext(); ) {\n+                if (contains(i.next(), tree.pos())) {\n+                    builder = new MappedDeclBuilder(mappedDecls, endPositions);\n@@ -200,1 +203,1 @@\n-                    return;\n+                    break;\n@@ -203,1 +206,4 @@\n-            throw new AssertionError(\"top-level declaration not found\");\n+            Assert.check(builder != null, \"top-level declaration not found\");\n+            builder.scan(tree);\n+            if (unmappedDecls.isEmpty())\n+                endPositions = null;                        \/\/ gc friendly\n@@ -206,1 +212,1 @@\n-        \/\/ Find the Lint configuration that applies to the given position, if known\n+        \/\/ Find the (narrowest) Lint that applies to the given position, unless the position has not been mapped yet\n@@ -208,3 +214,6 @@\n-            if (unmappedDecls.stream().anyMatch(decl -> decl.contains(pos)))    \/\/ the top level declaration is not mapped yet\n-                return Optional.empty();\n-            return Optional.of(mappedDecls.bestMatch(pos).lint);                \/\/ return the narrowest matching declaration\n+            boolean mapped = unmappedDecls.stream().noneMatch(tree -> contains(tree, pos));\n+            return mapped ? Optional.of(mappedDecls.bestMatch(pos).lint) : Optional.empty();\n+        }\n+\n+        boolean contains(JCTree tree, DiagnosticPosition pos) {\n+            return FileInfo.contains(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions), pos);\n@@ -218,16 +227,0 @@\n-    }\n-\n-\/\/ Decl\n-\n-    \/**\n-     * Represents a lexical range corresponding to a module, package, class, method, or variable declaration.\n-     *\/\n-    private static class Decl {\n-\n-        final int startPos;\n-        final int endPos;\n-\n-        Decl(int startPos, int endPos) {\n-            this.startPos = startPos;\n-            this.endPos = endPos;\n-        }\n@@ -235,5 +228,1 @@\n-        Decl(JCTree tree, EndPosTable endPositions) {\n-            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions));\n-        }\n-\n-        boolean contains(DiagnosticPosition pos) {\n+        static boolean contains(int startPos, int endPos, DiagnosticPosition pos) {\n@@ -243,9 +232,0 @@\n-\n-        boolean contains(Decl that) {\n-            return this.startPos <= that.startPos && this.endPos >= that.endPos;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return String.format(\"Decl[%d-%d]\", startPos, endPos);\n-        }\n@@ -257,1 +237,2 @@\n-     * A declaration for which the corresponding {@link Lint} configuration is known.\n+     * A module, package, class, method, or variable declaration within which all {@link Lint} configurations are known.\n+     * There is also a root instance that represents the entire file.\n@@ -259,1 +240,1 @@\n-    private static class MappedDecl extends Decl {\n+    private static class MappedDecl {\n@@ -261,0 +242,2 @@\n+        final int startPos;                                     \/\/ declaration's lexical starting position\n+        final int endPos;                                       \/\/ declaration's lexical ending position\n@@ -264,1 +247,1 @@\n-        final List<MappedDecl> children = new ArrayList<>();    \/\/ the nested declarations one level below this node\n+        final List<MappedDecl> children;                        \/\/ the nested declarations one level below this node\n@@ -268,4 +251,1 @@\n-            super(Integer.MIN_VALUE, Integer.MAX_VALUE);\n-            this.lint = rootLint;\n-            this.symbol = null;\n-            this.parent = null;\n+            this(Integer.MIN_VALUE, Integer.MAX_VALUE, rootLint, null, null);\n@@ -275,2 +255,8 @@\n-        MappedDecl(Symbol symbol, MappedDecl parent, JCTree tree, EndPosTable endPositions, Lint lint) {\n-            super(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions));\n+        MappedDecl(JCTree tree, EndPosTable endPositions, Lint lint, Symbol symbol, MappedDecl parent) {\n+            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions), lint, symbol, parent);\n+            parent.children.add(this);\n+        }\n+\n+        MappedDecl(int startPos, int endPos, Lint lint, Symbol symbol, MappedDecl parent) {\n+            this.startPos = startPos;\n+            this.endPos = endPos;\n@@ -280,1 +266,1 @@\n-            parent.children.add(this);\n+            this.children = new ArrayList<>();\n@@ -292,0 +278,8 @@\n+        boolean contains(DiagnosticPosition pos) {\n+            return FileInfo.contains(startPos, endPos, pos);\n+        }\n+\n+        boolean contains(MappedDecl that) {\n+            return this.startPos <= that.startPos && this.endPos >= that.endPos;\n+        }\n+\n@@ -303,1 +297,1 @@\n-     * The tree is sparse: only \"interesting\" declarations are included.\n+     * The tree is sparse: only declarations that differ from their parent are included.\n@@ -305,1 +299,1 @@\n-    private class MappedDeclBuilder extends TreeScanner {\n+    private static class MappedDeclBuilder extends TreeScanner {\n@@ -343,1 +337,1 @@\n-        private <T extends JCTree> void scanDecl(T tree, Symbol symbol, Consumer<? super T> recursion) {\n+        private <T extends JCTree> void scanDecl(T tree, Symbol symbol, Consumer<? super T> recursor) {\n@@ -345,1 +339,1 @@\n-            \/\/ \"symbol\" can be null if there were earlier errors; skip this declaration if so\n+            \/\/ The \"symbol\" can be null if there were earlier errors; skip this declaration if so\n@@ -347,1 +341,1 @@\n-                recursion.accept(tree);\n+                recursor.accept(tree);\n@@ -351,1 +345,1 @@\n-            \/\/ Update the current Lint in effect; note lint.augment() returns the same instance if there's no change\n+            \/\/ Update the current Lint in effect\n@@ -353,16 +347,14 @@\n-            lint = lint.augment(symbol);\n-\n-            \/\/ If this declaration is not \"interesting\", we don't need to create a MappedDecl for it\n-            if (lint == previousLint && parent.parent != null) {\n-                recursion.accept(tree);\n-                return;\n-            }\n-\n-            \/\/ Add a MappedDecl here\n-            MappedDecl node = new MappedDecl(symbol, parent, tree, endPositions, lint);\n-            parent = node;\n-            try {\n-                recursion.accept(tree);\n-            } finally {\n-                parent = node.parent;\n-                lint = previousLint;\n+            lint = lint.augment(symbol);            \/\/ note: lint.augment() returns the same instance if there's no change\n+\n+            \/\/ Add a MappedDecl node here, but only if this declaration's Lint configuration is different from its parent\n+            if (lint != previousLint) {\n+                MappedDecl node = new MappedDecl(tree, endPositions, lint, symbol, parent);\n+                parent = node;\n+                try {\n+                    recursor.accept(tree);\n+                } finally {\n+                    parent = node.parent;\n+                    lint = previousLint;\n+                }\n+            } else {\n+                recursor.accept(tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":78,"deletions":86,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -5299,1 +5299,1 @@\n-        lintMapper.calculateLints(env.toplevel.sourcefile, env.tree, env.toplevel.endPositions);\n+        lintMapper.calculateLints(env.toplevel.sourcefile, env.tree);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}