{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -415,0 +415,1 @@\n+            compiler.log.reportOutstandingWarnings();\n@@ -486,1 +487,2 @@\n-            if (compiler != null)\n+            if (compiler != null) {\n+                compiler.log.reportOutstandingWarnings();\n@@ -488,0 +490,1 @@\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskImpl.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -271,0 +272,1 @@\n+                LintMapper.instance(this).clear();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskPool.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -363,3 +363,8 @@\n-                    Type t = attr.attribType(dcReference.qualifierExpression, env);\n-                    if (t != null && !t.isErroneous()) {\n-                        return t;\n+                    JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n+                    try {\n+                        Type t = attr.attribType(dcReference.qualifierExpression, env);\n+                        if (t != null && !t.isErroneous()) {\n+                            return t;\n+                        }\n+                    } finally {\n+                        log.useSource(prevSource);\n@@ -391,0 +396,1 @@\n+        JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);\n@@ -512,0 +518,1 @@\n+            log.useSource(prevSource);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,176 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.javac.code;\n-\n-import java.util.ArrayDeque;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Optional;\n-import java.util.function.Consumer;\n-\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.tree.JCTree.Tag;\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.Context;\n-\n-\/**\n- * Holds pending {@link Lint} warnings until the {@lint Lint} instance associated with the containing\n- * module, package, class, method, or variable declaration is known so that {@link @SupressWarnings}\n- * suppressions may be applied.\n- *\n- * <p>\n- * Warnings are regsistered at any time prior to attribution via {@link #report}. The warning will be\n- * associated with the declaration placed in context by the most recent invocation of {@link #push push()}\n- * not yet {@link #pop}'d. Warnings are actually emitted later, during attribution, via {@link #flush}.\n- *\n- * <p>\n- * There is also an \"immediate\" mode, where warnings are emitted synchronously; see {@link #pushImmediate}.\n- *\n- * <p>\n- * Deferred warnings are grouped by the innermost containing module, package, class, method, or variable\n- * declaration (represented by {@link JCTree} nodes), so that the corresponding {@link Lint} configuration\n- * can be applied when the warning is eventually generated.\n- *\n- * <p><b>This is NOT part of any supported API.\n- * If you write code that depends on this, you do so at your own risk.\n- * This code and its internal interfaces are subject to change or\n- * deletion without notice.<\/b>\n- *\/\n-public class DeferredLintHandler {\n-\n-    protected static final Context.Key<DeferredLintHandler> deferredLintHandlerKey = new Context.Key<>();\n-\n-    public static DeferredLintHandler instance(Context context) {\n-        DeferredLintHandler instance = context.get(deferredLintHandlerKey);\n-        if (instance == null)\n-            instance = new DeferredLintHandler(context);\n-        return instance;\n-    }\n-\n-    \/**\n-     * Registered {@link LintLogger}s grouped by the innermost containing module, package, class,\n-     * method, or variable declaration.\n-     *\/\n-    private final HashMap<JCTree, ArrayList<LintLogger>> deferralMap = new HashMap<>();\n-\n-    \/**\n-     * The current \"reporter\" stack, reflecting calls to {@link #push} and {@link #pop}.\n-     *\n-     * <p>\n-     * The top of the stack determines how calls to {@link #report} are handled.\n-     *\/\n-    private final ArrayDeque<Consumer<LintLogger>> reporterStack = new ArrayDeque<>();\n-\n-    @SuppressWarnings(\"this-escape\")\n-    protected DeferredLintHandler(Context context) {\n-        context.put(deferredLintHandlerKey, this);\n-        Lint rootLint = Lint.instance(context);\n-        pushImmediate(rootLint);            \/\/ default to \"immediate\" mode\n-    }\n-\n-\/\/ LintLogger\n-\n-    \/**An interface for deferred lint reporting - loggers passed to\n-     * {@link #report(LintLogger) } will be called when\n-     * {@link #flush(DiagnosticPosition) } is invoked.\n-     *\/\n-    public interface LintLogger {\n-\n-        \/**\n-         * Generate a warning if appropriate.\n-         *\n-         * @param lint the applicable lint configuration\n-         *\/\n-        void report(Lint lint);\n-    }\n-\n-\/\/ Reporter Stack\n-\n-    \/**\n-     * Defer {@link #report}ed warnings until the given declaration is flushed.\n-     *\n-     * @param decl module, package, class, method, or variable declaration\n-     * @see #pop\n-     *\/\n-    public void push(JCTree decl) {\n-        Assert.check(decl.getTag() == Tag.MODULEDEF\n-                  || decl.getTag() == Tag.PACKAGEDEF\n-                  || decl.getTag() == Tag.CLASSDEF\n-                  || decl.getTag() == Tag.METHODDEF\n-                  || decl.getTag() == Tag.VARDEF);\n-        reporterStack.push(logger -> deferralMap\n-                                        .computeIfAbsent(decl, s -> new ArrayList<>())\n-                                        .add(logger));\n-    }\n-\n-    \/**\n-     * Enter \"immediate\" mode so that {@link #report}ed warnings are emitted synchonously.\n-     *\n-     * @param lint lint configuration to use for reported warnings\n-     *\/\n-    public void pushImmediate(Lint lint) {\n-        reporterStack.push(logger -> logger.report(lint));\n-    }\n-\n-    \/**\n-     * Revert to the previous configuration in effect prior to the most recent invocation\n-     * of {@link #push} or {@link #pushImmediate}.\n-     *\n-     * @see #pop\n-     *\/\n-    public void pop() {\n-        Assert.check(reporterStack.size() > 1);     \/\/ the bottom stack entry should never be popped\n-        reporterStack.pop();\n-    }\n-\n-    \/**\n-     * Report a warning.\n-     *\n-     * <p>\n-     * In immediate mode, the warning is emitted synchronously. Otherwise, the warning is emitted later\n-     * when the current declaration is flushed.\n-     *\/\n-    public void report(LintLogger logger) {\n-        Assert.check(!reporterStack.isEmpty());\n-        reporterStack.peek().accept(logger);\n-    }\n-\n-\/\/ Warning Flush\n-\n-    \/**\n-     * Emit deferred warnings encompassed by the given declaration.\n-     *\n-     * @param decl module, package, class, method, or variable declaration\n-     * @param lint lint configuration corresponding to {@code decl}\n-     *\/\n-    public void flush(JCTree decl, Lint lint) {\n-        Optional.of(decl)\n-          .map(deferralMap::remove)\n-          .stream()\n-          .flatMap(ArrayList::stream)\n-          .forEach(logger -> logger.report(lint));\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/DeferredLintHandler.java","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"@@ -377,3 +377,0 @@\n-         *\n-         * <p>\n-         * This category is not supported by {@code @SuppressWarnings} (yet - see JDK-8224228).\n@@ -381,1 +378,1 @@\n-        TEXT_BLOCKS(\"text-blocks\", false),\n+        TEXT_BLOCKS(\"text-blocks\"),\n@@ -479,21 +476,0 @@\n-    \/**\n-     * Helper method. Log a lint warning if its lint category is enabled.\n-     *\n-     * @param warning key for the localized warning message\n-     *\/\n-    public void logIfEnabled(LintWarning warning) {\n-        logIfEnabled(null, warning);\n-    }\n-\n-    \/**\n-     * Helper method. Log a lint warning if its lint category is enabled.\n-     *\n-     * @param pos source position at which to report the warning\n-     * @param warning key for the localized warning message\n-     *\/\n-    public void logIfEnabled(DiagnosticPosition pos, LintWarning warning) {\n-        if (isEnabled(warning.getLintCategory())) {\n-            log.warning(pos, warning);\n-        }\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,385 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.code;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.tools.DiagnosticListener;\n+import javax.tools.JavaFileObject;\n+\n+import com.sun.tools.javac.tree.EndPosTable;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.util.Assert;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+\n+\/**\n+ * Maps source code positions to the applicable {@link Lint} instance.\n+ *\n+ * <p>\n+ * Because {@code @SuppressWarnings} is a Java symbol, in general this mapping can't be\n+ * calculated until after attribution. As each top-level declaration (class, package, or module)\n+ * is attributed, this singleton is notified and the {@link Lint}s that apply to every source\n+ * position within that top-level declaration are calculated.\n+ *\n+ * <p>\n+ * The method {@link #lintAt} returns the {@link Lint} instance applicable to source position;\n+ * if it can't be determined yet, an empty {@link Optional} is returned.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n+public class LintMapper {\n+\n+    \/\/ The key for the context singleton\n+    private static final Context.Key<LintMapper> CONTEXT_KEY = new Context.Key<>();\n+\n+    \/\/ Per-source file information. Note: during the parsing of a file, an entry exists but the FileInfo value is null\n+    private final Map<JavaFileObject, FileInfo> fileInfoMap = new HashMap<>();\n+\n+    \/\/ Compiler context\n+    private final Context context;\n+\n+    \/\/ These are initialized lazily; see initializeIfNeeded()\n+    private Lint rootLint;\n+\n+    \/**\n+     * Obtain the {@link LintMapper} context singleton.\n+     *\/\n+    public static LintMapper instance(Context context) {\n+        LintMapper instance = context.get(CONTEXT_KEY);\n+        if (instance == null)\n+            instance = new LintMapper(context);\n+        return instance;\n+    }\n+\n+    \/**\n+     * Constructor.\n+     *\/\n+    @SuppressWarnings(\"this-escape\")\n+    protected LintMapper(Context context) {\n+        context.put(CONTEXT_KEY, this);\n+        this.context = context;\n+    }\n+\n+    \/\/ Lazy initialization to avoid dependency loops\n+    private void initializeIfNeeded() {\n+        if (rootLint == null)\n+            rootLint = Lint.instance(context);\n+    }\n+\n+\/\/ Lint Operations\n+\n+    \/**\n+     * Determine if the given file is known to this instance.\n+     *\n+     * @param sourceFile source file\n+     * @return true if file is recognized\n+     *\/\n+    public boolean isKnown(JavaFileObject sourceFile) {\n+        return fileInfoMap.containsKey(sourceFile);\n+    }\n+\n+    \/**\n+     * Obtain the {@link Lint} configuration that applies at the given position, if known.\n+     *\n+     * @param sourceFile source file\n+     * @param pos source position\n+     * @return the applicable {@link Lint}, if known, otherwise empty\n+     *\/\n+    public Optional<Lint> lintAt(JavaFileObject sourceFile, DiagnosticPosition pos) {\n+        initializeIfNeeded();\n+        return Optional.of(sourceFile)\n+          .map(fileInfoMap::get)\n+          .flatMap(fileInfo -> fileInfo.lintAt(pos));\n+    }\n+\n+    \/**\n+     * Calculate {@lint Lint} configurations for all positions within the given top-level declaration.\n+     *\n+     * @param sourceFile source file\n+     * @param tree top-level declaration (class, package, or module)\n+     *\/\n+    public void calculateLints(JavaFileObject sourceFile, JCTree tree, EndPosTable endPositions) {\n+        Assert.check(rootLint != null);\n+        fileInfoMap.get(sourceFile).afterAttr(tree, endPositions);\n+    }\n+\n+    \/**\n+     * Reset this instance.\n+     *\/\n+    public void clear() {\n+        fileInfoMap.clear();\n+    }\n+\n+\/\/ Parsing Notifications\n+\n+    \/**\n+     * Invoked when file parsing starts to create an entry for the new file (but with a null value).\n+     *\/\n+    public void startParsingFile(JavaFileObject sourceFile) {\n+        initializeIfNeeded();\n+        fileInfoMap.put(sourceFile, null);\n+    }\n+\n+    \/**\n+     * Invoked when file parsing completes to put in place a corresponding {@link FileInfo}.\n+     *\/\n+    public void finishParsingFile(JCCompilationUnit tree) {\n+        Assert.check(rootLint != null);\n+        fileInfoMap.put(tree.sourcefile, new FileInfo(tree));\n+    }\n+\n+\/\/ FileInfo\n+\n+    \/**\n+     * Holds {@link Lint} information for a fully parsed source file.\n+     *\n+     * <p>\n+     * Initially (immediately after parsing), \"rootNode\" will have an (unmapped) {@link DeclNode} child corresponding\n+     * to each top-level declaration in the source file. As those top-level declarations are attributed, the corresponding\n+     * {@link DeclNode} child is replaced with a {@link MappedDeclNode}, created via {@link MappedDeclNodeBuilder}.\n+     *\/\n+    private class FileInfo {\n+\n+        final MappedDeclNode rootNode = new MappedDeclNode(rootLint);   \/\/ tree of this file's \"interesting\" declaration nodes\n+\n+        \/\/ After parsing: Create the root node and its immediate (unmapped) children\n+        FileInfo(JCCompilationUnit tree) {\n+            tree.defs.stream()\n+              .filter(this::isTopLevelDecl)\n+              .forEach(decl -> new DeclNode(rootNode, decl, tree.endPositions));\n+        }\n+\n+        \/\/ After attribution: Replace top-level DeclNode child with a MappedDeclNode subtree\n+        void afterAttr(JCTree tree, EndPosTable endPositions) {\n+            Assert.check(rootNode != null, \"source not parsed\");\n+            DeclNode node = findTopNode(tree.pos(), true);\n+            Assert.check(node != null, \"unknown declaration\");\n+            Assert.check(!(node instanceof MappedDeclNode), \"duplicate call\");\n+            new MappedDeclNodeBuilder(rootNode, endPositions).scan(tree);\n+        }\n+\n+        \/\/ Find the Lint configuration that applies to the given position, if known\n+        Optional<Lint> lintAt(DiagnosticPosition pos) {\n+            return switch (findTopNode(pos, false)) {       \/\/ find the top-level declaration containing \"pos\", if any\n+            case MappedDeclNode node                        \/\/ if the declaration has been attributed...\n+              -> Optional.of(node.find(pos).lint);          \/\/  -> return the most specific applicable Lint configuration\n+            case DeclNode node                              \/\/ if the declaration has not been attributed...\n+              -> Optional.empty();                          \/\/  -> we don't know yet\n+            case null                                       \/\/ if \"pos\" is outside of any declaration...\n+              -> Optional.of(rootLint);                     \/\/  -> use the root lint\n+            };\n+        }\n+\n+        \/\/ Find (and optionally remove) the top-level declaration containing \"pos\", if any\n+        DeclNode findTopNode(DiagnosticPosition pos, boolean remove) {\n+            for (Iterator<DeclNode> i = rootNode.children.iterator(); i.hasNext(); ) {\n+                DeclNode node = i.next();\n+                if (node.contains(pos)) {\n+                    if (remove)\n+                        i.remove();\n+                    return node;\n+                }\n+            }\n+            return null;\n+        }\n+\n+        boolean isTopLevelDecl(JCTree tree) {\n+            return tree.getTag() == Tag.MODULEDEF\n+                || tree.getTag() == Tag.PACKAGEDEF\n+                || tree.getTag() == Tag.CLASSDEF;\n+        }\n+    }\n+\n+\/\/ DeclNode\n+\n+    \/**\n+     * Represents the lexical range corresponding to a module, package, class, method, or variable declaration,\n+     * or a \"root\" representing an entire file.\n+     *\/\n+    private static class DeclNode {\n+\n+        final int startPos;                                     \/\/ declaration's starting position\n+        final int endPos;                                       \/\/ declaration's ending position\n+        final MappedDeclNode parent;                            \/\/ the immediately containing declaration (null for root)\n+\n+        DeclNode(int startPos, int endPos, MappedDeclNode parent) {\n+            this.startPos = startPos;\n+            this.endPos = endPos;\n+            this.parent = parent;\n+            if (parent != null)\n+                parent.children.add(this);\n+        }\n+\n+        \/\/ Create a node representing the given declaration\n+        DeclNode(MappedDeclNode parent, JCTree tree, EndPosTable endPositions) {\n+            this(TreeInfo.getStartPos(tree), TreeInfo.getEndPos(tree, endPositions), parent);\n+        }\n+\n+        boolean contains(DiagnosticPosition pos) {\n+            int offset = pos.getLintPosition();\n+            return offset == startPos || (offset > startPos && offset < endPos);\n+        }\n+\n+        boolean contains(DeclNode that) {\n+            return this.startPos <= that.startPos && this.endPos >= that.endPos;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"DeclNode[%d-%d]\", startPos, endPos);\n+        }\n+    }\n+\n+    \/**\n+     * A {@link DeclNode} for which the corresponding {@link Lint} configuration is known.\n+     *\/\n+    private static class MappedDeclNode extends DeclNode {\n+\n+        final Symbol symbol;                                    \/\/ declaration symbol (null for root; for debug purposes only)\n+        final Lint lint;                                        \/\/ the Lint configuration that applies at this declaration\n+        final List<DeclNode> children = new ArrayList<>();      \/\/ the nested declarations one level below this node\n+\n+        \/\/ Create a node representing the entire file, using the root lint configuration\n+        MappedDeclNode(Lint rootLint) {\n+            super(Integer.MIN_VALUE, Integer.MAX_VALUE, null);\n+            this.symbol = null;\n+            this.lint = rootLint;\n+        }\n+\n+        \/\/ Create a node representing the given declaration and its corresponding Lint configuration\n+        MappedDeclNode(Symbol symbol, MappedDeclNode parent, JCTree tree, EndPosTable endPositions, Lint lint) {\n+            super(parent, tree, endPositions);\n+            this.symbol = symbol;\n+            this.lint = lint;\n+        }\n+\n+        \/\/ Find the narrowest node in this tree (including me) that contains the given position, if any\n+        MappedDeclNode find(DiagnosticPosition pos) {\n+            return children.stream()\n+              .map(MappedDeclNode.class::cast)      \/\/ this cast is ok because this method is never invoked on the root instance\n+              .map(child -> child.find(pos))\n+              .filter(Objects::nonNull)\n+              .reduce((a, b) -> a.contains(b) ? b : a)\n+              .orElseGet(() -> contains(pos) ? this : null);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String label = symbol != null ? \"sym=\" + symbol : \"ROOT\";\n+            return String.format(\"MappedDeclNode[%d-%d,%s,lint=%s]\", startPos, endPos, label, lint);\n+        }\n+    }\n+\n+\/\/ MappedDeclNodeBuilder\n+\n+    \/**\n+     * Builds a tree of {@link MappedDeclNode}s starting from a top-level declaration.\n+     *\/\n+    private class MappedDeclNodeBuilder extends TreeScanner {\n+\n+        private final EndPosTable endPositions;\n+\n+        private MappedDeclNode parent;\n+        private Lint lint;\n+\n+        MappedDeclNodeBuilder(MappedDeclNode rootNode, EndPosTable endPositions) {\n+            this.endPositions = endPositions;\n+            this.parent = rootNode;\n+            this.lint = rootNode.lint;              \/\/ i.e, rootLint\n+        }\n+\n+        @Override\n+        public void visitModuleDef(JCModuleDecl tree) {\n+            scanDecl(tree, tree.sym, super::visitModuleDef);\n+        }\n+\n+        @Override\n+        public void visitPackageDef(JCPackageDecl tree) {\n+            scanDecl(tree, tree.packge, super::visitPackageDef);\n+        }\n+\n+        @Override\n+        public void visitClassDef(JCClassDecl tree) {\n+            scanDecl(tree, tree.sym, super::visitClassDef);\n+        }\n+\n+        @Override\n+        public void visitMethodDef(JCMethodDecl tree) {\n+            scanDecl(tree, tree.sym, super::visitMethodDef);\n+        }\n+\n+        @Override\n+        public void visitVarDef(JCVariableDecl tree) {\n+            scanDecl(tree, tree.sym, super::visitVarDef);\n+        }\n+\n+        private <T extends JCTree> void scanDecl(T tree, Symbol symbol, Consumer<? super T> recursion) {\n+\n+            \/\/ \"symbol\" can be null if there were earlier errors; skip this declaration if so\n+            if (symbol == null) {\n+                recursion.accept(tree);\n+                return;\n+            }\n+\n+            \/\/ Update the current Lint in effect; note lint.augment() returns the same instance if there's no change\n+            Lint previousLint = lint;\n+            lint = lint.augment(symbol);\n+\n+            \/\/ If this declaration is not \"interesting\", we don't need to create a DeclNode for it\n+            if (lint == previousLint && parent.parent != null) {\n+                recursion.accept(tree);\n+                return;\n+            }\n+\n+            \/\/ Add a MappedDeclNode here\n+            MappedDeclNode node = new MappedDeclNode(symbol, parent, tree, endPositions, lint);\n+            parent = node;\n+            try {\n+                recursion.accept(tree);\n+            } finally {\n+                parent = node.parent;\n+                lint = previousLint;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/LintMapper.java","additions":385,"deletions":0,"binary":false,"changes":385,"status":"added"},{"patch":"@@ -70,3 +70,0 @@\n-    \/** flag: is the \"preview\" lint category enabled? *\/\n-    private final boolean verbose;\n-\n@@ -103,1 +100,0 @@\n-        verbose = Lint.instance(context).isEnabled(LintCategory.PREVIEW);\n@@ -187,3 +183,1 @@\n-        if (verbose) {\n-            log.warning(LintWarnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n-        }\n+        log.warning(LintWarnings.PreviewFeatureUseClassfile(classfile, majorVersionToSource.get(majorVersion).name));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n@@ -94,1 +93,0 @@\n-    private final Lint lint;\n@@ -113,1 +111,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -116,1 +113,0 @@\n-        lint = Lint.instance(context);\n@@ -238,1 +234,0 @@\n-     * @param deferDecl   enclosing declaration for DeferredLintHandler, or null for no deferral\n@@ -240,2 +235,1 @@\n-    public void annotateLater(List<JCAnnotation> annotations, Env<AttrContext> localEnv,\n-            Symbol s, JCTree deferDecl)\n+    public void annotateLater(List<JCAnnotation> annotations, Env<AttrContext> localEnv, Symbol s)\n@@ -259,2 +253,0 @@\n-            Assert.check(deferDecl != null);\n-            deferredLintHandler.push(deferDecl);\n@@ -271,1 +263,0 @@\n-                deferredLintHandler.pop();\n@@ -288,2 +279,1 @@\n-    public void annotateDefaultValueLater(JCExpression defaultValue, Env<AttrContext> localEnv,\n-            MethodSymbol m, JCTree deferDecl)\n+    public void annotateDefaultValueLater(JCExpression defaultValue, Env<AttrContext> localEnv, MethodSymbol m)\n@@ -293,1 +283,0 @@\n-            deferredLintHandler.push(deferDecl);\n@@ -297,1 +286,0 @@\n-                deferredLintHandler.pop();\n@@ -685,1 +673,1 @@\n-            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym, null);\n+            queueScanTreeAndTypeAnnotate(tree, env, tree.type.tsym);\n@@ -1037,2 +1025,1 @@\n-    public void enterTypeAnnotations(List<JCAnnotation> annotations, Env<AttrContext> env,\n-            Symbol s, JCTree deferDecl, boolean isTypeParam)\n+    public void enterTypeAnnotations(List<JCAnnotation> annotations, Env<AttrContext> env, Symbol s, boolean isTypeParam)\n@@ -1043,3 +1030,0 @@\n-        if (deferDecl != null) {\n-            deferredLintHandler.push(deferDecl);\n-        }\n@@ -1049,2 +1033,0 @@\n-            if (deferDecl != null)\n-                deferredLintHandler.pop();\n@@ -1058,1 +1040,1 @@\n-    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym, JCTree deferDecl)\n+    public void queueScanTreeAndTypeAnnotate(JCTree tree, Env<AttrContext> env, Symbol sym)\n@@ -1061,1 +1043,1 @@\n-        normal(() -> tree.accept(new TypeAnnotate(env, sym, deferDecl)));\n+        normal(() -> tree.accept(new TypeAnnotate(env, sym)));\n@@ -1096,1 +1078,0 @@\n-        private JCTree deferDecl;\n@@ -1098,1 +1079,1 @@\n-        public TypeAnnotate(Env<AttrContext> env, Symbol sym, JCTree deferDecl) {\n+        public TypeAnnotate(Env<AttrContext> env, Symbol sym) {\n@@ -1102,1 +1083,0 @@\n-            this.deferDecl = deferDecl;\n@@ -1107,1 +1087,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, false);\n@@ -1113,1 +1093,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, true);\n+            enterTypeAnnotations(tree.annotations, env, sym, true);\n@@ -1119,1 +1099,1 @@\n-            enterTypeAnnotations(tree.annotations, env, sym, deferDecl, false);\n+            enterTypeAnnotations(tree.annotations, env, sym, false);\n@@ -1121,1 +1101,1 @@\n-                enterTypeAnnotations(dimAnnos, env, sym, deferDecl, false);\n+                enterTypeAnnotations(dimAnnos, env, sym, false);\n@@ -1140,12 +1120,5 @@\n-            JCTree prevDecl = deferDecl;\n-            deferDecl = tree;\n-            try {\n-                if (sym != null && sym.kind == VAR) {\n-                    \/\/ Don't visit a parameter once when the sym is the method\n-                    \/\/ and once when the sym is the parameter.\n-                    scan(tree.mods);\n-                    scan(tree.vartype);\n-                }\n-                scan(tree.init);\n-            } finally {\n-                deferDecl = prevDecl;\n+            if (sym != null && sym.kind == VAR) {\n+                \/\/ Don't visit a parameter once when the sym is the method\n+                \/\/ and once when the sym is the parameter.\n+                scan(tree.mods);\n+                scan(tree.vartype);\n@@ -1153,0 +1126,1 @@\n+            scan(tree.init);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":17,"deletions":43,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -101,0 +102,1 @@\n+    final LintMapper lintMapper;\n@@ -119,1 +121,0 @@\n-    final DeferredLintHandler deferredLintHandler;\n@@ -140,0 +141,1 @@\n+        lintMapper = LintMapper.instance(context);\n@@ -159,1 +161,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -856,1 +857,0 @@\n-        deferredLintHandler.push(variable);\n@@ -872,1 +872,0 @@\n-            deferredLintHandler.pop();\n@@ -1001,1 +1000,0 @@\n-            deferredLintHandler.flush(tree, lint);\n@@ -1236,1 +1234,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);\n+                annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m);\n@@ -1300,1 +1298,0 @@\n-            deferredLintHandler.flush(tree, lint);\n@@ -1345,1 +1342,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym);\n@@ -1442,1 +1439,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);\n+            annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner);\n@@ -1955,1 +1952,1 @@\n-            env.info.lint.logIfEnabled(tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n+            log.warning(tree.pos(), LintWarnings.AttemptToSynchronizeOnInstanceOfValueBasedClass);\n@@ -2057,1 +2054,1 @@\n-                env.info.lint.logIfEnabled(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n+                log.warning(pos, LintWarnings.TryResourceThrowsInterruptedExc(resource));\n@@ -4229,1 +4226,1 @@\n-        annotate.annotateLater(tree.var.mods.annotations, env, v, tree.var);\n+        annotate.annotateLater(tree.var.mods.annotations, env, v);\n@@ -4231,1 +4228,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v, tree.var);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.var.vartype, env, v);\n@@ -4469,1 +4466,1 @@\n-            env.info.lint.logIfEnabled(tree, LintWarnings.TryExplicitCloseCall);\n+            log.warning(tree, LintWarnings.TryExplicitCloseCall);\n@@ -4496,1 +4493,1 @@\n-                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n+                log.warning(tree, LintWarnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));\n@@ -4498,1 +4495,1 @@\n-                chk.lint.logIfEnabled(tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n+                log.warning(tree, LintWarnings.StaticNotQualifiedByType2(sym.kind.kindName()));\n@@ -5300,0 +5297,3 @@\n+\n+        \/\/ Now that this tree is attributed, we can calculate the Lint configuration everywhere within it\n+        lintMapper.calculateLints(env.toplevel.sourcefile, env.tree, env.toplevel.endPositions);\n@@ -5342,1 +5342,0 @@\n-            deferredLintHandler.flush(env.tree, lint);\n@@ -5526,1 +5525,0 @@\n-                deferredLintHandler.flush(env.tree, env.info.lint);\n@@ -5572,3 +5570,0 @@\n-        chk.checkModuleName(tree);\n-        chk.checkDeprecatedAnnotation(tree, msym);\n-\n@@ -5576,1 +5571,2 @@\n-            deferredLintHandler.flush(tree, lint);\n+            chk.checkModuleName(tree);\n+            chk.checkDeprecatedAnnotation(tree, msym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":18,"deletions":22,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-    Lint lint;\n+    private Lint lint;\n@@ -167,2 +167,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n-\n@@ -183,4 +181,0 @@\n-    \/** A handler for deferred lint warnings.\n-     *\/\n-    private DeferredLintHandler deferredLintHandler;\n-\n@@ -232,18 +226,9 @@\n-        LintWarning warningKey = null;\n-        if (sym.isDeprecatedForRemoval()) {\n-            if (!lint.isSuppressed(LintCategory.REMOVAL)) {\n-                if (sym.kind == MDL) {\n-                    warningKey = LintWarnings.HasBeenDeprecatedForRemovalModule(sym);\n-                } else {\n-                    warningKey = LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location());\n-                }\n-            }\n-        } else if (!lint.isSuppressed(LintCategory.DEPRECATION)) {\n-            if (sym.kind == MDL) {\n-                warningKey = LintWarnings.HasBeenDeprecatedModule(sym);\n-            } else {\n-                warningKey = LintWarnings.HasBeenDeprecated(sym, sym.location());\n-            }\n-        }\n-        if (warningKey != null)\n-            log.warning(pos, warningKey);\n+        Assert.check(!importSuppression);\n+        LintWarning warningKey = sym.isDeprecatedForRemoval() ?\n+            (sym.kind == MDL ?\n+                LintWarnings.HasBeenDeprecatedForRemovalModule(sym) :\n+                LintWarnings.HasBeenDeprecatedForRemoval(sym, sym.location())) :\n+            (sym.kind == MDL ?\n+                LintWarnings.HasBeenDeprecatedModule(sym) :\n+                LintWarnings.HasBeenDeprecated(sym, sym.location()));\n+        log.warning(pos, warningKey);\n@@ -257,1 +242,1 @@\n-        if (!importSuppression && !lint.isSuppressed(LintCategory.PREVIEW))\n+        if (!importSuppression)\n@@ -261,8 +246,0 @@\n-    \/** Log a preview warning.\n-     *  @param pos        Position to be used for error reporting.\n-     *  @param msg        A Warning describing the problem.\n-     *\/\n-    public void warnRestrictedAPI(DiagnosticPosition pos, Symbol sym) {\n-        lint.logIfEnabled(pos, LintWarnings.RestrictedMethod(sym.enclClass(), sym));\n-    }\n-\n@@ -274,2 +251,1 @@\n-        if (!lint.isSuppressed(LintCategory.UNCHECKED))\n-            log.warning(pos, warnKey);\n+        log.warning(pos, warnKey);\n@@ -611,3 +587,1 @@\n-            deferredLintHandler.report(_l -> {\n-                lint.logIfEnabled(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n-            });\n+            log.warning(tree.pos(), LintWarnings.RedundantCast(tree.clazz.type));\n@@ -917,1 +891,1 @@\n-            lint.logIfEnabled(tree, LintWarnings.VarargsRedundantTrustmeAnno(\n+            log.warning(tree.pos(), LintWarnings.VarargsRedundantTrustmeAnno(\n@@ -1176,1 +1150,1 @@\n-                warnOnExplicitStrictfp(tree);\n+                log.warning(tree.pos(), LintWarnings.Strictfp);\n@@ -1220,1 +1194,1 @@\n-                warnOnExplicitStrictfp(tree);\n+                log.warning(tree.pos(), LintWarnings.Strictfp);\n@@ -1284,10 +1258,0 @@\n-    private void warnOnExplicitStrictfp(JCTree tree) {\n-        deferredLintHandler.push(tree);\n-        try {\n-            deferredLintHandler.report(_ -> lint.logIfEnabled(tree.pos(), LintWarnings.Strictfp));\n-        } finally {\n-            deferredLintHandler.pop();\n-        }\n-    }\n-\n-\n@@ -1506,1 +1470,1 @@\n-            lint.logIfEnabled(tree.pos(), LintWarnings.RawClassUse(tree.type, tree.type.tsym.type));\n+            log.warning(tree.pos(), LintWarnings.RawClassUse(tree.type, tree.type.tsym.type));\n@@ -1830,1 +1794,1 @@\n-            lint.logIfEnabled(TreeInfo.diagnosticPositionFor(m, tree),\n+            log.warning(TreeInfo.diagnosticPositionFor(m, tree),\n@@ -1844,6 +1808,1 @@\n-            Lint prevLint = setLint(lint.augment(m));\n-            try {\n-                checkDeprecated(() -> TreeInfo.diagnosticPositionFor(m, tree), m, other);\n-            } finally {\n-                setLint(prevLint);\n-            }\n+            checkDeprecated(() -> TreeInfo.diagnosticPositionFor(m, tree), m, other);\n@@ -2918,7 +2877,2 @@\n-        final Lint prevLint = setLint(warnOnAnyAccessToMembers ? lint.enable(LintCategory.SERIAL) : lint);\n-        try {\n-            if (warnOnAnyAccessToMembers || isLambda)\n-                checkAccessFromSerializableElementInner(tree, isLambda);\n-        } finally {\n-            setLint(prevLint);\n-        }\n+        if (warnOnAnyAccessToMembers || isLambda)\n+            checkAccessFromSerializableElementInner(tree, isLambda);\n@@ -2928,5 +2882,4 @@\n-        if (lint.isEnabled(LintCategory.SERIAL)) {\n-            Symbol sym = TreeInfo.symbol(tree);\n-            if (!sym.kind.matches(KindSelector.VAL_MTH)) {\n-                return;\n-            }\n+        Symbol sym = TreeInfo.symbol(tree);\n+        if (!sym.kind.matches(KindSelector.VAL_MTH)) {\n+            return;\n+        }\n@@ -2934,7 +2887,6 @@\n-            if (sym.kind == VAR) {\n-                if ((sym.flags() & PARAMETER) != 0 ||\n-                    sym.isDirectlyOrIndirectlyLocal() ||\n-                    sym.name == names._this ||\n-                    sym.name == names._super) {\n-                    return;\n-                }\n+        if (sym.kind == VAR) {\n+            if ((sym.flags() & PARAMETER) != 0 ||\n+                sym.isDirectlyOrIndirectlyLocal() ||\n+                sym.name == names._this ||\n+                sym.name == names._super) {\n+                return;\n@@ -2942,0 +2894,1 @@\n+        }\n@@ -2943,10 +2896,5 @@\n-            if (!types.isSubtype(sym.owner.type, syms.serializableType) &&\n-                isEffectivelyNonPublic(sym)) {\n-                if (isLambda) {\n-                    if (belongsToRestrictedPackage(sym)) {\n-                        log.warning(tree.pos(),\n-                                    LintWarnings.AccessToMemberFromSerializableLambda(sym));\n-                    }\n-                } else {\n-                    log.warning(tree.pos(),\n-                                LintWarnings.AccessToMemberFromSerializableElement(sym));\n+        if (!types.isSubtype(sym.owner.type, syms.serializableType) && isEffectivelyNonPublic(sym)) {\n+            DiagnosticFlag flag = warnOnAnyAccessToMembers ? DiagnosticFlag.DEFAULT_ENABLED : null;\n+            if (isLambda) {\n+                if (belongsToRestrictedPackage(sym)) {\n+                    log.warning(flag, tree.pos(), LintWarnings.AccessToMemberFromSerializableLambda(sym));\n@@ -2954,0 +2902,2 @@\n+            } else {\n+                log.warning(flag, tree.pos(), LintWarnings.AccessToMemberFromSerializableElement(sym));\n@@ -3740,2 +3690,1 @@\n-                log.warning(pos,\n-                            LintWarnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));\n+                log.warning(pos, LintWarnings.DeprecatedAnnotationHasNoEffect(Kinds.kindName(s)));\n@@ -3755,1 +3704,1 @@\n-            deferredLintHandler.report(_l -> warnDeprecated(pos.get(), s));\n+            warnDeprecated(pos.get(), s);\n@@ -3761,3 +3710,1 @@\n-            deferredLintHandler.report(_l -> {\n-                log.warning(pos, Warnings.SunProprietary(s));\n-            });\n+            log.warning(pos, Warnings.SunProprietary(s));\n@@ -3820,1 +3767,1 @@\n-            deferredLintHandler.report(_l -> warnRestrictedAPI(pos, s));\n+            log.warning(pos, LintWarnings.RestrictedMethod(s.enclClass(), s));\n@@ -4092,1 +4039,1 @@\n-                deferredLintHandler.report(_ -> lint.logIfEnabled(pos, LintWarnings.DivZero));\n+                log.warning(pos, LintWarnings.DivZero);\n@@ -4105,2 +4052,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.PossibleLossOfPrecision(found, req)));\n+            log.warning(pos, LintWarnings.PossibleLossOfPrecision(found, req));\n@@ -4115,1 +4061,1 @@\n-            lint.logIfEnabled(tree.thenpart.pos(), LintWarnings.EmptyIf);\n+            log.warning(tree.thenpart.pos(), LintWarnings.EmptyIf);\n@@ -4262,2 +4208,1 @@\n-            lint.logIfEnabled(pos,\n-                        LintWarnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));\n+            log.warning(pos, LintWarnings.AuxiliaryClassAccessedFromOutsideOfItsSourceFile(c, c.sourcefile));\n@@ -4305,2 +4250,1 @@\n-                            deferredLintHandler.report(_ ->\n-                                lint.logIfEnabled(pos, LintWarnings.MissingExplicitCtor(c, pkg, modle)));\n+                            log.warning(pos, LintWarnings.MissingExplicitCtor(c, pkg, modle));\n@@ -4342,1 +4286,1 @@\n-                        Check.this.lint.logIfEnabled(pos(), LintWarnings.VarargsUnsafeUseVarargsParam(method.params.last()));\n+                        log.warning(pos(), LintWarnings.VarargsUnsafeUseVarargsParam(method.params.last()));\n@@ -4640,2 +4584,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.ModuleNotFound(msym)));\n+            log.warning(pos, LintWarnings.ModuleNotFound(msym));\n@@ -4648,2 +4591,1 @@\n-            deferredLintHandler.report(_ ->\n-                lint.logIfEnabled(pos, LintWarnings.PackageEmptyOrNotFound(packge)));\n+            log.warning(pos, LintWarnings.PackageEmptyOrNotFound(packge));\n@@ -4655,7 +4597,5 @@\n-            deferredLintHandler.report(_ -> {\n-                if (rd.isTransitive() && lint.isEnabled(LintCategory.REQUIRES_TRANSITIVE_AUTOMATIC)) {\n-                    log.warning(pos, LintWarnings.RequiresTransitiveAutomatic);\n-                } else {\n-                    lint.logIfEnabled(pos, LintWarnings.RequiresAutomatic);\n-                }\n-            });\n+            if (rd.isTransitive()) {    \/\/ see comment in Log.applyLint() for special logic that applies\n+                log.warning(pos, LintWarnings.RequiresTransitiveAutomatic);\n+            } else {\n+                log.warning(pos, LintWarnings.RequiresAutomatic);\n+            }\n@@ -5696,1 +5636,1 @@\n-                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                                log.warning(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5703,1 +5643,1 @@\n-                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                                log.warning(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5730,1 +5670,1 @@\n-                lint.logIfEnabled(pos, LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                log.warning(pos, LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n@@ -5807,1 +5747,1 @@\n-                        .forEach(ta -> lint.logIfEnabled(typeParamTrees.get(ta.position.parameter_index).pos(),\n+                        .forEach(ta -> log.warning(typeParamTrees.get(ta.position.parameter_index).pos(),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":60,"deletions":120,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -217,1 +217,0 @@\n-    private       Lint lint;\n@@ -340,1 +339,0 @@\n-        lint = Lint.instance(context);\n@@ -565,1 +563,0 @@\n-            Lint lintPrev = lint;\n@@ -568,1 +565,0 @@\n-            lint = lint.augment(tree.sym);\n@@ -599,1 +595,0 @@\n-                lint = lintPrev;\n@@ -605,3 +600,0 @@\n-            Lint lintPrev = lint;\n-\n-            lint = lint.augment(tree.sym);\n@@ -611,4 +603,3 @@\n-            try {\n-                alive = Liveness.ALIVE;\n-                scanStat(tree.body);\n-                tree.completesNormally = alive != Liveness.DEAD;\n+            alive = Liveness.ALIVE;\n+            scanStat(tree.body);\n+            tree.completesNormally = alive != Liveness.DEAD;\n@@ -616,2 +607,2 @@\n-                if (alive == Liveness.ALIVE && !tree.sym.type.getReturnType().hasTag(VOID))\n-                    log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);\n+            if (alive == Liveness.ALIVE && !tree.sym.type.getReturnType().hasTag(VOID))\n+                log.error(TreeInfo.diagEndPos(tree.body), Errors.MissingRetStmt);\n@@ -619,4 +610,1 @@\n-                clearPendingExits(true);\n-            } finally {\n-                lint = lintPrev;\n-            }\n+            clearPendingExits(true);\n@@ -637,9 +625,1 @@\n-            if (tree.init != null) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try{\n-                    scan(tree.init);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n-            }\n+            scan(tree.init);\n@@ -727,2 +707,1 @@\n-                    lint.logIfEnabled(l.tail.head.pos(),\n-                                LintWarnings.PossibleFallThroughIntoCase);\n+                    log.warning(l.tail.head.pos(), LintWarnings.PossibleFallThroughIntoCase);\n@@ -1235,1 +1214,1 @@\n-                    lint.logIfEnabled(TreeInfo.diagEndPos(tree.finalizer),\n+                    log.warning(TreeInfo.diagEndPos(tree.finalizer),\n@@ -1456,1 +1435,0 @@\n-            Lint lintPrev = lint;\n@@ -1464,1 +1442,0 @@\n-            lint = lint.augment(tree.sym);\n@@ -1513,1 +1490,0 @@\n-                lint = lintPrev;\n@@ -1522,3 +1498,0 @@\n-            Lint lintPrev = lint;\n-\n-            lint = lint.augment(tree.sym);\n@@ -1557,1 +1530,0 @@\n-                lint = lintPrev;\n@@ -1562,9 +1534,1 @@\n-            if (tree.init != null) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try{\n-                    scan(tree.init);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n-            }\n+            scan(tree.init);\n@@ -2390,7 +2354,4 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n-            try {\n-                JCClassDecl classDefPrev = classDef;\n-                int firstadrPrev = firstadr;\n-                int nextadrPrev = nextadr;\n-                ListBuffer<PendingExit> pendingExitsPrev = pendingExits;\n+            JCClassDecl classDefPrev = classDef;\n+            int firstadrPrev = firstadr;\n+            int nextadrPrev = nextadr;\n+            ListBuffer<PendingExit> pendingExitsPrev = pendingExits;\n@@ -2398,15 +2359,14 @@\n-                pendingExits = new ListBuffer<>();\n-                if (tree.name != names.empty) {\n-                    firstadr = nextadr;\n-                }\n-                classDef = tree;\n-                try {\n-                    \/\/ define all the static fields\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(VARDEF)) {\n-                            JCVariableDecl def = (JCVariableDecl)l.head;\n-                            if ((def.mods.flags & STATIC) != 0) {\n-                                VarSymbol sym = def.sym;\n-                                if (trackable(sym)) {\n-                                    newVar(def);\n-                                }\n+            pendingExits = new ListBuffer<>();\n+            if (tree.name != names.empty) {\n+                firstadr = nextadr;\n+            }\n+            classDef = tree;\n+            try {\n+                \/\/ define all the static fields\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(VARDEF)) {\n+                        JCVariableDecl def = (JCVariableDecl)l.head;\n+                        if ((def.mods.flags & STATIC) != 0) {\n+                            VarSymbol sym = def.sym;\n+                            if (trackable(sym)) {\n+                                newVar(def);\n@@ -2416,0 +2376,1 @@\n+                }\n@@ -2417,5 +2378,5 @@\n-                    \/\/ process all the static initializers\n-                    forEachInitializer(tree, true, def -> {\n-                        scan(def);\n-                        clearPendingExits(false);\n-                    });\n+                \/\/ process all the static initializers\n+                forEachInitializer(tree, true, def -> {\n+                    scan(def);\n+                    clearPendingExits(false);\n+                });\n@@ -2423,7 +2384,6 @@\n-                    \/\/ verify all static final fields got initialized\n-                    for (int i = firstadr; i < nextadr; i++) {\n-                        JCVariableDecl vardecl = vardecls[i];\n-                        VarSymbol var = vardecl.sym;\n-                        if (var.owner == classDef.sym && var.isStatic()) {\n-                            checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n-                        }\n+                \/\/ verify all static final fields got initialized\n+                for (int i = firstadr; i < nextadr; i++) {\n+                    JCVariableDecl vardecl = vardecls[i];\n+                    VarSymbol var = vardecl.sym;\n+                    if (var.owner == classDef.sym && var.isStatic()) {\n+                        checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n@@ -2431,0 +2391,1 @@\n+                }\n@@ -2432,9 +2393,8 @@\n-                    \/\/ define all the instance fields\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(VARDEF)) {\n-                            JCVariableDecl def = (JCVariableDecl)l.head;\n-                            if ((def.mods.flags & STATIC) == 0) {\n-                                VarSymbol sym = def.sym;\n-                                if (trackable(sym)) {\n-                                    newVar(def);\n-                                }\n+                \/\/ define all the instance fields\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(VARDEF)) {\n+                        JCVariableDecl def = (JCVariableDecl)l.head;\n+                        if ((def.mods.flags & STATIC) == 0) {\n+                            VarSymbol sym = def.sym;\n+                            if (trackable(sym)) {\n+                                newVar(def);\n@@ -2444,0 +2404,1 @@\n+                }\n@@ -2445,5 +2406,4 @@\n-                    \/\/ process all the methods\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(METHODDEF)) {\n-                            scan(l.head);\n-                        }\n+                \/\/ process all the methods\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(METHODDEF)) {\n+                        scan(l.head);\n@@ -2451,0 +2411,1 @@\n+                }\n@@ -2452,5 +2413,4 @@\n-                    \/\/ process all the nested classes\n-                    for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n-                        if (l.head.hasTag(CLASSDEF)) {\n-                            scan(l.head);\n-                        }\n+                \/\/ process all the nested classes\n+                for (List<JCTree> l = tree.defs; l.nonEmpty(); l = l.tail) {\n+                    if (l.head.hasTag(CLASSDEF)) {\n+                        scan(l.head);\n@@ -2458,5 +2418,0 @@\n-                } finally {\n-                    pendingExits = pendingExitsPrev;\n-                    nextadr = nextadrPrev;\n-                    firstadr = firstadrPrev;\n-                    classDef = classDefPrev;\n@@ -2465,1 +2420,4 @@\n-                lint = lintPrev;\n+                pendingExits = pendingExitsPrev;\n+                nextadr = nextadrPrev;\n+                firstadr = firstadrPrev;\n+                classDef = classDefPrev;\n@@ -2480,2 +2438,8 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n+            final Bits initsPrev = new Bits(inits);\n+            final Bits uninitsPrev = new Bits(uninits);\n+            int nextadrPrev = nextadr;\n+            int firstadrPrev = firstadr;\n+            int returnadrPrev = returnadr;\n+\n+            Assert.check(pendingExits.isEmpty());\n+            boolean isConstructorPrev = isConstructor;\n@@ -2483,15 +2447,1 @@\n-                final Bits initsPrev = new Bits(inits);\n-                final Bits uninitsPrev = new Bits(uninits);\n-                int nextadrPrev = nextadr;\n-                int firstadrPrev = firstadr;\n-                int returnadrPrev = returnadr;\n-\n-                Assert.check(pendingExits.isEmpty());\n-                boolean isConstructorPrev = isConstructor;\n-                try {\n-                    isConstructor = TreeInfo.isConstructor(tree);\n-\n-                    \/\/ We only track field initialization inside constructors\n-                    if (!isConstructor) {\n-                        firstadr = nextadr;\n-                    }\n+                isConstructor = TreeInfo.isConstructor(tree);\n@@ -2499,42 +2449,44 @@\n-                    \/\/ Mark all method parameters as DA\n-                    for (List<JCVariableDecl> l = tree.params; l.nonEmpty(); l = l.tail) {\n-                        JCVariableDecl def = l.head;\n-                        scan(def);\n-                        Assert.check((def.sym.flags() & PARAMETER) != 0, \"Method parameter without PARAMETER flag\");\n-                        \/*  If we are executing the code from Gen, then there can be\n-                         *  synthetic or mandated variables, ignore them.\n-                         *\/\n-                        initParam(def);\n-                    }\n-                    \/\/ else we are in an instance initializer block;\n-                    \/\/ leave caught unchanged.\n-                    scan(tree.body);\n-\n-                    boolean isCompactOrGeneratedRecordConstructor = (tree.sym.flags() & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n-                            (tree.sym.flags() & (GENERATEDCONSTR | RECORD)) == (GENERATEDCONSTR | RECORD);\n-                    if (isConstructor) {\n-                        boolean isSynthesized = (tree.sym.flags() &\n-                                                 GENERATEDCONSTR) != 0;\n-                        for (int i = firstadr; i < nextadr; i++) {\n-                            JCVariableDecl vardecl = vardecls[i];\n-                            VarSymbol var = vardecl.sym;\n-                            if (var.owner == classDef.sym && !var.isStatic()) {\n-                                \/\/ choose the diagnostic position based on whether\n-                                \/\/ the ctor is default(synthesized) or not\n-                                if (isSynthesized && !isCompactOrGeneratedRecordConstructor) {\n-                                    checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),\n-                                            var, Errors.VarNotInitializedInDefaultConstructor(var));\n-                                } else if (isCompactOrGeneratedRecordConstructor) {\n-                                    boolean isInstanceRecordField = var.enclClass().isRecord() &&\n-                                            (var.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n-                                            var.owner.kind == TYP;\n-                                    if (isInstanceRecordField) {\n-                                        boolean notInitialized = !inits.isMember(var.adr);\n-                                        if (notInitialized && uninits.isMember(var.adr) && tree.completesNormally) {\n-                                        \/*  this way we indicate Lower that it should generate an initialization for this field\n-                                         *  in the compact constructor\n-                                         *\/\n-                                            var.flags_field |= UNINITIALIZED_FIELD;\n-                                        } else {\n-                                            checkInit(TreeInfo.diagEndPos(tree.body), var);\n-                                        }\n+                \/\/ We only track field initialization inside constructors\n+                if (!isConstructor) {\n+                    firstadr = nextadr;\n+                }\n+\n+                \/\/ Mark all method parameters as DA\n+                for (List<JCVariableDecl> l = tree.params; l.nonEmpty(); l = l.tail) {\n+                    JCVariableDecl def = l.head;\n+                    scan(def);\n+                    Assert.check((def.sym.flags() & PARAMETER) != 0, \"Method parameter without PARAMETER flag\");\n+                    \/*  If we are executing the code from Gen, then there can be\n+                     *  synthetic or mandated variables, ignore them.\n+                     *\/\n+                    initParam(def);\n+                }\n+                \/\/ else we are in an instance initializer block;\n+                \/\/ leave caught unchanged.\n+                scan(tree.body);\n+\n+                boolean isCompactOrGeneratedRecordConstructor = (tree.sym.flags() & Flags.COMPACT_RECORD_CONSTRUCTOR) != 0 ||\n+                        (tree.sym.flags() & (GENERATEDCONSTR | RECORD)) == (GENERATEDCONSTR | RECORD);\n+                if (isConstructor) {\n+                    boolean isSynthesized = (tree.sym.flags() &\n+                                             GENERATEDCONSTR) != 0;\n+                    for (int i = firstadr; i < nextadr; i++) {\n+                        JCVariableDecl vardecl = vardecls[i];\n+                        VarSymbol var = vardecl.sym;\n+                        if (var.owner == classDef.sym && !var.isStatic()) {\n+                            \/\/ choose the diagnostic position based on whether\n+                            \/\/ the ctor is default(synthesized) or not\n+                            if (isSynthesized && !isCompactOrGeneratedRecordConstructor) {\n+                                checkInit(TreeInfo.diagnosticPositionFor(var, vardecl),\n+                                        var, Errors.VarNotInitializedInDefaultConstructor(var));\n+                            } else if (isCompactOrGeneratedRecordConstructor) {\n+                                boolean isInstanceRecordField = var.enclClass().isRecord() &&\n+                                        (var.flags_field & (Flags.PRIVATE | Flags.FINAL | Flags.GENERATED_MEMBER | Flags.RECORD)) != 0 &&\n+                                        var.owner.kind == TYP;\n+                                if (isInstanceRecordField) {\n+                                    boolean notInitialized = !inits.isMember(var.adr);\n+                                    if (notInitialized && uninits.isMember(var.adr) && tree.completesNormally) {\n+                                    \/*  this way we indicate Lower that it should generate an initialization for this field\n+                                     *  in the compact constructor\n+                                     *\/\n+                                        var.flags_field |= UNINITIALIZED_FIELD;\n@@ -2542,1 +2494,1 @@\n-                                        checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n+                                        checkInit(TreeInfo.diagEndPos(tree.body), var);\n@@ -2545,1 +2497,1 @@\n-                                    checkInit(TreeInfo.diagEndPos(tree.body), var);\n+                                    checkInit(TreeInfo.diagnosticPositionFor(var, vardecl), var);\n@@ -2547,0 +2499,2 @@\n+                            } else {\n+                                checkInit(TreeInfo.diagEndPos(tree.body), var);\n@@ -2550,8 +2504,0 @@\n-                    clearPendingExits(true);\n-                } finally {\n-                    inits.assign(initsPrev);\n-                    uninits.assign(uninitsPrev);\n-                    nextadr = nextadrPrev;\n-                    firstadr = firstadrPrev;\n-                    returnadr = returnadrPrev;\n-                    isConstructor = isConstructorPrev;\n@@ -2559,0 +2505,1 @@\n+                clearPendingExits(true);\n@@ -2560,1 +2507,6 @@\n-                lint = lintPrev;\n+                inits.assign(initsPrev);\n+                uninits.assign(uninitsPrev);\n+                nextadr = nextadrPrev;\n+                firstadr = firstadrPrev;\n+                returnadr = returnadrPrev;\n+                isConstructor = isConstructorPrev;\n@@ -2588,12 +2540,8 @@\n-            Lint lintPrev = lint;\n-            lint = lint.augment(tree.sym);\n-            try{\n-                boolean track = trackable(tree.sym);\n-                if (track && (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {\n-                    newVar(tree);\n-                }\n-                if (tree.init != null) {\n-                    scanExpr(tree.init);\n-                    if (track) {\n-                        letInit(tree.pos(), tree.sym);\n-                    }\n+            boolean track = trackable(tree.sym);\n+            if (track && (tree.sym.owner.kind == MTH || tree.sym.owner.kind == VAR)) {\n+                newVar(tree);\n+            }\n+            if (tree.init != null) {\n+                scanExpr(tree.init);\n+                if (track) {\n+                    letInit(tree.pos(), tree.sym);\n@@ -2601,2 +2549,0 @@\n-            } finally {\n-                lint = lintPrev;\n@@ -2854,2 +2800,1 @@\n-            if (!resourceVarDecls.isEmpty() &&\n-                    lint.isEnabled(Lint.LintCategory.TRY)) {\n+            if (!resourceVarDecls.isEmpty()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":136,"deletions":191,"binary":false,"changes":327,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n@@ -90,1 +89,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -197,10 +195,5 @@\n-        deferredLintHandler.push(tree);\n-        try {\n-            \/\/ Compute the method type\n-            m.type = signature(m, tree.typarams, tree.params,\n-                               tree.restype, tree.recvparam,\n-                               tree.thrown,\n-                               localEnv);\n-        } finally {\n-            deferredLintHandler.pop();\n-        }\n+        \/\/ Compute the method type\n+        m.type = signature(m, tree.typarams, tree.params,\n+                           tree.restype, tree.recvparam,\n+                           tree.thrown,\n+                           localEnv);\n@@ -230,1 +223,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, m, tree);\n+        annotate.annotateLater(tree.mods.annotations, localEnv, m);\n@@ -233,1 +226,1 @@\n-        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m, tree);\n+        annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, m);\n@@ -237,1 +230,1 @@\n-            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m, tree);\n+            annotate.annotateDefaultValueLater(tree.defaultValue, localEnv, m);\n@@ -266,1 +259,0 @@\n-        deferredLintHandler.push(tree);\n@@ -268,10 +260,6 @@\n-        try {\n-            if (TreeInfo.isEnumInit(tree)) {\n-                attr.attribIdentAsEnumType(localEnv, (JCIdent)tree.vartype);\n-            } else if (!tree.isImplicitlyTyped()) {\n-                attr.attribType(tree.vartype, localEnv);\n-                if (TreeInfo.isReceiverParam(tree))\n-                    checkReceiver(tree, localEnv);\n-            }\n-        } finally {\n-            deferredLintHandler.pop();\n+        if (TreeInfo.isEnumInit(tree)) {\n+            attr.attribIdentAsEnumType(localEnv, (JCIdent)tree.vartype);\n+        } else if (!tree.isImplicitlyTyped()) {\n+            attr.attribType(tree.vartype, localEnv);\n+            if (TreeInfo.isReceiverParam(tree))\n+                checkReceiver(tree, localEnv);\n@@ -318,1 +306,1 @@\n-        annotate.annotateLater(tree.mods.annotations, localEnv, v, tree);\n+        annotate.annotateLater(tree.mods.annotations, localEnv, v);\n@@ -320,1 +308,1 @@\n-            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v, tree);\n+            annotate.queueScanTreeAndTypeAnnotate(tree.vartype, localEnv, v);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":16,"deletions":28,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -144,1 +143,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n@@ -172,2 +170,0 @@\n-    private final boolean lintOptions;\n-\n@@ -196,1 +192,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n@@ -208,2 +203,0 @@\n-        lintOptions = !options.isLintDisabled(LintCategory.OPTIONS);\n-\n@@ -749,1 +742,0 @@\n-                deferredLintHandler.push(moduleDecl);\n@@ -757,1 +749,0 @@\n-                    deferredLintHandler.pop();\n@@ -994,1 +985,0 @@\n-            deferredLintHandler.push(decl);\n@@ -1000,1 +990,0 @@\n-                deferredLintHandler.pop();\n@@ -1266,6 +1255,3 @@\n-            if (lintOptions) {\n-                for (ModuleSymbol msym : limitMods) {\n-                    if (!observable.contains(msym)) {\n-                        log.warning(\n-                                LintWarnings.ModuleForOptionNotFound(Option.LIMIT_MODULES, msym));\n-                    }\n+            for (ModuleSymbol msym : limitMods) {\n+                if (!observable.contains(msym)) {\n+                    log.warning(LintWarnings.ModuleForOptionNotFound(Option.LIMIT_MODULES, msym));\n@@ -1724,4 +1710,1 @@\n-            if (lintOptions) {\n-                log.warning(\n-                        LintWarnings.ModuleForOptionNotFound(Option.ADD_EXPORTS, msym));\n-            }\n+            log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_EXPORTS, msym));\n@@ -1763,3 +1746,1 @@\n-                if (lintOptions) {\n-                    log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, msym));\n-                }\n+                log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, msym));\n@@ -1783,3 +1764,1 @@\n-                        if (lintOptions) {\n-                            log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, targetModule));\n-                        }\n+                        log.warning(LintWarnings.ModuleForOptionNotFound(Option.ADD_READS, targetModule));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":6,"deletions":27,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -60,0 +61,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n@@ -70,0 +72,1 @@\n+import static com.sun.tools.javac.util.Position.NOPOS;\n@@ -159,1 +162,1 @@\n-    private       Lint lint;\n+    private final LintMapper lintMapper;\n@@ -171,4 +174,0 @@\n-    \/** Contains symbols of fields and constructors that have warnings suppressed.\n-     *\/\n-    private final Set<Symbol> suppressed = new HashSet<>();\n-\n@@ -234,1 +233,1 @@\n-        lint = Lint.instance(context);\n+        lintMapper = LintMapper.instance(context);\n@@ -265,2 +264,2 @@\n-        \/\/ Short circuit if warnings are totally disabled\n-        if (!lint.isEnabled(THIS_ESCAPE))\n+        \/\/ Short circuit if this calculation is unnecessary\n+        if (!lintMapper.lintAt(env.toplevel.sourcefile, env.tree.pos()).get().isEnabled(THIS_ESCAPE))\n@@ -281,1 +280,0 @@\n-        \/\/ Track which constructors and fields have warnings suppressed.\n@@ -285,1 +283,0 @@\n-            private Lint lint = ThisEscapeAnalyzer.this.lint;\n@@ -293,2 +290,0 @@\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n@@ -309,18 +304,0 @@\n-                    lint = lintPrev;\n-                }\n-            }\n-\n-            @Override\n-            public void visitVarDef(JCVariableDecl tree) {\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try {\n-\n-                    \/\/ Track warning suppression of fields\n-                    if (tree.sym.owner.kind == TYP && !lint.isEnabled(THIS_ESCAPE))\n-                        suppressed.add(tree.sym);\n-\n-                    \/\/ Recurse\n-                    super.visitVarDef(tree);\n-                } finally {\n-                    lint = lintPrev;\n@@ -332,7 +309,0 @@\n-                Lint lintPrev = lint;\n-                lint = lint.augment(tree.sym);\n-                try {\n-\n-                    \/\/ Track warning suppression of constructors\n-                    if (TreeInfo.isConstructor(tree) && !lint.isEnabled(THIS_ESCAPE))\n-                        suppressed.add(tree.sym);\n@@ -340,5 +310,5 @@\n-                    \/\/ Gather some useful info\n-                    boolean constructor = TreeInfo.isConstructor(tree);\n-                    boolean extendableClass = currentClassIsExternallyExtendable();\n-                    boolean nonPrivate = (tree.sym.flags() & (Flags.PUBLIC | Flags.PROTECTED)) != 0;\n-                    boolean finalish = (tree.mods.flags & (Flags.STATIC | Flags.PRIVATE | Flags.FINAL)) != 0;\n+                \/\/ Gather some useful info\n+                boolean constructor = TreeInfo.isConstructor(tree);\n+                boolean extendableClass = currentClassIsExternallyExtendable();\n+                boolean nonPrivate = (tree.sym.flags() & (Flags.PUBLIC | Flags.PROTECTED)) != 0;\n+                boolean finalish = (tree.mods.flags & (Flags.STATIC | Flags.PRIVATE | Flags.FINAL)) != 0;\n@@ -346,2 +316,2 @@\n-                    \/\/ Determine if this is a constructor we should analyze\n-                    boolean analyzable = extendableClass && constructor && nonPrivate;\n+                \/\/ Determine if this is a constructor we should analyze\n+                boolean analyzable = extendableClass && constructor && nonPrivate;\n@@ -349,2 +319,2 @@\n-                    \/\/ Determine if it's safe to \"invoke\" the method in an analysis (i.e., it can't be overridden)\n-                    boolean invokable = !extendableClass || constructor || finalish;\n+                \/\/ Determine if it's safe to \"invoke\" the method in an analysis (i.e., it can't be overridden)\n+                boolean invokable = !extendableClass || constructor || finalish;\n@@ -352,2 +322,2 @@\n-                    \/\/ Add this method or constructor to our map\n-                    methodMap.put(tree.sym, new MethodInfo(currentClass, tree, constructor, analyzable, invokable));\n+                \/\/ Add this method or constructor to our map\n+                methodMap.put(tree.sym, new MethodInfo(currentClass, tree, constructor, analyzable, invokable));\n@@ -355,5 +325,2 @@\n-                    \/\/ Recurse\n-                    super.visitMethodDef(tree);\n-                } finally {\n-                    lint = lintPrev;\n-                }\n+                \/\/ Recurse\n+                super.visitMethodDef(tree);\n@@ -404,1 +371,1 @@\n-                log.warning(frame.site.pos(), key);\n+                log.warning(frame.warningPos(), key);\n@@ -1749,0 +1716,8 @@\n+        DiagnosticPosition warningPos() {\n+            return site.pos().withLintPosition(NOPOS);      \/\/ disable normal Lint suppression\n+        }\n+\n+        Lint lint() {\n+            return lintMapper.lintAt(topLevelEnv.toplevel.sourcefile, site.pos()).get();\n+        }\n+\n@@ -1750,2 +1725,1 @@\n-            return suppressible &&\n-              suppressed.contains(initializer instanceof JCVariableDecl v ? v.sym : method.declaration.sym);\n+            return suppressible && !lint().isEnabled(THIS_ESCAPE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ThisEscapeAnalyzer.java","additions":30,"deletions":56,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -111,2 +110,0 @@\n-    private final DeferredLintHandler deferredLintHandler;\n-    private final Lint lint;\n@@ -138,2 +135,0 @@\n-        deferredLintHandler = DeferredLintHandler.instance(context);\n-        lint = Lint.instance(context);\n@@ -277,1 +272,0 @@\n-                deferredLintHandler.push(tree);\n@@ -285,1 +279,0 @@\n-                    deferredLintHandler.pop();\n@@ -354,2 +347,0 @@\n-            deferredLintHandler.pushImmediate(lint);\n-            Lint prevLint = chk.setLint(lint);\n@@ -379,7 +370,2 @@\n-                    deferredLintHandler.push(decl);\n-                    try {\n-                        \/\/check @Deprecated:\n-                        markDeprecated(decl.sym, decl.mods.annotations, env);\n-                    } finally {\n-                        deferredLintHandler.pop();\n-                    }\n+                    \/\/check for @Deprecated annotations\n+                    markDeprecated(decl.sym, decl.mods.annotations, env);\n@@ -387,1 +373,1 @@\n-                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle, decl);\n+                    annotate.annotateLater(decl.mods.annotations, env, env.toplevel.modle);\n@@ -391,2 +377,0 @@\n-                chk.setLint(prevLint);\n-                deferredLintHandler.pop();\n@@ -425,1 +409,1 @@\n-            annotate.annotateLater(tree.annotations, env, env.toplevel.packge, tree);\n+            annotate.annotateLater(tree.annotations, env, env.toplevel.packge);\n@@ -917,1 +901,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(tree.extending, baseEnv, sym);\n@@ -919,1 +903,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(impl, baseEnv, sym);\n@@ -934,1 +918,1 @@\n-            annotate.annotateLater(tree.mods.annotations, baseEnv, sym, tree);\n+            annotate.annotateLater(tree.mods.annotations, baseEnv, sym);\n@@ -938,1 +922,1 @@\n-                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym, tree);\n+                annotate.queueScanTreeAndTypeAnnotate(tp, baseEnv, sym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-        locations.update(log, lint, FSInfo.instance(context));\n+        locations.update(log, FSInfo.instance(context));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/BaseFileManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,2 +80,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -84,2 +82,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -88,0 +84,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n@@ -130,5 +127,0 @@\n-    \/**\n-     * The root {@link Lint} instance.\n-     *\/\n-    private Lint lint;\n-\n@@ -175,1 +167,1 @@\n-    void update(Log log, Lint lint, FSInfo fsInfo) {\n+    void update(Log log, FSInfo fsInfo) {\n@@ -177,1 +169,0 @@\n-        this.lint = lint;\n@@ -228,1 +219,1 @@\n-                    lint.logIfEnabled(LintWarnings.InvalidPath(s));\n+                    log.warning(LintWarnings.InvalidPath(s));\n@@ -322,1 +313,1 @@\n-                    lint.logIfEnabled(LintWarnings.DirPathElementNotFound(dir));\n+                    log.warning(LintWarnings.DirPathElementNotFound(dir));\n@@ -367,1 +358,1 @@\n-                    lint.logIfEnabled(LintWarnings.PathElementNotFound(file));\n+                    log.warning(LintWarnings.PathElementNotFound(file));\n@@ -389,1 +380,1 @@\n-                                lint.logIfEnabled(LintWarnings.UnexpectedArchiveFile(file));\n+                                log.warning(LintWarnings.UnexpectedArchiveFile(file));\n@@ -394,1 +385,1 @@\n-                                lint.logIfEnabled(LintWarnings.InvalidArchiveFile(file));\n+                                log.warning(LintWarnings.InvalidArchiveFile(file));\n@@ -1657,1 +1648,1 @@\n-                lint.logIfEnabled(Files.exists(prefix) ?\n+                log.warning(Files.exists(prefix) ?\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/Locations.java","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -142,3 +141,0 @@\n-    \/** The root Lint config. *\/\n-    Lint lint;\n-\n@@ -306,2 +302,0 @@\n-        lint = Lint.instance(context);\n-\n@@ -857,2 +851,1 @@\n-                        lint.logIfEnabled(\n-                                    LintWarnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));\n+                        log.warning(LintWarnings.FutureAttr(name, version.major, version.minor, majorVersion, minorVersion));\n@@ -1612,1 +1605,1 @@\n-            lint.logIfEnabled(LintWarnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n+            log.warning(LintWarnings.RuntimeVisibleInvisibleParamAnnotationsMismatch(currentClassFile));\n@@ -2078,1 +2071,1 @@\n-                    lint.logIfEnabled(LintWarnings.AnnotationMethodNotFound(container, name));\n+                    log.warning(LintWarnings.AnnotationMethodNotFound(container, name));\n@@ -2080,1 +2073,1 @@\n-                    lint.logIfEnabled(LintWarnings.AnnotationMethodNotFoundReason(container,\n+                    log.warning(LintWarnings.AnnotationMethodNotFoundReason(container,\n@@ -2957,1 +2950,1 @@\n-        lint.logIfEnabled(LintWarnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n+        log.warning(LintWarnings.RuntimeInvisibleParameterAnnotations(currentClassFile));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -506,6 +505,3 @@\n-                    boolean lintPaths = !options.isLintDisabled(LintCategory.PATH);\n-                    if (lintPaths) {\n-                        Path outDirParent = outDir.getParent();\n-                        if (outDirParent != null && Files.exists(outDirParent.resolve(\"module-info.class\"))) {\n-                            log.warning(LintWarnings.OutdirIsInExplodedModule(outDir));\n-                        }\n+                    Path outDirParent = outDir.getParent();\n+                    if (outDirParent != null && Files.exists(outDirParent.resolve(\"module-info.class\"))) {\n+                        log.warning(LintWarnings.OutdirIsInExplodedModule(outDir));\n@@ -579,2 +575,1 @@\n-        boolean lintOptions = !options.isLintDisabled(LintCategory.OPTIONS);\n-        if (lintOptions && source.compareTo(Source.DEFAULT) < 0 && !options.isSet(Option.RELEASE)) {\n+        if (source.compareTo(Source.DEFAULT) < 0 && !options.isSet(Option.RELEASE)) {\n@@ -583,1 +578,1 @@\n-                    if (baseFileManager.isDefaultBootClassPath())\n+                    if (baseFileManager.isDefaultBootClassPath()) {\n@@ -585,3 +580,3 @@\n-                } else {\n-                    if (baseFileManager.isDefaultSystemModulesPath())\n-                        log.warning(LintWarnings.SourceNoSystemModulesPath(source.name, releaseNote(source, targetString)));\n+                    }\n+                } else if (baseFileManager.isDefaultSystemModulesPath()) {\n+                    log.warning(LintWarnings.SourceNoSystemModulesPath(source.name, releaseNote(source, targetString)));\n@@ -596,1 +591,1 @@\n-        } else if (source == Source.MIN && lintOptions) {\n+        } else if (source == Source.MIN) {\n@@ -603,1 +598,1 @@\n-        } else if (target == Target.MIN && lintOptions) {\n+        } else if (target == Target.MIN) {\n@@ -637,1 +632,1 @@\n-        if (obsoleteOptionFound && lintOptions) {\n+        if (obsoleteOptionFound) {\n@@ -648,1 +643,1 @@\n-        if (lintOptions && options.isSet(Option.ADD_OPENS)) {\n+        if (options.isSet(Option.ADD_OPENS)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Arguments.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -261,0 +261,4 @@\n+    \/** The Lint mapper.\n+     *\/\n+    protected LintMapper lintMapper;\n+\n@@ -387,0 +391,1 @@\n+        lintMapper = LintMapper.instance(context);\n@@ -578,0 +583,1 @@\n+        log.reportOutstandingWarnings();\n@@ -628,0 +634,1 @@\n+        lintMapper.startParsingFile(filename);\n@@ -647,0 +654,1 @@\n+        lintMapper.finishParsingFile(tree);\n@@ -1846,0 +1854,1 @@\n+        log.reportOutstandingWarnings();\n@@ -1919,0 +1928,1 @@\n+        lintMapper = null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import com.sun.tools.javac.code.Lint;\n-import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -86,1 +84,1 @@\n-    private final Log log;\n+    protected final Log log;\n@@ -138,7 +136,0 @@\n-    \/**\n-     * The set of lint options currently in effect. It is initialized\n-     * from the context, and then is set\/reset as needed by Attr as it\n-     * visits all the various parts of the trees during attribution.\n-     *\/\n-    protected final Lint lint;\n-\n@@ -171,1 +162,0 @@\n-        this.lint = fac.lint;\n@@ -208,11 +198,0 @@\n-    \/**\n-     * Report a warning at the given position using the provided arguments.\n-     *\n-     * @param pos    position in input buffer.\n-     * @param key    error key to report.\n-     *\/\n-    protected void lexWarning(int pos, JCDiagnostic.LintWarning key) {\n-        DiagnosticPosition dp = new SimpleDiagnosticPosition(pos) ;\n-        log.warning(dp, key);\n-    }\n-\n@@ -1063,11 +1042,6 @@\n-                    if (lint.isEnabled(LintCategory.TEXT_BLOCKS)) {\n-                        Set<TextBlockSupport.WhitespaceChecks> checks =\n-                                TextBlockSupport.checkWhitespace(string);\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.InconsistentWhiteSpaceIndentation);\n-                        }\n-                        if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n-                            lexWarning(pos,\n-                                    LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n-                        }\n+                    Set<TextBlockSupport.WhitespaceChecks> checks = TextBlockSupport.checkWhitespace(string);\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.INCONSISTENT)) {\n+                        log.warning(pos, LintWarnings.InconsistentWhiteSpaceIndentation);\n+                    }\n+                    if (checks.contains(TextBlockSupport.WhitespaceChecks.TRAILING)) {\n+                        log.warning(pos, LintWarnings.TrailingWhiteSpaceWillBeRemoved);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":7,"deletions":33,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -119,2 +119,0 @@\n-    \/** Handler for deferred diagnostics. *\/\n-    protected final DeferredLintHandler deferredLintHandler;\n@@ -193,1 +191,0 @@\n-        this.deferredLintHandler = fac.deferredLintHandler;\n@@ -219,1 +216,0 @@\n-        this.deferredLintHandler = parser.deferredLintHandler;\n@@ -594,2 +590,1 @@\n-     *     dangling comments are also attached to the tree node\n-     *     by registering them using the {@link #deferredLintHandler}.\n+     *     dangling comments are reported to the log as warnings.\n@@ -656,6 +651,1 @@\n-            deferredLintHandler.push(tree);\n-            try {\n-                list.forEach(this::reportDanglingDocComment);\n-            } finally {\n-                deferredLintHandler.pop();\n-            }\n+            list.forEach(c -> reportDanglingDocComment(tree, c));\n@@ -666,1 +656,1 @@\n-     * Reports an individual dangling comment using the {@link #deferredLintHandler}.\n+     * Reports an individual dangling comment as a warning to the log.\n@@ -672,1 +662,1 @@\n-    void reportDanglingDocComment(Comment c) {\n+    void reportDanglingDocComment(JCTree tree, Comment c) {\n@@ -674,8 +664,3 @@\n-        if (pos != null) {\n-            deferredLintHandler.report(lint -> {\n-                if (lint.isEnabled(Lint.LintCategory.DANGLING_DOC_COMMENTS) &&\n-                        !shebang(c, pos)) {\n-                    log.warning(\n-                            pos, LintWarnings.DanglingDocComment);\n-                }\n-            });\n+        if (pos != null && !shebang(c, pos)) {\n+            pos = pos.withLintPosition(tree.getStartPosition());\n+            S.lintWarning(pos, LintWarnings.DanglingDocComment);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -106,0 +108,8 @@\n+\n+    \/**\n+     * Report a warning that is subject to possible suppression by {@code @SuppressWarnings}.\n+     *\n+     * @param pos the lexical position at which the warning occurs\n+     * @param key the warning to report\n+     *\/\n+    void lintWarning(DiagnosticPosition pos, LintWarning key);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Lexer.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import com.sun.tools.javac.code.DeferredLintHandler;\n@@ -73,1 +72,0 @@\n-    final DeferredLintHandler deferredLintHandler;\n@@ -91,1 +89,0 @@\n-        this.deferredLintHandler = DeferredLintHandler.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ParserFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -153,0 +155,5 @@\n+    @Override\n+    public void lintWarning(DiagnosticPosition pos, LintWarning key) {\n+        tokenizer.log.warning(pos, key);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import com.sun.tools.javac.code.Lint;\n@@ -65,1 +64,0 @@\n-    final Lint lint;\n@@ -77,1 +75,0 @@\n-        this.lint = Lint.instance(context);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ScannerFactory.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -170,4 +171,3 @@\n-        public void commit() {\n-            for (int i = 0 ; i < offset ; i++) {\n-                S.nextToken(); \/\/ advance underlying lexer until position matches\n-            }\n+        @Override\n+        public void lintWarning(DiagnosticPosition pos, LintWarning key) {\n+           \/\/ ignore\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/VirtualParser.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-import com.sun.tools.javac.code.Lint;\n@@ -65,1 +64,0 @@\n-import static com.sun.tools.javac.code.Lint.LintCategory.PROCESSING;\n@@ -341,1 +339,0 @@\n-    Lint lint;\n@@ -424,2 +421,0 @@\n-        lint = Lint.instance(context);\n-\n@@ -489,8 +484,6 @@\n-        if (lint.isEnabled(PROCESSING)) {\n-            int periodIndex = name.lastIndexOf(\".\");\n-            if (periodIndex != -1) {\n-                String base = name.substring(periodIndex);\n-                String extn = (isSourceFile ? \".java\" : \".class\");\n-                if (base.equals(extn))\n-                    log.warning(LintWarnings.ProcSuspiciousClassName(name, extn));\n-            }\n+        int periodIndex = name.lastIndexOf(\".\");\n+        if (periodIndex != -1) {\n+            String base = name.substring(periodIndex);\n+            String extn = (isSourceFile ? \".java\" : \".class\");\n+            if (base.equals(extn))\n+                log.warning(LintWarnings.ProcSuspiciousClassName(name, extn));\n@@ -710,1 +703,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcIllegalFileName(name));\n+            log.warning(LintWarnings.ProcIllegalFileName(name));\n@@ -738,1 +731,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcTypeRecreate(typename));\n+            log.warning(LintWarnings.ProcTypeRecreate(typename));\n@@ -742,1 +735,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcTypeAlreadyExists(typename));\n+            log.warning(LintWarnings.ProcTypeAlreadyExists(typename));\n@@ -771,1 +764,1 @@\n-            lint.logIfEnabled(LintWarnings.ProcFileReopening(fileObject.getName()));\n+            log.warning(LintWarnings.ProcFileReopening(fileObject.getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacFiler.java","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-    private final Lint lint;\n@@ -209,1 +208,0 @@\n-        lint = Lint.instance(context);\n@@ -629,1 +627,1 @@\n-                       boolean allowModules, ProcessingEnvironment env, Lint lint) {\n+                       boolean allowModules, ProcessingEnvironment env) {\n@@ -650,2 +648,1 @@\n-                        add(importStringToPattern(allowModules, annotationPattern,\n-                                                  processor, log, lint));\n+                        add(importStringToPattern(allowModules, annotationPattern, processor, log));\n@@ -653,1 +650,1 @@\n-                        lint.logIfEnabled(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n+                        log.warning(LintWarnings.ProcDuplicateSupportedAnnotation(annotationPattern,\n@@ -666,1 +663,1 @@\n-                    lint.logIfEnabled(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n+                    log.warning(LintWarnings.ProcRedundantTypesWithWildcard(p.getClass().getName()));\n@@ -674,2 +671,1 @@\n-                            lint.logIfEnabled(LintWarnings.ProcDuplicateOptionName(optionName,\n-                                                                         p.getClass().getName()));\n+                            log.warning(LintWarnings.ProcDuplicateOptionName(optionName, p.getClass().getName()));\n@@ -762,2 +758,1 @@\n-                                                           JavacProcessingEnvironment.this,\n-                                                           lint);\n+                                                           JavacProcessingEnvironment.this);\n@@ -891,1 +886,1 @@\n-        if (lint.isEnabled(PROCESSING) && unmatchedAnnotations.size() > 0) {\n+        if (unmatchedAnnotations.size() > 0) {\n@@ -1652,1 +1647,1 @@\n-    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log, Lint lint) {\n+    private static Pattern importStringToPattern(boolean allowModules, String s, Processor p, Log log) {\n@@ -1665,1 +1660,1 @@\n-                return warnAndNoMatches(s, p, log, lint);\n+                return warnAndNoMatches(s, p, log);\n@@ -1674,1 +1669,1 @@\n-            return warnAndNoMatches(s, p, log, lint);\n+            return warnAndNoMatches(s, p, log);\n@@ -1678,2 +1673,2 @@\n-    private static Pattern warnAndNoMatches(String s, Processor p, Log log, Lint lint) {\n-        lint.logIfEnabled(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n+    private static Pattern warnAndNoMatches(String s, Processor p, Log log) {\n+        log.warning(LintWarnings.ProcMalformedSupportedString(s, p.getClass().getName()));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1603,0 +1603,1 @@\n+# flags: default-enabled\n@@ -1927,1 +1928,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1933,1 +1934,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1939,1 +1940,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1950,1 +1951,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1962,1 +1963,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -1968,1 +1969,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2197,0 +2198,1 @@\n+# flags: default-enabled\n@@ -2202,0 +2204,1 @@\n+# flags: default-enabled\n@@ -2227,0 +2230,1 @@\n+# flags: default-enabled\n@@ -2232,0 +2236,1 @@\n+# flags: default-enabled\n@@ -2244,0 +2249,1 @@\n+# flags: default-enabled\n@@ -2368,1 +2374,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2374,1 +2380,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2384,1 +2390,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2392,1 +2398,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2398,1 +2404,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -2797,1 +2803,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3194,1 +3200,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3201,1 +3207,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3305,1 +3311,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3311,1 +3317,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n@@ -3882,0 +3888,1 @@\n+# flags: default-enabled\n@@ -3898,0 +3905,1 @@\n+# flags: default-enabled\n@@ -4275,1 +4283,1 @@\n-# flags: aggregate, mandatory\n+# flags: aggregate, mandatory, default-enabled\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -371,0 +371,30 @@\n+        \/** Get the position that determines which Lint configuration applies. *\/\n+        default int getLintPosition() {\n+            return getStartPosition();\n+        }\n+        \/** Create a new instance from this instance and the given lint position. *\/\n+        default DiagnosticPosition withLintPosition(int lintPos) {\n+            DiagnosticPosition orig = this;\n+            return new DiagnosticPosition() {\n+                @Override\n+                public JCTree getTree() {\n+                    return orig.getTree();\n+                }\n+                @Override\n+                public int getStartPosition() {\n+                    return orig.getStartPosition();\n+                }\n+                @Override\n+                public int getPreferredPosition() {\n+                    return orig.getPreferredPosition();\n+                }\n+                @Override\n+                public int getEndPosition(EndPosTable endPosTable) {\n+                    return orig.getEndPosition(endPosTable);\n+                }\n+                @Override\n+                public int getLintPosition() {\n+                    return lintPos;\n+                }\n+            };\n+        }\n@@ -408,0 +438,4 @@\n+        \/** Flag for lint diagnostics that should be emitted even when their category\n+         *  is not explicitly enabled, as long as it is not explicitly suppressed.\n+         *\/\n+        DEFAULT_ENABLED,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JCDiagnostic.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n@@ -39,0 +41,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -45,0 +48,1 @@\n+import com.sun.tools.javac.code.Flags;\n@@ -47,0 +51,1 @@\n+import com.sun.tools.javac.code.LintMapper;\n@@ -48,0 +53,3 @@\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.comp.AttrContext;\n+import com.sun.tools.javac.comp.Env;\n@@ -51,1 +59,4 @@\n-import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeScanner;\n@@ -55,0 +66,1 @@\n+import com.sun.tools.javac.util.JCDiagnostic.LintWarning;\n@@ -58,0 +70,4 @@\n+import static com.sun.tools.javac.code.Lint.LintCategory.*;\n+import static com.sun.tools.javac.resources.CompilerProperties.LintWarnings.RequiresAutomatic;\n+import static com.sun.tools.javac.resources.CompilerProperties.LintWarnings.RequiresTransitiveAutomatic;\n+import static com.sun.tools.javac.tree.JCTree.Tag.*;\n@@ -106,0 +122,5 @@\n+        \/**\n+         * Diagnostics waiting for an applicable {@link Lint} instance.\n+         *\/\n+        protected Map<JavaFileObject, List<JCDiagnostic>> lintWaitersMap = new LinkedHashMap<>();\n+\n@@ -116,1 +137,57 @@\n-         * Handle a diagnostic.\n+         * Step 1: Handle a diagnostic for which the applicable Lint instance (if any) may not be known yet.\n+         *\/\n+        public final void report(JCDiagnostic diag) {\n+            Lint lint = null;\n+            LintCategory category = diag.getLintCategory();\n+            if (category != null) {                                         \/\/ this is a lint warning; find the applicable Lint\n+                DiagnosticPosition pos = diag.getDiagnosticPosition();\n+                if (pos != null && category.annotationSuppression) {        \/\/ we should apply the Lint from the warning's position\n+                    if ((lint = lintFor(diag)) == null) {\n+                        addLintWaiter(currentSourceFile(), diag);           \/\/ ...but we don't know it yet, so defer\n+                        return;\n+                    }\n+                } else                                                      \/\/ we should apply the root Lint\n+                    lint = rootLint();\n+            }\n+            reportWithLint(diag, lint);\n+        }\n+\n+        \/**\n+         * Step 2: Handle a diagnostic for which the applicable Lint instance (if any) is known and provided.\n+         *\/\n+        public final void reportWithLint(JCDiagnostic diag, Lint lint) {\n+\n+            \/\/ Apply hackery for REQUIRES_TRANSITIVE_AUTOMATIC (see also Check.checkModuleRequires())\n+            if (diag.getCode().equals(RequiresTransitiveAutomatic.key()) && !lint.isEnabled(REQUIRES_TRANSITIVE_AUTOMATIC)) {\n+                reportWithLint(\n+                  diags.warning(null, diag.getDiagnosticSource(), diag.getDiagnosticPosition(), RequiresAutomatic), lint);\n+                return;\n+            }\n+\n+            \/\/ Apply the lint configuration (if any) and discard the warning if it gets filtered out\n+            if (lint != null) {\n+                LintCategory category = diag.getLintCategory();\n+                boolean emit = !diag.isFlagSet(DEFAULT_ENABLED) ?       \/\/ is the warning not enabled by default?\n+                  lint.isEnabled(category) :                            \/\/ then emit if the category is enabled\n+                  category.annotationSuppression ?                      \/\/ else emit if the category is not suppressed, where\n+                    !lint.isSuppressed(category) :                      \/\/ ...suppression happens via @SuppressWarnings\n+                    !options.isLintDisabled(category);                  \/\/ ...suppression happens via -Xlint:-category\n+                if (!emit)\n+                    return;\n+            }\n+\n+            \/\/ Proceed\n+            reportReady(diag);\n+        }\n+\n+        \/**\n+         * Step 3: Handle a diagnostic to which the applicable Lint instance (if any) has been applied.\n+         *\/\n+        protected abstract void reportReady(JCDiagnostic diag);\n+\n+        protected void addLintWaiter(JavaFileObject sourceFile, JCDiagnostic diagnostic) {\n+            lintWaitersMap.computeIfAbsent(sourceFile, s -> new LinkedList<>()).add(diagnostic);\n+        }\n+\n+        \/**\n+         * Flush any lint waiters whose {@link Lint} configurations are now known.\n@@ -118,1 +195,28 @@\n-        public abstract void report(JCDiagnostic diag);\n+        public void flushLintWaiters() {\n+            lintWaitersMap.entrySet().removeIf(entry -> {\n+\n+                \/\/ Is the source file no longer recognized? If so, discard warnings (e.g., this can happen with JShell)\n+                JavaFileObject sourceFile = entry.getKey();\n+                if (!lintMapper.isKnown(sourceFile))\n+                    return true;\n+\n+                \/\/ Flush those diagnostics for which we now know the applicable Lint\n+                List<JCDiagnostic> diagnosticList = entry.getValue();\n+                JavaFileObject prevSourceFile = useSource(sourceFile);\n+                try {\n+                    diagnosticList.removeIf(diag -> {\n+                        Lint lint = lintFor(diag);\n+                        if (lint != null) {\n+                            reportWithLint(diag, lint);\n+                            return true;\n+                        }\n+                        return false;\n+                    });\n+                } finally {\n+                    useSource(prevSourceFile);\n+                }\n+\n+                \/\/ Discard list if empty\n+                return diagnosticList.isEmpty();\n+            });\n+        }\n@@ -127,1 +231,4 @@\n-        public void report(JCDiagnostic diag) { }\n+        protected void addLintWaiter(JavaFileObject sourceFile, JCDiagnostic diagnostic) { }\n+\n+        @Override\n+        protected void reportReady(JCDiagnostic diag) { }\n@@ -160,1 +267,1 @@\n-        public void report(JCDiagnostic diag) {\n+        protected void reportReady(JCDiagnostic diag) {\n@@ -164,1 +271,10 @@\n-                prev.report(diag);\n+                prev.reportReady(diag);\n+            }\n+        }\n+\n+        @Override\n+        protected void addLintWaiter(JavaFileObject sourceFile, JCDiagnostic diag) {\n+            if (deferrable(diag)) {\n+                super.addLintWaiter(sourceFile, diag);\n+            } else {\n+                prev.addLintWaiter(sourceFile, diag);\n@@ -185,0 +301,7 @@\n+\n+            \/\/ Flush matching Lint waiters to the previous handler\n+            lintWaitersMap.forEach(\n+              (sourceFile, diagnostics) -> diagnostics.stream()\n+                .filter(accepter)\n+                .forEach(diagnostic -> prev.addLintWaiter(sourceFile, diagnostic)));\n+            lintWaitersMap = null; \/\/ prevent accidental ongoing use\n@@ -250,0 +373,10 @@\n+    \/**\n+     * The {@link Options} singleton.\n+     *\/\n+    private final Options options;\n+\n+    \/**\n+     * The lint positions table.\n+     *\/\n+    private final LintMapper lintMapper;\n+\n@@ -353,0 +486,2 @@\n+        this.options = Options.instance(context);\n+        this.lintMapper = LintMapper.instance(context);\n@@ -372,1 +507,0 @@\n-        final Options options = Options.instance(context);\n@@ -692,0 +826,15 @@\n+\/\/ Deferred Lint Calculation\n+\n+    \/**\n+     * Report unreported lint warnings for which the applicable {@link Lint} configuration is now known.\n+     *\/\n+    public void reportOutstandingWarnings() {\n+        diagnosticHandler.flushLintWaiters();\n+    }\n+\n+    \/\/ Get the Lint config for the given warning (if known)\n+    private Lint lintFor(JCDiagnostic diag) {\n+        Assert.check(diag.getLintCategory() != null);\n+        return lintMapper.lintAt(diag.getSource(), diag.getDiagnosticPosition()).orElse(null);\n+    }\n+\n@@ -759,1 +908,1 @@\n-        public void report(JCDiagnostic diagnostic) {\n+        protected void reportReady(JCDiagnostic diagnostic) {\n@@ -786,1 +935,1 @@\n-                    boolean verbose = rootLint().isEnabled(category);\n+                    boolean verbose = lintFor(diagnostic).isEnabled(category);\n@@ -792,1 +941,1 @@\n-                if (diagnostic.isFlagSet(DiagnosticFlag.STRICT)) {\n+                if (diagnostic.isFlagSet(STRICT)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Log.java","additions":159,"deletions":10,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-import com.sun.tools.javac.resources.CompilerProperties.LintWarnings;\n+import com.sun.tools.javac.resources.CompilerProperties.Warnings;\n@@ -133,4 +133,5 @@\n-            log.warning(LintWarnings.DivZero);\n-            log.warning(tree.pos, LintWarnings.DivZero);\n-            log.warning(tree.pos(), LintWarnings.DivZero);\n-            log.warning(nil, LintWarnings.DivZero);\n+            \/\/ some warnings that will be emitted during parsing\n+            log.warning(Warnings.ExtraneousSemicolon);\n+            log.warning(tree.pos, Warnings.ExtraneousSemicolon);\n+            log.warning(tree.pos(), Warnings.ExtraneousSemicolon);\n+            log.warning(nil, Warnings.ExtraneousSemicolon);\n","filename":"test\/langtools\/tools\/javac\/6304921\/TestLog.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -733,1 +733,0 @@\n-                \"module-info.java:3:18: compiler.warn.module.not.found: M1\",\n@@ -735,0 +734,1 @@\n+                \"module-info.java:3:18: compiler.warn.module.not.found: M1\",\n","filename":"test\/langtools\/tools\/javac\/ImportModule.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-T6400189a.java:14:35: compiler.warn.unchecked.call.mbr.of.raw.type: <T>getAnnotation(java.lang.Class<T>), java.lang.reflect.Constructor\n@@ -3,0 +2,1 @@\n+T6400189a.java:14:35: compiler.warn.unchecked.call.mbr.of.raw.type: <T>getAnnotation(java.lang.Class<T>), java.lang.reflect.Constructor\n","filename":"test\/langtools\/tools\/javac\/OverrideChecks\/6400189\/T6400189a.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-T6400189b.java:24:24: compiler.warn.unchecked.call.mbr.of.raw.type: <T>m(T6400189b<T>), T6400189b.B\n@@ -3,0 +2,1 @@\n+T6400189b.java:24:24: compiler.warn.unchecked.call.mbr.of.raw.type: <T>m(T6400189b<T>), T6400189b.B\n","filename":"test\/langtools\/tools\/javac\/OverrideChecks\/6400189\/T6400189b.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+DanglingDocCommentsClass.java:15:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass.java:19:5: compiler.warn.dangling.doc.comment\n@@ -5,2 +7,0 @@\n-DanglingDocCommentsClass.java:15:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsClass.java:19:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass.enabled.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,2 @@\n+DanglingDocCommentsClass_Line.java:21:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsClass_Line.java:26:5: compiler.warn.dangling.doc.comment\n@@ -5,2 +7,0 @@\n-DanglingDocCommentsClass_Line.java:21:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsClass_Line.java:26:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass_Line.enabled.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-DanglingDocCommentsClass_Mixed.java:13:1: compiler.warn.dangling.doc.comment\n@@ -4,0 +3,1 @@\n+DanglingDocCommentsClass_Mixed.java:13:1: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsClass_Mixed.enabled.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,3 @@\n+DanglingDocCommentsEnum.java:16:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:22:5: compiler.warn.dangling.doc.comment\n+DanglingDocCommentsEnum.java:28:5: compiler.warn.dangling.doc.comment\n@@ -5,3 +8,0 @@\n-DanglingDocCommentsEnum.java:16:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:22:5: compiler.warn.dangling.doc.comment\n-DanglingDocCommentsEnum.java:28:5: compiler.warn.dangling.doc.comment\n","filename":"test\/langtools\/tools\/javac\/danglingDocComments\/DanglingDocCommentsEnum.enabled.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,0 @@\n-T7188968.java:20:9: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n@@ -4,1 +3,0 @@\n-T7188968.java:21:29: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n@@ -6,0 +4,3 @@\n+T7188968.java:23:24: compiler.err.cant.resolve.location: kindname.variable, unknown, , , (compiler.misc.location: kindname.class, T7188968, null)\n+T7188968.java:20:9: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n+T7188968.java:21:29: compiler.warn.unchecked.call.mbr.of.raw.type: T7188968.Foo(java.util.List<X>,java.lang.Object), T7188968.Foo\n@@ -8,1 +9,0 @@\n-T7188968.java:23:24: compiler.err.cant.resolve.location: kindname.variable, unknown, , , (compiler.misc.location: kindname.class, T7188968, null)\n","filename":"test\/langtools\/tools\/javac\/generics\/diamond\/7188968\/T7188968.out","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-TargetType22.java:29:21: compiler.warn.unchecked.varargs.non.reifiable.type: A\n@@ -3,0 +2,1 @@\n+TargetType22.java:29:21: compiler.warn.unchecked.varargs.non.reifiable.type: A\n","filename":"test\/langtools\/tools\/javac\/lambda\/TargetType22.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify lexical lint warnings handle nested declarations with SuppressWarnings correctly\n+ * @compile\/fail\/ref=LexicalLintNesting.out -XDrawDiagnostics -Xlint:text-blocks -Werror LexicalLintNesting.java\n+ *\/\n+\n+\/\/@SuppressWarnings(\"text-blocks\")\n+public class LexicalLintNesting {\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s1 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s2 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    public static class Nested1 {\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s3 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s4 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        public static class Nested1A {\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s5 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s6 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s7 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s8 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        public static class Nested1B {\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s9 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            \/* WARNING HERE *\/ String s10 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s11 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        \/* WARNING HERE *\/ String s12 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s13 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s14 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Nested2 {\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s15 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s16 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        public static class Nested2A {\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s17 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s18 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s19 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s20 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        public static class Nested2B {\n+\n+            @SuppressWarnings(\"text-blocks\")\n+            String s21 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+            \/\/@SuppressWarnings(\"text-blocks\")\n+            String s22 = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";\n+\n+        }\n+\n+        @SuppressWarnings(\"text-blocks\")\n+        String s23 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+        \/\/@SuppressWarnings(\"text-blocks\")\n+        String s24 = \"\"\"\n+            trailing space here:\\u0020\n+            \"\"\";\n+\n+    }\n+\n+    \/\/@SuppressWarnings(\"text-blocks\")\n+    \/* WARNING HERE *\/ String s25 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    String s26 = \"\"\"\n+        trailing space here:\\u0020\n+        \"\"\";\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/LexicalLintNesting.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,10 @@\n+LexicalLintNesting.java:12:36: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:30:40: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:55:40: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:68:45: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:80:41: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:92:37: compiler.warn.trailing.white.space.will.be.removed\n+LexicalLintNesting.java:162:37: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+7 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/LexicalLintNesting.out","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8224228\n+ * @summary Verify SuppressWarnings works for LintCategore.TEXT_BLOCKS\n+ * @compile\/fail\/ref=TextBlockSuppress.out -XDrawDiagnostics -Xlint:text-blocks -Werror TextBlockSuppress.java\n+ *\/\n+\n+public class TextBlockSuppress {\n+\n+    public static class Example1 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example2 {\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example3 {\n+        @SuppressWarnings(\"text-blocks\")\n+        public void method() {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example4 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD get a warning here\n+        }\n+    }\n+\n+    @SuppressWarnings(\"text-blocks\")\n+    public static class Example5 {\n+        {\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+\n+    public static class Example6 {\n+        public void method() {\n+            @SuppressWarnings(\"text-blocks\")\n+            String s = \"\"\"\n+                trailing space here:\\u0020\n+                \"\"\";        \/\/ SHOULD NOT get a warning here\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+TextBlockSuppress.java:12:24: compiler.warn.trailing.white.space.will.be.removed\n+TextBlockSuppress.java:38:24: compiler.warn.trailing.white.space.will.be.removed\n+- compiler.err.warnings.and.werror\n+1 error\n+2 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/TextBlockSuppress.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -1,1 +0,0 @@\n-Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n@@ -3,0 +2,1 @@\n+Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n","filename":"test\/langtools\/tools\/javac\/mandatoryWarnings\/deprecated\/Test5.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +0,0 @@\n-Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n@@ -3,0 +2,1 @@\n+Q.java:7:10: compiler.warn.has.been.deprecated: bar(), Q2\n","filename":"test\/langtools\/tools\/javac\/mandatoryWarnings\/deprecated\/Test5b.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -602,1 +602,0 @@\n-                        \"module-info.java:1:19: compiler.warn.missing.deprecated.annotation\",\n@@ -604,0 +603,1 @@\n+                        \"module-info.java:1:19: compiler.warn.missing.deprecated.annotation\",\n","filename":"test\/langtools\/tools\/javac\/modules\/AnnotationsOnModules.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -327,1 +327,3 @@\n-                            if (lint == Lint.ENABLE_PREVIEW) {\n+                            if (suppress == Suppress.YES) {\n+                                expected = Set.of();\n+                            } else if (lint == Lint.ENABLE_PREVIEW) {\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewErrors.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -590,1 +590,0 @@\n-                        \"Test.java:24:11: compiler.warn.is.preview.reflective: test()\",\n@@ -596,0 +595,1 @@\n+                        \"Test.java:24:11: compiler.warn.is.preview.reflective: test()\",\n@@ -795,0 +795,93 @@\n+    @Test \/\/JDK-8224228:\n+    public void testSuppressWarnings(Path base) throws Exception {\n+        Path apiSrc = base.resolve(\"api-src\");\n+        tb.writeJavaFiles(apiSrc,\n+                          \"\"\"\n+                          package preview.api;\n+                          @jdk.internal.javac.PreviewFeature(feature=jdk.internal.javac.PreviewFeature.Feature.TEST)\n+                          public class Preview {\n+                              public static int test() {\n+                                return 0;\n+                              }\n+                          }\n+                          \"\"\");\n+        Path apiClasses = base.resolve(\"api-classes\");\n+\n+        new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(apiClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiSrc.toString(),\n+                         \"-Werror\")\n+                .files(tb.findJavaFiles(apiSrc))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        Path testSrc = base.resolve(\"test-src\");\n+        tb.writeJavaFiles(testSrc,\n+                          \"\"\"\n+                          package test;\n+                          import preview.api.Preview;\n+                          public class Test {\n+\n+                            public static class Example1 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example2 {\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example3 {\n+                                @SuppressWarnings(\"preview\")\n+                                public void method() {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example4 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD get a warning here\n+                                }\n+                            }\n+\n+                            @SuppressWarnings(\"preview\")\n+                            public static class Example5 {\n+                                {\n+                                    Preview.test();         \/\/ SHOULD NOT get a warning here\n+                                }\n+                            }\n+\n+                            public static class Example6 {\n+                                @SuppressWarnings(\"preview\")\n+                                int x = Preview.test();     \/\/ SHOULD NOT get a warning here\n+                            }\n+                          }\n+                          \"\"\");\n+        Path testClasses = base.resolve(\"test-classes\");\n+        List<String> log = new JavacTask(tb, Task.Mode.CMDLINE)\n+                .outdir(testClasses)\n+                .options(\"--patch-module\", \"java.base=\" + apiClasses.toString(),\n+                         \"--add-exports\", \"java.base\/preview.api=ALL-UNNAMED\",\n+                         \"--enable-preview\",\n+                         \"-Xlint:preview\",\n+                         \"-source\", String.valueOf(Runtime.version().feature()),\n+                         \"-XDrawDiagnostics\")\n+                .files(tb.findJavaFiles(testSrc))\n+                .run(Task.Expect.SUCCESS)\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        List<String> expected =\n+                List.of(\"Test.java:7:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"Test.java:27:11: compiler.warn.is.preview: preview.api.Preview\",\n+                        \"2 warnings\");\n+\n+        if (!log.equals(expected))\n+            throw new Exception(\"expected output not found: \" + log);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/preview\/PreviewTest.java","additions":95,"deletions":2,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -1,2 +0,0 @@\n-T7097436.java:13:20: compiler.warn.varargs.unsafe.use.varargs.param: ls\n-T7097436.java:14:25: compiler.warn.varargs.unsafe.use.varargs.param: ls\n@@ -5,0 +3,2 @@\n+T7097436.java:13:20: compiler.warn.varargs.unsafe.use.varargs.param: ls\n+T7097436.java:14:25: compiler.warn.varargs.unsafe.use.varargs.param: ls\n","filename":"test\/langtools\/tools\/javac\/varargs\/7097436\/T7097436.out","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+T6594914a.java:16:52: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n@@ -5,1 +6,0 @@\n-T6594914a.java:16:52: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n","filename":"test\/langtools\/tools\/javac\/warnings\/6594914\/T6594914a.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+T7090499.java:26:10: compiler.err.improperly.formed.type.inner.raw.param\n+T7090499.java:27:10: compiler.err.improperly.formed.type.inner.raw.param\n+T7090499.java:28:17: compiler.err.improperly.formed.type.inner.raw.param\n+T7090499.java:28:10: compiler.err.improperly.formed.type.inner.raw.param\n@@ -6,2 +10,0 @@\n-T7090499.java:26:10: compiler.err.improperly.formed.type.inner.raw.param\n-T7090499.java:27:10: compiler.err.improperly.formed.type.inner.raw.param\n@@ -9,1 +11,0 @@\n-T7090499.java:28:17: compiler.err.improperly.formed.type.inner.raw.param\n@@ -11,1 +12,0 @@\n-T7090499.java:28:10: compiler.err.improperly.formed.type.inner.raw.param\n","filename":"test\/langtools\/tools\/javac\/warnings\/7090499\/T7090499.out","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,0 @@\n-                               \"UnneededStrictfpWarning1.java:16:28: compiler.warn.strictfp\",\n@@ -121,0 +120,1 @@\n+                               \"UnneededStrictfpWarning1.java:16:28: compiler.warn.strictfp\",\n","filename":"test\/langtools\/tools\/javac\/warnings\/UnneededStrictfpWarningToolBox.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+T6480588.java:18:35: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n@@ -6,0 +7,4 @@\n+T6480588.java:30:5: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n+T6480588.java:33:25: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n+T6480588.java:33:52: compiler.warn.has.been.deprecated: DeprecatedInterface, compiler.misc.unnamed.package\n+T6480588.java:32:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n@@ -7,1 +12,1 @@\n-T6480588.java:18:35: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n+T6480588.java:29:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n@@ -13,2 +18,0 @@\n-T6480588.java:30:5: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n-T6480588.java:29:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n@@ -16,3 +19,0 @@\n-T6480588.java:33:25: compiler.warn.has.been.deprecated: DeprecatedClass, compiler.misc.unnamed.package\n-T6480588.java:33:52: compiler.warn.has.been.deprecated: DeprecatedInterface, compiler.misc.unnamed.package\n-T6480588.java:32:6: compiler.warn.has.been.deprecated: DeprecatedAnnotation, compiler.misc.unnamed.package\n","filename":"test\/langtools\/tools\/javac\/warnings\/suppress\/T6480588.out","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}