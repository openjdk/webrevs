{"files":[{"patch":"@@ -742,1 +742,1 @@\n-  \/* Thread.dump_to_file jcmd *\/                                                                                  \\\n+  \/* jcmd Thread.dump_to_file *\/                                                                                  \\\n@@ -746,0 +746,5 @@\n+                                                                                                                  \\\n+  \/* jcmd Thread.vthread_scheduler and Thread.vthread_pollers *\/                                                  \\\n+  template(jdk_internal_vm_JcmdVThreadCommands,    \"jdk\/internal\/vm\/JcmdVThreadCommands\")                         \\\n+  template(printScheduler_name,                    \"printScheduler\")                                              \\\n+  template(printPollers_name,                      \"printPollers\")                                                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -131,0 +131,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VThreadSchedulerDCmd>(full_export, true, false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<VThreadPollersDCmd>(full_export, true, false));\n@@ -1112,0 +1114,60 @@\n+}\n+\n+void VThreadSchedulerDCmd::execute(DCmdSource source, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  HandleMark hm(THREAD);\n+\n+  Symbol* sym = vmSymbols::jdk_internal_vm_JcmdVThreadCommands();\n+  Klass* k = SystemDictionary::resolve_or_fail(sym, true, CHECK);\n+\n+  \/\/ invoke VThreadCommands.printScheduler\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  JavaCalls::call_static(&result,\n+                         k,\n+                         vmSymbols::printScheduler_name(),\n+                         vmSymbols::void_byte_array_signature(),\n+                         &args,\n+                         THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    java_lang_Throwable::print(PENDING_EXCEPTION, output());\n+    output()->cr();\n+    CLEAR_PENDING_EXCEPTION;\n+    return;\n+  }\n+\n+  \/\/ copy the bytes to the output stream\n+  oop res = cast_to_oop(result.get_jobject());\n+  typeArrayOop ba = typeArrayOop(res);\n+  jbyte* addr = typeArrayOop(res)->byte_at_addr(0);\n+  output()->print_raw((const char*)addr, ba->length());\n+}\n+\n+void VThreadPollersDCmd::execute(DCmdSource source, TRAPS) {\n+  ResourceMark rm(THREAD);\n+  HandleMark hm(THREAD);\n+\n+  Symbol* sym = vmSymbols::jdk_internal_vm_JcmdVThreadCommands();\n+  Klass* k = SystemDictionary::resolve_or_fail(sym, true, CHECK);\n+\n+  \/\/ invoke VThreadCommands.printPollers\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  JavaCalls::call_static(&result,\n+                         k,\n+                         vmSymbols::printPollers_name(),\n+                         vmSymbols::void_byte_array_signature(),\n+                         &args,\n+                         THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    java_lang_Throwable::print(PENDING_EXCEPTION, output());\n+    output()->cr();\n+    CLEAR_PENDING_EXCEPTION;\n+    return;\n+  }\n+\n+  \/\/ copy the bytes to the output stream\n+  oop res = cast_to_oop(result.get_jobject());\n+  typeArrayOop ba = typeArrayOop(res);\n+  jbyte* addr = typeArrayOop(res)->byte_at_addr(0);\n+  output()->print_raw((const char*)addr, ba->length());\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -939,0 +939,27 @@\n+class VThreadSchedulerDCmd : public DCmd {\n+public:\n+  VThreadSchedulerDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+  static const char* name() {\n+    return \"Thread.vthread_scheduler\";\n+  }\n+  static const char* description() {\n+    return \"Print the virtual thread scheduler, and the delayed task schedulers that support \"\n+           \"virtual threads doing timed operations.\";\n+  }\n+  static const char* impact() { return \"Low\"; }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+class VThreadPollersDCmd : public DCmd {\n+public:\n+  VThreadPollersDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+  static const char* name() {\n+    return \"Thread.vthread_pollers\";\n+  }\n+  static const char* description() {\n+    return \"Print the I\/O pollers that support virtual threads doing blocking network I\/O operations.\";\n+  }\n+  static const char* impact() { return \"Low\"; }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import java.util.concurrent.ScheduledExecutorService;\n@@ -2307,0 +2308,4 @@\n+            public Stream<ScheduledExecutorService> virtualThreadDelayedTaskSchedulers() {\n+                return VirtualThread.delayedTaskSchedulers();\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Arrays;\n@@ -35,1 +36,0 @@\n-import java.util.concurrent.ForkJoinWorkerThread;\n@@ -41,0 +41,1 @@\n+import java.util.stream.Stream;\n@@ -195,0 +196,7 @@\n+    \/**\n+     * Returns a stream of the delayed task schedulers used to support timed operations.\n+     *\/\n+    static Stream<ScheduledExecutorService> delayedTaskSchedulers() {\n+        return Arrays.stream(DELAYED_TASK_SCHEDULERS);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.concurrent.ScheduledExecutorService;\n@@ -598,0 +599,5 @@\n+    \/**\n+     * Returns a stream of the delayed task schedulers used for virtual threads.\n+     *\/\n+    Stream<ScheduledExecutorService> virtualThreadDelayedTaskSchedulers();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import sun.nio.ch.Poller;\n+\n+\/**\n+ * The implementation for the jcmd Thread.vthread_* diagnostic commands. These methods are\n+ * called from the \"Attach Listener\" thread.\n+ *\/\n+public class JcmdVThreadCommands {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    private JcmdVThreadCommands() { }\n+\n+    \/**\n+     * Invoked by the VM to print the virtual scheduler to a byte[].\n+     *\/\n+    private static byte[] printScheduler() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        \/\/ virtual thread scheduler\n+        sb.append(JLA.virtualThreadDefaultScheduler())\n+          .append(System.lineSeparator());\n+\n+        \/\/ break\n+        sb.append(System.lineSeparator());\n+\n+        \/\/ delayed task schedulers\n+        sb.append(\"Delayed task schedulers:\").append(System.lineSeparator());\n+        var delayedTaskSchedulers = JLA.virtualThreadDelayedTaskSchedulers().toList();\n+        IntStream.range(0, delayedTaskSchedulers.size())\n+                .forEach(i -> sb.append('[')\n+                                .append(i)\n+                                .append(\"] \")\n+                                .append(delayedTaskSchedulers.get(i))\n+                                .append(System.lineSeparator()));\n+\n+        return sb.toString().getBytes(StandardCharsets.UTF_8);\n+    }\n+\n+    \/**\n+     * Print information on threads registered for I\/O to a byte[].\n+     *\/\n+    private static byte[] printPollers() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        Poller masterPoller = Poller.masterPoller();\n+        List<Poller> readPollers = Poller.readPollers();\n+        List<Poller> writePollers = Poller.writePollers();\n+\n+        if (masterPoller != null) {\n+            sb.append(\"Master I\/O poller:\")\n+              .append(System.lineSeparator())\n+              .append(masterPoller)\n+              .append(System.lineSeparator());\n+\n+            \/\/ break\n+            sb.append(System.lineSeparator());\n+        }\n+\n+        sb.append(\"Read I\/O pollers:\");\n+        sb.append(System.lineSeparator());\n+        IntStream.range(0, readPollers.size())\n+                .forEach(i -> sb.append('[')\n+                                .append(i)\n+                                .append(\"] \")\n+                                .append(readPollers.get(i))\n+                                .append(System.lineSeparator()));\n+\n+        \/\/ break\n+        sb.append(System.lineSeparator());\n+\n+        sb.append(\"Write I\/O pollers:\");\n+        sb.append(System.lineSeparator());\n+        IntStream.range(0, writePollers.size())\n+                .forEach(i -> sb.append('[')\n+                                .append(i)\n+                                .append(\"] \")\n+                                .append(writePollers.get(i))\n+                                .append(System.lineSeparator()));\n+\n+        return sb.toString().getBytes(StandardCharsets.UTF_8);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/JcmdVThreadCommands.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -56,0 +57,3 @@\n+    \/\/ the poller or sub-poller thread\n+    private @Stable Thread owner;\n+\n@@ -241,0 +245,1 @@\n+        owner = Thread.currentThread();\n@@ -261,0 +266,1 @@\n+        owner = Thread.currentThread();\n@@ -285,1 +291,2 @@\n-        return Objects.toIdentityString(this) + \" [registered = \" + registered() + \"]\";\n+        return String.format(\"%s [registered = %d, owner = %s]\",\n+                Objects.toIdentityString(this), registered(), owner);\n@@ -445,0 +452,21 @@\n+\n+    \/**\n+     * Return the master poller or null if there is no master poller.\n+     *\/\n+    public static Poller masterPoller() {\n+        return POLLERS.masterPoller();\n+    }\n+\n+    \/**\n+     * Return the list of read pollers.\n+     *\/\n+    public static List<Poller> readPollers() {\n+        return POLLERS.readPollers();\n+    }\n+\n+    \/**\n+     * Return the list of write pollers.\n+     *\/\n+    public static List<Poller> writePollers() {\n+        return POLLERS.writePollers();\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Poller.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -740,0 +740,11 @@\n+`Thread.vthread_scheduler`\n+:   Print the virtual thread scheduler, and the delayed task schedulers that support\n+    virtual threads doing timed operations.\n+\n+    Impact: Low\n+\n+`Thread.vthread_pollers`\n+:   Print the I\/O pollers that support virtual threads doing blocking network I\/O operations.\n+\n+    Impact: Low\n+\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.md","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  jcmd.gc.heap_info jcmd.gc.class_histogram jcmd.gc.finalizer_info jcmd.thread.dump_to_file \\\n+  jcmd.gc.heap_info jcmd.gc.class_histogram jcmd.gc.finalizer_info jcmd.thread.dump_to_file jcmd.thread.vthread_scheduler \\\n@@ -64,0 +64,2 @@\n+jcmd.thread.vthread_scheduler.args=%p Thread.vthread_scheduler\n+\n","filename":"test\/failure_handler\/src\/share\/conf\/common.properties","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337199\n+ * @summary Basic test for jcmd Thread.vthread_scheduler and Thread.vthread_pollers\n+ * @requires vm.continuations\n+ * @modules jdk.jcmd\n+ * @library \/test\/lib\n+ * @run junit\/othervm VThreadCommandsTest\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.ForkJoinWorkerThread;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.lang.management.ManagementFactory;\n+import jdk.management.VirtualThreadSchedulerMXBean;\n+\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class VThreadCommandsTest {\n+\n+    \/**\n+     * Thread.vthread_scheduler\n+     *\/\n+    @Test\n+    void testVThreadScheduler() {\n+        \/\/ ensure default scheduler and timeout schedulers are initialized\n+        Thread.startVirtualThread(() -> { });\n+\n+        jcmd(\"Thread.vthread_scheduler\")\n+                .shouldContain(Objects.toIdentityString(defaultScheduler()))\n+                .shouldContain(\"Delayed task schedulers:\")\n+                .shouldContain(\"[0] \" + ScheduledThreadPoolExecutor.class.getName());\n+    }\n+\n+    \/**\n+     * Thread.vthread_pollers\n+     *\/\n+    @Test\n+    void testVThreadPollers() throws Exception {\n+        \/\/ do blocking I\/O op on a virtual thread to ensure poller mechanism is initialized\n+        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {\n+            executor.submit(() -> {\n+                try (var listener = new ServerSocket()) {\n+                    InetAddress lb = InetAddress.getLoopbackAddress();\n+                    listener.bind(new InetSocketAddress(lb, 0));\n+                    listener.setSoTimeout(200);\n+                    try (Socket s = listener.accept()) {\n+                        System.err.format(\"Connection from %s ??%n\", s.getRemoteSocketAddress());\n+                    } catch (SocketTimeoutException e) {\n+                        \/\/ expected\n+                    }\n+                }\n+                return null;\n+            }).get();\n+        }\n+\n+        jcmd(\"Thread.vthread_pollers\")\n+                .shouldContain(\"Read I\/O pollers:\")\n+                .shouldContain(\"Write I\/O pollers:\")\n+                .shouldMatch(\"^\\\\[0\\\\] sun\\\\.nio\\\\.ch\\\\..+ \\\\[registered = [\\\\d]+, owner = .+\\\\]$\");\n+    }\n+\n+    private OutputAnalyzer jcmd(String cmd) {\n+        return new PidJcmdExecutor().execute(cmd);\n+    }\n+\n+    \/**\n+     * Returns the virtual thread default scheduler. This implementation works by finding\n+     * all FJ worker threads and mapping them to their pool. VirtualThreadSchedulerMXBean\n+     * is used to temporarily changing target parallelism to an \"unique\" value, make it\n+     * possbile to find the right pool.\n+     *\/\n+    private ForkJoinPool defaultScheduler() {\n+        var done = new AtomicBoolean();\n+        Thread vthread = Thread.startVirtualThread(() -> {\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+        var bean = ManagementFactory.getPlatformMXBean(VirtualThreadSchedulerMXBean.class);\n+        int parallelism = bean.getParallelism();\n+        try {\n+            bean.setParallelism(133);\n+            return Thread.getAllStackTraces()\n+                    .keySet()\n+                    .stream()\n+                    .filter(ForkJoinWorkerThread.class::isInstance)\n+                    .map(t -> ((ForkJoinWorkerThread) t).getPool())\n+                    .filter(p -> p.getParallelism() == 133)\n+                    .findAny()\n+                    .orElseThrow();\n+        } finally {\n+            bean.setParallelism(parallelism);\n+            done.set(true);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/thread\/VThreadCommandsTest.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"}]}