{"files":[{"patch":"@@ -1078,7 +1078,0 @@\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  if (HAS_PENDING_EXCEPTION) {\n-    java_lang_Throwable::print(PENDING_EXCEPTION, output());\n-    output()->cr();\n-    CLEAR_PENDING_EXCEPTION;\n-    return;\n-  }\n@@ -1115,1 +1108,4 @@\n-void VThreadSchedulerDCmd::execute(DCmdSource source, TRAPS) {\n+\/\/ Calls a static no-arg method on jdk.internal.vm.JcmdVThreadCommands that returns a byte[] with\n+\/\/ the output. If the method completes successfully then the bytes are copied to the output stream.\n+\/\/ If the method fails then the exception is printed to the output stream.\n+static void execute_vthread_command(Symbol* method_name, outputStream* output, TRAPS) {\n@@ -1119,2 +1115,1 @@\n-  Symbol* sym = vmSymbols::jdk_internal_vm_JcmdVThreadCommands();\n-  Klass* k = SystemDictionary::resolve_or_fail(sym, true, CHECK);\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_internal_vm_JcmdVThreadCommands(), true, CHECK);\n@@ -1122,1 +1117,0 @@\n-  \/\/ invoke VThreadCommands.printScheduler\n@@ -1127,1 +1121,1 @@\n-                         vmSymbols::printScheduler_name(),\n+                         method_name,\n@@ -1132,2 +1126,2 @@\n-    java_lang_Throwable::print(PENDING_EXCEPTION, output());\n-    output()->cr();\n+    java_lang_Throwable::print(PENDING_EXCEPTION, output);\n+    output->cr();\n@@ -1142,1 +1136,1 @@\n-  output()->print_raw((const char*)addr, ba->length());\n+  output->print_raw((const char*)addr, ba->length());\n@@ -1145,22 +1139,3 @@\n-void VThreadPollersDCmd::execute(DCmdSource source, TRAPS) {\n-  ResourceMark rm(THREAD);\n-  HandleMark hm(THREAD);\n-\n-  Symbol* sym = vmSymbols::jdk_internal_vm_JcmdVThreadCommands();\n-  Klass* k = SystemDictionary::resolve_or_fail(sym, true, CHECK);\n-\n-  \/\/ invoke VThreadCommands.printPollers\n-  JavaValue result(T_OBJECT);\n-  JavaCallArguments args;\n-  JavaCalls::call_static(&result,\n-                         k,\n-                         vmSymbols::printPollers_name(),\n-                         vmSymbols::void_byte_array_signature(),\n-                         &args,\n-                         THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    java_lang_Throwable::print(PENDING_EXCEPTION, output());\n-    output()->cr();\n-    CLEAR_PENDING_EXCEPTION;\n-    return;\n-  }\n+void VThreadSchedulerDCmd::execute(DCmdSource source, TRAPS) {\n+  execute_vthread_command(vmSymbols::printScheduler_name(), output(), CHECK);\n+}\n@@ -1168,5 +1143,2 @@\n-  \/\/ copy the bytes to the output stream\n-  oop res = cast_to_oop(result.get_jobject());\n-  typeArrayOop ba = typeArrayOop(res);\n-  jbyte* addr = typeArrayOop(res)->byte_at_addr(0);\n-  output()->print_raw((const char*)addr, ba->length());\n+void VThreadPollersDCmd::execute(DCmdSource source, TRAPS) {\n+  execute_vthread_command(vmSymbols::printPollers_name(), output(), CHECK);\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":14,"deletions":42,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-     * Print information on threads registered for I\/O to a byte[].\n+     * Invoked by the VM to print the I\/O pollers to a byte[].\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/JcmdVThreadCommands.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}