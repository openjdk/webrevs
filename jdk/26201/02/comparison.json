{"files":[{"patch":"@@ -69,0 +69,3 @@\n+     * @throws IllegalArgumentException if {@code major} is not in the range\n+     * {@code [0, 65535]}, or the {@code minor} is not in the range {@code [-1,\n+     * 65535]}\n@@ -80,0 +83,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not in the range\n+     * {@code [0, 0xFFFF]}\n@@ -191,0 +196,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not in the range\n+     * {@code [0, 0xFFFF]}\n@@ -224,0 +231,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not in the range\n+     * {@code [0, 0xFFFF]}\n@@ -263,0 +272,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not in the\n+     * range {@code [0, 0xFFFF]}\n@@ -287,0 +298,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not in the\n+     * range {@code [0, 0xFFFF]}\n@@ -307,0 +320,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not in the\n+     * range {@code [0, 0xFFFF]}\n@@ -336,0 +351,2 @@\n+     * @throws IllegalArgumentException if {@code methodFlags} is not in the\n+     * range {@code [0, 0xFFFF]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassBuilder.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -80,1 +80,3 @@\n-     * {@return a {@link ClassFileVersion} element}\n+     * {@return a {@link ClassFileVersion} element}  The minor version number\n+     * may be {@code -1} to represent {@value ClassFile#PREVIEW_MINOR_VERSION}.\n+     *\n@@ -83,0 +85,3 @@\n+     * @throws IllegalArgumentException if the major version is not in the range\n+     * {@code [0, 65535]}, or the minor version is not in the range {@code [-1,\n+     * 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassFileVersion.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -795,0 +795,2 @@\n+     * @throws IllegalArgumentException if {@code line} is not in the range\n+     * {@code [0, 65535]}\n@@ -891,0 +893,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not in the range\n+     * {@code [0, 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not in the range\n+     * {@code [0, 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/FieldBuilder.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,2 @@\n-     * @throws IllegalArgumentException if the {@link ClassFile#ACC_STATIC\n+     * @throws IllegalArgumentException if {@code flags} is not in the range\n+     *         {@code [0, 65535]}, or the {@link ClassFile#ACC_STATIC\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.classfile.impl.Util;\n@@ -355,0 +356,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} is not\n+         * in the range {@code [0, 255]}\n@@ -363,0 +366,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} is not\n+         * in the range {@code [0, 255]}\n@@ -371,0 +376,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} is not\n+         * in the range {@code [0, 255]}\n@@ -379,0 +386,2 @@\n+         * @throws IllegalArgumentException if {@code supertypeIndex} is not\n+         * in the range {@code [0, 65535]}\n@@ -390,0 +399,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} or\n+         * {@code boundIndex} is not in the range {@code [0, 255]}\n@@ -400,0 +411,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} or\n+         * {@code boundIndex} is not in the range {@code [0, 255]}\n@@ -410,0 +423,2 @@\n+         * @throws IllegalArgumentException if {@code typeParameterIndex} or\n+         * {@code boundIndex} is not in the range {@code [0, 255]}\n@@ -451,0 +466,2 @@\n+         * @throws IllegalArgumentException if {@code formalParameterIndex} is\n+         * not in the range {@code [0, 255]}\n@@ -460,0 +477,2 @@\n+         * @throws IllegalArgumentException if {@code throwsTargetIndex} is\n+         * not in the range {@code [0, 65535]}\n@@ -495,0 +514,2 @@\n+         * @throws IllegalArgumentException if {@code exceptionTableIndex} is not\n+         * in the range {@code [0, 65535]}\n@@ -555,0 +576,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         * in the range {@code [0, 255]}\n@@ -564,0 +587,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         * in the range {@code [0, 255]}\n@@ -574,0 +599,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         * in the range {@code [0, 255]}\n@@ -584,0 +611,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         * in the range {@code [0, 255]}\n@@ -594,0 +623,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         * in the range {@code [0, 255]}\n@@ -604,0 +635,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         * in the range {@code [0, 255]}\n@@ -795,0 +828,1 @@\n+         * @throws IllegalArgumentException if {@code index} is out of bounds\n@@ -962,0 +996,2 @@\n+         * @throws IllegalArgumentException if {@code typeArgumentIndex} is not\n+         * in the range {@code [0, 255]}\n@@ -964,1 +1000,1 @@\n-\n+            Util.checkU1(typeArgumentIndex, \"type argument index\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeAnnotation.java","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.classfile.impl.Util;\n@@ -169,0 +170,2 @@\n+     * @throws IllegalArgumentException if {@code startPc}, {@code endPc}, or\n+     * {@code flags} is not in the range {@code [0, 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CharacterRangeInfo.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,0 +107,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not in the range\n+     * {@code [0, 65535]}\n@@ -119,1 +121,2 @@\n-     * @throws IllegalArgumentException if {@code innerClass} or {@code outerClass} represents a primitive type\n+     * @throws IllegalArgumentException if {@code innerClass} or {@code outerClass}\n+     * represents a primitive type, or if {@code flags} is not in the range {@code [0, 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassInfo.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+     * @throws IllegalArgumentException if {@code startPc} or {@code lineNumber}\n+     * is not in the range {@code [0, 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LineNumberInfo.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not in the range\n+     * {@code [0, 65535]}\n@@ -108,0 +110,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not in the range\n+     * {@code [0, 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/MethodParameterInfo.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -173,0 +173,2 @@\n+     * @throws IllegalArgumentException if {@code moduleFlags} is not in the\n+     * range {@code [0, 65535]}\n@@ -233,0 +235,2 @@\n+         * @throws IllegalArgumentException if {@code flagsMask} is not in the\n+         * range {@code [0, 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleAttribute.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,0 +106,2 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not in the\n+     * range {@code [0, 65535]}\n@@ -134,0 +136,2 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not in the\n+     * range {@code [0, 65535]}\n@@ -164,0 +168,2 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not in the\n+     * range {@code [0, 65535]}\n@@ -194,0 +200,2 @@\n+     * @throws IllegalArgumentException if {@code exportFlags} is not in the\n+     * range {@code [0, 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleExportInfo.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -112,0 +112,2 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not in the\n+     * range {@code [0, 65535]}\n@@ -140,0 +142,2 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not in the\n+     * range {@code [0, 65535]}\n@@ -169,0 +173,2 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not in the\n+     * range {@code [0, 65535]}\n@@ -197,0 +203,2 @@\n+     * @throws IllegalArgumentException if {@code opensFlags} is not in the\n+     * range {@code [0, 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleOpenInfo.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+     * @throws IllegalArgumentException if {@code requiresFlags} is not in the\n+     * range {@code [0, 65535]}\n@@ -124,0 +126,2 @@\n+     * @throws IllegalArgumentException if {@code requiresFlags} is not in the\n+     * range {@code [0, 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleRequireInfo.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+     * @throws IllegalArgumentException if {@code resolutionFlags} is not in the\n+     * range {@code [0, 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleResolutionAttribute.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -406,0 +406,2 @@\n+     * @throws IllegalArgumentException if {@code refKind} is not in the range\n+     * {@code [0, 255]}; note that only {@code [1, 9]} are defined\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,0 +152,2 @@\n+     * @throws IllegalArgumentException if {@code flags} is not in the range\n+     * {@code [0, 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/CharacterRange.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+     * @throws IllegalArgumentException if {@code line} is not in the range\n+     * {@code [0, 65535]}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/LineNumber.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-            this.flags = flags;\n+            this.flags = Util.checkU2(flags, \"character range flags\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPseudoInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    public  AccessFlagsImpl(AccessFlag.Location location, AccessFlag... flags) {\n+    public AccessFlagsImpl(AccessFlag.Location location, AccessFlag... flags) {\n@@ -46,1 +46,1 @@\n-        this.flagsMask = mask;\n+        this.flagsMask = Util.checkFlags(mask);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AccessFlagsImpl.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import static java.lang.classfile.ClassFile.PREVIEW_MINOR_VERSION;\n+\n@@ -35,2 +37,3 @@\n-        this.majorVersion = majorVersion;\n-        this.minorVersion = minorVersion;\n+        this.majorVersion = Util.checkU2(majorVersion, \"major version\");\n+        this.minorVersion = minorVersion == -1 ? PREVIEW_MINOR_VERSION\n+                : Util.checkU2(minorVersion, \"minor version\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileVersionImpl.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        this.flags = flags;\n+        this.flags = Util.checkFlags(flags);\n@@ -74,1 +74,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectFieldBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        this.flags = flags;\n+        this.flags = Util.checkFlags(flags);\n@@ -59,1 +59,1 @@\n-        setFlags(flags);\n+        setFlags(Util.checkFlags(flags));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectMethodBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        return (line < INTERN_LIMIT)\n+        return (Util.checkU2(line, \"line number\") < INTERN_LIMIT)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/LineNumberImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-        this.moduleFlags = flags;\n+        this.moduleFlags = Util.checkFlags(flags);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ModuleAttributeBuilderImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -597,0 +597,1 @@\n+        Util.checkU1(refKind, \"reference kind\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,3 +47,3 @@\n-        public TypeParameterTargetImpl(TargetType targetType, int typeParameterIndex) {\n-            this.targetType = checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER, TARGET_METHOD_TYPE_PARAMETER);\n-            this.typeParameterIndex = typeParameterIndex;\n+        public TypeParameterTargetImpl {\n+            checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER, TARGET_METHOD_TYPE_PARAMETER);\n+            Util.checkU1(typeParameterIndex, \"type parameter index\");\n@@ -54,0 +54,5 @@\n+\n+        public SupertypeTargetImpl {\n+            Util.checkU2(supertypeIndex, \"supertype index\");\n+        }\n+\n@@ -63,4 +68,4 @@\n-        public TypeParameterBoundTargetImpl(TargetType targetType, int typeParameterIndex, int boundIndex) {\n-            this.targetType = checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER_BOUND, TARGET_METHOD_TYPE_PARAMETER_BOUND);\n-            this.typeParameterIndex = typeParameterIndex;\n-            this.boundIndex = boundIndex;\n+        public TypeParameterBoundTargetImpl {\n+            checkValid(targetType, TARGET_CLASS_TYPE_PARAMETER_BOUND, TARGET_METHOD_TYPE_PARAMETER_BOUND);\n+            Util.checkU1(typeParameterIndex, \"type parameter index\");\n+            Util.checkU1(boundIndex, \"bound index\");\n@@ -78,0 +83,5 @@\n+\n+        public FormalParameterTargetImpl {\n+            Util.checkU1(formalParameterIndex, \"formal parameter index\");\n+        }\n+\n@@ -85,0 +95,5 @@\n+\n+        public ThrowsTargetImpl {\n+            Util.checkU2(throwsTargetIndex, \"throws type index\");\n+        }\n+\n@@ -110,0 +125,1 @@\n+            BytecodeHelpers.validateSlot(index);\n@@ -114,0 +130,5 @@\n+\n+        public CatchTargetImpl {\n+            Util.checkU2(exceptionTableIndex, \"exception table index\");\n+        }\n+\n@@ -131,4 +152,4 @@\n-        public TypeArgumentTargetImpl(TargetType targetType, Label target, int typeArgumentIndex) {\n-            this.targetType = checkValid(targetType, TARGET_CAST, TARGET_METHOD_REFERENCE_TYPE_ARGUMENT);\n-            this.target = requireNonNull(target);\n-            this.typeArgumentIndex = typeArgumentIndex;\n+        public TypeArgumentTargetImpl {\n+            checkValid(targetType, TARGET_CAST, TARGET_METHOD_REFERENCE_TYPE_ARGUMENT);\n+            requireNonNull(target);\n+            Util.checkU1(typeArgumentIndex, \"type argument index\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/TargetInfoImpl.java","additions":33,"deletions":12,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,1 +477,1 @@\n-            resolutionFlags = flags;\n+            resolutionFlags = Util.checkU2(flags, \"resolution flags\");\n@@ -891,1 +891,8 @@\n-            implements CharacterRangeInfo { }\n+            implements CharacterRangeInfo {\n+\n+        public UnboundCharacterRangeInfo {\n+            Util.checkU2(startPc, \"start pc\");\n+            Util.checkU2(endPc, \"end pc\");\n+            Util.checkU2(flags, \"flags\");\n+        }\n+    }\n@@ -902,0 +909,1 @@\n+            Util.checkFlags(flagsMask);\n@@ -906,1 +914,6 @@\n-            implements LineNumberInfo { }\n+            implements LineNumberInfo {\n+        public UnboundLineNumberInfo {\n+            Util.checkU2(startPc, \"start pc\");\n+            Util.checkU2(lineNumber, \"line number\");\n+        }\n+    }\n@@ -934,0 +947,1 @@\n+            Util.checkFlags(flagsMask);\n@@ -943,0 +957,1 @@\n+            Util.checkFlags(exportsFlagsMask);\n@@ -960,0 +975,1 @@\n+            Util.checkFlags(opensFlagsMask);\n@@ -978,0 +994,1 @@\n+            Util.checkFlags(requiresFlagsMask);\n@@ -1031,1 +1048,1 @@\n-            this.moduleFlags = moduleFlags;\n+            this.moduleFlags = Util.checkFlags(moduleFlags);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-public class Util {\n+public final class Util {\n@@ -189,0 +189,25 @@\n+    \/\/\/ Ensures the given value won't be truncated when written as a u1\n+    public static int checkU1(int incoming, String valueName) {\n+        if ((incoming & ~0xFF) != 0) {\n+            throw outOfRangeException(incoming, valueName, \"u1\");\n+        }\n+        return incoming;\n+    }\n+\n+    \/\/\/ Ensures the given value won't be truncated when written as a u2\n+    public static char checkU2(int incoming, String valueName) {\n+        if ((incoming & ~0xFFFF) != 0)\n+            throw outOfRangeException(incoming, valueName, \"u2\");\n+        return (char) incoming;\n+    }\n+\n+    public static IllegalArgumentException outOfRangeException(int value, String fieldName, String typeName) {\n+        return new IllegalArgumentException(\n+                String.format(\"%s out of range of %d: %d\", fieldName, typeName, value));\n+    }\n+\n+    \/\/\/ Ensures the given mask won't be truncated when written as an access flag\n+    public static char checkFlags(int mask) {\n+        return checkU2(mask, \"access flags\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,2 @@\n- * @bug 8341277 8361102\n- * @summary Testing ClassFile instruction argument validation.\n+ * @bug 8341277 8361102 8361182 8361614\n+ * @summary Testing ClassFile (pseudo-)instruction argument validation.\n@@ -32,0 +32,2 @@\n+import java.lang.classfile.attribute.CharacterRangeInfo;\n+import java.lang.classfile.attribute.LineNumberInfo;\n@@ -281,0 +283,58 @@\n+\n+    @Test\n+    void testCharacterRange() {\n+        assertDoesNotThrow(() -> CharacterRangeInfo.of(0, 0, -234, 59494648, 0));\n+        assertDoesNotThrow(() -> CharacterRangeInfo.of(0, 0, -234, 59494648, 65535));\n+        assertThrows(IllegalArgumentException.class, () -> CharacterRangeInfo.of(0, 0, -234, 59494648, -1));\n+        assertThrows(IllegalArgumentException.class, () -> CharacterRangeInfo.of(0, 0, -234, 59494648, 65536));\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            var dummyLabel = cob.startLabel();\n+            assertDoesNotThrow(() -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, 0));\n+            assertDoesNotThrow(() -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, 65535));\n+            assertThrows(IllegalArgumentException.class, () -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, -1));\n+            assertThrows(IllegalArgumentException.class, () -> CharacterRange.of(dummyLabel, dummyLabel, -234, 59494648, 65536));\n+            assertThrows(IllegalArgumentException.class, () -> cob.characterRange(dummyLabel, dummyLabel, -234, 59494648, -1));\n+            assertThrows(IllegalArgumentException.class, () -> cob.characterRange(dummyLabel, dummyLabel, -234, 59494648, 65536));\n+            cob.return_();\n+        }));\n+    }\n+\n+    @Test\n+    void testLineNumber() {\n+        assertDoesNotThrow(() -> LineNumberInfo.of(0, 25));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumberInfo.of(0, -1));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumberInfo.of(0, 65536));\n+        assertDoesNotThrow(() -> LineNumber.of(25));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumber.of(-1));\n+        assertThrows(IllegalArgumentException.class, () -> LineNumber.of(65536));\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            assertThrows(IllegalArgumentException.class, () -> cob.lineNumber(-1));\n+            assertThrows(IllegalArgumentException.class, () -> cob.lineNumber(65536));\n+            cob.return_();\n+        }));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationLocalVarTargetInfo() {\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            var label = cob.startLabel();\n+            assertDoesNotThrow(() -> TypeAnnotation.LocalVarTargetInfo.of(label, label, 256));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.LocalVarTargetInfo.of(label, label, -1));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.LocalVarTargetInfo.of(label, label, 65536));\n+            cob.return_();\n+        }));\n+    }\n+\n+    @Test\n+    void testTypeAnnotationTypeArgumentTarget() {\n+        ClassFile.of().build(CD_Object, clb -> clb.withMethodBody(\"test\", MTD_void, 0, cob -> {\n+            var label = cob.startLabel();\n+            assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofTypeArgument(TypeAnnotation.TargetType.CAST, label, 0));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofCastExpr(label, -1));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodInvocationTypeArgument(label, Integer.MIN_VALUE));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodReferenceTypeArgument(label, 256));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofConstructorInvocationTypeArgument(label, 300));\n+            assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofConstructorReferenceTypeArgument(label, -2));\n+            cob.return_();\n+        }));\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/InstructionValidationTest.java","additions":63,"deletions":3,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-import java.lang.classfile.ClassFile;\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.constant.ClassDesc;\n-\n-import static java.lang.constant.ConstantDescs.*;\n-import static java.lang.classfile.ClassFile.*;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-\/*\n- * @test\n- * @bug 8311172\n- * @run junit PreviewMinorVersionTest\n- * @summary Ensures ClassFile.PREVIEW_MINOR_VERSION equals that of classes with\n- *          preview minor version from ClassModel::minorVersion\n- *\/\n-public class PreviewMinorVersionTest {\n-\n-    @Test\n-    public void testMinorVersionMatches() {\n-        \/\/ compile a class with --enable-preview\n-        \/\/ uses Record feature to trigger forcePreview\n-        var cf = ClassFile.of();\n-        var cd = ClassDesc.of(\"Test\");\n-        var bytes = cf.build(cd, cb -> cb\n-                .withSuperclass(CD_Object)\n-                \/\/ old preview minor version,\n-                \/\/ with all bits set to 1\n-                .withVersion(JAVA_17_VERSION, -1)\n-        );\n-\n-        var cm = ClassFile.of().parse(bytes);\n-        assertEquals(ClassFile.PREVIEW_MINOR_VERSION, cm.minorVersion());\n-    }\n-}\n","filename":"test\/jdk\/jdk\/classfile\/PreviewMinorVersionTest.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -0,0 +1,201 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassFileVersion;\n+import java.lang.classfile.TypeAnnotation;\n+import java.lang.classfile.attribute.InnerClassInfo;\n+import java.lang.classfile.attribute.MethodParameterInfo;\n+import java.lang.classfile.attribute.ModuleAttribute;\n+import java.lang.classfile.attribute.ModuleExportInfo;\n+import java.lang.classfile.attribute.ModuleOpenInfo;\n+import java.lang.classfile.attribute.ModuleRequireInfo;\n+import java.lang.classfile.attribute.ModuleResolutionAttribute;\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ModuleDesc;\n+import java.lang.constant.PackageDesc;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.ACC_STATIC;\n+import static java.lang.classfile.ClassFile.JAVA_17_VERSION;\n+import static java.lang.constant.ConstantDescs.*;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8311172 8361614\n+ * @summary Testing ClassFile validation of non-instruction subint (u1, u2) arguments.\n+ * @run junit SubIntValidationTest\n+ *\/\n+class SubIntValidationTest {\n+\n+    @Test\n+    public void testBuilderFlags() {\n+        ClassFile.of().build(CD_Void, clb -> {\n+            assertThrows(IllegalArgumentException.class, () -> clb.withFlags(-1));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withFlags(70000));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withField(\"test\", CD_String, -1));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withField(\"test\", CD_String, 70000));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withMethod(\"test\", MTD_void, -1, _ -> {}));\n+            assertThrows(IllegalArgumentException.class, () -> clb.withMethod(\"test\", MTD_void, 70000, _ -> {}));\n+            clb.withField(\"test\", CD_String, fb -> {\n+                assertThrows(IllegalArgumentException.class, () -> fb.withFlags(-1));\n+                assertThrows(IllegalArgumentException.class, () -> fb.withFlags(70000 | ACC_STATIC));\n+            });\n+            clb.withMethod(\"test\", MTD_void, ACC_STATIC, mb -> {\n+                assertThrows(IllegalArgumentException.class, () -> mb.withFlags(-1));\n+                assertThrows(IllegalArgumentException.class, () -> mb.withFlags(70000 | ACC_STATIC));\n+            });\n+        });\n+    }\n+\n+    @Test\n+    public void testClassFileVersion() {\n+        \/\/ Prohibited but representable major\/minor\n+        assertDoesNotThrow(() -> ClassFileVersion.of(0, 0));\n+        \/\/ Non-representable major\/minor\n+        assertDoesNotThrow(() -> ClassFileVersion.of(JAVA_17_VERSION, 42));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(-1, 0));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(65536, 0));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(0, -2));\n+        assertThrows(IllegalArgumentException.class, () -> ClassFileVersion.of(0, 65536));\n+        ClassFile.of().build(CD_Void, clb -> assertThrows(IllegalArgumentException.class, () -> clb.withVersion(-1, 0)));\n+        \/\/ Special rule without serializing to class file format\n+        assertEquals(ClassFile.PREVIEW_MINOR_VERSION, ClassFileVersion.of(0, -1).minorVersion());\n+    }\n+\n+    @Test\n+    public void testReadMinorVersion() {\n+        var cf = ClassFile.of();\n+        var cd = ClassDesc.of(\"Test\");\n+        var bytes = cf.build(cd, cb -> cb\n+                .withSuperclass(CD_Object)\n+                \/\/ old preview minor version,\n+                \/\/ with all bits set to 1\n+                .withVersion(JAVA_17_VERSION, -1)\n+        );\n+\n+        var cm = ClassFile.of().parse(bytes);\n+        assertEquals(ClassFile.PREVIEW_MINOR_VERSION, cm.minorVersion());\n+    }\n+\n+    \/\/ LocalVarTargetInfo\/TypeArgumentTarget in InstructionValidationTest for Label\n+    @Test\n+    public void testTypeAnnotations() {\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofTypeParameter(TypeAnnotation.TargetType.CLASS_TYPE_PARAMETER, 0));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassTypeParameter(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodTypeParameter(300));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofClassExtends(65535));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassExtends(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassExtends(65536));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofClassTypeParameterBound(255, 255));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofClassTypeParameterBound(-1, 255));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodTypeParameterBound(0, 256));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofMethodFormalParameter(0));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodFormalParameter(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofMethodFormalParameter(256));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofThrows(256));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofThrows(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofThrows(65536));\n+        assertDoesNotThrow(() -> TypeAnnotation.TargetInfo.ofExceptionParameter(256));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofExceptionParameter(-1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TargetInfo.ofExceptionParameter(65536));\n+        assertDoesNotThrow(() -> TypeAnnotation.TypePathComponent.of(TypeAnnotation.TypePathComponent.Kind.ARRAY, 2));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TypePathComponent.of(TypeAnnotation.TypePathComponent.Kind.INNER_TYPE, -1));\n+        assertThrows(IllegalArgumentException.class, () -> TypeAnnotation.TypePathComponent.of(TypeAnnotation.TypePathComponent.Kind.TYPE_ARGUMENT, 256));\n+    }\n+\n+    @Test\n+    public void testInnerClasses() {\n+        assertDoesNotThrow(() -> InnerClassInfo.of(CD_Object, Optional.empty(), Optional.empty(), 65535));\n+        assertThrows(IllegalArgumentException.class, () -> InnerClassInfo.of(CD_Object, Optional.empty(), Optional.empty(), -1));\n+        assertThrows(IllegalArgumentException.class, () -> InnerClassInfo.of(ConstantPoolBuilder.of().classEntry(CD_String),\n+                Optional.empty(), Optional.empty(), 65536));\n+    }\n+\n+    @Test\n+    public void testMethodParameter() {\n+        assertDoesNotThrow(() -> MethodParameterInfo.of(Optional.empty(), 65535));\n+        assertThrows(IllegalArgumentException.class, () -> MethodParameterInfo.of(Optional.empty(), -1));\n+        assertThrows(IllegalArgumentException.class, () -> MethodParameterInfo.ofParameter(Optional.empty(), 65536));\n+    }\n+\n+    @Test\n+    public void testModule() {\n+        assertDoesNotThrow(() -> ModuleAttribute.of(ConstantPoolBuilder.of().moduleEntry(ModuleDesc.of(\"java.base\")),\n+                65535, null, List.of(), List.of(), List.of(), List.of(), List.of()));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(ConstantPoolBuilder.of().moduleEntry(ModuleDesc.of(\"java.base\")),\n+                -1, null, List.of(), List.of(), List.of(), List.of(), List.of()));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleAttribute.of(ConstantPoolBuilder.of().moduleEntry(ModuleDesc.of(\"java.base\")),\n+                65536, null, List.of(), List.of(), List.of(), List.of(), List.of()));\n+        ModuleAttribute.of(ModuleDesc.of(\"java.base\"), b -> {\n+            assertThrows(IllegalArgumentException.class, () -> b.moduleFlags(-1));\n+            assertThrows(IllegalArgumentException.class, () -> b.moduleFlags(65536));\n+            b.moduleFlags(0);\n+        });\n+    }\n+\n+    @Test\n+    public void testModuleExport() {\n+        assertDoesNotThrow(() -> ModuleExportInfo.of(PackageDesc.of(\"java.lang\"), 0));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleExportInfo.of(PackageDesc.of(\"java.lang\"), -1));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleExportInfo.of(PackageDesc.of(\"java.lang\"), 65536));\n+    }\n+\n+    @Test\n+    public void testModuleOpen() {\n+        assertDoesNotThrow(() -> ModuleOpenInfo.of(PackageDesc.of(\"java.lang\"), 0));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleOpenInfo.of(PackageDesc.of(\"java.lang\"), -1));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleOpenInfo.of(PackageDesc.of(\"java.lang\"), 65536));\n+    }\n+\n+    @Test\n+    public void testModuleRequire() {\n+        assertDoesNotThrow(() -> ModuleRequireInfo.of(ModuleDesc.of(\"java.base\"), 0, null));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleRequireInfo.of(ModuleDesc.of(\"java.base\"), -1, null));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleRequireInfo.of(ModuleDesc.of(\"java.base\"), 65536, null));\n+    }\n+\n+    @Test\n+    public void testModuleResolution() {\n+        assertDoesNotThrow(() -> ModuleResolutionAttribute.of(256));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleResolutionAttribute.of(-1));\n+        assertThrows(IllegalArgumentException.class, () -> ModuleResolutionAttribute.of(65536));\n+    }\n+\n+    @Test\n+    public void testMethodHandleEntry() {\n+        ConstantPoolBuilder cp = ConstantPoolBuilder.of();\n+        var ref = cp.fieldRefEntry(CD_String, \"a\", CD_int);\n+        \/\/ Intentionally choose an invalid but representable refKind\n+        assertDoesNotThrow(() -> cp.methodHandleEntry(25, ref));\n+        assertThrows(IllegalArgumentException.class, () -> cp.methodHandleEntry(256, ref));\n+        assertThrows(IllegalArgumentException.class, () -> cp.methodHandleEntry(-1, ref));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/SubIntValidationTest.java","additions":201,"deletions":0,"binary":false,"changes":201,"status":"added"}]}