{"files":[{"patch":"@@ -307,0 +307,4 @@\n+    private static final String REQUIRES_IDENTITY_ANNOTATION =\n+            \"Ljdk\/internal\/RequieresIdentity;\";\n+    private static final String REQUIRES_IDENTITY_ANNOTATION_INTERNAL =\n+            \"Ljdk\/internal\/RequiresIdentity+Annotation;\";\n@@ -313,1 +317,2 @@\n-                    RESTRICTED_ANNOTATION));\n+                    RESTRICTED_ANNOTATION,\n+                    REQUIRES_IDENTITY_ANNOTATION));\n@@ -1024,0 +1029,6 @@\n+        if (REQUIRES_IDENTITY_ANNOTATION.equals(annotationType)) {\n+            \/\/the non-public RequiresIdentity annotation will not be available in ct.sym,\n+            \/\/replace with purely synthetic javac-internal annotation:\n+            annotationType = REQUIRES_IDENTITY_ANNOTATION_INTERNAL;\n+        }\n+\n@@ -2205,0 +2216,1 @@\n+            case RuntimeVisibleTypeAnnotationsAttribute a -> {\/* do nothing for now *\/}\n","filename":"make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-    public Cleanable register(Object obj, Runnable action) {\n+    public Cleanable register(@jdk.internal.RequiresIdentity Object obj, Runnable action) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-public non-sealed class PhantomReference<T> extends Reference<T> {\n+public non-sealed class PhantomReference<@jdk.internal.RequiresIdentity T> extends Reference<T> {\n@@ -104,1 +104,1 @@\n-    public PhantomReference(T referent, ReferenceQueue<? super T> q) {\n+    public PhantomReference(@jdk.internal.RequiresIdentity T referent, ReferenceQueue<? super T> q) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-public abstract sealed class Reference<T>\n+public abstract sealed class Reference<@jdk.internal.RequiresIdentity T>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-public class ReferenceQueue<T> {\n+public class ReferenceQueue<@jdk.internal.RequiresIdentity T> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-public non-sealed class SoftReference<T> extends Reference<T> {\n+public non-sealed class SoftReference<@jdk.internal.RequiresIdentity T> extends Reference<T> {\n@@ -85,1 +85,1 @@\n-    public SoftReference(T referent) {\n+    public SoftReference(@jdk.internal.RequiresIdentity T referent) {\n@@ -99,1 +99,1 @@\n-    public SoftReference(T referent, ReferenceQueue<? super T> q) {\n+    public SoftReference(@jdk.internal.RequiresIdentity T referent, ReferenceQueue<? super T> q) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/SoftReference.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-public non-sealed class WeakReference<T> extends Reference<T> {\n+public non-sealed class WeakReference<@jdk.internal.RequiresIdentity T> extends Reference<T> {\n@@ -57,1 +57,1 @@\n-    public WeakReference(T referent) {\n+    public WeakReference(@jdk.internal.RequiresIdentity T referent) {\n@@ -69,1 +69,1 @@\n-    public WeakReference(T referent, ReferenceQueue<? super T> q) {\n+    public WeakReference(@jdk.internal.RequiresIdentity T referent, ReferenceQueue<? super T> q) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/WeakReference.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-public class WeakHashMap<K,V>\n+public class WeakHashMap<@jdk.internal.RequiresIdentity K,V>\n@@ -460,1 +460,1 @@\n-    public V put(K key, V value) {\n+    public V put(@jdk.internal.RequiresIdentity K key, V value) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/WeakHashMap.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import static java.lang.annotation.ElementType.PARAMETER;\n+import static java.lang.annotation.ElementType.TYPE_PARAMETER;\n+\n+\/**\n+ * Indicates that the annotated parameter or type parameter is not expected to be a\n+ * Value Based class.\n+ * Using a parameter or type parameter of a <a href=\"..\/lang\/doc-files\/ValueBased.html\">value-based classes<\/a>\n+ * should produce warnings about behavior that is inconsistent with identity based semantics.\n+ *\n+ * Note this internal annotation is handled specially by the javac compiler.\n+ * To work properly with {@code --release older-release}, it requires special\n+ * handling in {@code make\/langtools\/src\/classes\/build\/tools\/symbolgenerator\/CreateSymbols.java}\n+ * and {@code src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java}.\n+ *\n+ * @since 25\n+ *\/\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target(value={PARAMETER, TYPE_PARAMETER})\n+public @interface RequiresIdentity {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/RequiresIdentity.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -49,1 +49,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ValueBased.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.ArrayList;\n@@ -29,0 +30,1 @@\n+import java.util.Collections;\n@@ -30,0 +32,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.List;\n@@ -32,1 +36,1 @@\n-import java.util.concurrent.ConcurrentHashMap;\n+import java.util.Set;\n@@ -122,1 +126,1 @@\n-    private static final Map<String, LintCategory> map = new ConcurrentHashMap<>(20);\n+    private static final Map<String, LintCategory> map = new LinkedHashMap<>(40);\n@@ -152,1 +156,1 @@\n-        if (options.isSet(Option.XLINT) || options.isSet(Option.XLINT_CUSTOM, \"all\")) {\n+        if (options.isSet(Option.XLINT) || options.isSet(Option.XLINT_CUSTOM, Option.LINT_CUSTOM_ALL)) {\n@@ -155,1 +159,1 @@\n-        } else if (options.isSet(Option.XLINT_CUSTOM, \"none\")) {\n+        } else if (options.isSet(Option.XLINT_CUSTOM, Option.LINT_CUSTOM_NONE)) {\n@@ -176,1 +180,1 @@\n-            values.add(LintCategory.SYNCHRONIZATION);\n+            values.add(LintCategory.IDENTITY);\n@@ -182,1 +186,1 @@\n-            if (options.isSet(Option.XLINT_CUSTOM, lc.option)) {\n+            if (options.isExplicitlyEnabled(Option.XLINT, lc)) {\n@@ -184,1 +188,1 @@\n-            } else if (options.isSet(Option.XLINT_CUSTOM, \"-\" + lc.option)) {\n+            } else if (options.isExplicitlyDisabled(Option.XLINT, lc)) {\n@@ -264,0 +268,5 @@\n+        \/**\n+         * Warn about uses of @ValueBased classes where an identity class is expected.\n+         *\/\n+        IDENTITY(\"identity\", true, \"synchronization\"),\n+\n@@ -366,5 +375,0 @@\n-        \/**\n-         * Warn about synchronization attempts on instances of @ValueBased classes.\n-         *\/\n-        SYNCHRONIZATION(\"synchronization\"),\n-\n@@ -413,1 +417,1 @@\n-        LintCategory(String option, boolean annotationSuppression) {\n+        LintCategory(String option, boolean annotationSuppression, String... aliases) {\n@@ -416,1 +420,5 @@\n-            map.put(option, this);\n+            ArrayList<String> optionList = new ArrayList<>(1 + aliases.length);\n+            optionList.add(option);\n+            Stream.of(aliases).forEach(optionList::add);\n+            this.optionList = Collections.unmodifiableList(optionList);\n+            this.optionList.forEach(ident -> map.put(ident, this));\n@@ -429,0 +437,7 @@\n+        \/**\n+         * Get all lint category option strings and aliases.\n+         *\/\n+        public static Set<String> options() {\n+            return Collections.unmodifiableSet(map.keySet());\n+        }\n+\n@@ -433,1 +448,1 @@\n-        \/** Get the string representing this category in @SuppressAnnotations and -Xlint options. *\/\n+        \/** Get the \"canonical\" string representing this category in @SuppressAnnotations and -Xlint options. *\/\n@@ -436,0 +451,3 @@\n+        \/** Get a list containing \"option\" followed by zero or more aliases. *\/\n+        public final List<String> optionList;\n+\n@@ -499,14 +517,0 @@\n-    \/**\n-     * Retrieve the recognized lint categories suppressed by the given @SuppressWarnings annotation.\n-     *\n-     * @param annotation @SuppressWarnings annotation, or null\n-     * @return set of lint categories, possibly empty but never null\n-     *\/\n-    private EnumSet<LintCategory> suppressionsFrom(JCAnnotation annotation) {\n-        initializeSymbolsIfNeeded();\n-        if (annotation == null)\n-            return LintCategory.newEmptySet();\n-        Assert.check(annotation.attribute.type.tsym == syms.suppressWarningsType.tsym);\n-        return suppressionsFrom(Stream.of(annotation).map(anno -> anno.attribute));\n-    }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Lint.java","additions":33,"deletions":29,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -231,0 +231,2 @@\n+    public final Type requiresIdentityType;\n+    public final Type requiresIdentityInternalType;\n@@ -613,0 +615,2 @@\n+        requiresIdentityType = enterClass(\"jdk.internal.RequiresIdentity\");\n+        requiresIdentityInternalType = enterSyntheticAnnotation(\"jdk.internal.RequiresIdentity+Annotation\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -668,0 +668,4 @@\n+    public boolean isValueBased() {\n+        return tsym != null && (tsym.flags_field & VALUE_BASED) != 0;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1050,1 +1050,1 @@\n-            if (tree.restype != null && !tree.restype.type.hasTag(VOID))\n+            if (tree.restype != null && !tree.restype.type.hasTag(VOID)) {\n@@ -1052,0 +1052,2 @@\n+            }\n+            chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -1331,0 +1333,1 @@\n+            chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -1948,1 +1951,1 @@\n-        if (isValueBased(tree.lock.type)) {\n+        if (tree.lock.type != null && tree.lock.type.isValueBased()) {\n@@ -1954,5 +1957,0 @@\n-        \/\/ where\n-        private boolean isValueBased(Type t) {\n-            return t != null && t.tsym != null && (t.tsym.flags() & VALUE_BASED) != 0;\n-        }\n-\n@@ -2671,0 +2669,3 @@\n+        if (env.info.lint.isEnabled(LintCategory.IDENTITY)) {\n+            chk.checkRequiresIdentity(tree, env.info.lint);\n+        }\n@@ -2913,0 +2914,2 @@\n+            chk.checkRequiresIdentity(tree, env.info.lint);\n+\n@@ -3792,0 +3795,1 @@\n+            chk.checkRequiresIdentity(that, localEnv.info.lint);\n@@ -4095,0 +4099,1 @@\n+        chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -4236,0 +4241,1 @@\n+        chk.checkRequiresIdentity(tree, env.info.lint);\n@@ -5589,0 +5595,2 @@\n+        chk.checkRequiresIdentity(tree, env.info.lint);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties;\n@@ -5670,0 +5671,189 @@\n+    void checkRequiresIdentity(JCTree tree, Lint lint) {\n+        switch (tree) {\n+            case JCClassDecl classDecl : {\n+                Type st = types.supertype(classDecl.sym.type);\n+                if (st != null &&\n+                        \/\/ no need to recheck j.l.Object, shortcut,\n+                        st.tsym != syms.objectType.tsym &&\n+                        \/\/ this one could be null, no explicit extends\n+                        classDecl.extending != null) {\n+                    checkIfIdentityIsExpected(classDecl.extending.pos(), st, lint);\n+                }\n+                for (JCExpression intrface: classDecl.implementing) {\n+                    checkIfIdentityIsExpected(intrface.pos(), intrface.type, lint);\n+                }\n+                for (JCTypeParameter tp : classDecl.typarams) {\n+                    checkIfIdentityIsExpected(tp.pos(), tp.type, lint);\n+                }\n+                break;\n+            }\n+            case JCVariableDecl variableDecl : {\n+                if (variableDecl.vartype != null &&\n+                        (variableDecl.sym.flags_field & RECORD) == 0 ||\n+                        (variableDecl.sym.flags_field & ~(Flags.PARAMETER | RECORD | GENERATED_MEMBER)) != 0) {\n+                    \/* we don't want to warn twice so if this variable is a compiler generated parameter of\n+                     * a canonical record constructor, we don't want to issue a warning as we will warn the\n+                     * corresponding compiler generated private record field anyways\n+                     *\/\n+                    checkIfIdentityIsExpected(variableDecl.vartype.pos(), variableDecl.vartype.type, lint);\n+                }\n+                break;\n+            }\n+            case JCTypeCast typeCast : {\n+                checkIfIdentityIsExpected(typeCast.clazz.pos(), typeCast.clazz.type, lint);\n+                break;\n+            }\n+            case JCBindingPattern bindingPattern : {\n+                if (bindingPattern.var.vartype != null) {\n+                    checkIfIdentityIsExpected(bindingPattern.var.vartype.pos(), bindingPattern.var.vartype.type, lint);\n+                }\n+                break;\n+            }\n+            case JCMethodDecl methodDecl : {\n+                for (JCTypeParameter tp : methodDecl.typarams) {\n+                    checkIfIdentityIsExpected(tp.pos(), tp.type, lint);\n+                }\n+                if (methodDecl.restype != null && !methodDecl.restype.type.hasTag(VOID)) {\n+                    checkIfIdentityIsExpected(methodDecl.restype.pos(), methodDecl.restype.type, lint);\n+                }\n+                break;\n+            }\n+            case JCMemberReference mref : {\n+                checkIfIdentityIsExpected(mref.expr.pos(), mref.target, lint);\n+                checkIfTypeParamsRequiresIdentity(mref.sym.getMetadata(), mref.typeargs, lint);\n+                break;\n+            }\n+            case JCPolyExpression poly\n+                when (poly instanceof JCNewClass || poly instanceof JCMethodInvocation) : {\n+                if (poly instanceof JCNewClass newClass) {\n+                    checkIfIdentityIsExpected(newClass.clazz.pos(), newClass.clazz.type, lint);\n+                }\n+                List<JCExpression> argExps = poly instanceof JCNewClass ?\n+                        ((JCNewClass)poly).args :\n+                        ((JCMethodInvocation)poly).args;\n+                Symbol msym = TreeInfo.symbolFor(poly);\n+                if (msym != null) {\n+                    if (!argExps.isEmpty() && msym instanceof MethodSymbol ms && ms.params != null) {\n+                        VarSymbol lastParam = ms.params.head;\n+                        for (VarSymbol param: ms.params) {\n+                            if (param.attribute(syms.requiresIdentityType.tsym) != null && argExps.head.type.isValueBased()) {\n+                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                            }\n+                            lastParam = param;\n+                            argExps = argExps.tail;\n+                        }\n+                        while (argExps != null && !argExps.isEmpty() && lastParam != null) {\n+                            if (lastParam.attribute(syms.requiresIdentityType.tsym) != null && argExps.head.type.isValueBased()) {\n+                                lint.logIfEnabled(argExps.head.pos(), LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                            }\n+                            argExps = argExps.tail;\n+                        }\n+                    }\n+                    checkIfTypeParamsRequiresIdentity(\n+                            msym.getMetadata(),\n+                            poly instanceof JCNewClass ?\n+                                ((JCNewClass)poly).typeargs :\n+                                ((JCMethodInvocation)poly).typeargs,\n+                            lint);\n+                }\n+                break;\n+            }\n+            default: throw new AssertionError(\"unexpected tree \" + tree);\n+        }\n+    }\n+\n+    \/** Check if a type required an identity class\n+     *\/\n+    private boolean checkIfIdentityIsExpected(DiagnosticPosition pos, Type t, Lint lint) {\n+        if (t != null &&\n+                lint != null &&\n+                lint.isEnabled(LintCategory.IDENTITY)) {\n+            RequiresIdentityVisitor requiresIdentityVisitor = new RequiresIdentityVisitor();\n+            \/\/ we need to avoid recursion due to self referencing type vars or captures, this is why we need a set\n+            requiresIdentityVisitor.visit(t, new HashSet<>());\n+            if (requiresIdentityVisitor.requiresWarning) {\n+                lint.logIfEnabled(pos, LintWarnings.AttemptToUseValueBasedWhereIdentityExpected);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/\/ where\n+    private class RequiresIdentityVisitor extends Types.SimpleVisitor<Void, Set<Type>> {\n+        boolean requiresWarning = false;\n+\n+        @Override\n+        public Void visitType(Type t, Set<Type> seen) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitWildcardType(WildcardType t, Set<Type> seen) {\n+            return visit(t.type, seen);\n+        }\n+\n+        @Override\n+        public Void visitTypeVar(TypeVar t, Set<Type> seen) {\n+            if (seen.add(t)) {\n+                visit(t.getUpperBound(), seen);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitCapturedType(CapturedType t, Set<Type> seen) {\n+            if (seen.add(t)) {\n+                visit(t.getUpperBound(), seen);\n+                visit(t.getLowerBound(), seen);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitArrayType(ArrayType t, Set<Type> seen) {\n+            return visit(t.elemtype, seen);\n+        }\n+\n+        @Override\n+        public Void visitClassType(ClassType t, Set<Type> seen) {\n+            if (t != null && t.tsym != null) {\n+                SymbolMetadata sm = t.tsym.getMetadata();\n+                if (sm != null && !t.getTypeArguments().isEmpty()) {\n+                    for (Attribute.TypeCompound ta: sm.getTypeAttributes().stream()\n+                            .filter(ta -> ta.type.tsym == syms.requiresIdentityType.tsym).toList()) {\n+                        Type type = t.getTypeArguments().get(ta.position.parameter_index);\n+                        if (type != null && type.isValueBased()) {\n+                            requiresWarning = true;\n+                            return null;\n+                        }\n+                    }\n+                }\n+            }\n+            visit(t.getEnclosingType(), seen);\n+            for (Type targ : t.getTypeArguments()) {\n+                visit(targ, seen);\n+            }\n+            return null;\n+        }\n+    } \/\/ RequiresIdentityVisitor\n+\n+    private void checkIfTypeParamsRequiresIdentity(SymbolMetadata sm,\n+                                                     List<JCExpression> typeParamTrees,\n+                                                     Lint lint) {\n+        if (typeParamTrees != null && !typeParamTrees.isEmpty()) {\n+            for (JCExpression targ : typeParamTrees) {\n+                checkIfIdentityIsExpected(targ.pos(), targ.type, lint);\n+            }\n+            if (sm != null)\n+                for (Attribute.TypeCompound ta : sm.getTypeAttributes().stream()\n+                        .filter(ta -> ta.type.tsym == syms.requiresIdentityType.tsym).toList()) {\n+                    Type paramType = typeParamTrees.get(ta.position.parameter_index).type;\n+                    if (paramType != null && paramType.isValueBased())\n+                        lint.logIfEnabled(\n+                                typeParamTrees.get(ta.position.parameter_index).pos(),\n+                                CompilerProperties.LintWarnings.AttemptToUseValueBasedWhereIdentityExpected\n+                        );\n+                }\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-        lintOptions = options.isUnset(Option.XLINT_CUSTOM, \"-\" + LintCategory.OPTIONS.option);\n+        lintOptions = !options.isExplicitlyDisabled(Option.XLINT, LintCategory.OPTIONS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -506,2 +506,1 @@\n-                    boolean lintPaths = options.isUnset(Option.XLINT_CUSTOM,\n-                            \"-\" + LintCategory.PATH.option);\n+                    boolean lintPaths = !options.isExplicitlyDisabled(Option.XLINT, LintCategory.PATH);\n@@ -580,1 +579,1 @@\n-        boolean lintOptions = options.isUnset(Option.XLINT_CUSTOM, \"-\" + LintCategory.OPTIONS.option);\n+        boolean lintOptions = !options.isExplicitlyDisabled(Option.XLINT, LintCategory.OPTIONS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Arguments.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import java.util.stream.Stream;\n@@ -494,1 +495,1 @@\n-                                            \"all\",\n+                                            LINT_CUSTOM_ALL,\n@@ -496,7 +497,4 @@\n-            for (LintCategory lc : LintCategory.values()) {\n-                log.printRawLines(WriterKind.STDOUT,\n-                                  String.format(LINT_KEY_FORMAT,\n-                                                lc.option,\n-                                                log.localize(PrefixKind.JAVAC,\n-                                                             \"opt.Xlint.desc.\" + lc.option)));\n-            }\n+            LintCategory.options().forEach(ident -> log.printRawLines(WriterKind.STDOUT,\n+                              String.format(LINT_KEY_FORMAT,\n+                                            ident,\n+                                            log.localize(PrefixKind.JAVAC, \"opt.Xlint.desc.\" + ident))));\n@@ -505,1 +503,1 @@\n-                                            \"none\",\n+                                            LINT_CUSTOM_NONE,\n@@ -838,0 +836,10 @@\n+    \/**\n+     * Special lint category key meaning \"all lint categories\".\n+     *\/\n+    public static final String LINT_CUSTOM_ALL = \"all\";\n+\n+    \/**\n+     * Special lint category key meaning \"no lint categories\".\n+     *\/\n+    public static final String LINT_CUSTOM_NONE = \"none\";\n+\n@@ -1084,0 +1092,11 @@\n+    \/**\n+     * If this option is named {@code FOO}, obtain the option named {@code FOO_CUSTOM}.\n+     *\n+     * @param option regular option\n+     * @return corresponding custom option\n+     * @throws IllegalArgumentException if no such option exists\n+     *\/\n+    public Option getCustom() {\n+        return Option.valueOf(name() + \"_CUSTOM\");\n+    }\n+\n@@ -1367,6 +1386,5 @@\n-        choices.add(\"all\");\n-        for (Lint.LintCategory c : Lint.LintCategory.values()) {\n-            choices.add(c.option);\n-            choices.add(\"-\" + c.option);\n-        }\n-        choices.add(\"none\");\n+        choices.add(LINT_CUSTOM_ALL);\n+        Lint.LintCategory.options().stream()\n+          .flatMap(ident -> Stream.of(ident, \"-\" + ident))\n+          .forEach(choices::add);\n+        choices.add(LINT_CUSTOM_NONE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/Option.java","additions":33,"deletions":15,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -4248,1 +4248,1 @@\n-# lint: synchronization\n+# lint: identity\n@@ -4252,0 +4252,4 @@\n+# lint: identity\n+compiler.warn.attempt.to.use.value.based.where.identity.expected=\\\n+    a value-based class has been used where an identity type is expected\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -295,1 +295,7 @@\n-    Warn about synchronization attempts on instances of value-based classes.\n+    Warn about synchronization attempts on instances of value-based classes.\\n\\\n+\\                         This key is a deprecated alias for ''identity'', which has the same uses and\\n\\\n+\\                         effects. Users are encouraged to use the ''identity'' category for all future\\n\\\n+\\                         and existing uses of ''synchronization''.\n+\n+javac.opt.Xlint.desc.identity=\\\n+    Warn about uses of value-based classes where an identity class is expected.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/javac.properties","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import com.sun.tools.javac.code.Lint.LintCategory;\n@@ -173,0 +174,52 @@\n+    \/**\n+     * Check whether the given lint category is explicitly enabled or disabled.\n+     *\n+     * <p>\n+     * If the category is neither enabled nor disabled, return the given default value.\n+     *\n+     * @param option the plain (non-custom) option\n+     * @param lc the {@link LintCategory} in question\n+     * @param defaultValue presumed default value\n+     * @return true if {@code lc} would be included\n+     *\/\n+    public boolean isSet(Option option, LintCategory lc, boolean defaultValue) {\n+        Option customOption = option.getCustom();\n+        if (lc.optionList.stream().anyMatch(alias -> isSet(customOption, alias))) {\n+            return true;\n+        }\n+        if (lc.optionList.stream().anyMatch(alias -> isSet(customOption, \"-\" + alias))) {\n+            return false;\n+        }\n+        if (isSet(option) || isSet(customOption, Option.LINT_CUSTOM_ALL)) {\n+            return true;\n+        }\n+        if (isSet(customOption, Option.LINT_CUSTOM_NONE)) {\n+            return false;\n+        }\n+        return defaultValue;\n+    }\n+\n+    \/**\n+     * Determine if a specific {@link LintCategory} was explicitly enabled via a custom option flag\n+     * of the form {@code -Flag:all} or {@code -Flag:key}.\n+     *\n+     * @param option the option\n+     * @param lc the {@link LintCategory} in question\n+     * @return true if {@code lc} has been explicitly enabled\n+     *\/\n+    public boolean isExplicitlyEnabled(Option option, LintCategory lc) {\n+        return isSet(option, lc, false);\n+    }\n+\n+    \/**\n+     * Determine if a specific {@link LintCategory} was explicitly disabled via a custom option flag\n+     * of the form {@code -Flag:none} or {@code -Flag:-key}.\n+     *\n+     * @param option the option\n+     * @param lc the {@link LintCategory} in question\n+     * @return true if {@code lc} has been explicitly disabled\n+     *\/\n+    public boolean isExplicitlyDisabled(Option option, LintCategory lc) {\n+        return !isSet(option, lc, true);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Options.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -167,0 +167,1 @@\n+ * <tr><th scope=\"row\">{@code identity}             <td>use of a value-based class where an identity class is expected\n@@ -189,1 +190,5 @@\n- * <tr><th scope=\"row\">{@code synchronization}      <td>synchronization attempts on instances of value-based classes\n+ * <tr><th scope=\"row\">{@code synchronization}      <td>synchronization attempts on instances of value-based classes;\n+ *                                                      this key is a deprecated alias for {@code identity}, which has\n+ *                                                      the same uses and effects. Users are encouraged to use the\n+ *                                                      {@code identity} category for all future and existing uses of\n+ *                                                      {@code synchronization}\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -599,0 +599,3 @@\n+    -   `identity`: Warns about use of a value-based class where an identity\n+        class is expected\n+\n@@ -649,1 +652,3 @@\n-        of value-based classes.\n+        of value-based classes. This key is a deprecated alias for `identity`,\n+        which has the same uses and effects. Users are encouraged to use the\n+        `identity` category for all future and existing uses of `synchronization`.\n","filename":"src\/jdk.compiler\/share\/man\/javac.md","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.stream.Stream;\n@@ -178,8 +179,1 @@\n-                boolean found = false;\n-\n-                for (LintCategory lc : LintCategory.values()) {\n-                    if (option.equals(lc.option))\n-                        found = true;\n-                }\n-\n-                if (found)\n+                if (LintCategory.options().contains(option))\n","filename":"test\/langtools\/tools\/javac\/diags\/CheckResourceKeys.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/\/ options: -Xlint:synchronization\n+\/\/ options: -Xlint:identity\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/AttemptToSynchronizeOnInstanceOfVbc.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+\/\/ options: -Xlint:identity --add-exports java.base\/jdk.internal=ALL-UNNAMED\n+\n+class RequiresIdentity<@jdk.internal.RequiresIdentity T> {\n+    RequiresIdentity<Integer> field; \/\/ should warn\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/RequiresIdentity.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -8,0 +8,1 @@\n+ * @compile\/fail\/ref=ExternalAbuseOfVbc.out -XDrawDiagnostics -Werror -Xlint:identity ExternalAbuseOfVbc.java\n@@ -9,1 +10,2 @@\n- * @compile\/ref=LintModeOffAbuseOfVbc.out -XDrawDiagnostics -Werror -Xlint:-synchronization ExternalAbuseOfVbc.java\n+ * @compile\/fail\/ref=ExternalAbuseOfVbc.out --release 16 -XDrawDiagnostics -Werror -Xlint:identity ExternalAbuseOfVbc.java\n+ * @compile\/ref=LintModeOffAbuseOfVbc.out -XDrawDiagnostics -Werror -Xlint:-synchronization,-identity ExternalAbuseOfVbc.java\n","filename":"test\/langtools\/tools\/javac\/lint\/ExternalAbuseOfVbc.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-ExternalAbuseOfVbc.java:19:13: compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class\n+ExternalAbuseOfVbc.java:21:13: compiler.warn.attempt.to.synchronize.on.instance.of.value.based.class\n","filename":"test\/langtools\/tools\/javac\/lint\/ExternalAbuseOfVbc.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,21 @@\n+\/* \/nodynamiccopyright\/ *\/\n+\n+package java.lang;\n+\n+public class RequiresIdentityHelper<@jdk.internal.RequiresIdentity T> {\n+    public RequiresIdentityHelper() {}\n+    public <@jdk.internal.RequiresIdentity TT> RequiresIdentityHelper(@jdk.internal.RequiresIdentity Object o) {}\n+\n+    class RequiresIdentity2<TT> {\n+        public RequiresIdentity2() {}\n+        public void foo(@jdk.internal.RequiresIdentity Object o) {}\n+        public void bar(@jdk.internal.RequiresIdentity Object... o) {}\n+        public void gg(@jdk.internal.RequiresIdentity TT ri) {}\n+    }\n+\n+    interface RequiresIdentityInt<@jdk.internal.RequiresIdentity T> {}\n+\n+    interface MyIntFunction<@jdk.internal.RequiresIdentity R> {\n+        R apply(int value);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/RequiresIdentityHelper.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8354556\n+ * @summary Expand value-based class warnings to java.lang.ref API\n+ * @compile --patch-module java.base=${test.src} RequiresIdentityHelper.java\n+ * @compile\/fail\/ref=RequiresIdentityTest.out --patch-module java.base=${test.src} -Werror -XDrawDiagnostics -Xlint:identity RequiresIdentityTest.java\n+ * @compile\/fail\/ref=RequiresIdentityTest.out --patch-module java.base=${test.src} -Werror -XDrawDiagnostics -Xlint:synchronization RequiresIdentityTest.java\n+ * @compile\/ref=RequiresIdentityTest2.out --patch-module java.base=${test.src} -Werror -XDrawDiagnostics -Xlint:-identity RequiresIdentityTest.java\n+ * @compile\/ref=RequiresIdentityTest2.out --patch-module java.base=${test.src} -Werror -XDrawDiagnostics -Xlint:-synchronization RequiresIdentityTest.java\n+ * @compile\/fail\/ref=RequiresIdentityTest.out --patch-module java.base=${test.src} -Werror -XDrawDiagnostics -Xlint:identity RequiresIdentityHelper.java RequiresIdentityTest.java\n+ * @compile\/fail\/ref=RequiresIdentityTest.out --patch-module java.base=${test.src} -Werror -XDrawDiagnostics -Xlint:synchronization RequiresIdentityHelper.java RequiresIdentityTest.java\n+ * @compile\/ref=RequiresIdentityTest2.out --patch-module java.base=${test.src} -Werror -XDrawDiagnostics -Xlint:-identity RequiresIdentityHelper.java RequiresIdentityTest.java\n+ * @compile\/ref=RequiresIdentityTest2.out --patch-module java.base=${test.src} -Werror -XDrawDiagnostics -Xlint:-synchronization RequiresIdentityHelper.java RequiresIdentityTest.java\n+ *\/\n+\n+package java.lang;\n+\n+@SuppressWarnings(\"deprecation\")\n+public class RequiresIdentityTest extends RequiresIdentityHelper<Integer> \/\/ should warn\n+                                  implements RequiresIdentityHelper.RequiresIdentityInt<Integer> { \/\/ should warn\n+    class Box<T> {}\n+\n+    RequiresIdentityHelper<Integer> field;                      \/\/ should warn\n+    RequiresIdentityHelper<Integer>[] field2;                   \/\/ should warn\n+    Box<? extends RequiresIdentityHelper<Integer>> field3;      \/\/ should warn\n+    Box<? super RequiresIdentityHelper<Integer>> field4;        \/\/ should warn\n+    RequiresIdentityHelper<Integer> field5 = new RequiresIdentityHelper<Integer>(); \/\/ two warnings here\n+\n+    public RequiresIdentityTest() {}\n+    public RequiresIdentityTest(Integer i) {\n+        super(i); \/\/ should warn\n+    }\n+\n+    void test(RequiresIdentity2<Object> ri, Integer i) { \/\/ warn on the first argument due to its enclosing type: RequiresIdentityHelper<Integer>\n+        RequiresIdentityHelper<Integer> localVar;     \/\/ should warn\n+        RequiresIdentityHelper<Integer>[] localVar2;  \/\/ should warn\n+        \/\/ there should be warnings for the invocations below\n+        ri.foo(i);\n+        ri.bar(i,  \/\/ warn here\n+               i); \/\/ and here too\n+        ri.gg(i);\n+    }\n+\n+    interface I extends RequiresIdentityHelper.RequiresIdentityInt<Integer> {} \/\/ should warn\n+\n+    void m(Object o) {\n+        RequiresIdentityHelper<?> ri = (RequiresIdentityHelper<Integer>) o; \/\/ should warn\n+    }\n+\n+    RequiresIdentityHelper<Integer> test() { \/\/ warn\n+        return null;\n+    }\n+\n+    \/\/ two warns here one for the type parameter and one for the result type\n+    <T extends RequiresIdentityHelper<Integer>> T test2() { return null; }\n+\n+    class SomeClass<T extends RequiresIdentityHelper<Integer>> {} \/\/ warn\n+\n+    record R(RequiresIdentityHelper<Integer> c) {} \/\/ warn\n+    record RR(R r) {}\n+\n+    void m1(RequiresIdentityInt<Integer> ri) { \/\/ warn here\n+        if (ri instanceof RequiresIdentityInt<Integer> rii) {} \/\/ and here\n+    }\n+\n+    void m2(RR rr) {\n+        if (rr instanceof RR(R(RequiresIdentityHelper<Integer> rii))) {}\n+    }\n+\n+    <T> void m3() {}\n+    void m4() {\n+        this.<RequiresIdentityHelper<Integer>>m3();\n+    }\n+\n+    MyIntFunction<Integer> field6 = Integer::new; \/\/ two warnings here\n+\n+    class Run<T> {\n+        public <@jdk.internal.RequiresIdentity K> void run() {}\n+    }\n+    void m5(Runnable r) {}\n+    void m6() {\n+        m5(new Run<Object>()::<Integer>run);\n+    }\n+\n+    void m7(Integer i, Object o) {\n+        RequiresIdentityHelper<Object> var1 = new <Object>RequiresIdentityHelper<Object>(i);\n+        RequiresIdentityHelper<Object> var2 = new <Integer>RequiresIdentityHelper<Object>(o);\n+        RequiresIdentityHelper<Integer> var3 = new <Object>RequiresIdentityHelper<Integer>(o);\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lint\/RequiresIdentityTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+RequiresIdentityTest.java:19:65: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:20:88: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:23:27: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:24:36: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:25:8: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:26:8: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:27:72: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:27:27: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:31:15: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:34:32: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:35:31: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:36:40: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:38:16: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:39:16: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:40:16: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:41:15: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:44:67: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:47:63: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:50:27: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:55:6: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:55:49: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:57:21: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:59:36: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:62:32: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:63:46: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:67:54: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:72:37: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:75:37: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:75:18: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:82:32: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:86:90: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:87:52: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:88:82: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+RequiresIdentityTest.java:88:31: compiler.warn.attempt.to.use.value.based.where.identity.expected\n+- compiler.err.warnings.and.werror\n+- compiler.note.unchecked.filename: RequiresIdentityTest.java\n+- compiler.note.unchecked.recompile\n+1 error\n+34 warnings\n","filename":"test\/langtools\/tools\/javac\/lint\/RequiresIdentityTest.out","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+- compiler.note.unchecked.filename: RequiresIdentityTest.java\n+- compiler.note.unchecked.recompile\n","filename":"test\/langtools\/tools\/javac\/lint\/RequiresIdentityTest2.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"}]}