{"files":[{"patch":"@@ -1581,1 +1581,1 @@\n-  static bool is_divisor_counted_loop_phi(const Node* divisor, const Node* loop);\n+  static bool is_divisor_loop_phi(const Node* divisor, const Node* loop);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-  return is_divisor_counted_loop_phi(divisor, region) &&\n+  return is_divisor_loop_phi(divisor, region) &&\n@@ -302,2 +302,2 @@\n-bool PhaseIdealLoop::is_divisor_counted_loop_phi(const Node* divisor, const Node* loop) {\n-  return loop->is_BaseCountedLoop() && divisor->is_Phi() && divisor->in(0) == loop;\n+bool PhaseIdealLoop::is_divisor_loop_phi(const Node* divisor, const Node* loop) {\n+  return loop->is_Loop() && divisor->is_Phi() && divisor->in(0) == loop;\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-* @bug 8299259\n+* @bug 8299259 8336729\n@@ -38,1 +38,1 @@\n-* @bug 8299259\n+* @bug 8299259 8336729\n@@ -46,0 +46,22 @@\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @bug 8336729\n+ * @requires vm.compiler2.enabled\n+ * @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM -XX:StressSeed=3434\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+ *                   compiler.splitif.TestSplitDivisionThroughPhi\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @bug 8336729\n+ * @requires vm.compiler2.enabled\n+ * @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+ *                   compiler.splitif.TestSplitDivisionThroughPhi\n+ *\/\n+\n@@ -64,0 +86,2 @@\n+            testPushDivLThruPhiForOuterLongLoop();\n+            testPushModLThruPhiForOuterLongLoop();\n@@ -81,0 +105,21 @@\n+    \/\/ Fixed with JDK-8336792.\n+    static void testPushDivLThruPhiForOuterLongLoop() {\n+        \/\/ This loop is first transformed into a LongCountedLoop in the first loop opts phase.\n+        \/\/ In the second loop opts phase, the LongCountedLoop is split into an inner and an outer loop. Both get the\n+        \/\/ same iv phi type which is [2..10]. Only the inner loop is transformed into a CountedLoopNode while the outer\n+        \/\/ loop is still a LoopNode. We run into the same problem as described in testPushDivIThruPhi() when splitting\n+        \/\/ the DivL node through the long iv phi of the outer LoopNode.\n+        \/\/ The fix for JDK-8299259 only prevents this splitting for CountedLoopNodes. We now extend it to LoopNodes\n+        \/\/ in general.\n+        for (long i = 10; i > 1; i -= 2) {\n+            lFld = 10 \/ i;\n+        }\n+    }\n+\n+    \/\/ Same as testPushDivLThruPhiForOuterLongLoop() but for ModL.\n+    static void testPushModLThruPhiForOuterLongLoop() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            iFld = 10 % i;\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestSplitDivisionThroughPhi.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"}]}