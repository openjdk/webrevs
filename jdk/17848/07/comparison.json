{"files":[{"patch":"@@ -471,1 +471,6 @@\n-  split_packs_longer_than_max_vector_size();\n+  construct_my_pack_map();\n+\n+  split_packs_at_use_def_boundaries();  \/\/ a first time: create natural boundaries\n+  split_packs_only_implemented_with_smaller_size();\n+  split_packs_to_break_mutual_dependence();\n+  split_packs_at_use_def_boundaries();  \/\/ again: propagate split of other packs\n@@ -474,1 +479,0 @@\n-  construct_my_pack_map();\n@@ -838,1 +842,3 @@\n-  if (isomorphic(s1, s2)) {\n+  \/\/ Forbid anything that looks like a PopulateIndex to be packed. It does not need to be packed,\n+  \/\/ and will still be vectorized by SuperWord::vector_opd.\n+  if (isomorphic(s1, s2) && !is_populate_index(s1, s2)) {\n@@ -917,0 +923,12 @@\n+\/\/ Look for pattern n1 = (iv + c) and n2 = (iv + c + 1), which may lead to PopulateIndex vector node.\n+\/\/ We skip the pack creation of these nodes. They will be vectorized by SuperWord::vector_opd.\n+bool SuperWord::is_populate_index(const Node* n1, const Node* n2) const {\n+  return n1->is_Add() &&\n+         n2->is_Add() &&\n+         n1->in(1) == iv() &&\n+         n2->in(1) == iv() &&\n+         n1->in(2)->is_Con() &&\n+         n2->in(2)->is_Con() &&\n+         n2->in(2)->get_int() - n1->in(2)->get_int() == 1;\n+}\n+\n@@ -1387,3 +1405,5 @@\n-void SuperWord::split_packs_longer_than_max_vector_size() {\n-  assert(!_packset.is_empty(), \"packset not empty\");\n-  DEBUG_ONLY( int old_packset_length = _packset.length(); )\n+SuperWord::SplitStatus SuperWord::split_pack(const char* split_name,\n+                                             Node_List* pack,\n+                                             SplitTask task)\n+{\n+  uint pack_size = pack->size();\n@@ -1391,25 +1411,5 @@\n-  for (int i = 0; i < _packset.length(); i++) {\n-    Node_List* pack = _packset.at(i);\n-    assert(pack != nullptr, \"no nullptr in packset\");\n-    uint max_vlen = max_vector_size_in_def_use_chain(pack->at(0));\n-    assert(is_power_of_2(max_vlen), \"sanity\");\n-    uint pack_size = pack->size();\n-    if (pack_size <= max_vlen) {\n-      continue;\n-    }\n-    \/\/ Split off the \"upper\" nodes into new packs\n-    Node_List* new_pack = new Node_List();\n-    for (uint j = max_vlen; j < pack_size; j++) {\n-      Node* n = pack->at(j);\n-      \/\/ is new_pack full?\n-      if (new_pack->size() >= max_vlen) {\n-        assert(is_power_of_2(new_pack->size()), \"sanity %d\", new_pack->size());\n-        _packset.append(new_pack);\n-        new_pack = new Node_List();\n-      }\n-      new_pack->push(n);\n-    }\n-    \/\/ remaining new_pack\n-    if (new_pack->size() > 1) {\n-      _packset.append(new_pack);\n-    } else {\n+  if (task.is_unchanged()) {\n+    return SplitStatus::make_unchanged(pack);\n+  }\n+\n+  if (task.is_rejected()) {\n@@ -1419,2 +1419,1 @@\n-        tty->print_cr(\"WARNING: Node dropped out of odd size pack:\");\n-        new_pack->at(0)->dump();\n+        tty->print_cr(\"WARNING: Removed pack during split: %s:\", task.message());\n@@ -1424,0 +1423,3 @@\n+    for (uint i = 0; i < pack_size; i++) {\n+      Node* n = pack->at(i);\n+      set_my_pack(n, nullptr);\n@@ -1425,3 +1427,32 @@\n-    \/\/ truncate\n-    while (pack->size() > max_vlen) {\n-      pack->pop();\n+    return SplitStatus::make_rejected();\n+  }\n+\n+  uint split_size = task.split_size();\n+  assert(0 < split_size && split_size < pack_size, \"split_size must be in range\");\n+\n+  \/\/ Split the size\n+  uint new_size = split_size;\n+  uint old_size = pack_size - new_size;\n+\n+#ifndef PRODUCT\n+  if (is_trace_superword_packset()) {\n+    tty->cr();\n+    tty->print_cr(\"INFO: splitting pack (sizes: %d %d): %s:\",\n+                  old_size, new_size, task.message());\n+    print_pack(pack);\n+  }\n+#endif\n+\n+  \/\/ Are both sizes too small to be a pack?\n+  if (old_size < 2 && new_size < 2) {\n+    assert(old_size == 1 && new_size == 1, \"implied\");\n+#ifndef PRODUCT\n+      if (is_trace_superword_rejections()) {\n+        tty->cr();\n+        tty->print_cr(\"WARNING: Removed size 2 pack, cannot be split: %s:\", task.message());\n+        print_pack(pack);\n+      }\n+#endif\n+    for (uint i = 0; i < pack_size; i++) {\n+      Node* n = pack->at(i);\n+      set_my_pack(n, nullptr);\n@@ -1429,0 +1460,1 @@\n+    return SplitStatus::make_rejected();\n@@ -1431,1 +1463,78 @@\n-  assert(old_packset_length <= _packset.length(), \"we only increased the number of packs\");\n+  \/\/ Just pop off a single node?\n+  if (new_size < 2) {\n+    assert(new_size == 1 && old_size >= 2, \"implied\");\n+    Node* n = pack->pop();\n+    set_my_pack(n, nullptr);\n+#ifndef PRODUCT\n+      if (is_trace_superword_rejections()) {\n+        tty->cr();\n+        tty->print_cr(\"WARNING: Removed node from pack, because of split: %s:\", task.message());\n+        n->dump();\n+      }\n+#endif\n+    return SplitStatus::make_modified(pack);\n+  }\n+\n+  \/\/ Just remove a single node at front?\n+  if (old_size < 2) {\n+    assert(old_size == 1 && new_size >= 2, \"implied\");\n+    Node* n = pack->at(0);\n+    pack->remove(0);\n+    set_my_pack(n, nullptr);\n+#ifndef PRODUCT\n+      if (is_trace_superword_rejections()) {\n+        tty->cr();\n+        tty->print_cr(\"WARNING: Removed node from pack, because of split: %s:\", task.message());\n+        n->dump();\n+      }\n+#endif\n+    return SplitStatus::make_modified(pack);\n+  }\n+\n+  \/\/ We will have two packs\n+  assert(old_size >= 2 && new_size >= 2, \"implied\");\n+  Node_List* new_pack = new Node_List(new_size);\n+\n+  for (uint i = 0; i < new_size; i++) {\n+    Node* n = pack->at(old_size + i);\n+    new_pack->push(n);\n+    set_my_pack(n, new_pack);\n+  }\n+\n+  for (uint i = 0; i < new_size; i++) {\n+    pack->pop();\n+  }\n+\n+  \/\/ We assume that new_pack is more \"stable\" (i.e. will have to be split less than new_pack).\n+  \/\/ Put \"pack\" second, so that we insert it later in the list, and iterate over it again sooner.\n+  return SplitStatus::make_split(new_pack, pack);\n+}\n+\n+template <typename SplitStrategy>\n+void SuperWord::split_packs(const char* split_name,\n+                            SplitStrategy strategy) {\n+  bool changed;\n+  do {\n+    changed = false;\n+    int new_packset_length = 0;\n+    for (int i = 0; i < _packset.length(); i++) {\n+      Node_List* pack = _packset.at(i);\n+      assert(pack != nullptr && pack->size() >= 2, \"no nullptr, at least size 2\");\n+      SplitTask task = strategy(pack);\n+      SplitStatus status = split_pack(split_name, pack, task);\n+      changed |= !status.is_unchanged();\n+      Node_List* first_pack = status.first_pack();\n+      Node_List* second_pack = status.second_pack();\n+      _packset.at_put(i, nullptr); \/\/ take out pack\n+      if (first_pack != nullptr) {\n+        \/\/ The first pack can be put at the current position\n+        assert(i >= new_packset_length, \"only move packs down\");\n+        _packset.at_put(new_packset_length++, first_pack);\n+      }\n+      if (second_pack != nullptr) {\n+        \/\/ The second node has to be appended at the end\n+        _packset.append(second_pack);\n+      }\n+    }\n+    _packset.trunc_to(new_packset_length);\n+  } while (changed);\n@@ -1435,1 +1544,1 @@\n-    tty->print_cr(\"\\nAfter Superword::split_packs_longer_than_max_vector_size\");\n+    tty->print_cr(\"\\nAfter %s\", split_name);\n@@ -1441,0 +1550,48 @@\n+\/\/ Split packs at boundaries where left and right have different use or def packs.\n+void SuperWord::split_packs_at_use_def_boundaries() {\n+  split_packs(\"SuperWord::split_packs_at_use_def_boundaries\",\n+               [&](const Node_List* pack) {\n+                 uint pack_size = pack->size();\n+                 uint boundary = find_use_def_boundary(pack);\n+                 assert(boundary < pack_size, \"valid boundary %d\", boundary);\n+                 if (boundary != 0) {\n+                   return SplitTask::make_split(pack_size - boundary, \"found a use\/def boundary\");\n+                 }\n+                 return SplitTask::make_unchanged();\n+               });\n+}\n+\n+\/\/ Split packs that are only implemented with a smaller pack size. Also splits packs\n+\/\/ such that they eventually have power of 2 size.\n+void SuperWord::split_packs_only_implemented_with_smaller_size() {\n+  split_packs(\"SuperWord::split_packs_only_implemented_with_smaller_size\",\n+               [&](const Node_List* pack) {\n+                 uint pack_size = pack->size();\n+                 uint implemented_size = max_implemented_size(pack);\n+                 if (implemented_size == 0)  {\n+                   return SplitTask::make_rejected(\"not implemented at any smaller size\");\n+                 }\n+                 assert(is_power_of_2(implemented_size), \"power of 2 size or zero: %d\", implemented_size);\n+                 if (implemented_size != pack_size) {\n+                   return SplitTask::make_split(implemented_size, \"only implemented at smaller size\");\n+                 }\n+                 return SplitTask::make_unchanged();\n+               });\n+}\n+\n+\/\/ Split packs that have a mutual dependency, until all packs are mutually_independent.\n+void SuperWord::split_packs_to_break_mutual_dependence() {\n+  split_packs(\"SuperWord::split_packs_to_break_mutual_dependence\",\n+               [&](const Node_List* pack) {\n+                 uint pack_size = pack->size();\n+                 assert(is_power_of_2(pack_size), \"ensured by earlier splits %d\", pack_size);\n+                 if (!is_marked_reduction(pack->at(0)) &&\n+                     !mutually_independent(pack)) {\n+                   \/\/ As a best guess, we split the pack in half. This way, we iteratively make the\n+                   \/\/ packs smaller, until there is no dependency.\n+                   return SplitTask::make_split(pack_size >> 1, \"was not mutually independent\");\n+                 }\n+                 return SplitTask::make_unchanged();\n+               });\n+}\n+\n@@ -1645,1 +1802,1 @@\n-                 return implemented(pack);\n+                 return implemented(pack, pack->size());\n@@ -1667,1 +1824,1 @@\n-                 \"size is not a power of 2\",\n+                 \"not profitable\",\n@@ -1686,3 +1843,3 @@\n-\/\/------------------------------implemented---------------------------\n-\/\/ Can code be generated for pack p?\n-bool SuperWord::implemented(const Node_List* p) {\n+\/\/ Can code be generated for the pack, restricted to size nodes?\n+bool SuperWord::implemented(const Node_List* pack, uint size) {\n+  assert(size >= 2 && size <= pack->size() && is_power_of_2(size), \"valid size\");\n@@ -1690,1 +1847,1 @@\n-  Node* p0 = p->at(0);\n+  Node* p0 = pack->at(0);\n@@ -1693,1 +1850,0 @@\n-    uint size = p->size();\n@@ -1735,0 +1891,16 @@\n+\/\/ Find the maximal implemented size smaller or equal to the packs size\n+uint SuperWord::max_implemented_size(const Node_List* pack) {\n+  uint size = round_down_power_of_2(pack->size());\n+  if (implemented(pack, size)) {\n+    return size;\n+  } else {\n+    \/\/ Iteratively divide size by 2, and check.\n+    for (uint s = size >> 1; s >= 2; s >>= 1) {\n+      if (implemented(pack, s)) {\n+        return s;\n+      }\n+    }\n+    return 0; \/\/ not implementable at all\n+  }\n+}\n+\n@@ -2766,0 +2938,88 @@\n+\/\/ Check if n_super's pack uses are a superset of n_sub's pack uses.\n+bool SuperWord::has_use_pack_superset(const Node* n_super, const Node* n_sub) const {\n+  Node_List* pack = my_pack(n_super);\n+  assert(pack != nullptr && pack == my_pack(n_sub), \"must have the same pack\");\n+\n+  \/\/ For all uses of n_sub that are in a pack (use_sub) ...\n+  for (DUIterator_Fast jmax, j = n_sub->fast_outs(jmax); j < jmax; j++) {\n+    Node* use_sub = n_sub->fast_out(j);\n+    Node_List* pack_use_sub = my_pack(use_sub);\n+    if (pack_use_sub == nullptr) { continue; }\n+\n+    \/\/ ... and all input edges: use_sub->in(i) == n_sub.\n+    uint start, end;\n+    VectorNode::vector_operands(use_sub, &start, &end);\n+    for (uint i = start; i < end; i++) {\n+      if (use_sub->in(i) != n_sub) { continue; }\n+\n+      \/\/ Check if n_super has any use use_super in the same pack ...\n+      bool found = false;\n+      for (DUIterator_Fast kmax, k = n_super->fast_outs(kmax); k < kmax; k++) {\n+        Node* use_super = n_super->fast_out(k);\n+        Node_List* pack_use_super = my_pack(use_super);\n+        if (pack_use_sub != pack_use_super) { continue; }\n+\n+        \/\/ ... and where there is an edge use_super->in(i) == n_super.\n+        \/\/ For MulAddS2I it is expected to have defs over different input edges.\n+        if (use_super->in(i) != n_super && !VectorNode::is_muladds2i(use_super)) { continue; }\n+\n+        found = true;\n+        break;\n+      }\n+      if (!found) {\n+        \/\/ n_sub has a use-edge (use_sub->in(i) == n_sub) with use_sub in a packset,\n+        \/\/ but n_super does not have any edge (use_super->in(i) == n_super) with\n+        \/\/ use_super in the same packset. Hence, n_super does not have a use pack\n+        \/\/ superset of n_sub.\n+        return false;\n+      }\n+    }\n+  }\n+  \/\/ n_super has all edges that n_sub has.\n+  return true;\n+}\n+\n+\/\/ Find a boundary in the pack, where left and right have different pack uses and defs.\n+\/\/ This is a natural boundary to split a pack, to ensure that use and def packs match.\n+\/\/ If no boundary is found, return zero.\n+uint SuperWord::find_use_def_boundary(const Node_List* pack) const {\n+  Node* p0 = pack->at(0);\n+  Node* p1 = pack->at(1);\n+\n+  const bool is_reduction_pack = reduction(p0, p1);\n+\n+  \/\/ Inputs range\n+  uint start, end;\n+  VectorNode::vector_operands(p0, &start, &end);\n+\n+  for (int i = pack->size() - 2; i >= 0; i--) {\n+    \/\/ For all neighbours\n+    Node* n0 = pack->at(i + 0);\n+    Node* n1 = pack->at(i + 1);\n+\n+\n+    \/\/ 1. Check for matching defs\n+    for (uint j = start; j < end; j++) {\n+      Node* n0_in = n0->in(j);\n+      Node* n1_in = n1->in(j);\n+      \/\/ No boundary if:\n+      \/\/ 1) the same packs OR\n+      \/\/ 2) reduction edge n0->n1 or n1->n0\n+      if (my_pack(n0_in) != my_pack(n1_in) &&\n+          !((n0 == n1_in || n1 == n0_in) && is_reduction_pack)) {\n+        return i + 1;\n+      }\n+    }\n+\n+    \/\/ 2. Check for matching uses: equal if both are superset of the other.\n+    \/\/    Reductions have no pack uses, so they match trivially on the use packs.\n+    if (!is_reduction_pack &&\n+        !(has_use_pack_superset(n0, n1) &&\n+          has_use_pack_superset(n1, n0))) {\n+      return i + 1;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":305,"deletions":45,"binary":false,"changes":350,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-  Node_List* my_pack(Node* n)                 { return !in_bb(n) ? nullptr : _node_info.adr_at(bb_idx(n))->_my_pack; }\n+  Node_List* my_pack(const Node* n)     const { return !in_bb(n) ? nullptr : _node_info.adr_at(bb_idx(n))->_my_pack; }\n@@ -276,0 +276,2 @@\n+  \/\/ Do we have pattern n1 = (iv + c) and n2 = (iv + c + 1)?\n+  bool is_populate_index(const Node* n1, const Node* n2) const;\n@@ -298,1 +300,96 @@\n-  void split_packs_longer_than_max_vector_size();\n+  class SplitTask {\n+  private:\n+    enum Kind {\n+      \/\/ The lambda method for split_packs can return one of these tasks:\n+      Unchanged, \/\/ The pack is left in the packset, unchanged.\n+      Rejected,  \/\/ The pack is removed from the packset.\n+      Split,     \/\/ Split away split_size nodes from the end of the pack.\n+    };\n+    const Kind _kind;\n+    const uint _split_size;\n+    const char* _message;\n+\n+    SplitTask(const Kind kind, const uint split_size, const char* message) :\n+        _kind(kind), _split_size(split_size), _message(message)\n+    {\n+      assert(message != nullptr, \"must have message\");\n+      assert(_kind != Unchanged || split_size == 0, \"unchanged task conditions\");\n+      assert(_kind != Rejected  || split_size == 0, \"reject task conditions\");\n+      assert(_kind != Split     || split_size != 0, \"split task conditions\");\n+    }\n+\n+  public:\n+    static SplitTask make_split(const uint split_size, const char* message) {\n+      return SplitTask(Split, split_size, message);\n+    }\n+\n+    static SplitTask make_unchanged() {\n+      return SplitTask(Unchanged, 0, \"unchanged\");\n+    }\n+\n+    static SplitTask make_rejected(const char* message) {\n+      return SplitTask(Rejected, 0, message);\n+    }\n+\n+    bool is_unchanged() const { return _kind == Unchanged; }\n+    bool is_rejected() const { return _kind == Rejected; }\n+    bool is_split() const { return _kind == Split; }\n+    const char* message() const { return _message; }\n+\n+    uint split_size() const {\n+      assert(is_split(), \"only split tasks have split_size\");\n+      return _split_size;\n+    }\n+  };\n+\n+  class SplitStatus {\n+  private:\n+    enum Kind {\n+      \/\/ After split_pack, we have:                              first_pack   second_pack\n+      Unchanged, \/\/ The pack is left in the pack, unchanged.     old_pack     nullptr\n+      Rejected,  \/\/ The pack is removed from the packset.        nullptr      nullptr\n+      Modified,  \/\/ The pack had some nodes removed.             old_pack     nullptr\n+      Split,     \/\/ The pack was split into two packs.           pack1        pack2\n+    };\n+    Kind _kind;\n+    Node_List* _first_pack;\n+    Node_List* _second_pack;\n+\n+    SplitStatus(Kind kind, Node_List* first_pack, Node_List* second_pack) :\n+      _kind(kind), _first_pack(first_pack), _second_pack(second_pack)\n+    {\n+      assert(_kind != Unchanged || (first_pack != nullptr && second_pack == nullptr), \"unchanged status conditions\");\n+      assert(_kind != Rejected  || (first_pack == nullptr && second_pack == nullptr), \"rejected status conditions\");\n+      assert(_kind != Modified  || (first_pack != nullptr && second_pack == nullptr), \"modified status conditions\");\n+      assert(_kind != Split     || (first_pack != nullptr && second_pack != nullptr), \"split status conditions\");\n+    }\n+\n+  public:\n+    static SplitStatus make_unchanged(Node_List* old_pack) {\n+      return SplitStatus(Unchanged, old_pack, nullptr);\n+    }\n+\n+    static SplitStatus make_rejected() {\n+      return SplitStatus(Rejected, nullptr, nullptr);\n+    }\n+\n+    static SplitStatus make_modified(Node_List* first_pack) {\n+      return SplitStatus(Modified, first_pack, nullptr);\n+    }\n+\n+    static SplitStatus make_split(Node_List* first_pack, Node_List* second_pack) {\n+      return SplitStatus(Split, first_pack, second_pack);\n+    }\n+\n+    bool is_unchanged() const { return _kind == Unchanged; }\n+    Node_List* first_pack() const { return _first_pack; }\n+    Node_List* second_pack() const { return _second_pack; }\n+  };\n+\n+  SplitStatus split_pack(const char* split_name, Node_List* pack, SplitTask task);\n+  template <typename SplitStrategy>\n+  void split_packs(const char* split_name, SplitStrategy strategy);\n+\n+  void split_packs_at_use_def_boundaries();\n+  void split_packs_only_implemented_with_smaller_size();\n+  void split_packs_to_break_mutual_dependence();\n@@ -331,2 +428,6 @@\n-  \/\/ Can code be generated for pack p?\n-  bool implemented(const Node_List* p);\n+\n+  \/\/ Can code be generated for the pack, restricted to size nodes?\n+  bool implemented(const Node_List* pack, uint size);\n+  \/\/ Find the maximal implemented size smaller or equal to the packs size\n+  uint max_implemented_size(const Node_List* pack);\n+\n@@ -337,0 +438,5 @@\n+\n+  \/\/ Check if n_super's pack uses are a superset of n_sub's pack uses.\n+  bool has_use_pack_superset(const Node* n1, const Node* n2) const;\n+  \/\/ Find a boundary in the pack, where left and right have different pack uses and defs.\n+  uint find_use_def_boundary(const Node_List* pack) const;\n@@ -339,0 +445,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":111,"deletions":4,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -44,1 +44,3 @@\n-    static final int[] GOLDEN;\n+    static final int[] GOLDEN_A;\n+    static final int[] GOLDEN_B;\n+    static final int[] GOLDEN_C;\n@@ -51,1 +53,3 @@\n-        GOLDEN = test();\n+        GOLDEN_A = testa();\n+        GOLDEN_B = testb();\n+        GOLDEN_C = testc();\n@@ -64,1 +68,1 @@\n-    @Run(test = \"test\")\n+    @Run(test = {\"testa\", \"testb\", \"testc\"})\n@@ -67,1 +71,3 @@\n-        compare(test());\n+        compare(testa(), GOLDEN_A, \"testa\");\n+        compare(testb(), GOLDEN_B, \"testb\");\n+        compare(testb(), GOLDEN_C, \"testc\");\n@@ -70,1 +76,1 @@\n-    public static void compare(int[] out) {\n+    public static void compare(int[] out, int[] golden, String name) {\n@@ -72,1 +78,1 @@\n-            Asserts.assertEQ(out[i], GOLDEN[i], \"wrong result for out[\" + i + \"]\");\n+            Asserts.assertEQ(out[i], golden[i], \"wrong result for '\" + name + \"' out[\" + i + \"]\");\n@@ -85,1 +91,1 @@\n-    public static int[] test() {\n+    public static int[] testa() {\n@@ -94,0 +100,36 @@\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    public static int[] testb() {\n+        int[] out = new int[ITER];\n+        int[] out2 = new int[ITER];\n+        for (int i = 0; i < ITER; i++) {\n+            out[i] += ((sArr1[2*i] * sArr2[2*i]) + (sArr1[2*i+1] * sArr2[2*i+1]));\n+            out2[i] += out[i];\n+        }\n+        return out;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeature = {\"sse2\", \"true\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIf = {\"MaxVectorSize\", \"16\"}, \/\/ AD file requires vector_length = 16\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI, \"> 0\"})\n+    @IR(applyIfCPUFeature = {\"avx512_vnni\", \"true\"},\n+        counts = {IRNode.MUL_ADD_S2I, \"> 0\", IRNode.MUL_ADD_VS2VI_VNNI, \"> 0\"})\n+    public static int[] testc() {\n+        int[] out = new int[ITER];\n+        for (int i = 0; i < ITER; i++) {\n+            out[i] += ((sArr1[2*i] * sArr2[2*i]) + (sArr1[2*i+1] * sArr2[2*i+1]));\n+        }\n+        return out;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":49,"deletions":7,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,766 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+import java.lang.reflect.Array;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.nio.ByteOrder;\n+\n+\/*\n+ * @test\n+ * @bug 8326139\n+ * @summary Test splitting packs in SuperWord\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run driver compiler.loopopts.superword.TestSplitPacks\n+ *\/\n+\n+public class TestSplitPacks {\n+    static int RANGE = 1024*8;\n+    static int RANGE_FINAL = 1024*8;\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/\/ Inputs\n+    byte[] aB;\n+    byte[] bB;\n+    byte mB = (byte)31;\n+    short[] aS;\n+    short[] bS;\n+    short mS = (short)0xF0F0;\n+    int[] aI;\n+    int[] bI;\n+    int mI = 0xF0F0F0F0;\n+    long[] aL;\n+    long[] bL;\n+    long mL = 0xF0F0F0F0F0F0F0F0L;\n+\n+    \/\/ List of tests\n+    Map<String,TestFunction> tests = new HashMap<String,TestFunction>();\n+\n+    \/\/ List of gold, the results from the first run before compilation\n+    Map<String,Object[]> golds = new HashMap<String,Object[]>();\n+\n+    interface TestFunction {\n+        Object[] run();\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:LoopUnrollLimit=1000\");\n+    }\n+\n+    public TestSplitPacks() {\n+        \/\/ Generate input once\n+        aB = generateB();\n+        bB = generateB();\n+        aS = generateS();\n+        bS = generateS();\n+        aI = generateI();\n+        bI = generateI();\n+        aL = generateL();\n+        bL = generateL();\n+\n+        \/\/ Add all tests to list\n+        tests.put(\"test0\",       () -> { return test0(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test1a\",      () -> { return test1a(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test1b\",      () -> { return test1b(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test1c\",      () -> { return test1c(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test1d\",      () -> { return test1d(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test2a\",      () -> { return test2a(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test2b\",      () -> { return test2b(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test2c\",      () -> { return test2c(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test2d\",      () -> { return test2d(aI.clone(), bI.clone(), mI); });\n+        tests.put(\"test3a\",      () -> { return test3a(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test4a\",      () -> { return test4a(aS.clone(), bS.clone()); });\n+        tests.put(\"test4b\",      () -> { return test4b(aS.clone(), bS.clone()); });\n+        tests.put(\"test4c\",      () -> { return test4c(aS.clone(), bS.clone()); });\n+        tests.put(\"test4d\",      () -> { return test4d(aS.clone(), bS.clone()); });\n+        tests.put(\"test4e\",      () -> { return test4e(aS.clone(), bS.clone()); });\n+        tests.put(\"test4f\",      () -> { return test4f(aS.clone(), bS.clone()); });\n+        tests.put(\"test4g\",      () -> { return test4g(aS.clone(), bS.clone()); });\n+        tests.put(\"test5a\",      () -> { return test5a(aS.clone(), bS.clone(), mS); });\n+        tests.put(\"test6a\",      () -> { return test6a(aI.clone(), bI.clone()); });\n+        tests.put(\"test7a\",      () -> { return test7a(aI.clone(), bI.clone()); });\n+\n+        \/\/ Compute gold value for all test methods before compilation\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            Object[] gold = test.run();\n+            golds.put(name, gold);\n+        }\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"test0\",\n+                 \"test1a\",\n+                 \"test1b\",\n+                 \"test1c\",\n+                 \"test1d\",\n+                 \"test2a\",\n+                 \"test2b\",\n+                 \"test2c\",\n+                 \"test2d\",\n+                 \"test3a\",\n+                 \"test4a\",\n+                 \"test4b\",\n+                 \"test4c\",\n+                 \"test4d\",\n+                 \"test4e\",\n+                 \"test4f\",\n+                 \"test4g\",\n+                 \"test5a\",\n+                 \"test6a\",\n+                 \"test7a\"})\n+    public void runTests() {\n+        for (Map.Entry<String,TestFunction> entry : tests.entrySet()) {\n+            String name = entry.getKey();\n+            TestFunction test = entry.getValue();\n+            \/\/ Recall gold value from before compilation\n+            Object[] gold = golds.get(name);\n+            \/\/ Compute new result\n+            Object[] result = test.run();\n+            \/\/ Compare gold and new result\n+            verify(name, gold, result);\n+        }\n+    }\n+\n+    static byte[] generateB() {\n+        byte[] a = new byte[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static short[] generateS() {\n+        short[] a = new short[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (short)RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static int[] generateI() {\n+        int[] a = new int[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+        return a;\n+    }\n+\n+    static long[] generateL() {\n+        long[] a = new long[RANGE];\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextLong();\n+        }\n+        return a;\n+    }\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g.getClass() != r.getClass() || !g.getClass().isArray() || !r.getClass().isArray()) {\n+                throw new RuntimeException(\"verify \" + name + \": must both be array of same type:\" +\n+                                           \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                           \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate arrays (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+            if (Array.getLength(g) != Array.getLength(r)) {\n+                    throw new RuntimeException(\"verify \" + name + \": arrays must have same length:\" +\n+                                           \" gold[\" + i + \"].length = \" + Array.getLength(g) +\n+                                           \" result[\" + i + \"].length = \" + Array.getLength(r));\n+            }\n+            Class c = g.getClass().getComponentType();\n+            if (c == byte.class) {\n+                verifyB(name, i, (byte[])g, (byte[])r);\n+            } else if (c == short.class) {\n+                verifyS(name, i, (short[])g, (short[])r);\n+            } else if (c == int.class) {\n+                verifyI(name, i, (int[])g, (int[])r);\n+            } else if (c == long.class) {\n+                verifyL(name, i, (long[])g, (long[])r);\n+            } else {\n+                throw new RuntimeException(\"verify \" + name + \": array type not supported for verify:\" +\n+                                       \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                       \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    static void verifyB(String name, int i, byte[] g, byte[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyS(String name, int i, short[] g, short[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyI(String name, int i, int[] g, int[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyL(String name, int i, long[] g, long[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Load and store are already split\n+    \/\/\n+    \/\/  0 1 - - 4 5 6 7\n+    \/\/  | |     | | | |\n+    \/\/  0 1 - - 4 5 6 7\n+    static Object[] test0(int[] a, int[] b, int mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            int b0 = a[i+0] & mask;\n+            int b1 = a[i+1] & mask;\n+\n+            int b4 = a[i+4] & mask;\n+            int b5 = a[i+5] & mask;\n+            int b6 = a[i+6] & mask;\n+            int b7 = a[i+7] & mask;\n+\n+            b[i+0] = b0;\n+            b[i+1] = b1;\n+\n+            b[i+4] = b4;\n+            b[i+5] = b5;\n+            b[i+6] = b6;\n+            b[i+7] = b7;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.MUL_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Adjacent Load and Store, but split by Add\/Mul\n+    static Object[] test1a(int[] a, int[] b, int mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            b[i+0] = a[i+0] + mask; \/\/ Add\n+            b[i+1] = a[i+1] + mask;\n+            b[i+2] = a[i+2] + mask;\n+            b[i+3] = a[i+3] + mask;\n+\n+            b[i+4] = a[i+4] * mask; \/\/ Mul\n+            b[i+5] = a[i+5] * mask;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.MUL_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Adjacent Load and Store, but split by Add\/Mul\n+    static Object[] test1b(int[] a, int[] b, int mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            b[i+0] = a[i+0] * mask; \/\/ Mul\n+            b[i+1] = a[i+1] * mask;\n+            b[i+2] = a[i+2] * mask;\n+            b[i+3] = a[i+3] * mask;\n+\n+            b[i+4] = a[i+4] + mask; \/\/ Add\n+            b[i+5] = a[i+5] + mask;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.MUL_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Adjacent Load and Store, but split by Add\/Mul\n+    static Object[] test1c(int[] a, int[] b, int mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            b[i+0] = a[i+0] + mask; \/\/ Add\n+            b[i+1] = a[i+1] + mask;\n+\n+            b[i+2] = a[i+2] * mask; \/\/ Mul\n+            b[i+3] = a[i+3] * mask;\n+            b[i+4] = a[i+4] * mask;\n+            b[i+5] = a[i+5] * mask;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.ADD_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.MUL_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Adjacent Load and Store, but split by Add\/Mul\n+    static Object[] test1d(int[] a, int[] b, int mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            b[i+0] = a[i+0] * mask; \/\/ Mul\n+            b[i+1] = a[i+1] * mask;\n+\n+            b[i+2] = a[i+2] + mask; \/\/ Add\n+            b[i+3] = a[i+3] + mask;\n+            b[i+4] = a[i+4] + mask;\n+            b[i+5] = a[i+5] + mask;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"= 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Split the load\n+    \/\/\n+    \/\/  0 1 2 3 4 5 - -\n+    \/\/  | |  \\ \\ \\ \\\n+    \/\/  | |   \\ \\ \\ \\\n+    \/\/  | |    \\ \\ \\ \\\n+    \/\/  0 1 - - 4 5 6 7\n+    \/\/\n+    \/\/ The 4-pack does not vectorize. This is a technical limitation that\n+    \/\/ we can hopefully soon remove. Load and store offsets are different.\n+    static Object[] test2a(int[] a, int[] b, int mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            int b0 = a[i+0] & mask;\n+            int b1 = a[i+1] & mask;\n+            int b2 = a[i+2] & mask;\n+            int b3 = a[i+3] & mask;\n+            int b4 = a[i+4] & mask;\n+            int b5 = a[i+5] & mask;\n+\n+            b[i+0] = b0;\n+            b[i+1] = b1;\n+\n+            b[i+4] = b2;\n+            b[i+5] = b3;\n+            b[i+6] = b4;\n+            b[i+7] = b5;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"= 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"= 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Split the load\n+    \/\/\n+    \/\/  0 1 2 3 4 5 - -\n+    \/\/  | | | |  \\ \\\n+    \/\/  | | | |   \\ \\\n+    \/\/  | | | |    \\ \\\n+    \/\/  0 1 2 3 -- 6 7\n+    \/\/\n+    \/\/ The 2-pack does not vectorize. This is a technical limitation that\n+    \/\/ we can hopefully soon remove. Load and store offsets are different.\n+    static Object[] test2b(int[] a, int[] b, int mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            int b0 = a[i+0] & mask;\n+            int b1 = a[i+1] & mask;\n+            int b2 = a[i+2] & mask;\n+            int b3 = a[i+3] & mask;\n+            int b4 = a[i+4] & mask;\n+            int b5 = a[i+5] & mask;\n+\n+            b[i+0] = b0;\n+            b[i+1] = b1;\n+            b[i+2] = b2;\n+            b[i+3] = b3;\n+\n+            b[i+6] = b4;\n+            b[i+7] = b5;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"= 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"= 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Split the load\n+    \/\/\n+    \/\/  0 1 - - 4 5 6 7\n+    \/\/  | |    \/ \/ \/ \/\n+    \/\/  | |   \/ \/ \/ \/\n+    \/\/  | |  \/ \/ \/ \/\n+    \/\/  0 1 2 3 4 5 - -\n+    \/\/\n+    \/\/ The 4-pack does not vectorize. This is a technical limitation that\n+    \/\/ we can hopefully soon remove. Load and store offsets are different.\n+    static Object[] test2c(int[] a, int[] b, int mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            int b0 = a[i+0] & mask;\n+            int b1 = a[i+1] & mask;\n+\n+            int b4 = a[i+4] & mask;\n+            int b5 = a[i+5] & mask;\n+            int b6 = a[i+6] & mask;\n+            int b7 = a[i+7] & mask;\n+\n+            b[i+0] = b0;\n+            b[i+1] = b1;\n+            b[i+2] = b4;\n+            b[i+3] = b5;\n+            b[i+4] = b6;\n+            b[i+5] = b7;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_2, \"= 0\",\n+                  IRNode.LOAD_VECTOR_I, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_2, \"= 0\",\n+                  IRNode.AND_VI,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Split the load\n+    \/\/\n+    \/\/  0 1 2 3 - - 6 7\n+    \/\/  | | | |    \/ \/\n+    \/\/  | | | |   \/ \/\n+    \/\/  | | | |  \/ \/\n+    \/\/  0 1 2 3 4 5 - -\n+    \/\/\n+    \/\/ The 2-pack does not vectorize. This is a technical limitation that\n+    \/\/ we can hopefully soon remove. Load and store offsets are different.\n+    static Object[] test2d(int[] a, int[] b, int mask) {\n+        for (int i = 0; i < RANGE; i+=8) {\n+            int b0 = a[i+0] & mask;\n+            int b1 = a[i+1] & mask;\n+            int b2 = a[i+2] & mask;\n+            int b3 = a[i+3] & mask;\n+\n+            int b6 = a[i+6] & mask;\n+            int b7 = a[i+7] & mask;\n+\n+            b[i+0] = b0;\n+            b[i+1] = b1;\n+            b[i+2] = b2;\n+            b[i+3] = b3;\n+            b[i+4] = b6;\n+            b[i+5] = b7;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ 0 1 2 3 4 5 6 7 -\n+    \/\/ | | | | | | | |\n+    \/\/ | + + + | | | |\n+    \/\/ |       | | | |\n+    \/\/ |     v | | | | v\n+    \/\/ |     | | | | | |\n+    \/\/ 1 - - 3 4 5 6 7 8\n+    static Object[] test3a(short[] a, short[] b, short val) {\n+        int sum = 0;\n+        for (int i = 0; i < RANGE; i+=16) {\n+          short a0 = a[i+0]; \/\/ required for alignment \/ offsets, technical limitation.\n+\n+          short a1 = a[i+1]; \/\/ adjacent to 4-pack, but need to be split off\n+          short a2 = a[i+2];\n+          short a3 = a[i+3];\n+\n+          short a4 = a[i+4]; \/\/ 4-pack\n+          short a5 = a[i+5];\n+          short a6 = a[i+6];\n+          short a7 = a[i+7];\n+\n+\n+          b[i+0] = a0; \/\/ required for alignment \/ offsets, technical limitation.\n+\n+          sum += a1 + a2 + a3; \/\/ not packed\n+\n+          b[i+3] = val; \/\/ adjacent to 4-pack but needs to be split off\n+\n+          b[i+4] = a4; \/\/ 4-pack\n+          b[i+5] = a5;\n+          b[i+6] = a6;\n+          b[i+7] = a7;\n+\n+          b[i+8] = val; \/\/ adjacent to 4-pack but needs to be split off\n+        }\n+        return new Object[]{ a, b, new int[]{ sum } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Cyclic dependency with distance 2 -> split into 2-packs\n+    static Object[] test4a(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+2] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\"})\n+    \/\/ Cyclic dependency with distance 3 -> split into 2-packs\n+    static Object[] test4b(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+3] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=8\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Cyclic dependency with distance 4 -> split into 4-packs\n+    static Object[] test4c(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+4] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Cyclic dependency with distance 5 -> split into 4-packs\n+    static Object[] test4d(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+5] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Cyclic dependency with distance 6 -> split into 4-packs\n+    static Object[] test4e(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+6] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=8\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Cyclic dependency with distance 7 -> split into 4-packs\n+    static Object[] test4f(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+7] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Cyclic dependency with distance 8 -> split into 8-packs\n+    static Object[] test4g(short[] a, short[] b) {\n+        for (int i = 0; i < RANGE-64; i++) {\n+          b[i+8] = a[i+0];\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.LOAD_VECTOR_S, IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.ADD_VS,        IRNode.VECTOR_SIZE_2, \"> 0\",\n+                  IRNode.ADD_VS,        IRNode.VECTOR_SIZE_8, \"> 0\",\n+                  IRNode.ADD_VS,        IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.STORE_VECTOR, \"> 0\"},\n+        applyIfAnd = {\"MaxVectorSize\", \">=32\", \"AlignVector\", \"false\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Split pack into power-of-2 sizes\n+    static Object[] test5a(short[] a, short[] b, short val) {\n+        for (int i = 0; i < RANGE; i+=16) {\n+            b[i+ 0] = (short)(a[i+ 0] + val); \/\/ 8 pack\n+            b[i+ 1] = (short)(a[i+ 1] + val);\n+            b[i+ 2] = (short)(a[i+ 2] + val);\n+            b[i+ 3] = (short)(a[i+ 3] + val);\n+            b[i+ 4] = (short)(a[i+ 4] + val);\n+            b[i+ 5] = (short)(a[i+ 5] + val);\n+            b[i+ 6] = (short)(a[i+ 6] + val);\n+            b[i+ 7] = (short)(a[i+ 7] + val);\n+\n+            b[i+ 8] = (short)(a[i+ 8] + val); \/\/ 4-pack\n+            b[i+ 9] = (short)(a[i+ 9] + val);\n+            b[i+10] = (short)(a[i+10] + val);\n+            b[i+11] = (short)(a[i+11] + val);\n+\n+            b[i+12] = (short)(a[i+12] + val); \/\/ 2-pack\n+            b[i+13] = (short)(a[i+13] + val);\n+\n+            b[i+14] = (short)(a[i+14] + val);\n+        }\n+        return new Object[]{ a, b };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,   IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.MUL_VI,          IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.AND_VI,          IRNode.VECTOR_SIZE_4, \"> 0\",\n+                  IRNode.ADD_VI,          IRNode.VECTOR_SIZE_4, \"> 0\", \/\/ reduction moved out of loop\n+                  IRNode.ADD_REDUCTION_V,                       \"> 0\"},\n+        applyIf = {\"MaxVectorSize\", \">=32\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n+    \/\/ Split packs including reductions\n+    static Object[] test6a(int[] a, int[] b) {\n+        int s = 0;\n+        for (int i = 0; i < RANGE; i+=8) {\n+            s += a[i+0] * b[i+0];\n+            s += a[i+1] * b[i+1];\n+            s += a[i+2] * b[i+2];\n+            s += a[i+3] * b[i+3];\n+\n+            s += a[i+4] & b[i+4];\n+            s += a[i+5] & b[i+5];\n+            s += a[i+6] & b[i+6];\n+            s += a[i+7] & b[i+7];\n+        }\n+        return new Object[]{ a, b, new int[]{ s } };\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_I,  \"> 0\",\n+                  IRNode.MUL_VI,         \"> 0\",\n+                  IRNode.POPULATE_INDEX, \"> 0\"},\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n+    \/\/ Index Populate:\n+    \/\/ There can be an issue when all the (iv + 1), (iv + 2), ...\n+    \/\/ get packed, but not (iv). Then we have a pack that is one element\n+    \/\/ too short, and we start splitting everything in a bad way.\n+    static Object[] test7a(int[] a, int[] b) {\n+        for (int i = 0; i < RANGE; i++) {\n+            a[i] = b[i] * i;\n+        }\n+        return new Object[]{ a, b };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestSplitPacks.java","additions":766,"deletions":0,"binary":false,"changes":766,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -293,1 +293,2 @@\n-        counts = {IRNode.STORE_VECTOR, \">0\"})\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.MUL_VS, \">0\"}) \/\/ expect maximum size\n@@ -304,2 +305,4 @@\n-    \/\/ Note that this case cannot be vectorized due to data dependence.\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ Data dependency at distance 2: restrict vector size to 2\n+    @IR(applyIfCPUFeatureOr = {\"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.MUL_VS, IRNode.VECTOR_SIZE_2, \">0\"}) \/\/ size 2 only\n@@ -357,2 +360,4 @@\n-    \/\/ Note that this case cannot be vectorized due to data dependence.\n-    @IR(failOn = {IRNode.STORE_VECTOR})\n+    \/\/ Data dependency at distance 4: restrict vector size to 4\n+    @IR(applyIfCPUFeatureOr = {\"asimd\", \"true\", \"sse2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\",\n+                  IRNode.OR_VB, IRNode.VECTOR_SIZE_4, \">0\"}) \/\/ size 4 only\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/LoopArrayIndexComputeTest.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"}]}