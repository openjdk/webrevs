{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,0 +119,4 @@\n+    if (CDSConfig::is_dumping_dynamic_archive()) {\n+      \/\/ This is difficult to handle. See JDK-8374639\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2162,1 +2162,0 @@\n-    DynamicArchive::setup_array_klasses();\n","filename":"src\/hotspot\/share\/cds\/aotMetaspace.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -987,2 +987,0 @@\n-\n-  DynamicArchive::make_array_klasses_shareable();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+#include \"oops\/array.hpp\"\n@@ -98,1 +99,0 @@\n-  void gather_array_klasses();\n@@ -135,1 +135,0 @@\n-    gather_array_klasses();\n@@ -162,1 +161,0 @@\n-      DynamicArchive::dump_array_klasses();\n@@ -178,2 +176,0 @@\n-    DynamicArchive::post_dump();\n-\n@@ -188,24 +184,0 @@\n-    iterate_primitive_array_klasses(it);\n-  }\n-\n-  void iterate_primitive_array_klasses(MetaspaceClosure* it) {\n-    for (int i = T_BOOLEAN; i <= T_LONG; i++) {\n-      assert(is_java_primitive((BasicType)i), \"sanity\");\n-      Klass* k = Universe::typeArrayKlass((BasicType)i);  \/\/ this give you \"[I\", etc\n-      assert(AOTMetaspace::in_aot_cache_static_region((void*)k),\n-        \"one-dimensional primitive array should be in static archive\");\n-      ArrayKlass* ak = ArrayKlass::cast(k);\n-      while (ak != nullptr && ak->in_aot_cache()) {\n-        Klass* next_k = ak->array_klass_or_null();\n-        if (next_k != nullptr) {\n-          ak = ArrayKlass::cast(next_k);\n-        } else {\n-          ak = nullptr;\n-        }\n-      }\n-      if (ak != nullptr) {\n-        assert(ak->dimension() > 1, \"sanity\");\n-        \/\/ this is the lowest dimension that's not in the static archive\n-        it->push(&ak);\n-      }\n-    }\n@@ -370,20 +342,0 @@\n-void DynamicArchiveBuilder::gather_array_klasses() {\n-  for (int i = 0; i < klasses()->length(); i++) {\n-    if (klasses()->at(i)->is_objArray_klass()) {\n-      ObjArrayKlass* oak = ObjArrayKlass::cast(klasses()->at(i));\n-      Klass* elem = oak->element_klass();\n-      if (AOTMetaspace::in_aot_cache_static_region(elem)) {\n-        \/\/ Only capture the array klass whose element_klass is in the static archive.\n-        \/\/ During run time, setup (see DynamicArchive::setup_array_klasses()) is needed\n-        \/\/ so that the element_klass can find its array klasses from the dynamic archive.\n-        DynamicArchive::append_array_klass(oak);\n-      } else {\n-        \/\/ The element_klass and its array klasses are in the same archive.\n-        assert(!AOTMetaspace::in_aot_cache_static_region(oak),\n-          \"we should not gather klasses that are already in the static archive\");\n-      }\n-    }\n-  }\n-  log_debug(aot)(\"Total array klasses gathered for dynamic archive: %d\", DynamicArchive::num_array_klasses());\n-}\n-\n@@ -406,5 +358,0 @@\n-\/\/ _array_klasses and _dynamic_archive_array_klasses only hold the array klasses\n-\/\/ which have element klass in the static archive.\n-GrowableArray<ObjArrayKlass*>* DynamicArchive::_array_klasses = nullptr;\n-Array<ObjArrayKlass*>* DynamicArchive::_dynamic_archive_array_klasses = nullptr;\n-\n@@ -414,62 +361,0 @@\n-  soc->do_ptr(&_dynamic_archive_array_klasses);\n-}\n-\n-void DynamicArchive::append_array_klass(ObjArrayKlass* ak) {\n-  if (_array_klasses == nullptr) {\n-    _array_klasses = new (mtClassShared) GrowableArray<ObjArrayKlass*>(50, mtClassShared);\n-  }\n-  _array_klasses->append(ak);\n-}\n-\n-void DynamicArchive::dump_array_klasses() {\n-  assert(CDSConfig::is_dumping_dynamic_archive(), \"sanity\");\n-  if (_array_klasses != nullptr) {\n-    ArchiveBuilder* builder = ArchiveBuilder::current();\n-    int num_array_klasses = _array_klasses->length();\n-    _dynamic_archive_array_klasses =\n-        ArchiveBuilder::new_ro_array<ObjArrayKlass*>(num_array_klasses);\n-    for (int i = 0; i < num_array_klasses; i++) {\n-      builder->write_pointer_in_buffer(_dynamic_archive_array_klasses->adr_at(i), _array_klasses->at(i));\n-    }\n-  }\n-}\n-\n-void DynamicArchive::setup_array_klasses() {\n-  if (_dynamic_archive_array_klasses != nullptr) {\n-    for (int i = 0; i < _dynamic_archive_array_klasses->length(); i++) {\n-      ObjArrayKlass* oak = _dynamic_archive_array_klasses->at(i);\n-      Klass* elm = oak->element_klass();\n-      assert(AOTMetaspace::in_aot_cache_static_region((void*)elm), \"must be\");\n-\n-      if (elm->is_instance_klass()) {\n-        assert(InstanceKlass::cast(elm)->array_klasses() == nullptr, \"must be\");\n-        InstanceKlass::cast(elm)->set_array_klasses(oak);\n-      } else {\n-        assert(elm->is_array_klass(), \"sanity\");\n-        assert(ArrayKlass::cast(elm)->higher_dimension() == nullptr, \"must be\");\n-        ArrayKlass::cast(elm)->set_higher_dimension(oak);\n-      }\n-    }\n-    log_debug(aot)(\"Total array klasses read from dynamic archive: %d\", _dynamic_archive_array_klasses->length());\n-  }\n-}\n-\n-void DynamicArchive::make_array_klasses_shareable() {\n-  if (_array_klasses != nullptr) {\n-    int num_array_klasses = _array_klasses->length();\n-    for (int i = 0; i < num_array_klasses; i++) {\n-      ObjArrayKlass* k = ArchiveBuilder::current()->get_buffered_addr(_array_klasses->at(i));\n-      k->remove_unshareable_info();\n-    }\n-  }\n-}\n-\n-void DynamicArchive::post_dump() {\n-  if (_array_klasses != nullptr) {\n-    delete _array_klasses;\n-    _array_klasses = nullptr;\n-  }\n-}\n-\n-int DynamicArchive::num_array_klasses() {\n-  return _array_klasses != nullptr ? _array_klasses->length() : 0;\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":2,"deletions":117,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-#include \"classfile\/compactHashtable.hpp\"\n@@ -31,3 +30,0 @@\n-#include \"memory\/memRegion.hpp\"\n-#include \"oops\/array.hpp\"\n-#include \"oops\/oop.hpp\"\n@@ -35,1 +31,0 @@\n-#include \"utilities\/growableArray.hpp\"\n@@ -62,3 +57,0 @@\n-private:\n-  static GrowableArray<ObjArrayKlass*>* _array_klasses;\n-  static Array<ObjArrayKlass*>* _dynamic_archive_array_klasses;\n@@ -71,3 +63,0 @@\n-  static void dump_array_klasses();\n-  static void setup_array_klasses();\n-  static void append_array_klass(ObjArrayKlass* oak);\n@@ -75,3 +64,0 @@\n-  static void make_array_klasses_shareable();\n-  static void post_dump();\n-  static int  num_array_klasses();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8374639\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/lib\n+ * @build DynamicDumpWithAOTLinkedStaticArchive jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar TestApp\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. DynamicDumpWithAOTLinkedStaticArchive\n+ *\/\n+\n+import jdk.test.lib.cds.SimpleCDSAppTester;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class DynamicDumpWithAOTLinkedStaticArchive {\n+    public static void main(String... args) throws Exception {\n+        SimpleCDSAppTester.of(\"DynamicDumpWithAOTLinkedStaticArchive\")\n+            .classpath(\"app.jar\")\n+            .appCommandLine(\"TestApp\")\n+            .setGenerateBaseArchive(true)\n+            .setBaseArchiveOptions(\"-XX:+AOTClassLinking\")\n+            .setProductionChecker((OutputAnalyzer out) -> {\n+                    out.shouldContain(\"HelloWorld\");\n+                })\n+            .runDynamicWorkflow();\n+    }\n+}\n+\n+class TestApp {\n+    public static void main(String[] args) {\n+        System.out.println(\"HelloWorld\");\n+        System[][][] x = new System[0][0][0];\n+        System.out.println(x);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/DynamicDumpWithAOTLinkedStaticArchive.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary handling of the existence of InstanceKlass::array_klasses()\n- * @requires vm.cds\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n- *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n- * @build ArrayKlassesApp\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar ArrayKlasses.jar ArrayKlassesApp\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. ArrayKlasses\n- *\/\n-\n-import jdk.test.lib.helpers.ClassFileInstaller;\n-\n-public class ArrayKlasses extends DynamicArchiveTestBase {\n-    public static void main(String[] args) throws Exception {\n-        runTest(ArrayKlasses::test);\n-    }\n-\n-    static void test() throws Exception {\n-        String topArchiveName = getNewArchiveName();\n-        final String appJar = ClassFileInstaller.getJarPath(\"ArrayKlasses.jar\");\n-        final String mainClass = \"ArrayKlassesApp\";\n-        final String runtimeLogOptions =\n-            \"-Xlog:class+load,class+load+array=debug,cds+dynamic=debug,cds=debug,aot+unshareable=trace\";\n-\n-        \/\/ Case 1\n-        \/\/ Create a dynamic archive with the ArrayKlassesApp app class and its\n-        \/\/ array classes.\n-        dump2(null, topArchiveName,\n-              \"-Xlog:cds+dynamic=debug,cds+class=debug\",\n-              \"-cp\", appJar, mainClass)\n-              .assertNormalExit(output -> {\n-                     output.shouldMatch(\"cds.class.*klasses.*array \\\\[LArrayKlassesApp;\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[LArrayKlassesApp;\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[LArrayKlassesApp;\");\n-                 });\n-\n-        \/\/ Case 1\n-        \/\/ At runtime , the ArrayKlasesApp and its array class should be loaded\n-        \/\/ from the dynamic archive.\n-        run2(null, topArchiveName, runtimeLogOptions,\n-             \"-cp\", appJar, mainClass)\n-             .assertNormalExit(output -> {\n-                     output.shouldContain(\"ArrayKlassesApp source: shared objects file (top)\")\n-                           .shouldContain(\"restore: ArrayKlassesApp with class loader: jdk.internal.loader.ClassLoaders$AppClassLoader\")\n-                           .shouldContain(\"[LArrayKlassesApp; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [LArrayKlassesApp; with class loader: jdk.internal.loader.ClassLoaders$AppClassLoader\")\n-                           .shouldContain(\"[[LArrayKlassesApp; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[LArrayKlassesApp; with class loader: jdk.internal.loader.ClassLoaders$AppClassLoader\")\n-                           .shouldContain(\"[[[LArrayKlassesApp; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[[LArrayKlassesApp; with class loader: jdk.internal.loader.ClassLoaders$AppClassLoader\")\n-                           .shouldHaveExitValue(0);\n-                 });\n-\n-        \/\/ Case 2\n-        \/\/ Create a dynamic archive with the array classes of java\/util\/Date which\n-        \/\/ is in the default CDS archive.\n-        topArchiveName = getNewArchiveName();\n-        dump2(null, topArchiveName,\n-              \"-Xlog:class+load,cds+dynamic=debug,cds+class=debug\",\n-              \"-cp\", appJar, mainClass, \"system\")\n-              .assertNormalExit(output -> {\n-                     output.shouldContain(\"java.util.Date source: shared objects file\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[Ljava.util.Date;\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[Ljava.util.Date;\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[Ljava.util.Date;\");\n-                 });\n-\n-        \/\/ Case 2\n-        \/\/ At runtime, the java\/util\/Date class should be loaded from the default\n-        \/\/ CDS archive; its array class should be loaded from the dynamic archive.\n-        run2(null, topArchiveName, runtimeLogOptions,\n-             \"-cp\", appJar, mainClass, \"system\")\n-             .assertNormalExit(output -> {\n-                     output.shouldContain(\"java.util.Date source: shared objects file\")\n-                           .shouldContain(\"restore: java.util.Date with class loader: boot\")\n-                           .shouldContain(\"[Ljava.util.Date; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [Ljava.util.Date; with class loader: boot\")\n-                           .shouldContain(\"[[Ljava.util.Date; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[Ljava.util.Date; with class loader: boot\")\n-                           .shouldContain(\"[[[Ljava.util.Date; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[[Ljava.util.Date; with class loader: boot\")\n-                           .shouldHaveExitValue(0);\n-                 });\n-\n-        \/\/ Case 3\n-        \/\/ Create a dynamic archive with primitive arrays [[J and [[[J with [J\n-        \/\/ already in the default CDS archive\n-        topArchiveName = getNewArchiveName();\n-        dump2(null, topArchiveName,\n-              \"-Xlog:class+load,cds+dynamic=debug,cds+class=debug\",\n-              \"-cp\", appJar, mainClass, \"primitive\")\n-              .assertNormalExit(output -> {\n-                     output.shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[J\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[J\");\n-                 });\n-\n-        \/\/ Case 3\n-        \/\/ At runtime, the [J should be loaded from the default CDS archive;\n-        \/\/ the higher-dimension array should be loaded from the dynamic archive.\n-        run2(null, topArchiveName, runtimeLogOptions,\n-             \"-cp\", appJar, mainClass, \"primitive\")\n-             .assertNormalExit(output -> {\n-                     output.shouldContain(\"[J source: shared objects file\")\n-                           .shouldContain(\"restore: [J with class loader: boot\")\n-                           .shouldContain(\"[[J source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[J with class loader: boot\")\n-                           .shouldContain(\"[[[J source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[[J with class loader: boot\")\n-                           .shouldHaveExitValue(0);\n-                 });\n-\n-        \/\/ Case 4\n-        \/\/ Create a dynamic archive with 2-, 3- and 4-dimension arrays of java\/lang\/Integer.\n-        \/\/ The java\/lang\/Integer class and the 1-dimension array is in the default archive.\n-        topArchiveName = getNewArchiveName();\n-        dump2(null, topArchiveName,\n-              \"-Xlog:class+load,cds+dynamic=debug,cds+class=debug\",\n-              \"-cp\", appJar, mainClass, \"integer-array\")\n-              .assertNormalExit(output -> {\n-                     output.shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[Ljava.lang.Integer;\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[Ljava.lang.Integer;\")\n-                           .shouldMatch(\"cds.class.*klasses.*array \\\\[\\\\[\\\\[\\\\[Ljava.lang.Integer;\");\n-                 });\n-\n-        \/\/ Case 4\n-        \/\/ At runtime, the 4-dimension array of java\/lang\/Integer should be\n-        \/\/ loaded from the dynamic archive.\n-        run2(null, topArchiveName, runtimeLogOptions,\n-             \"-cp\", appJar, mainClass, \"integer-array\")\n-             .assertNormalExit(output -> {\n-                     output.shouldContain(\"java.lang.Integer source: shared objects file\")\n-                           .shouldContain(\"restore: java.lang.Integer with class loader: boot\")\n-                           .shouldContain(\"restore: [Ljava.lang.Integer; with class loader: boot\")\n-                           .shouldContain(\"[[Ljava.lang.Integer; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[Ljava.lang.Integer; with class loader: boot\")\n-                           .shouldContain(\"[[[Ljava.lang.Integer; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[[Ljava.lang.Integer; with class loader: boot\")\n-                           .shouldContain(\"[[[[Ljava.lang.Integer; source: shared objects file (top)\")\n-                           .shouldContain(\"restore: [[[[Ljava.lang.Integer; with class loader: boot\")\n-                           .shouldHaveExitValue(0);\n-                 });\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArrayKlasses.java","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import java.lang.reflect.Array;\n-import java.util.Date;\n-\n-public class ArrayKlassesApp {\n-    public static void main(String args[]) {\n-        if (args.length == 1) {\n-            if (args[0].equals(\"system\")) {\n-                Date[][][] array = new Date[1][2][2];\n-                int count = 0;\n-                for (int i=0; i<1; i++) {\n-                    for (int j=0; j<2; j++) {\n-                        for (int k=0; k<2; k++) {\n-                            array[i][j][k] = new Date();\n-                            count++;\n-                            array[i][j][k].setTime(20000 * count);\n-                        }\n-                    }\n-                }\n-            } else if (args[0].equals(\"primitive\")) {\n-                long[][][] larray = new long[1][2][2];\n-                long lcount = 0;\n-                for (int i=0; i<1; i++) {\n-                    for (int j=0; j<2; j++) {\n-                        for (int k=0; k<2; k++) {\n-                            lcount++;\n-                            larray[i][j][k] = lcount;\n-                        }\n-                    }\n-                }\n-            } else if (args[0].equals(\"integer-array\")) {\n-                Integer[][][][] iarray = new Integer[4][4][4][4];\n-                int count = 0;\n-                for (int i = 0; i < 4; i++) {\n-                    for (int j = 0; j < 4; j++) {\n-                        for (int k = 0; k < 4; k++) {\n-                            for (int l = 0; l < 4; l++) {\n-                                count++;\n-                                iarray[i][j][k][l] = new Integer(count);\n-                            }\n-                        }\n-                    }\n-                }\n-                System.out.println(iarray);\n-                System.out.println(iarray.getClass());\n-            }\n-        } else {\n-            Object x = Array.newInstance(ArrayKlassesApp.class, 3,3,3);\n-            System.out.println(x);\n-            System.out.println(x.getClass());\n-            System.out.println(Array.getLength(x));\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/ArrayKlassesApp.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,0 +60,2 @@\n+    private boolean generateBaseArchive = false;\n+    private String[] baseArchiveOptions = new String[0];\n@@ -346,1 +348,1 @@\n-        if (wb.isSharingEnabled()) {\n+        if (wb.isSharingEnabled() && !generateBaseArchive) {\n@@ -359,0 +361,1 @@\n+                opts.addSuffix(baseArchiveOptions);\n@@ -367,0 +370,10 @@\n+    public CDSAppTester setGenerateBaseArchive(boolean b) {\n+        this.generateBaseArchive = b;\n+        return this;\n+    }\n+\n+    public CDSAppTester setBaseArchiveOptions(String... opts) {\n+        this.baseArchiveOptions = opts;\n+        return this;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,1 @@\n+    private Tester tester;\n@@ -64,0 +65,1 @@\n+        this.tester = new Tester(name);\n@@ -104,0 +106,10 @@\n+    public SimpleCDSAppTester setGenerateBaseArchive(boolean b) {\n+        tester.setGenerateBaseArchive(b);\n+        return this;\n+    }\n+\n+    public SimpleCDSAppTester setBaseArchiveOptions(String... opts) {\n+        tester.setBaseArchiveOptions(opts);\n+        return this;\n+    }\n+\n@@ -184,1 +196,6 @@\n-        (new Tester(name)).runStaticWorkflow();\n+        tester.runStaticWorkflow();\n+        return this;\n+    }\n+\n+    public SimpleCDSAppTester runDynamicWorkflow() throws Exception {\n+        tester.runDynamicWorkflow();\n@@ -189,1 +206,1 @@\n-        (new Tester(name)).runAOTWorkflow();\n+        tester.runAOTWorkflow();\n@@ -194,1 +211,1 @@\n-        (new Tester(name)).run(args);\n+        tester.run(args);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/SimpleCDSAppTester.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"}]}