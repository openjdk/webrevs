{"files":[{"patch":"@@ -79,0 +79,9 @@\n+      case Op_VectorLoadShuffle:\n+      case Op_VectorRearrange:\n+        \/\/ vlen >= 4 is required, because min vector size for byte is 4 on riscv,\n+        \/\/ VectorLoadShuffle is from byte to X, so it requires vlen >= 4.\n+        \/\/ VectorRearrange depends on VectorLoadShuffle, so it also requires vlen >= 4.\n+        if (vlen < 4) {\n+          return false;\n+        }\n+        break;\n@@ -3558,0 +3567,35 @@\n+\/\/ ------------------------------ Vector shuffle -------------------------------\n+\n+instruct loadshuffleB(vReg dst) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_BYTE);\n+  match(Set dst (VectorLoadShuffle dst));\n+  format %{ \"loadshuffleB $dst, $dst\" %}\n+  ins_encode %{\n+    \/\/ For T_BYTE, no need to do anything\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct loadshuffleX(vReg dst, vReg src) %{\n+  predicate(Matcher::vector_element_basic_type(n) == T_DOUBLE ||\n+            Matcher::vector_element_basic_type(n) == T_LONG ||\n+            Matcher::vector_element_basic_type(n) == T_FLOAT ||\n+            Matcher::vector_element_basic_type(n) == T_INT ||\n+            Matcher::vector_element_basic_type(n) == T_SHORT);\n+  match(Set dst (VectorLoadShuffle src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"loadshuffleX $dst, $src\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    __ vsetvli_helper(bt, Matcher::vector_length(this));\n+    if (bt == T_SHORT) {\n+      __ vzext_vf2(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+    } else if (bt == T_FLOAT || bt == T_INT) {\n+      __ vzext_vf4(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+    } else { \/\/ bt == T_DOUBLE || bt == T_LONG\n+      __ vzext_vf8(as_VectorRegister($dst$$reg), as_VectorRegister($src$$reg));\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"}]}