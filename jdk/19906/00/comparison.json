{"files":[{"patch":"@@ -59,0 +59,1 @@\n+import java.util.Arrays;\n@@ -98,3 +99,1 @@\n-        private static final MethodHandle NULL_CHECK;\n-        private static final MethodHandle IS_ZERO;\n-        private static final MethodHandle MAPPED_ENUM_LOOKUP;\n+        private static final MethodHandle MAPPED_ENUM_SWITCH;\n@@ -104,7 +103,3 @@\n-                NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\",\n-                                               MethodType.methodType(boolean.class, Object.class));\n-                IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\",\n-                                               MethodType.methodType(boolean.class, int.class));\n-                MAPPED_ENUM_LOOKUP = LOOKUP.findStatic(SwitchBootstraps.class, \"mappedEnumLookup\",\n-                                                       MethodType.methodType(int.class, Enum.class, MethodHandles.Lookup.class,\n-                                                                             Class.class, EnumDesc[].class, EnumMap.class));\n+                MAPPED_ENUM_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"mappedEnumSwitch\",\n+                                                       MethodType.methodType(int.class, Enum.class, int.class, MethodHandles.Lookup.class,\n+                                                                             Class.class, EnumDesc[].class, MappedEnumCache.class));\n@@ -214,4 +209,0 @@\n-    private static boolean isZero(int value) {\n-        return value == 0;\n-    }\n-\n@@ -292,1 +283,1 @@\n-        boolean constantsOnly = Stream.of(labels).allMatch(l -> enumClass.isAssignableFrom(EnumDesc.class));\n+        boolean constantsOnly = Stream.of(labels).allMatch(l -> EnumDesc.class.isAssignableFrom(l.getClass()));\n@@ -299,7 +290,3 @@\n-            MethodHandle body =\n-                    MethodHandles.guardWithTest(MethodHandles.dropArguments(StaticHolders.NULL_CHECK, 0, int.class),\n-                                                MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),\n-                                                MethodHandles.guardWithTest(MethodHandles.dropArguments(StaticHolders.IS_ZERO, 1, Object.class),\n-                                                                            generateTypeSwitch(lookup, invocationType.parameterType(0), labels),\n-                                                                            MethodHandles.insertArguments(StaticHolders.MAPPED_ENUM_LOOKUP, 1, lookup, enumClass, labels, new EnumMap())));\n-            target = MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);\n+            EnumDesc<?>[] enumDescLabels =\n+                    Arrays.copyOf(labels, labels.length, EnumDesc[].class);\n+            target = MethodHandles.insertArguments(StaticHolders.MAPPED_ENUM_SWITCH, 2, lookup, enumClass, enumDescLabels, new MappedEnumCache());\n@@ -334,8 +321,4 @@\n-    private static <T extends Enum<T>> int mappedEnumLookup(T value, MethodHandles.Lookup lookup, Class<T> enumClass, EnumDesc<?>[] labels, EnumMap enumMap) {\n-        if (enumMap.map == null) {\n-            T[] constants = SharedSecrets.getJavaLangAccess().getEnumConstantsShared(enumClass);\n-            int[] map = new int[constants.length];\n-            int ordinal = 0;\n-\n-            for (T constant : constants) {\n-                map[ordinal] = labels.length;\n+    private static <T extends Enum<T>> int mappedEnumSwitch(T value, int restartIndex, MethodHandles.Lookup lookup, Class<T> enumClass, EnumDesc<?>[] labels, MappedEnumCache enumCache) throws Throwable {\n+        if (value == null) {\n+            return -1;\n+        }\n@@ -343,4 +326,13 @@\n-                for (int i = 0; i < labels.length; i++) {\n-                    if (Objects.equals(labels[i].constantName(), constant.name())) {\n-                        map[ordinal] = i;\n-                        break;\n+        if (restartIndex != 0) {\n+            MethodHandle generatedSwitch = enumCache.generatedSwitch;\n+            if (generatedSwitch == null) {\n+                synchronized (enumCache) {\n+                    generatedSwitch = enumCache.generatedSwitch;\n+\n+                    if (generatedSwitch == null) {\n+                        generatedSwitch =\n+                                generateTypeSwitch(lookup, enumClass, labels)\n+                                        .asType(MethodType.methodType(int.class,\n+                                                                      enumClass,\n+                                                                      int.class));\n+                        enumCache.generatedSwitch = generatedSwitch;\n@@ -349,0 +341,10 @@\n+            }\n+\n+            return (int) generatedSwitch.invoke(value, restartIndex);\n+        }\n+\n+        int[] constantsMap = enumCache.constantsMap;\n+\n+        if (constantsMap == null) {\n+            synchronized (enumCache) {\n+                constantsMap = enumCache.constantsMap;\n@@ -350,1 +352,22 @@\n-                ordinal++;\n+                if (constantsMap == null) {\n+                    T[] constants = SharedSecrets.getJavaLangAccess()\n+                                                 .getEnumConstantsShared(enumClass);\n+                    constantsMap = new int[constants.length];\n+                    int ordinal = 0;\n+\n+                    for (T constant : constants) {\n+                        constantsMap[ordinal] = labels.length;\n+\n+                        for (int i = 0; i < labels.length; i++) {\n+                            if (Objects.equals(labels[i].constantName(),\n+                                               constant.name())) {\n+                                constantsMap[ordinal] = i;\n+                                break;\n+                            }\n+                        }\n+\n+                        ordinal++;\n+                    }\n+\n+                    enumCache.constantsMap = constantsMap;\n+                }\n@@ -353,1 +376,2 @@\n-        return enumMap.map[value.ordinal()];\n+\n+        return constantsMap[value.ordinal()];\n@@ -398,1 +422,3 @@\n-    private static final class EnumMap {\n+    private static final class MappedEnumCache {\n+        @Stable\n+        public volatile int[] constantsMap;\n@@ -400,1 +426,1 @@\n-        public int[] map;\n+        public volatile MethodHandle generatedSwitch;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":64,"deletions":38,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.runtime;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(3)\n+public class SwitchEnum {\n+\n+    public E[] inputs;\n+    @Setup\n+    public void setup() {\n+        inputs = E.values();\n+    }\n+\n+    @Benchmark\n+    public int enumSwitchWithBootstrap() {\n+        int sum = 0;\n+        for (E e : inputs) {\n+            sum += switch (e) {\n+                case null -> -1;\n+                case E0 -> 10;\n+                case E1 -> 11;\n+                case E2 -> 12;\n+                case E3 -> 13;\n+                case E4 -> 14;\n+                case E5 -> 15;\n+                case E6 -> 16;\n+                case E7 -> 17;\n+                case E8 -> 18;\n+                case E9 -> 19;\n+                default -> 17;\n+            };\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int enumSwitchTraditional() {\n+        int sum = 0;\n+        for (E e : inputs) {\n+            sum += switch (e) {\n+                case E0 -> 10;\n+                case E1 -> 11;\n+                case E2 -> 12;\n+                case E3 -> 13;\n+                case E4 -> 14;\n+                case E5 -> 15;\n+                case E6 -> 16;\n+                case E7 -> 17;\n+                case E8 -> 18;\n+                case E9 -> 19;\n+                default -> 17;\n+            };\n+        }\n+        return sum;\n+    }\n+\n+    public static void main(String[] args) {\n+        SwitchEnum s = new SwitchEnum();\n+        s.setup();\n+        System.out.println(s.enumSwitchWithBootstrap());\n+        System.out.println(s.enumSwitchTraditional());\n+    }\n+\n+    enum E {\n+        E0, E1, E2, E3, E4, E5, E6, E7, E8, E9;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/runtime\/SwitchEnum.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"}]}