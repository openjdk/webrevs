{"files":[{"patch":"@@ -67,1 +67,1 @@\n-  VMATree::TreapNode* prev = nullptr;\n+  const VMATree::TNode* prev = nullptr;\n@@ -69,2 +69,2 @@\n-  VMATree::TreapNode* broken_start = nullptr;\n-  VMATree::TreapNode* broken_end = nullptr;\n+  const VMATree::TNode* broken_start = nullptr;\n+  const VMATree::TNode* broken_end = nullptr;\n@@ -72,1 +72,1 @@\n-  file->_tree.visit_in_order([&](VMATree::TreapNode* current) {\n+  file->_tree.visit_in_order([&](const VMATree::TNode* current) {\n","filename":"src\/hotspot\/share\/nmt\/memoryFileTracker.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,447 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_NMT_NMTTREAP_HPP\n-#define SHARE_NMT_NMTTREAP_HPP\n-\n-#include \"runtime\/os.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/macros.hpp\"\n-#include \"utilities\/powerOfTwo.hpp\"\n-#include <type_traits>\n-\n-\/\/ A Treap is a self-balanced binary tree where each node is equipped with a\n-\/\/ priority. It adds the invariant that the priority of a parent P is strictly larger\n-\/\/ larger than the priority of its children. When priorities are randomly\n-\/\/ assigned the tree is balanced.\n-\/\/ All operations are defined through merge and split, which are each other's inverse.\n-\/\/ merge(left_treap, right_treap) => treap where left_treap <= right_treap\n-\/\/ split(treap, key) => (left_treap, right_treap)  where left_treap <= right_treap\n-\/\/ Recursion is used in these, but the depth of the call stack is the depth of\n-\/\/ the tree which is O(log n) so we are safe from stack overflow.\n-\/\/ TreapNode has LEQ nodes on the left, GT nodes on the right.\n-\/\/\n-\/\/ COMPARATOR must have a static function `cmp(a,b)` which returns:\n-\/\/     - an int < 0 when a < b\n-\/\/     - an int == 0 when a == b\n-\/\/     - an int > 0 when a > b\n-\/\/ ALLOCATOR must check for oom and exit, as Treap currently does not handle the allocation\n-\/\/ failing.\n-\n-template<typename K, typename V, typename COMPARATOR, typename ALLOCATOR>\n-class Treap {\n-  friend class NMTVMATreeTest;\n-  friend class NMTTreapTest;\n-  friend class VMTWithVMATreeTest;\n-public:\n-  class TreapNode {\n-    friend Treap;\n-    uint64_t _priority;\n-    const K _key;\n-    V _value;\n-\n-    TreapNode* _left;\n-    TreapNode* _right;\n-\n-  public:\n-    TreapNode(const K& k, uint64_t p) : _priority(p), _key(k), _left(nullptr), _right(nullptr) {}\n-\n-    TreapNode(const K& k, const V& v, uint64_t p)\n-      : _priority(p),\n-        _key(k),\n-        _value(v),\n-        _left(nullptr),\n-        _right(nullptr) {\n-    }\n-\n-    const K& key() const { return _key; }\n-    V& val() { return _value; }\n-\n-    TreapNode* left() const { return _left; }\n-    TreapNode* right() const { return _right; }\n-  };\n-\n-private:\n-  ALLOCATOR _allocator;\n-  TreapNode* _root;\n-\n-  \/\/ A random number\n-  static constexpr const uint64_t _initial_seed = 0xC8DD2114AE0543A3;\n-  uint64_t _prng_seed;\n-  int _node_count;\n-\n-  uint64_t prng_next() {\n-    uint64_t first_half = os::next_random(_prng_seed);\n-    uint64_t second_half = os::next_random(_prng_seed >> 32);\n-    _prng_seed = first_half | (second_half << 32);\n-    return _prng_seed;\n-  }\n-\n-  struct node_pair {\n-    TreapNode* left;\n-    TreapNode* right;\n-  };\n-\n-  enum SplitMode {\n-    LT, \/\/ <\n-    LEQ \/\/ <=\n-  };\n-\n-  \/\/ Split tree at head into two trees, SplitMode decides where EQ values go.\n-  \/\/ We have SplitMode because it makes remove() trivial to implement.\n-  static node_pair split(TreapNode* head, const K& key, SplitMode mode = LEQ DEBUG_ONLY(COMMA int recur_count = 0)) {\n-    assert(recur_count < 200, \"Call-stack depth should never exceed 200\");\n-\n-    if (head == nullptr) {\n-      return {nullptr, nullptr};\n-    }\n-    if ((COMPARATOR::cmp(head->_key, key) <= 0 && mode == LEQ) || (COMPARATOR::cmp(head->_key, key) < 0 && mode == LT)) {\n-      node_pair p = split(head->_right, key, mode DEBUG_ONLY(COMMA recur_count + 1));\n-      head->_right = p.left;\n-      return node_pair{head, p.right};\n-    } else {\n-      node_pair p = split(head->_left, key, mode DEBUG_ONLY(COMMA recur_count + 1));\n-      head->_left = p.right;\n-      return node_pair{p.left, head};\n-    }\n-  }\n-\n-  \/\/ Invariant: left is a treap whose keys are LEQ to the keys in right.\n-  static TreapNode* merge(TreapNode* left, TreapNode* right DEBUG_ONLY(COMMA int recur_count = 0)) {\n-    assert(recur_count < 200, \"Call-stack depth should never exceed 200\");\n-\n-    if (left == nullptr) return right;\n-    if (right == nullptr) return left;\n-\n-    if (left->_priority > right->_priority) {\n-      \/\/ We need\n-      \/\/      LEFT\n-      \/\/         |\n-      \/\/         RIGHT\n-      \/\/ for the invariant re: priorities to hold.\n-      left->_right = merge(left->_right, right DEBUG_ONLY(COMMA recur_count + 1));\n-      return left;\n-    } else {\n-      \/\/ We need\n-      \/\/         RIGHT\n-      \/\/         |\n-      \/\/      LEFT\n-      \/\/ for the invariant re: priorities to hold.\n-      right->_left = merge(left, right->_left DEBUG_ONLY(COMMA recur_count + 1));\n-      return right;\n-    }\n-  }\n-\n-  static TreapNode* find(TreapNode* node, const K& k DEBUG_ONLY(COMMA int recur_count = 0)) {\n-    if (node == nullptr) {\n-      return nullptr;\n-    }\n-\n-    int key_cmp_k = COMPARATOR::cmp(node->key(), k);\n-\n-    if (key_cmp_k == 0) { \/\/ key EQ k\n-      return node;\n-    }\n-\n-    if (key_cmp_k < 0) { \/\/ key LT k\n-      return find(node->right(), k DEBUG_ONLY(COMMA recur_count + 1));\n-    } else { \/\/ key GT k\n-      return find(node->left(), k DEBUG_ONLY(COMMA recur_count + 1));\n-    }\n-  }\n-\n-#ifdef ASSERT\n-  void verify_self() {\n-    \/\/ A balanced binary search tree should have a depth on the order of log(N).\n-    \/\/ We take the ceiling of log_2(N + 1) * 3 as our maximum bound.\n-    \/\/ For comparison, a RB-tree has a proven max depth of log_2(N + 1) * 2.\n-    const int expected_maximum_depth = ceil(log2i(this->_node_count+1) * 3);\n-    \/\/ Find the maximum depth through DFS and ensure that the priority invariant holds.\n-    int maximum_depth_found = 0;\n-\n-    struct DFS {\n-      int depth;\n-      uint64_t parent_prio;\n-      TreapNode* n;\n-    };\n-    GrowableArrayCHeap<DFS, mtNMT> to_visit;\n-    constexpr const uint64_t positive_infinity = 0xFFFFFFFFFFFFFFFF;\n-\n-    to_visit.push({0, positive_infinity, this->_root});\n-    while (!to_visit.is_empty()) {\n-      DFS head = to_visit.pop();\n-      if (head.n == nullptr) continue;\n-      maximum_depth_found = MAX2(maximum_depth_found, head.depth);\n-\n-      assert(head.parent_prio >= head.n->_priority, \"broken priority invariant\");\n-\n-      to_visit.push({head.depth + 1, head.n->_priority, head.n->left()});\n-      to_visit.push({head.depth + 1, head.n->_priority, head.n->right()});\n-    }\n-    assert(maximum_depth_found - expected_maximum_depth <= 3,\n-           \"depth unexpectedly large for treap of node count %d, was: %d, expected between %d and %d\",\n-           _node_count, maximum_depth_found, expected_maximum_depth - 3, expected_maximum_depth);\n-\n-    \/\/ Visit everything in order, see that the key ordering is monotonically increasing.\n-    TreapNode* last_seen = nullptr;\n-    bool failed = false;\n-    int seen_count = 0;\n-    this->visit_in_order([&](TreapNode* node) {\n-      seen_count++;\n-      if (last_seen == nullptr) {\n-        last_seen = node;\n-        return true;\n-      }\n-      if (COMPARATOR::cmp(last_seen->key(), node->key()) > 0) {\n-        failed = false;\n-      }\n-      last_seen = node;\n-      return true;\n-    });\n-    assert(seen_count == _node_count, \"the number of visited nodes do not match with the number of stored nodes\");\n-    assert(!failed, \"keys was not monotonically strongly increasing when visiting in order\");\n-  }\n-#endif \/\/ ASSERT\n-\n-public:\n-  NONCOPYABLE(Treap);\n-\n-  Treap()\n-  : _allocator(),\n-    _root(nullptr),\n-    _prng_seed(_initial_seed),\n-    _node_count(0) {\n-    static_assert(std::is_trivially_destructible<K>::value, \"must be\");\n-  }\n-\n-  ~Treap() {\n-    this->remove_all();\n-  }\n-\n-  int size() {\n-    return _node_count;\n-  }\n-\n-  void upsert(const K& k, const V& v) {\n-    TreapNode* found = find(_root, k);\n-    if (found != nullptr) {\n-      \/\/ Already exists, update value.\n-      found->_value = v;\n-      return;\n-    }\n-    _node_count++;\n-    \/\/ Doesn't exist, make node\n-    void* node_place = _allocator.allocate(sizeof(TreapNode));\n-    uint64_t prio = prng_next();\n-    TreapNode* node = new (node_place) TreapNode(k, v, prio);\n-\n-    \/\/ (LEQ_k, GT_k)\n-    node_pair split_up = split(this->_root, k);\n-    \/\/ merge(merge(LEQ_k, EQ_k), GT_k)\n-    this->_root = merge(merge(split_up.left, node), split_up.right);\n-  }\n-\n-  void remove(const K& k) {\n-    \/\/ (LEQ_k, GT_k)\n-    node_pair first_split = split(this->_root, k, LEQ);\n-    \/\/ (LT_k, GEQ_k) == (LT_k, EQ_k) since it's from LEQ_k and keys are unique.\n-    node_pair second_split = split(first_split.left, k, LT);\n-\n-    if (second_split.right != nullptr) {\n-      \/\/ The key k existed, we delete it.\n-      _node_count--;\n-      second_split.right->_value.~V();\n-      _allocator.free(second_split.right);\n-    }\n-    \/\/ Merge together everything\n-    _root = merge(second_split.left, first_split.right);\n-  }\n-\n-  \/\/ Delete all nodes.\n-  void remove_all() {\n-    _node_count = 0;\n-    GrowableArrayCHeap<TreapNode*, mtNMT> to_delete;\n-    to_delete.push(_root);\n-\n-    while (!to_delete.is_empty()) {\n-      TreapNode* head = to_delete.pop();\n-      if (head == nullptr) continue;\n-      to_delete.push(head->_left);\n-      to_delete.push(head->_right);\n-      head->_value.~V();\n-      _allocator.free(head);\n-    }\n-    _root = nullptr;\n-  }\n-\n-  TreapNode* closest_leq(const K& key) {\n-    TreapNode* candidate = nullptr;\n-    TreapNode* pos = _root;\n-    while (pos != nullptr) {\n-      int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r == 0) { \/\/ Exact match\n-        candidate = pos;\n-        break; \/\/ Can't become better than that.\n-      }\n-      if (cmp_r < 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_right;\n-      } else if (cmp_r > 0) {\n-        pos = pos->_left;\n-      }\n-    }\n-    return candidate;\n-  }\n-\n-  struct FindResult {\n-    FindResult(TreapNode* node, bool new_node) : node(node), new_node(new_node) {}\n-    TreapNode* const node;\n-    bool const new_node;\n-  };\n-\n-  \/\/ Finds the node for the given k in the tree or inserts a new node with the default constructed value.\n-  FindResult find(const K& k) {\n-    if (TreapNode* found = find(_root, k)) {\n-      return FindResult(found, false);\n-    }\n-    _node_count++;\n-    \/\/ Doesn't exist, make node\n-    void* node_place = _allocator.allocate(sizeof(TreapNode));\n-    uint64_t prio = prng_next();\n-    TreapNode* node = new (node_place) TreapNode(k, prio);\n-\n-    \/\/ (LEQ_k, GT_k)\n-    node_pair split_up = split(this->_root, k);\n-    \/\/ merge(merge(LEQ_k, EQ_k), GT_k)\n-    this->_root = merge(merge(split_up.left, node), split_up.right);\n-    return FindResult(node, true);\n-  }\n-\n-  TreapNode* closest_gt(const K& key) {\n-    TreapNode* candidate = nullptr;\n-    TreapNode* pos = _root;\n-    while (pos != nullptr) {\n-      int cmp_r = COMPARATOR::cmp(pos->key(), key);\n-      if (cmp_r > 0) {\n-        \/\/ Found a match, try to find a better one.\n-        candidate = pos;\n-        pos = pos->_left;\n-      } else if (cmp_r <= 0) {\n-        pos = pos->_right;\n-      }\n-    }\n-    return candidate;\n-  }\n-\n-  struct Range {\n-    TreapNode* start;\n-    TreapNode* end;\n-    Range(TreapNode* start, TreapNode* end)\n-    : start(start), end(end) {}\n-  };\n-\n-  \/\/ Return the range [start, end)\n-  \/\/ where start->key() <= addr < end->key().\n-  \/\/ Failure to find the range leads to start and\/or end being null.\n-  Range find_enclosing_range(K addr) {\n-    TreapNode* start = closest_leq(addr);\n-    TreapNode* end = closest_gt(addr);\n-    return Range(start, end);\n-  }\n-\n-  \/\/ Visit all TreapNodes in ascending key order.\n-  template<typename F>\n-  void visit_in_order(F f) const {\n-    GrowableArrayCHeap<TreapNode*, mtNMT> to_visit;\n-    TreapNode* head = _root;\n-    while (!to_visit.is_empty() || head != nullptr) {\n-      while (head != nullptr) {\n-        to_visit.push(head);\n-        head = head->left();\n-      }\n-      head = to_visit.pop();\n-      if (!f(head)) {\n-        return;\n-      }\n-      head = head->right();\n-    }\n-  }\n-\n-  \/\/ Visit all TreapNodes in ascending order whose keys are in range [from, to).\n-  template<typename F>\n-  void visit_range_in_order(const K& from, const K& to, F f) {\n-    assert(COMPARATOR::cmp(from, to) <= 0, \"from must be less or equal to to\");\n-    GrowableArrayCHeap<TreapNode*, mtNMT> to_visit;\n-    TreapNode* head = _root;\n-    while (!to_visit.is_empty() || head != nullptr) {\n-      while (head != nullptr) {\n-        int cmp_from = COMPARATOR::cmp(head->key(), from);\n-        to_visit.push(head);\n-        if (cmp_from >= 0) {\n-          head = head->left();\n-        } else {\n-          \/\/ We've reached a node which is strictly less than from\n-          \/\/ We don't need to visit any further to the left.\n-          break;\n-        }\n-      }\n-      head = to_visit.pop();\n-      const int cmp_from = COMPARATOR::cmp(head->key(), from);\n-      const int cmp_to = COMPARATOR::cmp(head->key(), to);\n-      if (cmp_from >= 0 && cmp_to < 0) {\n-        if (!f(head)) {\n-          return;\n-        }\n-      }\n-      if (cmp_to < 0) {\n-        head = head->right();\n-      } else {\n-        head = nullptr;\n-      }\n-    }\n-  }\n-};\n-\n-class TreapCHeapAllocator {\n-public:\n-  void* allocate(size_t sz) {\n-    void* allocation = os::malloc(sz, mtNMT);\n-    if (allocation == nullptr) {\n-      vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR, \"treap failed allocation\");\n-    }\n-    return allocation;\n-  }\n-\n-  void free(void* ptr) {\n-    os::free(ptr);\n-  }\n-};\n-\n-template<typename K, typename V, typename COMPARATOR>\n-using TreapCHeap = Treap<K, V, COMPARATOR, TreapCHeapAllocator>;\n-\n-#endif \/\/SHARE_NMT_NMTTREAP_HPP\n","filename":"src\/hotspot\/share\/nmt\/nmtTreap.hpp","additions":0,"deletions":447,"binary":false,"changes":447,"status":"deleted"},{"patch":"@@ -51,2 +51,2 @@\n-  visit_in_order([&](Node* node) {\n-    NodeHelper curr(node);\n+  visit_in_order([&](const Node* node) {\n+    NodeHelper curr(const_cast<Node*>(node));\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  using Node = VMATree::TreapNode;\n+  using Node = VMATree::TNode;\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-  visit_in_order([&](Node* node) {\n-    NodeHelper curr(node);\n+  visit_in_order([&](const Node* node) {\n+    NodeHelper curr(const_cast<Node*>(node));\n","filename":"src\/hotspot\/share\/nmt\/regionsTree.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-void VMATree::update_region(TreapNode* n1, TreapNode* n2, const RequestInfo& req, SummaryDiff& diff) {\n+void VMATree::update_region(TNode* n1, TNode* n2, const RequestInfo& req, SummaryDiff& diff) {\n@@ -264,2 +264,2 @@\n-  VMATreap::Range rA = _tree.find_enclosing_range(_A);\n-  VMATreap::Range rB = _tree.find_enclosing_range(_B);\n+  VMARBTree::Range rA = _tree.find_enclosing_range(_A);\n+  VMARBTree::Range rB = _tree.find_enclosing_range(_B);\n@@ -323,9 +323,9 @@\n-  TreapNode* X = rA.start;\n-  TreapNode* Y = rA.end;\n-  TreapNode* W = rB.start;\n-  TreapNode* U = rB.end;\n-  TreapNode nA{_A, stA, 0}; \/\/ the node that represents A\n-  TreapNode nB{_B, stB, 0}; \/\/ the node that represents B\n-  TreapNode* A = &nA;\n-  TreapNode* B = &nB;\n-  auto upsert_if= [&](TreapNode* node) {\n+  TNode* X = rA.start;\n+  TNode* Y = rA.end;\n+  TNode* W = rB.start;\n+  TNode* U = rB.end;\n+  TNode nA{_A, stA}; \/\/ the node that represents A\n+  TNode nB{_B, stB}; \/\/ the node that represents B\n+  TNode* A = &nA;\n+  TNode* B = &nB;\n+  auto upsert_if= [&](TNode* node) {\n@@ -337,1 +337,1 @@\n-  auto update = [&](TreapNode* n1, TreapNode* n2) {\n+  auto update = [&](TNode* n1, TNode* n2) {\n@@ -340,1 +340,1 @@\n-  auto remove_if = [&](TreapNode* node) -> bool{\n+  auto remove_if = [&](TNode* node) -> bool{\n@@ -350,2 +350,2 @@\n-    TreapNode* prev = nullptr;\n-    _tree.visit_range_in_order(_A + 1, _B + 1, [&](TreapNode* curr) {\n+    TNode* prev = nullptr;\n+    _tree.visit_range_in_order(_A + 1, _B + 1, [&](TNode* curr) {\n@@ -365,1 +365,1 @@\n-  auto update_A = [&](TreapNode* T) {\n+  auto update_A = [&](TNode* T) {\n@@ -653,1 +653,1 @@\n-  visit_in_order([&](TreapNode* current) {\n+  visit_in_order([&](const TNode* current) {\n@@ -663,1 +663,1 @@\n-  auto pos = [](TreapNode* n) { return n->key(); };\n+  auto pos = [](TNode* n) { return n->key(); };\n@@ -667,1 +667,1 @@\n-  VMATreap::Range range(nullptr, nullptr);\n+  VMARBTree::Range range(nullptr, nullptr);\n","filename":"src\/hotspot\/share\/nmt\/vmatree.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"nmt\/nmtTreap.hpp\"\n@@ -35,0 +34,1 @@\n+#include \"utilities\/rbTree.inline.hpp\"\n@@ -196,2 +196,2 @@\n-  using VMATreap = TreapCHeap<position, IntervalChange, PositionComparator>;\n-  using TreapNode = VMATreap::TreapNode;\n+  using VMARBTree = RBTreeCHeap<position, IntervalChange, PositionComparator, mtNMT>;\n+  using TNode = RBNode<position, IntervalChange>;\n@@ -200,1 +200,1 @@\n-  VMATreap _tree;\n+  VMARBTree _tree;\n@@ -202,1 +202,1 @@\n-  static IntervalState& in_state(TreapNode* node) {\n+  static IntervalState& in_state(TNode* node) {\n@@ -206,1 +206,5 @@\n-  static IntervalState& out_state(TreapNode* node) {\n+  static IntervalState& out_state(TNode* node) {\n+    return node->val().out;\n+  }\n+\n+  static const IntervalState& out_state(const TNode* node) {\n@@ -284,1 +288,1 @@\n-  void update_region(TreapNode* n1, TreapNode* n2, const RequestInfo& req, SummaryDiff& diff);\n+  void update_region(TNode* n1, TNode* n2, const RequestInfo& req, SummaryDiff& diff);\n@@ -328,1 +332,1 @@\n-  VMATreap& tree() { return _tree; }\n+  VMARBTree& tree() { return _tree; }\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -71,2 +71,1 @@\n-  auto find_result = _children.find(bci);\n-  IPInlineSite& child = find_result.node->val();\n+  RBTreeCHeap<int, IPInlineSite, Cmp, mtCompiler>::Cursor cursor = _children.cursor(bci);\n@@ -74,4 +73,2 @@\n-  if (find_result.new_node) {\n-    assert(callee != nullptr, \"an inline call is missing in the chain up to the root\");\n-    child.set_source(callee, bci);\n-  } else { \/\/ We already saw a call at this site before\n+  if (cursor.found()) { \/\/ We already saw a call at this site before\n+    IPInlineSite& child = cursor.node()->val();\n@@ -83,0 +80,1 @@\n+    return child;\n@@ -85,1 +83,7 @@\n-  return child;\n+  assert(callee != nullptr, \"an inline call is missing in the chain up to the root\");\n+\n+  RBNode<int, IPInlineSite>* node = _children.allocate_node(bci);\n+  _children.insert_at_cursor(node, cursor);\n+  node->val().set_source(callee, bci);\n+\n+  return node->val();\n","filename":"src\/hotspot\/share\/opto\/printinlining.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"nmt\/nmtTreap.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"utilities\/rbTree.inline.hpp\"\n@@ -80,1 +80,1 @@\n-    TreapCHeap<int, IPInlineSite, Cmp> _children;\n+    RBTreeCHeap<int, IPInlineSite, Cmp, mtCompiler> _children;\n","filename":"src\/hotspot\/share\/opto\/printinlining.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,0 +170,1 @@\n+  friend class NMTVMATreeTest;\n@@ -407,0 +408,1 @@\n+  \/\/ If f returns `true` the iteration continues, otherwise it is stopped at the current node.\n@@ -410,0 +412,3 @@\n+  template <typename F>\n+  void visit_in_order(F f);\n+\n@@ -411,0 +416,1 @@\n+  \/\/ If f returns `true` the iteration continues, otherwise it is stopped at the current node.\n@@ -414,0 +420,3 @@\n+  template <typename F>\n+  void visit_range_in_order(const K &from, const K &to, F f);\n+\n@@ -460,0 +469,6 @@\n+  RBNode<K, V>* allocate_node(const K& key) {\n+    void* node_place = _allocator.allocate(sizeof(RBNode<K, V>));\n+    assert(node_place != nullptr, \"rb-tree allocator must exit on failure\");\n+    return new (node_place) RBNode<K, V>(key);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/rbTree.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  if (_left != nullptr) { \/\/ right subtree exists\n+  if (_left != nullptr) { \/\/ left subtree exists\n@@ -602,1 +602,15 @@\n-    f(node);\n+    if (!f(node)) {\n+      return;\n+    }\n+    node = node->next();\n+  }\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+template <typename F>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::visit_in_order(F f) {\n+  NodeType* node = leftmost();\n+  while (node != nullptr) {\n+    if (!f(node)) {\n+      return;\n+    }\n@@ -621,1 +635,24 @@\n-    f(start);\n+    if (!f(start)) {\n+      return;\n+    }\n+    start = start->next();\n+  }\n+}\n+\n+template <typename K, typename NodeType, typename COMPARATOR>\n+template <typename F>\n+inline void AbstractRBTree<K, NodeType, COMPARATOR>::visit_range_in_order(const K& from, const K& to, F f) {\n+  assert_key_leq(from, to);\n+  if (_root == nullptr) {\n+    return;\n+  }\n+\n+  Cursor cursor_start = cursor(from);\n+  Cursor cursor_end = cursor(to);\n+  NodeType* start = cursor_start.found() ? cursor_start.node() : next(cursor_start).node();\n+  NodeType* end = next(cursor_end).node();\n+\n+  while (start != end) {\n+    if (!f(start)) {\n+      return;\n+    }\n","filename":"src\/hotspot\/share\/utilities\/rbTree.inline.hpp","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1,364 +0,0 @@\n-\/*\n- * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"memory\/resourceArea.hpp\"\n-#include \"nmt\/nmtTreap.hpp\"\n-#include \"nmt\/virtualMemoryTracker.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"unittest.hpp\"\n-class NMTTreapTest : public testing::Test {\n-public:\n-  struct Cmp {\n-    static int cmp(int a, int b) {\n-      return a - b;\n-    }\n-  };\n-\n-  struct CmpInverse {\n-    static int cmp(int a, int b) {\n-      return b - a;\n-    }\n-  };\n-\n-  struct FCmp {\n-    static int cmp(float a, float b) {\n-      if (a < b) return -1;\n-      if (a == b) return 0;\n-      return 1;\n-    }\n-  };\n-\n-#ifdef ASSERT\n-  template<typename K, typename V, typename CMP, typename ALLOC>\n-  void verify_it(Treap<K, V, CMP, ALLOC>& t) {\n-    t.verify_self();\n-  }\n-#endif \/\/ ASSERT\n-\n-public:\n-  void inserting_duplicates_results_in_one_value() {\n-    constexpr const int up_to = 10;\n-    GrowableArrayCHeap<int, mtTest> nums_seen(up_to, up_to, 0);\n-    TreapCHeap<int, int, Cmp> treap;\n-\n-    for (int i = 0; i < up_to; i++) {\n-      treap.upsert(i, i);\n-      treap.upsert(i, i);\n-      treap.upsert(i, i);\n-      treap.upsert(i, i);\n-      treap.upsert(i, i);\n-    }\n-\n-    treap.visit_in_order([&](TreapCHeap<int, int, Cmp>::TreapNode* node) {\n-      nums_seen.at(node->key())++;\n-      return true;\n-    });\n-    for (int i = 0; i < up_to; i++) {\n-      EXPECT_EQ(1, nums_seen.at(i));\n-    }\n-  }\n-\n-  void treap_ought_not_leak() {\n-    struct LeakCheckedAllocator {\n-      int allocations;\n-\n-      LeakCheckedAllocator()\n-        : allocations(0) {\n-      }\n-\n-      void* allocate(size_t sz) {\n-        void* allocation = os::malloc(sz, mtTest);\n-        if (allocation == nullptr) {\n-          vm_exit_out_of_memory(sz, OOM_MALLOC_ERROR, \"treap failed allocation\");\n-        }\n-        ++allocations;\n-        return allocation;\n-      }\n-\n-      void free(void* ptr) {\n-        --allocations;\n-        os::free(ptr);\n-      }\n-    };\n-\n-    constexpr const int up_to = 10;\n-    {\n-      Treap<int, int, Cmp, LeakCheckedAllocator> treap;\n-      for (int i = 0; i < up_to; i++) {\n-        treap.upsert(i, i);\n-      }\n-      EXPECT_EQ(up_to, treap._allocator.allocations);\n-      for (int i = 0; i < up_to; i++) {\n-        treap.remove(i);\n-      }\n-      EXPECT_EQ(0, treap._allocator.allocations);\n-      EXPECT_EQ(nullptr, treap._root);\n-    }\n-\n-    {\n-      Treap<int, int, Cmp, LeakCheckedAllocator> treap;\n-      for (int i = 0; i < up_to; i++) {\n-        treap.upsert(i, i);\n-      }\n-      treap.remove_all();\n-      EXPECT_EQ(0, treap._allocator.allocations);\n-      EXPECT_EQ(nullptr, treap._root);\n-    }\n-  }\n-\n-  void test_find() {\n-    struct Empty {};\n-    TreapCHeap<float, Empty, FCmp> treap;\n-    using Node = TreapCHeap<float, Empty, FCmp>::TreapNode;\n-\n-    Node* n = nullptr;\n-    auto test = [&](float f) {\n-      EXPECT_EQ(nullptr, treap.find(treap._root, f));\n-      treap.upsert(f, Empty{});\n-      Node* n = treap.find(treap._root, f);\n-      EXPECT_NE(nullptr, n);\n-      EXPECT_EQ(f, n->key());\n-    };\n-\n-    test(1.0f);\n-    test(5.0f);\n-    test(0.0f);\n-  }\n-};\n-\n-TEST_VM_F(NMTTreapTest, InsertingDuplicatesResultsInOneValue) {\n-  this->inserting_duplicates_results_in_one_value();\n-}\n-\n-TEST_VM_F(NMTTreapTest, TreapOughtNotLeak) {\n-  this->treap_ought_not_leak();\n-}\n-\n-TEST_VM_F(NMTTreapTest, TestVisitors) {\n-  { \/\/ Tests with 'default' ordering (ascending)\n-    TreapCHeap<int, int, Cmp> treap;\n-    using Node = TreapCHeap<int, int, Cmp>::TreapNode;\n-\n-    treap.visit_range_in_order(0, 100, [&](Node* x) {\n-      EXPECT_TRUE(false) << \"Empty treap has no nodes to visit\";\n-      return true;\n-    });\n-\n-    \/\/ Single-element set\n-    treap.upsert(1, 0);\n-    int count = 0;\n-    treap.visit_range_in_order(0, 100, [&](Node* x) {\n-      count++;\n-      return true;\n-    });\n-    EXPECT_EQ(1, count);\n-\n-    count = 0;\n-    treap.visit_in_order([&](Node* x) {\n-      count++;\n-      return true;\n-    });\n-    EXPECT_EQ(1, count);\n-\n-    \/\/ Add an element outside of the range that should not be visited on the right side and\n-    \/\/ one on the left side.\n-    treap.upsert(101, 0);\n-    treap.upsert(-1, 0);\n-    count = 0;\n-    treap.visit_range_in_order(0, 100, [&](Node* x) {\n-      count++;\n-      return true;\n-    });\n-    EXPECT_EQ(1, count);\n-\n-    count = 0;\n-    treap.visit_in_order([&](Node* x) {\n-      count++;\n-      return true;\n-    });\n-    EXPECT_EQ(3, count);\n-\n-    \/\/ Visiting empty range [0, 0) == {}\n-    treap.upsert(0, 0); \/\/ This node should not be visited.\n-    treap.visit_range_in_order(0, 0, [&](Node* x) {\n-      EXPECT_TRUE(false) << \"Empty visiting range should not visit any node\";\n-      return true;\n-    });\n-\n-    treap.remove_all();\n-    for (int i = 0; i < 11; i++) {\n-      treap.upsert(i, 0);\n-    }\n-\n-    ResourceMark rm;\n-    GrowableArray<int> seen;\n-    treap.visit_range_in_order(0, 10, [&](Node* x) {\n-      seen.push(x->key());\n-      return true;\n-    });\n-    EXPECT_EQ(10, seen.length());\n-    for (int i = 0; i < 10; i++) {\n-      EXPECT_EQ(i, seen.at(i));\n-    }\n-\n-    seen.clear();\n-    treap.visit_in_order([&](Node* x) {\n-      seen.push(x->key());\n-      return true;\n-    });\n-    EXPECT_EQ(11, seen.length());\n-    for (int i = 0; i < 10; i++) {\n-      EXPECT_EQ(i, seen.at(i));\n-    }\n-\n-    seen.clear();\n-    treap.visit_range_in_order(10, 12, [&](Node* x) {\n-      seen.push(x->key());\n-      return true;\n-    });\n-    EXPECT_EQ(1, seen.length());\n-    EXPECT_EQ(10, seen.at(0));\n-  }\n-  { \/\/ Test with descending ordering\n-    TreapCHeap<int, int, CmpInverse> treap;\n-    using Node = TreapCHeap<int, int, CmpInverse>::TreapNode;\n-\n-    for (int i = 0; i < 10; i++) {\n-      treap.upsert(i, 0);\n-    }\n-    ResourceMark rm;\n-    GrowableArray<int> seen;\n-    treap.visit_range_in_order(9, -1, [&](Node* x) {\n-      seen.push(x->key());\n-      return true;\n-    });\n-    EXPECT_EQ(10, seen.length());\n-    for (int i = 0; i < 10; i++) {\n-      EXPECT_EQ(10-i-1, seen.at(i));\n-    }\n-    seen.clear();\n-\n-    treap.visit_in_order([&](Node* x) {\n-      seen.push(x->key());\n-      return true;\n-    });\n-    EXPECT_EQ(10, seen.length());\n-    for (int i = 0; i < 10; i++) {\n-      EXPECT_EQ(10 - i - 1, seen.at(i));\n-    }\n-  }\n-}\n-\n-TEST_VM_F(NMTTreapTest, TestFind) {\n-  test_find();\n-}\n-\n-TEST_VM_F(NMTTreapTest, TestClosestLeq) {\n-  using Node = TreapCHeap<int, int, Cmp>::TreapNode;\n-  {\n-    TreapCHeap<int, int, Cmp> treap;\n-    Node* n = treap.closest_leq(0);\n-    EXPECT_EQ(nullptr, n);\n-\n-    treap.upsert(0, 0);\n-    n = treap.closest_leq(0);\n-    EXPECT_EQ(0, n->key());\n-\n-    treap.upsert(-1, -1);\n-    n = treap.closest_leq(0);\n-    EXPECT_EQ(0, n->key());\n-\n-    treap.upsert(6, 0);\n-    n = treap.closest_leq(6);\n-    EXPECT_EQ(6, n->key());\n-\n-    n = treap.closest_leq(-2);\n-    EXPECT_EQ(nullptr, n);\n-  }\n-}\n-\n-#ifdef ASSERT\n-\n-TEST_VM_F(NMTTreapTest, VerifyItThroughStressTest) {\n-  { \/\/ Repeatedly verify a treap of moderate size\n-    TreapCHeap<int, int, Cmp> treap;\n-    constexpr const int ten_thousand = 10000;\n-    for (int i = 0; i < ten_thousand; i++) {\n-      int r = os::random();\n-      if (r % 2 == 0) {\n-        treap.upsert(i, i);\n-      } else {\n-        treap.remove(i);\n-      }\n-      if (i % 100 == 0) {\n-        verify_it(treap);\n-      }\n-    }\n-    for (int i = 0; i < ten_thousand; i++) {\n-      int r = os::random();\n-      if (r % 2 == 0) {\n-        treap.upsert(i, i);\n-      } else {\n-        treap.remove(i);\n-      }\n-      if (i % 100 == 0) {\n-        verify_it(treap);\n-      }\n-    }\n-  }\n-  { \/\/ Make a very large treap and verify at the end\n-  struct Nothing {};\n-    TreapCHeap<int, Nothing, Cmp> treap;\n-    constexpr const int one_hundred_thousand = 100000;\n-    for (int i = 0; i < one_hundred_thousand; i++) {\n-      treap.upsert(i, Nothing());\n-    }\n-    verify_it(treap);\n-  }\n-}\n-struct NTD {\n-  static bool has_run_destructor;\n-  ~NTD() {\n-    has_run_destructor = true;\n-  }\n-};\n-\n-bool NTD::has_run_destructor = false;\n-\n-TEST_VM_F(NMTTreapTest, ValueDestructorsAreRun) {\n-  TreapCHeap<int, NTD, Cmp> treap;\n-  NTD ntd;\n-  treap.upsert(0, ntd);\n-  treap.remove(0);\n-  EXPECT_TRUE(NTD::has_run_destructor);\n-  NTD::has_run_destructor = false;\n-  {\n-    TreapCHeap<int, NTD, Cmp> treap;\n-    NTD ntd;\n-    treap.upsert(0, ntd);\n-  }\n-  EXPECT_TRUE(NTD::has_run_destructor);\n-}\n-\n-#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_treap.cpp","additions":0,"deletions":364,"binary":false,"changes":364,"status":"deleted"},{"patch":"@@ -34,1 +34,1 @@\n-using TNode = Tree::TreapNode;\n+using TNode = Tree::TNode;\n@@ -57,2 +57,2 @@\n-  VMATree::TreapNode* treap_root(VMATree& tree) {\n-    return tree._tree._root;\n+  VMATree::TNode* rbtree_root(VMATree& tree) {\n+    return static_cast<VMATree::TNode*>(tree._tree._root);\n@@ -61,1 +61,1 @@\n-  VMATree::VMATreap& treap(VMATree& tree) {\n+  VMATree::VMARBTree& rbtree(VMATree& tree) {\n@@ -65,2 +65,2 @@\n-  VMATree::TreapNode* find(VMATree::VMATreap& treap, const VMATree::position key) {\n-    return treap.find(treap._root, key);\n+  VMATree::TNode* find(VMATree::VMARBTree& rbtree, const VMATree::position key) {\n+    return rbtree.find_node(key);\n@@ -74,1 +74,1 @@\n-  VMATree::StateType in_type_of(VMATree::TreapNode* x) {\n+  VMATree::StateType in_type_of(VMATree::TNode* x) {\n@@ -78,1 +78,1 @@\n-  VMATree::StateType out_type_of(VMATree::TreapNode* x) {\n+  VMATree::StateType out_type_of(VMATree::TNode* x) {\n@@ -84,1 +84,1 @@\n-    treap(tree).visit_in_order([&](TNode* x) {\n+    rbtree(tree).visit_in_order([&](TNode* x) {\n@@ -126,1 +126,1 @@\n-    EXPECT_EQ(nullptr, treap_root(tree));\n+    EXPECT_EQ(nullptr, rbtree_root(tree));\n@@ -133,1 +133,1 @@\n-    EXPECT_EQ(nullptr, treap_root(tree));\n+    EXPECT_EQ(nullptr, rbtree_root(tree));\n@@ -143,1 +143,1 @@\n-    treap(tree).visit_in_order([&](TNode* x) {\n+    rbtree(tree).visit_in_order([&](TNode* x) {\n@@ -169,1 +169,1 @@\n-    treap(tree).visit_in_order([&](TNode* x) {\n+    rbtree(tree).visit_in_order([&](TNode* x) {\n@@ -202,1 +202,1 @@\n-    VMATree::TreapNode n1{upd.req.A, {}, 0}, n2{upd.req.B, {}, 0};\n+    VMATree::TNode n1{upd.req.A, {}}, n2{upd.req.B, {}};\n@@ -267,1 +267,1 @@\n-    using Node = VMATree::TreapNode;\n+    using Node = VMATree::TNode;\n@@ -277,1 +277,1 @@\n-      VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(et.nodes[i]);\n+      VMATree::VMARBTree::Range r = tree.tree().find_enclosing_range(et.nodes[i]);\n@@ -357,1 +357,1 @@\n-  VMATree::VMATreap::Range r = tree.tree().find_enclosing_range(110);\n+  VMATree::VMARBTree::Range r = tree.tree().find_enclosing_range(110);\n@@ -372,1 +372,1 @@\n-  tree.visit_in_order([&](TNode* node) {\n+  tree.visit_in_order([&](const TNode* node) {\n@@ -413,1 +413,1 @@\n-    treap(tree).visit_in_order([&](TNode* x) {\n+    rbtree(tree).visit_in_order([&](const TNode* x) {\n@@ -415,1 +415,1 @@\n-      if (x->key() == 0) {\n+      if (x->key() == 0UL) {\n@@ -441,1 +441,1 @@\n-    EXPECT_EQ(nullptr, treap_root(tree));\n+    EXPECT_EQ(nullptr, rbtree_root(tree));\n@@ -451,1 +451,1 @@\n-    treap(tree).visit_range_in_order(0, 99999, [&](TNode* x) {\n+    rbtree(tree).visit_range_in_order(0, 99999, [&](TNode* x) {\n@@ -466,1 +466,1 @@\n-    EXPECT_EQ(nullptr, treap_root(tree));\n+    EXPECT_EQ(nullptr, rbtree_root(tree));\n@@ -468,1 +468,1 @@\n-    EXPECT_EQ(nullptr, treap_root(tree));\n+    EXPECT_EQ(nullptr, rbtree_root(tree));\n@@ -486,1 +486,1 @@\n-    int len = sizeof(expected) \/ sizeof(testrange);\n+    size_t len = sizeof(expected) \/ sizeof(testrange);\n@@ -488,1 +488,1 @@\n-    for (int i = 0; i < len; i++) {\n+    for (size_t i = 0; i < len; i++) {\n@@ -493,1 +493,1 @@\n-      VMATree::VMATreap::Range found = tree.tree().find_enclosing_range(expect.from);\n+      VMATree::VMARBTree::Range found = tree.tree().find_enclosing_range(expect.from);\n@@ -996,2 +996,2 @@\n-        VMATree::VMATreap& treap = this->treap(tree);\n-        VMATree::TreapNode* startn = find(treap, start * page_size);\n+        VMATree::VMARBTree& rbtree = this->rbtree(tree);\n+        VMATree::TNode* startn = find(rbtree, start * page_size);\n@@ -999,1 +999,1 @@\n-        VMATree::TreapNode* endn = find(treap, (end * page_size) + page_size);\n+        VMATree::TNode* endn = find(rbtree, (end * page_size) + page_size);\n","filename":"test\/hotspot\/gtest\/nmt\/test_vmatree.cpp","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+      return true;\n@@ -213,0 +214,1 @@\n+        return true;\n@@ -220,0 +222,1 @@\n+        return true;\n@@ -226,0 +229,1 @@\n+        return true;\n@@ -228,0 +232,5 @@\n+      rbtree.visit_in_order([&](const Node* x) {\n+        count++;\n+        return true;\n+      });\n+      EXPECT_EQ(2, count);\n@@ -236,0 +245,1 @@\n+        return true;\n@@ -238,0 +248,5 @@\n+      rbtree.visit_range_in_order(0, 100, [&](const Node* x) {\n+        count++;\n+        return true;\n+      });\n+      EXPECT_EQ(2, count);\n@@ -242,0 +257,1 @@\n+        return true;\n@@ -244,0 +260,5 @@\n+      rbtree.visit_in_order([&](const Node* x) {\n+        count++;\n+        return true;\n+      });\n+      EXPECT_EQ(6, count);\n@@ -249,0 +270,1 @@\n+        return true;\n@@ -251,0 +273,28 @@\n+      rbtree.visit_range_in_order(0, 0, [&](const Node* x) {\n+        count++;\n+        return true;\n+      });\n+      EXPECT_EQ(2, count);\n+\n+      \/\/ Test exiting visit early\n+      rbtree.remove_all();\n+      for (int i = 0; i < 11; i++) {\n+        rbtree.upsert(i, 0);\n+      }\n+\n+      count = 0;\n+      rbtree_const.visit_in_order([&](const Node* x) {\n+        if (x->key() >= 6) return false;\n+        count++;\n+        return true;\n+      });\n+      EXPECT_EQ(6, count);\n+\n+      count = 0;\n+      rbtree_const.visit_range_in_order(6, 10, [&](const Node* x) {\n+        if (x->key() >= 6) return false;\n+        count++;\n+        return true;\n+      });\n+\n+      EXPECT_EQ(0, count);\n@@ -261,0 +311,1 @@\n+        return true;\n@@ -270,0 +321,1 @@\n+        return true;\n@@ -279,0 +331,1 @@\n+        return true;\n@@ -295,0 +348,1 @@\n+        return true;\n@@ -304,0 +358,1 @@\n+        return true;\n@@ -323,2 +378,4 @@\n-      rbtree.visit_range_in_order(test_case[0], test_case[1], [&](const Node* x) {\n-        FAIL() << \"Range should not visit nodes\";\n+      bool visited = false;\n+      rbtree.visit_range_in_order(test_case[0], test_case[1], [&](const Node* x) -> bool {\n+        visited = true;\n+        return true;\n@@ -326,0 +383,1 @@\n+      EXPECT_FALSE(visited);\n@@ -518,0 +576,1 @@\n+      return true;\n","filename":"test\/hotspot\/gtest\/utilities\/test_rbtree.cpp","additions":61,"deletions":2,"binary":false,"changes":63,"status":"modified"}]}