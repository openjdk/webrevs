{"files":[{"patch":"@@ -48,1 +48,1 @@\n-    SINGLE_KEYWORDS := JOBS TIMEOUT_FACTOR JCOV JCOV_DIFF_CHANGESET, \\\n+    SINGLE_KEYWORDS := JOBS TIMEOUT_FACTOR JCOV JCOV_DIFF_CHANGESET AOT_JDK, \\\n@@ -205,0 +205,1 @@\n+$(eval $(call SetTestOpt,AOT_JDK,JTREG))\n@@ -209,1 +210,1 @@\n-        RETRY_COUNT REPEAT_COUNT MAX_OUTPUT REPORT $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n+        RETRY_COUNT REPEAT_COUNT MAX_OUTPUT REPORT AOT_JDK $(CUSTOM_JTREG_SINGLE_KEYWORDS), \\\n@@ -705,0 +706,52 @@\n+\n+# Parameter 1 is the name of the rule.\n+#\n+# Remaining parameters are named arguments.\n+#   VM_OPTIONS  List of JVM arguments to use when creating AOT cache\n+#\n+#  After calling this, the following variables are defined\n+#   $1_AOT_TARGETS   List of all targets that the test rule will need to depend on\n+#   $1_AOT_JDK_CACHE The AOT cache file to be usd to wun the test with\n+#\n+SetupAot = $(NamedParamsMacroTemplate)\n+define SetupAotBody\n+  $1_AOT_JDK_CONF  := $$($1_TEST_SUPPORT_DIR)\/aot\/jdk.aotconf\n+  $1_AOT_JDK_CACHE := $$($1_TEST_SUPPORT_DIR)\/aot\/jdk.aotcache\n+\n+  $1_JAVA_TOOL_OPTS := $$(addprefix -J, $$($1_VM_OPTIONS))\n+\n+  $$($1_AOT_JDK_CACHE): $$(JDK_IMAGE_DIR)\/release\n+\t$$(call MakeDir, $$($1_TEST_SUPPORT_DIR)\/aot)\n+\t\n+\t$(foreach jtool, javac javap jlink jar, \\\n+\t    $(info AOT: Create cache configuration for $(jtool)) \\\n+\t    $$(call ExecuteWithLog, $$($1_TEST_SUPPORT_DIR)\/aot.$(jtool), ( \\\n+\t        $$(FIXPATH) $(JDK_UNDER_TEST)\/bin\/$(jtool) $$($1_JAVA_TOOL_OPTS) \\\n+\t                    -J-XX:AOTMode=record -J-XX:AOTConfiguration=$$($1_AOT_JDK_CONF).$(jtool) --help \\\n+\t    ))\n+\t)\n+\n+\t$$(info AOT: Copy $(JDK_UNDER_TEST)\/lib\/classlist to $$($1_AOT_JDK_CONF).jdk )\n+\t$$(call ExecuteWithLog, $$($1_TEST_SUPPORT_DIR)\/aot, ( \\\n+\t\t$$(FIXPATH) $(CP) $(JDK_UNDER_TEST)\/lib\/classlist $$($1_AOT_JDK_CONF).jdk \\\n+\t))\n+\n+\t$$(FIXPATH) $$(CAT) $$($1_AOT_JDK_CONF).* > $$($1_AOT_JDK_CONF).temp\n+\t$$(FIXPATH) $$(CAT) $$($1_AOT_JDK_CONF).temp | $(GREP) -v '#' | $(GREP) -v '@' | $(SORT) | \\\n+\t        $(SED) -e 's\/id:.*\/\/g' | uniq \\\n+\t\t> $$($1_AOT_JDK_CONF)\n+\t$$(FIXPATH) $$(CAT) $$($1_AOT_JDK_CONF).temp | $(GREP) '@cp' | $(SORT) \\\n+\t        >> $$($1_AOT_JDK_CONF)\n+\n+\t$$(info AOT: Generate AOT cache $$($1_AOT_JDK_CACHE) with flags: $$($1_VM_OPTIONS))\n+\t$$(call ExecuteWithLog, $$($1_TEST_SUPPORT_DIR)\/aot, ( \\\n+\t\t$$(FIXPATH) $(JDK_UNDER_TEST)\/bin\/java \\\n+\t        $$($1_VM_OPTIONS) -Xlog:cds,cds+class=debug:file=$$($1_AOT_JDK_CACHE).log \\\n+\t\t-XX:AOTMode=create -XX:AOTConfiguration=$$($1_AOT_JDK_CONF) -XX:AOTCache=$$($1_AOT_JDK_CACHE) \\\n+\t))\n+\n+  $1_AOT_TARGETS += $$($1_AOT_JDK_CACHE)\n+\n+endef\n+\n+\n@@ -765,0 +818,1 @@\n+  JTREG_AOT_JDK ?= false\n@@ -894,0 +948,11 @@\n+  ifeq ($$(JTREG_AOT_JDK), true)\n+    $$(info Add AOT target for $1)\n+    $$(eval $$(call SetupAot, $1, VM_OPTIONS := $$(JTREG_ALL_OPTIONS) ))\n+\n+    $$(info AOT_TARGETS=$$($1_AOT_TARGETS))\n+    $$(info AOT_JDK_CACHE=$$($1_AOT_JDK_CACHE))\n+\n+    $1_JTREG_BASIC_OPTIONS += -vmoption:-XX:AOTCache=\"$$($1_AOT_JDK_CACHE)\"\n+  endif\n+\n+\n@@ -909,0 +974,1 @@\n+\t$$(call LogWarn, Clean up dirs for $1)\n@@ -956,1 +1022,1 @@\n-  run-test-$1: pre-run-test clean-outputdirs-$1\n+  run-test-$1: clean-outputdirs-$1 pre-run-test $$($1_AOT_TARGETS)\n","filename":"make\/RunTests.gmk","additions":69,"deletions":3,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -0,0 +1,353 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/aotClassInitializer.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+\n+\/\/ Detector for class names we wish to handle specially.\n+\/\/ It is either an exact string match or a string prefix match.\n+class AOTClassInitializer::AllowedSpec {\n+  const char* _class_name;\n+  bool _is_prefix;\n+  int _len;\n+public:\n+  AllowedSpec(const char* class_name, bool is_prefix = false)\n+    : _class_name(class_name), _is_prefix(is_prefix)\n+  {\n+    _len = (class_name == nullptr) ? 0 : (int)strlen(class_name);\n+  }\n+  const char* class_name() { return _class_name; }\n+\n+  bool matches(Symbol* name, int len) {\n+    assert(_class_name != nullptr, \"caller resp.\");\n+    if (_is_prefix) {\n+      return len >= _len && name->starts_with(_class_name);\n+    } else {\n+      return len == _len && name->equals(_class_name);\n+    }\n+  }\n+};\n+\n+\n+\/\/ Tell if ik has a name that matches one of the given specs.\n+bool AOTClassInitializer::is_allowed(AllowedSpec* specs, InstanceKlass* ik) {\n+  Symbol* name = ik->name();\n+  int len = name->utf8_length();\n+  for (AllowedSpec* s = specs; s->class_name() != nullptr; s++) {\n+    if (s->matches(name, len)) {\n+      \/\/ If a type is included in the tables inside can_archive_initialized_mirror(), we require that\n+      \/\/   - all super classes must be included\n+      \/\/   - all super interfaces that have <clinit> must be included.\n+      \/\/ This ensures that in the production run, we don't run the <clinit> of a supertype but skips\n+      \/\/ ik's <clinit>.\n+      if (ik->java_super() != nullptr) {\n+        DEBUG_ONLY(ResourceMark rm);\n+        assert(AOTClassInitializer::can_archive_initialized_mirror(ik->java_super()),\n+               \"super class %s of %s must be aot-initialized\", ik->java_super()->external_name(),\n+               ik->external_name());\n+      }\n+\n+      Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n+      int len = interfaces->length();\n+      for (int i = 0; i < len; i++) {\n+        InstanceKlass* intf = interfaces->at(i);\n+        if (intf->class_initializer() != nullptr) {\n+          assert(AOTClassInitializer::can_archive_initialized_mirror(intf),\n+                 \"super interface %s (which has <clinit>) of %s must be aot-initialized\", intf->external_name(),\n+                 ik->external_name());\n+        }\n+      }\n+\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\n+bool AOTClassInitializer::can_archive_initialized_mirror(InstanceKlass* ik) {\n+  assert(!ArchiveBuilder::current()->is_in_buffer_space(ik), \"must be source klass\");\n+  if (!CDSConfig::is_initing_classes_at_dump_time()) {\n+    return false;\n+  }\n+\n+  if (!ik->is_initialized()) {\n+    return false;\n+  }\n+\n+  if (ik->is_hidden()) {\n+    return HeapShared::is_archivable_hidden_klass(ik);\n+  }\n+\n+  if (ik->is_enum_subclass()) {\n+    return true;\n+  }\n+\n+  \/\/ About \"static field that may hold a different value\" errors:\n+  \/\/\n+  \/\/ Automatic selection for aot-inited classes\n+  \/\/ ==========================================\n+  \/\/\n+  \/\/ When CDSConfig::is_initing_classes_at_dump_time() is enabled,\n+  \/\/ HeapShared::find_all_aot_initialized_classes() finds the classes of all\n+  \/\/ heap objects that are reachable from HeapShared::_run_time_special_subgraph,\n+  \/\/ and mark these classes as aot-inited. This preserves the initialized\n+  \/\/ mirrors of these classes, and their <clinit> methods are NOT executed\n+  \/\/ at runtime.\n+  \/\/\n+  \/\/ For example, with -XX:+AOTInvokeDynamicLinking, _run_time_special_subgraph\n+  \/\/ will contain some DirectMethodHandle objects. As a result, the DirectMethodHandle\n+  \/\/ class is automatically marked as aot-inited.\n+  \/\/\n+  \/\/ When a class is aot-inited, its static fields are already set up\n+  \/\/ by executing the <clinit> method at AOT assembly time.  Later on\n+  \/\/ in the production run, when the class would normally be\n+  \/\/ initialized, the VM performs guarding and synchronization as if\n+  \/\/ it were going to run the <clinit> again, but instead it simply\n+  \/\/ observes that that class was aot-inited.  The VM assumes that, if\n+  \/\/ it were to run <clinit> again, it would get a semantically\n+  \/\/ equivalent set of final field values, so it just adopts the\n+  \/\/ existing field values (from AOT assembly) and skips the call to\n+  \/\/ <clinit>.  There may at that point be fixups performed by ad hoc\n+  \/\/ code, if the VM recognizes a request in the library.\n+  \/\/\n+  \/\/ It is true that this is not generally correct for all possible\n+  \/\/ Java code.  A <clinit> method might have a side effect beyond\n+  \/\/ initializing the static fields.  It might send an email somewhere\n+  \/\/ noting the current time of day.  In that case, such an email\n+  \/\/ would have been sent during the AOT assembly phase, and the email\n+  \/\/ would NOT be sent again during production.  This is clearly NOT\n+  \/\/ what a user would want, if this were a general purpose facility.\n+  \/\/ But in fact it is only for certain well-behaved classes, which\n+  \/\/ are known NOT to have such side effects.  We know this because\n+  \/\/ the optimization (of skipping <clinit> for aot-init classes) is\n+  \/\/ only applied to classes fully defined by the JDK.\n+  \/\/\n+  \/\/ (A day may come when we figure out how to gracefully extend this\n+  \/\/ optimization to untrusted third parties, but it is not this day.)\n+  \/\/\n+  \/\/ Manual selection\n+  \/\/ ================\n+  \/\/\n+  \/\/ There are important cases where one aot-init class has a side\n+  \/\/ effect on another aot-class, a side effect which is not captured\n+  \/\/ in any static field value in either class.  The simplest example\n+  \/\/ is class A forces the initialization of class B.  In that case,\n+  \/\/ we need to aot-init either both classes or neither.  From looking\n+  \/\/ at the JDK state after AOT assembly is done, it is hard to tell\n+  \/\/ that A \"touched\" B and B might escape our notice.  Another common\n+  \/\/ example is A copying a field value from B.  We don't know where A\n+  \/\/ got the value, but it would be wrong to re-initialize B at\n+  \/\/ startup, while keeping the snapshot of the old B value in A.  In\n+  \/\/ general, if we aot-init A, we need to aot-init every class B that\n+  \/\/ somehow contributed to A's initial state, and every class C that\n+  \/\/ was somehow side-effected by A's initialization.  We say that the\n+  \/\/ aot-init of A is \"init-coupled\" to those of B and C.\n+  \/\/\n+  \/\/ So there are init-coupled classes that cannot be automatically discovered. For\n+  \/\/ example, DirectMethodHandle::IMPL_NAMES points to MethodHandles::IMPL_NAMES,\n+  \/\/ but the MethodHandles class is not automatically marked because there are\n+  \/\/ no archived instances of the MethodHandles type.\n+  \/\/\n+  \/\/ If we aot-initialize DirectMethodHandle, but allow MethodHandles to be\n+  \/\/ initialized at runtime, MethodHandles::IMPL_NAMES will get a different\n+  \/\/ value than DirectMethodHandle::IMPL_NAMES. This *may or may not* be a problem,\n+  \/\/ but to ensure compatibility, we should try to preserve the identity equality\n+  \/\/ of these two fields.\n+  \/\/\n+  \/\/ To do that, we add MethodHandles to the indy_specs[] table below.\n+  \/\/\n+  \/\/ Luckily we do not need to be all-knowing in order to choose which\n+  \/\/ items to add to that table.  We have tools to help detect couplings.\n+  \/\/\n+  \/\/ Automatic validation\n+  \/\/ ====================\n+  \/\/\n+  \/\/ CDSHeapVerifier is used to detect potential problems with identity equality.\n+  \/\/\n+  \/\/ A class B is assumed to be init-coupled to some aot-init class if\n+  \/\/ B has a field which points to a live object X in the AOT heap.\n+  \/\/ The live object X was created by some other class A which somehow\n+  \/\/ used B's reference to X, perhaps with the help of an intermediate\n+  \/\/ class Z.  Or, B pulled the reference to X from some other class\n+  \/\/ Y, and B obtained that reference from Y (or an intermediate Z).\n+  \/\/ It is not certain how X got into the heap, nor whether B\n+  \/\/ contributed it, but it is a good heuristic that B is init-coupled\n+  \/\/ to X's class or some other aot-init class.  In any case, B should\n+  \/\/ be made an aot-init class as well, unless a manual inspection\n+  \/\/ shows that would be a problem.  If there is a problem, then the\n+  \/\/ JDK code for B and\/or X probably needs refactoring.  If there is\n+  \/\/ no problem, we add B to the list.  Typically the same scan will\n+  \/\/ find any other accomplices Y, Z, etc.  One failure would be a\n+  \/\/ class Q whose only initialization action is to scribble a special\n+  \/\/ value into B, from which the value X is derived and then makes\n+  \/\/ its way into the heap.  In that case, the heuristic does not\n+  \/\/ identify Q.  It is (currently) a human responsibility, of JDK\n+  \/\/ engineers, not to write such dirty JDK code, or to repair it if\n+  \/\/ it crops up.  Eventually we may have tools, or even a user mode\n+  \/\/ with design rules and checks, that will vet our code base more\n+  \/\/ automatically.\n+  \/\/\n+  \/\/ To see how the tool detects the problem with MethodHandles::IMPL_NAMES:\n+  \/\/\n+  \/\/ - Comment out all the lines in indy_specs[] except the {nullptr} line.\n+  \/\/ - Rebuild the JDK\n+  \/\/\n+  \/\/ Then run the following:\n+  \/\/    java -XX:AOTMode=record -XX:AOTConfiguration=jc.aotconfig com.sun.tools.javac.Main\n+  \/\/    java -XX:AOTMode=create -Xlog:cds -XX:AOTCache=jc.aot -XX:AOTConfiguration=jc.aotconfig\n+  \/\/\n+  \/\/ You will see an error like this:\n+  \/\/\n+  \/\/ Archive heap points to a static field that may hold a different value at runtime:\n+  \/\/ Field: java\/lang\/invoke\/MethodHandles::IMPL_NAMES\n+  \/\/ Value: java.lang.invoke.MemberName$Factory\n+  \/\/ {0x000000060e906ae8} - klass: 'java\/lang\/invoke\/MemberName$Factory' - flags:\n+  \/\/\n+  \/\/  - ---- fields (total size 2 words):\n+  \/\/ --- trace begin ---\n+  \/\/ [ 0] {0x000000060e8deeb0} java.lang.Class (java.lang.invoke.DirectMethodHandle::IMPL_NAMES)\n+  \/\/ [ 1] {0x000000060e906ae8} java.lang.invoke.MemberName$Factory\n+  \/\/ --- trace end ---\n+  \/\/\n+  \/\/ Trouble-shooting\n+  \/\/ ================\n+  \/\/\n+  \/\/ If you see a \"static field that may hold a different value\" error, it's probably\n+  \/\/ because you've made some changes in the JDK core libraries (most likely\n+  \/\/ java.lang.invoke).\n+  \/\/\n+  \/\/  - Did you add a new static field to a class that could be referenced by\n+  \/\/    cached object instances of MethodType, MethodHandle, etc? You may need\n+  \/\/    to add that class to indy_specs[].\n+  \/\/  - Did you modify the <clinit> of the classes in java.lang.invoke such that\n+  \/\/    a static field now points to an object that should not be cached (e.g.,\n+  \/\/    a native resource such as a file descriptior, or a Thread)?\n+  \/\/\n+  \/\/ Note that these potential problems only occur when one class gets\n+  \/\/ the aot-init treatment, AND another class is init-coupled to it,\n+  \/\/ AND the coupling is not detected.  Currently there are a number\n+  \/\/ classes that get the aot-init treatment, in java.lang.invoke\n+  \/\/ because of invokedynamic.  They are few enough for now to be\n+  \/\/ manually tracked.  There may be more in the future.\n+\n+  \/\/ IS_PREFIX means that we match all class names that start with a\n+  \/\/ prefix.  Otherwise, it is an exact match, of just one class name.\n+  const bool IS_PREFIX = true;\n+\n+  {\n+    static AllowedSpec specs[] = {\n+      \/\/ everybody's favorite super\n+      {\"java\/lang\/Object\"},\n+\n+      \/\/ above we selected all enums; we must include their super as well\n+      {\"java\/lang\/Enum\"},\n+     {nullptr}\n+    };\n+    if (is_allowed(specs, ik)) {\n+      return true;\n+    }\n+  }\n+\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ This table was created with the help of CDSHeapVerifier.\n+    \/\/ Also, some $Holder classes are needed. E.g., Invokers.<clinit> explicitly\n+    \/\/ initializes Invokers$Holder. Since Invokers.<clinit> won't be executed\n+    \/\/ at runtime, we need to make sure Invokers$Holder is also aot-inited.\n+    \/\/\n+    \/\/ We hope we can reduce the size of this list over time, and move\n+    \/\/ the responsibility for identifying such classes into the JDK\n+    \/\/ code itself.  See tracking RFE JDK-8342481.\n+    static AllowedSpec indy_specs[] = {\n+      {\"java\/lang\/constant\/ConstantDescs\"},\n+      {\"java\/lang\/constant\/DynamicConstantDesc\"},\n+      {\"java\/lang\/invoke\/BoundMethodHandle\"},\n+      {\"java\/lang\/invoke\/BoundMethodHandle$Specializer\"},\n+      {\"java\/lang\/invoke\/BoundMethodHandle$Species_\", IS_PREFIX},\n+      {\"java\/lang\/invoke\/ClassSpecializer\"},\n+      {\"java\/lang\/invoke\/ClassSpecializer$\", IS_PREFIX},\n+      {\"java\/lang\/invoke\/DelegatingMethodHandle\"},\n+      {\"java\/lang\/invoke\/DelegatingMethodHandle$Holder\"},     \/\/ UNSAFE.ensureClassInitialized()\n+      {\"java\/lang\/invoke\/DirectMethodHandle\"},\n+      {\"java\/lang\/invoke\/DirectMethodHandle$Constructor\"},\n+      {\"java\/lang\/invoke\/DirectMethodHandle$Holder\"},         \/\/ UNSAFE.ensureClassInitialized()\n+      {\"java\/lang\/invoke\/Invokers\"},\n+      {\"java\/lang\/invoke\/Invokers$Holder\"},                   \/\/ UNSAFE.ensureClassInitialized()\n+      {\"java\/lang\/invoke\/LambdaForm\"},\n+      {\"java\/lang\/invoke\/LambdaForm$Holder\"},                 \/\/ UNSAFE.ensureClassInitialized()\n+      {\"java\/lang\/invoke\/LambdaForm$NamedFunction\"},\n+      {\"java\/lang\/invoke\/MethodHandle\"},\n+      {\"java\/lang\/invoke\/MethodHandles\"},\n+      {\"java\/lang\/invoke\/SimpleMethodHandle\"},\n+      {\"java\/util\/Collections\"},\n+      {\"java\/util\/stream\/Collectors\"},\n+      {\"jdk\/internal\/constant\/PrimitiveClassDescImpl\"},\n+      {\"jdk\/internal\/constant\/ReferenceClassDescImpl\"},\n+\n+    \/\/ Can't include this, as it will pull in MethodHandleStatics which has many environment\n+    \/\/ dependencies (on system properties, etc).\n+    \/\/ MethodHandleStatics is an example of a class that must NOT get the aot-init treatment,\n+    \/\/ because of its strong reliance on (a) final fields which are (b) environmentally determined.\n+    \/\/{\"java\/lang\/invoke\/InvokerBytecodeGenerator\"},\n+\n+      {nullptr}\n+    };\n+    if (is_allowed(indy_specs, ik)) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+\/\/ TODO: currently we have a hard-coded list. We should turn this into\n+\/\/ an annotation: @jdk.internal.vm.annotation.RuntimeSetupRequired\n+\/\/ See JDK-8342481.\n+bool AOTClassInitializer::is_runtime_setup_required(InstanceKlass* ik) {\n+  return ik == vmClasses::Class_klass() ||\n+         ik == vmClasses::internal_Unsafe_klass() ||\n+         ik == vmClasses::ConcurrentHashMap_klass();\n+}\n+\n+void AOTClassInitializer::call_runtime_setup(InstanceKlass* ik, TRAPS) {\n+  assert(ik->has_aot_initialized_mirror(), \"sanity\");\n+  if (ik->is_runtime_setup_required()) {\n+    if (log_is_enabled(Info, cds, init)) {\n+      ResourceMark rm;\n+      log_info(cds, init)(\"Calling %s::runtimeSetup()\", ik->external_name());\n+    }\n+    JavaValue result(T_VOID);\n+    JavaCalls::call_static(&result, ik,\n+                           vmSymbols::runtimeSetup(),\n+                           vmSymbols::void_method_signature(), CHECK);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.cpp","additions":353,"deletions":0,"binary":false,"changes":353,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTCLASSINITIALIZER_HPP\n+#define SHARE_CDS_AOTCLASSINITIALIZER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+\n+class InstanceKlass;\n+\n+class AOTClassInitializer : AllStatic {\n+  class AllowedSpec;\n+  static bool is_allowed(AllowedSpec* specs, InstanceKlass* ik);\n+\n+public:\n+  \/\/ Called by heapShared.cpp to see if src_ik->java_mirror() can be archived in\n+  \/\/ the initialized state.\n+  static bool can_archive_initialized_mirror(InstanceKlass* src_ik);\n+\n+  static bool is_runtime_setup_required(InstanceKlass* ik);\n+  static void call_runtime_setup(InstanceKlass* ik, TRAPS);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTCLASSINITIALIZER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotClassInitializer.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,315 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/aotClassLinker.hpp\"\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n+#include \"cds\/aotLinkedClassTable.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/archiveUtils.inline.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"cds\/lambdaFormInvokers.inline.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/dictionary.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/constantPool.inline.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+\n+AOTClassLinker::ClassesTable* AOTClassLinker::_vm_classes = nullptr;\n+AOTClassLinker::ClassesTable* AOTClassLinker::_candidates = nullptr;\n+GrowableArrayCHeap<InstanceKlass*, mtClassShared>* AOTClassLinker::_sorted_candidates = nullptr;\n+\n+#ifdef ASSERT\n+bool AOTClassLinker::is_initialized() {\n+  assert(CDSConfig::is_dumping_archive(), \"AOTClassLinker is for CDS dumping only\");\n+  return _vm_classes != nullptr;\n+}\n+#endif\n+\n+void AOTClassLinker::initialize() {\n+  assert(!is_initialized(), \"sanity\");\n+\n+  _vm_classes = new (mtClass)ClassesTable();\n+  _candidates = new (mtClass)ClassesTable();\n+  _sorted_candidates = new GrowableArrayCHeap<InstanceKlass*, mtClassShared>(1000);\n+\n+  for (auto id : EnumRange<vmClassID>{}) {\n+    add_vm_class(vmClasses::klass_at(id));\n+  }\n+\n+  assert(is_initialized(), \"sanity\");\n+\n+  AOTConstantPoolResolver::initialize();\n+}\n+\n+void AOTClassLinker::dispose() {\n+  assert(is_initialized(), \"sanity\");\n+\n+  delete _vm_classes;\n+  delete _candidates;\n+  delete _sorted_candidates;\n+  _vm_classes = nullptr;\n+  _candidates = nullptr;\n+  _sorted_candidates = nullptr;\n+\n+  assert(!is_initialized(), \"sanity\");\n+\n+  AOTConstantPoolResolver::dispose();\n+}\n+\n+bool AOTClassLinker::is_vm_class(InstanceKlass* ik) {\n+  assert(is_initialized(), \"sanity\");\n+  return (_vm_classes->get(ik) != nullptr);\n+}\n+\n+void AOTClassLinker::add_vm_class(InstanceKlass* ik) {\n+  assert(is_initialized(), \"sanity\");\n+  bool created;\n+  _vm_classes->put_if_absent(ik, &created);\n+  if (created) {\n+    if (CDSConfig::is_dumping_aot_linked_classes()) {\n+      bool v = try_add_candidate(ik);\n+      assert(v, \"must succeed for VM class\");\n+    }\n+    InstanceKlass* super = ik->java_super();\n+    if (super != nullptr) {\n+      add_vm_class(super);\n+    }\n+    Array<InstanceKlass*>* ifs = ik->local_interfaces();\n+    for (int i = 0; i < ifs->length(); i++) {\n+      add_vm_class(ifs->at(i));\n+    }\n+  }\n+}\n+\n+bool AOTClassLinker::is_candidate(InstanceKlass* ik) {\n+  return (_candidates->get(ik) != nullptr);\n+}\n+\n+void AOTClassLinker::add_candidate(InstanceKlass* ik) {\n+  _candidates->put_when_absent(ik, true);\n+  _sorted_candidates->append(ik);\n+\n+  if (log_is_enabled(Info, cds, aot, link)) {\n+    ResourceMark rm;\n+    log_info(cds, aot, link)(\"%s %s %p\", class_category_name(ik), ik->external_name(), ik);\n+  }\n+}\n+\n+\/\/ ik is a candidate for aot-linking; see if it can really work\n+\/\/ that way, and return success or failure.  Not only must ik itself\n+\/\/ look like a class we can preload but its supers must also be\n+\/\/ aot-linkable.\n+bool AOTClassLinker::try_add_candidate(InstanceKlass* ik) {\n+  assert(is_initialized(), \"sanity\");\n+  assert(CDSConfig::is_dumping_aot_linked_classes(), \"sanity\");\n+\n+  if (!SystemDictionaryShared::is_builtin(ik)) {\n+    \/\/ not loaded by a class loader which we know about\n+    return false;\n+  }\n+\n+  if (is_candidate(ik)) { \/\/ already checked.\n+    return true;\n+  }\n+\n+  if (ik->is_hidden()) {\n+    assert(ik->shared_class_loader_type() != ClassLoader::OTHER, \"must have been set\");\n+    if (!CDSConfig::is_dumping_invokedynamic()) {\n+      return false;\n+    }\n+    if (!SystemDictionaryShared::should_hidden_class_be_archived(ik)) {\n+      return false;\n+    }\n+    if (HeapShared::is_lambda_proxy_klass(ik)) {\n+      InstanceKlass* nest_host = ik->nest_host_not_null();\n+      if (!try_add_candidate(nest_host)) {\n+        ResourceMark rm;\n+        log_warning(cds, aot, link)(\"%s cannot be aot-linked because it nest host is not aot-linked\", ik->external_name());\n+        return false;\n+      }\n+    }\n+  }\n+\n+  InstanceKlass* s = ik->java_super();\n+  if (s != nullptr && !try_add_candidate(s)) {\n+    return false;\n+  }\n+\n+  Array<InstanceKlass*>* interfaces = ik->local_interfaces();\n+  int num_interfaces = interfaces->length();\n+  for (int index = 0; index < num_interfaces; index++) {\n+    InstanceKlass* intf = interfaces->at(index);\n+    if (!try_add_candidate(intf)) {\n+      return false;\n+    }\n+  }\n+\n+  add_candidate(ik);\n+\n+  return true;\n+}\n+\n+void AOTClassLinker::add_candidates() {\n+  assert_at_safepoint();\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+    for (GrowableArrayIterator<Klass*> it = klasses->begin(); it != klasses->end(); ++it) {\n+      Klass* k = *it;\n+      if (k->is_instance_klass()) {\n+        try_add_candidate(InstanceKlass::cast(k));\n+      }\n+    }\n+  }\n+}\n+\n+void AOTClassLinker::write_to_archive() {\n+  assert(is_initialized(), \"sanity\");\n+  assert_at_safepoint();\n+\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    AOTLinkedClassTable* table = AOTLinkedClassTable::get(CDSConfig::is_dumping_static_archive());\n+    table->set_boot(write_classes(nullptr, true));\n+    table->set_boot2(write_classes(nullptr, false));\n+    table->set_platform(write_classes(SystemDictionary::java_platform_loader(), false));\n+    table->set_app(write_classes(SystemDictionary::java_system_loader(), false));\n+  }\n+}\n+\n+Array<InstanceKlass*>* AOTClassLinker::write_classes(oop class_loader, bool is_javabase) {\n+  ResourceMark rm;\n+  GrowableArray<InstanceKlass*> list;\n+\n+  for (int i = 0; i < _sorted_candidates->length(); i++) {\n+    InstanceKlass* ik = _sorted_candidates->at(i);\n+    if (ik->class_loader() != class_loader) {\n+      continue;\n+    }\n+    if ((ik->module() == ModuleEntryTable::javabase_moduleEntry()) != is_javabase) {\n+      continue;\n+    }\n+\n+    if (ik->is_shared() && CDSConfig::is_dumping_dynamic_archive()) {\n+      if (CDSConfig::is_using_aot_linked_classes()) {\n+        \/\/ This class was recorded as AOT-linked for the base archive,\n+        \/\/ so there's no need to do so again for the dynamic archive.\n+      } else {\n+        list.append(ik);\n+      }\n+    } else {\n+      list.append(ArchiveBuilder::current()->get_buffered_addr(ik));\n+    }\n+  }\n+\n+  if (list.length() == 0) {\n+    return nullptr;\n+  } else {\n+    const char* category = class_category_name(list.at(0));\n+    log_info(cds, aot, link)(\"wrote %d class(es) for category %s\", list.length(), category);\n+    return ArchiveUtils::archive_array(&list);\n+  }\n+}\n+\n+int AOTClassLinker::num_platform_initiated_classes() {\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    \/\/ AOTLinkedClassBulkLoader will initiate loading of all public boot classes in the platform loader.\n+    return count_public_classes(nullptr);\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+int AOTClassLinker::num_app_initiated_classes() {\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    \/\/ AOTLinkedClassBulkLoader will initiate loading of all public boot\/platform classes in the app loader.\n+    return count_public_classes(nullptr) + count_public_classes(SystemDictionary::java_platform_loader());\n+  } else {\n+    return 0;\n+  }\n+}\n+\n+int AOTClassLinker::count_public_classes(oop loader) {\n+  int n = 0;\n+  for (int i = 0; i < _sorted_candidates->length(); i++) {\n+    InstanceKlass* ik = _sorted_candidates->at(i);\n+    if (ik->is_public() && !ik->is_hidden() && ik->class_loader() == loader) {\n+      n++;\n+    }\n+  }\n+\n+  return n;\n+}\n+\n+\/\/ Used in logging: \"boot1\", \"boot2\", \"plat\", \"app\" and \"unreg\", or \"array\"\n+const char* AOTClassLinker::class_category_name(Klass* k) {\n+  if (ArchiveBuilder::is_active() && ArchiveBuilder::current()->is_in_buffer_space(k)) {\n+    k = ArchiveBuilder::current()->get_source_addr(k);\n+  }\n+\n+  if (k->is_array_klass()) {\n+    return \"array\";\n+  } else {\n+    oop loader = k->class_loader();\n+    if (loader == nullptr) {\n+      if (k->module() != nullptr &&\n+          k->module()->name() != nullptr &&\n+          k->module()->name()->equals(\"java.base\")) {\n+        return \"boot1\"; \/\/ boot classes in java.base are loaded in the 1st phase\n+      } else {\n+        return \"boot2\"; \/\/ boot classes outside of java.base are loaded in the 2nd phase phase\n+      }\n+    } else {\n+      if (loader == SystemDictionary::java_platform_loader()) {\n+        return \"plat\";\n+      } else if (loader == SystemDictionary::java_system_loader()) {\n+        return \"app\";\n+      } else {\n+        return \"unreg\";\n+      }\n+    }\n+  }\n+}\n+\n+const char* AOTClassLinker::class_category_name(AOTLinkedClassCategory category) {\n+  switch (category) {\n+  case AOTLinkedClassCategory::BOOT1:\n+    return \"boot1\";\n+  case AOTLinkedClassCategory::BOOT2:\n+    return \"boot2\";\n+  case AOTLinkedClassCategory::PLATFORM:\n+    return \"plat\";\n+  case AOTLinkedClassCategory::APP:\n+    return \"app\";\n+  case AOTLinkedClassCategory::UNREGISTERED:\n+  default:\n+      return \"unreg\";\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":315,"deletions":0,"binary":false,"changes":315,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTCLASSLINKER_HPP\n+#define SHARE_CDS_AOTCLASSLINKER_HPP\n+\n+#include \"interpreter\/bytecodes.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class AOTLinkedClassTable;\n+class InstanceKlass;\n+class SerializeClosure;\n+template <typename T> class Array;\n+enum class AOTLinkedClassCategory : int;\n+\n+\/\/ AOTClassLinker is used during the AOTCache Assembly Phase.\n+\/\/ It links eligible classes before they are written into the AOTCache\n+\/\/\n+\/\/ The classes linked by AOTClassLinker are recorded in an AOTLinkedClassTable,\n+\/\/ which is also written into the AOTCache.\n+\/\/\n+\/\/ AOTClassLinker is enabled by the -XX:+AOTClassLinking option. If this option\n+\/\/ is disabled, an empty AOTLinkedClassTable will be included in the AOTCache.\n+\/\/\n+\/\/ For each class C in the AOTLinkedClassTable, the following properties for C\n+\/\/ are assigned by AOTClassLinker and cannot be changed thereafter.\n+\/\/     - The CodeSource for C\n+\/\/     - The bytecodes in C\n+\/\/     - The supertypes of C\n+\/\/     - The ClassLoader, Package and Module of C\n+\/\/     - The visibility of C\n+\/\/\n+\/\/ During a production run, the JVM can use an AOTCache with an AOTLinkedClassTable\n+\/\/ only if it's guaranteed to produce the same results for the above set of properties\n+\/\/ for each class C in the AOTLinkedClassTable.\n+\/\/\n+\/\/ For example,\n+\/\/     - C may be loaded from a different CodeSource when the CLASSPATH is changed.\n+\/\/     - Some JVMTI agent may allow the bytecodes of C to be modified.\n+\/\/     - C may be made invisible by module options such as --add-modules\n+\/\/ In such situations, the JVM will refuse to load the AOTCache.\n+\/\/\n+class AOTClassLinker :  AllStatic {\n+  static const int TABLE_SIZE = 15889; \/\/ prime number\n+  using ClassesTable = ResourceHashtable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared>;\n+\n+  \/\/ Classes loaded inside vmClasses::resolve_all()\n+  static ClassesTable* _vm_classes;\n+\n+  \/\/ Classes that should be automatically loaded into system dictionary at VM start-up\n+  static ClassesTable* _candidates;\n+\n+  \/\/ Sorted list such that super types come first.\n+  static GrowableArrayCHeap<InstanceKlass*, mtClassShared>* _sorted_candidates;\n+\n+  DEBUG_ONLY(static bool is_initialized());\n+\n+  static void add_vm_class(InstanceKlass* ik);\n+  static void add_candidate(InstanceKlass* ik);\n+\n+  static Array<InstanceKlass*>* write_classes(oop class_loader, bool is_javabase);\n+  static int count_public_classes(oop loader);\n+\n+public:\n+  static void initialize();\n+  static void add_candidates();\n+  static void write_to_archive();\n+  static void dispose();\n+\n+  \/\/ Is this class resolved as part of vmClasses::resolve_all()?\n+  static bool is_vm_class(InstanceKlass* ik);\n+\n+  \/\/ When CDS is enabled, is ik guaranteed to be linked at deployment time (and\n+  \/\/ cannot be replaced by JVMTI, etc)?\n+  \/\/ This is a necessary (but not sufficient) condition for keeping a direct pointer\n+  \/\/ to ik in AOT-computed data (such as ConstantPool entries in archived classes,\n+  \/\/ or in AOT-compiled code).\n+  static bool is_candidate(InstanceKlass* ik);\n+\n+  \/\/ Request that ik be added to the candidates table. This will return true only if\n+  \/\/ ik is allowed to be aot-linked.\n+  static bool try_add_candidate(InstanceKlass* ik);\n+\n+  static int num_app_initiated_classes();\n+  static int num_platform_initiated_classes();\n+\n+  \/\/ Used in logging: \"boot1\", \"boot2\", \"plat\", \"app\" and \"unreg\";\n+  static const char* class_category_name(AOTLinkedClassCategory category);\n+  static const char* class_category_name(Klass* k);\n+};\n+\n+\/\/ AOT-linked classes are divided into different categories and are loaded\n+\/\/ in two phases during the production run.\n+enum class AOTLinkedClassCategory : int {\n+  BOOT1,       \/\/ Only java.base classes are loaded in the 1st phase\n+  BOOT2,       \/\/ All boot classes that not in java.base are loaded in the 2nd phase\n+  PLATFORM,    \/\/ Classes for platform loader, loaded in the 2nd phase\n+  APP,         \/\/ Classes for the app loader, loaded in the 2nd phase\n+  UNREGISTERED \/\/ classes loaded outside of the boot\/platform\/app loaders; currently not supported by AOTClassLinker\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTCLASSLINKER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.hpp","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,573 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/aotClassLinker.hpp\"\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"interpreter\/bytecodeStream.hpp\"\n+#include \"interpreter\/interpreterRuntime.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/constantPool.inline.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+\n+AOTConstantPoolResolver::ClassesTable* AOTConstantPoolResolver::_processed_classes = nullptr;\n+\n+void AOTConstantPoolResolver::initialize() {\n+  assert(_processed_classes == nullptr, \"must be\");\n+  _processed_classes = new (mtClass)ClassesTable();\n+}\n+\n+void AOTConstantPoolResolver::dispose() {\n+  assert(_processed_classes != nullptr, \"must be\");\n+  delete _processed_classes;\n+  _processed_classes = nullptr;\n+}\n+\n+\/\/ Returns true if we CAN PROVE that cp_index will always resolve to\n+\/\/ the same information at both dump time and run time. This is a\n+\/\/ necessary (but not sufficient) condition for pre-resolving cp_index\n+\/\/ during CDS archive assembly.\n+bool AOTConstantPoolResolver::is_resolution_deterministic(ConstantPool* cp, int cp_index) {\n+  assert(!is_in_archivebuilder_buffer(cp), \"sanity\");\n+\n+  if (cp->tag_at(cp_index).is_klass()) {\n+    \/\/ We require cp_index to be already resolved. This is fine for now, are we\n+    \/\/ currently archive only CP entries that are already resolved.\n+    Klass* resolved_klass = cp->resolved_klass_at(cp_index);\n+    return resolved_klass != nullptr && is_class_resolution_deterministic(cp->pool_holder(), resolved_klass);\n+  } else if (cp->tag_at(cp_index).is_invoke_dynamic()) {\n+    return is_indy_resolution_deterministic(cp, cp_index);\n+  } else if (cp->tag_at(cp_index).is_field() ||\n+             cp->tag_at(cp_index).is_method() ||\n+             cp->tag_at(cp_index).is_interface_method()) {\n+    int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+    if (!cp->tag_at(klass_cp_index).is_klass()) {\n+      \/\/ Not yet resolved\n+      return false;\n+    }\n+    Klass* k = cp->resolved_klass_at(klass_cp_index);\n+    if (!is_class_resolution_deterministic(cp->pool_holder(), k)) {\n+      return false;\n+    }\n+\n+    if (!k->is_instance_klass()) {\n+      \/\/ TODO: support non instance klasses as well.\n+      return false;\n+    }\n+\n+    \/\/ Here, We don't check if this entry can actually be resolved to a valid Field\/Method.\n+    \/\/ This method should be called by the ConstantPool to check Fields\/Methods that\n+    \/\/ have already been successfully resolved.\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+bool AOTConstantPoolResolver::is_class_resolution_deterministic(InstanceKlass* cp_holder, Klass* resolved_class) {\n+  assert(!is_in_archivebuilder_buffer(cp_holder), \"sanity\");\n+  assert(!is_in_archivebuilder_buffer(resolved_class), \"sanity\");\n+\n+  if (resolved_class->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(resolved_class);\n+\n+    if (!ik->is_shared() && SystemDictionaryShared::is_excluded_class(ik)) {\n+      return false;\n+    }\n+\n+    if (cp_holder->is_subtype_of(ik)) {\n+      \/\/ All super types of ik will be resolved in ik->class_loader() before\n+      \/\/ ik is defined in this loader, so it's safe to archive the resolved klass reference.\n+      return true;\n+    }\n+\n+    if (CDSConfig::is_dumping_aot_linked_classes()) {\n+      \/\/ Need to call try_add_candidate instead of is_candidate, as this may be called\n+      \/\/ before AOTClassLinker::add_candidates().\n+      if (AOTClassLinker::try_add_candidate(ik)) {\n+        return true;\n+      } else {\n+        return false;\n+      }\n+    } else if (AOTClassLinker::is_vm_class(ik)) {\n+      if (ik->class_loader() != cp_holder->class_loader()) {\n+        \/\/ At runtime, cp_holder() may not be able to resolve to the same\n+        \/\/ ik. For example, a different version of ik may be defined in\n+        \/\/ cp->pool_holder()'s loader using MethodHandles.Lookup.defineClass().\n+        return false;\n+      } else {\n+        return true;\n+      }\n+    } else {\n+      return false;\n+    }\n+  } else if (resolved_class->is_objArray_klass()) {\n+    Klass* elem = ObjArrayKlass::cast(resolved_class)->bottom_klass();\n+    if (elem->is_instance_klass()) {\n+      return is_class_resolution_deterministic(cp_holder, InstanceKlass::cast(elem));\n+    } else if (elem->is_typeArray_klass()) {\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  } else if (resolved_class->is_typeArray_klass()) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+void AOTConstantPoolResolver::dumptime_resolve_constants(InstanceKlass* ik, TRAPS) {\n+  if (!ik->is_linked()) {\n+    return;\n+  }\n+  bool first_time;\n+  _processed_classes->put_if_absent(ik, &first_time);\n+  if (!first_time) {\n+    \/\/ We have already resolved the constants in class, so no need to do it again.\n+    return;\n+  }\n+\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  for (int cp_index = 1; cp_index < cp->length(); cp_index++) { \/\/ Index 0 is unused\n+    switch (cp->tag_at(cp_index).value()) {\n+    case JVM_CONSTANT_String:\n+      resolve_string(cp, cp_index, CHECK); \/\/ may throw OOM when interning strings.\n+      break;\n+    }\n+  }\n+}\n+\n+\/\/ This works only for the boot\/platform\/app loaders\n+Klass* AOTConstantPoolResolver::find_loaded_class(Thread* current, oop class_loader, Symbol* name) {\n+  HandleMark hm(current);\n+  Handle h_loader(current, class_loader);\n+  Klass* k = SystemDictionary::find_instance_or_array_klass(current, name,\n+                                                            h_loader,\n+                                                            Handle());\n+  if (k != nullptr) {\n+    return k;\n+  }\n+  if (h_loader() == SystemDictionary::java_system_loader()) {\n+    return find_loaded_class(current, SystemDictionary::java_platform_loader(), name);\n+  } else if (h_loader() == SystemDictionary::java_platform_loader()) {\n+    return find_loaded_class(current, nullptr, name);\n+  } else {\n+    assert(h_loader() == nullptr, \"This function only works for boot\/platform\/app loaders %p %p %p\",\n+           cast_from_oop<address>(h_loader()),\n+           cast_from_oop<address>(SystemDictionary::java_system_loader()),\n+           cast_from_oop<address>(SystemDictionary::java_platform_loader()));\n+  }\n+\n+  return nullptr;\n+}\n+\n+Klass* AOTConstantPoolResolver::find_loaded_class(Thread* current, ConstantPool* cp, int class_cp_index) {\n+  Symbol* name = cp->klass_name_at(class_cp_index);\n+  return find_loaded_class(current, cp->pool_holder()->class_loader(), name);\n+}\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+void AOTConstantPoolResolver::resolve_string(constantPoolHandle cp, int cp_index, TRAPS) {\n+  if (CDSConfig::is_dumping_heap()) {\n+    int cache_index = cp->cp_to_object_index(cp_index);\n+    ConstantPool::string_at_impl(cp, cp_index, cache_index, CHECK);\n+  }\n+}\n+#endif\n+\n+void AOTConstantPoolResolver::preresolve_class_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list) {\n+  if (!SystemDictionaryShared::is_builtin_loader(ik->class_loader_data())) {\n+    return;\n+  }\n+\n+  JavaThread* THREAD = current;\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  for (int cp_index = 1; cp_index < cp->length(); cp_index++) {\n+    if (cp->tag_at(cp_index).value() == JVM_CONSTANT_UnresolvedClass) {\n+      if (preresolve_list != nullptr && preresolve_list->at(cp_index) == false) {\n+        \/\/ This class was not resolved during trial run. Don't attempt to resolve it. Otherwise\n+        \/\/ the compiler may generate less efficient code.\n+        continue;\n+      }\n+      if (find_loaded_class(current, cp(), cp_index) == nullptr) {\n+        \/\/ Do not resolve any class that has not been loaded yet\n+        continue;\n+      }\n+      Klass* resolved_klass = cp->klass_at(cp_index, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+      } else {\n+        log_trace(cds, resolve)(\"Resolved class  [%3d] %s -> %s\", cp_index, ik->external_name(),\n+                                resolved_klass->external_name());\n+      }\n+    }\n+  }\n+}\n+\n+void AOTConstantPoolResolver::preresolve_field_and_method_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list) {\n+  JavaThread* THREAD = current;\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  if (cp->cache() == nullptr) {\n+    return;\n+  }\n+  for (int i = 0; i < ik->methods()->length(); i++) {\n+    Method* m = ik->methods()->at(i);\n+    BytecodeStream bcs(methodHandle(THREAD, m));\n+    while (!bcs.is_last_bytecode()) {\n+      bcs.next();\n+      Bytecodes::Code raw_bc = bcs.raw_code();\n+      switch (raw_bc) {\n+      case Bytecodes::_getfield:\n+      case Bytecodes::_putfield:\n+        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+        }\n+        break;\n+      case Bytecodes::_invokehandle:\n+      case Bytecodes::_invokespecial:\n+      case Bytecodes::_invokevirtual:\n+      case Bytecodes::_invokeinterface:\n+        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+        }\n+        break;\n+      default:\n+        break;\n+      }\n+    }\n+  }\n+}\n+\n+void AOTConstantPoolResolver::maybe_resolve_fmi_ref(InstanceKlass* ik, Method* m, Bytecodes::Code bc, int raw_index,\n+                                           GrowableArray<bool>* preresolve_list, TRAPS) {\n+  methodHandle mh(THREAD, m);\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  HandleMark hm(THREAD);\n+  int cp_index = cp->to_cp_index(raw_index, bc);\n+\n+  if (cp->is_resolved(raw_index, bc)) {\n+    return;\n+  }\n+\n+  if (preresolve_list != nullptr && preresolve_list->at(cp_index) == false) {\n+    \/\/ This field wasn't resolved during the trial run. Don't attempt to resolve it. Otherwise\n+    \/\/ the compiler may generate less efficient code.\n+    return;\n+  }\n+\n+  int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n+  if (find_loaded_class(THREAD, cp(), klass_cp_index) == nullptr) {\n+    \/\/ Do not resolve any field\/methods from a class that has not been loaded yet.\n+    return;\n+  }\n+\n+  Klass* resolved_klass = cp->klass_ref_at(raw_index, bc, CHECK);\n+\n+  switch (bc) {\n+  case Bytecodes::_getfield:\n+  case Bytecodes::_putfield:\n+    InterpreterRuntime::resolve_get_put(bc, raw_index, mh, cp, false \/*initialize_holder*\/, CHECK);\n+    break;\n+\n+  case Bytecodes::_invokevirtual:\n+  case Bytecodes::_invokespecial:\n+  case Bytecodes::_invokeinterface:\n+    InterpreterRuntime::cds_resolve_invoke(bc, raw_index, cp, CHECK);\n+    break;\n+\n+  case Bytecodes::_invokehandle:\n+    InterpreterRuntime::cds_resolve_invokehandle(raw_index, cp, CHECK);\n+    break;\n+\n+  default:\n+    ShouldNotReachHere();\n+  }\n+\n+  if (log_is_enabled(Trace, cds, resolve)) {\n+    ResourceMark rm(THREAD);\n+    bool resolved = cp->is_resolved(raw_index, bc);\n+    Symbol* name = cp->name_ref_at(raw_index, bc);\n+    Symbol* signature = cp->signature_ref_at(raw_index, bc);\n+    log_trace(cds, resolve)(\"%s %s [%3d] %s -> %s.%s:%s\",\n+                            (resolved ? \"Resolved\" : \"Failed to resolve\"),\n+                            Bytecodes::name(bc), cp_index, ik->external_name(),\n+                            resolved_klass->external_name(),\n+                            name->as_C_string(), signature->as_C_string());\n+  }\n+}\n+\n+void AOTConstantPoolResolver::preresolve_indy_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list) {\n+  JavaThread* THREAD = current;\n+  constantPoolHandle cp(THREAD, ik->constants());\n+  if (!CDSConfig::is_dumping_invokedynamic() || cp->cache() == nullptr) {\n+    return;\n+  }\n+\n+  assert(preresolve_list != nullptr, \"preresolve_indy_cp_entries() should not be called for \"\n+         \"regenerated LambdaForm Invoker classes, which should not have indys anyway.\");\n+\n+  Array<ResolvedIndyEntry>* indy_entries = cp->cache()->resolved_indy_entries();\n+  for (int i = 0; i < indy_entries->length(); i++) {\n+    ResolvedIndyEntry* rie = indy_entries->adr_at(i);\n+    int cp_index = rie->constant_pool_index();\n+    if (preresolve_list->at(cp_index) == true) {\n+      if (!rie->is_resolved() && is_indy_resolution_deterministic(cp(), cp_index)) {\n+        InterpreterRuntime::cds_resolve_invokedynamic(i, cp, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n+        }\n+      }\n+      if (log_is_enabled(Trace, cds, resolve)) {\n+        ResourceMark rm(THREAD);\n+        log_trace(cds, resolve)(\"%s indy   [%3d] %s\",\n+                                rie->is_resolved() ? \"Resolved\" : \"Failed to resolve\",\n+                                cp_index, ik->external_name());\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Check the MethodType signatures used by parameters to the indy BSMs. Make sure we don't\n+\/\/ use types that have been excluded, or else we might end up creating MethodTypes that cannot be stored\n+\/\/ in the AOT cache.\n+bool AOTConstantPoolResolver::check_methodtype_signature(ConstantPool* cp, Symbol* sig, Klass** return_type_ret) {\n+  ResourceMark rm;\n+  for (SignatureStream ss(sig); !ss.is_done(); ss.next()) {\n+    if (ss.is_reference()) {\n+      Symbol* type = ss.as_symbol();\n+      Klass* k = find_loaded_class(Thread::current(), cp->pool_holder()->class_loader(), type);\n+      if (k == nullptr) {\n+        return false;\n+      }\n+\n+      if (SystemDictionaryShared::check_for_exclusion(k)) {\n+        if (log_is_enabled(Warning, cds, resolve)) {\n+          ResourceMark rm;\n+          log_warning(cds, resolve)(\"Cannot aot-resolve Lambda proxy because %s is excluded\", k->external_name());\n+        }\n+        return false;\n+      }\n+\n+      if (ss.at_return_type() && return_type_ret != nullptr) {\n+        *return_type_ret = k;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+bool AOTConstantPoolResolver::check_lambda_metafactory_signature(ConstantPool* cp, Symbol* sig) {\n+  Klass* k;\n+  if (!check_methodtype_signature(cp, sig, &k)) {\n+    return false;\n+  }\n+\n+  \/\/ <k> is the interface type implemented by the lambda proxy\n+  if (!k->is_interface()) {\n+    \/\/ cp->pool_holder() doesn't look like a valid class generated by javac\n+    return false;\n+  }\n+\n+\n+  \/\/ The linked lambda callsite has an instance of the interface implemented by this lambda. If this\n+  \/\/ interface requires its <clinit> to be executed, then we must delay the execution to the production run\n+  \/\/ as <clinit> can have side effects ==> exclude such cases.\n+  InstanceKlass* intf = InstanceKlass::cast(k);\n+  bool exclude = intf->interface_needs_clinit_execution_as_super();\n+  if (log_is_enabled(Debug, cds, resolve)) {\n+    ResourceMark rm;\n+    log_debug(cds, resolve)(\"%s aot-resolve Lambda proxy of interface type %s\",\n+                            exclude ? \"Cannot\" : \"Can\", k->external_name());\n+  }\n+  return !exclude;\n+}\n+\n+bool AOTConstantPoolResolver::check_lambda_metafactory_methodtype_arg(ConstantPool* cp, int bsms_attribute_index, int arg_i) {\n+  int mt_index = cp->operand_argument_index_at(bsms_attribute_index, arg_i);\n+  if (!cp->tag_at(mt_index).is_method_type()) {\n+    \/\/ malformed class?\n+    return false;\n+  }\n+\n+  Symbol* sig = cp->method_type_signature_at(mt_index);\n+  if (log_is_enabled(Debug, cds, resolve)) {\n+    ResourceMark rm;\n+    log_debug(cds, resolve)(\"Checking MethodType for LambdaMetafactory BSM arg %d: %s\", arg_i, sig->as_C_string());\n+  }\n+\n+  return check_methodtype_signature(cp, sig);\n+}\n+\n+bool AOTConstantPoolResolver::check_lambda_metafactory_methodhandle_arg(ConstantPool* cp, int bsms_attribute_index, int arg_i) {\n+  int mh_index = cp->operand_argument_index_at(bsms_attribute_index, arg_i);\n+  if (!cp->tag_at(mh_index).is_method_handle()) {\n+    \/\/ malformed class?\n+    return false;\n+  }\n+\n+  Symbol* sig = cp->method_handle_signature_ref_at(mh_index);\n+  if (log_is_enabled(Debug, cds, resolve)) {\n+    ResourceMark rm;\n+    log_debug(cds, resolve)(\"Checking MethodType of MethodHandle for LambdaMetafactory BSM arg %d: %s\", arg_i, sig->as_C_string());\n+  }\n+  return check_methodtype_signature(cp, sig);\n+}\n+\n+bool AOTConstantPoolResolver::is_indy_resolution_deterministic(ConstantPool* cp, int cp_index) {\n+  assert(cp->tag_at(cp_index).is_invoke_dynamic(), \"sanity\");\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    return false;\n+  }\n+\n+  InstanceKlass* pool_holder = cp->pool_holder();\n+  if (!SystemDictionaryShared::is_builtin(pool_holder)) {\n+    return false;\n+  }\n+\n+  int bsm = cp->bootstrap_method_ref_index_at(cp_index);\n+  int bsm_ref = cp->method_handle_index_at(bsm);\n+  Symbol* bsm_name = cp->uncached_name_ref_at(bsm_ref);\n+  Symbol* bsm_signature = cp->uncached_signature_ref_at(bsm_ref);\n+  Symbol* bsm_klass = cp->klass_name_at(cp->uncached_klass_ref_index_at(bsm_ref));\n+\n+  \/\/ We currently support only StringConcatFactory::makeConcatWithConstants() and LambdaMetafactory::metafactory()\n+  \/\/ We should mark the allowed BSMs in the JDK code using a private annotation.\n+  \/\/ See notes on RFE JDK-8342481.\n+\n+  if (bsm_klass->equals(\"java\/lang\/invoke\/StringConcatFactory\") &&\n+      bsm_name->equals(\"makeConcatWithConstants\") &&\n+      bsm_signature->equals(\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;\"\n+                             \"Ljava\/lang\/String;\"\n+                             \"Ljava\/lang\/invoke\/MethodType;\"\n+                             \"Ljava\/lang\/String;\"\n+                             \"[Ljava\/lang\/Object;\"\n+                            \")Ljava\/lang\/invoke\/CallSite;\")) {\n+    Symbol* factory_type_sig = cp->uncached_signature_ref_at(cp_index);\n+    if (log_is_enabled(Debug, cds, resolve)) {\n+      ResourceMark rm;\n+      log_debug(cds, resolve)(\"Checking StringConcatFactory callsite signature [%d]: %s\", cp_index, factory_type_sig->as_C_string());\n+    }\n+\n+    Klass* k;\n+    if (!check_methodtype_signature(cp, factory_type_sig, &k)) {\n+      return false;\n+    }\n+    if (k != vmClasses::String_klass()) {\n+      \/\/ bad class file?\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  if (bsm_klass->equals(\"java\/lang\/invoke\/LambdaMetafactory\") &&\n+      bsm_name->equals(\"metafactory\") &&\n+      bsm_signature->equals(\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;\"\n+                             \"Ljava\/lang\/String;\"\n+                             \"Ljava\/lang\/invoke\/MethodType;\"\n+                             \"Ljava\/lang\/invoke\/MethodType;\"\n+                             \"Ljava\/lang\/invoke\/MethodHandle;\"\n+                             \"Ljava\/lang\/invoke\/MethodType;\"\n+                            \")Ljava\/lang\/invoke\/CallSite;\")) {\n+    \/*\n+     * An indy callsite is associated with the following MethodType and MethodHandles:\n+     *\n+     * https:\/\/github.com\/openjdk\/jdk\/blob\/580eb62dc097efeb51c76b095c1404106859b673\/src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java#L293-L309\n+     *\n+     * MethodType factoryType         The expected signature of the {@code CallSite}.  The\n+     *                                parameter types represent the types of capture variables;\n+     *                                the return type is the interface to implement.   When\n+     *                                used with {@code invokedynamic}, this is provided by\n+     *                                the {@code NameAndType} of the {@code InvokeDynamic}\n+     *\n+     * MethodType interfaceMethodType Signature and return type of method to be\n+     *                                implemented by the function object.\n+     *\n+     * MethodHandle implementation    A direct method handle describing the implementation\n+     *                                method which should be called (with suitable adaptation\n+     *                                of argument types and return types, and with captured\n+     *                                arguments prepended to the invocation arguments) at\n+     *                                invocation time.\n+     *\n+     * MethodType dynamicMethodType   The signature and return type that should\n+     *                                be enforced dynamically at invocation time.\n+     *                                In simple use cases this is the same as\n+     *                                {@code interfaceMethodType}.\n+     *\/\n+    Symbol* factory_type_sig = cp->uncached_signature_ref_at(cp_index);\n+    if (log_is_enabled(Debug, cds, resolve)) {\n+      ResourceMark rm;\n+      log_debug(cds, resolve)(\"Checking indy callsite signature [%d]: %s\", cp_index, factory_type_sig->as_C_string());\n+    }\n+\n+    if (!check_lambda_metafactory_signature(cp, factory_type_sig)) {\n+      return false;\n+    }\n+\n+    int bsms_attribute_index = cp->bootstrap_methods_attribute_index(cp_index);\n+    int arg_count = cp->operand_argument_count_at(bsms_attribute_index);\n+    if (arg_count != 3) {\n+      \/\/ Malformed class?\n+      return false;\n+    }\n+\n+    \/\/ interfaceMethodType\n+    if (!check_lambda_metafactory_methodtype_arg(cp, bsms_attribute_index, 0)) {\n+      return false;\n+    }\n+\n+    \/\/ implementation\n+    if (!check_lambda_metafactory_methodhandle_arg(cp, bsms_attribute_index, 1)) {\n+      return false;\n+    }\n+\n+    \/\/ dynamicMethodType\n+    if (!check_lambda_metafactory_methodtype_arg(cp, bsms_attribute_index, 2)) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  return false;\n+}\n+#ifdef ASSERT\n+bool AOTConstantPoolResolver::is_in_archivebuilder_buffer(address p) {\n+  if (!Thread::current()->is_VM_thread() || ArchiveBuilder::current() == nullptr) {\n+    return false;\n+  } else {\n+    return ArchiveBuilder::current()->is_in_buffer_space(p);\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":573,"deletions":0,"binary":false,"changes":573,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTCONSTANTPOOLRESOLVER_HPP\n+#define SHARE_CDS_AOTCONSTANTPOOLRESOLVER_HPP\n+\n+#include \"interpreter\/bytecodes.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class ConstantPool;\n+class constantPoolHandle;\n+class InstanceKlass;\n+class Klass;\n+\n+template <typename T> class GrowableArray;\n+\n+\/\/ AOTConstantPoolResolver is used to perform ahead-of-time linking of ConstantPool entries\n+\/\/ for archived InstanceKlasses.\n+\/\/\n+\/\/ At run time, Java classes are loaded dynamically and may be replaced with JVMTI.\n+\/\/ Therefore, we take care to prelink only the ConstantPool entries that are\n+\/\/ guatanteed to resolve to the same results at both dump time and run time.\n+\/\/\n+\/\/ For example, a JVM_CONSTANT_Class reference to a supertype can be safely resolved\n+\/\/ at dump time, because at run time we will load a class from the CDS archive only\n+\/\/ if all of its supertypes are loaded from the CDS archive.\n+class AOTConstantPoolResolver :  AllStatic {\n+  static const int TABLE_SIZE = 15889; \/\/ prime number\n+  using ClassesTable = ResourceHashtable<InstanceKlass*, bool, TABLE_SIZE, AnyObj::C_HEAP, mtClassShared> ;\n+  static ClassesTable* _processed_classes;\n+\n+#ifdef ASSERT\n+  template <typename T> static bool is_in_archivebuilder_buffer(T p) {\n+    return is_in_archivebuilder_buffer((address)(p));\n+  }\n+  static bool is_in_archivebuilder_buffer(address p);\n+#endif\n+\n+  static void resolve_string(constantPoolHandle cp, int cp_index, TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n+  static bool is_class_resolution_deterministic(InstanceKlass* cp_holder, Klass* resolved_class);\n+  static bool is_indy_resolution_deterministic(ConstantPool* cp, int cp_index);\n+\n+  static Klass* find_loaded_class(Thread* current, oop class_loader, Symbol* name);\n+  static Klass* find_loaded_class(Thread* current, ConstantPool* cp, int class_cp_index);\n+\n+  \/\/ fmi = FieldRef\/MethodRef\/InterfaceMethodRef\n+  static void maybe_resolve_fmi_ref(InstanceKlass* ik, Method* m, Bytecodes::Code bc, int raw_index,\n+                                    GrowableArray<bool>* resolve_fmi_list, TRAPS);\n+\n+  static bool check_methodtype_signature(ConstantPool* cp, Symbol* sig, Klass** return_type_ret = nullptr);\n+  static bool check_lambda_metafactory_signature(ConstantPool* cp, Symbol* sig);\n+  static bool check_lambda_metafactory_methodtype_arg(ConstantPool* cp, int bsms_attribute_index, int arg_i);\n+  static bool check_lambda_metafactory_methodhandle_arg(ConstantPool* cp, int bsms_attribute_index, int arg_i);\n+\n+public:\n+  static void initialize();\n+  static void dispose();\n+\n+  static void preresolve_class_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list);\n+  static void preresolve_field_and_method_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list);\n+  static void preresolve_indy_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list);\n+\n+\n+  \/\/ Resolve all constant pool entries that are safe to be stored in the\n+  \/\/ CDS archive.\n+  static void dumptime_resolve_constants(InstanceKlass* ik, TRAPS);\n+\n+  static bool is_resolution_deterministic(ConstantPool* cp, int cp_index);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTCONSTANTPOOLRESOLVER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.hpp","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,392 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/aotClassInitializer.hpp\"\n+#include \"cds\/aotClassLinker.hpp\"\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n+#include \"cds\/aotLinkedClassTable.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+\n+bool AOTLinkedClassBulkLoader::_boot2_completed = false;\n+bool AOTLinkedClassBulkLoader::_platform_completed = false;\n+bool AOTLinkedClassBulkLoader::_app_completed = false;\n+bool AOTLinkedClassBulkLoader::_all_completed = false;\n+\n+void AOTLinkedClassBulkLoader::serialize(SerializeClosure* soc, bool is_static_archive) {\n+  AOTLinkedClassTable::get(is_static_archive)->serialize(soc);\n+}\n+\n+void AOTLinkedClassBulkLoader::load_javabase_classes(JavaThread* current) {\n+  assert(CDSConfig::is_using_aot_linked_classes(), \"sanity\");\n+  load_classes_in_loader(current, AOTLinkedClassCategory::BOOT1, nullptr); \/\/ only java.base classes\n+}\n+\n+void AOTLinkedClassBulkLoader::load_non_javabase_classes(JavaThread* current) {\n+  assert(CDSConfig::is_using_aot_linked_classes(), \"sanity\");\n+\n+  \/\/ is_using_aot_linked_classes() requires is_using_full_module_graph(). As a result,\n+  \/\/ the platform\/system class loader should already have been initialized as part\n+  \/\/ of the FMG support.\n+  assert(CDSConfig::is_using_full_module_graph(), \"must be\");\n+  assert(SystemDictionary::java_platform_loader() != nullptr, \"must be\");\n+  assert(SystemDictionary::java_system_loader() != nullptr,   \"must be\");\n+\n+  load_classes_in_loader(current, AOTLinkedClassCategory::BOOT2, nullptr); \/\/ all boot classes outside of java.base\n+  _boot2_completed = true;\n+\n+  load_classes_in_loader(current, AOTLinkedClassCategory::PLATFORM, SystemDictionary::java_platform_loader());\n+  _platform_completed = true;\n+\n+  load_classes_in_loader(current, AOTLinkedClassCategory::APP, SystemDictionary::java_system_loader());\n+  _app_completed = true;\n+  _all_completed = true;\n+}\n+\n+void AOTLinkedClassBulkLoader::load_classes_in_loader(JavaThread* current, AOTLinkedClassCategory class_category, oop class_loader_oop) {\n+  load_classes_in_loader_impl(class_category, class_loader_oop, current);\n+  if (current->has_pending_exception()) {\n+    ResourceMark rm(current);\n+    \/\/ We cannot continue, as we might have loaded some of the aot-linked classes, which\n+    \/\/ may have dangling C++ pointers to other aot-linked classes that we have failed to load.\n+    if (current->pending_exception()->is_a(vmClasses::OutOfMemoryError_klass())) {\n+      log_error(cds)(\"Out of memory. Please run with a larger Java heap, current MaxHeapSize = \"\n+                     SIZE_FORMAT \"M\", MaxHeapSize\/M);\n+    } else {\n+      log_error(cds)(\"%s: %s\", current->pending_exception()->klass()->external_name(),\n+                     java_lang_String::as_utf8_string(java_lang_Throwable::message(current->pending_exception())));\n+    }\n+    vm_exit_during_initialization(\"Unexpected exception when loading aot-linked classes.\");\n+  }\n+}\n+\n+void AOTLinkedClassBulkLoader::load_classes_in_loader_impl(AOTLinkedClassCategory class_category, oop class_loader_oop, TRAPS) {\n+  Handle h_loader(THREAD, class_loader_oop);\n+  load_table(AOTLinkedClassTable::for_static_archive(),  class_category, h_loader, CHECK);\n+  load_table(AOTLinkedClassTable::for_dynamic_archive(), class_category, h_loader, CHECK);\n+\n+  \/\/ Initialize the InstanceKlasses of all archived heap objects that are reachable from the\n+  \/\/ archived java class mirrors.\n+  \/\/\n+  \/\/ Only the classes in the static archive can have archived mirrors.\n+  AOTLinkedClassTable* static_table = AOTLinkedClassTable::for_static_archive();\n+  switch (class_category) {\n+  case AOTLinkedClassCategory::BOOT1:\n+    \/\/ Delayed until finish_loading_javabase_classes(), as the VM is not ready to\n+    \/\/ execute some of the <clinit> methods.\n+    break;\n+  case AOTLinkedClassCategory::BOOT2:\n+    init_required_classes_for_loader(h_loader, static_table->boot2(), CHECK);\n+    break;\n+  case AOTLinkedClassCategory::PLATFORM:\n+    init_required_classes_for_loader(h_loader, static_table->platform(), CHECK);\n+    break;\n+  case AOTLinkedClassCategory::APP:\n+    init_required_classes_for_loader(h_loader, static_table->app(), CHECK);\n+    break;\n+  case AOTLinkedClassCategory::UNREGISTERED:\n+    ShouldNotReachHere();\n+    break;\n+  }\n+\n+  if (Universe::is_fully_initialized() && VerifyDuringStartup) {\n+    \/\/ Make sure we're still in a clean state.\n+    VM_Verify verify_op;\n+    VMThread::execute(&verify_op);\n+  }\n+}\n+\n+void AOTLinkedClassBulkLoader::load_table(AOTLinkedClassTable* table, AOTLinkedClassCategory class_category, Handle loader, TRAPS) {\n+  if (class_category != AOTLinkedClassCategory::BOOT1) {\n+    assert(Universe::is_module_initialized(), \"sanity\");\n+  }\n+\n+  const char* category_name = AOTClassLinker::class_category_name(class_category);\n+  switch (class_category) {\n+  case AOTLinkedClassCategory::BOOT1:\n+    load_classes_impl(class_category, table->boot(), category_name, loader, CHECK);\n+    break;\n+\n+  case AOTLinkedClassCategory::BOOT2:\n+    load_classes_impl(class_category, table->boot2(), category_name, loader, CHECK);\n+    break;\n+\n+  case AOTLinkedClassCategory::PLATFORM:\n+    {\n+      initiate_loading(THREAD, category_name, loader, table->boot());\n+      initiate_loading(THREAD, category_name, loader, table->boot2());\n+      load_classes_impl(class_category, table->platform(), category_name, loader, CHECK);\n+    }\n+    break;\n+  case AOTLinkedClassCategory::APP:\n+    {\n+      initiate_loading(THREAD, category_name, loader, table->boot());\n+      initiate_loading(THREAD, category_name, loader, table->boot2());\n+      initiate_loading(THREAD, category_name, loader, table->platform());\n+      load_classes_impl(class_category, table->app(), category_name, loader, CHECK);\n+    }\n+    break;\n+  case AOTLinkedClassCategory::UNREGISTERED:\n+  default:\n+    ShouldNotReachHere(); \/\/ Currently aot-linked classes are not supported for this category.\n+    break;\n+  }\n+}\n+\n+void AOTLinkedClassBulkLoader::load_classes_impl(AOTLinkedClassCategory class_category, Array<InstanceKlass*>* classes,\n+                                                 const char* category_name, Handle loader, TRAPS) {\n+  if (classes == nullptr) {\n+    return;\n+  }\n+\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(loader());\n+\n+  for (int i = 0; i < classes->length(); i++) {\n+    InstanceKlass* ik = classes->at(i);\n+    if (log_is_enabled(Info, cds, aot, load)) {\n+      ResourceMark rm(THREAD);\n+      log_info(cds, aot, load)(\"%-5s %s%s%s\", category_name, ik->external_name(),\n+                               ik->is_loaded() ? \" (already loaded)\" : \"\",\n+                               ik->is_hidden() ? \" (hidden)\" : \"\");\n+    }\n+\n+    if (!ik->is_loaded()) {\n+      if (ik->is_hidden()) {\n+        load_hidden_class(loader_data, ik, CHECK);\n+      } else {\n+        InstanceKlass* actual;\n+        if (loader_data == ClassLoaderData::the_null_class_loader_data()) {\n+          actual = SystemDictionary::load_instance_class(ik->name(), loader, CHECK);\n+        } else {\n+          actual = SystemDictionaryShared::find_or_load_shared_class(ik->name(), loader, CHECK);\n+        }\n+\n+        if (actual != ik) {\n+          ResourceMark rm(THREAD);\n+          log_error(cds)(\"Unable to resolve %s class from CDS archive: %s\", category_name, ik->external_name());\n+          log_error(cds)(\"Expected: \" INTPTR_FORMAT \", actual: \" INTPTR_FORMAT, p2i(ik), p2i(actual));\n+          log_error(cds)(\"JVMTI class retransformation is not supported when archive was generated with -XX:+AOTClassLinking.\");\n+          MetaspaceShared::unrecoverable_loading_error();\n+        }\n+        assert(actual->is_loaded(), \"must be\");\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Initiate loading of the <classes> in the <initiating_loader>. The <classes> should have already been loaded\n+\/\/ by a parent loader of the <initiating_loader>. This is necessary for handling pre-resolved CP entries.\n+\/\/\n+\/\/ For example, we initiate the loading of java\/lang\/String in the AppClassLoader. This will allow\n+\/\/ any App classes to have a pre-resolved ConstantPool entry that references java\/lang\/String.\n+\/\/\n+\/\/ TODO: we can limit the number of initiated classes to only those that are actually referenced by\n+\/\/ AOT-linked classes loaded by <initiating_loader>.\n+void AOTLinkedClassBulkLoader::initiate_loading(JavaThread* current, const char* category_name,\n+                                                Handle initiating_loader, Array<InstanceKlass*>* classes) {\n+  if (classes == nullptr) {\n+    return;\n+  }\n+\n+  assert(initiating_loader() == SystemDictionary::java_platform_loader() ||\n+         initiating_loader() == SystemDictionary::java_system_loader(), \"must be\");\n+  ClassLoaderData* loader_data = ClassLoaderData::class_loader_data(initiating_loader());\n+  MonitorLocker mu1(SystemDictionary_lock);\n+\n+  for (int i = 0; i < classes->length(); i++) {\n+    InstanceKlass* ik = classes->at(i);\n+    assert(ik->is_loaded(), \"must have already been loaded by a parent loader\");\n+    assert(ik->class_loader() != initiating_loader(), \"must be a parent loader\");\n+    assert(ik->class_loader() == nullptr ||\n+           ik->class_loader() == SystemDictionary::java_platform_loader(), \"must be\");\n+    if (ik->is_public() && !ik->is_hidden()) {\n+      if (log_is_enabled(Info, cds, aot, load)) {\n+        ResourceMark rm(current);\n+        const char* defining_loader = (ik->class_loader() == nullptr ? \"boot\" : \"plat\");\n+        log_info(cds, aot, load)(\"%s %s (initiated, defined by %s)\", category_name, ik->external_name(),\n+                                 defining_loader);\n+      }\n+      SystemDictionary::add_to_initiating_loader(current, ik, loader_data);\n+    }\n+  }\n+}\n+\n+\/\/ Currently, we archive only three types of hidden classes:\n+\/\/    - LambdaForms\n+\/\/    - lambda proxy classes\n+\/\/    - StringConcat classes\n+\/\/ See HeapShared::is_archivable_hidden_klass().\n+\/\/\n+\/\/ LambdaForm classes (with names like java\/lang\/invoke\/LambdaForm$MH+0x800000015) logically\n+\/\/ belong to the boot loader, but they are usually stored in their own special ClassLoaderData to\n+\/\/ facilitate class unloading, as a LambdaForm may refer to a class loaded by a custom loader\n+\/\/ that may be unloaded.\n+\/\/\n+\/\/ We only support AOT-resolution of indys in the boot\/platform\/app loader, so there's no need\n+\/\/ to support class unloading. For simplicity, we put all archived LambdaForm classes in the\n+\/\/ \"main\" ClassLoaderData of the boot loader.\n+\/\/\n+\/\/ (Even if we were to support other loaders, we would still feel free to ignore any requirement\n+\/\/ of class unloading, for any class asset in the AOT cache.  Anything that makes it into the AOT\n+\/\/ cache has a lifetime dispensation from unloading.  After all, the AOT cache never grows, and\n+\/\/ we can assume that the user is content with its size, and doesn't need its footprint to shrink.)\n+\/\/\n+\/\/ Lambda proxy classes are normally stored in the same ClassLoaderData as their nest hosts, and\n+\/\/ StringConcat are normally stored in the main ClassLoaderData of the boot class loader. We\n+\/\/ do the same for the archived copies of such classes.\n+void AOTLinkedClassBulkLoader::load_hidden_class(ClassLoaderData* loader_data, InstanceKlass* ik, TRAPS) {\n+  assert(HeapShared::is_lambda_form_klass(ik) ||\n+         HeapShared::is_lambda_proxy_klass(ik) ||\n+         HeapShared::is_string_concat_klass(ik), \"sanity\");\n+  DEBUG_ONLY({\n+      assert(ik->java_super()->is_loaded(), \"must be\");\n+      for (int i = 0; i < ik->local_interfaces()->length(); i++) {\n+        assert(ik->local_interfaces()->at(i)->is_loaded(), \"must be\");\n+      }\n+    });\n+\n+  Handle pd;\n+  PackageEntry* pkg_entry = nullptr;\n+\n+  \/\/ Since a hidden class does not have a name, it cannot be reloaded\n+  \/\/ normally via the system dictionary. Instead, we have to finish the\n+  \/\/ loading job here.\n+\n+  if (HeapShared::is_lambda_proxy_klass(ik)) {\n+    InstanceKlass* nest_host = ik->nest_host_not_null();\n+    assert(nest_host->is_loaded(), \"must be\");\n+    pd = Handle(THREAD, nest_host->protection_domain());\n+    pkg_entry = nest_host->package();\n+  }\n+\n+  ik->restore_unshareable_info(loader_data, pd, pkg_entry, CHECK);\n+  SystemDictionary::load_shared_class_misc(ik, loader_data);\n+  ik->add_to_hierarchy(THREAD);\n+  assert(ik->is_loaded(), \"Must be in at least loaded state\");\n+\n+  DEBUG_ONLY({\n+      \/\/ Make sure we don't make this hidden class available by name, even if we don't\n+      \/\/ use any special ClassLoaderData.\n+      Handle loader(THREAD, loader_data->class_loader());\n+      ResourceMark rm(THREAD);\n+      assert(SystemDictionary::resolve_or_null(ik->name(), loader, pd, THREAD) == nullptr,\n+             \"hidden classes cannot be accessible by name: %s\", ik->external_name());\n+      if (HAS_PENDING_EXCEPTION) {\n+        CLEAR_PENDING_EXCEPTION;\n+      }\n+    });\n+}\n+\n+void AOTLinkedClassBulkLoader::finish_loading_javabase_classes(TRAPS) {\n+  init_required_classes_for_loader(Handle(), AOTLinkedClassTable::for_static_archive()->boot(), CHECK);\n+}\n+\n+\/\/ Some AOT-linked classes for <class_loader> must be initialized early. This includes\n+\/\/ - classes that were AOT-initialized by AOTClassInitializer\n+\/\/ - the classes of all objects that are reachable from the archived mirrors of\n+\/\/   the AOT-linked classes for <class_loader>.\n+void AOTLinkedClassBulkLoader::init_required_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS) {\n+  if (classes != nullptr) {\n+    for (int i = 0; i < classes->length(); i++) {\n+      InstanceKlass* ik = classes->at(i);\n+      if (ik->class_loader_data() == nullptr) {\n+        \/\/ This class is not yet loaded. We will initialize it in a later phase.\n+        \/\/ For example, we have loaded only AOTLinkedClassCategory::BOOT1 classes\n+        \/\/ but k is part of AOTLinkedClassCategory::BOOT2.\n+        continue;\n+      }\n+      if (ik->has_aot_initialized_mirror()) {\n+        ik->initialize_with_aot_initialized_mirror(CHECK);\n+      } else {\n+        \/\/ Some cached heap objects may hold references to methods in aot-linked\n+        \/\/ classes (via MemberName). We need to make sure all classes are\n+        \/\/ linked to allow such MemberNames to be invoked.\n+        ik->link_class(CHECK);\n+      }\n+    }\n+  }\n+\n+  HeapShared::init_classes_for_special_subgraph(class_loader, CHECK);\n+}\n+\n+bool AOTLinkedClassBulkLoader::is_pending_aot_linked_class(Klass* k) {\n+  if (!CDSConfig::is_using_aot_linked_classes()) {\n+    return false;\n+  }\n+\n+  if (_all_completed) { \/\/ no more pending aot-linked classes\n+    return false;\n+  }\n+\n+  if (k->is_objArray_klass()) {\n+    k = ObjArrayKlass::cast(k)->bottom_klass();\n+  }\n+  if (!k->is_instance_klass()) {\n+    \/\/ type array klasses (and their higher dimensions),\n+    \/\/ must have been loaded before a GC can ever happen.\n+    return false;\n+  }\n+\n+  \/\/ There's a small window during VM start-up where a not-yet loaded aot-linked\n+  \/\/ class k may be discovered by the GC during VM initialization. This can happen\n+  \/\/ when the heap contains an aot-cached instance of k, but k is not ready to be\n+  \/\/ loaded yet. (TODO: JDK-8342429 eliminates this possibility)\n+  \/\/\n+  \/\/ The following checks try to limit this window as much as possible for each of\n+  \/\/ the four AOTLinkedClassCategory of classes that can be aot-linked.\n+\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+  if (ik->is_shared_boot_class()) {\n+    if (ik->module() != nullptr && ik->in_javabase_module()) {\n+      \/\/ AOTLinkedClassCategory::BOOT1 -- all aot-linked classes in\n+      \/\/ java.base must have been loaded before a GC can ever happen.\n+      return false;\n+    } else {\n+      \/\/ AOTLinkedClassCategory::BOOT2 classes cannot be loaded until\n+      \/\/ module system is ready.\n+      return !_boot2_completed;\n+    }\n+  } else if (ik->is_shared_platform_class()) {\n+    \/\/ AOTLinkedClassCategory::PLATFORM classes cannot be loaded until\n+    \/\/ the platform class loader is initialized.\n+    return !_platform_completed;\n+  } else if (ik->is_shared_app_class()) {\n+    \/\/ AOTLinkedClassCategory::APP cannot be loaded until the app class loader\n+    \/\/ is initialized.\n+    return !_app_completed;\n+  } else {\n+    return false;\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":392,"deletions":0,"binary":false,"changes":392,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTLINKEDCLASSBULKLOADER_HPP\n+#define SHARE_CDS_AOTLINKEDCLASSBULKLOADER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class AOTLinkedClassTable;\n+class ClassLoaderData;\n+class InstanceKlass;\n+class SerializeClosure;\n+template <typename T> class Array;\n+enum class AOTLinkedClassCategory : int;\n+\n+\/\/ During a Production Run, the AOTLinkedClassBulkLoader loads all classes from\n+\/\/ a AOTLinkedClassTable into their respective ClassLoaders. This happens very early\n+\/\/ in the JVM bootstrap stage, before any application code is executed.\n+\/\/\n+class AOTLinkedClassBulkLoader :  AllStatic {\n+  static bool _boot2_completed;\n+  static bool _platform_completed;\n+  static bool _app_completed;\n+  static bool _all_completed;\n+  static void load_classes_in_loader(JavaThread* current, AOTLinkedClassCategory class_category, oop class_loader_oop);\n+  static void load_classes_in_loader_impl(AOTLinkedClassCategory class_category, oop class_loader_oop, TRAPS);\n+  static void load_table(AOTLinkedClassTable* table, AOTLinkedClassCategory class_category, Handle loader, TRAPS);\n+  static void initiate_loading(JavaThread* current, const char* category, Handle initiating_loader, Array<InstanceKlass*>* classes);\n+  static void load_classes_impl(AOTLinkedClassCategory class_category, Array<InstanceKlass*>* classes,\n+                                const char* category_name, Handle loader, TRAPS);\n+  static void load_hidden_class(ClassLoaderData* loader_data, InstanceKlass* ik, TRAPS);\n+  static void init_required_classes_for_loader(Handle class_loader, Array<InstanceKlass*>* classes, TRAPS);\n+public:\n+  static void serialize(SerializeClosure* soc, bool is_static_archive) NOT_CDS_RETURN;\n+\n+  static void load_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void load_non_javabase_classes(JavaThread* current) NOT_CDS_RETURN;\n+  static void finish_loading_javabase_classes(TRAPS) NOT_CDS_RETURN;\n+\n+  static bool is_pending_aot_linked_class(Klass* k) NOT_CDS_RETURN_(false);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTLINKEDCLASSBULKLOADER_HPP\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/aotLinkedClassTable.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/serializeClosure.hpp\"\n+#include \"oops\/array.hpp\"\n+\n+AOTLinkedClassTable AOTLinkedClassTable::_for_static_archive;\n+AOTLinkedClassTable AOTLinkedClassTable::_for_dynamic_archive;\n+\n+void AOTLinkedClassTable::serialize(SerializeClosure* soc) {\n+  soc->do_ptr((void**)&_boot);\n+  soc->do_ptr((void**)&_boot2);\n+  soc->do_ptr((void**)&_platform);\n+  soc->do_ptr((void**)&_app);\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassTable.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTLINKEDCLASSTABLE_HPP\n+#define SHARE_CDS_AOTLINKEDCLASSTABLE_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+template <typename T> class Array;\n+class InstanceKlass;\n+class SerializeClosure;\n+\n+\/\/ Classes to be bulk-loaded, in the \"linked\" state, at VM bootstrap.\n+\/\/\n+\/\/ AOTLinkedClassTable is produced by AOTClassLinker when an AOTCache is assembled.\n+\/\/\n+\/\/ AOTLinkedClassTable is consumed by AOTLinkedClassBulkLoader when an AOTCache is used\n+\/\/ in a production run.\n+\/\/\n+class AOTLinkedClassTable {\n+  \/\/ The VM may load up to 2 CDS archives -- static and dynamic. Each\n+  \/\/ archive can have its own AOTLinkedClassTable.\n+  static AOTLinkedClassTable _for_static_archive;\n+  static AOTLinkedClassTable _for_dynamic_archive;\n+\n+  Array<InstanceKlass*>* _boot;  \/\/ only java.base classes\n+  Array<InstanceKlass*>* _boot2; \/\/ boot classes in other modules\n+  Array<InstanceKlass*>* _platform;\n+  Array<InstanceKlass*>* _app;\n+\n+public:\n+  AOTLinkedClassTable() :\n+    _boot(nullptr), _boot2(nullptr),\n+    _platform(nullptr), _app(nullptr) {}\n+\n+  static AOTLinkedClassTable* for_static_archive()  { return &_for_static_archive; }\n+  static AOTLinkedClassTable* for_dynamic_archive() { return &_for_dynamic_archive; }\n+\n+  static AOTLinkedClassTable* get(bool is_static_archive) {\n+    return is_static_archive ? for_static_archive() : for_dynamic_archive();\n+  }\n+\n+  Array<InstanceKlass*>* boot()     const { return _boot;     }\n+  Array<InstanceKlass*>* boot2()    const { return _boot2;    }\n+  Array<InstanceKlass*>* platform() const { return _platform; }\n+  Array<InstanceKlass*>* app()      const { return _app;      }\n+\n+  void set_boot    (Array<InstanceKlass*>* value) { _boot     = value; }\n+  void set_boot2   (Array<InstanceKlass*>* value) { _boot2    = value; }\n+  void set_platform(Array<InstanceKlass*>* value) { _platform = value; }\n+  void set_app     (Array<InstanceKlass*>* value) { _app      = value; }\n+\n+  void serialize(SerializeClosure* soc);\n+};\n+\n+#endif \/\/ SHARE_CDS_AOTLINKEDCLASSTABLE_HPP\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassTable.hpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"cds\/aotClassLinker.hpp\"\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -36,0 +38,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -37,0 +40,1 @@\n+#include \"classfile\/classLoaderExt.hpp\"\n@@ -229,0 +233,4 @@\n+      if (klass->is_hidden()) {\n+        assert(klass->is_instance_klass(), \"must be\");\n+        assert(SystemDictionaryShared::should_hidden_class_be_archived(InstanceKlass::cast(klass)), \"must be\");\n+      }\n@@ -285,0 +293,2 @@\n+\n+  AOTClassLinker::add_candidates();\n@@ -311,0 +321,9 @@\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    \/\/ This is difficult to estimate when dumping the dynamic archive, as the\n+    \/\/ AOTLinkedClassTable may need to contain classes in the static archive as well.\n+    \/\/\n+    \/\/ Just give a generous estimate for now. We will remove estimate_archive_size()\n+    \/\/ in JDK-8340416\n+    _estimated_hashtable_bytes += 20 * 1024 * 1024;\n+  }\n+\n@@ -424,0 +443,2 @@\n+\n+  remember_embedded_pointer_in_enclosing_obj(ref);\n@@ -428,1 +449,0 @@\n-  remember_embedded_pointer_in_enclosing_obj(ref);\n@@ -728,0 +748,10 @@\n+bool ArchiveBuilder::has_been_buffered(address src_addr) const {\n+  if (RegeneratedClasses::has_been_regenerated(src_addr) ||\n+      _src_obj_table.get(src_addr) == nullptr ||\n+      get_buffered_addr(src_addr) == nullptr) {\n+    return false;\n+  } else {\n+    return true;\n+  }\n+}\n+\n@@ -755,0 +785,10 @@\n+#define ADD_COUNT(x) \\\n+  x += 1; \\\n+  x ## _a += aotlinked ? 1 : 0; \\\n+  x ## _i += inited ? 1 : 0;\n+\n+#define DECLARE_INSTANCE_KLASS_COUNTER(x) \\\n+  int x = 0; \\\n+  int x ## _a = 0; \\\n+  int x ## _i = 0;\n+\n@@ -756,5 +796,9 @@\n-  int num_instance_klasses = 0;\n-  int num_boot_klasses = 0;\n-  int num_platform_klasses = 0;\n-  int num_app_klasses = 0;\n-  int num_hidden_klasses = 0;\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_instance_klasses);\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_boot_klasses);\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_vm_klasses);\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_platform_klasses);\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_app_klasses);\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_old_klasses);\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_hidden_klasses);\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_enum_klasses);\n+  DECLARE_INSTANCE_KLASS_COUNTER(num_unregistered_klasses);\n@@ -762,1 +806,0 @@\n-  int num_unregistered_klasses = 0;\n@@ -766,0 +809,5 @@\n+  int boot_unlinked = 0;\n+  int platform_unlinked = 0;\n+  int app_unlinked = 0;\n+  int unreg_unlinked = 0;\n+\n@@ -779,0 +827,1 @@\n+    const char* kind = \"\";\n@@ -780,0 +829,1 @@\n+    const char* old = \"\";\n@@ -781,0 +831,2 @@\n+    const char* aotlinked_msg = \"\";\n+    const char* inited_msg = \"\";\n@@ -794,1 +846,0 @@\n-      num_instance_klasses ++;\n@@ -796,1 +847,32 @@\n-      if (ik->is_shared_boot_class()) {\n+      InstanceKlass* src_ik = get_source_addr(ik);\n+      bool aotlinked = AOTClassLinker::is_candidate(src_ik);\n+      bool inited = ik->has_aot_initialized_mirror();\n+      ADD_COUNT(num_instance_klasses);\n+      if (CDSConfig::is_dumping_dynamic_archive()) {\n+        \/\/ For static dump, class loader type are already set.\n+        ik->assign_class_loader_type();\n+      }\n+      if (ik->is_hidden()) {\n+        ADD_COUNT(num_hidden_klasses);\n+        hidden = \" hidden\";\n+        oop loader = k->class_loader();\n+        if (loader == nullptr) {\n+          type = \"boot\";\n+          ADD_COUNT(num_boot_klasses);\n+        } else if (loader == SystemDictionary::java_platform_loader()) {\n+          type = \"plat\";\n+          ADD_COUNT(num_platform_klasses);\n+        } else if (loader == SystemDictionary::java_system_loader()) {\n+          type = \"app\";\n+          ADD_COUNT(num_app_klasses);\n+        } else {\n+          type = \"bad\";\n+          assert(0, \"shouldn't happen\");\n+        }\n+        if (CDSConfig::is_dumping_invokedynamic()) {\n+          assert(HeapShared::is_archivable_hidden_klass(ik), \"sanity\");\n+        } else {\n+          \/\/ Legacy CDS support for lambda proxies\n+          assert(HeapShared::is_lambda_proxy_klass(ik), \"sanity\");\n+        }\n+      } else if (ik->is_shared_boot_class()) {\n@@ -798,1 +880,1 @@\n-        num_boot_klasses ++;\n+        ADD_COUNT(num_boot_klasses);\n@@ -801,1 +883,1 @@\n-        num_platform_klasses ++;\n+        ADD_COUNT(num_platform_klasses);\n@@ -804,1 +886,1 @@\n-        num_app_klasses ++;\n+        ADD_COUNT(num_app_klasses);\n@@ -808,1 +890,5 @@\n-        num_unregistered_klasses ++;\n+        ADD_COUNT(num_unregistered_klasses);\n+      }\n+\n+      if (AOTClassLinker::is_vm_class(src_ik)) {\n+        ADD_COUNT(num_vm_klasses);\n@@ -813,1 +899,10 @@\n-        unlinked = \" ** unlinked\";\n+        unlinked = \" unlinked\";\n+        if (ik->is_shared_boot_class()) {\n+          boot_unlinked ++;\n+        } else if (ik->is_shared_platform_class()) {\n+          platform_unlinked ++;\n+        } else if (ik->is_shared_app_class()) {\n+          app_unlinked ++;\n+        } else {\n+          unreg_unlinked ++;\n+        }\n@@ -816,3 +911,10 @@\n-      if (ik->is_hidden()) {\n-        num_hidden_klasses ++;\n-        hidden = \" ** hidden\";\n+      if (ik->is_interface()) {\n+        kind = \" interface\";\n+      } else if (src_ik->is_enum_subclass()) {\n+        kind = \" enum\";\n+        ADD_COUNT(num_enum_klasses);\n+      }\n+\n+      if (!ik->can_be_verified_at_dumptime()) {\n+        ADD_COUNT(num_old_klasses);\n+        old = \" old\";\n@@ -822,1 +924,7 @@\n-        generated = \" ** generated\";\n+        generated = \" generated\";\n+      }\n+      if (aotlinked) {\n+        aotlinked_msg = \" aot-linked\";\n+      }\n+      if (inited) {\n+        inited_msg = \" inited\";\n@@ -824,0 +932,1 @@\n+\n@@ -830,1 +939,1 @@\n-      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s%s\", i,\n+      log_debug(cds, class)(\"klasses[%5d] = \" PTR_FORMAT \" %-5s %s%s%s%s%s%s%s%s\", i,\n@@ -832,1 +941,1 @@\n-                            hidden, unlinked, generated);\n+                            kind, hidden, old, unlinked, generated, aotlinked_msg, inited_msg);\n@@ -836,0 +945,3 @@\n+#define STATS_FORMAT    \"= %5d, aot-linked = %5d, inited = %5d\"\n+#define STATS_PARAMS(x) num_ ## x, num_ ## x ## _a, num_ ## x ## _i\n+\n@@ -837,7 +949,11 @@\n-  log_info(cds)(\"    instance classes   = %5d\", num_instance_klasses);\n-  log_info(cds)(\"      boot             = %5d\", num_boot_klasses);\n-  log_info(cds)(\"      app              = %5d\", num_app_klasses);\n-  log_info(cds)(\"      platform         = %5d\", num_platform_klasses);\n-  log_info(cds)(\"      unregistered     = %5d\", num_unregistered_klasses);\n-  log_info(cds)(\"      (hidden)         = %5d\", num_hidden_klasses);\n-  log_info(cds)(\"      (unlinked)       = %5d\", num_unlinked_klasses);\n+  log_info(cds)(\"    instance classes   \" STATS_FORMAT, STATS_PARAMS(instance_klasses));\n+  log_info(cds)(\"      boot             \" STATS_FORMAT, STATS_PARAMS(boot_klasses));\n+  log_info(cds)(\"        vm             \" STATS_FORMAT, STATS_PARAMS(vm_klasses));\n+  log_info(cds)(\"      platform         \" STATS_FORMAT, STATS_PARAMS(platform_klasses));\n+  log_info(cds)(\"      app              \" STATS_FORMAT, STATS_PARAMS(app_klasses));\n+  log_info(cds)(\"      unregistered     \" STATS_FORMAT, STATS_PARAMS(unregistered_klasses));\n+  log_info(cds)(\"      (enum)           \" STATS_FORMAT, STATS_PARAMS(enum_klasses));\n+  log_info(cds)(\"      (hidden)         \" STATS_FORMAT, STATS_PARAMS(hidden_klasses));\n+  log_info(cds)(\"      (old)            \" STATS_FORMAT, STATS_PARAMS(old_klasses));\n+  log_info(cds)(\"      (unlinked)       = %5d, boot = %d, plat = %d, app = %d, unreg = %d\",\n+                num_unlinked_klasses, boot_unlinked, platform_unlinked, app_unlinked, unreg_unlinked);\n@@ -848,0 +964,3 @@\n+#undef STATS_FORMAT\n+#undef STATS_PARAMS\n+\n@@ -855,0 +974,1 @@\n+  AOTLinkedClassBulkLoader::serialize(soc, false);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":147,"deletions":27,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-    return (buffer_bottom() <= p && p < buffer_top());\n+    return (buffer_bottom() != nullptr && buffer_bottom() <= p && p < buffer_top());\n@@ -414,0 +414,5 @@\n+  bool has_been_buffered(address src_addr) const;\n+  template <typename T> bool has_been_buffered(T src_addr) const {\n+    return has_been_buffered((address)src_addr);\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -440,4 +440,0 @@\n-    \/\/ Currently we have only Klass pointers in heap objects.\n-    \/\/ This needs to be relaxed when we support other types of native\n-    \/\/ pointers such as Method.\n-    assert(((Klass*)(*p))->is_klass(), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"oops\/oop.inline.hpp\"\n@@ -38,0 +38,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -530,1 +531,8 @@\n-  if (!CompressedOops::is_null(source_referent)) {\n+  if (source_referent != nullptr) {\n+    if (java_lang_Class::is_instance(source_referent)) {\n+      \/\/ When the source object points to a \"real\" mirror, the buffered object should point\n+      \/\/ to the \"scratch\" mirror, which has all unarchivable fields scrubbed (to be reinstated\n+      \/\/ at run time).\n+      source_referent = HeapShared::scratch_java_mirror(source_referent);\n+      assert(source_referent != nullptr, \"must be\");\n+    }\n@@ -713,1 +721,3 @@\n-    assert(native_ptr != nullptr, \"sanity\");\n+    guarantee(native_ptr != nullptr, \"sanity\");\n+    guarantee(ArchiveBuilder::current()->has_been_buffered((address)native_ptr),\n+              \"Metadata %p should have been archived\", native_ptr);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -373,0 +374,8 @@\n+bool ArchiveUtils::has_aot_initialized_mirror(InstanceKlass* src_ik) {\n+  if (SystemDictionaryShared::is_excluded_class(src_ik)) {\n+    assert(!ArchiveBuilder::current()->has_been_buffered(src_ik), \"sanity\");\n+    return false;\n+  }\n+  return ArchiveBuilder::current()->get_buffered_addr(src_ik)->has_aot_initialized_mirror();\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+template<class E> class Array;\n+template<class E> class GrowableArray;\n+\n@@ -251,0 +254,2 @@\n+  static bool has_aot_initialized_mirror(InstanceKlass* src_ik);\n+  template <typename T> static Array<T>* archive_array(GrowableArray<T>* tmp_array);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"oops\/array.hpp\"\n@@ -31,0 +33,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -50,0 +53,15 @@\n+\/\/ Returns the address of an Array<T> that's allocated in the ArchiveBuilder \"buffer\" space.\n+template <typename T>\n+Array<T>* ArchiveUtils::archive_array(GrowableArray<T>* tmp_array) {\n+  Array<T>* archived_array = ArchiveBuilder::new_ro_array<T>(tmp_array->length());\n+  for (int i = 0; i < tmp_array->length(); i++) {\n+    archived_array->at_put(i, tmp_array->at(i));\n+    if (std::is_pointer<T>::value) {\n+      ArchivePtrMarker::mark_pointer(archived_array->adr_at(i));\n+    }\n+  }\n+\n+  return archived_array;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.inline.hpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -38,0 +39,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -44,0 +46,3 @@\n+bool CDSConfig::_has_aot_linked_classes = false;\n+bool CDSConfig::_has_archived_invokedynamic = false;\n+bool CDSConfig::_old_cds_flags_used = false;\n@@ -328,0 +333,78 @@\n+#define CHECK_ALIAS(f) check_flag_alias(FLAG_IS_DEFAULT(f), #f)\n+\n+void CDSConfig::check_flag_alias(bool alias_is_default, const char* alias_name) {\n+  if (_old_cds_flags_used && !alias_is_default) {\n+    vm_exit_during_initialization(err_msg(\"Option %s cannot be used at the same time with \"\n+                                          \"-Xshare:on, -Xshare:auto, -Xshare:off, -Xshare:dump, \"\n+                                          \"DumpLoadedClassList, SharedClassListFile, or SharedArchiveFile\",\n+                                          alias_name));\n+  }\n+}\n+\n+void CDSConfig::check_flag_aliases() {\n+  if (!FLAG_IS_DEFAULT(DumpLoadedClassList) ||\n+      !FLAG_IS_DEFAULT(SharedClassListFile) ||\n+      !FLAG_IS_DEFAULT(SharedArchiveFile)) {\n+    _old_cds_flags_used = true;\n+  }\n+\n+  CHECK_ALIAS(AOTCache);\n+  CHECK_ALIAS(AOTConfiguration);\n+  CHECK_ALIAS(AOTMode);\n+\n+  if (FLAG_IS_DEFAULT(AOTCache) && FLAG_IS_DEFAULT(AOTConfiguration) && FLAG_IS_DEFAULT(AOTMode)) {\n+    \/\/ Aliases not used.\n+    return;\n+  }\n+\n+  if (FLAG_IS_DEFAULT(AOTMode) || strcmp(AOTMode, \"auto\") == 0 || strcmp(AOTMode, \"on\") == 0) {\n+    if (!FLAG_IS_DEFAULT(AOTConfiguration)) {\n+      vm_exit_during_initialization(\"AOTConfiguration can only be used with -XX:AOTMode=record or -XX:AOTMode=create\");\n+    }\n+\n+    if (!FLAG_IS_DEFAULT(AOTCache)) {\n+      assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n+      FLAG_SET_ERGO(SharedArchiveFile, AOTCache);\n+    }\n+\n+    UseSharedSpaces = true;\n+    if (FLAG_IS_DEFAULT(AOTMode) || (strcmp(AOTMode, \"auto\") == 0)) {\n+      RequireSharedSpaces = false;\n+    } else {\n+      assert(strcmp(AOTMode, \"on\") == 0, \"already checked\");\n+      RequireSharedSpaces = true;\n+    }\n+  } else if (strcmp(AOTMode, \"off\") == 0) {\n+    UseSharedSpaces = false;\n+    RequireSharedSpaces = false;\n+  } else {\n+    \/\/ AOTMode is record or create\n+    if (FLAG_IS_DEFAULT(AOTConfiguration)) {\n+      vm_exit_during_initialization(err_msg(\"-XX:AOTMode=%s cannot be used without setting AOTConfiguration\", AOTMode));\n+    }\n+\n+    if (strcmp(AOTMode, \"record\") == 0) {\n+      if (!FLAG_IS_DEFAULT(AOTCache)) {\n+        vm_exit_during_initialization(\"AOTCache must not be specified when using -XX:AOTMode=record\");\n+      }\n+\n+      assert(FLAG_IS_DEFAULT(DumpLoadedClassList), \"already checked\");\n+      FLAG_SET_ERGO(DumpLoadedClassList, AOTConfiguration);\n+      UseSharedSpaces = false;\n+      RequireSharedSpaces = false;\n+    } else {\n+      assert(strcmp(AOTMode, \"create\") == 0, \"checked by AOTModeConstraintFunc\");\n+      if (FLAG_IS_DEFAULT(AOTCache)) {\n+        vm_exit_during_initialization(\"AOTCache must be specified when using -XX:AOTMode=create\");\n+      }\n+\n+      assert(FLAG_IS_DEFAULT(SharedClassListFile), \"already checked\");\n+      FLAG_SET_ERGO(SharedClassListFile, AOTConfiguration);\n+      assert(FLAG_IS_DEFAULT(SharedArchiveFile), \"already checked\");\n+      FLAG_SET_ERGO(SharedArchiveFile, AOTCache);\n+\n+      CDSConfig::enable_dumping_static_archive();\n+    }\n+  }\n+}\n+\n@@ -329,0 +412,10 @@\n+  check_flag_aliases();\n+\n+  if (AOTClassLinking) {\n+    \/\/ If AOTClassLinking is specified, enable all AOT optimizations by default.\n+    FLAG_SET_ERGO_IF_DEFAULT(AOTInvokeDynamicLinking, true);\n+  } else {\n+    \/\/ AOTInvokeDynamicLinking depends on AOTClassLinking.\n+    FLAG_SET_ERGO(AOTInvokeDynamicLinking, false);\n+  }\n+\n@@ -347,0 +440,3 @@\n+\n+    \/\/ Don't use SoftReferences so that objects used by java.lang.invoke tables can be archived.\n+    Arguments::PropertyList_add(new SystemProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"false\", false));\n@@ -391,0 +487,5 @@\n+bool CDSConfig::allow_only_single_java_thread() {\n+  \/\/ See comments in JVM_StartThread()\n+  return is_dumping_static_archive();\n+}\n+\n@@ -411,0 +512,4 @@\n+bool CDSConfig::is_loading_heap() {\n+  return ArchiveHeapLoader::is_in_use();\n+}\n+\n@@ -449,0 +554,35 @@\n+\n+bool CDSConfig::is_dumping_aot_linked_classes() {\n+  if (is_dumping_dynamic_archive()) {\n+    return is_using_full_module_graph() && AOTClassLinking;\n+  } else if (is_dumping_static_archive()) {\n+    return is_dumping_full_module_graph() && AOTClassLinking;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+bool CDSConfig::is_using_aot_linked_classes() {\n+  \/\/ Make sure we have the exact same module graph as in the assembly phase, or else\n+  \/\/ some aot-linked classes may not be visible so cannot be loaded.\n+  return is_using_full_module_graph() && _has_aot_linked_classes;\n+}\n+\n+void CDSConfig::set_has_aot_linked_classes(bool has_aot_linked_classes) {\n+  _has_aot_linked_classes |= has_aot_linked_classes;\n+}\n+\n+bool CDSConfig::is_initing_classes_at_dump_time() {\n+  return is_dumping_heap() && is_dumping_aot_linked_classes();\n+}\n+\n+bool CDSConfig::is_dumping_invokedynamic() {\n+  \/\/ Requires is_dumping_aot_linked_classes(). Otherwise the classes of some archived heap\n+  \/\/ objects used by the archive indy callsites may be replaced at runtime.\n+  return AOTInvokeDynamicLinking && is_dumping_aot_linked_classes() && is_dumping_heap();\n+}\n+\n+bool CDSConfig::is_loading_invokedynamic() {\n+  return UseSharedSpaces && is_using_full_module_graph() && _has_archived_invokedynamic;\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+  static bool _has_aot_linked_classes;\n+  static bool _has_archived_invokedynamic;\n@@ -43,0 +45,2 @@\n+\n+  static bool  _old_cds_flags_used;\n@@ -50,0 +54,3 @@\n+  static void check_flag_alias(bool alias_is_default, const char* alias_name);\n+  static void check_flag_aliases();\n+\n@@ -60,0 +67,2 @@\n+  static void set_old_cds_flags_used()                       { CDS_ONLY(_old_cds_flags_used = true); }\n+  static bool old_cds_flags_used()                           { return CDS_ONLY(_old_cds_flags_used) NOT_CDS(false); }\n@@ -82,0 +91,3 @@\n+  \/\/ Misc CDS features\n+  static bool allow_only_single_java_thread()                NOT_CDS_RETURN_(false);\n+\n@@ -88,0 +100,4 @@\n+  static bool is_dumping_aot_linked_classes()                NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_using_aot_linked_classes()                  NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static void set_has_aot_linked_classes(bool has_aot_linked_classes) NOT_CDS_JAVA_HEAP_RETURN;\n+\n@@ -99,1 +115,7 @@\n-  static bool   is_dumping_heap()                            NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_dumping_heap()                              NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_loading_heap()                              NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_initing_classes_at_dump_time()              NOT_CDS_JAVA_HEAP_RETURN_(false);\n+\n+  static bool is_dumping_invokedynamic()                     NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_loading_invokedynamic()                     NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static void set_has_archived_invokedynamic()               { CDS_JAVA_HEAP_ONLY(_has_archived_invokedynamic = true); }\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-         InstanceKlass::cast(k)->java_super() == vmClasses::Enum_klass();\n+         InstanceKlass::cast(k)->is_enum_subclass();\n","filename":"src\/hotspot\/share\/cds\/cdsEnumKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassInitializer.hpp\"\n@@ -30,0 +31,3 @@\n+#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -41,1 +45,1 @@\n-\/\/ static field that may be reinitialized at runtime. In the following example,\n+\/\/ static field that may be get a different value at runtime. In the following example,\n@@ -43,1 +47,2 @@\n-\/\/ correctly returns true when CDS disabled, but incorrectly returns false when CDS is enabled.\n+\/\/ correctly returns true when CDS disabled, but incorrectly returns false when CDS is enabled,\n+\/\/ because the archived archivedFoo.bar value is different than Bar.bar.\n@@ -46,1 +51,1 @@\n-\/\/     final Foo archivedFoo; \/\/ this field is archived by CDS\n+\/\/     static final Foo archivedFoo; \/\/ this field is archived by CDS\n@@ -126,0 +131,5 @@\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    ADD_EXCL(\"java\/lang\/invoke\/InvokerBytecodeGenerator\", \"MEMBERNAME_FACTORY\",    \/\/ D\n+                                                          \"INVOKER_SUPER_DESC\");   \/\/ E same as java.lang.constant.ConstantDescs::CD_Object\n+  }\n+\n@@ -133,3 +143,4 @@\n-    log_warning(cds, heap)(\"Scanned %d objects. Found %d case(s) where \"\n-                           \"an object points to a static field that may be \"\n-                           \"reinitialized at runtime.\", _archived_objs, _problems);\n+    log_error(cds, heap)(\"Scanned %d objects. Found %d case(s) where \"\n+                         \"an object points to a static field that \"\n+                         \"may hold a different value at runtime.\", _archived_objs, _problems);\n+    MetaspaceShared::unrecoverable_writing_error();\n@@ -141,1 +152,1 @@\n-  InstanceKlass* _ik;\n+  InstanceKlass* _ik; \/\/ The class whose static fields are being checked.\n@@ -156,1 +167,1 @@\n-      Klass* klass = static_obj_field->klass();\n+      Klass* field_type = static_obj_field->klass();\n@@ -176,5 +187,29 @@\n-      if (klass->has_archived_enum_objs()) {\n-        \/\/ This klass is a subclass of java.lang.Enum. If any instance of this klass\n-        \/\/ has been archived, we will archive all static fields of this klass.\n-        \/\/ See HeapShared::initialize_enum_klass().\n-        return;\n+\n+      if (field_type->is_instance_klass()) {\n+        InstanceKlass* field_ik = InstanceKlass::cast(field_type);\n+        if (field_ik->is_enum_subclass()) {\n+          if (field_ik->has_archived_enum_objs() || ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+            \/\/ This field is an Enum. If any instance of this Enum has been archived, we will archive\n+            \/\/ all static fields of this Enum as well.\n+            return;\n+          }\n+        }\n+\n+        if (field_ik->is_hidden() && ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+          \/\/ We have a static field in a core-library class that points to a method reference, which\n+          \/\/ are safe to archive.\n+          guarantee(_ik->module()->name() == vmSymbols::java_base(), \"sanity\");\n+          return;\n+        }\n+\n+        if (field_ik == vmClasses::MethodType_klass()) {\n+          \/\/ The identity of MethodTypes are preserved between assembly phase and production runs\n+          \/\/ (by MethodType::AOTHolder::archivedMethodTypes). No need to check.\n+          return;\n+        }\n+\n+        if (field_ik == vmClasses::internal_Unsafe_klass() && ArchiveUtils::has_aot_initialized_mirror(field_ik)) {\n+          \/\/ There's only a single instance of jdk\/internal\/misc\/Unsafe, so all references will\n+          \/\/ be pointing to this singleton, which has been archived.\n+          return;\n+        }\n@@ -191,1 +226,2 @@\n-\/\/ loaded.\n+\/\/ loaded. Later, we will check if any archived objects reference one of\n+\/\/ these fields.\n@@ -203,0 +239,6 @@\n+    if (ArchiveUtils::has_aot_initialized_mirror(ik)) {\n+      \/\/ ik's <clinit> won't be executed at runtime, the static fields in\n+      \/\/ ik will carry their values to runtime.\n+      return;\n+    }\n+\n@@ -224,0 +266,3 @@\n+    if (info->_holder->is_hidden()) {\n+      return true;\n+    }\n@@ -225,0 +270,2 @@\n+    char* class_name = info->_holder->name()->as_C_string();\n+    char* field_name = info->_name->as_C_string();\n@@ -226,2 +273,2 @@\n-    ls.print_cr(\"Archive heap points to a static field that may be reinitialized at runtime:\");\n-    ls.print_cr(\"Field: %s::%s\", info->_holder->name()->as_C_string(), info->_name->as_C_string());\n+    ls.print_cr(\"Archive heap points to a static field that may hold a different value at runtime:\");\n+    ls.print_cr(\"Field: %s::%s\", class_name, field_name);\n@@ -269,0 +316,23 @@\n+const char* static_field_name(oop mirror, oop field) {\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n+  if (k->is_instance_klass()) {\n+    for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        fieldDescriptor& fd = fs.field_descriptor();\n+        switch (fd.field_type()) {\n+        case T_OBJECT:\n+        case T_ARRAY:\n+          if (mirror->obj_field(fd.offset()) == field) {\n+            return fs.name()->as_C_string();\n+          }\n+          break;\n+        default:\n+          break;\n+        }\n+      }\n+    }\n+  }\n+\n+  return \"<unknown>\";\n+}\n+\n@@ -283,0 +353,3 @@\n+  if (java_lang_Class::is_instance(orig_obj)) {\n+    st->print(\" (%s::%s)\", java_lang_Class::as_Klass(orig_obj)->external_name(), static_field_name(orig_obj, orig_field));\n+  }\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":90,"deletions":17,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -97,0 +97,24 @@\n+                                                                            \\\n+  \/*========== New \"AOT\" flags =========================================*\/  \\\n+  \/* The following 3 flags are aliases of -Xshare:dump,                 *\/  \\\n+  \/* -XX:SharedArchiveFile=..., etc. See CDSConfig::check_flag_aliases()*\/  \\\n+                                                                            \\\n+  product(ccstr, AOTMode, nullptr,                                          \\\n+          \"Specifies how AOTCache should be created or used. Valid values \" \\\n+          \"are: off, record, create, auto, on; the default is auto\")        \\\n+          constraint(AOTModeConstraintFunc, AtParse)                        \\\n+                                                                            \\\n+  product(ccstr, AOTConfiguration, nullptr,                                 \\\n+          \"Configuration information used by CreateAOTCache\")               \\\n+                                                                            \\\n+  product(ccstr, AOTCache, nullptr,                                         \\\n+          \"Cache for improving start up and warm up\")                       \\\n+                                                                            \\\n+  product(bool, AOTInvokeDynamicLinking, false, DIAGNOSTIC,                 \\\n+          \"AOT-link JVM_CONSTANT_InvokeDynamic entries in cached \"          \\\n+          \"ConstantPools\")                                                  \\\n+                                                                            \\\n+  product(bool, AOTClassLinking, false,                                     \\\n+          \"Load\/link all archived classes for the boot\/platform\/app \"       \\\n+          \"loaders before application main\")                                \\\n+\n","filename":"src\/hotspot\/share\/cds\/cds_globals.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -49,0 +49,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -72,3 +73,7 @@\n-    char errmsg[JVM_MAXPATHLEN];\n-    os::lasterror(errmsg, JVM_MAXPATHLEN);\n-    vm_exit_during_initialization(\"Loading classlist failed\", errmsg);\n+    char reason[JVM_MAXPATHLEN];\n+    os::lasterror(reason, JVM_MAXPATHLEN);\n+    vm_exit_during_initialization(err_msg(\"Loading %s %s failed\",\n+                                          FLAG_IS_DEFAULT(AOTConfiguration) ?\n+                                          \"classlist\" : \"AOTConfiguration file\",\n+                                          file),\n+                                  reason);\n@@ -597,0 +602,12 @@\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ The CP entry for the invokedynamic instruction will be resolved.\n+    \/\/ No need to do the following.\n+    return;\n+  }\n+\n+  \/\/ This is an older CDS optimization:\n+  \/\/ We store a pre-generated version of the lambda proxy class in the AOT cache,\n+  \/\/ which will be loaded via JVM_LookupLambdaProxyClassFromArchive().\n+  \/\/ This eliminate dynamic class generation of the proxy class, but we still need to\n+  \/\/ resolve the CP entry for the invokedynamic instruction, which may result in\n+  \/\/ generation of LambdaForm classes.\n@@ -839,0 +856,2 @@\n+    case JVM_CONSTANT_InvokeDynamic:\n+      preresolve_indy = true;\n@@ -848,1 +867,1 @@\n-    ClassPrelinker::preresolve_class_cp_entries(THREAD, ik, &preresolve_list);\n+    AOTConstantPoolResolver::preresolve_class_cp_entries(THREAD, ik, &preresolve_list);\n@@ -851,1 +870,4 @@\n-    ClassPrelinker::preresolve_field_and_method_cp_entries(THREAD, ik, &preresolve_list);\n+    AOTConstantPoolResolver::preresolve_field_and_method_cp_entries(THREAD, ik, &preresolve_list);\n+  }\n+  if (preresolve_indy) {\n+    AOTConstantPoolResolver::preresolve_indy_cp_entries(THREAD, ik, &preresolve_list);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -131,3 +131,9 @@\n-  \/\/ filter out java\/lang\/invoke\/BoundMethodHandle$Species...\n-  if (cfs != nullptr && cfs->source() != nullptr && strcmp(cfs->source(), \"_ClassSpecializer_generateConcreteSpeciesCode\") == 0) {\n-    return;\n+  if (cfs != nullptr && cfs->source() != nullptr) {\n+    if (strcmp(cfs->source(), \"_ClassSpecializer_generateConcreteSpeciesCode\") == 0) {\n+      return;\n+    }\n+\n+    if (strncmp(cfs->source(), \"__\", 2) == 0) {\n+      \/\/ generated class: __dynamic_proxy__, __JVM_LookupDefineClass__, etc\n+      return;\n+    }\n@@ -259,0 +265,12 @@\n+    Array<ResolvedIndyEntry>* indy_entries = cp->cache()->resolved_indy_entries();\n+    if (indy_entries != nullptr) {\n+      for (int i = 0; i < indy_entries->length(); i++) {\n+        ResolvedIndyEntry* rie = indy_entries->adr_at(i);\n+        int cp_index = rie->constant_pool_index();\n+        if (rie->is_resolved()) {\n+          list.at_put(cp_index, true);\n+          print = true;\n+        }\n+      }\n+    }\n+\n@@ -277,1 +295,2 @@\n-            rme->is_resolved(Bytecodes::_invokeinterface)) {\n+            rme->is_resolved(Bytecodes::_invokeinterface) ||\n+            rme->is_resolved(Bytecodes::_invokehandle)) {\n@@ -294,1 +313,2 @@\n-               cp_tag.value() == JVM_CONSTANT_InterfaceMethodref, \"sanity\");\n+               cp_tag.value() == JVM_CONSTANT_InterfaceMethodref ||\n+               cp_tag.value() == JVM_CONSTANT_InvokeDynamic, \"sanity\");\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1,345 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"cds\/archiveBuilder.hpp\"\n-#include \"cds\/cdsConfig.hpp\"\n-#include \"cds\/classPrelinker.hpp\"\n-#include \"cds\/regeneratedClasses.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"classfile\/systemDictionaryShared.hpp\"\n-#include \"classfile\/vmClasses.hpp\"\n-#include \"interpreter\/bytecodeStream.hpp\"\n-#include \"interpreter\/interpreterRuntime.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/constantPool.inline.hpp\"\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/klass.inline.hpp\"\n-#include \"runtime\/handles.inline.hpp\"\n-\n-ClassPrelinker::ClassesTable* ClassPrelinker::_processed_classes = nullptr;\n-ClassPrelinker::ClassesTable* ClassPrelinker::_vm_classes = nullptr;\n-\n-bool ClassPrelinker::is_vm_class(InstanceKlass* ik) {\n-  return (_vm_classes->get(ik) != nullptr);\n-}\n-\n-void ClassPrelinker::add_one_vm_class(InstanceKlass* ik) {\n-  bool created;\n-  _vm_classes->put_if_absent(ik, &created);\n-  if (created) {\n-    InstanceKlass* super = ik->java_super();\n-    if (super != nullptr) {\n-      add_one_vm_class(super);\n-    }\n-    Array<InstanceKlass*>* ifs = ik->local_interfaces();\n-    for (int i = 0; i < ifs->length(); i++) {\n-      add_one_vm_class(ifs->at(i));\n-    }\n-  }\n-}\n-\n-void ClassPrelinker::initialize() {\n-  assert(_vm_classes == nullptr, \"must be\");\n-  _vm_classes = new (mtClass)ClassesTable();\n-  _processed_classes = new (mtClass)ClassesTable();\n-  for (auto id : EnumRange<vmClassID>{}) {\n-    add_one_vm_class(vmClasses::klass_at(id));\n-  }\n-}\n-\n-void ClassPrelinker::dispose() {\n-  assert(_vm_classes != nullptr, \"must be\");\n-  delete _vm_classes;\n-  delete _processed_classes;\n-  _vm_classes = nullptr;\n-  _processed_classes = nullptr;\n-}\n-\n-\/\/ Returns true if we CAN PROVE that cp_index will always resolve to\n-\/\/ the same information at both dump time and run time. This is a\n-\/\/ necessary (but not sufficient) condition for pre-resolving cp_index\n-\/\/ during CDS archive assembly.\n-bool ClassPrelinker::is_resolution_deterministic(ConstantPool* cp, int cp_index) {\n-  assert(!is_in_archivebuilder_buffer(cp), \"sanity\");\n-\n-  if (cp->tag_at(cp_index).is_klass()) {\n-    \/\/ We require cp_index to be already resolved. This is fine for now, are we\n-    \/\/ currently archive only CP entries that are already resolved.\n-    Klass* resolved_klass = cp->resolved_klass_at(cp_index);\n-    return resolved_klass != nullptr && is_class_resolution_deterministic(cp->pool_holder(), resolved_klass);\n-  } else if (cp->tag_at(cp_index).is_field() ||\n-             cp->tag_at(cp_index).is_method() ||\n-             cp->tag_at(cp_index).is_interface_method()) {\n-    int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n-    if (!cp->tag_at(klass_cp_index).is_klass()) {\n-      \/\/ Not yet resolved\n-      return false;\n-    }\n-    Klass* k = cp->resolved_klass_at(klass_cp_index);\n-    if (!is_class_resolution_deterministic(cp->pool_holder(), k)) {\n-      return false;\n-    }\n-\n-    if (!k->is_instance_klass()) {\n-      \/\/ TODO: support non instance klasses as well.\n-      return false;\n-    }\n-\n-    \/\/ Here, We don't check if this entry can actually be resolved to a valid Field\/Method.\n-    \/\/ This method should be called by the ConstantPool to check Fields\/Methods that\n-    \/\/ have already been successfully resolved.\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-bool ClassPrelinker::is_class_resolution_deterministic(InstanceKlass* cp_holder, Klass* resolved_class) {\n-  assert(!is_in_archivebuilder_buffer(cp_holder), \"sanity\");\n-  assert(!is_in_archivebuilder_buffer(resolved_class), \"sanity\");\n-\n-  if (resolved_class->is_instance_klass()) {\n-    InstanceKlass* ik = InstanceKlass::cast(resolved_class);\n-\n-    if (!ik->is_shared() && SystemDictionaryShared::is_excluded_class(ik)) {\n-      return false;\n-    }\n-\n-    if (cp_holder->is_subtype_of(ik)) {\n-      \/\/ All super types of ik will be resolved in ik->class_loader() before\n-      \/\/ ik is defined in this loader, so it's safe to archive the resolved klass reference.\n-      return true;\n-    }\n-\n-    if (is_vm_class(ik)) {\n-      if (ik->class_loader() != cp_holder->class_loader()) {\n-        \/\/ At runtime, cp_holder() may not be able to resolve to the same\n-        \/\/ ik. For example, a different version of ik may be defined in\n-        \/\/ cp->pool_holder()'s loader using MethodHandles.Lookup.defineClass().\n-        return false;\n-      } else {\n-        return true;\n-      }\n-    }\n-  } else if (resolved_class->is_objArray_klass()) {\n-    Klass* elem = ObjArrayKlass::cast(resolved_class)->bottom_klass();\n-    if (elem->is_instance_klass()) {\n-      return is_class_resolution_deterministic(cp_holder, InstanceKlass::cast(elem));\n-    } else if (elem->is_typeArray_klass()) {\n-      return true;\n-    }\n-  } else if (resolved_class->is_typeArray_klass()) {\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n-void ClassPrelinker::dumptime_resolve_constants(InstanceKlass* ik, TRAPS) {\n-  if (!ik->is_linked()) {\n-    return;\n-  }\n-  bool first_time;\n-  _processed_classes->put_if_absent(ik, &first_time);\n-  if (!first_time) {\n-    \/\/ We have already resolved the constants in class, so no need to do it again.\n-    return;\n-  }\n-\n-  constantPoolHandle cp(THREAD, ik->constants());\n-  for (int cp_index = 1; cp_index < cp->length(); cp_index++) { \/\/ Index 0 is unused\n-    switch (cp->tag_at(cp_index).value()) {\n-    case JVM_CONSTANT_String:\n-      resolve_string(cp, cp_index, CHECK); \/\/ may throw OOM when interning strings.\n-      break;\n-    }\n-  }\n-}\n-\n-\/\/ This works only for the boot\/platform\/app loaders\n-Klass* ClassPrelinker::find_loaded_class(Thread* current, oop class_loader, Symbol* name) {\n-  HandleMark hm(current);\n-  Handle h_loader(current, class_loader);\n-  Klass* k = SystemDictionary::find_instance_or_array_klass(current, name,\n-                                                            h_loader,\n-                                                            Handle());\n-  if (k != nullptr) {\n-    return k;\n-  }\n-  if (h_loader() == SystemDictionary::java_system_loader()) {\n-    return find_loaded_class(current, SystemDictionary::java_platform_loader(), name);\n-  } else if (h_loader() == SystemDictionary::java_platform_loader()) {\n-    return find_loaded_class(current, nullptr, name);\n-  } else {\n-    assert(h_loader() == nullptr, \"This function only works for boot\/platform\/app loaders %p %p %p\",\n-           cast_from_oop<address>(h_loader()),\n-           cast_from_oop<address>(SystemDictionary::java_system_loader()),\n-           cast_from_oop<address>(SystemDictionary::java_platform_loader()));\n-  }\n-\n-  return nullptr;\n-}\n-\n-Klass* ClassPrelinker::find_loaded_class(Thread* current, ConstantPool* cp, int class_cp_index) {\n-  Symbol* name = cp->klass_name_at(class_cp_index);\n-  return find_loaded_class(current, cp->pool_holder()->class_loader(), name);\n-}\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-void ClassPrelinker::resolve_string(constantPoolHandle cp, int cp_index, TRAPS) {\n-  if (CDSConfig::is_dumping_heap()) {\n-    int cache_index = cp->cp_to_object_index(cp_index);\n-    ConstantPool::string_at_impl(cp, cp_index, cache_index, CHECK);\n-  }\n-}\n-#endif\n-\n-void ClassPrelinker::preresolve_class_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list) {\n-  if (!SystemDictionaryShared::is_builtin_loader(ik->class_loader_data())) {\n-    return;\n-  }\n-\n-  JavaThread* THREAD = current;\n-  constantPoolHandle cp(THREAD, ik->constants());\n-  for (int cp_index = 1; cp_index < cp->length(); cp_index++) {\n-    if (cp->tag_at(cp_index).value() == JVM_CONSTANT_UnresolvedClass) {\n-      if (preresolve_list != nullptr && preresolve_list->at(cp_index) == false) {\n-        \/\/ This class was not resolved during trial run. Don't attempt to resolve it. Otherwise\n-        \/\/ the compiler may generate less efficient code.\n-        continue;\n-      }\n-      if (find_loaded_class(current, cp(), cp_index) == nullptr) {\n-        \/\/ Do not resolve any class that has not been loaded yet\n-        continue;\n-      }\n-      Klass* resolved_klass = cp->klass_at(cp_index, THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-        CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n-      } else {\n-        log_trace(cds, resolve)(\"Resolved class  [%3d] %s -> %s\", cp_index, ik->external_name(),\n-                                resolved_klass->external_name());\n-      }\n-    }\n-  }\n-}\n-\n-void ClassPrelinker::preresolve_field_and_method_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list) {\n-  JavaThread* THREAD = current;\n-  constantPoolHandle cp(THREAD, ik->constants());\n-  if (cp->cache() == nullptr) {\n-    return;\n-  }\n-  for (int i = 0; i < ik->methods()->length(); i++) {\n-    Method* m = ik->methods()->at(i);\n-    BytecodeStream bcs(methodHandle(THREAD, m));\n-    while (!bcs.is_last_bytecode()) {\n-      bcs.next();\n-      Bytecodes::Code raw_bc = bcs.raw_code();\n-      switch (raw_bc) {\n-      case Bytecodes::_getfield:\n-      case Bytecodes::_putfield:\n-        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n-        if (HAS_PENDING_EXCEPTION) {\n-          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n-        }\n-        break;\n-      case Bytecodes::_invokespecial:\n-      case Bytecodes::_invokevirtual:\n-      case Bytecodes::_invokeinterface:\n-        maybe_resolve_fmi_ref(ik, m, raw_bc, bcs.get_index_u2(), preresolve_list, THREAD);\n-        if (HAS_PENDING_EXCEPTION) {\n-          CLEAR_PENDING_EXCEPTION; \/\/ just ignore\n-        }\n-        break;\n-      default:\n-        break;\n-      }\n-    }\n-  }\n-}\n-\n-void ClassPrelinker::maybe_resolve_fmi_ref(InstanceKlass* ik, Method* m, Bytecodes::Code bc, int raw_index,\n-                                           GrowableArray<bool>* preresolve_list, TRAPS) {\n-  methodHandle mh(THREAD, m);\n-  constantPoolHandle cp(THREAD, ik->constants());\n-  HandleMark hm(THREAD);\n-  int cp_index = cp->to_cp_index(raw_index, bc);\n-\n-  if (cp->is_resolved(raw_index, bc)) {\n-    return;\n-  }\n-\n-  if (preresolve_list != nullptr && preresolve_list->at(cp_index) == false) {\n-    \/\/ This field wasn't resolved during the trial run. Don't attempt to resolve it. Otherwise\n-    \/\/ the compiler may generate less efficient code.\n-    return;\n-  }\n-\n-  int klass_cp_index = cp->uncached_klass_ref_index_at(cp_index);\n-  if (find_loaded_class(THREAD, cp(), klass_cp_index) == nullptr) {\n-    \/\/ Do not resolve any field\/methods from a class that has not been loaded yet.\n-    return;\n-  }\n-\n-  Klass* resolved_klass = cp->klass_ref_at(raw_index, bc, CHECK);\n-\n-  switch (bc) {\n-  case Bytecodes::_getfield:\n-  case Bytecodes::_putfield:\n-    InterpreterRuntime::resolve_get_put(bc, raw_index, mh, cp, false \/*initialize_holder*\/, CHECK);\n-    break;\n-\n-  case Bytecodes::_invokevirtual:\n-  case Bytecodes::_invokespecial:\n-  case Bytecodes::_invokeinterface:\n-    InterpreterRuntime::cds_resolve_invoke(bc, raw_index, cp, CHECK);\n-    break;\n-\n-  default:\n-    ShouldNotReachHere();\n-  }\n-\n-  if (log_is_enabled(Trace, cds, resolve)) {\n-    ResourceMark rm(THREAD);\n-    bool resolved = cp->is_resolved(raw_index, bc);\n-    Symbol* name = cp->name_ref_at(raw_index, bc);\n-    Symbol* signature = cp->signature_ref_at(raw_index, bc);\n-    log_trace(cds, resolve)(\"%s %s [%3d] %s -> %s.%s:%s\",\n-                            (resolved ? \"Resolved\" : \"Failed to resolve\"),\n-                            Bytecodes::name(bc), cp_index, ik->external_name(),\n-                            resolved_klass->external_name(),\n-                            name->as_C_string(), signature->as_C_string());\n-  }\n-}\n-\n-#ifdef ASSERT\n-bool ClassPrelinker::is_in_archivebuilder_buffer(address p) {\n-  if (!Thread::current()->is_VM_thread() || ArchiveBuilder::current() == nullptr) {\n-    return false;\n-  } else {\n-    return ArchiveBuilder::current()->is_in_buffer_space(p);\n-  }\n-}\n-#endif\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.cpp","additions":0,"deletions":345,"binary":false,"changes":345,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_CDS_CLASSPRELINKER_HPP\n-#define SHARE_CDS_CLASSPRELINKER_HPP\n-\n-#include \"interpreter\/bytecodes.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-#include \"memory\/allStatic.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"runtime\/handles.hpp\"\n-#include \"utilities\/exceptions.hpp\"\n-#include \"utilities\/macros.hpp\"\n-#include \"utilities\/resourceHash.hpp\"\n-\n-class ConstantPool;\n-class constantPoolHandle;\n-class InstanceKlass;\n-class Klass;\n-\n-\/\/ ClassPrelinker is used to perform ahead-of-time linking of ConstantPool entries\n-\/\/ for archived InstanceKlasses.\n-\/\/\n-\/\/ At run time, Java classes are loaded dynamically and may be replaced with JVMTI.\n-\/\/ Therefore, we take care to prelink only the ConstantPool entries that are\n-\/\/ guatanteed to resolve to the same results at both dump time and run time.\n-\/\/\n-\/\/ For example, a JVM_CONSTANT_Class reference to a supertype can be safely resolved\n-\/\/ at dump time, because at run time we will load a class from the CDS archive only\n-\/\/ if all of its supertypes are loaded from the CDS archive.\n-class ClassPrelinker :  AllStatic {\n-  using ClassesTable = ResourceHashtable<InstanceKlass*, bool, 15889, AnyObj::C_HEAP, mtClassShared> ;\n-  static ClassesTable* _processed_classes;\n-  static ClassesTable* _vm_classes;\n-\n-  static void add_one_vm_class(InstanceKlass* ik);\n-\n-#ifdef ASSERT\n-  static bool is_in_archivebuilder_buffer(address p);\n-#endif\n-\n-  template <typename T>\n-  static bool is_in_archivebuilder_buffer(T p) {\n-    return is_in_archivebuilder_buffer((address)(p));\n-  }\n-  static void resolve_string(constantPoolHandle cp, int cp_index, TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n-  static bool is_class_resolution_deterministic(InstanceKlass* cp_holder, Klass* resolved_class);\n-\n-  static Klass* find_loaded_class(Thread* current, oop class_loader, Symbol* name);\n-  static Klass* find_loaded_class(Thread* current, ConstantPool* cp, int class_cp_index);\n-\n-  \/\/ fmi = FieldRef\/MethodRef\/InterfaceMethodRef\n-  static void maybe_resolve_fmi_ref(InstanceKlass* ik, Method* m, Bytecodes::Code bc, int raw_index,\n-                                    GrowableArray<bool>* resolve_fmi_list, TRAPS);\n-public:\n-  static void initialize();\n-  static void dispose();\n-\n-  static void preresolve_class_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list);\n-  static void preresolve_field_and_method_cp_entries(JavaThread* current, InstanceKlass* ik, GrowableArray<bool>* preresolve_list);\n-\n-  \/\/ Is this class resolved as part of vmClasses::resolve_all()? If so, these\n-  \/\/ classes are guatanteed to be loaded at runtime (and cannot be replaced by JVMTI)\n-  \/\/ when CDS is enabled. Therefore, we can safely keep a direct reference to these\n-  \/\/ classes.\n-  static bool is_vm_class(InstanceKlass* ik);\n-\n-  \/\/ Resolve all constant pool entries that are safe to be stored in the\n-  \/\/ CDS archive.\n-  static void dumptime_resolve_constants(InstanceKlass* ik, TRAPS);\n-\n-  static bool is_resolution_deterministic(ConstantPool* cp, int cp_index);\n-};\n-\n-#endif \/\/ SHARE_CDS_CLASSPRELINKER_HPP\n","filename":"src\/hotspot\/share\/cds\/classPrelinker.hpp","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassLinker.hpp\"\n@@ -117,0 +118,6 @@\n+  msg.info(\"Indy   CP entries = %6d, archived = %6d (%5.1f%%), reverted = %6d\",\n+           _num_indy_cp_entries, _num_indy_cp_entries_archived,\n+           percent_of(_num_indy_cp_entries_archived, _num_indy_cp_entries),\n+           _num_indy_cp_entries_reverted);\n+  msg.info(\"Platform loader initiated classes = %5d\", AOTClassLinker::num_platform_initiated_classes());\n+  msg.info(\"App      loader initiated classes = %5d\", AOTClassLinker::num_app_initiated_classes());\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -71,0 +71,3 @@\n+  int _num_indy_cp_entries;\n+  int _num_indy_cp_entries_archived;\n+  int _num_indy_cp_entries_reverted;\n@@ -87,0 +90,3 @@\n+    _num_indy_cp_entries            = 0;\n+    _num_indy_cp_entries_archived   = 0;\n+    _num_indy_cp_entries_reverted   = 0;\n@@ -125,0 +131,6 @@\n+  void record_indy_cp_entry(bool archived, bool reverted) {\n+    _num_indy_cp_entries ++;\n+    _num_indy_cp_entries_archived += archived ? 1 : 0;\n+    _num_indy_cp_entries_reverted += reverted ? 1 : 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,2 @@\n-\n+  bool                         _is_required_hidden_class;\n+  bool                         _has_scanned_constant_pool;\n@@ -140,0 +141,2 @@\n+    _is_required_hidden_class = false;\n+    _has_scanned_constant_pool = false;\n@@ -217,0 +220,5 @@\n+  bool is_required_hidden_class() const             { return _is_required_hidden_class; }\n+  void set_is_required_hidden_class()               { _is_required_hidden_class = true; }\n+  bool has_scanned_constant_pool() const            { return _has_scanned_constant_pool; }\n+  void set_has_scanned_constant_pool()              { _has_scanned_constant_pool = true; }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassLinker.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -50,1 +50,0 @@\n-#include \"runtime\/vmThread.hpp\"\n@@ -52,0 +51,1 @@\n+#include \"runtime\/vmThread.hpp\"\n@@ -115,1 +115,1 @@\n-    SystemDictionaryShared::check_excluded_classes();\n+    SystemDictionaryShared::find_all_archivable_classes();\n@@ -138,0 +138,5 @@\n+    sort_methods();\n+\n+    log_info(cds)(\"Make classes shareable\");\n+    make_klasses_shareable();\n+\n@@ -150,0 +155,1 @@\n+      AOTClassLinker::write_to_archive();\n@@ -158,5 +164,0 @@\n-    sort_methods();\n-\n-    log_info(cds)(\"Make classes shareable\");\n-    make_klasses_shareable();\n-\n@@ -237,1 +238,1 @@\n-  ClassPrelinker::dispose();\n+  AOTClassLinker::dispose();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -217,0 +217,1 @@\n+  _has_aot_linked_classes = CDSConfig::is_dumping_aot_linked_classes();\n@@ -218,0 +219,1 @@\n+  _has_archived_invokedynamic = CDSConfig::is_dumping_invokedynamic();\n@@ -304,0 +306,2 @@\n+  st->print_cr(\"- has_aot_linked_classes          %d\", _has_aot_linked_classes);\n+  st->print_cr(\"- has_archived_invokedynamic      %d\", _has_archived_invokedynamic);\n@@ -1051,1 +1055,5 @@\n-  validate_non_existent_class_paths();\n+  if (!validate_non_existent_class_paths()) {\n+    return false;\n+  }\n+\n+  check_main_module_name();\n@@ -1067,1 +1075,1 @@\n-void FileMapInfo::validate_non_existent_class_paths() {\n+bool FileMapInfo::validate_non_existent_class_paths() {\n@@ -1080,3 +1088,9 @@\n-      log_warning(cds)(\"Archived non-system classes are disabled because the \"\n-              \"file %s exists\", ent->name());\n-      header()->set_has_platform_or_app_classes(false);\n+      if (header()->has_aot_linked_classes()) {\n+        log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used because the \"\n+                       \"file %s exists\", ent->name());\n+        return false;\n+      } else {\n+        log_warning(cds)(\"Archived non-system classes are disabled because the \"\n+                         \"file %s exists\", ent->name());\n+        header()->set_has_platform_or_app_classes(false);\n+      }\n@@ -1085,0 +1099,2 @@\n+\n+  return true;\n@@ -2066,1 +2082,10 @@\n-    CDSConfig::stop_using_full_module_graph();\n+    if (CDSConfig::is_using_aot_linked_classes()) {\n+      \/\/ It's too late to recover -- we have already committed to use the archived metaspace objects, but\n+      \/\/ the archived heap objects cannot be loaded, so we don't have the archived FMG to guarantee that\n+      \/\/ all AOT-linked classes are visible.\n+      \/\/\n+      \/\/ We get here because the heap is too small. The app will fail anyway. So let's quit.\n+      MetaspaceShared::unrecoverable_loading_error(\"CDS archive has aot-linked classes but the archived \"\n+                                                   \"heap objects cannot be loaded. Try increasing your heap size.\");\n+    }\n+    CDSConfig::stop_using_full_module_graph(\"archive heap loading failed\");\n@@ -2395,0 +2420,58 @@\n+bool FileMapInfo::validate_aot_class_linking() {\n+  \/\/ These checks need to be done after FileMapInfo::initialize(), which gets called before Universe::heap()\n+  \/\/ is available.\n+  if (header()->has_aot_linked_classes()) {\n+    CDSConfig::set_has_aot_linked_classes(true);\n+    if (JvmtiExport::should_post_class_file_load_hook()) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when JVMTI ClassFileLoadHook is in use.\");\n+      return false;\n+    }\n+    if (JvmtiExport::has_early_vmstart_env()) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when JVMTI early vm start is in use.\");\n+      return false;\n+    }\n+    if (!CDSConfig::is_using_full_module_graph()) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when archived full module graph is not used.\");\n+      return false;\n+    }\n+\n+    const char* prop = Arguments::get_property(\"java.security.manager\");\n+    if (prop != nullptr && strcmp(prop, \"disallow\") != 0) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used with -Djava.security.manager=%s.\", prop);\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+void FileMapInfo::check_main_module_name() {\n+  const char* runtime_main_module_name = Arguments::get_property(\"jdk.module.main\");\n+  const char* archived_main_module_name = main_module_name();\n+  bool no_archived_main_module_name = strcmp(archived_main_module_name, \"\") == 0;\n+\n+  log_info(cds)(\"_archived_main_module_name: '%s'\", archived_main_module_name);\n+  bool disable = false;\n+  if (runtime_main_module_name == nullptr) {\n+    if (!no_archived_main_module_name) {\n+      log_info(cds)(\"Module %s specified during dump time but not during runtime\", archived_main_module_name);\n+      disable = true;\n+    }\n+  } else {\n+    if (no_archived_main_module_name) {\n+      log_info(cds)(\"Module %s specified during runtime but not during dump time\", runtime_main_module_name);\n+      disable = true;\n+    } else if (strcmp(runtime_main_module_name, archived_main_module_name) != 0) {\n+      log_info(cds)(\"Mismatched modules: runtime %s dump time %s\", runtime_main_module_name, archived_main_module_name);\n+      disable = true;\n+    }\n+  }\n+\n+  if (disable) {\n+    log_info(cds)(\"Disabling optimized module handling\");\n+    CDSConfig::stop_using_optimized_module_handling();\n+  }\n+  log_info(cds)(\"optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n+  log_info(cds)(\"full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n+}\n+\n@@ -2444,0 +2527,5 @@\n+    if (has_aot_linked_classes()) {\n+      log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used when the \"\n+                     \"java.system.class.loader property is specified.\");\n+      return false;\n+    }\n@@ -2505,1 +2593,1 @@\n-  if (is_static() && !_has_full_module_graph) {\n+  if (is_static()) {\n@@ -2507,1 +2595,7 @@\n-    CDSConfig::stop_using_full_module_graph(\"archive was created without full module graph\");\n+    if (!_has_full_module_graph) {\n+      CDSConfig::stop_using_full_module_graph(\"archive was created without full module graph\");\n+    }\n+\n+    if (_has_archived_invokedynamic) {\n+      CDSConfig::set_has_archived_invokedynamic();\n+    }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":102,"deletions":8,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -214,0 +214,1 @@\n+  size_t _main_module_name_offset;      \/\/ property of \"jdk.module.main\"\n@@ -228,0 +229,1 @@\n+  bool   _has_aot_linked_classes;       \/\/ Was the CDS archive created with -XX:+AOTClassLinking\n@@ -229,0 +231,1 @@\n+  bool   _has_archived_invokedynamic;   \/\/ Does the archive have aot-linked invokedynamic CP entries?\n@@ -266,0 +269,1 @@\n+  char* main_module_name()                 const { return from_mapped_offset(_main_module_name_offset); }\n@@ -271,0 +275,1 @@\n+  bool has_aot_linked_classes()            const { return _has_aot_linked_classes; }\n@@ -288,0 +293,1 @@\n+  void set_main_module_name(char* p)             { set_as_offset(p, &_main_module_name_offset); }\n@@ -402,0 +408,2 @@\n+  char* main_module_name()                    const { return header()->main_module_name(); }\n+  void  set_main_module_name(char* p)         const { header()->set_main_module_name(p); }\n@@ -485,1 +493,3 @@\n-  void validate_non_existent_class_paths();\n+  bool validate_non_existent_class_paths();\n+  bool validate_aot_class_linking();\n+  void check_main_module_name();\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassInitializer.hpp\"\n@@ -100,1 +101,1 @@\n-static const Klass* _test_class = nullptr;\n+static Klass* _test_class = nullptr;\n@@ -122,0 +123,1 @@\n+\n@@ -136,1 +138,2 @@\n-KlassSubGraphInfo* HeapShared::_default_subgraph_info;\n+KlassSubGraphInfo* HeapShared::_dump_time_special_subgraph;\n+ArchivedKlassSubGraphInfoRecord* HeapShared::_run_time_special_subgraph;\n@@ -301,0 +304,1 @@\n+    debug_trace();\n@@ -312,2 +316,13 @@\n-      log_debug(cds, heap)(\"Archived heap object \" PTR_FORMAT \" : %s\",\n-                           p2i(obj), obj->klass()->external_name());\n+      LogTarget(Debug, cds, heap) log;\n+      LogStream out(log);\n+      out.print(\"Archived heap object \" PTR_FORMAT \" : %s \",\n+                p2i(obj), obj->klass()->external_name());\n+      if (java_lang_Class::is_instance(obj)) {\n+        Klass* k = java_lang_Class::as_Klass(obj);\n+        if (k != nullptr) {\n+          out.print(\"%s\", k->external_name());\n+        } else {\n+          out.print(\"primitive\");\n+        }\n+      }\n+      out.cr();\n@@ -374,0 +389,25 @@\n+\/\/ Given java_mirror that represents a (primitive or reference) type T,\n+\/\/ return the \"scratch\" version that represents the same type T.\n+\/\/ Note that if java_mirror will be returned if it's already a\n+\/\/ scratch mirror.\n+\/\/\n+\/\/ See java_lang_Class::create_scratch_mirror() for more info.\n+oop HeapShared::scratch_java_mirror(oop java_mirror) {\n+  assert(java_lang_Class::is_instance(java_mirror), \"must be\");\n+\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    BasicType bt = (BasicType)i;\n+    if (!is_reference_type(bt)) {\n+      if (_scratch_basic_type_mirrors[i].resolve() == java_mirror) {\n+        return java_mirror;\n+      }\n+    }\n+  }\n+\n+  if (java_lang_Class::is_primitive(java_mirror)) {\n+    return scratch_java_mirror(java_lang_Class::as_BasicType(java_mirror));\n+  } else {\n+    return scratch_java_mirror(java_lang_Class::as_Klass(java_mirror));\n+  }\n+}\n+\n@@ -402,0 +442,109 @@\n+\/\/TODO: we eventually want a more direct test for these kinds of things.\n+\/\/For example the JVM could record some bit of context from the creation\n+\/\/of the klass, such as who called the hidden class factory.  Using\n+\/\/string compares on names is fragile and will break as soon as somebody\n+\/\/changes the names in the JDK code.  See discussion in JDK-8342481 for\n+\/\/related ideas about marking AOT-related classes.\n+bool HeapShared::is_lambda_form_klass(InstanceKlass* ik) {\n+  return ik->is_hidden() &&\n+    (ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$MH+\") ||\n+     ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$DMH+\") ||\n+     ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$BMH+\"));\n+}\n+\n+bool HeapShared::is_lambda_proxy_klass(InstanceKlass* ik) {\n+  return ik->is_hidden() && (ik->name()->index_of_at(0, \"$$Lambda+\", 9) > 0);\n+}\n+\n+bool HeapShared::is_string_concat_klass(InstanceKlass* ik) {\n+  return ik->is_hidden() && ik->name()->starts_with(\"java\/lang\/String$$StringConcat\");\n+}\n+\n+bool HeapShared::is_archivable_hidden_klass(InstanceKlass* ik) {\n+  return CDSConfig::is_dumping_invokedynamic() &&\n+    (is_lambda_form_klass(ik) || is_lambda_proxy_klass(ik) || is_string_concat_klass(ik));\n+}\n+\n+void HeapShared::copy_aot_initialized_mirror(Klass* orig_k, oop orig_mirror, oop m) {\n+  assert(orig_k->is_instance_klass(), \"sanity\");\n+  InstanceKlass* ik = InstanceKlass::cast(orig_k);\n+  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(ik);\n+\n+  assert(ik->is_initialized(), \"must be\");\n+\n+  int nfields = 0;\n+  for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      int offset = fd.offset();\n+      switch (fd.field_type()) {\n+      case T_OBJECT:\n+      case T_ARRAY:\n+        m->obj_field_put(offset, orig_mirror->obj_field(offset));\n+        break;\n+      case T_BOOLEAN:\n+        m->bool_field_put(offset, orig_mirror->bool_field(offset));\n+        break;\n+      case T_BYTE:\n+        m->byte_field_put(offset, orig_mirror->byte_field(offset));\n+        break;\n+      case T_SHORT:\n+        m->short_field_put(offset, orig_mirror->short_field(offset));\n+        break;\n+      case T_CHAR:\n+        m->char_field_put(offset, orig_mirror->char_field(offset));\n+        break;\n+      case T_INT:\n+        m->int_field_put(offset, orig_mirror->int_field(offset));\n+        break;\n+      case T_LONG:\n+        m->long_field_put(offset, orig_mirror->long_field(offset));\n+        break;\n+      case T_FLOAT:\n+        m->float_field_put(offset, orig_mirror->float_field(offset));\n+        break;\n+      case T_DOUBLE:\n+        m->double_field_put(offset, orig_mirror->double_field(offset));\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+      }\n+      nfields ++;\n+    }\n+  }\n+\n+  java_lang_Class::set_class_data(m, java_lang_Class::class_data(orig_mirror));\n+\n+  \/\/ Class::reflectData use SoftReference, which cannot be archived. Set it\n+  \/\/ to null and it will be recreated at runtime.\n+  java_lang_Class::set_reflection_data(m, nullptr);\n+\n+  if (log_is_enabled(Info, cds, init)) {\n+    ResourceMark rm;\n+    log_debug(cds, init)(\"copied %3d field(s) in aot-initialized mirror %s%s\", nfields, ik->external_name(),\n+                         ik->is_hidden() ? \" (hidden)\" : \"\");\n+  }\n+}\n+\n+static void copy_java_mirror_hashcode(oop orig_mirror, oop scratch_m) {\n+  int src_hash = orig_mirror->identity_hash();\n+  scratch_m->set_mark(markWord::prototype().copy_set_hash(src_hash));\n+  assert(scratch_m->mark().is_unlocked(), \"sanity\");\n+\n+  DEBUG_ONLY(int archived_hash = scratch_m->identity_hash());\n+  assert(src_hash == archived_hash, \"Java mirror wrong hash: original %x, scratch %x\", src_hash, archived_hash);\n+}\n+\n+static objArrayOop get_archived_resolved_references(InstanceKlass* src_ik) {\n+  InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n+  if (buffered_ik->is_shared_boot_class() ||\n+      buffered_ik->is_shared_platform_class() ||\n+      buffered_ik->is_shared_app_class()) {\n+    objArrayOop rr = src_ik->constants()->resolved_references_or_null();\n+    if (rr != nullptr && !ArchiveHeapWriter::is_too_large_to_archive(rr)) {\n+      return HeapShared::scratch_resolved_references(src_ik->constants());\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -406,0 +555,1 @@\n+      oop orig_mirror = Universe::java_mirror(bt);\n@@ -408,1 +558,2 @@\n-      bool success = archive_reachable_objects_from(1, _default_subgraph_info, m);\n+      copy_java_mirror_hashcode(orig_mirror, m);\n+      bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, m);\n@@ -421,0 +572,1 @@\n+\n@@ -423,0 +575,10 @@\n+    oop orig_mirror = orig_k->java_mirror();\n+    oop m = scratch_java_mirror(orig_k);\n+    if (m != nullptr) {\n+      copy_java_mirror_hashcode(orig_mirror, m);\n+    }\n+  }\n+\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* orig_k = klasses->at(i);\n+    oop orig_mirror = orig_k->java_mirror();\n@@ -426,1 +588,1 @@\n-      bool success = archive_reachable_objects_from(1, _default_subgraph_info, m);\n+      bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, m);\n@@ -437,3 +599,3 @@\n-        oop rr = ik->constants()->prepare_resolved_references_for_archiving();\n-        if (rr != nullptr && !ArchiveHeapWriter::is_too_large_to_archive(rr)) {\n-          bool success = HeapShared::archive_reachable_objects_from(1, _default_subgraph_info, rr);\n+        objArrayOop rr = get_archived_resolved_references(InstanceKlass::cast(orig_k));\n+        if (rr != nullptr) {\n+          bool success = HeapShared::archive_reachable_objects_from(1, _dump_time_special_subgraph, rr);\n@@ -451,1 +613,1 @@\n-  bool success = archive_reachable_objects_from(1, _default_subgraph_info, shared_strings_array);\n+  bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, shared_strings_array);\n@@ -460,1 +622,1 @@\n-  bool success = archive_reachable_objects_from(1, _default_subgraph_info, exception);\n+  bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, exception);\n@@ -469,0 +631,2 @@\n+  } else if (java_lang_invoke_ResolvedMethodName::is_instance(orig_obj)) {\n+    ArchiveHeapWriter::mark_native_pointer(orig_obj, java_lang_invoke_ResolvedMethodName::vmtarget_offset());\n@@ -485,0 +649,108 @@\n+void HeapShared::start_finding_required_hidden_classes() {\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    return;\n+  }\n+  NoSafepointVerifier nsv;\n+\n+  init_seen_objects_table();\n+\n+  \/\/ We first scan the objects that are known to be archived (from the archive_subgraph\n+  \/\/ tables)\n+  find_required_hidden_classes_helper(archive_subgraph_entry_fields);\n+  if (CDSConfig::is_dumping_full_module_graph()) {\n+    find_required_hidden_classes_helper(fmg_archive_subgraph_entry_fields);\n+  }\n+\n+  \/\/ Later, SystemDictionaryShared::find_all_archivable_classes_impl() will start\n+  \/\/ scanning the constant pools of all classes that it decides to archive.\n+}\n+\n+void HeapShared::end_finding_required_hidden_classes() {\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    return;\n+  }\n+  NoSafepointVerifier nsv;\n+\n+  delete_seen_objects_table();\n+}\n+\n+void HeapShared::find_required_hidden_classes_helper(ArchivableStaticFieldInfo fields[]) {\n+  if (!CDSConfig::is_dumping_heap()) {\n+    return;\n+  }\n+  for (int i = 0; fields[i].valid(); i++) {\n+    ArchivableStaticFieldInfo* f = &fields[i];\n+    InstanceKlass* k = f->klass;\n+    oop m = k->java_mirror();\n+    oop o = m->obj_field(f->offset);\n+    if (o != nullptr) {\n+      find_required_hidden_classes_in_object(o);\n+    }\n+  }\n+}\n+\n+class HeapShared::FindRequiredHiddenClassesOopClosure: public BasicOopIterateClosure {\n+  GrowableArray<oop> _stack;\n+  template <class T> void do_oop_work(T *p) {\n+    \/\/ Recurse on a GrowableArray to avoid overflowing the C stack.\n+    oop o = RawAccess<>::oop_load(p);\n+    if (o != nullptr) {\n+      _stack.append(o);\n+    }\n+  }\n+\n+ public:\n+\n+  void do_oop(narrowOop *p) { FindRequiredHiddenClassesOopClosure::do_oop_work(p); }\n+  void do_oop(      oop *p) { FindRequiredHiddenClassesOopClosure::do_oop_work(p); }\n+\n+  FindRequiredHiddenClassesOopClosure(oop o) {\n+    _stack.append(o);\n+  }\n+  oop pop() {\n+    if (_stack.length() == 0) {\n+      return nullptr;\n+    } else {\n+      return _stack.pop();\n+    }\n+  }\n+};\n+\n+static void mark_required_if_hidden_class(Klass* k) {\n+  if (k != nullptr && k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    if (ik->is_hidden()) {\n+      SystemDictionaryShared::mark_required_hidden_class(ik);\n+    }\n+  }\n+}\n+\n+\n+void HeapShared::find_required_hidden_classes_in_object(oop root) {\n+  ResourceMark rm;\n+  FindRequiredHiddenClassesOopClosure c(root);\n+  oop o;\n+  while ((o = c.pop()) != nullptr) {\n+    if (!has_been_seen_during_subgraph_recording(o)) {\n+      set_has_been_seen_during_subgraph_recording(o);\n+\n+      \/\/ Mark the klass of this object\n+      mark_required_if_hidden_class(o->klass());\n+\n+      \/\/ For special objects, mark the klass that they contain information about.\n+      \/\/ - a Class that refers to an hidden class\n+      \/\/ - a ResolvedMethodName that refers to a method declared in a hidden class\n+      if (java_lang_Class::is_instance(o)) {\n+        mark_required_if_hidden_class(java_lang_Class::as_Klass(o));\n+      } else if (java_lang_invoke_ResolvedMethodName::is_instance(o)) {\n+        Method* m = java_lang_invoke_ResolvedMethodName::vmtarget(o);\n+        if (m != nullptr) {\n+          mark_required_if_hidden_class(m->method_holder());\n+        }\n+      }\n+\n+      o->oop_iterate(&c);\n+    }\n+  }\n+}\n+\n@@ -489,1 +761,3 @@\n-    _default_subgraph_info = init_subgraph_info(vmClasses::Object_klass(), false);\n+    \/\/ The special subgraph doesn't belong to any class. We use Object_klass() here just\n+    \/\/ for convenience.\n+    _dump_time_special_subgraph = init_subgraph_info(vmClasses::Object_klass(), false);\n@@ -504,1 +778,1 @@\n-    check_default_subgraph_classes();\n+    check_special_subgraph_classes();\n@@ -516,1 +790,1 @@\n-    bool success = archive_reachable_objects_from(1, _default_subgraph_info, s);\n+    bool success = archive_reachable_objects_from(1, _dump_time_special_subgraph, s);\n@@ -527,2 +801,3 @@\n-void HeapShared::copy_special_objects() {\n-  \/\/ Archive special objects that do not belong to any subgraphs\n+void HeapShared::copy_special_subgraph() {\n+  copy_interned_strings();\n+\n@@ -530,3 +805,5 @@\n-  archive_java_mirrors();\n-  archive_strings();\n-  Universe::archive_exception_instances();\n+  {\n+    archive_java_mirrors();\n+    archive_strings();\n+    Universe::archive_exception_instances();\n+  }\n@@ -536,0 +813,11 @@\n+void HeapShared::prepare_resolved_references() {\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* src_k = klasses->at(i);\n+    if (src_k->is_instance_klass()) {\n+      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(InstanceKlass::cast(src_k));\n+      buffered_ik->constants()->prepare_resolved_references_for_archiving();\n+    }\n+  }\n+}\n+\n@@ -539,2 +827,3 @@\n-  copy_interned_strings();\n-  copy_special_objects();\n+  prepare_resolved_references();\n+  find_all_aot_initialized_classes();\n+  copy_special_subgraph();\n@@ -552,0 +841,192 @@\n+\/\/ Closure used by HeapShared::scan_for_aot_initialized_classes() to look for all objects\n+\/\/ that are reachable from a given root.\n+class HeapShared::AOTInitializedClassScanner : public BasicOopIterateClosure {\n+  bool _made_progress;\n+\n+  template <class T> void check(T *p) {\n+    oop obj = HeapAccess<>::oop_load(p);\n+    if (!java_lang_Class::is_instance(obj)) {\n+      \/\/ Don't scan the mirrors, as we may see an orig_mirror while scanning\n+      \/\/ the object graph, .... TODO more info\n+      _made_progress |= HeapShared::scan_for_aot_initialized_classes(obj);\n+    }\n+  }\n+\n+public:\n+  AOTInitializedClassScanner() : _made_progress(false) {}\n+  void do_oop(narrowOop *p) { check(p); }\n+  void do_oop(      oop *p) { check(p); }\n+  bool made_progress() { return _made_progress; }\n+};\n+\n+\/\/ If <buffered_ik> has been initialized during the assembly phase, mark its\n+\/\/ has_aot_initialized_mirror bit. And then do the same for all supertypes of\n+\/\/ <buffered_ik>.\n+\/\/\n+\/\/ Note: a super interface <intf> of <buffered_ik> may not have been initialized, if\n+\/\/ <intf> has not declared any default methods.\n+\/\/\n+\/\/ Note: this function doesn not call InstanceKlass::initialize() -- we are inside\n+\/\/ a safepoint.\n+\/\/\n+\/\/ Returns true if one or more classes have been newly marked.\n+static bool mark_for_aot_initialization(InstanceKlass* buffered_ik) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"sanity\");\n+  assert(ArchiveBuilder::current()->is_in_buffer_space(buffered_ik), \"sanity\");\n+\n+  if (buffered_ik->has_aot_initialized_mirror()) { \/\/ already marked\n+    return false;\n+  }\n+\n+  bool made_progress = false;\n+  if (buffered_ik->is_initialized()) {\n+    if (log_is_enabled(Info, cds, init)) {\n+      ResourceMark rm;\n+      log_info(cds, init)(\"Mark class for aot-init: %s\", buffered_ik->external_name());\n+    }\n+\n+    InstanceKlass* src_ik = ArchiveBuilder::current()->get_source_addr(buffered_ik);\n+\n+    \/\/ If we get here with a \"wild\" user class, which may have\n+    \/\/ uncontrolled <clinit> code, exit with an error.  Obviously\n+    \/\/ filtering logic upstream needs to detect APP classes and not mark\n+    \/\/ them for aot-init in the first place, but this will be the final\n+    \/\/ firewall.\n+\n+#ifndef PRODUCT\n+    \/\/ ArchiveHeapTestClass is used for a very small number of internal regression\n+    \/\/ tests (non-product builds only). It may initialize some unexpected classes.\n+    if (ArchiveHeapTestClass == nullptr)\n+#endif\n+    {\n+      if (!src_ik->in_javabase_module()) {\n+        \/\/ Class\/interface types in the boot loader may have been initialized as side effects\n+        \/\/ of JVM bootstrap code, so they are fine. But we need to check all other classes.\n+        if (buffered_ik->is_interface()) {\n+          \/\/ This probably means a bug in AOTConstantPoolResolver.::is_indy_resolution_deterministic()\n+          guarantee(!buffered_ik->interface_needs_clinit_execution_as_super(),\n+                    \"should not have initialized an interface whose <clinit> might have unpredictable side effects\");\n+        } else {\n+          \/\/ \"normal\" classes\n+          guarantee(HeapShared::is_archivable_hidden_klass(buffered_ik),\n+                    \"should not have initialized any non-interface, non-hidden classes outside of java.base\");\n+        }\n+      }\n+    }\n+\n+    buffered_ik->set_has_aot_initialized_mirror();\n+    if (AOTClassInitializer::is_runtime_setup_required(src_ik)) {\n+      buffered_ik->set_is_runtime_setup_required();\n+    }\n+    made_progress = true;\n+\n+    InstanceKlass* super = buffered_ik->java_super();\n+    if (super != nullptr) {\n+      mark_for_aot_initialization(super);\n+    }\n+\n+    Array<InstanceKlass*>* interfaces = buffered_ik->transitive_interfaces();\n+    for (int i = 0; i < interfaces->length(); i++) {\n+      InstanceKlass* intf = interfaces->at(i);\n+      mark_for_aot_initialization(intf);\n+      if (!intf->is_initialized()) {\n+        assert(!intf->interface_needs_clinit_execution_as_super(\/*also_check_supers*\/false), \"sanity\");\n+        assert(!intf->has_aot_initialized_mirror(), \"must not be marked\");\n+      }\n+    }\n+  }\n+\n+  return made_progress;\n+}\n+\n+void HeapShared::find_all_aot_initialized_classes() {\n+  if (!CDSConfig::is_dumping_aot_linked_classes()) {\n+    return;\n+  }\n+\n+  init_seen_objects_table();\n+  find_all_aot_initialized_classes_helper();\n+  delete_seen_objects_table();\n+}\n+\n+\/\/ Recursively find all class that should be aot-initialized:\n+\/\/ - the class has at least one instance that can be reachable from the special subgraph; or\n+\/\/ - the class is hard-coded in AOTClassInitializer::can_archive_initialized_mirror()\n+void HeapShared::find_all_aot_initialized_classes_helper() {\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+  assert(klasses != nullptr, \"sanity\");\n+\n+  \/\/ First scan all resolved constant pools references.\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* src_k = klasses->at(i);\n+    if (src_k->is_instance_klass()) {\n+      InstanceKlass* src_ik = InstanceKlass::cast(src_k);\n+      InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(src_ik);\n+      objArrayOop rr = get_archived_resolved_references(src_ik);\n+      if (rr != nullptr) {\n+        objArrayOop scratch_rr = scratch_resolved_references(src_ik->constants());\n+        for (int i = 0; i < scratch_rr->length(); i++) {\n+          scan_for_aot_initialized_classes(scratch_rr->obj_at(i));\n+        }\n+      }\n+\n+      \/\/ If a class is hard-coded to be aot-initialize, mark it as such.\n+      if (AOTClassInitializer::can_archive_initialized_mirror(src_ik)) {\n+        mark_for_aot_initialization(buffered_ik);\n+      }\n+    }\n+  }\n+\n+  \/\/ These objects also belong to the special subgraph\n+  scan_for_aot_initialized_classes(Universe::null_ptr_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::arithmetic_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::internal_error_instance());\n+  scan_for_aot_initialized_classes(Universe::array_index_out_of_bounds_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::array_store_exception_instance());\n+  scan_for_aot_initialized_classes(Universe::class_cast_exception_instance());\n+\n+  bool made_progress;\n+  do {\n+    \/\/ In each pass, we copy the scratch mirrors of the classes that were marked\n+    \/\/ as aot-init in the previous pass. We then scan these mirrors, which may\n+    \/\/ mark more classes. Keep iterating until no more progress can be made.\n+    made_progress = false;\n+    for (int i = 0; i < klasses->length(); i++) {\n+      Klass* orig_k = klasses->at(i);\n+      if (orig_k->is_instance_klass()) {\n+        InstanceKlass* orig_ik = InstanceKlass::cast(orig_k);\n+        if (ArchiveBuilder::current()->get_buffered_addr(orig_ik)->has_aot_initialized_mirror()) {\n+          oop orig_mirror = orig_ik->java_mirror();\n+          oop scratch_mirror = scratch_java_mirror(orig_k);\n+          if (!has_been_seen_during_subgraph_recording(scratch_mirror)) {\n+            \/\/ Scan scratch_mirror instead of orig_mirror (which has fields like ClassLoader that\n+            \/\/ are not archived).\n+            copy_aot_initialized_mirror(orig_k, orig_mirror, scratch_mirror);\n+            made_progress |= scan_for_aot_initialized_classes(scratch_mirror);\n+          }\n+        }\n+      }\n+    }\n+  } while (made_progress);\n+}\n+\n+bool HeapShared::scan_for_aot_initialized_classes(oop obj) {\n+  if (obj == nullptr || has_been_seen_during_subgraph_recording(obj)) {\n+    return false;\n+  }\n+  set_has_been_seen_during_subgraph_recording(obj);\n+\n+  bool made_progress = false;\n+  Klass* k = obj->klass();\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* orig_ik = InstanceKlass::cast(k);\n+    InstanceKlass* buffered_ik = ArchiveBuilder::current()->get_buffered_addr(orig_ik);\n+    made_progress = mark_for_aot_initialization(buffered_ik);\n+  }\n+\n+  AOTInitializedClassScanner scanner;\n+  obj->oop_iterate(&scanner);\n+  made_progress |= scanner.made_progress();\n+  return made_progress;\n+}\n+\n@@ -610,2 +1091,8 @@\n-    assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class(),\n-          \"must be boot class\");\n+    if (CDSConfig::is_dumping_invokedynamic()) {\n+      assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class() ||\n+             HeapShared::is_lambda_proxy_klass(InstanceKlass::cast(buffered_k)),\n+            \"we can archive only instances of boot classes or lambda proxy classes\");\n+    } else {\n+      assert(InstanceKlass::cast(buffered_k)->is_shared_boot_class(),\n+             \"must be boot class\");\n+    }\n@@ -620,0 +1107,4 @@\n+    if (buffered_k->has_aot_initialized_mirror()) {\n+      \/\/ No need to add to the runtime-init list.\n+      return;\n+    }\n@@ -656,0 +1147,11 @@\n+  const char* lambda_msg = \"\";\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    lambda_msg = \", or a lambda proxy class\";\n+    if (HeapShared::is_lambda_proxy_klass(ik) &&\n+        (ik->class_loader() == nullptr ||\n+         ik->class_loader() == SystemDictionary::java_platform_loader() ||\n+         ik->class_loader() == SystemDictionary::java_system_loader())) {\n+      return;\n+    }\n+  }\n+\n@@ -657,1 +1159,1 @@\n-  if (!ik->module()->is_named() && ik->package() == nullptr) {\n+  if (!ik->module()->is_named() && ik->package() == nullptr && ArchiveHeapTestClass != nullptr) {\n@@ -661,1 +1163,1 @@\n-  const char* extra_msg = \", or in an unnamed package of an unnamed module\";\n+  const char* testcls_msg = \", or a test class in an unnamed package of an unnamed module\";\n@@ -663,1 +1165,1 @@\n-  const char* extra_msg = \"\";\n+  const char* testcls_msg = \"\";\n@@ -667,2 +1169,2 @@\n-  log_error(cds, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s\",\n-                       ik->external_name(), extra_msg);\n+  log_error(cds, heap)(\"Class %s not allowed in archive heap. Must be in java.base%s%s\",\n+                       ik->external_name(), lambda_msg, testcls_msg);\n@@ -730,0 +1232,1 @@\n+    bool is_special = (_k == ArchiveBuilder::get_buffered_klass(vmClasses::Object_klass()));\n@@ -734,0 +1237,4 @@\n+        const char* owner_name =  is_special ? \"<special>\" : _k->external_name();\n+        if (subgraph_k->is_instance_klass()) {\n+          InstanceKlass* src_ik = InstanceKlass::cast(ArchiveBuilder::current()->get_source_addr(subgraph_k));\n+        }\n@@ -736,1 +1243,1 @@\n-          _k->external_name(), i, subgraph_k->external_name());\n+          owner_name, i, subgraph_k->external_name());\n@@ -748,1 +1255,1 @@\n-struct CopyKlassSubGraphInfoToArchive : StackObj {\n+class HeapShared::CopyKlassSubGraphInfoToArchive : StackObj {\n@@ -750,0 +1257,1 @@\n+public:\n@@ -754,4 +1262,1 @@\n-      ArchivedKlassSubGraphInfoRecord* record =\n-        (ArchivedKlassSubGraphInfoRecord*)ArchiveBuilder::ro_region_alloc(sizeof(ArchivedKlassSubGraphInfoRecord));\n-      record->init(&info);\n-\n+      ArchivedKlassSubGraphInfoRecord* record = HeapShared::archive_subgraph_info(&info);\n@@ -767,0 +1272,10 @@\n+ArchivedKlassSubGraphInfoRecord* HeapShared::archive_subgraph_info(KlassSubGraphInfo* info) {\n+  ArchivedKlassSubGraphInfoRecord* record =\n+      (ArchivedKlassSubGraphInfoRecord*)ArchiveBuilder::ro_region_alloc(sizeof(ArchivedKlassSubGraphInfoRecord));\n+  record->init(info);\n+  if (info ==  _dump_time_special_subgraph) {\n+    _run_time_special_subgraph = record;\n+  }\n+  return record;\n+}\n+\n@@ -823,0 +1338,1 @@\n+  soc->do_ptr(&_run_time_special_subgraph);\n@@ -890,0 +1406,59 @@\n+void HeapShared::initialize_java_lang_invoke(TRAPS) {\n+  if (CDSConfig::is_loading_invokedynamic() || CDSConfig::is_dumping_invokedynamic()) {\n+    resolve_or_init(\"java\/lang\/invoke\/Invokers$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/MethodHandle\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/MethodHandleNatives\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/DirectMethodHandle$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/DelegatingMethodHandle$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/LambdaForm$Holder\", true, CHECK);\n+    resolve_or_init(\"java\/lang\/invoke\/BoundMethodHandle$Species_L\", true, CHECK);\n+  }\n+}\n+\n+\/\/ Initialize the InstanceKlasses of objects that are reachable from the following roots:\n+\/\/   - interned strings\n+\/\/   - Klass::java_mirror() -- including aot-initialized mirrors such as those of Enum klasses.\n+\/\/   - ConstantPool::resolved_references()\n+\/\/   - Universe::<xxx>_exception_instance()\n+\/\/\n+\/\/ For example, if this enum class is initialized at AOT cache assembly time:\n+\/\/\n+\/\/    enum Fruit {\n+\/\/       APPLE, ORANGE, BANANA;\n+\/\/       static final Set<Fruit> HAVE_SEEDS = new HashSet<>(Arrays.asList(APPLE, ORANGE));\n+\/\/   }\n+\/\/\n+\/\/ the aot-initialized mirror of Fruit has a static field that references HashSet, which\n+\/\/ should be initialized before any Java code can access the Fruit class. Note that\n+\/\/ HashSet itself doesn't necessary need to be an aot-initialized class.\n+void HeapShared::init_classes_for_special_subgraph(Handle class_loader, TRAPS) {\n+  if (!ArchiveHeapLoader::is_in_use()) {\n+    return;\n+  }\n+\n+  assert( _run_time_special_subgraph != nullptr, \"must be\");\n+  Array<Klass*>* klasses = _run_time_special_subgraph->subgraph_object_klasses();\n+  if (klasses != nullptr) {\n+    for (int pass = 0; pass < 2; pass ++) {\n+      for (int i = 0; i < klasses->length(); i++) {\n+        Klass* k = klasses->at(i);\n+        if (k->class_loader_data() == nullptr) {\n+          \/\/ This class is not yet loaded. We will initialize it in a later phase.\n+          \/\/ For example, we have loaded only AOTLinkedClassCategory::BOOT1 classes\n+          \/\/ but k is part of AOTLinkedClassCategory::BOOT2.\n+          continue;\n+        }\n+        if (k->class_loader() == class_loader()) {\n+          if (pass == 0) {\n+            if (k->is_instance_klass()) {\n+              InstanceKlass::cast(k)->link_class(CHECK);\n+            }\n+          } else {\n+            resolve_or_init(k, \/*do_init*\/true, CHECK);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n@@ -993,0 +1568,13 @@\n+void HeapShared::resolve_or_init(const char* klass_name, bool do_init, TRAPS) {\n+  TempNewSymbol klass_name_sym =  SymbolTable::new_symbol(klass_name);\n+  InstanceKlass* k = SystemDictionaryShared::find_builtin_class(klass_name_sym);\n+  if (k == nullptr) {\n+    return;\n+  }\n+  assert(k->is_shared_boot_class(), \"sanity\");\n+  resolve_or_init(k, false, CHECK);\n+  if (do_init) {\n+    resolve_or_init(k, true, CHECK);\n+  }\n+}\n+\n@@ -1025,1 +1613,5 @@\n-      m->obj_field_put(field_offset, v);\n+      if (k->has_aot_initialized_mirror()) {\n+        assert(v == m->obj_field(field_offset), \"must be aot-initialized\");\n+      } else {\n+        m->obj_field_put(field_offset, v);\n+      }\n@@ -1033,2 +1625,3 @@\n-      log_info(cds, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s\",\n-                          k->external_name(), p2i(k), JvmtiExport::is_early_phase() ? \" (early)\" : \"\");\n+      log_info(cds, heap)(\"initialize_from_archived_subgraph %s \" PTR_FORMAT \"%s%s\",\n+                          k->external_name(), p2i(k), JvmtiExport::is_early_phase() ? \" (early)\" : \"\",\n+                          k->has_aot_initialized_mirror() ? \" (aot-inited)\" : \"\");\n@@ -1140,0 +1733,14 @@\n+void HeapShared::init_box_classes(TRAPS) {\n+  if (ArchiveHeapLoader::is_in_use()) {\n+    vmClasses::Boolean_klass()->initialize(CHECK);\n+    vmClasses::Character_klass()->initialize(CHECK);\n+    vmClasses::Float_klass()->initialize(CHECK);\n+    vmClasses::Double_klass()->initialize(CHECK);\n+    vmClasses::Byte_klass()->initialize(CHECK);\n+    vmClasses::Short_klass()->initialize(CHECK);\n+    vmClasses::Integer_klass()->initialize(CHECK);\n+    vmClasses::Long_klass()->initialize(CHECK);\n+    vmClasses::Void_klass()->initialize(CHECK);\n+  }\n+}\n+\n@@ -1154,8 +1761,2 @@\n-    log_error(cds, heap)(\"Cannot archive object of class %s\", orig_obj->klass()->external_name());\n-    if (log_is_enabled(Trace, cds, heap)) {\n-      WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n-      if (walker != nullptr) {\n-        LogStream ls(Log(cds, heap)::trace());\n-        CDSHeapVerifier::trace_to_root(&ls, walker->referencing_obj());\n-      }\n-    }\n+    log_error(cds, heap)(\"Cannot archive object \" PTR_FORMAT \" of class %s\", p2i(orig_obj), orig_obj->klass()->external_name());\n+    debug_trace();\n@@ -1165,8 +1766,45 @@\n-  \/\/ java.lang.Class instances cannot be included in an archived object sub-graph. We only support\n-  \/\/ them as Klass::_archived_mirror because they need to be specially restored at run time.\n-  \/\/\n-  \/\/ If you get an error here, you probably made a change in the JDK library that has added a Class\n-  \/\/ object that is referenced (directly or indirectly) by static fields.\n-  if (java_lang_Class::is_instance(orig_obj) && subgraph_info != _default_subgraph_info) {\n-    log_error(cds, heap)(\"(%d) Unknown java.lang.Class object is in the archived sub-graph\", level);\n-    MetaspaceShared::unrecoverable_writing_error();\n+  if (log_is_enabled(Debug, cds, heap) && java_lang_Class::is_instance(orig_obj)) {\n+    ResourceMark rm;\n+    LogTarget(Debug, cds, heap) log;\n+    LogStream out(log);\n+    out.print(\"Found java mirror \" PTR_FORMAT \" \", p2i(orig_obj));\n+    Klass* k = java_lang_Class::as_Klass(orig_obj);\n+    if (k != nullptr) {\n+      out.print(\"%s\", k->external_name());\n+    } else {\n+      out.print(\"primitive\");\n+    }\n+    out.print_cr(\"; scratch mirror = \"  PTR_FORMAT,\n+                 p2i(scratch_java_mirror(orig_obj)));\n+  }\n+\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    if (java_lang_Class::is_instance(orig_obj)) {\n+      orig_obj = scratch_java_mirror(orig_obj);\n+      assert(orig_obj != nullptr, \"must be archived\");\n+    }\n+  } else if (java_lang_Class::is_instance(orig_obj) && subgraph_info != _dump_time_special_subgraph) {\n+    \/\/ Without CDSConfig::is_initing_classes_at_dump_time(), we only allow archived objects to\n+    \/\/ point to the mirrors of (1) j.l.Object, (2) primitive classes, and (3) box classes. These are initialized\n+    \/\/ very early by HeapShared::init_box_classes().\n+    if (orig_obj == vmClasses::Object_klass()->java_mirror()\n+        || java_lang_Class::is_primitive(orig_obj)\n+        || orig_obj == vmClasses::Boolean_klass()->java_mirror()\n+        || orig_obj == vmClasses::Character_klass()->java_mirror()\n+        || orig_obj == vmClasses::Float_klass()->java_mirror()\n+        || orig_obj == vmClasses::Double_klass()->java_mirror()\n+        || orig_obj == vmClasses::Byte_klass()->java_mirror()\n+        || orig_obj == vmClasses::Short_klass()->java_mirror()\n+        || orig_obj == vmClasses::Integer_klass()->java_mirror()\n+        || orig_obj == vmClasses::Long_klass()->java_mirror()\n+        || orig_obj == vmClasses::Void_klass()->java_mirror()) {\n+      orig_obj = scratch_java_mirror(orig_obj);\n+      assert(orig_obj != nullptr, \"must be archived\");\n+    } else {\n+      \/\/ If you get an error here, you probably made a change in the JDK library that has added a Class\n+      \/\/ object that is referenced (directly or indirectly) by an ArchivableStaticFieldInfo\n+      \/\/ defined at the top of this file.\n+      log_error(cds, heap)(\"(%d) Unknown java.lang.Class object is in the archived sub-graph\", level);\n+      debug_trace();\n+      MetaspaceShared::unrecoverable_writing_error();\n+    }\n@@ -1212,2 +1850,7 @@\n-  if (CDSEnumKlass::is_enum_obj(orig_obj)) {\n-    CDSEnumKlass::handle_enum_obj(level + 1, subgraph_info, orig_obj);\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    \/\/ The enum klasses are archived with aot-initialized mirror.\n+    \/\/ See AOTClassInitializer::can_archive_initialized_mirror().\n+  } else {\n+    if (CDSEnumKlass::is_enum_obj(orig_obj)) {\n+      CDSEnumKlass::handle_enum_obj(level + 1, subgraph_info, orig_obj);\n+    }\n@@ -1215,0 +1858,1 @@\n+\n@@ -1332,0 +1976,4 @@\n+  if (java_lang_Class::is_instance(obj)) {\n+    obj = scratch_java_mirror(obj);\n+    assert(obj != nullptr, \"must be\");\n+  }\n@@ -1341,14 +1989,28 @@\n-\/\/ The \"default subgraph\" contains special objects (see heapShared.hpp) that\n-\/\/ can be accessed before we load any Java classes (including java\/lang\/Class).\n-\/\/ Make sure that these are only instances of the very few specific types\n-\/\/ that we can handle.\n-void HeapShared::check_default_subgraph_classes() {\n-  GrowableArray<Klass*>* klasses = _default_subgraph_info->subgraph_object_klasses();\n-  int num = klasses->length();\n-  for (int i = 0; i < num; i++) {\n-    Klass* subgraph_k = klasses->at(i);\n-    if (log_is_enabled(Info, cds, heap)) {\n-      ResourceMark rm;\n-      log_info(cds, heap)(\n-          \"Archived object klass (default subgraph %d) => %s\",\n-          i, subgraph_k->external_name());\n+void HeapShared::check_special_subgraph_classes() {\n+  if (CDSConfig::is_initing_classes_at_dump_time()) {\n+    \/\/ We can have aot-initialized classes (such as Enums) that can reference objects\n+    \/\/ of arbitrary types. Currently, we trust the JEP 483 implementation to only\n+    \/\/ aot-initialize classes that are \"safe\".\n+    \/\/\n+    \/\/ TODO: we need an automatic tool that checks the safety of aot-initialized\n+    \/\/ classes (when we extend the set of aot-initialized classes beyond JEP 483)\n+    return;\n+  } else {\n+    \/\/ In this case, the special subgraph should contain a few specific types\n+    GrowableArray<Klass*>* klasses = _dump_time_special_subgraph->subgraph_object_klasses();\n+    int num = klasses->length();\n+    for (int i = 0; i < num; i++) {\n+      Klass* subgraph_k = klasses->at(i);\n+      Symbol* name = ArchiveBuilder::current()->get_source_addr(subgraph_k->name());\n+      if (subgraph_k->is_instance_klass() &&\n+          name != vmSymbols::java_lang_Class() &&\n+          name != vmSymbols::java_lang_String() &&\n+          name != vmSymbols::java_lang_ArithmeticException() &&\n+          name != vmSymbols::java_lang_ArrayIndexOutOfBoundsException() &&\n+          name != vmSymbols::java_lang_ArrayStoreException() &&\n+          name != vmSymbols::java_lang_ClassCastException() &&\n+          name != vmSymbols::java_lang_InternalError() &&\n+          name != vmSymbols::java_lang_NullPointerException()) {\n+        ResourceMark rm;\n+        fatal(\"special subgraph cannot have objects of type %s\", subgraph_k->external_name());\n+      }\n@@ -1356,14 +2018,0 @@\n-\n-    Symbol* name = ArchiveBuilder::current()->get_source_addr(subgraph_k->name());\n-    guarantee(name == vmSymbols::java_lang_Class() ||\n-              name == vmSymbols::java_lang_String() ||\n-              name == vmSymbols::java_lang_ArithmeticException() ||\n-              name == vmSymbols::java_lang_NullPointerException() ||\n-              name == vmSymbols::java_lang_InternalError() ||\n-              name == vmSymbols::java_lang_ArrayIndexOutOfBoundsException() ||\n-              name == vmSymbols::java_lang_ArrayStoreException() ||\n-              name == vmSymbols::java_lang_ClassCastException() ||\n-              name == vmSymbols::object_array_signature() ||\n-              name == vmSymbols::byte_array_signature() ||\n-              name == vmSymbols::char_array_signature(),\n-              \"default subgraph can have only these objects\");\n@@ -1575,2 +2223,2 @@\n-        \/\/ See KlassSubGraphInfo::check_allowed_klass() - only two types of\n-        \/\/ classes are allowed:\n+        \/\/ See KlassSubGraphInfo::check_allowed_klass() - we only allow test classes\n+        \/\/ to be:\n@@ -1592,0 +2240,19 @@\n+\n+void HeapShared::initialize_test_class_from_archive(JavaThread* current) {\n+  Klass* k = _test_class;\n+  if (k != nullptr && ArchiveHeapLoader::is_in_use()) {\n+    JavaThread* THREAD = current;\n+    ExceptionMark em(THREAD);\n+    const ArchivedKlassSubGraphInfoRecord* record =\n+      resolve_or_init_classes_for_subgraph_of(k, \/*do_init=*\/false, THREAD);\n+\n+    \/\/ The _test_class is in the unnamed module, so it can't call CDS.initializeFromArchive()\n+    \/\/ from its <clinit> method. So we set up its \"archivedObjects\" field first, before\n+    \/\/ calling its <clinit>. This is not strictly clean, but it's a convenient way to write unit\n+    \/\/ test cases (see test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java).\n+    if (record != nullptr) {\n+      init_archived_fields_for(k, record);\n+    }\n+    resolve_or_init_classes_for_subgraph_of(k, \/*do_init=*\/true, THREAD);\n+  }\n+}\n@@ -1667,0 +2334,9 @@\n+void HeapShared::debug_trace() {\n+  ResourceMark rm;\n+  WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n+  if (walker != nullptr) {\n+    LogStream ls(Log(cds, heap)::error());\n+    CDSHeapVerifier::trace_to_root(&ls, walker->referencing_obj());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":761,"deletions":85,"binary":false,"changes":846,"status":"modified"},{"patch":"@@ -164,2 +164,3 @@\n-  static oop scratch_java_mirror(BasicType t) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n-  static oop scratch_java_mirror(Klass* k)    NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  static oop scratch_java_mirror(BasicType t)     NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  static oop scratch_java_mirror(Klass* k)        NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n+  static oop scratch_java_mirror(oop java_mirror) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n@@ -168,0 +169,5 @@\n+  \/\/ Look for all hidden classes that are referenced by archived objects.\n+  static void start_finding_required_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n+  static void find_required_hidden_classes_in_object(oop o) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void end_finding_required_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n+\n@@ -182,0 +188,1 @@\n+  static void debug_trace();\n@@ -188,0 +195,2 @@\n+  class CopyKlassSubGraphInfoToArchive;\n+\n@@ -249,0 +258,3 @@\n+  class FindRequiredHiddenClassesOopClosure;\n+  static void find_required_hidden_classes_helper(ArchivableStaticFieldInfo fields[]);\n+\n@@ -250,0 +262,1 @@\n+  static ArchivedKlassSubGraphInfoRecord* archive_subgraph_info(KlassSubGraphInfo* info);\n@@ -263,1 +276,1 @@\n-  static void check_default_subgraph_classes();\n+  static void check_special_subgraph_classes();\n@@ -285,2 +298,2 @@\n-  \/\/ The \"default subgraph\" is the root of all archived objects that do not belong to any\n-  \/\/ of the classes defined in the <xxx>_archive_subgraph_entry_fields[] arrays:\n+  \/\/ The \"special subgraph\" contains all the all archived objects that are reachable\n+  \/\/ from the following roots:\n@@ -288,1 +301,1 @@\n-  \/\/    - Klass::java_mirror()\n+  \/\/    - Klass::java_mirror() -- including aot-initialized mirrors such as those of Enum klasses.\n@@ -290,1 +303,3 @@\n-  static KlassSubGraphInfo* _default_subgraph_info;\n+  \/\/    - Universe::<xxx>_exception_instance()\n+  static KlassSubGraphInfo* _dump_time_special_subgraph;              \/\/ for collecting info during dump time\n+  static ArchivedKlassSubGraphInfoRecord* _run_time_special_subgraph; \/\/ for initializing classes during run time.\n@@ -328,1 +343,1 @@\n-\n+  static void copy_aot_initialized_mirror(Klass* orig_k, oop orig_mirror, oop m);\n@@ -336,0 +351,1 @@\n+  static void resolve_or_init(const char* klass_name, bool do_init, TRAPS);\n@@ -350,0 +366,1 @@\n+  static void prepare_resolved_references();\n@@ -352,0 +369,7 @@\n+  static void copy_special_subgraph();\n+\n+  class AOTInitializedClassScanner;\n+  static void find_all_aot_initialized_classes();\n+  static void find_all_aot_initialized_classes_helper();\n+  static bool scan_for_aot_initialized_classes(oop obj);\n+\n@@ -369,1 +393,0 @@\n-  static void copy_special_objects();\n@@ -418,0 +441,1 @@\n+  static void init_box_classes(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -434,0 +458,1 @@\n+  static void initialize_test_class_from_archive(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -435,0 +460,8 @@\n+\n+  static void initialize_java_lang_invoke(TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void init_classes_for_special_subgraph(Handle loader, TRAPS) NOT_CDS_JAVA_HEAP_RETURN;\n+\n+  static bool is_lambda_form_klass(InstanceKlass* ik) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_lambda_proxy_klass(InstanceKlass* ik) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_string_concat_klass(InstanceKlass* ik) NOT_CDS_JAVA_HEAP_RETURN_(false);\n+  static bool is_archivable_hidden_klass(InstanceKlass* ik) NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":42,"deletions":9,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"classfile\/classLoadInfo.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"classfile\/classLoadInfo.hpp\"\n@@ -99,0 +99,15 @@\n+  if (CDSConfig::is_dumping_static_archive() && CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ Work around JDK-8310831, as some methods in lambda form holder classes may not get generated.\n+    log_info(cds)(\"Archived MethodHandles may refer to lambda form holder classes. Cannot regenerate.\");\n+    return;\n+  }\n+\n+  if (CDSConfig::is_dumping_dynamic_archive() && CDSConfig::is_dumping_aot_linked_classes() &&\n+      CDSConfig::is_using_aot_linked_classes()) {\n+    \/\/ The base archive may have some pre-resolved CP entries that point to the lambda form holder\n+    \/\/ classes in the base archive. If we generate new versions of these classes, those CP entries\n+    \/\/ will be pointing to invalid classes.\n+    log_info(cds)(\"Base archive already has aot-linked lambda form holder classes. Cannot regenerate.\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+#include \"cds\/aotClassLinker.hpp\"\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -32,1 +35,0 @@\n-#include \"cds\/cds_globals.hpp\"\n@@ -35,1 +37,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -100,0 +101,1 @@\n+Array<Method*>* MetaspaceShared::_archived_method_handle_intrinsics = nullptr;\n@@ -310,0 +312,1 @@\n+\/\/ Extra java.lang.Strings to be added to the archive\n@@ -311,0 +314,1 @@\n+\/\/ Extra Symbols to be added to the archive\n@@ -312,0 +316,2 @@\n+\/\/ Methods managed by SystemDictionary::find_method_handle_intrinsic() to be added to the archive\n+static GrowableArray<Method*>* _pending_method_handle_intrinsics = NULL;\n@@ -362,0 +368,24 @@\n+void MetaspaceShared::make_method_handle_intrinsics_shareable() {\n+  for (int i = 0; i < _pending_method_handle_intrinsics->length(); i++) {\n+    Method* m = ArchiveBuilder::current()->get_buffered_addr(_pending_method_handle_intrinsics->at(i));\n+    m->remove_unshareable_info();\n+    \/\/ Each method has its own constant pool (which is distinct from m->method_holder()->constants());\n+    m->constants()->remove_unshareable_info();\n+  }\n+}\n+\n+void MetaspaceShared::write_method_handle_intrinsics() {\n+  int len = _pending_method_handle_intrinsics->length();\n+  _archived_method_handle_intrinsics = ArchiveBuilder::new_ro_array<Method*>(len);\n+  int word_size = _archived_method_handle_intrinsics->size();\n+  for (int i = 0; i < len; i++) {\n+    Method* m = _pending_method_handle_intrinsics->at(i);\n+    ArchiveBuilder::current()->write_pointer_in_buffer(_archived_method_handle_intrinsics->adr_at(i), m);\n+    word_size += m->size() + m->constMethod()->size() + m->constants()->size();\n+    if (m->constants()->cache() != nullptr) {\n+      word_size += m->constants()->cache()->size();\n+    }\n+  }\n+  log_info(cds)(\"Archived %d method handle intrinsics (%d bytes)\", len, word_size * BytesPerWord);\n+}\n+\n@@ -398,1 +428,1 @@\n-\n+  AOTLinkedClassBulkLoader::serialize(soc, true);\n@@ -405,1 +435,0 @@\n-  CDS_JAVA_HEAP_ONLY(Modules::serialize(soc);)\n@@ -407,0 +436,2 @@\n+  soc->do_ptr((void**)&_archived_method_handle_intrinsics);\n+\n@@ -451,0 +482,1 @@\n+  char* _archived_main_module_name;\n@@ -462,1 +494,2 @@\n-    VM_Operation(), _heap_info(), _map_info(nullptr), _builder(b) {}\n+    VM_Operation(), _heap_info(), _map_info(nullptr), _builder(b),\n+    _archived_main_module_name(nullptr) {}\n@@ -471,0 +504,9 @@\n+\n+  void dump_main_module_name() {\n+    const char* module_name = Arguments::get_property(\"jdk.module.main\");\n+    if (module_name != nullptr) {\n+      _archived_main_module_name = ArchiveBuilder::current()->ro_strdup(module_name);\n+    } else {\n+      _archived_main_module_name = ArchiveBuilder::current()->ro_strdup(\"\");\n+    }\n+  }\n@@ -493,0 +535,4 @@\n+\n+    for (int i = 0; i < _pending_method_handle_intrinsics->length(); i++) {\n+      it->push(_pending_method_handle_intrinsics->adr_at(i));\n+    }\n@@ -500,0 +546,2 @@\n+  AOTClassLinker::write_to_archive();\n+  MetaspaceShared::write_method_handle_intrinsics();\n@@ -504,1 +552,1 @@\n-  CDS_JAVA_HEAP_ONLY(Modules::dump_main_module_name();)\n+  CDS_JAVA_HEAP_ONLY(dump_main_module_name();)\n@@ -519,0 +567,7 @@\n+  _pending_method_handle_intrinsics = new (mtClassShared) GrowableArray<Method*>(256, mtClassShared);\n+  if (CDSConfig::is_dumping_aot_linked_classes()) {\n+    \/\/ When dumping AOT-linked classes, some classes may have direct references to a method handle\n+    \/\/ intrinsic. The easiest thing is to save all of them into the AOT cache.\n+    SystemDictionary::get_all_method_handle_intrinsics(_pending_method_handle_intrinsics);\n+  }\n+\n@@ -525,1 +580,2 @@\n-  SystemDictionaryShared::check_excluded_classes();\n+\n+  SystemDictionaryShared::find_all_archivable_classes();\n@@ -542,0 +598,1 @@\n+  MetaspaceShared::make_method_handle_intrinsics_shareable();\n@@ -558,0 +615,7 @@\n+\n+  \/\/ Note: main module name needs to be directly stored in the file header,\n+  \/\/ and not restored from MetaspaceShared::serialize():\n+  \/\/ With aot-linked classes, the main module name is used within\n+  \/\/ MetaspaceShared::map_archive() to decide whether to use the archive. This\n+  \/\/ is before we can call MetaspaceShared::serialize().\n+  _map_info->set_main_module_name(_archived_main_module_name);\n@@ -607,1 +671,1 @@\n-  ClassPrelinker::dumptime_resolve_constants(ik, CHECK_(false));\n+  AOTConstantPoolResolver::dumptime_resolve_constants(ik, CHECK_(false));\n@@ -612,1 +676,1 @@\n-  ClassPrelinker::initialize();\n+  AOTClassLinker::initialize();\n@@ -674,0 +738,9 @@\n+\n+  if (!CDSConfig::old_cds_flags_used()) {\n+    \/\/ The JLI launcher only recognizes the \"old\" -Xshare:dump flag.\n+    \/\/ When the new -XX:AOTMode=create flag is used, we can't return\n+    \/\/ to the JLI launcher, as the launcher will fail when trying to\n+    \/\/ run the main class, which is not what we want.\n+    tty->print_cr(\"AOTCache creation is complete: %s\", AOTCache);\n+    vm_exit(0);\n+  }\n@@ -802,0 +875,23 @@\n+    if (CDSConfig::is_dumping_invokedynamic()) {\n+      \/\/ This assert means that the MethodType and MethodTypeForm tables won't be\n+      \/\/ updated concurrently when we are saving their contents into a side table.\n+      assert(CDSConfig::allow_only_single_java_thread(), \"Required\");\n+\n+      JavaValue result(T_VOID);\n+      JavaCalls::call_static(&result, vmClasses::MethodType_klass(),\n+                             vmSymbols::createArchivedObjects(),\n+                             vmSymbols::void_method_signature(),\n+                             CHECK);\n+\n+      \/\/ java.lang.Class::reflectionFactory cannot be archived yet. We set this field\n+      \/\/ to null, and it will be initialized again at runtime.\n+      log_debug(cds)(\"Resetting Class::reflectionFactory\");\n+      TempNewSymbol method_name = SymbolTable::new_symbol(\"resetArchivedStates\");\n+      Symbol* method_sig = vmSymbols::void_method_signature();\n+      JavaCalls::call_static(&result, vmClasses::Class_klass(),\n+                             method_name, method_sig, CHECK);\n+\n+      \/\/ Perhaps there is a way to avoid hard-coding these names here.\n+      \/\/ See discussion in JDK-8342481.\n+    }\n+\n@@ -1473,0 +1569,5 @@\n+  if (!mapinfo->validate_aot_class_linking()) {\n+    unmap_archive(mapinfo);\n+    return MAP_ARCHIVE_OTHER_FAILURE;\n+  }\n+\n@@ -1533,0 +1634,12 @@\n+  LogStreamHandle(Info, cds) lsh;\n+  if (lsh.is_enabled()) {\n+    lsh.print(\"Using AOT-linked classes: %s (static archive: %s aot-linked classes\",\n+              BOOL_TO_STR(CDSConfig::is_using_aot_linked_classes()),\n+              static_mapinfo->header()->has_aot_linked_classes() ? \"has\" : \"no\");\n+    if (dynamic_mapinfo != nullptr) {\n+      lsh.print(\", dynamic archive: %s aot-linked classes\",\n+                dynamic_mapinfo->header()->has_aot_linked_classes() ? \"has\" : \"no\");\n+    }\n+    lsh.print_cr(\")\");\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":122,"deletions":9,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class Method;\n@@ -41,0 +42,1 @@\n+template<class E> class Array;\n@@ -59,0 +61,1 @@\n+  static Array<Method*>* _archived_method_handle_intrinsics;\n@@ -114,0 +117,3 @@\n+  static void make_method_handle_intrinsics_shareable() NOT_CDS_RETURN;\n+  static void write_method_handle_intrinsics() NOT_CDS_RETURN;\n+  static Array<Method*>* archived_method_handle_intrinsics() { return _archived_method_handle_intrinsics; }\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"classfile\/klassFactory.hpp\"\n@@ -38,1 +40,0 @@\n-#include \"classfile\/klassFactory.hpp\"\n@@ -1285,1 +1286,1 @@\n-    \/\/ We do not archive hidden classes.\n+    record_hidden_class(ik);\n@@ -1387,0 +1388,38 @@\n+\n+void ClassLoader::record_hidden_class(InstanceKlass* ik) {\n+  assert(ik->is_hidden(), \"must be\");\n+\n+  s2 classloader_type;\n+  if (HeapShared::is_lambda_form_klass(ik)) {\n+    classloader_type = ClassLoader::BOOT_LOADER;\n+  } else {\n+    oop loader = ik->class_loader();\n+\n+    if (loader == nullptr) {\n+      classloader_type = ClassLoader::BOOT_LOADER;\n+    } else if (SystemDictionary::is_platform_class_loader(loader)) {\n+      classloader_type = ClassLoader::PLATFORM_LOADER;\n+    } else if (SystemDictionary::is_system_class_loader(loader)) {\n+      classloader_type = ClassLoader::APP_LOADER;\n+    } else {\n+      \/\/ This class won't be archived, so no need to update its\n+      \/\/ classloader_type\/classpath_index.\n+      return;\n+    }\n+  }\n+  ik->set_shared_class_loader_type(classloader_type);\n+\n+  if (HeapShared::is_lambda_proxy_klass(ik)) {\n+    InstanceKlass* nest_host = ik->nest_host_not_null();\n+    ik->set_shared_classpath_index(nest_host->shared_classpath_index());\n+  } else if (HeapShared::is_lambda_form_klass(ik)) {\n+    ik->set_shared_classpath_index(0);\n+  } else {\n+    \/\/ Generated invoker classes.\n+    if (classloader_type == ClassLoader::APP_LOADER) {\n+      ik->set_shared_classpath_index(ClassLoaderExt::app_class_paths_start_index());\n+    } else {\n+      ik->set_shared_classpath_index(0);\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -143,0 +143,1 @@\n+    OTHER = 0,\n@@ -388,0 +389,1 @@\n+  static void record_hidden_class(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -845,0 +845,1 @@\n+int java_lang_Class::_reflectionData_offset;\n@@ -1281,0 +1282,5 @@\n+void java_lang_Class::set_reflection_data(oop java_class, oop reflection_data) {\n+  assert(_reflectionData_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_reflectionData_offset, reflection_data);\n+}\n+\n@@ -1471,0 +1477,1 @@\n+  macro(_reflectionData_offset,      k, \"reflectionData\",      java_lang_ref_SoftReference_signature, false); \\\n@@ -5425,14 +5432,12 @@\n-  if (klass == vmClasses::ClassLoader_klass() ||  \/\/ ClassLoader::loader_data is malloc'ed.\n-      \/\/ The next 3 classes are used to implement java.lang.invoke, and are not used directly in\n-      \/\/ regular Java code. The implementation of java.lang.invoke uses generated hidden classes\n-      \/\/ (e.g., as referenced by ResolvedMethodName::vmholder) that are not yet supported by CDS.\n-      \/\/ So for now we cannot not support these classes for archiving.\n-      \/\/\n-      \/\/ These objects typically are not referenced by static fields, but rather by resolved\n-      \/\/ constant pool entries, so excluding them shouldn't affect the archiving of static fields.\n-      klass == vmClasses::ResolvedMethodName_klass() ||\n-      klass == vmClasses::MemberName_klass() ||\n-      klass == vmClasses::Context_klass() ||\n-      \/\/ It's problematic to archive Reference objects. One of the reasons is that\n-      \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n-      klass->is_subclass_of(vmClasses::Reference_klass())) {\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ These are supported by CDS only when CDSConfig::is_dumping_invokedynamic() is enabled.\n+    if (klass == vmClasses::ResolvedMethodName_klass() ||\n+        klass == vmClasses::MemberName_klass() ||\n+        klass == vmClasses::Context_klass()) {\n+      return false;\n+    }\n+  }\n+\n+  if (klass->is_subclass_of(vmClasses::Reference_klass())) {\n+    \/\/ It's problematic to archive Reference objects. One of the reasons is that\n+    \/\/ Reference::discovered may pull in unwanted objects (see JDK-8284336)\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+  static int _reflectionData_offset;\n@@ -309,0 +310,1 @@\n+  static void set_reflection_data(oop java_class, oop reflection_data);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -567,41 +567,0 @@\n-char* Modules::_archived_main_module_name = nullptr;\n-\n-void Modules::dump_main_module_name() {\n-  const char* module_name = Arguments::get_property(\"jdk.module.main\");\n-  if (module_name != nullptr) {\n-    _archived_main_module_name = ArchiveBuilder::current()->ro_strdup(module_name);\n-  }\n-  ArchivePtrMarker::mark_pointer(&_archived_main_module_name);\n-}\n-\n-void Modules::serialize(SerializeClosure* soc) {\n-  soc->do_ptr(&_archived_main_module_name);\n-  if (soc->reading()) {\n-    const char* runtime_main_module = Arguments::get_property(\"jdk.module.main\");\n-    log_info(cds)(\"_archived_main_module_name %s\",\n-      _archived_main_module_name != nullptr ? _archived_main_module_name : \"(null)\");\n-    bool disable = false;\n-    if (runtime_main_module == nullptr) {\n-      if (_archived_main_module_name != nullptr) {\n-        log_info(cds)(\"Module %s specified during dump time but not during runtime\", _archived_main_module_name);\n-        disable = true;\n-      }\n-    } else {\n-      if (_archived_main_module_name == nullptr) {\n-        log_info(cds)(\"Module %s specified during runtime but not during dump time\", runtime_main_module);\n-        disable = true;\n-      } else if (strcmp(runtime_main_module, _archived_main_module_name) != 0) {\n-        log_info(cds)(\"Mismatched modules: runtime %s dump time %s\", runtime_main_module, _archived_main_module_name);\n-        disable = true;\n-      }\n-    }\n-\n-    if (disable) {\n-      log_info(cds)(\"Disabling optimized module handling\");\n-      CDSConfig::stop_using_optimized_module_handling();\n-    }\n-    log_info(cds)(\"optimized module handling: %s\", CDSConfig::is_using_optimized_module_handling() ? \"enabled\" : \"disabled\");\n-    log_info(cds)(\"full module graph: %s\", CDSConfig::is_using_full_module_graph() ? \"enabled\" : \"disabled\");\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":0,"deletions":41,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,6 +62,0 @@\n-  static void dump_main_module_name() NOT_CDS_JAVA_HEAP_RETURN;\n-  static void serialize(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  static char* _archived_main_module_name;\n-#endif\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -137,3 +138,3 @@\n-  if (_java_system_loader.is_empty()) {\n-    oop system_loader = get_system_class_loader_impl(CHECK);\n-    _java_system_loader = OopHandle(Universe::vm_global(), system_loader);\n+  if (_java_platform_loader.is_empty()) {\n+    oop platform_loader = get_platform_class_loader_impl(CHECK);\n+    _java_platform_loader = OopHandle(Universe::vm_global(), platform_loader);\n@@ -145,2 +146,2 @@\n-      oop system_loader = get_system_class_loader_impl(CHECK);\n-      assert(_java_system_loader.resolve() == system_loader, \"must be\");\n+      oop platform_loader = get_platform_class_loader_impl(CHECK);\n+      assert(_java_platform_loader.resolve() == platform_loader, \"must be\");\n@@ -150,3 +151,3 @@\n-  if (_java_platform_loader.is_empty()) {\n-    oop platform_loader = get_platform_class_loader_impl(CHECK);\n-    _java_platform_loader = OopHandle(Universe::vm_global(), platform_loader);\n+  if (_java_system_loader.is_empty()) {\n+    oop system_loader = get_system_class_loader_impl(CHECK);\n+    _java_system_loader = OopHandle(Universe::vm_global(), system_loader);\n@@ -158,2 +159,2 @@\n-      oop platform_loader = get_platform_class_loader_impl(CHECK);\n-      assert(_java_platform_loader.resolve() == platform_loader, \"must be\");\n+      oop system_loader = get_system_class_loader_impl(CHECK);\n+      assert(_java_system_loader.resolve() == system_loader, \"must be\");\n@@ -1729,0 +1730,17 @@\n+#if INCLUDE_CDS\n+\/\/ Indicate that loader_data has initiated the loading of class k, which\n+\/\/ has already been defined by a parent loader.\n+\/\/ This API should be used only by AOTLinkedClassBulkLoader\n+void SystemDictionary::add_to_initiating_loader(JavaThread* current,\n+                                                InstanceKlass* k,\n+                                                ClassLoaderData* loader_data) {\n+  assert(CDSConfig::is_using_aot_linked_classes(), \"must be\");\n+  assert_locked_or_safepoint(SystemDictionary_lock);\n+  Symbol* name  = k->name();\n+  Dictionary* dictionary = loader_data->dictionary();\n+  assert(k->is_loaded(), \"must be\");\n+  assert(k->class_loader_data() != loader_data, \"only for classes defined by a parent loader\");\n+  assert(dictionary->find_class(current, name) == nullptr, \"sanity\");\n+  dictionary->add_klass(current, name, k);\n+}\n+#endif\n@@ -2044,0 +2062,46 @@\n+#if INCLUDE_CDS\n+void SystemDictionary::get_all_method_handle_intrinsics(GrowableArray<Method*>* methods) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"must be\");\n+  auto do_method = [&] (InvokeMethodKey& key, Method*& m) {\n+    methods->append(m);\n+  };\n+  _invoke_method_intrinsic_table->iterate_all(do_method);\n+}\n+\n+void SystemDictionary::restore_archived_method_handle_intrinsics() {\n+  if (UseSharedSpaces) {\n+    EXCEPTION_MARK;\n+    restore_archived_method_handle_intrinsics_impl(THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      \/\/ This is probably caused by OOM -- other parts of the CDS archive have direct pointers to\n+      \/\/ the archived method handle intrinsics, so we can't really recover from this failure.\n+      vm_exit_during_initialization(err_msg(\"Failed to restore archived method handle intrinsics. Try to increase heap size.\"));\n+    }\n+  }\n+}\n+\n+void SystemDictionary::restore_archived_method_handle_intrinsics_impl(TRAPS) {\n+  Array<Method*>* list = MetaspaceShared::archived_method_handle_intrinsics();\n+  for (int i = 0; i < list->length(); i++) {\n+    methodHandle m(THREAD, list->at(i));\n+    Method::restore_archived_method_handle_intrinsic(m, CHECK);\n+    m->constants()->restore_unshareable_info(CHECK);\n+    if (!Arguments::is_interpreter_only() || m->intrinsic_id() == vmIntrinsics::_linkToNative) {\n+      AdapterHandlerLibrary::create_native_wrapper(m);\n+      if (!m->has_compiled_code()) {\n+        ResourceMark rm(THREAD);\n+        vm_exit_during_initialization(err_msg(\"Failed to initialize method %s\", m->external_name()));\n+      }\n+    }\n+\n+    \/\/ There's no need to grab the InvokeMethodIntrinsicTable_lock, as we are still very early in\n+    \/\/ VM start-up -- in init_globals2() -- so we are still running a single Java thread. It's not\n+    \/\/ possible to have a contention.\n+    const int iid_as_int = vmIntrinsics::as_int(m->intrinsic_id());\n+    InvokeMethodKey key(m->signature(), iid_as_int);\n+    bool created = _invoke_method_intrinsic_table->put(key, m());\n+    assert(created, \"unexpected contention\");\n+  }\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":74,"deletions":10,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+template <class E> class GrowableArray;\n+\n@@ -79,0 +81,1 @@\n+  friend class AOTLinkedClassBulkLoader;\n@@ -242,0 +245,3 @@\n+  static void get_all_method_handle_intrinsics(GrowableArray<Method*>* methods) NOT_CDS_RETURN;\n+  static void restore_archived_method_handle_intrinsics() NOT_CDS_RETURN;\n+\n@@ -296,0 +302,3 @@\n+  static void add_to_initiating_loader(JavaThread* current, InstanceKlass* k,\n+                                       ClassLoaderData* loader_data) NOT_CDS_RETURN;\n+\n@@ -334,0 +343,1 @@\n+  static void restore_archived_method_handle_intrinsics_impl(TRAPS) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/cdsProtectionDomain.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"cds\/dumpTimeClassInfo.inline.hpp\"\n@@ -34,2 +36,1 @@\n-#include \"cds\/cdsProtectionDomain.hpp\"\n-#include \"cds\/dumpTimeClassInfo.inline.hpp\"\n+#include \"cds\/heapShared.hpp\"\n@@ -196,0 +197,9 @@\n+void SystemDictionaryShared::mark_required_hidden_class(InstanceKlass* k) {\n+  assert(k->is_hidden(), \"sanity\");\n+  DumpTimeClassInfo* info = _dumptime_table->get(k);\n+  ResourceMark rm;\n+  if (info != nullptr) {\n+    info->set_is_required_hidden_class();\n+  }\n+}\n+\n@@ -279,3 +289,7 @@\n-      ResourceMark rm;\n-      log_info(cds)(\"Skipping %s because it is dynamically generated\", k->name()->as_C_string());\n-      return true; \/\/ exclude without warning\n+      if (CDSConfig::is_dumping_aot_linked_classes()) {\n+        k->set_shared_classpath_index(0);\n+      } else {\n+        ResourceMark rm;\n+        log_info(cds)(\"Skipping %s because it is dynamically generated\", k->name()->as_C_string());\n+        return true; \/\/ exclude without warning\n+      }\n@@ -318,3 +332,2 @@\n-  if (k->is_hidden() && !is_registered_lambda_proxy_class(k)) {\n-    ResourceMark rm;\n-    log_debug(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n+  if (k->is_hidden() && !should_hidden_class_be_archived(k)) {\n+    log_info(cds)(\"Skipping %s: Hidden class\", k->name()->as_C_string());\n@@ -580,1 +593,5 @@\n-      assert(is_registered_lambda_proxy_class(k), \"unexpected hidden class %s\", name);\n+      if (CDSConfig::is_dumping_invokedynamic()) {\n+        assert(should_hidden_class_be_archived(k), \"unexpected hidden class %s\", name);\n+      } else {\n+        assert(is_registered_lambda_proxy_class(k), \"unexpected hidden class %s\", name);\n+      }\n@@ -632,1 +649,73 @@\n-void SystemDictionaryShared::check_excluded_classes() {\n+void SystemDictionaryShared::scan_constant_pool(InstanceKlass* k) {\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    k->constants()->find_required_hidden_classes();\n+  }\n+}\n+\n+bool SystemDictionaryShared::should_hidden_class_be_archived(InstanceKlass* k) {\n+  assert(k->is_hidden(), \"sanity\");\n+  if (is_registered_lambda_proxy_class(k)) {\n+    return true;\n+  }\n+\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    DumpTimeClassInfo* info = _dumptime_table->get(k);\n+    if (info != nullptr && info->is_required_hidden_class()) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+\/\/ Returns true if the class should be excluded. This can be called before\n+\/\/ SystemDictionaryShared::find_all_archivable_classes().\n+bool SystemDictionaryShared::check_for_exclusion(Klass* k) {\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n+\n+  if (k->is_objArray_klass()) {\n+    return check_for_exclusion(ObjArrayKlass::cast(k)->bottom_klass());\n+  }\n+\n+  if (!k->is_instance_klass()) {\n+    return false;\n+  } else {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      return is_excluded_class(ik);\n+    }\n+\n+    if (!ik->is_linked()) {\n+      JavaThread* THREAD = JavaThread::current();\n+      ik->link_class(THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        CLEAR_PENDING_EXCEPTION;\n+        return true;\n+      }\n+    }\n+\n+    MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+    DumpTimeClassInfo* p = get_info_locked(ik);\n+    if (p->is_excluded()) {\n+      return true;\n+    }\n+    return check_for_exclusion(ik, p);\n+  }\n+}\n+\n+void SystemDictionaryShared::find_all_archivable_classes() {\n+  HeapShared::start_finding_required_hidden_classes();\n+  find_all_archivable_classes_impl();\n+  HeapShared::end_finding_required_hidden_classes();\n+}\n+\n+\/\/ Iterate over all the classes in _dumptime_table, marking the ones that must be\n+\/\/ excluded from the archive. Those that are not excluded will be archivable.\n+\/\/\n+\/\/ (a) Non-hidden classes are easy. They are only check by the rules in\n+\/\/     SystemDictionaryShared::check_for_exclusion().\n+\/\/ (b) For hidden classes, we only archive those that are required (i.e., they are\n+\/\/     referenced by Java objects (such as CallSites) that are reachable from\n+\/\/     ConstantPools). This needs help from HeapShared.\n+void SystemDictionaryShared::find_all_archivable_classes_impl() {\n@@ -645,2 +734,11 @@\n-  auto check_for_exclusion = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n-    SystemDictionaryShared::check_for_exclusion(k, &info);\n+  ResourceMark rm;\n+\n+  \/\/ First, scan all non-hidden classes\n+  auto check_non_hidden = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (!k->is_hidden()) {\n+      SystemDictionaryShared::check_for_exclusion(k, &info);\n+      if (!info.is_excluded() && !info.has_scanned_constant_pool()) {\n+        scan_constant_pool(k);\n+        info.set_has_scanned_constant_pool();\n+      }\n+    }\n@@ -648,1 +746,38 @@\n-  _dumptime_table->iterate_all_live_classes(check_for_exclusion);\n+  _dumptime_table->iterate_all_live_classes(check_non_hidden);\n+\n+  \/\/ Then, scan all the hidden classes that have been marked as required to\n+  \/\/ discover more hidden classes. Stop when we cannot make progress anymore.\n+  bool made_progress;\n+  do {\n+    made_progress = false;\n+    auto check_hidden = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n+      if (k->is_hidden() && should_hidden_class_be_archived(k)) {\n+        SystemDictionaryShared::check_for_exclusion(k, &info);\n+        if (info.is_excluded()) {\n+          guarantee(!info.is_required_hidden_class(), \"A required hidden class cannot be marked as excluded\");\n+        } else if (!info.has_scanned_constant_pool()) {\n+          scan_constant_pool(k);\n+          info.set_has_scanned_constant_pool();\n+          \/\/ The CP entries in k *MAY* refer to other hidden classes, so scan\n+          \/\/ every hidden class again.\n+          made_progress = true;\n+        }\n+      }\n+    };\n+    _dumptime_table->iterate_all_live_classes(check_hidden);\n+  } while (made_progress);\n+\n+  \/\/ Now, all hidden classes that have not yet been scanned must be marked as excluded\n+  auto exclude_remaining_hidden = [&] (InstanceKlass* k, DumpTimeClassInfo& info) {\n+    if (k->is_hidden()) {\n+      SystemDictionaryShared::check_for_exclusion(k, &info);\n+      if (CDSConfig::is_dumping_invokedynamic()) {\n+        if (should_hidden_class_be_archived(k)) {\n+          guarantee(!info.is_excluded(), \"Must be\");\n+        } else {\n+          guarantee(info.is_excluded(), \"Must be\");\n+        }\n+      }\n+    }\n+  };\n+  _dumptime_table->iterate_all_live_classes(exclude_remaining_hidden);\n@@ -758,0 +893,5 @@\n+  if (CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ The lambda proxy classes will be stored as part of aot-resolved constant pool entries.\n+    \/\/ There's no need to remember them in a separate table.\n+    return;\n+  }\n@@ -1169,1 +1309,1 @@\n-    \/\/ The following check has been moved to SystemDictionaryShared::check_excluded_classes(), which\n+    \/\/ The following check has been moved to SystemDictionaryShared::find_all_archivable_classes(), which\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":154,"deletions":14,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,0 +191,1 @@\n+  static void find_all_archivable_classes_impl();\n@@ -202,1 +203,1 @@\n-\n+  static void scan_constant_pool(InstanceKlass* k);\n@@ -206,0 +207,2 @@\n+  static bool should_hidden_class_be_archived(InstanceKlass* k);\n+  static void mark_required_hidden_class(InstanceKlass* k);\n@@ -291,1 +294,2 @@\n-  static void check_excluded_classes();\n+  static void find_all_archivable_classes();\n+  static bool check_for_exclusion(Klass* k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,0 +180,1 @@\n+  do_klass(Void_klass,                                  java_lang_Void                                        ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -213,0 +214,3 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    AOTLinkedClassBulkLoader::load_javabase_classes(THREAD);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+  template(java_lang_Void,                            \"java\/lang\/Void\")                           \\\n@@ -313,0 +314,2 @@\n+  template(java_lang_ref_SoftReference_signature,         \"Ljava\/lang\/ref\/SoftReference;\")        \\\n+                                                                                                  \\\n@@ -730,0 +733,1 @@\n+  template(createArchivedObjects,                           \"createArchivedObjects\")                              \\\n@@ -743,0 +747,1 @@\n+  template(runtimeSetup,                                    \"runtimeSetup\")                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -952,0 +952,9 @@\n+void InterpreterRuntime::cds_resolve_invokehandle(int raw_index,\n+                                                  constantPoolHandle& pool, TRAPS) {\n+  const Bytecodes::Code bytecode = Bytecodes::_invokehandle;\n+  CallInfo info;\n+  LinkResolver::resolve_invoke(info, Handle(), pool, raw_index, bytecode, CHECK);\n+\n+  pool->cache()->set_method_handle(raw_index, info);\n+}\n+\n@@ -971,0 +980,8 @@\n+void InterpreterRuntime::cds_resolve_invokedynamic(int raw_index,\n+                                                   constantPoolHandle& pool, TRAPS) {\n+  const Bytecodes::Code bytecode = Bytecodes::_invokedynamic;\n+  CallInfo info;\n+  LinkResolver::resolve_invoke(info, Handle(), pool, raw_index, bytecode, CHECK);\n+  pool->cache()->set_dynamic_call(info, raw_index);\n+}\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  \/\/ Used by ClassPrelinker\n+  \/\/ Used by AOTConstantPoolResolver\n@@ -100,1 +100,4 @@\n-\n+  static void cds_resolve_invokehandle(int raw_index,\n+                                       constantPoolHandle& pool, TRAPS);\n+  static void cds_resolve_invokedynamic(int raw_index,\n+                                        constantPoolHandle& pool, TRAPS);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+  LOG_TAG(aot) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -54,1 +55,5 @@\n-  ClaimMetadataVisitingOopIterateClosure::do_cld(cld);\n+  if (cld != nullptr) {\n+    ClaimMetadataVisitingOopIterateClosure::do_cld(cld);\n+  } else {\n+    assert(AOTLinkedClassBulkLoader::is_pending_aot_linked_class(k), \"sanity\");\n+  }\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n-#include \"cds\/archiveHeapWriter.hpp\"\n-#include \"cds\/archiveHeapLoader.hpp\"\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n@@ -29,0 +28,2 @@\n+#include \"cds\/archiveHeapLoader.hpp\"\n+#include \"cds\/archiveHeapWriter.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -38,0 +38,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -302,1 +303,3 @@\n-  if (rr != nullptr) {\n+  if (rr == nullptr) {\n+    return nullptr;\n+  } else {\n@@ -308,0 +311,1 @@\n+\n@@ -319,0 +323,1 @@\n+            continue;\n@@ -321,0 +326,4 @@\n+\n+        if (CDSConfig::is_dumping_invokedynamic()) {\n+          scratch_rr->obj_at_put(i, obj);\n+        }\n@@ -325,1 +334,33 @@\n-  return rr;\n+}\n+\n+void ConstantPool::find_required_hidden_classes() {\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ This function is needed only for supporting aot-linking indy.\n+    return;\n+  }\n+\n+  if (_cache == nullptr) {\n+    return;\n+  }\n+\n+  ClassLoaderData* loader_data = pool_holder()->class_loader_data();\n+  if (loader_data == nullptr) {\n+    \/\/ These are custom loader classes from the preimage\n+    return;\n+  }\n+\n+  if (!SystemDictionaryShared::is_builtin_loader(loader_data)) {\n+    \/\/ Archiving resolved references for classes from non-builtin loaders\n+    \/\/ is not yet supported.\n+    return;\n+  }\n+\n+  objArrayOop rr = resolved_references();\n+  if (rr != nullptr) {\n+    for (int i = 0; i < rr->length(); i++) {\n+      oop obj = rr->obj_at(i);\n+      if (obj != nullptr) {\n+        HeapShared::find_required_hidden_classes_in_object(obj);\n+      }\n+    }\n+  }\n@@ -352,0 +393,5 @@\n+  if (is_for_method_handle_intrinsic()) {\n+    \/\/ See the same check in remove_unshareable_info() below.\n+    assert(cache() == NULL, \"must not have cpCache\");\n+    return;\n+  }\n@@ -391,0 +437,8 @@\n+  if (is_for_method_handle_intrinsic()) {\n+    \/\/ This CP was created by Method::make_method_handle_intrinsic() and has nothing\n+    \/\/ that need to be removed\/restored. It has no cpCache since the intrinsic methods\n+    \/\/ don't have any bytecodes.\n+    assert(cache() == NULL, \"must not have cpCache\");\n+    return;\n+  }\n+\n@@ -485,1 +539,1 @@\n-    can_archive = ClassPrelinker::is_resolution_deterministic(src_cp, cp_index);\n+    can_archive = AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index);\n@@ -505,1 +559,1 @@\n-      log.print(\"    %s\", name->as_C_string());\n+      log.print(\" => %s\", name->as_C_string());\n@@ -751,3 +805,1 @@\n-      tty->print_cr(\"Unexpected bytecode: %d\", code);\n-      ShouldNotReachHere(); \/\/ All cases should have been handled\n-      return -1;\n+      fatal(\"Unexpected bytecode: %s\", Bytecodes::name(code));\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":62,"deletions":10,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-  friend class ClassPrelinker;       \/\/ CDS\n+  friend class AOTConstantPoolResolver;\n@@ -112,1 +112,2 @@\n-    _has_dynamic_constant = 8\n+    _has_dynamic_constant = 8,\n+    _is_for_method_handle_intrinsic = 16\n@@ -219,0 +220,3 @@\n+  bool is_for_method_handle_intrinsic() const  { return (_flags & _is_for_method_handle_intrinsic) != 0; }\n+  void set_is_for_method_handle_intrinsic()    { _flags |= _is_for_method_handle_intrinsic; }\n+\n@@ -682,0 +686,1 @@\n+  void find_required_hidden_classes() NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotConstantPoolResolver.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"cds\/classPrelinker.hpp\"\n@@ -404,3 +404,1 @@\n-    for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n-      resolved_indy_entry_at(i)->remove_unshareable_info();\n-    }\n+    remove_resolved_indy_entries_if_non_deterministic();\n@@ -425,1 +423,1 @@\n-    if (resolved && ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n+    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n@@ -439,1 +437,1 @@\n-        log.print(\"%s field  CP entry [%3d]: %s %s %s.%s:%s\",\n+        log.print(\"%s field  CP entry [%3d]: %s => %s.%s:%s\",\n@@ -443,1 +441,0 @@\n-                  (archived ? \"=>\" : \"  \"),\n@@ -460,1 +457,2 @@\n-                    rme->is_resolved(Bytecodes::_invokeinterface);\n+                    rme->is_resolved(Bytecodes::_invokeinterface) ||\n+                    rme->is_resolved(Bytecodes::_invokehandle);\n@@ -463,2 +461,1 @@\n-    resolved &= !(rme->is_resolved(Bytecodes::_invokehandle) ||\n-                  rme->is_resolved(Bytecodes::_invokestatic));\n+    resolved &= !(rme->is_resolved(Bytecodes::_invokestatic));\n@@ -466,1 +463,1 @@\n-    if (resolved && can_archive_resolved_method(rme)) {\n+    if (resolved && can_archive_resolved_method(src_cp, rme)) {\n@@ -498,1 +495,40 @@\n-bool ConstantPoolCache::can_archive_resolved_method(ResolvedMethodEntry* method_entry) {\n+void ConstantPoolCache::remove_resolved_indy_entries_if_non_deterministic() {\n+  ConstantPool* cp = constant_pool();\n+  ConstantPool* src_cp =  ArchiveBuilder::current()->get_source_addr(cp);\n+  for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n+    ResolvedIndyEntry* rei = _resolved_indy_entries->adr_at(i);\n+    int cp_index = rei->constant_pool_index();\n+    bool archived = false;\n+    bool resolved = rei->is_resolved();\n+    if (resolved && CDSConfig::is_dumping_invokedynamic()) {\n+      \/\/ If we have resolved indys with MethodTypes that reference excluded classes,\n+      \/\/ it's too late to undo now. AOTConstantPoolResolver::preresolve_indy_cp_entries()\n+      \/\/ should not have resolved such entries.\n+      guarantee(AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index),\n+                \"should not have resolved non-deterministic indy\");\n+      rei->mark_and_relocate();\n+      archived = true;\n+    } else {\n+      rei->remove_unshareable_info();\n+    }\n+    if (resolved) {\n+      LogStreamHandle(Trace, cds, resolve) log;\n+      if (log.is_enabled()) {\n+        ResourceMark rm;\n+        int bsm = cp->bootstrap_method_ref_index_at(cp_index);\n+        int bsm_ref = cp->method_handle_index_at(bsm);\n+        Symbol* bsm_name = cp->uncached_name_ref_at(bsm_ref);\n+        Symbol* bsm_signature = cp->uncached_signature_ref_at(bsm_ref);\n+        Symbol* bsm_klass = cp->klass_name_at(cp->uncached_klass_ref_index_at(bsm_ref));\n+        log.print(\"%s indy   CP entry [%3d]: %s (%d)\",\n+                  (archived ? \"archived\" : \"reverted\"),\n+                  cp_index, cp->pool_holder()->name()->as_C_string(), i);\n+        log.print(\" %s %s.%s:%s\", (archived ? \"=>\" : \"  \"), bsm_klass->as_C_string(),\n+                  bsm_name->as_C_string(), bsm_signature->as_C_string());\n+      }\n+      ArchiveBuilder::alloc_stats()->record_indy_cp_entry(archived, resolved && !archived);\n+    }\n+  }\n+}\n+\n+bool ConstantPoolCache::can_archive_resolved_method(ConstantPool* src_cp, ResolvedMethodEntry* method_entry) {\n@@ -523,1 +559,0 @@\n-  ConstantPool* src_cp = ArchiveBuilder::current()->get_source_addr(constant_pool());\n@@ -526,3 +561,1 @@\n-  if (!ClassPrelinker::is_resolution_deterministic(src_cp, cp_index)) {\n-    return false;\n-  }\n+  bool deterministic = AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index);\n@@ -533,1 +566,9 @@\n-    return true;\n+    return deterministic;\n+  } else if (method_entry->is_resolved(Bytecodes::_invokehandle)) {\n+    if (CDSConfig::is_dumping_invokedynamic()) {\n+      \/\/ invokehandle depends on archived MethodType and LambdaForms.\n+      guarantee(deterministic, \"should not have resolved resolve non-deterministic invokehandle\");\n+      return true;\n+    } else {\n+      return false;\n+    }\n@@ -535,1 +576,0 @@\n-    \/\/ invokestatic and invokehandle are not supported yet.\n@@ -538,1 +578,0 @@\n-\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":58,"deletions":19,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+  void remove_resolved_indy_entries_if_non_deterministic();\n@@ -228,1 +229,1 @@\n-  bool can_archive_resolved_method(ResolvedMethodEntry* method_entry);\n+  bool can_archive_resolved_method(ConstantPool* src_cp, ResolvedMethodEntry* method_entry);\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/aotClassInitializer.hpp\"\n@@ -731,0 +732,12 @@\n+\/\/ JLS 8.9: An enum class is either implicitly final and derives\n+\/\/ from java.lang.Enum, or else is implicitly sealed to its\n+\/\/ anonymous subclasses. This query detects both kinds.\n+\/\/ It does not validate the finality or\n+\/\/ sealing conditions: it merely checks for a super of Enum.\n+\/\/ This is sufficient for recognizing well-formed enums.\n+bool InstanceKlass::is_enum_subclass() const {\n+  InstanceKlass* s = java_super();\n+  return (s == vmClasses::Enum_klass() ||\n+          (s != nullptr && s->java_super() == vmClasses::Enum_klass()));\n+}\n+\n@@ -788,0 +801,62 @@\n+#ifdef ASSERT\n+void InstanceKlass::assert_no_clinit_will_run_for_aot_initialized_class() const {\n+  assert(has_aot_initialized_mirror(), \"must be\");\n+\n+  InstanceKlass* s = java_super();\n+  if (s != nullptr) {\n+    DEBUG_ONLY(ResourceMark rm);\n+    assert(s->is_initialized(), \"super class %s of aot-inited class %s must have been initialized\",\n+           s->external_name(), external_name());\n+    s->assert_no_clinit_will_run_for_aot_initialized_class();\n+  }\n+\n+  Array<InstanceKlass*>* interfaces = local_interfaces();\n+  int len = interfaces->length();\n+  for (int i = 0; i < len; i++) {\n+    InstanceKlass* intf = interfaces->at(i);\n+    if (!intf->is_initialized()) {\n+      ResourceMark rm;\n+      \/\/ Note: an interface needs to be marked as is_initialized() only if\n+      \/\/ - it has a <clinit>\n+      \/\/ - it has declared a default method.\n+      assert(!intf->interface_needs_clinit_execution_as_super(\/*also_check_supers*\/false),\n+             \"uninitialized super interface %s of aot-inited class %s must not have <clinit>\",\n+             intf->external_name(), external_name());\n+    }\n+  }\n+}\n+#endif\n+\n+#if INCLUDE_CDS\n+void InstanceKlass::initialize_with_aot_initialized_mirror(TRAPS) {\n+  assert(has_aot_initialized_mirror(), \"must be\");\n+  assert(CDSConfig::is_loading_heap(), \"must be\");\n+  assert(CDSConfig::is_using_aot_linked_classes(), \"must be\");\n+  assert_no_clinit_will_run_for_aot_initialized_class();\n+\n+  if (is_initialized()) {\n+    return;\n+  }\n+\n+  if (log_is_enabled(Info, cds, init)) {\n+    ResourceMark rm;\n+    log_info(cds, init)(\"%s (aot-inited)\", external_name());\n+  }\n+\n+  link_class(CHECK);\n+\n+#ifdef ASSERT\n+  {\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, THREAD);\n+    assert(!is_initialized(), \"sanity\");\n+    assert(!is_being_initialized(), \"sanity\");\n+    assert(!is_in_error_state(), \"sanity\");\n+  }\n+#endif\n+\n+  set_init_thread(THREAD);\n+  set_initialization_state_and_notify(fully_initialized, CHECK);\n+  AOTClassInitializer::call_runtime_setup(this, CHECK);\n+}\n+#endif\n@@ -1584,1 +1659,4 @@\n-  if (has_archived_enum_objs()) {\n+  if (has_aot_initialized_mirror() && CDSConfig::is_loading_heap()) {\n+    AOTClassInitializer::call_runtime_setup(this, CHECK);\n+    return;\n+  } else if (has_archived_enum_objs()) {\n@@ -1612,0 +1690,41 @@\n+\/\/ If a class that implements this interface is initialized, is the JVM required\n+\/\/ to first execute a <clinit> method declared in this interface,\n+\/\/ or (if also_check_supers==true) any of the super types of this interface?\n+\/\/\n+\/\/ JVMS 5.5. Initialization, step 7: Next, if C is a class rather than\n+\/\/ an interface, then let SC be its superclass and let SI1, ..., SIn\n+\/\/ be all superinterfaces of C (whether direct or indirect) that\n+\/\/ declare at least one non-abstract, non-static method.\n+\/\/\n+\/\/ So when an interface is initialized, it does not look at its\n+\/\/ supers. But a proper class will ensure that all of its supers have\n+\/\/ run their <clinit> methods, except that it disregards interfaces\n+\/\/ that lack a non-static concrete method (i.e., a default method).\n+\/\/ Therefore, you should probably call this method only when the\n+\/\/ current class is a super of some proper class, not an interface.\n+bool InstanceKlass::interface_needs_clinit_execution_as_super(bool also_check_supers) const {\n+  assert(is_interface(), \"must be\");\n+\n+  if (!has_nonstatic_concrete_methods()) {\n+    \/\/ quick check: no nonstatic concrete methods are declared by this or any super interfaces\n+    return false;\n+  }\n+\n+  \/\/ JVMS 5.5. Initialization\n+  \/\/ ...If C is an interface that declares a non-abstract,\n+  \/\/ non-static method, the initialization of a class that\n+  \/\/ implements C directly or indirectly.\n+  if (declares_nonstatic_concrete_methods() && class_initializer() != nullptr) {\n+    return true;\n+  }\n+  if (also_check_supers) {\n+    Array<InstanceKlass*>* all_ifs = transitive_interfaces();\n+    for (int i = 0; i < all_ifs->length(); ++i) {\n+      InstanceKlass* super_intf = all_ifs->at(i);\n+      if (super_intf->declares_nonstatic_concrete_methods() && super_intf->class_initializer() != nullptr) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n@@ -2502,0 +2621,1 @@\n+  it->push(&_nest_host);\n@@ -2565,2 +2685,6 @@\n-  \/\/ clear _nest_host to ensure re-load at runtime\n-  _nest_host = nullptr;\n+  if (CDSConfig::is_dumping_invokedynamic() && HeapShared::is_lambda_proxy_klass(this)) {\n+    \/\/ keep _nest_host\n+  } else {\n+    \/\/ clear _nest_host to ensure re-load at runtime\n+    _nest_host = nullptr;\n+  }\n@@ -2700,0 +2824,12 @@\n+\n+int InstanceKlass::shared_class_loader_type() const {\n+  if (is_shared_boot_class()) {\n+    return ClassLoader::BOOT_LOADER;\n+  } else if (is_shared_platform_class()) {\n+    return ClassLoader::PLATFORM_LOADER;\n+  } else if (is_shared_app_class()) {\n+    return ClassLoader::APP_LOADER;\n+  } else {\n+    return ClassLoader::OTHER;\n+  }\n+}\n@@ -2907,0 +3043,4 @@\n+bool InstanceKlass::in_javabase_module() const {\n+  return module()->name() == vmSymbols::java_base();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":143,"deletions":3,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -326,0 +326,1 @@\n+  int  shared_class_loader_type() const;\n@@ -432,0 +433,3 @@\n+  \/\/ test for enum class (or possibly an anonymous subclass within a sealed enum)\n+  bool is_enum_subclass() const;\n+\n@@ -478,0 +482,1 @@\n+  bool in_javabase_module() const;\n@@ -534,0 +539,2 @@\n+  void initialize_with_aot_initialized_mirror(TRAPS);\n+  void assert_no_clinit_will_run_for_aot_initialized_class() const NOT_DEBUG_RETURN;\n@@ -540,0 +547,1 @@\n+  bool interface_needs_clinit_execution_as_super(bool also_check_supers=true) const;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -196,1 +196,6 @@\n-    _is_generated_shared_class             = 1 << 5\n+    _is_generated_shared_class             = 1 << 5,\n+    \/\/ archived mirror already initialized by AOT-cache assembly: no further need to call <clinit>\n+    _has_aot_initialized_mirror            = 1 << 6,\n+    \/\/ If this class has been aot-inititalized, do we need to call its runtimeSetup()\n+    \/\/ method during the production run?\n+    _is_runtime_setup_required             = 1 << 7,\n@@ -379,0 +384,17 @@\n+  void set_has_aot_initialized_mirror() {\n+    CDS_ONLY(_shared_class_flags |= _has_aot_initialized_mirror;)\n+  }\n+  bool has_aot_initialized_mirror() const {\n+    CDS_ONLY(return (_shared_class_flags & _has_aot_initialized_mirror) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n+  void set_is_runtime_setup_required() {\n+    assert(has_aot_initialized_mirror(), \"sanity\");\n+    CDS_ONLY(_shared_class_flags |= _is_runtime_setup_required;)\n+  }\n+  bool is_runtime_setup_required() const {\n+    CDS_ONLY(return (_shared_class_flags & _is_runtime_setup_required) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1430,0 +1430,1 @@\n+  cp->set_is_for_method_handle_intrinsic();\n@@ -1478,0 +1479,10 @@\n+#if INCLUDE_CDS\n+void Method::restore_archived_method_handle_intrinsic(methodHandle m, TRAPS) {\n+  m->link_method(m, CHECK);\n+\n+  if (m->intrinsic_id() == vmIntrinsics::_linkToNative) {\n+    m->set_interpreter_entry(m->adapter()->get_i2c_entry());\n+  }\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+  static void restore_archived_method_handle_intrinsic(methodHandle m, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2922,1 +2922,1 @@\n-  if (CDSConfig::is_dumping_static_archive()) {\n+  if (CDSConfig::allow_only_single_java_thread()) {\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1078,0 +1078,10 @@\n+bool JvmtiExport::has_early_vmstart_env() {\n+  JvmtiEnvIterator it;\n+  for (JvmtiEnv* env = it.first(); env != nullptr; env = it.next(env)) {\n+    if (env->early_vmstart_env()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -374,0 +374,1 @@\n+  static bool has_early_vmstart_env() NOT_JVMTI_RETURN_(false);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2532,0 +2532,1 @@\n+      CDSConfig::set_old_cds_flags_used();\n@@ -2536,0 +2537,1 @@\n+      CDSConfig::set_old_cds_flags_used();\n@@ -2541,0 +2543,1 @@\n+      CDSConfig::set_old_cds_flags_used();\n@@ -2545,0 +2548,1 @@\n+      CDSConfig::set_old_cds_flags_used();\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -313,0 +313,11 @@\n+  const JVMTypedFlagLimit<ccstr>* constraint = (const JVMTypedFlagLimit<ccstr>*)JVMFlagLimit::get_constraint(flag);\n+  if (constraint != nullptr && constraint->phase() <= JVMFlagLimit::validating_phase()) {\n+    bool verbose = JVMFlagLimit::verbose_checks_needed() | (origin == JVMFlagOrigin::ERGONOMIC);\n+    JVMFlag::Error err = ((JVMFlagConstraintFunc_ccstr)constraint->constraint_func())(*value, verbose);\n+    if (err != JVMFlag::SUCCESS) {\n+      if (origin == JVMFlagOrigin::ERGONOMIC) {\n+        fatal(\"FLAG_SET_ERGO cannot be used to set an invalid value for %s\", flag->name());\n+      }\n+      return err;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,15 @@\n+JVMFlag::Error AOTModeConstraintFunc(ccstr value, bool verbose) {\n+  if (strcmp(value, \"off\") != 0 &&\n+      strcmp(value, \"record\") != 0 &&\n+      strcmp(value, \"create\") != 0 &&\n+      strcmp(value, \"auto\") != 0 &&\n+      strcmp(value, \"on\") != 0) {\n+    JVMFlag::printError(verbose,\n+                        \"Unrecognized value %s for AOTMode. Must be one of the following: \"\n+                        \"off, record, create, auto, on\\n\",\n+                        value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+\n+  return JVMFlag::SUCCESS;\n+}\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+  f(ccstr,  AOTModeConstraintFunc)                    \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotLinkedClassBulkLoader.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -33,0 +35,1 @@\n+#include \"classfile\/symbolTable.hpp\"\n@@ -348,0 +351,1 @@\n+\n@@ -354,0 +358,2 @@\n+  HeapShared::init_box_classes(CHECK);\n+\n@@ -401,0 +407,1 @@\n+  initialize_class(vmSymbols::java_lang_InternalError(), CHECK);\n@@ -410,0 +417,4 @@\n+\n+  if (UseSharedSpaces) {\n+    HeapShared::initialize_java_lang_invoke(CHECK);\n+  }\n@@ -727,0 +738,5 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    AOTLinkedClassBulkLoader::finish_loading_javabase_classes(CHECK_JNI_ERR);\n+    SystemDictionary::restore_archived_method_handle_intrinsics();\n+  }\n+\n@@ -742,0 +758,7 @@\n+  if (CDSConfig::is_using_aot_linked_classes()) {\n+    AOTLinkedClassBulkLoader::load_non_javabase_classes(THREAD);\n+  }\n+#ifndef PRODUCT\n+  HeapShared::initialize_test_class_from_archive(THREAD);\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -234,0 +234,5 @@\n+        runtimeSetup();\n+    }\n+\n+    \/\/ Called from JVM when loading an AOT cache\n+    private static void runtimeSetup() {\n@@ -4058,0 +4063,9 @@\n+    \/**\n+     * When CDS is enabled, the Class class may be aot-initialized. However,\n+     * we can't archive reflectionFactory, so we reset it to null, so it\n+     * will be allocated again at runtime.\n+     *\/\n+    private static void resetArchivedStates() {\n+        reflectionFactory = null;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -92,1 +93,2 @@\n-    private static final class Transform extends SoftReference<LambdaForm> {\n+    private static final class Transform {\n+        final Object cache;\n@@ -97,1 +99,5 @@\n-            super(result);\n+            if (USE_SOFT_CACHE) {\n+                cache = new SoftReference<LambdaForm>(result);\n+            } else {\n+                cache = result;\n+            }\n@@ -138,0 +144,9 @@\n+\n+        @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+        public LambdaForm get() {\n+            if (cache instanceof LambdaForm lf) {\n+                return lf;\n+            } else {\n+                return ((SoftReference<LambdaForm>)cache).get();\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import sun.security.action.GetPropertyAction;\n@@ -34,0 +35,1 @@\n+import java.util.Properties;\n@@ -693,0 +695,19 @@\n+\n+    \/\/--- AOTCache support\n+\n+    \/**\n+     * In normal execution, this is set to true, so that LambdaFormEditor and MethodTypeForm will\n+     * use soft references to allow class unloading.\n+     *\n+     * When dumping the AOTCache, this is set to false so that no cached heap objects will\n+     * contain soft references (which are not yet supported by AOTCache - see JDK-8341587). AOTCache\n+     * only stores LambdaFormEditors and MethodTypeForms for classes in the boot\/platform\/app loaders.\n+     * Such classes will never be unloaded, so it's OK to use hard references.\n+     *\/\n+    static final boolean USE_SOFT_CACHE;\n+\n+    static {\n+        Properties props = GetPropertyAction.privilegedGetProperties();\n+        USE_SOFT_CACHE = Boolean.parseBoolean(\n+                props.getProperty(\"java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE\", \"true\"));\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+import java.util.HashMap;\n+import java.util.Iterator;\n@@ -49,0 +51,1 @@\n+import jdk.internal.misc.CDS;\n@@ -401,0 +404,11 @@\n+        if (archivedMethodTypes != null) {\n+            \/\/ If this JVM process reads from archivedMethodTypes, it never\n+            \/\/ modifies the table. So there's no need for synchronization.\n+            \/\/ See copyInternTable() below.\n+            assert CDS.isUsingArchive();\n+            MethodType mt = archivedMethodTypes.get(primordialMT);\n+            if (mt != null) {\n+                return mt;\n+            }\n+        }\n+\n@@ -419,0 +433,1 @@\n+\n@@ -420,0 +435,1 @@\n+    private static @Stable HashMap<MethodType,MethodType> archivedMethodTypes;\n@@ -1400,0 +1416,26 @@\n+\n+    static HashMap<MethodType,MethodType> copyInternTable() {\n+        HashMap<MethodType,MethodType> copy = new HashMap<>();\n+\n+        for (Iterator<MethodType> i = internTable.iterator(); i.hasNext(); ) {\n+            MethodType t = i.next();\n+            copy.put(t, t);\n+        }\n+\n+        return copy;\n+    }\n+\n+    \/\/ This is called from C code, at the very end of Java code execution\n+    \/\/ during the AOT cache assembly phase.\n+    static void createArchivedObjects() {\n+        \/\/ After the archivedMethodTypes field is assigned, this table\n+        \/\/ is never modified. So we don't need synchronization when reading from\n+        \/\/ it (which happens only in a future JVM process, never in the current process).\n+        \/\/\n+        \/\/ @implNote CDS.isDumpingStaticArchive() is mutually exclusive with\n+        \/\/ CDS.isUsingArchive(); at most one of them can return true for any given JVM\n+        \/\/ process.\n+        assert CDS.isDumpingStaticArchive();\n+        archivedMethodTypes = copyInternTable();\n+        internTable.clear();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import static java.lang.invoke.MethodHandleNatives.USE_SOFT_CACHE;\n@@ -54,1 +55,1 @@\n-    final SoftReference<MethodHandle>[] methodHandles;\n+    private final Object[] methodHandles;\n@@ -64,1 +65,1 @@\n-    final SoftReference<LambdaForm>[] lambdaForms;\n+    private final Object[] lambdaForms;\n@@ -112,0 +113,1 @@\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -113,2 +115,8 @@\n-        SoftReference<MethodHandle> entry = methodHandles[which];\n-        return (entry != null) ? entry.get() : null;\n+        Object entry = methodHandles[which];\n+        if (entry == null) {\n+            return null;\n+        } else if (entry instanceof MethodHandle mh) {\n+            return mh;\n+        } else {\n+            return ((SoftReference<MethodHandle>)entry).get();\n+        }\n@@ -119,6 +127,8 @@\n-        SoftReference<MethodHandle> entry = methodHandles[which];\n-        if (entry != null) {\n-            MethodHandle prev = entry.get();\n-            if (prev != null) {\n-                return prev;\n-            }\n+        MethodHandle prev = cachedMethodHandle(which);\n+        if (prev != null) {\n+            return prev;\n+        }\n+        if (USE_SOFT_CACHE) {\n+            methodHandles[which] = new SoftReference<>(mh);\n+        } else {\n+            methodHandles[which] = mh;\n@@ -126,1 +136,0 @@\n-        methodHandles[which] = new SoftReference<>(mh);\n@@ -130,0 +139,1 @@\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n@@ -131,2 +141,8 @@\n-        SoftReference<LambdaForm> entry = lambdaForms[which];\n-        return (entry != null) ? entry.get() : null;\n+        Object entry = lambdaForms[which];\n+        if (entry == null) {\n+            return null;\n+        } else if (entry instanceof LambdaForm lf) {\n+            return lf;\n+        } else {\n+            return ((SoftReference<LambdaForm>)entry).get();\n+        }\n@@ -137,6 +153,8 @@\n-        SoftReference<LambdaForm> entry = lambdaForms[which];\n-        if (entry != null) {\n-            LambdaForm prev = entry.get();\n-            if (prev != null) {\n-                return prev;\n-            }\n+        LambdaForm prev = cachedLambdaForm(which);\n+        if (prev != null) {\n+            return prev;\n+        }\n+        if (USE_SOFT_CACHE) {\n+            lambdaForms[which] = new SoftReference<>(form);\n+        } else {\n+            lambdaForms[which] = form;\n@@ -144,1 +162,0 @@\n-        lambdaForms[which] = new SoftReference<>(form);\n@@ -194,2 +211,2 @@\n-            this.lambdaForms   = new SoftReference[LF_LIMIT];\n-            this.methodHandles = new SoftReference[MH_LIMIT];\n+            this.lambdaForms   = new Object[LF_LIMIT];\n+            this.methodHandles = new Object[MH_LIMIT];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodTypeForm.java","additions":40,"deletions":23,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1083,0 +1083,2 @@\n+        \/\/ The CLASS_NAME prefix must be the same as used by HeapShared::is_string_concat_klass()\n+        \/\/ in the HotSpot code.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -598,1 +599,10 @@\n-    static final int NCPU = Runtime.getRuntime().availableProcessors();\n+    static @Stable int NCPU;\n+\n+    static {\n+        runtimeSetup();\n+    }\n+\n+    \/\/ Called from JVM when loading an AOT cache.\n+    private static void runtimeSetup() {\n+        NCPU = Runtime.getRuntime().availableProcessors();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -60,0 +60,5 @@\n+        runtimeSetup();\n+    }\n+\n+    \/\/ Called from JVM when loading an AOT cache\n+    private static void runtimeSetup() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,18 @@\n+runtime\/modules\/PatchModule\/PatchModuleClassList.java 0000000 generic-all\n+runtime\/NMT\/NMTWithCDS.java                           0000000 generic-all\n+runtime\/symbols\/TestSharedArchiveConfigFile.java      0000000 generic-all\n+\n+gc\/arguments\/TestSerialHeapSizeFlags.java             0000000 generic-all\n+gc\/TestAllocateHeapAtMultiple.java                    0000000 generic-all\n+gc\/TestAllocateHeapAt.java                            0000000 generic-all\n+\n+# use -Xshare\n+serviceability\/sa\/ClhsdbCDSJstackPrintAll.java        0000000 generic-all\n+serviceability\/sa\/ClhsdbCDSCore.java                  0000000 generic-all\n+serviceability\/sa\/CDSJMapClstats.java                 0000000 generic-all\n+compiler\/intrinsics\/klass\/TestIsPrimitive.java        0000000 generic-all\n+\n+# This test is incompatible with AOTClassLinking.\n+# It has the assumption about unresolved Integer.\n+# However when AOTClassLinking is enabled, Integer is always resolved at JVM start-up.\n+compiler\/ciReplay\/TestInliningProtectionDomain.java   0000000 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList-AotJdk.txt","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -79,0 +79,1 @@\n+    vm.cds.supports.aot.class.linking \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+  -runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java \\\n@@ -437,0 +438,1 @@\n+ -runtime\/cds\/appcds\/applications \\\n@@ -453,0 +455,1 @@\n+ -runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java \\\n@@ -457,0 +460,1 @@\n+ -runtime\/cds\/appcds\/CommandLineFlagCombo.java \\\n@@ -524,0 +528,49 @@\n+# Run CDS tests with -XX:+AOTClassLinking. This should include most CDS tests, except for\n+# those that rely on redefining classes that are already archived.\n+hotspot_aot_classlinking = \\\n+  runtime\/cds \\\n+ -runtime\/cds\/appcds\/aotClassLinking \\\n+ -runtime\/cds\/appcds\/BadBSM.java \\\n+ -runtime\/cds\/appcds\/cacheObject\/ArchivedIntegerCacheTest.java \\\n+ -runtime\/cds\/appcds\/cacheObject\/ArchivedModuleCompareTest.java \\\n+ -runtime\/cds\/appcds\/CDSandJFR.java \\\n+ -runtime\/cds\/appcds\/customLoader\/HelloCustom_JFR.java \\\n+ -runtime\/cds\/appcds\/customLoader\/ParallelTestMultiFP.java \\\n+ -runtime\/cds\/appcds\/customLoader\/ParallelTestSingleFP.java \\\n+ -runtime\/cds\/appcds\/customLoader\/SameNameInTwoLoadersTest.java \\\n+ -runtime\/cds\/appcds\/DumpClassListWithLF.java \\\n+ -runtime\/cds\/appcds\/dynamicArchive\/ModulePath.java \\\n+ -runtime\/cds\/appcds\/dynamicArchive\/LambdaInBaseArchive.java \\\n+ -runtime\/cds\/appcds\/dynamicArchive\/LambdasInTwoArchives.java \\\n+ -runtime\/cds\/appcds\/HelloExtTest.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/classpathtests\/EmptyClassInBootClassPath.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/JigsawOptionsCombo.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/AddOpens.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/JvmtiAddPath.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/MainModuleOnly.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndCP.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndCP_JFR.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndFMG.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/modulepath\/OptimizeModuleHandlingTest.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/overridetests\/OverrideTests.java \\\n+ -runtime\/cds\/appcds\/jigsaw\/RedefineClassesInModuleGraph.java \\\n+ -runtime\/cds\/appcds\/JvmtiAddPath.java \\\n+ -runtime\/cds\/appcds\/jvmti \\\n+ -runtime\/cds\/appcds\/LambdaProxyClasslist.java \\\n+ -runtime\/cds\/appcds\/loaderConstraints\/LoaderConstraintsTest.java \\\n+ -runtime\/cds\/appcds\/redefineClass \\\n+ -runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java \\\n+ -runtime\/cds\/appcds\/RewriteBytecodesTest.java \\\n+ -runtime\/cds\/appcds\/SpecifySysLoaderProp.java \\\n+ -runtime\/cds\/appcds\/StaticArchiveWithLambda.java \\\n+ -runtime\/cds\/appcds\/TestEpsilonGCWithCDS.java \\\n+ -runtime\/cds\/appcds\/TestParallelGCWithCDS.java \\\n+ -runtime\/cds\/appcds\/TestSerialGCWithCDS.java \\\n+ -runtime\/cds\/appcds\/TestZGCWithCDS.java \\\n+ -runtime\/cds\/appcds\/TestWithProfiler.java \\\n+ -runtime\/cds\/serviceability\/ReplaceCriticalClassesForSubgraphs.java \\\n+ -runtime\/cds\/serviceability\/ReplaceCriticalClasses.java \\\n+ -runtime\/cds\/serviceability\/transformRelatedClasses\/TransformInterfaceAndImplementor.java \\\n+ -runtime\/cds\/serviceability\/transformRelatedClasses\/TransformSuperAndSubClasses.java \\\n+ -runtime\/cds\/serviceability\/transformRelatedClasses\/TransformSuperSubTwoPckgs.java\n+\n@@ -543,0 +596,4 @@\n+tier1_runtime_no_cds = \\\n+   :tier1_runtime \\\n+   -runtime\/cds\n+\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,1 @@\n+import jtreg.SkippedException;\n@@ -72,0 +73,14 @@\n+    static final boolean skipUncompressedOopsTests;\n+    static boolean checkSkipUncompressedOopsTests(String prop) {\n+        String opts = System.getProperty(prop);\n+        return opts.contains(\"+AOTClassLinking\") &&\n+               opts.matches(\".*[+]Use[A-Za-z]+GC.*\") && !opts.contains(\"+UseG1GC\");\n+    }\n+    static {\n+        \/\/ AOTClassLinking requires the ability to load archived heap objects. However,\n+        \/\/ due to JDK-8341371, only G1GC supports loading archived heap objects\n+        \/\/ with uncompressed oops.\n+        skipUncompressedOopsTests =\n+            checkSkipUncompressedOopsTests(\"test.vm.opts\") ||\n+            checkSkipUncompressedOopsTests(\"test.java.opts\");\n+    }\n@@ -103,0 +118,4 @@\n+        if (provoke && skipUncompressedOopsTests) {\n+            throw new SkippedException(\"Test skipped due to JDK-8341371\");\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/SharedBaseAddress.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary \"AOT\" aliases for traditional CDS command-line options\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build Hello\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar Hello\n+ * @run driver AOTFlags\n+ *\/\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class AOTFlags {\n+    static String appJar = ClassFileInstaller.getJarPath(\"hello.jar\");\n+    static String aotConfigFile = \"hello.aotconfig\";\n+    static String aotCacheFile = \"hello.aot\";\n+    static String helloClass = \"Hello\";\n+\n+    public static void main(String[] args) throws Exception {\n+        positiveTests();\n+        negativeTests();\n+    }\n+\n+    static void positiveTests() throws Exception {\n+        \/\/ (1) Training Run\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=record\",\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-cp\", appJar, helloClass);\n+\n+        OutputAnalyzer out = CDSTestUtils.executeAndLog(pb, \"train\");\n+        out.shouldContain(\"Hello World\");\n+        out.shouldHaveExitValue(0);\n+\n+        \/\/ (2) Assembly Phase\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=create\",\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-XX:AOTCache=\" + aotCacheFile,\n+            \"-Xlog:cds\",\n+            \"-cp\", appJar);\n+        out = CDSTestUtils.executeAndLog(pb, \"asm\");\n+        out.shouldContain(\"Dumping shared data to file:\");\n+        out.shouldMatch(\"cds.*hello[.]aot\");\n+        out.shouldHaveExitValue(0);\n+\n+        \/\/ (3) Production Run with AOTCache\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTCache=\" + aotCacheFile,\n+            \"-Xlog:cds\",\n+            \"-cp\", appJar, helloClass);\n+        out = CDSTestUtils.executeAndLog(pb, \"prod\");\n+        out.shouldContain(\"Opened archive hello.aot.\");\n+        out.shouldContain(\"Hello World\");\n+        out.shouldHaveExitValue(0);\n+\n+        \/\/ (4) AOTMode=off\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTCache=\" + aotCacheFile,\n+            \"--show-version\",\n+            \"-Xlog:cds\",\n+            \"-XX:AOTMode=off\",\n+            \"-cp\", appJar, helloClass);\n+        out = CDSTestUtils.executeAndLog(pb, \"prod\");\n+        out.shouldNotContain(\", sharing\");\n+        out.shouldNotContain(\"Opened archive hello.aot.\");\n+        out.shouldContain(\"Hello World\");\n+        out.shouldHaveExitValue(0);\n+\n+        \/\/ (5) AOTMode=auto\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTCache=\" + aotCacheFile,\n+            \"--show-version\",\n+            \"-Xlog:cds\",\n+            \"-XX:AOTMode=auto\",\n+            \"-cp\", appJar, helloClass);\n+        out = CDSTestUtils.executeAndLog(pb, \"prod\");\n+        out.shouldContain(\", sharing\");\n+        out.shouldContain(\"Opened archive hello.aot.\");\n+        out.shouldContain(\"Hello World\");\n+        out.shouldHaveExitValue(0);\n+\n+        \/\/ (5) AOTMode=on\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTCache=\" + aotCacheFile,\n+            \"--show-version\",\n+            \"-Xlog:cds\",\n+            \"-XX:AOTMode=on\",\n+            \"-cp\", appJar, helloClass);\n+        out = CDSTestUtils.executeAndLog(pb, \"prod\");\n+        out.shouldContain(\", sharing\");\n+        out.shouldContain(\"Opened archive hello.aot.\");\n+        out.shouldContain(\"Hello World\");\n+        out.shouldHaveExitValue(0);\n+    }\n+\n+    static void negativeTests() throws Exception {\n+        \/\/ (1) Mixing old and new options\n+        String mixOldNewErrSuffix = \" cannot be used at the same time with -Xshare:on, -Xshare:auto, \"\n+            + \"-Xshare:off, -Xshare:dump, DumpLoadedClassList, SharedClassListFile, \"\n+            + \"or SharedArchiveFile\";\n+\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-Xshare:off\",\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-cp\", appJar, helloClass);\n+\n+        OutputAnalyzer out = CDSTestUtils.executeAndLog(pb, \"neg\");\n+        out.shouldContain(\"Option AOTConfiguration\" + mixOldNewErrSuffix);\n+        out.shouldNotHaveExitValue(0);\n+\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:SharedArchiveFile=\" + aotCacheFile,\n+            \"-XX:AOTCache=\" + aotCacheFile,\n+            \"-cp\", appJar, helloClass);\n+        out = CDSTestUtils.executeAndLog(pb, \"neg\");\n+        out.shouldContain(\"Option AOTCache\" + mixOldNewErrSuffix);\n+        out.shouldNotHaveExitValue(0);\n+\n+        \/\/ (2) Use AOTConfiguration without AOTMode\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-cp\", appJar, helloClass);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"neg\");\n+        out.shouldContain(\"AOTConfiguration can only be used with -XX:AOTMode=record or -XX:AOTMode=create\");\n+        out.shouldNotHaveExitValue(0);\n+\n+        \/\/ (3) Use AOTMode without AOTConfiguration\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=record\",\n+            \"-cp\", appJar, helloClass);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"neg\");\n+        out.shouldContain(\"-XX:AOTMode=record cannot be used without setting AOTConfiguration\");\n+\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=create\",\n+            \"-cp\", appJar, helloClass);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"neg\");\n+        out.shouldContain(\"-XX:AOTMode=create cannot be used without setting AOTConfiguration\");\n+        out.shouldNotHaveExitValue(0);\n+\n+        \/\/ (4) Bad AOTMode\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=foo\",\n+            \"-cp\", appJar, helloClass);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"neg\");\n+        out.shouldContain(\"Unrecognized value foo for AOTMode. Must be one of the following: off, record, create, auto, on\");\n+        out.shouldNotHaveExitValue(0);\n+\n+        \/\/ (5) AOTCache specified with -XX:AOTMode=record\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=record\",\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-XX:AOTCache=\" + aotCacheFile,\n+            \"-cp\", appJar, helloClass);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"neg\");\n+        out.shouldContain(\"AOTCache must not be specified when using -XX:AOTMode=record\");\n+        out.shouldNotHaveExitValue(0);\n+\n+        \/\/ (5) AOTCache not specified with -XX:AOTMode=create\n+        pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            \"-XX:AOTMode=create\",\n+            \"-XX:AOTConfiguration=\" + aotConfigFile,\n+            \"-cp\", appJar, helloClass);\n+\n+        out = CDSTestUtils.executeAndLog(pb, \"neg\");\n+        out.shouldContain(\"AOTCache must be specified when using -XX:AOTMode=create\");\n+        out.shouldNotHaveExitValue(0);\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/AOTFlags.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -193,1 +193,1 @@\n-    TestCommon.run(\n+    CDSTestUtils.Result result = TestCommon.run(\n@@ -196,4 +196,11 @@\n-        \"CpAttr6\")\n-      .assertNormalExit(output -> {\n-          output.shouldMatch(\"Archived non-system classes are disabled because the file .*cpattrX.jar exists\");\n-        });\n+        \"CpAttr6\");\n+    if (CDSTestUtils.isAOTClassLinkingEnabled()) {\n+        result.assertAbnormalExit(output -> {\n+                output.shouldMatch(\"CDS archive has aot-linked classes. It cannot be used because the file .*cpattrX.jar exists\");\n+            });\n+\n+    } else {\n+        result.assertNormalExit(output -> {\n+                output.shouldMatch(\"Archived non-system classes are disabled because the file .*cpattrX.jar exists\");\n+            });\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/ClassPathAttr.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,5 @@\n-            output.shouldMatch(\"Skipping.LambdaContainsOldInfApp[$][$]Lambda.*0x.*:.*Old.class.has.been.linked\");\n+            if (CDSTestUtils.isAOTClassLinkingEnabled()) {\n+                output.shouldMatch(\"Cannot aot-resolve Lambda proxy because OldProvider is excluded\");\n+            } else {\n+                output.shouldMatch(\"Skipping.LambdaContainsOldInfApp[$][$]Lambda.*0x.*:.*Old.class.has.been.linked\");\n+            }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaContainsOldInf.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,0 @@\n-              .shouldMatch(\".class.load. LambdaWithOldClassApp[$][$]Lambda.*\/0x.*source:.*shared objects file\")\n@@ -73,0 +72,5 @@\n+        if (!CDSTestUtils.isAOTClassLinkingEnabled()) {\n+            \/\/ With AOTClassLinking, we don't archive any lambda with old classes in the method\n+            \/\/ signatures.\n+            output.shouldMatch(\".class.load. LambdaWithOldClassApp[$][$]Lambda.*\/0x.*source:.*shared objects file\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaWithOldClass.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,5 @@\n+        test(false);\n+        test(true);\n+    }\n+\n+    static void test(boolean aotClassLinking) throws Exception {\n@@ -60,0 +65,3 @@\n+        if (aotClassLinking) {\n+            opts.addPrefix(\"-XX:+AOTClassLinking\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaWithUseImplMethodHandle.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -119,0 +119,1 @@\n+                                     \"|(CDS archive has aot-linked classes but the archived heap objects cannot be loaded)\" +\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestParallelGCWithCDS.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @requires vm.flagless\n+ * @summary Disable CDS when incompatible options related to AOTClassLinking are used\n+ * @library \/test\/jdk\/lib\/testlibrary\n+ *          \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ * @build Hello\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar Hello\n+ * @run driver AOTClassLinkingVMOptions\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class AOTClassLinkingVMOptions {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+\n+    static int testCaseNum = 0;\n+    static void testCase(String s) {\n+        testCaseNum++;\n+        System.out.println(\"Test case \" + testCaseNum + \": \" + s);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        TestCommon.testDump(appJar, TestCommon.list(\"Hello\"),\n+                            \"-XX:+AOTClassLinking\");\n+\n+        testCase(\"Archived full module graph must be enabled at runtime\");\n+        TestCommon.run(\"-cp\", appJar, \"-Djdk.module.validation=1\", \"Hello\")\n+            .assertAbnormalExit(\"CDS archive has aot-linked classes.\" +\n+                                \" It cannot be used when archived full module graph is not used\");\n+\n+        testCase(\"Cannot use -Djava.system.class.loader\");\n+        TestCommon.run(\"-cp\", appJar, \"-Djava.system.class.loader=dummy\", \"Hello\")\n+            .assertAbnormalExit(\"CDS archive has aot-linked classes.\" +\n+                                \" It cannot be used when the java.system.class.loader property is specified.\");\n+\n+        testCase(\"Cannot use a different main module\");\n+        TestCommon.run(\"-cp\", appJar, \"-Xlog:cds\", \"-m\", \"jdk.compiler\/com.sun.tools.javac.Main\")\n+            .assertAbnormalExit(\"CDS archive has aot-linked classes.\" +\n+                                \" It cannot be used when archived full module graph is not used.\");\n+        testCase(\"Cannot use security manager\");\n+        TestCommon.run(\"-cp\", appJar, \"-Xlog:cds\", \"-Djava.security.manager=allow\")\n+            .assertAbnormalExit(\"CDS archive has aot-linked classes.\" +\n+                                \" It cannot be used with -Djava.security.manager=allow.\");\n+        TestCommon.run(\"-cp\", appJar, \"-Xlog:cds\", \"-Djava.security.manager=default\")\n+            .assertAbnormalExit(\"CDS archive has aot-linked classes.\" +\n+                                \" It cannot be used with -Djava.security.manager=default.\");\n+\n+        \/\/ NOTE: tests for ClassFileLoadHook + AOTClassLinking is in\n+        \/\/ ..\/jvmti\/ClassFileLoadHookTest.java\n+\n+        boolean dynamicMode = Boolean.getBoolean(\"test.dynamic.cds.archive\");\n+        if (!dynamicMode) {\n+            \/\/ These tests need to dump the full module graph, which is not possible with\n+            \/\/ dynamic dump.\n+            modulePathTests();\n+        }\n+    }\n+\n+    static void modulePathTests() throws Exception {\n+        CDSModulePathUtils.init();\n+\n+        testCase(\"Cannot use mis-matched module path\");\n+        String goodModulePath = CDSModulePathUtils.getModulesDir().toString();\n+        TestCommon.testDump(null, CDSModulePathUtils.getAppClasses(),\n+                            \"--module-path\", goodModulePath,\n+                            \"-XX:+AOTClassLinking\",\n+                            \"-m\", CDSModulePathUtils.MAIN_MODULE);\n+        TestCommon.run(\"-Xlog:cds\",\n+                       \"--module-path\", goodModulePath,\n+                       \"-m\", CDSModulePathUtils.MAIN_MODULE)\n+            .assertNormalExit(\"Using AOT-linked classes: true\");\n+\n+        TestCommon.run(\"-Xlog:cds\",\n+                       \"--module-path\", goodModulePath + \"\/bad\",\n+                       \"-m\", CDSModulePathUtils.MAIN_MODULE)\n+            .assertAbnormalExit(\"CDS archive has aot-linked classes. It cannot be used when archived full module graph is not used.\");\n+    }\n+}\n+\n+\/\/ TODO: enhance and move this class to jdk.test.lib.cds.CDSModulePathUtils\n+\n+class CDSModulePathUtils {\n+    private static String TEST_SRC = System.getProperty(\"test.root\");\n+    private static Path USER_DIR = Paths.get(CDSTestUtils.getOutputDir());\n+    private static Path SRC_DIR = Paths.get(TEST_SRC, \"runtime\/cds\/appcds\/jigsaw\/modulepath\/src\");\n+    private static Path MODS_DIR = Paths.get(\"mods\");\n+\n+    public static String MAIN_MODULE = \"com.bars\";\n+    public static String TEST_MODULE = \"com.foos\";\n+\n+    private static String MAIN_CLASS = \"com.bars.Main\";\n+    private static String TEST_CLASS = \"com.foos.Test\";\n+    private static String appClasses[] = {MAIN_CLASS, TEST_CLASS};\n+\n+    private static Path modulesDir;\n+\n+    \/\/ This directory contains all the modular jar files\n+    \/\/     $USER_DIR\/modules\/com.bars.jar\n+    \/\/     $USER_DIR\/modules\/com.foos.jar\n+    static Path getModulesDir() {\n+        return modulesDir;\n+    }\n+\n+    static String[] getAppClasses() {\n+        return appClasses;\n+    }\n+\n+    static void init() throws Exception  {\n+        JarBuilder.compileModule(SRC_DIR.resolve(TEST_MODULE),\n+                                 MODS_DIR.resolve(TEST_MODULE),\n+                                 null);\n+        JarBuilder.compileModule(SRC_DIR.resolve(MAIN_MODULE),\n+                                 MODS_DIR.resolve(MAIN_MODULE),\n+                                 MODS_DIR.toString());\n+\n+        String PATH_LIBS = \"modules\";\n+        modulesDir = Files.createTempDirectory(USER_DIR, PATH_LIBS);\n+        Path mainJar = modulesDir.resolve(MAIN_MODULE + \".jar\");\n+        Path testJar = modulesDir.resolve(TEST_MODULE + \".jar\");\n+\n+        \/\/ modylibs contains both modules com.foos.jar, com.bars.jar\n+        \/\/ build com.foos.jar\n+        String classes = MODS_DIR.resolve(TEST_MODULE).toString();\n+        JarBuilder.createModularJar(testJar.toString(), classes, TEST_CLASS);\n+\n+        \/\/ build com.bars.jar\n+        classes = MODS_DIR.resolve(MAIN_MODULE).toString();\n+        JarBuilder.createModularJar(mainJar.toString(), classes, MAIN_CLASS);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/AOTClassLinkingVMOptions.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ AOT-linked classes are loaded during VM bootstrap by the C++ class AOTLinkedClassBulkLoader.\n+\/\/ Make sure that the Module, Package, CodeSource and ProtectionDomain of these classes are\n+\/\/ set up properly.\n+\n+\/*\n+ * @test id=static\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build InitiatingLoaderTester\n+ * @build BulkLoaderTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar BulkLoaderTestApp.jar BulkLoaderTestApp MyUtil InitiatingLoaderTester\n+ * @run driver BulkLoaderTest STATIC\n+ *\/\n+\n+\/*\n+ * @test id=dynamic\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/jdk\/lib\/testlibrary \/test\/lib\n+ * @build InitiatingLoaderTester\n+ * @build BulkLoaderTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar BulkLoaderTestApp.jar BulkLoaderTestApp MyUtil InitiatingLoaderTester\n+ * @run driver BulkLoaderTest DYNAMIC\n+ *\/\n+\n+import java.io.File;\n+import java.lang.StackWalker.StackFrame;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.Set;\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class BulkLoaderTest {\n+    static final String appJar = ClassFileInstaller.getJarPath(\"BulkLoaderTestApp.jar\");\n+    static final String mainClass = \"BulkLoaderTestApp\";\n+\n+    public static void main(String[] args) throws Exception {\n+        Tester t = new Tester();\n+\n+        \/\/ Run with archived FMG loaded\n+        t.run(args);\n+\n+        \/\/ Run with an extra classpath -- archived FMG can still load.\n+        {\n+            String extraVmArgs[] = {\n+                \"-cp\",\n+                appJar + File.pathSeparator + \"foobar.jar\"\n+            };\n+            OutputAnalyzer out = t.productionRun(extraVmArgs);\n+            out.shouldHaveExitValue(0);\n+        }\n+\n+        \/\/ Run without archived FMG -- fail to load\n+        {\n+            String extraVmArgs[] = {\n+                \"-Xshare:on\",\n+                \"-Xlog:cds\",\n+                \"-Djdk.module.showModuleResolution=true\"\n+            };\n+            t.setCheckExitValue(false);\n+            OutputAnalyzer out = t.productionRun(extraVmArgs);\n+            out.shouldHaveExitValue(1);\n+            out.shouldContain(\"CDS archive has aot-linked classes. It cannot be used when archived full module graph is not used.\");\n+            t.setCheckExitValue(true);\n+        }\n+    }\n+\n+    static class Tester extends CDSAppTester {\n+        public Tester() {\n+            super(mainClass);\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] vmArgs(RunMode runMode) {\n+            return new String[] {\n+                \"-Xlog:cds,cds+aot+load\",\n+                \"-XX:+AOTClassLinking\",\n+            };\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+            };\n+        }\n+    }\n+}\n+\n+class BulkLoaderTestApp {\n+    static String allPerms = \"null.*<no principals>.*java.security.Permissions.*,*java.security.AllPermission.*<all permissions>.*<all actions>\";\n+\n+    public static void main(String args[]) throws Exception {\n+        checkClasses();\n+        checkInitiatingLoader();\n+    }\n+\n+    \/\/ Check the ClassLoader\/Module\/Package\/ProtectionDomain\/CodeSource of classes that are aot-linked\n+    static void checkClasses() throws Exception {\n+        check(String.class,\n+              \"null\",  \/\/ loader\n+              \"module java.base\",\n+              \"package java.lang\",\n+              \"null\",\n+              allPerms);\n+\n+        check(Class.forName(\"sun.util.logging.internal.LoggingProviderImpl\"),\n+              \"null\",\n+              \"module java.logging\",\n+              \"package sun.util.logging.internal\",\n+              \"null\",\n+              allPerms);\n+\n+\n+        check(javax.tools.FileObject.class,\n+              \"^jdk.internal.loader.ClassLoaders[$]PlatformClassLoader@\",\n+              \"module java.compiler\",\n+              \"package javax.tools\",\n+              \"jrt:\/java.compiler <no signer certificates>\",\n+              \"jdk.internal.loader.ClassLoaders[$]PlatformClassLoader.*<no principals>.*java.security.Permissions.*\"\n+              + \"java.lang.RuntimePermission.*accessSystemModules\");\n+\n+        check(BulkLoaderTestApp.class,\n+              \"jdk.internal.loader.ClassLoaders[$]AppClassLoader@\",\n+              \"^unnamed module @\",\n+              \"package \",\n+              \"file:.*BulkLoaderTestApp.jar <no signer certificates>\",\n+              \"jdk.internal.loader.ClassLoaders[$]AppClassLoader.*<no principals>.*java.security.Permissions.*\"\n+              + \"java.io.FilePermission.*BulkLoaderTestApp.jar.*read\");\n+\n+        check(Class.forName(\"com.sun.tools.javac.Main\"),\n+              \"jdk.internal.loader.ClassLoaders[$]AppClassLoader@\",\n+              \"module jdk.compiler\",\n+              \"package com.sun.tools.javac\",\n+              \"jrt:\/jdk.compiler <no signer certificates>\",\n+              \"jdk.internal.loader.ClassLoaders[$]AppClassLoader.*<no principals>.*java.security.Permissions.*\"\n+              + \"java.lang.RuntimePermission.*accessSystemModules\");\n+\n+        doit(() -> {\n+            Class<?> lambdaClass = MyUtil.getCallerClass(1);\n+            check(lambdaClass,\n+              \"jdk.internal.loader.ClassLoaders[$]AppClassLoader@\",\n+              \"unnamed module\",\n+              \"package \",\n+              \"file:.*BulkLoaderTestApp.jar <no signer certificates>\",\n+              \"jdk.internal.loader.ClassLoaders[$]AppClassLoader.*<no principals>.*java.security.Permissions.*\"\n+              + \"java.io.FilePermission.*BulkLoaderTestApp.jar.*read\");\n+\n+          });\n+    }\n+\n+    static void check(Class c, String loader, String module, String pkg, String codeSource, String protectionDomain) {\n+        System.out.println(\"====================================================================\");\n+        System.out.println(c.getName() + \", loader  = \" + c.getClassLoader());\n+        System.out.println(c.getName() + \", module  = \" + c.getModule());\n+        System.out.println(c.getName() + \", package = \" + c.getPackage());\n+        System.out.println(c.getName() + \", CS      = \" + c.getProtectionDomain().getCodeSource());\n+        System.out.println(c.getName() + \", PD      = \" + c.getProtectionDomain());\n+\n+        expectMatch(\"\" + c.getClassLoader(), loader);\n+        expectMatch(\"\" + c.getModule(), module);\n+        expectSame(\"\" + c.getPackage(), pkg);\n+        expectMatch(\"\" + c.getProtectionDomain().getCodeSource(), codeSource);\n+        expectMatch(\"\" + c.getProtectionDomain(), protectionDomain);\n+    }\n+\n+    static void expectSame(String a, String b) {\n+        if (!a.equals(b)) {\n+            throw new RuntimeException(\"Expected \\\"\" + b + \"\\\" but got \\\"\" + a + \"\\\"\");\n+        }\n+    }\n+    static void expectMatch(String string, String pattern) {\n+        Matcher matcher = Pattern.compile(pattern, Pattern.DOTALL).matcher(string);\n+        if (!matcher.find()) {\n+            throw new RuntimeException(\"Expected pattern \\\"\" + pattern + \"\\\" but got \\\"\" + string + \"\\\"\");\n+        }\n+    }\n+\n+    static void doit(Runnable t) {\n+        t.run();\n+    }\n+\n+    static void checkInitiatingLoader() throws Exception {\n+        try {\n+            InitiatingLoaderTester.tryAccess();\n+        } catch (IllegalAccessError t) {\n+            if (t.getMessage().contains(\"cannot access class jdk.internal.misc.Unsafe (in module java.base)\")) {\n+                System.out.println(\"Expected exception:\");\n+                t.printStackTrace(System.out);\n+                \/\/ Class.forName() should still work. We just can't resolve it in CP entries.\n+                Class<?> c = Class.forName(\"jdk.internal.misc.Unsafe\");\n+                System.out.println(\"App loader can still resolve by name: \" + c);\n+                return;\n+            }\n+            throw new RuntimeException(\"Unexpected exception\", t);\n+        }\n+\n+        throw new RuntimeException(\"Should not have succeeded\");\n+    }\n+}\n+\n+class MyUtil {\n+    \/\/ depth is 0-based -- i.e., depth==0 returns the class of the immediate caller of getCallerClass\n+    static Class<?> getCallerClass(int depth) {\n+        \/\/ Need to add the frame of the getCallerClass -- so the immediate caller (depth==0) of this method\n+        \/\/ is at stack.get(1) == stack.get(depth+1);\n+        StackWalker walker = StackWalker.getInstance(\n+            Set.of(StackWalker.Option.RETAIN_CLASS_REFERENCE,\n+                   StackWalker.Option.SHOW_HIDDEN_FRAMES));\n+        List<StackFrame> stack = walker.walk(s -> s.limit(depth+2).collect(Collectors.toList()));\n+        return stack.get(depth+1).getDeclaringClass();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/BulkLoaderTest.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+\n+\n+class InitiatingLoaderTester {\n+    public static Object tryAccess() {\n+        return jdk.internal.misc.Unsafe.getUnsafe();\n+    }\n+}\n+\n+\n+\n+*\/\n+\n+\n+super class InitiatingLoaderTester\n+    version 66:0\n+{\n+  Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+  {\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+  }\n+  public static Method tryAccess:\"()Ljava\/lang\/Object;\"\n+    stack 2 locals 0\n+  {\n+        invokestatic    Method jdk\/internal\/misc\/Unsafe.\"getUnsafe\":\"()Ljdk\/internal\/misc\/Unsafe;\";\n+        areturn;\n+  }\n+\n+} \/\/ end Class InitiatingLoaderTester\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/InitiatingLoaderTester.jasm","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * @modules java.base\/sun.invoke.util java.logging\n+ * @modules java.logging\n@@ -38,1 +38,1 @@\n- *             CDSTestClassE CDSTestClassF CDSTestClassG\n+ *             CDSTestClassE CDSTestClassF CDSTestClassG CDSTestClassG$MyEnum CDSTestClassG$Wrapper\n@@ -44,0 +44,1 @@\n+import jdk.test.lib.cds.CDSTestUtils;\n@@ -154,3 +155,4 @@\n-        testCase(\"Use a disallowed class: in unnamed module but not in unname package\");\n-        output = dumpBootAndHello(CDSTestClassE_name);\n-        mustFail(output, \"Class pkg.ClassInPackage not allowed in archive heap\");\n+        if (!CDSTestUtils.isAOTClassLinkingEnabled()) {\n+            testCase(\"Use a disallowed class: in unnamed module but not in unname package\");\n+            output = dumpBootAndHello(CDSTestClassE_name);\n+            mustFail(output, \"Class pkg.ClassInPackage not allowed in archive heap\");\n@@ -158,8 +160,3 @@\n-        testCase(\"Use a disallowed class: not in java.base module\");\n-        output = dumpBootAndHello(CDSTestClassF_name);\n-        mustFail(output, \"Class java.util.logging.Level not allowed in archive heap\");\n-\n-        if (false) { \/\/ JDK-8293187\n-            testCase(\"sun.invoke.util.Wrapper\");\n-            output = dumpBootAndHello(CDSTestClassG_name);\n-            mustSucceed(output);\n+            testCase(\"Use a disallowed class: not in java.base module\");\n+            output = dumpBootAndHello(CDSTestClassF_name);\n+            mustFail(output, \"Class java.util.logging.Level not allowed in archive heap\");\n@@ -167,0 +164,9 @@\n+\n+        testCase(\"Complex enums\");\n+        output = dumpBootAndHello(CDSTestClassG_name, \"-XX:+AOTClassLinking\", \"-Xlog:cds+class=debug\");\n+        mustSucceed(output);\n+\n+        TestCommon.run(\"-Xbootclasspath\/a:\" + bootJar, \"-cp\", appJar, \"-Xlog:cds+heap,cds+init\",\n+                       CDSTestClassG_name)\n+            .assertNormalExit(\"init subgraph \" + CDSTestClassG_name,\n+                              \"Initialized from CDS\");\n@@ -174,6 +180,21 @@\n-        archivedObjects = new Object[5];\n-        archivedObjects[0] = output;\n-        archivedObjects[1] = new CDSTestClassA[0];\n-        archivedObjects[2] = new YY();\n-        archivedObjects[3] = new int[0];\n-        archivedObjects[4] = new int[2][2];\n+        \/\/ The usual convention would be to call this here:\n+        \/\/     CDS.initializeFromArchive(CDSTestClassA.class);\n+        \/\/ However, the CDS class is not exported to the unnamed module by default,\n+        \/\/ and we don't want to use \"--add-exports java.base\/jdk.internal.misc=ALL-UNNAMED\", as\n+        \/\/ that would disable the archived full module graph, which will disable\n+        \/\/ CDSConfig::is_using_aot_linked_classes().\n+        \/\/\n+        \/\/ Instead, HeapShared::initialize_test_class_from_archive() will set up the\n+        \/\/ \"archivedObjects\" field first, before calling CDSTestClassA.<clinit>. So\n+        \/\/ if we see that archivedObjects is magically non-null here, that means\n+        \/\/ it has been restored from the CDS archive.\n+        if (archivedObjects == null) {\n+            archivedObjects = new Object[5];\n+            archivedObjects[0] = output;\n+            archivedObjects[1] = new CDSTestClassA[0];\n+            archivedObjects[2] = new YY();\n+            archivedObjects[3] = new int[0];\n+            archivedObjects[4] = new int[2][2];\n+        } else {\n+            System.out.println(\"Initialized from CDS\");\n+        }\n@@ -272,3 +293,138 @@\n-        \/\/ Not in java.base\n-        archivedObjects = new Object[1];\n-        archivedObjects[0] = sun.invoke.util.Wrapper.BOOLEAN;\n+        if (archivedObjects == null) {\n+            archivedObjects = new Object[13];\n+            archivedObjects[0] = Wrapper.BOOLEAN;\n+            archivedObjects[1] = Wrapper.INT.zero();\n+            archivedObjects[2] = Wrapper.DOUBLE.zero();\n+            archivedObjects[3] = MyEnum.DUMMY1;\n+\n+            archivedObjects[4] = Boolean.class;\n+            archivedObjects[5] = Byte.class;\n+            archivedObjects[6] = Character.class;\n+            archivedObjects[7] = Short.class;\n+            archivedObjects[8] = Integer.class;\n+            archivedObjects[9] = Long.class;\n+            archivedObjects[10] = Float.class;\n+            archivedObjects[11] = Double.class;\n+            archivedObjects[12] = Void.class;\n+        } else {\n+            System.out.println(\"Initialized from CDS\");\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+        if (archivedObjects[0] != Wrapper.BOOLEAN) {\n+            throw new RuntimeException(\"Huh 0\");\n+        }\n+\n+        if (archivedObjects[1] != Wrapper.INT.zero()) {\n+            throw new RuntimeException(\"Huh 1\");\n+        }\n+\n+        if (archivedObjects[2] != Wrapper.DOUBLE.zero()) {\n+            throw new RuntimeException(\"Huh 2\");\n+        }\n+\n+        if (archivedObjects[3] != MyEnum.DUMMY1) {\n+            throw new RuntimeException(\"Huh 3\");\n+        }\n+\n+        if (MyEnum.BOOLEAN != true) {\n+            throw new RuntimeException(\"Huh 10.1\");\n+        }\n+        if (MyEnum.BYTE != -128) {\n+            throw new RuntimeException(\"Huh 10.2\");\n+        }\n+        if (MyEnum.CHAR != 'c') {\n+            throw new RuntimeException(\"Huh 10.3\");\n+        }\n+        if (MyEnum.SHORT != -12345) {\n+            throw new RuntimeException(\"Huh 10.4\");\n+        }\n+        if (MyEnum.INT != -123456) {\n+            throw new RuntimeException(\"Huh 10.5\");\n+        }\n+        if (MyEnum.LONG != 0x1234567890L) {\n+            throw new RuntimeException(\"Huh 10.6\");\n+        }\n+        if (MyEnum.LONG2 != -0x1234567890L) {\n+            throw new RuntimeException(\"Huh 10.7\");\n+        }\n+        if (MyEnum.FLOAT != 567891.0f) {\n+            throw new RuntimeException(\"Huh 10.8\");\n+        }\n+        if (MyEnum.DOUBLE != 12345678905678.890) {\n+            throw new RuntimeException(\"Huh 10.9\");\n+        }\n+\n+        checkClass(4, Boolean.class);\n+        checkClass(5, Byte.class);\n+        checkClass(6, Character.class);\n+        checkClass(7, Short.class);\n+        checkClass(8, Integer.class);\n+        checkClass(9, Long.class);\n+        checkClass(10, Float.class);\n+        checkClass(11, Double.class);\n+        checkClass(12, Void.class);\n+\n+        System.out.println(\"Success!\");\n+    }\n+\n+    static void checkClass(int index, Class c) {\n+        if (archivedObjects[index] != c) {\n+            throw new RuntimeException(\"archivedObjects[\" + index + \"] should be \" + c);\n+        }\n+    }\n+\n+    \/\/ Simplified version of sun.invoke.util.Wrapper\n+    public enum Wrapper {\n+        \/\/        wrapperType      simple     primitiveType  simple     char  emptyArray\n+        BOOLEAN(  Boolean.class,   \"Boolean\", boolean.class, \"boolean\", 'Z', new boolean[0]),\n+        INT    (  Integer.class,   \"Integer\",     int.class,     \"int\", 'I', new     int[0]),\n+        DOUBLE (   Double.class,    \"Double\",  double.class,  \"double\", 'D', new  double[0])\n+        ;\n+\n+        public static final int COUNT = 10;\n+        private static final Object DOUBLE_ZERO = (Double)(double)0;\n+\n+        private final Class<?> wrapperType;\n+        private final Class<?> primitiveType;\n+        private final char     basicTypeChar;\n+        private final String   basicTypeString;\n+        private final Object   emptyArray;\n+\n+        Wrapper(Class<?> wtype,\n+                String wtypeName,\n+                Class<?> ptype,\n+                String ptypeName,\n+                char tchar,\n+                Object emptyArray) {\n+            this.wrapperType = wtype;\n+            this.primitiveType = ptype;\n+            this.basicTypeChar = tchar;\n+            this.basicTypeString = String.valueOf(this.basicTypeChar);\n+            this.emptyArray = emptyArray;\n+        }\n+\n+        public Object zero() {\n+            return switch (this) {\n+                case BOOLEAN -> Boolean.FALSE;\n+                case INT -> (Integer)0;\n+                case DOUBLE -> DOUBLE_ZERO;\n+                default -> null;\n+            };\n+        }\n+    }\n+\n+    enum MyEnum {\n+        DUMMY1,\n+        DUMMY2;\n+\n+        static final boolean BOOLEAN = true;\n+        static final byte    BYTE    = -128;\n+        static final short   SHORT   = -12345;\n+        static final char    CHAR    = 'c';\n+        static final int     INT     = -123456;\n+        static final long    LONG    =  0x1234567890L;\n+        static final long    LONG2   = -0x1234567890L;\n+        static final float   FLOAT   = 567891.0f;\n+        static final double  DOUBLE  = 12345678905678.890;\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchiveHeapTestClass.java","additions":179,"deletions":23,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-            .shouldContain(\"unreg OldClass ** unlinked\");\n+            .shouldContain(\"unreg OldClass old unlinked\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/CustomClassListDump.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,0 +99,18 @@\n+\n+        \/\/ JEP 483: if dumped with -XX:+AOTClassLinking, cannot use archive when CFLH is enabled\n+        TestCommon.testDump(appJar, sharedClasses, useWb, \"-XX:+AOTClassLinking\");\n+        out = TestCommon.exec(appJar,\n+                \"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:+WhiteBoxAPI\", useWb,\n+                \"-agentlib:SimpleClassFileLoadHook=LoadMe,beforeHook,after_Hook\",\n+                \"-Xlog:cds\",\n+                \"ClassFileLoadHook\",\n+                \"\" + ClassFileLoadHook.TestCaseId.SHARING_ON_CFLH_ON);\n+        if (out.contains(\"Using AOT-linked classes: false (static archive: no aot-linked classes\")) {\n+            \/\/ JTREG is executed with VM options that do not support -XX:+AOTClassLinking, so\n+            \/\/ the static archive was not created with aot-linked classes.\n+            out.shouldHaveExitValue(0);\n+        } else {\n+            out.shouldContain(\"CDS archive has aot-linked classes. It cannot be used when JVMTI ClassFileLoadHook is in use.\");\n+            out.shouldNotHaveExitValue(0);\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jvmti\/ClassFileLoadHookTest.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,388 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary AOT resolution of lambda expressions\n+ * @bug 8340836\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/\n+ * @build AOTLinkedLambdas\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 AOTLinkedLambdasApp InitTracker\n+ *                 IntfWithNoClinit IntfWithNoClinit2\n+ *                 IA IB IC ID1 ID2 IE1 IE2 IF1 IF2 IG1 IG2 IH1 IH2 IH3\n+ *                 FooA FooB\n+ *                 BarA BarB BarC\n+ * @run driver AOTLinkedLambdas\n+ *\/\n+\n+import java.util.function.Supplier;\n+import static java.util.stream.Collectors.*;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AOTLinkedLambdas {\n+    static final String classList = \"AOTLinkedLambdas.classlist\";\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = AOTLinkedLambdasApp.class.getName();\n+\n+    public static void main(String[] args) throws Exception {\n+        CDSTestUtils.dumpClassList(classList, \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"Hello AOTLinkedLambdasApp\");\n+            });\n+\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-XX:+AOTClassLinking\",\n+                       \"-Xlog:cds+resolve=trace\",\n+                       \"-Xlog:cds+class=debug\",\n+                       \"-cp\", appJar);\n+\n+        OutputAnalyzer dumpOut = CDSTestUtils.createArchiveAndCheck(opts);\n+        dumpOut.shouldContain(\"Can aot-resolve Lambda proxy of interface type IA\");\n+        dumpOut.shouldContain(\"Can aot-resolve Lambda proxy of interface type IB\");\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IC\");\n+        dumpOut.shouldContain(\"Can aot-resolve Lambda proxy of interface type ID2\");\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IE2\"); \/\/ unsupported = IE1\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IF2\");\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IG2\");\n+        dumpOut.shouldContain(\"Cannot aot-resolve Lambda proxy of interface type IH3\"); \/\/ unsupported = IH1\n+\n+        CDSOptions runOpts = (new CDSOptions())\n+            .setUseVersion(false)\n+            .addPrefix(\"-Xlog:cds\",\n+                       \"-esa\",         \/\/ see JDK-8340836\n+                       \"-cp\", appJar)\n+            .addSuffix(mainClass);\n+\n+        CDSTestUtils.run(runOpts)\n+            .assertNormalExit(\"Hello AOTLinkedLambdasApp\",\n+                              \"hello, world\");\n+    }\n+}\n+\n+class AOTLinkedLambdasApp {\n+    static {\n+        System.out.println(\"AOTLinkedLambdasApp.<clinit>\");\n+    }\n+    public static void main(String args[]) {\n+        System.out.println(\"Hello AOTLinkedLambdasApp\");\n+\n+        \/\/ (1) Simple tests\n+        var words = java.util.List.of(\"hello\", \"fuzzy\", \"world\");\n+        System.out.println(words.stream().filter(w->!w.contains(\"u\")).collect(joining(\", \")));\n+        \/\/ => hello, world\n+\n+        \/\/ (2) Test for <clinit> order.\n+        testClinitOrder();\n+    }\n+\n+\n+    \/\/ Check that aot-linking of lambdas does not cause <clinit> to be skipped or\n+    \/\/ otherwise executed in the wrong order.\n+    \/\/\n+    \/\/ A lambda is declared to implement an interface X, but it also implicitly\n+    \/\/ implements all super interfaces of X.\n+    \/\/\n+    \/\/ For any interface IN that's implemented by a lambda, if IN has declared\n+    \/\/ a non-abstract, non-static method (JVMS 5.5. Initialization), IN must be\n+    \/\/ initialized before the lambda can be linked. If IN::<clinit> exists, the\n+    \/\/ initialization of IN can have side effects.\n+    \/\/\n+    \/\/ AOTConstantPoolResolver::is_indy_resolution_deterministic() excludes\n+    \/\/ any lambda if initializing its interfaces can cause side effects. This test\n+    \/\/ checks that such exclusions are working as expected.\n+    \/\/\n+    \/\/ This test also proves that is_indy_resolution_deterministic() doen't need to check\n+    \/\/ for all other types that are mentioned by the lambda call site, as those classes\n+    \/\/ will not be initialized as part of linking the lambda.\n+    static void testClinitOrder() {\n+        \/*\n+         * An indy callsite is associated with the following MethodType and MethodHandles:\n+         *\n+         * https:\/\/github.com\/openjdk\/jdk\/blob\/580eb62dc097efeb51c76b095c1404106859b673\/src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaMetafactory.java#L293-L309\n+         *\n+         * MethodType factoryType         The expected signature of the {@code CallSite}.  The\n+         *                                parameter types represent the types of capture variables;\n+         *                                the return type is the interface to implement.   When\n+         *                                used with {@code invokedynamic}, this is provided by\n+         *                                the {@code NameAndType} of the {@code InvokeDynamic}\n+         *\n+         * MethodType interfaceMethodType Signature and return type of method to be\n+         *                                implemented by the function object.\n+         *\n+         * MethodHandle implementation    A direct method handle describing the implementation\n+         *                                method which should be called (with suitable adaptation\n+         *                                of argument types and return types, and with captured\n+         *                                arguments prepended to the invocation arguments) at\n+         *                                invocation time.\n+         *\n+         * MethodType dynamicMethodType   The signature and return type that should\n+         *                                be enforced dynamically at invocation time.\n+         *                                In simple use cases this is the same as\n+         *                                {@code interfaceMethodType}.\n+         *\/\n+\n+        \/\/ Initial condition: no <clinit> used by our Foo* and Bar* types have been called.\n+        InitTracker.assertOrder(\"InitTracker\");\n+\n+        \/\/==============================\n+        \/\/ Case (i) -- Check for types used by factoryType, interfaceMethodType and dynamicMethodType\n+        \/\/             (Note: no tests for captured variables in factoryType yet; will be tested in case (ii))\n+        \/\/ factoryType         = \"()LIntfWithNoClinit;\n+        \/\/ interfaceMethodType = \"(LFooB;)LFooA;\"\n+        \/\/ implementation      = \"REF_invokeStatic AOTLinkedLambdasApp.implAB:(LBarB;)LBarA;\"\n+        \/\/ dynamicMethodType   = \"(LBarB;)LBarA;\"\n+        IntfWithNoClinit<BarA, BarB> noclinit = AOTLinkedLambdasApp::implAB;\n+\n+        \/\/ None of the Foo? and Bar? types used by the lambda should have been initialized yet, even though\n+        \/\/ the indy callsite has been resolved now.\n+        InitTracker.assertOrder(\"InitTracker\");\n+\n+        BarB barB = new BarB();\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB\");\n+        BarA barA = noclinit.doit(barB);\n+        System.out.println(barB);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA\");\n+\n+        \/\/==============================\n+        \/\/ Case (ii) -- Check for types used by captured variables in factoryType\n+        BarC barC = null;\n+        IntfWithNoClinit2 noclinit2 = () -> { return barC.hashCode(); };\n+        try {\n+            noclinit2.doit();\n+            throw new RuntimeException(\"NullPointerException should have been thrown\");\n+        } catch (NullPointerException npe) {\n+            \/\/ expected\n+        }\n+        \/\/ BarC shouldn't be initialized as no instances of it has been created.\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA\");\n+\n+\n+        \/\/==============================\n+        \/\/ (IA) No default methods -- is not initialized during lambda linking. Lambda can be archived.\n+        IA ia = () -> {};\n+        ia.doit();\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA\");\n+        System.out.println(IA._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA\");\n+\n+        \/\/==============================\n+        \/\/ (IB) Has default method but has not <clinit> -- OK to initialize IB during lambda linking. Lambda can be archived.\n+        IB ib = () -> {};\n+        ib.doit();\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA\");\n+\n+        \/\/==============================\n+        \/\/ (IC) Has both default method and <clinit> -- cannot AOT link the lambda\n+        IC ic = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC\");\n+        ic.doit();\n+\n+        \/\/==============================\n+        \/\/ ID1 - has default method, but no <clinit>\n+        \/\/ ID2 - has <clinit>, but no default method\n+        ID2 id2 = () -> {};\n+        id2.doit();\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC\");\n+        System.out.println(ID2._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2\");\n+\n+       \/\/==============================\n+        \/\/ IE1 - has both default method and <clinit>\n+        \/\/ IE2 - has <clinit>, but no default method\n+        IE2 ie2 = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1\");\n+        System.out.println(IE2._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2\");\n+\n+       \/\/==============================\n+        \/\/ IF1 - has <clinit>, but no default method\n+        \/\/ IF2 - has both default method and <clinit>\n+        IF2 if2 = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2\");\n+        System.out.println(IF1._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1\");\n+\n+       \/\/==============================\n+        \/\/ IG1 - has both default method and <clinit>\n+        \/\/ IG2 - has both default method and <clinit>\n+        IG2 ig2 = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1, IG1, IG2\");\n+\n+       \/\/==============================\n+        \/\/ Similar to IE1\/IE2, but IH3 is one more level away from IH1\n+        \/\/ IH1 - has both default method and <clinit>\n+        \/\/ IH2 - has <clinit>, but no default method\n+        \/\/ IH3 - has <clinit>, but no default method\n+        IH3 ih3 = () -> {};\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1, IG1, IG2, IH1\");\n+        System.out.println(IH3._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1, IG1, IG2, IH1, IH3\");\n+        System.out.println(IH2._dummy);\n+        InitTracker.assertOrder(\"InitTracker, FooB, BarB, FooA, BarA, IA, IC, ID2, IE1, IE2, IF2, IF1, IG1, IG2, IH1, IH3, IH2\");\n+    }\n+\n+    static BarA implAB(BarB param) {\n+        return new BarA(param);\n+    }\n+}\n+\n+\n+\/\/ An interface with no <clinit> method. A lambda implementing this\n+\/\/ interface can be AOT-linked.\n+@FunctionalInterface\n+interface IntfWithNoClinit<X extends FooA, Y extends FooB> {\n+    X doit(Y param);\n+}\n+\n+\/\/ Another interface with no <clinit> method. A lambda implementing this\n+\/\/ interface can be AOT-linked.\n+@FunctionalInterface\n+interface IntfWithNoClinit2 {\n+    int doit();\n+}\n+\n+\n+\/\/ (IA) No default methods -- is not initialized during lambda linking. Lambda can be archived.\n+@FunctionalInterface interface IA {\n+    static int _dummy = InitTracker.trackEvent(\"IA\");\n+    void doit();\n+}\n+\n+\/\/ (IB) Has default method but has not <clinit> -- OK to initialize IB during lambda linking. Lambda can be archived.\n+@FunctionalInterface interface IB {\n+    default int dummy() { return 0; }\n+    void doit();\n+}\n+\n+\/\/ (IC) Has both default method and <clinit> -- cannot AOT link the lambda\n+@FunctionalInterface interface IC {\n+    static int _dummy = InitTracker.trackEvent(\"IC\");\n+    default int dummy() { return _dummy; }\n+    void doit();\n+}\n+\n+\/\/ (ID1\/ID2)\n+@FunctionalInterface interface ID1 { \/\/ has default method, but no <clinit>\n+    default int dummy() { return 0; }\n+    void doit();\n+}\n+\n+@FunctionalInterface interface ID2 extends ID1 { \/\/ has <clinit>, but no default method\n+    static int _dummy = InitTracker.trackEvent(\"ID2\");\n+}\n+\n+\/\/ (IE1\/IE2)\n+@FunctionalInterface interface IE1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IE1\");\n+    default int dummy() { return _dummy; }\n+    void doit();\n+}\n+\n+@FunctionalInterface interface IE2 extends IE1 { \/\/ has <clinit>, but no default method\n+    static int _dummy = InitTracker.trackEvent(\"IE2\");\n+}\n+\n+\/\/ (IF1\/IF2)\n+@FunctionalInterface interface IF1 { \/\/ has <clinit>, but no default method\n+    static int _dummy = InitTracker.trackEvent(\"IF1\");\n+    void doit();\n+}\n+\n+@FunctionalInterface interface IF2 extends IF1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IF2\");\n+    default int dummy() { return 0; }\n+}\n+\n+\/\/ (IG1\/IG2)\n+@FunctionalInterface interface IG1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IG1\");\n+    default int dummy() { return _dummy; }\n+    void doit();\n+}\n+\n+@FunctionalInterface interface IG2 extends IG1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IG2\");\n+    default int dummy() { return _dummy; }\n+}\n+\n+\/\/ (IH1\/IH2\/IH3)\n+@FunctionalInterface interface IH1 { \/\/ has default method and <clinit>\n+    static int _dummy = InitTracker.trackEvent(\"IH1\");\n+    default int dummy() { return _dummy; }\n+    void doit();\n+}\n+\n+@FunctionalInterface interface IH2 extends IH1 { \/\/ has <clinit> but no default method\n+    static int _dummy = InitTracker.trackEvent(\"IH2\");\n+}\n+\n+@FunctionalInterface interface IH3 extends IH2 { \/\/ has <clinit> but no default method\n+    static int _dummy = InitTracker.trackEvent(\"IH3\");\n+}\n+\n+\n+class InitTracker {\n+    static String actualOrder = \"InitTracker\";\n+    static int trackEvent(String event) {\n+        actualOrder += \", \" + event;\n+        return actualOrder.lastIndexOf(',');\n+    }\n+    static void assertOrder(String wantOrder) {\n+        System.out.println(\"wantOrder   = \" + wantOrder);\n+        System.out.println(\"actualOrder = \" + actualOrder);\n+        if (!actualOrder.equals(wantOrder)) {\n+            throw new RuntimeException(\"Want <clinit> order: {\" + wantOrder + \"}, but got {\" + actualOrder + \"}\");\n+        }\n+    }\n+}\n+\n+interface FooA {\n+    static final int _dummy = InitTracker.trackEvent(\"FooA\");\n+    default int dummy() { return _dummy; }\n+}\n+\n+interface FooB {\n+    static final int _dummy = InitTracker.trackEvent(\"FooB\");\n+    default int dummy() { return _dummy; }\n+}\n+\n+class BarA implements FooA {\n+    static {InitTracker.trackEvent(\"BarA\");}\n+    BarA(BarB dummy) {}\n+}\n+\n+class BarB implements FooB {\n+    static {InitTracker.trackEvent(\"BarB\");}\n+}\n+\n+class BarC {\n+    static {InitTracker.trackEvent(\"BarC\");}\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/AOTLinkedLambdas.java","additions":388,"deletions":0,"binary":false,"changes":388,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Dump time resolutiom of constant pool entries.\n+ * @summary Dump time resolution of constant pool entries.\n@@ -29,0 +29,1 @@\n+ * @requires vm.cds.supports.aot.class.linking\n@@ -30,1 +31,2 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/\n+ * @build OldProvider OldClass OldConsumer StringConcatTestOld\n@@ -32,1 +34,5 @@\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar ResolvedConstantsApp ResolvedConstantsFoo ResolvedConstantsBar\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 ResolvedConstantsApp ResolvedConstantsFoo ResolvedConstantsBar\n+ *                 MyInterface InterfaceWithClinit NormalClass\n+ *                 OldProvider OldClass OldConsumer SubOfOldClass\n+ *                 StringConcatTest StringConcatTestOld\n@@ -36,0 +42,1 @@\n+import java.util.function.Consumer;\n@@ -39,0 +46,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -45,0 +53,1 @@\n+    static boolean aotClassLinking;\n@@ -46,1 +55,6 @@\n-        \/\/ dump class list\n+        test(false);\n+        test(true);\n+    }\n+\n+    static void test(boolean testMode) throws Exception {\n+        aotClassLinking = testMode;\n@@ -55,2 +69,9 @@\n-                       \"-Xlog:cds+resolve=trace\");\n-        CDSTestUtils.createArchiveAndCheck(opts)\n+                       \"-Xlog:cds+resolve=trace\",\n+                       \"-Xlog:cds+class=debug\");\n+        if (aotClassLinking) {\n+            opts.addPrefix(\"-XX:+AOTClassLinking\");\n+        } else {\n+            opts.addPrefix(\"-XX:-AOTClassLinking\");\n+        }\n+\n+        OutputAnalyzer out = CDSTestUtils.createArchiveAndCheck(opts);\n@@ -60,1 +81,1 @@\n-            .shouldMatch(\"cds,resolve.*archived klass.* ResolvedConstantsApp app => ResolvedConstantsApp app\")\n+        out.shouldMatch(ALWAYS(\"klass.* ResolvedConstantsApp app => ResolvedConstantsApp app\"))\n@@ -63,2 +84,2 @@\n-            .shouldMatch(\"cds,resolve.*archived klass.* ResolvedConstantsApp app => java\/lang\/Object boot\")\n-            .shouldMatch(\"cds,resolve.*archived klass.* ResolvedConstantsBar app => ResolvedConstantsFoo app\")\n+            .shouldMatch(ALWAYS(\"klass.* ResolvedConstantsApp app => java\/lang\/Object boot\"))\n+            .shouldMatch(ALWAYS(\"klass.* ResolvedConstantsBar app => ResolvedConstantsFoo app\"))\n@@ -67,1 +88,1 @@\n-            .shouldMatch(\"cds,resolve.*archived klass.* ResolvedConstantsApp app => java\/lang\/Runnable boot\")\n+            .shouldMatch(ALWAYS(\"klass.* ResolvedConstantsApp app => java\/lang\/Runnable boot\"))\n@@ -69,5 +90,6 @@\n-            \/\/ java\/lang\/System is in the root loader but ResolvedConstantsApp is loaded by the app loader.\n-            \/\/ Even though System is in the vmClasses list, when ResolvedConstantsApp looks up\n-            \/\/ \"java\/lang\/System\" in its ConstantPool, the app loader may not have resolved the System\n-            \/\/ class yet (i.e., there's no initiaited class entry for System in the app loader's dictionary)\n-            .shouldMatch(\"cds,resolve.*reverted klass.* ResolvedConstantsApp .*java\/lang\/System\")\n+            \/\/ Without -XX:+AOTClassLinking:\n+            \/\/   java\/lang\/System is in the boot loader but ResolvedConstantsApp is loaded by the app loader.\n+            \/\/   Even though System is in the vmClasses list, when ResolvedConstantsApp looks up\n+            \/\/   \"java\/lang\/System\" in its ConstantPool, the app loader may not have resolved the System\n+            \/\/   class yet (i.e., there's no initiaited class entry for System in the app loader's dictionary)\n+            .shouldMatch(AOTLINK_ONLY(\"klass.* ResolvedConstantsApp .*java\/lang\/System\"))\n@@ -78,3 +100,4 @@\n-            .shouldMatch(\"cds,resolve.*archived field.* ResolvedConstantsBar => ResolvedConstantsBar.b:I\")\n-            .shouldMatch(\"cds,resolve.*archived field.* ResolvedConstantsBar => ResolvedConstantsBar.a:I\")\n-            .shouldMatch(\"cds,resolve.*archived field.* ResolvedConstantsBar => ResolvedConstantsFoo.a:I\")\n+            .shouldMatch(ALWAYS(\"field.* ResolvedConstantsBar => ResolvedConstantsBar.b:I\"))\n+            .shouldMatch(ALWAYS(\"field.* ResolvedConstantsBar => ResolvedConstantsBar.a:I\"))\n+            .shouldMatch(ALWAYS(\"field.* ResolvedConstantsBar => ResolvedConstantsFoo.a:I\"))\n+            .shouldMatch(ALWAYS(\"field.* ResolvedConstantsFoo => ResolvedConstantsFoo.a:I\"))\n@@ -82,4 +105,3 @@\n-            \/\/ Do not resolve field references to child classes\n-            .shouldMatch(\"cds,resolve.*archived field.* ResolvedConstantsFoo => ResolvedConstantsFoo.a:I\")\n-            .shouldMatch(\"cds,resolve.*reverted field.* ResolvedConstantsFoo    ResolvedConstantsBar.a:I\")\n-            .shouldMatch(\"cds,resolve.*reverted field.* ResolvedConstantsFoo    ResolvedConstantsBar.b:I\")\n+            \/\/ Resolve field references to child classes ONLY when using -XX:+AOTClassLinking\n+            .shouldMatch(AOTLINK_ONLY(\"field.* ResolvedConstantsFoo => ResolvedConstantsBar.a:I\"))\n+            .shouldMatch(AOTLINK_ONLY(\"field.* ResolvedConstantsFoo => ResolvedConstantsBar.b:I\"))\n@@ -87,3 +109,3 @@\n-            \/\/ Do not resolve field references to unrelated classes\n-            .shouldMatch(\"cds,resolve.*reverted field.* ResolvedConstantsApp    ResolvedConstantsBar.a:I\")\n-            .shouldMatch(\"cds,resolve.*reverted field.* ResolvedConstantsApp    ResolvedConstantsBar.b:I\")\n+            \/\/ Resolve field references to unrelated classes ONLY when using -XX:+AOTClassLinking\n+            .shouldMatch(AOTLINK_ONLY(\"field.* ResolvedConstantsApp => ResolvedConstantsBar.a:I\"))\n+            .shouldMatch(AOTLINK_ONLY(\"field.* ResolvedConstantsApp => ResolvedConstantsBar.b:I\"))\n@@ -94,1 +116,1 @@\n-            .shouldMatch(\"cds,resolve.*archived method .* ResolvedConstantsApp ResolvedConstantsApp.<init>:\")\n+            .shouldMatch(ALWAYS(\"method.* ResolvedConstantsApp ResolvedConstantsApp.<init>:\"))\n@@ -96,1 +118,1 @@\n-            .shouldMatch(\"cds,resolve.*archived method .* ResolvedConstantsApp java\/lang\/Object.<init>:\")\n+            .shouldMatch(ALWAYS(\"method.* ResolvedConstantsApp java\/lang\/Object.<init>:\"))\n@@ -99,1 +121,1 @@\n-            .shouldMatch(\"cds,resolve.*archived interface method .* ResolvedConstantsApp java\/lang\/Runnable.run:\")\n+            .shouldMatch(ALWAYS(\"interface method .* ResolvedConstantsApp java\/lang\/Runnable.run:\"))\n@@ -102,3 +124,3 @@\n-            .shouldMatch(\"archived method.*: ResolvedConstantsBar ResolvedConstantsBar.doBar:\")\n-            .shouldMatch(\"archived method.*: ResolvedConstantsApp ResolvedConstantsApp.privateInstanceCall:\")\n-            .shouldMatch(\"archived method.*: ResolvedConstantsApp ResolvedConstantsApp.publicInstanceCall:\")\n+            .shouldMatch(ALWAYS(\"method.*: ResolvedConstantsBar ResolvedConstantsBar.doBar:\"))\n+            .shouldMatch(ALWAYS(\"method.*: ResolvedConstantsApp ResolvedConstantsApp.privateInstanceCall:\"))\n+            .shouldMatch(ALWAYS(\"method.*: ResolvedConstantsApp ResolvedConstantsApp.publicInstanceCall:\"))\n@@ -107,1 +129,1 @@\n-            .shouldNotMatch(\" archived method CP entry.*: ResolvedConstantsApp ResolvedConstantsApp.staticCall:\")\n+            .shouldNotMatch(ALWAYS(\"method.*: ResolvedConstantsApp ResolvedConstantsApp.staticCall:\"))\n@@ -110,1 +132,1 @@\n-            .shouldMatch(\" archived method CP entry.*: ResolvedConstantsBar ResolvedConstantsFoo.doBar:\")\n+            .shouldMatch(ALWAYS(\"method.*: ResolvedConstantsBar ResolvedConstantsFoo.doBar:\"))\n@@ -112,1 +134,1 @@\n-            \/\/ App class cannot resolve references to methods in boot classes:\n+            \/\/ Without -XX:+AOTClassLinking App class cannot resolve references to methods in boot classes:\n@@ -117,4 +139,2 @@\n-            \/\/\n-            \/\/    This will be addressed in JDK-8315737.\n-            .shouldMatch(\"reverted method.*: ResolvedConstantsApp java\/io\/PrintStream.println:\")\n-            .shouldMatch(\"reverted method.*: ResolvedConstantsBar java\/lang\/Class.getName:\")\n+            .shouldMatch(AOTLINK_ONLY(\"method.*: ResolvedConstantsApp java\/io\/PrintStream.println:\"))\n+            .shouldMatch(AOTLINK_ONLY(\"method.*: ResolvedConstantsBar java\/lang\/Class.getName:\"))\n@@ -122,2 +142,2 @@\n-            \/\/ Should not resolve methods in unrelated classes.\n-            .shouldMatch(\"reverted method.*: ResolvedConstantsApp ResolvedConstantsBar.doit:\")\n+            \/\/ Resole resolve methods in unrelated classes ONLY when using -XX:+AOTClassLinking\n+            .shouldMatch(AOTLINK_ONLY(\"method.*: ResolvedConstantsApp ResolvedConstantsBar.doit:\"))\n@@ -127,0 +147,25 @@\n+\n+\n+        \/\/ Indy References ---\n+        if (aotClassLinking) {\n+            out.shouldContain(\"Cannot aot-resolve Lambda proxy because OldConsumer is excluded\")\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldProvider is excluded\")\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy because OldClass is excluded\")\n+               .shouldContain(\"Cannot aot-resolve Lambda proxy of interface type InterfaceWithClinit\")\n+               .shouldMatch(\"klasses.* app *NormalClass[$][$]Lambda\/.* hidden aot-linked inited\")\n+               .shouldNotMatch(\"klasses.* app *SubOfOldClass[$][$]Lambda\/\")\n+               .shouldMatch(\"archived indy *CP entry.*StringConcatTest .* => java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants\")\n+               .shouldNotMatch(\"archived indy *CP entry.*StringConcatTestOld .* => java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants\");\n+        }\n+    }\n+\n+    static String ALWAYS(String s) {\n+        return \"cds,resolve.*archived \" + s;\n+    }\n+\n+    static String AOTLINK_ONLY(String s) {\n+        if (aotClassLinking) {\n+            return ALWAYS(s);\n+        } else {\n+            return \"cds,resolve.*reverted \" + s;\n+        }\n@@ -145,0 +190,4 @@\n+\n+        testLambda();\n+        StringConcatTest.test();\n+        StringConcatTestOld.main(null);\n@@ -151,0 +200,82 @@\n+\n+    static void testLambda() {\n+        \/\/ The functional type used in the Lambda is an excluded class\n+        OldProvider op = () -> {\n+            return null;\n+        };\n+\n+        \/\/ A captured value is an instance of an excluded Class\n+        OldClass c = new OldClass();\n+        Runnable r = () -> {\n+            System.out.println(\"Test 1 \" + c);\n+        };\n+        r.run();\n+\n+        \/\/ The functional interface accepts an argument that's an excluded class\n+        MyInterface i = (o) -> {\n+            System.out.println(\"Test 2 \" + o);\n+        };\n+        i.dispatch(c);\n+\n+        \/\/ Method reference to old class\n+        OldConsumer oldConsumer = new OldConsumer();\n+        Consumer<String> wrapper = oldConsumer::consumeString;\n+        wrapper.accept(\"Hello\");\n+\n+        \/\/ Lambda of interfaces that have <clinit> are not archived.\n+        InterfaceWithClinit i2 = () -> {\n+            System.out.println(\"Test 3\");\n+        };\n+        i2.dispatch();\n+\n+        \/\/ These two classes have almost identical source code, but\n+        \/\/ only NormalClass should have its lambdas pre-resolved.\n+        \/\/ SubOfOldClass is \"old\" -- it should be excluded from the AOT cache,\n+        \/\/ so none of its lambda proxies should be cached\n+        NormalClass.testLambda();   \/\/ Lambda proxy should be cached\n+        SubOfOldClass.testLambda(); \/\/ Lambda proxy shouldn't be cached\n+    }\n+}\n+\n+class StringConcatTest {\n+    static void test() {\n+        System.out.println(\"StringConcatTest <concat> \" + new StringConcatTest()); \/\/ concat should be aot-resolved\n+    }\n+}\n+\n+\/* see StringConcatTestOld.jasm\n+\n+class StringConcatTestOld {\n+    public static void main(String args[]) {\n+        \/\/ concat should be aot-resolved => the MethodType refers to an old class\n+        System.out.println(\"StringConcatTestOld <concat> \" + new OldConsumer());\n+    }\n+}\n+*\/\n+\n+class NormalClass {\n+    static void testLambda() {\n+        Runnable r = () -> {\n+            System.out.println(\"NormalClass testLambda\");\n+        };\n+        r.run();\n+    }\n+}\n+\n+class SubOfOldClass extends OldClass {\n+    static void testLambda() {\n+        Runnable r = () -> {\n+            System.out.println(\"SubOfOldClass testLambda\");\n+        };\n+        r.run();\n+    }\n+}\n+\n+interface MyInterface {\n+    void dispatch(OldClass c);\n+}\n+\n+interface InterfaceWithClinit {\n+    static final long X = System.currentTimeMillis();\n+    void dispatch();\n+    default long dummy() { return X; }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/ResolvedConstants.java","additions":171,"deletions":40,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+\n+decompiled from\n+\n+class OldConsumer {}\n+\n+class StringConcatTestOld {\n+    public static void main(String args[]) {\n+        System.out.println(\"StringConcatTestOld <concat> \" + new OldConsumer());\n+    }\n+}\n+\n+\n+(1) Comment out this line\n+\n+    invokestatic    Method java\/lang\/String.valueOf:\"(Ljava\/lang\/Object;)Ljava\/lang\/String;\";\n+\n+(2) Change the MethodType parameter of makeConcatWithConstants from\n+\n+       \"(Ljava\/lang\/String;)Ljava\/lang\/String;\"\n+    ->\n+\n+       \"(LOldConsumer;)Ljava\/lang\/String;\"\n+\n+*\/\n+\n+super class StringConcatTestOld\n+    version 67:0\n+{\n+  Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+  {\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+  }\n+  public static Method main:\"([Ljava\/lang\/String;)V\"\n+    stack 3 locals 1\n+  {\n+        getstatic    Field java\/lang\/System.out:\"Ljava\/io\/PrintStream;\";\n+        new    class OldConsumer;\n+        dup;\n+        invokespecial   Method OldConsumer.\"<init>\":\"()V\";\n+      \/\/invokestatic    Method java\/lang\/String.valueOf:\"(Ljava\/lang\/Object;)Ljava\/lang\/String;\";\n+        invokedynamic   InvokeDynamic REF_invokeStatic:Method java\/lang\/invoke\/StringConcatFactory.makeConcatWithConstants:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/String;[Ljava\/lang\/Object;)Ljava\/lang\/invoke\/CallSite;\":makeConcatWithConstants:\"(LOldConsumer;)Ljava\/lang\/String;\" {\n+            String \"StringConcatTestOld <concat> \"\n+        };\n+        invokevirtual   Method java\/io\/PrintStream.println:\"(Ljava\/lang\/String;)V\";\n+        return;\n+  }\n+\n+  public static final InnerClass Lookup=class java\/lang\/invoke\/MethodHandles$Lookup of class java\/lang\/invoke\/MethodHandles;\n+\n+} \/\/ end Class StringConcatTestOld\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/StringConcatTestOld.jasm","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+super class OldConsumer\n+    version 49:0\n+{\n+\n+\n+Method \"<init>\":\"()V\"\n+    stack 1 locals 1\n+{\n+        aload_0;\n+        invokespecial    Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+}\n+\n+public Method consumeString:\"(Ljava\/lang\/String;)V\"\n+    stack 3 locals 2\n+{\n+        getstatic        Field java\/lang\/System.out:\"Ljava\/io\/PrintStream;\";\n+        new              class java\/lang\/StringBuilder;\n+        dup;\n+        invokespecial    Method java\/lang\/StringBuilder.\"<init>\":\"()V\";\n+        ldc              String \"Hello: \";\n+        invokevirtual    Method java\/lang\/StringBuilder.append:\"(Ljava\/lang\/String;)Ljava\/lang\/StringBuilder;\";\n+        aload_1;\n+        invokevirtual    Method java\/lang\/StringBuilder.append:\"(Ljava\/lang\/String;)Ljava\/lang\/StringBuilder;\";\n+        invokevirtual    Method java\/lang\/StringBuilder.toString:\"()Ljava\/lang\/String;\";\n+        invokevirtual    Method java\/io\/PrintStream.println:\"(Ljava\/lang\/String;)V\";\n+        return;\n+}\n+\n+} \/\/ end Class OldConsumer\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/OldConsumer.jasm","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+java\/math\/BigInteger\/largeMemory\/DivisionOverflow.java          0000000 generic-all\n+java\/math\/BigInteger\/largeMemory\/StringConstructorOverflow.java 0000000 generic-all\n+\n+jdk\/internal\/misc\/CDS\/ArchivedEnumTest.java                     0000000 generic-all\n+\n+java\/lang\/module\/ModuleDescriptorHashCodeTest.java              0000000 generic-all\n+\n+\n+# The test case is incorrect. There's no guarantee that running a JVM with the following\n+# parameters will always cause the class java\/lang\/invoke\/MethodHandleStatics to be initialized\n+java\/lang\/invoke\/DumpMethodHandleInternals.java                 0000000 generic-all\n","filename":"test\/jdk\/ProblemList-AotJdk.txt","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import jdk.test.lib.cds.CDSTestUtils;\n@@ -49,1 +50,1 @@\n-        out.shouldNotContain(\"object points to a static field that may be reinitialized at runtime\");\n+        out.shouldNotContain(CDSTestUtils.MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n","filename":"test\/jdk\/jdk\/internal\/misc\/CDS\/ArchivedEnumTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+        map.put(\"vm.cds.supports.aot.class.linking\", this::vmCDSSupportsAOTClassLinking);\n@@ -471,0 +472,8 @@\n+    \/**\n+     * @return true if this VM can support the -XX:AOTClassLinking option\n+     *\/\n+    protected String vmCDSSupportsAOTClassLinking() {\n+      \/\/ Currently, the VM supports AOTClassLinking as long as it's able to write archived java heap.\n+      return vmCDSCanWriteArchivedJavaHeap();\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jtreg.SkippedException;\n@@ -45,1 +46,1 @@\n-    private final String productionRunLog;\n+    private int numProductionRuns = 0;\n@@ -48,0 +49,4 @@\n+        if (CDSTestUtils.DYNAMIC_DUMP) {\n+            throw new SkippedException(\"Tests based on CDSAppTester should be excluded when -Dtest.dynamic.cds.archive is specified\");\n+        }\n+\n@@ -56,1 +61,8 @@\n-        productionRunLog = name() + \".production.log\";\n+    }\n+\n+    private String productionRunLog() {\n+        if (numProductionRuns == 0) {\n+            return name() + \".production.log\";\n+        } else {\n+            return name() + \".production.\" + numProductionRuns + \".log\";\n+        }\n@@ -100,0 +112,5 @@\n+    private boolean checkExitValue = true;\n+\n+    public final void setCheckExitValue(boolean b) {\n+        checkExitValue = b;\n+    }\n@@ -137,1 +154,4 @@\n-        output.shouldHaveExitValue(0);\n+        if (checkExitValue) {\n+            output.shouldHaveExitValue(0);\n+        }\n+        output.shouldNotContain(CDSTestUtils.MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n@@ -192,0 +212,10 @@\n+        return productionRun(null, null);\n+    }\n+\n+    public OutputAnalyzer productionRun(String[] extraVmArgs) throws Exception {\n+        return productionRun(extraVmArgs, null);\n+    }\n+\n+    \/\/ After calling run(String[]), you can call this method to run the app again, with the AOTCache\n+    \/\/ using different args to the VM and application.\n+    public OutputAnalyzer productionRun(String[] extraVmArgs, String[] extraAppArgs) throws Exception {\n@@ -194,0 +224,2 @@\n+                                                   \"-XX:+UnlockDiagnosticVMOptions\",\n+                                                   \"-XX:VerifyArchivedFields=2\", \/\/ make sure archived heap objects are good.\n@@ -195,1 +227,1 @@\n-                                                   logToFile(productionRunLog, \"cds\"));\n+                                                   logToFile(productionRunLog(), \"cds\"));\n@@ -203,0 +235,4 @@\n+        if (extraVmArgs != null) {\n+            cmdLine = StringArrayUtils.concat(cmdLine, extraVmArgs);\n+        }\n+\n@@ -204,1 +240,8 @@\n-        return executeAndCheck(cmdLine, runMode, productionRunLog);\n+\n+        if (extraAppArgs != null) {\n+            cmdLine = StringArrayUtils.concat(cmdLine, extraAppArgs);\n+        }\n+\n+        OutputAnalyzer out = executeAndCheck(cmdLine, runMode, productionRunLog());\n+        numProductionRuns ++;\n+        return out;\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,2 @@\n+    public static final String MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE =\n+        \"an object points to a static field that may hold a different value at runtime\";\n@@ -287,0 +289,1 @@\n+        output.shouldNotContain(MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n@@ -299,0 +302,1 @@\n+        output.shouldNotContain(MSG_STATIC_FIELD_MAY_HOLD_DIFFERENT_VALUE);\n@@ -862,0 +866,20 @@\n+\n+    \/\/ Some tests were initially written without the knowledge of -XX:+AOTClassLinking. These tests need to\n+    \/\/ be adjusted if -XX:+AOTClassLinking is specified in jtreg -vmoptions or -javaoptions:\n+    public static boolean isAOTClassLinkingEnabled() {\n+        return isBooleanVMOptionEnabledInCommandLine(\"AOTClassLinking\");\n+    }\n+\n+    public static boolean isBooleanVMOptionEnabledInCommandLine(String optionName) {\n+        String lastMatch = null;\n+        String pattern = \"^-XX:.\" + optionName + \"$\";\n+        for (String s : Utils.getTestJavaOpts()) {\n+            if (s.matches(pattern)) {\n+                lastMatch = s;\n+            }\n+        }\n+        if (lastMatch != null && lastMatch.equals(\"-XX:+\" + optionName)) {\n+            return true;\n+        }\n+        return false;\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"}]}