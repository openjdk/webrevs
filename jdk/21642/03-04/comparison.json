{"files":[{"patch":"@@ -116,1 +116,2 @@\n-void AOTClassLinker::add_candidate(InstanceKlass* ik) {\n+void AOTClassLinker::add_new_candidate(InstanceKlass* ik) {\n+  assert(!is_candidate(ik), \"caller need to check\");\n@@ -127,2 +128,2 @@\n-\/\/ that way, and return success or failure.  Not only must ik itself\n-\/\/ look like a class we can preload but its supers must also be\n+\/\/ that way, and return success or failure. Not only must ik itself\n+\/\/ look like a class that can be aot-linked but its supers must also be\n@@ -175,1 +176,4 @@\n-  add_candidate(ik);\n+  \/\/ There are no loops in the class hierarchy, and this function is always called single-threaded, so\n+  \/\/ we know ik has not been added yet.\n+  assert(CDSConfig::current_thread_is_vm_or_dumper(), \"that's why we don't need locks\");\n+  add_new_candidate(ik);\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  static void add_candidate(InstanceKlass* ik);\n+  static void add_new_candidate(InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/cds\/aotClassLinker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-      if (SystemDictionaryShared::check_for_exclusion(k)) {\n+      if (SystemDictionaryShared::should_be_excluded(k)) {\n","filename":"src\/hotspot\/share\/cds\/aotConstantPoolResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/vmThread.hpp\"\n@@ -54,0 +55,2 @@\n+JavaThread* CDSConfig::_dumper_thread = nullptr;\n+\n@@ -62,1 +65,0 @@\n-\n@@ -506,0 +508,16 @@\n+\n+CDSConfig::DumperThreadMark::DumperThreadMark(JavaThread* current) {\n+  assert(_dumper_thread == nullptr, \"sanity\");\n+  _dumper_thread = current;\n+}\n+\n+CDSConfig::DumperThreadMark::~DumperThreadMark() {\n+  assert(_dumper_thread != nullptr, \"sanity\");\n+  _dumper_thread = nullptr;\n+}\n+\n+bool CDSConfig::current_thread_is_vm_or_dumper() {\n+  Thread* t = Thread::current();\n+  return t != nullptr && (t->is_VM_thread() || t == _dumper_thread);\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+class JavaThread;\n+\n@@ -47,0 +49,2 @@\n+\n+  static JavaThread* _dumper_thread;\n@@ -128,0 +132,15 @@\n+\n+\n+  \/\/ Some CDS functions assume that they are called only within a single-threaded context. I.e.,\n+  \/\/ they are called from:\n+  \/\/    - The VM thread (e.g., inside VM_PopulateDumpSharedSpace)\n+  \/\/    - The thread that performs prepatory steps before switching to the VM thread\n+  \/\/ Since these two threads never execute concurrently, we can avoid using locks in these CDS\n+  \/\/ function. For safety, these functions should assert with CDSConfig::current_thread_is_vm_or_dumper().\n+  class DumperThreadMark {\n+  public:\n+    DumperThreadMark(JavaThread* current);\n+    ~DumperThreadMark();\n+  };\n+\n+  static bool current_thread_is_vm_or_dumper() NOT_CDS(false);\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -501,0 +501,1 @@\n+  CDSConfig::DumperThreadMark dumper_thread_mark(current);\n@@ -530,0 +531,1 @@\n+  CDSConfig::DumperThreadMark dumper_thread_mark(THREAD);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -452,1 +452,2 @@\n-     ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$BMH+\"));\n+     ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$BMH+\") ||\n+     ik->name()->starts_with(\"java\/lang\/invoke\/LambdaForm$VH+\"));\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-  \/\/ The \"special subgraph\" contains all the all archived objects that are reachable\n+  \/\/ The \"special subgraph\" contains all the archived objects that are reachable\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -724,0 +724,1 @@\n+  CDSConfig::DumperThreadMark dumper_thread_mark(THREAD);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -664,0 +664,1 @@\n+      guarantee(HeapShared::is_archivable_hidden_klass(k), \"required hidden class must be archivable\");\n@@ -671,3 +672,5 @@\n-\/\/ Returns true if the class should be excluded. This can be called before\n-\/\/ SystemDictionaryShared::find_all_archivable_classes().\n-bool SystemDictionaryShared::check_for_exclusion(Klass* k) {\n+\/\/ Returns true if the class should be excluded. This can be called by\n+\/\/ AOTConstantPoolResolver before or after we enter the CDS safepoint.\n+\/\/ When called before the safepoint, we need to link the class so that\n+\/\/ it can be checked by check_for_exclusion().\n+bool SystemDictionaryShared::should_be_excluded(Klass* k) {\n@@ -675,0 +678,1 @@\n+  assert(CDSConfig::current_thread_is_vm_or_dumper(), \"sanity\");\n@@ -677,1 +681,1 @@\n-    return check_for_exclusion(ObjArrayKlass::cast(k)->bottom_klass());\n+    return should_be_excluded(ObjArrayKlass::cast(k)->bottom_klass());\n@@ -685,3 +689,12 @@\n-    if (SafepointSynchronize::is_at_safepoint()) {\n-      return is_excluded_class(ik);\n-    }\n+    if (!SafepointSynchronize::is_at_safepoint()) {\n+      if (!ik->is_linked()) {\n+        \/\/ check_for_exclusion() below doesn't link unlinked classes. We come\n+        \/\/ here only when we are trying to aot-link constant pool entries, so\n+        \/\/ we'd better link the class.\n+        JavaThread* THREAD = JavaThread::current();\n+        ik->link_class(THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          CLEAR_PENDING_EXCEPTION;\n+          return true; \/\/ linking failed -- let's exclude it\n+        }\n+      }\n@@ -689,5 +702,3 @@\n-    if (!ik->is_linked()) {\n-      JavaThread* THREAD = JavaThread::current();\n-      ik->link_class(THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-        CLEAR_PENDING_EXCEPTION;\n+      MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+      DumpTimeClassInfo* p = get_info_locked(ik);\n+      if (p->is_excluded()) {\n@@ -696,0 +707,10 @@\n+      return check_for_exclusion(ik, p);\n+    } else {\n+      \/\/ No need to check for is_linked() as all eligible classes should have\n+      \/\/ already been linked in MetaspaceShared::link_class_for_cds().\n+      \/\/ Can't take the lock as we are in safepoint.\n+      DumpTimeClassInfo* p = _dumptime_table->get(ik);\n+      if (p->is_excluded()) {\n+        return true;\n+      }\n+      return check_for_exclusion(ik, p);\n@@ -697,7 +718,0 @@\n-\n-    MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n-    DumpTimeClassInfo* p = get_info_locked(ik);\n-    if (p->is_excluded()) {\n-      return true;\n-    }\n-    return check_for_exclusion(ik, p);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":33,"deletions":19,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-  static bool check_for_exclusion(Klass* k);\n+  static bool should_be_excluded(Klass* k);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -287,0 +287,38 @@\n+template <typename Function>\n+void ConstantPool::iterate_archivable_resolved_references(Function function) {\n+  objArrayOop rr = resolved_references();\n+  if (rr != nullptr && cache() != nullptr && CDSConfig::is_dumping_invokedynamic()) {\n+    Array<ResolvedIndyEntry>* indy_entries = cache()->resolved_indy_entries();\n+    if (indy_entries != nullptr) {\n+      for (int i = 0; i < indy_entries->length(); i++) {\n+        ResolvedIndyEntry *rie = indy_entries->adr_at(i);\n+        if (rie->is_resolved() && AOTConstantPoolResolver::is_resolution_deterministic(this, rie->constant_pool_index())) {\n+          int rr_index = rie->resolved_references_index();\n+          assert(resolved_reference_at(rr_index) != nullptr, \"must exist\");\n+          function(rr_index);\n+\n+          \/\/ Save the BSM as well (sometimes the JIT looks up the BSM it for replay)\n+          int indy_cp_index = rie->constant_pool_index();\n+          int bsm_mh_cp_index = bootstrap_method_ref_index_at(indy_cp_index);\n+          int bsm_rr_index = cp_to_object_index(bsm_mh_cp_index);\n+          assert(resolved_reference_at(bsm_rr_index) != nullptr, \"must exist\");\n+          function(bsm_rr_index);\n+        }\n+      }\n+    }\n+\n+    Array<ResolvedMethodEntry>* method_entries = cache()->resolved_method_entries();\n+    if (method_entries != nullptr) {\n+      for (int i = 0; i < method_entries->length(); i++) {\n+        ResolvedMethodEntry* rme = method_entries->adr_at(i);\n+        if (rme->is_resolved(Bytecodes::_invokehandle) && rme->has_appendix() &&\n+            cache()->can_archive_resolved_method(this, rme)) {\n+          int rr_index = rme->resolved_references_index();\n+          assert(resolved_reference_at(rr_index) != nullptr, \"must exist\");\n+          function(rr_index);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n@@ -303,3 +341,2 @@\n-  if (rr == nullptr) {\n-    return nullptr;\n-  } else {\n+  if (rr != nullptr) {\n+    ResourceMark rm;\n@@ -307,0 +344,2 @@\n+    GrowableArray<bool> keep_resolved_refs(rr_len, rr_len, false);\n+\n@@ -308,0 +347,4 @@\n+    src_cp->iterate_archivable_resolved_references([&](int rr_index) {\n+      keep_resolved_refs.at_put(rr_index, true);\n+    });\n+\n@@ -311,1 +354,0 @@\n-\n@@ -327,1 +369,1 @@\n-        if (CDSConfig::is_dumping_invokedynamic()) {\n+        if (keep_resolved_refs.at(i)) {\n@@ -334,0 +376,1 @@\n+  return rr;\n@@ -337,5 +380,0 @@\n-  if (!CDSConfig::is_dumping_invokedynamic()) {\n-    \/\/ This function is needed only for supporting aot-linking indy.\n-    return;\n-  }\n-\n@@ -360,6 +398,4 @@\n-    for (int i = 0; i < rr->length(); i++) {\n-      oop obj = rr->obj_at(i);\n-      if (obj != nullptr) {\n-        HeapShared::find_required_hidden_classes_in_object(obj);\n-      }\n-    }\n+    iterate_archivable_resolved_references([&](int rr_index) {\n+      oop obj = rr->obj_at(rr_index);\n+      HeapShared::find_required_hidden_classes_in_object(obj);\n+    });\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":52,"deletions":16,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -693,0 +693,1 @@\n+  template <typename Function> void iterate_archivable_resolved_references(Function function);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -503,6 +503,1 @@\n-    if (resolved && CDSConfig::is_dumping_invokedynamic()) {\n-      \/\/ If we have resolved indys with MethodTypes that reference excluded classes,\n-      \/\/ it's too late to undo now. AOTConstantPoolResolver::preresolve_indy_cp_entries()\n-      \/\/ should not have resolved such entries.\n-      guarantee(AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index),\n-                \"should not have resolved non-deterministic indy\");\n+    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n@@ -561,1 +556,3 @@\n-  bool deterministic = AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index);\n+  if (!AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n+    return false;\n+  }\n@@ -566,1 +563,1 @@\n-    return deterministic;\n+    return true;\n@@ -570,1 +567,0 @@\n-      guarantee(deterministic, \"should not have resolved resolve non-deterministic invokehandle\");\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -562,0 +562,2 @@\n+ -runtime\/cds\/appcds\/resolvedConstants\/AOTLinkedLambdas.java \\\n+ -runtime\/cds\/appcds\/resolvedConstants\/AOTLinkedVarHandles.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary AOT resolution of VarHandle invocation\n+ * @bug 8343245\n+ * @requires vm.cds\n+ * @requires vm.cds.supports.aot.class.linking\n+ * @library \/test\/lib\n+ * @build AOTLinkedVarHandles\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar app.jar\n+ *                 AOTLinkedVarHandlesApp AOTLinkedVarHandlesApp$Data\n+ * @run driver AOTLinkedVarHandles\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class AOTLinkedVarHandles {\n+    static final String classList = \"AOTLinkedVarHandles.classlist\";\n+    static final String appJar = ClassFileInstaller.getJarPath(\"app.jar\");\n+    static final String mainClass = AOTLinkedVarHandlesApp.class.getName();\n+\n+    public static void main(String[] args) throws Exception {\n+        CDSTestUtils.dumpClassList(classList, \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"Hello AOTLinkedVarHandlesApp\");\n+            });\n+\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-XX:+AOTClassLinking\",\n+                       \"-Xlog:cds+resolve=trace\",\n+                       \"-Xlog:cds+class=debug\",\n+                       \"-cp\", appJar);\n+\n+        String s = \"archived method CP entry.* AOTLinkedVarHandlesApp \";\n+        OutputAnalyzer dumpOut = CDSTestUtils.createArchiveAndCheck(opts);\n+        dumpOut.shouldMatch(s + \"java\/lang\/invoke\/VarHandle.compareAndExchangeAcquire:\\\\(\\\\[DIDI\\\\)D =>\");\n+        dumpOut.shouldMatch(s + \"java\/lang\/invoke\/VarHandle.get:\\\\(\\\\[DI\\\\)D => \");\n+\n+        CDSOptions runOpts = (new CDSOptions())\n+            .setUseVersion(false)\n+            .addPrefix(\"-Xlog:cds\",\n+                       \"-esa\",\n+                       \"-cp\", appJar)\n+            .addSuffix(mainClass);\n+\n+        CDSTestUtils.run(runOpts)\n+            .assertNormalExit(\"Hello AOTLinkedVarHandlesApp\");\n+    }\n+}\n+\n+class AOTLinkedVarHandlesApp {\n+    static final VarHandle initialized;\n+    static final VarHandle lazy;\n+    static long longField = 5678;\n+    static long seed;\n+\n+    static {\n+        try {\n+            lazy = MethodHandles.lookup().findStaticVarHandle(Data.class, \"longField\", long.class);\n+            initialized = MethodHandles.lookup().findStaticVarHandle(AOTLinkedVarHandlesApp.class, \"longField\", long.class);\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static class Data {\n+        static long longField = seed;\n+    }\n+\n+    public static void main(String args[]) {\n+        seed = 1234;\n+        System.out.println(\"Hello AOTLinkedVarHandlesApp\");\n+        long a = (long) lazy.get();\n+        long b = (long) initialized.get();\n+        System.out.println(a);\n+        System.out.println(b);\n+        if (a != 1234) {\n+            throw new RuntimeException(\"Data class should not be initialized: \" + a);\n+        }\n+        if (b != 5678) {\n+            throw new RuntimeException(\"VarHandle.get() failed: \" + b);\n+        }\n+\n+        VarHandle vh = MethodHandles.arrayElementVarHandle(double[].class);\n+        double[] array = new double[] {1.0};\n+        int index = 0;\n+        int v = 4;\n+\n+        \/\/ JDK-8343245 -- this generates \"java.lang.invoke.LambdaForm$VH\/0x80????\" hidden class\n+        double r = (double) vh.compareAndExchangeAcquire(array, index, 1.0, v);\n+        if (r != 1.0) {\n+            throw new RuntimeException(\"Unexpected result: \" + r);\n+        }\n+        r = (double) vh.get(array, index);\n+        if (r != 4.0) {\n+            throw new RuntimeException(\"Unexpected result: \" + r);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/resolvedConstants\/AOTLinkedVarHandles.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}