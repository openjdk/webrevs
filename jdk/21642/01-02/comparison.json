{"files":[{"patch":"@@ -332,0 +332,5 @@\n+      } else {\n+        \/\/ Some cached heap objects may hold references to methods in aot-linked\n+        \/\/ classes (via MemberName). We need to make sure all classes are\n+        \/\/ linked to allow such MemberNames to be invoked.\n+        ik->link_class(CHECK);\n","filename":"src\/hotspot\/share\/cds\/aotLinkedClassBulkLoader.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -287,29 +287,0 @@\n-template <typename Function>\n-void ConstantPool::iterate_archivable_resolved_references(Function function) {\n-  objArrayOop rr = resolved_references();\n-  if (rr != nullptr && cache() != nullptr && CDSConfig::is_dumping_invokedynamic()) {\n-    Array<ResolvedIndyEntry>* indy_entries = cache()->resolved_indy_entries();\n-    if (indy_entries != nullptr) {\n-      for (int i = 0; i < indy_entries->length(); i++) {\n-        ResolvedIndyEntry *rie = indy_entries->adr_at(i);\n-        if (rie->is_resolved() && AOTConstantPoolResolver::is_resolution_deterministic(this, rie->constant_pool_index())) {\n-          int rr_index = rie->resolved_references_index();\n-          function(rr_index);\n-        }\n-      }\n-    }\n-\n-    Array<ResolvedMethodEntry>* method_entries = cache()->resolved_method_entries();\n-    if (method_entries != nullptr) {\n-      for (int i = 0; i < method_entries->length(); i++) {\n-        ResolvedMethodEntry* rme = method_entries->adr_at(i);\n-        if (rme->is_resolved(Bytecodes::_invokehandle) && rme->has_appendix() &&\n-            cache()->can_archive_resolved_method(this, rme)) {\n-          int rr_index = rme->resolved_references_index();\n-          function(rr_index);\n-        }\n-      }\n-    }\n-  }\n-}\n-\n@@ -332,2 +303,3 @@\n-  if (rr != nullptr) {\n-    ResourceMark rm;\n+  if (rr == nullptr) {\n+    return nullptr;\n+  } else {\n@@ -335,2 +307,0 @@\n-    GrowableArray<bool> keep_resolved_refs(rr_len, rr_len, false);\n-\n@@ -338,4 +308,0 @@\n-    src_cp->iterate_archivable_resolved_references([&](int rr_index) {\n-      keep_resolved_refs.at_put(rr_index, true);\n-    });\n-\n@@ -345,0 +311,1 @@\n+\n@@ -356,0 +323,1 @@\n+            continue;\n@@ -357,1 +325,3 @@\n-        } else if (keep_resolved_refs.at(i)) {\n+        }\n+\n+        if (CDSConfig::is_dumping_invokedynamic()) {\n@@ -364,1 +334,0 @@\n-  return rr;\n@@ -368,0 +337,5 @@\n+  if (!CDSConfig::is_dumping_invokedynamic()) {\n+    \/\/ This function is needed only for supporting aot-linking indy.\n+    return;\n+  }\n+\n@@ -386,4 +360,6 @@\n-    iterate_archivable_resolved_references([&](int rr_index) {\n-      oop obj = rr->obj_at(rr_index);\n-      HeapShared::find_required_hidden_classes_in_object(obj);\n-    });\n+    for (int i = 0; i < rr->length(); i++) {\n+      oop obj = rr->obj_at(i);\n+      if (obj != nullptr) {\n+        HeapShared::find_required_hidden_classes_in_object(obj);\n+      }\n+    }\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":19,"deletions":43,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -693,1 +693,0 @@\n-  template <typename Function> void iterate_archivable_resolved_references(Function function);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -503,1 +503,6 @@\n-    if (resolved && AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n+    if (resolved && CDSConfig::is_dumping_invokedynamic()) {\n+      \/\/ If we have resolved indys with MethodTypes that reference excluded classes,\n+      \/\/ it's too late to undo now. AOTConstantPoolResolver::preresolve_indy_cp_entries()\n+      \/\/ should not have resolved such entries.\n+      guarantee(AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index),\n+                \"should not have resolved non-deterministic indy\");\n@@ -556,3 +561,1 @@\n-  if (!AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index)) {\n-    return false;\n-  }\n+  bool deterministic = AOTConstantPoolResolver::is_resolution_deterministic(src_cp, cp_index);\n@@ -563,1 +566,1 @@\n-    return true;\n+    return deterministic;\n@@ -567,0 +570,1 @@\n+      guarantee(deterministic, \"should not have resolved resolve non-deterministic invokehandle\");\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -86,1 +86,6 @@\n-        modulePathTests();\n+        boolean dynamicMode = Boolean.getBoolean(\"test.dynamic.cds.archive\");\n+        if (!dynamicMode) {\n+            \/\/ These tests need to dump the full module graph, which is not possible with\n+            \/\/ dynamic dump.\n+            modulePathTests();\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotClassLinking\/AOTClassLinkingVMOptions.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}