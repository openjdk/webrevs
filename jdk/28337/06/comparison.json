{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -7323,0 +7323,19 @@\n+void Assembler::vucomxsd(XMMRegister dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_64bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x2E);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vucomxsd(XMMRegister dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ true, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x2E, (0xC0 | encode));\n+}\n+\n@@ -7338,0 +7357,19 @@\n+void Assembler::vucomxss(XMMRegister dst, Address src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionMark im(this);\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_address_attributes(\/* tuple_type *\/ EVEX_T1S, \/* input_size_in_bits *\/ EVEX_32bit);\n+  attributes.set_is_evex_instruction();\n+  vex_prefix(src, 0, dst->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int8(0x2E);\n+  emit_operand(dst, src, 0);\n+}\n+\n+void Assembler::vucomxss(XMMRegister dst, XMMRegister src) {\n+  assert(VM_Version::supports_avx10_2(), \"\");\n+  InstructionAttr attributes(AVX_128bit, \/* rex_w *\/ false, \/* legacy_mode *\/ false, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  attributes.set_is_evex_instruction();\n+  int encode = vex_prefix_and_encode(dst->encoding(), 0, src->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &attributes);\n+  emit_int16(0x2E, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":39,"deletions":1,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -2334,0 +2334,2 @@\n+  void vucomxsd(XMMRegister dst, Address src);\n+  void vucomxsd(XMMRegister dst, XMMRegister src);\n@@ -2338,0 +2340,2 @@\n+  void vucomxss(XMMRegister dst, Address src);\n+  void vucomxss(XMMRegister dst, XMMRegister src);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1049,0 +1049,3 @@\n+  \/\/ Handle special cases +0.0\/-0.0 and NaN, if argument is +0.0\/-0.0 or NaN, return argument\n+  \/\/ If AVX10.2 (or newer) floating point comparison instructions used, SF=1 for equal and unordered cases\n+  \/\/ If other floating point comparison instructions used, ZF=1 for equal and unordered cases\n@@ -1050,3 +1053,7 @@\n-    ucomiss(dst, zero);\n-    jcc(Assembler::equal, DONE_LABEL);    \/\/ handle special case +0.0\/-0.0, if argument is +0.0\/-0.0, return argument\n-    jcc(Assembler::parity, DONE_LABEL);   \/\/ handle special case NaN, if argument NaN, return NaN\n+    if (VM_Version::supports_avx10_2()) {\n+      vucomxss(dst, zero);\n+      jcc(Assembler::negative, DONE_LABEL);\n+    } else {\n+      ucomiss(dst, zero);\n+      jcc(Assembler::equal, DONE_LABEL);\n+    }\n@@ -1057,3 +1064,7 @@\n-    ucomisd(dst, zero);\n-    jcc(Assembler::equal, DONE_LABEL);    \/\/ handle special case +0.0\/-0.0, if argument is +0.0\/-0.0, return argument\n-    jcc(Assembler::parity, DONE_LABEL);   \/\/ handle special case NaN, if argument NaN, return NaN\n+    if (VM_Version::supports_avx10_2()) {\n+      vucomxsd(dst, zero);\n+      jcc(Assembler::negative, DONE_LABEL);\n+    } else {\n+      ucomisd(dst, zero);\n+      jcc(Assembler::equal, DONE_LABEL);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2659,0 +2659,11 @@\n+void MacroAssembler::vucomxsd(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::vucomxsd(dst, as_Address(src));\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::vucomxsd(dst, Address(rscratch, 0));\n+  }\n+}\n+\n@@ -2670,0 +2681,11 @@\n+void MacroAssembler::vucomxss(XMMRegister dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::vucomxss(dst, as_Address(src));\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::vucomxss(dst, Address(rscratch, 0));\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -1316,0 +1316,4 @@\n+  void vucomxss(XMMRegister dst, XMMRegister    src) { Assembler::vucomxss(dst, src); }\n+  void vucomxss(XMMRegister dst, Address        src) { Assembler::vucomxss(dst, src); }\n+  void vucomxss(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n+\n@@ -1320,0 +1324,4 @@\n+  void vucomxsd(XMMRegister dst, XMMRegister    src) { Assembler::vucomxsd(dst, src); }\n+  void vucomxsd(XMMRegister dst, Address        src) { Assembler::vucomxsd(dst, src); }\n+  void vucomxsd(XMMRegister dst, AddressLiteral src, Register rscratch = noreg);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1702,0 +1702,2 @@\n+  \/\/ If any floating point comparison instruction is used, unordered case always triggers jump\n+  \/\/ for below condition, CF=1 is true when at least one input is NaN\n@@ -1704,1 +1706,0 @@\n-  __ jcc(Assembler::parity, done);\n@@ -5532,1 +5533,1 @@\n-  predicate(false);\n+  predicate(!UseAPX || !VM_Version::supports_avx10_2());\n@@ -5538,0 +5539,9 @@\n+operand rFlagsRegUCFE() %{\n+  constraint(ALLOC_IN_RC(int_flags));\n+  match(RegFlags);\n+  predicate(UseAPX && VM_Version::supports_avx10_2());\n+\n+  format %{ \"RFLAGS_U_CFE\" %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -6030,4 +6040,4 @@\n-    less(0xC, \"l\");\n-    greater_equal(0xD, \"ge\");\n-    less_equal(0xE, \"le\");\n-    greater(0xF, \"g\");\n+    less(0xc, \"l\");\n+    greater_equal(0xd, \"ge\");\n+    less_equal(0xe, \"le\");\n+    greater(0xf, \"g\");\n@@ -6065,5 +6075,6 @@\n-  predicate(n->as_Bool()->_test._test == BoolTest::lt ||\n-            n->as_Bool()->_test._test == BoolTest::ge ||\n-            n->as_Bool()->_test._test == BoolTest::le ||\n-            n->as_Bool()->_test._test == BoolTest::gt ||\n-            n->in(1)->in(1) == n->in(1)->in(2));\n+  predicate((!UseAPX || !VM_Version::supports_avx10_2()) &&\n+            (n->as_Bool()->_test._test == BoolTest::lt ||\n+             n->as_Bool()->_test._test == BoolTest::ge ||\n+             n->as_Bool()->_test._test == BoolTest::le ||\n+             n->as_Bool()->_test._test == BoolTest::gt ||\n+             n->in(1)->in(1) == n->in(1)->in(2)));\n@@ -6087,1 +6098,2 @@\n-  predicate((n->as_Bool()->_test._test == BoolTest::ne ||\n+  predicate((!UseAPX || !VM_Version::supports_avx10_2()) &&\n+            (n->as_Bool()->_test._test == BoolTest::ne ||\n@@ -6103,0 +6115,31 @@\n+\n+\/\/ Floating point comparisons that set condition flags to test more directly,\n+\/\/ Unsigned tests are used for G (>) and GE (>=) conditions while signed tests\n+\/\/ are used for L (<) and LE (<=) conditions. It's important to convert these\n+\/\/ latter conditions to ones that use unsigned tests before passing into an\n+\/\/ instruction because the preceding comparison might be based on a three way\n+\/\/ comparison (CmpF3 or CmpD3) that also assigns unordered outcomes to -1.\n+operand cmpOpUCFE()\n+%{\n+  match(Bool);\n+  predicate((UseAPX && VM_Version::supports_avx10_2()) &&\n+            (n->as_Bool()->_test._test == BoolTest::ne ||\n+             n->as_Bool()->_test._test == BoolTest::eq ||\n+             n->as_Bool()->_test._test == BoolTest::lt ||\n+             n->as_Bool()->_test._test == BoolTest::ge ||\n+             n->as_Bool()->_test._test == BoolTest::le ||\n+             n->as_Bool()->_test._test == BoolTest::gt));\n+\n+  format %{ \"\" %}\n+  interface(COND_INTER) %{\n+    equal(0x4, \"e\");\n+    not_equal(0x5, \"ne\");\n+    less(0x2, \"b\");\n+    greater_equal(0x3, \"ae\");\n+    less_equal(0x6, \"be\");\n+    greater(0x7, \"a\");\n+    overflow(0x0, \"o\");\n+    no_overflow(0x1, \"no\");\n+  %}\n+%}\n+\n@@ -9119,0 +9162,14 @@\n+instruct cmovI_imm_01UCFE(rRegI dst, immI_1 src, rFlagsRegUCFE cr, cmpOpUCFE cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_int() == 0);\n+  match(Set dst (CMoveI (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# signed, unsigned, int\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9120,1 +9177,0 @@\n-  predicate(!UseAPX);\n@@ -9122,0 +9178,1 @@\n+\n@@ -9128,2 +9185,1 @@\n-instruct cmovI_regUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, rRegI src2) %{\n-  predicate(UseAPX);\n+instruct cmovI_regUCFE_ndd(rRegI dst, cmpOpUCFE cop, rFlagsRegUCFE cr, rRegI src1, rRegI src2) %{\n@@ -9131,0 +9187,1 @@\n+\n@@ -9132,1 +9189,1 @@\n-  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, unsigned, int ndd\" %}\n@@ -9140,1 +9197,1 @@\n-  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n@@ -9153,15 +9210,0 @@\n-instruct cmovI_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src1, rRegI src2) %{\n-  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src1 src2)));\n-  effect(TEMP dst);\n-\n-  ins_cost(200);\n-  format %{ \"ecmovpl  $dst, $src1, $src2\\n\\t\"\n-            \"cmovnel  $dst, $src2\" %}\n-  ins_encode %{\n-    __ ecmovl(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n-    __ cmovl(Assembler::notEqual, $dst$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n@@ -9171,1 +9213,1 @@\n-  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n@@ -9185,17 +9227,0 @@\n-\/\/ We need this special handling for only eq \/ neq comparison since NaN == NaN is false,\n-\/\/ and parity flag bit is set if any of the operand is a NaN.\n-instruct cmovI_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegI dst, rRegI src1, rRegI src2) %{\n-  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n-  match(Set dst (CMoveI (Binary cop cr) (Binary src2 src1)));\n-  effect(TEMP dst);\n-\n-  ins_cost(200);\n-  format %{ \"ecmovpl  $dst, $src1, $src2\\n\\t\"\n-            \"cmovnel  $dst, $src2\" %}\n-  ins_encode %{\n-    __ ecmovl(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n-    __ cmovl(Assembler::notEqual, $dst$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n@@ -9244,1 +9269,0 @@\n-  predicate(!UseAPX);\n@@ -9246,0 +9270,1 @@\n+\n@@ -9265,1 +9290,1 @@\n-instruct cmovI_rReg_rReg_memUCF_ndd(rRegI dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegI src1, memory src2)\n+instruct cmovI_rReg_rReg_memUCFE_ndd(rRegI dst, cmpOpUCFE cop, rFlagsRegUCFE cr, rRegI src1, memory src2)\n@@ -9267,1 +9292,0 @@\n-  predicate(UseAPX);\n@@ -9269,0 +9293,1 @@\n+\n@@ -9270,1 +9295,1 @@\n-  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, int ndd\" %}\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, unsigned, int ndd\" %}\n@@ -9320,1 +9345,0 @@\n-  predicate(!UseAPX);\n@@ -9322,0 +9346,1 @@\n+\n@@ -9342,2 +9367,1 @@\n-instruct cmovN_regUCF_ndd(rRegN dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegN src1, rRegN src2) %{\n-  predicate(UseAPX);\n+instruct cmovN_regUCFE_ndd(rRegN dst, cmpOpUCFE cop, rFlagsRegUCFE cr, rRegN src1, rRegN src2) %{\n@@ -9345,0 +9369,1 @@\n+\n@@ -9346,1 +9371,1 @@\n-  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# unsigned, compressed ptr ndd\" %}\n+  format %{ \"ecmovl$cop $dst, $src1, $src2\\t# signed, unsigned, compressed ptr ndd\" %}\n@@ -9440,1 +9465,0 @@\n-  predicate(!UseAPX);\n@@ -9442,0 +9466,1 @@\n+\n@@ -9448,2 +9473,1 @@\n-instruct cmovP_regUCF_ndd(rRegP dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegP src1, rRegP src2) %{\n-  predicate(UseAPX);\n+instruct cmovP_regUCFE_ndd(rRegP dst, cmpOpUCFE cop, rFlagsRegUCFE cr, rRegP src1, rRegP src2) %{\n@@ -9451,0 +9475,1 @@\n+\n@@ -9452,1 +9477,1 @@\n-  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, ptr ndd\" %}\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, unsigned, ptr ndd\" %}\n@@ -9460,1 +9485,1 @@\n-  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n@@ -9473,15 +9498,0 @@\n-instruct cmovP_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src1, rRegP src2) %{\n-  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n-  match(Set dst (CMoveP (Binary cop cr) (Binary src1 src2)));\n-  effect(TEMP dst);\n-\n-  ins_cost(200);\n-  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n-            \"cmovneq  $dst, $src2\" %}\n-  ins_encode %{\n-    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n-    __ cmovq(Assembler::notEqual, $dst$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n@@ -9491,1 +9501,1 @@\n-  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n@@ -9504,15 +9514,0 @@\n-instruct cmovP_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegP dst, rRegP src1, rRegP src2) %{\n-  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n-  match(Set dst (CMoveP (Binary cop cr) (Binary src2 src1)));\n-  effect(TEMP dst);\n-\n-  ins_cost(200);\n-  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n-            \"cmovneq  $dst, $src2\" %}\n-  ins_encode %{\n-    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n-    __ cmovq(Assembler::notEqual, $dst$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n@@ -9639,0 +9634,14 @@\n+instruct cmovL_imm_01UCFE(rRegL dst, immL1 src, rFlagsRegUCFE cr, cmpOpUCFE cop)\n+%{\n+  predicate(n->in(2)->in(2)->is_Con() && n->in(2)->in(2)->get_long() == 0);\n+  match(Set dst (CMoveL (Binary cop cr) (Binary src dst)));\n+\n+  ins_cost(100); \/\/ XXX\n+  format %{ \"setbn$cop $dst\\t# signed, unsigned, long\" %}\n+  ins_encode %{\n+    Assembler::Condition cond = (Assembler::Condition)($cop$$cmpcode);\n+    __ setb(MacroAssembler::negate_condition(cond), $dst$$Register);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9640,1 +9649,0 @@\n-  predicate(!UseAPX);\n@@ -9642,0 +9650,1 @@\n+\n@@ -9648,1 +9657,1 @@\n-instruct cmovL_regUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, rRegL src2)\n+instruct cmovL_regUCFE_ndd(rRegL dst, cmpOpUCFE cop, rFlagsRegUCFE cr, rRegL src1, rRegL src2)\n@@ -9650,1 +9659,0 @@\n-  predicate(UseAPX);\n@@ -9652,0 +9660,1 @@\n+\n@@ -9653,1 +9662,1 @@\n-  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, unsigned, long ndd\" %}\n@@ -9661,1 +9670,1 @@\n-  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n@@ -9674,15 +9683,0 @@\n-instruct cmovL_regUCF2_ne_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src1, rRegL src2) %{\n-  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::ne);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src1 src2)));\n-  effect(TEMP dst);\n-\n-  ins_cost(200);\n-  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n-            \"cmovneq  $dst, $src2\" %}\n-  ins_encode %{\n-    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n-    __ cmovq(Assembler::notEqual, $dst$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n@@ -9692,1 +9686,1 @@\n-  predicate(!UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n+  predicate(n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n@@ -9705,15 +9699,0 @@\n-instruct cmovL_regUCF2_eq_ndd(cmpOpUCF2 cop, rFlagsRegUCF cr, rRegL dst, rRegL src1, rRegL src2) %{\n-  predicate(UseAPX && n->in(1)->in(1)->as_Bool()->_test._test == BoolTest::eq);\n-  match(Set dst (CMoveL (Binary cop cr) (Binary src2 src1)));\n-  effect(TEMP dst);\n-\n-  ins_cost(200);\n-  format %{ \"ecmovpq  $dst, $src1, $src2\\n\\t\"\n-            \"cmovneq $dst, $src2\" %}\n-  ins_encode %{\n-    __ ecmovq(Assembler::parity, $dst$$Register, $src1$$Register, $src2$$Register);\n-    __ cmovq(Assembler::notEqual, $dst$$Register, $src2$$Register);\n-  %}\n-  ins_pipe(pipe_cmov_reg);\n-%}\n-\n@@ -9734,1 +9713,0 @@\n-  predicate(!UseAPX);\n@@ -9736,0 +9714,1 @@\n+\n@@ -9755,1 +9734,1 @@\n-instruct cmovL_rReg_rReg_memUCF_ndd(rRegL dst, cmpOpUCF cop, rFlagsRegUCF cr, rRegL src1, memory src2)\n+instruct cmovL_rReg_rReg_memUCFE_ndd(rRegL dst, cmpOpUCFE cop, rFlagsRegUCFE cr, rRegL src1, memory src2)\n@@ -9757,1 +9736,0 @@\n-  predicate(UseAPX);\n@@ -9759,0 +9737,1 @@\n+\n@@ -9760,1 +9739,1 @@\n-  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# unsigned, long ndd\" %}\n+  format %{ \"ecmovq$cop $dst, $src1, $src2\\t# signed, unsigned, long ndd\" %}\n@@ -9805,0 +9784,1 @@\n+\n@@ -9811,0 +9791,18 @@\n+instruct cmovF_regUCFE(cmpOpUCFE cop, rFlagsRegUCFE cr, regF dst, regF src)\n+%{\n+  match(Set dst (CMoveF (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"jn$cop    skip\\t# signed, unsigned cmove float\\n\\t\"\n+            \"movss     $dst, $src\\n\"\n+    \"skip:\" %}\n+  ins_encode %{\n+    Label Lskip;\n+    \/\/ Invert sense of branch from sense of CMOV\n+    __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);\n+    __ movflt($dst$$XMMRegister, $src$$XMMRegister);\n+    __ bind(Lskip);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -9849,0 +9847,1 @@\n+\n@@ -9855,0 +9854,18 @@\n+instruct cmovD_regUCFE(cmpOpUCFE cop, rFlagsRegUCFE cr, regD dst, regD src)\n+%{\n+  match(Set dst (CMoveD (Binary cop cr) (Binary dst src)));\n+\n+  ins_cost(200); \/\/ XXX\n+  format %{ \"jn$cop    skip\\t# signed, unsigned cmove double\\n\\t\"\n+            \"movsd     $dst, $src\\n\"\n+    \"skip:\" %}\n+  ins_encode %{\n+    Label Lskip;\n+    \/\/ Invert sense of branch from sense of CMOV\n+    __ jccb((Assembler::Condition)($cop$$cmpcode^1), Lskip);\n+    __ movdbl($dst$$XMMRegister, $src$$XMMRegister);\n+    __ bind(Lskip);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -14322,1 +14339,1 @@\n-instruct cmpF_cc_reg_CF(rFlagsRegUCF cr, regF src1, regF src2) %{\n+instruct cmpF_cc_regCF(rFlagsRegUCF cr, regF src1, regF src2) %{\n@@ -14333,0 +14350,11 @@\n+instruct cmpF_cc_regCFE(rFlagsRegUCFE cr, regF src1, regF src2) %{\n+  match(Set cr (CmpF src1 src2));\n+\n+  ins_cost(100);\n+  format %{ \"vucomxss $src1, $src2\" %}\n+  ins_encode %{\n+    __ vucomxss($src1$$XMMRegister, $src2$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -14344,0 +14372,11 @@\n+instruct cmpF_cc_memCFE(rFlagsRegUCFE cr, regF src1, memory src2) %{\n+  match(Set cr (CmpF src1 (LoadF src2)));\n+\n+  ins_cost(100);\n+  format %{ \"vucomxss $src1, $src2\" %}\n+  ins_encode %{\n+    __ vucomxss($src1$$XMMRegister, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -14346,0 +14385,1 @@\n+\n@@ -14354,0 +14394,11 @@\n+instruct cmpF_cc_immCFE(rFlagsRegUCFE cr, regF src, immF con) %{\n+  match(Set cr (CmpF src con));\n+\n+  ins_cost(100);\n+  format %{ \"vucomxss $src, [$constantaddress]\\t# load from constant table: float=$con\" %}\n+  ins_encode %{\n+    __ vucomxss($src$$XMMRegister, $constantaddress($con));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -14373,1 +14424,1 @@\n-instruct cmpD_cc_reg_CF(rFlagsRegUCF cr, regD src1, regD src2) %{\n+instruct cmpD_cc_regCF(rFlagsRegUCF cr, regD src1, regD src2) %{\n@@ -14384,0 +14435,11 @@\n+instruct cmpD_cc_regCFE(rFlagsRegUCFE cr, regD src1, regD src2) %{\n+  match(Set cr (CmpD src1 src2));\n+\n+  ins_cost(100);\n+  format %{ \"vucomxsd $src1, $src2 test\" %}\n+  ins_encode %{\n+    __ vucomxsd($src1$$XMMRegister, $src2$$XMMRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -14395,0 +14457,11 @@\n+instruct cmpD_cc_memCFE(rFlagsRegUCFE cr, regD src1, memory src2) %{\n+  match(Set cr (CmpD src1 (LoadD src2)));\n+\n+  ins_cost(100);\n+  format %{ \"vucomxsd $src1, $src2\" %}\n+  ins_encode %{\n+    __ vucomxsd($src1$$XMMRegister, $src2$$Address);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -14405,0 +14478,11 @@\n+instruct cmpD_cc_immCFE(rFlagsRegUCFE cr, regD src, immD con) %{\n+  match(Set cr (CmpD src con));\n+\n+  ins_cost(100);\n+  format %{ \"vucomxsd $src, [$constantaddress]\\t# load from constant table: double=$con\" %}\n+  ins_encode %{\n+    __ vucomxsd($src$$XMMRegister, $constantaddress($con));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n@@ -16811,0 +16895,15 @@\n+\/\/ Jump Direct Conditional - using signed and unsigned comparison\n+instruct jmpConUCFE(cmpOpUCFE cop, rFlagsRegUCFE cmp, label labl) %{\n+  match(If cop cmp);\n+  effect(USE labl);\n+\n+  ins_cost(200);\n+  format %{ \"j$cop,su   $labl\" %}\n+  size(6);\n+  ins_encode %{\n+    Label* L = $labl$$label;\n+    __ jcc((Assembler::Condition)($cop$$cmpcode), *L, false); \/\/ Always long jump\n+  %}\n+  ins_pipe(pipe_jcc);\n+%}\n+\n@@ -17029,0 +17128,16 @@\n+\/\/ Jump Direct Conditional - using signed and unsigned comparison\n+instruct jmpConUCFE_short(cmpOpUCFE cop, rFlagsRegUCFE cmp, label labl) %{\n+  match(If cop cmp);\n+  effect(USE labl);\n+\n+  ins_cost(300);\n+  format %{ \"j$cop,sus  $labl\" %}\n+  size(2);\n+  ins_encode %{\n+    Label* L = $labl$$label;\n+    __ jccb((Assembler::Condition)($cop$$cmpcode), *L);\n+  %}\n+  ins_pipe(pipe_jcc);\n+  ins_short_branch(1);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":251,"deletions":136,"binary":false,"changes":387,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,3 @@\n-    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_CMOVEL_IMM01, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.X86_CMOVEL_IMM01, \"1\"},\n+        applyIfPlatform = {\"x64\", \"true\"},\n+        phase = CompilePhase.FINAL_CODE)\n@@ -48,1 +50,3 @@\n-    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_CMOVEL_IMM01U, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.X86_CMOVEL_IMM01U, \"1\"},\n+        applyIfPlatform = {\"x64\", \"true\"},\n+        phase = CompilePhase.FINAL_CODE)\n@@ -54,1 +58,8 @@\n-    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_CMOVEL_IMM01UCF, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.X86_CMOVEL_IMM01UCF, \"1\"},\n+        applyIfPlatform = {\"x64\", \"true\"},\n+        applyIfCPUFeatureOr = {\"apx_f\", \"false\", \"avx10_2\", \"false\"},\n+        phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = {IRNode.X86_CMOVEL_IMM01UCFE, \"1\"},\n+        applyIfPlatform = {\"x64\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"apx_f\", \"true\", \"avx10_2\", \"true\"},\n+        phase = CompilePhase.FINAL_CODE)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/CMoveLConstants.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -3083,0 +3083,5 @@\n+    public static final String X86_CMOVEL_IMM01UCFE = PREFIX + \"X86_CMOVEL_IMM01UCFE\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_CMOVEL_IMM01UCFE, \"cmovL_imm_01UCFE\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -113,0 +113,2 @@\n+        \/\/ Intel APX\n+        \"apx_f\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/ApplicableIRRulesPrinter.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-@Measurement(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 5)\n@@ -78,0 +78,5 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    static int callI() {\n+        return 1;\n+    }\n+\n@@ -79,1 +84,1 @@\n-    public void isNanFloat() {\n+    public void cMoveIsNanFloat() {\n@@ -86,1 +91,1 @@\n-    public void isNanDouble() {\n+    public void cMoveIsNanDouble() {\n@@ -93,1 +98,1 @@\n-    public void isInfiniteFloat() {\n+    public void cMoveIsInfiniteFloat() {\n@@ -100,1 +105,1 @@\n-    public void isInfiniteDouble() {\n+    public void cMoveIsInfiniteDouble() {\n@@ -107,1 +112,1 @@\n-    public void isFiniteFloat() {\n+    public void cMoveIsFiniteFloat() {\n@@ -114,1 +119,1 @@\n-    public void isFiniteDouble() {\n+    public void cMoveIsFiniteDouble() {\n@@ -121,1 +126,1 @@\n-    public void equalFloat() {\n+    public void cMoveEqualFloat() {\n@@ -128,1 +133,1 @@\n-    public void equalDouble() {\n+    public void cMoveEqualDouble() {\n@@ -135,1 +140,1 @@\n-    public void lessFloat() {\n+    public void cMoveLessFloat() {\n@@ -142,1 +147,1 @@\n-    public void lessDouble() {\n+    public void cMoveLessDouble() {\n@@ -149,1 +154,1 @@\n-    public void lessEqualFloat() {\n+    public void cMoveLessEqualFloat() {\n@@ -156,1 +161,1 @@\n-    public void lessEqualDouble() {\n+    public void cMoveLessEqualDouble() {\n@@ -163,1 +168,1 @@\n-    public void greaterFloat() {\n+    public void cMoveGreaterFloat() {\n@@ -170,1 +175,1 @@\n-    public void greaterDouble() {\n+    public void cMoveGreaterDouble() {\n@@ -177,1 +182,1 @@\n-    public void greaterEqualFloat() {\n+    public void cMoveGreaterEqualFloat() {\n@@ -184,1 +189,1 @@\n-    public void greaterEqualDouble() {\n+    public void cMoveGreaterEqualDouble() {\n@@ -190,0 +195,112 @@\n+    @Benchmark\n+    public void branchIsNanFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Float.isNaN(f1[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchIsNanDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Double.isNaN(d1[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchIsInfiniteFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Float.isInfinite(f1[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchIsInfiniteDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Double.isInfinite(d1[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchIsFiniteFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Float.isFinite(f1[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchIsFiniteDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = Double.isFinite(d1[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchEqualFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (f1[i] == f2[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchEqualDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (d1[i] == d2[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (f1[i] < f2[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (d1[i] < d2[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessEqualFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (f1[i] <= f2[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessEqualDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (d1[i] <= d2[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (f1[i] > f2[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (d1[i] > d2[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterEqualFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (f1[i] >= f2[i]) ? callI() : 2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterEqualDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            res[i] = (d1[i] >= d2[i]) ? callI() : 2;\n+        }\n+    }\n+\n@@ -192,0 +309,5 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    static long callL() {\n+        return Long.MAX_VALUE;\n+    }\n+\n@@ -193,1 +315,1 @@\n-    public void equalFloatResLong() {\n+    public void cMoveEqualFloatResLong() {\n@@ -200,1 +322,1 @@\n-    public void equalDoubleResLong() {\n+    public void cMoveEqualDoubleResLong() {\n@@ -207,1 +329,1 @@\n-    public void lessFloatResLong() {\n+    public void cMoveLessFloatResLong() {\n@@ -214,1 +336,1 @@\n-    public void lessDoubleResLong() {\n+    public void cMoveLessDoubleResLong() {\n@@ -221,1 +343,1 @@\n-    public void lessEqualFloatResLong() {\n+    public void cMoveLessEqualFloatResLong() {\n@@ -228,1 +350,1 @@\n-    public void lessEqualDoubleResLong() {\n+    public void cMoveLessEqualDoubleResLong() {\n@@ -235,1 +357,1 @@\n-    public void greaterFloatResLong() {\n+    public void cMoveGreaterFloatResLong() {\n@@ -242,1 +364,1 @@\n-    public void greaterDoubleResLong() {\n+    public void cMoveGreaterDoubleResLong() {\n@@ -249,1 +371,1 @@\n-    public void greaterEqualFloatResLong() {\n+    public void cMoveGreaterEqualFloatResLong() {\n@@ -256,1 +378,1 @@\n-    public void greaterEqualDoubleResLong() {\n+    public void cMoveGreaterEqualDoubleResLong() {\n@@ -262,0 +384,70 @@\n+    @Benchmark\n+    public void branchEqualFloatResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (f1[i] == f2[i]) ? callL() : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchEqualDoubleResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (d1[i] == d2[i]) ? callL() : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessFloatResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (f1[i] < f2[i]) ? callL() : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessDoubleResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (d1[i] < d2[i]) ? callL() : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessEqualFloatResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (f1[i] <= f2[i]) ? callL() : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessEqualDoubleResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (d1[i] <= d2[i]) ? callL() : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterFloatResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (f1[i] > f2[i]) ? callL() : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterDoubleResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (d1[i] > d2[i]) ? callL() : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterEqualFloatResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (f1[i] >= f2[i]) ? callL() : Long.MIN_VALUE;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterEqualDoubleResLong() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resLong[i] = (d1[i] >= d2[i]) ? callL() : Long.MIN_VALUE;\n+        }\n+    }\n+\n@@ -264,0 +456,5 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    static float callF() {\n+        return 0.1f;\n+    }\n+\n@@ -265,1 +462,1 @@\n-    public void equalFloatResFloat() {\n+    public void cMoveEqualFloatResFloat() {\n@@ -272,1 +469,1 @@\n-    public void equalDoubleResFloat() {\n+    public void cMoveEqualDoubleResFloat() {\n@@ -279,1 +476,1 @@\n-    public void lessFloatResFloat() {\n+    public void cMoveLessFloatResFloat() {\n@@ -286,1 +483,1 @@\n-    public void lessDoubleResFloat() {\n+    public void cMoveLessDoubleResFloat() {\n@@ -293,1 +490,1 @@\n-    public void lessEqualFloatResFloat() {\n+    public void cMoveLessEqualFloatResFloat() {\n@@ -300,1 +497,1 @@\n-    public void lessEqualDoubleResFloat() {\n+    public void cMoveLessEqualDoubleResFloat() {\n@@ -307,1 +504,1 @@\n-    public void greaterFloatResFloat() {\n+    public void cMoveGreaterFloatResFloat() {\n@@ -314,1 +511,1 @@\n-    public void greaterDoubleResFloat() {\n+    public void cMoveGreaterDoubleResFloat() {\n@@ -321,1 +518,1 @@\n-    public void greaterEqualFloatResFloat() {\n+    public void cMoveGreaterEqualFloatResFloat() {\n@@ -328,1 +525,1 @@\n-    public void greaterEqualDoubleResFloat() {\n+    public void cMoveGreaterEqualDoubleResFloat() {\n@@ -334,0 +531,70 @@\n+    @Benchmark\n+    public void branchEqualFloatResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (f1[i] == f2[i]) ? callF() : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchEqualDoubleResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (d1[i] == d2[i]) ? callF() : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessFloatResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (f1[i] < f2[i]) ? callF() : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessDoubleResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (d1[i] < d2[i]) ? callF() : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessEqualFloatResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (f1[i] <= f2[i]) ? callF() : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessEqualDoubleResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (d1[i] <= d2[i]) ? callF() : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterFloatResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (f1[i] > f2[i]) ? callF() : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterDoubleResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (d1[i] > d2[i]) ? callF() : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterEqualFloatResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (f1[i] >= f2[i]) ? callF() : 0.2f;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterEqualDoubleResFloat() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resFloat[i] = (d1[i] >= d2[i]) ? callF() : 0.2f;\n+        }\n+    }\n+\n@@ -336,0 +603,5 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    static double callD() {\n+        return 0.1;\n+    }\n+\n@@ -337,1 +609,1 @@\n-    public void equalFloatResDouble() {\n+    public void cMoveEqualFloatResDouble() {\n@@ -344,1 +616,1 @@\n-    public void equalDoubleResDouble() {\n+    public void cMoveEqualDoubleResDouble() {\n@@ -351,1 +623,1 @@\n-    public void lessFloatResDouble() {\n+    public void cMoveLessFloatResDouble() {\n@@ -358,1 +630,1 @@\n-    public void lessDoubleResDouble() {\n+    public void cMoveLessDoubleResDouble() {\n@@ -365,1 +637,1 @@\n-    public void lessEqualFloatResDouble() {\n+    public void cMoveLessEqualFloatResDouble() {\n@@ -372,1 +644,1 @@\n-    public void lessEqualDoubleResDouble() {\n+    public void cMoveLessEqualDoubleResDouble() {\n@@ -379,1 +651,1 @@\n-    public void greaterFloatResDouble() {\n+    public void cMoveGreaterFloatResDouble() {\n@@ -386,1 +658,1 @@\n-    public void greaterDoubleResDouble() {\n+    public void cMoveGreaterDoubleResDouble() {\n@@ -393,1 +665,1 @@\n-    public void greaterEqualFloatResDouble() {\n+    public void cMoveGreaterEqualFloatResDouble() {\n@@ -400,1 +672,1 @@\n-    public void greaterEqualDoubleResDouble() {\n+    public void cMoveGreaterEqualDoubleResDouble() {\n@@ -405,0 +677,70 @@\n+\n+    @Benchmark\n+    public void branchEqualFloatResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (f1[i] == f2[i]) ? callD() : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchEqualDoubleResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (d1[i] == d2[i]) ? callD() : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessFloatResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (f1[i] < f2[i]) ? callD() : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessDoubleResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (d1[i] < d2[i]) ? callD() : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessEqualFloatResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (f1[i] <= f2[i]) ? callD() : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchLessEqualDoubleResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (d1[i] <= d2[i]) ? callD() : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterFloatResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (f1[i] > f2[i]) ? callD() : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterDoubleResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (d1[i] > d2[i]) ? callD() : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterEqualFloatResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (f1[i] >= f2[i]) ? callD() : 0.2;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void branchGreaterEqualDoubleResDouble() {\n+        for (int i = 0; i < INVOCATIONS; i++) {\n+            resDouble[i] = (d1[i] >= d2[i]) ? callD() : 0.2;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/FPComparison.java","additions":390,"deletions":48,"binary":false,"changes":438,"status":"modified"}]}