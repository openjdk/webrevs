{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -353,1 +353,4 @@\n-        output.shouldBeEmptyIgnoreVMWarnings();\n+        List<String> stdout = output.asLinesWithoutVMWarnings();\n+        output.reportDiagnosticSummary();\n+        assertEquals(stdout.size(), 1, \"Output should contain one line\");\n+        assertTrue(stdout.get(0).startsWith(\"jstatd started\"), \"List should start with 'jstatd started'\");\n","filename":"test\/jdk\/sun\/tools\/jstatd\/JstatdTest.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Unit test for ProcessTools.startProcess()\n+ * @library \/test\/lib\n+ * @compile ProcessToolsStartProcessTest.java\n+ * @run main ProcessToolsStartProcessTest\n+ *\/\n+\n+import java.util.function.Consumer;\n+import java.io.File;\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ProcessToolsStartProcessTest {\n+    static final int NUM_LINES = 50;\n+    static String output = \"\";\n+\n+    private static Consumer<String> outputConsumer = s -> {\n+        output += s + \"\\n\";\n+    };\n+\n+    static boolean testStartProcess(boolean withConsumer) throws Exception {\n+        boolean success = true;\n+        Process p;\n+        JDKToolLauncher launcher = JDKToolLauncher.createUsingTestJDK(\"java\");\n+        launcher.addToolArg(\"-cp\");\n+        launcher.addToolArg(Utils.TEST_CLASSES);\n+        launcher.addToolArg(\"ProcessToolsStartProcessTest\");\n+        launcher.addToolArg(\"test\"); \/\/ This one argument triggers producing the output\n+        ProcessBuilder pb = new ProcessBuilder();\n+        pb.command(launcher.getCommand());\n+\n+        System.out.println(\"DEBUG: Test with withConsumer=\" + withConsumer);\n+        System.out.println(\"DEBUG: about to start process.\");\n+        if (withConsumer) {\n+            p = ProcessTools.startProcess(\"java\", pb, outputConsumer);\n+        } else {\n+            p = ProcessTools.startProcess(\"java\", pb);\n+        }\n+        OutputAnalyzer out = new OutputAnalyzer(p);\n+\n+        System.out.println(\"DEBUG: process started.\");\n+        p.waitFor();\n+        if (p.exitValue() != 0) {\n+            throw new RuntimeException(\"Bad exit value: \" + p.exitValue());\n+        }\n+\n+        if (withConsumer) {\n+            int numLines = output.split(\"\\n\").length;\n+            if (numLines != NUM_LINES ) {\n+                System.out.print(\"FAILED: wrong number of lines in Consumer output\\n\");\n+                success = false;\n+            }\n+            System.out.println(\"DEBUG: Consumer output: got \" + numLines + \" lines , expected \"\n+                               + NUM_LINES  + \". Output follow:\");\n+            System.out.print(output);\n+            System.out.println(\"DEBUG: done with Consumer output.\");\n+        }\n+\n+        int numLinesOut = out.getStdout().split(\"\\n\").length;\n+        if (numLinesOut != NUM_LINES) {\n+            System.out.print(\"FAILED: wrong number of lines in OutputAnalyzer output\\n\");\n+            success = false;\n+        }\n+        System.out.println(\"DEBUG: OutputAnalyzer output: got \" + numLinesOut + \" lines, expected \"\n+                           + NUM_LINES  + \". Output follows:\");\n+        System.out.print(out.getStdout());\n+        System.out.println(\"DEBUG: done with OutputAnalyzer stdout.\");\n+\n+        return success;\n+    }\n+\n+    public static void main(String[] args) {\n+        if (args.length > 0) {\n+            for (int i = 0; i < NUM_LINES; i++) {\n+                System.out.println(\"A line on stdout \" + i);\n+            }\n+        } else {\n+            try {\n+                boolean test1Result = testStartProcess(false);\n+                boolean test2Result = testStartProcess(true);\n+                if (!test1Result || !test2Result) {\n+                    throw new RuntimeException(\"One or more tests failed. See output for details.\");\n+                }\n+            } catch (RuntimeException re) {\n+                re.printStackTrace();\n+                System.out.println(\"Test ERROR\");\n+                throw re;\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+                System.out.println(\"Test ERROR\");\n+                throw new RuntimeException(ex);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/process\/ProcessToolsStartProcessTest.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import java.io.ByteArrayOutputStream;\n@@ -74,1 +75,0 @@\n-\n@@ -81,1 +81,5 @@\n-     *\n+     * <p>\n+     * Same as\n+     * {@linkplain #startProcess(String, ProcessBuilder, Consumer, Predicate, long, TimeUnit) startProcess}\n+     * {@code (name, processBuilder, null, null, -1, TimeUnit.NANOSECONDS)}\n+     * <\/p>\n@@ -96,1 +100,5 @@\n-     * <p>It is possible to monitor the in-streams via the provided {@code consumer}\n+     * <p>\n+     * Same as\n+     * {@linkplain #startProcess(String, ProcessBuilder, Consumer, Predicate, long, TimeUnit) startProcess}\n+     * {@code (name, processBuilder, consumer, null, -1, TimeUnit.NANOSECONDS)}\n+     * <\/p>\n@@ -99,1 +107,0 @@\n-     * @param consumer       {@linkplain Consumer} instance to process the in-streams\n@@ -101,0 +108,1 @@\n+     * @param consumer       {@linkplain Consumer} instance to process the in-streams\n@@ -121,2 +129,3 @@\n-     * It is possible to wait for the process to get to a warmed-up state\n-     * via {@linkplain Predicate} condition on the STDOUT\/STDERR\n+     * Same as\n+     * {@linkplain #startProcess(String, ProcessBuilder, Consumer, Predicate, long, TimeUnit) startProcess}\n+     * {@code (name, processBuilder, null, linePredicate, timeout, unit)}\n@@ -147,0 +156,52 @@\n+\n+    \/*\n+        BufferOutputStream and BufferInputStream allow to re-use p.getInputStream() amd p.getOutputStream() of\n+        processes started with ProcessTools.startProcess(...).\n+        Implementation cashes ALL process output and allow to read it through InputStream.\n+     *\/\n+    private static class BufferOutputStream extends ByteArrayOutputStream {\n+        private int current = 0;\n+        final private Process p;\n+\n+        public BufferOutputStream(Process p) {\n+            this.p = p;\n+        }\n+\n+        synchronized int readNext() {\n+            if (current > count) {\n+                throw new RuntimeException(\"Shouldn't ever happen.  start: \"\n+                        + current + \" count: \" + count + \" buffer: \" + this);\n+            }\n+            while (current == count) {\n+                if (!p.isAlive()) {\n+                    return -1;\n+                }\n+                try {\n+                    wait(1);\n+                } catch (InterruptedException ie) {\n+                    return -1;\n+                }\n+            }\n+            return this.buf[current++];\n+        }\n+    }\n+\n+    private static class BufferInputStream extends InputStream {\n+\n+        private final BufferOutputStream buffer;\n+\n+        public BufferInputStream(Process p) {\n+            buffer = new BufferOutputStream(p);\n+        }\n+\n+        OutputStream getOutputStream() {\n+            return buffer;\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            return buffer.readNext();\n+        }\n+    }\n+\n+\n@@ -184,0 +245,6 @@\n+        BufferInputStream stdOut = new BufferInputStream(p);\n+        BufferInputStream stdErr = new BufferInputStream(p);\n+\n+        stdout.addOutputStream(stdOut.getOutputStream());\n+        stderr.addOutputStream(stdErr.getOutputStream());\n+\n@@ -253,1 +320,1 @@\n-        return new ProcessImpl(p, stdoutTask, stderrTask);\n+        return new ProcessImpl(p, stdoutTask, stderrTask, stdOut, stdErr);\n@@ -704,0 +771,2 @@\n+        private final InputStream stdOut;\n+        private final InputStream stdErr;\n@@ -708,1 +777,2 @@\n-        public ProcessImpl(Process p, Future<Void> stdoutTask, Future<Void> stderrTask) {\n+        public ProcessImpl(Process p, Future<Void> stdoutTask, Future<Void> stderrTask,\n+                           InputStream stdOut, InputStream etdErr) {\n@@ -712,0 +782,2 @@\n+            this.stdOut = stdOut;\n+            this.stdErr = etdErr;\n@@ -721,1 +793,1 @@\n-            return p.getInputStream();\n+            return stdOut;\n@@ -726,1 +798,1 @@\n-            return p.getErrorStream();\n+            return stdErr;\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":82,"deletions":10,"binary":false,"changes":92,"status":"modified"}]}