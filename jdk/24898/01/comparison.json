{"files":[{"patch":"@@ -2592,3 +2592,5 @@\n-        if (signum == 0) {\n-            return (exponent == 0 ? ONE : this);\n-        }\n+        if (exponent == 0 || this.equals(ONE))\n+            return ONE;\n+\n+        if (signum == 0)\n+            return ZERO;\n@@ -2596,1 +2598,1 @@\n-        BigInteger partToSquare = this.abs();\n+        BigInteger base = this.abs();\n@@ -2602,1 +2604,1 @@\n-        int powersOfTwo = partToSquare.getLowestSetBit();\n+        int powersOfTwo = base.getLowestSetBit();\n@@ -2613,2 +2615,2 @@\n-            partToSquare = partToSquare.shiftRight(powersOfTwo);\n-            remainingBits = partToSquare.bitLength();\n+            base = base.shiftRight(powersOfTwo);\n+            remainingBits = base.bitLength();\n@@ -2623,1 +2625,1 @@\n-            remainingBits = partToSquare.bitLength();\n+            remainingBits = base.bitLength();\n@@ -2640,1 +2642,1 @@\n-        if (partToSquare.mag.length == 1 && scaleFactor <= 62) {\n+        if (base.mag.length == 1 && scaleFactor <= 62) {\n@@ -2643,15 +2645,1 @@\n-            long result = 1;\n-            long baseToPow2 = partToSquare.mag[0] & LONG_MASK;\n-\n-            int workingExponent = exponent;\n-\n-            \/\/ Perform exponentiation using repeated squaring trick\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    result = result * baseToPow2;\n-                }\n-\n-                if ((workingExponent >>>= 1) != 0) {\n-                    baseToPow2 = baseToPow2 * baseToPow2;\n-                }\n-            }\n+            long result = unsignedLongPow(base.mag[0] & LONG_MASK, exponent);\n@@ -2675,1 +2663,1 @@\n-            \/\/ the algorithm above, but calls multiply() and square()\n+            \/\/ the algorithm above, but calls multiply()\n@@ -2677,1 +2665,5 @@\n-            BigInteger answer = ONE;\n+            BigInteger answer;\n+            if (base.mag.length == 1) {\n+                answer = unsignedIntPow(base.mag[0], exponent);\n+            } else {\n+                answer = ONE;\n@@ -2679,6 +2671,7 @@\n-            int workingExponent = exponent;\n-            \/\/ Perform exponentiation using repeated squaring trick\n-            while (workingExponent != 0) {\n-                if ((workingExponent & 1) == 1) {\n-                    answer = answer.multiply(partToSquare);\n-                }\n+                final int expZeros = Integer.numberOfLeadingZeros(exponent);\n+                int workingExp = exponent << expZeros;\n+                \/\/ Perform exponentiation using repeated squaring trick\n+                for (int expLen = Integer.SIZE - expZeros; expLen > 0; expLen--) {\n+                    answer = answer.multiply(answer);\n+                    if (workingExp < 0) \/\/ leading bit is set\n+                        answer = answer.multiply(base);\n@@ -2686,2 +2679,1 @@\n-                if ((workingExponent >>>= 1) != 0) {\n-                    partToSquare = partToSquare.square();\n+                    workingExp <<= 1;\n@@ -2690,0 +2682,1 @@\n+\n@@ -2704,0 +2697,124 @@\n+    \/**\n+     * Computes {@code x^n} using repeated squaring trick.\n+     * Assumes {@code x != 0}.\n+     *\/\n+    private static BigInteger unsignedIntPow(int x, int n) {\n+        if (x == 1)\n+            return ONE;\n+        \/\/ Double.PRECISION \/ bitLength(x) is the largest integer e\n+        \/\/ such that x^e fits into a double. If e <= 2, we won't use fp arithmetic.\n+        \/\/ This allows to use fp arithmetic where possible.\n+        final int maxExp = Math.max(2, Double.PRECISION \/ bitLengthForInt(x));\n+        final int maxExpLen = bitLengthForInt(maxExp);\n+        final BigInteger[] powerCache = new BigInteger[1 << maxExpLen];\n+\n+        final int nZeros = Integer.numberOfLeadingZeros(n);\n+        n <<= nZeros;\n+\n+        BigInteger pow = ONE;\n+        int blockLen;\n+        for (int nLen = Integer.SIZE - nZeros; nLen > 0; nLen -= blockLen) {\n+            blockLen = maxExpLen < nLen ? maxExpLen : nLen;\n+            \/\/ compute pow^(2^blockLen)\n+            if (!pow.equals(ONE)) {\n+                for (int i = 0; i < blockLen; i++)\n+                    pow = pow.multiply(pow);\n+            }\n+\n+            \/\/ add exp to power's exponent\n+            int exp = n >>> -blockLen;\n+            if (exp > 0) {\n+                BigInteger xToExp = powerCache[exp];\n+                if (xToExp == null) {\n+                    \/\/ adjust exp to fit x^expAdj into a double\n+                    int expAdj = exp <= maxExp ? exp : exp >>> 1;\n+\n+                    long xLong = x & LONG_MASK;\n+                    \/\/ don't use fp arithmetic if expAdj <= 2\n+                    long xToExpAdj = expAdj == 1 ? xLong :\n+                                    (expAdj == 2 ? xLong*xLong : (long) Math.pow(xLong, expAdj));\n+\n+                    xToExp = new BigInteger(1, new int[] { (int) (xToExpAdj >>> 32), (int) xToExpAdj });\n+                    powerCache[expAdj] = xToExp;\n+                    \/\/ append exp's rightmost bit to expAdj\n+                    if (expAdj != exp) {\n+                        xToExp = xToExp.multiply(xToExp);\n+                        powerCache[expAdj << 1] = xToExp;\n+\n+                        if ((exp & 1) == 1) {\n+                            xToExp = xToExp.multiply(xLong);\n+                            powerCache[exp] = xToExp;\n+                        }\n+                    }\n+                }\n+                pow = pow.multiply(xToExp);\n+            }\n+            n <<= blockLen; \/\/ shift to next block of bits\n+        }\n+\n+        return pow;\n+    }\n+\n+    \/**\n+     * Computes {@code x^n} using repeated squaring trick.\n+     * Assumes {@code x != 0 && x^n < 2^Long.SIZE}.\n+     *\/\n+    static long unsignedLongPow(long x, int n) {\n+        if (x == 1L)\n+            return 1L;\n+\n+        if (x == 2L)\n+            return 1L << n;\n+        \/\/ Double.PRECISION \/ bitLength(x) is the largest integer e\n+        \/\/ such that x^e fits into a double. If e <= 3, we won't use fp arithmetic.\n+        \/\/ This allows to use fp arithmetic where possible.\n+        final int maxExp = Math.max(3, Double.PRECISION \/ bitLengthForLong(x));\n+        final int maxExpLen = bitLengthForInt(maxExp);\n+        final long[] powerCache = new long[1 << maxExpLen];\n+\n+        final int nZeros = Integer.numberOfLeadingZeros(n);\n+        n <<= nZeros;\n+\n+        long pow = 1L;\n+        int blockLen;\n+        for (int nLen = Integer.SIZE - nZeros; nLen > 0; nLen -= blockLen) {\n+            blockLen = maxExpLen < nLen ? maxExpLen : nLen;\n+            \/\/ compute pow^(2^blockLen)\n+            if (pow != 1L) {\n+                for (int i = 0; i < blockLen; i++)\n+                    pow *= pow;\n+            }\n+\n+            \/\/ add exp to power's exponent\n+            int exp = n >>> -blockLen;\n+            if (exp > 0) {\n+                long xToExp = powerCache[exp];\n+                if (xToExp == 0) {\n+                    \/\/ adjust exp to fit x^expAdj into a double\n+                    int expAdj = exp <= maxExp ? exp : exp >>> 1;\n+\n+                    \/\/ don't use fp arithmetic if expAdj <= 3\n+                    xToExp = expAdj == 1 ? x :\n+                            (expAdj == 2 ? x*x :\n+                            (expAdj == 3 ? x*x*x : (long) Math.pow(x, expAdj)));\n+                    powerCache[expAdj] = xToExp;\n+\n+                    \/\/ append exp's rightmost bit to expAdj\n+                    if (expAdj != exp) {\n+                        xToExp *= xToExp;\n+                        powerCache[expAdj << 1] = xToExp;\n+\n+                        if ((exp & 1) == 1) {\n+                            xToExp *= x;\n+                            powerCache[exp] = xToExp;\n+                        }\n+                    }\n+                }\n+                pow *= xToExp;\n+            }\n+            n <<= blockLen; \/\/ shift to next block of bits\n+        }\n+\n+        return pow;\n+    }\n+\n@@ -2753,0 +2870,74 @@\n+    \/**\n+     * Returns the integer {@code n}th root of this BigInteger. The integer\n+     * {@code n}th root of the corresponding mathematical integer {@code x} has the\n+     * same sign of {@code x}, and its magnitude is the largest integer {@code r}\n+     * such that {@code r**n <= abs(x)}. It is equal to the value of\n+     * {@code (x.signum() * floor(abs(nthRoot(x, n))))}, where {@code nthRoot(x, n)}\n+     * denotes the real {@code n}th root of {@code x} treated as a real. If {@code n}\n+     * is even and this BigInteger is negative, an {@code ArithmeticException} will be\n+     * thrown.\n+     *\n+     * <p>Note that the magnitude of the integer {@code n}th root will be less than\n+     * the magnitude of the real {@code n}th root if the latter is not representable\n+     * as an integral value.\n+     *\n+     * @param n the root degree\n+     * @return the integer {@code n}th root of {@code this}\n+     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n+     *                             defined.)\n+     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n+     *                             operation to yield a non-integer value.)\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is\n+     *                             negative. (This would cause the operation to\n+     *                             yield non-real roots.)\n+     * @see #sqrt()\n+     * @since 25\n+     *\/\n+    public BigInteger nthRoot(int n) {\n+        if (n == 1)\n+            return this;\n+\n+        if (n == 2)\n+            return sqrt();\n+\n+        if (n <= 0)\n+            throw new ArithmeticException(\"Non-positive root degree\");\n+\n+        if ((n & 1) == 0 && this.signum < 0)\n+            throw new ArithmeticException(\"Negative radicand with even root degree\");\n+\n+        return new MutableBigInteger(this.mag).nthRoot(n).toBigInteger(signum);\n+    }\n+\n+    \/**\n+     * Returns an array of two BigIntegers containing the integer {@code n}th root\n+     * {@code r} of {@code this} and its remainder {@code this - r^n},\n+     * respectively.\n+     *\n+     * @param n the root degree\n+     * @return an array of two BigIntegers with the integer {@code n}th root at\n+     *         offset 0 and the remainder at offset 1\n+     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n+     *                             defined.)\n+     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n+     *                             operation to yield a non-integer value.)\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is\n+     *                             negative. (This would cause the operation to\n+     *                             yield non-real roots.)\n+     * @see #sqrt()\n+     * @see #sqrtAndRemainder()\n+     * @see #nthRoot(int)\n+     * @since 25\n+     *\/\n+    public BigInteger[] nthRootAndRemainder(int n) {\n+        if (n == 1)\n+            return new BigInteger[] { this, ZERO };\n+\n+        if (n == 2)\n+            return sqrtAndRemainder();\n+\n+        BigInteger root = nthRoot(n), rem = this.subtract(root.pow(n));\n+        assert rem.signum == 0 || rem.signum == this.signum;\n+        return new BigInteger[] { root, rem };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":225,"deletions":34,"binary":false,"changes":259,"status":"modified"},{"patch":"@@ -161,0 +161,21 @@\n+    \/**\n+     * Returns a MutableBigInteger with a magnitude specified by\n+     * the absolute value of the double val. Any fractional part is discarded.\n+     *\n+     * Assume val is in the finite double range.\n+     *\/\n+    static MutableBigInteger valueOf(double val) {\n+        val = Math.abs(val);\n+        if (val < 0x1p63)\n+            return new MutableBigInteger((long) val);\n+        \/\/ Translate the double into exponent and significand, according\n+        \/\/ to the formulae in JLS, Section 20.10.22.\n+        long valBits = Double.doubleToRawLongBits(val);\n+        int exponent = (int) ((valBits >> 52) & 0x7ffL) - 1075;\n+        long significand = (valBits & ((1L << 52) - 1)) | (1L << 52);\n+        \/\/ At this point, val == significand * 2^exponent, with exponent > 0\n+        MutableBigInteger result = new MutableBigInteger(significand);\n+        result.leftShift(exponent);\n+        return result;\n+    }\n+\n@@ -1895,0 +1916,115 @@\n+    \/**\n+     * Calculate the integer {@code n}th root {@code floor(nthRoot(this, n))} where\n+     * {@code nthRoot(., n)} denotes the mathematical {@code n}th root. The contents of\n+     * {@code this} are <b>not<\/b> changed. The value of {@code this} is assumed\n+     * to be non-negative and the root degree {@code n >= 3}.\n+     *\n+     * @implNote The implementation is based on the material in Richard P. Brent\n+     * and Paul Zimmermann, <a href=\"https:\/\/maths-people.anu.edu.au\/~brent\/pd\/mca-cup-0.5.9.pdf\">\n+     * Modern Computer Arithmetic<\/a>, 27-28.\n+     *\n+     * @return the integer {@code n}th of {@code this}\n+     *\/\n+    MutableBigInteger nthRoot(int n) {\n+        \/\/ Special cases.\n+        if (this.isZero() || this.isOne())\n+            return this;\n+\n+        final int bitLength = (int) this.bitLength();\n+        \/\/ if this < 2^n, result is unity\n+        if (bitLength <= n) {\n+            MutableBigInteger rem = new MutableBigInteger(this);\n+            rem.subtract(ONE);\n+            return new MutableBigInteger(1);\n+        }\n+\n+        MutableBigInteger r;\n+        long shift = 0L;\n+        if (bitLength <= Long.SIZE) {\n+            \/\/ Initial estimate is the root of the unsigned long value.\n+            final long x = this.toLong();\n+            \/\/ Use fp arithmetic to get an upper bound of the root\n+            final double rad = Math.nextUp(x >= 0 ? x : x + 0x1p64);\n+            final double approx = n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n));\n+            long rLong = (long) Math.ceil(Math.nextUp(approx));\n+\n+            if (BigInteger.bitLengthForLong(rLong) * (n - 1) <= Long.SIZE) {\n+                \/\/ Refine the estimate.\n+                long r1 = rLong;\n+                do {\n+                    rLong = r1;\n+                    long rToN1 = BigInteger.unsignedLongPow(rLong, n - 1);\n+                    r1 = ((n - 1) * rLong + x \/ rToN1) \/ n;\n+                } while (r1 < rLong); \/\/ Terminate when non-decreasing.\n+\n+                return new MutableBigInteger(rLong);\n+            } else { \/\/ r^(n - 1) could overflow long range, use MutableBigInteger loop instead\n+                r = new MutableBigInteger(rLong);\n+            }\n+        } else {\n+            \/\/ Set up the initial estimate of the iteration.\n+            \/\/ Determine a right shift that is a multiple of n into finite double range.\n+            double rad;\n+            if (bitLength > Double.MAX_EXPONENT) {\n+                shift = bitLength - Double.MAX_EXPONENT;\n+                int shiftExcess = (int) (shift % n);\n+\n+                \/\/ Shift the value into finite double range\n+                rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n+                \/\/ Complete the shift to a multiple of n,\n+                \/\/ avoiding to lose more bits than necessary.\n+                if (shiftExcess != 0) {\n+                    int shiftLack = n - shiftExcess;\n+                    shift += shiftLack; \/\/ shift is long, no overflow\n+                    rad \/= Double.valueOf(\"0x1p\" + shiftLack);\n+                }\n+            } else {\n+                rad = this.toBigInteger().doubleValue();\n+            }\n+\n+            \/\/ Use the root of the shifted value as an estimate.\n+            rad = Math.nextUp(rad);\n+            final double approx = n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n));\n+            r = valueOf(Math.ceil(Math.nextUp(approx)));\n+        }\n+\n+        \/\/ Refine the estimate, avoiding to compute non-significant bits\n+        final int trailingZeros = this.getLowestSetBit();\n+        int rootShift = (int) (shift \/ n);\n+        for (int rootBits = (int) r.bitLength(); rootShift >= rootBits; rootBits <<= 1) {\n+            r.leftShift(rootBits);\n+            rootShift -= rootBits;\n+\n+            \/\/ Remove useless bits from the radicand\n+            MutableBigInteger x = new MutableBigInteger(this);\n+            int removedBits = rootShift * n;\n+            x.rightShift(removedBits);\n+            if (removedBits > trailingZeros)\n+                x.add(ONE); \/\/ round up to ensure r is an upper bound of the root\n+\n+            MutableBigInteger rToN1 = new MutableBigInteger(r.toBigInteger().pow(n - 1).mag);\n+            MutableBigInteger dividend = new MutableBigInteger();\n+            r.mul(n - 1, dividend);\n+            MutableBigInteger xDivRToN1 = new MutableBigInteger();\n+            x.divide(rToN1, xDivRToN1, false);\n+            dividend.add(xDivRToN1);\n+            dividend.divideOneWord(n, r);\n+        }\n+\n+        \/\/ Refine the estimate.\n+        r.safeLeftShift(rootShift);\n+        MutableBigInteger r1 = r;\n+        do {\n+            r = r1;\n+            MutableBigInteger rToN1 = new MutableBigInteger(r.toBigInteger().pow(n - 1).mag);\n+            MutableBigInteger dividend = new MutableBigInteger();\n+            r.mul(n - 1, dividend);\n+            MutableBigInteger xDivRToN1 = new MutableBigInteger();\n+            this.divide(rToN1, xDivRToN1);\n+            dividend.add(xDivRToN1);\n+            dividend.divideOneWord(n, r1);\n+        } while (r1.compare(r) < 0); \/\/ Terminate when non-decreasing.\n+\n+        return r;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"modified"}]}