{"files":[{"patch":"@@ -1979,0 +1979,1 @@\n+            final int rootLen = (bitLength - 1) \/ n + 1;\n@@ -1982,2 +1983,3 @@\n-                \/\/ Set the shift to the root's bit length and then the initial estimate to 1\n-                rootSh = (bitLength - 1) \/ n + 1;\n+                \/\/ Set the root shift to the root's bit length minus 1\n+                \/\/ The initial estimate will be 2^rBitLen == 2 << (rBitLen - 1)\n+                rootSh = rootLen - 1;\n@@ -2035,2 +2037,2 @@\n-                    \/\/ Set the initial estimate to 1\n-                    s.value[0] = 1;\n+                    \/\/ Set the initial estimate to 2 << (rBitLen - 1)\n+                    s.value[0] = 2;\n@@ -2044,0 +2046,2 @@\n+                    \/\/ Double.PRECISION correct bits in the radicand yield to at least\n+                    \/\/ one correct bit in the root, so rootSh < rootLen\n@@ -2062,3 +2066,4 @@\n-                for (int rootBits = (int) s.bitLength(); rootSh > rootBits; rootBits <<= 1) {\n-                    s.leftShift(rootBits);\n-                    rootSh -= rootBits;\n+                \/\/ rootSh is always less than rootLen, so correctBits >= 1\n+                for (int correctBits = rootLen - rootSh; correctBits < rootSh; correctBits <<= 1) {\n+                    s.leftShift(correctBits);\n+                    rootSh -= correctBits;\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"}]}