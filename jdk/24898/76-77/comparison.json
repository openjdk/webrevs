{"files":[{"patch":"@@ -1979,1 +1979,1 @@\n-            final int rootLen = (bitLength - 1) \/ n + 1;\n+            final int rootLen = (bitLength - 1) \/ n + 1; \/\/ ⌈bitLength \/ n⌉\n@@ -1982,5 +1982,1 @@\n-            if (n >= Double.PRECISION) { \/\/ fp arithmetic gives too few correct bits\n-                \/\/ Set the root shift to the root's bit length minus 1\n-                \/\/ The initial estimate will be 2^rootLen == 2 << (rootLen - 1)\n-                rootSh = rootLen - 1;\n-            } else {\n+            if (n < Double.PRECISION) {\n@@ -1993,1 +1989,1 @@\n-                 * The uppper bound will be s * 2^(sh\/n), indeed:\n+                 * The upper bound will be s * 2^(sh\/n), indeed:\n@@ -2000,1 +1996,1 @@\n-                 * non-significant bits), avoiding to lose bits in the significand.\n+                 * non-significant bits), to avoid losing bits in the significand.\n@@ -2003,1 +1999,1 @@\n-                int sh = bitLength - Double.PRECISION;\n+                rootSh = (bitLength - Double.PRECISION) \/ n; \/\/ rootSh < rootLen\n@@ -2005,1 +2001,1 @@\n-                 * bl = bitLength, ex = sh % n\n+                 * bl = bitLength, sh = rootSh * n, ex = (bl - P) % n\n@@ -2007,2 +2003,2 @@\n-                 * We have bl-(sh-ex) = bl-(bl-P-ex) = P + ex\n-                 * Since ex < n < P, we get P + ex ≤ ME, and so bl-(sh-ex) ≤ ME.\n+                 * We have bl-sh = bl-((bl-P)-ex) = P + ex\n+                 * Since ex < n < P, we get P + ex ≤ ME, and so bl-sh ≤ ME.\n@@ -2011,1 +2007,1 @@\n-                 * x >> (sh-ex) < 2^(bl-(sh-ex)) ≤ 2^ME < Double.MAX_VALUE\n+                 * x >> sh < 2^(bl-sh) ≤ 2^ME < Double.MAX_VALUE\n@@ -2014,3 +2010,3 @@\n-                 * Noting that ex ≥ 0, we get bl-(sh-ex) = P + ex ≥ P\n-                 * which shows that x >> (sh-ex) has at least P bits of precision,\n-                 * since bl-(sh-ex) is its bit length.\n+                 * Noting that ex ≥ 0, we get bl-sh = P + ex ≥ P\n+                 * which shows that x >> sh has at least P bits of precision,\n+                 * since bl-sh is its bit length.\n@@ -2018,1 +2014,0 @@\n-                sh -= sh % n; \/\/ Adjust shift to a multiple of n\n@@ -2020,1 +2015,1 @@\n-                rad = this.toBigInteger().shiftRight(sh).doubleValue();\n+                rad = this.toBigInteger().shiftRight(rootSh * n).doubleValue();\n@@ -2026,1 +2021,4 @@\n-                rootSh = sh \/ n; \/\/ sh < bitLength, so sh \/ n == rootSh < rootLen\n+            } else { \/\/ fp arithmetic gives too few correct bits\n+                \/\/ Set the root shift to the root's bit length minus 1\n+                \/\/ The initial estimate will be 2^rootLen == 2 << (rootLen - 1)\n+                rootSh = rootLen - 1;\n@@ -2033,1 +2031,1 @@\n-                \/\/ Allocate sufficient space to store the final root\n+                \/\/ Allocate ⌈intLen \/ n⌉ ints to store the final root\n@@ -2048,1 +2046,1 @@\n-                    \/\/ so wrongBits is less than ((bitLength - sh) - 1) \/ n + 1,\n+                    \/\/ so wrongBits is less than ⌈(bitLength - sh) \/ n⌉,\n@@ -2050,1 +2048,1 @@\n-                    \/\/ hence wrongBits + rootSh < (((bitLength - sh) - 1) \/ n + 1) + rootSh == rootLen\n+                    \/\/ hence wrongBits + rootSh < ⌈(bitLength - sh) \/ n⌉ + rootSh == rootLen\n@@ -2067,1 +2065,1 @@\n-                \/\/ Refine the estimate, avoiding to compute non-significant bits\n+                \/\/ Refine the estimate to avoid computing non-significant bits\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":21,"deletions":23,"binary":false,"changes":44,"status":"modified"}]}