{"files":[{"patch":"@@ -1997,2 +1997,1 @@\n-                 * non-significant bits), and the shift is performed in order to lose\n-                 * the smallest number of bits in the significand if necessary (minimizing loss of precision).\n+                 * non-significant bits), avoiding to lose bits in the significand.\n@@ -2005,31 +2004,18 @@\n-                \/\/ Try to shift as many bits as possible\n-                \/\/ without losing precision in double's representation.\n-                if (shExcess <= Double.MAX_EXPONENT - Double.PRECISION) {\n-                    \/* Let x = this, P = Double.PRECISION, ME = Double.MAX_EXPONENT,\n-                     * bl = bitLength, ex = shExcess\n-                     *\n-                     * We have bl-(sh-ex) = bl-(bl-P-ex) = P + ex,\n-                     * so ex ≤ ME - P ⇔ bl-(sh-ex) ≤ ME.\n-                     *\n-                     * Recalling x < 2^bl:\n-                     * x >> (sh-ex) < 2^(bl-(sh-ex)) ≤ 2^ME < Double.MAX_VALUE\n-                     * Thus, rad ≤ 2^ME is in the range of finite doubles.\n-                     *\n-                     * Noting that ex ≥ 0, we get bl-(sh-ex) = P + ex ≥ P\n-                     * which shows that x >> (sh-ex) has at least P bits of precision,\n-                     * since bl-(sh-ex) is its bit length.\n-                     *\/\n-                    sh -= shExcess; \/\/ Adjust shift to a multiple of n\n-                    \/\/ Shift the value into finite double range\n-                    rad = this.toBigInteger().shiftRight((int) sh).doubleValue();\n-                } else { \/\/ x >> (sh-ex) could exceed finite double range, may lose precision\n-                    \/\/ Shift the value into finite double range\n-                    \/\/ x >> sh < 2^(bl-sh) = 2^(bl-(bl-P)) = 2^P < Double.MAX_VALUE\n-                    rad = this.toBigInteger().shiftRight((int) sh).doubleValue();\n-                    \/\/ Complete the shift to a multiple of n,\n-                    \/\/ avoiding to lose more bits (possibly all) than necessary.\n-                    \/\/ The instruction rad = Math.nextUp(rad) below ensures rad > 0.0\n-                    int shLack = n - shExcess;\n-                    sh += shLack; \/\/ sh is long, no overflow\n-                    rad = Math.scalb(rad, -shLack);\n-                }\n+                \/\/ Shift as many bits as possible without losing precision in the significand.\n+                \/* Let x = this, P = Double.PRECISION, ME = Double.MAX_EXPONENT,\n+                 * bl = bitLength, ex = shExcess\n+                 *\n+                 * We have bl-(sh-ex) = bl-(bl-P-ex) = P + ex\n+                 * Since ex < n < P, we get P + ex ≤ ME, and so bl-(sh-ex) ≤ ME.\n+                 *\n+                 * Recalling x < 2^bl:\n+                 * x >> (sh-ex) < 2^(bl-(sh-ex)) ≤ 2^ME < Double.MAX_VALUE\n+                 * Thus, rad ≤ 2^ME is in the range of finite doubles.\n+                 *\n+                 * Noting that ex ≥ 0, we get bl-(sh-ex) = P + ex ≥ P\n+                 * which shows that x >> (sh-ex) has at least P bits of precision,\n+                 * since bl-(sh-ex) is its bit length.\n+                 *\/\n+                sh -= shExcess; \/\/ Adjust shift to a multiple of n\n+                \/\/ Shift the value into finite double range\n+                rad = this.toBigInteger().shiftRight((int) sh).doubleValue();\n@@ -2056,25 +2042,8 @@\n-                    \/\/ Discard wrong bits from the initial estimate\n-                    int radExp = Math.getExponent(rad);\n-                    if (radExp == Double.MIN_EXPONENT - 1) \/\/ Handle subnormals\n-                        radExp = Double.MIN_EXPONENT;\n-\n-                    if (radExp >= Double.PRECISION - 1) { \/\/ Discard wrong integer bits\n-                        \/\/ The radicand has radExp+1 integer bits, but only\n-                        \/\/ the first Double.PRECISION leftmost bits are correct\n-                        \/\/ We scale the corresponding wrong bits of approx in the fraction part.\n-                        int wrongBits = ((radExp + 1) - Double.PRECISION) \/ n;\n-                        rootSh += wrongBits;\n-                        approx = Math.scalb(approx, -wrongBits);\n-                    } else { \/\/ Save correct fraction bits\n-                        \/* Some correct bits of the radicand are fraction bits.\n-                         * If radExp >= 0, there are (Double.PRECISION - 1) - radExp\n-                         * correct fraction bits in the radicand.\n-                         * If radExp < 0, there are (Double.PRECISION - 1) + |radExp|\n-                         * correct fraction bits in the radicand.\n-                         * We scale the corresponding bits of approx in the integer part,\n-                         * rounding up correctBits for simmetry with then-case.\n-                         *\/\n-                        int correctBits = ((Double.PRECISION - 1) - radExp - 1) \/ n + 1;\n-                        rootSh -= correctBits;\n-                        approx = Math.scalb(approx, correctBits);\n-                    }\n+                    \/\/ Discard wrong integer bits from the initial estimate\n+                    \/\/ The radicand has Math.getExponent(rad)+1 integer bits, but only\n+                    \/\/ the first Double.PRECISION leftmost bits are correct\n+                    \/\/ We scale the corresponding wrong bits of approx in the fraction part.\n+                    int wrongBits = ((Math.getExponent(rad) + 1) - Double.PRECISION) \/ n;\n+                    rootSh += wrongBits;\n+                    approx = Math.scalb(approx, -wrongBits);\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":27,"deletions":58,"binary":false,"changes":85,"status":"modified"}]}