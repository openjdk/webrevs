{"files":[{"patch":"@@ -2745,0 +2745,79 @@\n+    \/**\n+     * Returns the integer {@code n}th root of this BigInteger. The integer\n+     * {@code n}th root {@code r} of the corresponding mathematical integer {@code x}\n+     * is defined as follows:\n+     * <ul>\n+     *   <li>if {@code x} &ge; 0, then {@code r} &ge; 0 is the largest integer such that\n+     *   {@code r}<sup>{@code n}<\/sup> &le; {@code x};\n+     *   <li>if {@code x} &lt; 0, then {@code r} &le; 0 is the smallest integer such that\n+     *   {@code r}<sup>{@code n}<\/sup> &ge; {@code x}.\n+     * <\/ul>\n+     * If the root is defined, it is equal to the value of\n+     * {@code x.signum()}&sdot; &lfloor;{@code |nthRoot(x, n)|}&rfloor;,\n+     * where {@code nthRoot(x, n)} denotes the real {@code n}th root of {@code x}\n+     * treated as a real.\n+     * Otherwise, the method throws an {@code ArithmeticException}.\n+     *\n+     * <p>Note that the magnitude of the integer {@code n}th root will be less than\n+     * the magnitude of the real {@code n}th root if the latter is not representable\n+     * as an integral value.\n+     *\n+     * @param n the root degree\n+     * @return the integer {@code n}th root of {@code this}\n+     * @throws ArithmeticException if {@code n <= 0}.\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is negative.\n+     * @see #sqrt()\n+     * @since 26\n+     *\/\n+    public BigInteger nthRoot(int n) {\n+        if (n == 1)\n+            return this;\n+\n+        if (n == 2)\n+            return sqrt();\n+\n+        checkRootDegree(n);\n+        return new MutableBigInteger(this.mag).nthRootRem(n)[0].toBigInteger(signum);\n+    }\n+\n+    \/**\n+     * Returns an array of two BigIntegers containing the integer {@code n}th root\n+     * {@code r} of {@code this} and its remainder {@code this - r}<sup>{@code n}<\/sup>,\n+     * respectively.\n+     *\n+     * @param n the root degree\n+     * @return an array of two BigIntegers with the integer {@code n}th root at\n+     *         offset 0 and the remainder at offset 1\n+     * @throws ArithmeticException if {@code n <= 0} (Non-positive degree integer roots\n+     *                             are not defined.)\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is\n+     *                             negative. (This would cause the operation to\n+     *                             yield non-real roots.)\n+     * @see #sqrt()\n+     * @see #sqrtAndRemainder()\n+     * @see #nthRoot(int)\n+     * @since 26\n+     *\/\n+    public BigInteger[] nthRootAndRemainder(int n) {\n+        if (n == 1)\n+            return new BigInteger[] { this, ZERO };\n+\n+        if (n == 2)\n+            return sqrtAndRemainder();\n+\n+        checkRootDegree(n);\n+        MutableBigInteger[] rootRem = new MutableBigInteger(this.mag).nthRootRem(n);\n+        return new BigInteger[] {\n+                rootRem[0].toBigInteger(signum),\n+                rootRem[1].toBigInteger(signum)\n+        };\n+    }\n+\n+    private void checkRootDegree(int n) {\n+        if (n <= 0)\n+            throw new ArithmeticException(\"Non-positive root degree\");\n+\n+        if ((n & 1) == 0 && this.signum < 0)\n+            throw new ArithmeticException(\"Negative radicand with even root degree\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,0 +161,21 @@\n+    \/**\n+     * Returns a MutableBigInteger with a magnitude specified by\n+     * the absolute value of the double val. Any fractional part is discarded.\n+     *\n+     * Assume val is in the finite double range.\n+     *\/\n+    private static MutableBigInteger valueOf(double val) {\n+        val = Math.abs(val);\n+        if (val < 0x1p63)\n+            return new MutableBigInteger((long) val);\n+        \/\/ Translate the double into exponent and significand, according\n+        \/\/ to the formulae in JLS, Section 20.10.22.\n+        long valBits = Double.doubleToRawLongBits(val);\n+        int exponent = (int) ((valBits >> 52) & 0x7ffL) - 1075;\n+        long significand = (valBits & ((1L << 52) - 1)) | (1L << 52);\n+        \/\/ At this point, val == significand * 2^exponent, with exponent > 0\n+        MutableBigInteger result = new MutableBigInteger(significand);\n+        result.leftShift(exponent);\n+        return result;\n+    }\n+\n@@ -1895,0 +1916,195 @@\n+    \/**\n+     * Calculate the integer {@code n}th root {@code floor(nthRoot(this, n))} and the remainder,\n+     * where {@code nthRoot(., n)} denotes the mathematical {@code n}th root.\n+     * The contents of {@code this} are <em>not<\/em> changed. The value of {@code this}\n+     * is assumed to be non-negative and the root degree {@code n >= 3}.\n+     * Assumes {@code bitLength() <= Integer.MAX_VALUE}.\n+     *\n+     * @implNote The implementation is based on the material in Richard P. Brent\n+     * and Paul Zimmermann, <a href=\"https:\/\/maths-people.anu.edu.au\/~brent\/pd\/mca-cup-0.5.9.pdf\">\n+     * Modern Computer Arithmetic<\/a>, p. 27-28.\n+     *\n+     * @param n the root degree\n+     * @return the integer {@code n}th root of {@code this} and the remainder\n+     *\/\n+    MutableBigInteger[] nthRootRem(int n) {\n+        \/\/ Special cases.\n+        if (this.isZero() || this.isOne())\n+            return new MutableBigInteger[] { this, new MutableBigInteger() };\n+\n+        final int bitLength = (int) this.bitLength();\n+        \/\/ if this < 2^n, result is unity\n+        if (bitLength <= n) {\n+            MutableBigInteger rem = new MutableBigInteger(this);\n+            rem.subtract(ONE);\n+            return new MutableBigInteger[] { new MutableBigInteger(1), rem };\n+        }\n+\n+        MutableBigInteger s;\n+        if (bitLength <= Long.SIZE) {\n+            \/\/ Initial estimate is the root of the unsigned long value.\n+            final long x = this.toLong();\n+            long sLong = (long) nthRootApprox(Math.nextUp(x >= 0 ? x : x + 0x1p64), n) + 1L;\n+            \/* The integer-valued recurrence formula in the algorithm of Brent&Zimmermann\n+             * simply discards the fraction part of the real-valued Newton recurrence\n+             * on the function f discussed in the referenced work.\n+             * Indeed, for real x and integer n > 0, the equality ⌊x\/n⌋ == ⌊⌊x⌋\/n⌋ holds,\n+             * from which the claim follows.\n+             * As a consequence, an initial underestimate (not discussed in BZ)\n+             * will immediately lead to a (weak) overestimate during the 1st iteration,\n+             * thus meeting BZ requirements for termination and correctness.\n+             *\/\n+            if (BigInteger.bitLengthForLong(sLong) * (n - 1) <= Long.SIZE) {\n+                \/\/ Do the 1st iteration outside the loop to ensure an overestimate\n+                long sToN1 = BigInteger.unsignedLongPow(sLong, n - 1);\n+                sLong = ((n - 1) * sLong + Long.divideUnsigned(x, sToN1)) \/ n;\n+\n+                if (BigInteger.bitLengthForLong(sLong) * (n - 1) <= Long.SIZE) {\n+                    \/\/ Refine the estimate.\n+                    long u = sLong;\n+                    do {\n+                        sLong = u;\n+                        sToN1 = BigInteger.unsignedLongPow(sLong, n - 1);\n+                        u = ((n - 1) * sLong + Long.divideUnsigned(x, sToN1)) \/ n;\n+                    } while (u < sLong); \/\/ Terminate when non-decreasing.\n+\n+                    return new MutableBigInteger[] {\n+                            new MutableBigInteger(sLong), new MutableBigInteger(x - sToN1 * sLong)\n+                    };\n+                }\n+            }\n+            \/\/ s^(n - 1) could overflow long range, use MutableBigInteger loop instead\n+            s = new MutableBigInteger(sLong);\n+        } else {\n+            \/* Since the following equality holds:\n+             * nthRoot(x, n) == nthRoot(x\/2^sh, n) * 2^(sh\/n),\n+             *\n+             * to get an upper bound of the root of x, it suffices to find an integer sh\n+             * and a real s such that s >= nthRoot(x\/2^sh, n) and sh % n == 0.\n+             * The uppper bound will be s * 2^(sh\/n), indeed:\n+             * s * 2^(sh\/n) >= nthRoot(x\/2^sh, n) * 2^(sh\/n) == nthRoot(x, n).\n+             * To achieve this, we right shift the input of sh bits into finite double range,\n+             * rounding up the result.\n+             *\n+             * The value of the shift sh is chosen in order to have the smallest number of\n+             * trailing zeros in the double value of s after the significand (minimizing\n+             * non-significant bits), and the shift is performed in order to lose\n+             * the smallest number of bits in the significand if necessary (minimizing loss of precision).\n+             *\/\n+            \/\/ Set up the initial estimate of the iteration.\n+            \/\/ Determine a right shift that is a multiple of n into finite double range.\n+            long sh = bitLength - Double.PRECISION;\n+            int shExcess = (int) (sh % n);\n+            double rad;\n+\n+            \/\/ Try to shift as many bits as possible\n+            \/\/ without losing precision in double's representation.\n+            if (shExcess <= Double.MAX_EXPONENT - Double.PRECISION) {\n+                \/* Let x = this, P = Double.PRECISION, ME = Double.MAX_EXPONENT,\n+                 * bl = bitLength, ex = shExcess\n+                 *\n+                 * We have bl-(sh-ex) = bl-(bl-P-ex) = P + ex,\n+                 * so ex ≤ ME - P ⇔ bl-(sh-ex) ≤ ME.\n+                 *\n+                 * Recalling x < 2^bl:\n+                 * x >> (sh-ex) < 2^(bl-(sh-ex)) ≤ 2^ME < Double.MAX_VALUE\n+                 * Thus, x >> (sh-ex) is in the range of finite doubles.\n+                 *\n+                 * Noting that ex ≥ 0, we get bl-(sh-ex) = P + ex ≥ P\n+                 * which shows that x >> (sh-ex) has at least P bits of precision,\n+                 * since bl-(sh-ex) is its bit length.\n+                 *\/\n+                sh -= shExcess; \/\/ Adjust shift to a multiple of n\n+                \/\/ Shift the value into finite double range\n+                rad = this.toBigInteger().shiftRight((int) sh).doubleValue();\n+            } else { \/\/ x >> (sh-ex) could exceed finite double range, may lose precision\n+                \/\/ Shift the value into finite double range\n+                rad = this.toBigInteger().shiftRight((int) sh).doubleValue();\n+                \/\/ Complete the shift to a multiple of n,\n+                \/\/ avoiding to lose more bits than necessary.\n+                if (shExcess != 0) {\n+                    int shLack = n - shExcess;\n+                    sh += shLack; \/\/ sh is long, no overflow\n+                    rad = Math.scalb(rad, -shLack);\n+                }\n+            }\n+\n+            \/\/ Use the root of the shifted value as an estimate.\n+            \/\/ rad < 2^ME, so Math.nextUp(rad) ≤ 2^ME < Double.MAX_VALUE\n+            rad = Math.nextUp(rad);\n+            double approx = nthRootApprox(rad, n);\n+            int rootSh = (int) (sh \/ n);\n+            if (rootSh == 0) {\n+                s = valueOf(approx + 1.0);\n+            } else {\n+                \/\/ Allocate sufficient space to store the final root\n+                s = new MutableBigInteger(new int[(intLen - 1) \/ n + 1]);\n+\n+                \/\/ Discard wrong bits from the initial estimate\n+                int radExp = Math.getExponent(rad);\n+                if (radExp == Double.MIN_EXPONENT - 1) \/\/ Handle subnormals\n+                    radExp = Double.MIN_EXPONENT;\n+\n+                if (radExp >= Double.PRECISION - 1) { \/\/ Discard wrong integer bits\n+                    int wrongBits = ((radExp + 1) - Double.PRECISION) \/ n;\n+                    rootSh += wrongBits;\n+                    approx = Math.scalb(approx, -wrongBits);\n+                } else { \/\/ Avoid to discard correct fraction bits\n+                    int correctBits = ((Double.PRECISION - 1) - radExp - 1) \/ n + 1;\n+                    rootSh -= correctBits;\n+                    approx = Math.scalb(approx, correctBits);\n+                }\n+                s.copyValue(valueOf(approx + 1.0));\n+\n+                \/\/ Refine the estimate, avoiding to compute non-significant bits\n+                final int trailingZeros = this.getLowestSetBit();\n+                for (int rootBits = (int) s.bitLength(); rootSh > rootBits; rootBits <<= 1) {\n+                    s.leftShift(rootBits);\n+                    rootSh -= rootBits;\n+\n+                    \/\/ Remove useless bits from the radicand\n+                    MutableBigInteger x = new MutableBigInteger(this);\n+                    int removedBits = rootSh * n;\n+                    x.rightShift(removedBits);\n+                    if (removedBits > trailingZeros)\n+                        x.add(ONE); \/\/ round up to ensure s is an upper bound of the root\n+\n+                    newtonRecurrenceNthRoot(x, s, n, s.toBigInteger().pow(n - 1));\n+                }\n+\n+                \/\/ Shift the approximate root back into the original range.\n+                s.safeLeftShift(rootSh);\n+            }\n+        }\n+\n+        \/\/ Do the 1st iteration outside the loop to ensure an overestimate\n+        newtonRecurrenceNthRoot(this, s, n, s.toBigInteger().pow(n - 1));\n+        \/\/ Refine the estimate.\n+        do {\n+            BigInteger sBig = s.toBigInteger();\n+            BigInteger sToN1 = sBig.pow(n - 1);\n+            MutableBigInteger rem = new MutableBigInteger(sToN1.multiply(sBig).mag);\n+            if (rem.subtract(this) <= 0)\n+                return new MutableBigInteger[] { s, rem };\n+\n+            newtonRecurrenceNthRoot(this, s, n, sToN1);\n+        } while (true);\n+    }\n+\n+    private static double nthRootApprox(double x, int n) {\n+        return Math.nextUp(n == 3 ? Math.cbrt(x) : Math.pow(x, Math.nextUp(1.0 \/ n)));\n+    }\n+\n+    \/**\n+     * Computes {@code ((n-1)*s + x\/sToN1)\/n} and places the result in {@code s}.\n+     *\/\n+    private static void newtonRecurrenceNthRoot(\n+            MutableBigInteger x, MutableBigInteger s, int n, BigInteger sToN1) {\n+        MutableBigInteger dividend = new MutableBigInteger();\n+        s.mul(n - 1, dividend);\n+        MutableBigInteger xDivSToN1 = new MutableBigInteger();\n+        x.divide(new MutableBigInteger(sToN1.mag), xDivSToN1, false);\n+        dividend.add(xDivSToN1);\n+        dividend.divideOneWord(n, s);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":217,"deletions":1,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 4181191 4161971 4227146 4194389 4823171 4624738 4812225 4837946 4026465 8074460 8078672 8032027 8229845\n+ * @bug 4181191 4161971 4227146 4194389 4823171 4624738 4812225 4837946 4026465 8074460 8078672 8032027 8229845 8077587\n@@ -234,0 +234,3 @@\n+\n+            failCount1 += checkResult(x.signum() < 0 && power % 2 == 0 ? x.negate() : x,\n+                    y.nthRoot(power), \"BigInteger.pow() inconsistent with BigInteger.nthRoot()\");\n@@ -415,0 +418,148 @@\n+    private static void nthRootSmall() {\n+        int failCount = 0;\n+\n+        \/\/ A non-positive degree should cause an exception.\n+        int n = 0;\n+        BigInteger x = BigInteger.ONE;\n+        BigInteger s;\n+        try {\n+            s = x.nthRoot(n);\n+            \/\/ If nthRoot() does not throw an exception that is a failure.\n+            failCount++;\n+            printErr(\"nthRoot() of non-positive degree did not throw an exception\");\n+        } catch (ArithmeticException expected) {\n+            \/\/ Not a failure\n+        }\n+\n+        \/\/ A negative value with even degree should cause an exception.\n+        n = 4;\n+        x = BigInteger.valueOf(-1);\n+        try {\n+            s = x.nthRoot(n);\n+            \/\/ If nthRoot() does not throw an exception that is a failure.\n+            failCount++;\n+            printErr(\"nthRoot() of negative number and even degree did not throw an exception\");\n+        } catch (ArithmeticException expected) {\n+            \/\/ Not a failure\n+        }\n+\n+        \/\/ A negative value with odd degree should return -nthRoot(-x, n)\n+        n = 3;\n+        x = BigInteger.valueOf(-8);\n+        failCount += checkResult(x.negate().nthRoot(n).negate(), x.nthRoot(n),\n+                \"nthRoot(\" + x + \", \" + n + \") != -nthRoot(\" + x.negate() + \", \" + n + \")\");\n+\n+        \/\/ A zero value should return BigInteger.ZERO.\n+        failCount += checkResult(BigInteger.ZERO, BigInteger.ZERO.nthRoot(n),\n+                \"nthRoot(0, \" + n + \") != 0\");\n+\n+        \/\/ A one degree should return x.\n+        x = BigInteger.TWO;\n+        failCount += checkResult(x, x.nthRoot(1), \"nthRoot(\" + x + \", 1) != \" + x);\n+\n+        n = 8;\n+        \/\/ 1 <= value < 2^n should return BigInteger.ONE.\n+        int end = 1 << n;\n+        for (int i = 0; i < end; i++) {\n+            failCount += checkResult(BigInteger.ONE,\n+                    BigInteger.valueOf(i).nthRoot(n), \"nthRoot(\" + i + \", \" + n + \") != 1\");\n+        }\n+\n+        report(\"nthRootSmall\", failCount);\n+    }\n+\n+    public static void nthRoot() {\n+        nthRootSmall();\n+\n+        ToIntFunction<BigInteger> f = (x) -> {\n+            int n = random.nextInt(x.bitLength()) + 2;\n+            int failCount = 0;\n+\n+            \/\/ nth root of x^n -> x\n+            BigInteger xN = x.pow(n);\n+            failCount += checkResult(x, xN.nthRoot(n), \"nthRoot() x^n -> x\");\n+\n+            \/\/ nth root of x^n + 1 -> x\n+            BigInteger xNup = xN.add(BigInteger.ONE);\n+            failCount += checkResult(x, xNup.nthRoot(n), \"nthRoot() x^n + 1 -> x\");\n+\n+            \/\/ nth root of (x + 1)^n - 1 -> x\n+            BigInteger up =\n+                x.add(BigInteger.ONE).pow(n).subtract(BigInteger.ONE);\n+            failCount += checkResult(x, up.nthRoot(n), \"nthRoot() (x + 1)^n - 1 -> x\");\n+\n+            \/\/ nthRoot(x, n)^n <= x\n+            BigInteger r = x.nthRoot(n);\n+            if (r.pow(n).compareTo(x) > 0) {\n+                failCount++;\n+                printErr(\"nthRoot(x, n)^n > x for x = \" + x + \", n = \" + n);\n+            }\n+\n+            \/\/ (nthRoot(x, n) + 1)^n > x\n+            if (r.add(BigInteger.ONE).pow(n).compareTo(x) <= 0) {\n+                failCount++;\n+                printErr(\"(nthRoot(x, n) + 1)^n <= x for x = \" + x + \", n = \" + n);\n+            }\n+\n+            return failCount;\n+        };\n+\n+        Stream.Builder<BigInteger> sb = Stream.builder();\n+        int maxExponent = Double.MAX_EXPONENT + 1;\n+        for (int i = 1; i <= maxExponent; i++) {\n+            BigInteger p2 = BigInteger.ONE.shiftLeft(i);\n+            sb.add(p2.subtract(BigInteger.ONE));\n+            sb.add(p2);\n+            sb.add(p2.add(BigInteger.ONE));\n+        }\n+        sb.add((new BigDecimal(Double.MAX_VALUE)).toBigInteger());\n+        sb.add((new BigDecimal(Double.MAX_VALUE)).toBigInteger().add(BigInteger.ONE));\n+        report(\"nthRoot for 2^N, 2^N - 1 and 2^N + 1, 1 <= N <= Double.MAX_EXPONENT\",\n+            sb.build().collect(Collectors.summingInt(f)));\n+\n+        IntStream ints = random.ints(SIZE, 2, Integer.MAX_VALUE);\n+        report(\"nthRoot for int\", ints.mapToObj(x ->\n+            BigInteger.valueOf(x)).collect(Collectors.summingInt(f)));\n+\n+        LongStream longs = random.longs(SIZE, Integer.MAX_VALUE + 1L, Long.MAX_VALUE);\n+        report(\"nthRoot for long\", longs.mapToObj(x ->\n+            BigInteger.valueOf(x)).collect(Collectors.summingInt(f)));\n+\n+        DoubleStream doubles = random.doubles(SIZE, 0x1p63, Double.MAX_VALUE);\n+        report(\"nthRoot for double\", doubles.mapToObj(x ->\n+            BigDecimal.valueOf(x).toBigInteger()).collect(Collectors.summingInt(f)));\n+    }\n+\n+    public static void nthRootAndRemainder() {\n+        ToIntFunction<BigInteger> g = (x) -> {\n+            int failCount = 0;\n+            int n = random.nextInt(x.bitLength()) + 2;\n+            BigInteger xN = x.pow(n);\n+\n+            \/\/ nth root of x^n -> x\n+            BigInteger[] actual = xN.nthRootAndRemainder(n);\n+            failCount += checkResult(x, actual[0], \"nthRootAndRemainder()[0]\");\n+            failCount += checkResult(BigInteger.ZERO, actual[1], \"nthRootAndRemainder()[1]\");\n+\n+            \/\/ nth root of x^n + 1 -> x\n+            BigInteger xNup = xN.add(BigInteger.ONE);\n+            actual = xNup.nthRootAndRemainder(n);\n+            failCount += checkResult(x, actual[0], \"nthRootAndRemainder()[0]\");\n+            failCount += checkResult(BigInteger.ONE, actual[1], \"nthRootAndRemainder()[1]\");\n+\n+            \/\/ nth root of (x + 1)^n - 1 -> x\n+            BigInteger up =\n+                x.add(BigInteger.ONE).pow(n).subtract(BigInteger.ONE);\n+            actual = up.nthRootAndRemainder(n);\n+            failCount += checkResult(x, actual[0], \"nthRootAndRemainder()[0]\");\n+            BigInteger r = up.subtract(xN);\n+            failCount += checkResult(r, actual[1], \"nthRootAndRemainder()[1]\");\n+\n+            return failCount;\n+        };\n+\n+        IntStream bits = random.ints(SIZE, 3, Short.MAX_VALUE);\n+        report(\"nthRootAndRemainder\", bits.mapToObj(x ->\n+            BigInteger.valueOf(x)).collect(Collectors.summingInt(g)));\n+    }\n+\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerTest.java","additions":153,"deletions":2,"binary":false,"changes":155,"status":"modified"}]}