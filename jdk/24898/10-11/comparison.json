{"files":[{"patch":"@@ -2773,13 +2773,1 @@\n-        if (n == 1)\n-            return this;\n-\n-        if (n == 2)\n-            return sqrt();\n-\n-        if (n <= 0)\n-            throw new ArithmeticException(\"Non-positive root degree\");\n-\n-        if ((n & 1) == 0 && this.signum < 0)\n-            throw new ArithmeticException(\"Negative radicand with even root degree\");\n-\n-        return new MutableBigInteger(this.mag).nthRoot(n).toBigInteger(signum);\n+        return n == 1 ? this : (n == 2 ? sqrt() : nthRootAndRemainder(n, false)[0]);\n@@ -2809,2 +2797,10 @@\n-        if (n == 1)\n-            return new BigInteger[] { this, ZERO };\n+        return n == 1 ? new BigInteger[] { this, ZERO }\n+                      : (n == 2 ? sqrtAndRemainder() : nthRootAndRemainder(n, true));\n+    }\n+\n+    \/**\n+     * Assume {@code n != 1 && n != 2}\n+     *\/\n+    private BigInteger[] nthRootAndRemainder(int n, boolean needRemainder) {\n+        if (n <= 0)\n+            throw new ArithmeticException(\"Non-positive root degree\");\n@@ -2812,2 +2808,2 @@\n-        if (n == 2)\n-            return sqrtAndRemainder();\n+        if ((n & 1) == 0 && this.signum < 0)\n+            throw new ArithmeticException(\"Negative radicand with even root degree\");\n@@ -2815,3 +2811,5 @@\n-        BigInteger root = nthRoot(n), rem = this.subtract(root.pow(n));\n-        assert rem.signum == 0 || rem.signum == this.signum;\n-        return new BigInteger[] { root, rem };\n+        MutableBigInteger[] rootRem = new MutableBigInteger(this.mag).nthRootRem(n);\n+        return new BigInteger[] {\n+                rootRem[0].toBigInteger(signum),\n+                needRemainder ? rootRem[1].toBigInteger(signum) : null\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1917,4 +1917,4 @@\n-     * Calculate the integer {@code n}th root {@code floor(nthRoot(this, n))} where\n-     * {@code nthRoot(., n)} denotes the mathematical {@code n}th root. The contents of\n-     * {@code this} are <em>not<\/em> changed. The value of {@code this} is assumed\n-     * to be non-negative and the root degree {@code n >= 3}.\n+     * Calculate the integer {@code n}th root {@code floor(nthRoot(this, n))} and the remainder,\n+     * where {@code nthRoot(., n)} denotes the mathematical {@code n}th root.\n+     * The contents of {@code this} are <em>not<\/em> changed. The value of {@code this}\n+     * is assumed to be non-negative and the root degree {@code n >= 3}.\n@@ -1926,1 +1926,1 @@\n-     * @return the integer {@code n}th root of {@code this}\n+     * @return the integer {@code n}th root of {@code this} and the remainder\n@@ -1928,1 +1928,1 @@\n-    MutableBigInteger nthRoot(int n) {\n+    MutableBigInteger[] nthRootRem(int n) {\n@@ -1931,1 +1931,1 @@\n-            return this;\n+            return new MutableBigInteger[] { this, new MutableBigInteger() };\n@@ -1935,2 +1935,5 @@\n-        if (bitLength <= n)\n-            return new MutableBigInteger(1);\n+        if (bitLength <= n) {\n+            MutableBigInteger rem = new MutableBigInteger(this);\n+            rem.subtract(ONE);\n+            return new MutableBigInteger[] { new MutableBigInteger(1), rem };\n+        }\n@@ -1950,1 +1953,1 @@\n-                long r1 = rLong;\n+                long r1 = rLong, rToN1;\n@@ -1953,1 +1956,1 @@\n-                    long rToN1 = BigInteger.unsignedLongPow(rLong, n - 1);\n+                    rToN1 = BigInteger.unsignedLongPow(rLong, n - 1);\n@@ -1957,1 +1960,3 @@\n-                return new MutableBigInteger(rLong);\n+                return new MutableBigInteger[] {\n+                        new MutableBigInteger(rLong), new MutableBigInteger(x - rToN1 * rLong)\n+                };\n@@ -2009,1 +2014,1 @@\n-            newtonRecurrenceNthRoot(x, r, n, r);\n+            newtonRecurrenceNthRoot(x, r, n, r.toBigInteger().pow(n - 1), r);\n@@ -2012,1 +2017,1 @@\n-        \/\/ Refine the estimate.\n+        \/\/ Shift the approximate root back into the original range.\n@@ -2014,1 +2019,1 @@\n-        MutableBigInteger r1 = new MutableBigInteger(new int[r.intLen]);\n+        \/\/ Refine the estimate.\n@@ -2016,3 +2021,5 @@\n-            newtonRecurrenceNthRoot(this, r, n, r1);\n-            if (r1.compare(r) >= 0) \/\/ Terminate when non-decreasing.\n-                return r;\n+            BigInteger rBig = r.toBigInteger();\n+            BigInteger rToN1 = rBig.pow(n - 1);\n+            MutableBigInteger rem = new MutableBigInteger(rToN1.multiply(rBig).mag);\n+            if (rem.subtract(this) <= 0)\n+                return new MutableBigInteger[] { r, rem };\n@@ -2020,1 +2027,1 @@\n-            r.copyValue(r1);\n+            newtonRecurrenceNthRoot(this, r, n, rToN1, r);\n@@ -2025,1 +2032,1 @@\n-     * Computes {@code ((n-1)*r + x\/r^(n-1))\/n} and places the result in {@code res}.\n+     * Computes {@code ((n-1)*r + x\/rToN1)\/n} and places the result in {@code res}.\n@@ -2029,2 +2036,1 @@\n-            MutableBigInteger x, MutableBigInteger r, int n, MutableBigInteger res) {\n-        MutableBigInteger rToN1 = new MutableBigInteger(r.toBigInteger().pow(n - 1).mag);\n+            MutableBigInteger x, MutableBigInteger r, int n, BigInteger rToN1, MutableBigInteger res) {\n@@ -2034,1 +2040,1 @@\n-        x.divide(rToN1, xDivRToN1, false);\n+        x.divide(new MutableBigInteger(rToN1.mag), xDivRToN1, false);\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":29,"deletions":23,"binary":false,"changes":52,"status":"modified"}]}