{"files":[{"patch":"@@ -1979,29 +1979,8 @@\n-            \/* Since the following equality holds:\n-             * nthRoot(x, n) == nthRoot(x\/2^sh, n) * 2^(sh\/n),\n-             *\n-             * to get an upper bound of the root of x, it suffices to find an integer sh\n-             * and a real s such that s >= nthRoot(x\/2^sh, n) and sh % n == 0.\n-             * The uppper bound will be s * 2^(sh\/n), indeed:\n-             * s * 2^(sh\/n) >= nthRoot(x\/2^sh, n) * 2^(sh\/n) == nthRoot(x, n).\n-             * To achieve this, we right shift the input of sh bits into finite double range,\n-             * rounding up the result.\n-             *\n-             * The value of the shift sh is chosen in order to have the smallest number of\n-             * trailing zeros in the double value of s after the significand (minimizing\n-             * non-significant bits), and the shift is performed in order to lose\n-             * the smallest number of bits in the significand if necessary (minimizing loss of precision).\n-             *\/\n-            \/\/ Set up the initial estimate of the iteration.\n-            \/\/ Determine a right shift that is a multiple of n into finite double range.\n-            long sh = bitLength - Double.PRECISION;\n-            int shExcess = (int) (sh % n);\n-            double rad;\n-\n-            \/\/ Try to shift as many bits as possible\n-            \/\/ without losing precision in double's representation.\n-            if (shExcess <= Double.MAX_EXPONENT - Double.PRECISION) {\n-                \/* Let x = this, P = Double.PRECISION, ME = Double.MAX_EXPONENT,\n-                 * bl = bitLength, ex = shExcess\n-                 *\n-                 * We have bl-(sh-ex) = bl-(bl-P-ex) = P + ex,\n-                 * so ex ≤ ME - P ⇔ bl-(sh-ex) ≤ ME.\n+            int rootSh;\n+            double rad = 0.0, approx = 0.0;\n+            if (n >= Double.PRECISION) { \/\/ fp arithmetic gives too few correct bits\n+                \/\/ Set the shift to the root's bit length and then the initial estimate to 1\n+                rootSh = (bitLength - 1) \/ n + 1;\n+            } else {\n+                \/* Since the following equality holds:\n+                 * nthRoot(x, n) == nthRoot(x\/2^sh, n) * 2^(sh\/n),\n@@ -2009,3 +1988,6 @@\n-                 * Recalling x < 2^bl:\n-                 * x >> (sh-ex) < 2^(bl-(sh-ex)) ≤ 2^ME < Double.MAX_VALUE\n-                 * Thus, rad ≤ 2^ME is in the range of finite doubles.\n+                 * to get an upper bound of the root of x, it suffices to find an integer sh\n+                 * and a real s such that s >= nthRoot(x\/2^sh, n) and sh % n == 0.\n+                 * The uppper bound will be s * 2^(sh\/n), indeed:\n+                 * s * 2^(sh\/n) >= nthRoot(x\/2^sh, n) * 2^(sh\/n) == nthRoot(x, n).\n+                 * To achieve this, we right shift the input of sh bits into finite double range,\n+                 * rounding up the result.\n@@ -2013,3 +1995,4 @@\n-                 * Noting that ex ≥ 0, we get bl-(sh-ex) = P + ex ≥ P\n-                 * which shows that x >> (sh-ex) has at least P bits of precision,\n-                 * since bl-(sh-ex) is its bit length.\n+                 * The value of the shift sh is chosen in order to have the smallest number of\n+                 * trailing zeros in the double value of s after the significand (minimizing\n+                 * non-significant bits), and the shift is performed in order to lose\n+                 * the smallest number of bits in the significand if necessary (minimizing loss of precision).\n@@ -2017,13 +2000,42 @@\n-                sh -= shExcess; \/\/ Adjust shift to a multiple of n\n-                \/\/ Shift the value into finite double range\n-                rad = this.toBigInteger().shiftRight((int) sh).doubleValue();\n-            } else { \/\/ x >> (sh-ex) could exceed finite double range, may lose precision\n-                \/\/ Shift the value into finite double range\n-                \/\/ x >> sh < 2^(bl-sh) = 2^(bl-(bl-P)) = 2^P < Double.MAX_VALUE\n-                rad = this.toBigInteger().shiftRight((int) sh).doubleValue();\n-                \/\/ Complete the shift to a multiple of n,\n-                \/\/ avoiding to lose more bits (possibly all) than necessary.\n-                \/\/ The instruction rad = Math.nextUp(rad) below ensures rad > 0.0\n-                int shLack = n - shExcess;\n-                sh += shLack; \/\/ sh is long, no overflow\n-                rad = Math.scalb(rad, -shLack);\n+                \/\/ Set up the initial estimate of the iteration.\n+                \/\/ Determine a right shift that is a multiple of n into finite double range.\n+                long sh = bitLength - Double.PRECISION;\n+                int shExcess = (int) (sh % n);\n+\n+                \/\/ Try to shift as many bits as possible\n+                \/\/ without losing precision in double's representation.\n+                if (shExcess <= Double.MAX_EXPONENT - Double.PRECISION) {\n+                    \/* Let x = this, P = Double.PRECISION, ME = Double.MAX_EXPONENT,\n+                     * bl = bitLength, ex = shExcess\n+                     *\n+                     * We have bl-(sh-ex) = bl-(bl-P-ex) = P + ex,\n+                     * so ex ≤ ME - P ⇔ bl-(sh-ex) ≤ ME.\n+                     *\n+                     * Recalling x < 2^bl:\n+                     * x >> (sh-ex) < 2^(bl-(sh-ex)) ≤ 2^ME < Double.MAX_VALUE\n+                     * Thus, rad ≤ 2^ME is in the range of finite doubles.\n+                     *\n+                     * Noting that ex ≥ 0, we get bl-(sh-ex) = P + ex ≥ P\n+                     * which shows that x >> (sh-ex) has at least P bits of precision,\n+                     * since bl-(sh-ex) is its bit length.\n+                     *\/\n+                    sh -= shExcess; \/\/ Adjust shift to a multiple of n\n+                    \/\/ Shift the value into finite double range\n+                    rad = this.toBigInteger().shiftRight((int) sh).doubleValue();\n+                } else { \/\/ x >> (sh-ex) could exceed finite double range, may lose precision\n+                    \/\/ Shift the value into finite double range\n+                    \/\/ x >> sh < 2^(bl-sh) = 2^(bl-(bl-P)) = 2^P < Double.MAX_VALUE\n+                    rad = this.toBigInteger().shiftRight((int) sh).doubleValue();\n+                    \/\/ Complete the shift to a multiple of n,\n+                    \/\/ avoiding to lose more bits (possibly all) than necessary.\n+                    \/\/ The instruction rad = Math.nextUp(rad) below ensures rad > 0.0\n+                    int shLack = n - shExcess;\n+                    sh += shLack; \/\/ sh is long, no overflow\n+                    rad = Math.scalb(rad, -shLack);\n+                }\n+\n+                \/\/ Use the root of the shifted value as an estimate.\n+                \/\/ rad ≤ 2^ME, so Math.nextUp(rad) < Double.MAX_VALUE\n+                rad = Math.nextUp(rad);\n+                approx = nthRootApprox(rad, n);\n+                rootSh = (int) (sh \/ n);\n@@ -2032,5 +2044,0 @@\n-            \/\/ Use the root of the shifted value as an estimate.\n-            \/\/ rad ≤ 2^ME, so Math.nextUp(rad) < Double.MAX_VALUE\n-            rad = Math.nextUp(rad);\n-            double approx = nthRootApprox(rad, n);\n-            int rootSh = (int) (sh \/ n);\n@@ -2043,24 +2050,32 @@\n-                \/\/ Discard wrong bits from the initial estimate\n-                int radExp = Math.getExponent(rad);\n-                if (radExp == Double.MIN_EXPONENT - 1) \/\/ Handle subnormals\n-                    radExp = Double.MIN_EXPONENT;\n-\n-                if (radExp >= Double.PRECISION - 1) { \/\/ Discard wrong integer bits\n-                    \/\/ The radicand has radExp+1 integer bits, but only\n-                    \/\/ the first Double.PRECISION leftmost bits are correct\n-                    \/\/ We scale the corresponding wrong bits of approx in the fraction part.\n-                    int wrongBits = ((radExp + 1) - Double.PRECISION) \/ n;\n-                    rootSh += wrongBits;\n-                    approx = Math.scalb(approx, -wrongBits);\n-                } else { \/\/ Save correct fraction bits\n-                    \/* Some correct bits of the radicand are fraction bits.\n-                     * If radExp >= 0, there are (Double.PRECISION - 1) - radExp\n-                     * correct fraction bits in the radicand.\n-                     * If radExp < 0, there are (Double.PRECISION - 1) + |radExp|\n-                     * correct fraction bits in the radicand.\n-                     * We scale the corresponding bits of approx in the integer part,\n-                     * rounding up correctBits for simmetry with then-case.\n-                     *\/\n-                    int correctBits = ((Double.PRECISION - 1) - radExp - 1) \/ n + 1;\n-                    rootSh -= correctBits;\n-                    approx = Math.scalb(approx, correctBits);\n+                if (n >= Double.PRECISION) {\n+                    \/\/ Set the initial estimate to 1\n+                    s.value[0] = 1;\n+                    s.offset = 0;\n+                    s.intLen = 1;\n+                } else {\n+                    \/\/ Discard wrong bits from the initial estimate\n+                    int radExp = Math.getExponent(rad);\n+                    if (radExp == Double.MIN_EXPONENT - 1) \/\/ Handle subnormals\n+                        radExp = Double.MIN_EXPONENT;\n+\n+                    if (radExp >= Double.PRECISION - 1) { \/\/ Discard wrong integer bits\n+                        \/\/ The radicand has radExp+1 integer bits, but only\n+                        \/\/ the first Double.PRECISION leftmost bits are correct\n+                        \/\/ We scale the corresponding wrong bits of approx in the fraction part.\n+                        int wrongBits = ((radExp + 1) - Double.PRECISION) \/ n;\n+                        rootSh += wrongBits;\n+                        approx = Math.scalb(approx, -wrongBits);\n+                    } else { \/\/ Save correct fraction bits\n+                        \/* Some correct bits of the radicand are fraction bits.\n+                         * If radExp >= 0, there are (Double.PRECISION - 1) - radExp\n+                         * correct fraction bits in the radicand.\n+                         * If radExp < 0, there are (Double.PRECISION - 1) + |radExp|\n+                         * correct fraction bits in the radicand.\n+                         * We scale the corresponding bits of approx in the integer part,\n+                         * rounding up correctBits for simmetry with then-case.\n+                         *\/\n+                        int correctBits = ((Double.PRECISION - 1) - radExp - 1) \/ n + 1;\n+                        rootSh -= correctBits;\n+                        approx = Math.scalb(approx, correctBits);\n+                    }\n+                    s.copyValue(valueOf(approx + 1.0));\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":92,"deletions":77,"binary":false,"changes":169,"status":"modified"}]}