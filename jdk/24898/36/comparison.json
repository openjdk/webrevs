{"files":[{"patch":"@@ -2746,0 +2746,71 @@\n+    \/**\n+     * Returns the integer {@code n}th root of this BigInteger. The integer\n+     * {@code n}th root {@code r} of the corresponding mathematical integer {@code x}\n+     * is defined as follows:\n+     * <ul>\n+     *   <li>if {@code x} &ge; 0, then {@code r} &ge; 0 is the largest integer such that\n+     *   {@code r}<sup>{@code n}<\/sup> &le; {@code x};\n+     *   <li>if {@code x} &lt; 0, then {@code r} &le; 0 is the smallest integer such that\n+     *   {@code r}<sup>{@code n}<\/sup> &ge; {@code x}.\n+     * <\/ul>\n+     * If the root is defined, it is equal to the value of\n+     * {@code x.signum()}&sdot; &lfloor;{@code |nthRoot(x, n)|}&rfloor;,\n+     * where {@code nthRoot(x, n)} denotes the real {@code n}th root of {@code x}\n+     * treated as a real.\n+     * Otherwise, the method throws an {@code ArithmeticException}.\n+     *\n+     * <p>Note that the magnitude of the integer {@code n}th root will be less than\n+     * the magnitude of the real {@code n}th root if the latter is not representable\n+     * as an integral value.\n+     *\n+     * @param n the root degree\n+     * @return the integer {@code n}th root of {@code this}\n+     * @throws ArithmeticException if {@code n <= 0}.\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is negative.\n+     * @see #sqrt()\n+     * @since 26\n+     *\/\n+    public BigInteger nthRoot(int n) {\n+        return n == 1 ? this : (n == 2 ? sqrt() : nthRootAndRemainder(n, false)[0]);\n+    }\n+\n+    \/**\n+     * Returns an array of two BigIntegers containing the integer {@code n}th root\n+     * {@code r} of {@code this} and its remainder {@code this - r}<sup>{@code n}<\/sup>,\n+     * respectively.\n+     *\n+     * @param n the root degree\n+     * @return an array of two BigIntegers with the integer {@code n}th root at\n+     *         offset 0 and the remainder at offset 1\n+     * @throws ArithmeticException if {@code n <= 0} (Non-positive degree integer roots\n+     *                             are not defined.)\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is\n+     *                             negative. (This would cause the operation to\n+     *                             yield non-real roots.)\n+     * @see #sqrt()\n+     * @see #sqrtAndRemainder()\n+     * @see #nthRoot(int)\n+     * @since 26\n+     *\/\n+    public BigInteger[] nthRootAndRemainder(int n) {\n+        return n == 1 ? new BigInteger[] { this, ZERO }\n+                      : (n == 2 ? sqrtAndRemainder() : nthRootAndRemainder(n, true));\n+    }\n+\n+    \/*\n+     * Assume {@code n != 1 && n != 2}\n+     *\/\n+    private BigInteger[] nthRootAndRemainder(int n, boolean needRemainder) {\n+        if (n <= 0)\n+            throw new ArithmeticException(\"Non-positive root degree\");\n+\n+        if ((n & 1) == 0 && this.signum < 0)\n+            throw new ArithmeticException(\"Negative radicand with even root degree\");\n+\n+        MutableBigInteger[] rootRem = new MutableBigInteger(this.mag).nthRootRem(n);\n+        return new BigInteger[] {\n+                rootRem[0].toBigInteger(signum),\n+                needRemainder ? rootRem[1].toBigInteger(signum) : null\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -161,0 +161,21 @@\n+    \/**\n+     * Returns a MutableBigInteger with a magnitude specified by\n+     * the absolute value of the double val. Any fractional part is discarded.\n+     *\n+     * Assume val is in the finite double range.\n+     *\/\n+    private static MutableBigInteger valueOf(double val) {\n+        val = Math.abs(val);\n+        if (val < 0x1p63)\n+            return new MutableBigInteger((long) val);\n+        \/\/ Translate the double into exponent and significand, according\n+        \/\/ to the formulae in JLS, Section 20.10.22.\n+        long valBits = Double.doubleToRawLongBits(val);\n+        int exponent = (int) ((valBits >> 52) & 0x7ffL) - 1075;\n+        long significand = (valBits & ((1L << 52) - 1)) | (1L << 52);\n+        \/\/ At this point, val == significand * 2^exponent, with exponent > 0\n+        MutableBigInteger result = new MutableBigInteger(significand);\n+        result.leftShift(exponent);\n+        return result;\n+    }\n+\n@@ -1895,0 +1916,166 @@\n+    \/**\n+     * Calculate the integer {@code n}th root {@code floor(nthRoot(this, n))} and the remainder,\n+     * where {@code nthRoot(., n)} denotes the mathematical {@code n}th root.\n+     * The contents of {@code this} are <em>not<\/em> changed. The value of {@code this}\n+     * is assumed to be non-negative and the root degree {@code n >= 3}.\n+     *\n+     * @implNote The implementation is based on the material in Richard P. Brent\n+     * and Paul Zimmermann, <a href=\"https:\/\/maths-people.anu.edu.au\/~brent\/pd\/mca-cup-0.5.9.pdf\">\n+     * Modern Computer Arithmetic<\/a>, p. 27-28.\n+     *\n+     * @param n the root degree\n+     * @return the integer {@code n}th root of {@code this} and the remainder\n+     *\/\n+    MutableBigInteger[] nthRootRem(final int n) {\n+        \/\/ Special cases.\n+        if (this.isZero() || this.isOne())\n+            return new MutableBigInteger[] { this, new MutableBigInteger() };\n+\n+        final int bitLength = (int) this.bitLength();\n+        \/\/ if this < 2^n, result is unity\n+        if (bitLength <= n) {\n+            MutableBigInteger rem = new MutableBigInteger(this);\n+            rem.subtract(ONE);\n+            return new MutableBigInteger[] { new MutableBigInteger(1), rem };\n+        }\n+\n+        MutableBigInteger r;\n+        if (bitLength <= Long.SIZE) {\n+            \/\/ Initial estimate is the root of the unsigned long value.\n+            final long x = this.toLong();\n+            \/\/ Use fp arithmetic to get an upper bound of the root\n+            long rLong = (long) nthRootUpper(Math.nextUp(x >= 0 ? x : x + 0x1p64), n);\n+\n+            if (BigInteger.bitLengthForLong(rLong) * (n - 1) <= Long.SIZE) {\n+                \/\/ Refine the estimate.\n+                long r1 = rLong, rToN1;\n+                do {\n+                    rLong = r1;\n+                    rToN1 = BigInteger.unsignedLongPow(rLong, n - 1);\n+                    r1 = ((n - 1) * rLong + Long.divideUnsigned(x, rToN1)) \/ n;\n+                } while (r1 < rLong); \/\/ Terminate when non-decreasing.\n+\n+                return new MutableBigInteger[] {\n+                        new MutableBigInteger(rLong), new MutableBigInteger(x - rToN1 * rLong)\n+                };\n+            } else { \/\/ r^(n - 1) could overflow long range, use MutableBigInteger loop instead\n+                r = new MutableBigInteger(rLong);\n+            }\n+        } else {\n+            \/* Since the following equality holds:\n+             * nthRoot(x, n) == nthRoot(x\/2^s, n) * 2^(s\/n),\n+             *\n+             * to get an upper bound of the root of x, it suffices to find an integer s\n+             * and a real r such that r >= nthRoot(x\/2^s, n) and s % n == 0.\n+             * The uppper bound will be r * 2^(s\/n), indeed:\n+             * r * 2^(s\/n) >= nthRoot(x\/2^s, n) * 2^(s\/n) == nthRoot(x, n).\n+             * To achieve this, we right shift the input of s bits into finite double range,\n+             * rounding up the result.\n+             *\n+             * The value of the shift s is chosen in order to have the smallest number of\n+             * trailing zeros in the double value of r after the significand (minimizing\n+             * non-significant bits), and the shift is performed in order to lose\n+             * the smallest number of bits in the significand if necessary (minimizing loss of precision).\n+             *\/\n+            \/\/ Set up the initial estimate of the iteration.\n+            \/\/ Determine a right shift that is a multiple of n into finite double range.\n+            long shift = bitLength - Double.PRECISION;\n+            int shiftExcess = (int) (shift % n);\n+            double rad;\n+\n+            \/\/ Try to shift as many bits as possible\n+            \/\/ without losing precision in double's representation.\n+            if (bitLength - (shift - shiftExcess) <= Double.MAX_EXPONENT) {\n+                shift -= shiftExcess; \/\/ Adjust shift to a multiple of n\n+                \/\/ Shift the value into finite double range\n+                rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n+            } else { \/\/ this >> (shift - shiftExcess) could exceed finite double range, may lose precision\n+                \/\/ Shift the value into finite double range\n+                rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n+                \/\/ Complete the shift to a multiple of n,\n+                \/\/ avoiding to lose more bits than necessary.\n+                if (shiftExcess != 0) {\n+                    int shiftLack = n - shiftExcess;\n+                    shift += shiftLack; \/\/ shift is long, no overflow\n+                    rad \/= Double.parseDouble(\"0x1p\" + shiftLack);\n+                }\n+            }\n+\n+            \/\/ Use the root of the shifted value as an estimate.\n+            rad = Math.nextUp(rad);\n+            double approx = nthRootUpper(rad, n);\n+            int rootShift = (int) (shift \/ n);\n+            if (rootShift == 0) {\n+                r = valueOf(approx);\n+            } else {\n+                \/\/ Allocate sufficient space to store the final root\n+                r = new MutableBigInteger(new int[(intLen - 1) \/ n + 1]);\n+\n+                \/\/ Discard wrong bits from the initial estimate\n+                int radExp = Math.getExponent(rad);\n+                if (radExp == Double.MIN_EXPONENT - 1) \/\/ Handle subnormals\n+                    radExp = Double.MIN_EXPONENT;\n+\n+                if (radExp >= Double.PRECISION - 1) { \/\/ Discard wrong integer bits\n+                    int wrongBits = ((radExp + 1) - Double.PRECISION) \/ n;\n+                    rootShift += wrongBits;\n+                    approx \/= Double.parseDouble(\"0x1p\" + wrongBits);\n+                } else { \/\/ Avoid to discard correct fraction bits\n+                    int correctBits = ((Double.PRECISION - 1) - radExp - 1) \/ n + 1;\n+                    rootShift -= correctBits;\n+                    approx *= Double.parseDouble(\"0x1p\" + correctBits);\n+                }\n+                r.copyValue(valueOf(Math.ceil(approx)));\n+\n+                \/\/ Refine the estimate, avoiding to compute non-significant bits\n+                final int trailingZeros = this.getLowestSetBit();\n+                for (int rootBits = (int) r.bitLength(); rootShift >= rootBits; rootBits <<= 1) {\n+                    r.leftShift(rootBits);\n+                    rootShift -= rootBits;\n+\n+                    \/\/ Remove useless bits from the radicand\n+                    MutableBigInteger x = new MutableBigInteger(this);\n+                    int removedBits = rootShift * n;\n+                    x.rightShift(removedBits);\n+                    if (removedBits > trailingZeros)\n+                        x.add(ONE); \/\/ round up to ensure r is an upper bound of the root\n+\n+                    newtonRecurrenceNthRoot(x, r, n, r.toBigInteger().pow(n - 1));\n+                }\n+\n+                \/\/ Shift the approximate root back into the original range.\n+                r.safeLeftShift(rootShift);\n+            }\n+        }\n+\n+        \/\/ Refine the estimate.\n+        do {\n+            BigInteger rBig = r.toBigInteger();\n+            BigInteger rToN1 = rBig.pow(n - 1);\n+            MutableBigInteger rem = new MutableBigInteger(rToN1.multiply(rBig).mag);\n+            if (rem.subtract(this) <= 0)\n+                return new MutableBigInteger[] { r, rem };\n+\n+            newtonRecurrenceNthRoot(this, r, n, rToN1);\n+        } while (true);\n+    }\n+\n+    private static double nthRootUpper(double x, int n) {\n+        return Math.nextUp(n == 3\n+                ? Math.cbrt(x)\n+                : Math.exp(Math.nextUp(Math.nextUp(Math.log(x)) \/ n)));\n+    }\n+\n+    \/**\n+     * Computes {@code ((n-1)*r + x\/rToN1)\/n} and places the result in {@code r}.\n+     *\/\n+    private static void newtonRecurrenceNthRoot(\n+            MutableBigInteger x, MutableBigInteger r, int n, BigInteger rToN1) {\n+        MutableBigInteger dividend = new MutableBigInteger();\n+        r.mul(n - 1, dividend);\n+        MutableBigInteger xDivRToN1 = new MutableBigInteger();\n+        x.divide(new MutableBigInteger(rToN1.mag), xDivRToN1, false);\n+        dividend.add(xDivRToN1);\n+        dividend.divideOneWord(n, r);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 4181191 4161971 4227146 4194389 4823171 4624738 4812225 4837946 4026465 8074460 8078672 8032027 8229845\n+ * @bug 4181191 4161971 4227146 4194389 4823171 4624738 4812225 4837946 4026465 8074460 8078672 8032027 8229845 8077587\n@@ -415,0 +415,148 @@\n+    private static void nthRootSmall() {\n+        int failCount = 0;\n+\n+        \/\/ A non-positive degree should cause an exception.\n+        int n = 0;\n+        BigInteger x = BigInteger.ONE;\n+        BigInteger s;\n+        try {\n+            s = x.nthRoot(n);\n+            \/\/ If nthRoot() does not throw an exception that is a failure.\n+            failCount++;\n+            printErr(\"nthRoot() of non-positive degree did not throw an exception\");\n+        } catch (ArithmeticException expected) {\n+            \/\/ Not a failure\n+        }\n+\n+        \/\/ A negative value with even degree should cause an exception.\n+        n = 4;\n+        x = BigInteger.valueOf(-1);\n+        try {\n+            s = x.nthRoot(n);\n+            \/\/ If nthRoot() does not throw an exception that is a failure.\n+            failCount++;\n+            printErr(\"nthRoot() of negative number and even degree did not throw an exception\");\n+        } catch (ArithmeticException expected) {\n+            \/\/ Not a failure\n+        }\n+\n+        \/\/ A negative value with odd degree should return -nthRoot(-x, n)\n+        n = 3;\n+        x = BigInteger.valueOf(-8);\n+        failCount += checkResult(x.negate().nthRoot(n).negate(), x.nthRoot(n),\n+                \"nthRoot(\" + x + \", \" + n + \") != -nthRoot(\" + x.negate() + \", \" + n + \")\");\n+\n+        \/\/ A zero value should return BigInteger.ZERO.\n+        failCount += checkResult(BigInteger.ZERO, BigInteger.ZERO.nthRoot(n),\n+                \"nthRoot(0, \" + n + \") != 0\");\n+\n+        \/\/ A one degree should return x.\n+        x = BigInteger.TWO;\n+        failCount += checkResult(x, x.nthRoot(1), \"nthRoot(\" + x + \", 1) != \" + x);\n+\n+        n = 8;\n+        \/\/ 1 <= value < 2^n should return BigInteger.ONE.\n+        int end = 1 << n;\n+        for (int i = 0; i < end; i++) {\n+            failCount += checkResult(BigInteger.ONE,\n+                    BigInteger.valueOf(i).nthRoot(n), \"nthRoot(\" + i + \", \" + n + \") != 1\");\n+        }\n+\n+        report(\"nthRootSmall\", failCount);\n+    }\n+\n+    public static void nthRoot() {\n+        nthRootSmall();\n+\n+        ToIntFunction<BigInteger> f = (x) -> {\n+            int n = random.nextInt(x.bitLength()) + 2;\n+            int failCount = 0;\n+\n+            \/\/ nth root of x^n -> x\n+            BigInteger xN = x.pow(n);\n+            failCount += checkResult(x, xN.nthRoot(n), \"nthRoot() x^n -> x\");\n+\n+            \/\/ nth root of x^n + 1 -> x\n+            BigInteger xNup = xN.add(BigInteger.ONE);\n+            failCount += checkResult(x, xNup.nthRoot(n), \"nthRoot() x^n + 1 -> x\");\n+\n+            \/\/ nth root of (x + 1)^n - 1 -> x\n+            BigInteger up =\n+                x.add(BigInteger.ONE).pow(n).subtract(BigInteger.ONE);\n+            failCount += checkResult(x, up.nthRoot(n), \"nthRoot() (x + 1)^n - 1 -> x\");\n+\n+            \/\/ nthRoot(x, n)^n <= x\n+            BigInteger r = x.nthRoot(n);\n+            if (r.pow(n).compareTo(x) > 0) {\n+                failCount++;\n+                printErr(\"nthRoot(x, n)^n > x for x = \" + x + \", n = \" + n);\n+            }\n+\n+            \/\/ (nthRoot(x, n) + 1)^n > x\n+            if (r.add(BigInteger.ONE).pow(n).compareTo(x) <= 0) {\n+                failCount++;\n+                printErr(\"(nthRoot(x, n) + 1)^n <= x for x = \" + x + \", n = \" + n);\n+            }\n+\n+            return failCount;\n+        };\n+\n+        Stream.Builder<BigInteger> sb = Stream.builder();\n+        int maxExponent = Double.MAX_EXPONENT + 1;\n+        for (int i = 1; i <= maxExponent; i++) {\n+            BigInteger p2 = BigInteger.ONE.shiftLeft(i);\n+            sb.add(p2.subtract(BigInteger.ONE));\n+            sb.add(p2);\n+            sb.add(p2.add(BigInteger.ONE));\n+        }\n+        sb.add((new BigDecimal(Double.MAX_VALUE)).toBigInteger());\n+        sb.add((new BigDecimal(Double.MAX_VALUE)).toBigInteger().add(BigInteger.ONE));\n+        report(\"nthRoot for 2^N, 2^N - 1 and 2^N + 1, 1 <= N <= Double.MAX_EXPONENT\",\n+            sb.build().collect(Collectors.summingInt(f)));\n+\n+        IntStream ints = random.ints(SIZE, 2, Integer.MAX_VALUE);\n+        report(\"nthRoot for int\", ints.mapToObj(x ->\n+            BigInteger.valueOf(x)).collect(Collectors.summingInt(f)));\n+\n+        LongStream longs = random.longs(SIZE, Integer.MAX_VALUE + 1L, Long.MAX_VALUE);\n+        report(\"nthRoot for long\", longs.mapToObj(x ->\n+            BigInteger.valueOf(x)).collect(Collectors.summingInt(f)));\n+\n+        DoubleStream doubles = random.doubles(SIZE, Long.MAX_VALUE + 1.0, Double.MAX_VALUE);\n+        report(\"nthRoot for double\", doubles.mapToObj(x ->\n+            BigDecimal.valueOf(x).toBigInteger()).collect(Collectors.summingInt(f)));\n+    }\n+\n+    public static void nthRootAndRemainder() {\n+        ToIntFunction<BigInteger> g = (x) -> {\n+            int failCount = 0;\n+            int n = random.nextInt(x.bitLength()) + 2;\n+            BigInteger xN = x.pow(n);\n+\n+            \/\/ nth root of x^n -> x\n+            BigInteger[] actual = xN.nthRootAndRemainder(n);\n+            failCount += checkResult(x, actual[0], \"nthRootAndRemainder()[0]\");\n+            failCount += checkResult(BigInteger.ZERO, actual[1], \"nthRootAndRemainder()[1]\");\n+\n+            \/\/ nth root of x^n + 1 -> x\n+            BigInteger xNup = xN.add(BigInteger.ONE);\n+            actual = xNup.nthRootAndRemainder(n);\n+            failCount += checkResult(x, actual[0], \"nthRootAndRemainder()[0]\");\n+            failCount += checkResult(BigInteger.ONE, actual[1], \"nthRootAndRemainder()[1]\");\n+\n+            \/\/ nth root of (x + 1)^n - 1 -> x\n+            BigInteger up =\n+                x.add(BigInteger.ONE).pow(n).subtract(BigInteger.ONE);\n+            actual = up.nthRootAndRemainder(n);\n+            failCount += checkResult(x, actual[0], \"nthRootAndRemainder()[0]\");\n+            BigInteger r = up.subtract(xN);\n+            failCount += checkResult(r, actual[1], \"nthRootAndRemainder()[1]\");\n+\n+            return failCount;\n+        };\n+\n+        IntStream bits = random.ints(SIZE, 3, Short.MAX_VALUE);\n+        report(\"nthRootAndRemainder\", bits.mapToObj(x ->\n+            BigInteger.valueOf(x)).collect(Collectors.summingInt(g)));\n+    }\n+\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerTest.java","additions":150,"deletions":2,"binary":false,"changes":152,"status":"modified"}]}