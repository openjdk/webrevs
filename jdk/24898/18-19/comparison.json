{"files":[{"patch":"@@ -163,1 +163,1 @@\n-     * the absolute value of the double val. Any fractional part is discarded.\n+     * the absolute value of {@code val * 2^pow}. Any fractional part is discarded.\n@@ -167,1 +167,1 @@\n-    static MutableBigInteger valueOf(double val) {\n+    static MutableBigInteger valueOf(double val, int pow) {\n@@ -169,2 +169,0 @@\n-        if (val < 0x1p63)\n-            return new MutableBigInteger((long) val);\n@@ -174,5 +172,24 @@\n-        int exponent = (int) ((valBits >> 52) & 0x7ffL) - 1075;\n-        long significand = (valBits & ((1L << 52) - 1)) | (1L << 52);\n-        \/\/ At this point, val == significand * 2^exponent, with exponent > 0\n-        MutableBigInteger result = new MutableBigInteger(significand);\n-        result.leftShift(exponent);\n+        int exponent = (int) ((valBits >> 52) & 0x7ffL);\n+        long significand = (exponent == 0\n+                ? (valBits & ((1L << 52) - 1)) << 1\n+                : (valBits & ((1L << 52) - 1)) | (1L << 52));\n+        exponent -= 1075;\n+        \/\/ At this point, val == significand * 2^exponent\n+\n+        long shiftL = (long) exponent + pow;\n+        int shift = (int) shiftL;\n+        if (shift != shiftL) {\n+            if (shiftL > 0)\n+                throw new ArithmeticException(\"BigInteger Overflow\");\n+\n+            shift = -Long.SIZE;\n+        }\n+\n+        MutableBigInteger result;\n+        if (shift > 0) {\n+            result = new MutableBigInteger(significand);\n+            result.leftShift(shift);\n+        } else {\n+            shift = -shift;\n+            result = new MutableBigInteger(shift < Long.SIZE ? significand >> shift : 0L);\n+        }\n@@ -1998,2 +2015,1 @@\n-            double approx = n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n));\n-            approx = Math.ceil(Math.nextUp(approx));\n+            final double approx = Math.nextUp(n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n)));\n@@ -2001,1 +2017,1 @@\n-                r = valueOf(approx);\n+                r = valueOf(approx, 0);\n@@ -2005,1 +2021,12 @@\n-                r.copyValue(valueOf(approx));\n+                int approxExp = Math.getExponent(approx);\n+                if (approxExp == Double.MIN_EXPONENT - 1) \/\/ Handle subnormals\n+                    approxExp = Double.MIN_EXPONENT;\n+\n+                \/\/ Avoid to lose fraction bits\n+                if (approxExp + 1 >= Double.PRECISION) {\n+                    r.copyValue(valueOf(approx, 0));\n+                } else {\n+                    int pow = Math.min(Double.PRECISION - (approxExp + 1), (int) (shift \/ n));\n+                    shift -= (long) pow * n;\n+                    r.copyValue(valueOf(approx, pow));\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":40,"deletions":13,"binary":false,"changes":53,"status":"modified"}]}