{"files":[{"patch":"@@ -2748,7 +2748,11 @@\n-     * {@code n}th root of the corresponding mathematical integer {@code x} has the\n-     * same sign of {@code x}, and its magnitude is the largest integer {@code r}\n-     * such that {@code r**n <= abs(x)}. It is equal to the value of\n-     * {@code (x.signum() * floor(abs(nthRoot(x, n))))}, where {@code nthRoot(x, n)}\n-     * denotes the real {@code n}th root of {@code x} treated as a real. If {@code n}\n-     * is even and this BigInteger is negative, an {@code ArithmeticException} will be\n-     * thrown.\n+     * {@code n}th root {@code r} of the corresponding mathematical integer {@code x}\n+     * is defined as follows:\n+     * <ul>\n+     *   <li>if {@code x} &ge; 0, then {@code r} &ge; 0 is the largest integer such that\n+     *   {@code r}<sup>{@code n}<\/sup> &le; {@code x};\n+     *   <li>if {@code x} &lt; 0, then {@code r} &le; 0 is the smallest integer such that\n+     *   {@code r}<sup>{@code n }<\/sup> &ge; {@code x}.\n+     * <\/ul>\n+     * It is equal to the value of {@code x.signum() * } &lfloor;{@code |nthRoot(x, n)|}&rfloor;,\n+     * where {@code nthRoot(x, n)} denotes the real {@code n}th root of {@code x}\n+     * treated as a real.\n@@ -2762,4 +2766,2 @@\n-     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n-     *                             defined.)\n-     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n-     *                             operation to yield a non-integer value.)\n+     * @throws ArithmeticException if {@code n <= 0} (Non-positive degree integer roots\n+     *                             are not defined.)\n@@ -2778,1 +2780,1 @@\n-     * {@code r} of {@code this} and its remainder {@code this - r^n},\n+     * {@code r} of {@code this} and its remainder {@code this - r}<sup>{@code n}<\/sup>,\n@@ -2784,4 +2786,2 @@\n-     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n-     *                             defined.)\n-     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n-     *                             operation to yield a non-integer value.)\n+     * @throws ArithmeticException if {@code n <= 0} (Non-positive degree integer roots\n+     *                             are not defined.)\n@@ -2801,1 +2801,1 @@\n-    \/**\n+    \/*\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -167,1 +167,2 @@\n-    static MutableBigInteger valueOf(double val, int pow) {\n+\n+    private static MutableBigInteger valueOf(double val, int pow) {\n@@ -1940,1 +1941,1 @@\n-     * Modern Computer Arithmetic<\/a>, 27-28.\n+     * Modern Computer Arithmetic<\/a>, p. 27-28.\n@@ -1942,0 +1943,1 @@\n+     * @param n the root degree\n@@ -1982,0 +1984,15 @@\n+            \/* Since the following relation holds:\n+             * nthRoot(x, n) == nthRoot(x\/2^s, n) * 2^(s\/n), where s % n == 0,\n+             *\n+             * to get an upper bound of the root of x, it suffices to find an integer s\n+             * and a real r such that r >= nthRoot(x\/2^s, n) and s % n == 0.\n+             * The uppper bound will be r * 2^(s\/n), indeed:\n+             * r * 2^(s\/n) >= nthRoot(x\/2^s, n) * 2^(s\/n) == nthRoot(x, n).\n+             * To achieve this, we right shift the input of s bits into finite double range,\n+             * rounding up the result if necessary.\n+             *\n+             * The value of the shift s is chosen in order to have the smallest number of\n+             * trailing zeros in the double value of r after the significand (minimizing\n+             * non-significant bits), and the shift is performed in order to lose\n+             * the smallest number of bits in the significand if necessary (minimizing loss of precision).\n+             *\/\n@@ -1984,1 +2001,2 @@\n-            long shift;\n+            long shift = bitLength - Double.PRECISION;\n+            int shiftExcess = (int) (shift % n);\n@@ -1986,0 +2004,1 @@\n+\n@@ -1987,19 +2006,14 @@\n-            \/\/ without losing precision in double's representation\n-            if (bitLength > Double.PRECISION) {\n-                shift = bitLength - Double.PRECISION;\n-                int shiftExcess = (int) (shift % n);\n-\n-                if (bitLength - (shift - shiftExcess) <= Double.MAX_EXPONENT) {\n-                    shift -= shiftExcess; \/\/ Adjust shift to a multiple of n\n-                    \/\/ Shift the value into finite double range\n-                    rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n-                } else { \/\/ this >> (shift - shiftExcess) could exceed finite double range, must lose precision\n-                    \/\/ Shift the value into finite double range\n-                    rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n-                    \/\/ Complete the shift to a multiple of n,\n-                    \/\/ avoiding to lose more bits than necessary.\n-                    if (shiftExcess != 0) {\n-                        int shiftLack = n - shiftExcess;\n-                        shift += shiftLack; \/\/ shift is long, no overflow\n-                        rad \/= Double.parseDouble(\"0x1p\" + shiftLack);\n-                    }\n+            \/\/ without losing precision in double's representation.\n+            if (bitLength - (shift - shiftExcess) <= Double.MAX_EXPONENT) {\n+                shift -= shiftExcess; \/\/ Adjust shift to a multiple of n\n+                \/\/ Shift the value into finite double range\n+                rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n+            } else { \/\/ this >> (shift - shiftExcess) could exceed finite double range, may lose precision\n+                \/\/ Shift the value into finite double range\n+                rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n+                \/\/ Complete the shift to a multiple of n,\n+                \/\/ avoiding to lose more bits than necessary.\n+                if (shiftExcess != 0) {\n+                    int shiftLack = n - shiftExcess;\n+                    shift += shiftLack; \/\/ shift is long, no overflow\n+                    rad \/= Double.parseDouble(\"0x1p\" + shiftLack);\n@@ -2007,3 +2021,0 @@\n-            } else {\n-                shift = 0L;\n-                rad = this.toBigInteger().doubleValue();\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":36,"deletions":25,"binary":false,"changes":61,"status":"modified"}]}