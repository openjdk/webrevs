{"files":[{"patch":"@@ -415,0 +415,148 @@\n+    private static void nthRootSmall() {\n+        int failCount = 0;\n+\n+        \/\/ A non-positive degree should cause an exception.\n+        int n = 0;\n+        BigInteger x = BigInteger.ONE;\n+        BigInteger s;\n+        try {\n+            s = x.nthRoot(n);\n+            \/\/ If nthRoot() does not throw an exception that is a failure.\n+            failCount++;\n+            printErr(\"nthRoot() of non-positive degree did not throw an exception\");\n+        } catch (ArithmeticException expected) {\n+            \/\/ Not a failure\n+        }\n+\n+        \/\/ A negative value with even degree should cause an exception.\n+        n = 4;\n+        x = BigInteger.valueOf(-1);\n+        try {\n+            s = x.nthRoot(n);\n+            \/\/ If nthRoot() does not throw an exception that is a failure.\n+            failCount++;\n+            printErr(\"nthRoot() of negative number and even degree did not throw an exception\");\n+        } catch (ArithmeticException expected) {\n+            \/\/ Not a failure\n+        }\n+\n+        \/\/ A negative value with odd degree should return -nthRoot(-x, n)\n+        n = 3;\n+        x = BigInteger.valueOf(-8);\n+        failCount += checkResult(x.negate().nthRoot(n).negate(), x.nthRoot(n),\n+                \"nthRoot(\" + x + \", \" + n + \") != -nthRoot(\" + x.negate() + \", \" + n + \")\");\n+\n+        \/\/ A zero value should return BigInteger.ZERO.\n+        failCount += checkResult(BigInteger.ZERO, BigInteger.ZERO.nthRoot(n),\n+                \"nthRoot(0, \" + n + \") != 0\");\n+\n+        \/\/ A one degree should return x.\n+        x = BigInteger.TWO;\n+        failCount += checkResult(x, x.nthRoot(1), \"nthRoot(\" + x + \", 1) != \" + x);\n+\n+        n = 8;\n+        \/\/ 1 <= value < 2^n should return BigInteger.ONE.\n+        int end = 1 << n;\n+        for (int i = 0; i < end; i++) {\n+            failCount += checkResult(BigInteger.ONE,\n+                    BigInteger.valueOf(i).nthRoot(n), \"nthRoot(\" + i + \", \" + n + \") != 1\");\n+        }\n+\n+        report(\"nthRootSmall\", failCount);\n+    }\n+\n+    public static void nthRoot() {\n+        nthRootSmall();\n+\n+        ToIntFunction<BigInteger> f = (x) -> {\n+            int n = random.nextInt(x.bitLength()) + 2;\n+            int failCount = 0;\n+\n+            \/\/ nth root of x^n -> x\n+            BigInteger xN = x.pow(n);\n+            failCount += checkResult(x, xN.nthRoot(n), \"nthRoot() x^n -> x\");\n+\n+            \/\/ nth root of x^n + 1 -> x\n+            BigInteger xNup = xN.add(BigInteger.ONE);\n+            failCount += checkResult(x, xNup.nthRoot(n), \"nthRoot() x^n + 1 -> x\");\n+\n+            \/\/ nth root of (x + 1)^n - 1 -> x\n+            BigInteger up =\n+                x.add(BigInteger.ONE).pow(n).subtract(BigInteger.ONE);\n+            failCount += checkResult(x, up.nthRoot(n), \"nthRoot() (x + 1)^n - 1 -> x\");\n+\n+            \/\/ nthRoot(x, n)^n <= x\n+            BigInteger r = x.nthRoot(n);\n+            if (r.pow(n).compareTo(x) > 0) {\n+                failCount++;\n+                printErr(\"nthRoot(x, n)^n > x for x = \" + x + \", n = \" + n);\n+            }\n+\n+            \/\/ (nthRoot(x, n) + 1)^n > x\n+            if (r.add(BigInteger.ONE).pow(n).compareTo(x) <= 0) {\n+                failCount++;\n+                printErr(\"(nthRoot(x, n) + 1)^n <= x for x = \" + x + \", n = \" + n);\n+            }\n+\n+            return failCount;\n+        };\n+\n+        Stream.Builder<BigInteger> sb = Stream.builder();\n+        int maxExponent = Double.MAX_EXPONENT + 1;\n+        for (int i = 1; i <= maxExponent; i++) {\n+            BigInteger p2 = BigInteger.ONE.shiftLeft(i);\n+            sb.add(p2.subtract(BigInteger.ONE));\n+            sb.add(p2);\n+            sb.add(p2.add(BigInteger.ONE));\n+        }\n+        sb.add((new BigDecimal(Double.MAX_VALUE)).toBigInteger());\n+        sb.add((new BigDecimal(Double.MAX_VALUE)).toBigInteger().add(BigInteger.ONE));\n+        report(\"nthRoot for 2^N, 2^N - 1 and 2^N + 1, 1 <= N <= Double.MAX_EXPONENT\",\n+            sb.build().collect(Collectors.summingInt(f)));\n+\n+        IntStream ints = random.ints(SIZE, 2, Integer.MAX_VALUE);\n+        report(\"nthRoot for int\", ints.mapToObj(x ->\n+            BigInteger.valueOf(x)).collect(Collectors.summingInt(f)));\n+\n+        LongStream longs = random.longs(SIZE, Integer.MAX_VALUE + 1L, Long.MAX_VALUE);\n+        report(\"nthRoot for long\", longs.mapToObj(x ->\n+            BigInteger.valueOf(x)).collect(Collectors.summingInt(f)));\n+\n+        DoubleStream doubles = random.doubles(SIZE, Long.MAX_VALUE + 1.0, Double.MAX_VALUE);\n+        report(\"nthRoot for double\", doubles.mapToObj(x ->\n+            BigDecimal.valueOf(x).toBigInteger()).collect(Collectors.summingInt(f)));\n+    }\n+\n+    public static void nthRootAndRemainder() {\n+        ToIntFunction<BigInteger> g = (x) -> {\n+            int failCount = 0;\n+            int n = random.nextInt(x.bitLength()) + 2;\n+            BigInteger xN = x.pow(n);\n+\n+            \/\/ nth root of x^n -> x\n+            BigInteger[] actual = xN.nthRootAndRemainder(n);\n+            failCount += checkResult(x, actual[0], \"nthRootAndRemainder()[0]\");\n+            failCount += checkResult(BigInteger.ZERO, actual[1], \"nthRootAndRemainder()[1]\");\n+\n+            \/\/ nth root of x^n + 1 -> x\n+            BigInteger xNup = xN.add(BigInteger.ONE);\n+            actual = xNup.nthRootAndRemainder(n);\n+            failCount += checkResult(x, actual[0], \"nthRootAndRemainder()[0]\");\n+            failCount += checkResult(BigInteger.ONE, actual[1], \"nthRootAndRemainder()[1]\");\n+\n+            \/\/ nth root of (x + 1)^n - 1 -> x\n+            BigInteger up =\n+                x.add(BigInteger.ONE).pow(n).subtract(BigInteger.ONE);\n+            actual = up.nthRootAndRemainder(n);\n+            failCount += checkResult(x, actual[0], \"nthRootAndRemainder()[0]\");\n+            BigInteger r = up.subtract(xN);\n+            failCount += checkResult(r, actual[1], \"nthRootAndRemainder()[1]\");\n+\n+            return failCount;\n+        };\n+\n+        IntStream bits = random.ints(SIZE, 3, Short.MAX_VALUE);\n+        report(\"nthRootAndRemainder\", bits.mapToObj(x ->\n+            BigInteger.valueOf(x)).collect(Collectors.summingInt(g)));\n+    }\n+\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"modified"}]}