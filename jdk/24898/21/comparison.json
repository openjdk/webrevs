{"files":[{"patch":"@@ -2746,0 +2746,72 @@\n+    \/**\n+     * Returns the integer {@code n}th root of this BigInteger. The integer\n+     * {@code n}th root of the corresponding mathematical integer {@code x} has the\n+     * same sign of {@code x}, and its magnitude is the largest integer {@code r}\n+     * such that {@code r**n <= abs(x)}. It is equal to the value of\n+     * {@code (x.signum() * floor(abs(nthRoot(x, n))))}, where {@code nthRoot(x, n)}\n+     * denotes the real {@code n}th root of {@code x} treated as a real. If {@code n}\n+     * is even and this BigInteger is negative, an {@code ArithmeticException} will be\n+     * thrown.\n+     *\n+     * <p>Note that the magnitude of the integer {@code n}th root will be less than\n+     * the magnitude of the real {@code n}th root if the latter is not representable\n+     * as an integral value.\n+     *\n+     * @param n the root degree\n+     * @return the integer {@code n}th root of {@code this}\n+     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n+     *                             defined.)\n+     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n+     *                             operation to yield a non-integer value.)\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is\n+     *                             negative. (This would cause the operation to\n+     *                             yield non-real roots.)\n+     * @see #sqrt()\n+     * @since 26\n+     *\/\n+    public BigInteger nthRoot(int n) {\n+        return n == 1 ? this : (n == 2 ? sqrt() : nthRootAndRemainder(n, false)[0]);\n+    }\n+\n+    \/**\n+     * Returns an array of two BigIntegers containing the integer {@code n}th root\n+     * {@code r} of {@code this} and its remainder {@code this - r^n},\n+     * respectively.\n+     *\n+     * @param n the root degree\n+     * @return an array of two BigIntegers with the integer {@code n}th root at\n+     *         offset 0 and the remainder at offset 1\n+     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n+     *                             defined.)\n+     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n+     *                             operation to yield a non-integer value.)\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is\n+     *                             negative. (This would cause the operation to\n+     *                             yield non-real roots.)\n+     * @see #sqrt()\n+     * @see #sqrtAndRemainder()\n+     * @see #nthRoot(int)\n+     * @since 26\n+     *\/\n+    public BigInteger[] nthRootAndRemainder(int n) {\n+        return n == 1 ? new BigInteger[] { this, ZERO }\n+                      : (n == 2 ? sqrtAndRemainder() : nthRootAndRemainder(n, true));\n+    }\n+\n+    \/**\n+     * Assume {@code n != 1 && n != 2}\n+     *\/\n+    private BigInteger[] nthRootAndRemainder(int n, boolean needRemainder) {\n+        if (n <= 0)\n+            throw new ArithmeticException(\"Non-positive root degree\");\n+\n+        if ((n & 1) == 0 && this.signum < 0)\n+            throw new ArithmeticException(\"Negative radicand with even root degree\");\n+\n+        MutableBigInteger[] rootRem = new MutableBigInteger(this.mag).nthRootRem(n);\n+        return new BigInteger[] {\n+                rootRem[0].toBigInteger(signum),\n+                needRemainder ? rootRem[1].toBigInteger(signum) : null\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -161,0 +161,38 @@\n+    \/**\n+     * Returns a MutableBigInteger with a magnitude specified by\n+     * the absolute value of {@code val * 2^pow}. Any fractional part is discarded.\n+     *\n+     * Assume val is in the finite double range.\n+     *\/\n+    static MutableBigInteger valueOf(double val, int pow) {\n+        val = Math.abs(val);\n+        \/\/ Translate the double into exponent and significand, according\n+        \/\/ to the formulae in JLS, Section 20.10.22.\n+        long valBits = Double.doubleToRawLongBits(val);\n+        int exponent = (int) ((valBits >> 52) & 0x7ffL);\n+        long significand = (exponent == 0\n+                ? (valBits & ((1L << 52) - 1)) << 1\n+                : (valBits & ((1L << 52) - 1)) | (1L << 52));\n+        exponent -= 1075;\n+        \/\/ At this point, val == significand * 2^exponent\n+\n+        long shiftL = (long) exponent + pow;\n+        int shift = (int) shiftL;\n+        if (shift != shiftL) {\n+            if (shiftL > 0L)\n+                throw new ArithmeticException(\"BigInteger Overflow\");\n+\n+            return new MutableBigInteger();\n+        }\n+\n+        MutableBigInteger result;\n+        if (shift > 0) {\n+            result = new MutableBigInteger(significand);\n+            result.leftShift(shift);\n+        } else {\n+            shift = -shift;\n+            result = new MutableBigInteger(shift < Long.SIZE ? significand >> shift : 0L);\n+        }\n+        return result;\n+    }\n+\n@@ -1895,0 +1933,148 @@\n+    \/**\n+     * Calculate the integer {@code n}th root {@code floor(nthRoot(this, n))} and the remainder,\n+     * where {@code nthRoot(., n)} denotes the mathematical {@code n}th root.\n+     * The contents of {@code this} are <em>not<\/em> changed. The value of {@code this}\n+     * is assumed to be non-negative and the root degree {@code n >= 3}.\n+     *\n+     * @implNote The implementation is based on the material in Richard P. Brent\n+     * and Paul Zimmermann, <a href=\"https:\/\/maths-people.anu.edu.au\/~brent\/pd\/mca-cup-0.5.9.pdf\">\n+     * Modern Computer Arithmetic<\/a>, 27-28.\n+     *\n+     * @return the integer {@code n}th root of {@code this} and the remainder\n+     *\/\n+    MutableBigInteger[] nthRootRem(int n) {\n+        \/\/ Special cases.\n+        if (this.isZero() || this.isOne())\n+            return new MutableBigInteger[] { this, new MutableBigInteger() };\n+\n+        final int bitLength = (int) this.bitLength();\n+        \/\/ if this < 2^n, result is unity\n+        if (bitLength <= n) {\n+            MutableBigInteger rem = new MutableBigInteger(this);\n+            rem.subtract(ONE);\n+            return new MutableBigInteger[] { new MutableBigInteger(1), rem };\n+        }\n+\n+        MutableBigInteger r;\n+        if (bitLength <= Long.SIZE) {\n+            \/\/ Initial estimate is the root of the unsigned long value.\n+            final long x = this.toLong();\n+            \/\/ Use fp arithmetic to get an upper bound of the root\n+            final double rad = Math.nextUp(x >= 0 ? x : x + 0x1p64);\n+            final double approx = n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n));\n+            long rLong = (long) Math.ceil(Math.nextUp(approx));\n+\n+            if (BigInteger.bitLengthForLong(rLong) * (n - 1) <= Long.SIZE) {\n+                \/\/ Refine the estimate.\n+                long r1 = rLong, rToN1;\n+                do {\n+                    rLong = r1;\n+                    rToN1 = BigInteger.unsignedLongPow(rLong, n - 1);\n+                    r1 = ((n - 1) * rLong + Long.divideUnsigned(x, rToN1)) \/ n;\n+                } while (r1 < rLong); \/\/ Terminate when non-decreasing.\n+\n+                return new MutableBigInteger[] {\n+                        new MutableBigInteger(rLong), new MutableBigInteger(x - rToN1 * rLong)\n+                };\n+            } else { \/\/ r^(n - 1) could overflow long range, use MutableBigInteger loop instead\n+                r = new MutableBigInteger(rLong);\n+            }\n+        } else {\n+            \/\/ Set up the initial estimate of the iteration.\n+            \/\/ Determine a right shift that is a multiple of n into finite double range.\n+            long shift;\n+            double rad;\n+            \/\/ Try to shift as many bits as possible\n+            \/\/ without losing precision in double's representation\n+            if (bitLength > Double.PRECISION) {\n+                shift = bitLength - Double.PRECISION;\n+                int shiftExcess = (int) (shift % n);\n+\n+                if (bitLength - (shift - shiftExcess) <= Double.MAX_EXPONENT) {\n+                    shift -= shiftExcess; \/\/ Adjust shift to a multiple of n\n+                    \/\/ Shift the value into finite double range\n+                    rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n+                } else { \/\/ this >> (shift - shiftExcess) could exceed finite double range, must lose precision\n+                    \/\/ Shift the value into finite double range\n+                    rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n+                    \/\/ Complete the shift to a multiple of n,\n+                    \/\/ avoiding to lose more bits than necessary.\n+                    if (shiftExcess != 0) {\n+                        int shiftLack = n - shiftExcess;\n+                        shift += shiftLack; \/\/ shift is long, no overflow\n+                        rad \/= Double.parseDouble(\"0x1p\" + shiftLack);\n+                    }\n+                }\n+            } else {\n+                shift = 0L;\n+                rad = this.toBigInteger().doubleValue();\n+            }\n+\n+            \/\/ Use the root of the shifted value as an estimate.\n+            rad = Math.nextUp(rad);\n+            final double approx = Math.nextUp(n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n)));\n+            if (shift == 0L) {\n+                r = valueOf(approx, 0);\n+            } else {\n+                \/\/ Allocate sufficient space to store the final root\n+                r = new MutableBigInteger(new int[(intLen - 1) \/ n + 1]);\n+                int approxExp = Math.getExponent(approx);\n+                if (approxExp == Double.MIN_EXPONENT - 1) \/\/ Handle subnormals\n+                    approxExp = Double.MIN_EXPONENT;\n+\n+                \/\/ Avoid to lose fraction bits\n+                if (approxExp >= Double.PRECISION - 1) {\n+                    r.copyValue(valueOf(approx, 0));\n+                } else {\n+                    int pow = Math.min((Double.PRECISION - 1) - approxExp, (int) (shift \/ n));\n+                    shift -= (long) pow * n;\n+                    r.copyValue(valueOf(approx, pow));\n+                }\n+\n+                \/\/ Refine the estimate, avoiding to compute non-significant bits\n+                final int trailingZeros = this.getLowestSetBit();\n+                int rootShift = (int) (shift \/ n);\n+                for (int rootBits = (int) r.bitLength(); rootShift >= rootBits; rootBits <<= 1) {\n+                    r.leftShift(rootBits);\n+                    rootShift -= rootBits;\n+\n+                    \/\/ Remove useless bits from the radicand\n+                    MutableBigInteger x = new MutableBigInteger(this);\n+                    int removedBits = rootShift * n;\n+                    x.rightShift(removedBits);\n+                    if (removedBits > trailingZeros)\n+                        x.add(ONE); \/\/ round up to ensure r is an upper bound of the root\n+\n+                    newtonRecurrenceNthRoot(x, r, n, r.toBigInteger().pow(n - 1));\n+                }\n+\n+                \/\/ Shift the approximate root back into the original range.\n+                r.safeLeftShift(rootShift);\n+            }\n+        }\n+\n+        \/\/ Refine the estimate.\n+        do {\n+            BigInteger rBig = r.toBigInteger();\n+            BigInteger rToN1 = rBig.pow(n - 1);\n+            MutableBigInteger rem = new MutableBigInteger(rToN1.multiply(rBig).mag);\n+            if (rem.subtract(this) <= 0)\n+                return new MutableBigInteger[] { r, rem };\n+\n+            newtonRecurrenceNthRoot(this, r, n, rToN1);\n+        } while (true);\n+    }\n+\n+    \/**\n+     * Computes {@code ((n-1)*r + x\/rToN1)\/n} and places the result in {@code r}.\n+     *\/\n+    private static void newtonRecurrenceNthRoot(\n+            MutableBigInteger x, MutableBigInteger r, int n, BigInteger rToN1) {\n+        MutableBigInteger dividend = new MutableBigInteger();\n+        r.mul(n - 1, dividend);\n+        MutableBigInteger xDivRToN1 = new MutableBigInteger();\n+        x.divide(new MutableBigInteger(rToN1.mag), xDivRToN1, false);\n+        dividend.add(xDivRToN1);\n+        dividend.divideOneWord(n, r);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"modified"}]}