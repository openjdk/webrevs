{"files":[{"patch":"@@ -163,1 +163,1 @@\n-     * the absolute value of {@code val * 2^pow}. Any fractional part is discarded.\n+     * the absolute value of the double val. Any fractional part is discarded.\n@@ -167,2 +167,4 @@\n-\n-    private static MutableBigInteger valueOf(double val, int pow) {\n+    private static MutableBigInteger valueOf(double val) {\n+        val = Math.abs(val);\n+        if (val < 0x1p63)\n+            return new MutableBigInteger((long) val);\n@@ -172,24 +174,5 @@\n-        int exponent = (int) ((valBits >> 52) & 0x7ffL);\n-        long significand = (exponent == 0\n-                ? (valBits & ((1L << 52) - 1)) << 1\n-                : (valBits & ((1L << 52) - 1)) | (1L << 52));\n-        exponent -= 1075;\n-        \/\/ At this point, |val| == significand * 2^exponent\n-\n-        long shiftL = (long) exponent + pow;\n-        int shift = (int) shiftL;\n-        if (shift != shiftL) {\n-            if (shiftL > 0L)\n-                throw new ArithmeticException(\"BigInteger Overflow\");\n-\n-            return new MutableBigInteger();\n-        }\n-\n-        MutableBigInteger result;\n-        if (shift > 0) {\n-            result = new MutableBigInteger(significand);\n-            result.leftShift(shift);\n-        } else {\n-            shift = -shift;\n-            result = new MutableBigInteger(shift < Long.SIZE ? significand >> shift : 0L);\n-        }\n+        int exponent = (int) ((valBits >> 52) & 0x7ffL) - 1075;\n+        long significand = (valBits & ((1L << 52) - 1)) | (1L << 52);\n+        \/\/ At this point, val == significand * 2^exponent, with exponent > 0\n+        MutableBigInteger result = new MutableBigInteger(significand);\n+        result.leftShift(exponent);\n@@ -1946,1 +1929,1 @@\n-    MutableBigInteger[] nthRootRem(int n) {\n+    MutableBigInteger[] nthRootRem(final int n) {\n@@ -2025,3 +2008,4 @@\n-            final double approx = Math.nextUp(n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n)));\n-            if (shift == 0L) {\n-                r = valueOf(approx, 0);\n+            double approx = Math.nextUp(n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n)));\n+            int rootShift = (int) (shift \/ n);\n+            if (rootShift == 0) {\n+                r = valueOf(approx);\n@@ -2031,11 +2015,17 @@\n-                int approxExp = Math.getExponent(approx);\n-                if (approxExp == Double.MIN_EXPONENT - 1) \/\/ Handle subnormals\n-                    approxExp = Double.MIN_EXPONENT;\n-\n-                \/\/ Avoid to lose fraction bits\n-                if (approxExp >= Double.PRECISION - 1) {\n-                    r.copyValue(valueOf(approx, 0));\n-                } else {\n-                    int pow = Math.min((Double.PRECISION - 1) - approxExp, (int) (shift \/ n));\n-                    shift -= (long) pow * n;\n-                    r.copyValue(valueOf(approx, pow));\n+\n+                \/\/ Discard wrong bits from the initial estimate\n+                int radExp = Math.getExponent(rad);\n+                if (radExp == Double.MIN_EXPONENT - 1) \/\/ Handle subnormals\n+                    radExp = Double.MIN_EXPONENT;\n+\n+                if (radExp >= Double.PRECISION - 1) { \/\/ Discard wrong integer bits\n+                    int wrongBits = ((radExp + 1) - Double.PRECISION) \/ n;\n+                    if ((long) rootShift + wrongBits > Integer.MAX_VALUE) \/\/ Avoid overflow\n+                        wrongBits = Integer.MAX_VALUE - rootShift;\n+\n+                    rootShift += wrongBits;\n+                    approx \/= Double.parseDouble(\"0x1p\" + wrongBits);\n+                } else { \/\/ Avoid to discard correct fraction bits\n+                    int correctBits = ((Double.PRECISION - 1) - radExp) \/ n;\n+                    rootShift -= correctBits;\n+                    approx *= Double.parseDouble(\"0x1p\" + correctBits);\n@@ -2043,0 +2033,1 @@\n+                r.copyValue(valueOf(Math.ceil(approx)));\n@@ -2046,1 +2037,0 @@\n-                int rootShift = (int) (shift \/ n);\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":33,"deletions":43,"binary":false,"changes":76,"status":"modified"}]}