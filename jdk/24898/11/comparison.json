{"files":[{"patch":"@@ -2746,0 +2746,72 @@\n+    \/**\n+     * Returns the integer {@code n}th root of this BigInteger. The integer\n+     * {@code n}th root of the corresponding mathematical integer {@code x} has the\n+     * same sign of {@code x}, and its magnitude is the largest integer {@code r}\n+     * such that {@code r**n <= abs(x)}. It is equal to the value of\n+     * {@code (x.signum() * floor(abs(nthRoot(x, n))))}, where {@code nthRoot(x, n)}\n+     * denotes the real {@code n}th root of {@code x} treated as a real. If {@code n}\n+     * is even and this BigInteger is negative, an {@code ArithmeticException} will be\n+     * thrown.\n+     *\n+     * <p>Note that the magnitude of the integer {@code n}th root will be less than\n+     * the magnitude of the real {@code n}th root if the latter is not representable\n+     * as an integral value.\n+     *\n+     * @param n the root degree\n+     * @return the integer {@code n}th root of {@code this}\n+     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n+     *                             defined.)\n+     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n+     *                             operation to yield a non-integer value.)\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is\n+     *                             negative. (This would cause the operation to\n+     *                             yield non-real roots.)\n+     * @see #sqrt()\n+     * @since 25\n+     *\/\n+    public BigInteger nthRoot(int n) {\n+        return n == 1 ? this : (n == 2 ? sqrt() : nthRootAndRemainder(n, false)[0]);\n+    }\n+\n+    \/**\n+     * Returns an array of two BigIntegers containing the integer {@code n}th root\n+     * {@code r} of {@code this} and its remainder {@code this - r^n},\n+     * respectively.\n+     *\n+     * @param n the root degree\n+     * @return an array of two BigIntegers with the integer {@code n}th root at\n+     *         offset 0 and the remainder at offset 1\n+     * @throws ArithmeticException if {@code n == 0} (Zeroth roots are not\n+     *                             defined.)\n+     * @throws ArithmeticException if {@code n} is negative. (This would cause the\n+     *                             operation to yield a non-integer value.)\n+     * @throws ArithmeticException if {@code n} is even and {@code this} is\n+     *                             negative. (This would cause the operation to\n+     *                             yield non-real roots.)\n+     * @see #sqrt()\n+     * @see #sqrtAndRemainder()\n+     * @see #nthRoot(int)\n+     * @since 25\n+     *\/\n+    public BigInteger[] nthRootAndRemainder(int n) {\n+        return n == 1 ? new BigInteger[] { this, ZERO }\n+                      : (n == 2 ? sqrtAndRemainder() : nthRootAndRemainder(n, true));\n+    }\n+\n+    \/**\n+     * Assume {@code n != 1 && n != 2}\n+     *\/\n+    private BigInteger[] nthRootAndRemainder(int n, boolean needRemainder) {\n+        if (n <= 0)\n+            throw new ArithmeticException(\"Non-positive root degree\");\n+\n+        if ((n & 1) == 0 && this.signum < 0)\n+            throw new ArithmeticException(\"Negative radicand with even root degree\");\n+\n+        MutableBigInteger[] rootRem = new MutableBigInteger(this.mag).nthRootRem(n);\n+        return new BigInteger[] {\n+                rootRem[0].toBigInteger(signum),\n+                needRemainder ? rootRem[1].toBigInteger(signum) : null\n+        };\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -161,0 +161,21 @@\n+    \/**\n+     * Returns a MutableBigInteger with a magnitude specified by\n+     * the absolute value of the double val. Any fractional part is discarded.\n+     *\n+     * Assume val is in the finite double range.\n+     *\/\n+    static MutableBigInteger valueOf(double val) {\n+        val = Math.abs(val);\n+        if (val < 0x1p63)\n+            return new MutableBigInteger((long) val);\n+        \/\/ Translate the double into exponent and significand, according\n+        \/\/ to the formulae in JLS, Section 20.10.22.\n+        long valBits = Double.doubleToRawLongBits(val);\n+        int exponent = (int) ((valBits >> 52) & 0x7ffL) - 1075;\n+        long significand = (valBits & ((1L << 52) - 1)) | (1L << 52);\n+        \/\/ At this point, val == significand * 2^exponent, with exponent > 0\n+        MutableBigInteger result = new MutableBigInteger(significand);\n+        result.leftShift(exponent);\n+        return result;\n+    }\n+\n@@ -1895,0 +1916,129 @@\n+    \/**\n+     * Calculate the integer {@code n}th root {@code floor(nthRoot(this, n))} and the remainder,\n+     * where {@code nthRoot(., n)} denotes the mathematical {@code n}th root.\n+     * The contents of {@code this} are <em>not<\/em> changed. The value of {@code this}\n+     * is assumed to be non-negative and the root degree {@code n >= 3}.\n+     *\n+     * @implNote The implementation is based on the material in Richard P. Brent\n+     * and Paul Zimmermann, <a href=\"https:\/\/maths-people.anu.edu.au\/~brent\/pd\/mca-cup-0.5.9.pdf\">\n+     * Modern Computer Arithmetic<\/a>, 27-28.\n+     *\n+     * @return the integer {@code n}th root of {@code this} and the remainder\n+     *\/\n+    MutableBigInteger[] nthRootRem(int n) {\n+        \/\/ Special cases.\n+        if (this.isZero() || this.isOne())\n+            return new MutableBigInteger[] { this, new MutableBigInteger() };\n+\n+        final int bitLength = (int) this.bitLength();\n+        \/\/ if this < 2^n, result is unity\n+        if (bitLength <= n) {\n+            MutableBigInteger rem = new MutableBigInteger(this);\n+            rem.subtract(ONE);\n+            return new MutableBigInteger[] { new MutableBigInteger(1), rem };\n+        }\n+\n+        MutableBigInteger r;\n+        long shift = 0L;\n+        if (bitLength <= Long.SIZE) {\n+            \/\/ Initial estimate is the root of the unsigned long value.\n+            final long x = this.toLong();\n+            \/\/ Use fp arithmetic to get an upper bound of the root\n+            final double rad = Math.nextUp(x >= 0 ? x : x + 0x1p64);\n+            final double approx = n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n));\n+            long rLong = (long) Math.ceil(Math.nextUp(approx));\n+\n+            if (BigInteger.bitLengthForLong(rLong) * (n - 1) <= Long.SIZE) {\n+                \/\/ Refine the estimate.\n+                long r1 = rLong, rToN1;\n+                do {\n+                    rLong = r1;\n+                    rToN1 = BigInteger.unsignedLongPow(rLong, n - 1);\n+                    r1 = ((n - 1) * rLong + Long.divideUnsigned(x, rToN1)) \/ n;\n+                } while (r1 < rLong); \/\/ Terminate when non-decreasing.\n+\n+                return new MutableBigInteger[] {\n+                        new MutableBigInteger(rLong), new MutableBigInteger(x - rToN1 * rLong)\n+                };\n+            } else { \/\/ r^(n - 1) could overflow long range, use MutableBigInteger loop instead\n+                r = new MutableBigInteger(rLong);\n+            }\n+        } else {\n+            \/\/ Set up the initial estimate of the iteration.\n+            \/\/ Determine a right shift that is a multiple of n into finite double range.\n+            double rad;\n+            if (bitLength > Double.MAX_EXPONENT) {\n+                shift = bitLength - Double.MAX_EXPONENT;\n+                int shiftExcess = (int) (shift % n);\n+\n+                \/\/ Shift the value into finite double range\n+                rad = this.toBigInteger().shiftRight((int) shift).doubleValue();\n+                \/\/ Complete the shift to a multiple of n,\n+                \/\/ avoiding to lose more bits than necessary.\n+                if (shiftExcess != 0) {\n+                    int shiftLack = n - shiftExcess;\n+                    shift += shiftLack; \/\/ shift is long, no overflow\n+                    rad \/= Double.parseDouble(\"0x1p\" + shiftLack);\n+                }\n+            } else {\n+                rad = this.toBigInteger().doubleValue();\n+            }\n+\n+            \/\/ Use the root of the shifted value as an estimate.\n+            rad = Math.nextUp(rad);\n+            double approx = n == 3 ? Math.cbrt(rad) : Math.pow(rad, Math.nextUp(1.0 \/ n));\n+            approx = Math.ceil(Math.nextUp(approx));\n+            if (shift == 0L) {\n+                r = valueOf(approx);\n+            } else {\n+                \/\/ Allocate sufficient space to store the final root\n+                r = new MutableBigInteger(new int[(intLen - 1) \/ n + 1]);\n+                r.copyValue(valueOf(approx));\n+            }\n+        }\n+\n+        \/\/ Refine the estimate, avoiding to compute non-significant bits\n+        final int trailingZeros = this.getLowestSetBit();\n+        int rootShift = (int) (shift \/ n);\n+        for (int rootBits = (int) r.bitLength(); rootShift >= rootBits; rootBits <<= 1) {\n+            r.leftShift(rootBits);\n+            rootShift -= rootBits;\n+\n+            \/\/ Remove useless bits from the radicand\n+            MutableBigInteger x = new MutableBigInteger(this);\n+            int removedBits = rootShift * n;\n+            x.rightShift(removedBits);\n+            if (removedBits > trailingZeros)\n+                x.add(ONE); \/\/ round up to ensure r is an upper bound of the root\n+\n+            newtonRecurrenceNthRoot(x, r, n, r.toBigInteger().pow(n - 1), r);\n+        }\n+\n+        \/\/ Shift the approximate root back into the original range.\n+        r.safeLeftShift(rootShift);\n+        \/\/ Refine the estimate.\n+        do {\n+            BigInteger rBig = r.toBigInteger();\n+            BigInteger rToN1 = rBig.pow(n - 1);\n+            MutableBigInteger rem = new MutableBigInteger(rToN1.multiply(rBig).mag);\n+            if (rem.subtract(this) <= 0)\n+                return new MutableBigInteger[] { r, rem };\n+\n+            newtonRecurrenceNthRoot(this, r, n, rToN1, r);\n+        } while (true);\n+    }\n+\n+    \/**\n+     * Computes {@code ((n-1)*r + x\/rToN1)\/n} and places the result in {@code res}.\n+     * {@code res} and {@code r} can be the same object.\n+     *\/\n+    private static void newtonRecurrenceNthRoot(\n+            MutableBigInteger x, MutableBigInteger r, int n, BigInteger rToN1, MutableBigInteger res) {\n+        MutableBigInteger dividend = new MutableBigInteger();\n+        r.mul(n - 1, dividend);\n+        MutableBigInteger xDivRToN1 = new MutableBigInteger();\n+        x.divide(new MutableBigInteger(rToN1.mag), xDivRToN1, false);\n+        dividend.add(xDivRToN1);\n+        dividend.divideOneWord(n, res);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"modified"}]}