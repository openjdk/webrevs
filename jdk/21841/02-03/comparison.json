{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Map;\n@@ -37,0 +38,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -46,0 +48,2 @@\n+    private static final Map<String, Pattern> patternCache =\n+            new ConcurrentHashMap<>();\n@@ -114,1 +118,2 @@\n-    private static boolean wildCardMatch(String pattern, String algorithm) {\n+    private static boolean wildCardMatch(final String pattern,\n+                                         final String algorithm) {\n@@ -116,1 +121,1 @@\n-            if (!pattern.toUpperCase(Locale.ENGLISH).startsWith(\"TLS_\")) {\n+            if (!pattern.startsWith(\"TLS_\")) {\n@@ -118,1 +123,1 @@\n-                        \"Wildcard pattern should start with 'TLS_'\");\n+                        \"Wildcard pattern must start with 'TLS_'\");\n@@ -121,4 +126,8 @@\n-            return Pattern.compile(pattern.replace(\"*\", \".*\"),\n-                                   Pattern.CASE_INSENSITIVE)\n-                    .matcher(algorithm)\n-                    .matches();\n+            Pattern p = patternCache.get(pattern);\n+\n+            if (p == null) {\n+                p = Pattern.compile(pattern.replace(\"*\", \".*\"));\n+                patternCache.put(pattern, p);\n+            }\n+\n+            return p.matcher(algorithm).matches();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AbstractAlgorithmConstraints.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -779,3 +779,4 @@\n-# can be disabled here using \"*\" wildcard syntax. For example \"TLS_RSA_*\"\n-# disables all cipher suites that start with \"TLS_RSA_\". Only the algorithms\n-# starting with \"TLS_\" are allowed to have \"*\" wildcard.\n+# can be disabled with this property using one or more \"*\" wildcard characters.\n+# For example, \"TLS_RSA_*\" disables all cipher suites that start with\n+# \"TLS_RSA_\". Only cipher suites starting with \"TLS_\" are allowed to have\n+# wildcard characters.\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,295 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLSession;\n+\n+\/**\n+ * This is not a test. Actual tests are implemented by concrete subclasses.\n+ * The abstract class AbstractDisableCipherSuites provides a base framework\n+ * for testing cipher suite disablement.\n+ *\/\n+public abstract class AbstractDisableCipherSuites {\n+\n+    private static final byte RECTYPE_HS = 0x16;\n+    private static final byte HSMSG_CLIHELLO = 0x01;\n+    private static final ByteBuffer CLIOUTBUF =\n+            ByteBuffer.wrap(\"Client Side\".getBytes());\n+\n+    \/**\n+     * Create an engine with the default set of cipher suites enabled and make\n+     * sure none of the disabled suites are present in the client hello.\n+     *\n+     * @param disabledSuiteIds the {@code List} of disabled cipher suite IDs\n+     *      to be checked for.\n+     *\n+     * @return true if the test passed (No disabled suites), false otherwise\n+     *\/\n+    protected boolean testDefaultCase(List<Integer> disabledSuiteIds)\n+            throws Exception {\n+        System.err.println(\"\\nTest: Default SSLEngine suite set\");\n+        SSLEngine ssle = makeEngine();\n+        if (getDebug()) {\n+            listCiphers(\"Suite set upon creation\", ssle);\n+        }\n+        SSLEngineResult clientResult;\n+        ByteBuffer cTOs = makeClientBuf(ssle);\n+        clientResult = ssle.wrap(CLIOUTBUF, cTOs);\n+        if (getDebug()) {\n+            dumpResult(\"ClientHello: \", clientResult);\n+        }\n+        cTOs.flip();\n+        boolean foundSuite = areSuitesPresentCH(cTOs, disabledSuiteIds);\n+        if (foundSuite) {\n+            System.err.println(\"FAIL: Found disabled suites!\");\n+            return false;\n+        } else {\n+            System.err.println(\"PASS: No disabled suites found.\");\n+            return true;\n+        }\n+    }\n+\n+    \/**\n+     * Create an engine and set only disabled cipher suites.\n+     * The engine should not create the client hello message since the only\n+     * available suites to assert in the client hello are disabled ones.\n+     *\n+     * @param disabledSuiteNames an array of cipher suite names that\n+     *      should be disabled cipher suites.\n+     *\n+     * @return true if the engine throws SSLHandshakeException during client\n+     *      hello creation, false otherwise.\n+     *\/\n+    protected boolean testEngOnlyDisabled(String[] disabledSuiteNames)\n+            throws Exception {\n+        System.err.println(\n+                \"\\nTest: SSLEngine configured with only disabled suites\");\n+        try {\n+            SSLEngine ssle = makeEngine();\n+            ssle.setEnabledCipherSuites(disabledSuiteNames);\n+            if (getDebug()) {\n+                listCiphers(\"Suite set upon creation\", ssle);\n+            }\n+            SSLEngineResult clientResult;\n+            ByteBuffer cTOs = makeClientBuf(ssle);\n+            clientResult = ssle.wrap(CLIOUTBUF, cTOs);\n+            if (getDebug()) {\n+                dumpResult(\"ClientHello: \", clientResult);\n+            }\n+            cTOs.flip();\n+        } catch (SSLHandshakeException shse) {\n+            System.err.println(\"PASS: Caught expected exception: \" + shse);\n+            return true;\n+        }\n+        System.err.println(\"FAIL: Expected SSLHandshakeException not thrown\");\n+        return false;\n+    }\n+\n+    \/**\n+     * Create an engine and add some disabled suites to the default\n+     * set of cipher suites.  Make sure none of the disabled suites show up\n+     * in the client hello even though they were explicitly added.\n+     *\n+     * @param disabledNames an array of cipher suite names that\n+     *      should be disabled cipher suites.\n+     * @param disabledIds the {@code List} of disabled cipher suite IDs\n+     *      to be checked for.\n+     *\n+     * @return true if the test passed (No disabled suites), false otherwise\n+     *\/\n+    protected boolean testEngAddDisabled(String[] disabledNames,\n+                                         List<Integer> disabledIds) throws Exception {\n+        System.err.println(\"\\nTest: SSLEngine with disabled suites added\");\n+        SSLEngine ssle = makeEngine();\n+\n+        \/\/ Add disabled suites to the existing engine's set of enabled suites\n+        String[] initialSuites = ssle.getEnabledCipherSuites();\n+        String[] plusDisSuites = Arrays.copyOf(initialSuites,\n+                                               initialSuites.length + disabledNames.length);\n+        System.arraycopy(disabledNames, 0, plusDisSuites,\n+                         initialSuites.length, disabledNames.length);\n+        ssle.setEnabledCipherSuites(plusDisSuites);\n+\n+        if (getDebug()) {\n+            listCiphers(\"Suite set upon creation\", ssle);\n+        }\n+        SSLEngineResult clientResult;\n+        ByteBuffer cTOs = makeClientBuf(ssle);\n+        clientResult = ssle.wrap(CLIOUTBUF, cTOs);\n+        if (getDebug()) {\n+            dumpResult(\"ClientHello: \", clientResult);\n+        }\n+        cTOs.flip();\n+        boolean foundDisabled = areSuitesPresentCH(cTOs, disabledIds);\n+        if (foundDisabled) {\n+            System.err.println(\"FAIL: Found disabled suites!\");\n+            return false;\n+        } else {\n+            System.err.println(\"PASS: No disabled suites found.\");\n+            return true;\n+        }\n+    }\n+\n+    protected String getProtocol() {\n+        return \"TLSv1.2\";\n+    }\n+\n+    private SSLEngine makeEngine() throws GeneralSecurityException {\n+        SSLContext ctx = SSLContext.getInstance(getProtocol());\n+        ctx.init(null, null, null);\n+        return ctx.createSSLEngine();\n+    }\n+\n+    private static ByteBuffer makeClientBuf(SSLEngine ssle) {\n+        ssle.setUseClientMode(true);\n+        ssle.setNeedClientAuth(false);\n+        SSLSession sess = ssle.getSession();\n+        ByteBuffer cTOs = ByteBuffer.allocateDirect(sess.getPacketBufferSize());\n+        return cTOs;\n+    }\n+\n+    private static void listCiphers(String prefix, SSLEngine ssle) {\n+        System.err.println(prefix + \"\\n---------------\");\n+        String[] suites = ssle.getEnabledCipherSuites();\n+        for (String suite : suites) {\n+            System.err.println(suite);\n+        }\n+        System.err.println(\"---------------\");\n+    }\n+\n+    \/**\n+     * Walk a TLS 1.2 or earlier ClientHello looking for any of the suites\n+     * in the suiteIdList.\n+     *\n+     * @param clientHello a ByteBuffer containing the ClientHello message as\n+     *      a complete TLS record.  The position of the buffer should be\n+     *      at the first byte of the TLS record header.\n+     * @param suiteIdList a List of integer values corresponding to\n+     *      TLS cipher suite identifiers.\n+     *\n+     * @return true if at least one of the suites in {@code suiteIdList}\n+     * is found in the ClientHello's cipher suite list\n+     *\n+     * @throws IOException if the data in the {@code clientHello}\n+     *      buffer is not a TLS handshake message or is not a client hello.\n+     *\/\n+    private boolean areSuitesPresentCH(ByteBuffer clientHello,\n+                                       List<Integer> suiteIdList) throws IOException {\n+        byte val;\n+\n+        \/\/ Process the TLS Record\n+        val = clientHello.get();\n+        if (val != RECTYPE_HS) {\n+            throw new IOException(\n+                    \"Not a handshake record, type = \" + val);\n+        }\n+\n+        \/\/ Just skip over the version and length\n+        clientHello.position(clientHello.position() + 4);\n+\n+        \/\/ Check the handshake message type\n+        val = clientHello.get();\n+        if (val != HSMSG_CLIHELLO) {\n+            throw new IOException(\n+                    \"Not a ClientHello handshake message, type = \" + val);\n+        }\n+\n+        \/\/ Skip over the length\n+        clientHello.position(clientHello.position() + 3);\n+\n+        \/\/ Skip over the protocol version (2) and random (32);\n+        clientHello.position(clientHello.position() + 34);\n+\n+        \/\/ Skip past the session ID (variable length <= 32)\n+        int len = Byte.toUnsignedInt(clientHello.get());\n+        if (len > 32) {\n+            throw new IOException(\"Session ID is too large, len = \" + len);\n+        }\n+        clientHello.position(clientHello.position() + len);\n+\n+        \/\/ Finally, we are at the cipher suites.  Walk the list and place them\n+        \/\/ into a List.\n+        int csLen = Short.toUnsignedInt(clientHello.getShort());\n+        if (csLen % 2 != 0) {\n+            throw new IOException(\"CipherSuite length is invalid, len = \" +\n+                                          csLen);\n+        }\n+        int csCount = csLen \/ 2;\n+        List<Integer> csSuiteList = new ArrayList<>(csCount);\n+        log(\"Found following suite IDs in hello:\");\n+        for (int i = 0; i < csCount; i++) {\n+            int curSuite = Short.toUnsignedInt(clientHello.getShort());\n+            log(String.format(\"Suite ID: 0x%04x\", curSuite));\n+            csSuiteList.add(curSuite);\n+        }\n+\n+        \/\/ Now check to see if any of the suites passed in match what is in\n+        \/\/ the suite list.\n+        boolean foundMatch = false;\n+        for (Integer cs : suiteIdList) {\n+            if (csSuiteList.contains(cs)) {\n+                System.err.format(\"Found match for suite ID 0x%04x\\n\", cs);\n+                foundMatch = true;\n+                break;\n+            }\n+        }\n+\n+        \/\/ We don't care about the rest of the ClientHello message.\n+        \/\/ Rewind and return whether we found a match or not.\n+        clientHello.rewind();\n+        return foundMatch;\n+    }\n+\n+    private static void dumpResult(String str, SSLEngineResult result) {\n+        System.err.println(\"The format of the SSLEngineResult is: \\n\" +\n+                                   \"\\t\\\"getStatus() \/ getHandshakeStatus()\\\" +\\n\" +\n+                                   \"\\t\\\"bytesConsumed() \/ bytesProduced()\\\"\\n\");\n+        HandshakeStatus hsStatus = result.getHandshakeStatus();\n+        System.err.println(str + result.getStatus() + \"\/\" + hsStatus + \", \" +\n+                                   result.bytesConsumed() + \"\/\" + result.bytesProduced() + \" bytes\");\n+        if (hsStatus == HandshakeStatus.FINISHED) {\n+            System.err.println(\"\\t...ready for application data\");\n+        }\n+    }\n+\n+    private void log(String str) {\n+        if (getDebug()) {\n+            System.err.println(str);\n+        }\n+    }\n+\n+    protected boolean getDebug() {\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/AbstractDisableCipherSuites.java","additions":295,"deletions":0,"binary":false,"changes":295,"status":"added"},{"patch":"@@ -37,7 +37,0 @@\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.security.GeneralSecurityException;\n-import java.util.List;\n-import java.util.ArrayList;\n@@ -45,0 +38,1 @@\n+import java.util.List;\n@@ -46,1 +40,1 @@\n-public class NoDesRC4DesEdeCiphSuite {\n+public class NoDesRC4DesEdeCiphSuite extends AbstractDisableCipherSuites {\n@@ -48,2 +42,0 @@\n-    private static final byte RECTYPE_HS = 0x16;\n-    private static final byte HSMSG_CLIHELLO = 0x01;\n@@ -94,2 +86,0 @@\n-    private static final ByteBuffer CLIOUTBUF =\n-            ByteBuffer.wrap(\"Client Side\".getBytes());\n@@ -124,246 +114,0 @@\n-\n-    \/**\n-     * Create an engine with the default set of cipher suites enabled and make\n-     * sure none of the disabled suites are present in the client hello.\n-     *\n-     * @param disabledSuiteIds the {@code List} of disabled cipher suite IDs\n-     *      to be checked for.\n-     *\n-     * @return true if the test passed (No disabled suites), false otherwise\n-     *\/\n-    protected boolean testDefaultCase(List<Integer> disabledSuiteIds)\n-            throws Exception {\n-        System.err.println(\"\\nTest: Default SSLEngine suite set\");\n-        SSLEngine ssle = makeEngine();\n-        if (getDebug()) {\n-            listCiphers(\"Suite set upon creation\", ssle);\n-        }\n-        SSLEngineResult clientResult;\n-        ByteBuffer cTOs = makeClientBuf(ssle);\n-        clientResult = ssle.wrap(CLIOUTBUF, cTOs);\n-        if (getDebug()) {\n-            dumpResult(\"ClientHello: \", clientResult);\n-        }\n-        cTOs.flip();\n-        boolean foundSuite = areSuitesPresentCH(cTOs, disabledSuiteIds);\n-        if (foundSuite) {\n-            System.err.println(\"FAIL: Found disabled suites!\");\n-            return false;\n-        } else {\n-            System.err.println(\"PASS: No disabled suites found.\");\n-            return true;\n-        }\n-    }\n-\n-    \/**\n-     * Create an engine and set only disabled cipher suites.\n-     * The engine should not create the client hello message since the only\n-     * available suites to assert in the client hello are disabled ones.\n-     *\n-     * @param disabledSuiteNames an array of cipher suite names that\n-     *      should be disabled cipher suites.\n-     *\n-     * @return true if the engine throws SSLHandshakeException during client\n-     *      hello creation, false otherwise.\n-     *\/\n-    protected boolean testEngOnlyDisabled(String[] disabledSuiteNames)\n-            throws Exception {\n-        System.err.println(\n-                \"\\nTest: SSLEngine configured with only disabled suites\");\n-        try {\n-            SSLEngine ssle = makeEngine();\n-            ssle.setEnabledCipherSuites(disabledSuiteNames);\n-            if (getDebug()) {\n-                listCiphers(\"Suite set upon creation\", ssle);\n-            }\n-            SSLEngineResult clientResult;\n-            ByteBuffer cTOs = makeClientBuf(ssle);\n-            clientResult = ssle.wrap(CLIOUTBUF, cTOs);\n-            if (getDebug()) {\n-                dumpResult(\"ClientHello: \", clientResult);\n-            }\n-            cTOs.flip();\n-        } catch (SSLHandshakeException shse) {\n-            System.err.println(\"PASS: Caught expected exception: \" + shse);\n-            return true;\n-        }\n-        System.err.println(\"FAIL: Expected SSLHandshakeException not thrown\");\n-        return false;\n-    }\n-\n-    \/**\n-     * Create an engine and add some disabled suites to the default\n-     * set of cipher suites.  Make sure none of the disabled suites show up\n-     * in the client hello even though they were explicitly added.\n-     *\n-     * @param disabledNames an array of cipher suite names that\n-     *      should be disabled cipher suites.\n-     * @param disabledIds the {@code List} of disabled cipher suite IDs\n-     *      to be checked for.\n-     *\n-     * @return true if the test passed (No disabled suites), false otherwise\n-     *\/\n-    protected boolean testEngAddDisabled(String[] disabledNames,\n-            List<Integer> disabledIds) throws Exception {\n-        System.err.println(\"\\nTest: SSLEngine with disabled suites added\");\n-        SSLEngine ssle = makeEngine();\n-\n-        \/\/ Add disabled suites to the existing engine's set of enabled suites\n-        String[] initialSuites = ssle.getEnabledCipherSuites();\n-        String[] plusDisSuites = Arrays.copyOf(initialSuites,\n-                initialSuites.length + disabledNames.length);\n-        System.arraycopy(disabledNames, 0, plusDisSuites,\n-                initialSuites.length, disabledNames.length);\n-        ssle.setEnabledCipherSuites(plusDisSuites);\n-\n-        if (getDebug()) {\n-            listCiphers(\"Suite set upon creation\", ssle);\n-        }\n-        SSLEngineResult clientResult;\n-        ByteBuffer cTOs = makeClientBuf(ssle);\n-        clientResult = ssle.wrap(CLIOUTBUF, cTOs);\n-        if (getDebug()) {\n-            dumpResult(\"ClientHello: \", clientResult);\n-        }\n-        cTOs.flip();\n-        boolean foundDisabled = areSuitesPresentCH(cTOs, disabledIds);\n-        if (foundDisabled) {\n-            System.err.println(\"FAIL: Found disabled suites!\");\n-            return false;\n-        } else {\n-            System.err.println(\"PASS: No disabled suites found.\");\n-            return true;\n-        }\n-    }\n-\n-    protected String getProtocol() {\n-        return \"TLSv1.2\";\n-    }\n-\n-    private SSLEngine makeEngine() throws GeneralSecurityException {\n-        SSLContext ctx = SSLContext.getInstance(getProtocol());\n-        ctx.init(null, null, null);\n-        return ctx.createSSLEngine();\n-    }\n-\n-    private static ByteBuffer makeClientBuf(SSLEngine ssle) {\n-        ssle.setUseClientMode(true);\n-        ssle.setNeedClientAuth(false);\n-        SSLSession sess = ssle.getSession();\n-        ByteBuffer cTOs = ByteBuffer.allocateDirect(sess.getPacketBufferSize());\n-        return cTOs;\n-    }\n-\n-    private static void listCiphers(String prefix, SSLEngine ssle) {\n-        System.err.println(prefix + \"\\n---------------\");\n-        String[] suites = ssle.getEnabledCipherSuites();\n-        for (String suite : suites) {\n-            System.err.println(suite);\n-        }\n-        System.err.println(\"---------------\");\n-    }\n-\n-    \/**\n-     * Walk a TLS 1.2 or earlier ClientHello looking for any of the suites\n-     * in the suiteIdList.\n-     *\n-     * @param clientHello a ByteBuffer containing the ClientHello message as\n-     *      a complete TLS record.  The position of the buffer should be\n-     *      at the first byte of the TLS record header.\n-     * @param suiteIdList a List of integer values corresponding to\n-     *      TLS cipher suite identifiers.\n-     *\n-     * @return true if at least one of the suites in {@code suiteIdList}\n-     * is found in the ClientHello's cipher suite list\n-     *\n-     * @throws IOException if the data in the {@code clientHello}\n-     *      buffer is not a TLS handshake message or is not a client hello.\n-     *\/\n-    private boolean areSuitesPresentCH(ByteBuffer clientHello,\n-            List<Integer> suiteIdList) throws IOException {\n-        byte val;\n-\n-        \/\/ Process the TLS Record\n-        val = clientHello.get();\n-        if (val != RECTYPE_HS) {\n-            throw new IOException(\n-                    \"Not a handshake record, type = \" + val);\n-        }\n-\n-        \/\/ Just skip over the version and length\n-        clientHello.position(clientHello.position() + 4);\n-\n-        \/\/ Check the handshake message type\n-        val = clientHello.get();\n-        if (val != HSMSG_CLIHELLO) {\n-            throw new IOException(\n-                    \"Not a ClientHello handshake message, type = \" + val);\n-        }\n-\n-        \/\/ Skip over the length\n-        clientHello.position(clientHello.position() + 3);\n-\n-        \/\/ Skip over the protocol version (2) and random (32);\n-        clientHello.position(clientHello.position() + 34);\n-\n-        \/\/ Skip past the session ID (variable length <= 32)\n-        int len = Byte.toUnsignedInt(clientHello.get());\n-        if (len > 32) {\n-            throw new IOException(\"Session ID is too large, len = \" + len);\n-        }\n-        clientHello.position(clientHello.position() + len);\n-\n-        \/\/ Finally, we are at the cipher suites.  Walk the list and place them\n-        \/\/ into a List.\n-        int csLen = Short.toUnsignedInt(clientHello.getShort());\n-        if (csLen % 2 != 0) {\n-            throw new IOException(\"CipherSuite length is invalid, len = \" +\n-                    csLen);\n-        }\n-        int csCount = csLen \/ 2;\n-        List<Integer> csSuiteList = new ArrayList<>(csCount);\n-        log(\"Found following suite IDs in hello:\");\n-        for (int i = 0; i < csCount; i++) {\n-            int curSuite = Short.toUnsignedInt(clientHello.getShort());\n-            log(String.format(\"Suite ID: 0x%04x\", curSuite));\n-            csSuiteList.add(curSuite);\n-        }\n-\n-        \/\/ Now check to see if any of the suites passed in match what is in\n-        \/\/ the suite list.\n-        boolean foundMatch = false;\n-        for (Integer cs : suiteIdList) {\n-            if (csSuiteList.contains(cs)) {\n-                System.err.format(\"Found match for suite ID 0x%04x\\n\", cs);\n-                foundMatch = true;\n-                break;\n-            }\n-        }\n-\n-        \/\/ We don't care about the rest of the ClientHello message.\n-        \/\/ Rewind and return whether we found a match or not.\n-        clientHello.rewind();\n-        return foundMatch;\n-    }\n-\n-    private static void dumpResult(String str, SSLEngineResult result) {\n-        System.err.println(\"The format of the SSLEngineResult is: \\n\" +\n-            \"\\t\\\"getStatus() \/ getHandshakeStatus()\\\" +\\n\" +\n-            \"\\t\\\"bytesConsumed() \/ bytesProduced()\\\"\\n\");\n-        HandshakeStatus hsStatus = result.getHandshakeStatus();\n-        System.err.println(str + result.getStatus() + \"\/\" + hsStatus + \", \" +\n-            result.bytesConsumed() + \"\/\" + result.bytesProduced() + \" bytes\");\n-        if (hsStatus == HandshakeStatus.FINISHED) {\n-            System.err.println(\"\\t...ready for application data\");\n-        }\n-    }\n-\n-    private void log(String str) {\n-        if (getDebug()) {\n-            System.err.println(str);\n-        }\n-    }\n-\n-    protected boolean getDebug() {\n-        return false;\n-    }\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/NoDesRC4DesEdeCiphSuite.java","additions":2,"deletions":258,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    NoDesRC4DesEdeCiphSuite {\n+        AbstractDisableCipherSuites {\n@@ -44,1 +44,1 @@\n-            \"TLS_ECDH_*, TLS_RSA_*, TLS_ECDHE_*_WITH_AES_256_GCM_*, Tls_DH_anon_*SHA, tls_ECDH_anon_WITH_AES_*_SHA\";\n+            \"TLS_ECDH_*, TLS_RSA_*, TLS_ECDHE_*_WITH_AES_256_GCM_*, TLS_DH_anon_*SHA, TLS_ECDH_anon_WITH_AES_*_SHA\";\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/TLSCipherSuiteWildCardMatchingDisablePartsOfCipherSuite.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-            assertEquals(\"Wildcard pattern should start with 'TLS_'\",\n+            assertEquals(\"Wildcard pattern must start with 'TLS_'\",\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/TLSCipherSuiteWildCardMatchingIllegalArgument.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}