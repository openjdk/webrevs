{"files":[{"patch":"@@ -126,2 +126,2 @@\n-    <Field type=\"Class\" name=\"monitorClass\" label=\"Monitor Class\" \/>\n-    <Field type=\"ulong\" contentType=\"address\" name=\"address\" label=\"Monitor Address\" relation=\"JavaMonitorAddress\" \/>\n+    <Field type=\"Class\" name=\"monitorClass\" label=\"Monitor Class\" description=\"Class of the object deflated. If null or N\/A, the object has been garbage collected.\" \/>\n+    <Field type=\"ulong\" contentType=\"address\" name=\"address\" label=\"Monitor Address\" relation=\"JavaMonitorAddress\" description=\"Address of the object deflated. If null or N\/A, the object has been garbage collected.\"\/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -740,3 +740,12 @@\n-  const Klass* monitor_klass = obj->klass();\n-  if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n-    return;\n+  if (obj == nullptr) {\n+    \/\/ Accept the case when obj was already garbage-collected.\n+    \/\/ Emit the event anyway, but without details.\n+    event->set_monitorClass(nullptr);\n+    event->set_address(0);\n+  } else {\n+    const Klass* monitor_klass = obj->klass();\n+    if (ObjectMonitor::is_jfr_excluded(monitor_klass)) {\n+      return;\n+    }\n+    event->set_monitorClass(monitor_klass);\n+    event->set_address((uintptr_t)(void*)obj);\n@@ -744,2 +753,0 @@\n-  event->set_monitorClass(monitor_klass);\n-  event->set_address((uintptr_t)(void*)obj);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.thread.TestThread;\n+import jdk.test.lib.thread.XRun;\n+\n+\/**\n+ * @test StressJavaMonitorEvents\n+ * @summary Tests that VM does not crash when monitor-related JFR events are enabled\n+ * @requires vm.flagless\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:GuaranteedAsyncDeflationInterval=100 jdk.jfr.event.runtime.StressJavaMonitorEvents\n+ *\/\n+public class StressJavaMonitorEvents {\n+\n+    static final int RUN_TIME_MS = 10000;\n+    static final int GC_EVERY_MS = 500;\n+    static final int THREADS = 4;\n+    static final int NUM_LOCKS = 1024;\n+\n+    static final List<String> CAPTURE_EVENTS = List.of(\n+        EventNames.JavaMonitorEnter,\n+        EventNames.JavaMonitorWait,\n+        EventNames.JavaMonitorNotify,\n+        EventNames.JavaMonitorInflate,\n+        EventNames.JavaMonitorDeflate,\n+        EventNames.JavaMonitorStatistics\n+    );\n+\n+    static final Set<String> CAN_BE_ZERO_EVENTS = Set.of(\n+        \/\/ Only when lock actually gets contended, not guaranteed.\n+        EventNames.JavaMonitorEnter,\n+        \/\/ Only when there are waiters on the lock, not guaranteed.\n+        EventNames.JavaMonitorNotify\n+    );\n+\n+    static final Object[] LOCKS = new Object[NUM_LOCKS];\n+\n+    public static TestThread startThread(final long deadline) {\n+        TestThread t = new TestThread(new XRun() {\n+            @Override\n+            public void xrun() throws Throwable {\n+                ThreadLocalRandom r = ThreadLocalRandom.current();\n+                while (System.nanoTime() < deadline) {\n+                    \/\/ Overwrite random lock, making the old one dead\n+                    LOCKS[r.nextInt(NUM_LOCKS)] = new Object();\n+\n+                    \/\/ Wait on random lock, inflating it\n+                    Object waitLock = LOCKS[r.nextInt(NUM_LOCKS)];\n+                    if (waitLock != null) {\n+                        synchronized (waitLock) {\n+                            waitLock.wait(1);\n+                        }\n+                    }\n+\n+                    \/\/ Notify a random lock\n+                    Object notifyLock = LOCKS[r.nextInt(NUM_LOCKS)];\n+                    if (notifyLock != null) {\n+                        synchronized (notifyLock) {\n+                            notifyLock.notify();\n+                        }\n+                    }\n+\n+                    \/\/ Notify all on a random lock\n+                    Object notifyAllLock = LOCKS[r.nextInt(NUM_LOCKS)];\n+                    if (notifyAllLock != null) {\n+                        synchronized (notifyAllLock) {\n+                            notifyAllLock.notifyAll();\n+                        }\n+                    }\n+                }\n+            }\n+        });\n+        t.start();\n+        return t;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Map<String, AtomicLong> counters = new HashMap<>();\n+\n+        try (RecordingStream rs = new RecordingStream()) {\n+            \/\/ Setup all interesting events, and start recording.\n+            for (String ev : CAPTURE_EVENTS) {\n+                rs.enable(ev).withoutThreshold();\n+                AtomicLong counter = new AtomicLong();\n+                rs.onEvent(ev, e -> counter.incrementAndGet());\n+                counters.put(ev, counter);\n+            }\n+            rs.startAsync();\n+\n+            long deadline = System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(RUN_TIME_MS);\n+            List<TestThread> threads = new ArrayList<>();\n+            for (int t = 0; t < THREADS; t++) {\n+                threads.add(startThread(deadline));\n+            }\n+\n+            \/\/ Trigger GCs periodically to yield dead objects with inflated monitors.\n+            while (System.nanoTime() < deadline) {\n+                Thread.sleep(GC_EVERY_MS);\n+                System.gc();\n+            }\n+\n+            \/\/ Wait for all threads to exit and close the recording.\n+            for (TestThread t : threads) {\n+                t.join();\n+            }\n+            rs.close();\n+\n+            \/\/ Print stats and check event counts.\n+            for (String ev : CAPTURE_EVENTS) {\n+                long count = counters.get(ev).get();\n+                System.out.println(ev + \": \" + count);\n+                assertTrue(CAN_BE_ZERO_EVENTS.contains(ev) || (count > 0));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/StressJavaMonitorEvents.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -59,0 +59,4 @@\n+    \/\/ Make sure the object stays reachable.\n+    \/\/ This guarantees the fields are fully set up on deflation.\n+    static final Lock lock = new Lock();\n+\n@@ -60,1 +64,0 @@\n-        final Lock lock = new Lock();\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestJavaMonitorDeflateEvent.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}