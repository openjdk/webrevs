{"files":[{"patch":"@@ -54,0 +54,5 @@\n+  if (!rs.is_reserved()) {\n+    \/\/ Failed to reserve memory for the bitmap,\n+    return false;\n+  }\n+\n@@ -61,7 +66,0 @@\n-  if (_virtual_space != nullptr && _virtual_space->expand_by(_reserved_byte_size)) {\n-    _heap_start = covered_region.start();\n-    _heap_size = covered_region.word_size();\n-    BitMap::bm_word_t* map = (BitMap::bm_word_t*)_virtual_space->reserved_low_addr();\n-    _beg_bits = BitMapView(map, bits);\n-    return true;\n-  }\n@@ -69,3 +67,3 @@\n-  _heap_start = nullptr;\n-  _heap_size = 0;\n-  if (_virtual_space != nullptr) {\n+  if (!_virtual_space->expand_by(_reserved_byte_size)) {\n+    \/\/ Failed to commit memory for the bitmap.\n+\n@@ -73,1 +71,1 @@\n-    _virtual_space = nullptr;\n+\n@@ -75,3 +73,3 @@\n-    if (rs.is_reserved()) {\n-      MemoryReserver::release(rs);\n-    }\n+    MemoryReserver::release(rs);\n+\n+    return false;\n@@ -79,1 +77,7 @@\n-  return false;\n+\n+  _heap_start = covered_region.start();\n+  _heap_size = covered_region.word_size();\n+  BitMap::bm_word_t* map = (BitMap::bm_word_t*)_virtual_space->reserved_low_addr();\n+  _beg_bits = BitMapView(map, bits);\n+\n+  return true;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.cpp","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -252,0 +252,5 @@\n+  if (!rs.is_reserved()) {\n+    \/\/ Failed to reserve memory.\n+    return nullptr;\n+  }\n+\n@@ -258,4 +263,4 @@\n-  if (vspace != nullptr) {\n-    if (vspace->expand_by(_reserved_byte_size)) {\n-      return vspace;\n-    }\n+\n+  if (!vspace->expand_by(_reserved_byte_size)) {\n+    \/\/ Failed to commit memory.\n+\n@@ -263,0 +268,1 @@\n+\n@@ -264,4 +270,3 @@\n-    if (rs.is_reserved()) {\n-      MemoryReserver::release(rs);\n-      rs = {};\n-    }\n+    MemoryReserver::release(rs);\n+\n+    return nullptr;\n@@ -270,1 +275,1 @@\n-  return nullptr;\n+  return vspace;\n@@ -2481,1 +2486,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+\n@@ -51,0 +52,1 @@\n+\n@@ -55,3 +57,4 @@\n-  if (!_vs.initialize(rs, 0)) {\n-    vm_exit_during_initialization(\"Could not reserve enough space for heap offset array\");\n-  }\n+  const bool initialized = _vs.initialize(rs, 0 \/* committed_size *\/);\n+\n+  assert(initialized, \"Should never fail when commmitted_size is 0\");\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -86,4 +86,0 @@\n-  MemTracker::record_virtual_memory_tag((address)rs.base(), mtGC);\n-\n-  os::trace_page_sizes(\"Card Table\", num_bytes, num_bytes,\n-                       rs.base(), rs.size(), _page_size);\n@@ -95,0 +91,5 @@\n+  MemTracker::record_virtual_memory_tag((address)rs.base(), mtGC);\n+\n+  os::trace_page_sizes(\"Card Table\", num_bytes, num_bytes,\n+                       rs.base(), rs.size(), _page_size);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -83,0 +83,4 @@\n+  if (!card_table.is_reserved()) {\n+    vm_exit_during_initialization(\"Could not reserve enough space for the card marking array\");\n+  }\n+\n@@ -87,3 +91,0 @@\n-  if (!card_table.is_reserved()) {\n-    vm_exit_during_initialization(\"Could not reserve enough space for the card marking array\");\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -389,0 +389,3 @@\n+\n+      \/\/ Maybe Shenandoah wants to check the the memory got reserved here?\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -962,9 +962,5 @@\n-  if (rhs.is_reserved()) {\n-    assert(total_reserved == rhs.size(),    \"must be exactly of required size\");\n-    assert(is_aligned(rhs.base(),alignment),\"must be exactly of required alignment\");\n-\n-    assert(markWord::encode_pointer_as_mark(rhs.base()).decode_pointer() == rhs.base(),\n-           \"area must be distinguishable from marks for mark-sweep\");\n-    assert(markWord::encode_pointer_as_mark(&rhs.base()[rhs.size()]).decode_pointer() ==\n-           &rhs.base()[rhs.size()],\n-           \"area must be distinguishable from marks for mark-sweep\");\n+  if (!rhs.is_reserved()) {\n+    vm_exit_during_initialization(\n+      err_msg(\"Could not reserve enough space for \" SIZE_FORMAT \"KB object heap\",\n+              total_reserved\/K));\n+  }\n@@ -972,1 +968,2 @@\n-    \/\/ We are good.\n+  assert(total_reserved == rhs.size(),    \"must be exactly of required size\");\n+  assert(is_aligned(rhs.base(),alignment),\"must be exactly of required alignment\");\n@@ -974,3 +971,5 @@\n-    if (AllocateHeapAt != nullptr) {\n-      log_info(gc,heap)(\"Successfully allocated Java heap at location %s\", AllocateHeapAt);\n-    }\n+  assert(markWord::encode_pointer_as_mark(rhs.base()).decode_pointer() == rhs.base(),\n+      \"area must be distinguishable from marks for mark-sweep\");\n+  assert(markWord::encode_pointer_as_mark(&rhs.base()[rhs.size()]).decode_pointer() ==\n+      &rhs.base()[rhs.size()],\n+      \"area must be distinguishable from marks for mark-sweep\");\n@@ -978,3 +977,1 @@\n-    if (UseCompressedOops) {\n-      CompressedOops::initialize(rhs);\n-    }\n+  \/\/ We are good.\n@@ -982,1 +979,3 @@\n-    Universe::calculate_verify_data((HeapWord*)rhs.base(), (HeapWord*)rhs.end());\n+  if (AllocateHeapAt != nullptr) {\n+    log_info(gc,heap)(\"Successfully allocated Java heap at location %s\", AllocateHeapAt);\n+  }\n@@ -984,1 +983,2 @@\n-    return rhs;\n+  if (UseCompressedOops) {\n+    CompressedOops::initialize(rhs);\n@@ -987,3 +987,1 @@\n-  vm_exit_during_initialization(\n-    err_msg(\"Could not reserve enough space for \" SIZE_FORMAT \"KB object heap\",\n-            total_reserved\/K));\n+  Universe::calculate_verify_data((HeapWord*)rhs.base(), (HeapWord*)rhs.end());\n@@ -991,2 +989,1 @@\n-  \/\/ satisfy compiler\n-  ShouldNotReachHere();\n+  return rhs;\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  if(!rs.is_reserved()) return false;  \/\/ allocation failed.\n+  assert(rs.is_reserved(), \"ReservedSpace should have been initialized\");\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -304,2 +304,0 @@\n-  VirtualSpace vs;\n-  vs.initialize(rhs, 50 * granularity);\n@@ -308,1 +306,1 @@\n-  if (!( UseCompressedOops && rhs.base() != nullptr &&\n+  if (!( UseCompressedOops && rhs.is_reserved() &&\n@@ -322,0 +320,4 @@\n+\n+  VirtualSpace vs;\n+  vs.initialize(rhs, 50 * granularity);\n+\n@@ -331,0 +333,5 @@\n+  if (!rhs.is_reserved()) {\n+    tty->print_cr(\"Failed to initialize ReservedSpace. Can't proceed.\");\n+    return 3;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -548,1 +548,1 @@\n-    EXPECT_TRUE(reserved.is_reserved());\n+    ASSERT_TRUE(reserved.is_reserved());\n@@ -568,3 +568,1 @@\n-    if (reserved.is_reserved()) {\n-      MemoryReserver::release(reserved);\n-    }\n+    MemoryReserver::release(reserved);\n@@ -584,1 +582,1 @@\n-    EXPECT_TRUE(reserved.is_reserved());\n+    ASSERT_TRUE(reserved.is_reserved());\n@@ -594,3 +592,1 @@\n-    if (reserved.is_reserved()) {\n-      MemoryReserver::release(reserved);\n-    }\n+    MemoryReserver::release(reserved);\n","filename":"test\/hotspot\/gtest\/memory\/test_virtualspace.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"}]}