{"files":[{"patch":"@@ -53,0 +53,5 @@\n+  if (!rs.is_reserved()) {\n+    \/\/ Failed to reserve memory for the bitmap,\n+    return false;\n+  }\n+\n@@ -60,7 +65,0 @@\n-  if (_virtual_space != nullptr && _virtual_space->expand_by(_reserved_byte_size)) {\n-    _heap_start = covered_region.start();\n-    _heap_size = covered_region.word_size();\n-    BitMap::bm_word_t* map = (BitMap::bm_word_t*)_virtual_space->reserved_low_addr();\n-    _beg_bits = BitMapView(map, bits);\n-    return true;\n-  }\n@@ -68,3 +66,3 @@\n-  _heap_start = nullptr;\n-  _heap_size = 0;\n-  if (_virtual_space != nullptr) {\n+  if (!_virtual_space->expand_by(_reserved_byte_size)) {\n+    \/\/ Failed to commit memory for the bitmap.\n+\n@@ -72,1 +70,1 @@\n-    _virtual_space = nullptr;\n+\n@@ -74,3 +72,3 @@\n-    if (rs.is_reserved()) {\n-      MemoryReserver::release(rs);\n-    }\n+    MemoryReserver::release(rs);\n+\n+    return false;\n@@ -78,1 +76,7 @@\n-  return false;\n+\n+  _heap_start = covered_region.start();\n+  _heap_size = covered_region.word_size();\n+  BitMap::bm_word_t* map = (BitMap::bm_word_t*)_virtual_space->reserved_low_addr();\n+  _beg_bits = BitMapView(map, bits);\n+\n+  return true;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parMarkBitMap.cpp","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -251,0 +251,5 @@\n+  if (!rs.is_reserved()) {\n+    \/\/ Failed to reserve memory.\n+    return nullptr;\n+  }\n+\n@@ -257,4 +262,4 @@\n-  if (vspace != nullptr) {\n-    if (vspace->expand_by(_reserved_byte_size)) {\n-      return vspace;\n-    }\n+\n+  if (!vspace->expand_by(_reserved_byte_size)) {\n+    \/\/ Failed to commit memory.\n+\n@@ -262,0 +267,1 @@\n+\n@@ -263,4 +269,3 @@\n-    if (rs.is_reserved()) {\n-      MemoryReserver::release(rs);\n-      rs = {};\n-    }\n+    MemoryReserver::release(rs);\n+\n+    return nullptr;\n@@ -269,1 +274,1 @@\n-  return nullptr;\n+  return vspace;\n@@ -2480,1 +2485,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+\n@@ -50,0 +51,1 @@\n+\n@@ -54,3 +56,4 @@\n-  if (!_vs.initialize(rs, 0)) {\n-    vm_exit_during_initialization(\"Could not reserve enough space for heap offset array\");\n-  }\n+  const bool initialized = _vs.initialize(rs, 0 \/* committed_size *\/);\n+\n+  assert(initialized, \"Should never fail when commmitted_size is 0\");\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -85,4 +85,0 @@\n-  MemTracker::record_virtual_memory_tag((address)rs.base(), mtGC);\n-\n-  os::trace_page_sizes(\"Card Table\", num_bytes, num_bytes,\n-                       rs.base(), rs.size(), _page_size);\n@@ -94,0 +90,5 @@\n+  MemTracker::record_virtual_memory_tag((address)rs.base(), mtGC);\n+\n+  os::trace_page_sizes(\"Card Table\", num_bytes, num_bytes,\n+                       rs.base(), rs.size(), _page_size);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -82,0 +82,4 @@\n+  if (!card_table.is_reserved()) {\n+    vm_exit_during_initialization(\"Could not reserve enough space for the card marking array\");\n+  }\n+\n@@ -86,3 +90,0 @@\n-  if (!card_table.is_reserved()) {\n-    vm_exit_during_initialization(\"Could not reserve enough space for the card marking array\");\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCardTable.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -389,0 +389,3 @@\n+\n+      \/\/ Maybe Shenandoah wants to check the the memory got reserved here?\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -961,9 +961,5 @@\n-  if (rhs.is_reserved()) {\n-    assert(total_reserved == rhs.size(),    \"must be exactly of required size\");\n-    assert(is_aligned(rhs.base(),alignment),\"must be exactly of required alignment\");\n-\n-    assert(markWord::encode_pointer_as_mark(rhs.base()).decode_pointer() == rhs.base(),\n-           \"area must be distinguishable from marks for mark-sweep\");\n-    assert(markWord::encode_pointer_as_mark(&rhs.base()[rhs.size()]).decode_pointer() ==\n-           &rhs.base()[rhs.size()],\n-           \"area must be distinguishable from marks for mark-sweep\");\n+  if (!rhs.is_reserved()) {\n+    vm_exit_during_initialization(\n+      err_msg(\"Could not reserve enough space for %zu KB object heap\",\n+              total_reserved\/K));\n+  }\n@@ -971,1 +967,2 @@\n-    \/\/ We are good.\n+  assert(total_reserved == rhs.size(),    \"must be exactly of required size\");\n+  assert(is_aligned(rhs.base(),alignment),\"must be exactly of required alignment\");\n@@ -973,3 +970,5 @@\n-    if (AllocateHeapAt != nullptr) {\n-      log_info(gc,heap)(\"Successfully allocated Java heap at location %s\", AllocateHeapAt);\n-    }\n+  assert(markWord::encode_pointer_as_mark(rhs.base()).decode_pointer() == rhs.base(),\n+      \"area must be distinguishable from marks for mark-sweep\");\n+  assert(markWord::encode_pointer_as_mark(&rhs.base()[rhs.size()]).decode_pointer() ==\n+      &rhs.base()[rhs.size()],\n+      \"area must be distinguishable from marks for mark-sweep\");\n@@ -977,3 +976,1 @@\n-    if (UseCompressedOops) {\n-      CompressedOops::initialize(rhs);\n-    }\n+  \/\/ We are good.\n@@ -981,1 +978,3 @@\n-    Universe::calculate_verify_data((HeapWord*)rhs.base(), (HeapWord*)rhs.end());\n+  if (AllocateHeapAt != nullptr) {\n+    log_info(gc,heap)(\"Successfully allocated Java heap at location %s\", AllocateHeapAt);\n+  }\n@@ -983,1 +982,2 @@\n-    return rhs;\n+  if (UseCompressedOops) {\n+    CompressedOops::initialize(rhs);\n@@ -986,3 +986,1 @@\n-  vm_exit_during_initialization(\n-    err_msg(\"Could not reserve enough space for %zuKB object heap\",\n-            total_reserved\/K));\n+  Universe::calculate_verify_data((HeapWord*)rhs.base(), (HeapWord*)rhs.end());\n@@ -990,2 +988,1 @@\n-  \/\/ satisfy compiler\n-  ShouldNotReachHere();\n+  return rhs;\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  if(!rs.is_reserved()) return false;  \/\/ allocation failed.\n+  assert(rs.is_reserved(), \"ReservedSpace should have been initialized\");\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -303,2 +303,0 @@\n-  VirtualSpace vs;\n-  vs.initialize(rhs, 50 * granularity);\n@@ -307,1 +305,1 @@\n-  if (!( UseCompressedOops && rhs.base() != nullptr &&\n+  if (!( UseCompressedOops && rhs.is_reserved() &&\n@@ -321,0 +319,4 @@\n+\n+  VirtualSpace vs;\n+  vs.initialize(rhs, 50 * granularity);\n+\n@@ -330,0 +332,5 @@\n+  if (!rhs.is_reserved()) {\n+    tty->print_cr(\"Failed to initialize ReservedSpace. Can't proceed.\");\n+    return 3;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -547,1 +547,1 @@\n-    EXPECT_TRUE(reserved.is_reserved());\n+    ASSERT_TRUE(reserved.is_reserved());\n@@ -567,3 +567,1 @@\n-    if (reserved.is_reserved()) {\n-      MemoryReserver::release(reserved);\n-    }\n+    MemoryReserver::release(reserved);\n@@ -583,1 +581,1 @@\n-    EXPECT_TRUE(reserved.is_reserved());\n+    ASSERT_TRUE(reserved.is_reserved());\n@@ -593,3 +591,1 @@\n-    if (reserved.is_reserved()) {\n-      MemoryReserver::release(reserved);\n-    }\n+    MemoryReserver::release(reserved);\n","filename":"test\/hotspot\/gtest\/memory\/test_virtualspace.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"}]}