{"files":[{"patch":"@@ -218,0 +218,8 @@\n+     * <p>The object being registered is kept strongly reachable (and therefore not eligible\n+     * for cleaning) during the register() method.\n+     *\n+     * <p><a href=\"{@docRoot}\/java.base\/java\/lang\/ref\/package-summary.html#MemoryConsistency\">Memory consistency effects<\/a>:\n+     * Actions in a thread prior to calling {@code Cleaner.register()}\n+     * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happen-before<\/i><\/a>\n+     * the cleaning action is run by the Cleaner's thread.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -391,2 +391,3 @@\n-     * Clears this reference object.  Invoking this method will not cause this\n-     * object to be enqueued.\n+     * Clears this reference object. Invoking this method does not enqueue this\n+     * object, and the garbage collector will no longer clear or enqueue this\n+     * object.\n@@ -394,2 +395,10 @@\n-     * <p> This method is invoked only by Java code; when the garbage collector\n-     * clears references it does so directly, without invoking this method.\n+     * <p>When the garbage collector or the {@link #enqueue()} method clear\n+     * references they do so directly, without invoking this method.\n+     *\n+     * @apiNote\n+     * There is a potential race condition with the garbage collector. When this\n+     * method is called, the garbage collector may already be in the process of\n+     * (or already completed) clearing and\/or enqueueing this reference.\n+     * Avoid this race by ensuring the referent remains strongly reachable until\n+     * after the call to clear(), using {@link #reachabilityFence(Object)} if\n+     * necessary.\n@@ -473,2 +482,21 @@\n-     * Clears this reference object and adds it to the queue with which\n-     * it is registered, if any.\n+     * Clears this reference object, then attempts to add it to the queue with\n+     * which it is registered, if any.\n+     *\n+     * <p>If this reference is registered with a queue but not yet enqueued,\n+     * the reference is added to the queue; this method is\n+     * <b><i>successful<\/i><\/b> and returns true.\n+     * If this reference is not registered with a queue, or was already enqueued\n+     * (by the garbage collector, or a previous call to {@code enqueue}), this\n+     * method is <b><i>unsuccessful<\/i><\/b> and returns false.\n+     *\n+     * <p><a href=\"{@docRoot}\/java.base\/java\/lang\/ref\/package-summary.html#MemoryConsistency\">Memory consistency effects<\/a>:\n+     * Actions in a thread prior to a <b><i>successful<\/i><\/b> call to {@code enqueue}\n+     * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happen-before<\/i><\/a>\n+     * the reference is removed from the queue by {@link ReferenceQueue#poll}\n+     * or {@link ReferenceQueue#remove}. <b><i>Unsuccessful<\/i><\/b> calls to\n+     * {@code enqueue} have no specified memory consistency effects.\n+     *\n+     * <p> When this method clears references it does so directly, without\n+     * invoking the {@link #clear()} method. When the garbage collector clears\n+     * and enqueues references it does so directly, without invoking the\n+     * {@link #clear()} method or this method.\n@@ -476,2 +504,5 @@\n-     * <p> This method is invoked only by Java code; when the garbage collector\n-     * enqueues references it does so directly, without invoking this method.\n+     * @apiNote\n+     * Use of this method allows the registered queue's\n+     * {@link ReferenceQueue#poll} and {@link ReferenceQueue#remove} methods\n+     * to return this reference even though the referent may still be strongly\n+     * reachable.\n@@ -514,4 +545,5 @@\n-     * Ensures that the object referenced by the given reference remains\n-     * <a href=\"package-summary.html#reachability\"><em>strongly reachable<\/em><\/a>,\n-     * regardless of any prior actions of the program that might otherwise cause\n-     * the object to become unreachable; thus, the referenced object is not\n+     * Ensures that the given object remains\n+     * <a href=\"package-summary.html#reachability\"><em>strongly reachable<\/em><\/a>.\n+     * This reachability is assured regardless of any optimizing transformations\n+     * the virtual machine may perform that might otherwise allow the object to\n+     * become unreachable (see {@jls 12.6.1}). Thus, the given object is not\n@@ -519,2 +551,5 @@\n-     * this method.  Invocation of this method does not itself initiate garbage\n-     * collection or finalization.\n+     * this method. References to the given object will not be cleared (or\n+     * enqueued, if applicable) by the garbage collector until after invocation\n+     * of this method.\n+     * Invocation of this method does not itself initiate reference processing,\n+     * garbage collection, or finalization.\n@@ -525,9 +560,10 @@\n-     * triggering garbage collection.  This method is designed for use in\n-     * uncommon situations of premature finalization where using\n-     * {@code synchronized} blocks or methods, or using other synchronization\n-     * facilities are not possible or do not provide the desired control.  This\n-     * method is applicable only when reclamation may have visible effects,\n-     * which is possible for objects with finalizers (See Section {@jls 12.6}\n-     * of <cite>The Java Language Specification<\/cite>) that\n-     * are implemented in ways that rely on ordering control for\n-     * correctness.\n+     * triggering garbage collection.  This method is applicable only\n+     * when reclamation may have visible effects,\n+     * such as for objects that use finalizers or {@link Cleaner}, or code that\n+     * performs\n+     * <a href=\"{@docRoot}\/java.base\/java\/lang\/ref\/package-summary.html\">reference processing<\/a>.\n+     *\n+     * <p><a href=\"{@docRoot}\/java.base\/java\/lang\/ref\/package-summary.html#MemoryConsistency\">Memory consistency effects<\/a>:\n+     * Actions in a thread prior to calling {@code reachabilityFence(x)}\n+     * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happen-before<\/i><\/a>\n+     * the garbage collector clears any reference to {@code x}.\n@@ -536,6 +572,20 @@\n-     * Finalization may occur whenever the virtual machine detects that no\n-     * reference to an object will ever be stored in the heap: The garbage\n-     * collector may reclaim an object even if the fields of that object are\n-     * still in use, so long as the object has otherwise become unreachable.\n-     * This may have surprising and undesirable effects in cases such as the\n-     * following example in which the bookkeeping associated with a class is\n+     * Reference processing or finalization can occur after an object becomes\n+     * unreachable. An object can become unreachable when the virtual machine\n+     * detects that there is no further need for the object (other than for\n+     * running a finalizer). In the course of optimization, the virtual machine\n+     * can reorder operations of an object's methods such that the object\n+     * becomes unneeded earlier than might naively be expected &mdash;\n+     * including while a method of the object is still running. For instance,\n+     * the VM can move the loading of <em>values<\/em> from the object's fields\n+     * to occur earlier. The object itself is then no longer needed and becomes\n+     * unreachable, and the method can continue running using the obtained values.\n+     * This may have surprising and undesirable effects when using a Cleaner or\n+     * finalizer for cleanup: there is a race between the\n+     * program thread running the method, and the cleanup thread running the\n+     * Cleaner or finalizer. The cleanup thread could free a\n+     * resource, followed by the program thread (still running the method)\n+     * attempting to access the now-already-freed resource.\n+     * Use of {@code reachabilityFence} can prevent this race by ensuring that the\n+     * object remains strongly reachable.\n+     * <p>\n+     * The following is an example in which the bookkeeping associated with a class is\n@@ -545,1 +595,1 @@\n-     * {@code ExternalResource} has been performed; in particular here, to\n+     * {@code ExternalResource} has been performed; specifically, to\n@@ -556,1 +606,1 @@\n-     *     myIndex = ...\n+     *     this.myIndex = ...\n@@ -561,1 +611,1 @@\n-     *     externalResourceArray[myIndex] = null;\n+     *     externalResourceArray[this.myIndex] = null;\n@@ -567,1 +617,1 @@\n-     *       int i = myIndex;\n+     *       int i = this.myIndex; \/\/ last use of 'this' Resource in action()\n@@ -578,1 +628,1 @@\n-     * Here, the invocation of {@code reachabilityFence} is nonintuitively\n+     * The invocation of {@code reachabilityFence} is\n@@ -582,1 +632,1 @@\n-     * object.  This might be the case if, for example a usage in a user program\n+     * object.  This might be the case if, for example, a usage in a user program\n@@ -584,22 +634,5 @@\n-     * reference to this {@code Resource}.  While probably overkill here,\n-     * {@code reachabilityFence} is placed in a {@code finally} block to ensure\n-     * that it is invoked across all paths in the method.  In a method with more\n-     * complex control paths, you might need further precautions to ensure that\n-     * {@code reachabilityFence} is encountered along all of them.\n-     *\n-     * <p> It is sometimes possible to better encapsulate use of\n-     * {@code reachabilityFence}.  Continuing the above example, if it were\n-     * acceptable for the call to method {@code update} to proceed even if the\n-     * finalizer had already executed (nulling out slot), then you could\n-     * localize use of {@code reachabilityFence}:\n-     *\n-     * <pre> {@code\n-     * public void action2() {\n-     *   \/\/ ...\n-     *   Resource.update(getExternalResource());\n-     * }\n-     * private ExternalResource getExternalResource() {\n-     *   ExternalResource ext = externalResourceArray[myIndex];\n-     *   Reference.reachabilityFence(this);\n-     *   return ext;\n-     * }}<\/pre>\n+     * reference to this {@code Resource}.\n+     * The {@code reachabilityFence} call is placed in a {@code finally} block to\n+     * ensure that it is invoked across all paths in the method. A more complex\n+     * method might need further precautions to ensure that\n+     * {@code reachabilityFence} is encountered along all code paths.\n@@ -615,1 +648,1 @@\n-     * remains a better option in cases where this approach is not as efficient,\n+     * remains a better option in cases where synchronization is not as efficient,\n@@ -618,1 +651,2 @@\n-     * @param ref the reference. If {@code null}, this method has no effect.\n+     * @param ref the reference to the object to keep strongly reachable. If\n+     * {@code null}, this method has no effect.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":93,"deletions":59,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -37,0 +37,8 @@\n+ *\n+ * <p><a href=\"{@docRoot}\/java.base\/java\/lang\/ref\/package-summary.html#MemoryConsistency\">Memory consistency effects<\/a>:\n+ * The enqueueing of a reference on a queue (by the garbage collector, or by a\n+ * successful call to {@link Reference#enqueue})\n+ * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n+ * the reference is removed from the queue by {@link ReferenceQueue#poll} or\n+ * {@link ReferenceQueue#remove}.\n+ *\n@@ -178,0 +186,1 @@\n+     * @see java.lang.ref.Reference#enqueue()\n@@ -209,0 +218,2 @@\n+     *\n+     * @see java.lang.ref.Reference#enqueue()\n@@ -230,0 +241,1 @@\n+     * @see java.lang.ref.Reference#enqueue()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,2 +65,4 @@\n- * object with a <em>reference queue<\/em> at the time the reference\n- * object is created.  Some time after the garbage collector\n+ * object with a <em>reference queue<\/em>.\n+ * This is done by providing the reference queue as\n+ * a constructor argument when creating the reference object.\n+ * Some time after the garbage collector\n@@ -70,1 +72,3 @@\n- * reference is considered to be <em>enqueued<\/em>.  The program may remove\n+ * reference is considered to be <em>enqueued<\/em>.  The program learns of the\n+ * object's change in reachability when the associated reference becomes\n+ * available on the queue. The program may remove\n@@ -72,2 +76,6 @@\n- * reference becomes available.  Reference queues are implemented by\n- * the {@link java.lang.ref.ReferenceQueue} class.\n+ * reference becomes available. Additional state needed to respond to a\n+ * referent's change in reachability can be stored in the fields of a custom\n+ * reference subclass, and accessed when the reference is returned from the\n+ * queue.\n+ * Reference queues are implemented by the {@link java.lang.ref.ReferenceQueue}\n+ * class.\n@@ -79,2 +87,2 @@\n- * the responsibility of the program using reference objects to ensure\n- * that the objects remain reachable for as long as the program is\n+ * the responsibility of the program to ensure\n+ * that reference objects remain reachable for as long as the program is\n@@ -99,1 +107,4 @@\n- * Going from strongest to weakest, the different levels of\n+ * A <em>reachable<\/em> object is any object that can be accessed in any potential\n+ * continuing computation from any live thread (as stated in {@jls 12.6.1}).\n+ *\n+ * <p> Going from strongest to weakest, the different levels of\n@@ -105,4 +116,2 @@\n- * <li> An object is <em>strongly reachable<\/em> if it can be reached\n- * by some thread without traversing any reference objects.  A\n- * newly-created object is strongly reachable by the thread that\n- * created it.\n+ * <li> An object is <em>strongly reachable<\/em> if it is reachable and if it\n+ * can be accessed without traversing the referent of a Reference object.\n@@ -128,0 +137,36 @@\n+ * <a id=\"MemoryConsistency\"><\/a>\n+ * <h3>Memory Consistency Properties<\/h3>\n+ * Certain interactions between the garbage collector, references, and reference\n+ * queues form\n+ * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n+ * relationships:\n+ *\n+ * <ul>\n+ *\n+ * <li> Actions in a thread prior to calling\n+ * {@link Reference#reachabilityFence Reference.reachabilityFence(x)}\n+ * <i>happen-before<\/i> the garbage collector clears any reference to {@code x}.<\/li>\n+ *\n+ * <li>The clearing of a reference by the garbage collector <i>happens-before<\/i>\n+ * the garbage collector enqueues the reference.<\/li>\n+ *\n+ * <li> The enqueueing of a reference (by the garbage collector, or\n+ * by a successful call to {@link Reference#enqueue}) <i>happens-before<\/i>\n+ * the reference is removed from the queue (\"dequeued\") by {@link ReferenceQueue#poll} or\n+ * {@link ReferenceQueue#remove}.<\/li>\n+ *\n+ * <li>The dequeuing of a reference to a\n+ * {@linkplain Cleaner#register(Object object, Runnable action) registered}\n+ * object, by the Cleaner thread, <i>happens-before<\/i> the Cleaner thread runs\n+ * the cleaning action for that object.<\/li>\n+ *\n+ * <\/ul>\n+ *\n+ * The above chain of <i>happens-before<\/i> edges ensures that actions in a\n+ * thread prior to a {@link Reference#reachabilityFence Reference.reachabilityFence(x)}\n+ * <i>happen-before<\/i> cleanup code for {@code x} runs on the cleaner thread.\n+ * In particular, changes to the state of {@code x} made before\n+ * {@code reachabilityFence(x)} will be visible to the cleanup code running on\n+ * the cleaner thread without additional synchronization.\n+ * See {@jls 17.4.5}.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/package-info.java","additions":57,"deletions":12,"binary":false,"changes":69,"status":"modified"}]}