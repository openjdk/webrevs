{"files":[{"patch":"@@ -41,1 +41,1 @@\n- * notified when the <a href=\"package-summary.html#reachability\">reachability<\/a>\n+ * notified when the {@linkplain java.lang.ref##reachability reachability}\n@@ -218,0 +218,8 @@\n+     * <p>The given object is kept strongly reachable (and therefore not eligible\n+     * for cleaning) during the register() method.\n+     *\n+     * <p>{@linkplain java.lang.ref##MemoryConsistency Memory consistency effects}:\n+     * Actions in a thread prior to calling {@code Cleaner.register()}\n+     * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happen-before<\/i><\/a>\n+     * the cleaning action is run by the Cleaner's thread.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -391,2 +391,2 @@\n-     * Clears this reference object.  Invoking this method will not cause this\n-     * object to be enqueued.\n+     * Clears this reference object. Invoking this method does not enqueue this\n+     * object, and the garbage collector will not clear or enqueue this object.\n@@ -394,2 +394,10 @@\n-     * <p> This method is invoked only by Java code; when the garbage collector\n-     * clears references it does so directly, without invoking this method.\n+     * <p>When the garbage collector or the {@link #enqueue()} method clear\n+     * references they do so directly, without invoking this method.\n+     *\n+     * @apiNote\n+     * There is a potential race condition with the garbage collector. When this\n+     * method is called, the garbage collector may already be in the process of\n+     * (or already completed) clearing and\/or enqueueing this reference.\n+     * Avoid this race by ensuring the referent remains strongly reachable until\n+     * after the call to clear(), using {@link #reachabilityFence(Object)} if\n+     * necessary.\n@@ -473,2 +481,21 @@\n-     * Clears this reference object and adds it to the queue with which\n-     * it is registered, if any.\n+     * Clears this reference object, then attempts to add it to the queue with\n+     * which it is registered, if any.\n+     *\n+     * <p>If this reference is registered with a queue but not yet enqueued,\n+     * the reference is added to the queue; this method is\n+     * <b><i>successful<\/i><\/b> and returns true.\n+     * If this reference is not registered with a queue, or was already enqueued\n+     * (by the garbage collector, or a previous call to {@code enqueue}), this\n+     * method is <b><i>unsuccessful<\/i><\/b> and returns false.\n+     *\n+     * <p>{@linkplain java.lang.ref##MemoryConsistency Memory consistency effects}:\n+     * Actions in a thread prior to a <b><i>successful<\/i><\/b> call to {@code enqueue}\n+     * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happen-before<\/i><\/a>\n+     * the reference is removed from the queue by {@link ReferenceQueue#poll}\n+     * or {@link ReferenceQueue#remove}. <b><i>Unsuccessful<\/i><\/b> calls to\n+     * {@code enqueue} have no specified memory consistency effects.\n+     *\n+     * <p> When this method clears references it does so directly, without\n+     * invoking the {@link #clear()} method. When the garbage collector clears\n+     * and enqueues references it does so directly, without invoking the\n+     * {@link #clear()} method or this method.\n@@ -476,2 +503,5 @@\n-     * <p> This method is invoked only by Java code; when the garbage collector\n-     * enqueues references it does so directly, without invoking this method.\n+     * @apiNote\n+     * Use of this method allows the registered queue's\n+     * {@link ReferenceQueue#poll} and {@link ReferenceQueue#remove} methods\n+     * to return this reference even though the referent may still be strongly\n+     * reachable.\n@@ -514,4 +544,5 @@\n-     * Ensures that the object referenced by the given reference remains\n-     * <a href=\"package-summary.html#reachability\"><em>strongly reachable<\/em><\/a>,\n-     * regardless of any prior actions of the program that might otherwise cause\n-     * the object to become unreachable; thus, the referenced object is not\n+     * Ensures that the given object remains\n+     * <a href=\"package-summary.html#reachability\"><em>strongly reachable<\/em><\/a>.\n+     * This reachability is assured regardless of any optimizing transformations\n+     * the virtual machine may perform that might otherwise allow the object to\n+     * become unreachable (see JLS {@jls 12.6.1}). Thus, the given object is not\n@@ -519,2 +550,5 @@\n-     * this method.  Invocation of this method does not itself initiate garbage\n-     * collection or finalization.\n+     * this method. References to the given object will not be cleared (or\n+     * enqueued, if applicable) by the garbage collector until after invocation\n+     * of this method.\n+     * Invocation of this method does not itself initiate reference processing,\n+     * garbage collection, or finalization.\n@@ -525,9 +559,9 @@\n-     * triggering garbage collection.  This method is designed for use in\n-     * uncommon situations of premature finalization where using\n-     * {@code synchronized} blocks or methods, or using other synchronization\n-     * facilities are not possible or do not provide the desired control.  This\n-     * method is applicable only when reclamation may have visible effects,\n-     * which is possible for objects with finalizers (See Section {@jls 12.6}\n-     * of <cite>The Java Language Specification<\/cite>) that\n-     * are implemented in ways that rely on ordering control for\n-     * correctness.\n+     * triggering garbage collection.  This method is applicable only\n+     * when reclamation may have visible effects,\n+     * such as for objects that use finalizers or {@link Cleaner}, or code that\n+     * performs {@linkplain java.lang.ref reference processing}.\n+     *\n+     * <p>{@linkplain java.lang.ref##MemoryConsistency Memory consistency effects}:\n+     * Actions in a thread prior to calling {@code reachabilityFence(x)}\n+     * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happen-before<\/i><\/a>\n+     * the garbage collector clears any reference to {@code x}.\n@@ -536,6 +570,20 @@\n-     * Finalization may occur whenever the virtual machine detects that no\n-     * reference to an object will ever be stored in the heap: The garbage\n-     * collector may reclaim an object even if the fields of that object are\n-     * still in use, so long as the object has otherwise become unreachable.\n-     * This may have surprising and undesirable effects in cases such as the\n-     * following example in which the bookkeeping associated with a class is\n+     * Reference processing or finalization can occur after an object becomes\n+     * unreachable. An object can become unreachable when the virtual machine\n+     * detects that there is no further need for the object (other than for\n+     * running a finalizer). In the course of optimization, the virtual machine\n+     * can reorder operations of an object's methods such that the object\n+     * becomes unneeded earlier than might naively be expected &mdash;\n+     * including while a method of the object is still running. For instance,\n+     * the VM can move the loading of <em>values<\/em> from the object's fields\n+     * to occur earlier. The object itself is then no longer needed and becomes\n+     * unreachable, and the method can continue running using the obtained values.\n+     * This may have surprising and undesirable effects when using a Cleaner or\n+     * finalizer for cleanup: there is a race between the\n+     * program thread running the method, and the cleanup thread running the\n+     * Cleaner or finalizer. The cleanup thread could free a\n+     * resource, followed by the program thread (still running the method)\n+     * attempting to access the now-already-freed resource.\n+     * Use of {@code reachabilityFence} can prevent this race by ensuring that the\n+     * object remains strongly reachable.\n+     * <p>\n+     * The following is an example in which the bookkeeping associated with a class is\n@@ -545,1 +593,1 @@\n-     * {@code ExternalResource} has been performed; in particular here, to\n+     * {@code ExternalResource} has been performed; specifically, to\n@@ -550,1 +598,1 @@\n-     * <pre> {@code\n+     * {@snippet :\n@@ -556,1 +604,1 @@\n-     *     myIndex = ...\n+     *     this.myIndex = ...\n@@ -561,1 +609,1 @@\n-     *     externalResourceArray[myIndex] = null;\n+     *     externalResourceArray[this.myIndex] = null;\n@@ -567,1 +615,1 @@\n-     *       int i = myIndex;\n+     *       int i = this.myIndex; \/\/ last use of 'this' Resource in action()\n@@ -576,1 +624,2 @@\n-     * }}<\/pre>\n+     * }\n+     * }\n@@ -578,1 +627,1 @@\n-     * Here, the invocation of {@code reachabilityFence} is nonintuitively\n+     * The invocation of {@code reachabilityFence} is\n@@ -582,1 +631,1 @@\n-     * object.  This might be the case if, for example a usage in a user program\n+     * object.  This might be the case if, for example, a usage in a user program\n@@ -584,22 +633,5 @@\n-     * reference to this {@code Resource}.  While probably overkill here,\n-     * {@code reachabilityFence} is placed in a {@code finally} block to ensure\n-     * that it is invoked across all paths in the method.  In a method with more\n-     * complex control paths, you might need further precautions to ensure that\n-     * {@code reachabilityFence} is encountered along all of them.\n-     *\n-     * <p> It is sometimes possible to better encapsulate use of\n-     * {@code reachabilityFence}.  Continuing the above example, if it were\n-     * acceptable for the call to method {@code update} to proceed even if the\n-     * finalizer had already executed (nulling out slot), then you could\n-     * localize use of {@code reachabilityFence}:\n-     *\n-     * <pre> {@code\n-     * public void action2() {\n-     *   \/\/ ...\n-     *   Resource.update(getExternalResource());\n-     * }\n-     * private ExternalResource getExternalResource() {\n-     *   ExternalResource ext = externalResourceArray[myIndex];\n-     *   Reference.reachabilityFence(this);\n-     *   return ext;\n-     * }}<\/pre>\n+     * reference to this {@code Resource}.\n+     * The {@code reachabilityFence} call is placed in a {@code finally} block to\n+     * ensure that it is invoked across all paths in the method. A more complex\n+     * method might need further precautions to ensure that\n+     * {@code reachabilityFence} is encountered along all code paths.\n@@ -615,1 +647,1 @@\n-     * remains a better option in cases where this approach is not as efficient,\n+     * remains a better option in cases where synchronization is not as efficient,\n@@ -618,1 +650,2 @@\n-     * @param ref the reference. If {@code null}, this method has no effect.\n+     * @param ref the reference to the object to keep strongly reachable. If\n+     * {@code null}, this method has no effect.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":94,"deletions":61,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -37,0 +37,8 @@\n+ *\n+ * <p><a href=\"package-summary.html#MemoryConsistency\">Memory consistency effects<\/a>:\n+ * The enqueueing of a reference to a queue (by the garbage collector, or by a\n+ * successful call to {@link Reference#enqueue})\n+ * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n+ * the reference is removed from the queue by {@link ReferenceQueue#poll} or\n+ * {@link ReferenceQueue#remove}.\n+ *\n@@ -178,0 +186,1 @@\n+     * @see java.lang.ref.Reference#enqueue()\n@@ -209,0 +218,2 @@\n+     *\n+     * @see java.lang.ref.Reference#enqueue()\n@@ -230,0 +241,1 @@\n+     * @see java.lang.ref.Reference#enqueue()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- *<h2>Package Specification<\/h2>\n+ * <h2>Reference Objects<\/h2>\n@@ -47,1 +47,1 @@\n- * Post-mortem cleanup actions can be registered and managed by a\n+ * Post-mortem cleanup actions can also be registered and managed by a\n@@ -61,1 +61,35 @@\n- * <h3>Notification<\/h3>\n+ * <a id=\"reachability\"><\/a>\n+ * <h2>Reachability<\/h2>\n+ *\n+ * A <em>reachable<\/em> object is any object that can be accessed in any potential\n+ * continuing computation from any\n+ * {@linkplain java.lang.Thread#isAlive live thread} (as stated in JLS {@jls 12.6.1}).\n+ *\n+ * <p> Going from strongest to weakest, the different levels of\n+ * reachability reflect the life cycle of an object.  They are\n+ * operationally defined as follows:\n+ *\n+ * <ul>\n+ *\n+ * <li> An object is <em>strongly reachable<\/em> if it is reachable and if it\n+ * can be accessed without traversing the referent of a Reference object.\n+ *\n+ * <li> An object is <em>softly reachable<\/em> if it is not strongly\n+ * reachable but can be reached by traversing a soft reference.\n+ *\n+ * <li> An object is <em>weakly reachable<\/em> if it is neither\n+ * strongly nor softly reachable but can be reached by traversing a\n+ * weak reference.  When the weak references to a weakly-reachable\n+ * object are cleared, the object becomes eligible for finalization.\n+ *\n+ * <li> An object is <em>phantom reachable<\/em> if it is neither\n+ * strongly, softly, nor weakly reachable, it has been finalized, and\n+ * some phantom reference refers to it.\n+ *\n+ * <li> Finally, an object is <em>unreachable<\/em>, and therefore\n+ * eligible for reclamation, when it is not reachable in any of the\n+ * above ways.\n+ *\n+ * <\/ul>\n+ *\n+ * <h2>Notification<\/h2>\n@@ -65,4 +99,6 @@\n- * object with a <em>reference queue<\/em> at the time the reference\n- * object is created.  Some time after the garbage collector\n- * determines that the reachability of the referent has changed to the\n- * value corresponding to the type of the reference, it will clear the\n+ * object with a {@link java.lang.ref.ReferenceQueue}.\n+ * This is done by providing the reference queue as\n+ * a constructor argument when creating the reference object.\n+ * Some time after the garbage collector\n+ * determines that the reachability of the referent has changed to correspond\n+ * with the type of the reference, it will clear the\n@@ -70,4 +106,8 @@\n- * reference is considered to be <em>enqueued<\/em>.  The program may remove\n- * references from a queue either by polling or by blocking until a\n- * reference becomes available.  Reference queues are implemented by\n- * the {@link java.lang.ref.ReferenceQueue} class.\n+ * reference is considered to be <em>enqueued<\/em>.  The program learns of the\n+ * referent's change in reachability when the associated reference becomes\n+ * available on the queue. The program may remove references from a queue\n+ * (that is, <em>dequeue<\/em> them) using the {@link ReferenceQueue#poll()} or\n+ * {@link ReferenceQueue#remove()} methods. Additional state needed to respond to a\n+ * referent's change in reachability can be stored in the fields of a custom\n+ * reference subclass, and accessed when the reference is returned from the\n+ * queue.\n@@ -79,2 +119,2 @@\n- * the responsibility of the program using reference objects to ensure\n- * that the objects remain reachable for as long as the program is\n+ * the responsibility of the program to ensure\n+ * that reference objects remain reachable for as long as the program is\n@@ -96,6 +136,6 @@\n- * <a id=\"reachability\"><\/a>\n- * <h3>Reachability<\/h3>\n- *\n- * Going from strongest to weakest, the different levels of\n- * reachability reflect the life cycle of an object.  They are\n- * operationally defined as follows:\n+ * <a id=\"MemoryConsistency\"><\/a>\n+ * <h2>Memory Consistency Properties<\/h2>\n+ * Certain interactions between references, reference queues, and the garbage\n+ * collector form\n+ * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\"><i>happens-before<\/i><\/a>\n+ * relationships:\n@@ -105,4 +145,3 @@\n- * <li> An object is <em>strongly reachable<\/em> if it can be reached\n- * by some thread without traversing any reference objects.  A\n- * newly-created object is strongly reachable by the thread that\n- * created it.\n+ * <li>Actions in a thread prior to calling\n+ * {@link Reference#reachabilityFence Reference.reachabilityFence(x)}\n+ * <i>happen-before<\/i> the garbage collector clears any reference to {@code x}.<\/li>\n@@ -110,2 +149,2 @@\n- * <li> An object is <em>softly reachable<\/em> if it is not strongly\n- * reachable but can be reached by traversing a soft reference.\n+ * <li>The clearing of a reference by the garbage collector <i>happens-before<\/i>\n+ * the garbage collector enqueues the reference.<\/li>\n@@ -113,4 +152,3 @@\n- * <li> An object is <em>weakly reachable<\/em> if it is neither\n- * strongly nor softly reachable but can be reached by traversing a\n- * weak reference.  When the weak references to a weakly-reachable\n- * object are cleared, the object becomes eligible for finalization.\n+ * <li>The enqueueing of a reference (by the garbage collector, or\n+ * by a successful call to {@link Reference#enqueue}) <i>happens-before<\/i>\n+ * the reference is removed from the queue (<em>dequeued<\/em>).<\/li>\n@@ -118,3 +156,4 @@\n- * <li> An object is <em>phantom reachable<\/em> if it is neither\n- * strongly, softly, nor weakly reachable, it has been finalized, and\n- * some phantom reference refers to it.\n+ * <li>The dequeuing of a reference to a\n+ * {@linkplain Cleaner#register(Object object, Runnable action) registered}\n+ * object, by the Cleaner thread, <i>happens-before<\/i> the Cleaner thread runs\n+ * the cleaning action for that object.<\/li>\n@@ -122,3 +161,12 @@\n- * <li> Finally, an object is <em>unreachable<\/em>, and therefore\n- * eligible for reclamation, when it is not reachable in any of the\n- * above ways.\n+ * <\/ul>\n+ * The above chain of <i>happens-before<\/i> edges ensures that actions in a\n+ * thread prior to a {@link Reference#reachabilityFence Reference.reachabilityFence(x)}\n+ * <i>happen-before<\/i> cleanup code for {@code x} runs on a Cleaner thread.\n+ * In particular, changes to the state of {@code x} made before\n+ * {@code reachabilityFence(x)} will be visible to the cleanup code running on\n+ * a Cleaner thread without additional synchronization.\n+ * See JLS {@jls 17.4.5}.\n+ *\n+ * <p>\n+ * The interaction between references, finalizers, and the garbage collector\n+ * also forms a <em>happens-before<\/em> relationship:\n@@ -126,0 +174,4 @@\n+ * <ul>\n+ * <li>Actions in a thread prior to calling\n+ * {@link Reference#reachabilityFence Reference.reachabilityFence(x)}\n+ * <i>happen-before<\/i> the finalizer for {@code x} is run by a finalizer thread.<\/li>\n@@ -128,0 +180,8 @@\n+ * This ensures that actions in a thread prior to a\n+ * {@link Reference#reachabilityFence Reference.reachabilityFence(x)}\n+ * <i>happen-before<\/i> cleanup code for {@code x} runs on a finalizer thread.\n+ * In particular, changes to the state of {@code x} made before\n+ * {@code reachabilityFence(x)} will be visible to the cleanup code running on\n+ * a finalizer thread without additional synchronization.\n+ * See JLS {@jls 17.4.5}.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/package-info.java","additions":95,"deletions":35,"binary":false,"changes":130,"status":"modified"}]}