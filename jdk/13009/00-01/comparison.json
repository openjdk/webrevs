{"files":[{"patch":"@@ -220,8 +220,8 @@\n-                ce instanceof MethodModel mm && mm.methodName().equalsString(CTR_NAME))\n-                .andThen(ClassTransform.endHandler(clb -> {\n-                    clb.withMethodBody(CTR_NAME, MethodTypeDesc.of(CD_void, CD_Object), ACC_PUBLIC, cob -> {\n-                        cob.aload(0);\n-                        cob.invokespecial(Record.class.describeConstable().orElseThrow(), CTR_NAME, MethodTypeDesc.of(CD_void));\n-                        cob.return_();\n-                    });\n-                })));\n+                        ce instanceof MethodModel mm && mm.methodName().equalsString(CTR_NAME))\n+                .andThen(ClassTransform.endHandler(clb -> clb.withMethodBody(CTR_NAME,\n+                        MethodTypeDesc.of(CD_void, CD_Object), ACC_PUBLIC, cob -> {\n+                            cob.aload(0);\n+                            cob.invokespecial(Record.class.describeConstable().orElseThrow(),\n+                                    CTR_NAME, MethodTypeDesc.of(CD_void));\n+                            cob.return_();\n+                        }))));\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/BadCanonicalCtrTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-        var model =  Classfile.parse(classBytes);\n+        var model = Classfile.parse(classBytes);\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/SerialPersistentFieldsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n@@ -150,1 +152,1 @@\n-            clb.withMethodBody(CTOR_NAME, MD_void, AccessFlag.PUBLIC.mask(), cb -> {\n+            clb.withMethodBody(CTOR_NAME, MD_void, ACC_PUBLIC, cb -> {\n@@ -159,1 +161,2 @@\n-                clb.accept(EnclosingMethodAttribute.of(outerName, Optional.of(\"f\"), Optional.of(MD_void)));\n+                clb.accept(EnclosingMethodAttribute.of(outerName,\n+                        Optional.of(\"f\"), Optional.of(MD_void)));\n@@ -161,1 +164,2 @@\n-                clb.withMethodBody(\"f\", MD_void, AccessFlag.PUBLIC.mask() | AccessFlag.STATIC.mask(), CodeBuilder::return_);\n+                clb.withMethodBody(\"f\", MD_void, ACC_PUBLIC | ACC_STATIC,\n+                        CodeBuilder::return_);\n@@ -171,2 +175,3 @@\n-                        InnerClassInfo.of(innerName, Optional.of(outerName), Optional.of(simpleName))\n-                ));\n+                        InnerClassInfo.of(innerName,\n+                                Optional.of(outerName),\n+                                Optional.of(simpleName))));\n@@ -183,2 +188,4 @@\n-                        InnerClassInfo.of(innerName, Optional.of(outerName), Optional.of(simpleName), AccessFlag.PUBLIC)\n-                ));\n+                        InnerClassInfo.of(innerName,\n+                                Optional.of(outerName),\n+                                Optional.of(simpleName),\n+                                AccessFlag.PUBLIC)));\n@@ -195,2 +202,4 @@\n-                        InnerClassInfo.of(innerName, Optional.empty(), Optional.of(simpleName), AccessFlag.PUBLIC, AccessFlag.STATIC)\n-                ));\n+                        InnerClassInfo.of(innerName,\n+                                Optional.empty(),\n+                                Optional.of(simpleName),\n+                                AccessFlag.PUBLIC, AccessFlag.STATIC)));\n@@ -208,2 +217,4 @@\n-                        InnerClassInfo.of(innerName, Optional.empty(), Optional.empty(), AccessFlag.PUBLIC, AccessFlag.STATIC)\n-                ));\n+                        InnerClassInfo.of(innerName,\n+                                Optional.empty(),\n+                                Optional.empty(),\n+                                AccessFlag.PUBLIC, AccessFlag.STATIC)));\n","filename":"test\/jdk\/java\/lang\/Class\/getSimpleName\/GetSimpleNameTest.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -41,1 +39,0 @@\n-import jdk.internal.classfile.attribute.ModuleTargetAttribute;\n@@ -146,9 +143,9 @@\n-        return Classfile.parse(bytes).transform(ClassTransform.ACCEPT_ALL.andThen(ClassTransform.endHandler(clb -> {\n-            clb.with(RuntimeVisibleAnnotationsAttribute.of(\n-                    jdk.internal.classfile.Annotation.of(\n-                            Deprecated.class.describeConstable().orElseThrow(),\n-                            AnnotationElement.ofBoolean(\"forRemoval\", forRemoval),\n-                            AnnotationElement.ofString(\"since\", since)\n-                    )\n-            ));\n-        })));\n+        return Classfile.parse(bytes)\n+                .transform(ClassTransform.endHandler(clb ->\n+                        clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                                jdk.internal.classfile.Annotation.of(\n+                                        Deprecated.class.describeConstable().orElseThrow(),\n+                                        AnnotationElement.ofBoolean(\"forRemoval\", forRemoval),\n+                                        AnnotationElement.ofString(\"since\", since)\n+                                )\n+                        ))));\n","filename":"test\/jdk\/java\/lang\/ModuleTests\/AnnotationsTest.java","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+import static jdk.internal.classfile.Classfile.ACC_ABSTRACT;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n@@ -91,1 +93,1 @@\n-            clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+            var badAnnotationArray = AnnotationValue.ofArray(AnnotationValue.ofAnnotation(\n@@ -93,8 +95,5 @@\n-                            ClassDesc.of(\"sample\", \"Host\"),\n-                            AnnotationElement.of(\"value\", AnnotationValue.ofArray(\n-                                    AnnotationValue.ofAnnotation(\n-                                            jdk.internal.classfile.Annotation.of(\n-                                                    NoAnnotation.class.describeConstable().orElseThrow()\n-                                            )\n-                                    )\n-                            ))\n+                            NoAnnotation.class.describeConstable().orElseThrow()\n+                    )));\n+            clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                    jdk.internal.classfile.Annotation.of(ClassDesc.of(\"sample\", \"Host\"),\n+                            AnnotationElement.of(\"value\", badAnnotationArray)\n@@ -110,1 +109,2 @@\n-            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.ABSTRACT, AccessFlag.INTERFACE, AccessFlag.ANNOTATION);\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.ABSTRACT, AccessFlag.INTERFACE,\n+                    AccessFlag.ANNOTATION);\n@@ -117,2 +117,2 @@\n-            clb.withMethod(\"value\", MethodTypeDesc.of(NoAnnotation[].class.describeConstable().orElseThrow()),\n-                    AccessFlag.PUBLIC.mask() | AccessFlag.ABSTRACT.mask(), mb -> {});\n+            clb.withMethod(\"value\", MethodTypeDesc.of(NoAnnotation[].class.describeConstable()\n+                    .orElseThrow()), ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationTypeMismatchException\/ArrayTypeMismatchTest.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import static java.lang.constant.ConstantDescs.CD_Exception;\n@@ -53,0 +54,2 @@\n+import static jdk.internal.classfile.Classfile.ACC_ABSTRACT;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n@@ -94,1 +97,2 @@\n-                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\", AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n@@ -96,3 +100,2 @@\n-                clb.withMethod(\"m\", MethodTypeDesc.of(CD_void), PUBLIC.mask() | ABSTRACT.mask(), mb -> {\n-                    mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1)));\n-                });\n+                clb.withMethod(\"m\", MethodTypeDesc.of(CD_void), ACC_PUBLIC | ACC_ABSTRACT,\n+                        mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1))));\n@@ -119,1 +122,2 @@\n-                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\", AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n@@ -121,3 +125,2 @@\n-                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int, CD_int), PUBLIC.mask() | ABSTRACT.mask(), mb -> {\n-                    mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(-1)));\n-                });\n+                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int, CD_int), ACC_PUBLIC | ACC_ABSTRACT,\n+                        mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(-1))));\n@@ -144,1 +147,2 @@\n-                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\", AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n@@ -146,3 +150,2 @@\n-                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int), PUBLIC.mask() | ABSTRACT.mask(), mb -> {\n-                    mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1)));\n-                });\n+                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int), ACC_PUBLIC | ACC_ABSTRACT,\n+                        mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1))));\n@@ -169,1 +172,2 @@\n-                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\", AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n@@ -171,1 +175,1 @@\n-                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int), PUBLIC.mask() | ABSTRACT.mask(), mb -> {\n+                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int), ACC_PUBLIC | ACC_ABSTRACT, mb -> {\n@@ -173,1 +177,1 @@\n-                    mb.with(ExceptionsAttribute.ofSymbols(Exception.class.describeConstable().orElseThrow()));\n+                    mb.with(ExceptionsAttribute.ofSymbols(CD_Exception));\n@@ -195,1 +199,2 @@\n-                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\", AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n@@ -197,3 +202,2 @@\n-                clb.withMethod(\"hashCode\", MethodTypeDesc.of(CD_int), PUBLIC.mask() | ABSTRACT.mask(), mb -> {\n-                    mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1)));\n-                });\n+                clb.withMethod(\"hashCode\", MethodTypeDesc.of(CD_int), ACC_PUBLIC | ACC_ABSTRACT,\n+                        mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1))));\n@@ -221,1 +225,2 @@\n-                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\", AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n@@ -223,4 +228,3 @@\n-                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int), PUBLIC.mask() | ABSTRACT.mask(), mb -> {\n-                    mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1)));\n-                });\n-                clb.withMethod(\"d\", MethodTypeDesc.of(CD_int), PUBLIC.mask(), mb -> {\n+                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int), ACC_PUBLIC | ACC_ABSTRACT,\n+                        mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1))));\n+                clb.withMethod(\"d\", MethodTypeDesc.of(CD_int), ACC_PUBLIC, mb -> {\n@@ -253,1 +257,2 @@\n-                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\", AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n@@ -255,3 +260,2 @@\n-                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int), PUBLIC.mask() | ABSTRACT.mask(), mb -> {\n-                    mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1)));\n-                });\n+                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int), ACC_PUBLIC | ACC_ABSTRACT,\n+                        mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1))));\n","filename":"test\/jdk\/java\/lang\/annotation\/ClassFileGenerator.java","additions":32,"deletions":28,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -85,1 +85,4 @@\n-                                            h.invokestatic(ClassDesc.ofInternalName(\"bootreporter\/StringIdCallbackReporter\"), \"tracker\", MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/String;I)V\"));\n+                                            h.invokestatic(\n+                                                    ClassDesc.ofInternalName(\"bootreporter\/StringIdCallbackReporter\"),\n+                                                    \"tracker\",\n+                                                    MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/String;I)V\"));\n","filename":"test\/jdk\/java\/lang\/instrument\/NativeMethodPrefixAgent.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -93,1 +93,2 @@\n-                                           cb.invokestatic(RetransformAgent.class.describeConstable().orElseThrow(),\n+                                           cb.invokestatic(\n+                                                   RetransformAgent.class.describeConstable().orElseThrow(),\n","filename":"test\/jdk\/java\/lang\/instrument\/RetransformAgent.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,1 +113,2 @@\n-                            mb.withCode(((Consumer<CodeBuilder>) cb0 -> injector.accept(name, cb0)).andThen(cb -> {\n+                            Consumer<CodeBuilder> injection = cb -> injector.accept(name, cb);\n+                            mb.withCode(injection.andThen(cb -> {\n","filename":"test\/jdk\/java\/lang\/instrument\/asmlib\/Instrumentor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+import static jdk.internal.classfile.Classfile.ACC_PRIVATE;\n+import static jdk.internal.classfile.Classfile.ACC_PROTECTED;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+\n@@ -55,5 +59,1 @@\n-              Set<AccessFlag> set = EnumSet.copyOf(af.flags());\n-              set.add(AccessFlag.PRIVATE);\n-              set.remove(AccessFlag.PROTECTED);\n-              set.remove(AccessFlag.PUBLIC);\n-              mb.withFlags(set.toArray(AccessFlag[]::new));\n+              mb.withFlags((af.flagsMask() | ACC_PRIVATE) & ~ (ACC_PUBLIC | ACC_PROTECTED));\n","filename":"test\/jdk\/java\/lang\/invoke\/8022701\/MHIllegalAccess.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import java.lang.reflect.Modifier;\n@@ -52,0 +51,3 @@\n+\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n@@ -308,1 +310,1 @@\n-            clb.withMethodBody(CTOR_NAME, MD_void, PUBLIC, cob -> {\n+            clb.withMethodBody(CTOR_NAME, MD_void, ACC_PUBLIC, cob -> {\n@@ -313,1 +315,1 @@\n-            clb.withMethodBody(\"<clinit>\", MD_void, AccessFlag.STATIC.mask(), cob -> {\n+            clb.withMethodBody(\"<clinit>\", MD_void, ACC_STATIC, cob -> {\n@@ -327,1 +329,1 @@\n-            clb.withMethodBody(CTOR_NAME, MD_void, PUBLIC, cob -> {\n+            clb.withMethodBody(CTOR_NAME, MD_void, ACC_PUBLIC, cob -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/DefineClassTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,0 +46,4 @@\n+import static jdk.internal.classfile.Classfile.ACC_PRIVATE;\n+import static jdk.internal.classfile.Classfile.ACC_PROTECTED;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+\n@@ -58,4 +62,0 @@\n-                    var flags = EnumSet.copyOf(ici.flags());\n-                    flags.remove(AccessFlag.PRIVATE);\n-                    flags.remove(AccessFlag.PUBLIC);\n-                    flags.add(AccessFlag.PROTECTED);\n@@ -63,1 +63,1 @@\n-                    var updatedFlags = flags.stream().mapToInt(AccessFlag::mask).reduce(0, (a, b) -> a | b);\n+                    var flags = (ACC_PROTECTED | ici.flagsMask()) & ~(ACC_PRIVATE | ACC_PUBLIC);\n@@ -68,2 +68,2 @@\n-                            + \", access modified to 0x\" + Integer.toHexString(updatedFlags));\n-                    return InnerClassInfo.of(ici.innerClass(), ici.outerClass(), ici.innerName(), updatedFlags);\n+                            + \", access modified to 0x\" + Integer.toHexString(flags));\n+                    return InnerClassInfo.of(ici.innerClass(), ici.outerClass(), ici.innerName(), flags);\n","filename":"test\/jdk\/java\/lang\/invoke\/accessProtectedSuper\/Test.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n@@ -282,1 +283,3 @@\n-        assertEquals(hc.getModifiers(), accessFlags.stream().mapToInt(AccessFlag::mask).reduce(AccessFlag.PUBLIC.mask(), (a, b) -> a | b));\n+        assertEquals(hc.getModifiers(), accessFlags.stream()\n+                .mapToInt(AccessFlag::mask)\n+                .reduce(ACC_PUBLIC, (a, b) -> a | b));\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/BasicTest.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,2 +46,2 @@\n-import static java.lang.reflect.AccessFlag.PUBLIC;\n-import static java.lang.reflect.AccessFlag.STATIC;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n@@ -121,1 +121,1 @@\n-            clb.withFlags(PUBLIC, AccessFlag.SUPER);\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.SUPER);\n@@ -127,1 +127,2 @@\n-            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object, CD_int), PUBLIC.mask() | STATIC.mask(), cob -> {\n+            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object, CD_int),\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/StaticInvocableTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import static java.lang.reflect.AccessFlag.ABSTRACT;\n@@ -49,0 +48,3 @@\n+import static jdk.internal.classfile.Classfile.ACC_ABSTRACT;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n@@ -140,1 +142,1 @@\n-            clb.withFlags(ABSTRACT, AccessFlag.INTERFACE);\n+            clb.withFlags(AccessFlag.ABSTRACT, AccessFlag.INTERFACE);\n@@ -142,1 +144,2 @@\n-            clb.withMethod(\"make\", MethodTypeDesc.of(CD_Object), PUBLIC.mask() | ABSTRACT.mask(), mb -> {});\n+            clb.withMethod(\"make\", MethodTypeDesc.of(CD_Object),\n+                    ACC_PUBLIC | ACC_STATIC, mb -> {});\n@@ -151,1 +154,1 @@\n-            clb.withFlags(ABSTRACT, AccessFlag.INTERFACE);\n+            clb.withFlags(AccessFlag.ABSTRACT, AccessFlag.INTERFACE);\n@@ -154,1 +157,2 @@\n-            clb.withMethod(\"make\", MethodTypeDesc.of(CD_String), PUBLIC.mask() | ABSTRACT.mask(), mb -> {});\n+            clb.withMethod(\"make\", MethodTypeDesc.of(CD_String),\n+                    ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaStackTrace.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n@@ -124,1 +126,1 @@\n-            clb.withMethodBody(CTOR_NAME, MD_void, AccessFlag.PUBLIC.mask(), cob -> {\n+            clb.withMethodBody(CTOR_NAME, MD_void, ACC_PUBLIC, cob -> {\n@@ -129,1 +131,1 @@\n-            clb.withMethodBody(METHOD_NAME, MD_int, AccessFlag.PUBLIC.mask(), cob -> {\n+            clb.withMethodBody(METHOD_NAME, MD_int, ACC_PUBLIC, cob -> {\n@@ -140,1 +142,1 @@\n-            clb.withMethodBody(CTOR_NAME, MD_void, AccessFlag.PUBLIC.mask(), cob -> {\n+            clb.withMethodBody(CTOR_NAME, MD_void, ACC_PUBLIC, cob -> {\n@@ -145,1 +147,1 @@\n-            clb.withMethodBody(METHOD_NAME, MD_int, AccessFlag.PUBLIC.mask() | AccessFlag.STATIC.mask(), cob -> {\n+            clb.withMethodBody(METHOD_NAME, MD_int, ACC_PUBLIC | ACC_STATIC, cob -> {\n@@ -156,1 +158,1 @@\n-            clb.withMethodBody(CTOR_NAME, MD_void, AccessFlag.PUBLIC.mask(), cob -> {\n+            clb.withMethodBody(CTOR_NAME, MD_void, ACC_PUBLIC, cob -> {\n@@ -161,1 +163,1 @@\n-            clb.withMethodBody(METHOD_NAME, MD_int, AccessFlag.PUBLIC.mask(), cob -> {\n+            clb.withMethodBody(METHOD_NAME, MD_int, ACC_PUBLIC, cob -> {\n@@ -166,1 +168,1 @@\n-                    AccessFlag.PUBLIC.mask() | AccessFlag.STATIC.mask(), cob -> {\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n@@ -171,1 +173,1 @@\n-                    AccessFlag.PUBLIC.mask() | AccessFlag.STATIC.mask(), cob -> {\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n","filename":"test\/jdk\/java\/lang\/invoke\/lookup\/SpecialStatic.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import static jdk.internal.classfile.Classfile.ACC_PRIVATE;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n@@ -69,1 +71,1 @@\n-                    clb.withMethodBody(\"privInstance\", MethodTypeDesc.of(CD_int), AccessFlag.PRIVATE.mask(), cob -> {\n+                    clb.withMethodBody(\"privInstance\", MethodTypeDesc.of(CD_int), ACC_PRIVATE, cob -> {\n@@ -78,1 +80,1 @@\n-                    clb.withMethodBody(CTOR_NAME, CTOR_DESC, AccessFlag.PUBLIC.mask(), cob -> {\n+                    clb.withMethodBody(CTOR_NAME, CTOR_DESC, ACC_PUBLIC, cob -> {\n","filename":"test\/jdk\/java\/lang\/reflect\/Method\/invoke\/TestPrivateInterfaceMethodReflect.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,0 +46,3 @@\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static jdk.internal.classfile.Classfile.ACC_ABSTRACT;\n+import static jdk.internal.classfile.Classfile.ACC_FINAL;\n@@ -86,1 +89,1 @@\n-        List<RecordComponentEntry> rc = null;\n+        List<RecordComponentInfo> rc = null;\n@@ -88,1 +91,1 @@\n-            rc = List.of(new RecordComponentEntry(\"x\", \"I\"));\n+            rc = List.of(RecordComponentInfo.of(\"x\", CD_int));\n@@ -113,1 +116,1 @@\n-        List<RecordComponentEntry> rc = null;\n+        List<RecordComponentInfo> rc = null;\n@@ -115,1 +118,1 @@\n-            rc = List.of(new RecordComponentEntry(\"x\", \"I\"));\n+            rc = List.of(RecordComponentInfo.of(\"x\", CD_int));\n@@ -165,1 +168,1 @@\n-                              List<RecordComponentEntry> components) {\n+                              List<RecordComponentInfo> components) {\n@@ -169,1 +172,1 @@\n-                access = access | AccessFlag.FINAL.mask();\n+                access = access | ACC_FINAL;\n@@ -171,1 +174,1 @@\n-                access = access | AccessFlag.ABSTRACT.mask();\n+                access = access | ACC_ABSTRACT;\n@@ -175,3 +178,1 @@\n-                clb.accept(RecordAttribute.of(components.stream()\n-                        .map(e -> RecordComponentInfo.of(e.name, ClassDesc.ofDescriptor(e.descriptor)))\n-                        .toList()));\n+                clb.accept(RecordAttribute.of(components));\n@@ -181,2 +182,0 @@\n-    record RecordComponentEntry (String name, String descriptor) { }\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/IsRecordTest.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n@@ -216,1 +218,2 @@\n-            var provider$1Desc = ClassDesc.of(\"p\", \"ProviderFactory$1\");\n+\n+            var providerFactory$1 = ClassDesc.of(\"p\", \"ProviderFactory$1\");\n@@ -220,6 +223,6 @@\n-                    AccessFlag.PUBLIC.mask() | AccessFlag.STATIC.mask(), cob -> {\n-                cob.new_(provider$1Desc);\n-                cob.dup();\n-                cob.invokespecial(provider$1Desc, \"<init>\", MethodTypeDesc.of(CD_void));\n-                cob.areturn();\n-            });\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n+                        cob.new_(providerFactory$1);\n+                        cob.dup();\n+                        cob.invokespecial(providerFactory$1, \"<init>\", MethodTypeDesc.of(CD_void));\n+                        cob.areturn();\n+                    });\n@@ -228,7 +231,7 @@\n-            clb.withMethodBody(\"provider\", MethodTypeDesc.of(provider$1Desc),\n-                    AccessFlag.PUBLIC.mask() | AccessFlag.STATIC.mask(), cob -> {\n-                cob.new_(provider$1Desc);\n-                cob.dup();\n-                cob.invokespecial(provider$1Desc, \"<init>\", MethodTypeDesc.of(CD_void));\n-                cob.areturn();\n-            });\n+            clb.withMethodBody(\"provider\", MethodTypeDesc.of(providerFactory$1),\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n+                        cob.new_(providerFactory$1);\n+                        cob.dup();\n+                        cob.invokespecial(providerFactory$1, \"<init>\", MethodTypeDesc.of(CD_void));\n+                        cob.areturn();\n+                    });\n","filename":"test\/jdk\/java\/util\/ServiceLoader\/BadProvidersTest.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"}]}