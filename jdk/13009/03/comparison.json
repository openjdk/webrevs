{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.constantpool\n@@ -41,4 +42,5 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import java.lang.constant.MethodTypeDesc;\n+\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.MethodModel;\n@@ -51,3 +53,3 @@\n-import static jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES;\n-import static jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n@@ -201,0 +203,2 @@\n+    static final String CTR_NAME = \"<init>\";\n+\n@@ -206,27 +210,2 @@\n-        ClassReader reader = new ClassReader(classBytes);\n-        ClassWriter writer = new ClassWriter(reader, COMPUTE_MAXS | COMPUTE_FRAMES);\n-        reader.accept(new RemoveCanonicalCtrVisitor(writer), 0);\n-        return writer.toByteArray();\n-    }\n-\n-    \/** Removes the <init> method. *\/\n-    static class RemoveCanonicalCtrVisitor extends ClassVisitor {\n-        static final String CTR_NAME = \"<init>\";\n-        RemoveCanonicalCtrVisitor(ClassVisitor cv) {\n-            super(ASM8, cv);\n-        }\n-        volatile boolean foundCanonicalCtr;\n-        @Override\n-        public MethodVisitor visitMethod(final int access,\n-                                         final String name,\n-                                         final String descriptor,\n-                                         final String signature,\n-                                         final String[] exceptions) {\n-            if (name.equals(CTR_NAME)) {  \/\/ assume just a single constructor\n-                assert foundCanonicalCtr == false;\n-                foundCanonicalCtr = true;\n-                return null;\n-            } else {\n-                return cv.visitMethod(access, name, descriptor, signature, exceptions);\n-            }\n-        }\n+        return Classfile.parse(classBytes).transform(ClassTransform.dropping(ce ->\n+                ce instanceof MethodModel mm && mm.methodName().equalsString(CTR_NAME)));\n@@ -240,50 +219,9 @@\n-        ClassReader reader = new ClassReader(classBytes);\n-        ClassWriter writer = new ClassWriter(reader, COMPUTE_MAXS | COMPUTE_FRAMES);\n-        reader.accept(new ModifyCanonicalCtrVisitor(writer), 0);\n-        return writer.toByteArray();\n-    }\n-\n-    \/** Replaces whatever <init> method it finds with <init>(Ljava\/lang\/Object;)V. *\/\n-    static class ModifyCanonicalCtrVisitor extends ClassVisitor {\n-        ModifyCanonicalCtrVisitor(ClassVisitor cv) {\n-            super(ASM8, cv);\n-        }\n-        boolean foundCanonicalCtr;\n-        String className;\n-        @Override\n-        public void visit(final int version,\n-                          final int access,\n-                          final String name,\n-                          final String signature,\n-                          final String superName,\n-                          final String[] interfaces) {\n-            this.className = name;\n-            cv.visit(version, access, name, signature, superName, interfaces);\n-        }\n-        @Override\n-        public MethodVisitor visitMethod(final int access,\n-                                         final String name,\n-                                         final String descriptor,\n-                                         final String signature,\n-                                         final String[] exceptions) {\n-            if (name.equals(\"<init>\")) {  \/\/ assume just a single constructor\n-                assert foundCanonicalCtr == false;\n-                foundCanonicalCtr = true;\n-                return null;\n-            } else {\n-                return cv.visitMethod(access, name, descriptor, signature, exceptions);\n-            }\n-        }\n-        @Override\n-        public void visitEnd() {\n-            \/\/ must have a signature that is not the same as the test record constructor\n-            MethodVisitor mv = cv.visitMethod(ACC_PUBLIC, \"<init>\", \"(Ljava\/lang\/Object;)V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Record\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-\n-            cv.visitEnd();\n-        }\n+        return Classfile.parse(classBytes).transform(ClassTransform.dropping(ce ->\n+                        ce instanceof MethodModel mm && mm.methodName().equalsString(CTR_NAME))\n+                .andThen(ClassTransform.endHandler(clb -> clb.withMethodBody(CTR_NAME,\n+                        MethodTypeDesc.of(CD_void, CD_Object), ACC_PUBLIC, cob -> {\n+                            cob.aload(0);\n+                            cob.invokespecial(Record.class.describeConstable().orElseThrow(),\n+                                    CTR_NAME, MethodTypeDesc.of(CD_void));\n+                            cob.return_();\n+                        }))));\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/BadCanonicalCtrTest.java","additions":24,"deletions":86,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n@@ -44,0 +44,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -47,5 +48,3 @@\n-import java.util.function.Function;\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n+\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n@@ -54,0 +53,1 @@\n+import org.testng.Assert;\n@@ -58,3 +58,3 @@\n-import static jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_FRAMES;\n-import static jdk.internal.org.objectweb.asm.ClassWriter.COMPUTE_MAXS;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static jdk.internal.classfile.Classfile.ACC_PRIVATE;\n@@ -222,0 +222,3 @@\n+    static final String WRITE_OBJECT_NAME = \"writeObject\";\n+    static final MethodTypeDesc WRITE_OBJECT_DESC = MethodTypeDesc.ofDescriptor(\"(Ljava\/io\/ObjectOutputStream;)V\");\n+\n@@ -223,1 +226,1 @@\n-        return addMethod(classBytes, cv -> new WriteObjectVisitor(cv));\n+        return addMethod(classBytes, WRITE_OBJECT_NAME, WRITE_OBJECT_DESC);\n@@ -226,0 +229,3 @@\n+    static final String READ_OBJECT_NAME = \"readObject\";\n+    static final MethodTypeDesc READ_OBJECT_DESC = MethodTypeDesc.ofDescriptor(\"(Ljava\/io\/ObjectInputStream;)V\");\n+\n@@ -227,1 +233,1 @@\n-        return addMethod(classBytes, cv -> new ReadObjectVisitor(cv));\n+        return addMethod(classBytes, READ_OBJECT_NAME, READ_OBJECT_DESC);\n@@ -230,0 +236,3 @@\n+    static final String READ_OBJECT_NO_DATA_NAME = \"readObjectNoData\";\n+    static final MethodTypeDesc READ_OBJECT_NO_DATA_DESC = MethodTypeDesc.of(CD_void);\n+\n@@ -231,1 +240,1 @@\n-        return addMethod(classBytes, cv -> new ReadObjectNoDataVisitor(cv));\n+        return addMethod(classBytes, READ_OBJECT_NO_DATA_NAME, READ_OBJECT_NO_DATA_DESC);\n@@ -235,84 +244,9 @@\n-                            Function<ClassVisitor,ClassVisitor> classVisitorCreator) {\n-        ClassReader reader = new ClassReader(classBytes);\n-        ClassWriter writer = new ClassWriter(reader, COMPUTE_MAXS | COMPUTE_FRAMES);\n-        reader.accept(classVisitorCreator.apply(writer), 0);\n-        return writer.toByteArray();\n-    }\n-\n-    static abstract class AbstractVisitor extends ClassVisitor {\n-        final String nameOfMethodToAdd;\n-        AbstractVisitor(ClassVisitor cv, String nameOfMethodToAdd) {\n-            super(ASM8, cv);\n-            this.nameOfMethodToAdd = nameOfMethodToAdd;\n-        }\n-        @Override\n-        public MethodVisitor visitMethod(final int access,\n-                                         final String name,\n-                                         final String descriptor,\n-                                         final String signature,\n-                                         final String[] exceptions) {\n-            \/\/ the method-to-be-added should not already exist\n-            assert !name.equals(nameOfMethodToAdd) : \"Unexpected \" + name + \" method\";\n-            return cv.visitMethod(access, name, descriptor, signature, exceptions);\n-        }\n-        @Override\n-        public void visitEnd() {\n-            throw new UnsupportedOperationException(\"implement me\");\n-        }\n-    }\n-\n-    \/** A visitor that generates and adds a writeObject method. *\/\n-    static final class WriteObjectVisitor extends AbstractVisitor {\n-        static final String WRITE_OBJECT_NAME = \"writeObject\";\n-        static final String WRITE_OBJECT_DESC = \"(Ljava\/io\/ObjectOutputStream;)V\";\n-        WriteObjectVisitor(ClassVisitor cv) { super(cv, WRITE_OBJECT_NAME); }\n-        @Override\n-        public void visitEnd() {\n-            MethodVisitor mv = cv.visitMethod(ACC_PRIVATE, WRITE_OBJECT_NAME, WRITE_OBJECT_DESC, null, null);\n-            mv.visitCode();\n-            mv.visitLdcInsn(WRITE_OBJECT_NAME + \" should not be invoked\");\n-            mv.visitMethodInsn(INVOKESTATIC, \"org\/testng\/Assert\", \"fail\", \"(Ljava\/lang\/String;)V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-\n-            cv.visitEnd();\n-        }\n-    }\n-\n-    \/** A visitor that generates and adds a readObject method. *\/\n-    static final class ReadObjectVisitor extends AbstractVisitor {\n-        static final String READ_OBJECT_NAME = \"readObject\";\n-        static final String READ_OBJECT_DESC = \"(Ljava\/io\/ObjectInputStream;)V\";\n-        ReadObjectVisitor(ClassVisitor cv) { super(cv, READ_OBJECT_NAME); }\n-        @Override\n-        public void visitEnd() {\n-            MethodVisitor mv = cv.visitMethod(ACC_PRIVATE, READ_OBJECT_NAME, READ_OBJECT_DESC, null, null);\n-            mv.visitCode();\n-            mv.visitLdcInsn(READ_OBJECT_NAME + \" should not be invoked\");\n-            mv.visitMethodInsn(INVOKESTATIC, \"org\/testng\/Assert\", \"fail\", \"(Ljava\/lang\/String;)V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-\n-            cv.visitEnd();\n-        }\n-    }\n-\n-    \/** A visitor that generates and adds a readObjectNoData method. *\/\n-    static final class ReadObjectNoDataVisitor extends AbstractVisitor {\n-        static final String READ_OBJECT_NO_DATA_NAME = \"readObjectNoData\";\n-        static final String READ_OBJECT_NO_DATA_DESC = \"()V\";\n-        ReadObjectNoDataVisitor(ClassVisitor cv) { super(cv, READ_OBJECT_NO_DATA_NAME); }\n-        @Override\n-        public void visitEnd() {\n-            MethodVisitor mv = cv.visitMethod(ACC_PRIVATE, READ_OBJECT_NO_DATA_NAME, READ_OBJECT_NO_DATA_DESC, null, null);\n-            mv.visitCode();\n-            mv.visitLdcInsn(READ_OBJECT_NO_DATA_NAME + \" should not be invoked\");\n-            mv.visitMethodInsn(INVOKESTATIC, \"org\/testng\/Assert\", \"fail\", \"(Ljava\/lang\/String;)V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-\n-            cv.visitEnd();\n-        }\n+                            String name, MethodTypeDesc desc) {\n+        return Classfile.parse(classBytes).transform(ClassTransform.endHandler(clb -> {\n+            clb.withMethodBody(name, desc, ACC_PRIVATE, cob -> {\n+                cob.constantInstruction(name + \" should not be invoked\");\n+                cob.invokestatic(Assert.class.describeConstable().orElseThrow(), \"fail\",\n+                        MethodTypeDesc.of(CD_void, CD_String));\n+                cob.return_();\n+            });\n+        }));\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/ProhibitedMethods.java","additions":31,"deletions":97,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.constantpool\n@@ -41,0 +42,4 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -44,6 +49,6 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.FieldVisitor;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Type;\n+\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.FieldModel;\n@@ -56,2 +61,6 @@\n-import static jdk.internal.org.objectweb.asm.ClassWriter.*;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static java.lang.constant.ConstantDescs.CD_Class;\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static jdk.internal.classfile.Classfile.ACC_FINAL;\n+import static jdk.internal.classfile.Classfile.ACC_PRIVATE;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n@@ -221,4 +230,2 @@\n-        ClassReader reader = new ClassReader(classBytes);\n-        ClassWriter writer = new ClassWriter(reader, COMPUTE_MAXS | COMPUTE_FRAMES);\n-        reader.accept(new SerialPersistentFieldsVisitor(writer, spf), 0);\n-        return writer.toByteArray();\n+        var model = Classfile.parse(classBytes);\n+        return model.transform(new SerialPersistentFieldsVisitor(model.thisClass().asSymbol(), spf));\n@@ -228,1 +235,1 @@\n-    static final class SerialPersistentFieldsVisitor extends ClassVisitor {\n+    static final class SerialPersistentFieldsVisitor implements ClassTransform {\n@@ -230,1 +237,2 @@\n-        static final String FIELD_DESC = \"[Ljava\/io\/ObjectStreamField;\";\n+        static final ClassDesc CD_ObjectStreamField = ObjectStreamField.class.describeConstable().orElseThrow();\n+        static final ClassDesc FIELD_DESC = CD_ObjectStreamField.arrayType();\n@@ -232,3 +240,3 @@\n-        String className;\n-        SerialPersistentFieldsVisitor(ClassVisitor cv, ObjectStreamField[] spf) {\n-            super(ASM8, cv);\n+        final ClassDesc className;\n+        SerialPersistentFieldsVisitor(ClassDesc className, ObjectStreamField[] spf) {\n+            this.className = className;\n@@ -237,0 +245,1 @@\n+\n@@ -238,18 +247,8 @@\n-        public void visit(final int version,\n-                          final int access,\n-                          final String name,\n-                          final String signature,\n-                          final String superName,\n-                          final String[] interfaces) {\n-            this.className = name;\n-            cv.visit(version, access, name, signature, superName, interfaces);\n-        }\n-        @Override\n-        public FieldVisitor visitField(final int access,\n-                                       final String name,\n-                                       final String descriptor,\n-                                       final String signature,\n-                                       final Object value) {\n-            \/\/ the field-to-be-added should not already exist\n-            assert !name.equals(\"serialPersistentFields\") : \"Unexpected \" + name + \" field\";\n-            return cv.visitField(access, name, descriptor, signature, value);\n+        public void accept(ClassBuilder builder, ClassElement element) {\n+            if (element instanceof FieldModel fieldModel) {\n+                var name = fieldModel.fieldName().stringValue();\n+                assert !name.equals(FIELD_NAME) : \"Unexpected \" + FIELD_NAME + \" field\";\n+                builder.accept(fieldModel);\n+            } else {\n+                builder.accept(element);\n+            }\n@@ -257,0 +256,1 @@\n+\n@@ -258,14 +258,5 @@\n-        public void visitEnd() {\n-            {\n-                FieldVisitor fv = cv.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL,\n-                                                FIELD_NAME,\n-                                                FIELD_DESC,\n-                                                null,\n-                                                null);\n-                fv.visitEnd();\n-            }\n-            {\n-                MethodVisitor mv = cv.visitMethod(ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n-                mv.visitCode();\n-                mv.visitIntInsn(BIPUSH, spf.length);\n-                mv.visitTypeInsn(ANEWARRAY, \"java\/io\/ObjectStreamField\");\n+        public void atEnd(ClassBuilder builder) {\n+            builder.withField(FIELD_NAME, FIELD_DESC, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n+            builder.withMethodBody(\"<clinit>\", MethodTypeDesc.of(CD_void), ACC_STATIC, cob -> {\n+                cob.bipush(spf.length);\n+                cob.anewarray(CD_ObjectStreamField);\n@@ -275,7 +266,8 @@\n-                    mv.visitInsn(DUP);\n-                    mv.visitIntInsn(BIPUSH, i);\n-                    mv.visitTypeInsn(NEW, \"java\/io\/ObjectStreamField\");\n-                    mv.visitInsn(DUP);\n-                    mv.visitLdcInsn(osf.getName());\n-                    if (osf.getType().isPrimitive()) {\n-                        mv.visitFieldInsn(GETSTATIC,  getPrimitiveBoxClass(osf.getType()), \"TYPE\", \"Ljava\/lang\/Class;\");\n+                    cob.dup();\n+                    cob.bipush(i);\n+                    cob.new_(CD_ObjectStreamField);\n+                    cob.dup();\n+                    cob.constantInstruction(osf.getName());\n+                    if (osf.isPrimitive()) {\n+                        cob.constantInstruction(DynamicConstantDesc.ofNamed(\n+                                ConstantDescs.BSM_PRIMITIVE_CLASS, String.valueOf(osf.getTypeCode()), CD_Class));\n@@ -283,1 +275,2 @@\n-                        mv.visitLdcInsn(Type.getType(osf.getType()));\n+                        \/\/ Currently Classfile API cannot encode primitive classdescs as condy\n+                        cob.constantInstruction(osf.getType().describeConstable().orElseThrow());\n@@ -285,2 +278,2 @@\n-                    mv.visitMethodInsn(INVOKESPECIAL, \"java\/io\/ObjectStreamField\", \"<init>\", \"(Ljava\/lang\/String;Ljava\/lang\/Class;)V\", false);\n-                    mv.visitInsn(AASTORE);\n+                    cob.invokespecial(CD_ObjectStreamField, \"<init>\", MethodTypeDesc.of(CD_void, CD_String, CD_Class));\n+                    cob.aastore();\n@@ -289,31 +282,3 @@\n-                mv.visitFieldInsn(PUTSTATIC, className, \"serialPersistentFields\", \"[Ljava\/io\/ObjectStreamField;\");\n-                mv.visitInsn(RETURN);\n-                mv.visitMaxs(0, 0);\n-                mv.visitEnd();\n-            }\n-            cv.visitEnd();\n-        }\n-\n-        static String getPrimitiveBoxClass(final Class<?> clazz) {\n-            if (!clazz.isPrimitive())\n-                throw new AssertionError(\"unexpected non-primitive:\" + clazz);\n-\n-            if (clazz == Integer.TYPE) {\n-                return \"java\/lang\/Integer\";\n-            } else if (clazz == Boolean.TYPE) {\n-                return \"java\/lang\/Boolean\";\n-            } else if (clazz == Byte.TYPE) {\n-                return \"java\/lang\/Byte\";\n-            } else if (clazz == Character.TYPE) {\n-                return \"java\/lang\/Character\";\n-            } else if (clazz == Short.TYPE) {\n-                return \"java\/lang\/Short\";\n-            } else if (clazz == Double.TYPE) {\n-                return \"java\/lang\/Double\";\n-            } else if (clazz == Float.TYPE) {\n-                return \"java\/lang\/Float\";\n-            } else if (clazz == Long.TYPE) {\n-                return \"java\/lang\/Long\";\n-            } else {\n-                throw new AssertionError(\"unknown:\" + clazz);\n-            }\n+                cob.putstatic(className, FIELD_NAME, FIELD_DESC);\n+                cob.return_();\n+            });\n","filename":"test\/jdk\/java\/io\/Serializable\/records\/SerialPersistentFieldsTest.java","additions":57,"deletions":92,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n@@ -29,2 +30,16 @@\n-import jdk.internal.org.objectweb.asm.*;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n+import java.util.Optional;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.attribute.EnclosingMethodAttribute;\n+import jdk.internal.classfile.attribute.InnerClassInfo;\n+import jdk.internal.classfile.attribute.InnerClassesAttribute;\n+\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n@@ -124,2 +139,4 @@\n-        final String innerName;\n-        final String outerName;\n+        private static final String CTOR_NAME = \"<init>\";\n+        private static final MethodTypeDesc MD_void = MethodTypeDesc.of(CD_void);\n+        final ClassDesc innerName;\n+        final ClassDesc outerName;\n@@ -129,2 +146,2 @@\n-            this.innerName = intl(innerName);\n-            this.outerName = intl(outerName);\n+            this.innerName = ClassDesc.of(innerName);\n+            this.outerName = ClassDesc.of(outerName);\n@@ -134,10 +151,6 @@\n-        static String intl(String name) { return name.replace('.', '\/'); }\n-\n-        static void makeDefaultCtor(ClassWriter cw) {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n+        static void makeDefaultCtor(ClassBuilder clb) {\n+            clb.withMethodBody(CTOR_NAME, MD_void, ACC_PUBLIC, cb -> {\n+                cb.aload(0);\n+                cb.invokespecial(CD_Object, CTOR_NAME, MD_void);\n+                cb.return_();\n+            });\n@@ -146,1 +159,1 @@\n-        void makeCtxk(ClassWriter cw, boolean isInner) {\n+        void makeCtxk(ClassBuilder clb, boolean isInner) {\n@@ -148,1 +161,2 @@\n-                cw.visitOuterClass(outerName, \"f\", \"()V\");\n+                clb.with(EnclosingMethodAttribute.of(outerName,\n+                        Optional.of(\"f\"), Optional.of(MD_void)));\n@@ -150,5 +164,2 @@\n-                MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"f\", \"()V\", null, null);\n-                mv.visitCode();\n-                mv.visitInsn(RETURN);\n-                mv.visitMaxs(0, 0);\n-                mv.visitEnd();\n+                clb.withMethodBody(\"f\", MD_void, ACC_PUBLIC | ACC_STATIC,\n+                        CodeBuilder::return_);\n@@ -159,9 +170,10 @@\n-            String name = (isInner ? innerName : outerName);\n-            ClassWriter cw = new ClassWriter(0);\n-            cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, name, null, \"java\/lang\/Object\", null);\n-\n-            cw.visitInnerClass(innerName, outerName, simpleName, ACC_PUBLIC | ACC_STATIC);\n-\n-            makeDefaultCtor(cw);\n-            cw.visitEnd();\n-            return cw.toByteArray();\n+            var name = (isInner ? innerName : outerName);\n+            return Classfile.build(name, clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withFlags(AccessFlag.PUBLIC, AccessFlag.SUPER);\n+                clb.with(InnerClassesAttribute.of(\n+                        InnerClassInfo.of(innerName,\n+                                Optional.of(outerName),\n+                                Optional.of(simpleName))));\n+                makeDefaultCtor(clb);\n+            });\n@@ -171,9 +183,11 @@\n-            String name = (isInner ? innerName : outerName);\n-            ClassWriter cw = new ClassWriter(0);\n-            cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, name, null, \"java\/lang\/Object\", null);\n-\n-            cw.visitInnerClass(innerName, outerName, simpleName, ACC_PUBLIC);\n-\n-            makeDefaultCtor(cw);\n-            cw.visitEnd();\n-            return cw.toByteArray();\n+            var name = (isInner ? innerName : outerName);\n+            return Classfile.build(name, clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withFlags(AccessFlag.PUBLIC, AccessFlag.SUPER);\n+                clb.with(InnerClassesAttribute.of(\n+                        InnerClassInfo.of(innerName,\n+                                Optional.of(outerName),\n+                                Optional.of(simpleName),\n+                                AccessFlag.PUBLIC)));\n+                makeDefaultCtor(clb);\n+            });\n@@ -183,10 +197,12 @@\n-            String name = (isInner ? innerName : outerName);\n-            ClassWriter cw = new ClassWriter(0);\n-            cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, name, null, \"java\/lang\/Object\", null);\n-\n-            cw.visitInnerClass(innerName, null, simpleName, ACC_PUBLIC | ACC_STATIC);\n-            makeCtxk(cw, isInner);\n-\n-            makeDefaultCtor(cw);\n-            cw.visitEnd();\n-            return cw.toByteArray();\n+            var name = (isInner ? innerName : outerName);\n+            return Classfile.build(name, clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withFlags(AccessFlag.PUBLIC, AccessFlag.SUPER);\n+                clb.with(InnerClassesAttribute.of(\n+                        InnerClassInfo.of(innerName,\n+                                Optional.empty(),\n+                                Optional.of(simpleName),\n+                                AccessFlag.PUBLIC, AccessFlag.STATIC)));\n+                makeDefaultCtor(clb);\n+                makeCtxk(clb, isInner);\n+            });\n@@ -196,10 +212,12 @@\n-            String name = (isInner ? innerName : outerName);\n-            ClassWriter cw = new ClassWriter(0);\n-            cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, name, null, \"java\/lang\/Object\", null);\n-\n-            cw.visitInnerClass(innerName, null, null, ACC_PUBLIC | ACC_STATIC);\n-            makeCtxk(cw, isInner);\n-\n-            makeDefaultCtor(cw);\n-            cw.visitEnd();\n-            return cw.toByteArray();\n+            var name = (isInner ? innerName : outerName);\n+            return Classfile.build(name, clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withFlags(AccessFlag.PUBLIC, AccessFlag.SUPER);\n+                clb.with(InnerClassesAttribute.of(\n+                        InnerClassInfo.of(innerName,\n+                                Optional.empty(),\n+                                Optional.empty(),\n+                                AccessFlag.PUBLIC, AccessFlag.STATIC)));\n+                makeDefaultCtor(clb);\n+                makeCtxk(clb, isInner);\n+            });\n","filename":"test\/jdk\/java\/lang\/Class\/getSimpleName\/GetSimpleNameTest.java","additions":81,"deletions":63,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.InputStream;\n@@ -35,2 +34,0 @@\n-import java.util.ArrayList;\n-import java.util.List;\n@@ -39,0 +36,4 @@\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -40,7 +41,0 @@\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-import jdk.internal.org.objectweb.asm.Attribute;\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.commons.ModuleTargetAttribute;\n@@ -53,2 +47,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          java.base\/jdk.internal.org.objectweb.asm.commons\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n@@ -149,17 +143,9 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-\n-        ClassVisitor cv = new ClassVisitor(Opcodes.ASM6, cw) { };\n-\n-        ClassReader cr = new ClassReader(bytes);\n-        List<Attribute> attrs = new ArrayList<>();\n-        attrs.add(new ModuleTargetAttribute());\n-        cr.accept(cv, attrs.toArray(new Attribute[0]), 0);\n-\n-        AnnotationVisitor annotationVisitor\n-            = cv.visitAnnotation(\"Ljava\/lang\/Deprecated;\", true);\n-        annotationVisitor.visit(\"forRemoval\", forRemoval);\n-        annotationVisitor.visit(\"since\", since);\n-        annotationVisitor.visitEnd();\n-\n-        return cw.toByteArray();\n+        return Classfile.parse(bytes)\n+                .transform(ClassTransform.endHandler(clb ->\n+                        clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                                jdk.internal.classfile.Annotation.of(\n+                                        Deprecated.class.describeConstable().orElseThrow(),\n+                                        AnnotationElement.ofBoolean(\"forRemoval\", forRemoval),\n+                                        AnnotationElement.ofString(\"since\", since)\n+                                )\n+                        ))));\n","filename":"test\/jdk\/java\/lang\/ModuleTests\/AnnotationsTest.java","additions":15,"deletions":29,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n@@ -33,4 +34,5 @@\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -41,0 +43,3 @@\n+import java.lang.constant.ClassDesc;\n+\n+import static java.lang.constant.ConstantDescs.CD_Object;\n@@ -49,6 +54,9 @@\n-        ClassWriter writer = new ClassWriter(0);\n-        writer.visit(Opcodes.V1_8, 0, \"sample\/Carrier\", null, Type.getInternalName(Object.class), null);\n-        AnnotationVisitor v = writer.visitAnnotation(Type.getDescriptor(AnAnnotation.class), true);\n-        v.visitEnum(\"value\", Type.getDescriptor(AnEnum.class), \"VALUE\");\n-        writer.visitEnd();\n-        byte[] b = writer.toByteArray();\n+        byte[] b = Classfile.build(ClassDesc.of(\"sample\", \"Carrier\"), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                    Annotation.of(\n+                            AnAnnotation.class.describeConstable().orElseThrow(),\n+                            AnnotationElement.of(\"value\", AnnotationValue.of(AnEnum.VALUE))\n+                    )\n+            ));\n+        });\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationTypeMismatchException\/AnnotationTypeMismatchTest.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n@@ -34,4 +35,5 @@\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -42,0 +44,3 @@\n+import java.lang.constant.ClassDesc;\n+\n+import static java.lang.constant.ConstantDescs.CD_Object;\n@@ -57,9 +62,9 @@\n-        ClassWriter writer = new ClassWriter(0);\n-        writer.visit(Opcodes.V1_8, 0, \"sample\/Carrier\", null, Type.getInternalName(Object.class), null);\n-        AnnotationVisitor v = writer.visitAnnotation(Type.getDescriptor(AnAnnotation.class), true);\n-        AnnotationVisitor v2 = v.visitArray(\"value\");\n-        v2.visit(null, \"v\");\n-        v2.visitEnd();\n-        v.visitEnd();\n-        writer.visitEnd();\n-        byte[] b = writer.toByteArray();\n+        byte[] b = Classfile.build(ClassDesc.of(\"sample\", \"Carrier\"), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                    Annotation.of(\n+                            AnAnnotation.class.describeConstable().orElseThrow(),\n+                            AnnotationElement.of(\"value\", AnnotationValue.of(new String[] {\"v\"}))\n+                    )\n+            ));\n+        });\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationTypeMismatchException\/ArityTypeMismatchTest.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n@@ -33,4 +34,4 @@\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -42,0 +43,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -44,0 +48,4 @@\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static jdk.internal.classfile.Classfile.ACC_ABSTRACT;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+\n@@ -70,2 +78,1 @@\n-            if (cause instanceof AnnotationTypeMismatchException) {\n-                AnnotationTypeMismatchException e = ((AnnotationTypeMismatchException) cause);\n+            if (cause instanceof AnnotationTypeMismatchException e) {\n@@ -84,9 +91,12 @@\n-        ClassWriter writer = new ClassWriter(0);\n-        writer.visit(Opcodes.V1_8, 0, \"sample\/Carrier\", null, Type.getInternalName(Object.class), null);\n-        AnnotationVisitor v = writer.visitAnnotation(\"Lsample\/Host;\", true);\n-        AnnotationVisitor a = v.visitArray(\"value\");\n-        a.visitAnnotation(null, Type.getDescriptor(NoAnnotation.class)).visitEnd();\n-        a.visitEnd();\n-        v.visitEnd();\n-        writer.visitEnd();\n-        return writer.toByteArray();\n+        return Classfile.build(ClassDesc.of(\"sample\", \"Carrier\"), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            var badAnnotationArray = AnnotationValue.ofArray(AnnotationValue.ofAnnotation(\n+                    jdk.internal.classfile.Annotation.of(\n+                            NoAnnotation.class.describeConstable().orElseThrow()\n+                    )));\n+            clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                    jdk.internal.classfile.Annotation.of(ClassDesc.of(\"sample\", \"Host\"),\n+                            AnnotationElement.of(\"value\", badAnnotationArray)\n+                    )\n+            ));\n+        });\n@@ -96,16 +106,14 @@\n-        ClassWriter writer = new ClassWriter(0);\n-        writer.visit(Opcodes.V1_8,\n-                Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT | Opcodes.ACC_INTERFACE | Opcodes.ACC_ANNOTATION,\n-                \"sample\/Host\",\n-                null,\n-                Type.getInternalName(Object.class),\n-                new String[]{Type.getInternalName(Annotation.class)});\n-        AnnotationVisitor a = writer.visitAnnotation(Type.getDescriptor(Retention.class), true);\n-        a.visitEnum(\"value\", Type.getDescriptor(RetentionPolicy.class), RetentionPolicy.RUNTIME.name());\n-        writer.visitMethod(Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,\n-                \"value\",\n-                Type.getMethodDescriptor(Type.getType(NoAnnotation[].class)),\n-                null,\n-                null).visitEnd();\n-        writer.visitEnd();\n-        return writer.toByteArray();\n+        return Classfile.build(ClassDesc.of(\"sample\", \"Host\"), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(Annotation.class.describeConstable().orElseThrow());\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.ABSTRACT, AccessFlag.INTERFACE,\n+                    AccessFlag.ANNOTATION);\n+            clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                    jdk.internal.classfile.Annotation.of(\n+                            Retention.class.describeConstable().orElseThrow(),\n+                            AnnotationElement.of(\"value\", AnnotationValue.of(RetentionPolicy.RUNTIME))\n+                    )\n+            ));\n+            clb.withMethod(\"value\", MethodTypeDesc.of(NoAnnotation[].class.describeConstable()\n+                    .orElseThrow()), ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationTypeMismatchException\/ArrayTypeMismatchTest.java","additions":41,"deletions":33,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n@@ -33,4 +34,5 @@\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -41,0 +43,3 @@\n+import java.lang.constant.ClassDesc;\n+\n+import static java.lang.constant.ConstantDescs.CD_Object;\n@@ -49,6 +54,8 @@\n-        ClassWriter writer = new ClassWriter(0);\n-        writer.visit(Opcodes.V1_8, 0, \"sample\/Carrier\", null, Type.getInternalName(Object.class), null);\n-        AnnotationVisitor v = writer.visitAnnotation(Type.getDescriptor(AnAnnotation.class), true);\n-        v.visitAnnotation(\"value\", Type.getDescriptor(AnAnnotation.class)).visitEnd();\n-        writer.visitEnd();\n-        byte[] b = writer.toByteArray();\n+        ClassDesc anAnnotationDesc = AnAnnotation.class.describeConstable().orElseThrow();\n+        byte[] b = Classfile.build(ClassDesc.of(\"sample\", \"Carrier\"), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                    Annotation.of(anAnnotationDesc, AnnotationElement.of(\"value\",\n+                            AnnotationValue.ofAnnotation(Annotation.of(anAnnotationDesc))))\n+            ));\n+        });\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationTypeMismatchException\/EnumTypeMismatchTest.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,2 +44,3 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- * @modules java.base\/sun.reflect.annotation\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.attribute\n+ *          java.base\/sun.reflect.annotation\n","filename":"test\/jdk\/java\/lang\/annotation\/AnnotationVerifier.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * Create class file using ASM, slightly modified the ASMifier output\n+ * Create class file using Classfile API, slightly modified the ASMifier output\n@@ -30,2 +30,0 @@\n-\n-\n@@ -35,1 +33,23 @@\n-import jdk.internal.org.objectweb.asm.*;\n+import java.io.Serializable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.Annotation;\n+import jdk.internal.classfile.AnnotationElement;\n+import jdk.internal.classfile.AnnotationValue;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.AnnotationDefaultAttribute;\n+import jdk.internal.classfile.attribute.ExceptionsAttribute;\n+import jdk.internal.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n+\n+import static java.lang.constant.ConstantDescs.CD_Exception;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static java.lang.reflect.AccessFlag.ABSTRACT;\n+import static java.lang.reflect.AccessFlag.INTERFACE;\n+import static java.lang.reflect.AccessFlag.PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_ABSTRACT;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n@@ -39,0 +59,2 @@\n+    private static final ClassDesc CD_Annotation = java.lang.annotation.Annotation.class.describeConstable().orElseThrow();\n+    private static final ClassDesc CD_Retention = Retention.class.describeConstable().orElseThrow();\n@@ -68,29 +90,13 @@\n-    private static class AnnotationWithVoidReturnDump implements Opcodes {\n-        public static byte[] dump() throws Exception {\n-            ClassWriter cw = new ClassWriter(0);\n-            MethodVisitor mv;\n-            AnnotationVisitor av0;\n-\n-            cw.visit(52, ACC_PUBLIC + ACC_ANNOTATION + ACC_ABSTRACT + ACC_INTERFACE,\n-                    \"AnnotationWithVoidReturn\", null,\n-                    \"java\/lang\/Object\", new String[]{\"java\/lang\/annotation\/Annotation\"});\n-\n-            {\n-                av0 = cw.visitAnnotation(\"Ljava\/lang\/annotation\/Retention;\", true);\n-                av0.visitEnum(\"value\", \"Ljava\/lang\/annotation\/RetentionPolicy;\",\n-                        \"RUNTIME\");\n-                av0.visitEnd();\n-            }\n-            {\n-                mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, \"m\", \"()V\", null, null);\n-                mv.visitEnd();\n-            }\n-            {\n-                av0 = mv.visitAnnotationDefault();\n-                av0.visit(null, new Integer(1));\n-                av0.visitEnd();\n-            }\n-            cw.visitEnd();\n-\n-            return cw.toByteArray();\n-\n+    private static class AnnotationWithVoidReturnDump {\n+        public static byte[] dump() {\n+            return Classfile.build(ClassDesc.of(\"AnnotationWithVoidReturn\"), clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withInterfaceSymbols(CD_Annotation);\n+                clb.withFlags(PUBLIC, AccessFlag.ANNOTATION, ABSTRACT, AccessFlag.INTERFACE);\n+                clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                ));\n+                clb.withMethod(\"m\", MethodTypeDesc.of(CD_void), ACC_PUBLIC | ACC_ABSTRACT,\n+                        mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1))));\n+            });\n@@ -109,32 +115,13 @@\n-    private static class AnnotationWithParameterDump implements Opcodes {\n-        public static byte[] dump() throws Exception {\n-\n-            ClassWriter cw = new ClassWriter(0);\n-            MethodVisitor mv;\n-            AnnotationVisitor av0;\n-\n-            cw.visit(52, ACC_PUBLIC + ACC_ANNOTATION + ACC_ABSTRACT + ACC_INTERFACE,\n-                    \"AnnotationWithParameter\", null,\n-                    \"java\/lang\/Object\", new String[]{\"java\/lang\/annotation\/Annotation\"});\n-\n-            {\n-                av0 = cw.visitAnnotation(\"Ljava\/lang\/annotation\/Retention;\", true);\n-                av0.visitEnum(\"value\", \"Ljava\/lang\/annotation\/RetentionPolicy;\",\n-                        \"RUNTIME\");\n-                av0.visitEnd();\n-            }\n-            {\n-                mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT,\n-                        \"badValue\",\n-                        \"(I)I\", \/\/ Bad method with a parameter\n-                        null, null);\n-                mv.visitEnd();\n-            }\n-            {\n-                av0 = mv.visitAnnotationDefault();\n-                av0.visit(null, new Integer(-1));\n-                av0.visitEnd();\n-            }\n-            cw.visitEnd();\n-\n-            return cw.toByteArray();\n+    private static class AnnotationWithParameterDump {\n+        public static byte[] dump() {\n+            return Classfile.build(ClassDesc.of(\"AnnotationWithParameter\"), clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withInterfaceSymbols(CD_Annotation);\n+                clb.withFlags(PUBLIC, AccessFlag.ANNOTATION, ABSTRACT, AccessFlag.INTERFACE);\n+                clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                ));\n+                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int, CD_int), ACC_PUBLIC | ACC_ABSTRACT,\n+                        mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(-1))));\n+            });\n@@ -153,29 +140,13 @@\n-    private static class AnnotationWithExtraInterfaceDump implements Opcodes {\n-        public static byte[] dump() throws Exception {\n-            ClassWriter cw = new ClassWriter(0);\n-            MethodVisitor mv;\n-            AnnotationVisitor av0;\n-\n-            cw.visit(52, ACC_PUBLIC + ACC_ANNOTATION + ACC_ABSTRACT + ACC_INTERFACE,\n-                    \"AnnotationWithExtraInterface\", null,\n-                    \"java\/lang\/Object\", new String[]{\"java\/lang\/annotation\/Annotation\",\n-                                                     \"java\/io\/Serializable\"});\n-\n-            {\n-                av0 = cw.visitAnnotation(\"Ljava\/lang\/annotation\/Retention;\", true);\n-                av0.visitEnum(\"value\", \"Ljava\/lang\/annotation\/RetentionPolicy;\",\n-                        \"RUNTIME\");\n-                av0.visitEnd();\n-            }\n-            {\n-                mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, \"m\", \"()I\", null, null);\n-                mv.visitEnd();\n-            }\n-            {\n-                av0 = mv.visitAnnotationDefault();\n-                av0.visit(null, new Integer(1));\n-                av0.visitEnd();\n-            }\n-            cw.visitEnd();\n-\n-            return cw.toByteArray();\n+    private static class AnnotationWithExtraInterfaceDump {\n+        public static byte[] dump() {\n+            return Classfile.build(ClassDesc.of(\"AnnotationWithExtraInterface\"), clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withInterfaceSymbols(CD_Annotation, Serializable.class.describeConstable().orElseThrow());\n+                clb.withFlags(PUBLIC, AccessFlag.ANNOTATION, ABSTRACT, AccessFlag.INTERFACE);\n+                clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                ));\n+                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int), ACC_PUBLIC | ACC_ABSTRACT,\n+                        mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1))));\n+            });\n@@ -194,29 +165,15 @@\n-    private static class AnnotationWithExceptionDump implements Opcodes {\n-        public static byte[] dump() throws Exception {\n-            ClassWriter cw = new ClassWriter(0);\n-            MethodVisitor mv;\n-            AnnotationVisitor av0;\n-\n-            cw.visit(52, ACC_PUBLIC + ACC_ANNOTATION + ACC_ABSTRACT + ACC_INTERFACE,\n-                    \"AnnotationWithException\", null,\n-                    \"java\/lang\/Object\", new String[]{\"java\/lang\/annotation\/Annotation\"});\n-\n-            {\n-                av0 = cw.visitAnnotation(\"Ljava\/lang\/annotation\/Retention;\", true);\n-                av0.visitEnum(\"value\", \"Ljava\/lang\/annotation\/RetentionPolicy;\",\n-                        \"RUNTIME\");\n-                av0.visitEnd();\n-            }\n-            {\n-                mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, \"m\", \"()I\", null,\n-                                    new String[] {\"java\/lang\/Exception\"});\n-                mv.visitEnd();\n-            }\n-            {\n-                av0 = mv.visitAnnotationDefault();\n-                av0.visit(null, new Integer(1));\n-                av0.visitEnd();\n-            }\n-            cw.visitEnd();\n-\n-            return cw.toByteArray();\n+    private static class AnnotationWithExceptionDump {\n+        public static byte[] dump() {\n+            return Classfile.build(ClassDesc.of(\"AnnotationWithException\"), clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withInterfaceSymbols(CD_Annotation);\n+                clb.withFlags(PUBLIC, AccessFlag.ANNOTATION, ABSTRACT, AccessFlag.INTERFACE);\n+                clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                ));\n+                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int), ACC_PUBLIC | ACC_ABSTRACT, mb -> {\n+                    mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1)));\n+                    mb.with(ExceptionsAttribute.ofSymbols(CD_Exception));\n+                });\n+            });\n@@ -235,28 +192,13 @@\n-    private static class AnnotationWithHashCodeDump implements Opcodes {\n-        public static byte[] dump() throws Exception {\n-            ClassWriter cw = new ClassWriter(0);\n-            MethodVisitor mv;\n-            AnnotationVisitor av0;\n-\n-            cw.visit(52, ACC_PUBLIC + ACC_ANNOTATION + ACC_ABSTRACT + ACC_INTERFACE,\n-                    \"AnnotationWithHashCode\", null,\n-                    \"java\/lang\/Object\", new String[]{\"java\/lang\/annotation\/Annotation\"});\n-\n-            {\n-                av0 = cw.visitAnnotation(\"Ljava\/lang\/annotation\/Retention;\", true);\n-                av0.visitEnum(\"value\", \"Ljava\/lang\/annotation\/RetentionPolicy;\",\n-                        \"RUNTIME\");\n-                av0.visitEnd();\n-            }\n-            {\n-                mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, \"hashCode\", \"()I\", null, null);\n-                mv.visitEnd();\n-            }\n-            {\n-                av0 = mv.visitAnnotationDefault();\n-                av0.visit(null, new Integer(1));\n-                av0.visitEnd();\n-            }\n-            cw.visitEnd();\n-\n-            return cw.toByteArray();\n+    private static class AnnotationWithHashCodeDump {\n+        public static byte[] dump() {\n+            return Classfile.build(ClassDesc.of(\"AnnotationWithHashCode\"), clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withInterfaceSymbols(CD_Annotation);\n+                clb.withFlags(PUBLIC, AccessFlag.ANNOTATION, ABSTRACT, AccessFlag.INTERFACE);\n+                clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                ));\n+                clb.withMethod(\"hashCode\", MethodTypeDesc.of(CD_int), ACC_PUBLIC | ACC_ABSTRACT,\n+                        mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1))));\n+            });\n@@ -276,1 +218,1 @@\n-    private static class AnnotationWithDefaultMemberDump implements Opcodes {\n+    private static class AnnotationWithDefaultMemberDump {\n@@ -278,39 +220,18 @@\n-            ClassWriter cw = new ClassWriter(0);\n-            MethodVisitor mv, dv;\n-            AnnotationVisitor av0;\n-\n-            cw.visit(52, ACC_PUBLIC + ACC_ANNOTATION + ACC_ABSTRACT + ACC_INTERFACE,\n-                    \"AnnotationWithDefaultMember\", null,\n-                    \"java\/lang\/Object\", new String[]{\"java\/lang\/annotation\/Annotation\"});\n-\n-            {\n-                av0 = cw.visitAnnotation(\"Ljava\/lang\/annotation\/Retention;\", true);\n-                av0.visitEnum(\"value\", \"Ljava\/lang\/annotation\/RetentionPolicy;\",\n-                        \"RUNTIME\");\n-                av0.visitEnd();\n-            }\n-            {\n-                mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, \"m\", \"()I\", null, null);\n-                mv.visitEnd();\n-            }\n-            {\n-                av0 = mv.visitAnnotationDefault();\n-                av0.visit(null, new Integer(1));\n-                av0.visitEnd();\n-            }\n-            {\n-                dv = cw.visitMethod(ACC_PUBLIC, \"d\", \"()I\", null, null);\n-                dv.visitMaxs(1, 1);\n-                dv.visitCode();\n-                dv.visitInsn(Opcodes.ICONST_2);\n-                dv.visitInsn(Opcodes.IRETURN);\n-                dv.visitEnd();\n-            }\n-            {\n-                av0 = dv.visitAnnotationDefault();\n-                av0.visit(null, new Integer(2));\n-                av0.visitEnd();\n-            }\n-            cw.visitEnd();\n-\n-            return cw.toByteArray();\n+            return Classfile.build(ClassDesc.of(\"AnnotationWithDefaultMember\"), clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withInterfaceSymbols(CD_Annotation);\n+                clb.withFlags(PUBLIC, AccessFlag.ANNOTATION, ABSTRACT, AccessFlag.INTERFACE);\n+                clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                ));\n+                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int), ACC_PUBLIC | ACC_ABSTRACT,\n+                        mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1))));\n+                clb.withMethod(\"d\", MethodTypeDesc.of(CD_int), ACC_PUBLIC, mb -> {\n+                    mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(2)));\n+                    mb.withCode(cob -> {\n+                        cob.iconst_2();\n+                        cob.ireturn();\n+                    });\n+                });\n+            });\n@@ -329,28 +250,13 @@\n-    private static class AnnotationWithoutAnnotationAccessModifierDump implements Opcodes {\n-        public static byte[] dump() throws Exception {\n-            ClassWriter cw = new ClassWriter(0);\n-            MethodVisitor mv;\n-            AnnotationVisitor av0;\n-\n-            cw.visit(52, ACC_PUBLIC + \/* ACC_ANNOTATION +*\/ ACC_ABSTRACT + ACC_INTERFACE,\n-                    \"AnnotationWithoutAnnotationAccessModifier\", null,\n-                    \"java\/lang\/Object\", new String[]{\"java\/lang\/annotation\/Annotation\"});\n-\n-            {\n-                av0 = cw.visitAnnotation(\"Ljava\/lang\/annotation\/Retention;\", true);\n-                av0.visitEnum(\"value\", \"Ljava\/lang\/annotation\/RetentionPolicy;\",\n-                        \"RUNTIME\");\n-                av0.visitEnd();\n-            }\n-            {\n-                mv = cw.visitMethod(ACC_PUBLIC + ACC_ABSTRACT, \"m\", \"()I\", null, null);\n-                mv.visitEnd();\n-            }\n-            {\n-                av0 = mv.visitAnnotationDefault();\n-                av0.visit(null, new Integer(1));\n-                av0.visitEnd();\n-            }\n-            cw.visitEnd();\n-\n-            return cw.toByteArray();\n+    private static class AnnotationWithoutAnnotationAccessModifierDump {\n+        public static byte[] dump() {\n+            return Classfile.build(ClassDesc.of(\"AnnotationWithoutAnnotationAccessModifier\"), clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withInterfaceSymbols(CD_Annotation);\n+                clb.withFlags(PUBLIC, \/*AccessFlag.ANNOTATION,*\/ ABSTRACT, AccessFlag.INTERFACE);\n+                clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                        Annotation.of(CD_Retention, AnnotationElement.of(\"value\",\n+                                AnnotationValue.of(RetentionPolicy.RUNTIME)))\n+                ));\n+                clb.withMethod(\"m\", MethodTypeDesc.of(CD_int), ACC_PUBLIC | ACC_ABSTRACT,\n+                        mb -> mb.with(AnnotationDefaultAttribute.of(AnnotationValue.ofInt(1))));\n+            });\n@@ -370,18 +276,10 @@\n-    private static class HolderXDump implements Opcodes {\n-        public static byte[] dump() throws Exception {\n-            ClassWriter cw = new ClassWriter(0);\n-\n-            cw.visit(52, ACC_PUBLIC + ACC_ABSTRACT + ACC_INTERFACE,\n-                    \"HolderX\", null,\n-                    \"java\/lang\/Object\", new String[0]);\n-\n-            {\n-                AnnotationVisitor av0;\n-                av0 = cw.visitAnnotation(\"LGoodAnnotation;\", true);\n-                av0.visitEnd();\n-                av0 = cw.visitAnnotation(\"LAnnotationWithoutAnnotationAccessModifier;\", true);\n-                av0.visitEnd();\n-            }\n-            cw.visitEnd();\n-\n-            return cw.toByteArray();\n+    private static class HolderXDump {\n+        public static byte[] dump() {\n+            return Classfile.build(ClassDesc.of(\"HolderX\"), clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withFlags(PUBLIC, ABSTRACT, INTERFACE);\n+                clb.with(RuntimeVisibleAnnotationsAttribute.of(\n+                        Annotation.of(ClassDesc.of(\"GoodAnnotation\")),\n+                        Annotation.of(ClassDesc.of(\"ClassFileGenerator$AnnotationWithoutAnnotationAccessModifier\"))\n+                ));\n+            });\n","filename":"test\/jdk\/java\/lang\/annotation\/ClassFileGenerator.java","additions":136,"deletions":238,"binary":false,"changes":374,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-# Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,3 @@\n-    --add-exports java.base\/jdk.internal.org.objectweb.asm=ALL-UNNAMED ${AGENT}.java asmlib\/*.java\n+    --add-exports java.base\/jdk.internal.classfile=ALL-UNNAMED \\\n+    --add-exports java.base\/jdk.internal.classfile.constantpool=ALL-UNNAMED \\\n+    ${AGENT}.java asmlib\/*.java\n","filename":"test\/jdk\/java\/lang\/instrument\/MakeJAR2.sh","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.constantpool\n@@ -38,0 +39,4 @@\n+import asmlib.Instrumentor;\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -42,2 +47,0 @@\n-import asmlib.*;\n-\n@@ -79,5 +82,7 @@\n-                                        \"wrapped_\" + trname + \"_\",\n-                                        (h)->{\n-                                            h.push(h.getName());\n-                                            h.push(transformId);\n-                                            h.invokeStatic(\"bootreporter\/StringIdCallbackReporter\", \"tracker\", \"(Ljava\/lang\/String;I)V\", false);\n+                                        \"wrapped_\" + trname + \"_\", (name, h) -> {\n+                                            h.constantInstruction(name);\n+                                            h.constantInstruction(transformId);\n+                                            h.invokestatic(\n+                                                    ClassDesc.ofInternalName(\"bootreporter\/StringIdCallbackReporter\"),\n+                                                    \"tracker\",\n+                                                    MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/String;I)V\"));\n","filename":"test\/jdk\/java\/lang\/instrument\/NativeMethodPrefixAgent.java","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.constantpool\n@@ -36,0 +37,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -41,0 +43,3 @@\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+\n@@ -86,3 +91,5 @@\n-                                        (h)->{\n-                                           h.push(fixedIndex);\n-                                           h.invokeStatic(\"RetransformAgent\", \"callTracker\", \"(I)V\", false);\n+                                        cb -> {\n+                                           cb.constantInstruction(fixedIndex);\n+                                           cb.invokestatic(\n+                                                   RetransformAgent.class.describeConstable().orElseThrow(),\n+                                                   \"callTracker\", MethodTypeDesc.of(CD_void, CD_int));\n","filename":"test\/jdk\/java\/lang\/instrument\/RetransformAgent.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,19 @@\n-import java.io.PrintStream;\n+import jdk.internal.classfile.AccessFlags;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.ClassElement;\n+import jdk.internal.classfile.ClassModel;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.CodeBuilder;\n+import jdk.internal.classfile.CodeElement;\n+import jdk.internal.classfile.CodeModel;\n+import jdk.internal.classfile.CodeTransform;\n+import jdk.internal.classfile.MethodBuilder;\n+import jdk.internal.classfile.MethodElement;\n+import jdk.internal.classfile.MethodModel;\n+import jdk.internal.classfile.MethodTransform;\n+import jdk.internal.classfile.Opcode;\n+import jdk.internal.classfile.TypeKind;\n+\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -29,0 +47,1 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -30,6 +49,1 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-\n+import java.util.function.BiConsumer;\n@@ -37,39 +51,0 @@\n-import jdk.internal.org.objectweb.asm.Type;\n-\n-public class Instrumentor {\n-    public static class InstrHelper {\n-        private final MethodVisitor mv;\n-        private final String name;\n-\n-        InstrHelper(MethodVisitor mv, String name) {\n-            this.mv = mv;\n-            this.name = name;\n-        }\n-\n-        public String getName() {\n-            return this.name;\n-        }\n-\n-        public void invokeStatic(String owner, String name, String desc, boolean itf) {\n-            mv.visitMethodInsn(Opcodes.INVOKESTATIC, owner, name, desc, itf);\n-        }\n-\n-        public void invokeSpecial(String owner, String name, String desc) {\n-            mv.visitMethodInsn(Opcodes.INVOKESPECIAL, owner, name, desc, false);\n-        }\n-\n-        public void invokeVirtual(String owner, String name, String desc) {\n-            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, owner, name, desc, false);\n-        }\n-\n-        public void push(int val) {\n-            if (val >= -1 && val <= 5) {\n-                mv.visitInsn(Opcodes.ICONST_0 + val);\n-            } else if (val >= Byte.MIN_VALUE && val <= Byte.MAX_VALUE) {\n-                mv.visitIntInsn(Opcodes.BIPUSH, val);\n-            } else if (val >= Short.MIN_VALUE && val <= Short.MAX_VALUE) {\n-                mv.visitIntInsn(Opcodes.SIPUSH, val);\n-            } else {\n-                mv.visitLdcInsn(val);\n-            }\n-        }\n@@ -77,3 +52,1 @@\n-        public void push(Object val) {\n-            mv.visitLdcInsn(val);\n-        }\n+import static jdk.internal.classfile.Classfile.ACC_NATIVE;\n@@ -81,6 +54,1 @@\n-        public void println(String s) {\n-            mv.visitFieldInsn(Opcodes.GETSTATIC, Type.getInternalName(System.class), \"out\", Type.getDescriptor(PrintStream.class));\n-            mv.visitLdcInsn(s);\n-            mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(PrintStream.class), \"println\", Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(String.class)), false);\n-        }\n-    }\n+public class Instrumentor {\n@@ -92,4 +60,2 @@\n-\n-    private final ClassReader cr;\n-    private final ClassWriter output;\n-    private ClassVisitor instrumentingVisitor = null;\n+    private final ClassModel model;\n+    private ClassTransform transform = ClassTransform.ACCEPT_ALL;\n@@ -99,3 +65,1 @@\n-        cr = new ClassReader(classData);\n-        output = new ClassWriter(ClassWriter.COMPUTE_MAXS);\n-        instrumentingVisitor = output;\n+        model = Classfile.parse(classData);\n@@ -104,2 +68,8 @@\n-    public synchronized Instrumentor addMethodEntryInjection(String methodName, Consumer<InstrHelper> injector) {\n-        instrumentingVisitor = new ClassVisitor(Opcodes.ASM7, instrumentingVisitor) {\n+    public synchronized Instrumentor addMethodEntryInjection(String methodName, Consumer<CodeBuilder> injector) {\n+        transform = transform.andThen(ClassTransform.transformingMethodBodies(mm -> {\n+            if (mm.methodName().equalsString(methodName)) {\n+                matches.getAndIncrement();\n+                return true;\n+            }\n+            return false;\n+        }, new CodeTransform() {\n@@ -107,14 +77,2 @@\n-            public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-                MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-\n-                if (name.equals(methodName)) {\n-                    matches.getAndIncrement();\n-\n-                    mv = new MethodVisitor(Opcodes.ASM7, mv) {\n-                        @Override\n-                        public void visitCode() {\n-                            injector.accept(new InstrHelper(mv, name));\n-                        }\n-                    };\n-                }\n-                return mv;\n+            public void atStart(CodeBuilder builder) {\n+                injector.accept(builder);\n@@ -122,8 +80,0 @@\n-        };\n-        return this;\n-    }\n-\n-    public synchronized Instrumentor addNativeMethodTrackingInjection(String prefix, Consumer<InstrHelper> injector) {\n-        instrumentingVisitor = new ClassVisitor(Opcodes.ASM9, instrumentingVisitor) {\n-            private final Set<Consumer<ClassVisitor>> wmGenerators = new HashSet<>();\n-            private String className;\n@@ -132,3 +82,2 @@\n-            public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-                this.className = name;\n-                super.visit(version, access, name, signature, superName, interfaces);\n+            public void accept(CodeBuilder builder, CodeElement element) {\n+                builder.accept(element);\n@@ -136,0 +85,3 @@\n+        }));\n+        return this;\n+    }\n@@ -137,0 +89,3 @@\n+    public synchronized Instrumentor addNativeMethodTrackingInjection(String prefix, BiConsumer<String, CodeBuilder> injector) {\n+        transform = transform.andThen(new ClassTransform() {\n+            private final Set<Consumer<ClassBuilder>> wmGenerators = new HashSet<>();\n@@ -139,2 +94,2 @@\n-            public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-                if ((access & Opcodes.ACC_NATIVE) != 0) {\n+            public void accept(ClassBuilder builder, ClassElement element) {\n+                if (element instanceof MethodModel mm && mm.flags().has(AccessFlag.NATIVE)) {\n@@ -143,0 +98,1 @@\n+                    String name = mm.methodName().stringValue();\n@@ -144,18 +100,8 @@\n-                    wmGenerators.add((v)->{\n-                        MethodVisitor mv = v.visitMethod(access & ~Opcodes.ACC_NATIVE, name, desc, signature, exceptions);\n-                        mv.visitCode();\n-                        injector.accept(new InstrHelper(mv, name));\n-                        Type[] argTypes = Type.getArgumentTypes(desc);\n-                        Type retType = Type.getReturnType(desc);\n-\n-                        boolean isStatic = (access & Opcodes.ACC_STATIC) != 0;\n-                        if (!isStatic) {\n-                            mv.visitIntInsn(Opcodes.ALOAD, 0); \/\/ load \"this\"\n-                        }\n-\n-                        \/\/ load the method parameters\n-                        if (argTypes.length > 0) {\n-                            int ptr = isStatic ? 0 : 1;\n-                            for(Type argType : argTypes) {\n-                                mv.visitIntInsn(argType.getOpcode(Opcodes.ILOAD), ptr);\n-                                ptr += argType.getSize();\n+                    MethodTypeDesc mt = mm.methodTypeSymbol();\n+                    wmGenerators.add(clb -> clb.transformMethod(mm, new MethodTransform() {\n+                        @Override\n+                        public void accept(MethodBuilder mb, MethodElement me) {\n+                            if (me instanceof AccessFlags flags) {\n+                                mb.withFlags(flags.flagsMask() & ~ACC_NATIVE);\n+                            } else if (!(me instanceof CodeModel)) {\n+                                mb.with(me);\n@@ -165,2 +111,26 @@\n-                        mv.visitMethodInsn(isStatic ? Opcodes.INVOKESTATIC : Opcodes.INVOKESPECIAL, className, newName, desc, false);\n-                        mv.visitInsn(retType.getOpcode(Opcodes.IRETURN));\n+                        @Override\n+                        public void atEnd(MethodBuilder mb) {\n+                            Consumer<CodeBuilder> injection = cb -> injector.accept(name, cb);\n+                            mb.withCode(injection.andThen(cb -> {\n+                                int ptr;\n+                                boolean isStatic = mm.flags().has(AccessFlag.STATIC);\n+                                if (!isStatic) {\n+                                    cb.aload(0); \/\/ load \"this\"\n+                                    ptr = 1;\n+                                } else {\n+                                    ptr = 0;\n+                                }\n+\n+                                \/\/ load method parameters\n+                                for (int i = 0; i < mt.parameterCount(); i++) {\n+                                    TypeKind kind = TypeKind.from(mt.parameterType(i));\n+                                    cb.loadInstruction(kind, ptr);\n+                                    ptr += kind.slotSize();\n+                                }\n+\n+                                cb.invokeInstruction(isStatic ? Opcode.INVOKESTATIC : Opcode.INVOKESPECIAL,\n+                                        model.thisClass().asSymbol(), newName, mt, false);\n+                                cb.returnInstruction(TypeKind.from(mt.returnType()));\n+                            }));\n+                        }\n+                    }));\n@@ -168,4 +138,3 @@\n-                        mv.visitMaxs(1, 1); \/\/ dummy call; let ClassWriter to deal with this\n-                        mv.visitEnd();\n-                    });\n-                    return super.visitMethod(access, newName, desc, signature, exceptions);\n+                    builder.withMethod(newName, mt, mm.flags().flagsMask(), mm::forEachElement);\n+                } else {\n+                    builder.accept(element);\n@@ -173,1 +142,0 @@\n-                return super.visitMethod(access, name, desc, signature, exceptions);\n@@ -177,5 +145,2 @@\n-            public void visitEnd() {\n-                wmGenerators.stream().forEach((e) -> {\n-                    e.accept(cv);\n-                });\n-                super.visitEnd();\n+            public void atEnd(ClassBuilder builder) {\n+                wmGenerators.forEach(e -> e.accept(builder));\n@@ -183,2 +148,1 @@\n-        };\n-\n+        });\n@@ -189,1 +153,1 @@\n-        cr.accept(instrumentingVisitor, ClassReader.SKIP_DEBUG + ClassReader.EXPAND_FRAMES);\n+        var bytes = model.transform(transform);\n@@ -191,1 +155,1 @@\n-        return matches.get() == 0 ? null : output.toByteArray();\n+        return matches.get() == 0 ? null : bytes;\n","filename":"test\/jdk\/java\/lang\/instrument\/asmlib\/Instrumentor.java","additions":90,"deletions":126,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n-import jdk.internal.org.objectweb.asm.*;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n@@ -34,5 +35,0 @@\n-    static interface VisitorMaker {\n-    ClassVisitor make(ClassVisitor visitor);\n-    }\n-\n-\n@@ -58,1 +54,1 @@\n-    private Map<String, VisitorMaker> replaced;\n+    private Map<String, ClassTransform> replaced;\n@@ -70,1 +66,1 @@\n-    public BogoLoader(Set<String> non_system, Map<String, VisitorMaker> replaced) {\n+    public BogoLoader(Set<String> non_system, Map<String, ClassTransform> replaced) {\n@@ -129,5 +125,1 @@\n-                    ClassReader cr = new ClassReader(classData);\n-                    ClassWriter cw = new ClassWriter(0);\n-                    VisitorMaker vm = replaced.get(name);\n-                    cr.accept(vm.make(cw), 0);\n-                    classData = cw.toByteArray();\n+                    classData = Classfile.parse(classData).transform(replaced.get(name));\n","filename":"test\/jdk\/java\/lang\/invoke\/8022701\/BogoLoader.java","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n+ *          java.base\/jdk.internal.classfile.constantpool\n@@ -33,0 +34,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -34,0 +36,1 @@\n+import java.util.EnumSet;\n@@ -36,4 +39,4 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n+import java.util.Set;\n+import jdk.internal.classfile.AccessFlags;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.MethodModel;\n@@ -41,1 +44,3 @@\n-public class MHIllegalAccess implements Opcodes {\n+import static jdk.internal.classfile.Classfile.ACC_PRIVATE;\n+import static jdk.internal.classfile.Classfile.ACC_PROTECTED;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n@@ -43,1 +48,3 @@\n-   public static void main(String args[]) throws Throwable  {\n+public class MHIllegalAccess {\n+\n+   public static void main(String[] args) throws Throwable  {\n@@ -50,12 +57,7 @@\n-      BogoLoader.VisitorMaker privatize = new BogoLoader.VisitorMaker() {\n-           public ClassVisitor make(ClassVisitor cv) {\n-               return new ClassVisitor(Opcodes.ASM5, cv) {\n-                   public MethodVisitor visitMethod(int access, String name, String desc,\n-                           String signature, String[] exceptions) {\n-                       if (name.equals(\"m\"))\n-                           access = (access | ACC_PRIVATE) & ~ (ACC_PUBLIC | ACC_PROTECTED);\n-                           return super.visitMethod(access, name, desc, signature, exceptions);\n-                   }\n-               };\n-           }\n-       };\n+      var privatize = ClassTransform.transformingMethods(m -> m.methodName().equalsString(\"m\"), (mb, me) -> {\n+          if (me instanceof AccessFlags af) {\n+              mb.withFlags((af.flagsMask() | ACC_PRIVATE) & ~ (ACC_PUBLIC | ACC_PROTECTED));\n+          } else {\n+              mb.accept(me);\n+          }\n+      });\n@@ -66,12 +68,7 @@\n-     BogoLoader.VisitorMaker changeName = new BogoLoader.VisitorMaker() {\n-           public ClassVisitor make(ClassVisitor cv) {\n-               return new ClassVisitor(Opcodes.ASM5, cv) {\n-                   public MethodVisitor visitMethod(int access, String name, String desc,\n-                           String signature, String[] exceptions) {\n-                       if (name.equals(\"m\"))\n-                           name = \"nemo\";\n-                           return super.visitMethod(access, name, desc, signature, exceptions);\n-                   }\n-               };\n-           }\n-       };\n+     ClassTransform changeName = (cb, ce) -> {\n+         if (ce instanceof MethodModel mm && mm.methodName().equalsString(\"m\")) {\n+             cb.withMethod(\"nemo\", mm.methodTypeSymbol(), mm.flags().flagsMask(), mm::forEachElement);\n+         } else {\n+             cb.accept(ce);\n+         }\n+     };\n@@ -97,2 +94,2 @@\n-    private static int testOneError(BogoLoader.VisitorMaker vm, String[] args, Class expected) throws ClassNotFoundException, Throwable {\n-      HashMap<String, BogoLoader.VisitorMaker> replace = new HashMap<String, BogoLoader.VisitorMaker>();\n+    private static int testOneError(ClassTransform vm, String[] args, Class<?> expected) throws ClassNotFoundException, Throwable {\n+      var replace = new HashMap<String, ClassTransform>();\n","filename":"test\/jdk\/java\/lang\/invoke\/8022701\/MHIllegalAccess.java","additions":31,"deletions":34,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- *          java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.classfile\n@@ -33,0 +33,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +36,3 @@\n+\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_void;\n@@ -36,0 +41,2 @@\n+\n+import java.lang.reflect.AccessFlag;\n@@ -42,4 +49,1 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-\n+import jdk.internal.classfile.Classfile;\n@@ -47,0 +51,3 @@\n+\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n@@ -51,0 +58,4 @@\n+    private static final String CTOR_NAME = \"<init>\";\n+    private static final MethodTypeDesc MD_void = MethodTypeDesc.of(CD_void);\n+    private static final ClassDesc CD_Runnable = Runnable.class.describeConstable().orElseThrow();\n+    private static final ClassDesc CD_MissingSuperClass = ClassDesc.of(\"MissingSuperClass\");\n@@ -254,19 +265,9 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V9,\n-                ACC_PUBLIC + ACC_SUPER,\n-                className.replace(\".\", \"\/\"),\n-                null,\n-                \"java\/lang\/Object\",\n-                null);\n-\n-        \/\/ <init>\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return Classfile.build(ClassDesc.of(className), clb -> {\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.SUPER);\n+            clb.withSuperclass(CD_Object);\n+            clb.withMethodBody(CTOR_NAME, MD_void, PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, CTOR_NAME, MD_void);\n+                cob.return_();\n+            });\n+        });\n@@ -283,27 +284,13 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V9,\n-                ACC_PUBLIC + ACC_SUPER,\n-                className.replace(\".\", \"\/\"),\n-                null,\n-                \"java\/lang\/Object\",\n-                new String[] { \"java\/lang\/Runnable\" });\n-\n-        \/\/ <init>\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ run()\n-        String tc = targetClass.replace(\".\", \"\/\");\n-        mv = cw.visitMethod(ACC_PUBLIC, \"run\", \"()V\", null, null);\n-        mv.visitMethodInsn(INVOKESTATIC, tc, targetMethod, \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return Classfile.build(ClassDesc.of(className), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(CD_Runnable);\n+            clb.withMethodBody(CTOR_NAME, MD_void, PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, CTOR_NAME, MD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(\"run\", MD_void, PUBLIC, cob -> {\n+                cob.invokestatic(ClassDesc.of(targetClass), targetMethod, MD_void);\n+                cob.return_();\n+            });\n+        });\n@@ -320,27 +307,13 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V9,\n-                ACC_PUBLIC + ACC_SUPER,\n-                className.replace(\".\", \"\/\"),\n-                null,\n-                \"java\/lang\/Object\",\n-                null);\n-\n-        \/\/ <init>\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ <clinit>\n-        String tc = targetClass.replace(\".\", \"\/\");\n-        mv = cw.visitMethod(ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n-        mv.visitMethodInsn(INVOKESTATIC, tc, targetMethod, \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return Classfile.build(ClassDesc.of(className), clb -> {\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.SUPER);\n+            clb.withSuperclass(CD_Object);\n+            clb.withMethodBody(CTOR_NAME, MD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, CTOR_NAME, MD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(\"<clinit>\", MD_void, ACC_STATIC, cob -> {\n+                cob.invokestatic(ClassDesc.of(targetClass), targetMethod, MD_void);\n+                cob.return_();\n+            });\n+        });\n@@ -353,19 +326,9 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V14,\n-                ACC_PUBLIC + ACC_SUPER,\n-                className.replace(\".\", \"\/\"),\n-                null,\n-                \"MissingSuperClass\",\n-                null);\n-\n-        \/\/ <init>\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"MissingSuperClass\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return Classfile.build(ClassDesc.of(className), clb -> {\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.SUPER);\n+            clb.withSuperclass(CD_MissingSuperClass);\n+            clb.withMethodBody(CTOR_NAME, MD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_MissingSuperClass, CTOR_NAME, MD_void);\n+                cob.return_();\n+            });\n+        });\n@@ -378,11 +341,1 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V14,\n-                ACC_MODULE,\n-                \"module-info\",\n-                null,\n-                null,\n-                null);\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return Classfile.build(ClassDesc.of(\"module-info\"), cb -> cb.withFlags(AccessFlag.MODULE));\n","filename":"test\/jdk\/java\/lang\/invoke\/DefineClassTest.java","additions":62,"deletions":109,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n@@ -35,0 +35,5 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DirectMethodHandleDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -39,0 +44,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -46,0 +52,1 @@\n+import java.util.function.Consumer;\n@@ -48,1 +55,3 @@\n-import jdk.internal.org.objectweb.asm.*;\n+import jdk.internal.classfile.ClassBuilder;\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.TypeKind;\n@@ -52,0 +61,7 @@\n+import static java.lang.constant.ConstantDescs.CD_Class;\n+import static java.lang.constant.ConstantDescs.CD_MethodHandle;\n+import static java.lang.constant.ConstantDescs.CD_MethodHandles;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static java.lang.constant.ConstantDescs.DEFAULT_NAME;\n@@ -53,1 +69,1 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static jdk.internal.classfile.Classfile.*;\n@@ -58,0 +74,3 @@\n+    private static final ClassDesc CD_ClassDataTest = ClassDataTest.class.describeConstable().orElseThrow();\n+    private static final DirectMethodHandleDesc BSM_CLASS_DATA = ConstantDescs.ofConstantBootstrap(CD_MethodHandles, \"classData\", CD_Object);\n+    private static final DirectMethodHandleDesc BSM_CLASS_DATA_AT = ConstantDescs.ofConstantBootstrap(CD_MethodHandles, \"classDataAt\", CD_Object, CD_int);\n@@ -297,3 +316,1 @@\n-        Handle bsm = new Handle(H_INVOKESTATIC, \"ClassDataTest\", \"getClassDataEntry\",\n-                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)Ljava\/lang\/Object;\",\n-                false);\n+        DirectMethodHandleDesc bsm = ConstantDescs.ofConstantBootstrap(CD_ClassDataTest, \"getClassDataEntry\", CD_Object);\n@@ -303,1 +320,1 @@\n-                                         Class.class, new ConstantDynamic(\"class\", Type.getDescriptor(Class.class), bsm))\n+                                         Class.class, DynamicConstantDesc.ofNamed(bsm, \"class\", CD_Class))\n@@ -305,1 +322,1 @@\n-                                         MethodHandle.class, new ConstantDynamic(\"method\", Type.getDescriptor(MethodHandle.class), bsm))\n+                                         MethodHandle.class, DynamicConstantDesc.ofNamed(bsm, \"method\", CD_MethodHandle))\n@@ -345,2 +362,2 @@\n-        private final ClassWriter cw;\n-        private final String classname;\n+        private Consumer<ClassBuilder> cw;\n+        private final ClassDesc classname;\n@@ -353,10 +370,10 @@\n-            this.classname = classname;\n-            this.cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-            cw.visit(V14, ACC_FINAL, classname, null, OBJECT_CLS, null);\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, OBJECT_CLS, \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+            this.classname = ClassDesc.ofInternalName(classname);\n+            this.cw = clb -> {\n+                clb.withSuperclass(CD_Object);\n+                clb.withFlags(AccessFlag.FINAL);\n+                clb.withMethodBody(\"<init>\", MethodTypeDesc.of(CD_void), ACC_PUBLIC, cob -> {\n+                    cob.aload(0);\n+                    cob.invokespecial(CD_Object, \"<init>\", MethodTypeDesc.of(CD_void));\n+                    cob.return_();\n+                });\n+            };\n@@ -366,2 +383,1 @@\n-            cw.visitEnd();\n-            byte[] bytes = cw.toByteArray();\n+            byte[] bytes = Classfile.build(classname, cw);\n@@ -381,14 +397,8 @@\n-            MethodType mtype = MethodType.methodType(returnType);\n-            MethodVisitor mv = cw.visitMethod(accessFlags,\n-                                             \"classData\",\n-                                              mtype.descriptorString(), null, null);\n-            mv.visitCode();\n-            Handle bsm = new Handle(H_INVOKESTATIC, MHS_CLS, \"classData\",\n-                                    CLASS_DATA_BSM_DESCR,\n-                                    false);\n-            ConstantDynamic dynamic = new ConstantDynamic(\"_\", Type.getDescriptor(returnType), bsm);\n-            mv.visitLdcInsn(dynamic);\n-            mv.visitInsn(returnType == int.class ? IRETURN :\n-                            (returnType == float.class ? FRETURN : ARETURN));\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+            ClassDesc returnDesc = returnType.describeConstable().orElseThrow();\n+            MethodTypeDesc mt = MethodTypeDesc.of(returnDesc);\n+            cw = cw.andThen(clb -> {\n+                clb.withMethodBody(\"classData\", mt, accessFlags, cob -> {\n+                    cob.constantInstruction(DynamicConstantDesc.ofNamed(BSM_CLASS_DATA, DEFAULT_NAME, returnDesc));\n+                    cob.returnInstruction(TypeKind.fromDescriptor(returnType.descriptorString()));\n+                });\n+            });\n@@ -402,13 +412,8 @@\n-            MethodType mtype = MethodType.methodType(returnType);\n-            MethodVisitor mv = cw.visitMethod(accessFlags,\n-                                              \"classData\",\n-                                               mtype.descriptorString(), null, null);\n-            mv.visitCode();\n-            Handle bsm = new Handle(H_INVOKESTATIC, \"java\/lang\/invoke\/MethodHandles\", \"classDataAt\",\n-                        \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;I)Ljava\/lang\/Object;\",\n-                        false);\n-            ConstantDynamic dynamic = new ConstantDynamic(\"_\", Type.getDescriptor(returnType), bsm, index);\n-            mv.visitLdcInsn(dynamic);\n-            mv.visitInsn(returnType == int.class? IRETURN : ARETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+            ClassDesc returnDesc = returnType.describeConstable().orElseThrow();\n+            MethodTypeDesc mt = MethodTypeDesc.of(returnDesc);\n+            cw = cw.andThen(clb -> {\n+                clb.withMethodBody(\"classData\", mt, accessFlags, cob -> {\n+                    cob.constantInstruction(DynamicConstantDesc.ofNamed(BSM_CLASS_DATA_AT, DEFAULT_NAME, returnDesc, index));\n+                    cob.returnInstruction(TypeKind.fromDescriptor(returnType.descriptorString()));\n+                });\n+            });\n@@ -418,10 +423,9 @@\n-        ClassByteBuilder classData(int accessFlags, String name, Class<?> returnType, ConstantDynamic dynamic) {\n-            MethodType mtype = MethodType.methodType(returnType);\n-            MethodVisitor mv = cw.visitMethod(accessFlags,\n-                                              name,\n-                                              mtype.descriptorString(), null, null);\n-            mv.visitCode();\n-            mv.visitLdcInsn(dynamic);\n-            mv.visitInsn(returnType == int.class? IRETURN : ARETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n+        ClassByteBuilder classData(int accessFlags, String name, Class<?> returnType, DynamicConstantDesc<?> dynamic) {\n+            ClassDesc returnDesc = returnType.describeConstable().orElseThrow();\n+            MethodTypeDesc mt = MethodTypeDesc.of(returnDesc);\n+            cw = cw.andThen(clb -> {\n+                clb.withMethodBody(name, mt, accessFlags, cob -> {\n+                    cob.constantInstruction(dynamic);\n+                    cob.returnInstruction(TypeKind.fromDescriptor(returnType.descriptorString()));\n+                });\n+            });\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/classData\/ClassDataTest.java","additions":64,"deletions":60,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n-import jdk.internal.org.objectweb.asm.*;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.Classfile;\n@@ -35,5 +36,0 @@\n-    static interface VisitorMaker {\n-    ClassVisitor make(ClassVisitor visitor);\n-    }\n-\n-\n@@ -59,1 +55,1 @@\n-    private Map<String, VisitorMaker> replaced;\n+    private Map<String, ClassTransform> replaced;\n@@ -71,1 +67,1 @@\n-    public BogoLoader(Set<String> non_system, Map<String, VisitorMaker> replaced) {\n+    public BogoLoader(Set<String> non_system, Map<String, ClassTransform> replaced) {\n@@ -130,5 +126,1 @@\n-                    ClassReader cr = new ClassReader(classData);\n-                    ClassWriter cw = new ClassWriter(0);\n-                    VisitorMaker vm = replaced.get(name);\n-                    cr.accept(vm.make(cw), 0);\n-                    classData = cw.toByteArray();\n+                    classData = Classfile.parse(classData).transform(replaced.get(name));\n","filename":"test\/jdk\/java\/lang\/invoke\/accessProtectedSuper\/BogoLoader.java","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n+ * @modules java.base\/jdk.internal.classfile.attribute\n+ * @modules java.base\/jdk.internal.classfile.constantpool\n@@ -33,1 +35,1 @@\n-import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.AccessFlag;\n@@ -35,0 +37,1 @@\n+import java.util.EnumSet;\n@@ -37,4 +40,9 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.classfile.ClassTransform;\n+import jdk.internal.classfile.attribute.InnerClassInfo;\n+import jdk.internal.classfile.attribute.InnerClassesAttribute;\n+import jdk.internal.classfile.constantpool.ClassEntry;\n+import jdk.internal.classfile.constantpool.Utf8Entry;\n+\n+import static jdk.internal.classfile.Classfile.ACC_PRIVATE;\n+import static jdk.internal.classfile.Classfile.ACC_PROTECTED;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n@@ -47,11 +55,1 @@\n-class MakeProtected implements BogoLoader.VisitorMaker, Opcodes {\n-\n-    final boolean whenVisitInner;\n-\n-    MakeProtected(boolean when_visit_inner) {\n-        super();\n-        whenVisitInner = when_visit_inner;\n-    }\n-\n-    public ClassVisitor make(ClassVisitor cv) {\n-        return new ClassVisitor(Opcodes.ASM7, cv) {\n+public class Test {\n@@ -59,13 +57,16 @@\n-            @Override\n-            public void visitInnerClass(String name, String outerName,\n-                    String innerName, int access) {\n-                if (whenVisitInner) {\n-                    int access_ = (ACC_PROTECTED | access) & ~(ACC_PRIVATE | ACC_PUBLIC);\n-                    System.out.println(\"visitInnerClass: name = \" + name\n-                            + \", outerName = \" + outerName\n-                            + \", innerName = \" + innerName\n-                            + \", access original = 0x\" + Integer.toHexString(access)\n-                            + \", access modified to 0x\" + Integer.toHexString(access_));\n-                    access = access_;\n-                }\n-                super.visitInnerClass(name, outerName, innerName, access);\n+    public static void main(String[] argv) throws Throwable {\n+        ClassTransform makeProtectedNop = ClassTransform.ACCEPT_ALL;\n+        ClassTransform makeProtectedMod = (cb, ce) -> {\n+            if (ce instanceof InnerClassesAttribute ica) {\n+                cb.accept(InnerClassesAttribute.of(ica.classes().stream().map(ici -> {\n+                    \/\/ AccessFlags doesn't support inner class flags yet\n+                    var flags = (ACC_PROTECTED | ici.flagsMask()) & ~(ACC_PRIVATE | ACC_PUBLIC);\n+                    System.out.println(\"visitInnerClass: name = \" + ici.innerClass().asInternalName()\n+                            + \", outerName = \" + ici.outerClass().map(ClassEntry::asInternalName).orElse(\"null\")\n+                            + \", innerName = \" + ici.innerName().map(Utf8Entry::stringValue).orElse(\"null\")\n+                            + \", access original = 0x\" + Integer.toHexString(ici.flagsMask())\n+                            + \", access modified to 0x\" + Integer.toHexString(flags));\n+                    return InnerClassInfo.of(ici.innerClass(), ici.outerClass(), ici.innerName(), flags);\n+                }).toList()));\n+            } else {\n+                cb.accept(ce);\n@@ -74,8 +75,0 @@\n-    }\n-};\n-\n-public class Test {\n-\n-    public static void main(String argv[]) throws Exception, Throwable {\n-        BogoLoader.VisitorMaker makeProtectedNop = new MakeProtected(false);\n-        BogoLoader.VisitorMaker makeProtectedMod = new MakeProtected(true);\n@@ -92,4 +85,3 @@\n-    private static int tryModifiedInvocation(BogoLoader.VisitorMaker makeProtected)\n-            throws Throwable, ClassNotFoundException {\n-        HashMap<String, BogoLoader.VisitorMaker> replace\n-                = new HashMap<String, BogoLoader.VisitorMaker>();\n+    private static int tryModifiedInvocation(ClassTransform makeProtected)\n+            throws Throwable {\n+        var replace = new HashMap<String, ClassTransform>();\n@@ -97,1 +89,1 @@\n-        HashSet<String> in_bogus = new HashSet<String>();\n+        var in_bogus = new HashSet<String>();\n","filename":"test\/jdk\/java\/lang\/invoke\/accessProtectedSuper\/Test.java","additions":36,"deletions":44,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n@@ -39,0 +39,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -40,4 +41,1 @@\n-\n-import static java.lang.invoke.MethodHandles.lookup;\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;\n-\n+import java.lang.reflect.AccessFlag;\n@@ -51,0 +49,1 @@\n+import java.util.EnumSet;\n@@ -52,0 +51,1 @@\n+import java.util.Set;\n@@ -53,3 +53,1 @@\n-\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Type;\n+import jdk.internal.classfile.Classfile;\n@@ -63,1 +61,10 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static java.lang.constant.ConstantDescs.CD_Enum;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.*;\n+import static java.lang.reflect.AccessFlag.ABSTRACT;\n+import static java.lang.reflect.AccessFlag.ANNOTATION;\n+import static java.lang.reflect.AccessFlag.ENUM;\n+import static java.lang.reflect.AccessFlag.INTERFACE;\n+import static java.lang.reflect.AccessFlag.SYNTHETIC;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n@@ -249,5 +256,5 @@\n-                new Object[] { \"EmptyHiddenSynthetic\", ACC_SYNTHETIC },\n-                new Object[] { \"EmptyHiddenEnum\", ACC_ENUM },\n-                new Object[] { \"EmptyHiddenAbstractClass\", ACC_ABSTRACT },\n-                new Object[] { \"EmptyHiddenInterface\", ACC_ABSTRACT|ACC_INTERFACE },\n-                new Object[] { \"EmptyHiddenAnnotation\", ACC_ANNOTATION|ACC_ABSTRACT|ACC_INTERFACE },\n+                new Object[] { \"EmptyHiddenSynthetic\", Set.of(SYNTHETIC) },\n+                new Object[] { \"EmptyHiddenEnum\", Set.of(ENUM) },\n+                new Object[] { \"EmptyHiddenAbstractClass\", Set.of(ABSTRACT) },\n+                new Object[] { \"EmptyHiddenInterface\", Set.of(ABSTRACT, INTERFACE) },\n+                new Object[] { \"EmptyHiddenAnnotation\", Set.of(ANNOTATION, ABSTRACT, INTERFACE) },\n@@ -266,2 +273,2 @@\n-    public void emptyHiddenClass(String name, int accessFlags) throws Exception {\n-        byte[] bytes = (accessFlags == ACC_ENUM) ? classBytes(name, Enum.class, accessFlags)\n+    public void emptyHiddenClass(String name, Set<AccessFlag> accessFlags) throws Exception {\n+        byte[] bytes = (accessFlags.equals(Set.of(ENUM))) ? classBytes(name, CD_Enum, accessFlags)\n@@ -270,34 +277,5 @@\n-        switch (accessFlags) {\n-            case ACC_SYNTHETIC:\n-                assertTrue(hc.isSynthetic());\n-                assertFalse(hc.isEnum());\n-                assertFalse(hc.isAnnotation());\n-                assertFalse(hc.isInterface());\n-                break;\n-            case ACC_ENUM:\n-                assertFalse(hc.isSynthetic());\n-                assertTrue(hc.isEnum());\n-                assertFalse(hc.isAnnotation());\n-                assertFalse(hc.isInterface());\n-                break;\n-            case ACC_ABSTRACT:\n-                assertFalse(hc.isSynthetic());\n-                assertFalse(hc.isEnum());\n-                assertFalse(hc.isAnnotation());\n-                assertFalse(hc.isInterface());\n-                break;\n-            case ACC_ABSTRACT|ACC_INTERFACE:\n-                assertFalse(hc.isSynthetic());\n-                assertFalse(hc.isEnum());\n-                assertFalse(hc.isAnnotation());\n-                assertTrue(hc.isInterface());\n-                break;\n-            case ACC_ANNOTATION|ACC_ABSTRACT|ACC_INTERFACE:\n-                assertFalse(hc.isSynthetic());\n-                assertFalse(hc.isEnum());\n-                assertTrue(hc.isAnnotation());\n-                assertTrue(hc.isInterface());\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"unexpected access flag: \" + accessFlags);\n-        }\n+        assertEquals(hc.isSynthetic(), accessFlags.contains(SYNTHETIC));\n+        assertEquals(hc.isEnum(), accessFlags.contains(ENUM));\n+        assertEquals(hc.isAnnotation(), accessFlags.contains(ANNOTATION));\n+        assertEquals(hc.isInterface(), accessFlags.contains(INTERFACE));\n+\n@@ -305,1 +283,3 @@\n-        assertTrue(hc.getModifiers() == (ACC_PUBLIC|accessFlags));\n+        assertEquals(hc.getModifiers(), accessFlags.stream()\n+                .mapToInt(AccessFlag::mask)\n+                .reduce(ACC_PUBLIC, (a, b) -> a | b));\n@@ -516,2 +496,2 @@\n-    private static byte[] classBytes(String classname, int accessFlags) {\n-        return classBytes(classname, Object.class, accessFlags);\n+    private static byte[] classBytes(String classname, Set<AccessFlag> accessFlags) {\n+        return classBytes(classname, CD_Object, accessFlags);\n@@ -520,6 +500,7 @@\n-    private static byte[] classBytes(String classname, Class<?> supertType, int accessFlags) {\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V14, ACC_PUBLIC|accessFlags, classname, null, Type.getInternalName(supertType), null);\n-        cw.visitEnd();\n-\n-        return cw.toByteArray();\n+    private static byte[] classBytes(String classname, ClassDesc supertType, Set<AccessFlag> accessFlags) {\n+        return Classfile.build(ClassDesc.ofInternalName(classname), cb -> {\n+            cb.withSuperclass(supertType);\n+            var allFlags = EnumSet.copyOf(accessFlags);\n+            allFlags.add(AccessFlag.PUBLIC);\n+            cb.withFlags(allFlags.toArray(AccessFlag[]::new));\n+        });\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/BasicTest.java","additions":41,"deletions":60,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n@@ -32,0 +32,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -34,0 +36,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -38,0 +41,1 @@\n+import jdk.internal.classfile.Classfile;\n@@ -39,1 +43,0 @@\n-import jdk.internal.org.objectweb.asm.*;\n@@ -42,0 +45,3 @@\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.CD_void;\n@@ -45,1 +51,0 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n@@ -49,0 +54,3 @@\n+    private static final String CTOR_NAME = \"<init>\";\n+    private static final MethodTypeDesc CTOR_DESC = MethodTypeDesc.of(CD_void);\n+    private static final ClassDesc CD_HiddenNestmateTest = HiddenNestmateTest.class.describeConstable().orElseThrow();\n@@ -168,28 +176,14 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS + ClassWriter.COMPUTE_FRAMES);\n-        MethodVisitor mv;\n-\n-        cw.visit(V12, ACC_FINAL, classname, null, \"java\/lang\/Object\", null);\n-\n-        {\n-            mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\");\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-        }\n-        {\n-            \/\/ access a private member of the nest host class\n-            mv = cw.visitMethod(ACC_PUBLIC, \"test\", \"(LHiddenNestmateTest;)I\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitVarInsn(ALOAD, 1);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"HiddenNestmateTest\", \"privMethod\", \"()I\");\n-            mv.visitInsn(IRETURN);\n-            mv.visitMaxs(0, 0);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n-\n-        return cw.toByteArray();\n+        return Classfile.build(ClassDesc.ofInternalName(classname), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(AccessFlag.FINAL);\n+            clb.withMethodBody(CTOR_NAME, CTOR_DESC, PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, CTOR_NAME, CTOR_DESC);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(\"test\", MethodTypeDesc.of(CD_int, CD_HiddenNestmateTest), PUBLIC, cob -> {\n+                cob.aload(1);\n+                cob.invokevirtual(CD_HiddenNestmateTest, \"privMethod\", MethodTypeDesc.of(CD_int));\n+                cob.ireturn();\n+            });\n+        });\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/HiddenNestmateTest.java","additions":26,"deletions":32,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n@@ -42,1 +42,1 @@\n-import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.classfile.Classfile;\n@@ -65,3 +65,1 @@\n-        ClassReader reader = new ClassReader(bytes);\n-        int minor = reader.readUnsignedShort(4);\n-        assertTrue(minor == 65535);\n+        assertEquals(Classfile.parse(bytes).minorVersion(), 65535);\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/PreviewHiddenClass.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @modules java.base\/jdk.internal.misc java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.misc java.base\/jdk.internal.classfile\n@@ -33,0 +33,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -37,1 +39,2 @@\n-import jdk.internal.org.objectweb.asm.*;\n+import java.lang.reflect.AccessFlag;\n+import jdk.internal.classfile.Classfile;\n@@ -40,1 +43,5 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n@@ -101,0 +108,3 @@\n+    private static final String CTOR_NAME = \"<init>\";\n+    private static final MethodTypeDesc CTOR_DESC = MethodTypeDesc.of(CD_void);\n+\n@@ -109,23 +119,14 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        MethodVisitor mv;\n-\n-        cw.visit(52, ACC_SUPER | ACC_PUBLIC, pkg+\"\/MyClass\", null, \"java\/lang\/Object\", null);\n-        {\n-            mv = cw.visitMethod(0, \"<init>\", \"()V\", null, null);\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, \"get\", \"(I)Ljava\/lang\/Object;\", null, null);\n-            mv.visitCode();\n-            mv.visitInsn(ACONST_NULL);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return Classfile.build(ClassDesc.of(pkg.replace('\/', '.'), \"MyClass\"), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.SUPER);\n+            clb.withMethodBody(CTOR_NAME, CTOR_DESC, 0, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, CTOR_NAME, CTOR_DESC);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object, CD_int),\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n+                cob.aconst_null();\n+                cob.areturn();\n+            });\n+        });\n","filename":"test\/jdk\/java\/lang\/invoke\/defineHiddenClass\/StaticInvocableTest.java","additions":28,"deletions":27,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8027232\n- * @summary ensures that j.l.i.InvokerByteCodeGenerator and ASM visitMethodInsn\n- * generate  bytecodes with correct constant pool references\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- *          jdk.jdeps\/com.sun.tools.classfile\n- *          jdk.zipfs\n- * @compile -XDignore.symbol.file LambdaAsm.java LUtils.java\n- * @run main\/othervm LambdaAsm\n- *\/\n-import com.sun.tools.classfile.Attribute;\n-import com.sun.tools.classfile.ClassFile;\n-import com.sun.tools.classfile.Code_attribute;\n-import com.sun.tools.classfile.ConstantPool;\n-import com.sun.tools.classfile.ConstantPool.CPInfo;\n-import com.sun.tools.classfile.Instruction;\n-import com.sun.tools.classfile.Method;\n-import java.io.ByteArrayInputStream;\n-import java.io.File;\n-import java.util.ArrayList;\n-import java.nio.file.DirectoryStream;\n-import java.nio.file.Path;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-\n-import static java.nio.file.Files.*;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-\n-public class LambdaAsm {\n-\n-    static final File TestFile = new File(\"A.java\");\n-\n-    static void init() {\n-        emitCode();\n-        LUtils.compile(TestFile.getName());\n-        LUtils.TestResult tr = LUtils.doExec(LUtils.JAVA_CMD.getAbsolutePath(),\n-                \"-Djdk.internal.lambda.dumpProxyClasses=.\",\n-                \"-cp\", \".\", \"A\");\n-        if (tr.exitValue != 0) {\n-            System.out.println(\"Error: \" + tr.toString());\n-            throw new RuntimeException(\"could not create proxy classes\");\n-        }\n-    }\n-\n-    static void emitCode() {\n-        ArrayList<String> scratch = new ArrayList<>();\n-        scratch.add(\"import java.util.function.*;\");\n-        scratch.add(\"class A {\");\n-        scratch.add(\"   interface I {\");\n-        scratch.add(\"       default Supplier<Integer> a() { return () -> 1; }\");\n-        scratch.add(\"       default Supplier<Integer> b(int i) { return () -> i; }\");\n-        scratch.add(\"       default Supplier<Integer> c(int i) { return () -> m(i); }\");\n-        scratch.add(\"       int m(int i);\");\n-        scratch.add(\"       static Integer d() { return 0; }\");\n-        scratch.add(\"   }\");\n-        scratch.add(\"   static class C implements I {\");\n-        scratch.add(\"       public int m(int i) { return i;}\");\n-        scratch.add(\"   }\");\n-        scratch.add(\"   public static void main(String[] args) {\");\n-        scratch.add(\"       I i = new C();\");\n-        scratch.add(\"       i.a();\");\n-        scratch.add(\"       i.b(1);\");\n-        scratch.add(\"       i.c(1);\");\n-        scratch.add(\"       I.d();\");\n-        scratch.add(\"   }\");\n-        scratch.add(\"}\");\n-        LUtils.createFile(TestFile, scratch);\n-    }\n-\n-    static void checkMethod(String cname, String mname, ConstantPool cp,\n-            Code_attribute code) throws ConstantPool.InvalidIndex {\n-        for (Instruction i : code.getInstructions()) {\n-            String iname = i.getMnemonic();\n-            if (\"invokespecial\".equals(iname)\n-                    || \"invokestatic\".equals(iname)) {\n-                int idx = i.getByte(2);\n-                System.out.println(\"Verifying \" + cname + \":\" + mname +\n-                        \" instruction:\" + iname + \" index @\" + idx);\n-                CPInfo cpinfo = cp.get(idx);\n-                if (cpinfo instanceof ConstantPool.CONSTANT_Methodref_info) {\n-                    throw new RuntimeException(\"unexpected CP type expected \"\n-                            + \"InterfaceMethodRef, got MethodRef, \" + cname\n-                            + \", \" + mname);\n-                }\n-            }\n-        }\n-    }\n-\n-    static int checkMethod(ClassFile cf, String mthd) throws Exception {\n-        if (cf.major_version < 52) {\n-            throw new RuntimeException(\"unexpected class file version, in \"\n-                    + cf.getName() + \"expected 52, got \" + cf.major_version);\n-        }\n-        int count = 0;\n-        for (Method m : cf.methods) {\n-            String mname = m.getName(cf.constant_pool);\n-            if (mname.equals(mthd)) {\n-                for (Attribute a : m.attributes) {\n-                    if (\"Code\".equals(a.getName(cf.constant_pool))) {\n-                        count++;\n-                        checkMethod(cf.getName(), mname, cf.constant_pool,\n-                                (Code_attribute) a);\n-                    }\n-                }\n-            }\n-        }\n-        return count;\n-    }\n-\n-    static void verifyInvokerBytecodeGenerator() throws Exception {\n-        int count = 0;\n-        int mcount = 0;\n-        try (DirectoryStream<Path> ds = newDirectoryStream(new File(\".\").toPath(),\n-                \/\/ filter in lambda proxy classes\n-                \"A$I$$Lambda.*.class\")) {\n-            for (Path p : ds) {\n-                System.out.println(p.toFile());\n-                ClassFile cf = ClassFile.read(p.toFile());\n-                \/\/ Check those methods implementing Supplier.get\n-                mcount += checkMethod(cf, \"get\");\n-                count++;\n-            }\n-        }\n-        if (count < 3) {\n-            throw new RuntimeException(\"unexpected number of files, \"\n-                    + \"expected atleast 3 files, but got only \" + count);\n-        }\n-        if (mcount < 3) {\n-            throw new RuntimeException(\"unexpected number of methods, \"\n-                    + \"expected atleast 3 methods, but got only \" + mcount);\n-        }\n-    }\n-\n-    static void verifyASM() throws Exception {\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(V1_8, ACC_PUBLIC, \"X\", null, \"java\/lang\/Object\", null);\n-        MethodVisitor mv = cw.visitMethod(ACC_STATIC, \"foo\",\n-                \"()V\", null, null);\n-        mv.visitMaxs(2, 1);\n-        mv.visitMethodInsn(INVOKESTATIC,\n-                \"java\/util\/function\/Function.class\",\n-                \"identity\", \"()Ljava\/util\/function\/Function;\", true);\n-        mv.visitInsn(RETURN);\n-        cw.visitEnd();\n-        byte[] carray = cw.toByteArray();\n-        \/\/ for debugging\n-        \/\/ write((new File(\"X.class\")).toPath(), carray, CREATE, TRUNCATE_EXISTING);\n-\n-        \/\/ verify using javap\/classfile reader\n-        ClassFile cf = ClassFile.read(new ByteArrayInputStream(carray));\n-        int mcount = checkMethod(cf, \"foo\");\n-        if (mcount < 1) {\n-            throw new RuntimeException(\"unexpected method count, expected 1\" +\n-                    \"but got \" + mcount);\n-        }\n-    }\n-\n-    public static void main(String... args) throws Exception {\n-        init();\n-        verifyInvokerBytecodeGenerator();\n-        verifyASM();\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaAsm.java","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -28,1 +28,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n@@ -34,2 +34,0 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-\n@@ -39,0 +37,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -42,0 +43,1 @@\n+import jdk.internal.classfile.Classfile;\n@@ -43,4 +45,4 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_ABSTRACT;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_INTERFACE;\n-import static jdk.internal.org.objectweb.asm.Opcodes.ACC_PUBLIC;\n-import static jdk.internal.org.objectweb.asm.Opcodes.V1_7;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static jdk.internal.classfile.Classfile.ACC_ABSTRACT;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n@@ -50,0 +52,1 @@\n+    private static final ClassDesc CD_Maker = ClassDesc.of(\"Maker\");\n@@ -136,6 +139,6 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(V1_7, ACC_INTERFACE | ACC_ABSTRACT, \"Maker\", null, \"java\/lang\/Object\", null);\n-        cw.visitMethod(ACC_PUBLIC | ACC_ABSTRACT, \"make\",\n-                \"()Ljava\/lang\/Object;\", null, null);\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return Classfile.build(CD_Maker, clb -> {\n+            clb.withFlags(AccessFlag.ABSTRACT, AccessFlag.INTERFACE);\n+            clb.withSuperclass(CD_Object);\n+            clb.withMethod(\"make\", MethodTypeDesc.of(CD_Object),\n+                    ACC_PUBLIC, mb -> {});\n+        });\n@@ -148,6 +151,7 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(V1_7, ACC_INTERFACE | ACC_ABSTRACT, \"StringMaker\", null, \"java\/lang\/Object\", new String[]{\"Maker\"});\n-        cw.visitMethod(ACC_PUBLIC | ACC_ABSTRACT, \"make\",\n-                \"()Ljava\/lang\/String;\", null, null);\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return Classfile.build(ClassDesc.of(\"StringMaker\"), clb -> {\n+            clb.withFlags(AccessFlag.ABSTRACT, AccessFlag.INTERFACE);\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(CD_Maker);\n+            clb.withMethod(\"make\", MethodTypeDesc.of(CD_String),\n+                    ACC_PUBLIC | ACC_ABSTRACT, mb -> {});\n+        });\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LambdaStackTrace.java","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n@@ -33,0 +33,3 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -36,1 +39,4 @@\n-import jdk.internal.org.objectweb.asm.*;\n+import java.lang.reflect.AccessFlag;\n+import java.util.Objects;\n+\n+import jdk.internal.classfile.Classfile;\n@@ -38,1 +44,4 @@\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static java.lang.constant.ConstantDescs.*;\n+import static java.lang.constant.DirectMethodHandleDesc.Kind.SPECIAL;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n@@ -75,0 +84,8 @@\n+    private static final MethodTypeDesc MD_void = MethodTypeDesc.of(CD_void);\n+    private static final MethodTypeDesc MD_int = MethodTypeDesc.of(CD_int);\n+    private static final MethodTypeDesc MD_Lookup = MethodTypeDesc.of(CD_MethodHandles_Lookup);\n+    private static final String CTOR_NAME = \"<init>\";\n+    private static final String METHOD_NAME = \"m\";\n+    private static final ClassDesc CD_T1 = ClassDesc.of(\"T1\");\n+    private static final ClassDesc CD_T2 = ClassDesc.of(\"T2\");\n+    private static final ClassDesc CD_T3 = ClassDesc.of(\"T3\");\n@@ -106,22 +123,13 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        MethodVisitor mv;\n-\n-        cw.visit(52, ACC_PUBLIC + ACC_SUPER, \"T1\", null, \"java\/lang\/Object\", null);\n-\n-        mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitCode();\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(ACC_PUBLIC, \"m\", \"()I\", null, null);\n-        mv.visitCode();\n-        mv.visitIntInsn(BIPUSH, 1);\n-        mv.visitInsn(IRETURN);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return Classfile.build(CD_T1, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.SUPER);\n+            clb.withMethodBody(CTOR_NAME, MD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, CTOR_NAME, MD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(METHOD_NAME, MD_int, ACC_PUBLIC, cob -> {\n+                cob.bipush(1);\n+                cob.ireturn();\n+            });\n+        });\n@@ -131,22 +139,13 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        MethodVisitor mv;\n-\n-        cw.visit(52, ACC_PUBLIC + ACC_SUPER, \"T2\", null, \"T1\", null);\n-\n-        mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitCode();\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"T1\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"m\", \"()I\", null, null);\n-        mv.visitCode();\n-        mv.visitIntInsn(BIPUSH, 2);\n-        mv.visitInsn(IRETURN);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return Classfile.build(CD_T2, clb -> {\n+            clb.withSuperclass(CD_T1);\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.SUPER);\n+            clb.withMethodBody(CTOR_NAME, MD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_T1, CTOR_NAME, MD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(METHOD_NAME, MD_int, ACC_PUBLIC | ACC_STATIC, cob -> {\n+                cob.bipush(2);\n+                cob.ireturn();\n+            });\n+        });\n@@ -156,38 +155,23 @@\n-        ClassWriter cw = new ClassWriter(0);\n-        MethodVisitor mv;\n-\n-        cw.visit(52, ACC_PUBLIC + ACC_SUPER, \"T3\", null, \"T2\", null);\n-\n-        mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-        mv.visitCode();\n-        mv.visitVarInsn(ALOAD, 0);\n-        mv.visitMethodInsn(INVOKESPECIAL, \"T2\", \"<init>\", \"()V\", false);\n-        mv.visitInsn(RETURN);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        mv = cw.visitMethod(ACC_PUBLIC, \"m\", \"()I\", null, null);\n-        mv.visitCode();\n-        mv.visitIntInsn(BIPUSH, 3);\n-        mv.visitInsn(IRETURN);\n-        mv.visitMaxs(1, 1);\n-        mv.visitEnd();\n-\n-        \/\/ getMethodHandle\n-        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, \"getMethodHandle\", \"()Ljava\/lang\/invoke\/MethodHandle;\", null, null);\n-        mv.visitCode();\n-        mv.visitLdcInsn(new Handle(H_INVOKESPECIAL, \"T1\", \"m\", \"()I\"));\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(1, 0);\n-        mv.visitEnd();\n-\n-        \/\/ getLookup\n-        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, \"getLookup\", \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", null, null);\n-        mv.visitCode();\n-        mv.visitMethodInsn(INVOKESTATIC, \"java\/lang\/invoke\/MethodHandles\", \"lookup\", \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", false);\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(1, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+        return Classfile.build(CD_T3, clb -> {\n+            clb.withSuperclass(CD_T2);\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.SUPER);\n+            clb.withMethodBody(CTOR_NAME, MD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_T2, CTOR_NAME, MD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(METHOD_NAME, MD_int, ACC_PUBLIC, cob -> {\n+                cob.bipush(3);\n+                cob.ireturn();\n+            });\n+            clb.withMethodBody(\"getMethodHandle\", MethodTypeDesc.of(CD_MethodHandle),\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n+                cob.constantInstruction(MethodHandleDesc.ofMethod(SPECIAL, CD_T1, METHOD_NAME, MD_int));\n+                cob.areturn();\n+            });\n+            clb.withMethodBody(\"getLookup\", MD_Lookup,\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n+                cob.invokestatic(CD_MethodHandles, \"lookup\", MD_Lookup);\n+                cob.areturn();\n+            });\n+        });\n","filename":"test\/jdk\/java\/lang\/invoke\/lookup\/SpecialStatic.java","additions":70,"deletions":86,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n@@ -33,0 +33,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -35,3 +37,6 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.classfile.Classfile;\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static jdk.internal.classfile.Classfile.ACC_PRIVATE;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n@@ -44,0 +49,2 @@\n+    private static final String CTOR_NAME = \"<init>\";\n+    private static final MethodTypeDesc CTOR_DESC = MethodTypeDesc.of(CD_void);\n@@ -45,1 +52,1 @@\n-    static class TestClassLoader extends ClassLoader implements Opcodes {\n+    static class TestClassLoader extends ClassLoader {\n@@ -48,1 +55,1 @@\n-        public Class findClass(String name) throws ClassNotFoundException {\n+        public Class<?> findClass(String name) throws ClassNotFoundException {\n@@ -59,33 +66,22 @@\n-        private byte[] loadClassData(String name) throws Exception {\n-            ClassWriter cw = new ClassWriter(0);\n-            MethodVisitor mv;\n-            switch (name) {\n-                case INTERFACE_NAME:\n-                    cw.visit(V1_8, ACC_ABSTRACT | ACC_INTERFACE | ACC_PUBLIC, INTERFACE_NAME, null, \"java\/lang\/Object\", null);\n-                    {\n-                        mv = cw.visitMethod(ACC_PRIVATE, \"privInstance\", \"()I\", null, null);\n-                        mv.visitCode();\n-                        mv.visitLdcInsn(EXPECTED);\n-                        mv.visitInsn(IRETURN);\n-                        mv.visitMaxs(1, 1);\n-                        mv.visitEnd();\n-                    }\n-                    break;\n-                case CLASS_NAME:\n-                    cw.visit(52, ACC_SUPER | ACC_PUBLIC, CLASS_NAME, null, \"java\/lang\/Object\", new String[]{INTERFACE_NAME});\n-                    {\n-                        mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n-                        mv.visitCode();\n-                        mv.visitVarInsn(ALOAD, 0);\n-                        mv.visitMethodInsn(INVOKESPECIAL, \"java\/lang\/Object\", \"<init>\", \"()V\");\n-                        mv.visitInsn(RETURN);\n-                        mv.visitMaxs(1, 1);\n-                        mv.visitEnd();\n-                    }\n-                    break;\n-                default:\n-                    break;\n-            }\n-            cw.visitEnd();\n-\n-            return cw.toByteArray();\n+        private byte[] loadClassData(String name) {\n+            return switch (name) {\n+                case INTERFACE_NAME -> Classfile.build(ClassDesc.ofInternalName(INTERFACE_NAME), clb -> {\n+                    clb.withFlags(AccessFlag.ABSTRACT, AccessFlag.INTERFACE, AccessFlag.PUBLIC);\n+                    clb.withSuperclass(CD_Object);\n+                    clb.withMethodBody(\"privInstance\", MethodTypeDesc.of(CD_int), ACC_PRIVATE, cob -> {\n+                        cob.constantInstruction(EXPECTED);\n+                        cob.ireturn();\n+                    });\n+                });\n+                case CLASS_NAME -> Classfile.build(ClassDesc.of(CLASS_NAME), clb -> {\n+                    clb.withFlags(AccessFlag.PUBLIC);\n+                    clb.withSuperclass(CD_Object);\n+                    clb.withInterfaceSymbols(ClassDesc.ofInternalName(INTERFACE_NAME));\n+                    clb.withMethodBody(CTOR_NAME, CTOR_DESC, ACC_PUBLIC, cob -> {\n+                        cob.aload(0);\n+                        cob.invokespecial(CD_Object, CTOR_NAME, CTOR_DESC);\n+                        cob.return_();\n+                    });\n+                });\n+                default -> throw new IllegalArgumentException();\n+            };\n@@ -99,1 +95,1 @@\n-        Object inst = k.newInstance();\n+        Object inst = k.getDeclaredConstructor().newInstance();\n","filename":"test\/jdk\/java\/lang\/reflect\/Method\/invoke\/TestPrivateInterfaceMethodReflect.java","additions":37,"deletions":41,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile java.base\/jdk.internal.classfile.attribute\n@@ -34,2 +34,2 @@\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n+import java.lang.constant.ClassDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -38,2 +38,4 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n+\n+import jdk.internal.classfile.Classfile;\n+import jdk.internal.classfile.attribute.RecordAttribute;\n+import jdk.internal.classfile.attribute.RecordComponentInfo;\n@@ -44,1 +46,3 @@\n-import static jdk.internal.org.objectweb.asm.ClassWriter.*;\n+import static java.lang.constant.ConstantDescs.CD_int;\n+import static jdk.internal.classfile.Classfile.ACC_ABSTRACT;\n+import static jdk.internal.classfile.Classfile.ACC_FINAL;\n@@ -85,1 +89,1 @@\n-        List<RecordComponentEntry> rc = null;\n+        List<RecordComponentInfo> rc = null;\n@@ -87,1 +91,1 @@\n-            rc = List.of(new RecordComponentEntry(\"x\", \"I\"));\n+            rc = List.of(RecordComponentInfo.of(\"x\", CD_int));\n@@ -112,1 +116,1 @@\n-        List<RecordComponentEntry> rc = null;\n+        List<RecordComponentInfo> rc = null;\n@@ -114,1 +118,1 @@\n-            rc = List.of(new RecordComponentEntry(\"x\", \"I\"));\n+            rc = List.of(RecordComponentInfo.of(\"x\", CD_int));\n@@ -164,21 +168,12 @@\n-                              List<RecordComponentEntry> components) {\n-        ClassWriter cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n-\n-        int access = 0;\n-        if (isFinal)\n-            access = access | Opcodes.ACC_FINAL;\n-        if (isAbstract)\n-            access = access | Opcodes.ACC_ABSTRACT;\n-\n-        cw.visit(Opcodes.V16,\n-                 access,\n-                 className,\n-                 null,\n-                 superName,\n-                 null);\n-\n-        if (components != null)\n-            components.forEach(rc -> cw.visitRecordComponent(rc.name(), rc.descriptor(), null));\n-\n-        cw.visitEnd();\n-        return cw.toByteArray();\n+                              List<RecordComponentInfo> components) {\n+        return Classfile.build(ClassDesc.ofInternalName(className), clb -> {\n+            int access = 0;\n+            if (isFinal)\n+                access = access | ACC_FINAL;\n+            if (isAbstract)\n+                access = access | ACC_ABSTRACT;\n+            clb.withFlags(access);\n+            clb.withSuperclass(ClassDesc.ofInternalName(superName));\n+            if (components != null)\n+                clb.accept(RecordAttribute.of(components));\n+        });\n@@ -187,2 +182,0 @@\n-    record RecordComponentEntry (String name, String descriptor) { }\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/IsRecordTest.java","additions":27,"deletions":34,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @modules java.base\/jdk.internal.classfile\n@@ -35,0 +35,2 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n@@ -37,0 +39,1 @@\n+import java.lang.reflect.AccessFlag;\n@@ -48,4 +51,1 @@\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-\n+import jdk.internal.classfile.Classfile;\n@@ -56,0 +56,5 @@\n+\n+import static java.lang.constant.ConstantDescs.CD_Object;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+import static jdk.internal.classfile.Classfile.ACC_PUBLIC;\n+import static jdk.internal.classfile.Classfile.ACC_STATIC;\n@@ -210,43 +215,24 @@\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS\n-                                         + ClassWriter.COMPUTE_FRAMES);\n-        cw.visit(V9,\n-                ACC_PUBLIC + ACC_SUPER,\n-                \"p\/ProviderFactory\",\n-                null,\n-                \"java\/lang\/Object\",\n-                null);\n-\n-        \/\/ public static p.Service provider()\n-        MethodVisitor mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC,\n-                \"provider\",\n-                \"()Lp\/Service;\",\n-                null,\n-                null);\n-        mv.visitTypeInsn(NEW, \"p\/ProviderFactory$1\");\n-        mv.visitInsn(DUP);\n-        mv.visitMethodInsn(INVOKESPECIAL,\n-                \"p\/ProviderFactory$1\",\n-                \"<init>\", \"()V\",\n-                false);\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        \/\/ public static p.ProviderFactory$1 provider()\n-        mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC,\n-                \"provider\",\n-                \"()Lp\/ProviderFactory$1;\",\n-                null,\n-                null);\n-        mv.visitTypeInsn(NEW, \"p\/ProviderFactory$1\");\n-        mv.visitInsn(DUP);\n-        mv.visitMethodInsn(INVOKESPECIAL,\n-                \"p\/ProviderFactory$1\",\n-                \"<init>\",\n-                \"()V\",\n-                false);\n-        mv.visitInsn(ARETURN);\n-        mv.visitMaxs(0, 0);\n-        mv.visitEnd();\n-\n-        cw.visitEnd();\n+        var bytes = Classfile.build(ClassDesc.of(\"p\", \"ProviderFactory\"), clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withFlags(AccessFlag.PUBLIC, AccessFlag.SUPER);\n+\n+            var providerFactory$1 = ClassDesc.of(\"p\", \"ProviderFactory$1\");\n+\n+            \/\/ public static p.Service provider()\n+            clb.withMethodBody(\"provider\", MethodTypeDesc.of(ClassDesc.of(\"p\", \"Service\")),\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n+                        cob.new_(providerFactory$1);\n+                        cob.dup();\n+                        cob.invokespecial(providerFactory$1, \"<init>\", MethodTypeDesc.of(CD_void));\n+                        cob.areturn();\n+                    });\n+\n+            \/\/ public static p.ProviderFactory$1 provider()\n+            clb.withMethodBody(\"provider\", MethodTypeDesc.of(providerFactory$1),\n+                    ACC_PUBLIC | ACC_STATIC, cob -> {\n+                        cob.new_(providerFactory$1);\n+                        cob.dup();\n+                        cob.invokespecial(providerFactory$1, \"<init>\", MethodTypeDesc.of(CD_void));\n+                        cob.areturn();\n+                    });\n+        });\n@@ -258,1 +244,1 @@\n-        Files.write(classFile, cw.toByteArray());\n+        Files.write(classFile, bytes);\n","filename":"test\/jdk\/java\/util\/ServiceLoader\/BadProvidersTest.java","additions":36,"deletions":50,"binary":false,"changes":86,"status":"modified"}]}