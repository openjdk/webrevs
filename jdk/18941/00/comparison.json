{"files":[{"patch":"@@ -145,2 +145,1 @@\n-\/\/ Default value if probing is not implemented for a certain platform: 128TB\n-static const size_t DEFAULT_MAX_ADDRESS_BIT = 47;\n+static const size_t DEFAULT_MAX_ADDRESS_BIT = XMaxAddressOffsetBits + XAddressableMetadataBits - 1;\n@@ -201,1 +200,1 @@\n-  const size_t max_address_offset_bits = valid_max_address_offset_bits - 3;\n+  const size_t max_address_offset_bits = valid_max_address_offset_bits - XAddressableMetadataBits;\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/x\/xGlobals_aarch64.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,2 +39,1 @@\n-\/\/ Default value if probing is not implemented for a certain platform: 128TB\n-static const size_t DEFAULT_MAX_ADDRESS_BIT = 47;\n+static const size_t DEFAULT_MAX_ADDRESS_BIT = ZMaxAddressOffsetBits - 1;\n@@ -94,2 +93,1 @@\n-  const static size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n-  const size_t max_address_offset_bits = valid_max_address_offset_bits - 3;\n+  const static size_t max_address_offset_bits = probe_valid_max_address_bit() + 1;\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zAddress_aarch64.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+static const unsigned int MAX_ADDRESS_BIT_LIMIT = XMaxAddressOffsetBits + XAddressableMetadataBits - 1;\n+\n@@ -172,1 +174,1 @@\n-    if (max_valid_address_bit == init_bit) {\n+    if ((max_valid_address_bit == init_bit) && (max_valid_address_bit < MAX_ADDRESS_BIT_LIMIT)) {\n@@ -193,1 +195,1 @@\n-  const size_t max_address_offset_bits = valid_max_address_offset_bits - 3;\n+  const size_t max_address_offset_bits = valid_max_address_offset_bits - XAddressableMetadataBits;\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/x\/xGlobals_ppc.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,2 +38,1 @@\n-\/\/ Default value if probing is not implemented for a certain platform: 128TB\n-static const size_t DEFAULT_MAX_ADDRESS_BIT = 47;\n+static const size_t DEFAULT_MAX_ADDRESS_BIT = ZMaxAddressOffsetBits - 1;\n@@ -93,2 +92,1 @@\n-  const static size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n-  const size_t max_address_offset_bits = valid_max_address_offset_bits - 3;\n+  const static size_t max_address_offset_bits = probe_valid_max_address_bit() + 1;\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zAddress_ppc.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -147,2 +147,1 @@\n-\/\/ Default value if probing is not implemented for a certain platform: 128TB\n-static const size_t DEFAULT_MAX_ADDRESS_BIT = 47;\n+static const size_t DEFAULT_MAX_ADDRESS_BIT = XMaxAddressOffsetBits + XAddressableMetadataBits - 1;\n@@ -203,1 +202,1 @@\n-  const size_t max_address_offset_bits = valid_max_address_offset_bits - 3;\n+  const size_t max_address_offset_bits = valid_max_address_offset_bits - XAddressableMetadataBits;\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/x\/xGlobals_riscv.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n-\/\/ Default value if probe is not implemented for a certain platform: 128TB\n-static const size_t DEFAULT_MAX_ADDRESS_BIT = 47;\n+static const size_t DEFAULT_MAX_ADDRESS_BIT = ZMaxAddressOffsetBits - 1;\n@@ -95,2 +94,1 @@\n-  const static size_t valid_max_address_offset_bits = probe_valid_max_address_bit() + 1;\n-  const size_t max_address_offset_bits = valid_max_address_offset_bits - 3;\n+  const static size_t max_address_offset_bits = probe_valid_max_address_bit() + 1;\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zAddress_riscv.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -140,0 +140,1 @@\n+  const size_t max_address_offset_bits = XMaxAddressOffsetBits;\n@@ -141,1 +142,3 @@\n-  const size_t max_address_offset_bits = 44; \/\/ 16TB\n+  assert(max_address_offset_bits >= min_address_offset_bits,\n+         \"max_address_offset_bits %zu cannot be less than min_address_offset_bits %zu\",\n+         max_address_offset_bits, min_address_offset_bits);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/x\/xGlobals_x86.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+  const size_t max_address_offset_bits = ZMaxAddressOffsetBits;\n@@ -35,1 +36,3 @@\n-  const size_t max_address_offset_bits = 44; \/\/ 16TB\n+  assert(max_address_offset_bits >= min_address_offset_bits,\n+         \"max_address_offset_bits %zu cannot be less than min_address_offset_bits %zu\",\n+         max_address_offset_bits, min_address_offset_bits);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/zAddress_x86.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,0 +65,3 @@\n+size_t     XMarkPartialArrayMinSizeShift;\n+size_t     XMarkPartialArrayMinSize;\n+\n","filename":"src\/hotspot\/share\/gc\/x\/xGlobals.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -105,0 +105,3 @@\n+\/\/ Maximum value of addressable offset bits is set to 44 based on the\n+\/\/ maximum address space requirement of 16 TB.\n+const size_t      XMaxAddressOffsetBits  = 44;\n@@ -111,0 +114,1 @@\n+\/\/ Finalizable bit doesn't need to be addressable\n@@ -112,0 +116,1 @@\n+const size_t      XAddressableMetadataBits      = XAddressMetadataBits - 1;\n@@ -148,2 +153,3 @@\n-const size_t      XMarkPartialArrayMinSizeShift = 12; \/\/ 4K\n-const size_t      XMarkPartialArrayMinSize      = (size_t)1 << XMarkPartialArrayMinSizeShift;\n+const size_t      XMarkPartialArrayDefaultMinSizeShift = 12;\n+extern size_t     XMarkPartialArrayMinSizeShift;\n+extern size_t     XMarkPartialArrayMinSize;\n","filename":"src\/hotspot\/share\/gc\/x\/xGlobals.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/x\/xMarkStackEntry.hpp\"\n@@ -48,0 +49,1 @@\n+  XMarkStackEntry::initialize();\n","filename":"src\/hotspot\/share\/gc\/x\/xInitialize.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/x\/xGlobals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/x\/xMark.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/x\/xGlobals.hpp\"\n@@ -76,0 +77,4 @@\n+  \/\/ Based on the layout of the mark stack entry\n+  static const size_t _object_address_encoding_bits = 59;\n+  static const size_t _partial_array_offset_encoding_bits = 32;\n+\n@@ -81,1 +86,1 @@\n-  typedef XBitField<uint64_t, uintptr_t, 5,  59> field_object_address;\n+  typedef XBitField<uint64_t, uintptr_t, 5,  _object_address_encoding_bits> field_object_address;\n@@ -83,1 +88,1 @@\n-  typedef XBitField<uint64_t, size_t,    32, 32> field_partial_array_offset;\n+  typedef XBitField<uint64_t, size_t,    32, _partial_array_offset_encoding_bits> field_partial_array_offset;\n@@ -140,0 +145,8 @@\n+\n+  static void initialize() {\n+    if (XAddressOffsetBits > _object_address_encoding_bits) {\n+      fatal(\"Insufficient bits to encode object address in mark stack\");\n+    }\n+    XMarkPartialArrayMinSizeShift = MAX2(XAddressOffsetBits - _partial_array_offset_encoding_bits, XMarkPartialArrayDefaultMinSizeShift);\n+    XMarkPartialArrayMinSize = (size_t)1 << XMarkPartialArrayMinSizeShift;\n+  }\n","filename":"src\/hotspot\/share\/gc\/x\/xMarkStackEntry.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+\/\/ Default maximum value of addressable offset bits is set to 44 based on the\n+\/\/ maximum address space requirement of 16 TB.\n+const size_t     ZMaxAddressOffsetBits  = 44;\n","filename":"src\/hotspot\/share\/gc\/z\/zAddress.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,4 @@\n+\n+size_t     ZMarkPartialArrayMinSizeShift;\n+size_t     ZMarkPartialArrayMinSize;\n+size_t     ZMarkPartialArrayMinLength;\n","filename":"src\/hotspot\/share\/gc\/z\/zGlobals.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,3 +91,4 @@\n-const size_t      ZMarkPartialArrayMinSizeShift = 12; \/\/ 4K\n-const size_t      ZMarkPartialArrayMinSize      = (size_t)1 << ZMarkPartialArrayMinSizeShift;\n-const size_t      ZMarkPartialArrayMinLength    = ZMarkPartialArrayMinSize \/ oopSize;\n+const size_t      ZMarkPartialArrayDefaultMinSizeShift = 12; \/\/ 4K\n+extern size_t     ZMarkPartialArrayMinSizeShift;\n+extern size_t     ZMarkPartialArrayMinSize;\n+extern size_t     ZMarkPartialArrayMinLength;\n","filename":"src\/hotspot\/share\/gc\/z\/zGlobals.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/z\/zMarkStackEntry.hpp\"\n@@ -50,0 +51,1 @@\n+  ZMarkStackEntry::initialize();\n","filename":"src\/hotspot\/share\/gc\/z\/zInitialize.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/z\/zAddress.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"gc\/z\/zGlobals.hpp\"\n@@ -76,0 +78,4 @@\n+  \/\/ Based on the layout of the mark stack entry\n+  static const size_t _object_address_encoding_bits = 59;\n+  static const size_t _partial_array_offset_encoding_bits = 32;\n+\n@@ -81,1 +87,1 @@\n-  typedef ZBitField<uint64_t, uintptr_t, 5,  59> field_object_address;\n+  typedef ZBitField<uint64_t, uintptr_t, 5,  _object_address_encoding_bits> field_object_address;\n@@ -83,1 +89,1 @@\n-  typedef ZBitField<uint64_t, size_t,    32, 32> field_partial_array_offset;\n+  typedef ZBitField<uint64_t, size_t,    32, _partial_array_offset_encoding_bits> field_partial_array_offset;\n@@ -140,0 +146,9 @@\n+\n+  static void initialize() {\n+    if (ZAddressOffsetBits > _object_address_encoding_bits) {\n+      fatal(\"Insufficient bits to encode object address in mark stack\");\n+    }\n+    ZMarkPartialArrayMinSizeShift = MAX2(ZAddressOffsetBits - _partial_array_offset_encoding_bits, ZMarkPartialArrayDefaultMinSizeShift);\n+    ZMarkPartialArrayMinSize = (size_t)1 << ZMarkPartialArrayMinSizeShift;\n+    ZMarkPartialArrayMinLength = ZMarkPartialArrayMinSize \/ oopSize;\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackEntry.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"}]}