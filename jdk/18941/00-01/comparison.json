{"files":[{"patch":"@@ -65,3 +65,0 @@\n-size_t     XMarkPartialArrayMinSizeShift;\n-size_t     XMarkPartialArrayMinSize;\n-\n","filename":"src\/hotspot\/share\/gc\/x\/xGlobals.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -153,3 +153,2 @@\n-const size_t      XMarkPartialArrayDefaultMinSizeShift = 12;\n-extern size_t     XMarkPartialArrayMinSizeShift;\n-extern size_t     XMarkPartialArrayMinSize;\n+const size_t      XMarkPartialArrayMinSizeShift = 12; \/\/ 4K\n+const size_t      XMarkPartialArrayMinSize      = (size_t)1 << XMarkPartialArrayMinSizeShift;\n","filename":"src\/hotspot\/share\/gc\/x\/xGlobals.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/x\/xMarkStackEntry.hpp\"\n@@ -49,1 +48,0 @@\n-  XMarkStackEntry::initialize();\n","filename":"src\/hotspot\/share\/gc\/x\/xInitialize.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"gc\/x\/xGlobals.hpp\"\n","filename":"src\/hotspot\/share\/gc\/x\/xMark.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/x\/xGlobals.hpp\"\n@@ -77,4 +76,0 @@\n-  \/\/ Based on the layout of the mark stack entry\n-  static const size_t _object_address_encoding_bits = 59;\n-  static const size_t _partial_array_offset_encoding_bits = 32;\n-\n@@ -86,1 +81,1 @@\n-  typedef XBitField<uint64_t, uintptr_t, 5,  _object_address_encoding_bits> field_object_address;\n+  typedef XBitField<uint64_t, uintptr_t, 5,  59> field_object_address;\n@@ -88,1 +83,1 @@\n-  typedef XBitField<uint64_t, size_t,    32, _partial_array_offset_encoding_bits> field_partial_array_offset;\n+  typedef XBitField<uint64_t, size_t,    32, 32> field_partial_array_offset;\n@@ -145,8 +140,0 @@\n-\n-  static void initialize() {\n-    if (XAddressOffsetBits > _object_address_encoding_bits) {\n-      fatal(\"Insufficient bits to encode object address in mark stack\");\n-    }\n-    XMarkPartialArrayMinSizeShift = MAX2(XAddressOffsetBits - _partial_array_offset_encoding_bits, XMarkPartialArrayDefaultMinSizeShift);\n-    XMarkPartialArrayMinSize = (size_t)1 << XMarkPartialArrayMinSizeShift;\n-  }\n","filename":"src\/hotspot\/share\/gc\/x\/xMarkStackEntry.hpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,4 +37,0 @@\n-\n-size_t     ZMarkPartialArrayMinSizeShift;\n-size_t     ZMarkPartialArrayMinSize;\n-size_t     ZMarkPartialArrayMinLength;\n","filename":"src\/hotspot\/share\/gc\/z\/zGlobals.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,4 +91,3 @@\n-const size_t      ZMarkPartialArrayDefaultMinSizeShift = 12; \/\/ 4K\n-extern size_t     ZMarkPartialArrayMinSizeShift;\n-extern size_t     ZMarkPartialArrayMinSize;\n-extern size_t     ZMarkPartialArrayMinLength;\n+const size_t      ZMarkPartialArrayMinSizeShift = 12; \/\/ 4K\n+const size_t      ZMarkPartialArrayMinSize      = (size_t)1 << ZMarkPartialArrayMinSizeShift;;\n+const size_t      ZMarkPartialArrayMinLength    = ZMarkPartialArrayMinSize \/ oopSize;\n","filename":"src\/hotspot\/share\/gc\/z\/zGlobals.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"gc\/z\/zMarkStackAllocator.hpp\"\n@@ -51,1 +50,0 @@\n-  ZMarkStackEntry::initialize();\n","filename":"src\/hotspot\/share\/gc\/z\/zInitialize.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/z\/zAddress.hpp\"\n@@ -29,1 +28,0 @@\n-#include \"gc\/z\/zGlobals.hpp\"\n@@ -78,4 +76,0 @@\n-  \/\/ Based on the layout of the mark stack entry\n-  static const size_t _object_address_encoding_bits = 59;\n-  static const size_t _partial_array_offset_encoding_bits = 32;\n-\n@@ -87,1 +81,1 @@\n-  typedef ZBitField<uint64_t, uintptr_t, 5,  _object_address_encoding_bits> field_object_address;\n+  typedef ZBitField<uint64_t, uintptr_t, 5,  59> field_object_address;\n@@ -89,1 +83,1 @@\n-  typedef ZBitField<uint64_t, size_t,    32, _partial_array_offset_encoding_bits> field_partial_array_offset;\n+  typedef ZBitField<uint64_t, size_t,    32, 32> field_partial_array_offset;\n@@ -146,9 +140,0 @@\n-\n-  static void initialize() {\n-    if (ZAddressOffsetBits > _object_address_encoding_bits) {\n-      fatal(\"Insufficient bits to encode object address in mark stack\");\n-    }\n-    ZMarkPartialArrayMinSizeShift = MAX2(ZAddressOffsetBits - _partial_array_offset_encoding_bits, ZMarkPartialArrayDefaultMinSizeShift);\n-    ZMarkPartialArrayMinSize = (size_t)1 << ZMarkPartialArrayMinSizeShift;\n-    ZMarkPartialArrayMinLength = ZMarkPartialArrayMinSize \/ oopSize;\n-  }\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackEntry.hpp","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"}]}