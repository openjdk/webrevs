{"files":[{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http;\n+\n+import java.util.Iterator;\n+\n+\/**\n+ * An {@link Iterable} clone supporting checked exceptions.\n+ *\n+ * @param <E> the type of elements returned by the produced iterators\n+ *\/\n+@FunctionalInterface\n+interface CheckedIterable<E> {\n+\n+    \/**\n+     * {@return an {@linkplain CheckedIterator iterator} over elements of type {@code E}}\n+     *\/\n+    CheckedIterator<E> iterator() throws Exception;\n+\n+    static <E> CheckedIterable<E> fromIterable(Iterable<E> iterable) {\n+        return () -> {\n+            Iterator<E> iterator = iterable.iterator();\n+            return CheckedIterator.fromIterator(iterator);\n+        };\n+    }\n+\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/CheckedIterable.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.net.http;\n+\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+\n+\/**\n+ * An {@link Iterator} clone supporting checked exceptions.\n+ *\n+ * @param <E> the type of elements returned by this iterator\n+ *\/\n+interface CheckedIterator<E> {\n+\n+    \/**\n+     * {@return {@code true} if the iteration has more elements}\n+     * @throws Exception if operation fails\n+     *\/\n+    boolean hasNext() throws Exception;\n+\n+    \/**\n+     * {@return the next element in the iteration}\n+     *\n+     * @throws NoSuchElementException if the iteration has no more elements\n+     * @throws Exception if operation fails\n+     *\/\n+    E next() throws Exception;\n+\n+    static <E> CheckedIterator<E> fromIterator(Iterator<E> iterator) {\n+        return new CheckedIterator<>() {\n+\n+            @Override\n+            public boolean hasNext() {\n+                return iterator.hasNext();\n+            }\n+\n+            @Override\n+            public E next() {\n+                return iterator.next();\n+            }\n+\n+        };\n+    }\n+\n+}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/CheckedIterator.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Iterator;\n@@ -30,0 +29,1 @@\n+\n@@ -34,2 +34,2 @@\n- * A Publisher that publishes items obtained from the given Iterable. Each new\n- * subscription gets a new Iterator.\n+ * A {@linkplain Flow.Publisher publisher} that publishes items obtained from the given {@link CheckedIterable}.\n+ * Each new subscription gets a new {@link CheckedIterator}.\n@@ -39,1 +39,1 @@\n-    \/\/ Only one of `iterable` and `throwable` can be non-null. throwable is\n+    \/\/ Only one of `iterable` or `throwable` should be null, and the other non-null. throwable is\n@@ -43,1 +43,1 @@\n-    private final Iterable<T> iterable;\n+    private final CheckedIterable<T> iterable;\n@@ -46,1 +46,7 @@\n-    PullPublisher(Iterable<T> iterable, Throwable throwable) {\n+    PullPublisher(CheckedIterable<T> iterable, Throwable throwable) {\n+        if ((iterable == null) == (throwable == null)) {\n+            String message = String.format(\n+                    \"only one of `iterable` or `throwable` should be null, and the other non-null, but %s are null\",\n+                    throwable == null ? \"both\" : \"none\");\n+            throw new IllegalArgumentException(message);\n+        }\n@@ -51,1 +57,1 @@\n-    PullPublisher(Iterable<T> iterable) {\n+    PullPublisher(CheckedIterable<T> iterable) {\n@@ -57,7 +63,8 @@\n-        Subscription sub;\n-        if (throwable != null) {\n-            assert iterable == null : \"non-null iterable: \" + iterable;\n-            sub = new Subscription(subscriber, null, throwable);\n-        } else {\n-            assert throwable == null : \"non-null exception: \" + throwable;\n-            sub = new Subscription(subscriber, iterable.iterator(), null);\n+        Throwable failure = throwable;\n+        CheckedIterator<T> iterator = null;\n+        if (failure == null) {\n+            try {\n+                iterator = iterable.iterator();\n+            } catch (Exception exception) {\n+                failure = exception;\n+            }\n@@ -65,0 +72,3 @@\n+        Subscription sub = failure != null\n+                ? new Subscription(subscriber, null, failure)\n+                : new Subscription(subscriber, iterator, null);\n@@ -66,2 +76,1 @@\n-\n-        if (throwable != null) {\n+        if (failure != null) {\n@@ -75,1 +84,1 @@\n-        private final Iterator<T> iter;\n+        private final CheckedIterator<T> iter;\n@@ -83,1 +92,1 @@\n-                     Iterator<T> iter,\n+                     CheckedIterator<T> iter,\n@@ -120,1 +129,12 @@\n-                if (!iter.hasNext() && !cancelled) {\n+\n+                boolean hasNext;\n+                try {\n+                    hasNext = iter.hasNext();\n+                } catch (Exception e) {\n+                    completed = true;\n+                    pullScheduler.stop();\n+                    subscriber.onError(e);\n+                    return;\n+                }\n+\n+                if (!hasNext && !cancelled) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PullPublisher.java","additions":39,"deletions":19,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -76,2 +76,5 @@\n-        \/* bufSize exposed for testing purposes *\/\n-        ByteArrayPublisher(byte[] content, int offset, int length, int bufSize) {\n+        private ByteArrayPublisher(byte[] content, int offset, int length, int bufSize) {\n+            Objects.checkFromIndexSize(offset, length, content.length);     \/\/ Implicit null check on `content`\n+            if (bufSize <= 0) {\n+                throw new IllegalArgumentException(\"Invalid buffer size: \" + bufSize);\n+            }\n@@ -102,1 +105,1 @@\n-            var delegate = new PullPublisher<>(copy);\n+            var delegate = new PullPublisher<>(CheckedIterable.fromIterable(copy));\n@@ -124,1 +127,1 @@\n-        class ByteBufferIterator implements Iterator<ByteBuffer> {\n+        private final class ByteBufferIterator implements CheckedIterator<ByteBuffer> {\n@@ -169,4 +172,0 @@\n-        public Iterator<ByteBuffer> iterator() {\n-            return new ByteBufferIterator();\n-        }\n-\n@@ -175,1 +174,1 @@\n-            Iterable<ByteBuffer> iterable = this::iterator;\n+            CheckedIterable<ByteBuffer> iterable = () -> new ByteBufferIterator();\n@@ -205,1 +204,1 @@\n-            super(content.getBytes(charset));\n+            super(content.getBytes(Objects.requireNonNull(charset)));   \/\/ Implicit null check on `content`\n@@ -211,1 +210,1 @@\n-                new PullPublisher<ByteBuffer>(Collections.emptyList(), null);\n+                new PullPublisher<>(CheckedIterable.fromIterable(Collections.emptyList()), null);\n@@ -293,1 +292,1 @@\n-    public static class StreamIterator implements Iterator<ByteBuffer> {\n+    private static final class StreamIterator implements CheckedIterator<ByteBuffer> {\n@@ -334,12 +333,0 @@\n-        \/**\n-         * Close stream in this instance.\n-         * UncheckedIOException may be thrown if IOE happens at InputStream::close.\n-         *\/\n-        private void closeStream() {\n-            try {\n-                is.close();\n-            } catch (IOException e) {\n-                throw new UncheckedIOException(e);\n-            }\n-        }\n-\n@@ -347,1 +334,1 @@\n-        public boolean hasNext() {\n+        public boolean hasNext() throws IOException {\n@@ -356,1 +343,1 @@\n-        private boolean hasNext0() {\n+        private boolean hasNext0() throws IOException {\n@@ -366,1 +353,1 @@\n-                    throw new UncheckedIOException(e);\n+                    throw e;\n@@ -369,1 +356,1 @@\n-                        closeStream();\n+                        is.close();\n@@ -377,1 +364,1 @@\n-        public ByteBuffer next() {\n+        public ByteBuffer next() throws IOException {\n@@ -401,7 +388,9 @@\n-            PullPublisher<ByteBuffer> publisher;\n-            InputStream is = streamSupplier.get();\n-            if (is == null) {\n-                Throwable t = new IOException(\"streamSupplier returned null\");\n-                publisher = new PullPublisher<>(null, t);\n-            } else  {\n-                publisher = new PullPublisher<>(iterableOf(is), null);\n+            InputStream is = null;\n+            Exception exception = null;\n+            try {\n+                is = streamSupplier.get();\n+                if (is == null) {\n+                    exception = new IOException(\"Stream supplier returned null\");\n+                }\n+            } catch (Exception cause) {\n+                exception = new IOException(\"Stream supplier has failed\", cause);\n@@ -409,0 +398,3 @@\n+            PullPublisher<ByteBuffer> publisher = exception != null\n+                    ? new PullPublisher<>(null, exception)\n+                    : new PullPublisher<>(iterableOf(is), null);\n@@ -412,1 +404,1 @@\n-        protected Iterable<ByteBuffer> iterableOf(InputStream is) {\n+        private CheckedIterable<ByteBuffer> iterableOf(InputStream is) {\n@@ -445,1 +437,1 @@\n-            Iterable<ByteBuffer> iterable = () -> new FileChannelIterator(channel, position, limit);\n+            CheckedIterable<ByteBuffer> iterable = () -> new FileChannelIterator(channel, position, limit);\n@@ -451,1 +443,1 @@\n-    private static final class FileChannelIterator implements Iterator<ByteBuffer> {\n+    private static final class FileChannelIterator implements CheckedIterator<ByteBuffer> {\n@@ -473,1 +465,1 @@\n-        public ByteBuffer next() {\n+        public ByteBuffer next() throws IOException {\n@@ -490,1 +482,1 @@\n-                throw new UncheckedIOException(ioe);\n+                throw ioe;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RequestPublishers.java","additions":33,"deletions":41,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public final class ByteBufferUtils {\n+\n+    private ByteBufferUtils() {}\n+\n+    public static void assertEquals(ByteBuffer expectedBuffer, ByteBuffer actualBuffer, String message) {\n+        assertEquals(bytes(expectedBuffer), bytes(actualBuffer), message);\n+    }\n+\n+    public static void assertEquals(byte[] expectedBytes, ByteBuffer actualBuffer, String message) {\n+        assertEquals(expectedBytes, bytes(actualBuffer), message);\n+    }\n+\n+    public static void assertEquals(byte[] expectedBytes, byte[] actualBytes, String message) {\n+        Objects.requireNonNull(expectedBytes);\n+        Objects.requireNonNull(actualBytes);\n+        int mismatchIndex = Arrays.mismatch(expectedBytes, actualBytes);\n+        if (mismatchIndex >= 0) {\n+            Byte expectedByte = mismatchIndex >= expectedBytes.length ? null : expectedBytes[mismatchIndex];\n+            Byte actualByte = mismatchIndex >= actualBytes.length ? null : actualBytes[mismatchIndex];\n+            String extendedMessage = String.format(\n+                    \"%s\" +\n+                            \"array contents differ at index [%s], expected: <%s> but was: <%s>%n\" +\n+                            \"expected: %s%n\" +\n+                            \"actual:   %s%n\",\n+                    message == null ? \"\" : (message + \": \"),\n+                    mismatchIndex, expectedByte, actualByte,\n+                    prettyPrintBytes(expectedBytes),\n+                    prettyPrintBytes(actualBytes));\n+            throw new AssertionError(extendedMessage);\n+        }\n+    }\n+\n+    private static byte[] bytes(ByteBuffer buffer) {\n+        byte[] bytes = new byte[buffer.limit()];\n+        buffer.get(bytes);\n+        return bytes;\n+    }\n+\n+    private static String prettyPrintBytes(byte[] bytes) {\n+        return IntStream.range(0, bytes.length)\n+                .mapToObj(i -> \"\" + bytes[i])\n+                .collect(Collectors.joining(\", \", \"[\", \"]\"));\n+    }\n+\n+    public static int findLengthExceedingMaxMemory() {\n+        long memoryLength = Runtime.getRuntime().maxMemory();\n+        double length = Math.ceil(1.5D * memoryLength);\n+        if (length < 1 || length > Integer.MAX_VALUE) {\n+            throw new IllegalArgumentException(\"Bogus or excessive memory: \" + memoryLength);\n+        }\n+        return (int) length;\n+    }\n+\n+    public static byte[] byteArrayOfLength(int length) {\n+        byte[] bytes = new byte[length];\n+        for (int i = 0; i < length; i++) {\n+            bytes[i] = (byte) i;\n+        }\n+        return bytes;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/ByteBufferUtils.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.net.http.HttpRequest;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8364733\n+ * @summary Verify all specified `HttpRequest.BodyPublishers::fromPublisher` behavior\n+ * @build RecordingSubscriber\n+ * @run junit FromPublisherTest\n+ *\/\n+\n+class FromPublisherTest {\n+\n+    @Test\n+    void testNullPublisher() {\n+        assertThrows(NullPointerException.class, () -> HttpRequest.BodyPublishers.fromPublisher(null));\n+        assertThrows(NullPointerException.class, () -> HttpRequest.BodyPublishers.fromPublisher(null, 1));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(longs = {0L, -1L, Long.MIN_VALUE})\n+    void testInvalidContentLength(long contentLength) {\n+        IllegalArgumentException exception = assertThrows(\n+                IllegalArgumentException.class,\n+                () -> HttpRequest.BodyPublishers.fromPublisher(null, contentLength));\n+        String exceptionMessage = exception.getMessage();\n+        assertTrue(\n+                exceptionMessage.contains(\"non-positive contentLength\"),\n+                \"Unexpected exception message: \" + exceptionMessage);\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(longs = {1, 2, 3, 4})\n+    void testValidContentLength(long contentLength) {\n+        HttpRequest.BodyPublisher publisher =\n+                HttpRequest.BodyPublishers.fromPublisher(HttpRequest.BodyPublishers.noBody(), contentLength);\n+        assertEquals(contentLength, publisher.contentLength());\n+    }\n+\n+    @Test\n+    void testNoContentLength() {\n+        HttpRequest.BodyPublisher publisher =\n+                HttpRequest.BodyPublishers.fromPublisher(HttpRequest.BodyPublishers.noBody());\n+        assertEquals(-1, publisher.contentLength());\n+    }\n+\n+    @Test\n+    void testNullSubscriber() {\n+        HttpRequest.BodyPublisher publisher =\n+                HttpRequest.BodyPublishers.fromPublisher(HttpRequest.BodyPublishers.noBody());\n+        assertThrows(NullPointerException.class, () -> publisher.subscribe(null));\n+    }\n+\n+    @Test\n+    void testDelegation() throws InterruptedException {\n+        BlockingQueue<Object> publisherInvocations = new LinkedBlockingQueue<>();\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.fromPublisher(subscriber -> {\n+            publisherInvocations.add(\"subscribe\");\n+            publisherInvocations.add(subscriber);\n+        });\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        publisher.subscribe(subscriber);\n+        assertEquals(\"subscribe\", publisherInvocations.take());\n+        assertEquals(subscriber, publisherInvocations.take());\n+        assertTrue(subscriber.invocations.isEmpty());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/FromPublisherTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.net.http.HttpRequest;\n+import java.util.concurrent.Flow;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/*\n+ * @test\n+ * @bug 8364733\n+ * @summary Verify all specified `HttpRequest.BodyPublishers::noBody` behavior\n+ * @build RecordingSubscriber\n+ * @run junit NoBodyTest\n+ *\/\n+\n+class NoBodyTest {\n+\n+    @Test\n+    void test() throws InterruptedException {\n+\n+        \/\/ Create the publisher\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.noBody();\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, 0);\n+\n+        \/\/ Verify the state after `request()`\n+        subscription.request(Long.MAX_VALUE);\n+        assertEquals(\"onComplete\", subscriber.invocations.take());\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/NoBodyTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+\n+import java.net.http.HttpRequest;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.concurrent.Flow;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8364733\n+ * @summary Verify all specified `HttpRequest.BodyPublishers::ofByteArray` behavior\n+ * @build RecordingSubscriber\n+ * @run junit OfByteArrayTest\n+ *\n+ * @comment Using `main\/othervm` to initiate tests that depend on a custom-configured JVM\n+ * @run main\/othervm -Djdk.httpclient.bufsize=-1 OfByteArrayTest testInvalidBufferSize\n+ * @run main\/othervm -Djdk.httpclient.bufsize=0 OfByteArrayTest testInvalidBufferSize\n+ * @run main\/othervm -Djdk.httpclient.bufsize=3 OfByteArrayTest testChunking \"\" 0 0 \"\"\n+ * @run main\/othervm -Djdk.httpclient.bufsize=3 OfByteArrayTest testChunking a 0 0 \"\"\n+ * @run main\/othervm -Djdk.httpclient.bufsize=3 OfByteArrayTest testChunking a 1 0 \"\"\n+ * @run main\/othervm -Djdk.httpclient.bufsize=3 OfByteArrayTest testChunking a 0 1 a\n+ * @run main\/othervm -Djdk.httpclient.bufsize=3 OfByteArrayTest testChunking ab 0 1 a\n+ * @run main\/othervm -Djdk.httpclient.bufsize=3 OfByteArrayTest testChunking ab 1 1 b\n+ * @run main\/othervm -Djdk.httpclient.bufsize=3 OfByteArrayTest testChunking ab 0 2 ab\n+ * @run main\/othervm -Djdk.httpclient.bufsize=1 OfByteArrayTest testChunking abc 0 3 a:b:c\n+ * @run main\/othervm -Djdk.httpclient.bufsize=2 OfByteArrayTest testChunking abc 0 3 ab:c\n+ * @run main\/othervm -Djdk.httpclient.bufsize=2 OfByteArrayTest testChunking abcdef 2 4 cd:ef\n+ *\/\n+\n+public class OfByteArrayTest {\n+\n+    private static final Charset CHARSET = StandardCharsets.US_ASCII;\n+\n+    @Test\n+    void testNullContent() {\n+        assertThrows(NullPointerException.class, () -> HttpRequest.BodyPublishers.ofByteArray(null));\n+        assertThrows(NullPointerException.class, () -> HttpRequest.BodyPublishers.ofByteArray(null, 1, 2));\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+            \"abc,-1,1\",     \/\/ Negative offset\n+            \"abc,1,-1\",     \/\/ Negative length\n+            \"'',1,1\",       \/\/ Offset overflow on empty string\n+            \"a,2,1\",        \/\/ Offset overflow\n+            \"'',0,1\",       \/\/ Length overflow on empty string\n+            \"a,0,2\",        \/\/ Length overflow\n+    })\n+    void testInvalidOffsetOrLength(String contentText, int offset, int length) {\n+        byte[] content = contentText.getBytes(CHARSET);\n+        assertThrows(\n+                IndexOutOfBoundsException.class,\n+                () -> HttpRequest.BodyPublishers.ofByteArray(content, offset, length));\n+    }\n+\n+    \/**\n+     * Initiates tests that depend on a custom-configured JVM.\n+     *\/\n+    public static void main(String[] args) throws InterruptedException {\n+        switch (args[0]) {\n+            case \"testInvalidBufferSize\" -> testInvalidBufferSize();\n+            case \"testChunking\" -> testChunking(\n+                    parseStringArg(args[1]),\n+                    Integer.parseInt(args[2]),\n+                    Integer.parseInt(args[3]),\n+                    parseStringArg(args[4]));\n+            default -> throw new IllegalArgumentException(\"Unexpected arguments: \" + List.of(args));\n+        }\n+    }\n+\n+    private static String parseStringArg(String arg) {\n+        return arg == null || arg.trim().equals(\"\\\"\\\"\") ? \"\" : arg;\n+    }\n+\n+    private static void testInvalidBufferSize() {\n+        assertThrows(IllegalArgumentException.class, () -> HttpRequest.BodyPublishers.ofByteArray(new byte[1]));\n+    }\n+\n+    private static void testChunking(\n+            String contentText, int offset, int length, String expectedBuffersText)\n+            throws InterruptedException {\n+\n+        \/\/ Create the publisher\n+        byte[] content = contentText.getBytes(CHARSET);\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofByteArray(content, offset, length);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, length);\n+\n+        \/\/ Verify the state after `request()`\n+        String[] expectedBuffers = expectedBuffersText.isEmpty() ? new String[0] : expectedBuffersText.split(\":\");\n+        subscription.request(Long.MAX_VALUE);\n+        for (int bufferIndex = 0; bufferIndex < expectedBuffers.length; bufferIndex++) {\n+            assertEquals(\"onNext\", subscriber.invocations.take());\n+            String actualBuffer = CHARSET.decode((ByteBuffer) subscriber.invocations.take()).toString();\n+            String expectedBuffer = expectedBuffers[bufferIndex];\n+            assertEquals(expectedBuffer, actualBuffer, \"buffer mismatch at index \" + bufferIndex);\n+        }\n+        assertEquals(\"onComplete\", subscriber.invocations.take());\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/OfByteArrayTest.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,317 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.net.http.HttpRequest;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.Flow;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8364733\n+ * @summary Verify all specified `HttpRequest.BodyPublishers::ofByteArrays` behavior\n+ * @build ByteBufferUtils\n+ *        RecordingSubscriber\n+ * @run junit OfByteArraysTest\n+ *\n+ * @comment Using `main\/othervm` to initiate tests that depend on a custom-configured JVM\n+ * @run main\/othervm -Xmx64m OfByteArraysTest testOOM\n+ *\/\n+\n+public class OfByteArraysTest {\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, 1, 2, 3})\n+    void testIteratorOfLength(int length) throws InterruptedException {\n+\n+        \/\/ Create the publisher\n+        List<byte[]> buffers = IntStream\n+                .range(0, length)\n+                .mapToObj(i -> new byte[]{(byte) i})\n+                .toList();\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofByteArrays(buffers::iterator);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, -1);\n+\n+        \/\/ Verify the state after `request()`\n+        subscription.request(Long.MAX_VALUE);\n+        for (int bufferIndex = 0; bufferIndex < length; bufferIndex++) {\n+            assertEquals(\"onNext\", subscriber.invocations.take());\n+            byte[] expectedBuffer = buffers.get(bufferIndex);\n+            ByteBuffer actualBuffer = (ByteBuffer) subscriber.invocations.take();\n+            ByteBufferUtils.assertEquals(expectedBuffer, actualBuffer, \"buffer mismatch at index \" + bufferIndex);\n+        }\n+        assertEquals(\"onComplete\", subscriber.invocations.take());\n+\n+    }\n+\n+    @Test\n+    void testDifferentIterators() throws InterruptedException {\n+\n+        \/\/ Create a publisher using an iterable that returns a different iterator at each invocation\n+        byte[] buffer1 = ByteBufferUtils.byteArrayOfLength(9);\n+        byte[] buffer2 = ByteBufferUtils.byteArrayOfLength(9);\n+        int[] iteratorRequestCount = {0};\n+        Iterable<byte[]> iterable = () -> switch (++iteratorRequestCount[0]) {\n+            case 1 -> List.of(buffer1).iterator();\n+            case 2 -> List.of(buffer2).iterator();\n+            default -> throw new AssertionError();\n+        };\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofByteArrays(iterable);\n+\n+        \/\/ Subscribe twice (to force two `Iterable::iterator` invocations)\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription1 = subscriber.verifyAndSubscribe(publisher, -1);\n+        Flow.Subscription subscription2 = subscriber.verifyAndSubscribe(publisher, -1);\n+\n+        \/\/ Drain emissions until completion, and verify the content\n+        byte[] actualBuffer1 = subscriber.drainToByteArray(subscription1, Long.MAX_VALUE);\n+        byte[] actualBuffer2 = subscriber.drainToByteArray(subscription2, Long.MAX_VALUE);\n+        ByteBufferUtils.assertEquals(buffer1, actualBuffer1, null);\n+        ByteBufferUtils.assertEquals(buffer2, actualBuffer2, null);\n+\n+    }\n+\n+    @Test\n+    void testNullIterable() {\n+        assertThrows(NullPointerException.class, () -> HttpRequest.BodyPublishers.ofByteArrays(null));\n+    }\n+\n+    @Test\n+    void testNullIterator() throws InterruptedException {\n+\n+        \/\/ Create the publisher\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofByteArrays(() -> null);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, -1);\n+\n+        \/\/ Verify the NPE\n+        subscription.request(1);\n+        assertEquals(\"onError\", subscriber.invocations.take());\n+        assertInstanceOf(NullPointerException.class, subscriber.invocations.take());\n+\n+    }\n+\n+    @Test\n+    void testNullArray() throws InterruptedException {\n+\n+        \/\/ Create the publisher\n+        List<byte[]> iterable = new ArrayList<>();\n+        iterable.add(null);\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofByteArrays(iterable);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, -1);\n+\n+        \/\/ Verify the NPE\n+        subscription.request(1);\n+        assertEquals(\"onError\", subscriber.invocations.take());\n+        assertInstanceOf(NullPointerException.class, subscriber.invocations.take());\n+\n+    }\n+\n+    @Test\n+    void testThrowingIterable() throws InterruptedException {\n+\n+        \/\/ Create the publisher\n+        RuntimeException exception = new RuntimeException(\"failure for `testIteratorCreationException`\");\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofByteArrays(() -> {\n+            throw exception;\n+        });\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, -1);\n+\n+        \/\/ Verify the failure\n+        subscription.request(1);\n+        assertEquals(\"onError\", subscriber.invocations.take());\n+        Exception actualException = (Exception) subscriber.invocations.take();\n+        assertSame(exception, actualException);\n+\n+    }\n+\n+    static Stream<Arguments> testThrowingIteratorArgs() {\n+        RuntimeException hasNextException = new RuntimeException(\"failure for `hasNext`\");\n+        RuntimeException nextException = new RuntimeException(\"failure for `next`\");\n+        return Stream.of(\n+                Arguments.of(0, hasNextException, null, hasNextException),\n+                Arguments.of(0, hasNextException, nextException, hasNextException),\n+                Arguments.of(1, hasNextException, null, hasNextException),\n+                Arguments.of(1, hasNextException, nextException, hasNextException),\n+                Arguments.of(1, null, nextException, nextException));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testThrowingIteratorArgs\")\n+    void testThrowingIterator(\n+            int exceptionIndex, RuntimeException hasNextException, RuntimeException nextException, Exception expectedException)\n+            throws InterruptedException {\n+\n+        \/\/ Create the publisher\n+        IteratorThrowingAtEnd iterator =\n+                new IteratorThrowingAtEnd(exceptionIndex, hasNextException, nextException);\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofByteArrays(() -> iterator);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, -1);\n+\n+        \/\/ Drain successful emissions\n+        subscription.request(Long.MAX_VALUE);\n+        for (int itemIndex = 0; itemIndex < exceptionIndex; itemIndex++) {\n+            assertEquals(\"onNext\", subscriber.invocations.take());\n+            ByteBuffer actualBuffer = (ByteBuffer) subscriber.invocations.take();\n+            ByteBuffer expectedBuffer = ByteBuffer.wrap(iterator.content, itemIndex, 1);\n+            ByteBufferUtils.assertEquals(expectedBuffer, actualBuffer, null);\n+        }\n+\n+        \/\/ Verify the result\n+        if (expectedException == null) {\n+            assertEquals(\"onComplete\", subscriber.invocations.take());\n+        } else {\n+            assertEquals(\"onError\", subscriber.invocations.take());\n+            Exception actualException = (Exception) subscriber.invocations.take();\n+            assertSame(expectedException, actualException);\n+        }\n+\n+    }\n+\n+    private static final class IteratorThrowingAtEnd implements Iterator<byte[]> {\n+\n+        private final byte[] content;\n+\n+        private final RuntimeException hasNextException;\n+\n+        private final RuntimeException nextException;\n+\n+        private int position;\n+\n+        private IteratorThrowingAtEnd(\n+                int length,\n+                RuntimeException hasNextException,\n+                RuntimeException nextException) {\n+            this.content = ByteBufferUtils.byteArrayOfLength(length);\n+            this.hasNextException = hasNextException;\n+            this.nextException = nextException;\n+        }\n+\n+        @Override\n+        public synchronized boolean hasNext() {\n+            if (position >= content.length && hasNextException != null) {\n+                throw hasNextException;\n+            }\n+            \/\/ We always instruct to proceed, so `next()` can throw\n+            return true;\n+        }\n+\n+        @Override\n+        public synchronized byte[] next() {\n+            if (position < content.length) {\n+                return new byte[]{content[position++]};\n+            }\n+            assertNotNull(nextException);\n+            throw nextException;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Initiates tests that depend on a custom-configured JVM.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        if (\"testOOM\".equals(args[0])) {\n+            testOOM();\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown arguments: \" + List.of(args));\n+        }\n+    }\n+\n+    private static void testOOM() throws Exception {\n+\n+        \/\/ Create the publisher\n+        int length = ByteBufferUtils.findLengthExceedingMaxMemory();\n+        Iterable<byte[]> iterable = createIterableOfLength(length);\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofByteArrays(iterable);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, -1);\n+\n+        \/\/ Drain emissions until completion, and verify the received content length\n+        final int[] readLength = {0};\n+        subscriber.drainToAccumulator(subscription, 1, buffer -> readLength[0] += buffer.limit());\n+        assertEquals(length, readLength[0]);\n+\n+    }\n+\n+    private static Iterable<byte[]> createIterableOfLength(int length) {\n+        return () -> new Iterator<>() {\n+\n+            \/\/ Instead of emitting `length` at once, doing it gradually using a buffer to avoid OOM.\n+            private final byte[] buffer = new byte[8192];\n+\n+            private volatile int remainingLength = length;\n+\n+            @Override\n+            public boolean hasNext() {\n+                return remainingLength > 0;\n+            }\n+\n+            @Override\n+            public synchronized byte[] next() {\n+                if (remainingLength >= buffer.length) {\n+                    remainingLength -= buffer.length;\n+                    return buffer;\n+                } else {\n+                    byte[] remainingBuffer = new byte[remainingLength];\n+                    remainingLength = 0;\n+                    return remainingBuffer;\n+                }\n+            }\n+\n+        };\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/OfByteArraysTest.java","additions":317,"deletions":0,"binary":false,"changes":317,"status":"added"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.http.HttpRequest;\n+import java.nio.ByteBuffer;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Flow;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8364733\n+ * @summary Verify all specified `HttpRequest.BodyPublishers::ofFile` behavior\n+ * @build ByteBufferUtils\n+ *        RecordingSubscriber\n+ * @run junit OfFileTest\n+ *\n+ * @comment Using `main\/othervm` to initiate tests that depend on a custom-configured JVM\n+ * @run main\/othervm -Xmx64m OfFileTest testOOM\n+ *\/\n+\n+public class OfFileTest {\n+\n+    private static final Path DEFAULT_FS_DIR = Path.of(System.getProperty(\"java.io.tmpdir\"));\n+\n+    private static final Path ZIP_FS_DIR = zipFsDir();\n+\n+    private static final List<Path> PARENT_DIRS = List.of(DEFAULT_FS_DIR, ZIP_FS_DIR);\n+\n+    private static Path zipFsDir() {\n+        try {\n+            Path zipFile = DEFAULT_FS_DIR.resolve(\"file.zip\");\n+            FileSystem zipFS = FileSystems.newFileSystem(zipFile, Map.of(\"create\", \"true\"));\n+            return zipFS.getRootDirectories().iterator().next();\n+        } catch (IOException ioe) {\n+            throw new UncheckedIOException(ioe);\n+        }\n+    }\n+\n+    static List<Path> parentDirs() {\n+        return PARENT_DIRS;\n+    }\n+\n+    @Test\n+    void testNullPath() {\n+        assertThrows(NullPointerException.class, () -> HttpRequest.BodyPublishers.ofFile(null));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"parentDirs\")\n+    void testNonExistentPath(Path parentDir) {\n+        Path nonExistentPath = createFilePath(parentDir, \"testNonExistentPath\");\n+        assertThrows(FileNotFoundException.class, () -> HttpRequest.BodyPublishers.ofFile(nonExistentPath));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"parentDirs\")\n+    void testNonExistentPathAtSubscribe(Path parentDir) throws Exception {\n+\n+        \/\/ Create the publisher\n+        byte[] fileBytes = ByteBufferUtils.byteArrayOfLength(3);\n+        Path filePath = createFile(parentDir, \"testNonExistentPathAtSubscribe\", fileBytes);\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofFile(filePath);\n+\n+        \/\/ Delete the file\n+        Files.delete(filePath);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, fileBytes.length);\n+\n+        \/\/ Verify the state after `request()`\n+        subscription.request(1);\n+        assertEquals(\"onError\", subscriber.invocations.take());\n+        FileNotFoundException actualException = (FileNotFoundException) subscriber.invocations.take();\n+        String actualExceptionMessage = actualException.getMessage();\n+        assertTrue(\n+                actualExceptionMessage.contains(\"Not a regular file\"),\n+                \"Unexpected message: \" + actualExceptionMessage);\n+\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"parentDirs\")\n+    void testIrregularFile(Path parentDir) throws Exception {\n+\n+        \/\/ Create the publisher\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofFile(parentDir);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, Files.size(parentDir));\n+\n+        \/\/ Verify the state after `request()`\n+        subscription.request(1);\n+        assertEquals(\"onError\", subscriber.invocations.take());\n+        FileNotFoundException actualException = (FileNotFoundException) subscriber.invocations.take();\n+        String actualExceptionMessage = actualException.getMessage();\n+        assertTrue(\n+                actualExceptionMessage.contains(\"Not a regular file\"),\n+                \"Unexpected message: \" + actualExceptionMessage);\n+\n+    }\n+\n+    \/**\n+     * A <em>big enough<\/em> file length to observe the effects of file\n+     * modification whilst the file is getting read.\n+     *\/\n+    private static final int BIG_FILE_LENGTH = 8 * 1024 * 1024;  \/\/ 8 MiB\n+\n+    @ParameterizedTest\n+    @MethodSource(\"parentDirs\")\n+    void testFileModificationWhileReading(Path parentDir) throws Exception {\n+\n+        \/\/ ZIP file system (sadly?) consumes the entire content at open.\n+        \/\/ Hence, we cannot observe the effect of file modification while reading.\n+        if (parentDir == ZIP_FS_DIR) {\n+            return;\n+        }\n+\n+        \/\/ Create the publisher\n+        byte[] fileBytes = ByteBufferUtils.byteArrayOfLength(BIG_FILE_LENGTH);\n+        Path filePath = createFile(parentDir, \"testFileModificationWhileReading\", fileBytes);\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofFile(filePath);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, fileBytes.length);\n+\n+        \/\/ Verify the state after the 1st `request()`\n+        subscription.request(1);\n+        assertEquals(\"onNext\", subscriber.invocations.take());\n+        ByteBuffer buffer1 = (ByteBuffer) subscriber.invocations.take();\n+        assertTrue(buffer1.limit() > 0, \"unexpected empty buffer\");\n+        List<ByteBuffer> buffers = new ArrayList<>();\n+        buffers.add(buffer1);\n+\n+        \/\/ Truncate the file\n+        Files.write(filePath, new byte[0]);\n+\n+        \/\/ Drain emissions until completion, and verify the content\n+        byte[] readBytes = subscriber.drainToByteArray(subscription, Long.MAX_VALUE, buffers);\n+        assertTrue(\n+                readBytes.length < fileBytes.length,\n+                \"was expecting less than the total amount (%s bytes), found: %s\".formatted(\n+                        fileBytes.length, readBytes.length));\n+        ByteBuffer expectedReadBytes = ByteBuffer.wrap(fileBytes, 0, readBytes.length);\n+        ByteBufferUtils.assertEquals(expectedReadBytes, ByteBuffer.wrap(readBytes), null);\n+\n+    }\n+\n+    static Stream<Arguments> testFileOfLengthParams() {\n+        return PARENT_DIRS\n+                .stream()\n+                .flatMap(parentDir -> Stream\n+                        .of(0, 1, 2, 3, BIG_FILE_LENGTH)\n+                        .map(fileLength -> Arguments.of(parentDir, fileLength)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testFileOfLengthParams\")\n+    void testFileOfLength(Path parentDir, int fileLength) throws Exception {\n+\n+        \/\/ Create the publisher\n+        byte[] fileBytes = ByteBufferUtils.byteArrayOfLength(fileLength);\n+        Path filePath = createFile(parentDir, \"testFileOfLength\", fileBytes);\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofFile(filePath);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, fileBytes.length);\n+\n+        \/\/ Drain emissions until completion, and verify the received content\n+        byte[] readBytes = subscriber.drainToByteArray(subscription, Long.MAX_VALUE);\n+        ByteBufferUtils.assertEquals(fileBytes, readBytes, null);\n+\n+    }\n+\n+    \/**\n+     * Initiates tests that depend on a custom-configured JVM.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        if (\"testOOM\".equals(args[0])) {\n+            testOOM();\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown arguments: \" + List.of(args));\n+        }\n+    }\n+\n+    private static void testOOM() {\n+        for (Path parentDir : PARENT_DIRS) {\n+            try {\n+                testOOM(parentDir);\n+            } catch (Exception exception) {\n+                throw new AssertionError(\"failed for parent directory: \" + parentDir, exception);\n+            }\n+        }\n+    }\n+\n+    private static void testOOM(Path parentDir) throws Exception {\n+\n+        \/\/ Create the publisher\n+        int fileLength = ByteBufferUtils.findLengthExceedingMaxMemory();\n+        Path filePath = createFileOfLength(parentDir, \"testOOM\", fileLength);\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofFile(filePath);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, fileLength);\n+\n+        \/\/ Drain emissions until completion, and verify the received content length\n+        final int[] readLength = {0};\n+        subscriber.drainToAccumulator(subscription, 1, buffer -> readLength[0] += buffer.limit());\n+        assertEquals(fileLength, readLength[0]);\n+\n+    }\n+\n+    private static Path createFileOfLength(Path parentDir, String identifier, int fileLength) throws IOException {\n+        Path filePath = createFilePath(parentDir, identifier);\n+        try (OutputStream fileStream = Files.newOutputStream(filePath)) {\n+            byte[] buffer = ByteBufferUtils.byteArrayOfLength(8192);\n+            for (int writtenLength = 0; writtenLength < fileLength; writtenLength += buffer.length) {\n+                int remainingLength = fileLength - writtenLength;\n+                byte[] effectiveBuffer = remainingLength < buffer.length\n+                        ? ByteBufferUtils.byteArrayOfLength(remainingLength)\n+                        : buffer;\n+                fileStream.write(effectiveBuffer);\n+            }\n+        }\n+        return filePath;\n+    }\n+\n+    private static Path createFile(Path parentDir, String identifier, byte[] fileBytes) throws IOException {\n+        Path filePath = createFilePath(parentDir, identifier);\n+        Files.write(filePath, fileBytes);\n+        return filePath;\n+    }\n+\n+    private static Path createFilePath(Path parentDir, String identifier) {\n+        String fileName = identifier.replaceAll(\"\\\\W*\", \"\");\n+        return parentDir.resolve(fileName);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/OfFileTest.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.http.HttpRequest;\n+import java.util.List;\n+import java.util.concurrent.Flow;\n+import java.util.function.Supplier;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8364733\n+ * @summary Verify all specified `HttpRequest.BodyPublishers::ofInputStream` behavior\n+ * @build ByteBufferUtils\n+ *        RecordingSubscriber\n+ * @run junit OfInputStreamTest\n+ *\n+ * @comment Using `main\/othervm` to initiate tests that depend on a custom-configured JVM\n+ * @run main\/othervm -Xmx64m OfInputStreamTest testOOM\n+ *\/\n+\n+public class OfInputStreamTest {\n+\n+    @Test\n+    void testNullInputStreamSupplier() {\n+        assertThrows(NullPointerException.class, () -> HttpRequest.BodyPublishers.ofInputStream(null));\n+    }\n+\n+    @Test\n+    void testThrowingInputStreamSupplier() throws InterruptedException {\n+\n+        \/\/ Create the publisher\n+        RuntimeException exception = new RuntimeException();\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofInputStream(() -> { throw exception; });\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, -1);\n+\n+        \/\/ Verify the state after `request()`\n+        subscription.request(1);\n+        assertEquals(\"onError\", subscriber.invocations.take());\n+        IOException actualException = (IOException) subscriber.invocations.take();\n+        assertEquals(\"Stream supplier has failed\", actualException.getMessage());\n+        assertSame(exception, actualException.getCause());\n+\n+    }\n+\n+    @Test\n+    void testNullInputStream() throws InterruptedException {\n+\n+        \/\/ Create the publisher\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofInputStream(() -> null);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, -1);\n+\n+        \/\/ Verify the state after `request()`\n+        subscription.request(1);\n+        assertEquals(\"onError\", subscriber.invocations.take());\n+        IOException actualException = (IOException) subscriber.invocations.take();\n+        assertEquals(\"Stream supplier returned null\", actualException.getMessage());\n+\n+    }\n+\n+    @Test\n+    void testInputStreamSupplierInvocations() throws InterruptedException {\n+\n+        \/\/ Create a publisher from an `InputStream` supplier returning a different instance at each invocation\n+        byte[] buffer1 = ByteBufferUtils.byteArrayOfLength(10);\n+        byte[] buffer2 = ByteBufferUtils.byteArrayOfLength(10);\n+        int[] inputStreamSupplierInvocationCount = {0};\n+        Supplier<InputStream> inputStreamSupplier = () ->\n+                switch (++inputStreamSupplierInvocationCount[0]) {\n+                    case 1 -> new ByteArrayInputStream(buffer1);\n+                    case 2 -> new ByteArrayInputStream(buffer2);\n+                    default -> throw new AssertionError();\n+                };\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofInputStream(inputStreamSupplier);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription1 = subscriber.verifyAndSubscribe(publisher, -1);\n+        Flow.Subscription subscription2 = subscriber.verifyAndSubscribe(publisher, -1);\n+\n+        \/\/ Drain each subscription and verify the received content\n+        byte[] actualBuffer1 = subscriber.drainToByteArray(subscription1, Long.MAX_VALUE);\n+        ByteBufferUtils.assertEquals(buffer1, actualBuffer1, null);\n+        byte[] actualBuffer2 = subscriber.drainToByteArray(subscription2, Long.MAX_VALUE);\n+        ByteBufferUtils.assertEquals(buffer2, actualBuffer2, null);\n+\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, 1, 2, 3})\n+    void testInputStreamOfLength(int length) throws InterruptedException {\n+\n+        \/\/ Create the publisher\n+        byte[] content = ByteBufferUtils.byteArrayOfLength(length);\n+        InputStream inputStream = new ByteArrayInputStream(content);\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofInputStream(() -> inputStream);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, -1);\n+\n+        \/\/ Drain emissions until completion, and verify the received content\n+        byte[] actualContent = subscriber.drainToByteArray(subscription, Long.MAX_VALUE);\n+        ByteBufferUtils.assertEquals(content, actualContent, null);\n+\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, 1, 2, 3})\n+    void testThrowingInputStream(int exceptionIndex) throws InterruptedException {\n+\n+        \/\/ Create the publisher\n+        RuntimeException exception = new RuntimeException(\"failure for `read`\");\n+        InputStream inputStream = new InputStreamThrowingOnCompletion(exceptionIndex, exception);\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofInputStream(() -> inputStream);\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, -1);\n+\n+        \/\/ Verify the failure\n+        subscription.request(1);\n+        assertEquals(\"onError\", subscriber.invocations.take());\n+        Exception actualException = (Exception) subscriber.invocations.take();\n+        assertSame(exception, actualException);\n+\n+    }\n+\n+    private static final class InputStreamThrowingOnCompletion extends InputStream {\n+\n+        private final int length;\n+\n+        private final RuntimeException exception;\n+\n+        private int position;\n+\n+        private InputStreamThrowingOnCompletion(int length, RuntimeException exception) {\n+            this.length = length;\n+            this.exception = exception;\n+        }\n+\n+        @Override\n+        public synchronized int read() {\n+            if (position < length) {\n+                return position++ & 0xFF;\n+            }\n+            throw exception;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Initiates tests that depend on a custom-configured JVM.\n+     *\/\n+    public static void main(String[] args) throws Exception {\n+        if (\"testOOM\".equals(args[0])) {\n+            testOOM();\n+        } else {\n+            throw new IllegalArgumentException(\"Unknown arguments: \" + List.of(args));\n+        }\n+    }\n+\n+    private static void testOOM() throws InterruptedException {\n+\n+        \/\/ Create the publisher using an `InputStream` that emits content exceeding the maximum memory\n+        int length = ByteBufferUtils.findLengthExceedingMaxMemory();\n+        HttpRequest.BodyPublisher publisher =\n+                HttpRequest.BodyPublishers.ofInputStream(() -> new InputStream() {\n+\n+                    private int position;\n+\n+                    @Override\n+                    public synchronized int read() {\n+                        return position < length ? (position++ & 0xFF) : -1;\n+                    }\n+\n+                });\n+\n+        \/\/ Subscribe\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        Flow.Subscription subscription = subscriber.verifyAndSubscribe(publisher, -1);\n+\n+        \/\/ Drain emissions until completion, and verify the received content length\n+        final int[] readLength = {0};\n+        subscriber.drainToAccumulator(subscription, 1, buffer -> readLength[0] += buffer.limit());\n+        assertEquals(length, readLength[0]);\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/OfInputStreamTest.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.CsvSource;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.net.http.HttpRequest;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.Flow;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/*\n+ * @test\n+ * @bug 8364733\n+ * @summary Verify all specified `HttpRequest.BodyPublishers::ofString` behavior\n+ * @build ByteBufferUtils\n+ *        RecordingSubscriber\n+ * @run junit OfStringTest\n+ *\/\n+\n+class OfStringTest {\n+\n+    private static final Charset CHARSET = StandardCharsets.US_ASCII;\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {0, 1, 2, 3})\n+    void testContentOfLength(int length) throws InterruptedException {\n+\n+        \/\/ Create the publisher\n+        char[] contentChars = new char[length];\n+        for (int i = 0; i < length; i++) {\n+            contentChars[i] = (char) ('a' + i);\n+        }\n+        String content = new String(contentChars);\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofString(content, CHARSET);\n+\n+        \/\/ Subscribe\n+        assertEquals(length, publisher.contentLength());\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        publisher.subscribe(subscriber);\n+        assertEquals(\"onSubscribe\", subscriber.invocations.take());\n+        Flow.Subscription subscription = (Flow.Subscription) subscriber.invocations.take();\n+\n+        \/\/ Verify the state after `request()`\n+        subscription.request(Long.MAX_VALUE);\n+        if (length > 0) {\n+            assertEquals(\"onNext\", subscriber.invocations.take());\n+            String actualContent = CHARSET.decode((ByteBuffer) subscriber.invocations.take()).toString();\n+            assertEquals(content, actualContent);\n+        }\n+        assertEquals(\"onComplete\", subscriber.invocations.take());\n+\n+    }\n+\n+    @ParameterizedTest\n+    @CsvSource({\n+            \"a,UTF-8\",\n+            \"b,UTF-16\",\n+            \",ISO-8859-9\"\n+    })\n+    void testCharset(String content, Charset charset) throws InterruptedException {\n+\n+        \/\/ Create the publisher\n+        HttpRequest.BodyPublisher publisher = HttpRequest.BodyPublishers.ofString(content, charset);\n+\n+        \/\/ Subscribe\n+        ByteBuffer expectedBuffer = charset.encode(content);\n+        assertEquals(expectedBuffer.limit(), publisher.contentLength());\n+        RecordingSubscriber subscriber = new RecordingSubscriber();\n+        publisher.subscribe(subscriber);\n+        assertEquals(\"onSubscribe\", subscriber.invocations.take());\n+        Flow.Subscription subscription = (Flow.Subscription) subscriber.invocations.take();\n+\n+        \/\/ Verify the state after `request()`\n+        subscription.request(Long.MAX_VALUE);\n+        assertEquals(\"onNext\", subscriber.invocations.take());\n+        ByteBuffer actualBuffer = (ByteBuffer) subscriber.invocations.take();\n+        ByteBufferUtils.assertEquals(expectedBuffer, actualBuffer, null);\n+        assertEquals(\"onComplete\", subscriber.invocations.take());\n+\n+    }\n+\n+    @Test\n+    void testNullContent() {\n+        assertThrows(NullPointerException.class, () -> HttpRequest.BodyPublishers.ofString(null, CHARSET));\n+    }\n+\n+    @Test\n+    void testNullCharset() {\n+        assertThrows(NullPointerException.class, () -> HttpRequest.BodyPublishers.ofString(\"foo\", null));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/OfStringTest.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.http.HttpRequest;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/**\n+ * Test subscriber recording received invocations.\n+ *\/\n+public final class RecordingSubscriber implements Flow.Subscriber<ByteBuffer> {\n+\n+    public final BlockingQueue<Object> invocations = new LinkedBlockingQueue<>();\n+\n+    @Override\n+    public void onSubscribe(Flow.Subscription subscription) {\n+        invocations.add(\"onSubscribe\");\n+        invocations.add(subscription);\n+    }\n+\n+    @Override\n+    public void onNext(ByteBuffer item) {\n+        invocations.add(\"onNext\");\n+        invocations.add(item);\n+    }\n+\n+    @Override\n+    public synchronized void onError(Throwable throwable) {\n+        invocations.add(\"onError\");\n+        invocations.add(throwable);\n+    }\n+\n+    @Override\n+    public synchronized void onComplete() {\n+        invocations.add(\"onComplete\");\n+    }\n+\n+    \/**\n+     * Verifies the content length of the given publisher and subscribes to it.\n+     *\/\n+    public Flow.Subscription verifyAndSubscribe(HttpRequest.BodyPublisher publisher, long contentLength)\n+            throws InterruptedException {\n+        assertEquals(contentLength, publisher.contentLength());\n+        publisher.subscribe(this);\n+        assertEquals(\"onSubscribe\", invocations.take());\n+        return (Flow.Subscription) invocations.take();\n+    }\n+\n+    \/**\n+     * {@return the byte sequence collected by draining all emissions until completion}\n+     *\n+     * @param subscription a subscription to drain from\n+     * @param itemCount the number of items to request per iteration\n+     *\/\n+    public byte[] drainToByteArray(Flow.Subscription subscription, long itemCount) throws InterruptedException {\n+        return drainToByteArray(subscription, itemCount, new ArrayList<>());\n+    }\n+\n+    \/**\n+     * {@return the byte sequence collected by draining all emissions until completion}\n+     *\n+     * @param subscription a subscription to drain from\n+     * @param itemCount the number of items to request per iteration\n+     * @param buffers a list to accumulate the received content in\n+     *\/\n+    public byte[] drainToByteArray(Flow.Subscription subscription, long itemCount, List<ByteBuffer> buffers)\n+            throws InterruptedException {\n+        drainToAccumulator(subscription, itemCount, buffers::add);\n+        return flattenBuffers(buffers);\n+    }\n+\n+    \/**\n+     * Drains all emissions until completion to the given {@code accumulator}.\n+     *\n+     * @param subscription a subscription to drain from\n+     * @param itemCount the number of items to request per iteration\n+     * @param accumulator an accumulator to pass the received content to\n+     *\/\n+    public void drainToAccumulator(\n+            Flow.Subscription subscription, long itemCount, Consumer<ByteBuffer> accumulator)\n+            throws InterruptedException {\n+        boolean completed = false;\n+        while (!completed) {\n+            subscription.request(itemCount);\n+            String op = (String) invocations.take();\n+            if (\"onNext\".equals(op)) {\n+                ByteBuffer buffer = (ByteBuffer) invocations.take();\n+                accumulator.accept(buffer);\n+            } else if (\"onComplete\".equals(op)) {\n+                completed = true;\n+            } else {\n+                throw new AssertionError(\"Unexpected invocation: \" + op);\n+            }\n+        }\n+    }\n+\n+    private static byte[] flattenBuffers(List<ByteBuffer> buffers) {\n+        int arrayLength = buffers.stream().mapToInt(ByteBuffer::limit).sum();\n+        byte[] array = new byte[arrayLength];\n+        for (int bufferIndex = 0, arrayOffset = 0; bufferIndex < buffers.size(); bufferIndex++) {\n+            ByteBuffer buffer = buffers.get(bufferIndex);\n+            int bufferLimit = buffer.limit();\n+            buffer.get(array, arrayOffset, bufferLimit);\n+            arrayOffset += bufferLimit;\n+        }\n+        return array;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBodyPublishers\/RecordingSubscriber.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}