{"files":[{"patch":"@@ -53,107 +53,0 @@\n-void NativeLoadGot::report_and_fail() const {\n-  tty->print_cr(\"Addr: \" INTPTR_FORMAT, p2i(instruction_address()));\n-  fatal(\"not a indirect rip mov to rbx\");\n-}\n-\n-void NativeLoadGot::verify() const {\n-  assert(is_adrp_at((address)this), \"must be adrp\");\n-}\n-\n-address NativeLoadGot::got_address() const {\n-  return MacroAssembler::target_addr_for_insn((address)this);\n-}\n-\n-intptr_t NativeLoadGot::data() const {\n-  return *(intptr_t *) got_address();\n-}\n-\n-address NativePltCall::destination() const {\n-  NativeGotJump* jump = nativeGotJump_at(plt_jump());\n-  return *(address*)MacroAssembler::target_addr_for_insn((address)jump);\n-}\n-\n-address NativePltCall::plt_entry() const {\n-  return MacroAssembler::target_addr_for_insn((address)this);\n-}\n-\n-address NativePltCall::plt_jump() const {\n-  address entry = plt_entry();\n-  \/\/ Virtual PLT code has move instruction first\n-  if (((NativeGotJump*)entry)->is_GotJump()) {\n-    return entry;\n-  } else {\n-    return nativeLoadGot_at(entry)->next_instruction_address();\n-  }\n-}\n-\n-address NativePltCall::plt_load_got() const {\n-  address entry = plt_entry();\n-  if (!((NativeGotJump*)entry)->is_GotJump()) {\n-    \/\/ Virtual PLT code has move instruction first\n-    return entry;\n-  } else {\n-    \/\/ Static PLT code has move instruction second (from c2i stub)\n-    return nativeGotJump_at(entry)->next_instruction_address();\n-  }\n-}\n-\n-address NativePltCall::plt_c2i_stub() const {\n-  address entry = plt_load_got();\n-  \/\/ This method should be called only for static calls which has C2I stub.\n-  NativeLoadGot* load = nativeLoadGot_at(entry);\n-  return entry;\n-}\n-\n-address NativePltCall::plt_resolve_call() const {\n-  NativeGotJump* jump = nativeGotJump_at(plt_jump());\n-  address entry = jump->next_instruction_address();\n-  if (((NativeGotJump*)entry)->is_GotJump()) {\n-    return entry;\n-  } else {\n-    \/\/ c2i stub 2 instructions\n-    entry = nativeLoadGot_at(entry)->next_instruction_address();\n-    return nativeGotJump_at(entry)->next_instruction_address();\n-  }\n-}\n-\n-void NativePltCall::reset_to_plt_resolve_call() {\n-  set_destination_mt_safe(plt_resolve_call());\n-}\n-\n-void NativePltCall::set_destination_mt_safe(address dest) {\n-  \/\/ rewriting the value in the GOT, it should always be aligned\n-  NativeGotJump* jump = nativeGotJump_at(plt_jump());\n-  address* got = (address *) jump->got_address();\n-  *got = dest;\n-}\n-\n-void NativePltCall::set_stub_to_clean() {\n-  NativeLoadGot* method_loader = nativeLoadGot_at(plt_c2i_stub());\n-  NativeGotJump* jump          = nativeGotJump_at(method_loader->next_instruction_address());\n-  method_loader->set_data(0);\n-  jump->set_jump_destination((address)-1);\n-}\n-\n-void NativePltCall::verify() const {\n-  assert(NativeCall::is_call_at((address)this), \"unexpected code at call site\");\n-}\n-\n-address NativeGotJump::got_address() const {\n-  return MacroAssembler::target_addr_for_insn((address)this);\n-}\n-\n-address NativeGotJump::destination() const {\n-  address *got_entry = (address *) got_address();\n-  return *got_entry;\n-}\n-\n-bool NativeGotJump::is_GotJump() const {\n-  NativeInstruction *insn =\n-    nativeInstruction_at(addr_at(3 * NativeInstruction::instruction_size));\n-  return insn->encoding() == 0xd61f0200; \/\/ br x16\n-}\n-\n-void NativeGotJump::verify() const {\n-  assert(is_adrp_at((address)this), \"must be adrp\");\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":0,"deletions":107,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-\/\/ - - NativeMovConstRegPatching\n@@ -44,1 +43,0 @@\n-\/\/ - - NativeMovRegMemPatching\n@@ -46,6 +44,7 @@\n-\/\/ - - NativeIllegalOpCode\n-\/\/ - - NativeGeneralJump\n-\/\/ - - NativeReturn\n-\/\/ - - NativeReturnX (return with argument)\n-\/\/ - - NativePushConst\n-\/\/ - - NativeTstRegMem\n+\/\/ - - - NativeGeneralJump\n+\/\/ - - NativeIllegalInstruction\n+\/\/ - - NativeCallTrampolineStub\n+\/\/ - - NativeMembar\n+\/\/ - - NativeLdSt\n+\/\/ - - NativePostCallNop\n+\/\/ - - NativeDeoptInstruction\n@@ -158,38 +157,0 @@\n-class NativePltCall: public NativeInstruction {\n-public:\n-  enum Arm_specific_constants {\n-    instruction_size           =    4,\n-    instruction_offset         =    0,\n-    displacement_offset        =    1,\n-    return_address_offset      =    4\n-  };\n-  address instruction_address() const { return addr_at(instruction_offset); }\n-  address next_instruction_address() const { return addr_at(return_address_offset); }\n-  address displacement_address() const { return addr_at(displacement_offset); }\n-  int displacement() const { return (jint) int_at(displacement_offset); }\n-  address return_address() const { return addr_at(return_address_offset); }\n-  address destination() const;\n-  address plt_entry() const;\n-  address plt_jump() const;\n-  address plt_load_got() const;\n-  address plt_resolve_call() const;\n-  address plt_c2i_stub() const;\n-  void set_stub_to_clean();\n-\n-  void reset_to_plt_resolve_call();\n-  void set_destination_mt_safe(address dest);\n-\n-  void verify() const;\n-};\n-\n-inline NativePltCall* nativePltCall_at(address address) {\n-  NativePltCall* call = (NativePltCall*)address;\n-  DEBUG_ONLY(call->verify());\n-  return call;\n-}\n-\n-inline NativePltCall* nativePltCall_before(address addr) {\n-  address at = addr - NativePltCall::instruction_size;\n-  return nativePltCall_at(at);\n-}\n-\n@@ -329,9 +290,0 @@\n-class NativeMovConstRegPatching: public NativeMovConstReg {\n-private:\n-  friend NativeMovConstRegPatching* nativeMovConstRegPatching_at(address address) {\n-    NativeMovConstRegPatching* test = (NativeMovConstRegPatching*)(address - instruction_offset);\n-    DEBUG_ONLY(test->verify());\n-    return test;\n-  }\n-};\n-\n@@ -390,54 +342,0 @@\n-class NativeMovRegMemPatching: public NativeMovRegMem {\n-private:\n-  friend NativeMovRegMemPatching* nativeMovRegMemPatching_at(address address) {\n-    Unimplemented();\n-    return 0;\n-  }\n-};\n-\n-\/\/ An interface for accessing\/manipulating native leal instruction of form:\n-\/\/        leal reg, [reg + offset]\n-\n-class NativeLoadAddress: public NativeInstruction {\n-  enum AArch64_specific_constants {\n-    instruction_size            =    4,\n-    instruction_offset          =    0,\n-    data_offset                 =    0,\n-    next_instruction_offset     =    4\n-  };\n-\n-public:\n-  void verify();\n-};\n-\n-\/\/   adrp    x16, #page\n-\/\/   add     x16, x16, #offset\n-\/\/   ldr     x16, [x16]\n-class NativeLoadGot: public NativeInstruction {\n-public:\n-  enum AArch64_specific_constants {\n-    instruction_length = 4 * NativeInstruction::instruction_size,\n-    offset_offset = 0,\n-  };\n-\n-  address instruction_address() const { return addr_at(0); }\n-  address return_address() const { return addr_at(instruction_length); }\n-  address got_address() const;\n-  address next_instruction_address() const { return return_address(); }\n-  intptr_t data() const;\n-  void set_data(intptr_t data) {\n-    intptr_t* addr = (intptr_t*)got_address();\n-    *addr = data;\n-  }\n-\n-  void verify() const;\n-private:\n-  void report_and_fail() const;\n-};\n-\n-inline NativeLoadGot* nativeLoadGot_at(address addr) {\n-  NativeLoadGot* load = (NativeLoadGot*)addr;\n-  DEBUG_ONLY(load->verify());\n-  return load;\n-}\n-\n@@ -499,33 +397,0 @@\n-class NativeGotJump: public NativeInstruction {\n-public:\n-  enum AArch64_specific_constants {\n-    instruction_size = 4 * NativeInstruction::instruction_size,\n-  };\n-\n-  void verify() const;\n-  address instruction_address() const { return addr_at(0); }\n-  address destination() const;\n-  address return_address() const { return addr_at(instruction_size); }\n-  address got_address() const;\n-  address next_instruction_address() const { return addr_at(instruction_size); }\n-  bool is_GotJump() const;\n-\n-  void set_jump_destination(address dest) {\n-    address* got = (address*)got_address();\n-    *got = dest;\n-  }\n-};\n-\n-inline NativeGotJump* nativeGotJump_at(address addr) {\n-  NativeGotJump* jump = (NativeGotJump*)(addr);\n-  DEBUG_ONLY(jump->verify());\n-  return jump;\n-}\n-\n-class NativePopReg : public NativeInstruction {\n-public:\n-  \/\/ Insert a pop instruction\n-  static void insert(address code_pos, Register reg);\n-};\n-\n-\n@@ -538,15 +403,0 @@\n-\/\/ return instruction that does not pop values of the stack\n-class NativeReturn: public NativeInstruction {\n-public:\n-};\n-\n-\/\/ return instruction that does pop values of the stack\n-class NativeReturnX: public NativeInstruction {\n-public:\n-};\n-\n-\/\/ Simple test vs memory\n-class NativeTstRegMem: public NativeInstruction {\n-public:\n-};\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":7,"deletions":157,"binary":false,"changes":164,"status":"modified"}]}