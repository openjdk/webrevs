{"files":[{"patch":"@@ -76,1 +76,5 @@\n-        String imports = state.maps.packageAndImportsExcept(except, plus);\n+        List<String> extraImports =\n+                plus.stream()\n+                    .map(psi -> psi.importLine(state))\n+                    .toList();\n+        String imports = state.maps.packageAndImportsExcept(except, extraImports);\n@@ -89,1 +93,8 @@\n-        String imports = state.maps.packageAndImportsExcept(null, null);\n+        return wrapInTrialClass(List.of(), List.of(), wrap);\n+    }\n+\n+    OuterWrap wrapInTrialClass(List<String> extraImports, List<Wrap> preWraps, Wrap wrap) {\n+        String imports = state.maps.packageAndImportsExcept(null, extraImports);\n+        List<Wrap> allWraps = new ArrayList<>();\n+        allWraps.addAll(preWraps);\n+        allWraps.add(wrap);\n@@ -91,1 +102,1 @@\n-                Collections.singletonList(wrap));\n+                allWraps);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/OuterWrapMap.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    String packageAndImportsExcept(Set<Key> except, Collection<Snippet> plus) {\n+    String packageAndImportsExcept(Set<Key> except, Collection<String> extraImports) {\n@@ -116,3 +116,1 @@\n-        if (plus != null) {\n-            plus.forEach(psi -> sb.append(psi.importLine(state)));\n-        }\n+        extraImports.forEach(sb::append);\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SnippetMaps.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -303,11 +303,2 @@\n-        code = code.substring(0, cursor);\n-        if (code.trim().isEmpty()) { \/\/TODO: comment handling\n-            code += \";\";\n-        }\n-        boolean[] moduleImport = new boolean[1];\n-        OuterWrap codeWrap = switch (guessKind(code, moduleImport)) {\n-            case IMPORT -> moduleImport[0] ? proc.outerMap.wrapImport(Wrap.simpleWrap(code), null)\n-                                           : proc.outerMap.wrapImport(Wrap.simpleWrap(code + \"any.any\"), null);\n-            case CLASS, METHOD -> proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(code));\n-            default -> proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));\n-        };\n+\n+        OuterWrap codeWrap = wrapCodeForCompletion(code, cursor, true);\n@@ -1743,6 +1734,3 @@\n-        code = code.substring(0, cursor);\n-        if (code.trim().isEmpty()) { \/\/TODO: comment handling\n-            code += \";\";\n-        }\n-\n-        if (guessKind(code) == Kind.IMPORT)\n+        OuterWrap codeWrap = wrapCodeForCompletion(code, cursor, false);\n+        if (codeWrap == null) {\n+            \/\/import:\n@@ -1750,2 +1738,1 @@\n-\n-        OuterWrap codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));\n+        }\n@@ -2432,0 +2419,93 @@\n+    private OuterWrap wrapCodeForCompletion(String code, int cursor, boolean wrapImports) {\n+        code = code.substring(0, cursor);\n+        if (code.trim().isEmpty()) { \/\/TODO: comment handling\n+            code += \";\";\n+        }\n+\n+        List<String> imports = new ArrayList<>();\n+        List<Wrap> declarationParts = new ArrayList<>();\n+        String lastImport = null;\n+        boolean lastImportIsModuleImport = false;\n+        Wrap declarationWrap = null;\n+        Wrap pendingWrap = null;\n+        String input = code;\n+        boolean cont = true;\n+        int startOffset = 0;\n+\n+        while (cont) {\n+            if (lastImport != null) {\n+                imports.add(lastImport);\n+                lastImport = null;\n+            }\n+            if (declarationWrap != null) {\n+                declarationParts.add(declarationWrap);\n+                declarationWrap = null;\n+                pendingWrap = null;\n+            }\n+\n+            String current;\n+            SourceCodeAnalysis.CompletionInfo completeness = analyzeCompletion(input);\n+            int newStartOffset;\n+\n+            if (completeness.completeness().isComplete() && !completeness.remaining().isBlank()) {\n+                current = input.substring(0, input.length() - completeness.remaining().length());\n+                newStartOffset = startOffset + input.length() - completeness.remaining().length();\n+                input = completeness.remaining();\n+                cont = true;\n+            } else {\n+                current = input;\n+                cont = false;\n+                newStartOffset = startOffset;\n+            }\n+\n+            boolean[] moduleImport = new boolean[1];\n+\n+            switch (guessKind(current, moduleImport)) {\n+                case IMPORT -> {\n+                    lastImport = current;\n+                    lastImportIsModuleImport = moduleImport[0];\n+                }\n+                case CLASS, METHOD -> {\n+                    pendingWrap = declarationWrap = Wrap.classMemberWrap(whitespaces(code, startOffset) + current);\n+                }\n+                case VARIABLE -> {\n+                    declarationWrap = Wrap.classMemberWrap(whitespaces(code, startOffset) + current);\n+                    pendingWrap = Wrap.methodWrap(whitespaces(code, startOffset) + current);\n+                }\n+                default -> {\n+                    pendingWrap = declarationWrap = Wrap.methodWrap(whitespaces(code, startOffset) + current);\n+                }\n+            }\n+\n+            startOffset = newStartOffset;\n+        }\n+\n+        if (lastImport != null) {\n+            if (wrapImports) {\n+                return proc.outerMap.wrapImport(Wrap.simpleWrap(whitespaces(code, startOffset) + lastImport + (!lastImportIsModuleImport ? \"any.any\" : \"\")), null);\n+            } else {\n+                return null;\n+            }\n+        }\n+\n+        if (pendingWrap != null) {\n+            return proc.outerMap.wrapInTrialClass(imports, declarationParts, pendingWrap);\n+        }\n+\n+        throw new IllegalStateException(\"No pending wrap for: \" + code);\n+    }\n+\n+    private static String whitespaces(String input, int offset) {\n+        StringBuilder result = new StringBuilder();\n+\n+        for (int i = 0; i < offset; i++) {\n+            if (input.charAt(i) == '\\n') {\n+                result.append('\\n');\n+            } else {\n+                result.append(' ');\n+            }\n+        }\n+\n+        return result.toString();\n+    }\n+\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":99,"deletions":19,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -944,0 +944,10 @@\n+\n+    @Test\n+    public void testMultiSnippet() {\n+        assertCompletion(\"String s = \\\"\\\"; s.len|\", true, \"length()\");\n+        assertCompletion(\"String s() { return \\\"\\\"; } s().len|\", true, \"length()\");\n+        assertCompletion(\"String s() { return \\\"\\\"; } import java.util.List; List.o|\", true, \"of(\");\n+        assertCompletion(\"String s() { return \\\"\\\"; } import java.ut| \", true, \"util.\");\n+        assertCompletion(\"class S { public int length() { return 0; } } new S().len|\", true, \"length()\");\n+        assertSignature(\"void f() { } f(|\", \"void f()\");\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/CompletionSuggestionTest.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}