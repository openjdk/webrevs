{"files":[{"patch":"@@ -203,182 +203,0 @@\n-#ifndef PRODUCT\n-const char* PSParallelCompact::space_names[] = {\n-  \"old \", \"eden\", \"from\", \"to  \"\n-};\n-\n-void PSParallelCompact::print_region_ranges() {\n-  if (!log_develop_is_enabled(Trace, gc, compaction)) {\n-    return;\n-  }\n-  Log(gc, compaction) log;\n-  ResourceMark rm;\n-  LogStream ls(log.trace());\n-  Universe::print_on(&ls);\n-  log.trace(\"space  bottom     top        end        new_top\");\n-  log.trace(\"------ ---------- ---------- ---------- ----------\");\n-\n-  for (unsigned int id = 0; id < last_space_id; ++id) {\n-    const MutableSpace* space = _space_info[id].space();\n-    log.trace(\"%u %s \"\n-              SIZE_FORMAT_W(10) \" \" SIZE_FORMAT_W(10) \" \"\n-              SIZE_FORMAT_W(10) \" \" SIZE_FORMAT_W(10) \" \",\n-              id, space_names[id],\n-              summary_data().addr_to_region_idx(space->bottom()),\n-              summary_data().addr_to_region_idx(space->top()),\n-              summary_data().addr_to_region_idx(space->end()),\n-              summary_data().addr_to_region_idx(_space_info[id].new_top()));\n-  }\n-}\n-\n-static void\n-print_generic_summary_region(size_t i, const ParallelCompactData::RegionData* c)\n-{\n-#define REGION_IDX_FORMAT        SIZE_FORMAT_W(7)\n-#define REGION_DATA_FORMAT       SIZE_FORMAT_W(5)\n-\n-  ParallelCompactData& sd = PSParallelCompact::summary_data();\n-  size_t dci = c->destination() ? sd.addr_to_region_idx(c->destination()) : 0;\n-  log_develop_trace(gc, compaction)(\n-      REGION_IDX_FORMAT \" \"\n-      REGION_IDX_FORMAT \" \" PTR_FORMAT \" \"\n-      REGION_DATA_FORMAT \" \" REGION_DATA_FORMAT \" \"\n-      REGION_DATA_FORMAT \" \" REGION_IDX_FORMAT \" %d\",\n-      i, dci, p2i(c->destination()),\n-      c->partial_obj_size(), c->live_obj_size(),\n-      c->data_size(), c->source_region(), c->destination_count());\n-\n-#undef  REGION_IDX_FORMAT\n-#undef  REGION_DATA_FORMAT\n-}\n-\n-void\n-print_generic_summary_data(ParallelCompactData& summary_data,\n-                           HeapWord* const beg_addr,\n-                           HeapWord* const end_addr)\n-{\n-  size_t total_words = 0;\n-  size_t i = summary_data.addr_to_region_idx(beg_addr);\n-  const size_t last = summary_data.addr_to_region_idx(end_addr);\n-  HeapWord* pdest = 0;\n-\n-  while (i < last) {\n-    ParallelCompactData::RegionData* c = summary_data.region(i);\n-    if (c->data_size() != 0 || c->destination() != pdest) {\n-      print_generic_summary_region(i, c);\n-      total_words += c->data_size();\n-      pdest = c->destination();\n-    }\n-    ++i;\n-  }\n-\n-  log_develop_trace(gc, compaction)(\"summary_data_bytes=\" SIZE_FORMAT, total_words * HeapWordSize);\n-}\n-\n-void\n-PSParallelCompact::print_generic_summary_data(ParallelCompactData& summary_data,\n-                                              HeapWord* const beg_addr,\n-                                              HeapWord* const end_addr) {\n-  ::print_generic_summary_data(summary_data,beg_addr, end_addr);\n-}\n-\n-static void\n-print_initial_summary_data(ParallelCompactData& summary_data,\n-                           const MutableSpace* space) {\n-  if (space->top() == space->bottom()) {\n-    return;\n-  }\n-\n-  const size_t region_size = ParallelCompactData::RegionSize;\n-  typedef ParallelCompactData::RegionData RegionData;\n-  HeapWord* const top_aligned_up = summary_data.region_align_up(space->top());\n-  const size_t end_region = summary_data.addr_to_region_idx(top_aligned_up);\n-  const RegionData* c = summary_data.region(end_region - 1);\n-  HeapWord* end_addr = c->destination() + c->data_size();\n-  const size_t live_in_space = pointer_delta(end_addr, space->bottom());\n-\n-  \/\/ Print (and count) the full regions at the beginning of the space.\n-  size_t full_region_count = 0;\n-  size_t i = summary_data.addr_to_region_idx(space->bottom());\n-  while (i < end_region && summary_data.region(i)->data_size() == region_size) {\n-    ParallelCompactData::RegionData* c = summary_data.region(i);\n-    log_develop_trace(gc, compaction)(\n-        SIZE_FORMAT_W(5) \" \" PTR_FORMAT \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" %d\",\n-        i, p2i(c->destination()),\n-        c->partial_obj_size(), c->live_obj_size(),\n-        c->data_size(), c->source_region(), c->destination_count());\n-    ++full_region_count;\n-    ++i;\n-  }\n-\n-  size_t live_to_right = live_in_space - full_region_count * region_size;\n-\n-  double max_reclaimed_ratio = 0.0;\n-  size_t max_reclaimed_ratio_region = 0;\n-  size_t max_dead_to_right = 0;\n-  size_t max_live_to_right = 0;\n-\n-  \/\/ Print the 'reclaimed ratio' for regions while there is something live in\n-  \/\/ the region or to the right of it.  The remaining regions are empty (and\n-  \/\/ uninteresting), and computing the ratio will result in division by 0.\n-  while (i < end_region && live_to_right > 0) {\n-    c = summary_data.region(i);\n-    HeapWord* const region_addr = summary_data.region_to_addr(i);\n-    const size_t used_to_right = pointer_delta(space->top(), region_addr);\n-    const size_t dead_to_right = used_to_right - live_to_right;\n-    const double reclaimed_ratio = double(dead_to_right) \/ live_to_right;\n-\n-    if (reclaimed_ratio > max_reclaimed_ratio) {\n-            max_reclaimed_ratio = reclaimed_ratio;\n-            max_reclaimed_ratio_region = i;\n-            max_dead_to_right = dead_to_right;\n-            max_live_to_right = live_to_right;\n-    }\n-\n-    ParallelCompactData::RegionData* c = summary_data.region(i);\n-    log_develop_trace(gc, compaction)(\n-        SIZE_FORMAT_W(5) \" \" PTR_FORMAT \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" %d\"\n-        \"%12.10f \" SIZE_FORMAT_W(10) \" \" SIZE_FORMAT_W(10),\n-        i, p2i(c->destination()),\n-        c->partial_obj_size(), c->live_obj_size(),\n-        c->data_size(), c->source_region(), c->destination_count(),\n-        reclaimed_ratio, dead_to_right, live_to_right);\n-\n-\n-    live_to_right -= c->data_size();\n-    ++i;\n-  }\n-\n-  \/\/ Any remaining regions are empty.  Print one more if there is one.\n-  if (i < end_region) {\n-    ParallelCompactData::RegionData* c = summary_data.region(i);\n-    log_develop_trace(gc, compaction)(\n-        SIZE_FORMAT_W(5) \" \" PTR_FORMAT \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" \" SIZE_FORMAT_W(5) \" %d\",\n-         i, p2i(c->destination()),\n-         c->partial_obj_size(), c->live_obj_size(),\n-         c->data_size(), c->source_region(), c->destination_count());\n-  }\n-\n-  log_develop_trace(gc, compaction)(\"max:  \" SIZE_FORMAT_W(4) \" d2r=\" SIZE_FORMAT_W(10) \" l2r=\" SIZE_FORMAT_W(10) \" max_ratio=%14.12f\",\n-                                    max_reclaimed_ratio_region, max_dead_to_right, max_live_to_right, max_reclaimed_ratio);\n-}\n-\n-static void\n-print_initial_summary_data(ParallelCompactData& summary_data,\n-                           SpaceInfo* space_info) {\n-  if (!log_develop_is_enabled(Trace, gc, compaction)) {\n-    return;\n-  }\n-\n-  unsigned int id = PSParallelCompact::old_space_id;\n-  const MutableSpace* space;\n-  do {\n-    space = space_info[id].space();\n-    print_initial_summary_data(summary_data, space);\n-  } while (++id < PSParallelCompact::eden_space_id);\n-\n-  do {\n-    space = space_info[id].space();\n-    print_generic_summary_data(summary_data, space->bottom(), space->top());\n-  } while (++id < PSParallelCompact::last_space_id);\n-}\n-#endif  \/\/ #ifndef PRODUCT\n-\n@@ -1011,23 +829,0 @@\n-#ifndef PRODUCT\n-void PSParallelCompact::summary_phase_msg(SpaceId dst_space_id,\n-                                          HeapWord* dst_beg, HeapWord* dst_end,\n-                                          SpaceId src_space_id,\n-                                          HeapWord* src_beg, HeapWord* src_end)\n-{\n-  log_develop_trace(gc, compaction)(\n-      \"Summarizing %d [%s] into %d [%s]:  \"\n-      \"src=\" PTR_FORMAT \"-\" PTR_FORMAT \" \"\n-      SIZE_FORMAT \"-\" SIZE_FORMAT \" \"\n-      \"dst=\" PTR_FORMAT \"-\" PTR_FORMAT \" \"\n-      SIZE_FORMAT \"-\" SIZE_FORMAT,\n-      src_space_id, space_names[src_space_id],\n-      dst_space_id, space_names[dst_space_id],\n-      p2i(src_beg), p2i(src_end),\n-      _summary_data.addr_to_region_idx(src_beg),\n-      _summary_data.addr_to_region_idx(src_end),\n-      p2i(dst_beg), p2i(dst_end),\n-      _summary_data.addr_to_region_idx(dst_beg),\n-      _summary_data.addr_to_region_idx(dst_end));\n-}\n-#endif  \/\/ #ifndef PRODUCT\n-\n@@ -1117,2 +912,0 @@\n-    NOT_PRODUCT(summary_phase_msg(dst_space_id, *new_top_addr, dst_space_end,\n-                                  SpaceId(id), space->bottom(), space->top());)\n@@ -1146,3 +939,0 @@\n-      NOT_PRODUCT(summary_phase_msg(dst_space_id,\n-                                    space->bottom(), dst_space_end,\n-                                    SpaceId(id), next_src_addr, space->top());)\n@@ -1158,4 +948,0 @@\n-\n-  log_develop_trace(gc, compaction)(\"Summary_phase:  after final summarization\");\n-  NOT_PRODUCT(print_region_ranges());\n-  NOT_PRODUCT(print_initial_summary_data(_summary_data, _space_info));\n@@ -2129,2 +1915,0 @@\n-  bool issued_a_warning = false;\n-\n@@ -2137,1 +1921,0 @@\n-      issued_a_warning = true;\n@@ -2146,1 +1929,0 @@\n-      issued_a_warning = true;\n@@ -2149,4 +1931,0 @@\n-\n-  if (issued_a_warning) {\n-    print_region_ranges();\n-  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":0,"deletions":222,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -698,2 +698,0 @@\n-  friend class PSParallelCompactTest;\n-\n@@ -758,7 +756,0 @@\n-#ifndef PRODUCT\n-  \/\/ Print generic summary data\n-  static void print_generic_summary_data(ParallelCompactData& summary_data,\n-                                         HeapWord* const beg_addr,\n-                                         HeapWord* const end_addr);\n-#endif  \/\/ #ifndef PRODUCT\n-\n@@ -860,10 +851,0 @@\n-#ifndef PRODUCT\n-  \/\/ Debugging support.\n-  static const char* space_names[last_space_id];\n-  static void print_region_ranges();\n-  static void summary_phase_msg(SpaceId dst_space_id,\n-                                HeapWord* dst_beg, HeapWord* dst_end,\n-                                SpaceId src_space_id,\n-                                HeapWord* src_beg, HeapWord* src_end);\n-#endif  \/\/ #ifndef PRODUCT\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/parallel\/parMarkBitMap.inline.hpp\"\n-#include \"gc\/parallel\/psCompactionManager.inline.hpp\"\n-#include \"gc\/parallel\/psParallelCompact.hpp\"\n-#include \"unittest.hpp\"\n-\n-#ifndef PRODUCT\n-\n-class PSParallelCompactTest : public ::testing::Test {\n- public:\n-  static void print_generic_summary_data(ParallelCompactData& summary_data,\n-                                         HeapWord* const beg_addr,\n-                                         HeapWord* const end_addr) {\n-    PSParallelCompact::print_generic_summary_data(summary_data,\n-                                                  beg_addr, end_addr);\n-  }\n-};\n-\n-\/\/ @requires UseParallelGC\n-TEST_VM(PSParallelCompact, print_generic_summary_data) {\n-  if (!UseParallelGC) {\n-    return;\n-  }\n-  \/\/ Check that print_generic_summary_data() does not print the\n-  \/\/ end region by placing a bad value in the destination of the\n-  \/\/ end region.  The end region should not be printed because it\n-  \/\/ corresponds to the space after the end of the heap.\n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-  HeapWord* begin_heap =\n-    (HeapWord*) heap->old_gen()->virtual_space()->low_boundary();\n-  HeapWord* end_heap =\n-    (HeapWord*) heap->young_gen()->virtual_space()->high_boundary();\n-\n-  PSParallelCompactTest::print_generic_summary_data(PSParallelCompact::summary_data(),\n-    begin_heap, end_heap);\n-}\n-\n-#endif\n","filename":"test\/hotspot\/gtest\/gc\/parallel\/test_psParallelCompact.cpp","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"}]}