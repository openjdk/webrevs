{"files":[{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=static\n+ * @summary Run JavacBenchApp with the classic static archive workflow\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver JavacBench STATIC\n+ *\/\n+\n+\/*\n+ * @test id=dynamic\n+ * @summary Run JavacBenchApp with the classic dynamic archive workflow\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver JavacBench DYNAMIC\n+ *\/\n+\n+import jdk.test.lib.cds.CDSAppTester;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class JavacBench {\n+    static String mainClass = JavacBenchApp.class.getName();\n+    static String appJar;\n+\n+    public static void main(String args[]) throws Exception {\n+        appJar = ClassFileInstaller.writeJar(\"JavacBenchApp.jar\",\n+                                             \"JavacBenchApp\",\n+                                             \"JavacBenchApp$ClassFile\",\n+                                             \"JavacBenchApp$FileManager\",\n+                                             \"JavacBenchApp$SourceFile\");\n+        JavacBenchTester tester = new JavacBenchTester();\n+        tester.run(args);\n+    }\n+\n+    static class JavacBenchTester extends CDSAppTester {\n+        public JavacBenchTester() {\n+            super(\"JavacBench\");\n+        }\n+\n+        @Override\n+        public String classpath(RunMode runMode) {\n+            return appJar;\n+        }\n+\n+        @Override\n+        public String[] appCommandLine(RunMode runMode) {\n+            return new String[] {\n+                mainClass,\n+                \"90\",\n+            };\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/applications\/JavacBench.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,228 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import javax.tools.Diagnostic;\n+import javax.tools.DiagnosticCollector;\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+\/**\n+ * This program tries to compile a large number of classes that exercise a fair amount of\n+ * features in javac.\n+ *\/\n+public class JavacBenchApp {\n+    static class ClassFile extends SimpleJavaFileObject {\n+        private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        protected ClassFile(String name) {\n+            super(URI.create(\"memo:\/\/\/\" + name.replace('.', '\/') + Kind.CLASS.extension), Kind.CLASS);\n+        }\n+        @Override\n+        public ByteArrayOutputStream openOutputStream() {\n+            return this.baos;\n+        }\n+        byte[] toByteArray() {\n+            return baos.toByteArray();\n+        }\n+    }\n+\n+    static class FileManager extends ForwardingJavaFileManager<JavaFileManager> {\n+        private Map<String, ClassFile> classesMap = new HashMap<String, ClassFile>();\n+        protected FileManager(JavaFileManager fileManager) {\n+            super(fileManager);\n+        }\n+        @Override\n+        public ClassFile getJavaFileForOutput(Location location, String name, JavaFileObject.Kind kind, FileObject source) {\n+            ClassFile classFile = new ClassFile(name);\n+            classesMap.put(name, classFile);\n+            return classFile;\n+        }\n+        public Map<String, byte[]> getCompiledClasses() {\n+            Map<String, byte[]> result = new HashMap<>();\n+            for (Map.Entry<String, ClassFile> entry : classesMap.entrySet()) {\n+                result.put(entry.getKey(), entry.getValue().toByteArray());\n+            }\n+            return result;\n+        }\n+    }\n+\n+    static class SourceFile extends SimpleJavaFileObject {\n+        private CharSequence sourceCode;\n+        public SourceFile(String name, CharSequence sourceCode) {\n+            super(URI.create(\"memo:\/\/\/\" + name.replace('.', '\/') + Kind.SOURCE.extension), Kind.SOURCE);\n+            this.sourceCode = sourceCode;\n+        }\n+        @Override\n+        public CharSequence getCharContent(boolean ignore) {\n+            return this.sourceCode;\n+        }\n+    }\n+\n+    public Map<String, byte[]> compile() {\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        DiagnosticCollector<JavaFileObject> ds = new DiagnosticCollector<>();\n+        Collection<SourceFile> sourceFiles = sources;\n+\n+        try (FileManager fileManager = new FileManager(compiler.getStandardFileManager(ds, null, null))) {\n+            JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, null, null, null, sourceFiles);\n+            if (task.call()) {\n+                return fileManager.getCompiledClasses();\n+            } else {\n+                for (Diagnostic<? extends JavaFileObject> d : ds.getDiagnostics()) {\n+                    System.out.format(\"Line: %d, %s in %s\", d.getLineNumber(), d.getMessage(null), d.getSource().getName());\n+                }\n+                throw new InternalError(\"compilation failure\");\n+            }\n+        } catch (IOException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    List<SourceFile> sources;\n+\n+    static final String imports = \"\"\"\n+        import java.lang.*;\n+        import java.util.*;\n+        \"\"\";\n+\n+    static final String testClassBody = \"\"\"\n+        \/\/ Some comments\n+        static long x;\n+        static final long y;\n+        static {\n+            y = System.currentTimeMillis();\n+        }\n+        \/* More comments *\/\n+        @Deprecated\n+        String func() { return \"String \" + this + y; }\n+        public static void main(String args[]) {\n+            try {\n+                x = Long.parseLong(args[0]);\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+            }\n+            doit(() -> {\n+                System.out.println(\"Hello Lambda\");\n+                Thread.dumpStack();\n+            });\n+        }\n+        static List<String> list = List.of(\"1\", \"2\");\n+        class InnerClass1 {\n+            static final long yy = y;\n+        }\n+        static void doit(Runnable r) {\n+            for (var x : list) {\n+                r.run();\n+            }\n+        }\n+        static String patternMatch(String arg, Object o) {\n+            if (o instanceof String s) {\n+                return \"1234\";\n+            }\n+            final String b = \"B\";\n+            return switch (arg) {\n+                case \"A\" -> \"a\";\n+                case b   -> \"b\";\n+                default  -> \"c\";\n+            };\n+        }\n+        public sealed class SealedInnerClass {}\n+        public final class Foo extends SealedInnerClass {}\n+        enum Expression {\n+            ADDITION,\n+            SUBTRACTION,\n+            MULTIPLICATION,\n+            DIVISION\n+        }\n+        public record Point(int x, int y) {\n+            public Point(int x) {\n+                this(x, 0);\n+            }\n+        }\n+        \"\"\";\n+\n+    String sanitySource = \"\"\"\n+        public class Sanity implements java.util.concurrent.Callable<String> {\n+            public String call() {\n+                return \"this is a test\";\n+            }\n+        }\n+        \"\"\";\n+\n+    void setup(int count) {\n+        sources = new ArrayList<>(count);\n+        for (int i = 0; i < count; i++) {\n+            String source = imports + \"public class Test\" + i + \" {\" + testClassBody + \"}\";\n+            sources.add(new SourceFile(\"Test\" + i, source));\n+        }\n+\n+        sources.add(new SourceFile(\"Sanity\", sanitySource));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static void validate(byte[] sanityClassFile) throws Throwable {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        Class<?> cls = lookup.defineClass(sanityClassFile);\n+        Callable<String> obj = (Callable<String>)cls.getDeclaredConstructor().newInstance();\n+        String s = obj.call();\n+        if (!s.equals(\"this is a test\")) {\n+            throw new RuntimeException(\"Expected \\\"this is a test\\\", but got \\\"\" + s + \"\\\"\");\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Throwable {\n+        long started = System.currentTimeMillis();\n+        JavacBenchApp bench = new JavacBenchApp();\n+\n+        int count = 0;\n+        if (args.length > 0) {\n+            count = Integer.parseInt(args[0]);\n+            if (count >= 0) {\n+                bench.setup(count);\n+                Map<String, byte[]> allClasses = bench.compile();\n+                validate(allClasses.get(\"Sanity\"));\n+            }\n+        }\n+        if (System.getProperty(\"JavacBenchApp.silent\") == null) {\n+            \/\/ Set this property when running with \"perf stat\", etc\n+            long elapsed = System.currentTimeMillis() - started;\n+            System.out.println(\"Generated source code for \" + bench.sources.size() + \" classes and compiled them in \" + elapsed + \" ms\");\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/applications\/JavacBenchApp.java","additions":228,"deletions":0,"binary":false,"changes":228,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib;\n+\n+import java.util.ArrayList;\n+\n+public class StringArrayUtils {\n+    \/**\n+     * The various concat() functions in this class can be used for building\n+     * a command-line argument array for ProcessTools.createTestJavaProcessBuilder(),\n+     * etc. When some of the arguments are conditional, this is more convenient\n+     * than alternatives like ArrayList.\n+     *\n+     * Example:\n+     *\n+     * <pre>\n+     *     String args[] = StringArrayUtils.concat(\"-Xint\", \"-Xmx32m\");\n+     *     if (verbose) {\n+     *         args = StringArrayUtils.concat(args, \"-verbose\");\n+     *     }\n+     *     args = StringArrayUtils.concat(args, \"HelloWorld\");\n+     *     ProcessTools.createTestJavaProcessBuilder(args);\n+     * <\/pre>\n+     *\/\n+    public static String[] concat(String... args) {\n+        return args;\n+    }\n+\n+    public static String[] concat(String[] prefix, String... extra) {\n+        String[] ret = new String[prefix.length + extra.length];\n+        System.arraycopy(prefix, 0, ret, 0, prefix.length);\n+        System.arraycopy(extra, 0, ret, prefix.length, extra.length);\n+        return ret;\n+    }\n+\n+    public static String[] concat(String prefix, String[] extra) {\n+        String[] ret = new String[1 + extra.length];\n+        ret[0] = prefix;\n+        System.arraycopy(extra, 0, ret, 1, extra.length);\n+        return ret;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/StringArrayUtils.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.cds;\n+\n+import java.io.File;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.StringArrayUtils;\n+\n+\/*\n+ * This is a base class used for testing CDS functionalities with complex applications.\n+ * You can define the application by overridding the vmArgs(), classpath() and appCommandLine()\n+ * methods. Application-specific validation checks can be implemented with checkExecution().\n+*\/\n+abstract public class CDSAppTester {\n+    private enum Workflow {\n+        STATIC,        \/\/ classic -Xshare:dump workflow\n+        DYNAMIC,       \/\/ classic -XX:ArchiveClassesAtExit\n+    }\n+\n+    public enum RunMode {\n+        CLASSLIST,\n+        DUMP_STATIC,\n+        DUMP_DYNAMIC,\n+        PRODUCTION;\n+\n+        public boolean isStaticDump() {\n+            return this == DUMP_STATIC;\n+        }\n+        public boolean isProductionRun() {\n+            return this == PRODUCTION;\n+        }\n+    }\n+\n+    public final String name() {\n+        return this.name;\n+    }\n+\n+    \/\/ optional\n+    public String[] vmArgs(RunMode runMode) {\n+        return new String[0];\n+    }\n+\n+    \/\/ optional\n+    public String classpath(RunMode runMode) {\n+        return null;\n+    }\n+\n+    \/\/ must override\n+    \/\/ main class, followed by arguments to the main class\n+    abstract public String[] appCommandLine(RunMode runMode);\n+\n+    \/\/ optional\n+    public void checkExecution(OutputAnalyzer out, RunMode runMode) throws Exception {}\n+\n+    private Workflow workflow;\n+\n+    public final boolean isStaticWorkflow() {\n+        return workflow == Workflow.STATIC;\n+    }\n+\n+    public final boolean isDynamicWorkflow() {\n+        return workflow == Workflow.DYNAMIC;\n+    }\n+\n+    private String classListLog() {\n+        return \"-Xlog:class+load=debug:file=\" + classListFile + \".log\";\n+    }\n+    private String staticDumpLog() {\n+        return \"-Xlog:cds=debug,cds+class=debug,cds+heap=warning,cds+resolve=debug:file=\" + staticArchiveFile + \".log::filesize=0\";\n+    }\n+    private String dynamicDumpLog() {\n+        return \"-Xlog:cds=debug,cds+class=debug,cds+resolve=debug,class+load=debug:file=\" + dynamicArchiveFile + \".log::filesize=0\";\n+    }\n+\n+    private final String name;\n+    private final String classListFile;\n+    private final String staticArchiveFile;\n+    private final String dynamicArchiveFile;\n+\n+    private String productionRunLog() {\n+        return \"-Xlog:cds:file=\" + name() + \".production.log::filesize=0\";\n+    }\n+\n+    public CDSAppTester(String name) {\n+        \/\/ Old workflow\n+        this.name = name;\n+        classListFile = name() + \".classlist\";\n+        staticArchiveFile = name() + \".static.jsa\";\n+        dynamicArchiveFile = name() + \".dynamic.jsa\";\n+    }\n+\n+    private void listOutputFile(String file) {\n+        File f = new File(file);\n+        if (f.exists()) {\n+            System.out.println(\"[output file: \" + file + \" \" + f.length() + \" bytes]\");\n+        } else {\n+            System.out.println(\"[output file: \" + file + \" does not exist]\");\n+        }\n+    }\n+\n+    private void checkExecutionHelper(OutputAnalyzer output, RunMode runMode) throws Exception {\n+        output.shouldHaveExitValue(0);\n+        CDSTestUtils.checkCommonExecExceptions(output);\n+        checkExecution(output, runMode);\n+    }\n+\n+    private OutputAnalyzer createClassList() throws Exception {\n+        RunMode runMode = RunMode.CLASSLIST;\n+        String[] cmdLine = StringArrayUtils.concat(vmArgs(runMode), classListLog(),\n+                                                   \"-Xshare:off\",\n+                                                   \"-XX:DumpLoadedClassList=\" + classListFile,\n+                                                   \"-cp\", classpath(runMode));\n+        cmdLine = StringArrayUtils.concat(cmdLine, appCommandLine(runMode));\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(cmdLine);\n+        Process process = pb.start();\n+        OutputAnalyzer output = CDSTestUtils.executeAndLog(process, \"classlist\");\n+        listOutputFile(classListFile);\n+        listOutputFile(classListFile + \".log\");\n+        checkExecutionHelper(output, runMode);\n+        return output;\n+    }\n+\n+    private OutputAnalyzer dumpStaticArchive() throws Exception {\n+        RunMode runMode = RunMode.DUMP_STATIC;\n+        String[] cmdLine = StringArrayUtils.concat(vmArgs(runMode), staticDumpLog(),\n+                                                   \"-Xlog:cds\",\n+                                                   \"-Xlog:cds+heap=error\",\n+                                                   \"-Xshare:dump\",\n+                                                   \"-XX:SharedArchiveFile=\" + staticArchiveFile,\n+                                                   \"-XX:SharedClassListFile=\" + classListFile,\n+                                                   \"-cp\", classpath(runMode));\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(cmdLine);\n+        Process process = pb.start();\n+        OutputAnalyzer output = CDSTestUtils.executeAndLog(process, \"static\");\n+        listOutputFile(staticArchiveFile);\n+        listOutputFile(staticArchiveFile + \".log\");\n+        checkExecutionHelper(output, runMode);\n+        return output;\n+    }\n+\n+    private OutputAnalyzer dumpDynamicArchive() throws Exception {\n+        RunMode runMode = RunMode.DUMP_DYNAMIC;\n+        String[] cmdLine = new String[0];\n+        if (isDynamicWorkflow()) {\n+          \/\/ \"classic\" dynamic archive\n+          cmdLine = StringArrayUtils.concat(vmArgs(runMode), dynamicDumpLog(),\n+                                            \"-Xlog:cds\",\n+                                            \"-XX:ArchiveClassesAtExit=\" + dynamicArchiveFile,\n+                                            \"-cp\", classpath(runMode));\n+        }\n+        cmdLine = StringArrayUtils.concat(cmdLine, appCommandLine(runMode));\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(cmdLine);\n+        Process process = pb.start();\n+        OutputAnalyzer output = CDSTestUtils.executeAndLog(process, \"dynamic\");\n+        listOutputFile(dynamicArchiveFile);\n+        listOutputFile(dynamicArchiveFile + \".log\");\n+        checkExecutionHelper(output, runMode);\n+        return output;\n+    }\n+\n+    private OutputAnalyzer productionRun() throws Exception {\n+        RunMode runMode = RunMode.PRODUCTION;\n+        String[] cmdLine = StringArrayUtils.concat(vmArgs(runMode), productionRunLog(),\n+                                                   \"-cp\", classpath(runMode));\n+        if (isStaticWorkflow()) {\n+            cmdLine = StringArrayUtils.concat(cmdLine, \"-XX:SharedArchiveFile=\" + staticArchiveFile);\n+        } else if (isDynamicWorkflow()) {\n+            cmdLine = StringArrayUtils.concat(cmdLine, \"-XX:SharedArchiveFile=\" + dynamicArchiveFile);\n+        }\n+\n+        cmdLine = StringArrayUtils.concat(cmdLine, appCommandLine(runMode));\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(cmdLine);\n+        Process process = pb.start();\n+        OutputAnalyzer output = CDSTestUtils.executeAndLog(process, \"production\");\n+        listOutputFile(name() + \".production.log\");\n+        checkExecutionHelper(output, runMode);\n+        return output;\n+    }\n+\n+    public void run(String args[]) throws Exception {\n+        String err = \"Must have exactly one command line argument: STATIC or DYNAMIC\";\n+        if (args.length != 1) {\n+            throw new RuntimeException(err);\n+        } else {\n+            if (args[0].equals(\"STATIC\")) {\n+                runStaticWorkflow();\n+            } else if (args[0].equals(\"DYNAMIC\")) {\n+                runDynamicWorkflow();\n+            } else {\n+                throw new RuntimeException(err);\n+            }\n+        }\n+    }\n+\n+    private void runStaticWorkflow() throws Exception {\n+        this.workflow = Workflow.STATIC;\n+        createClassList();\n+        dumpStaticArchive();\n+        productionRun();\n+    }\n+\n+    private void runDynamicWorkflow() throws Exception {\n+        this.workflow = Workflow.DYNAMIC;\n+        dumpDynamicArchive();\n+        productionRun();\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSAppTester.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"}]}