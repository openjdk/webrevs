{"files":[{"patch":"@@ -197,0 +197,5 @@\n+    \/**\n+     * A table to hold the access flags of the method parameters.\n+     *\/\n+    int[] parameterAccessFlags;\n+\n@@ -1059,0 +1064,1 @@\n+                        parameterAccessFlags = new int[numEntries];\n@@ -1067,1 +1073,3 @@\n-                            parameterNameIndices[index++] = nameIndex;\n+                            parameterNameIndices[index] = nameIndex;\n+                            parameterAccessFlags[index] = flags;\n+                            index++;\n@@ -2383,0 +2391,1 @@\n+        parameterAccessFlags = null;\n@@ -2392,0 +2401,4 @@\n+        if (parameterAccessFlags != null && index < parameterAccessFlags.length\n+                && parameterAccessFlags[index] != 0) {\n+            flags |= parameterAccessFlags[index];\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8226216\n+ * @summary parameter modifiers are not visible to javac plugins across compilation boundaries\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ParameterModifiersAcrossCompilationBoundaries\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.nio.file.Path;\n+\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+\n+public class ParameterModifiersAcrossCompilationBoundaries extends TestRunner {\n+    ToolBox tb;\n+\n+    String moduleCode = \"\"\"\n+                module P {\n+                    requires transitive jdk.compiler;\n+                    provides com.sun.source.util.Plugin with p.P;\n+                }\n+                \"\"\";\n+\n+    String pluginCode = \"\"\"\n+                package p;\n+\n+                import com.sun.source.util.JavacTask;\n+                import com.sun.source.util.Plugin;\n+                import com.sun.source.util.TaskEvent;\n+                import com.sun.source.util.TaskListener;\n+\n+                import javax.lang.model.element.Element;\n+                import javax.lang.model.element.ExecutableElement;\n+                import javax.lang.model.element.TypeElement;\n+                import javax.lang.model.element.VariableElement;\n+                import javax.lang.model.util.Elements;\n+\n+                public class P implements Plugin {\n+\n+                    @Override\n+                    public String getName() {\n+                        return \"P\";\n+                    }\n+\n+                    @Override\n+                    public void init(JavacTask javacTask, String... strings) {\n+                        javacTask.addTaskListener(\n+                                new TaskListener() {\n+                                    @Override\n+                                    public void finished(TaskEvent e) {\n+                                        if (e.getKind() != TaskEvent.Kind.ENTER) {\n+                                            return;\n+                                        }\n+                                        Elements elements = javacTask.getElements();\n+                                        TypeElement typeElement = elements.getTypeElement(\"B\");\n+                                        for (Element m : typeElement.getEnclosedElements()) {\n+                                            if (m instanceof ExecutableElement) {\n+                                                for (VariableElement p : ((ExecutableElement) m).getParameters()) {\n+                                                    System.err.println(p.getSimpleName() + \" \" + p.getModifiers());\n+                                                }\n+                                            }\n+                                        }\n+                                    }\n+                                });\n+                    }\n+                }\n+                \"\"\";\n+\n+    String aCode = \"\"\"\n+            public class A { }\n+            \"\"\";\n+\n+    String bCode = \"\"\"\n+            public class B {\n+                void f(final int x) {\n+                }\n+            }\n+            \"\"\";\n+\n+    public ParameterModifiersAcrossCompilationBoundaries() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        var t = new ParameterModifiersAcrossCompilationBoundaries();\n+        t.runTests();\n+    }\n+\n+    @Test\n+    public void testParameterModifiersNotVisible() throws Exception {\n+        Path base = Path.of(\".\");\n+        Path pluginPath = base.resolve(\"plugin\");\n+        Path testPath = base.resolve(\"test\");\n+        tb.writeFile(pluginPath.resolve(\"p\").resolve(\"P.java\"), pluginCode);\n+        tb.writeFile(pluginPath.resolve(\"module-info.java\"), moduleCode);\n+        tb.writeFile(testPath.resolve(\"A.java\"), aCode);\n+        tb.writeFile(testPath.resolve(\"B.java\"), bCode);\n+\n+        new JavacTask(tb)\n+                .files(\"plugin\/module-info.java\", \"plugin\/p\/P.java\")\n+                .run()\n+                .writeAll();\n+\n+        List<String> firstOutput = new JavacTask(tb)\n+                .options(\"--processor-module-path\", \"plugin\", \"-Xplugin:P\",\n+                         \"-parameters\")\n+                .files(\"test\/A.java\", \"test\/B.java\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDERR);\n+        List<String> firstExpected = Arrays.asList(\"x [final]\", \"x [final]\");\n+        tb.checkEqual(firstExpected, firstOutput);\n+\n+        List<String> secondOutput = new JavacTask(tb)\n+                .options(\"--processor-module-path\", \"plugin\", \"-Xplugin:P\",\n+                         \"-parameters\", \"-classpath\", \"test\")\n+                .files(\"test\/B.java\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDERR);\n+        List<String> secondExpected = Arrays.asList(\"x [final]\");\n+        tb.checkEqual(secondExpected, secondOutput);\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/classreader\/ParameterModifiersAcrossCompilationBoundaries.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"}]}