{"files":[{"patch":"@@ -196,0 +196,54 @@\n+    static String scale2(long value) {\n+        long valueAbs = Math.abs(value);\n+        long highInt = valueAbs \/ 100;\n+        byte[] buf = new byte[Long.stringSize(highInt) + (value < 0 ? 4 : 3)];\n+        int p = buf.length - 2;\n+        writeDigitPair(buf, p, (int) (valueAbs % 100));\n+        buf[--p] = '.';\n+        getChars(highInt, p, buf);\n+        if (value < 0) {\n+            buf[0] = '-';\n+        }\n+        if (String.COMPACT_STRINGS) {\n+            return new String(buf, LATIN1);\n+        }\n+        return new String(inflate(buf, 0, buf.length), UTF16);\n+    }\n+\n+    static String scale(int value, int scale) {\n+        int valueAbs = Math.abs(value);\n+        int coeffLen = 1;\n+        int power = 10;\n+        for (int p = 10; p <= valueAbs && coeffLen < 10; p *= 10, coeffLen++) {\n+            if (coeffLen == scale) {\n+                power = p;\n+            }\n+        }\n+\n+        int fillZeros = scale - coeffLen; \/\/ Insert decimal point\n+        byte[] buf;\n+        if (fillZeros < 0) {              \/\/ Point goes inside intVal\n+            buf = new byte[coeffLen + (value < 0 ? 2 : 1)];\n+            int p = getChars(power + valueAbs % power, buf.length, buf);\n+            buf[p] = '.';\n+            getChars(valueAbs \/ power, p, buf);\n+        } else {\n+            \/\/ We must insert zeros between point and intVal\n+            buf = new byte[coeffLen + fillZeros + (value < 0 ? 3 : 2)];\n+            int p = getChars(valueAbs, buf.length, buf);\n+            for (int i = 0; i < fillZeros; i++) {\n+                buf[--p] = '0';\n+            }\n+            buf[p - 1] = '.';\n+            buf[p - 2] = '0';\n+        }\n+        if (value < 0) {\n+            buf[0] = '-';\n+        }\n+\n+        if (String.COMPACT_STRINGS) {\n+            return new String(buf, LATIN1);\n+        }\n+        return new String(inflate(buf, 0, buf.length), UTF16);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2506,0 +2506,8 @@\n+            public String scale(int i, int scale) {\n+                return StringLatin1.scale(i, scale);\n+            }\n+\n+            public String scale2(long i) {\n+                return StringLatin1.scale2(i);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n@@ -41,0 +42,3 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n@@ -282,1 +286,1 @@\n- *\n+\n@@ -295,21 +299,0 @@\n- * <h2><a id=algorithmicComplexity>Algorithmic Complexity<\/a><\/h2>\n- *\n- * Operations on {@code BigDecimal} values have a range of algorithmic\n- * complexities; in general, those complexities are a function of both\n- * the size of the unscaled value as well as the size of the\n- * scale. For example, an {@linkplain BigDecimal#multiply(BigDecimal)\n- * exact multiply} of two {@code BigDecimal} values is subject to the\n- * same {@linkplain BigInteger##algorithmicComplexity complexity\n- * constraints} as {@code BigInteger} multiply of the unscaled\n- * values. In contrast, a {@code BigDecimal} value with a compact\n- * representation like {@code new BigDecimal(1E-1000000000)} has a\n- * {@link toPlainString} result with over one billion characters.\n- *\n- * <p>Operations may also allocate and compute on intermediate\n- * results, potentially those allocations may be as large as in\n- * proportion to the running time of the algorithm.\n- *\n- * <p>Users of {@code BigDecimal} concerned with bounding the running\n- * time or space of operations can screen out {@code BigDecimal}\n- * values with unscaled values or scales above a chosen magnitude.\n- *\n@@ -331,0 +314,1 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n@@ -3494,9 +3478,12 @@\n-        if(scale==0) {\n-            if(intCompact!=INFLATED) {\n-                return Long.toString(intCompact);\n-            } else {\n-                return intVal.toString();\n-            }\n-        }\n-        if(this.scale<0) { \/\/ No decimal point\n-            if(signum()==0) {\n+        int scale = this.scale;\n+        long intCompact = this.intCompact;\n+\n+        if (scale == 0)\n+            return unscaledString();\n+        \/\/ currency fast path\n+        if (scale == 2 && intCompact != INFLATED)\n+            return JLA.scale2(intCompact);\n+\n+        int signum = signum();\n+        if (this.scale < 0) { \/\/ No decimal point\n+            if (signum == 0)\n@@ -3504,1 +3491,1 @@\n-            }\n+\n@@ -3506,6 +3493,16 @@\n-            String str = intCompact != INFLATED\n-                ? Long.toString(intCompact)\n-                : intVal.toString();\n-            int len = str.length() + trailingZeros;\n-            if (len < 0) {\n-                throw new OutOfMemoryError(\"too large to fit in a String\");\n+            StringBuilder buf;\n+            if (intCompact != INFLATED) {\n+                int initSize = 20 + trailingZeros;\n+                if (initSize < 0) {\n+                    throw new OutOfMemoryError(\"too large to fit in a String\");\n+                }\n+                buf = new StringBuilder(initSize)\n+                        .append(intCompact);\n+            } else {\n+                String str = intVal.toString();\n+                int initSize = str.length() + trailingZeros;\n+                if (initSize < 0) {\n+                    throw new OutOfMemoryError(\"too large to fit in a String\");\n+                }\n+                buf = new StringBuilder(initSize)\n+                        .append(str);\n@@ -3513,4 +3510,2 @@\n-            StringBuilder buf = new StringBuilder(len);\n-            buf.append(str);\n-            buf.repeat('0', trailingZeros);\n-            return buf.toString();\n+            return buf.repeat('0', trailingZeros)\n+                    .toString();\n@@ -3518,7 +3513,8 @@\n-        String str;\n-        if(intCompact!=INFLATED) {\n-            str = Long.toString(Math.abs(intCompact));\n-        } else {\n-            str = intVal.abs().toString();\n-        }\n-        return getValueString(signum(), str, scale);\n+\n+        if (intCompact != INFLATED\n+                && intCompact >= Integer.MIN_VALUE\n+                && intCompact <= Integer.MAX_VALUE\n+                && scale < 512)\n+            return JLA.scale((int) intCompact, scale);\n+\n+        return getValueString(signum, unscaledAbsString(), scale);\n@@ -3527,1 +3523,7 @@\n-    \/* Returns a digit.digit string *\/\n+    \/**\n+     * Returns a string representation without an exponent field.\n+     *\n+     * @param signum the signum of {@code BigDecimal}.\n+     * @param intString the significand as an absolute value\n+     * @param scale the scale of this {@code BigDecimal}.\n+     *\/\n@@ -3532,2 +3534,2 @@\n-        if (insertionPoint == 0) {  \/* Point goes just before intVal *\/\n-            return (signum<0 ? \"-0.\" : \"0.\") + intString;\n+        if (insertionPoint == 0) { \/* Point goes just before intVal *\/\n+            return (signum < 0 ? \"-0.\" : \"0.\").concat(intString);\n@@ -3535,2 +3537,1 @@\n-            buf = new StringBuilder(intString);\n-            buf.insert(insertionPoint, '.');\n+            buf = new StringBuilder();\n@@ -3538,1 +3539,3 @@\n-                buf.insert(0, '-');\n+                buf.append('-');\n+            buf.append(intString)\n+               .insert(insertionPoint + (signum < 0 ? 1 : 0), '.');\n@@ -3544,4 +3547,4 @@\n-            buf = new StringBuilder(len);\n-            buf.append(signum<0 ? \"-0.\" : \"0.\");\n-            buf.repeat('0', -insertionPoint);  \/\/ insertionPoint != MIN_VALUE\n-            buf.append(intString);\n+            buf = new StringBuilder(len)\n+                    .append(signum < 0 ? \"-0.\" : \"0.\")\n+                    .repeat('0', -insertionPoint)\n+                    .append(intString);\n@@ -4171,97 +4174,0 @@\n-    \/\/ Private class to build a string representation for BigDecimal object. The\n-    \/\/ StringBuilder field acts as a buffer to hold the temporary representation\n-    \/\/ of BigDecimal. The cmpCharArray holds all the characters for the compact\n-    \/\/ representation of BigDecimal (except for '-' sign' if it is negative) if\n-    \/\/ its intCompact field is not INFLATED.\n-    static class StringBuilderHelper {\n-        final StringBuilder sb;    \/\/ Placeholder for BigDecimal string\n-        final char[] cmpCharArray; \/\/ character array to place the intCompact\n-\n-        StringBuilderHelper() {\n-            sb = new StringBuilder(32);\n-            \/\/ All non negative longs can be made to fit into 19 character array.\n-            cmpCharArray = new char[19];\n-        }\n-\n-        \/\/ Accessors.\n-        StringBuilder getStringBuilder() {\n-            sb.setLength(0);\n-            return sb;\n-        }\n-\n-        char[] getCompactCharArray() {\n-            return cmpCharArray;\n-        }\n-\n-        \/**\n-         * Places characters representing the intCompact in {@code long} into\n-         * cmpCharArray and returns the offset to the array where the\n-         * representation starts.\n-         *\n-         * @param intCompact the number to put into the cmpCharArray.\n-         * @return offset to the array where the representation starts.\n-         * Note: intCompact must be greater or equal to zero.\n-         *\/\n-        int putIntCompact(long intCompact) {\n-            assert intCompact >= 0;\n-\n-            long q;\n-            int r;\n-            \/\/ since we start from the least significant digit, charPos points to\n-            \/\/ the last character in cmpCharArray.\n-            int charPos = cmpCharArray.length;\n-\n-            \/\/ Get 2 digits\/iteration using longs until quotient fits into an int\n-            while (intCompact > Integer.MAX_VALUE) {\n-                q = intCompact \/ 100;\n-                r = (int)(intCompact - q * 100);\n-                intCompact = q;\n-                cmpCharArray[--charPos] = DIGIT_ONES[r];\n-                cmpCharArray[--charPos] = DIGIT_TENS[r];\n-            }\n-\n-            \/\/ Get 2 digits\/iteration using ints when i2 >= 100\n-            int q2;\n-            int i2 = (int)intCompact;\n-            while (i2 >= 100) {\n-                q2 = i2 \/ 100;\n-                r  = i2 - q2 * 100;\n-                i2 = q2;\n-                cmpCharArray[--charPos] = DIGIT_ONES[r];\n-                cmpCharArray[--charPos] = DIGIT_TENS[r];\n-            }\n-\n-            cmpCharArray[--charPos] = DIGIT_ONES[i2];\n-            if (i2 >= 10)\n-                cmpCharArray[--charPos] = DIGIT_TENS[i2];\n-\n-            return charPos;\n-        }\n-\n-        static final char[] DIGIT_TENS = {\n-            '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',\n-            '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',\n-            '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',\n-            '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',\n-            '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',\n-            '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',\n-            '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',\n-            '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',\n-            '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',\n-            '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',\n-        };\n-\n-        static final char[] DIGIT_ONES = {\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n-        };\n-    }\n-\n@@ -4278,0 +4184,2 @@\n+        int scale = this.scale;\n+        long intCompact = this.intCompact;\n@@ -4279,5 +4187,2 @@\n-            return (intCompact != INFLATED) ?\n-                Long.toString(intCompact):\n-                intVal.toString();\n-        if (scale == 2  &&\n-            intCompact >= 0 && intCompact < Integer.MAX_VALUE) {\n+            return unscaledString();\n+        if (intCompact != INFLATED) {\n@@ -4285,5 +4190,5 @@\n-            int lowInt = (int)intCompact % 100;\n-            int highInt = (int)intCompact \/ 100;\n-            return (Integer.toString(highInt) + '.' +\n-                    StringBuilderHelper.DIGIT_TENS[lowInt] +\n-                    StringBuilderHelper.DIGIT_ONES[lowInt]) ;\n+            if (scale == 2)\n+                return JLA.scale2(intCompact);\n+\n+            if (scale > 0 && scale <= 6 && intCompact >= Integer.MIN_VALUE && intCompact <= Integer.MAX_VALUE)\n+                return JLA.scale((int) intCompact, scale);\n@@ -4292,3 +4197,0 @@\n-        StringBuilderHelper sbHelper = new StringBuilderHelper();\n-        char[] coeff;\n-        int offset;  \/\/ offset is the starting index for coeff array\n@@ -4296,7 +4198,1 @@\n-        if (intCompact != INFLATED) {\n-            offset = sbHelper.putIntCompact(Math.abs(intCompact));\n-            coeff  = sbHelper.getCompactCharArray();\n-        } else {\n-            offset = 0;\n-            coeff  = intVal.abs().toString().toCharArray();\n-        }\n+        String coeff = unscaledAbsString();\n@@ -4308,4 +4204,1 @@\n-        StringBuilder buf = sbHelper.getStringBuilder();\n-        if (signum() < 0)             \/\/ prefix '-' if negative\n-            buf.append('-');\n-        int coeffLen = coeff.length - offset;\n+        int coeffLen = coeff.length();\n@@ -4314,12 +4207,16 @@\n-            int pad = scale - coeffLen;         \/\/ count of padding zeros\n-            if (pad >= 0) {                     \/\/ 0.xxx form\n-                buf.append('0');\n-                buf.append('.');\n-                for (; pad>0; pad--) {\n-                    buf.append('0');\n-                }\n-                buf.append(coeff, offset, coeffLen);\n-            } else {                         \/\/ xx.xx form\n-                buf.append(coeff, offset, -pad);\n-                buf.append('.');\n-                buf.append(coeff, -pad + offset, scale);\n+            return getValueString(signum(), coeff, scale);\n+        }\n+        \/\/ E-notation is needed\n+        return layoutCharsE(sci, coeff, coeffLen, adjusted);\n+    }\n+\n+    private String layoutCharsE(boolean sci, String coeff, int coeffLen, long adjusted) {\n+        StringBuilder buf = new StringBuilder(32);\n+        int signum = signum();\n+        if (signum < 0)                  \/\/ prefix '-' if negative\n+            buf.append('-');\n+        if (sci) {                       \/\/ Scientific notation\n+            buf.append(coeff.charAt(0)); \/\/ first character\n+            if (coeffLen > 1) {          \/\/ more to come\n+                buf.append('.')\n+                   .append(coeff, 1, coeffLen);\n@@ -4327,15 +4224,8 @@\n-        } else { \/\/ E-notation is needed\n-            if (sci) {                       \/\/ Scientific notation\n-                buf.append(coeff[offset]);   \/\/ first character\n-                if (coeffLen > 1) {          \/\/ more to come\n-                    buf.append('.');\n-                    buf.append(coeff, offset + 1, coeffLen - 1);\n-                }\n-            } else {                         \/\/ Engineering notation\n-                int sig = (int)(adjusted % 3);\n-                if (sig < 0)\n-                    sig += 3;                \/\/ [adjusted was negative]\n-                adjusted -= sig;             \/\/ now a multiple of 3\n-                sig++;\n-                if (signum() == 0) {\n-                    switch (sig) {\n+        } else {                         \/\/ Engineering notation\n+            int sig = (int)(adjusted % 3);\n+            if (sig < 0)\n+                sig += 3;                \/\/ [adjusted was negative]\n+            adjusted -= sig;             \/\/ now a multiple of 3\n+            sig++;\n+            if (signum == 0) {\n+                switch (sig) {\n@@ -4355,11 +4245,0 @@\n-                    }\n-                } else if (sig >= coeffLen) {   \/\/ significand all in integer\n-                    buf.append(coeff, offset, coeffLen);\n-                    \/\/ may need some zeros, too\n-                    for (int i = sig - coeffLen; i > 0; i--) {\n-                        buf.append('0');\n-                    }\n-                } else {                     \/\/ xx.xxE form\n-                    buf.append(coeff, offset, sig);\n-                    buf.append('.');\n-                    buf.append(coeff, offset + sig, coeffLen - sig);\n@@ -4367,6 +4246,7 @@\n-            }\n-            if (adjusted != 0) {             \/\/ [!sci could have made 0]\n-                buf.append('E');\n-                if (adjusted > 0)            \/\/ force sign for positive\n-                    buf.append('+');\n-                buf.append(adjusted);\n+            } else if (sig >= coeffLen) {\/\/ significand all in integer\n+                buf.append(coeff, 0, coeffLen)\n+                   .repeat('0', sig - coeffLen); \/\/ may need some zeros, too\n+            } else {                     \/\/ xx.xxE form\n+                buf.append(coeff, 0, sig)\n+                   .append('.')\n+                   .append(coeff, sig, coeffLen);\n@@ -4375,0 +4255,6 @@\n+        if (adjusted != 0) {             \/\/ [!sci could have made 0]\n+            buf.append('E');\n+            if (adjusted > 0)            \/\/ force sign for positive\n+                buf.append('+');\n+            buf.append(adjusted);\n+        }\n@@ -4378,0 +4264,15 @@\n+    \/**\n+     * Get the significand as an absolute value\n+     *\/\n+    private String unscaledAbsString() {\n+        return intCompact != INFLATED\n+                ? Long.toString(Math.abs(intCompact))\n+                : intVal.abs().toString();\n+    }\n+\n+    private String unscaledString() {\n+        return intCompact != INFLATED\n+                ? Long.toString(intCompact)\n+                : intVal.toString();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":125,"deletions":224,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -394,0 +394,4 @@\n+    String scale(int i, int scale);\n+\n+    String scale2(long i);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,0 +129,19 @@\n+        String str = new StringBuilder().repeat('1', 100).toString();\n+        int[] scales = new int[]{\n+                Integer.MIN_VALUE,\n+                Integer.MIN_VALUE + 1,\n+                Integer.MAX_VALUE - 1,\n+                Integer.MAX_VALUE\n+        };\n+        for (int scale : scales) {\n+            try {\n+                new BigDecimal(\n+                        new BigInteger(str),\n+                        scale\n+                ).toPlainString();\n+                errors++;\n+            } catch (OutOfMemoryError | ArithmeticException ignored) {\n+                \/\/ ignored\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/math\/BigDecimal\/ToPlainStringTests.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All rights reserved.\n@@ -38,0 +39,1 @@\n+import java.lang.invoke.*;\n@@ -48,1 +50,1 @@\n-@Fork(value = 3)\n+@Fork(value = 3, jvmArgsAppend = {\"--add-opens\", \"java.base\/java.math=ALL-UNNAMED\"})\n@@ -63,1 +65,3 @@\n-    private BigDecimal[] hugeArray, largeArray, smallArray;\n+    private BigDecimal[] hugeArray;\n+    private BigDecimal[] large2Array, small2Array;\n+    private BigDecimal[] large3Array, small3Array;\n@@ -99,3 +103,4 @@\n-        * Large numbers less than MAX_LONG but larger than MAX_INT\n-        *\/\n-        largeArray = new BigDecimal[TEST_SIZE];\n+         * Large numbers less than MAX_LONG but larger than MAX_INT\n+         *\/\n+        large2Array = new BigDecimal[TEST_SIZE];\n+        large3Array = new BigDecimal[TEST_SIZE];\n@@ -104,3 +109,4 @@\n-        * Small number less than MAX_INT\n-        *\/\n-        smallArray = new BigDecimal[TEST_SIZE];\n+         * Small number less than MAX_INT\n+         *\/\n+        small2Array = new BigDecimal[TEST_SIZE];\n+        small3Array = new BigDecimal[TEST_SIZE];\n@@ -113,2 +119,6 @@\n-            largeArray[i] = new BigDecimal(\"\" + ((long) value + (long) Integer.MAX_VALUE) + \".55\");\n-            smallArray[i] = new BigDecimal(\"\" + ((long) value \/ 1000) + \".55\");\n+\n+            large2Array[i] = new BigDecimal(\"\" + ((long) value + (long) Integer.MAX_VALUE) + \".55\");\n+            large3Array[i] = new BigDecimal(\"\" + ((long) value + (long) Integer.MAX_VALUE) + \".555\");\n+\n+            small2Array[i] = new BigDecimal(\"\" + ((long) value \/ 1000) + \".55\");\n+            small3Array[i] = new BigDecimal(\"\" + ((long) value \/ 1000) + \".555\");\n@@ -136,9 +146,0 @@\n-    \/** Invokes the toString method of BigDecimal with various different values. *\/\n-    @Benchmark\n-    @OperationsPerInvocation(TEST_SIZE)\n-    public void testToString(Blackhole bh) {\n-        for (BigDecimal s : bigDecimals) {\n-            bh.consume(s.toString());\n-        }\n-    }\n-\n@@ -207,1 +208,1 @@\n-    \/** Test BigDecimal.toString() with huge numbers larger than MAX_LONG *\/\n+    \/** Test BigDecimal.toString() with large numbers (scale 2) less than MAX_LONG but larger than MAX_INT *\/\n@@ -210,1 +211,1 @@\n-    public void testHugeToString(Blackhole bh) {\n+    public void hugeLayoutCharsToString(Blackhole bh) throws Throwable {\n@@ -212,1 +213,1 @@\n-            bh.consume(s.toString());\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n@@ -216,1 +217,1 @@\n-    \/** Test BigDecimal.toString() with large numbers less than MAX_LONG but larger than MAX_INT *\/\n+    \/** Test BigDecimal.toEngineeringString() with huge numbers larger than MAX_LONG *\/\n@@ -219,3 +220,12 @@\n-    public void testLargeToString(Blackhole bh) {\n-        for (BigDecimal s : largeArray) {\n-            bh.consume(s.toString());\n+    public void hugeEngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toEngineeringString() with huge numbers larger than MAX_LONG *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void hugePlainToString(Blackhole bh) {\n+        for (BigDecimal s : hugeArray) {\n+            bh.consume(s.toPlainString());\n@@ -225,1 +235,1 @@\n-    \/** Test BigDecimal.toString() with small numbers less than MAX_INT *\/\n+    \/** Test BigDecimal.toString() with large numbers (scale 2) less than MAX_LONG but larger than MAX_INT *\/\n@@ -228,3 +238,115 @@\n-    public void testSmallToString(Blackhole bh) {\n-        for (BigDecimal s : smallArray) {\n-            bh.consume(s.toString());\n+    public void largeScale2LayoutCharsToString(Blackhole bh) throws Throwable {\n+        for (BigDecimal s : large2Array) {\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toEngineeringString() with large numbers (scale 2) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale2EngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : large2Array) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toPlainString() with large numbers (scale 2) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale2PlainToString(Blackhole bh) {\n+        for (BigDecimal s : large2Array) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toString() with large numbers (scale 3) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale3LayoutCharsToString(Blackhole bh) throws Throwable {\n+        for (BigDecimal s : large3Array) {\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toEngineeringString() with large numbers (scale 3) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale3EngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : large3Array) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n+\n+    \/** Test BigDecimal.toPlainString() with large numbers (scale 3) less than MAX_LONG but larger than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void largeScale3PlainToString(Blackhole bh) {\n+        for (BigDecimal s : large3Array) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toString() with small numbers (scale 2) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale2LayoutCharsToString(Blackhole bh) throws Throwable {\n+        for (BigDecimal s : small2Array) {\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toEngineeringString() with small numbers (scale 2) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale2EngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : small2Array) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toPlainString() with small numbers (scale 3) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale2PlainToString(Blackhole bh) {\n+        for (BigDecimal s : small2Array) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toString() with small numbers (scale 3) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale3LayoutCharsToString(Blackhole bh) throws Throwable {\n+        for (BigDecimal s : small3Array) {\n+            bh.consume((String) BigDecimalAccess.layoutChars.invokeExact(s, true));\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toEngineeringString() with small numbers (scale 3) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale3EngineeringToString(Blackhole bh) {\n+        for (BigDecimal s : small3Array) {\n+            bh.consume(s.toEngineeringString());\n+        }\n+    }\n+\n+    \/** Test BigDecimal.toPlainString() with small numbers (scale 3) less than MAX_INT *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TEST_SIZE)\n+    public void smallScale3PlainToString(Blackhole bh) {\n+        for (BigDecimal s : small3Array) {\n+            bh.consume(s.toPlainString());\n+        }\n+    }\n+\n+    static class BigDecimalAccess {\n+        final static MethodHandle layoutChars;\n+        static {\n+            try {\n+                MethodHandles.Lookup lookup = MethodHandles.privateLookupIn(BigDecimal.class, MethodHandles.lookup());\n+                layoutChars = lookup.findVirtual(BigDecimal.class, \"layoutChars\", MethodType.methodType(String.class, boolean.class));\n+            } catch (Throwable e) {\n+                throw new AssertionError(e);\n+            }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigDecimals.java","additions":153,"deletions":31,"binary":false,"changes":184,"status":"modified"}]}