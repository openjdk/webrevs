{"files":[{"patch":"@@ -59,2 +59,0 @@\n-\/\/ MT-safe pool of same-sized chunks to reduce malloc\/free thrashing\n-\/\/ NB: not using Mutex because pools are used before Threads are initialized\n@@ -62,48 +60,0 @@\n-  \/\/ Our four static pools\n-  static constexpr int _num_pools = 4;\n-  static ChunkPool _pools[_num_pools];\n-\n-  Chunk*       _first;\n-  const size_t _size;         \/\/ (inner payload) size of the chunks this pool serves\n-\n-  \/\/ Returns null if pool is empty.\n-  Chunk* take_from_pool() {\n-    ThreadCritical tc;\n-    Chunk* c = _first;\n-    if (_first != nullptr) {\n-      _first = _first->next();\n-    }\n-    return c;\n-  }\n-  void return_to_pool(Chunk* chunk) {\n-    assert(chunk->length() == _size, \"wrong pool for this chunk\");\n-    ThreadCritical tc;\n-    chunk->set_next(_first);\n-    _first = chunk;\n-  }\n-\n-  \/\/ Clear this pool of all contained chunks\n-  void prune() {\n-    \/\/ Free all chunks while in ThreadCritical lock\n-    \/\/ so NMT adjustment is stable.\n-    ThreadCritical tc;\n-    Chunk* cur = _first;\n-    Chunk* next = nullptr;\n-    while (cur != nullptr) {\n-      next = cur->next();\n-      os::free(cur);\n-      cur = next;\n-    }\n-    _first = nullptr;\n-  }\n-\n-  \/\/ Given a (inner payload) size, return the pool responsible for it, or null if the size is non-standard\n-  static ChunkPool* get_pool_for_size(size_t size) {\n-    for (int i = 0; i < _num_pools; i++) {\n-      if (_pools[i]._size == size) {\n-        return _pools + i;\n-      }\n-    }\n-    return nullptr;\n-  }\n-\n@@ -111,9 +61,0 @@\n-  ChunkPool(size_t size) : _first(nullptr), _size(size) {}\n-\n-  static void clean() {\n-    NativeHeapTrimmer::SuspendMark sm(\"chunk pool cleaner\");\n-    for (int i = 0; i < _num_pools; i++) {\n-      _pools[i].prune();\n-    }\n-  }\n-\n@@ -153,2 +94,0 @@\n-  \/\/ Try to reuse a freed chunk from the pool\n-  ChunkPool* pool = ChunkPool::get_pool_for_size(length);\n@@ -156,6 +95,5 @@\n-  if (pool != nullptr) {\n-    Chunk* c = pool->take_from_pool();\n-    if (c != nullptr) {\n-      assert(c->length() == length, \"wrong length?\");\n-      chunk = c;\n-    }\n+  \/\/ Allocate a new Chunk from C-heap.\n+  size_t bytes = ARENA_ALIGN(sizeof(Chunk)) + length;\n+  void* p = os::malloc(bytes, mtChunk, CALLER_PC);\n+  if (p == nullptr && alloc_failmode == AllocFailStrategy::EXIT_OOM) {\n+    vm_exit_out_of_memory(bytes, OOM_MALLOC_ERROR, \"Chunk::new\");\n@@ -163,10 +101,1 @@\n-  if (chunk == nullptr) {\n-    \/\/ Either the pool was empty, or this is a non-standard length. Allocate a new Chunk from C-heap.\n-    size_t bytes = ARENA_ALIGN(sizeof(Chunk)) + length;\n-    void* p = os::malloc(bytes, mtChunk, CALLER_PC);\n-    if (p == nullptr && alloc_failmode == AllocFailStrategy::EXIT_OOM) {\n-      vm_exit_out_of_memory(bytes, OOM_MALLOC_ERROR, \"Chunk::new\");\n-    }\n-    chunk = (Chunk*)p;\n-  }\n-  ::new(chunk) Chunk(length);\n+  chunk = ::new(p) Chunk(length);\n@@ -188,1 +117,0 @@\n-\n@@ -196,30 +124,2 @@\n-  \/\/ If this is a standard-sized chunk, return it to its pool; otherwise free it.\n-  ChunkPool* pool = ChunkPool::get_pool_for_size(c->length());\n-  if (pool != nullptr) {\n-    pool->return_to_pool(c);\n-  } else {\n-    ThreadCritical tc;  \/\/ Free chunks under TC lock so that NMT adjustment is stable.\n-    os::free(c);\n-  }\n-}\n-\n-ChunkPool ChunkPool::_pools[] = { Chunk::size, Chunk::medium_size, Chunk::init_size, Chunk::tiny_size };\n-\n-class ChunkPoolCleaner : public PeriodicTask {\n-  static const int cleaning_interval = 5000; \/\/ cleaning interval in ms\n-\n- public:\n-   ChunkPoolCleaner() : PeriodicTask(cleaning_interval) {}\n-   void task() {\n-     ChunkPool::clean();\n-   }\n-};\n-\n-void Arena::start_chunk_pool_cleaner_task() {\n-#ifdef ASSERT\n-  static bool task_created = false;\n-  assert(!task_created, \"should not start chuck pool cleaner twice\");\n-  task_created = true;\n-#endif\n-  ChunkPoolCleaner* cleaner = new ChunkPoolCleaner();\n-  cleaner->enroll();\n+  ThreadCritical tc;  \/\/ Free chunks under TC lock so that NMT adjustment is stable.\n+  os::free(c);\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":8,"deletions":108,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -153,2 +153,0 @@\n-  \/\/ Start the chunk_pool cleaner task\n-  static void start_chunk_pool_cleaner_task();\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -716,2 +716,0 @@\n-  Arena::start_chunk_pool_cleaner_task();\n-\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}