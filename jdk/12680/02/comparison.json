{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -640,8 +640,0 @@\n-  size_table_field = C->env()->Integer_klass()->get_field_by_name(ciSymbol::make(\"sizeTable\"),\n-                                                                  ciSymbols::int_array_signature(), true);\n-  if (size_table_field == NULL) {\n-    \/\/ Something wrong so give up.\n-    assert(false, \"why can't we find Integer.sizeTable?\");\n-    return;\n-  }\n-\n@@ -1171,31 +1163,1 @@\n-Node* PhaseStringOpts::fetch_static_field(GraphKit& kit, ciField* field) {\n-  const TypeInstPtr* mirror_type = TypeInstPtr::make(field->holder()->java_mirror());\n-  Node* klass_node = __ makecon(mirror_type);\n-  BasicType bt = field->layout_type();\n-  ciType* field_klass = field->type();\n-\n-  const Type *type;\n-  if( bt == T_OBJECT ) {\n-    if (!field->type()->is_loaded()) {\n-      type = TypeInstPtr::BOTTOM;\n-    } else if (field->is_static_constant()) {\n-      \/\/ This can happen if the constant oop is non-perm.\n-      ciObject* con = field->constant_value().as_object();\n-      \/\/ Do not \"join\" in the previous type; it doesn't add value,\n-      \/\/ and may yield a vacuous result if the field is of interface type.\n-      type = TypeOopPtr::make_from_constant(con, true)->isa_oopptr();\n-      assert(type != NULL, \"field singleton type must be consistent\");\n-      return __ makecon(type);\n-    } else {\n-      type = TypeOopPtr::make_from_klass(field_klass->as_klass());\n-    }\n-  } else {\n-    type = Type::get_const_basic_type(bt);\n-  }\n-\n-  return kit.make_load(NULL, kit.basic_plus_adr(klass_node, field->offset_in_bytes()),\n-                       type, T_OBJECT,\n-                       C->get_alias_index(mirror_type->add_offset(field->offset_in_bytes())),\n-                       MemNode::unordered);\n-}\n-\n+\/\/ Mirror of Integer.stringSize() method, return the count of digits in integer,\n@@ -1204,9 +1166,5 @@\n-    \/\/ Constant integer. Compute constant length using Integer.sizeTable\n-    int arg_val = arg->get_int();\n-    int count = 1;\n-    if (arg_val < 0) {\n-      \/\/ Special case for min_jint - it can't be negated.\n-      if (arg_val == min_jint) {\n-        return __ intcon(11);\n-      }\n-\n+    \/\/ Constant integer. Compute constant length\n+    jint arg_val = arg->get_int();\n+    jint d = 1;\n+    if (arg_val >= 0) {\n+      d = 0;\n@@ -1214,1 +1172,0 @@\n-      count++;\n@@ -1216,6 +1173,4 @@\n-\n-    ciArray* size_table = (ciArray*)size_table_field->constant_value().as_object();\n-    for (int i = 0; i < size_table->length(); i++) {\n-      if (arg_val <= size_table->element_value(i).as_int()) {\n-        count += i;\n-        break;\n+    jint p = -10;\n+    for (int i = 1; i < 10; i++) {\n+      if (arg_val > p) {\n+        return __ intcon(i + d);\n@@ -1223,0 +1178,1 @@\n+      p = 10 * p;\n@@ -1224,1 +1180,1 @@\n-    return __ intcon(count);\n+    return __ intcon(10 + d);\n@@ -1227,4 +1183,11 @@\n-  RegionNode *final_merge = new RegionNode(3);\n-  kit.gvn().set_type(final_merge, Type::CONTROL);\n-  Node* final_size = new PhiNode(final_merge, TypeInt::INT);\n-  kit.gvn().set_type(final_size, TypeInt::INT);\n+  \/\/ int d = 1;\n+  \/\/ if (x >= 0) {\n+  \/\/     d = 0;\n+  \/\/     x = -x;\n+  \/\/ }\n+  RegionNode* sign_merge = new RegionNode(3);\n+  kit.gvn().set_type(sign_merge, Type::CONTROL);\n+  Node* digit_cnt = new PhiNode(sign_merge, TypeInt::INT);\n+  kit.gvn().set_type(digit_cnt, TypeInt::INT);\n+  Node* val = new PhiNode(sign_merge, TypeInt::INT);\n+  kit.gvn().set_type(val, TypeInt::INT);\n@@ -1233,1 +1196,1 @@\n-                                      __ Bool(__ CmpI(arg, __ intcon(0x80000000)), BoolTest::ne),\n+                                      __ Bool(__ CmpI(arg, __ intcon(0)), BoolTest::ge),\n@@ -1235,69 +1198,18 @@\n-  Node* is_min = __ IfFalse(iff);\n-  final_merge->init_req(1, is_min);\n-  final_size->init_req(1, __ intcon(11));\n-\n-  kit.set_control(__ IfTrue(iff));\n-  if (kit.stopped()) {\n-    final_merge->init_req(2, C->top());\n-    final_size->init_req(2, C->top());\n-  } else {\n-\n-    \/\/ int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);\n-    RegionNode *r = new RegionNode(3);\n-    kit.gvn().set_type(r, Type::CONTROL);\n-    Node *phi = new PhiNode(r, TypeInt::INT);\n-    kit.gvn().set_type(phi, TypeInt::INT);\n-    Node *size = new PhiNode(r, TypeInt::INT);\n-    kit.gvn().set_type(size, TypeInt::INT);\n-    Node* chk = __ CmpI(arg, __ intcon(0));\n-    Node* p = __ Bool(chk, BoolTest::lt);\n-    IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_FAIR, COUNT_UNKNOWN);\n-    Node* lessthan = __ IfTrue(iff);\n-    Node* greaterequal = __ IfFalse(iff);\n-    r->init_req(1, lessthan);\n-    phi->init_req(1, __ SubI(__ intcon(0), arg));\n-    size->init_req(1, __ intcon(1));\n-    r->init_req(2, greaterequal);\n-    phi->init_req(2, arg);\n-    size->init_req(2, __ intcon(0));\n-    kit.set_control(r);\n-    C->record_for_igvn(r);\n-    C->record_for_igvn(phi);\n-    C->record_for_igvn(size);\n-\n-    \/\/ for (int i=0; ; i++)\n-    \/\/   if (x <= sizeTable[i])\n-    \/\/     return i+1;\n-\n-    \/\/ Add loop predicate first.\n-    kit.add_empty_predicates();\n-    C->set_has_loops(true);\n-\n-    RegionNode *loop = new RegionNode(3);\n-    loop->init_req(1, kit.control());\n-    kit.gvn().set_type(loop, Type::CONTROL);\n-\n-    Node *index = new PhiNode(loop, TypeInt::INT);\n-    index->init_req(1, __ intcon(0));\n-    kit.gvn().set_type(index, TypeInt::INT);\n-    kit.set_control(loop);\n-    Node* sizeTable = fetch_static_field(kit, size_table_field);\n-\n-    Node* value = kit.load_array_element(sizeTable, index, TypeAryPtr::INTS, \/* set_ctrl *\/ false);\n-    C->record_for_igvn(value);\n-    Node* limit = __ CmpI(phi, value);\n-    Node* limitb = __ Bool(limit, BoolTest::le);\n-    IfNode* iff2 = kit.create_and_map_if(kit.control(), limitb, PROB_MIN, COUNT_UNKNOWN);\n-    Node* lessEqual = __ IfTrue(iff2);\n-    Node* greater = __ IfFalse(iff2);\n-\n-    loop->init_req(2, greater);\n-    index->init_req(2, __ AddI(index, __ intcon(1)));\n-\n-    kit.set_control(lessEqual);\n-    C->record_for_igvn(loop);\n-    C->record_for_igvn(index);\n-\n-    final_merge->init_req(2, kit.control());\n-    final_size->init_req(2, __ AddI(__ AddI(index, size), __ intcon(1)));\n-  }\n+  sign_merge->init_req(1, __ IfTrue(iff));\n+  sign_merge->init_req(2, __ IfFalse(iff));\n+  digit_cnt->init_req(1, __ intcon(0));\n+  digit_cnt->init_req(2, __ intcon(1));\n+  val->init_req(1, __ SubI(__ intcon(0), arg));\n+  val->init_req(2, arg);\n+  kit.set_control(sign_merge);\n+\n+  \/\/ int p = -10;\n+  \/\/ for (int i = 1; i < 10; i++) {\n+  \/\/     if (x > p)\n+  \/\/         return i + d;\n+  \/\/     p = 10 * p;\n+  \/\/ }\n+  RegionNode* final_merge = new RegionNode(3);\n+  kit.gvn().set_type(final_merge, Type::CONTROL);\n+  Node* final_size = new PhiNode(final_merge, TypeInt::INT);\n+  kit.gvn().set_type(final_size, TypeInt::INT);\n@@ -1305,0 +1217,35 @@\n+  kit.add_empty_predicates();\n+  C->set_has_loops(true);\n+\n+  RegionNode* loop = new RegionNode(3);\n+  kit.gvn().set_type(loop, Type::CONTROL);\n+  Node* index = new PhiNode(loop, TypeInt::INT);\n+  kit.gvn().set_type(index, TypeInt::INT);\n+  Node* temp = new PhiNode(loop, TypeInt::INT);\n+  kit.gvn().set_type(temp, TypeInt::INT);\n+\n+  loop->init_req(1, kit.control());\n+  index->init_req(1, __ intcon(1));\n+  temp->init_req(1, __ intcon(-10));\n+  kit.set_control(loop);\n+\n+  Node* limit = __ CmpI(index, __ intcon(10));\n+  Node* limitb = __ Bool(limit, BoolTest::lt);\n+  IfNode* iff2 = kit.create_and_map_if(kit.control(), limitb, PROB_MIN, COUNT_UNKNOWN);\n+  Node* limit_less = __ IfTrue(iff2);\n+  kit.set_control(limit_less);\n+\n+  Node* cmp = __ CmpI(val, temp);\n+  Node* cmpb = __ Bool(cmp, BoolTest::gt);\n+  IfNode* iff3 = kit.create_and_map_if(kit.control(), cmpb, PROB_MIN, COUNT_UNKNOWN);\n+  Node* cmp_le = __ IfFalse(iff3);\n+  kit.set_control(cmp_le);\n+\n+  loop->init_req(2, kit.control());\n+  index->init_req(2, __ AddI(index, __ intcon(1)));\n+  temp->init_req(2, __ MulI(temp, __ intcon(10)));\n+\n+  final_merge->init_req(1, __ IfFalse(iff2));\n+  final_merge->init_req(2, __ IfTrue(iff3));\n+  final_size->init_req(1, __ AddI(digit_cnt, __ intcon(10)));\n+  final_size->init_req(2, __ AddI(digit_cnt, index));\n@@ -1306,0 +1253,4 @@\n+\n+  C->record_for_igvn(sign_merge);\n+  C->record_for_igvn(digit_cnt);\n+  C->record_for_igvn(val);\n@@ -1308,1 +1259,3 @@\n-\n+  C->record_for_igvn(loop);\n+  C->record_for_igvn(index);\n+  C->record_for_igvn(temp);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":85,"deletions":132,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,3 +46,0 @@\n-  \/\/ Integer.sizeTable - used for int to String conversion\n-  ciField* size_table_field;\n-\n@@ -62,3 +59,0 @@\n-  \/\/ Load the value of a static field, performing any constant folding.\n-  Node* fetch_static_field(GraphKit& kit, ciField* field);\n-\n","filename":"src\/hotspot\/share\/opto\/stringopts.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -532,4 +532,0 @@\n-    \/\/ Left here for compatibility reasons, see JDK-8143900.\n-    static final int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999,\n-                                      99999999, 999999999, Integer.MAX_VALUE };\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}