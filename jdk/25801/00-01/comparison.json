{"files":[{"patch":"@@ -120,1 +120,1 @@\n-          \"Options: none, nop, isb, yield.\")                            \\\n+          \"Options: none, nop, isb, yield, sb.\")                        \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6814,0 +6814,3 @@\n+      case SpinWait::SB:\n+        sb();\n+        break;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-    YIELD\n+    YIELD,\n+    SB\n","filename":"src\/hotspot\/cpu\/aarch64\/spin_wait_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,5 @@\n+  } else if (strcmp(OnSpinWaitInst, \"sb\") == 0) {\n+    if (!VM_Version::supports_sb()) {\n+      vm_exit_during_initialization(\"OnSpinWaitInst is SB but current CPU does not support SB instruction\");\n+    }\n+    return SpinWait(SpinWait::SB, OnSpinWaitInstCount);\n@@ -61,1 +66,1 @@\n-    vm_exit_during_initialization(\"The options for OnSpinWaitInst are nop, isb, yield, and none\", OnSpinWaitInst);\n+    vm_exit_during_initialization(\"The options for OnSpinWaitInst are nop, isb, yield, sb, and none\", OnSpinWaitInst);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+    decl(SB,            sb,            29)    \\\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -95,0 +95,3 @@\n+  if (cpu_has(\"hw.optional.arm.FEAT_SB\")) {\n+    _features |= CPU_SB;\n+  }\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/vm_version_bsd_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,0 +74,4 @@\n+#ifndef HWCAP_SB\n+#define HWCAP_SB (1 << 29)\n+#endif\n+\n@@ -146,0 +150,1 @@\n+      HWCAP_SB      |\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+        SB,\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/aarch64\/AArch64.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ * @run driver compiler.onSpinWait.TestOnSpinWaitAArch64 c2 sb\n@@ -39,0 +40,1 @@\n+ * @run driver compiler.onSpinWait.TestOnSpinWaitAArch64 c1 sb\n@@ -59,1 +61,0 @@\n-        command.add(\"-XX:+PrintAssembly\");\n@@ -72,0 +73,1 @@\n+        command.add(\"-XX:CompileCommand=print,\" + Launcher.class.getName() + \"::\" + \"test\");\n@@ -78,1 +80,4 @@\n-        analyzer.shouldHaveExitValue(0);\n+        if (analyzer.getExitValue() != 0 && \"sb\".equals(spinWaitInst) && analyzer.contains(\"CPU does not support SB\")) {\n+            System.out.println(\"Skipping the test. The current CPU does not support SB instruction.\");\n+            return;\n+        }\n@@ -92,0 +97,2 @@\n+      } else if (\"sb\".equals(spinWaitInst)) {\n+          return \"ff30 03d5\";\n","filename":"test\/hotspot\/jtreg\/compiler\/onSpinWait\/TestOnSpinWaitAArch64.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"}]}