{"files":[{"patch":"@@ -766,0 +766,1 @@\n+  declare_constant(Deoptimization::Reason_short_running_long_loop)        \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -871,0 +871,9 @@\n+  product(bool, ShortRunningLongLoop, true, DIAGNOSTIC,                     \\\n+          \"long counted loop\/long range checks: don't create loop nest if \" \\\n+          \"loop runs for small enough number of iterations. Long loop is \"  \\\n+          \"converted to a single int loop.\")                                \\\n+                                                                            \\\n+  develop(bool, StressShortRunningLongLoop, false,                          \\\n+          \"Speculate all long counted loops are short running when bounds \" \\\n+          \"are unknown even if profile data doesn't say so.\")               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/cfgnode.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"opto\/loopnode.hpp\"\n@@ -326,0 +328,61 @@\n+bool CastLLNode::is_inner_loop_backedge(ProjNode* proj) {\n+  if (proj != nullptr) {\n+    Node* ctrl_use = proj->unique_ctrl_out_or_null();\n+    if (ctrl_use != nullptr && ctrl_use->Opcode() == Op_Loop &&\n+        ctrl_use->in(2) == proj &&\n+        ctrl_use->as_Loop()->is_loop_nest_inner_loop()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool CastLLNode::cmp_used_at_inner_loop_exit_test(CmpNode* cmp) {\n+  for (DUIterator_Fast imax, i = cmp->fast_outs(imax); i < imax; i++) {\n+    Node* bol = cmp->fast_out(i);\n+    if (bol->Opcode() == Op_Bool) {\n+      for (DUIterator_Fast jmax, j = bol->fast_outs(jmax); j < jmax; j++) {\n+        Node* iff = bol->fast_out(j);\n+        if (iff->Opcode() == Op_If) {\n+          ProjNode* true_proj = iff->as_If()->proj_out_or_null(true);\n+          ProjNode* false_proj = iff->as_If()->proj_out_or_null(false);\n+          if (is_inner_loop_backedge(true_proj) || is_inner_loop_backedge(false_proj)) {\n+            return true;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Find if this is a cast node added by PhaseIdealLoop::create_loop_nest() to narrow the number of iterations of the\n+\/\/ inner loop\n+bool CastLLNode::used_at_inner_loop_exit_test() const {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* convl2i = fast_out(i);\n+    if (convl2i->Opcode() == Op_ConvL2I) {\n+      for (DUIterator_Fast jmax, j = convl2i->fast_outs(jmax); j < jmax; j++) {\n+        Node* cmp_or_sub = convl2i->fast_out(j);\n+        if (cmp_or_sub->Opcode() == Op_CmpI) {\n+          if (cmp_used_at_inner_loop_exit_test(cmp_or_sub->as_Cmp())) {\n+            \/\/ (Loop .. .. (IfProj (If (Bool (CmpI (ConvL2I (CastLL )))))))\n+            return true;\n+          }\n+        } else if (cmp_or_sub->Opcode() == Op_SubI && cmp_or_sub->in(1)->find_int_con(-1) == 0) {\n+          for (DUIterator_Fast kmax, k = cmp_or_sub->fast_outs(kmax); k < kmax; k++) {\n+            Node* cmp = cmp_or_sub->fast_out(k);\n+            if (cmp->Opcode() == Op_CmpI) {\n+              if (cmp_used_at_inner_loop_exit_test(cmp->as_Cmp())) {\n+                \/\/ (Loop .. .. (IfProj (If (Bool (CmpI (SubI 0 (ConvL2I (CastLL ))))))))\n+                return true;\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -355,1 +418,6 @@\n-  return optimize_integer_cast(phase, T_LONG);\n+  \/\/ If it's a cast created by PhaseIdealLoop::short_running_loop(), don't transform it until the counted loop is created\n+  \/\/ in next loop opts pass\n+  if (!can_reshape || !used_at_inner_loop_exit_test()) {\n+    return optimize_integer_cast(phase, T_LONG);\n+  }\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":69,"deletions":1,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -141,0 +141,6 @@\n+\n+  static bool is_inner_loop_backedge(ProjNode* proj);\n+\n+  static bool cmp_used_at_inner_loop_exit_test(CmpNode* cmp);\n+  bool used_at_inner_loop_exit_test() const;\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4053,0 +4053,5 @@\n+  if (ShortRunningLongLoop) {\n+    \/\/ Will narrow the limit down with a cast node. Predicates added later may depend on the cast so should be last when\n+    \/\/ walking up from the loop.\n+    add_parse_predicate(Deoptimization::Reason_short_running_long_loop, nargs);\n+  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2181,0 +2181,1 @@\n+    case Deoptimization::Reason_short_running_long_loop:\n@@ -2229,0 +2230,3 @@\n+    case Deoptimization::DeoptReason::Reason_short_running_long_loop:\n+      st->print(\"Short_Running_Long_Loop \");\n+      break;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1057,1 +1057,1 @@\n-    loop->compute_trip_count(this);\n+    loop->compute_trip_count(this, T_INT);\n@@ -1174,1 +1174,1 @@\n-    loop->compute_trip_count(this);\n+    loop->compute_trip_count(this, T_INT);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,2 +99,2 @@\n-void IdealLoopTree::compute_trip_count(PhaseIdealLoop* phase) {\n-  if (!_head->as_Loop()->is_valid_counted_loop(T_INT)) {\n+void IdealLoopTree::compute_trip_count(PhaseIdealLoop* phase, BasicType loop_bt) {\n+  if (!_head->as_Loop()->is_valid_counted_loop(loop_bt)) {\n@@ -103,1 +103,1 @@\n-  CountedLoopNode* cl = _head->as_CountedLoop();\n+  BaseCountedLoopNode* cl = _head->as_BaseCountedLoop();\n@@ -122,8 +122,18 @@\n-    \/\/ Use longs to avoid integer overflow.\n-    int stride_con = cl->stride_con();\n-    const TypeInt* init_type = phase->_igvn.type(init_n)->is_int();\n-    const TypeInt* limit_type = phase->_igvn.type(limit_n)->is_int();\n-    jlong init_con = (stride_con > 0) ? init_type->_lo : init_type->_hi;\n-    jlong limit_con = (stride_con > 0) ? limit_type->_hi : limit_type->_lo;\n-    int stride_m = stride_con - (stride_con > 0 ? 1 : -1);\n-    jlong trip_count = (limit_con - init_con + stride_m)\/stride_con;\n+    jlong stride_con = cl->stride_con();\n+    const TypeInteger* init_type = phase->_igvn.type(init_n)->is_integer(loop_bt);\n+    const TypeInteger* limit_type = phase->_igvn.type(limit_n)->is_integer(loop_bt);\n+\n+    \/\/ compute trip count\n+    \/\/ It used to be computed as:\n+    \/\/ max(1, limit_con - init_con + stride_m) \/ stride_con\n+    \/\/ with stride_m = stride_con - (stride_con > 0 ? 1 : -1)\n+    \/\/ for int counted loops only and by promoting all values to long to avoid overflow\n+    \/\/ This implements the computation for int and long counted loops in a way that promotion to the next larger integer\n+    \/\/ type is not needed to protect against overflow.\n+    \/\/\n+    \/\/ Use unsigned longs to avoid overflow: number of iteration is a positive number but can be really large for\n+    \/\/ instance if init_con = min_jint, limit_con = max_jint\n+    jlong init_con = (stride_con > 0) ? init_type->lo_as_long() : init_type->hi_as_long();\n+    julong uinit_con = init_con;\n+    jlong limit_con = (stride_con > 0) ? limit_type->hi_as_long() : limit_type->lo_as_long();\n+    julong ulimit_con = limit_con;\n@@ -132,2 +142,30 @@\n-    trip_count = MAX2(trip_count, (jlong)1);\n-    if (trip_count < (jlong)max_juint) {\n+    julong udiff = 1;\n+    if (stride_con > 0 && limit_con > init_con) {\n+      udiff = ulimit_con - uinit_con;\n+    } else if (stride_con < 0 && limit_con < init_con) {\n+      udiff = uinit_con - ulimit_con;\n+    }\n+    \/\/ The loop runs for one more iteration if the limit is (stride > 0 in this example):\n+    \/\/ init + k * stride + small_value, 0 < small_value < stride\n+    julong utrip_count = udiff \/ ABS(stride_con);\n+    if (utrip_count * ABS(stride_con) != udiff) {\n+      \/\/ Guaranteed to not overflow because it can only happen for ABS(stride) > 1 in which case, utrip_count can't be\n+      \/\/ max_juint\/max_julong\n+      utrip_count++;\n+    }\n+\n+#ifdef ASSERT\n+    if (loop_bt == T_INT) {\n+      \/\/ Use longs to avoid integer overflow.\n+      jlong init_con = (stride_con > 0) ? init_type->is_int()->_lo : init_type->is_int()->_hi;\n+      jlong limit_con = (stride_con > 0) ? limit_type->is_int()->_hi : limit_type->is_int()->_lo;\n+      int stride_m = stride_con - (stride_con > 0 ? 1 : -1);\n+      jlong trip_count = (limit_con - init_con + stride_m) \/ stride_con;\n+      \/\/ The loop body is always executed at least once even if init >= limit (for stride_con > 0) or\n+      \/\/ init <= limit (for stride_con < 0).\n+      trip_count = MAX2(trip_count, (jlong)1);\n+      assert(checked_cast<juint>(trip_count) == checked_cast<juint>(utrip_count), \"incorrect trip count computation\");\n+    }\n+#endif\n+\n+    if (utrip_count < max_unsigned_integer(loop_bt)) {\n@@ -136,2 +174,2 @@\n-        cl->set_exact_trip_count((uint)trip_count);\n-      } else if (cl->unrolled_count() == 1) {\n+        cl->set_exact_trip_count(utrip_count);\n+      } else if (loop_bt == T_LONG || cl->as_CountedLoop()->unrolled_count() == 1) {\n@@ -139,1 +177,1 @@\n-        cl->set_trip_count((uint)trip_count);\n+        cl->set_trip_count(utrip_count);\n@@ -1851,1 +1889,1 @@\n-      tty->print(\"Unroll %d(%2d) \", loop_head->unrolled_count()*2, loop_head->trip_count());\n+      tty->print(\"Unroll %d(\" JULONG_FORMAT_W(2) \") \", loop_head->unrolled_count()*2, loop_head->trip_count());\n@@ -2104,1 +2142,1 @@\n-    tty->print(\"MaxUnroll  %d \", cl->trip_count());\n+    tty->print(\"MaxUnroll  \" JULONG_FORMAT \" \", cl->trip_count());\n@@ -3355,1 +3393,1 @@\n-  compute_trip_count(phase);\n+  compute_trip_count(phase, T_INT);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":57,"deletions":19,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -604,1 +604,0 @@\n-    JVMState* jvms = sfpt->jvms();\n@@ -859,0 +858,2 @@\n+  assert(iters_limit > 0, \"can't be negative\");\n+\n@@ -860,1 +861,0 @@\n-  Node* incr = head->incr();\n@@ -891,1 +891,1 @@\n-  const Node* init = head->init_trip();\n+  Node* init = head->init_trip();\n@@ -910,1 +910,1 @@\n-    loop->compute_trip_count(this);\n+    loop->compute_trip_count(this, bt);\n@@ -923,0 +923,5 @@\n+  if (try_make_short_running_loop(loop, stride_con, range_checks, iters_limit)) {\n+    C->set_major_progress();\n+    return true;\n+  }\n+\n@@ -1121,0 +1126,3 @@\n+    if (ShortRunningLongLoop) {\n+      add_parse_predicate(Deoptimization::Reason_short_running_long_loop, inner_head, outer_ilt, cloned_sfpt);\n+    }\n@@ -1150,0 +1158,209 @@\n+\/\/ Make a copy of Parse\/Template Assertion predicates below existing predicates at the loop passed as argument\n+class CloneShortLoopPredicateVisitor : public PredicateVisitor {\n+  ClonePredicateToTargetLoop _clone_predicate_to_loop;\n+  PhaseIdealLoop* const _phase;\n+\n+public:\n+  CloneShortLoopPredicateVisitor(LoopNode* target_loop_head,\n+                                 const NodeInSingleLoopBody &node_in_loop_body,\n+                                 PhaseIdealLoop* phase)\n+    : _clone_predicate_to_loop(target_loop_head, node_in_loop_body, phase),\n+      _phase(phase) {\n+  }\n+  NONCOPYABLE(CloneShortLoopPredicateVisitor);\n+\n+  using PredicateVisitor::visit;\n+\n+  void visit(const ParsePredicate& parse_predicate) override {\n+    _clone_predicate_to_loop.clone_parse_predicate(parse_predicate, true);\n+    parse_predicate.kill(_phase->igvn());\n+  }\n+\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override {\n+    _clone_predicate_to_loop.clone_template_assertion_predicate(template_assertion_predicate);\n+    template_assertion_predicate.kill(_phase->igvn());\n+  }\n+};\n+\n+\/\/ If the loop is either statically known to run for a small enough number of iterations or if profile data indicates\n+\/\/ that, we don't want an outer loop because the overhead of having an outer loop whose backedge is never taken, has a\n+\/\/ measurable cost. Furthermore, creating the loop nest usually causes one iteration of the loop to be peeled so\n+\/\/ predicates can be set up. If the loop is short running, then it's an extra iteration that's run with range checks\n+\/\/ (compared to an int counted loop with int range checks).\n+\/\/\n+\/\/ In the short running case, turn the loop into a regular loop again and transform the long range checks:\n+\/\/ - LongCountedLoop: Create LoopNode but keep the loop limit type with a CastLL node to avoid that we later try to\n+\/\/                    create a Loop Limit Check when turning the LoopNode into a CountedLoopNode.\n+\/\/ - CountedLoop: Can be reused.\n+bool PhaseIdealLoop::try_make_short_running_loop(IdealLoopTree* loop, jint stride_con, const Node_List &range_checks,\n+                                                 const uint iters_limit) {\n+  if (!ShortRunningLongLoop) {\n+    return false;\n+  }\n+  BaseCountedLoopNode* head = loop->_head->as_BaseCountedLoop();\n+  BasicType bt = head->bt();\n+  Node* entry_control = head->skip_strip_mined()->in(LoopNode::EntryControl);\n+\n+  loop->compute_trip_count(this, bt);\n+  \/\/ Loop must run for no more than iter_limits as it guarantees no overflow of scale * iv in long range checks (see\n+  \/\/ comment above PhaseIdealLoop::transform_long_range_checks()).\n+  \/\/ iters_limit \/ ABS(stride_con) is the largest trip count for which we know it's correct to not create a loop nest:\n+  \/\/ it's always beneficial to have a single loop rather than a loop nest, so we try to apply this transformation as\n+  \/\/ often as possible.\n+  bool known_short_running_loop = head->trip_count() <= iters_limit \/ ABS(stride_con);\n+  bool profile_short_running_loop = false;\n+  if (!known_short_running_loop) {\n+    loop->compute_profile_trip_cnt(this);\n+    if (StressShortRunningLongLoop) {\n+      profile_short_running_loop = true;\n+    } else {\n+      profile_short_running_loop = !head->is_profile_trip_failed() && head->profile_trip_cnt() <= iters_limit \/ ABS(stride_con);\n+    }\n+  }\n+\n+  if (!known_short_running_loop && !profile_short_running_loop) {\n+    return false;\n+  }\n+\n+  Node* limit = head->limit();\n+  Node* init = head->init_trip();\n+\n+  Node* new_limit;\n+  if (stride_con > 0) {\n+    new_limit = SubNode::make(limit, init, bt);\n+  } else {\n+    new_limit = SubNode::make(init, limit, bt);\n+  }\n+  register_new_node(new_limit, entry_control);\n+\n+  PhiNode* phi = head->phi()->as_Phi();\n+  if (profile_short_running_loop) {\n+    \/\/ Add a Short Running Long Loop Predicate. It's the first predicate in the predicate chain before entering a loop\n+    \/\/ because a cast that's control dependent on the Short Running Long Loop Predicate is added to narrow the limit and\n+    \/\/ future predicates may be dependent on the new limit (so have to be between the loop and Short Running Long Loop\n+    \/\/ Predicate). The current limit could, itself, be dependent on an existing predicate. Clone parse and template\n+    \/\/ assertion predicates below existing predicates to get proper ordering of predicates when walking from the loop\n+    \/\/ up: future predicates, Short Running Long Loop Predicate, existing predicates.\n+    \/\/\n+    \/\/        Existing Hoisted\n+    \/\/        Check Predicates\n+    \/\/               |\n+    \/\/     New Short Running Long\n+    \/\/         Loop Predicate\n+    \/\/               |\n+    \/\/   Cloned Parse Predicates and\n+    \/\/  Template Assertion Predicates\n+    \/\/  (future predicates added here)\n+    \/\/               |\n+    \/\/             Loop\n+    const Predicates predicates_before_cloning(entry_control);\n+    const PredicateBlock* short_running_long_loop_predicate_block = predicates_before_cloning.short_running_long_loop_predicate_block();\n+    if (!short_running_long_loop_predicate_block->has_parse_predicate()) { \/\/ already trapped\n+      return false;\n+    }\n+    PredicateIterator predicate_iterator(entry_control);\n+    NodeInSingleLoopBody node_in_short_loop_body(this, loop);\n+    CloneShortLoopPredicateVisitor clone_short_loop_predicates_visitor(head, node_in_short_loop_body, this);\n+    predicate_iterator.for_each(clone_short_loop_predicates_visitor);\n+\n+    entry_control = head->skip_strip_mined()->in(LoopNode::EntryControl);\n+\n+    const Predicates predicates_after_cloning(entry_control);\n+\n+    ParsePredicateSuccessProj* short_running_loop_predicate_proj = predicates_after_cloning.\n+        short_running_long_loop_predicate_block()->\n+        parse_predicate_success_proj();\n+    assert(short_running_loop_predicate_proj->in(0)->is_ParsePredicate(), \"must be parse predicate\");\n+\n+    const jlong iters_limit_long = iters_limit;\n+    Node* cmp_limit = CmpNode::make(new_limit, _igvn.integercon(iters_limit_long, bt), bt);\n+    Node* bol = new BoolNode(cmp_limit, BoolTest::le);\n+    Node* new_predicate_proj = create_new_if_for_predicate(short_running_loop_predicate_proj,\n+                                                           nullptr,\n+                                                           Deoptimization::Reason_short_running_long_loop,\n+                                                           Op_If);\n+    Node* iff = new_predicate_proj->in(0);\n+    _igvn.replace_input_of(iff, 1, bol);\n+    register_new_node(cmp_limit, iff->in(0));\n+    register_new_node(bol, iff->in(0));\n+    new_limit = ConstraintCastNode::make_cast_for_basic_type(new_predicate_proj, new_limit,\n+                                                             TypeInteger::make(1, iters_limit_long, Type::WidenMin, bt),\n+                                                             ConstraintCastNode::UnconditionalDependency, bt);\n+    register_new_node(new_limit, new_predicate_proj);\n+\n+#ifndef PRODUCT\n+    if (TraceLoopLimitCheck) {\n+      tty->print_cr(\"Short Long Loop Check Predicate generated:\");\n+      DEBUG_ONLY(bol->dump(2);)\n+    }\n+#endif\n+    entry_control = head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  } else if (bt == T_LONG) {\n+    \/\/ We're turning a long counted loop into a regular loop that will be converted into an int counted loop. That loop\n+    \/\/ won't need loop limit check predicates (iters_limit guarantees that). Add a cast to make sure that, whatever\n+    \/\/ transformation happens by the time the counted loop is created (in a subsequent pass of loop opts), C2 knows\n+    \/\/ enough about the loop's limit that it doesn't try to add loop limit check predicates.\n+    const Predicates predicates(entry_control);\n+    const TypeLong* new_limit_t = new_limit->Value(&_igvn)->is_long();\n+    new_limit = ConstraintCastNode::make_cast_for_basic_type(predicates.entry(), new_limit,\n+                                                             TypeLong::make(0, new_limit_t->_hi, new_limit_t->_widen),\n+                                                             ConstraintCastNode::UnconditionalDependency, bt);\n+    register_new_node(new_limit, predicates.entry());\n+  } else {\n+    assert(bt == T_INT && known_short_running_loop, \"only CountedLoop statically known to be short running\");\n+  }\n+  IfNode* exit_test = head->loopexit();\n+\n+  if (bt == T_LONG) {\n+    \/\/ The loop is short running so new_limit fits into an int: either we determined that statically or added a guard\n+    new_limit = new ConvL2INode(new_limit);\n+    register_new_node(new_limit, entry_control);\n+  }\n+\n+  Node* int_zero = intcon(0);\n+  if (stride_con < 0) {\n+    new_limit = new SubINode(int_zero, new_limit);\n+    register_new_node(new_limit, entry_control);\n+  }\n+\n+  \/\/ Clone the iv data nodes as an integer iv\n+  Node* int_stride = intcon(stride_con);\n+  Node* inner_phi = new PhiNode(head, TypeInt::INT);\n+  Node* inner_incr = new AddINode(inner_phi, int_stride);\n+  Node* inner_cmp = new CmpINode(inner_incr, new_limit);\n+  Node* inner_bol = new BoolNode(inner_cmp, exit_test->in(1)->as_Bool()->_test._test);\n+  inner_phi->set_req(LoopNode::EntryControl, int_zero);\n+  inner_phi->set_req(LoopNode::LoopBackControl, inner_incr);\n+  register_new_node(inner_phi, head);\n+  register_new_node(inner_incr, head);\n+  register_new_node(inner_cmp, head);\n+  register_new_node(inner_bol, head);\n+\n+  _igvn.replace_input_of(exit_test, 1, inner_bol);\n+\n+  \/\/ Replace inner loop long iv phi as inner loop int iv phi + outer\n+  \/\/ loop iv phi\n+  Node* iv_add = loop_nest_replace_iv(phi, inner_phi, init, head, bt);\n+\n+  LoopNode* inner_head = head;\n+  if (bt == T_LONG) {\n+    \/\/ Turn the loop back to a counted loop\n+    inner_head = create_inner_head(loop, head, exit_test);\n+  } else {\n+    \/\/ Use existing counted loop\n+    revert_to_normal_loop(head);\n+  }\n+\n+  if (bt == T_INT) {\n+    init = new ConvI2LNode(init);\n+    register_new_node(init, entry_control);\n+  }\n+\n+  transform_long_range_checks(stride_con, range_checks, init, new_limit,\n+                              inner_phi, iv_add, inner_head);\n+\n+  inner_head->mark_loop_nest_inner_loop();\n+\n+  return true;\n+}\n+\n@@ -1321,1 +1538,0 @@\n-    ProjNode* unc_proj = proj->other_if_proj();\n@@ -4418,0 +4634,3 @@\n+  if (predicates.short_running_long_loop_predicate_block()->is_non_empty()) {\n+    tty->print(\" short_running\");\n+  }\n@@ -4925,1 +5144,1 @@\n-        lpt->compute_trip_count(this);\n+        lpt->compute_trip_count(this, T_INT);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":225,"deletions":6,"binary":false,"changes":231,"status":"modified"},{"patch":"@@ -221,0 +221,12 @@\n+\n+  virtual void set_trip_count(julong tc) = 0;\n+  virtual julong trip_count() const = 0;\n+\n+  bool has_exact_trip_count() const { return (_loop_flags & HasExactTripCount) != 0; }\n+  void set_exact_trip_count(julong tc) {\n+    set_trip_count(tc);\n+    _loop_flags |= HasExactTripCount;\n+  }\n+  void set_nonexact_trip_count() {\n+    _loop_flags &= ~HasExactTripCount;\n+  }\n@@ -301,0 +313,5 @@\n+  void set_trip_count(julong tc) {\n+    assert(tc < max_juint, \"Cannot set trip count to max_juint\");\n+    _trip_count = checked_cast<uint>(tc);\n+  }\n+  julong trip_count() const      { return _trip_count; }\n@@ -307,14 +324,0 @@\n-  \/\/ We use max_juint for the default value of _trip_count to signal it wasn't set.\n-  \/\/ We shouldn't set _trip_count to max_juint explicitly.\n-  void set_trip_count(uint tc) { assert(tc < max_juint, \"Cannot set trip count to max_juint\"); _trip_count = tc; }\n-  uint trip_count()            { return _trip_count; }\n-\n-  bool has_exact_trip_count() const { return (_loop_flags & HasExactTripCount) != 0; }\n-  void set_exact_trip_count(uint tc) {\n-    assert(tc < max_juint, \"Cannot set trip count to max_juint\");\n-    _trip_count = tc;\n-    _loop_flags |= HasExactTripCount;\n-  }\n-  void set_nonexact_trip_count() {\n-    _loop_flags &= ~HasExactTripCount;\n-  }\n@@ -383,0 +386,6 @@\n+private:\n+  virtual uint size_of() const { return sizeof(*this); }\n+\n+  \/\/ Known trip count calculated by compute_exact_trip_count()\n+  julong _trip_count;\n+\n@@ -385,1 +394,1 @@\n-    : BaseCountedLoopNode(entry, backedge) {\n+    : BaseCountedLoopNode(entry, backedge), _trip_count(max_julong) {\n@@ -395,0 +404,6 @@\n+  void set_trip_count(julong tc) {\n+    assert(tc < max_julong, \"Cannot set trip count to max_julong\");\n+    _trip_count = tc;\n+  }\n+  julong trip_count() const      { return _trip_count; }\n+\n@@ -781,1 +796,1 @@\n-  void compute_trip_count(PhaseIdealLoop* phase);\n+  void compute_trip_count(PhaseIdealLoop* phase, BasicType bt);\n@@ -1832,0 +1847,2 @@\n+  bool try_make_short_running_loop(IdealLoopTree* loop, jint stride_con, const Node_List& range_checks, const uint iters_limit);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":33,"deletions":16,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -85,2 +85,2 @@\n-ParsePredicate ParsePredicate::clone_to_unswitched_loop(Node* new_control, const bool is_false_path_loop,\n-                                                        PhaseIdealLoop* phase) const {\n+ParsePredicate ParsePredicate::clone_to_loop(Node* new_control, const bool rewire_uncommon_proj_phi_inputs,\n+                                             PhaseIdealLoop* phase) const {\n@@ -89,2 +89,1 @@\n-                                                                               Op_ParsePredicate, is_false_path_loop);\n-  NOT_PRODUCT(trace_cloned_parse_predicate(is_false_path_loop, success_proj));\n+                                                                               Op_ParsePredicate, rewire_uncommon_proj_phi_inputs);\n@@ -100,3 +99,2 @@\n-void ParsePredicate::trace_cloned_parse_predicate(const bool is_false_path_loop,\n-                                                  const ParsePredicateSuccessProj* success_proj) {\n-  if (TraceLoopPredicate) {\n+void ParsePredicate::trace_cloned_parse_predicate(const bool is_false_path_loop) const {\n+  if (TraceLoopUnswitching) {\n@@ -104,1 +102,1 @@\n-    success_proj->in(0)->dump();\n+    head()->dump();\n@@ -129,0 +127,1 @@\n+          deopt_reason == Deoptimization::Reason_short_running_long_loop ||\n@@ -944,0 +943,2 @@\n+    tty->print_cr(\"- Short Running Long Loop Predicate Block:\");\n+    _short_running_long_loop_predicate_block.dump(\"  \");\n@@ -1002,0 +1003,4 @@\n+bool NodeInSingleLoopBody::check_node_in_loop_body(Node* node) const {\n+  return _phase->is_member(_ilt, _phase->get_ctrl(node));\n+}\n+\n@@ -1111,2 +1116,2 @@\n-  _clone_predicate_to_true_path_loop.clone_parse_predicate(parse_predicate, false);\n-  _clone_predicate_to_false_path_loop.clone_parse_predicate(parse_predicate, true);\n+  clone_parse_predicate(parse_predicate, false);\n+  clone_parse_predicate(parse_predicate, true);\n@@ -1116,0 +1121,7 @@\n+void CloneUnswitchedLoopPredicatesVisitor::clone_parse_predicate(const ParsePredicate& parse_predicate,\n+                                                                 const bool is_false_path_loop) {\n+  ClonePredicateToTargetLoop& clone_predicate_to_loop = is_false_path_loop ? _clone_predicate_to_false_path_loop : _clone_predicate_to_true_path_loop;\n+  const ParsePredicate cloned_parse_predicate = clone_predicate_to_loop.clone_parse_predicate(parse_predicate, is_false_path_loop);\n+  NOT_PRODUCT(cloned_parse_predicate.trace_cloned_parse_predicate(is_false_path_loop);)\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":22,"deletions":10,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -76,0 +76,8 @@\n+ *     - Short:              This predicate is created when a long counted loop is transformed into an int counted\n+ *       Running Long        loop. In general, that transformation requires an outer loop to guarantee that the new\n+ *       Loop                loop nest iterates over the entire range of the loop before transformation. However, if the\n+ *       Predicate           loop is speculated to run for a small enough number of iterations, the outer loop is not\n+ *                           needed. This predicate is added to catch mis-speculation in this case. It also applies to\n+ *                           int counted loops with long range checks for which a loop nest also needs to be created\n+ *                           in the general case (so the transformation of long range checks to int range checks is\n+ *                           legal).\n@@ -291,2 +299,0 @@\n-  NOT_PRODUCT(static void trace_cloned_parse_predicate(bool is_false_path_loop,\n-                                                       const ParsePredicateSuccessProj* success_proj);)\n@@ -323,2 +329,2 @@\n-  ParsePredicate clone_to_unswitched_loop(Node* new_control, bool is_false_path_loop,\n-                                          PhaseIdealLoop* phase) const;\n+  ParsePredicate clone_to_loop(Node* new_control, bool rewire_uncommon_proj_phi_inputs, PhaseIdealLoop* phase) const;\n+  NOT_PRODUCT(void trace_cloned_parse_predicate(bool is_false_path_loop) const;)\n@@ -789,1 +795,2 @@\n-    return current_node;\n+    PredicateBlockIterator short_running_loop_predicate_iterator(current_node, Deoptimization::Reason_short_running_long_loop);\n+    return short_running_loop_predicate_iterator.for_each(predicate_visitor);\n@@ -956,0 +963,1 @@\n+  const PredicateBlock _short_running_long_loop_predicate_block;\n@@ -968,1 +976,3 @@\n-        _entry(_loop_predicate_block.entry()) {}\n+        _short_running_long_loop_predicate_block(_loop_predicate_block.entry(),\n+                                            Deoptimization::Reason_short_running_long_loop),\n+        _entry(_short_running_long_loop_predicate_block.entry()) {}\n@@ -993,0 +1003,4 @@\n+  const PredicateBlock* short_running_long_loop_predicate_block() const {\n+    return &_short_running_long_loop_predicate_block;\n+  }\n+\n@@ -1085,0 +1099,13 @@\n+\/\/ This class checks whether a node is in the loop body passed to the constructor.\n+class NodeInSingleLoopBody : public NodeInLoopBody {\n+  PhaseIdealLoop* const _phase;\n+  IdealLoopTree* const _ilt;\n+\n+public:\n+  NodeInSingleLoopBody(PhaseIdealLoop* phase, IdealLoopTree* ilt) : _phase(phase), _ilt(ilt) {\n+  }\n+  NONCOPYABLE(NodeInSingleLoopBody);\n+\n+  bool check_node_in_loop_body(Node* node) const override;\n+};\n+\n@@ -1161,3 +1188,3 @@\n-  void clone_parse_predicate(const ParsePredicate& parse_predicate, bool is_false_path_loop) {\n-    ParsePredicate cloned_parse_predicate = parse_predicate.clone_to_unswitched_loop(_old_target_loop_entry,\n-                                                                                     is_false_path_loop, _phase);\n+  ParsePredicate clone_parse_predicate(const ParsePredicate& parse_predicate, bool rewire_uncommon_proj_phi_inputs) {\n+    ParsePredicate cloned_parse_predicate = parse_predicate.clone_to_loop(_old_target_loop_entry,\n+                                                                          rewire_uncommon_proj_phi_inputs, _phase);\n@@ -1165,0 +1192,1 @@\n+    return cloned_parse_predicate;\n@@ -1192,0 +1220,3 @@\n+\n+  void clone_parse_predicate(const ParsePredicate &parse_predicate,\n+                             bool is_false_path_loop);\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":40,"deletions":9,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2770,0 +2770,1 @@\n+  \"short_running_loop\" JVMCI_ONLY(\"_or_aliasing\"),\n@@ -2771,1 +2772,0 @@\n-  \"aliasing\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+    Reason_short_running_long_loop,    \/\/ profile reports loop runs for small number of iterations\n@@ -121,1 +122,1 @@\n-    Reason_aliasing,              \/\/ optimistic assumption about aliasing failed\n+    Reason_aliasing = Reason_short_running_long_loop, \/\/ optimistic assumption about aliasing failed\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1569,0 +1569,1 @@\n+  declare_constant(Deoptimization::Reason_short_running_long_loop)        \\\n@@ -1576,1 +1577,0 @@\n-  NOT_ZERO(JVMCI_ONLY(declare_constant(Deoptimization::Reason_aliasing)))                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,0 +151,3 @@\n+#ifndef JULONG_FORMAT_W\n+#define JULONG_FORMAT_W(width)   UINT64_FORMAT_W(width)\n+#endif\n@@ -774,0 +777,8 @@\n+inline julong max_unsigned_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return max_juint;\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return max_julong;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2021, 2022, 2025 Red Hat, Inc. All rights reserved.\n@@ -41,0 +41,3 @@\n+        TestFramework.runWithFlags(\"-XX:-ShortRunningLongLoop\", \"-XX:+TieredCompilation\", \"-XX:-UseCountedLoopSafepoints\", \"-XX:LoopUnrollLimit=0\");\n+        TestFramework.runWithFlags(\"-XX:-ShortRunningLongLoop\", \"-XX:+TieredCompilation\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1\", \"-XX:LoopUnrollLimit=0\");\n+        TestFramework.runWithFlags(\"-XX:-ShortRunningLongLoop\", \"-XX:+TieredCompilation\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\", \"-XX:LoopUnrollLimit=0\");\n@@ -48,1 +51,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -69,1 +73,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -87,1 +92,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -105,1 +111,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -121,1 +128,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -138,1 +146,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -155,1 +164,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -171,1 +181,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -187,1 +198,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -203,1 +215,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -219,1 +232,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -235,1 +249,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLongRangeChecks.java","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1668,0 +1668,5 @@\n+    public static final String SHORT_RUNNING_LOOP_TRAP = PREFIX + \"SHORT_RUNNING_LOOP_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(SHORT_RUNNING_LOOP_TRAP, \"short_running_loop\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342692\n+ * @summary C2: long counted loop\/long range checks: don't create loop-nest for short running loops\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation TestShortLoopLostLimit\n+ * @run main\/othervm TestShortLoopLostLimit\n+ *\/\n+\n+public class TestShortLoopLostLimit {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(0, 100);\n+            test2(0, 100);\n+        }\n+    }\n+\n+    private static void test1(int a, long b) {\n+        for (long i = 0; i < a + b; i += 2) {\n+            volatileField = 42;\n+        }\n+    }\n+\n+    private static void test2(int a, long b) {\n+        for (long i = a + b; i > 0; i -= 2) {\n+            volatileField = 42;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortLoopLostLimit.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342692\n+ * @summary C2: long counted loop\/long range checks: don't create loop-nest for short running loops\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:LoopUnrollLimit=100\n+ *                   TestShortRunningIntLoopWithLongChecksPredicates\n+ * @run main\/othervm TestShortRunningIntLoopWithLongChecksPredicates\n+ *\/\n+\n+import java.util.Objects;\n+\n+\/\/ int RC is first eliminated by predication which causes Assertion\n+\/\/ Predicates to be added. Then the loop is transformed to make it\n+\/\/ possible to optimize long RC. Finally unrolling happen which\n+\/\/ require the Assertion Predicates to have been properly copied when\n+\/\/ the loop was transformed for the long range check.\n+public class TestShortRunningIntLoopWithLongChecksPredicates {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            helper1(100, array, 100);\n+            test1(1, 100);\n+        }\n+    }\n+\n+    private static void test1(int stop, long range) {\n+        int[] array = new int[3];\n+        helper1(stop, array, range);\n+    }\n+\n+    private static void helper1(int stop, int[] array, long range) {\n+        for (int i = 0; i < stop; i++) {\n+            if (i % 2 == 0) {\n+                array[i] += i;\n+            } else {\n+                volatileField = 42;\n+            }\n+            Objects.checkIndex(i, range);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortRunningIntLoopWithLongChecksPredicates.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,579 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.longcountedloops;\n+import compiler.lib.ir_framework.*;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.util.Objects;\n+\/*\n+ * @test\n+ * @bug 8342692\n+ * @summary C2: long counted loop\/long range checks: don't create loop-nest for short running loops\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.longcountedloops.TestShortRunningLongCountedLoop\n+ *\/\n+\n+public class TestShortRunningLongCountedLoop {\n+    private static volatile int volatileField;\n+    private final static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ IR rules expect a single loop so disable unrolling\n+        \/\/ IR rules expect strip mined loop to be enabled\n+        \/\/ testIntLoopUnknownBoundsShortUnswitchedLoop and testLongLoopUnknownBoundsShortUnswitchedLoop need -XX:-UseProfiledLoopPredicate\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=0\", \"-XX:LoopStripMiningIter=1000\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:-UseProfiledLoopPredicate\");\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are known and loop run for a short time\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop1() {\n+        int j = 0;\n+        for (long i = 0; i < 100; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsShortLoop1\")\n+    public static void checkTestLongLoopConstantBoundsShortLoop1(int res) {\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Same with stride > 1\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop2() {\n+        int j = 0;\n+        for (long i = 0; i < 2000; i += 20) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsShortLoop2\")\n+    public static void checkTestLongLoopConstantBoundsShortLoop2(int res) {\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Same with loop going downward\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop3() {\n+        int j = 0;\n+        for (long i = 99; i >= 0; i--) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsShortLoop3\")\n+    public static void checkTestLongLoopConstantBoundsShortLoop3(int res) {\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Same with loop going downward and stride > 1\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop4() {\n+        int j = 0;\n+        for (long i = 1999; i >= 0; i-=20) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsShortLoop4\")\n+    public static void checkTestLongLoopConstantBoundsShortLoop4(int res) {\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are known but not exact and loop run for a short time\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop5(int start, int stop) {\n+        start= Integer.max(start, 0);\n+        stop= Integer.min(stop, 999);\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopConstantBoundsShortLoop5\")\n+    public static void testLongLoopConstantBoundsShortLoop5_runner() {\n+        int res = testLongLoopConstantBoundsShortLoop5(0, 100);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check that loop nest is created when bounds are known and loop is not short run\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static int testLongLoopConstantBoundsLongLoop1() {\n+        final long stride = Integer.MAX_VALUE \/ 1000;\n+        int j = 0;\n+        for (long i = 0; i < stride * 1001; i += stride) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsLongLoop1\")\n+    public static void checkTestLongLoopConstantBoundsLongLoop1(int res) {\n+        if (res != 1001) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Same with negative stride\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static int testLongLoopConstantBoundsLongLoop2() {\n+        final long stride = Integer.MAX_VALUE \/ 1000;\n+        int j = 0;\n+        for (long i = stride * 1000; i >= 0; i -= stride) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsLongLoop2\")\n+    public static void checkTestLongLoopConstantBoundsLongLoop2(int res) {\n+        if (res != 1001) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are unknown but profile reports a short running loop\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static int testLongLoopUnknownBoundsShortLoop(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoop_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop(0, 100);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ same with stride > 1\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static int testLongLoopUnknownBoundsShortLoop2(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i < stop; i+=20) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop2\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoop2_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop2(0, 2000);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ same with negative stride\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static int testLongLoopUnknownBoundsShortLoop3(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i >= stop; i--) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop3\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoop3_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop3(99, 0);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ same with negative stride > 1\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static int testLongLoopUnknownBoundsShortLoop4(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i >= stop; i -= 20) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop4\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoop4_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop4(1999, 0);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check that loop nest is created when bounds are not known but profile reports loop is not short run\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\", IRNode.LOOP,  \"1\"})\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopUnknownBoundsLongLoop1(long start, long stop, long range) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            Objects.checkIndex(i * (1024 * 1024), range); \/\/ max number of iteration of inner loop is roughly Integer.MAX_VALUE \/ 1024 \/ 1024\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsLongLoop1\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsLongLoop1_runner() {\n+        int res = testLongLoopUnknownBoundsLongLoop1(0, 3000, Long.MAX_VALUE);\n+        if (res != 3000) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ same with negative stride\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\", IRNode.LOOP,  \"1\"})\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopUnknownBoundsLongLoop2(long start, long stop, long range) {\n+        int j = 0;\n+        for (long i = start; i >= stop; i--) {\n+            volatileField = 42;\n+            Objects.checkIndex(i * (1024 * 1024), range); \/\/ max number of iteration of inner loop is roughly Integer.MAX_VALUE \/ 1024 \/ 1024\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsLongLoop2\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsLongLoop2_runner() {\n+        int res = testLongLoopUnknownBoundsLongLoop2(2999, 0, Long.MAX_VALUE);\n+        if (res != 3000) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check IR has a loop nest when bounds are unknown, profile reports a short running loop but trap is taken\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.LOOP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopUnknownBoundsShortLoopFailedSpeculation(long start, long stop, long range) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            Objects.checkIndex(i * (1024 * 1024), range); \/\/ max number of iteration of inner loop is roughly Integer.MAX_VALUE \/ 1024 \/ 1024\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoopFailedSpeculation\")\n+    @Warmup(1)\n+    public static void testLongLoopUnknownBoundsShortLoopFailedSpeculation_runner(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            for (int i = 0; i < 10_0000; i++) {\n+                int res = testLongLoopUnknownBoundsShortLoopFailedSpeculation(0, 100, Long.MAX_VALUE);\n+                if (res != 100) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+            wb.enqueueMethodForCompilation(info.getTest(), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            if (!wb.isMethodCompiled(info.getTest())) {\n+                throw new RuntimeException(\"Should be compiled now\");\n+            }\n+            for (int i = 0; i < 10; i++) {\n+                int res = testLongLoopUnknownBoundsShortLoopFailedSpeculation(0, 10_000, Long.MAX_VALUE);\n+                if (res != 10_000) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+        } else {\n+            int res = testLongLoopUnknownBoundsShortLoopFailedSpeculation(0, 100, Long.MAX_VALUE);\n+            if (res != 100) {\n+                throw new RuntimeException(\"incorrect result: \" + res);\n+            }\n+        }\n+    }\n+\n+    \/\/ Check IR has a loop nest when bounds are known, is short running loop but trap was taken\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\"  })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopKnownBoundsShortLoopFailedSpeculation() {\n+        return testLongLoopKnownBoundsShortLoopFailedSpeculationHelper(0, 100);\n+    }\n+\n+    @ForceInline\n+    private static int testLongLoopKnownBoundsShortLoopFailedSpeculationHelper(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopKnownBoundsShortLoopFailedSpeculation\")\n+    @Warmup(1)\n+    public static void testLongLoopKnownBoundsShortLoopFailedSpeculation_runner(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            for (int i = 0; i < 10_0000; i++) {\n+                int res = testLongLoopKnownBoundsShortLoopFailedSpeculationHelper(0, 100);\n+                if (res != 100) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+            for (int i = 0; i < 10; i++) {\n+                int res = testLongLoopKnownBoundsShortLoopFailedSpeculationHelper(0, 10_000);\n+                if (res != 10_000) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+            for (int i = 0; i < 10_0000; i++) {\n+                int res = testLongLoopKnownBoundsShortLoopFailedSpeculation();\n+                if (res != 100) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+        } else {\n+            int res = testLongLoopKnownBoundsShortLoopFailedSpeculation();\n+            if (res != 100) {\n+                throw new RuntimeException(\"incorrect result: \" + res);\n+            }\n+        }\n+    }\n+\n+    \/\/ Check range check can be eliminated by predication\n+    @Test\n+    @IR(counts = { IRNode.PREDICATE_TRAP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static void testLongLoopConstantBoundsPredication(long range) {\n+        for (long i = 0; i < 100; i++) {\n+            Objects.checkIndex(i, range);\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopConstantBoundsPredication\")\n+    public static void testLongLoopConstantBoundsPredication_runner() {\n+        testLongLoopConstantBoundsPredication(100);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.PREDICATE_TRAP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static void testLongLoopUnknownBoundsShortLoopPredication(long start, long stop, long range) {\n+        for (long i = start; i < stop; i++) {\n+            Objects.checkIndex(i, range);\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoopPredication\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoopPredication_runner() {\n+        testLongLoopUnknownBoundsShortLoopPredication(0, 100, 100);\n+    }\n+\n+    \/\/ If scale too large, transformation can't happen\n+    static final long veryLargeScale = Integer.MAX_VALUE \/ 99;\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\", IRNode.PREDICATE_TRAP, \"2\"})\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static void testLongLoopConstantBoundsLargeScale(long range) {\n+        for (long i = 0; i < 100; i++) {\n+            Objects.checkIndex(veryLargeScale * i, range);\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopConstantBoundsLargeScale\")\n+    public static void testLongLoopConstantBoundsLargeScale_runner() {\n+        testLongLoopConstantBoundsLargeScale(veryLargeScale * 100);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\", IRNode.PREDICATE_TRAP, \"2\"})\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static void testLongLoopUnknownBoundsShortLoopLargeScale(long start, long stop, long range) {\n+        for (long i = start; i < stop; i++) {\n+            Objects.checkIndex(veryLargeScale * i, range);\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoopLargeScale\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoopLargeScale_runner() {\n+        testLongLoopUnknownBoundsShortLoopLargeScale(0, 100, veryLargeScale * 100);\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are known and loop run for a short time (int loop case)\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.PREDICATE_TRAP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static void testIntLoopConstantBoundsShortLoop1(long range) {\n+        for (int i = 0; i < 100; i++) {\n+            Objects.checkIndex(i, range);\n+            volatileField = 42;\n+        }\n+    }\n+\n+    @Run(test = \"testIntLoopConstantBoundsShortLoop1\")\n+    public static void testIntLoopConstantBoundsShortLoop1_runner() {\n+        testIntLoopConstantBoundsShortLoop1(100);\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are unknown but profile reports a short running loop (int loop case)\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.PREDICATE_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static void testIntLoopUnknownBoundsShortLoop(int start, int stop, long range) {\n+        for (int i = start; i < stop; i++) {\n+            Objects.checkIndex(i, range);\n+            volatileField = 42;\n+        }\n+    }\n+\n+    @Run(test = \"testIntLoopUnknownBoundsShortLoop\")\n+    @Warmup(10_000)\n+    public static void testIntLoopUnknownBoundsShortLoop_runner() {\n+        testIntLoopUnknownBoundsShortLoop(0, 100, 100);\n+    }\n+\n+    \/\/ Same with unswitched loop\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"2\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.PREDICATE_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"2\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static void testIntLoopUnknownBoundsShortUnswitchedLoop(int start, int stop, long range, boolean flag) {\n+        for (int i = start; i < stop; i++) {\n+            if (flag) {\n+                Objects.checkIndex(i, range);\n+                volatileField = 42;\n+            } else {\n+                Objects.checkIndex(i, range);\n+                volatileField = 42;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"testIntLoopUnknownBoundsShortUnswitchedLoop\")\n+    @Warmup(10_000)\n+    public static void testIntLoopUnknownBoundsShortUnswitchedLoop_runner() {\n+        testIntLoopUnknownBoundsShortUnswitchedLoop(0, 100, 100, true);\n+        testIntLoopUnknownBoundsShortUnswitchedLoop(0, 100, 100, false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"2\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.PREDICATE_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"2\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static void testLongLoopUnknownBoundsShortUnswitchedLoop(long start, long stop, long range, boolean flag) {\n+        for (long i = start; i < stop; i++) {\n+            if (flag) {\n+                Objects.checkIndex(i, range);\n+                volatileField = 42;\n+            } else {\n+                Objects.checkIndex(i, range);\n+                volatileField = 42;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortUnswitchedLoop\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortUnswitchedLoop_runner() {\n+        testLongLoopUnknownBoundsShortUnswitchedLoop(0, 100, 100, true);\n+        testLongLoopUnknownBoundsShortUnswitchedLoop(0, 100, 100, false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static int testLongLoopUnknownBoundsAddLimitShortLoop(int stop1, long stop2) {\n+        int j = 0;\n+        for (long i = 0; i < stop1 + stop2; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsAddLimitShortLoop\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsAddLimitShortLoop_runner() {\n+        int res = testLongLoopUnknownBoundsAddLimitShortLoop(100, 0);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortRunningLongCountedLoop.java","additions":579,"deletions":0,"binary":false,"changes":579,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342692\n+ * @summary C2: long counted loop\/long range checks: don't create loop-nest for short running loops\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:LoopMaxUnroll=0\n+ *                   TestShortRunningLongCountedLoopPredicatesClone\n+ * @run main\/othervm TestShortRunningLongCountedLoopPredicatesClone\n+ *\/\n+\n+import java.util.Objects;\n+\n+\/\/ Predicate added after int counted loop is created depends on\n+\/\/ narrowed limit which depends on predicate added before the int\n+\/\/ counted loop was created: predicates need to be properly ordered.\n+public class TestShortRunningLongCountedLoopPredicatesClone {\n+    public static void main(String[] args) {\n+        A a = new A(100);\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(a, 0);\n+        }\n+    }\n+\n+    private static void test1(A a, long start) {\n+        long i = start;\n+        do {\n+            synchronized (new Object()) {}\n+            Objects.checkIndex(i, a.range);\n+            i++;\n+        } while (i < a.range);\n+    }\n+\n+    static class A {\n+        A(long range) {\n+            this.range = range;\n+        }\n+\n+        long range;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortRunningLongCountedLoopPredicatesClone.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342692\n+ * @summary C2: long counted loop\/long range checks: don't create loop-nest for short running loops\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:LoopMaxUnroll=0\n+ *                   -XX:-UseLoopPredicate -XX:-RangeCheckElimination TestShortRunningLongCountedLoopScaleOverflow\n+ * @run main\/othervm TestShortRunningLongCountedLoopScaleOverflow\n+ *\/\n+\n+import java.util.Objects;\n+\n+\/\/ When scale is large, even if loop is short running having a single\n+\/\/ counted loop is not possible.\n+public class TestShortRunningLongCountedLoopScaleOverflow {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(Integer.MAX_VALUE, 0);\n+            test2(Integer.MAX_VALUE, 0, 100);\n+        }\n+        boolean exception = false;\n+        try {\n+            test1(Integer.MAX_VALUE, 10);\n+        } catch (IndexOutOfBoundsException indexOutOfBoundsException) {\n+            exception = true;\n+        }\n+        if (!exception) {\n+            throw new RuntimeException(\"Expected exception not thrown\");\n+        }\n+        exception = false;\n+        try {\n+            test2(Integer.MAX_VALUE, 10, 100);\n+        } catch (IndexOutOfBoundsException indexOutOfBoundsException) {\n+            exception = true;\n+        }\n+        if (!exception) {\n+            throw new RuntimeException(\"Expected exception not thrown\");\n+        }\n+    }\n+\n+    static final long veryLargeScale = 1 << 29;\n+\n+    private static void test1(long range, long j) {\n+        Objects.checkIndex(0, range);\n+        for (long i = 0; i < 100; i++) {\n+            if (i == j) {\n+                Objects.checkIndex(veryLargeScale * i, range);\n+            }\n+        }\n+    }\n+\n+    private static void test2(long range, long j, long stop) {\n+        Objects.checkIndex(0, range);\n+        for (long i = 0; i < stop; i++) {\n+            if (i == j) {\n+                Objects.checkIndex(veryLargeScale * i, range);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortRunningLongCountedLoopScaleOverflow.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.longcountedloops;\n+import jdk.internal.misc.Unsafe;\n+\n+import java.util.Objects;\n+\/*\n+ * @test\n+ * @bug 8342692\n+ * @summary C2: long counted loop\/long range checks: don't create loop-nest for short running loops\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm -XX:-BackgroundCompilation compiler.longcountedloops.TestShortRunningLongCountedLoopVectorization\n+ *\/\n+\n+public class TestShortRunningLongCountedLoopVectorization {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1();\n+        }\n+    }\n+\n+    static int size = 1024;\n+    static long longSize = size;\n+    static int[] intArray = new int[size];\n+\n+    public static void test1() {\n+        boolean doIt = true;\n+        int localSize = Integer.max(Integer.min(size, 10000), 0);\n+        int i = 0;\n+        while (true) {\n+            synchronized (new Object()) {};\n+            if (i >= localSize) {\n+                break;\n+            }\n+            if (doIt) {\n+                volatileField = 42;\n+                doIt = false;\n+            }\n+            long j = Objects.checkIndex(i, longSize);\n+            UNSAFE.putInt(intArray, Unsafe.ARRAY_INT_BASE_OFFSET + j * Unsafe.ARRAY_INT_INDEX_SCALE, 42);\n+            i++;\n+        }\n+    }\n+};\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortRunningLongCountedLoopVectorization.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.longcountedloops;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8342692\n+ * @summary C2: long counted loop\/long range checks: don't create loop-nest for short running loops\n+ * @library \/test\/lib \/\n+ * @run driver compiler.longcountedloops.TestStressShortRunningLongCountedLoop\n+ *\/\n+\n+public class TestStressShortRunningLongCountedLoop {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=0\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+StressShortRunningLongLoop\");\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=0\",  \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-StressShortRunningLongLoop\");\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"StressShortRunningLongLoop\", \"true\" }, counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(applyIf = { \"StressShortRunningLongLoop\", \"true\" }, failOn = { IRNode.LOOP })\n+    @IR(applyIf = { \"StressShortRunningLongLoop\", \"false\" }, counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.LOOP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(applyIf = { \"StressShortRunningLongLoop\", \"false\" }, failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopUnknownBoundsShortLoop(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop\")\n+    @Warmup(0)\n+    public static void testLongLoopUnknownBoundsShortLoop_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop(0, 100);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestStressShortRunningLongCountedLoop.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -50,0 +50,17 @@\n+\/*\n+ * @test id=byte-array-NoShortRunningLongLoop\n+ * @bug 8329273 8342692\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector-NoShortRunningLongLoop\n+ * @bug 8329273 8348263 8342692\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\n@@ -175,0 +192,7 @@\n+        for (int i = 1; i < args.length; i++) {\n+            String tag = args[i];\n+            switch (tag) {\n+                case \"AlignVector\" ->                framework.addFlags(\"-XX:+AlignVector\");\n+                case \"NoShortRunningLongLoop\" ->     framework.addFlags(\"-XX:-ShortRunningLongLoop\");\n+            }\n+        }\n@@ -780,0 +804,7 @@\n+        applyIfAnd = { \"ShortRunningLongLoop\", \"false\", \"AlignVector\", \"false\" },\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfAnd = { \"ShortRunningLongLoop\", \"true\", \"AlignVector\", \"false\" },\n@@ -798,0 +829,7 @@\n+        applyIfAnd = { \"ShortRunningLongLoop\", \"false\", \"AlignVector\", \"false\" },\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfAnd = { \"ShortRunningLongLoop\", \"true\", \"AlignVector\", \"false\" },\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ *  Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import jdk.internal.misc.Unsafe;\n+import java.util.Objects;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgs = { \"--add-opens=java.base\/jdk.internal.misc=ALL-UNNAMED\" })\n+public class HeapMismatchManualLoopTest {\n+\n+    @Param({\"4\", \"8\", \"16\", \"32\", \"64\", \"128\"})\n+    public int ELEM_SIZE;\n+\n+    static final Unsafe unsafe = Utils.unsafe;\n+\n+    byte[] srcArray;\n+    byte[] dstArray;\n+    MemorySegment srcSegment;\n+    MemorySegment dstSegment;\n+    ByteBuffer srcBuffer;\n+    ByteBuffer dstBuffer;\n+    long srcByteSize;\n+    long dstByteSize;\n+\n+    @Setup\n+    public void setup() {\n+        srcArray = new byte[ELEM_SIZE];\n+        dstArray = new byte[ELEM_SIZE];\n+        srcSegment = MemorySegment.ofArray(srcArray);\n+        dstSegment = MemorySegment.ofArray(dstArray);\n+        srcBuffer = ByteBuffer.wrap(srcArray);\n+        dstBuffer = ByteBuffer.wrap(dstArray);\n+        srcByteSize = ELEM_SIZE;\n+        dstByteSize = ELEM_SIZE;\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int array_mismatch() {\n+        for (int i = 0; i < srcArray.length ; i++) {\n+            if (srcArray[i] != dstArray[i]) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public long segment_mismatch() {\n+        for (long i = 0; i < srcSegment.byteSize() ; i++) {\n+            if (srcSegment.get(ValueLayout.JAVA_BYTE, i) != dstSegment.get(ValueLayout.JAVA_BYTE, i)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int buffer_mismatch() {\n+        for (int i = 0; i < srcBuffer.capacity() ; i++) {\n+            if (srcBuffer.get(i) != dstBuffer.get(i)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public long unsafe_mismatch() {\n+        for (long i = 0; i < srcByteSize ; i++) {\n+            Objects.checkIndex(i, srcByteSize);\n+            Objects.checkIndex(i, dstByteSize);\n+            long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET + i * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n+            if (unsafe.getByte(srcArray, offset) != unsafe.getByte(dstArray, offset)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public long unsafe_mismatch2() {\n+        for (long i = 0; i < srcByteSize ; i++) {\n+            long offset = Unsafe.ARRAY_BYTE_BASE_OFFSET + i * Unsafe.ARRAY_BYTE_INDEX_SCALE;\n+            if (unsafe.getByte(srcArray, offset) != unsafe.getByte(dstArray, offset)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/HeapMismatchManualLoopTest.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"}]}