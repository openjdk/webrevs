{"files":[{"patch":"@@ -809,0 +809,4 @@\n+                                                                            \\\n+  product(uintx, ShortLoopIter, 1000,                                       \\\n+          \"Number of iterations for a short running loop\")                  \\\n+          range(0, max_juint)                                               \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -242,6 +242,7 @@\n-  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n-    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n-    phase->C->record_for_post_loop_opts_igvn(this);\n-  }\n-  if (!_range_check_dependency) {\n-    return optimize_integer_cast(phase, T_INT);\n+  if (can_reshape && !_range_check_dependency) {\n+    if (!phase->C->post_loop_opts_phase()) {\n+      \/\/ makes sure we run ::Value to potentially remove type assertion and optimize_integer_cast() after loop opts\n+      phase->C->record_for_post_loop_opts_igvn(this);\n+    } else {\n+      return optimize_integer_cast(phase, T_INT);\n+    }\n@@ -309,1 +310,1 @@\n-    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    \/\/ makes sure we run ::Value to potentially remove type assertion and optimize_integer_cast() after loop opts\n@@ -332,1 +333,4 @@\n-  return optimize_integer_cast(phase, T_LONG);\n+  if (phase->C->post_loop_opts_phase()) {\n+    return optimize_integer_cast(phase, T_LONG);\n+  }\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4087,0 +4087,3 @@\n+  \/\/ Will narrow the limit down with a cast node. Predicates added later may depend on the cast so should be last when\n+  \/\/ starting from the loop.\n+  add_parse_predicate(Deoptimization::Reason_short_running_loop, nargs);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2176,0 +2176,1 @@\n+    case Deoptimization::Reason_short_running_loop:\n@@ -2215,0 +2216,3 @@\n+    case Deoptimization::DeoptReason::Reason_short_running_loop:\n+      st->print(\"Short_Running_Loop \");\n+      break;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -276,3 +276,3 @@\n-IfProjNode* PhaseIdealLoop::clone_parse_predicate_to_unswitched_loop(ParsePredicateSuccessProj* parse_predicate_proj,\n-                                                                     Node* new_entry, Deoptimization::DeoptReason reason,\n-                                                                     const bool slow_loop) {\n+IfProjNode* PhaseIdealLoop::clone_parse_predicate(ParsePredicateSuccessProj* parse_predicate_proj,\n+                                                  Node* new_entry, Deoptimization::DeoptReason reason,\n+                                                  const bool slow_loop) {\n@@ -303,3 +303,13 @@\n-  Node_List to_process;\n-  IfNode* iff = old_predicate_proj->in(0)->as_If();\n-  IfProjNode* uncommon_proj = iff->proj_out(1 - old_predicate_proj->as_Proj()->_con)->as_IfProj();\n+  clone_assertion_predicates_to_slow_unswitched_loop(loop, old_new, reason, list, slow_loop_parse_predicate_proj);\n+  clone_assertion_predicates(loop, reason, list, fast_loop_parse_predicate_proj);\n+}\n+\n+void PhaseIdealLoop::clone_assertion_predicates(IdealLoopTree* loop,\n+                                                Deoptimization::DeoptReason reason,\n+                                                const Unique_Node_List &list,\n+                                                ParsePredicateSuccessProj*\n+                                                fast_loop_parse_predicate_proj) {\n+  assert(fast_loop_parse_predicate_proj->in(0)->is_ParsePredicate(), \"sanity check\");\n+  \/\/ Only need to clone range check predicates as those can be changed and duplicated by inserting pre\/main\/post loops\n+  \/\/ and doing loop unrolling. Push the original predicates on a list to later process them in reverse order to keep the\n+  \/\/ original predicate order.\n@@ -311,1 +321,1 @@\n-    iff = predicate->in(0)->as_If();\n+    IfNode* iff = predicate->in(0)->as_If();\n@@ -317,2 +327,0 @@\n-    IfProjNode* slow_proj = clone_assertion_predicate_for_unswitched_loops(iff, predicate_proj, reason, slow_loop_parse_predicate_proj);\n-    assert(assertion_predicate_has_loop_opaque_node(slow_proj->in(0)->as_If()), \"must find Assertion Predicate for slow loop\");\n@@ -323,0 +331,34 @@\n+      if (loop->is_member(get_loop(ctrl_or_self(fast_node)))) {\n+        assert(fast_node->in(0) == predicate, \"only control edge\");\n+        _igvn.replace_input_of(fast_node, 0, fast_proj);\n+        --j;\n+      }\n+    }\n+  }\n+}\n+\n+void PhaseIdealLoop::clone_assertion_predicates_to_slow_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new,\n+                                                                        Deoptimization::DeoptReason reason,\n+                                                                        const Unique_Node_List& list,\n+                                                                        ParsePredicateSuccessProj*\n+                                                                        slow_loop_parse_predicate_proj) {\n+  assert(slow_loop_parse_predicate_proj->in(0)->is_ParsePredicate(), \"sanity check\");\n+  \/\/ Only need to clone range check predicates as those can be changed and duplicated by inserting pre\/main\/post loops\n+  \/\/ and doing loop unrolling. Push the original predicates on a list to later process them in reverse order to keep the\n+  \/\/ original predicate order.\n+  Node_List to_process;\n+  \/\/ Process in reverse order such that 'create_new_if_for_predicate' can be used in\n+  \/\/ 'clone_assertion_predicate_for_unswitched_loops' and the original order is maintained.\n+  for (int i = list.size() - 1; i >= 0; i--) {\n+    Node* predicate = list.at(i);\n+    assert(predicate->in(0)->is_If(), \"must be If node\");\n+    IfNode* iff = predicate->in(0)->as_If();\n+    assert(predicate->is_Proj() && predicate->as_Proj()->is_IfProj(), \"predicate must be a projection of an if node\");\n+    IfProjNode* predicate_proj = predicate->as_IfProj();\n+\n+    IfProjNode* slow_proj = clone_assertion_predicate_for_unswitched_loops(iff, predicate_proj, reason, slow_loop_parse_predicate_proj);\n+    assert(assertion_predicate_has_loop_opaque_node(slow_proj->in(0)->as_If()), \"must find Assertion Predicate for slow loop\");\n+\n+    \/\/ Update control dependent data nodes.\n+    for (DUIterator_Fast jmax, j = predicate->fast_outs(jmax); j < jmax; j++) {\n+      Node* fast_node = predicate->fast_out(j);\n@@ -327,1 +369,0 @@\n-        _igvn.replace_input_of(fast_node, 0, fast_proj);\n@@ -329,1 +370,0 @@\n-        --j;\n@@ -395,0 +435,5 @@\n+  const PredicateBlock* short_running_loop_predicate_block = predicates.short_running_loop_predicate_block();\n+  if (short_running_loop_predicate_block->has_parse_predicate()) {\n+    clone_parse_predicate_to_unswitched_loops(short_running_loop_predicate_block, Deoptimization::Reason_short_running_loop,\n+                                              iffast_pred, ifslow_pred);\n+  }\n@@ -431,1 +476,1 @@\n-  iffast_pred = clone_parse_predicate_to_unswitched_loop(parse_predicate_proj, iffast_pred, reason, false);\n+  iffast_pred = clone_parse_predicate(parse_predicate_proj, iffast_pred, reason, false);\n@@ -434,1 +479,1 @@\n-  ifslow_pred = clone_parse_predicate_to_unswitched_loop(parse_predicate_proj, ifslow_pred, reason, true);\n+  ifslow_pred = clone_parse_predicate(parse_predicate_proj, ifslow_pred, reason, true);\n@@ -1225,1 +1270,1 @@\n-    loop->compute_trip_count(this);\n+    loop->compute_trip_count(this, T_INT);\n@@ -1341,1 +1386,1 @@\n-    loop->compute_trip_count(this);\n+    loop->compute_trip_count(this, T_INT);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":60,"deletions":15,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -100,2 +100,2 @@\n-void IdealLoopTree::compute_trip_count(PhaseIdealLoop* phase) {\n-  if (!_head->as_Loop()->is_valid_counted_loop(T_INT)) {\n+void IdealLoopTree::compute_trip_count(PhaseIdealLoop* phase, BasicType loop_bt) {\n+  if (!_head->as_Loop()->is_valid_counted_loop(loop_bt)) {\n@@ -104,1 +104,1 @@\n-  CountedLoopNode* cl = _head->as_CountedLoop();\n+  BaseCountedLoopNode* cl = _head->as_BaseCountedLoop();\n@@ -124,7 +124,8 @@\n-    int stride_con = cl->stride_con();\n-    const TypeInt* init_type = phase->_igvn.type(init_n)->is_int();\n-    const TypeInt* limit_type = phase->_igvn.type(limit_n)->is_int();\n-    jlong init_con = (stride_con > 0) ? init_type->_lo : init_type->_hi;\n-    jlong limit_con = (stride_con > 0) ? limit_type->_hi : limit_type->_lo;\n-    int stride_m = stride_con - (stride_con > 0 ? 1 : -1);\n-    jlong trip_count = (limit_con - init_con + stride_m)\/stride_con;\n+    jlong stride_con = cl->stride_con();\n+    const TypeInteger* init_type = phase->_igvn.type(init_n)->is_integer(loop_bt);\n+    const TypeInteger* limit_type = phase->_igvn.type(limit_n)->is_integer(loop_bt);\n+\n+    jlong init_con = (stride_con > 0) ? init_type->lo_as_long() : init_type->hi_as_long();\n+    julong uinit_con = init_con;\n+    jlong limit_con = (stride_con > 0) ? limit_type->hi_as_long() : limit_type->lo_as_long();\n+    julong ulimit_con = limit_con;\n@@ -133,2 +134,25 @@\n-    trip_count = MAX2(trip_count, (jlong)1);\n-    if (trip_count < (jlong)max_juint) {\n+    julong udiff = 1;\n+    if (stride_con > 0 && limit_con > init_con) {\n+      udiff = ulimit_con - uinit_con;\n+    } else if (stride_con < 0 && limit_con < init_con) {\n+      udiff = uinit_con - ulimit_con;\n+    }\n+    julong utrip_count = udiff \/ ABS(stride_con);\n+    if (utrip_count * ABS(stride_con) != udiff) {\n+      utrip_count++;\n+    }\n+\n+#ifdef ASSERT\n+    if (loop_bt == T_INT) {\n+      jlong init_con = (stride_con > 0) ? init_type->is_int()->_lo : init_type->is_int()->_hi;\n+      jlong limit_con = (stride_con > 0) ? limit_type->is_int()->_hi : limit_type->is_int()->_lo;\n+      int stride_m = stride_con - (stride_con > 0 ? 1 : -1);\n+      jlong trip_count = (limit_con - init_con + stride_m)\/stride_con;\n+      \/\/ The loop body is always executed at least once even if init >= limit (for stride_con > 0) or\n+      \/\/ init <= limit (for stride_con < 0).\n+      trip_count = MAX2(trip_count, (jlong)1);\n+      assert(checked_cast<juint>(trip_count) == checked_cast<juint>(utrip_count), \"incorrect trip count computation\");\n+    }\n+#endif\n+\n+    if (utrip_count < max_unsigned_integer(loop_bt)) {\n@@ -137,2 +161,2 @@\n-        cl->set_exact_trip_count((uint)trip_count);\n-      } else if (cl->unrolled_count() == 1) {\n+        cl->set_exact_trip_count(utrip_count);\n+      } else if (loop_bt == T_LONG || cl->as_CountedLoop()->unrolled_count() == 1) {\n@@ -140,1 +164,1 @@\n-        cl->set_trip_count((uint)trip_count);\n+        cl->set_trip_count(utrip_count);\n@@ -2046,1 +2070,1 @@\n-      tty->print(\"Unroll %d(%2d) \", loop_head->unrolled_count()*2, loop_head->trip_count());\n+      tty->print(\"Unroll %d(%2ld) \", loop_head->unrolled_count()*2, loop_head->trip_count());\n@@ -2299,1 +2323,1 @@\n-    tty->print(\"MaxUnroll  %d \", cl->trip_count());\n+    tty->print(\"MaxUnroll  %ld \", cl->trip_count());\n@@ -3556,1 +3580,1 @@\n-  compute_trip_count(phase);\n+  compute_trip_count(phase, T_INT);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":42,"deletions":18,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -827,0 +827,2 @@\n+  assert(iters_limit > 0, \"can't be negative\");\n+\n@@ -828,1 +830,0 @@\n-  Node* incr = head->incr();\n@@ -859,1 +860,1 @@\n-  const Node* init = head->init_trip();\n+  Node* init = head->init_trip();\n@@ -878,1 +879,1 @@\n-    loop->compute_trip_count(this);\n+    loop->compute_trip_count(this, bt);\n@@ -891,0 +892,5 @@\n+  if (short_running_loop(loop, stride_con, range_checks, iters_limit)) {\n+    C->set_major_progress();\n+    return true;\n+  }\n+\n@@ -1091,0 +1097,1 @@\n+    add_parse_predicate(Deoptimization::Reason_short_running_loop, inner_head, outer_ilt, cloned_sfpt);\n@@ -1112,0 +1119,176 @@\n+\/\/ If bounds are known is the loop doesn't need an outer loop or profile data indicates it runs for less than\n+\/\/ ShortLoopIter, don't create the outer loop\n+bool PhaseIdealLoop::short_running_loop(IdealLoopTree* loop, jint stride_con, const Node_List &range_checks, uint iters_limit) {\n+  if (ShortLoopIter == 0) {\n+    return false;\n+  }\n+\n+  Node* x = loop->_head;\n+  BaseCountedLoopNode* head = x->as_BaseCountedLoop();\n+  BasicType bt = head->bt();\n+  Node* entry_control = head->skip_strip_mined()->in(LoopNode::EntryControl);\n+\n+  loop->compute_trip_count(this, bt);\n+  \/\/ Loop must run for no more than iter_limits as it guarantees no overflow of scale * iv in long range checks.\n+  bool known_short_running_loop = head->trip_count() <= iters_limit \/ ABS(stride_con);\n+  bool profile_short_running_loop = false;\n+  if (!known_short_running_loop) {\n+    loop->compute_profile_trip_cnt(this);\n+    profile_short_running_loop = !head->is_profile_trip_failed() && head->profile_trip_cnt() < ShortLoopIter && ShortLoopIter <= iters_limit \/ ABS(stride_con);\n+  }\n+\n+  if (!known_short_running_loop && !profile_short_running_loop) {\n+    return false;\n+  }\n+\n+  Node* limit = head->limit();\n+  Node* init = head->init_trip();\n+\n+  Node* new_limit;\n+  if (stride_con > 0) {\n+    new_limit = SubNode::make(limit, init, bt);\n+  } else {\n+    new_limit = SubNode::make(init, limit, bt);\n+  }\n+  register_new_node(new_limit, entry_control);\n+\n+  PhiNode* phi = head->phi()->as_Phi();\n+  const Type* new_phi_t = TypeInt::INT;\n+  if (profile_short_running_loop) {\n+    \/\/ Add a short_limit predicate. It's the last predicate when coming from the loop because a cast that's control\n+    \/\/ dependent on the short_limit predicate is added to narrow the limit and future predicates may be dependent on the\n+    \/\/ new limit (so have to be between the loop and short_limit predicate). The current limit could, itself, be\n+    \/\/ dependent on an existing predicate. Clone parse predicates below existing predicates to get proper ordering of\n+    \/\/ predicates when coming from the loop: future predicates, short_limit predicate, existing predicates.\n+    const Predicates predicates(entry_control);\n+    const PredicateBlock* short_running_loop_predicate_block = predicates.short_running_loop_predicate_block();\n+    if (!short_running_loop_predicate_block->has_parse_predicate()) { \/\/ already trapped\n+      return false;\n+    }\n+    const PredicateBlock* predicate_block = predicates.loop_predicate_block();\n+    ParsePredicateSuccessProj* parse_predicate_proj = short_running_loop_predicate_block-> parse_predicate_success_proj();\n+    Node* ctrl = entry_control;\n+    ctrl = clone_parse_predicate(parse_predicate_proj, ctrl,\n+                                                    Deoptimization::Reason_short_running_loop, true);\n+    Node* short_running_loop_ctrl = ctrl;\n+    if (predicate_block->has_parse_predicate()) {\n+      parse_predicate_proj = predicate_block->parse_predicate_success_proj();\n+      ctrl = clone_parse_predicate(parse_predicate_proj, ctrl, Deoptimization::Reason_predicate,\n+                                                      true);\n+      Unique_Node_List list;\n+      get_assertion_predicates(parse_predicate_proj, list);\n+      clone_assertion_predicates(loop, Deoptimization::Reason_predicate, list, ctrl->as_IfTrue());\n+    }\n+    const PredicateBlock* profiled_predicate_block = predicates.profiled_loop_predicate_block();\n+    if (profiled_predicate_block->has_parse_predicate()) {\n+      parse_predicate_proj = profiled_predicate_block->parse_predicate_success_proj();\n+      ctrl = clone_parse_predicate(parse_predicate_proj, ctrl,\n+                                                      Deoptimization::Reason_profile_predicate, true);\n+      Unique_Node_List list;\n+      get_assertion_predicates(parse_predicate_proj, list);\n+      clone_assertion_predicates(loop, Deoptimization::Reason_profile_predicate, list, ctrl->as_IfTrue());\n+    }\n+    assert(ctrl != entry_control, \"some parse predicates must have been inserted\");\n+    _igvn.replace_input_of(head->skip_strip_mined(), LoopNode::EntryControl, ctrl);\n+    set_idom(head->skip_strip_mined(), ctrl, dom_depth(head->skip_strip_mined()));\n+\n+    PredicateBlock inner_short_running_loop_predicate_block(short_running_loop_ctrl,\n+                                                            Deoptimization::Reason_short_running_loop);\n+    ParsePredicateSuccessProj* short_running_loop_predicate_proj = inner_short_running_loop_predicate_block.\n+        parse_predicate_success_proj();\n+    assert(short_running_loop_predicate_proj->in(0)->is_ParsePredicate(), \"must be parse predicate\");\n+\n+    jlong limit_long = ShortLoopIter * ABS(stride_con);\n+    Node* cmp_limit = CmpNode::make(new_limit, _igvn.integercon(limit_long, bt), bt);\n+    Node* bol = new BoolNode(cmp_limit, BoolTest::le);\n+    Node* new_predicate_proj = create_new_if_for_predicate(short_running_loop_predicate_proj,\n+                                                           nullptr,\n+                                                           Deoptimization::Reason_short_running_loop,\n+                                                           Op_If);\n+    Node* iff = new_predicate_proj->in(0);\n+    _igvn.replace_input_of(iff, 1, bol);\n+    register_new_node(cmp_limit, iff->in(0));\n+    register_new_node(bol, iff->in(0));\n+    new_limit = ConstraintCastNode::make_cast_for_basic_type(new_predicate_proj, new_limit,\n+                                                             TypeInteger::make(1, limit_long, Type::WidenMin, bt),\n+                                                             ConstraintCastNode::UnconditionalDependency, bt);\n+    register_new_node(new_limit, new_predicate_proj);\n+\n+#ifndef PRODUCT\n+    \/\/ report that the loop predication has been actually performed\n+    \/\/ for this loop\n+    if (TraceLoopLimitCheck) {\n+      tty->print_cr(\"Short Loop Check generated:\");\n+      debug_only(bol->dump(2);)\n+    }\n+#endif\n+    entry_control = head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  } else if (bt == T_LONG) {\n+    \/\/ We're turning a long counted loop into a regular loop that will be converted into an int count loop. That loop\n+    \/\/ won't need loop limit checks (iters_limit guarantees that). Add a cast to make sure that, whatever transformation\n+    \/\/ happens by the time the counted loop is created, c2 knows enough about the loop's limit that it doesn't try to\n+    \/\/ add loop limit checks.\n+    const Predicates predicates(entry_control);\n+    const TypeLong* new_limit_t = new_limit->Value(&_igvn)->is_long();\n+    new_limit = ConstraintCastNode::make_cast_for_basic_type(predicates.entry(), new_limit,\n+                                                             TypeLong::make(0, new_limit_t->_hi, new_limit_t->_widen),\n+                                                             ConstraintCastNode::UnconditionalDependency, bt);\n+    register_new_node(new_limit, predicates.entry());\n+  }\n+  IfNode* exit_test = head->loopexit();\n+\n+  if (bt == T_LONG) {\n+    new_limit = new ConvL2INode(new_limit);\n+    register_new_node(new_limit, entry_control);\n+  }\n+\n+  Node* int_zero = _igvn.intcon(0);\n+  set_ctrl(int_zero, C->root());\n+  if (stride_con < 0) {\n+    new_limit = new SubINode(int_zero, new_limit);\n+    register_new_node(new_limit, entry_control);\n+  }\n+\n+  \/\/ Clone the iv data nodes as an integer iv\n+  Node* int_stride = _igvn.intcon(stride_con);\n+  set_ctrl(int_stride, C->root());\n+  Node* inner_phi = new PhiNode(head, new_phi_t);\n+  Node* inner_incr = new AddINode(inner_phi, int_stride);\n+  Node* inner_cmp = nullptr;\n+  inner_cmp = new CmpINode(inner_incr, new_limit);\n+  Node* inner_bol = new BoolNode(inner_cmp, exit_test->in(1)->as_Bool()->_test._test);\n+  inner_phi->set_req(LoopNode::EntryControl, int_zero);\n+  inner_phi->set_req(LoopNode::LoopBackControl, inner_incr);\n+  register_new_node(inner_phi, head);\n+  register_new_node(inner_incr, head);\n+  register_new_node(inner_cmp, head);\n+  register_new_node(inner_bol, head);\n+\n+  _igvn.replace_input_of(exit_test, 1, inner_bol);\n+\n+  \/\/ Replace inner loop long iv phi as inner loop int iv phi + outer\n+  \/\/ loop iv phi\n+  Node* iv_add = loop_nest_replace_iv(phi, inner_phi, init, head, bt);\n+\n+  LoopNode* inner_head = head;\n+  if (bt == T_LONG) {\n+    \/\/ Turn the loop back to a counted loop\n+    inner_head = create_inner_head(loop, head, exit_test);\n+  } else {\n+    \/\/ Use existing counted loop\n+    head->as_CountedLoop()->set_normal_loop();\n+  }\n+\n+  if (bt == T_INT) {\n+    init = new ConvI2LNode(init);\n+    register_new_node(init, entry_control);\n+  }\n+\n+  transform_long_range_checks(stride_con, range_checks, init, new_limit,\n+                              inner_phi, iv_add, inner_head);\n+\n+  inner_head->mark_loop_nest_inner_loop();\n+\n+  return true;\n+}\n+\n@@ -4220,0 +4403,3 @@\n+  if (predicates.short_running_loop_predicate_block()->is_non_empty()) {\n+    tty->print(\" short_running\");\n+  }\n@@ -4776,1 +4962,1 @@\n-        lpt->compute_trip_count(this);\n+        lpt->compute_trip_count(this, T_INT);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":190,"deletions":4,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -211,0 +211,12 @@\n+\n+  virtual void set_trip_count(julong tc) = 0;\n+  virtual julong trip_count() = 0;\n+\n+  bool has_exact_trip_count() const { return (_loop_flags & HasExactTripCount) != 0; }\n+  void set_exact_trip_count(julong tc) {\n+    set_trip_count(tc);\n+    _loop_flags |= HasExactTripCount;\n+  }\n+  void set_nonexact_trip_count() {\n+    _loop_flags &= ~HasExactTripCount;\n+  }\n@@ -289,0 +301,2 @@\n+  void set_trip_count(julong tc) { _trip_count = checked_cast<uint>(tc); }\n+  julong trip_count()            { return _trip_count; }\n@@ -295,11 +309,0 @@\n-  void set_trip_count(uint tc) { _trip_count = tc; }\n-  uint trip_count()            { return _trip_count; }\n-\n-  bool has_exact_trip_count() const { return (_loop_flags & HasExactTripCount) != 0; }\n-  void set_exact_trip_count(uint tc) {\n-    _trip_count = tc;\n-    _loop_flags |= HasExactTripCount;\n-  }\n-  void set_nonexact_trip_count() {\n-    _loop_flags &= ~HasExactTripCount;\n-  }\n@@ -340,0 +343,6 @@\n+private:\n+  virtual uint size_of() const { return sizeof(*this); }\n+\n+  \/\/ Known trip count calculated by compute_exact_trip_count()\n+  julong _trip_count;\n+\n@@ -352,0 +361,3 @@\n+  void set_trip_count(julong tc) { _trip_count = tc; }\n+  julong trip_count()            { return _trip_count; }\n+\n@@ -733,1 +745,1 @@\n-  void compute_trip_count(PhaseIdealLoop* phase);\n+  void compute_trip_count(PhaseIdealLoop* phase, BasicType bt);\n@@ -1673,2 +1685,3 @@\n-  IfProjNode* clone_parse_predicate_to_unswitched_loop(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n-                                                       Deoptimization::DeoptReason reason, bool slow_loop);\n+\n+  IfProjNode* clone_parse_predicate(ParsePredicateSuccessProj* parse_predicate_proj, Node* new_entry,\n+                                    Deoptimization::DeoptReason reason, bool slow_loop);\n@@ -1679,1 +1692,15 @@\n-  IfProjNode* clone_assertion_predicate_for_unswitched_loops(IfNode* template_assertion_predicate, IfProjNode* predicate,\n+\n+  void clone_assertion_predicates(IdealLoopTree* loop,\n+                                  Deoptimization::DeoptReason reason,\n+                                  const Unique_Node_List &list,\n+                                  ParsePredicateSuccessProj*\n+                                  fast_loop_parse_predicate_proj);\n+\n+  void clone_assertion_predicates_to_slow_unswitched_loop(IdealLoopTree* loop, const Node_List &old_new,\n+                                                          Deoptimization::DeoptReason reason,\n+                                                          const Unique_Node_List &list,\n+                                                          ParsePredicateSuccessProj*\n+                                                          slow_loop_parse_predicate_proj);\n+\n+  IfProjNode* clone_assertion_predicate_for_unswitched_loops(IfNode* template_assertion_predicate,\n+                                                             IfProjNode* predicate,\n@@ -1794,0 +1821,1 @@\n+  bool short_running_loop(IdealLoopTree* loop, jint stride_con, const Node_List &range_checks, uint iters_limit);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":43,"deletions":15,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -98,0 +98,1 @@\n+          deopt_reason == Deoptimization::Reason_short_running_loop ||\n@@ -691,0 +692,2 @@\n+    tty->print_cr(\"- Short Running Loop Predicate Block:\");\n+    _short_running_loop_predicate_block.dump(\"  \");\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -693,1 +693,3 @@\n-    return loop_predicate_iterator.for_each(predicate_visitor);\n+    current = loop_predicate_iterator.for_each(predicate_visitor);\n+    PredicateBlockIterator short_running_loop_predicate_iterator(current, Deoptimization::Reason_short_running_loop);\n+    return short_running_loop_predicate_iterator.for_each(predicate_visitor);\n@@ -859,0 +861,1 @@\n+  const PredicateBlock _short_running_loop_predicate_block;\n@@ -869,1 +872,3 @@\n-        _entry(_loop_predicate_block.entry()) {}\n+        _short_running_loop_predicate_block(_loop_predicate_block.entry(),\n+                                            Deoptimization::Reason_short_running_loop),\n+        _entry(_short_running_loop_predicate_block.entry()) {}\n@@ -890,0 +895,4 @@\n+  const PredicateBlock* short_running_loop_predicate_block() const {\n+    return &_short_running_loop_predicate_block;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2731,0 +2731,1 @@\n+  \"short_running_loop\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+    Reason_short_running_loop,\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -806,0 +806,9 @@\n+inline julong max_unsigned_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return max_juint;\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return max_julong;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1352,0 +1352,5 @@\n+    public static final String SHORT_RUNNING_LOOP_TRAP = PREFIX + \"SHORT_RUNNING_LOOP_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(SHORT_RUNNING_LOOP_TRAP, \"short_running_loop\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342330\n+ * @summary C2: MemorySegment API slow with short running loops\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:LoopUnrollLimit=100\n+ *                   TestShortRunningIntLoopWithLongChecksPredicates\n+ *\/\n+\n+import java.util.Objects;\n+\n+\/\/ int RC is first eliminated by predication which causes assert\n+\/\/ predicate to be added. Then the loop is transformed to make it\n+\/\/ possible to optimize long RC. Finally unrolling happen which\n+\/\/ require the assert predicate to have been properly copied when the\n+\/\/ loop was transformed for the long range check.\n+public class TestShortRunningIntLoopWithLongChecksPredicates {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            helper1(100, array, 100);\n+            test1(1, 100);\n+        }\n+    }\n+\n+    private static void test1(int stop, long range) {\n+        int[] array = new int[3];\n+        helper1(stop, array, range);\n+    }\n+\n+    private static void helper1(int stop, int[] array, long range) {\n+        for (int i = 0; i < stop; i++) {\n+            if (i % 2 == 0) {\n+                array[i] = i;\n+            } else {\n+                volatileField = 42;\n+            }\n+            Objects.checkIndex(i, range);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortRunningIntLoopWithLongChecksPredicates.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,552 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.longcountedloops;\n+import compiler.lib.ir_framework.*;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.util.Objects;\n+\/*\n+ * @test\n+ * @bug 8342330\n+ * @summary C2: MemorySegment API slow with short running loops\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.longcountedloops.TestShortRunningLongCountedLoop\n+ *\/\n+\n+public class TestShortRunningLongCountedLoop {\n+    private static volatile int volatileField;\n+    private final static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=0\", \"-XX:ShortLoopIter=1000\", \"-XX:LoopStripMiningIter=1000\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:-UseProfiledLoopPredicate\");\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are known and loop run for a short time\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop1() {\n+        int j = 0;\n+        for (long i = 0; i < 100; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsShortLoop1\")\n+    public static void checkTestLongLoopConstantBoundsShortLoop1(int res) {\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Same with stride > 1\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop2() {\n+        int j = 0;\n+        for (long i = 0; i < 2000; i += 20) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsShortLoop2\")\n+    public static void checkTestLongLoopConstantBoundsShortLoop2(int res) {\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Same with loop going downward\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop3() {\n+        int j = 0;\n+        for (long i = 99; i >= 0; i--) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsShortLoop3\")\n+    public static void checkTestLongLoopConstantBoundsShortLoop3(int res) {\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Same with loop going downward and stride > 1\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop4() {\n+        int j = 0;\n+        for (long i = 1999; i >= 0; i-=20) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsShortLoop4\")\n+    public static void checkTestLongLoopConstantBoundsShortLoop4(int res) {\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are known but not exact and loop run for a short time\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop5(int start, int stop) {\n+        start= Integer.max(start, 0);\n+        stop= Integer.min(stop, 999);\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopConstantBoundsShortLoop5\")\n+    public static void testLongLoopConstantBoundsShortLoop5_runner() {\n+        int res = testLongLoopConstantBoundsShortLoop5(0, 100);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check that loop nest is created when bounds are known and loop is not short run\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static int testLongLoopConstantBoundsLongLoop1() {\n+        final long stride = Integer.MAX_VALUE \/ 1000;\n+        int j = 0;\n+        for (long i = 0; i < stride * 1001; i += stride) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsLongLoop1\")\n+    public static void checkTestLongLoopConstantBoundsLongLoop1(int res) {\n+        if (res != 1001) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Same with negative stride\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static int testLongLoopConstantBoundsLongLoop2() {\n+        final long stride = Integer.MAX_VALUE \/ 1000;\n+        int j = 0;\n+        for (long i = stride * 1000; i >= 0; i -= stride) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsLongLoop2\")\n+    public static void checkTestLongLoopConstantBoundsLongLoop2(int res) {\n+        if (res != 1001) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are unknown but profile reports a short running loop\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static int testLongLoopUnknownBoundsShortLoop(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoop_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop(0, 100);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ same with stride > 1\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static int testLongLoopUnknownBoundsShortLoop2(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i < stop; i+=20) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop2\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoop2_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop2(0, 2000);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ same with negative stride\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static int testLongLoopUnknownBoundsShortLoop3(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i >= stop; i--) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop3\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoop3_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop3(99, 0);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ same with negative stride > 1\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static int testLongLoopUnknownBoundsShortLoop4(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i >= stop; i -= 20) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop4\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoop4_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop4(1999, 0);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check that loop nest is created when bounds are not known but profile reports loop is not short run\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\", IRNode.LOOP,  \"1\"})\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopUnknownBoundsLongLoop1(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsLongLoop1\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsLongLoop1_runner() {\n+        int res = testLongLoopUnknownBoundsLongLoop1(0, 2000);\n+        if (res != 2000) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ same with negative stride\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\", IRNode.LOOP,  \"1\"})\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopUnknownBoundsLongLoop2(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i >= stop; i--) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsLongLoop2\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsLongLoop2_runner() {\n+        int res = testLongLoopUnknownBoundsLongLoop2(1999, 0);\n+        if (res != 2000) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check IR has a loop nest when bounds are unknown, profile reports a short running loop but trap is taken\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.LOOP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopUnknownBoundsShortLoopFailedSpeculation(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoopFailedSpeculation\")\n+    @Warmup(1)\n+    public static void testLongLoopUnknownBoundsShortLoopFailedSpeculation_runner(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            for (int i = 0; i < 10_0000; i++) {\n+                int res = testLongLoopUnknownBoundsShortLoopFailedSpeculation(0, 100);\n+                if (res != 100) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+            wb.enqueueMethodForCompilation(info.getTest(), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            if (!wb.isMethodCompiled(info.getTest())) {\n+                throw new RuntimeException(\"Should be compiled now\");\n+            }\n+            for (int i = 0; i < 10; i++) {\n+                int res = testLongLoopUnknownBoundsShortLoopFailedSpeculation(0, 10_000);\n+                if (res != 10_000) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+        } else {\n+            int res = testLongLoopUnknownBoundsShortLoopFailedSpeculation(0, 100);\n+            if (res != 100) {\n+                throw new RuntimeException(\"incorrect result: \" + res);\n+            }\n+        }\n+    }\n+\n+    \/\/ Check IR has a loop nest when bounds are known, is short running loop but trap was taken\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\"  })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopKnownBoundsShortLoopFailedSpeculation() {\n+        return testLongLoopKnownBoundsShortLoopFailedSpeculationHelper(0, 100);\n+    }\n+\n+    @ForceInline\n+    private static int testLongLoopKnownBoundsShortLoopFailedSpeculationHelper(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopKnownBoundsShortLoopFailedSpeculation\")\n+    @Warmup(1)\n+    public static void testLongLoopKnownBoundsShortLoopFailedSpeculation_runner(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            for (int i = 0; i < 10_0000; i++) {\n+                int res = testLongLoopKnownBoundsShortLoopFailedSpeculationHelper(0, 100);\n+                if (res != 100) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+            for (int i = 0; i < 10; i++) {\n+                int res = testLongLoopKnownBoundsShortLoopFailedSpeculationHelper(0, 10_000);\n+                if (res != 10_000) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+            for (int i = 0; i < 10_0000; i++) {\n+                int res = testLongLoopKnownBoundsShortLoopFailedSpeculation();\n+                if (res != 100) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+        } else {\n+            int res = testLongLoopKnownBoundsShortLoopFailedSpeculation();\n+            if (res != 100) {\n+                throw new RuntimeException(\"incorrect result: \" + res);\n+            }\n+        }\n+    }\n+\n+    \/\/ Check range check can be eliminated by predication\n+    @Test\n+    @IR(counts = { IRNode.PREDICATE_TRAP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static void testLongLoopConstantBoundsPredication(long range) {\n+        for (long i = 0; i < 100; i++) {\n+            Objects.checkIndex(i, range);\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopConstantBoundsPredication\")\n+    public static void testLongLoopConstantBoundsPredication_runner() {\n+        testLongLoopConstantBoundsPredication(100);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.PREDICATE_TRAP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static void testLongLoopUnknownBoundsShortLoopPredication(long start, long stop, long range) {\n+        for (long i = start; i < stop; i++) {\n+            Objects.checkIndex(i, range);\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoopPredication\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoopPredication_runner() {\n+        testLongLoopUnknownBoundsShortLoopPredication(0, 100, 100);\n+    }\n+\n+    \/\/ If scale too large, transformation can't happen\n+    static final long veryLargeScale = Integer.MAX_VALUE \/ 99;\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\", IRNode.PREDICATE_TRAP, \"2\"})\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static void testLongLoopConstantBoundsLargeScale(long range) {\n+        for (long i = 0; i < 100; i++) {\n+            Objects.checkIndex(veryLargeScale * i, range);\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopConstantBoundsLargeScale\")\n+    public static void testLongLoopConstantBoundsLargeScale_runner() {\n+        testLongLoopConstantBoundsLargeScale(veryLargeScale * 100);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\", IRNode.PREDICATE_TRAP, \"2\"})\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static void testLongLoopUnknownBoundsShortLoopLargeScale(long start, long stop, long range) {\n+        for (long i = start; i < stop; i++) {\n+            Objects.checkIndex(veryLargeScale * i, range);\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoopLargeScale\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoopLargeScale_runner() {\n+        testLongLoopUnknownBoundsShortLoopLargeScale(0, 100, veryLargeScale * 100);\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are known and loop run for a short time (int loop case)\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.PREDICATE_TRAP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static void testIntLoopConstantBoundsShortLoop1(long range) {\n+        for (int i = 0; i < 100; i++) {\n+            Objects.checkIndex(i, range);\n+            volatileField = 42;\n+        }\n+    }\n+\n+    @Run(test = \"testIntLoopConstantBoundsShortLoop1\")\n+    public static void testIntLoopConstantBoundsShortLoop1_runner() {\n+        testIntLoopConstantBoundsShortLoop1(100);\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are unknown but profile reports a short running loop (int loop case)\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.PREDICATE_TRAP, \"1\"  })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static void testIntLoopUnknownBoundsShortLoop(int start, int stop, long range) {\n+        for (int i = start; i < stop; i++) {\n+            Objects.checkIndex(i, range);\n+            volatileField = 42;\n+        }\n+    }\n+\n+    @Run(test = \"testIntLoopUnknownBoundsShortLoop\")\n+    @Warmup(10_000)\n+    public static void testIntLoopUnknownBoundsShortLoop_runner() {\n+        testIntLoopUnknownBoundsShortLoop(0, 100, 100);\n+    }\n+\n+    \/\/ Same with unswitched loop\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"2\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.PREDICATE_TRAP, \"1\"  })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static void testIntLoopUnknownBoundsShortUnswitchedLoop(int start, int stop, long range, boolean flag) {\n+        for (int i = start; i < stop; i++) {\n+            if (flag) {\n+                Objects.checkIndex(i, range);\n+                volatileField = 42;\n+            } else {\n+                Objects.checkIndex(i, range);\n+                volatileField = 42;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"testIntLoopUnknownBoundsShortUnswitchedLoop\")\n+    @Warmup(10_000)\n+    public static void testIntLoopUnknownBoundsShortUnswitchedLoop_runner() {\n+        testIntLoopUnknownBoundsShortUnswitchedLoop(0, 100, 100, true);\n+        testIntLoopUnknownBoundsShortUnswitchedLoop(0, 100, 100, false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"2\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.PREDICATE_TRAP, \"1\"  })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static void testLongLoopUnknownBoundsShortUnswitchedLoop(long start, long stop, long range, boolean flag) {\n+        for (long i = start; i < stop; i++) {\n+            if (flag) {\n+                Objects.checkIndex(i, range);\n+                volatileField = 42;\n+            } else {\n+                Objects.checkIndex(i, range);\n+                volatileField = 42;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortUnswitchedLoop\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortUnswitchedLoop_runner() {\n+        testLongLoopUnknownBoundsShortUnswitchedLoop(0, 100, 100, true);\n+        testLongLoopUnknownBoundsShortUnswitchedLoop(0, 100, 100, false);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortRunningLongCountedLoop.java","additions":552,"deletions":0,"binary":false,"changes":552,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342330\n+ * @summary C2: MemorySegment API slow with short running loops\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:LoopMaxUnroll=0\n+ *                   TestShortRunningLongCountedLoopPredicatesClone\n+ *\/\n+\n+import java.util.Objects;\n+\n+\/\/ Predicate added after int counted loop is created depends on\n+\/\/ narrowed limit which depends on predicate added before the int\n+\/\/ counted loop was created: predicates need to be properly ordered.\n+public class TestShortRunningLongCountedLoopPredicatesClone {\n+    public static void main(String[] args) {\n+        A a = new A(100);\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(a, 0);\n+        }\n+    }\n+\n+    private static void test1(A a, long start) {\n+        long i = start;\n+        do {\n+            synchronized (new Object()) {}\n+            Objects.checkIndex(i, a.range);\n+            i++;\n+        } while (i < a.range);\n+    }\n+\n+    static class A {\n+        A(long range) {\n+            this.range = range;\n+        }\n+\n+        long range;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortRunningLongCountedLoopPredicatesClone.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342330\n+ * @summary C2: MemorySegment API slow with short running loops\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:LoopMaxUnroll=0\n+ *                   -XX:-UseLoopPredicate -XX:-RangeCheckElimination TestShortRunningLongCountedLoopScaleOverflow\n+ *\/\n+\n+import java.util.Objects;\n+\n+\/\/ When scale is large, even if loop is short running having a single\n+\/\/ counted loop is not possible.\n+public class TestShortRunningLongCountedLoopScaleOverflow {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(Integer.MAX_VALUE, 0);\n+            test2(Integer.MAX_VALUE, 0, 100);\n+        }\n+        boolean exception = false;\n+        try {\n+            test1(Integer.MAX_VALUE, 10);\n+        } catch (IndexOutOfBoundsException indexOutOfBoundsException) {\n+            exception = true;\n+        }\n+        if (!exception) {\n+            throw new RuntimeException(\"Expected exception not thrown\");\n+        }\n+        exception = false;\n+        try {\n+            test2(Integer.MAX_VALUE, 10, 100);\n+        } catch (IndexOutOfBoundsException indexOutOfBoundsException) {\n+            exception = true;\n+        }\n+        if (!exception) {\n+            throw new RuntimeException(\"Expected exception not thrown\");\n+        }\n+    }\n+\n+    static final long veryLargeScale = 1 << 29;\n+\n+    private static void test1(long range, long j) {\n+        Objects.checkIndex(0, range);\n+        for (long i = 0; i < 100; i++) {\n+            if (i == j) {\n+                Objects.checkIndex(veryLargeScale * i, range);\n+            }\n+        }\n+    }\n+\n+    private static void test2(long range, long j, long stop) {\n+        Objects.checkIndex(0, range);\n+        for (long i = 0; i < stop; i++) {\n+            if (i == j) {\n+                Objects.checkIndex(veryLargeScale * i, range);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortRunningLongCountedLoopScaleOverflow.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}