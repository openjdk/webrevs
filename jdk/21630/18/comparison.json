{"files":[{"patch":"@@ -733,0 +733,1 @@\n+  declare_constant(Deoptimization::Reason_short_running_long_loop)        \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -836,0 +836,8 @@\n+                                                                            \\\n+  product(bool, ShortRunningLongLoop, true, DIAGNOSTIC,                     \\\n+          \"long counted loop\/long range checks: don't create loop nest if\"  \\\n+          \"loop runs for small enough number of iterations\")                \\\n+                                                                            \\\n+  develop(bool, StressShortRunningLongLoop, false,                          \\\n+          \"Speculate all long counted loops are short running when bounds\"  \\\n+          \"are unknown even if profile data doesn't say so\")                \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"opto\/cfgnode.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"loopnode.hpp\"\n@@ -326,0 +328,59 @@\n+bool CastLLNode::inner_loop_backedge(Node* proj) {\n+  if (proj != nullptr) {\n+    Node* ctrl_use = proj->unique_ctrl_out_or_null();\n+    if (ctrl_use != nullptr && ctrl_use->Opcode() == Op_Loop &&\n+        ctrl_use->in(2) == proj &&\n+        ctrl_use->as_Loop()->is_loop_nest_inner_loop()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool CastLLNode::cmp_used_at_inner_loop_exit_test(Node* cmp) {\n+  for (DUIterator_Fast imax, i = cmp->fast_outs(imax); i < imax; i++) {\n+    Node* bol = cmp->fast_out(i);\n+    if (bol->Opcode() == Op_Bool) {\n+      for (DUIterator_Fast jmax, j = bol->fast_outs(jmax); j < jmax; j++) {\n+        Node* iff = bol->fast_out(j);\n+        if (iff->Opcode() == Op_If) {\n+          Node* true_proj = iff->as_If()->proj_out_or_null(true);\n+          Node* false_proj = iff->as_If()->proj_out_or_null(false);\n+          if (inner_loop_backedge(true_proj) || inner_loop_backedge(false_proj)) {\n+            return true;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Find if this is a cast node added by PhaseIdealLoop::create_loop_nest() to narrow the number of iterations of the\n+\/\/ inner loop\n+bool CastLLNode::used_at_inner_loop_exit_test() {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* convl2i = fast_out(i);\n+    if (convl2i->Opcode() == Op_ConvL2I) {\n+      for (DUIterator_Fast jmax, j = convl2i->fast_outs(jmax); j < jmax; j++) {\n+        Node* cmp_or_sub = convl2i->fast_out(j);\n+        if (cmp_or_sub->Opcode() == Op_CmpI) {\n+          if (cmp_used_at_inner_loop_exit_test(cmp_or_sub)) {\n+            return true;\n+          }\n+        } else if (cmp_or_sub->Opcode() == Op_SubI && cmp_or_sub->in(1)->find_int_con(-1) == 0) {\n+          for (DUIterator_Fast kmax, k = cmp_or_sub->fast_outs(kmax); k < kmax; k++) {\n+            Node* cmp = cmp_or_sub->fast_out(k);\n+            if (cmp->Opcode() == Op_CmpI) {\n+              if (cmp_used_at_inner_loop_exit_test(cmp)) {\n+                return true;\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -355,1 +416,6 @@\n-  return optimize_integer_cast(phase, T_LONG);\n+  \/\/ if it's a cast created by PhaseIdealLoop::create_loop_nest(), don't transform it until the counted loop is created\n+  \/\/ in next loop opts pass\n+  if (!can_reshape || !used_at_inner_loop_exit_test()) {\n+    return optimize_integer_cast(phase, T_LONG);\n+  }\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":67,"deletions":1,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -141,0 +141,5 @@\n+\n+  bool inner_loop_backedge(Node* proj);\n+  bool cmp_used_at_inner_loop_exit_test(Node* cmp);\n+  bool used_at_inner_loop_exit_test();\n+\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4053,0 +4053,3 @@\n+  \/\/ Will narrow the limit down with a cast node. Predicates added later may depend on the cast so should be last when\n+  \/\/ starting from the loop.\n+  add_parse_predicate(Deoptimization::Reason_short_running_long_loop, nargs);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2182,0 +2182,1 @@\n+    case Deoptimization::Reason_short_running_long_loop:\n@@ -2230,0 +2231,3 @@\n+    case Deoptimization::DeoptReason::Reason_short_running_long_loop:\n+      st->print(\"Short_Running_Long_Loop \");\n+      break;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1056,1 +1056,1 @@\n-    loop->compute_trip_count(this);\n+    loop->compute_trip_count(this, T_INT);\n@@ -1173,1 +1173,1 @@\n-    loop->compute_trip_count(this);\n+    loop->compute_trip_count(this, T_INT);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -99,2 +99,2 @@\n-void IdealLoopTree::compute_trip_count(PhaseIdealLoop* phase) {\n-  if (!_head->as_Loop()->is_valid_counted_loop(T_INT)) {\n+void IdealLoopTree::compute_trip_count(PhaseIdealLoop* phase, BasicType loop_bt) {\n+  if (!_head->as_Loop()->is_valid_counted_loop(loop_bt)) {\n@@ -103,1 +103,1 @@\n-  CountedLoopNode* cl = _head->as_CountedLoop();\n+  BaseCountedLoopNode* cl = _head->as_BaseCountedLoop();\n@@ -123,7 +123,8 @@\n-    int stride_con = cl->stride_con();\n-    const TypeInt* init_type = phase->_igvn.type(init_n)->is_int();\n-    const TypeInt* limit_type = phase->_igvn.type(limit_n)->is_int();\n-    jlong init_con = (stride_con > 0) ? init_type->_lo : init_type->_hi;\n-    jlong limit_con = (stride_con > 0) ? limit_type->_hi : limit_type->_lo;\n-    int stride_m = stride_con - (stride_con > 0 ? 1 : -1);\n-    jlong trip_count = (limit_con - init_con + stride_m)\/stride_con;\n+    jlong stride_con = cl->stride_con();\n+    const TypeInteger* init_type = phase->_igvn.type(init_n)->is_integer(loop_bt);\n+    const TypeInteger* limit_type = phase->_igvn.type(limit_n)->is_integer(loop_bt);\n+\n+    jlong init_con = (stride_con > 0) ? init_type->lo_as_long() : init_type->hi_as_long();\n+    julong uinit_con = init_con;\n+    jlong limit_con = (stride_con > 0) ? limit_type->hi_as_long() : limit_type->lo_as_long();\n+    julong ulimit_con = limit_con;\n@@ -132,2 +133,25 @@\n-    trip_count = MAX2(trip_count, (jlong)1);\n-    if (trip_count < (jlong)max_juint) {\n+    julong udiff = 1;\n+    if (stride_con > 0 && limit_con > init_con) {\n+      udiff = ulimit_con - uinit_con;\n+    } else if (stride_con < 0 && limit_con < init_con) {\n+      udiff = uinit_con - ulimit_con;\n+    }\n+    julong utrip_count = udiff \/ ABS(stride_con);\n+    if (utrip_count * ABS(stride_con) != udiff) {\n+      utrip_count++;\n+    }\n+\n+#ifdef ASSERT\n+    if (loop_bt == T_INT) {\n+      jlong init_con = (stride_con > 0) ? init_type->is_int()->_lo : init_type->is_int()->_hi;\n+      jlong limit_con = (stride_con > 0) ? limit_type->is_int()->_hi : limit_type->is_int()->_lo;\n+      int stride_m = stride_con - (stride_con > 0 ? 1 : -1);\n+      jlong trip_count = (limit_con - init_con + stride_m) \/ stride_con;\n+      \/\/ The loop body is always executed at least once even if init >= limit (for stride_con > 0) or\n+      \/\/ init <= limit (for stride_con < 0).\n+      trip_count = MAX2(trip_count, (jlong)1);\n+      assert(checked_cast<juint>(trip_count) == checked_cast<juint>(utrip_count), \"incorrect trip count computation\");\n+    }\n+#endif\n+\n+    if (utrip_count < max_unsigned_integer(loop_bt)) {\n@@ -136,2 +160,2 @@\n-        cl->set_exact_trip_count((uint)trip_count);\n-      } else if (cl->unrolled_count() == 1) {\n+        cl->set_exact_trip_count(utrip_count);\n+      } else if (loop_bt == T_LONG || cl->as_CountedLoop()->unrolled_count() == 1) {\n@@ -139,1 +163,1 @@\n-        cl->set_trip_count((uint)trip_count);\n+        cl->set_trip_count(utrip_count);\n@@ -1831,1 +1855,1 @@\n-      tty->print(\"Unroll %d(%2d) \", loop_head->unrolled_count()*2, loop_head->trip_count());\n+      tty->print(\"Unroll %d(\" JULONG_FORMAT_W(2) \") \", loop_head->unrolled_count()*2, loop_head->trip_count());\n@@ -2080,1 +2104,1 @@\n-    tty->print(\"MaxUnroll  %d \", cl->trip_count());\n+    tty->print(\"MaxUnroll  \" JULONG_FORMAT \" \", cl->trip_count());\n@@ -3331,1 +3355,1 @@\n-  compute_trip_count(phase);\n+  compute_trip_count(phase, T_INT);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":42,"deletions":18,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -826,0 +826,2 @@\n+  assert(iters_limit > 0, \"can't be negative\");\n+\n@@ -827,1 +829,0 @@\n-  Node* incr = head->incr();\n@@ -858,1 +859,1 @@\n-  const Node* init = head->init_trip();\n+  Node* init = head->init_trip();\n@@ -877,1 +878,1 @@\n-    loop->compute_trip_count(this);\n+    loop->compute_trip_count(this, bt);\n@@ -890,0 +891,5 @@\n+  if (short_running_loop(loop, stride_con, range_checks, iters_limit)) {\n+    C->set_major_progress();\n+    return true;\n+  }\n+\n@@ -1088,0 +1094,1 @@\n+    add_parse_predicate(Deoptimization::Reason_short_running_long_loop, inner_head, outer_ilt, cloned_sfpt);\n@@ -1117,0 +1124,212 @@\n+class NodeInShortLoopBody : public NodeInLoopBody {\n+  PhaseIdealLoop* _phase;\n+  IdealLoopTree* _ilt;\n+\n+public:\n+  NodeInShortLoopBody(PhaseIdealLoop* phase, IdealLoopTree* ilt) : _phase(phase), _ilt(ilt) {\n+  }\n+  NONCOPYABLE(NodeInShortLoopBody);\n+\n+  bool check_node_in_loop_body(Node* node) const override {\n+    return _phase->is_member(_ilt, _phase->get_ctrl(node));\n+  }\n+};\n+\n+class CloneShortLoopPredicatesVisitor : public PredicateVisitor {\n+  ClonePredicateToTargetLoop _clone_predicate_to_loop;\n+\n+  PhaseIdealLoop* const _phase;\n+  bool _has_hoisted_check_parse_predicates;\n+\n+public:\n+  CloneShortLoopPredicatesVisitor(LoopNode* loop_head,\n+                                  const NodeInShortLoopBody& node_in_loop_body,\n+                                  PhaseIdealLoop* phase)\n+    : _clone_predicate_to_loop(loop_head, node_in_loop_body, phase),\n+      _phase(phase),\n+      _has_hoisted_check_parse_predicates(false) {\n+  }\n+  NONCOPYABLE(CloneShortLoopPredicatesVisitor);\n+\n+  using PredicateVisitor::visit;\n+\n+  void visit(const ParsePredicate& parse_predicate) override {\n+    Deoptimization::DeoptReason deopt_reason = parse_predicate.head()->deopt_reason();\n+    if (deopt_reason == Deoptimization::Reason_predicate ||\n+        deopt_reason == Deoptimization::Reason_profile_predicate) {\n+      _has_hoisted_check_parse_predicates = true;\n+    }\n+\n+    _clone_predicate_to_loop.clone_parse_predicate(parse_predicate, true);\n+    parse_predicate.kill(_phase->igvn());\n+  }\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override {\n+    if (!_has_hoisted_check_parse_predicates) {\n+      \/\/ Only process if we are in the correct Predicate Block.\n+      return;\n+    }\n+\n+    _clone_predicate_to_loop.clone_template_assertion_predicate(template_assertion_predicate);\n+    template_assertion_predicate.kill(_phase->igvn());\n+  }\n+};\n+\n+\/\/ If bounds are known is the loop doesn't need an outer loop or profile data indicates it runs for less than\n+\/\/ ShortLoopIter, don't create the outer loop\n+bool PhaseIdealLoop::short_running_loop(IdealLoopTree* loop, jint stride_con, const Node_List &range_checks, uint iters_limit) {\n+  if (!ShortRunningLongLoop) {\n+    return false;\n+  }\n+  BaseCountedLoopNode* head = loop->_head->as_BaseCountedLoop();\n+  BasicType bt = head->bt();\n+  Node* entry_control = head->skip_strip_mined()->in(LoopNode::EntryControl);\n+\n+  loop->compute_trip_count(this, bt);\n+  \/\/ Loop must run for no more than iter_limits as it guarantees no overflow of scale * iv in long range checks.\n+  bool known_short_running_loop = head->trip_count() <= iters_limit \/ ABS(stride_con);\n+  bool profile_short_running_loop = false;\n+  if (!known_short_running_loop) {\n+    loop->compute_profile_trip_cnt(this);\n+    if (StressShortRunningLongLoop) {\n+      profile_short_running_loop = true;\n+    } else {\n+      profile_short_running_loop = !head->is_profile_trip_failed() && head->profile_trip_cnt() < iters_limit \/ ABS(stride_con);\n+    }\n+  }\n+\n+  if (!known_short_running_loop && !profile_short_running_loop) {\n+    return false;\n+  }\n+\n+  Node* limit = head->limit();\n+  Node* init = head->init_trip();\n+\n+  Node* new_limit;\n+  if (stride_con > 0) {\n+    new_limit = SubNode::make(limit, init, bt);\n+  } else {\n+    new_limit = SubNode::make(init, limit, bt);\n+  }\n+  register_new_node(new_limit, entry_control);\n+\n+  PhiNode* phi = head->phi()->as_Phi();\n+  const Type* new_phi_t = TypeInt::INT;\n+  if (profile_short_running_loop) {\n+    \/\/ Add a short_limit predicate. It's the last predicate when coming from the loop because a cast that's control\n+    \/\/ dependent on the short_limit predicate is added to narrow the limit and future predicates may be dependent on the\n+    \/\/ new limit (so have to be between the loop and short_limit predicate). The current limit could, itself, be\n+    \/\/ dependent on an existing predicate. Clone parse predicates below existing predicates to get proper ordering of\n+    \/\/ predicates when walking from the loop up: future predicates, short_limit predicate, existing predicates.\n+    const Predicates predicates_before_cloning(entry_control);\n+    const PredicateBlock* short_running_loop_predicate_block = predicates_before_cloning.short_running_loop_predicate_block();\n+    if (!short_running_loop_predicate_block->has_parse_predicate()) { \/\/ already trapped\n+      return false;\n+    }\n+    PredicateIterator predicate_iterator(entry_control);\n+    NodeInShortLoopBody node_in_short_loop_body(this, loop);\n+    CloneShortLoopPredicatesVisitor clone_short_loop_predicates_visitor(head, node_in_short_loop_body, this);\n+    predicate_iterator.for_each(clone_short_loop_predicates_visitor);\n+\n+    entry_control = head->skip_strip_mined()->in(LoopNode::EntryControl);\n+\n+    const Predicates predicates_after_cloning(entry_control);\n+\n+    ParsePredicateSuccessProj* short_running_loop_predicate_proj = predicates_after_cloning.\n+        short_running_loop_predicate_block()->\n+        parse_predicate_success_proj();\n+    assert(short_running_loop_predicate_proj->in(0)->is_ParsePredicate(), \"must be parse predicate\");\n+\n+    jlong limit_long = iters_limit;\n+    Node* cmp_limit = CmpNode::make(new_limit, _igvn.integercon(limit_long, bt), bt);\n+    Node* bol = new BoolNode(cmp_limit, BoolTest::le);\n+    Node* new_predicate_proj = create_new_if_for_predicate(short_running_loop_predicate_proj,\n+                                                           nullptr,\n+                                                           Deoptimization::Reason_short_running_long_loop,\n+                                                           Op_If);\n+    Node* iff = new_predicate_proj->in(0);\n+    _igvn.replace_input_of(iff, 1, bol);\n+    register_new_node(cmp_limit, iff->in(0));\n+    register_new_node(bol, iff->in(0));\n+    new_limit = ConstraintCastNode::make_cast_for_basic_type(new_predicate_proj, new_limit,\n+                                                             TypeInteger::make(1, limit_long, Type::WidenMin, bt),\n+                                                             ConstraintCastNode::UnconditionalDependency, bt);\n+    register_new_node(new_limit, new_predicate_proj);\n+\n+#ifndef PRODUCT\n+    \/\/ report that the loop predication has been actually performed\n+    \/\/ for this loop\n+    if (TraceLoopLimitCheck) {\n+      tty->print_cr(\"Short Loop Check generated:\");\n+      DEBUG_ONLY(bol->dump(2);)\n+    }\n+#endif\n+    entry_control = head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  } else if (bt == T_LONG) {\n+    \/\/ We're turning a long counted loop into a regular loop that will be converted into an int count loop. That loop\n+    \/\/ won't need loop limit checks (iters_limit guarantees that). Add a cast to make sure that, whatever transformation\n+    \/\/ happens by the time the counted loop is created, c2 knows enough about the loop's limit that it doesn't try to\n+    \/\/ add loop limit checks.\n+    const Predicates predicates(entry_control);\n+    const TypeLong* new_limit_t = new_limit->Value(&_igvn)->is_long();\n+    new_limit = ConstraintCastNode::make_cast_for_basic_type(predicates.entry(), new_limit,\n+                                                             TypeLong::make(0, new_limit_t->_hi, new_limit_t->_widen),\n+                                                             ConstraintCastNode::UnconditionalDependency, bt);\n+    register_new_node(new_limit, predicates.entry());\n+  }\n+  IfNode* exit_test = head->loopexit();\n+\n+  if (bt == T_LONG) {\n+    new_limit = new ConvL2INode(new_limit);\n+    register_new_node(new_limit, entry_control);\n+  }\n+\n+  Node* int_zero = _igvn.intcon(0);\n+  set_ctrl(int_zero, C->root());\n+  if (stride_con < 0) {\n+    new_limit = new SubINode(int_zero, new_limit);\n+    register_new_node(new_limit, entry_control);\n+  }\n+\n+  \/\/ Clone the iv data nodes as an integer iv\n+  Node* int_stride = _igvn.intcon(stride_con);\n+  set_ctrl(int_stride, C->root());\n+  Node* inner_phi = new PhiNode(head, new_phi_t);\n+  Node* inner_incr = new AddINode(inner_phi, int_stride);\n+  Node* inner_cmp = nullptr;\n+  inner_cmp = new CmpINode(inner_incr, new_limit);\n+  Node* inner_bol = new BoolNode(inner_cmp, exit_test->in(1)->as_Bool()->_test._test);\n+  inner_phi->set_req(LoopNode::EntryControl, int_zero);\n+  inner_phi->set_req(LoopNode::LoopBackControl, inner_incr);\n+  register_new_node(inner_phi, head);\n+  register_new_node(inner_incr, head);\n+  register_new_node(inner_cmp, head);\n+  register_new_node(inner_bol, head);\n+\n+  _igvn.replace_input_of(exit_test, 1, inner_bol);\n+\n+  \/\/ Replace inner loop long iv phi as inner loop int iv phi + outer\n+  \/\/ loop iv phi\n+  Node* iv_add = loop_nest_replace_iv(phi, inner_phi, init, head, bt);\n+\n+  LoopNode* inner_head = head;\n+  if (bt == T_LONG) {\n+    \/\/ Turn the loop back to a counted loop\n+    inner_head = create_inner_head(loop, head, exit_test);\n+  } else {\n+    \/\/ Use existing counted loop\n+    head->as_CountedLoop()->set_normal_loop();\n+  }\n+\n+  if (bt == T_INT) {\n+    init = new ConvI2LNode(init);\n+    register_new_node(init, entry_control);\n+  }\n+\n+  transform_long_range_checks(stride_con, range_checks, init, new_limit,\n+                              inner_phi, iv_add, inner_head);\n+\n+  inner_head->mark_loop_nest_inner_loop();\n+\n+  return true;\n+}\n+\n@@ -4301,0 +4520,3 @@\n+  if (predicates.short_running_loop_predicate_block()->is_non_empty()) {\n+    tty->print(\" short_running\");\n+  }\n@@ -4808,1 +5030,1 @@\n-        lpt->compute_trip_count(this);\n+        lpt->compute_trip_count(this, T_INT);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":226,"deletions":4,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -217,0 +217,12 @@\n+\n+  virtual void set_trip_count(julong tc) = 0;\n+  virtual julong trip_count() = 0;\n+\n+  bool has_exact_trip_count() const { return (_loop_flags & HasExactTripCount) != 0; }\n+  void set_exact_trip_count(julong tc) {\n+    set_trip_count(tc);\n+    _loop_flags |= HasExactTripCount;\n+  }\n+  void set_nonexact_trip_count() {\n+    _loop_flags &= ~HasExactTripCount;\n+  }\n@@ -297,0 +309,2 @@\n+  void set_trip_count(julong tc) { _trip_count = checked_cast<uint>(tc); }\n+  julong trip_count()            { return _trip_count; }\n@@ -303,11 +317,0 @@\n-  void set_trip_count(uint tc) { _trip_count = tc; }\n-  uint trip_count()            { return _trip_count; }\n-\n-  bool has_exact_trip_count() const { return (_loop_flags & HasExactTripCount) != 0; }\n-  void set_exact_trip_count(uint tc) {\n-    _trip_count = tc;\n-    _loop_flags |= HasExactTripCount;\n-  }\n-  void set_nonexact_trip_count() {\n-    _loop_flags &= ~HasExactTripCount;\n-  }\n@@ -376,0 +379,6 @@\n+private:\n+  virtual uint size_of() const { return sizeof(*this); }\n+\n+  \/\/ Known trip count calculated by compute_exact_trip_count()\n+  julong _trip_count;\n+\n@@ -388,0 +397,3 @@\n+  void set_trip_count(julong tc) { _trip_count = tc; }\n+  julong trip_count()            { return _trip_count; }\n+\n@@ -769,1 +781,1 @@\n-  void compute_trip_count(PhaseIdealLoop* phase);\n+  void compute_trip_count(PhaseIdealLoop* phase, BasicType bt);\n@@ -1820,0 +1832,2 @@\n+  bool short_running_loop(IdealLoopTree* loop, jint stride_con, const Node_List& range_checks, uint iters_limit);\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":26,"deletions":12,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+          deopt_reason == Deoptimization::Reason_short_running_long_loop ||\n@@ -944,0 +945,2 @@\n+    tty->print_cr(\"- Short Running Loop Predicate Block:\");\n+    _short_running_loop_predicate_block.dump(\"  \");\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -789,1 +789,2 @@\n-    return current_node;\n+    PredicateBlockIterator short_running_loop_predicate_iterator(current_node, Deoptimization::Reason_short_running_long_loop);\n+    return short_running_loop_predicate_iterator.for_each(predicate_visitor);\n@@ -956,0 +957,1 @@\n+  const PredicateBlock _short_running_loop_predicate_block;\n@@ -968,1 +970,3 @@\n-        _entry(_loop_predicate_block.entry()) {}\n+        _short_running_loop_predicate_block(_loop_predicate_block.entry(),\n+                                            Deoptimization::Reason_short_running_long_loop),\n+        _entry(_short_running_loop_predicate_block.entry()) {}\n@@ -993,0 +997,4 @@\n+  const PredicateBlock* short_running_loop_predicate_block() const {\n+    return &_short_running_loop_predicate_block;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2750,0 +2750,1 @@\n+  \"short_running_loop\" JVMCI_ONLY(\"_or_aliasing\"),\n@@ -2751,1 +2752,0 @@\n-  \"aliasing\",\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,0 +120,1 @@\n+    Reason_short_running_long_loop,    \/\/ profile reports loop runs for small number of iterations\n@@ -121,1 +122,1 @@\n-    Reason_aliasing,              \/\/ optimistic assumption about aliasing failed\n+    Reason_aliasing = Reason_short_running_long_loop, \/\/ optimistic assumption about aliasing failed\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1564,0 +1564,1 @@\n+  declare_constant(Deoptimization::Reason_short_running_long_loop)        \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -151,0 +151,3 @@\n+#ifndef JULONG_FORMAT_W\n+#define JULONG_FORMAT_W(width)   UINT64_FORMAT_W(width)\n+#endif\n@@ -772,0 +775,8 @@\n+}\n+\n+inline julong max_unsigned_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return max_juint;\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return max_julong;\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+        TestFramework.runWithFlags(\"-XX:-ShortRunningLongLoop\", \"-XX:+TieredCompilation\", \"-XX:-UseCountedLoopSafepoints\", \"-XX:LoopUnrollLimit=0\");\n+        TestFramework.runWithFlags(\"-XX:-ShortRunningLongLoop\", \"-XX:+TieredCompilation\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1\", \"-XX:LoopUnrollLimit=0\");\n+        TestFramework.runWithFlags(\"-XX:-ShortRunningLongLoop\", \"-XX:+TieredCompilation\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\", \"-XX:LoopUnrollLimit=0\");\n@@ -48,1 +51,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -69,1 +73,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -87,1 +92,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -105,1 +111,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -121,1 +128,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -138,1 +146,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -155,1 +164,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -171,1 +181,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -187,1 +198,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -203,1 +215,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -219,1 +232,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n@@ -235,1 +249,2 @@\n-    @IR(counts = { IRNode.LOOP, \"1\"})\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"false\" }, counts = { IRNode.LOOP, \"1\" })\n+    @IR(applyIf = { \"ShortRunningLongLoop\", \"true\" }, failOn = IRNode.LOOP)\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLongRangeChecks.java","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1647,0 +1647,5 @@\n+    public static final String SHORT_RUNNING_LOOP_TRAP = PREFIX + \"SHORT_RUNNING_LOOP_TRAP\" + POSTFIX;\n+    static {\n+        trapNodes(SHORT_RUNNING_LOOP_TRAP, \"short_running_loop\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342692\n+ * @summary C2: long counted loop\/long range checks: don't create loop-nest for short running loops\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation TestShortLoopLostLimit\n+ * @run main\/othervm TestShortLoopLostLimit\n+ *\/\n+\n+public class TestShortLoopLostLimit {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(0, 100);\n+            test2(0, 100);\n+        }\n+    }\n+\n+    private static void test1(int a, long b) {\n+        for (long i = 0; i < a + b; i += 2) {\n+            volatileField = 42;\n+        }\n+    }\n+\n+    private static void test2(int a, long b) {\n+        for (long i = a + b; i > 0; i -= 2) {\n+            volatileField = 42;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortLoopLostLimit.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342692\n+ * @summary C2: long counted loop\/long range checks: don't create loop-nest for short running loops\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:LoopUnrollLimit=100\n+ *                   TestShortRunningIntLoopWithLongChecksPredicates\n+ * @run main\/othervm TestShortRunningIntLoopWithLongChecksPredicates\n+ *\/\n+\n+import java.util.Objects;\n+\n+\/\/ int RC is first eliminated by predication which causes assert\n+\/\/ predicate to be added. Then the loop is transformed to make it\n+\/\/ possible to optimize long RC. Finally unrolling happen which\n+\/\/ require the assert predicate to have been properly copied when the\n+\/\/ loop was transformed for the long range check.\n+public class TestShortRunningIntLoopWithLongChecksPredicates {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            helper1(100, array, 100);\n+            test1(1, 100);\n+        }\n+    }\n+\n+    private static void test1(int stop, long range) {\n+        int[] array = new int[3];\n+        helper1(stop, array, range);\n+    }\n+\n+    private static void helper1(int stop, int[] array, long range) {\n+        for (int i = 0; i < stop; i++) {\n+            if (i % 2 == 0) {\n+                array[i] += i;\n+            } else {\n+                volatileField = 42;\n+            }\n+            Objects.checkIndex(i, range);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortRunningIntLoopWithLongChecksPredicates.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,579 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.longcountedloops;\n+import compiler.lib.ir_framework.*;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.util.Objects;\n+\/*\n+ * @test\n+ * @bug 8342692\n+ * @summary C2: long counted loop\/long range checks: don't create loop-nest for short running loops\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.longcountedloops.TestShortRunningLongCountedLoop\n+ *\/\n+\n+public class TestShortRunningLongCountedLoop {\n+    private static volatile int volatileField;\n+    private final static WhiteBox wb = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) {\n+        \/\/ IR rules expect a single loop so disable unrolling\n+        \/\/ IR rules expect strip mined loop to be enabled\n+        \/\/ testIntLoopUnknownBoundsShortUnswitchedLoop and testLongLoopUnknownBoundsShortUnswitchedLoop need -XX:-UseProfiledLoopPredicate\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=0\", \"-XX:LoopStripMiningIter=1000\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:-UseProfiledLoopPredicate\");\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are known and loop run for a short time\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop1() {\n+        int j = 0;\n+        for (long i = 0; i < 100; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsShortLoop1\")\n+    public static void checkTestLongLoopConstantBoundsShortLoop1(int res) {\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Same with stride > 1\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop2() {\n+        int j = 0;\n+        for (long i = 0; i < 2000; i += 20) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsShortLoop2\")\n+    public static void checkTestLongLoopConstantBoundsShortLoop2(int res) {\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Same with loop going downward\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop3() {\n+        int j = 0;\n+        for (long i = 99; i >= 0; i--) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsShortLoop3\")\n+    public static void checkTestLongLoopConstantBoundsShortLoop3(int res) {\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Same with loop going downward and stride > 1\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop4() {\n+        int j = 0;\n+        for (long i = 1999; i >= 0; i-=20) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsShortLoop4\")\n+    public static void checkTestLongLoopConstantBoundsShortLoop4(int res) {\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are known but not exact and loop run for a short time\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopConstantBoundsShortLoop5(int start, int stop) {\n+        start= Integer.max(start, 0);\n+        stop= Integer.min(stop, 999);\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopConstantBoundsShortLoop5\")\n+    public static void testLongLoopConstantBoundsShortLoop5_runner() {\n+        int res = testLongLoopConstantBoundsShortLoop5(0, 100);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check that loop nest is created when bounds are known and loop is not short run\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static int testLongLoopConstantBoundsLongLoop1() {\n+        final long stride = Integer.MAX_VALUE \/ 1000;\n+        int j = 0;\n+        for (long i = 0; i < stride * 1001; i += stride) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsLongLoop1\")\n+    public static void checkTestLongLoopConstantBoundsLongLoop1(int res) {\n+        if (res != 1001) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Same with negative stride\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.LOOP, \"1\"})\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static int testLongLoopConstantBoundsLongLoop2() {\n+        final long stride = Integer.MAX_VALUE \/ 1000;\n+        int j = 0;\n+        for (long i = stride * 1000; i >= 0; i -= stride) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Check(test = \"testLongLoopConstantBoundsLongLoop2\")\n+    public static void checkTestLongLoopConstantBoundsLongLoop2(int res) {\n+        if (res != 1001) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are unknown but profile reports a short running loop\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static int testLongLoopUnknownBoundsShortLoop(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoop_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop(0, 100);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ same with stride > 1\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static int testLongLoopUnknownBoundsShortLoop2(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i < stop; i+=20) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop2\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoop2_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop2(0, 2000);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ same with negative stride\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static int testLongLoopUnknownBoundsShortLoop3(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i >= stop; i--) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop3\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoop3_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop3(99, 0);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ same with negative stride > 1\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static int testLongLoopUnknownBoundsShortLoop4(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i >= stop; i -= 20) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop4\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoop4_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop4(1999, 0);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check that loop nest is created when bounds are not known but profile reports loop is not short run\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\", IRNode.LOOP,  \"1\"})\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopUnknownBoundsLongLoop1(long start, long stop, long range) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            Objects.checkIndex(i * (1024 * 1024), range); \/\/ max number of iteration of inner loop is roughly Integer.MAX_VALUE \/ 1024 \/ 1024\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsLongLoop1\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsLongLoop1_runner() {\n+        int res = testLongLoopUnknownBoundsLongLoop1(0, 3000, Long.MAX_VALUE);\n+        if (res != 3000) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ same with negative stride\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\", IRNode.LOOP,  \"1\"})\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopUnknownBoundsLongLoop2(long start, long stop, long range) {\n+        int j = 0;\n+        for (long i = start; i >= stop; i--) {\n+            volatileField = 42;\n+            Objects.checkIndex(i * (1024 * 1024), range); \/\/ max number of iteration of inner loop is roughly Integer.MAX_VALUE \/ 1024 \/ 1024\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsLongLoop2\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsLongLoop2_runner() {\n+        int res = testLongLoopUnknownBoundsLongLoop2(2999, 0, Long.MAX_VALUE);\n+        if (res != 3000) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Check IR has a loop nest when bounds are unknown, profile reports a short running loop but trap is taken\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.LOOP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopUnknownBoundsShortLoopFailedSpeculation(long start, long stop, long range) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            Objects.checkIndex(i * (1024 * 1024), range); \/\/ max number of iteration of inner loop is roughly Integer.MAX_VALUE \/ 1024 \/ 1024\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoopFailedSpeculation\")\n+    @Warmup(1)\n+    public static void testLongLoopUnknownBoundsShortLoopFailedSpeculation_runner(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            for (int i = 0; i < 10_0000; i++) {\n+                int res = testLongLoopUnknownBoundsShortLoopFailedSpeculation(0, 100, Long.MAX_VALUE);\n+                if (res != 100) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+            wb.enqueueMethodForCompilation(info.getTest(), CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION);\n+            if (!wb.isMethodCompiled(info.getTest())) {\n+                throw new RuntimeException(\"Should be compiled now\");\n+            }\n+            for (int i = 0; i < 10; i++) {\n+                int res = testLongLoopUnknownBoundsShortLoopFailedSpeculation(0, 10_000, Long.MAX_VALUE);\n+                if (res != 10_000) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+        } else {\n+            int res = testLongLoopUnknownBoundsShortLoopFailedSpeculation(0, 100, Long.MAX_VALUE);\n+            if (res != 100) {\n+                throw new RuntimeException(\"incorrect result: \" + res);\n+            }\n+        }\n+    }\n+\n+    \/\/ Check IR has a loop nest when bounds are known, is short running loop but trap was taken\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\"  })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopKnownBoundsShortLoopFailedSpeculation() {\n+        return testLongLoopKnownBoundsShortLoopFailedSpeculationHelper(0, 100);\n+    }\n+\n+    @ForceInline\n+    private static int testLongLoopKnownBoundsShortLoopFailedSpeculationHelper(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopKnownBoundsShortLoopFailedSpeculation\")\n+    @Warmup(1)\n+    public static void testLongLoopKnownBoundsShortLoopFailedSpeculation_runner(RunInfo info) {\n+        if (info.isWarmUp()) {\n+            for (int i = 0; i < 10_0000; i++) {\n+                int res = testLongLoopKnownBoundsShortLoopFailedSpeculationHelper(0, 100);\n+                if (res != 100) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+            for (int i = 0; i < 10; i++) {\n+                int res = testLongLoopKnownBoundsShortLoopFailedSpeculationHelper(0, 10_000);\n+                if (res != 10_000) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+            for (int i = 0; i < 10_0000; i++) {\n+                int res = testLongLoopKnownBoundsShortLoopFailedSpeculation();\n+                if (res != 100) {\n+                    throw new RuntimeException(\"incorrect result: \" + res);\n+                }\n+            }\n+        } else {\n+            int res = testLongLoopKnownBoundsShortLoopFailedSpeculation();\n+            if (res != 100) {\n+                throw new RuntimeException(\"incorrect result: \" + res);\n+            }\n+        }\n+    }\n+\n+    \/\/ Check range check can be eliminated by predication\n+    @Test\n+    @IR(counts = { IRNode.PREDICATE_TRAP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static void testLongLoopConstantBoundsPredication(long range) {\n+        for (long i = 0; i < 100; i++) {\n+            Objects.checkIndex(i, range);\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopConstantBoundsPredication\")\n+    public static void testLongLoopConstantBoundsPredication_runner() {\n+        testLongLoopConstantBoundsPredication(100);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.PREDICATE_TRAP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP })\n+    public static void testLongLoopUnknownBoundsShortLoopPredication(long start, long stop, long range) {\n+        for (long i = start; i < stop; i++) {\n+            Objects.checkIndex(i, range);\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoopPredication\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoopPredication_runner() {\n+        testLongLoopUnknownBoundsShortLoopPredication(0, 100, 100);\n+    }\n+\n+    \/\/ If scale too large, transformation can't happen\n+    static final long veryLargeScale = Integer.MAX_VALUE \/ 99;\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\", IRNode.PREDICATE_TRAP, \"2\"})\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static void testLongLoopConstantBoundsLargeScale(long range) {\n+        for (long i = 0; i < 100; i++) {\n+            Objects.checkIndex(veryLargeScale * i, range);\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopConstantBoundsLargeScale\")\n+    public static void testLongLoopConstantBoundsLargeScale_runner() {\n+        testLongLoopConstantBoundsLargeScale(veryLargeScale * 100);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOOP, \"1\", IRNode.PREDICATE_TRAP, \"2\"})\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static void testLongLoopUnknownBoundsShortLoopLargeScale(long start, long stop, long range) {\n+        for (long i = start; i < stop; i++) {\n+            Objects.checkIndex(veryLargeScale * i, range);\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoopLargeScale\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortLoopLargeScale_runner() {\n+        testLongLoopUnknownBoundsShortLoopLargeScale(0, 100, veryLargeScale * 100);\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are known and loop run for a short time (int loop case)\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.PREDICATE_TRAP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP, IRNode.OUTER_STRIP_MINED_LOOP, IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static void testIntLoopConstantBoundsShortLoop1(long range) {\n+        for (int i = 0; i < 100; i++) {\n+            Objects.checkIndex(i, range);\n+            volatileField = 42;\n+        }\n+    }\n+\n+    @Run(test = \"testIntLoopConstantBoundsShortLoop1\")\n+    public static void testIntLoopConstantBoundsShortLoop1_runner() {\n+        testIntLoopConstantBoundsShortLoop1(100);\n+    }\n+\n+    \/\/ Check IR only has a counted loop when bounds are unknown but profile reports a short running loop (int loop case)\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.PREDICATE_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static void testIntLoopUnknownBoundsShortLoop(int start, int stop, long range) {\n+        for (int i = start; i < stop; i++) {\n+            Objects.checkIndex(i, range);\n+            volatileField = 42;\n+        }\n+    }\n+\n+    @Run(test = \"testIntLoopUnknownBoundsShortLoop\")\n+    @Warmup(10_000)\n+    public static void testIntLoopUnknownBoundsShortLoop_runner() {\n+        testIntLoopUnknownBoundsShortLoop(0, 100, 100);\n+    }\n+\n+    \/\/ Same with unswitched loop\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"2\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.PREDICATE_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"2\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static void testIntLoopUnknownBoundsShortUnswitchedLoop(int start, int stop, long range, boolean flag) {\n+        for (int i = start; i < stop; i++) {\n+            if (flag) {\n+                Objects.checkIndex(i, range);\n+                volatileField = 42;\n+            } else {\n+                Objects.checkIndex(i, range);\n+                volatileField = 42;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"testIntLoopUnknownBoundsShortUnswitchedLoop\")\n+    @Warmup(10_000)\n+    public static void testIntLoopUnknownBoundsShortUnswitchedLoop_runner() {\n+        testIntLoopUnknownBoundsShortUnswitchedLoop(0, 100, 100, true);\n+        testIntLoopUnknownBoundsShortUnswitchedLoop(0, 100, 100, false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"2\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.PREDICATE_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"2\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static void testLongLoopUnknownBoundsShortUnswitchedLoop(long start, long stop, long range, boolean flag) {\n+        for (long i = start; i < stop; i++) {\n+            if (flag) {\n+                Objects.checkIndex(i, range);\n+                volatileField = 42;\n+            } else {\n+                Objects.checkIndex(i, range);\n+                volatileField = 42;\n+            }\n+        }\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortUnswitchedLoop\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsShortUnswitchedLoop_runner() {\n+        testLongLoopUnknownBoundsShortUnswitchedLoop(0, 100, 100, true);\n+        testLongLoopUnknownBoundsShortUnswitchedLoop(0, 100, 100, false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static int testLongLoopUnknownBoundsAddLimitShortLoop(int stop1, long stop2) {\n+        int j = 0;\n+        for (long i = 0; i < stop1 + stop2; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsAddLimitShortLoop\")\n+    @Warmup(10_000)\n+    public static void testLongLoopUnknownBoundsAddLimitShortLoop_runner() {\n+        int res = testLongLoopUnknownBoundsAddLimitShortLoop(100, 0);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortRunningLongCountedLoop.java","additions":579,"deletions":0,"binary":false,"changes":579,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342692\n+ * @summary C2: long counted loop\/long range checks: don't create loop-nest for short running loops\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:LoopMaxUnroll=0\n+ *                   TestShortRunningLongCountedLoopPredicatesClone\n+ * @run main\/othervm TestShortRunningLongCountedLoopPredicatesClone\n+ *\/\n+\n+import java.util.Objects;\n+\n+\/\/ Predicate added after int counted loop is created depends on\n+\/\/ narrowed limit which depends on predicate added before the int\n+\/\/ counted loop was created: predicates need to be properly ordered.\n+public class TestShortRunningLongCountedLoopPredicatesClone {\n+    public static void main(String[] args) {\n+        A a = new A(100);\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(a, 0);\n+        }\n+    }\n+\n+    private static void test1(A a, long start) {\n+        long i = start;\n+        do {\n+            synchronized (new Object()) {}\n+            Objects.checkIndex(i, a.range);\n+            i++;\n+        } while (i < a.range);\n+    }\n+\n+    static class A {\n+        A(long range) {\n+            this.range = range;\n+        }\n+\n+        long range;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortRunningLongCountedLoopPredicatesClone.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8342692\n+ * @summary C2: long counted loop\/long range checks: don't create loop-nest for short running loops\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:LoopMaxUnroll=0\n+ *                   -XX:-UseLoopPredicate -XX:-RangeCheckElimination TestShortRunningLongCountedLoopScaleOverflow\n+ * @run main\/othervm TestShortRunningLongCountedLoopScaleOverflow\n+ *\/\n+\n+import java.util.Objects;\n+\n+\/\/ When scale is large, even if loop is short running having a single\n+\/\/ counted loop is not possible.\n+public class TestShortRunningLongCountedLoopScaleOverflow {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(Integer.MAX_VALUE, 0);\n+            test2(Integer.MAX_VALUE, 0, 100);\n+        }\n+        boolean exception = false;\n+        try {\n+            test1(Integer.MAX_VALUE, 10);\n+        } catch (IndexOutOfBoundsException indexOutOfBoundsException) {\n+            exception = true;\n+        }\n+        if (!exception) {\n+            throw new RuntimeException(\"Expected exception not thrown\");\n+        }\n+        exception = false;\n+        try {\n+            test2(Integer.MAX_VALUE, 10, 100);\n+        } catch (IndexOutOfBoundsException indexOutOfBoundsException) {\n+            exception = true;\n+        }\n+        if (!exception) {\n+            throw new RuntimeException(\"Expected exception not thrown\");\n+        }\n+    }\n+\n+    static final long veryLargeScale = 1 << 29;\n+\n+    private static void test1(long range, long j) {\n+        Objects.checkIndex(0, range);\n+        for (long i = 0; i < 100; i++) {\n+            if (i == j) {\n+                Objects.checkIndex(veryLargeScale * i, range);\n+            }\n+        }\n+    }\n+\n+    private static void test2(long range, long j, long stop) {\n+        Objects.checkIndex(0, range);\n+        for (long i = 0; i < stop; i++) {\n+            if (i == j) {\n+                Objects.checkIndex(veryLargeScale * i, range);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestShortRunningLongCountedLoopScaleOverflow.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -777,3 +777,4 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.ADD_VI,        \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfAnd = { \"ShortRunningLongLoop\", \"true\", \"AlignVector\", \"false\" },\n@@ -795,3 +796,4 @@\n-    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n-                  IRNode.ADD_VI,        \"= 0\",\n-                  IRNode.STORE_VECTOR,  \"= 0\"},\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"> 0\",\n+                  IRNode.ADD_VI,        \"> 0\",\n+                  IRNode.STORE_VECTOR,  \"> 0\"},\n+        applyIfAnd = { \"ShortRunningLongLoop\", \"true\", \"AlignVector\", \"false\" },\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"}]}