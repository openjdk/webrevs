{"files":[{"patch":"@@ -856,1 +856,2 @@\n-          \"loop runs for small enough number of iterations.\")               \\\n+          \"loop runs for small enough number of iterations. Long loop is\"   \\\n+          \"converted to a single int loop.\")                                \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-bool CastLLNode::inner_loop_backedge(Node* proj) {\n+bool CastLLNode::is_inner_loop_backedge(ProjNode* proj) {\n@@ -339,1 +339,1 @@\n-bool CastLLNode::cmp_used_at_inner_loop_exit_test(Node* cmp) {\n+bool CastLLNode::cmp_used_at_inner_loop_exit_test(CmpNode* cmp) {\n@@ -346,3 +346,3 @@\n-          Node* true_proj = iff->as_If()->proj_out_or_null(true);\n-          Node* false_proj = iff->as_If()->proj_out_or_null(false);\n-          if (inner_loop_backedge(true_proj) || inner_loop_backedge(false_proj)) {\n+          ProjNode* true_proj = iff->as_If()->proj_out_or_null(true);\n+          ProjNode* false_proj = iff->as_If()->proj_out_or_null(false);\n+          if (is_inner_loop_backedge(true_proj) || is_inner_loop_backedge(false_proj)) {\n@@ -367,1 +367,2 @@\n-          if (cmp_used_at_inner_loop_exit_test(cmp_or_sub)) {\n+          if (cmp_used_at_inner_loop_exit_test(cmp_or_sub->as_Cmp())) {\n+            \/\/ (Loop .. .. (IfProj (If (Bool (CmpI (ConvL2I (CastLL )))))))\n@@ -374,1 +375,2 @@\n-              if (cmp_used_at_inner_loop_exit_test(cmp)) {\n+              if (cmp_used_at_inner_loop_exit_test(cmp->as_Cmp())) {\n+                \/\/ (Loop .. .. (IfProj (If (Bool (CmpI (SubI 0 (ConvL2I (CastLL ))))))))\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-  static bool inner_loop_backedge(Node* proj);\n+  static bool is_inner_loop_backedge(ProjNode* proj);\n@@ -144,1 +144,1 @@\n-  static bool cmp_used_at_inner_loop_exit_test(Node* cmp);\n+  static bool cmp_used_at_inner_loop_exit_test(CmpNode* cmp);\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -126,1 +126,10 @@\n-    \/\/ Use unsigned longs to avoid overflow\n+    \/\/ compute trip count\n+    \/\/ It used to be computed as:\n+    \/\/ max(1, limit_con - init_con + stride_m) \/ stride_con\n+    \/\/ with stride_m = stride_con - (stride_con > 0 ? 1 : -1)\n+    \/\/ for int counted loops only and by promoting all values to long to avoid overflow\n+    \/\/ This implements the computation for int and long counted loops in a way that promotion to the next larger integer\n+    \/\/ type is not needed to protect against overflow.\n+    \/\/\n+    \/\/ Use unsigned longs to avoid overflow: number of iteration is a positive number but can be really large for\n+    \/\/ instance if init_con = min_jint, limit_con = max_jint\n@@ -143,2 +152,2 @@\n-      \/\/ Guaranteed to not overflow because it can only happen for stride > 1 in which case, utrip_count can't be\n-      \/\/ max_juint\n+      \/\/ Guaranteed to not overflow because it can only happen for ABS(stride) > 1 in which case, utrip_count can't be\n+      \/\/ max_juint\/max_julong\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -571,1 +571,0 @@\n-    JVMState* jvms = sfpt->jvms();\n@@ -891,1 +890,1 @@\n-  if (short_running_loop(loop, stride_con, range_checks, iters_limit)) {\n+  if (try_make_short_running_loop(loop, stride_con, range_checks, iters_limit)) {\n@@ -1126,1 +1125,1 @@\n-class NodeInShortLoopBody : public NodeInLoopBody {\n+class NodeInSingleLoopBody : public NodeInLoopBody {\n@@ -1131,1 +1130,1 @@\n-  NodeInShortLoopBody(PhaseIdealLoop* phase, IdealLoopTree* ilt) : _phase(phase), _ilt(ilt) {\n+  NodeInSingleLoopBody(PhaseIdealLoop* phase, IdealLoopTree* ilt) : _phase(phase), _ilt(ilt) {\n@@ -1133,1 +1132,1 @@\n-  NONCOPYABLE(NodeInShortLoopBody);\n+  NONCOPYABLE(NodeInSingleLoopBody);\n@@ -1141,1 +1140,1 @@\n-class CloneShortLoopPredicatesVisitor : public PredicateVisitor {\n+class CloneShortLoopPredicateVisitor : public PredicateVisitor {\n@@ -1146,2 +1145,2 @@\n-  CloneShortLoopPredicatesVisitor(LoopNode* target_loop_head,\n-                                  const NodeInShortLoopBody& node_in_loop_body,\n+  CloneShortLoopPredicateVisitor(LoopNode* target_loop_head,\n+                                  const NodeInSingleLoopBody& node_in_loop_body,\n@@ -1152,1 +1151,1 @@\n-  NONCOPYABLE(CloneShortLoopPredicatesVisitor);\n+  NONCOPYABLE(CloneShortLoopPredicateVisitor);\n@@ -1177,2 +1176,2 @@\n-bool PhaseIdealLoop::short_running_loop(IdealLoopTree* loop, jint stride_con, const Node_List &range_checks,\n-                                        uint iters_limit) {\n+bool PhaseIdealLoop::try_make_short_running_loop(IdealLoopTree* loop, jint stride_con, const Node_List &range_checks,\n+                                                 const uint iters_limit) {\n@@ -1187,1 +1186,2 @@\n-  \/\/ Loop must run for no more than iter_limits as it guarantees no overflow of scale * iv in long range checks.\n+  \/\/ Loop must run for no more than iter_limits as it guarantees no overflow of scale * iv in long range checks (see\n+  \/\/ comment above PhaseIdealLoop::transform_long_range_checks()).\n@@ -1189,1 +1189,1 @@\n-  \/\/ it's always benificial to have a single loop rather than a loop nest, so we try to apply this transformation as\n+  \/\/ it's always beneficial to have a single loop rather than a loop nest, so we try to apply this transformation as\n@@ -1234,0 +1234,1 @@\n+    \/\/  (future predicates added here)\n@@ -1242,2 +1243,2 @@\n-    NodeInShortLoopBody node_in_short_loop_body(this, loop);\n-    CloneShortLoopPredicatesVisitor clone_short_loop_predicates_visitor(head, node_in_short_loop_body, this);\n+    NodeInSingleLoopBody node_in_short_loop_body(this, loop);\n+    CloneShortLoopPredicateVisitor clone_short_loop_predicates_visitor(head, node_in_short_loop_body, this);\n@@ -1255,2 +1256,2 @@\n-    jlong limit_long = iters_limit;\n-    Node* cmp_limit = CmpNode::make(new_limit, _igvn.integercon(limit_long, bt), bt);\n+    const jlong iters_limit_long = iters_limit;\n+    Node* cmp_limit = CmpNode::make(new_limit, _igvn.integercon(iters_limit_long, bt), bt);\n@@ -1267,1 +1268,1 @@\n-                                                             TypeInteger::make(1, limit_long, Type::WidenMin, bt),\n+                                                             TypeInteger::make(1, iters_limit_long, Type::WidenMin, bt),\n@@ -1279,4 +1280,4 @@\n-    \/\/ We're turning a long counted loop into a regular loop that will be converted into an int count loop. That loop\n-    \/\/ won't need loop limit checks (iters_limit guarantees that). Add a cast to make sure that, whatever transformation\n-    \/\/ happens by the time the counted loop is created, C2 knows enough about the loop's limit that it doesn't try to\n-    \/\/ add loop limit checks.\n+    \/\/ We're turning a long counted loop into a regular loop that will be converted into an int counted loop. That loop\n+    \/\/ won't need loop limit check predicates (iters_limit guarantees that). Add a cast to make sure that, whatever\n+    \/\/ transformation happens by the time the counted loop is created (in a subsequent pass of loop opts), C2 knows\n+    \/\/ enough about the loop's limit that it doesn't try to add loop limit check predicates.\n@@ -1289,0 +1290,2 @@\n+  } else {\n+    assert(bt == T_INT && known_short_running_loop, \"only CountedLoop statically known to be short running\");\n@@ -1293,0 +1296,1 @@\n+    \/\/ The loop is short running so new_limit fits into an int: either we determined that statically or added a guard\n@@ -1515,1 +1519,0 @@\n-    ProjNode* unc_proj = proj->other_if_proj();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":26,"deletions":23,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1836,1 +1836,1 @@\n-  bool short_running_loop(IdealLoopTree* loop, jint stride_con, const Node_List& range_checks, uint iters_limit);\n+  bool try_make_short_running_loop(IdealLoopTree* loop, jint stride_con, const Node_List& range_checks, const uint iters_limit);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n- *     - Short Short:        This predicate is created when a long counted loop is transformed into an int counted\n+ *     - Short:              This predicate is created when a long counted loop is transformed into an int counted\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.longcountedloops;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8342692\n+ * @summary C2: long counted loop\/long range checks: don't create loop-nest for short running loops\n+ * @library \/test\/lib \/\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI compiler.longcountedloops.TestStressShortRunningLongCountedLoop\n+ *\/\n+\n+public class TestStressShortRunningLongCountedLoop {\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=0\", \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:+StressShortRunningLongLoop\");\n+        TestFramework.runWithFlags(\"-XX:LoopMaxUnroll=0\",  \"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-StressShortRunningLongLoop\");\n+    }\n+\n+    @Test\n+    @IR(applyIf = { \"StressShortRunningLongLoop\", \"true\" }, counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.SHORT_RUNNING_LOOP_TRAP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(applyIf = { \"StressShortRunningLongLoop\", \"true\" }, failOn = { IRNode.LOOP })\n+    @IR(applyIf = { \"StressShortRunningLongLoop\", \"false\" }, counts = { IRNode.COUNTED_LOOP, \"1\", IRNode.LOOP, \"1\", IRNode.OUTER_STRIP_MINED_LOOP, \"1\" })\n+    @IR(applyIf = { \"StressShortRunningLongLoop\", \"false\" }, failOn = { IRNode.SHORT_RUNNING_LOOP_TRAP })\n+    public static int testLongLoopUnknownBoundsShortLoop(long start, long stop) {\n+        int j = 0;\n+        for (long i = start; i < stop; i++) {\n+            volatileField = 42;\n+            j++;\n+        }\n+        return j;\n+    }\n+\n+    @Run(test = \"testLongLoopUnknownBoundsShortLoop\")\n+    @Warmup(0)\n+    public static void testLongLoopUnknownBoundsShortLoop_runner() {\n+        int res = testLongLoopUnknownBoundsShortLoop(0, 100);\n+        if (res != 100) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/longcountedloops\/TestStressShortRunningLongCountedLoop.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -52,1 +52,1 @@\n- * @bug 8329273\n+ * @bug 8329273 8342692\n@@ -60,1 +60,1 @@\n- * @bug 8329273 8348263\n+ * @bug 8329273 8348263 8342692\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}