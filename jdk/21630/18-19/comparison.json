{"files":[{"patch":"@@ -4053,3 +4053,5 @@\n-  \/\/ Will narrow the limit down with a cast node. Predicates added later may depend on the cast so should be last when\n-  \/\/ starting from the loop.\n-  add_parse_predicate(Deoptimization::Reason_short_running_long_loop, nargs);\n+  if (ShortRunningLongLoop) {\n+    \/\/ Will narrow the limit down with a cast node. Predicates added later may depend on the cast so should be last when\n+    \/\/ starting from the loop.\n+    add_parse_predicate(Deoptimization::Reason_short_running_long_loop, nargs);\n+  }\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -122,1 +122,0 @@\n-    \/\/ Use longs to avoid integer overflow.\n@@ -127,0 +126,1 @@\n+    \/\/ Use unsigned longs to avoid overflow\n@@ -139,0 +139,2 @@\n+    \/\/ The loop runs for one more iteration if the limit is (stride > 0 in this example):\n+    \/\/ init + k * stride + small_value, 0 < small_value < stride\n@@ -141,0 +143,2 @@\n+      \/\/ Guaranteed to not overflow because it can only happen for stride > 1 in which case, utrip_count can't be\n+      \/\/ max_juint\n@@ -146,0 +150,1 @@\n+      \/\/ Use longs to avoid integer overflow.\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1094,1 +1094,3 @@\n-    add_parse_predicate(Deoptimization::Reason_short_running_long_loop, inner_head, outer_ilt, cloned_sfpt);\n+    if (ShortRunningLongLoop) {\n+      add_parse_predicate(Deoptimization::Reason_short_running_long_loop, inner_head, outer_ilt, cloned_sfpt);\n+    }\n@@ -1177,2 +1179,2 @@\n-\/\/ If bounds are known is the loop doesn't need an outer loop or profile data indicates it runs for less than\n-\/\/ ShortLoopIter, don't create the outer loop\n+\/\/ If bounds are known, or profile data indicates it runs for a small enough number of iterations, so the loop doesn't\n+\/\/ need an outer loop, don't create the outer loop\n@@ -1218,5 +1220,6 @@\n-    \/\/ Add a short_limit predicate. It's the last predicate when coming from the loop because a cast that's control\n-    \/\/ dependent on the short_limit predicate is added to narrow the limit and future predicates may be dependent on the\n-    \/\/ new limit (so have to be between the loop and short_limit predicate). The current limit could, itself, be\n-    \/\/ dependent on an existing predicate. Clone parse predicates below existing predicates to get proper ordering of\n-    \/\/ predicates when walking from the loop up: future predicates, short_limit predicate, existing predicates.\n+    \/\/ Add a Short Running Long Loop Predicate. It's the first predicate in the predicate chain before entering a loop\n+    \/\/ because a cast that's control dependent on the Short Running Long Loop Predicate is added to narrow the limit and\n+    \/\/ future predicates may be dependent on the new limit (so have to be between the loop and Short Running Long Loop\n+    \/\/ Predicate). The current limit could, itself, be dependent on an existing predicate. Clone parse and template\n+    \/\/ assertion predicates below existing predicates to get proper ordering of predicates when walking from the loop\n+    \/\/ up: future predicates, Short Running Long Loop Predicate, existing predicates.\n@@ -1224,2 +1227,2 @@\n-    const PredicateBlock* short_running_loop_predicate_block = predicates_before_cloning.short_running_loop_predicate_block();\n-    if (!short_running_loop_predicate_block->has_parse_predicate()) { \/\/ already trapped\n+    const PredicateBlock* short_running_long_loop_predicate_block = predicates_before_cloning.short_running_long_loop_predicate_block();\n+    if (!short_running_long_loop_predicate_block->has_parse_predicate()) { \/\/ already trapped\n@@ -1238,1 +1241,1 @@\n-        short_running_loop_predicate_block()->\n+        short_running_long_loop_predicate_block()->\n@@ -4520,1 +4523,1 @@\n-  if (predicates.short_running_loop_predicate_block()->is_non_empty()) {\n+  if (predicates.short_running_long_loop_predicate_block()->is_non_empty()) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -946,1 +946,1 @@\n-    _short_running_loop_predicate_block.dump(\"  \");\n+    _short_running_long_loop_predicate_block.dump(\"  \");\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,0 +76,8 @@\n+ *     - Short Short:        This predicate is created when a long counted loop is transformed into an int counted\n+ *       Running Long        loop. In the general, that transformation requires an outer loop to guarantee that the new\n+ *       Loop                loop nest iterates over the entire range of the loop before transformation. However, if the\n+ *       Predicate           loop is speculated to run for a small enough number of iterations, the outer loop is not\n+ *                           needed. This predicate is added to catch mis-speculation in this case. It also applies to\n+ *                           int counted loops with long range checks for which a loop nest also needs to be created\n+ *                           in the general case (so the transformation of long range checks to int range checks is\n+ *                           legal).\n@@ -957,1 +965,1 @@\n-  const PredicateBlock _short_running_loop_predicate_block;\n+  const PredicateBlock _short_running_long_loop_predicate_block;\n@@ -970,1 +978,1 @@\n-        _short_running_loop_predicate_block(_loop_predicate_block.entry(),\n+        _short_running_long_loop_predicate_block(_loop_predicate_block.entry(),\n@@ -972,1 +980,1 @@\n-        _entry(_short_running_loop_predicate_block.entry()) {}\n+        _entry(_short_running_long_loop_predicate_block.entry()) {}\n@@ -997,2 +1005,2 @@\n-  const PredicateBlock* short_running_loop_predicate_block() const {\n-    return &_short_running_loop_predicate_block;\n+  const PredicateBlock* short_running_long_loop_predicate_block() const {\n+    return &_short_running_long_loop_predicate_block;\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -50,0 +50,17 @@\n+\/*\n+ * @test id=byte-array-NoShortRunningLongLoop\n+ * @bug 8329273\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray NoShortRunningLongLoop\n+ *\/\n+\n+\/*\n+ * @test id=byte-array-AlignVector-NoShortRunningLongLoop\n+ * @bug 8329273 8348263\n+ * @summary Test vectorization of loops over MemorySegment\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestMemorySegment ByteArray AlignVector NoShortRunningLongLoop\n+ *\/\n+\n+\n@@ -175,0 +192,7 @@\n+        for (int i = 1; i < args.length; i++) {\n+            String tag = args[i];\n+            switch (tag) {\n+                case \"AlignVector\" ->                framework.addFlags(\"-XX:+AlignVector\");\n+                case \"NoShortRunningLongLoop\" ->     framework.addFlags(\"-XX:-ShortRunningLongLoop\");\n+            }\n+        }\n@@ -777,0 +801,6 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfAnd = { \"ShortRunningLongLoop\", \"false\", \"AlignVector\", \"false\" },\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n@@ -796,0 +826,6 @@\n+    @IR(counts = {IRNode.LOAD_VECTOR_I, \"= 0\",\n+                  IRNode.ADD_VI,        \"= 0\",\n+                  IRNode.STORE_VECTOR,  \"= 0\"},\n+        applyIfAnd = { \"ShortRunningLongLoop\", \"false\", \"AlignVector\", \"false\" },\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\", \"rvv\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMemorySegment.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"}]}