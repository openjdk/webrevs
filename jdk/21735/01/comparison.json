{"files":[{"patch":"@@ -614,1 +614,0 @@\n-  do_intrinsic(_notifyJvmtiVThreadHideFrames, java_lang_VirtualThread, notifyJvmtiHideFrames_name, bool_void_signature, F_SN) \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -401,1 +401,0 @@\n-  template(notifyJvmtiHideFrames_name,                \"notifyJvmtiHideFrames\")                    \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1145,3 +1145,0 @@\n-JNIEXPORT void JNICALL\n-JVM_VirtualThreadHideFrames(JNIEnv* env, jclass clazz, jboolean hide);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -251,1 +251,0 @@\n-  JVMTI_ONLY(nonstatic_field(JavaThread,       _is_in_tmp_VTMS_transition,                    bool))                                 \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -844,1 +844,0 @@\n-  case vmIntrinsics::_notifyJvmtiVThreadHideFrames:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -498,1 +498,0 @@\n-  case vmIntrinsics::_notifyJvmtiVThreadHideFrames:     return inline_native_notify_jvmti_hide();\n@@ -2978,23 +2977,0 @@\n-\/\/ Always update the temporary VTMS transition bit.\n-bool LibraryCallKit::inline_native_notify_jvmti_hide() {\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    return true;\n-  }\n-  IdealKit ideal(this);\n-\n-  {\n-    \/\/ unconditionally update the temporary VTMS transition bit in current JavaThread\n-    Node* thread = ideal.thread();\n-    Node* hide = _gvn.transform(argument(0)); \/\/ hide argument for temporary VTMS transition notification\n-    Node* addr = basic_plus_adr(thread, in_bytes(JavaThread::is_in_tmp_VTMS_transition_offset()));\n-    const TypePtr *addr_type = _gvn.type(addr)->isa_ptr();\n-\n-    sync_kit(ideal);\n-    access_store_at(nullptr, addr, addr_type, hide, _gvn.type(hide), T_BOOLEAN, IN_NATIVE | MO_UNORDERED);\n-    ideal.sync_kit(this);\n-  }\n-  final_sync(ideal);\n-\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3944,13 +3944,0 @@\n-\/\/ Always update the temporary VTMS transition bit.\n-JVM_ENTRY(void, JVM_VirtualThreadHideFrames(JNIEnv* env, jclass clazz, jboolean hide))\n-#if INCLUDE_JVMTI\n-  if (!DoJVMTIVirtualThreadTransitions) {\n-    assert(!JvmtiExport::can_support_virtual_threads(), \"sanity check\");\n-    return;\n-  }\n-  assert(!thread->is_in_VTMS_transition(), \"sanity check\");\n-  assert(thread->is_in_tmp_VTMS_transition() != (bool)hide, \"sanity check\");\n-  thread->toggle_is_in_tmp_VTMS_transition();\n-#endif\n-JVM_END\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -932,1 +932,1 @@\n-    assert(!_thread->is_in_any_VTMS_transition(), \"CFLH events are not allowed in any VTMS transition\");\n+    assert(!_thread->is_in_VTMS_transition(), \"CFLH events are not allowed in VTMS transition\");\n@@ -1094,2 +1094,2 @@\n-  if (JavaThread::current()->is_in_any_VTMS_transition()) {\n-    return false; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (JavaThread::current()->is_in_VTMS_transition()) {\n+    return false; \/\/ no events should be posted if thread is in VTMS transition\n@@ -1231,2 +1231,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -1371,2 +1371,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -1408,2 +1408,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -1746,2 +1746,2 @@\n-  if (javaThread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (javaThread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -1770,2 +1770,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -1813,2 +1813,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -1905,2 +1905,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -1981,2 +1981,2 @@\n-  if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2023,2 +2023,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2145,2 +2145,2 @@\n-      if (mh->jvmti_mount_transition() || thread->is_in_any_VTMS_transition()) {\n-        return; \/\/ no events should be posted if thread is in any VTMS transition\n+      if (mh->jvmti_mount_transition() || thread->is_in_VTMS_transition()) {\n+        return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2191,2 +2191,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2227,2 +2227,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2277,2 +2277,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2308,2 +2308,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2383,2 +2383,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2422,2 +2422,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2496,1 +2496,1 @@\n-  assert(!thread->is_in_any_VTMS_transition(), \"compiled method load events are not allowed in any VTMS transition\");\n+  assert(!thread->is_in_VTMS_transition(), \"compiled method load events are not allowed in VTMS transition\");\n@@ -2519,1 +2519,1 @@\n-  assert(!thread->is_in_any_VTMS_transition(), \"compiled method load events are not allowed in any VTMS transition\");\n+  assert(!thread->is_in_VTMS_transition(), \"compiled method load events are not allowed in VTMS transition\");\n@@ -2544,1 +2544,1 @@\n-  assert(!thread->is_in_any_VTMS_transition(), \"dynamic code generated events are not allowed in any VTMS transition\");\n+  assert(!thread->is_in_VTMS_transition(), \"dynamic code generated events are not allowed in VTMS transition\");\n@@ -2592,1 +2592,1 @@\n-  assert(!thread->is_in_any_VTMS_transition(), \"dynamic code generated events are not allowed in any VTMS transition\");\n+  assert(!thread->is_in_VTMS_transition(), \"dynamic code generated events are not allowed in VTMS transition\");\n@@ -2747,2 +2747,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2780,2 +2780,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2814,2 +2814,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2848,2 +2848,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2877,2 +2877,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n@@ -2914,2 +2914,2 @@\n-  if (thread->is_in_any_VTMS_transition()) {\n-    return; \/\/ no events should be posted if thread is in any VTMS transition\n+  if (thread->is_in_VTMS_transition()) {\n+    return; \/\/ no events should be posted if thread is in VTMS transition\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":51,"deletions":51,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -356,1 +356,0 @@\n-    assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n@@ -570,1 +569,0 @@\n-  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n@@ -596,1 +594,0 @@\n-  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n@@ -641,1 +638,0 @@\n-  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n@@ -654,1 +650,0 @@\n-  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n@@ -662,1 +657,0 @@\n-  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n@@ -675,1 +669,0 @@\n-  assert(!thread->is_in_tmp_VTMS_transition(), \"sanity check\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -449,1 +449,0 @@\n-  _is_in_tmp_VTMS_transition(false),\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -314,1 +314,0 @@\n-  bool                  _is_in_tmp_VTMS_transition;      \/\/ thread is in temporary virtual thread mount state transition\n@@ -678,3 +677,0 @@\n-  bool is_in_tmp_VTMS_transition() const         { return _is_in_tmp_VTMS_transition; }\n-  bool is_in_any_VTMS_transition() const         { return _is_in_VTMS_transition || _is_in_tmp_VTMS_transition; }\n-\n@@ -682,1 +678,0 @@\n-  void toggle_is_in_tmp_VTMS_transition()        { _is_in_tmp_VTMS_transition = !_is_in_tmp_VTMS_transition; };\n@@ -854,1 +849,0 @@\n-  static ByteSize is_in_tmp_VTMS_transition_offset() { return byte_offset_of(JavaThread, _is_in_tmp_VTMS_transition); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -235,2 +235,2 @@\n-        if (TRACE_VTHREAD_LOCALS) {\n-            dumpStackIfVirtualThread();\n+        if (TRACE_VTHREAD_LOCALS && t == Thread.currentThread() && t.isVirtual()) {\n+            printStackTrace();\n@@ -252,2 +252,2 @@\n-        if (TRACE_VTHREAD_LOCALS) {\n-            dumpStackIfVirtualThread();\n+        if (TRACE_VTHREAD_LOCALS && Thread.currentThread().isVirtual()) {\n+            printStackTrace();\n@@ -802,1 +802,0 @@\n-\n@@ -814,1 +813,3 @@\n-     * Print a stack trace if the current thread is a virtual thread.\n+     * Print the stack trace of the current thread, skipping the printStackTrace frame.\n+     * A thread local is used to detect reentrancy as the printing may itself use\n+     * thread locals.\n@@ -816,2 +817,5 @@\n-    static void dumpStackIfVirtualThread() {\n-        if (Thread.currentThread() instanceof VirtualThread vthread) {\n+    private void printStackTrace() {\n+        Thread t = Thread.currentThread();\n+        ThreadLocalMap map = getMap(t);\n+        if (map.getEntry(DUMPING_STACK) == null) {\n+            map.set(DUMPING_STACK, true);\n@@ -819,1 +823,1 @@\n-                var stack = StackWalkerHolder.STACK_WALKER.walk(s ->\n+                var stack = StackWalker.getInstance().walk(s ->\n@@ -822,11 +826,6 @@\n-\n-                \/\/ switch to carrier thread to avoid recursive use of thread-locals\n-                vthread.executeOnCarrierThread(() -> {\n-                    System.out.println(vthread);\n-                    for (StackWalker.StackFrame frame : stack) {\n-                        System.out.format(\"    %s%n\", frame.toStackTraceElement());\n-                    }\n-                    return null;\n-                });\n-            } catch (Exception e) {\n-                throw new InternalError(e);\n+                System.out.println(t);\n+                for (StackWalker.StackFrame frame : stack) {\n+                    System.out.format(\"    %s%n\", frame.toStackTraceElement());\n+                }\n+            } finally {\n+                map.remove(DUMPING_STACK);\n@@ -837,3 +836,1 @@\n-    private static class StackWalkerHolder {\n-        static final StackWalker STACK_WALKER = StackWalker.getInstance();\n-    }\n+    private static final ThreadLocal<Boolean> DUMPING_STACK = new ThreadLocal<>();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadLocal.java","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.concurrent.Callable;\n@@ -140,0 +139,6 @@\n+    \/\/ timeout for timed-park, in nanoseconds, only accessed on current\/carrier thread\n+    private long parkTimeout;\n+\n+    \/\/ timer task for timed-park, only accessed on current\/carrier thread\n+    private Future<?> timeoutTask;\n+\n@@ -146,1 +151,0 @@\n-\n@@ -249,1 +253,2 @@\n-            \/\/ consume parking permit when continuing after parking\n+            \/\/ consume permit when continuing after parking. If continuing after a\n+            \/\/ timed-park then the timeout task is cancelled.\n@@ -251,0 +256,1 @@\n+                cancelTimeoutTask();\n@@ -271,0 +277,11 @@\n+    \/**\n+     * Cancel timeout task when continuing after a timed-park. The\n+     * timeout task may be executing, or may have already completed.\n+     *\/\n+    private void cancelTimeoutTask() {\n+        if (timeoutTask != null) {\n+            timeoutTask.cancel(false);\n+            timeoutTask = null;\n+        }\n+    }\n+\n@@ -279,1 +296,0 @@\n-    @ChangesCurrentThread\n@@ -284,8 +300,7 @@\n-                \/\/ The scheduler's execute method is invoked in the context of the\n-                \/\/ carrier thread. For the default scheduler this ensures that the\n-                \/\/ current thread is a ForkJoinWorkerThread so the task will be pushed\n-                \/\/ to the local queue. For other schedulers, it avoids deadlock that\n-                \/\/ would arise due to platform and virtual threads contending for a\n-                \/\/ lock on the scheduler's submission queue.\n-                if (currentThread() instanceof VirtualThread vthread) {\n-                    vthread.switchToCarrierThread();\n+                \/\/ Pin the continuation to prevent the virtual thread from unmounting\n+                \/\/ when submitting a task. For the default scheduler this ensures that\n+                \/\/ the carrier doesn't change when pushing a task. For other schedulers\n+                \/\/ it avoids deadlock that could arise due to carriers and virtual\n+                \/\/ threads contending for a lock.\n+                if (currentThread().isVirtual()) {\n+                    Continuation.pin();\n@@ -295,1 +310,1 @@\n-                        switchToVirtualThread(vthread);\n+                        Continuation.unpin();\n@@ -314,18 +329,0 @@\n-    \/**\n-     * Submits the runContinuation task to given scheduler with a lazy submit.\n-     * If OutOfMemoryError is thrown then the submit will be retried until it succeeds.\n-     * @throws RejectedExecutionException\n-     * @see ForkJoinPool#lazySubmit(ForkJoinTask)\n-     *\/\n-    private void lazySubmitRunContinuation(ForkJoinPool pool) {\n-        assert Thread.currentThread() instanceof CarrierThread;\n-        try {\n-            pool.lazySubmit(ForkJoinTask.adapt(runContinuation));\n-        } catch (RejectedExecutionException ree) {\n-            submitFailed(ree);\n-            throw ree;\n-        } catch (OutOfMemoryError e) {\n-            submitRunContinuation(pool, true);\n-        }\n-    }\n-\n@@ -361,0 +358,24 @@\n+    \/**\n+     * Lazy submit the runContinuation task if invoked on a carrier thread and its local\n+     * queue is empty. If not empty, or invoked by another thread, then this method works\n+     * like submitRunContinuation and just submits the task to the scheduler.\n+     * If OutOfMemoryError is thrown then the submit will be retried until it succeeds.\n+     * @throws RejectedExecutionException\n+     * @see ForkJoinPool#lazySubmit(ForkJoinTask)\n+     *\/\n+    private void lazySubmitRunContinuation() {\n+        if (currentThread() instanceof CarrierThread ct && ct.getQueuedTaskCount() == 0) {\n+            ForkJoinPool pool = ct.getPool();\n+            try {\n+                pool.lazySubmit(ForkJoinTask.adapt(runContinuation));\n+            } catch (RejectedExecutionException ree) {\n+                submitFailed(ree);\n+                throw ree;\n+            } catch (OutOfMemoryError e) {\n+                submitRunContinuation();\n+            }\n+        } else {\n+            submitRunContinuation();\n+        }\n+    }\n+\n@@ -477,39 +498,0 @@\n-    \/**\n-     * Sets the current thread to the current carrier thread.\n-     *\/\n-    @ChangesCurrentThread\n-    @JvmtiMountTransition\n-    private void switchToCarrierThread() {\n-        notifyJvmtiHideFrames(true);\n-        Thread carrier = this.carrierThread;\n-        assert Thread.currentThread() == this\n-                && carrier == Thread.currentCarrierThread();\n-        carrier.setCurrentThread(carrier);\n-    }\n-\n-    \/**\n-     * Sets the current thread to the given virtual thread.\n-     *\/\n-    @ChangesCurrentThread\n-    @JvmtiMountTransition\n-    private static void switchToVirtualThread(VirtualThread vthread) {\n-        Thread carrier = vthread.carrierThread;\n-        assert carrier == Thread.currentCarrierThread();\n-        carrier.setCurrentThread(vthread);\n-        notifyJvmtiHideFrames(false);\n-    }\n-\n-    \/**\n-     * Executes the given value returning task on the current carrier thread.\n-     *\/\n-    @ChangesCurrentThread\n-    <V> V executeOnCarrierThread(Callable<V> task) throws Exception {\n-        assert Thread.currentThread() == this;\n-        switchToCarrierThread();\n-        try {\n-            return task.call();\n-        } finally {\n-            switchToVirtualThread(this);\n-        }\n-     }\n-\n@@ -531,3 +513,2 @@\n-     * Invoked after the continuation yields. If parking then it sets the state\n-     * and also re-submits the task to continue if unparked while parking.\n-     * If yielding due to Thread.yield then it just submits the task to continue.\n+     * Invoked in the context of the carrier thread after the Continuation yields when\n+     * parking or Thread.yield.\n@@ -547,2 +528,9 @@\n-            int newState = (s == PARKING) ? PARKED : TIMED_PARKED;\n-            setState(newState);\n+            int newState;\n+            if (s == PARKING) {\n+                setState(newState = PARKED);\n+            } else {\n+                \/\/ schedule unpark\n+                assert parkTimeout > 0;\n+                timeoutTask = schedule(this::unpark, parkTimeout, NANOSECONDS);\n+                setState(newState = TIMED_PARKED);\n+            }\n@@ -552,6 +540,2 @@\n-                \/\/ lazy submit to continue on the current carrier if possible\n-                if (currentThread() instanceof CarrierThread ct && ct.getQueuedTaskCount() == 0) {\n-                    lazySubmitRunContinuation(ct.getPool());\n-                } else {\n-                    submitRunContinuation();\n-                }\n+                \/\/ lazy submit if local queue is empty\n+                lazySubmitRunContinuation();\n@@ -675,1 +659,3 @@\n-            yielded = yieldContinuation();  \/\/ may throw\n+            yielded = yieldContinuation();\n+        } catch (OutOfMemoryError e) {\n+            \/\/ park on carrier\n@@ -710,0 +696,1 @@\n+            \/\/ park the thread, afterYield will schedule the thread to unpark\n@@ -711,1 +698,1 @@\n-            Future<?> unparker = scheduleUnpark(nanos);  \/\/ may throw OOME\n+            setParkTimeout(nanos);\n@@ -714,1 +701,3 @@\n-                yielded = yieldContinuation();  \/\/ may throw\n+                yielded = yieldContinuation();\n+            } catch (OutOfMemoryError e) {\n+                \/\/ park on carrier\n@@ -721,1 +710,0 @@\n-                cancel(unparker);\n@@ -724,1 +712,1 @@\n-            \/\/ park on carrier thread for remaining time when pinned\n+            \/\/ park on carrier thread for remaining time when pinned (or OOME)\n@@ -775,32 +763,0 @@\n-    \/**\n-     * Schedule this virtual thread to be unparked after a given delay.\n-     *\/\n-    @ChangesCurrentThread\n-    private Future<?> scheduleUnpark(long nanos) {\n-        assert Thread.currentThread() == this;\n-        \/\/ need to switch to current carrier thread to avoid nested parking\n-        switchToCarrierThread();\n-        try {\n-            return schedule(this::unpark, nanos, NANOSECONDS);\n-        } finally {\n-            switchToVirtualThread(this);\n-        }\n-    }\n-\n-    \/**\n-     * Cancels a task if it has not completed.\n-     *\/\n-    @ChangesCurrentThread\n-    private void cancel(Future<?> future) {\n-        assert Thread.currentThread() == this;\n-        if (!future.isDone()) {\n-            \/\/ need to switch to current carrier thread to avoid nested parking\n-            switchToCarrierThread();\n-            try {\n-                future.cancel(false);\n-            } finally {\n-                switchToVirtualThread(this);\n-            }\n-        }\n-    }\n-\n@@ -1044,1 +1000,1 @@\n-                return State.WAITING;\n+                return Thread.State.WAITING;\n@@ -1047,1 +1003,1 @@\n-                return State.TIMED_WAITING;\n+                return Thread.State.TIMED_WAITING;\n@@ -1266,0 +1222,4 @@\n+    private void setParkTimeout(long timeout) {\n+        parkTimeout = timeout;\n+    }\n+\n@@ -1289,4 +1249,0 @@\n-    @IntrinsicCandidate\n-    @JvmtiMountTransition\n-    private static native void notifyJvmtiHideFrames(boolean hide);\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":80,"deletions":124,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.internal.access.JavaLangAccess;\n@@ -2635,1 +2636,1 @@\n-        if (((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) &&\n+        if (((t = JLA.currentCarrierThread()) instanceof ForkJoinWorkerThread) &&\n@@ -2646,0 +2647,1 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-    { \"notifyJvmtiHideFrames\",     \"(Z)V\", (void *)&JVM_VirtualThreadHideFrames },\n","filename":"src\/java.base\/share\/native\/libjava\/VirtualThread.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,2 +33,4 @@\n-import java.util.concurrent.*;\n-import java.util.concurrent.atomic.*;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n@@ -40,1 +42,1 @@\n-        try (ExecutorService scheduler = Executors.newFixedThreadPool(8)) {\n+        try (var scheduler = new Scheduler(8)) {\n@@ -77,0 +79,23 @@\n+\n+    static class Scheduler implements Executor, AutoCloseable {\n+        private final ExecutorService pool;\n+\n+        Scheduler(int poolSize) {\n+            pool = Executors.newFixedThreadPool(poolSize);\n+        }\n+\n+        @Override\n+        public void execute(Runnable task) {\n+            try {\n+                pool.execute(task);\n+            } finally {\n+                \/\/ ExecutorService::execute may consume parking permit\n+                LockSupport.unpark(Thread.currentThread());\n+            }\n+        }\n+\n+        @Override\n+        public void close() {\n+            pool.close();\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ParkWithFixedThreadPool.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"}]}