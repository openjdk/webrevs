{"files":[{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs;\n+\n+import sun.security.util.DerInputStream;\n+import sun.security.util.DerValue;\n+import sun.security.x509.AlgorithmId;\n+\n+import javax.security.auth.DestroyFailedException;\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.Serial;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+\n+public final class NamedPKCS8Key extends PKCS8Key {\n+    @Serial\n+    private static final long serialVersionUID = 1L;\n+\n+    private final String fname;\n+    private final transient NamedParameterSpec paramSpec;\n+    private final byte[] h;\n+\n+    private transient boolean destroyed = false;\n+\n+    \/\/\/ Ctor from family name, parameter set name, raw key bytes.\n+    \/\/\/ Key bytes won't be cloned, caller must relinquish ownership\n+    public NamedPKCS8Key(String fname, String pname, byte[] h) {\n+        this.fname = fname;\n+        this.paramSpec = new NamedParameterSpec(pname);\n+        try {\n+            this.algid = AlgorithmId.get(pname);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ProviderException(e);\n+        }\n+        this.h = h;\n+\n+        DerValue val = new DerValue(DerValue.tag_OctetString, h);\n+        try {\n+            this.key = val.toByteArray();\n+        } finally {\n+            val.clear();\n+        }\n+    }\n+\n+    \/\/\/ Ctor from family name, and PKCS #8 bytes\n+    public NamedPKCS8Key(String fname, byte[] encoded) throws InvalidKeyException {\n+        super(encoded);\n+        this.fname = fname;\n+        try {\n+            paramSpec = new NamedParameterSpec(algid.getName());\n+            if (algid.getEncodedParams() != null) {\n+                throw new InvalidKeyException(\"algorithm identifier has params\");\n+            }\n+            h = new DerInputStream(key).getOctetString();\n+        } catch (IOException e) {\n+            throw new InvalidKeyException(\"Cannot parse input\", e);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        \/\/ Do not modify: this can be used by earlier JDKs that\n+        \/\/ do not have the getParams() method\n+        return paramSpec.getName() + \" private key\";\n+    }\n+\n+    \/\/\/ Returns the reference to the internal key. Caller must not modify\n+    \/\/\/ the content or keep a reference.\n+    public byte[] getRawBytes() {\n+        return h;\n+    }\n+\n+    @Override\n+    public NamedParameterSpec getParams() {\n+        return paramSpec;\n+    }\n+\n+    @Override\n+    public String getAlgorithm() {\n+        return fname;\n+    }\n+\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"NamedPKCS8Key keys are not directly deserializable\");\n+    }\n+\n+    @Override\n+    public void destroy() throws DestroyFailedException {\n+        Arrays.fill(h, (byte)0);\n+        Arrays.fill(this.key, (byte)0);\n+        if (this.encodedKey != null) {\n+            Arrays.fill(this.encodedKey, (byte)0);\n+        }\n+        destroyed = true;\n+    }\n+\n+    @Override\n+    public boolean isDestroyed() {\n+        return destroyed;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/NamedPKCS8Key.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import javax.crypto.DecapsulateException;\n+import javax.crypto.KEM;\n+import javax.crypto.KEMSpi;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+\/\/\/ An implementation extends this class to create its own `KEM`.\n+\/\/\/\n+\/\/\/ @see NamedKeyPairGenerator\n+public abstract class NamedKEM implements KEMSpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    \/\/\/ Creates a new `NamedKEM` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n+    protected NamedKEM(String fname, String... pnames) {\n+        this.fname = Objects.requireNonNull(fname);\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.pnames = pnames;\n+    }\n+\n+    @Override\n+    public EncapsulatorSpi engineNewEncapsulator(PublicKey publicKey,\n+            AlgorithmParameterSpec spec, SecureRandom secureRandom)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"No params needed\");\n+        }\n+        \/\/ translate also check the key\n+        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(publicKey);\n+        var pk = nk.getRawBytes();\n+        return getKeyConsumerImpl(this, nk.getParams(), pk,\n+                implCheckPublicKey(nk.getParams().getName(), pk), secureRandom);\n+    }\n+\n+    @Override\n+    public DecapsulatorSpi engineNewDecapsulator(\n+            PrivateKey privateKey, AlgorithmParameterSpec spec)\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n+        if (spec != null) {\n+            throw new InvalidAlgorithmParameterException(\"No params needed\");\n+        }\n+        \/\/ translate also check the key\n+        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(privateKey);\n+        var sk = nk.getRawBytes();\n+        return getKeyConsumerImpl(this, nk.getParams(), sk,\n+                implCheckPrivateKey(nk.getParams().getName(), sk), null);\n+    }\n+\n+    \/\/ We don't have a flag on whether key is public key or private key.\n+    \/\/ The correct method should always be called.\n+    private record KeyConsumerImpl(NamedKEM kem, String name, int sslen,\n+            int clen, byte[] key, Object k2, SecureRandom sr)\n+            implements KEMSpi.EncapsulatorSpi, KEMSpi.DecapsulatorSpi {\n+        @Override\n+        public SecretKey engineDecapsulate(byte[] encapsulation, int from, int to,\n+                String algorithm) throws DecapsulateException {\n+            if (encapsulation.length != clen) {\n+                throw new DecapsulateException(\"Invalid key encapsulation message length\");\n+            }\n+            var ss = kem.implDecapsulate(name, key, k2, encapsulation);\n+            try {\n+                return new SecretKeySpec(ss,\n+                        from, to - from, algorithm);\n+            } finally {\n+                Arrays.fill(ss, (byte)0);\n+            }\n+        }\n+\n+        @Override\n+        public KEM.Encapsulated engineEncapsulate(int from, int to, String algorithm) {\n+            var enc = kem.implEncapsulate(name, key, k2, sr);\n+            try {\n+                return new KEM.Encapsulated(\n+                        new SecretKeySpec(enc[1],\n+                                from, to - from, algorithm),\n+                        enc[0],\n+                        null);\n+            } finally {\n+                Arrays.fill(enc[1], (byte)0);\n+            }\n+        }\n+\n+        @Override\n+        public int engineSecretSize() {\n+            return sslen;\n+        }\n+\n+        @Override\n+        public int engineEncapsulationSize() {\n+            return clen;\n+        }\n+    }\n+\n+    private static KeyConsumerImpl getKeyConsumerImpl(NamedKEM kem,\n+            NamedParameterSpec nps, byte[] key, Object k2, SecureRandom sr) {\n+        String name = nps.getName();\n+        return new KeyConsumerImpl(kem, name, kem.implSecretSize(name), kem.implEncapsulationSize(name),\n+                key, k2, sr);\n+    }\n+\n+    \/\/\/ User-defined encap function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @param pk2 parsed public key, `null` if none.\n+    \/\/\/ @param sr SecureRandom object, `null` if not initialized\n+    \/\/\/ @return the key encapsulation message and the shared key (in this order)\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    public abstract byte[][] implEncapsulate(String name, byte[] pk, Object pk2, SecureRandom sr);\n+\n+    \/\/\/ User-defined decap function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk private key in raw bytes\n+    \/\/\/ @param sk2 parsed private key, `null` if none.\n+    \/\/\/ @param encap the key encapsulation message\n+    \/\/\/ @return the shared key\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    \/\/\/ @throws DecapsulateException if there is another error\n+    public abstract byte[] implDecapsulate(String name, byte[] sk, Object sk2, byte[] encap)\n+            throws DecapsulateException;\n+\n+    \/\/\/ User-defined function returning shared secret key length.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @return shared secret key length\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    public abstract int implSecretSize(String name);\n+\n+    \/\/\/ User-defined function returning key encapsulation message length.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @return key encapsulation message length\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    public abstract int implEncapsulationSize(String name);\n+\n+    \/\/\/ User-defined function to validate a public key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `newEncapsulator`. This gives provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optional return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implEncapsulate] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    public Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+        return null;\n+    }\n+\n+    \/\/\/ User-defined function to validate a private key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `newDecapsulator`. This gives provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optional return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implDecapsulate] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk public key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    public Object implCheckPrivateKey(String name, byte[] sk) throws InvalidKeyException {\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKEM.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.AsymmetricKey;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.KeyFactorySpi;\n+import java.security.PrivateKey;\n+import java.security.PublicKey;\n+import java.security.spec.EncodedKeySpec;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.KeySpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+\/\/\/ An implementation extends this class to create its own `KeyFactory`.\n+\/\/\/\n+\/\/\/ Bonus: This factory can read from a RAW key using `translateKey`\n+\/\/\/ if `key.getFormat` is \"RAW\", and write to a RAW `EncodedKeySpec`\n+\/\/\/ using `getKeySpec(key, EncodedKeySpec.class)`.\n+\/\/\/\n+\/\/\/ @see NamedKeyPairGenerator\n+public class NamedKeyFactory extends KeyFactorySpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    \/\/\/ Creates a new `NamedKeyFactory` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n+    protected NamedKeyFactory(String fname, String... pnames) {\n+        this.fname = Objects.requireNonNull(fname);\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.pnames = pnames;\n+    }\n+\n+    private String checkName(String name) throws InvalidKeyException  {\n+        for (var pname : pnames) {\n+            if (pname.equalsIgnoreCase(name)) {\n+                \/\/ return the stored standard name\n+                return pname;\n+            }\n+        }\n+        throw new InvalidKeyException(\"Unknown parameter set name: \" + name);\n+    }\n+\n+    @Override\n+    protected PublicKey engineGeneratePublic(KeySpec keySpec)\n+            throws InvalidKeySpecException {\n+        if (keySpec instanceof X509EncodedKeySpec xspec) {\n+            try {\n+                return fromX509(xspec.getEncoded());\n+            } catch (InvalidKeyException e) {\n+                throw new InvalidKeySpecException(e);\n+            }\n+        } else {\n+            throw new InvalidKeySpecException(\"Unsupported keyspec: \" + keySpec);\n+        }\n+    }\n+\n+    @Override\n+    protected PrivateKey engineGeneratePrivate(KeySpec keySpec)\n+            throws InvalidKeySpecException {\n+        if (keySpec instanceof PKCS8EncodedKeySpec pspec) {\n+            var bytes = pspec.getEncoded();\n+            try {\n+                return fromPKCS8(bytes);\n+            } catch (InvalidKeyException e) {\n+                throw new InvalidKeySpecException(e);\n+            } finally {\n+                Arrays.fill(bytes, (byte)0);\n+            }\n+        } else {\n+            throw new InvalidKeySpecException(\"Unsupported keyspec: \" + keySpec);\n+        }\n+    }\n+\n+    private PrivateKey fromPKCS8(byte[] bytes)\n+            throws InvalidKeyException, InvalidKeySpecException {\n+        var k = new NamedPKCS8Key(fname, bytes);\n+        checkName(k.getParams().getName());\n+        return k;\n+    }\n+\n+    private PublicKey fromX509(byte[] bytes)\n+            throws InvalidKeyException, InvalidKeySpecException {\n+        var k = new NamedX509Key(fname, bytes);\n+        checkName(k.getParams().getName());\n+        return k;\n+    }\n+\n+    private static class RawEncodedKeySpec extends EncodedKeySpec {\n+        public RawEncodedKeySpec(byte[] encodedKey) {\n+            super(encodedKey);\n+        }\n+\n+        @Override\n+        public String getFormat() {\n+            return \"RAW\";\n+        }\n+    }\n+\n+    @Override\n+    protected <T extends KeySpec> T engineGetKeySpec(Key key, Class<T> keySpec)\n+            throws InvalidKeySpecException {\n+        try {\n+            key = engineTranslateKey(key);\n+        } catch (InvalidKeyException e) {\n+            throw new InvalidKeySpecException(e);\n+        }\n+        \/\/ key is now either NamedPKCS8Key or NamedX509Key of permitted param set\n+        if (key instanceof NamedPKCS8Key nk) {\n+            byte[] bytes = null;\n+            try {\n+                if (keySpec == PKCS8EncodedKeySpec.class) {\n+                    return keySpec.cast(\n+                            new PKCS8EncodedKeySpec(bytes = key.getEncoded()));\n+                } else if (keySpec.isAssignableFrom(EncodedKeySpec.class)) {\n+                    return keySpec.cast(\n+                            new RawEncodedKeySpec(bytes = nk.getRawBytes()));\n+                }\n+            } finally {\n+                if (bytes != null) {\n+                    Arrays.fill(bytes, (byte)0);\n+                }\n+            }\n+        } else if (key instanceof NamedX509Key nk) {\n+            if (keySpec == X509EncodedKeySpec.class\n+                    && key.getFormat().equalsIgnoreCase(\"X.509\")) {\n+                return keySpec.cast(new X509EncodedKeySpec(key.getEncoded()));\n+            } else if (keySpec.isAssignableFrom(EncodedKeySpec.class)) {\n+                return keySpec.cast(new RawEncodedKeySpec(nk.getRawBytes()));\n+            }\n+        }\n+        throw new AssertionError(\"Unknown key: \" + key.getClass());\n+    }\n+\n+    @Override\n+    protected Key engineTranslateKey(Key key) throws InvalidKeyException {\n+        if (key == null) {\n+            throw new InvalidKeyException(\"Key must not be null\");\n+        }\n+        if (key instanceof NamedX509Key nk) {\n+            checkName(nk.getParams().getName());\n+            return key;\n+        }\n+        if (key instanceof NamedPKCS8Key nk) {\n+            checkName(nk.getParams().getName());\n+            return key;\n+        }\n+        var format = key.getFormat();\n+        if (format == null) {\n+            throw new InvalidKeyException(\"Unextractable key\");\n+        } else if (format.equalsIgnoreCase(\"RAW\")) {\n+            var kAlg = key.getAlgorithm();\n+            if (key instanceof AsymmetricKey pk) {\n+                String name;\n+                \/\/ Three case that we can find the parameter set name from a RAW key:\n+                \/\/ 1. getParams() returns one\n+                \/\/ 2. getAlgorithm() returns param set name (some provider does this)\n+                \/\/ 3. getAlgorithm() returns family name but this KF is for param set name\n+                if (pk.getParams() instanceof NamedParameterSpec nps) {\n+                    name = checkName(nps.getName());\n+                } else {\n+                    if (kAlg.equalsIgnoreCase(fname)) {\n+                        if (pnames.length == 1) {\n+                            name = pnames[0];\n+                        } else {\n+                            throw new InvalidKeyException(\"No parameter set info\");\n+                        }\n+                    } else {\n+                        name = checkName(kAlg);\n+                    }\n+                }\n+                return key instanceof PrivateKey\n+                        ? new NamedPKCS8Key(fname, name, key.getEncoded())\n+                        : new NamedX509Key(fname, name, key.getEncoded());\n+            } else {\n+                throw new InvalidKeyException(\"Unsupported key type: \" + key.getClass());\n+            }\n+        } else if (format.equalsIgnoreCase(\"PKCS#8\") && key instanceof PrivateKey) {\n+            var bytes = key.getEncoded();\n+            try {\n+                return fromPKCS8(bytes);\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(\"Invalid PKCS#8 key\", e);\n+            } finally {\n+                Arrays.fill(bytes, (byte) 0);\n+            }\n+        } else if (format.equalsIgnoreCase(\"X.509\") && key instanceof PublicKey) {\n+            try {\n+                return fromX509(key.getEncoded());\n+            } catch (InvalidKeySpecException e) {\n+                throw new InvalidKeyException(\"Invalid X.509 key\", e);\n+            }\n+        } else {\n+            throw new InvalidKeyException(\"Unknown key format: \" + key.getFormat());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyFactory.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidParameterException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGeneratorSpi;\n+import java.security.ProviderException;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Objects;\n+\n+\/\/\/ An implementation extends this class to create its own `KeyPairGenerator`.\n+\/\/\/\n+\/\/\/ An implementation must include a zero-argument public constructor that calls\n+\/\/\/ `super(fname, pnames)`, where `fname` is the family name of the algorithm and\n+\/\/\/ `pnames` are the supported parameter set names. `pnames` must contain at least\n+\/\/\/ one element and the first element is the default parameter set name,\n+\/\/\/ i.e. the parameter set to be used in key pair generation unless\n+\/\/\/ [#initialize(AlgorithmParameterSpec, java.security.SecureRandom)]\n+\/\/\/ is called to choose a specific parameter set. This requirement also applies\n+\/\/\/ to implementations of [NamedKeyFactory], [NamedKEM], and [NamedSignature],\n+\/\/\/ although there is no default parameter set concept for these classes.\n+\/\/\/\n+\/\/\/ An implementation must implement all abstract methods. For all these\n+\/\/\/ methods, the implementation must relinquish any \"ownership\" of any input\n+\/\/\/ and output array argument. Precisely, the implementation must not retain\n+\/\/\/ any reference to a returning array so that it won't be able to modify its\n+\/\/\/ content later. Similarly, the implementation must not modify any input\n+\/\/\/ array argument and must not retain any reference to an input array argument\n+\/\/\/ after the call. Together, this makes sure that the caller does not need to\n+\/\/\/ make any defensive copy on the input and output arrays. This requirement\n+\/\/\/ also applies to abstract methods defined in [NamedKEM] and [NamedSignature].\n+\/\/\/\n+\/\/\/ Also, an implementation must not keep any extra copy of a private key.\n+\/\/\/ For key generation, the only copy is the one returned in the\n+\/\/\/ [#implGenerateKeyPair] call. For all other methods, it must not make\n+\/\/\/ a copy of the input private key. A `KEM` implementation also must\n+\/\/\/ not keep a copy of the shared secret key, no matter if it's an\n+\/\/\/ encapsulator or a decapsulator.\n+\/\/\/\n+\/\/\/ The `NamedSignature` and `NamedKEM` classes provide `implCheckPublicKey`\n+\/\/\/ and `implCheckPrivateKey` methods that allow an implementation to validate\n+\/\/\/ a key before using it. An implementation may return a parsed key of\n+\/\/\/ a local type, and this parsed key will be passed to an operational method\n+\/\/\/ (For example, `implSign`) later. An implementation must not retain\n+\/\/\/ a reference of the parsed key.\n+public abstract class NamedKeyPairGenerator extends KeyPairGeneratorSpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    protected String name = null; \/\/ init as\n+    private SecureRandom secureRandom;\n+\n+    \/\/\/ Creates a new `NamedKeyPairGenerator` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames supported parameter set names, at least one is needed.\n+    \/\/\/     If multiple, the first one becomes the default parameter set name.\n+    protected NamedKeyPairGenerator(String fname, String... pnames) {\n+        this.fname = Objects.requireNonNull(fname);\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.pnames = pnames;\n+    }\n+\n+    private String checkName(String name) throws InvalidAlgorithmParameterException  {\n+        for (var pname : pnames) {\n+            if (pname.equalsIgnoreCase(name)) {\n+                \/\/ return the stored standard name\n+                return pname;\n+            }\n+        }\n+        throw new InvalidAlgorithmParameterException(\n+                \"Unknown parameter set name: \" + name);\n+    }\n+\n+    @Override\n+    public void initialize(AlgorithmParameterSpec params, SecureRandom random)\n+            throws InvalidAlgorithmParameterException {\n+        if (params instanceof NamedParameterSpec spec) {\n+            name = checkName(spec.getName());\n+        } else {\n+            throw new InvalidAlgorithmParameterException(\n+                    \"Unknown AlgorithmParameterSpec: \" + params);\n+        }\n+        this.secureRandom = random ;\n+    }\n+\n+    @Override\n+    public void initialize(int keysize, SecureRandom random) {\n+        if (keysize != -1) {\n+            \/\/ Bonus: a chance to provide a SecureRandom without\n+            \/\/ specifying a parameter set name\n+            throw new InvalidParameterException(\"keysize not supported\");\n+        }\n+        this.secureRandom = random;\n+    }\n+\n+    @Override\n+    public KeyPair generateKeyPair() {\n+        String pname = name != null ? name : pnames[0];\n+        var keys = implGenerateKeyPair(pname, secureRandom);\n+        return new KeyPair(new NamedX509Key(fname, pname, keys[0]),\n+                new NamedPKCS8Key(fname, pname, keys[1]));\n+    }\n+\n+    \/\/\/ User-defined key pair generator.\n+    \/\/\/\n+    \/\/\/ @param pname parameter set name\n+    \/\/\/ @param sr `SecureRandom` object, `null` if not initialized\n+    \/\/\/ @return public key and private key (in this order) in raw bytes\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    public abstract byte[][] implGenerateKeyPair(String pname, SecureRandom sr);\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedKeyPairGenerator.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.provider;\n+\n+import sun.security.pkcs.NamedPKCS8Key;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidParameterException;\n+import java.security.PrivateKey;\n+import java.security.ProviderException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.SignatureException;\n+import java.security.SignatureSpi;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.util.Objects;\n+\n+\/\/\/ An implementation extends this class to create its own `Signature`.\n+\/\/\/\n+\/\/\/ This class does not work with preHash signatures.\n+\/\/\/\n+\/\/\/ @see NamedKeyPairGenerator\n+public abstract class NamedSignature extends SignatureSpi {\n+\n+    private final String fname; \/\/ family name\n+    private final String[] pnames; \/\/ allowed parameter set name (at least one)\n+\n+    private final ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+\n+    \/\/ init with...\n+    private String name = null;\n+    private byte[] secKey = null;\n+    private byte[] pubKey = null;\n+\n+    private Object sk2 = null;\n+    private Object pk2 = null;\n+\n+    \/\/\/ Creates a new `NamedSignature` object.\n+    \/\/\/\n+    \/\/\/ @param fname the family name\n+    \/\/\/ @param pnames the standard parameter set names, at least one is needed.\n+    protected NamedSignature(String fname, String... pnames) {\n+        this.fname = Objects.requireNonNull(fname);\n+        if (pnames == null || pnames.length == 0) {\n+            throw new AssertionError(\"pnames cannot be null or empty\");\n+        }\n+        this.pnames = pnames;\n+    }\n+\n+    @Override\n+    protected void engineInitVerify(PublicKey publicKey) throws InvalidKeyException {\n+        \/\/ translate also check the key\n+        var nk = (NamedX509Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(publicKey);\n+        name = nk.getParams().getName();\n+        pubKey = nk.getRawBytes();\n+        pk2 = implCheckPublicKey(name, pubKey);\n+        secKey = null;\n+        bout.reset();\n+    }\n+\n+    @Override\n+    protected void engineInitSign(PrivateKey privateKey) throws InvalidKeyException {\n+        \/\/ translate also check the key\n+        var nk = (NamedPKCS8Key) new NamedKeyFactory(fname, pnames)\n+                .engineTranslateKey(privateKey);\n+        name = nk.getParams().getName();\n+        secKey = nk.getRawBytes();\n+        sk2 = implCheckPrivateKey(name, secKey);\n+        pubKey = null;\n+        bout.reset();\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte b) throws SignatureException {\n+        bout.write(b);\n+    }\n+\n+    @Override\n+    protected void engineUpdate(byte[] b, int off, int len) throws SignatureException {\n+        bout.write(b, off, len);\n+    }\n+\n+    @Override\n+    protected byte[] engineSign() throws SignatureException {\n+        if (secKey != null) {\n+            var msg = bout.toByteArray();\n+            bout.reset();\n+            return implSign(name, secKey, sk2, msg, appRandom);\n+        } else {\n+            throw new IllegalStateException(\"No private key\");\n+        }\n+    }\n+\n+    @Override\n+    protected boolean engineVerify(byte[] sig) throws SignatureException {\n+        if (pubKey != null) {\n+            var msg = bout.toByteArray();\n+            bout.reset();\n+            return implVerify(name, pubKey, pk2, msg, sig);\n+        } else {\n+            throw new IllegalStateException(\"No public key\");\n+        }\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected void engineSetParameter(String param, Object value)\n+            throws InvalidParameterException {\n+        throw new UnsupportedOperationException(\"setParameter() not supported\");\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"deprecation\")\n+    protected Object engineGetParameter(String param) throws InvalidParameterException {\n+        throw new UnsupportedOperationException(\"getParameter() not supported\");\n+    }\n+\n+    @Override\n+    protected void engineSetParameter(AlgorithmParameterSpec params)\n+            throws InvalidAlgorithmParameterException {\n+        if (params != null) {\n+            throw new InvalidAlgorithmParameterException(\"No params needed\");\n+        }\n+    }\n+\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        return null;\n+    }\n+\n+    \/\/\/ User-defined sign function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk private key in raw bytes\n+    \/\/\/ @param sk2 parsed private key, `null` if none.\n+    \/\/\/ @param msg the message\n+    \/\/\/ @param sr SecureRandom object, `null` if not initialized\n+    \/\/\/ @return the signature\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    \/\/\/ @throws SignatureException if there is another error\n+    public abstract byte[] implSign(String name, byte[] sk, Object sk2,\n+            byte[] msg, SecureRandom sr) throws SignatureException;\n+\n+    \/\/\/ User-defined verify function.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @param pk2 parsed public key, `null` if none.\n+    \/\/\/ @param msg the message\n+    \/\/\/ @param sig the signature\n+    \/\/\/ @return true if verified\n+    \/\/\/ @throws ProviderException if there is an internal error\n+    \/\/\/ @throws SignatureException if there is another error\n+    public abstract boolean implVerify(String name, byte[] pk, Object pk2,\n+            byte[] msg, byte[] sig) throws SignatureException;\n+\n+    \/\/\/ User-defined function to validate a public key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `initVerify`. This gives provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optional return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implVerify] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param pk public key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    public Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+        return null;\n+    }\n+\n+    \/\/\/ User-defined function to validate a private key.\n+    \/\/\/\n+    \/\/\/ This method will be called in `initSign`. This gives provider a chance to\n+    \/\/\/ reject the key so an `InvalidKeyException` can be thrown earlier.\n+    \/\/\/ An implementation can optional return a \"parsed key\" as an `Object` value.\n+    \/\/\/ This object will be passed into the [#implSign] method along with the raw key.\n+    \/\/\/\n+    \/\/\/ The default implementation returns `null`.\n+    \/\/\/\n+    \/\/\/ @param name parameter name\n+    \/\/\/ @param sk public key in raw bytes\n+    \/\/\/ @return a parsed key, `null` if none.\n+    \/\/\/ @throws InvalidKeyException if the key is invalid\n+    public Object implCheckPrivateKey(String name, byte[] sk) throws InvalidKeyException {\n+        return null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/NamedSignature.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -393,2 +393,2 @@\n-            if (key instanceof EdECKey) {\n-                return AlgorithmId.get(((EdECKey) key).getParams().getName());\n+            if (key.getParams() instanceof NamedParameterSpec nps) {\n+                return AlgorithmId.get(nps.getName());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.x509;\n+\n+import sun.security.util.BitArray;\n+\n+import java.io.IOException;\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.Serial;\n+import java.security.InvalidKeyException;\n+import java.security.KeyRep;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.ProviderException;\n+import java.security.spec.NamedParameterSpec;\n+\n+public final class NamedX509Key extends X509Key {\n+    @Serial\n+    private static final long serialVersionUID = 1L;\n+\n+    private final String fname;\n+    private final transient NamedParameterSpec paramSpec;\n+    private final byte[] h;\n+\n+    \/\/\/ Ctor from family name, parameter set name, raw key bytes.\n+    \/\/\/ Key bytes won't be cloned, caller must relinquish ownership\n+    public NamedX509Key(String fname, String pname, byte[] h) {\n+        this.fname = fname;\n+        this.paramSpec = new NamedParameterSpec(pname);\n+        try {\n+            this.algid = AlgorithmId.get(pname);\n+        } catch (NoSuchAlgorithmException e) {\n+            throw new ProviderException(e);\n+        }\n+        this.h = h;\n+\n+        setKey(new BitArray(h.length * 8, h));\n+    }\n+\n+    \/\/\/ Ctor from family name, and X.509 bytes\n+    public NamedX509Key(String fname, byte[] encoded) throws InvalidKeyException {\n+        this.fname = fname;\n+        decode(encoded);\n+        paramSpec = new NamedParameterSpec(algid.getName());\n+        if (algid.encodedParams != null) {\n+            throw new InvalidKeyException(\"algorithm identifier has params\");\n+        }\n+        h = getKey().toByteArray();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        \/\/ Do not modify: this can be used by earlier JDKs that\n+        \/\/ do not have the getParams() method\n+        return paramSpec.getName() + \" public key\";\n+    }\n+\n+    \/\/\/ Returns the reference to the internal key. Caller must not modify\n+    \/\/\/ the content or keep a reference.\n+    public byte[] getRawBytes() {\n+        return h;\n+    }\n+\n+    @Override\n+    public NamedParameterSpec getParams() {\n+        return paramSpec;\n+    }\n+\n+    @Override\n+    public String getAlgorithm() {\n+        return fname;\n+    }\n+\n+    @java.io.Serial\n+    private Object writeReplace() throws java.io.ObjectStreamException {\n+        return new KeyRep(KeyRep.Type.PUBLIC, getAlgorithm(), getFormat(),\n+                getEncoded());\n+    }\n+\n+    @java.io.Serial\n+    private void readObject(ObjectInputStream stream)\n+            throws IOException, ClassNotFoundException {\n+        throw new InvalidObjectException(\n+                \"NamedX509Key keys are not directly deserializable\");\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/NamedX509Key.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340327\n+ * @modules java.base\/sun.security.ec.ed\n+ *          java.base\/sun.security.ec.point\n+ *          java.base\/sun.security.jca\n+ *          java.base\/sun.security.provider\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.ec.ed.EdDSAOperations;\n+import sun.security.ec.ed.EdDSAParameters;\n+import sun.security.ec.point.AffinePoint;\n+import sun.security.jca.JCAUtil;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+import sun.security.provider.NamedSignature;\n+\n+import java.security.*;\n+import java.security.spec.EdDSAParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class NamedEdDSA {\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"Named\", \"0\", \"\");\n+            put(\"KeyPairGenerator.EdDSA\", EdDSAKeyPairGenerator.class.getName());\n+            put(\"KeyPairGenerator.Ed25519\", EdDSAKeyPairGenerator.Ed25519.class.getName());\n+            put(\"KeyPairGenerator.Ed448\", EdDSAKeyPairGenerator.Ed448.class.getName());\n+            put(\"KeyFactory.EdDSA\", EdDSAKeyFactory.class.getName());\n+            put(\"KeyFactory.Ed25519\", EdDSAKeyFactory.Ed25519.class.getName());\n+            put(\"KeyFactory.Ed448\", EdDSAKeyFactory.Ed448.class.getName());\n+            put(\"Signature.EdDSA\", EdDSASignature.class.getName());\n+            put(\"Signature.Ed25519\", EdDSASignature.Ed25519.class.getName());\n+            put(\"Signature.Ed448\", EdDSASignature.Ed448.class.getName());\n+        }\n+    }\n+\n+    public static class EdDSASignature extends NamedSignature {\n+        public EdDSASignature() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSASignature(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSASignature {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSASignature {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+\n+        @Override\n+        public byte[] implSign(String name, byte[] sk, Object sk2, byte[] msg, SecureRandom sr) throws SignatureException {\n+            return getOps(name).sign(plain, sk, msg);\n+        }\n+\n+        @Override\n+        public boolean implVerify(String name, byte[] pk, Object pk2, byte[] msg, byte[] sig) throws SignatureException {\n+            return getOps(name).verify(plain, (AffinePoint) pk2, pk, msg, sig);\n+        }\n+\n+        @Override\n+        public Object implCheckPublicKey(String name, byte[] pk) throws InvalidKeyException {\n+            return getOps(name).decodeAffinePoint(InvalidKeyException::new, pk);\n+        }\n+    }\n+\n+    public static class EdDSAKeyFactory extends NamedKeyFactory {\n+        public EdDSAKeyFactory() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSAKeyFactory(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSAKeyFactory {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSAKeyFactory {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+    }\n+\n+    public static class EdDSAKeyPairGenerator extends NamedKeyPairGenerator {\n+        public EdDSAKeyPairGenerator() {\n+            super(\"EdDSA\", \"Ed25519\", \"Ed448\");\n+        }\n+\n+        protected EdDSAKeyPairGenerator(String pname) {\n+            super(\"EdDSA\", pname);\n+        }\n+\n+        public static class Ed25519 extends EdDSAKeyPairGenerator {\n+            public Ed25519() {\n+                super(\"Ed25519\");\n+            }\n+        }\n+\n+        public static class Ed448 extends EdDSAKeyPairGenerator {\n+            public Ed448() {\n+                super(\"Ed448\");\n+            }\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String pname, SecureRandom sr) {\n+            sr = sr == null ? JCAUtil.getDefSecureRandom() : sr;\n+            var op = getOps(pname);\n+            var sk = op.generatePrivate(sr);\n+            var point = op.computePublic(sk);\n+            byte[] encodedPoint = point.getY().toByteArray();\n+            reverse(encodedPoint);\n+            \/\/ array may be too large or too small, depending on the value\n+            encodedPoint = Arrays.copyOf(encodedPoint, op.getParameters().getKeyLength());\n+            \/\/ set the high-order bit of the encoded point\n+            byte msb = (byte) (point.isXOdd() ? 0x80 : 0);\n+            encodedPoint[encodedPoint.length - 1] |= msb;\n+            return new byte[][] { encodedPoint, sk };\n+        }\n+\n+        private static void swap(byte[] arr, int i, int j) {\n+            byte tmp = arr[i];\n+            arr[i] = arr[j];\n+            arr[j] = tmp;\n+        }\n+\n+        private static void reverse(byte [] arr) {\n+            int i = 0;\n+            int j = arr.length - 1;\n+\n+            while (i < j) {\n+                swap(arr, i, j);\n+                i++;\n+                j--;\n+            }\n+        }\n+    }\n+\n+    private static EdDSAOperations getOps(String pname) {\n+        var op = switch (pname) {\n+            case \"Ed25519\" -> e2;\n+            case \"Ed448\" -> e4;\n+            default -> throw new AssertionError(\"unknown pname \" + pname);\n+        };\n+        return op;\n+    }\n+\n+    static final EdDSAParameterSpec plain = new EdDSAParameterSpec(false);\n+    static final EdDSAOperations e2, e4;\n+    static {\n+        try {\n+            e2 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 255));\n+            e4 = new EdDSAOperations(EdDSAParameters.getBySize(AssertionError::new, 448));\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        var ps = List.of(new ProviderImpl(), Security.getProvider(\"SunEC\"));\n+        for (var p1 : ps) {\n+            for (var p2 : ps) {\n+                for (var p3 : ps) {\n+                    test(p1, p2, p3);\n+                }\n+            }\n+        }\n+    }\n+\n+    static void test(Provider p1, Provider p2, Provider p3) throws Exception {\n+        System.out.println(p1.getName() + \" \" + p2.getName() + \" \" + p3.getName());\n+        var g = KeyPairGenerator.getInstance(\"EdDSA\", p1);\n+        g.initialize(NamedParameterSpec.ED448);\n+        var kp = g.generateKeyPair();\n+        var s1 = Signature.getInstance(\"EdDSA\", p2);\n+        var s2 = Signature.getInstance(\"EdDSA\", p3);\n+        var f1 = KeyFactory.getInstance(\"EdDSA\", p2);\n+        var f2 = KeyFactory.getInstance(\"EdDSA\", p3);\n+        s1.initSign((PrivateKey) f1.translateKey(kp.getPrivate()));\n+        var sig = s1.sign();\n+        s2.initVerify((PublicKey) f2.translateKey(kp.getPublic()));\n+        Asserts.assertTrue(s2.verify(sig));\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/NamedEdDSA.java","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8340327\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.provider\n+ * @library \/test\/lib\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import sun.security.provider.NamedKeyFactory;\n+import sun.security.provider.NamedKeyPairGenerator;\n+import sun.security.x509.NamedX509Key;\n+\n+import java.security.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.NamedParameterSpec;\n+import java.security.spec.X509EncodedKeySpec;\n+\n+public class NamedKeyFactoryTest {\n+    public static void main(String[] args) throws Exception {\n+        Security.addProvider(new ProviderImpl());\n+\n+        var k = new NamedX509Key(\"sHa\", \"SHA-256\", new byte[2]);\n+        var kf = KeyFactory.getInstance(\"ShA\");\n+\n+        Asserts.assertTrue(k.getAlgorithm().equalsIgnoreCase(\"SHA\"));\n+        Asserts.assertEquals(k.getFormat(), \"X.509\");\n+        Asserts.assertEquals(k.getParams().getName(), \"SHA-256\");\n+\n+        var spec = kf.getKeySpec(k, X509EncodedKeySpec.class);\n+        Asserts.assertEquals(kf.generatePublic(spec).getAlgorithm(), \"SHA\");\n+\n+        var kf2 = KeyFactory.getInstance(\"Sha-256\");\n+        var kf5 = KeyFactory.getInstance(\"Sha-512\");\n+\n+        var pk1 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return new byte[2]; }\n+        };\n+        var pk2 = new PublicKey() {\n+            public String getAlgorithm() { return \"sHA-256\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return new byte[2]; }\n+        };\n+        var pk3 = new PublicKey() {\n+            public String getAlgorithm() { return \"SHA\"; }\n+            public String getFormat() { return \"RAW\"; }\n+            public byte[] getEncoded() { return new byte[2]; }\n+            public AlgorithmParameterSpec getParams() { return new NamedParameterSpec(\"sHA-256\"); }\n+        };\n+\n+        Asserts.assertTrue(kf2.translateKey(pk1).toString().contains(\"SHA-256\"));\n+        Asserts.assertTrue(kf.translateKey(pk2).toString().contains(\"SHA-256\"));\n+        Asserts.assertTrue(kf.translateKey(pk3).toString().contains(\"SHA-256\"));\n+\n+        Utils.runAndCheckException(() -> kf.translateKey(pk1), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk2), InvalidKeyException.class);\n+        Utils.runAndCheckException(() -> kf5.translateKey(pk3), InvalidKeyException.class);\n+\n+        var kpg = KeyPairGenerator.getInstance(\"SHA\");\n+        Asserts.assertTrue(kpg.generateKeyPair().getPublic().toString().contains(\"SHA-256\"));\n+\n+        kpg.initialize(new NamedParameterSpec(\"ShA-256\"));\n+        Asserts.assertTrue(kpg.generateKeyPair().getPublic().toString().contains(\"SHA-256\"));\n+        kpg.initialize(new NamedParameterSpec(\"SHa-512\"));\n+        Asserts.assertTrue(kpg.generateKeyPair().getPublic().toString().contains(\"SHA-512\"));\n+\n+        var kpg1 = KeyPairGenerator.getInstance(\"ShA-256\");\n+        Asserts.assertTrue(kpg1.generateKeyPair().getPublic().toString().contains(\"SHA-256\"));\n+\n+        var kpg2 = KeyPairGenerator.getInstance(\"sHA-512\");\n+        Asserts.assertTrue(kpg2.generateKeyPair().getPublic().toString().contains(\"SHA-512\"));\n+    }\n+\n+    public static class ProviderImpl extends Provider {\n+        public ProviderImpl() {\n+            super(\"P\", \"1\", \"...\");\n+            put(\"KeyFactory.SHA\", KF.class.getName());\n+            put(\"KeyFactory.SHA-256\", KF1.class.getName());\n+            put(\"KeyFactory.SHA-512\", KF2.class.getName());\n+            put(\"KeyPairGenerator.SHA\", KPG.class.getName());\n+            put(\"KeyPairGenerator.SHA-256\", KPG1.class.getName());\n+            put(\"KeyPairGenerator.SHA-512\", KPG2.class.getName());\n+        }\n+    }\n+    public static class KF extends NamedKeyFactory {\n+        public KF() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+    }\n+    public static class KF1 extends NamedKeyFactory {\n+        public KF1() {\n+            super(\"SHA\", \"SHA-256\");\n+        }\n+    }\n+    public static class KF2 extends NamedKeyFactory {\n+        public KF2() {\n+            super(\"SHA\", \"SHA-512\");\n+        }\n+    }\n+    public static class KPG extends NamedKeyPairGenerator {\n+        public KPG() {\n+            super(\"SHA\", \"SHA-256\", \"SHA-512\");\n+        }\n+\n+        public KPG(String pname) {\n+            super(\"SHA\", pname);\n+        }\n+\n+        @Override\n+        public byte[][] implGenerateKeyPair(String name, SecureRandom sr) {\n+            var out = new byte[2][];\n+            out[0] = new byte[name.endsWith(\"256\") ? 2 : 4];\n+            out[1] = new byte[name.endsWith(\"256\") ? 2 : 4];\n+            return out;\n+        }\n+    }\n+    public static class KPG1 extends KPG {\n+        public KPG1() {\n+            super(\"SHA-256\");\n+        }\n+    }\n+    public static class KPG2 extends KPG {\n+        public KPG2() {\n+            super(\"SHA-512\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/NamedKeyFactoryTest.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"}]}