{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -742,1 +742,1 @@\n-    public synchronized void publish(LogRecord record) {\n+    public void publish(LogRecord record) {\n@@ -746,0 +746,3 @@\n+        \/\/ JDK-8349206: Do NOT synchronize around the parent's publish() method.\n+        \/\/ StreamHandler will lock the instance, as needed, to protect writes to\n+        \/\/ the metered stream.\n@@ -747,3 +750,8 @@\n-        flush();\n-        if (limit > 0 && (meter.written >= limit || meter.written < 0)) {\n-            rotate();\n+        \/\/ We must lock around the check of meter.xxx fields and the call to\n+        \/\/ rotate(), and since flush() is also synchronized on the same instance\n+        \/\/ we might as well lock around everything.\n+        synchronized(this) {\n+            flush();\n+            if (limit > 0 && (meter.written >= limit || meter.written < 0)) {\n+                rotate();\n+            }\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/FileHandler.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,0 +126,3 @@\n+     * <p>\n+     * Implementations of this method should avoid holding any locks around the\n+     * formatting of {@code LogRecord}.\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/Handler.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,1 +175,1 @@\n-    public synchronized void publish(LogRecord record) {\n+    public void publish(LogRecord record) {\n@@ -179,0 +179,1 @@\n+        \/\/ JDK-8349206: Do NOT synchronize around the parent's publish() method.\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/SocketHandler.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,2 +187,2 @@\n-    public synchronized void publish(LogRecord record) {\n-       if (!isLoggable(record)) {\n+    public void publish(LogRecord record) {\n+        if (!isLoggable(record)) {\n@@ -191,0 +191,4 @@\n+        \/\/ JDK-8349206: To avoid deadlock risk, it is essential that the handler\n+        \/\/ is not locked while formatting the log record. Methods such as\n+        \/\/ reportError() and isLoggable() are defined to be thread safe, so we\n+        \/\/ can restrict locking to just writing the message.\n@@ -202,4 +206,7 @@\n-            Writer writer = this.writer;\n-            if (!doneHeader) {\n-                writer.write(getFormatter().getHead(this));\n-                doneHeader = true;\n+            synchronized(this) {\n+                Writer writer = this.writer;\n+                if (!doneHeader) {\n+                    writer.write(getFormatter().getHead(this));\n+                    doneHeader = true;\n+                }\n+                writer.write(msg);\n@@ -207,1 +214,0 @@\n-            writer.write(msg);\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/StreamHandler.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,203 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8349206\n+ * @summary j.u.l.Handler classes create deadlock risk via synchronized publish() method.\n+ * @modules java.base\/sun.util.logging\n+ *          java.logging\n+ * @compile -XDignore.symbol.file LoggingDeadlock5.java\n+ * @run main\/othervm LoggingDeadlock5\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.concurrent.Semaphore;\n+import java.util.logging.FileHandler;\n+import java.util.logging.Formatter;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+import java.util.logging.StreamHandler;\n+\n+\/**\n+ * This test verifies that logging Handler implementations no longer suffer\n+ * from the deadlock risk outlined in JDK-8349206.\n+ *\n+ * <p>This test should reliably cause, and detect, deadlocks in a timely\n+ * manner if the problem occurs, and SHOULD NOT time out.\n+ *\/\n+public class LoggingDeadlock5 {\n+    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n+\n+    \/\/ Formatter which calls toString() on all arguments.\n+    private static final Formatter TEST_FORMATTER = new Formatter() {\n+        @Override\n+        public String format(LogRecord record) {\n+            \/\/ All we care about is that our formatter will invoke toString() on user arguments.\n+            for (Object p : record.getParameters()) {\n+                var unused = p.toString();\n+            }\n+            return \"<formatted string>\";\n+        }\n+    };\n+\n+    \/\/ A handler which *should* cause a deadlock by synchronizing publish().\n+    private static final Handler SELF_TEST_HANDLER = new Handler() {\n+        @Override\n+        public synchronized void publish(LogRecord record) {\n+            TEST_FORMATTER.formatMessage(record);\n+        }\n+\n+        @Override\n+        public void flush() {\n+        }\n+\n+        @Override\n+        public void close() {\n+        }\n+    };\n+\n+    public static void main(String[] args) throws InterruptedException, IOException {\n+        \/\/ Self test that deadlocks are correctly caught (and don't deadlock the test itself).\n+        new DeadLocker(SELF_TEST_HANDLER).checkDeadlock(true);\n+\n+        \/\/ In theory, we should test SocketHandler here as well because, while\n+        \/\/ it is just a subclass, it could be adding locking around the call to\n+        \/\/ super.publish(). However, it is problematic in a test environment\n+        \/\/ since it needs to open sockets. It is not being tested for now.\n+        assertNoDeadlock(new StreamHandler(new ByteArrayOutputStream(0), TEST_FORMATTER));\n+\n+        \/\/ Single log file in current directory, no rotation. JTreg will delete\n+        \/\/ temporary files after test completion.\n+        assertNoDeadlock(new FileHandler(\"temp_log_file\"));\n+\n+        \/\/ Any other problematic handler classes can be easily added here if\n+        \/\/ they are simple enough to be constructed in a test environment.\n+    }\n+\n+    static void assertNoDeadlock(Handler handler) throws InterruptedException, UnsupportedEncodingException {\n+        try {\n+            handler.setEncoding(UTF_8);\n+            new DeadLocker(handler).checkDeadlock(false);\n+        } finally {\n+            \/\/ Handlers may have open resources, so must be closed.\n+            handler.close();\n+        }\n+    }\n+\n+    private static class DeadLocker {\n+        private final static Duration JOIN_WAIT = Duration.ofMillis(500);\n+\n+        private final Semaphore readyToDeadlock = new Semaphore(0);\n+        private final Semaphore userLockIsHeld = new Semaphore(0);\n+        private final Logger logger = Logger.getAnonymousLogger();\n+        private final Handler handlerUnderTest;\n+        private final Object userLock = new Object();\n+        private boolean deadlockEncountered = true;\n+\n+        DeadLocker(Handler handlerUnderTest) {\n+            this.handlerUnderTest = handlerUnderTest;\n+\n+            this.logger.setUseParentHandlers(false);\n+            this.logger.addHandler(handlerUnderTest);\n+            this.logger.setLevel(Level.INFO);\n+            this.handlerUnderTest.setLevel(Level.INFO);\n+        }\n+\n+        void checkDeadlock(boolean expectDeadlock) throws InterruptedException {\n+            \/\/ Note: Even though the message format string isn't used in the\n+            \/\/ test formatter, it must be a valid log format string (Logger\n+            \/\/ detects if there are no \"{n}\" placeholders and skips calling\n+            \/\/ the formatter otherwise).\n+            Thread t1 = runAsDaemon(() -> logger.log(Level.INFO, \"Hello {0}\", new Argument()));\n+            readyToDeadlock.acquireUninterruptibly();\n+            \/\/ First thread is blocked until userLockIsHeld is released in t2.\n+            Thread t2 = runAsDaemon(this::locksThenLogs);\n+\n+            \/\/ If deadlock occurs, the join() calls both return false.\n+            int threadsBlocked = 0;\n+            if (!t1.join(JOIN_WAIT)) {\n+                threadsBlocked += 1;\n+            }\n+            if (!t2.join(JOIN_WAIT)) {\n+                threadsBlocked += 1;\n+            }\n+            \/\/ These indicate test problems, not a failure of the code under test.\n+            errorIf(threadsBlocked == 1, \"Inconsistent number of blocked threads.\");\n+            errorIf(deadlockEncountered != (threadsBlocked == 2),\n+                    \"Deadlock reporting should coincide with number of blocked threads.\");\n+\n+            \/\/ This is the actual test assertion.\n+            if (expectDeadlock != deadlockEncountered) {\n+                String issue = expectDeadlock ? \"Expected deadlock but none occurred\" : \"Unexpected deadlock\";\n+                throw new AssertionError(errorMsg(issue));\n+            }\n+        }\n+\n+        void locksThenLogs() {\n+            synchronized (userLock) {\n+                userLockIsHeld.release();\n+                logger.log(Level.INFO, \"This will cause a deadlock if the Handler locks!\");\n+            }\n+        }\n+\n+        void calledFromToString() {\n+            this.readyToDeadlock.release();\n+            this.userLockIsHeld.acquireUninterruptibly();\n+            synchronized (userLock) {\n+                this.deadlockEncountered = false;\n+            }\n+        }\n+\n+        class Argument {\n+            @Override\n+            public String toString() {\n+                calledFromToString();\n+                return \"<to string>\";\n+            }\n+        }\n+\n+        String errorMsg(String msg) {\n+            return String.format(\"Handler deadlock test [%s]: %s\", handlerUnderTest.getClass().getName(), msg);\n+        }\n+\n+        void errorIf(boolean condition, String msg) {\n+            if (condition) {\n+                throw new RuntimeException(errorMsg(\"TEST ERROR - \" + msg));\n+            }\n+        }\n+    }\n+\n+    static Thread runAsDaemon(Runnable job) {\n+        Thread thread = new Thread(job);\n+        thread.setDaemon(true);\n+        thread.start();\n+        return thread;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/logging\/LoggingDeadlock5.java","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"}]}