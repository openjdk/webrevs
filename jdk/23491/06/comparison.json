{"files":[{"patch":"@@ -95,0 +95,1 @@\n+        \/\/ JDK-8349206: Do NOT synchronize around the parent's publish() method.\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/ConsoleHandler.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -742,4 +742,1 @@\n-    public synchronized void publish(LogRecord record) {\n-        if (!isLoggable(record)) {\n-            return;\n-        }\n+    public void publish(LogRecord record) {\n@@ -747,0 +744,4 @@\n+    }\n+\n+    @Override\n+    void synchronousPostWriteHook() {\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/FileHandler.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,4 @@\n+ * @implNote Implementations of {@code Handler} should be thread-safe. Handlers\n+ * are expected to be invoked concurrently from arbitrary threads. However,\n+ * over-use of synchronization may result in unwanted thread contention,\n+ * performance issues or even deadlocking.\n@@ -126,0 +130,4 @@\n+     * <p>\n+     * @implNote To avoid the risk of deadlock, implementations of this method\n+     * should avoid holding any locks while calling out to application code,\n+     * such as the formatting of {@code LogRecord}.\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/Handler.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,4 +175,2 @@\n-    public synchronized void publish(LogRecord record) {\n-        if (!isLoggable(record)) {\n-            return;\n-        }\n+    public void publish(LogRecord record) {\n+        \/\/ JDK-8349206: Do NOT synchronize around the parent's publish() method.\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/SocketHandler.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,0 +183,7 @@\n+     * @implSpec this method avoids acquiring locks during {@code LogRecord}\n+     * formatting, but {@code this} instance is synchronized when writing to the\n+     * output stream. To avoid deadlock risk, subclasses must not hold locks\n+     * while calling {@code super.publish()}. Specifically, subclasses must\n+     * not define the overridden {@code publish()} method to be\n+     * {@code synchronized}.\n+     *\n@@ -187,2 +194,2 @@\n-    public synchronized void publish(LogRecord record) {\n-       if (!isLoggable(record)) {\n+    public void publish(LogRecord record) {\n+        if (!isLoggable(record)) {\n@@ -191,0 +198,7 @@\n+        \/\/ Read once for consistency (whether in or outside the locked region\n+        \/\/ is not important).\n+        Formatter formatter = getFormatter();\n+        \/\/ JDK-8349206: To avoid deadlock risk, it is essential that the handler\n+        \/\/ is not locked while formatting the log record. Methods such as\n+        \/\/ reportError() and isLoggable() are defined to be thread safe, so we\n+        \/\/ can restrict locking to just writing the message.\n@@ -193,1 +207,1 @@\n-            msg = getFormatter().format(record);\n+            msg = formatter.format(record);\n@@ -202,4 +216,8 @@\n-            Writer writer = this.writer;\n-            if (!doneHeader) {\n-                writer.write(getFormatter().getHead(this));\n-                doneHeader = true;\n+            synchronized(this) {\n+                Writer writer = this.writer;\n+                if (!doneHeader) {\n+                    writer.write(formatter.getHead(this));\n+                    doneHeader = true;\n+                }\n+                writer.write(msg);\n+                synchronousPostWriteHook();\n@@ -207,1 +225,0 @@\n-            writer.write(msg);\n@@ -215,0 +232,9 @@\n+    \/**\n+     * Overridden by other handlers in this package to facilitate synchronous\n+     * post-write behaviour. If other handlers need similar functionality, it\n+     * might be feasible to make this method protected (see JDK-8349206), but\n+     * please find a better name if you do ;).\n+     *\/\n+    void synchronousPostWriteHook() {\n+        \/\/ Empty by default.\n+    }\n@@ -252,0 +278,1 @@\n+    \/\/ Called synchronously.\n@@ -255,0 +282,1 @@\n+            Formatter formatter = getFormatter();\n@@ -257,1 +285,1 @@\n-                    writer.write(getFormatter().getHead(this));\n+                    writer.write(formatter.getHead(this));\n@@ -260,1 +288,1 @@\n-                writer.write(getFormatter().getTail(this));\n+                writer.write(formatter.getTail(this));\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/StreamHandler.java","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8349206\n+ * @summary j.u.l.Handler classes create deadlock risk via synchronized publish() method.\n+ * @modules java.base\/sun.util.logging\n+ *          java.logging\n+ * @build java.logging\/java.util.logging.TestStreamHandler\n+ * @run main\/othervm StreamHandlerLockingTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.logging.Formatter;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.TestStreamHandler;\n+\n+public class StreamHandlerLockingTest {\n+    static class TestFormatter extends Formatter {\n+        final Handler handler;\n+\n+        TestFormatter(Handler handler) {\n+            this.handler = handler;\n+        }\n+\n+        @Override\n+        public String format(LogRecord record) {\n+            if (Thread.holdsLock(handler)) {\n+                throw new AssertionError(\"format() was called with handler locked (bad).\");\n+            }\n+            return record.getMessage() + \"\\n\";\n+        }\n+\n+        @Override\n+        public String getHead(Handler h) {\n+            \/\/ This is currently true, and not easy to make unsynchronized.\n+            if (!Thread.holdsLock(handler)) {\n+                throw new AssertionError(\"getHead() expected to be called with handler locked.\");\n+            }\n+            return \"--HEAD--\\n\";\n+        }\n+\n+        @Override\n+        public String getTail(Handler h) {\n+            \/\/ This is currently true, and not easy to make unsynchronized.\n+            if (!Thread.holdsLock(handler)) {\n+                throw new AssertionError(\"getTail() expected to be called with handler locked.\");\n+            }\n+            return \"--TAIL--\\n\";\n+        }\n+    }\n+\n+    private static final String EXPECTED_LOG =\n+            String.join(\"\\n\",\"--HEAD--\", \"Hello World\", \"Some more logging...\", \"And we're done!\", \"--TAIL--\", \"\");\n+\n+    public static void main(String[] args) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        TestStreamHandler handler = new TestStreamHandler(out);\n+        TestFormatter formatter = new TestFormatter(handler);\n+        handler.setFormatter(formatter);\n+\n+        handler.publish(log(\"Hello World\"));\n+        handler.publish(log(\"Some more logging...\"));\n+        handler.publish(log(\"And we're done!\"));\n+        handler.close();\n+\n+        \/\/ Post write callback should have happened once per publish call (with lock held).\n+        if (handler.callbackCount != 3) {\n+            throw new AssertionError(\"Unexpected callback count: \" + handler.callbackCount);\n+        }\n+\n+        String logged = out.toString(\"UTF-8\");\n+        if (!EXPECTED_LOG.equals(logged)) {\n+            throw new AssertionError(\"Unexpected log contents: \" + logged);\n+        }\n+    }\n+\n+    static LogRecord log(String msg) {\n+        return new LogRecord(Level.INFO, msg);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/logging\/Handler\/StreamHandlerLockingTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util.logging;\n+\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+\/**\n+ * A trivial UTF-8 stream handler subclass class to capture whether the\n+ * (package protected) post-write callback method is synchronized.\n+ *\/\n+public class TestStreamHandler extends StreamHandler {\n+\n+    public int callbackCount = 0;\n+\n+    public TestStreamHandler(OutputStream out) {\n+        setOutputStream(out);\n+        try {\n+            setEncoding(\"UTF-8\");\n+        } catch (UnsupportedEncodingException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    void synchronousPostWriteHook() {\n+        if (!Thread.holdsLock(this)) {\n+            throw new AssertionError(\n+                    String.format(\"Post write callback [index=%d] was invoked without handler locked.\", callbackCount));\n+        }\n+        callbackCount++;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/logging\/Handler\/java.logging\/java\/util\/logging\/TestStreamHandler.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8349206\n+ * @summary j.u.l.Handler classes create deadlock risk via synchronized publish() method.\n+ * @modules java.base\/sun.util.logging\n+ *          java.logging\n+ * @run main\/othervm LoggingDeadlock5\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.util.concurrent.Semaphore;\n+import java.util.logging.FileHandler;\n+import java.util.logging.Formatter;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.Logger;\n+import java.util.logging.StreamHandler;\n+\n+\/**\n+ * This test verifies that logging Handler implementations no longer suffer\n+ * from the deadlock risk outlined in JDK-8349206.\n+ *\n+ * <p>This test should reliably cause, and detect, deadlocks in a timely\n+ * manner if the problem occurs, and SHOULD NOT time out.\n+ *\/\n+public class LoggingDeadlock5 {\n+    private static final String UTF_8 = StandardCharsets.UTF_8.name();\n+\n+    \/\/ Formatter which calls toString() on all arguments.\n+    private static final Formatter TEST_FORMATTER = new Formatter() {\n+        @Override\n+        public String format(LogRecord record) {\n+            \/\/ All we care about is that our formatter will invoke toString() on user arguments.\n+            for (Object p : record.getParameters()) {\n+                var unused = p.toString();\n+            }\n+            return \"<formatted string>\";\n+        }\n+    };\n+\n+    \/\/ A handler which *should* cause a deadlock by synchronizing publish().\n+    private static final Handler SELF_TEST_HANDLER = new Handler() {\n+        @Override\n+        public synchronized void publish(LogRecord record) {\n+            TEST_FORMATTER.formatMessage(record);\n+        }\n+\n+        @Override\n+        public void flush() {\n+        }\n+\n+        @Override\n+        public void close() {\n+        }\n+    };\n+\n+    public static void main(String[] args) throws InterruptedException, IOException {\n+        \/\/ Self test that deadlocks are correctly caught (and don't deadlock the test itself).\n+        new DeadLocker(SELF_TEST_HANDLER).checkDeadlock(true);\n+\n+        \/\/ In theory, we should test SocketHandler here as well because, while\n+        \/\/ it is just a subclass, it could be adding locking around the call to\n+        \/\/ super.publish(). However, it is problematic in a test environment\n+        \/\/ since it needs to open sockets. It is not being tested for now.\n+        assertNoDeadlock(new StreamHandler(new ByteArrayOutputStream(0), TEST_FORMATTER));\n+\n+        \/\/ Single log file in current directory, no rotation. JTreg will delete\n+        \/\/ temporary files after test completion.\n+        assertNoDeadlock(new FileHandler(\"temp_log_file\"));\n+\n+        \/\/ Any other problematic handler classes can be easily added here if\n+        \/\/ they are simple enough to be constructed in a test environment.\n+    }\n+\n+    static void assertNoDeadlock(Handler handler) throws InterruptedException, UnsupportedEncodingException {\n+        try {\n+            handler.setEncoding(UTF_8);\n+            new DeadLocker(handler).checkDeadlock(false);\n+        } finally {\n+            \/\/ Handlers may have open resources, so must be closed.\n+            handler.close();\n+        }\n+    }\n+\n+    private static class DeadLocker {\n+        private final static Duration JOIN_WAIT = Duration.ofMillis(500);\n+\n+        private final Semaphore readyToDeadlock = new Semaphore(0);\n+        private final Semaphore userLockIsHeld = new Semaphore(0);\n+        private final Logger logger = Logger.getAnonymousLogger();\n+        private final Handler handlerUnderTest;\n+        private final Object userLock = new Object();\n+        private boolean deadlockEncountered = true;\n+\n+        DeadLocker(Handler handlerUnderTest) {\n+            this.handlerUnderTest = handlerUnderTest;\n+\n+            this.logger.setUseParentHandlers(false);\n+            this.logger.addHandler(handlerUnderTest);\n+            this.logger.setLevel(Level.INFO);\n+            this.handlerUnderTest.setLevel(Level.INFO);\n+        }\n+\n+        void checkDeadlock(boolean expectDeadlock) throws InterruptedException {\n+            \/\/ Note: Even though the message format string isn't used in the\n+            \/\/ test formatter, it must be a valid log format string (Logger\n+            \/\/ detects if there are no \"{n}\" placeholders and skips calling\n+            \/\/ the formatter otherwise).\n+            Thread t1 = runAsDaemon(() -> logger.log(Level.INFO, \"Hello {0}\", new Argument()));\n+            readyToDeadlock.acquireUninterruptibly();\n+            \/\/ First thread is blocked until userLockIsHeld is released in t2.\n+            Thread t2 = runAsDaemon(this::locksThenLogs);\n+\n+            \/\/ If deadlock occurs, the join() calls both return false.\n+            int threadsBlocked = 0;\n+            if (!t1.join(JOIN_WAIT)) {\n+                threadsBlocked += 1;\n+            }\n+            if (!t2.join(JOIN_WAIT)) {\n+                threadsBlocked += 1;\n+            }\n+            \/\/ These indicate test problems, not a failure of the code under test.\n+            errorIf(threadsBlocked == 1, \"Inconsistent number of blocked threads.\");\n+            errorIf(deadlockEncountered != (threadsBlocked == 2),\n+                    \"Deadlock reporting should coincide with number of blocked threads.\");\n+\n+            \/\/ This is the actual test assertion.\n+            if (expectDeadlock != deadlockEncountered) {\n+                String issue = expectDeadlock ? \"Expected deadlock but none occurred\" : \"Unexpected deadlock\";\n+                throw new AssertionError(errorMsg(issue));\n+            }\n+        }\n+\n+        void locksThenLogs() {\n+            synchronized (userLock) {\n+                userLockIsHeld.release();\n+                logger.log(Level.INFO, \"This will cause a deadlock if the Handler locks!\");\n+            }\n+        }\n+\n+        void calledFromToString() {\n+            this.readyToDeadlock.release();\n+            this.userLockIsHeld.acquireUninterruptibly();\n+            synchronized (userLock) {\n+                this.deadlockEncountered = false;\n+            }\n+        }\n+\n+        class Argument {\n+            @Override\n+            public String toString() {\n+                calledFromToString();\n+                return \"<to string>\";\n+            }\n+        }\n+\n+        String errorMsg(String msg) {\n+            return String.format(\"Handler deadlock test [%s]: %s\", handlerUnderTest.getClass().getName(), msg);\n+        }\n+\n+        void errorIf(boolean condition, String msg) {\n+            if (condition) {\n+                throw new RuntimeException(errorMsg(\"TEST ERROR - \" + msg));\n+            }\n+        }\n+    }\n+\n+    static Thread runAsDaemon(Runnable job) {\n+        Thread thread = new Thread(job);\n+        thread.setDaemon(true);\n+        thread.start();\n+        return thread;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/logging\/LoggingDeadlock5.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"}]}