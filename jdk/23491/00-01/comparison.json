{"files":[{"patch":"@@ -169,0 +169,3 @@\n+     *\n+     * The only calls to this class come from StreamHandler, which locks its\n+     * handler instance around any calls it makes.\n@@ -170,1 +173,1 @@\n-    private static final class MeteredStream extends OutputStream {\n+    private final class MeteredStream extends OutputStream {\n@@ -173,0 +176,7 @@\n+        \/\/ We need to know when the current file is about to be rotated to avoid\n+        \/\/ recursive calls to write() when the tail() is written.\n+        \/\/\n+        \/\/ Each metered stream is monotonic and gets replaced rather than reset,\n+        \/\/ so this flag only goes from false->true on each instance and indicates\n+        \/\/ when we're flushing, closing and no longer using this instance.\n+        boolean isRotating = false;\n@@ -183,0 +193,1 @@\n+            flushOrRotateIfFull();\n@@ -189,0 +200,1 @@\n+            flushOrRotateIfFull();\n@@ -191,0 +203,5 @@\n+        \/\/ This is the only write() method we actually expect to be called from\n+        \/\/ StreamHandler's OutputStreamWriter (since it only calls write(String)\n+        \/\/ on its stream). Apart from writing the head\/tail entries to log files,\n+        \/\/ there should be a 1-to-1 match between emitted log entries and calls\n+        \/\/ to this method, so flushing for each write is not unreasonable.\n@@ -195,0 +212,1 @@\n+            flushOrRotateIfFull();\n@@ -206,0 +224,14 @@\n+\n+        \/**\n+         * Always called with the owning handler instance locked.\n+         *\/\n+        private void flushOrRotateIfFull() throws IOException {\n+            boolean shouldRotate = meter.written >= limit || meter.written < 0;\n+            if (!isRotating && shouldRotate) {\n+                isRotating = true;\n+                \/\/ Calling rotate() will always flush() before closing the stream.\n+                rotate();\n+            } else {\n+                flush();\n+            }\n+        }\n@@ -743,6 +775,1 @@\n-        if (!isLoggable(record)) {\n-            return;\n-        }\n-        \/\/ JDK-8349206: Do NOT synchronize around the parent's publish() method.\n-        \/\/ StreamHandler will lock the instance, as needed, to protect writes to\n-        \/\/ the metered stream.\n+        \/\/ Stub method kept to preserve historical API shape.\n@@ -750,9 +777,0 @@\n-        \/\/ We must lock around the check of meter.xxx fields and the call to\n-        \/\/ rotate(), and since flush() is also synchronized on the same instance\n-        \/\/ we might as well lock around everything.\n-        synchronized(this) {\n-            flush();\n-            if (limit > 0 && (meter.written >= limit || meter.written < 0)) {\n-                rotate();\n-            }\n-        }\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/FileHandler.java","additions":34,"deletions":16,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/timeout=10 LoggingDeadlock5\n+ * @run main\/othervm LoggingDeadlock5\n","filename":"test\/jdk\/java\/util\/logging\/LoggingDeadlock5.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}