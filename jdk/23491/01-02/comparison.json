{"files":[{"patch":"@@ -169,3 +169,0 @@\n-     *\n-     * The only calls to this class come from StreamHandler, which locks its\n-     * handler instance around any calls it makes.\n@@ -173,1 +170,1 @@\n-    private final class MeteredStream extends OutputStream {\n+    private static final class MeteredStream extends OutputStream {\n@@ -176,7 +173,0 @@\n-        \/\/ We need to know when the current file is about to be rotated to avoid\n-        \/\/ recursive calls to write() when the tail() is written.\n-        \/\/\n-        \/\/ Each metered stream is monotonic and gets replaced rather than reset,\n-        \/\/ so this flag only goes from false->true on each instance and indicates\n-        \/\/ when we're flushing, closing and no longer using this instance.\n-        boolean isRotating = false;\n@@ -193,1 +183,0 @@\n-            flushOrRotateIfFull();\n@@ -200,1 +189,0 @@\n-            flushOrRotateIfFull();\n@@ -203,5 +191,0 @@\n-        \/\/ This is the only write() method we actually expect to be called from\n-        \/\/ StreamHandler's OutputStreamWriter (since it only calls write(String)\n-        \/\/ on its stream). Apart from writing the head\/tail entries to log files,\n-        \/\/ there should be a 1-to-1 match between emitted log entries and calls\n-        \/\/ to this method, so flushing for each write is not unreasonable.\n@@ -212,1 +195,0 @@\n-            flushOrRotateIfFull();\n@@ -224,14 +206,0 @@\n-\n-        \/**\n-         * Always called with the owning handler instance locked.\n-         *\/\n-        private void flushOrRotateIfFull() throws IOException {\n-            boolean shouldRotate = meter.written >= limit || meter.written < 0;\n-            if (!isRotating && shouldRotate) {\n-                isRotating = true;\n-                \/\/ Calling rotate() will always flush() before closing the stream.\n-                rotate();\n-            } else {\n-                flush();\n-            }\n-        }\n@@ -775,1 +743,6 @@\n-        \/\/ Stub method kept to preserve historical API shape.\n+        if (!isLoggable(record)) {\n+            return;\n+        }\n+        \/\/ JDK-8349206: Do NOT synchronize around the parent's publish() method.\n+        \/\/ StreamHandler will lock the instance, as needed, to protect writes to\n+        \/\/ the metered stream.\n@@ -777,0 +750,9 @@\n+        \/\/ We must lock around the check of meter.xxx fields and the call to\n+        \/\/ rotate(), and since flush() is also synchronized on the same instance\n+        \/\/ we might as well lock around everything.\n+        synchronized(this) {\n+            flush();\n+            if (limit > 0 && (meter.written >= limit || meter.written < 0)) {\n+                rotate();\n+            }\n+        }\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/FileHandler.java","additions":16,"deletions":34,"binary":false,"changes":50,"status":"modified"}]}