{"files":[{"patch":"@@ -70,6 +70,0 @@\n-     * <p>\n-     * @implNote Note that this method is often called with an associated\n-     * {@link Handler} instance locked so, to avoid deadlock risk, it is\n-     * important to avoid making callbacks to unknown user-provided arguments\n-     * (e.g. log record parameters captured from previous calls to\n-     * {@link #format(LogRecord)}.\n@@ -89,6 +83,0 @@\n-     * <p>\n-     * @implNote Note that this method is often called with an associated\n-     * {@link Handler} instance locked so, to avoid deadlock risk, it is\n-     * important to avoid making callbacks to unknown user-provided arguments\n-     * (e.g. log record parameters captured from previous calls to\n-     * {@link #format(LogRecord)}.\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/Formatter.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -46,35 +46,4 @@\n- * @implNote When implementing new {@code Handler} subclasses, it is important\n- * to understand the potential effects of synchronization.\n- * <p>\n- * Logging can occur concurrently in many threads, so a general principle\n- * is to synchronize as little as necessary to minimize thread contention.\n- * <p>\n- * As such, the following pattern is often used in the core {@code Handler}\n- * classes:\n- * <ul>\n- *     <li>Mutable state is held in {@code volatile} fields.\n- *     <li>These fields are read from unsynchronized getter methods.\n- *     <li>These fields are modified via synchronized setter methods.\n- * <\/ul>\n- * For example, this prevents thread contention around calls to\n- * {@link #isLoggable(LogRecord)} while allowing code synchronized on the\n- * {@code Handler} instance to set a new log level.\n- * <p>\n- * Another principle is to avoid synchronizing {@code Handler} instances\n- * (or holding any other locks) while processing user-provided arguments,\n- * such as {@link LogRecord} parameters.\n- * <p>\n- * This applies most directly to the {@link #publish(LogRecord)} method, where\n- * user arguments are processed. Holding a lock when calling {@code toString()}\n- * on log arguments creates an inevitable deadlock risk.\n- * <p>\n- * A consequence of this is that the {@link #publish(LogRecord)} method of\n- * {@code Handler} subclasses should typically never be synchronized. However,\n- * {@code Handler} subclasses can synchronize within their\n- * {@link #publish(LogRecord)} implementation to protect internal state.\n- * <p>\n- * If you have requirements for a {@code Handler} which do not match the\n- * synchronization behaviour in classes such as {@link StreamHandler},\n- * {@link FileHandler} or {@link Formatter} then, in order to have complete\n- * control of synchronization, it is recommended to subclass {@code Handler}\n- * directly.\n+ * @implNote Implementations of {@code Handler} should be thread-safe. Handlers\n+ * are expected to be invoked concurrently from arbitrary threads. However,\n+ * over-use of synchronization may result in unwanted thread contention,\n+ * performance issues or even deadlocking.\n@@ -162,2 +131,3 @@\n-     * @implNote Implementations of this method should avoid holding any locks\n-     * around the formatting of {@code LogRecord}.\n+     * @implNote To avoid the risk of deadlock, implementations of this method\n+     * should avoid holding any locks while calling out to application code,\n+     * such as the formatting of {@code LogRecord}.\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/Handler.java","additions":7,"deletions":37,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -183,0 +183,7 @@\n+     * @implSpec this method avoids acquiring locks during {@code LogRecord}\n+     * formatting, but {@code this} instance is synchronized when writing to the\n+     * output stream. To avoid deadlock risk, subclasses must not hold locks\n+     * while calling {@code super.publish()}. Specifically, subclasses must\n+     * not define the overridden {@code publish()} method to be\n+     * {@code synchronized}.\n+     *\n@@ -191,0 +198,3 @@\n+        \/\/ Read once for consistency (whether in or outside the locked region\n+        \/\/ is not important).\n+        Formatter formatter = getFormatter();\n@@ -197,1 +207,1 @@\n-            msg = getFormatter().format(record);\n+            msg = formatter.format(record);\n@@ -209,1 +219,1 @@\n-                    writer.write(getFormatter().getHead(this));\n+                    writer.write(formatter.getHead(this));\n@@ -272,0 +282,1 @@\n+            Formatter formatter = getFormatter();\n@@ -274,1 +285,1 @@\n-                    writer.write(getFormatter().getHead(this));\n+                    writer.write(formatter.getHead(this));\n@@ -277,1 +288,1 @@\n-                writer.write(getFormatter().getTail(this));\n+                writer.write(formatter.getTail(this));\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/StreamHandler.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"}]}