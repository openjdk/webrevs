{"files":[{"patch":"@@ -95,0 +95,1 @@\n+        \/\/ JDK-8349206: Do NOT synchronize around the parent's publish() method.\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/ConsoleHandler.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -743,6 +743,0 @@\n-        if (!isLoggable(record)) {\n-            return;\n-        }\n-        \/\/ JDK-8349206: Do NOT synchronize around the parent's publish() method.\n-        \/\/ StreamHandler will lock the instance, as needed, to protect writes to\n-        \/\/ the metered stream.\n@@ -750,8 +744,7 @@\n-        \/\/ We must lock around the check of meter.xxx fields and the call to\n-        \/\/ rotate(), and since flush() is also synchronized on the same instance\n-        \/\/ we might as well lock around everything.\n-        synchronized(this) {\n-            flush();\n-            if (limit > 0 && (meter.written >= limit || meter.written < 0)) {\n-                rotate();\n-            }\n+    }\n+\n+    @Override\n+    void synchronousPostWriteHook() {\n+        flush();\n+        if (limit > 0 && (meter.written >= limit || meter.written < 0)) {\n+            rotate();\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/FileHandler.java","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -70,0 +70,5 @@\n+     * <p>\n+     * Note that this method is often called with an associated {@link Handler}\n+     * instance locked so, to avoid deadlock risk, it is important to avoid\n+     * making callbacks to unknown user-provided arguments (e.g. log record\n+     * parameters captured from previous calls to {@link #format(LogRecord)}.\n@@ -83,0 +88,5 @@\n+     * <p>\n+     * Note that this method is often called with an associated {@link Handler}\n+     * instance locked so, to avoid deadlock risk, it is important to avoid\n+     * making callbacks to unknown user-provided arguments (e.g. log record\n+     * parameters captured from previous calls to {@link #format(LogRecord)}.\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/Formatter.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,0 +46,37 @@\n+ * <h2>Subclass Implementation Notes<\/h2>\n+ *\n+ * When implementing new {@code Handler} subclasses, it is important to\n+ * understand the potential effects of synchronization.\n+ * <p>\n+ * Logging can occur concurrently in many threads, so a general principle\n+ * is to synchronize as little as necessary to minimize thread contention.\n+ * <p>\n+ * As such, the following pattern is often used in the core {@code Handler}\n+ * classes:\n+ * <ul>\n+ *     <li>Mutable state is held in {@code volatile} fields.\n+ *     <li>These fields are read from unsynchronized getter methods.\n+ *     <li>These fields are modified via synchronized setter methods.\n+ * <\/ul>\n+ * For example, this prevents thread contention around calls to\n+ * {@link #isLoggable(LogRecord)} while allowing code synchronized on the\n+ * {@code Handler} instance to set a new log level.\n+ * <p>\n+ * Another principle is to avoid synchronizing {@code Handler} instances (or\n+ * holding any other locks) while processing user-provided arguments, such as\n+ * {@link LogRecord} parameters.\n+ * <p>\n+ * This applies most directly to the {@link #publish(LogRecord)} method, where\n+ * user arguments are processed. Holding a lock when calling {@code toString()}\n+ * on log arguments creates an inevitable deadlock risk.\n+ * <p>\n+ * A consequence of this is that the {@link #publish(LogRecord)} method of\n+ * {@code Handler} subclasses should typically never be synchronized. However,\n+ * {@code Handler} subclasses can synchronize within their\n+ * {@link #publish(LogRecord)} implementation to protect internal state.\n+ * <p>\n+ * If you have requirements for a {@code Handler} which do not match the\n+ * synchronization behaviour in classes such as {@link StreamHandler},\n+ * {@link FileHandler} or {@link Formatter} then, in order to have complete\n+ * control of synchronization, it is recommended to subclass {@code Handler}\n+ * directly.\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/Handler.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -176,3 +176,0 @@\n-        if (!isLoggable(record)) {\n-            return;\n-        }\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/SocketHandler.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -213,0 +213,1 @@\n+                synchronousPostWriteHook();\n@@ -221,0 +222,9 @@\n+    \/**\n+     * Overridden by other handlers in this package to facilitate synchronous\n+     * post-write behaviour. If other handlers need similar functionality, it\n+     * might be feasible to make this method protected (see JDK-8349206), but\n+     * please find a better name if you do ;).\n+     *\/\n+    void synchronousPostWriteHook() {\n+        \/\/ Empty by default.\n+    }\n@@ -258,0 +268,1 @@\n+    \/\/ Called synchronously.\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/StreamHandler.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8349206\n+ * @summary j.u.l.Handler classes create deadlock risk via synchronized publish() method.\n+ * @modules java.base\/sun.util.logging\n+ *          java.logging\n+ * @build java.logging\/java.util.logging.TestStreamHandler\n+ * @run main\/othervm StreamHandlerLockingTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.logging.Formatter;\n+import java.util.logging.Handler;\n+import java.util.logging.Level;\n+import java.util.logging.LogRecord;\n+import java.util.logging.TestStreamHandler;\n+\n+public class StreamHandlerLockingTest {\n+    static class TestFormatter extends Formatter {\n+        final Handler handler;\n+\n+        TestFormatter(Handler handler) {\n+            this.handler = handler;\n+        }\n+\n+        @Override\n+        public String format(LogRecord record) {\n+            if (Thread.holdsLock(handler)) {\n+                throw new AssertionError(\"format() was called with handler locked (bad).\");\n+            }\n+            return record.getMessage() + \"\\n\";\n+        }\n+\n+        @Override\n+        public String getHead(Handler h) {\n+            \/\/ This is currently true, and not easy to make unsynchronized.\n+            if (!Thread.holdsLock(handler)) {\n+                throw new AssertionError(\"getHead() expected to be called with handler locked.\");\n+            }\n+            return \"--HEAD--\\n\";\n+        }\n+\n+        @Override\n+        public String getTail(Handler h) {\n+            \/\/ This is currently true, and not easy to make unsynchronized.\n+            if (!Thread.holdsLock(handler)) {\n+                throw new AssertionError(\"getTail() expected to be called with handler locked.\");\n+            }\n+            return \"--TAIL--\\n\";\n+        }\n+    }\n+\n+    private static final String EXPECTED_LOG =\n+            String.join(\"\\n\",\"--HEAD--\", \"Hello World\", \"Some more logging...\", \"And we're done!\", \"--TAIL--\", \"\");\n+\n+    public static void main(String[] args) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        TestStreamHandler handler = new TestStreamHandler(out);\n+        TestFormatter formatter = new TestFormatter(handler);\n+        handler.setFormatter(formatter);\n+\n+        handler.publish(log(\"Hello World\"));\n+        handler.publish(log(\"Some more logging...\"));\n+        handler.publish(log(\"And we're done!\"));\n+        handler.close();\n+\n+        \/\/ Post write callback should have happened once per publish call (with lock held).\n+        if (handler.callbackCount != 3) {\n+            throw new AssertionError(\"Unexpected callback count: \" + handler.callbackCount);\n+        }\n+\n+        String logged = out.toString(\"UTF-8\");\n+        if (!EXPECTED_LOG.equals(logged)) {\n+            throw new AssertionError(\"Unexpected log contents: \" + logged);\n+        }\n+    }\n+\n+    static LogRecord log(String msg) {\n+        return new LogRecord(Level.INFO, msg);\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/logging\/Handler\/StreamHandlerLockingTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util.logging;\n+\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+\/**\n+ * A trivial UTF-8 stream handler subclass class to capture whether the\n+ * (package protected) post-write callback method is synchronized.\n+ *\/\n+public class TestStreamHandler extends StreamHandler {\n+\n+    public int callbackCount = 0;\n+\n+    public TestStreamHandler(OutputStream out) {\n+        setOutputStream(out);\n+        try {\n+            setEncoding(\"UTF-8\");\n+        } catch (UnsupportedEncodingException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    void synchronousPostWriteHook() {\n+        if (!Thread.holdsLock(this)) {\n+            throw new AssertionError(\n+                    String.format(\"Post write callback [index=%d] was invoked without handler locked.\", callbackCount));\n+        }\n+        callbackCount++;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/logging\/Handler\/java.logging\/java\/util\/logging\/TestStreamHandler.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n- * @compile -XDignore.symbol.file LoggingDeadlock5.java\n","filename":"test\/jdk\/java\/util\/logging\/LoggingDeadlock5.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}