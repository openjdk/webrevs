{"files":[{"patch":"@@ -813,1 +813,6 @@\n-      const size_t protzone_size = os::vm_page_size();\n+      \/\/ Let the protection zone be a whole commit granule. Otherwise, buddy allocator may later place neighboring\n+      \/\/ chunks in the same granule, see that the granule is not yet committed, and commit it, which would replace\n+      \/\/ the protection mapping and make the zone readable.\n+      \/\/ Alternatively, we could commit the chunk right now, but that is a tiny bit more fiddly, since we are not\n+      \/\/ fully set up yet at this point.\n+      const size_t protzone_size = metaspace::Settings::commit_granule_bytes(); \/\/ granule size >= page size\n@@ -824,1 +829,1 @@\n-#endif\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -156,0 +156,2 @@\n+  static inline Klass* decode_not_null_without_asserts(narrowKlass v, address base, int shift);\n+\n@@ -234,1 +236,1 @@\n-  static inline Klass* decode_not_null_without_asserts(narrowKlass v, address base, int shift);\n+  static inline Klass* decode_not_null_without_asserts(narrowKlass v);\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+inline Klass* CompressedKlassPointers::decode_not_null_without_asserts(narrowKlass v) {\n+  return decode_not_null_without_asserts(v, base(), shift());\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -326,0 +326,11 @@\n+WB_ENTRY(void, WB_DecodeNKlassAndAccessKlass(JNIEnv* env, jobject o, jint nKlass))\n+  assert(UseCompressedClassPointers, \"Should only call for UseCompressedClassPointers\");\n+  const narrowKlass nk = (narrowKlass)nKlass;\n+  const Klass* const k = CompressedKlassPointers::decode_not_null_without_asserts(nKlass);\n+  printf(\"WB_DecodeNKlassAndAccessKlass: nk %u k \" PTR_FORMAT \"\\n\", nk, p2i(k));\n+  printf(\"Will attempt to crash now...\\n\");\n+  fflush(stdout); \/\/ flush now - we will crash below\n+  \/\/ Access k by calling a virtual function - will result in loading the vtable from *k\n+  k->print_on(tty);\n+WB_END\n+\n@@ -2733,0 +2744,1 @@\n+  {CC\"decodeNKlassAndAccessKlass\",CC\"(I)V\",            (void*)&WB_DecodeNKlassAndAccessKlass},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -111,30 +111,0 @@\n-\n-\/\/ This tests the protection zone mechanism. If the encoding base is not zero, VM should have\n-\/\/ established a protection zone. Decoding an nKlass==0 should result in a Klass* that, upon\n-\/\/ access, causes a SIGSEGV\n-static bool test_nklass_protection_zone() {\n-  if (!UseCompressedClassPointers) {\n-    tty->print_cr(\"UseCompressedClassPointers is off, test not possible\");\n-    return true; \/\/ skipped\n-  } else if (CompressedKlassPointers::base() == nullptr) {\n-    tty->print_cr(\"Zero-based encoding; test not needed\");\n-    return true; \/\/ skipped\n-  } else {\n-    constexpr narrowKlass nk = 0;\n-    Klass* const k = CompressedKlassPointers::decode_not_null_without_asserts(nk, CompressedKlassPointers::base(), CompressedKlassPointers::shift());\n-    assert(k == (Klass*) CompressedKlassPointers::base(), \"Sanity? (\" PTR_FORMAT \" vs \" PTR_FORMAT \")\",\n-           p2i(k), p2i(CompressedKlassPointers::base()));\n-    \/\/ Now call a virtual function on that klass.\n-    k->print_on(tty); \/\/ << loading vtable ptr from protected page, crash expected here\n-    return false;\n-  }\n-}\n-\n-\/\/ This does not work yet, since gtest death tests don't work with real signals. That needs to be fixed first (see JDK-8348028).\n-TEST_VM_FATAL_ERROR_MSG(CompressedKlass, DISABLED_test_nklass_protection_zone_death_test, \".*SIGSEGV.*\") {\n-  if (test_nklass_protection_zone()) {\n-    \/\/ Still alive but returned true, so we skipped the test.\n-    \/\/ Do a fake assert that matches the regex above to satisfy the death test\n-    guarantee(false, \"fake message ignore this - SIGSEGV\");\n-  }\n-}\n","filename":"test\/hotspot\/gtest\/oops\/test_compressedKlass.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat, Inc.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=no_coh_no_cds\n+ * @summary Test that dereferencing a Klass that is the result of a decode(0) crashes accessing the nKlass guard zone\n+ * @library \/test\/lib\n+ * @requires vm.bits == 64 & vm.debug == true\n+ * @requires vm.flagless\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver AccessZeroNKlassHitsProtectionZone no_coh_no_cds\n+ *\/\n+\n+\/*\n+ * @test id=no_coh_cds\n+ * @summary Test that dereferencing a Klass that is the result of a decode(0) crashes accessing the nKlass guard zone\n+ * @requires vm.bits == 64 & vm.debug == true & vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver AccessZeroNKlassHitsProtectionZone no_coh_cds\n+ *\/\n+\n+\/*\n+ * @test id=coh_no_cds\n+ * @summary Test that dereferencing a Klass that is the result of a decode(0) crashes accessing the nKlass guard zone\n+ * @requires vm.bits == 64 & vm.debug == true & vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver AccessZeroNKlassHitsProtectionZone coh_no_cds\n+ *\/\n+\n+\/*\n+ * @test id=coh_cds\n+ * @summary Test that dereferencing a Klass that is the result of a decode(0) crashes accessing the nKlass guard zone\n+ * @requires vm.bits == 64 & vm.debug == true & vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run driver AccessZeroNKlassHitsProtectionZone coh_cds\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+import jtreg.SkippedException;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.regex.Pattern;\n+\n+\/\/ Test that dereferencing a Klass that is the result of a narrowKlass=0 will give us immediate crashes\n+\/\/ that hit the protection zone at encoding base.\n+public class AccessZeroNKlassHitsProtectionZone {\n+\n+    private static OutputAnalyzer run_test(boolean COH, boolean CDS, String forceBaseString) throws IOException, SkippedException {\n+        ArrayList<String> args = new ArrayList<>();\n+        args.add(\"-Xbootclasspath\/a:.\");\n+        args.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        args.add(\"-XX:+WhiteBoxAPI\");\n+        args.add(\"-XX:CompressedClassSpaceSize=128m\");\n+        args.add(\"-Xmx128m\");\n+        args.add(\"-XX:-CreateCoredumpOnCrash\");\n+        args.add(\"-Xlog:metaspace*\");\n+        if (COH) {\n+            args.add(\"-XX:+UnlockExperimentalVMOptions\");\n+            args.add(\"-XX:+UseCompactObjectHeaders\");\n+        }\n+        if (CDS) {\n+            args.add(\"-Xshare:on\");\n+        } else {\n+            args.add(\"-Xshare:off\");\n+            args.add(\"-XX:CompressedClassSpaceBaseAddress=\" + forceBaseString);\n+        }\n+        args.add(AccessZeroNKlassHitsProtectionZone.class.getName());\n+        args.add(\"runwb\");\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(args.toArray(new String[0]));\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.reportDiagnosticSummary();\n+        return output;\n+    }\n+\n+    private static void run_test(boolean COH, boolean CDS) throws IOException, SkippedException {\n+        \/\/ Notes:\n+        \/\/ We want to enforce zero-based encoding, to test the protection page in that case. For zero-based encoding,\n+        \/\/ protection page is at address zero, no need to test that.\n+        \/\/ If CDS is on, we never use zero-based, forceBase is ignored.\n+        \/\/ If CDS is off, we use forceBase to (somewhat) reliably force the encoding base to beyond 32G,\n+        \/\/ in order to prevent zero-based encoding. Since that may fail, we try several times.\n+        OutputAnalyzer output = null;\n+        long forceBase = -1;\n+        if (CDS) {\n+            output = run_test(COH, CDS, \"\");\n+        } else {\n+            long g4 = 0x1_0000_0000L;\n+            long start = g4 * 8; \/\/ 32g\n+            long step = g4;\n+            long end = start + step * 16;\n+            for (forceBase = start; forceBase < end; forceBase += step) {\n+                String thisBaseString = String.format(\"0x%016X\", forceBase).toLowerCase();\n+                output = run_test(COH, CDS, thisBaseString);\n+                if (output.contains(\"CompressedClassSpaceBaseAddress=\" + thisBaseString + \" given, but reserving class space failed.\")) {\n+                    \/\/ try next one\n+                } else if (output.contains(\"Successfully forced class space address to \" + thisBaseString)) {\n+                    break;\n+                } else {\n+                    throw new RuntimeException(\"Unexpected\");\n+                }\n+            }\n+            if (forceBase >= end) {\n+\/\/ testtest                throw new SkippedException(\"Failed to force ccs to any of the given bases. Skipping test.\");\n+            }\n+        }\n+\n+        \/\/ Parse the encoding base from the output. In case of CDS, it depends on ASLR. Even in case of CDS=off, we want\n+        \/\/ to double-check it is the force address.\n+        String nKlassBaseString = output.firstMatch(\"Narrow klass base: 0x([0-9a-f]+)\", 1);\n+        if (nKlassBaseString == null) {\n+            throw new RuntimeException(\"did not find Narrow klass base in log output\");\n+        }\n+        long nKlassBase = Long.valueOf(nKlassBaseString, 16);\n+\n+        if (!CDS && nKlassBase != forceBase) {\n+            throw new RuntimeException(\"Weird - we should have mapped at force base\"); \/\/ .. otherwise we would have skipped out above\n+        }\n+        if (nKlassBase == 0) {\n+            throw new RuntimeException(\"We should not be running zero-based at this point.\");\n+        }\n+\n+        \/\/ Calculate the expected crash address pattern. The precise crash address is unknown, but should be located\n+        \/\/ in the lower part of the guard page following the encoding base. We just accept any address matching the\n+        \/\/ upper 52 digits (leaving 4K = 12 bits = 4 nibbles of wiggle room)\n+        String expectedCrashAddressString = nKlassBaseString.substring(0, nKlassBaseString.length() - 3);\n+\n+        \/\/ output from whitebox function: Klass* should point to encoding base\n+        output.shouldMatch(\"WB_DecodeNKlassAndAccessKlass: nk 0 k 0x\" + nKlassBaseString);\n+\n+        \/\/ Then, we should have crashed\n+        output.shouldNotHaveExitValue(0);\n+        output.shouldContain(\"# A fatal error has been detected\");\n+\n+        \/\/ The hs-err file should contain a reference to the nKlass protection zone, like this:\n+        \/\/ \"RDI=0x0000000800000000 points into nKlass protection zone\"\n+        File hsErrFile = HsErrFileUtils.openHsErrFileFromOutput(output);\n+\n+        ArrayList<Pattern> hsErrPatternList = new ArrayList<>();\n+        hsErrPatternList.add(Pattern.compile(\".*(SIGBUS|SIGSEGV|EXCEPTION_ACCESS_VIOLATION).*\"));\n+        hsErrPatternList.add(Pattern.compile(\".*(si_addr|ExceptionInformation).*\" + expectedCrashAddressString + \".*\"));\n+        hsErrPatternList.add(Pattern.compile(\".*\" + expectedCrashAddressString + \".*points into nKlass protection zone.*\"));\n+        Pattern[] hsErrPattern = hsErrPatternList.toArray(new Pattern[0]);\n+        HsErrFileUtils.checkHsErrFileContent(hsErrFile, hsErrPattern, true);\n+    }\n+\n+    enum Argument { runwb, no_coh_no_cds, no_coh_cds, coh_no_cds, coh_cds };\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Expecting one argument\");\n+        }\n+        Argument arg = Argument.valueOf(args[0]);\n+        System.out.println(arg);\n+        switch (arg) {\n+            case runwb -> WhiteBox.getWhiteBox().decodeNKlassAndAccessKlass(0);\n+            case no_coh_no_cds -> run_test(false, false);\n+            case no_coh_cds -> run_test(false, true);\n+            case coh_no_cds -> run_test(true, false);\n+            case coh_cds -> run_test(true, true);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/AccessZeroNKlassHitsProtectionZone.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -645,0 +645,2 @@\n+\n+  public native void decodeNKlassAndAccessKlass(int nKlass);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}